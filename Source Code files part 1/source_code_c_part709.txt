
// Function:   TSSendComplete
//
// Arguments:  pDeviceObject  -- device object that called protocol
//             pIrp           -- IRP used in the call
//             pContext       -- context used for the call
//
// Returns:    status of operation (STATUS_MORE_PROCESSING_REQUIRED)
//
// Descript:   Gets the result of the send, stuffs result into
//             receive buffer, completes the IRP from the dll, and
//             cleans up the Irp and associated data from the send
//
// ---------------------------------------------------------

#pragma warning(disable: UNREFERENCED_PARAM)

TDI_STATUS
TSSendComplete(PDEVICE_OBJECT pDeviceObject,
               PIRP           pLowerIrp,
               PVOID          pvContext)
{
   PSEND_CONTEXT     pSendContext   = (PSEND_CONTEXT)pvContext;
   NTSTATUS          lStatus        = pLowerIrp->IoStatus.Status;
   ULONG             ulBytesSent    = (ULONG)pLowerIrp->IoStatus.Information;
   PRECEIVE_BUFFER   pReceiveBuffer = TSGetReceiveBuffer(pSendContext->pUpperIrp);

   pReceiveBuffer->lStatus = lStatus;

   if (ulDebugLevel & ulDebugShowCommand)
   {
      if (NT_SUCCESS(lStatus))
      {
         DebugPrint2("%s: BytesSent = 0x%08x\n",
                      strFuncP1,
                      ulBytesSent);
      }
      else
      {
         DebugPrint2("%s:  Completed with status 0x%08x\n", 
                      strFuncP1,
                      lStatus);
      }
   }
   TSCompleteIrp(pSendContext->pUpperIrp);

   //
   // now cleanup
   //
   TSFreeUserBuffer(pSendContext->pLowerMdl);
   if (pSendContext->pTdiConnectInfo)
   {
      TSFreeMemory(pSendContext->pTdiConnectInfo);
   }
   TSFreeMemory(pSendContext);

   TSFreeIrp(pLowerIrp, NULL);
   return TDI_MORE_PROCESSING;
}

#pragma warning(default: UNREFERENCED_PARAM)



///////////////////////////////////////////////////////////////////////////////
// end of file send.cpp
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\tdisamp\tdisamp.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//    Copyright (c) 2001 Microsoft Corporation
//
//    Module Name:
//       tdisample.cpp
//
//    Abstract:
//       test executable--demonstrates the tdi client by calling it via the library
//
//////////////////////////////////////////////////////////////////////////

#include "libbase.h"

const ULONG MAX_ADDRESS_SIZE = sizeof(TRANSPORT_ADDRESS) + TDI_ADDRESS_LENGTH_OSI_TSAP;
const USHORT DGRAM_SERVER_PORT = 0x5555;
const USHORT DGRAM_CLIENT_PORT = 0x4444;
const USHORT CONN_SERVER_PORT  = 0x5656;
const USHORT CONN_CLIENT_PORT  = 0x4545;

VOID
ServerTest(ULONG ulType, 
           ULONG ulNumDevices);


VOID
ClientTest(ULONG ulType, 
           ULONG ulNumDevices);



/////////////////////////////////////////////////
//
// Function:   main
//
// Descript:   parse the arguments to the program, initialize library and driver,
//             then call client or server side of test
//
/////////////////////////////////////////////////


int __cdecl main(ULONG argc, TCHAR *argv[])
{
   //
   // first step:  get the arguments for this run
   //
   BOOLEAN  fIsServer = FALSE;
   ULONG    ulType    = TDI_ADDRESS_TYPE_UNSPEC;
   BOOLEAN  fArgsOk   = FALSE;
   TCHAR   *pArgStr;

   if(argc > 1)
   {
      for(ULONG ulArg = 1; ulArg < argc; ulArg++)
      {
         pArgStr = argv[ulArg];
         if ((*pArgStr == TEXT('/')) || (*pArgStr == TEXT('-')))
         {
            pArgStr++;
         }
         if (_tcsicmp(pArgStr, TEXT("server")) == 0)
         {
            if (fIsServer)
            {
               fArgsOk = FALSE;
               break;
            }
            fIsServer = TRUE;
         }
         else
         {
            fArgsOk = FALSE;
            if (ulType)
            {
               break;
            }
            if (_tcsicmp(pArgStr, TEXT("ipx")) == 0)
            {
               fArgsOk = TRUE;
               ulType = TDI_ADDRESS_TYPE_IPX;
            }
            else if (_tcsicmp(pArgStr, TEXT("ipv4")) == 0)
            {
               fArgsOk = TRUE;
               ulType = TDI_ADDRESS_TYPE_IP;
            }
            else if (_tcsicmp(pArgStr, TEXT("netbt")) == 0)
            {
               fArgsOk = TRUE;
               ulType = TDI_ADDRESS_TYPE_NETBIOS;
            }
            else
            {
               break;
            }
         }
      }
   }
   if (!fArgsOk)
   {
      _putts(TEXT("Usage: tdisample [/server] [/ipx | /ipv4 | /netbt] \n"));
      return 0;
   }

   //
   // ready to go.  Initialize the library, connect to the driver, etc
   //
   if (TdiLibInit())
   {
      //
      // change this to limit debug output for kernel mode driver
      // 0 = none, 1 = commands, 2 = handlers, 3 = both
      //
      DoDebugLevel(0x03);
      ULONG ulNumDevices = DoGetNumDevices(ulType);
      if (ulNumDevices)
      {
         if (fIsServer)
         {
            ServerTest(ulType, ulNumDevices);
         }
         else
         {
            ClientTest(ulType, ulNumDevices);
         }
      }
      TdiLibClose();
   }
   
   return 0;
}


//////////////////////////////////////////////////////////////////////////
// server-side test functions
//////////////////////////////////////////////////////////////////////////

ULONG_PTR
__cdecl
ServerThread(LPVOID pvDummy);


BOOLEAN  WaitForClient(
   ULONG                TdiHandle, 
   PTRANSPORT_ADDRESS   pRemoteAddr
   );

CRITICAL_SECTION  CriticalSection;
HANDLE            hEvent;
ULONG             ulServerCount;


/////////////////////////////////////////////////
// 
// Function:   IncServerCount
//
// Descript:   multi-thread safe incrementing of server count
//
/////////////////////////////////////////////////

VOID IncServerCount()
{
   EnterCriticalSection(&CriticalSection);
   ++ulServerCount;
   LeaveCriticalSection(&CriticalSection);
}


/////////////////////////////////////////////////
// 
// Function:   DecServerCount
//
// Descript:   multi-thread safe decrementing of server count
//             when last one done, sets event
//
/////////////////////////////////////////////////

VOID DecServerCount()
{
   BOOLEAN  fDone = FALSE;

   EnterCriticalSection(&CriticalSection);
   --ulServerCount;
   if (!ulServerCount)
   {
      fDone = TRUE;
   }
   LeaveCriticalSection(&CriticalSection);
   if (fDone)
   {
      SetEvent(hEvent);
   }
}

struct   THREAD_DATA
{
   ULONG    ulType;
   ULONG    ulSlot;
};
typedef THREAD_DATA  *PTHREAD_DATA;

// ----------------------------------------------
//
// Function:   ServerTest
//
// Arguments:  ulType -- protocol type to use
//             NumDevices -- number of devices of this protocol type
//
// Descript:   this function controls the server side of the test
//
// ----------------------------------------------


VOID
ServerTest(ULONG ulType, ULONG ulNumDevices)
{
   //
   // initialize globals
   //
   try
   {
      InitializeCriticalSection(&CriticalSection);
   }
   catch(...)
   {
      return;
   }


   hEvent = CreateEvent(NULL,
                        TRUE,    // manual reset
                        FALSE,   // starts reset
                        NULL);
   ulServerCount = 1;      // a single bogus reference, so event doesn't fire prematurely



   //
   // go thru our list of nodes, starting a thread for each one
   //
   for(ULONG ulCount = 0; ulCount < ulNumDevices; ulCount++)
   {
      ULONG ulThreadId;
      PTHREAD_DATA   pThreadData = (PTHREAD_DATA)LocalAllocateMemory(sizeof(THREAD_DATA));
      if (!pThreadData)
      {
         _putts(TEXT("ServerTest: unable to allocate memory for pThreadData\n"));
         break;
      }

      pThreadData->ulType = ulType;
      pThreadData->ulSlot = ulCount;

      //
      // reference for one starting now
      //
      IncServerCount();

      HANDLE   hThread = CreateThread((LPSECURITY_ATTRIBUTES)NULL,
                                       0,
                                       (LPTHREAD_START_ROUTINE)ServerThread,
                                       (LPVOID)pThreadData,
                                       0,
                                       &ulThreadId);

      if (!hThread)
      {
         _putts(TEXT("ServerTest:  failed starting server thread\n"));
         DecServerCount();
      }
      Sleep(100);
   }
   
   //
   // get rid of bogus reference
   //
   DecServerCount();

   //
   // wait until all the threads have completed
   //
   WaitForSingleObject(hEvent, INFINITE);

   //
   // cleanup
   //
   CloseHandle(hEvent);
   DeleteCriticalSection(&CriticalSection);
}


/////////////////////////////////////////////////
//
// Function:   ServerThread
//
// Arguments:  pvData -- actually pThreadData for this server
//
// Descript:   This is the thread that runs for each server instance
//
/////////////////////////////////////////////////

ULONG_PTR
__cdecl
ServerThread(LPVOID pvData)
{
   PTHREAD_DATA         pThreadData  = (PTHREAD_DATA)pvData;
   PTRANSPORT_ADDRESS   pTransAddr   = NULL;
   PTRANSPORT_ADDRESS   pRemoteAddr  = NULL;
   TCHAR                *pDeviceName = NULL;
   BOOLEAN              fSuccessful  = FALSE;

   while (TRUE)
   {
      //
      // stores local interface address (server)
      //
      pTransAddr = (PTRANSPORT_ADDRESS)LocalAllocateMemory(MAX_ADDRESS_SIZE);
      if (!pTransAddr)
      {
         _putts(TEXT("ServerThread:  unable to allocate memory for pTransAddr\n"));
         break;
      }
      pTransAddr->TAAddressCount = 1;

      //
      // stores remote interface address (client)
      //
      pRemoteAddr = (PTRANSPORT_ADDRESS)LocalAllocateMemory(MAX_ADDRESS_SIZE);
      if (!pRemoteAddr)
      {
         _putts(TEXT("ServerThread:  unable to allocate memory for pRemoteAddr\n"));
         break;
      }
      pRemoteAddr->TAAddressCount = 1;
         
      //
      // stores local interface name (server)
      //
      pDeviceName = (TCHAR *)LocalAllocateMemory(256 * sizeof(TCHAR));
      if (!pDeviceName)
      {
         _putts(TEXT("ServerThread:  unable to allocate memory for pDeviceName\n"));
         break;
      }

      //
      // get name of local device
      //
      if (DoGetDeviceName(pThreadData->ulType, pThreadData->ulSlot, pDeviceName) != STATUS_SUCCESS)
      {
         break;
      }

      TCHAR    *pDataDeviceName = NULL;
      TCHAR    *pConnDeviceName = NULL;

      //
      // for netbios, each "address" has its own name.  You open a device based mostly on the name
      //
      if (pThreadData->ulType == TDI_ADDRESS_TYPE_NETBIOS)
      {
         pDataDeviceName = pDeviceName;
         pConnDeviceName = pDeviceName;

         PTA_NETBIOS_ADDRESS  pTaAddr = (PTA_NETBIOS_ADDRESS)pTransAddr;
         
         pTaAddr->Address[0].AddressType   = TDI_ADDRESS_TYPE_NETBIOS;
         pTaAddr->Address[0].AddressLength = TDI_ADDRESS_LENGTH_NETBIOS;
         pTaAddr->Address[0].Address[0].NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
         memcpy(pTaAddr->Address[0].Address[0].NetbiosName, "SERVER", 7);  // NOTE:  ascii string
      }

      //
      // for others, there is one name for the datagram device and another for the "connected"
      // device.  You open an interface based largely on the address
      //
      else
      {
         if (DoGetAddress(pThreadData->ulType, pThreadData->ulSlot, pTransAddr) != STATUS_SUCCESS)
         {
            break;
         }
         
         switch (pThreadData->ulType)
         {
            case TDI_ADDRESS_TYPE_IPX:
            {
               PTA_IPX_ADDRESS pAddr = (PTA_IPX_ADDRESS)pTransAddr;
               pAddr->Address[0].Address[0].Socket = DGRAM_SERVER_PORT;

               pDataDeviceName = TEXT("\\device\\nwlnkipx");
               pConnDeviceName = TEXT("\\device\\nwlnkspx");
               break;
            }
            case TDI_ADDRESS_TYPE_IP:
            {
               PTA_IP_ADDRESS pAddr = (PTA_IP_ADDRESS)pTransAddr;
               pAddr->Address[0].Address[0].sin_port = DGRAM_SERVER_PORT;

               pDataDeviceName = TEXT("\\device\\udp");
               pConnDeviceName = TEXT("\\device\\tcp");
               break;
            }
         }
      }
      _tprintf(TEXT("ServerThread: DeviceName: %s\n"), pDeviceName);
      _putts(TEXT("Device Address:\n"));
      DoPrintAddress(pTransAddr);

      //
      // wait for a client to contact us
      //
      ULONG TdiHandle = DoOpenAddress(pDataDeviceName, pTransAddr);
      if (!TdiHandle)
      {
         _putts(TEXT("ServerThread:  failed to open address object\n"));
         break;
      }
      DoEnableEventHandler(TdiHandle, TDI_EVENT_ERROR);
      DoEnableEventHandler(TdiHandle, TDI_EVENT_RECEIVE_DATAGRAM);
      
      if (!WaitForClient(TdiHandle, pRemoteAddr))
      {
         _putts(TEXT("ServerThread:  Timed out waiting for client\n"));
         DoCloseAddress(TdiHandle);
         break;
      }
      _putts(TEXT("ServerThread:  Found by client.  Client address:\n"));
      DoPrintAddress(pTransAddr);

      //
      // echo datagram packets until we get one that is TEXT("Last Packet"), or until we time out
      //
      for (ULONG ulCount = 1; ulCount < 60000; ulCount++)
      {
         ULONG    ulNumBytes;
         PUCHAR   pucData;

         Sleep(10);
         ulNumBytes = DoReceiveDatagram(TdiHandle, NULL, pRemoteAddr, &pucData);
         if (ulNumBytes)
         {
            DoSendDatagram(TdiHandle, pRemoteAddr, pucData, ulNumBytes);

            TCHAR *pString = (TCHAR *)pucData;
            _tprintf(TEXT("ServerThread:  Packet Received: %s\n"), pString);
            if (_tcscmp(pString, TEXT("Last Packet")))
            {
               ulCount = 0;
            }
            LocalFreeMemory(pucData);
            if (ulCount)
            {
               _putts(TEXT("ServerThread:  Exitting datagram receive loop\n"));
               break;
            }
         }
      }
      Sleep(50);
      DoCloseAddress(TdiHandle);

      //
      // now, open an endpoint, and wait for a connection request
      //
      switch (pThreadData->ulType)
      {
         case TDI_ADDRESS_TYPE_IPX:
         {
            PTA_IPX_ADDRESS pAddr = (PTA_IPX_ADDRESS)pTransAddr;
            pAddr->Address[0].Address[0].Socket = CONN_SERVER_PORT;
            break;
         }
         case TDI_ADDRESS_TYPE_IP:
         {
            PTA_IP_ADDRESS pAddr = (PTA_IP_ADDRESS)pTransAddr;
            pAddr->Address[0].Address[0].sin_port = CONN_SERVER_PORT;
            break;
         }
      }
      TdiHandle = DoOpenEndpoint(pConnDeviceName, pTransAddr);
      if (!TdiHandle)
      {
         _putts(TEXT("ServerThread:  unable to open endpoint\n"));
         break;
      }
      
      DoEnableEventHandler(TdiHandle, TDI_EVENT_CONNECT);
      DoEnableEventHandler(TdiHandle, TDI_EVENT_DISCONNECT);
      DoEnableEventHandler(TdiHandle, TDI_EVENT_ERROR);
      DoEnableEventHandler(TdiHandle, TDI_EVENT_RECEIVE);

      fSuccessful = FALSE;
      for (ULONG ulCount = 0; ulCount < 100; ulCount++)
      {
         if (DoIsConnected(TdiHandle))
         {
            _putts(TEXT("ServerThread:  connect successful\n"));
            fSuccessful = TRUE;
            break;
         }
         Sleep(20);
      }
      if (!fSuccessful)
      {
         _putts(TEXT("ServerThread:  timed out waiting for connect\n"));
         DoCloseEndpoint(TdiHandle);
         break;
      }

      //
      // echo packets until we get one that is TEXT("Last Packet")
      //

      for (ULONG ulCount = 0; ulCount < 60000; ulCount++)
      {
         ULONG    ulNumBytes;
         PUCHAR   pucData;

         Sleep(10);
         ulNumBytes = DoReceive(TdiHandle, &pucData);
         if (ulNumBytes)
         {
            DoSend(TdiHandle, pucData, ulNumBytes, 0);

            TCHAR *pString = (TCHAR *)pucData;
            _tprintf(TEXT("ServerThread:  Packet received: %s\n"), pString);
            if (_tcscmp(pString, TEXT("Last Packet")))
            {
               ulCount = 0;
            }
            LocalFreeMemory(pucData);
            if (ulCount)
            {
               _putts(TEXT("ServerThread:  Exitting connected receive loop\n"));
               break;
            }
         }
      }
      for (ulCount = 0; ulCount < 1000; ulCount++)
      {
         if (!DoIsConnected(TdiHandle))
         {
            break;
         }
      }
      DoCloseEndpoint(TdiHandle);
      break;
   }

   //
   // cleanup
   //
   if (pTransAddr)
   {
      LocalFreeMemory(pTransAddr);
   }
   if (pRemoteAddr)
   {
      LocalFreeMemory(pTransAddr);
   }
   if (pDeviceName)
   {
      LocalFreeMemory(pDeviceName);
   }
   LocalFreeMemory(pvData);
   DecServerCount();
   _putts(TEXT("ServerThread:  exitting\n"));

   return 0;
}

/////////////////////////////////////////////////
//
// Function:   WaitForClient
//
// Arguments:  TdiHandle -- address object handle for calling driver
//             pRemoteAddr -- returns address received from
//
// Returns:    TRUE if hear from client before timeout
//
// Descript:   This function is used by the server side of the test to
//             wait for contact with the client side.
//
/////////////////////////////////////////////////

BOOLEAN  WaitForClient(ULONG              TdiHandle, 
                       PTRANSPORT_ADDRESS pRemoteAddr)
{
   while(TRUE)
   {
      //
      // wait for up to a 2 minutes for first packet (broadcast)
      // 
      BOOLEAN  fSuccessful = FALSE;
      for (ULONG ulCount = 0; ulCount < 6000; ulCount++)
      {
         ULONG    ulNumBytes;
         PUCHAR   pucData;

         Sleep(20);
         ulNumBytes = DoReceiveDatagram(TdiHandle, NULL, pRemoteAddr, &pucData);
         if (ulNumBytes)
         {
            if (ulNumBytes == 4)
            {
               PULONG   pulValue = (PULONG)pucData;
               if (*pulValue == 0x12345678)
               {
                  _putts(TEXT("WaitForClient:  first packet received\n"));
                  fSuccessful = TRUE;
               }
               else
               {
                  _putts(TEXT("WaitForClient:  unexpected packet received\n"));
               }
            }
            LocalFreeMemory(pucData);
            //
            // break out of wait loop if successful
            //
            if (fSuccessful)     
            {
               break;
            }
         }
      }

      //
      // check for timed out
      //
      if (!fSuccessful)
      {
         _putts(TEXT("WaitForClient: timed out waiting for first packet\n"));
         break;
      }


      //
      // send 1st response
      //
      ULONG    ulBuffer = 0x98765432;
      DoSendDatagram(TdiHandle, pRemoteAddr, (PUCHAR)&ulBuffer, sizeof(ULONG));

      //
      // wait for second response (directed)
      //
      fSuccessful = FALSE;
      for (ULONG ulCount = 0; ulCount < 1000; ulCount++)
      {
         ULONG    ulNumBytes;
         PUCHAR   pucData;

         Sleep(10);
         ulNumBytes = DoReceiveDatagram(TdiHandle, NULL, NULL, &pucData);
         if (ulNumBytes)
         {
            if (ulNumBytes == 4)
            {
               PULONG   pulValue = (PULONG)pucData;
               if (*pulValue == 0x22222222)
               {
                  _putts(TEXT("WaitForClient:  Second packet received\n"));
                  fSuccessful = TRUE;
               }
               else
               {
                  _putts(TEXT("WaitForClient:  unexpected packet received\n"));
               }
            }
            LocalFreeMemory(pucData);
            //
            // break out if recieved
            //
            if (fSuccessful)
            {
               break;
            }
         }
      }

      //
      // if received second packet, send second response
      //
      if (fSuccessful)
      {
         ulBuffer = 0x33333333;
         DoSendDatagram(TdiHandle, pRemoteAddr, (PUCHAR)&ulBuffer, sizeof(ULONG));
         return TRUE;
      }
      //
      // else reloop and wait again for broadcast
      //
      _putts(TEXT("WaitForClient:  timed out waiting for second packet\n"));
   }
   return FALSE;
      
}

//////////////////////////////////////////////////////////////////////////
// client-side test functions
//////////////////////////////////////////////////////////////////////////


BOOLEAN
FindServer(TCHAR              *pDataDeviceName, 
           PTRANSPORT_ADDRESS pTransAddr, 
           PTRANSPORT_ADDRESS pRemoteAddr);


/////////////////////////////////////////////////
//
// Function:   ClientTest
//
// Arguments:  ulType -- protocol type to use
//             NumDevices -- number of devices of this protocol type
//
// Descript:   this function controls the client side of the test
//
/////////////////////////////////////////////////

VOID
ClientTest(ULONG ulType, ULONG ulNumDevices)
{
   //
   // address of local interface
   //
   PTRANSPORT_ADDRESS   pTransAddr = (PTRANSPORT_ADDRESS)LocalAllocateMemory(MAX_ADDRESS_SIZE);
   if (!pTransAddr)
   {
      _putts(TEXT("ClientTest: unable to allocate memory for pTransAddr\n"));
      return;
   }
   pTransAddr->TAAddressCount = 1;

   //
   // address of remote interface
   //
   PTRANSPORT_ADDRESS   pRemoteAddr = (PTRANSPORT_ADDRESS)LocalAllocateMemory(MAX_ADDRESS_SIZE);
   if (!pRemoteAddr)
   {
      _putts(TEXT("ClientTest: unable to allocate memory for pRemoteAddr\n"));
      LocalFreeMemory(pTransAddr);
      return;
   }
   pRemoteAddr->TAAddressCount = 1;
         
   //
   // name of device (from driver)
   //
   TCHAR    *pDeviceName = (TCHAR *)LocalAllocateMemory(256 * sizeof(TCHAR));
   if (!pDeviceName)
   {
      _putts(TEXT("ClientTest: unable to allocate memory for pDeviceNameAddr\n"));
      LocalFreeMemory(pTransAddr);
      LocalFreeMemory(pRemoteAddr);
      return;
   }

   //
   // name of tdi datagram interface to open
   //
   TCHAR    *pDataDeviceName = NULL;
   //
   // name of tdi connection endpoint interface to open
   //
   TCHAR    *pConnDeviceName = NULL;
   //
   // Stores handle used by driver to access interface
   //
   ULONG    TdiHandle;

   //
   // for netbios, each "address" has its own name.  You open a device based on the name
   //
   if (ulType == TDI_ADDRESS_TYPE_NETBIOS)
   {
      PTA_NETBIOS_ADDRESS  pTaAddr = (PTA_NETBIOS_ADDRESS)pTransAddr;
         
      pTaAddr->Address[0].AddressType   = TDI_ADDRESS_TYPE_NETBIOS;
      pTaAddr->Address[0].AddressLength = TDI_ADDRESS_LENGTH_NETBIOS;
      pTaAddr->Address[0].Address[0].NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
      memcpy(pTaAddr->Address[0].Address[0].NetbiosName, "CLIENT", 7);  // NOTE:  ascii string
   }

   //
   // for others, there is one name for the datagram device and another for the "connected"
   // device.  You open an interface based on the address
   //
   else
   {
      switch (ulType)
      {
         case TDI_ADDRESS_TYPE_IPX:
            pDataDeviceName = TEXT("\\device\\nwlnkipx");
            pConnDeviceName = TEXT("\\device\\nwlnkspx");
            break;
         case TDI_ADDRESS_TYPE_IP:
            pDataDeviceName = TEXT("\\device\\udp");
            pConnDeviceName = TEXT("\\device\\tcp");
            break;
      }
      _putts(TEXT("ClientTest: get provider information\n"));
      TdiHandle = DoOpenControl(pDataDeviceName);

      if (TdiHandle)
      {
         PTDI_PROVIDER_INFO   pInfo = (PTDI_PROVIDER_INFO)DoTdiQuery(TdiHandle, TDI_QUERY_PROVIDER_INFO);
         if (pInfo)
         {
            DoPrintProviderInfo(pInfo);
            LocalFreeMemory(pInfo);
         }
         DoCloseControl(TdiHandle);
      }
   }

   //
   // loop thru the available devices, trying each one in turn..
   //
   for (ULONG ulCount = 0; ulCount < ulNumDevices; ulCount++)
   {
      //
      // collect necessary information
      //
      if (DoGetDeviceName(ulType, ulCount, pDeviceName) != STATUS_SUCCESS)
      {
         continue;
      }
      _tprintf(TEXT("ClientTest:  LocalDeviceName = %s\n"), pDeviceName);

      if (ulType == TDI_ADDRESS_TYPE_NETBIOS)
      {
         pDataDeviceName = pDeviceName;
         pConnDeviceName = pDeviceName;

         _putts(TEXT("ClientTest: get provider information\n"));
         TdiHandle = DoOpenControl(pDataDeviceName);
         if (TdiHandle)
         {
            PTDI_PROVIDER_INFO   pInfo = (PTDI_PROVIDER_INFO)DoTdiQuery(TdiHandle, TDI_QUERY_PROVIDER_INFO);
            if (pInfo)
            {
               DoPrintProviderInfo(pInfo);
               LocalFreeMemory(pInfo);
            }
            DoCloseControl(TdiHandle);
         }
      }
      else
      {
         if (DoGetAddress(ulType, ulCount, pTransAddr) != STATUS_SUCCESS)
         {
            continue;
         }
      }
      
      _putts(TEXT("ClientTest: Local device address:\n"));
      DoPrintAddress(pTransAddr);

      //
      // try to contact server
      //
      if (FindServer(pDataDeviceName, pTransAddr, pRemoteAddr))
      {
         _putts(TEXT("Remote interface found:\n"));
         DoPrintAddress(pRemoteAddr);
         //
         // do a datagram send/receive test
         //
         TdiHandle = DoOpenAddress(pDataDeviceName, pTransAddr);
         if (TdiHandle)                                         
         {
            _putts(TEXT("ClientTest: Sending first test packet\n"));

            TCHAR *strBuffer = TEXT("This is only a test");

            DoEnableEventHandler(TdiHandle, TDI_EVENT_ERROR);
            DoPostReceiveBuffer(TdiHandle, 128);
            DoSendDatagram(TdiHandle, pRemoteAddr, (PUCHAR)strBuffer, sizeof(TCHAR) * (1 + _tcslen(strBuffer)));
            Sleep(300);
            
            PUCHAR   pucData;
            ULONG    ulNumBytes = DoFetchReceiveBuffer(TdiHandle, &pucData);
            if (ulNumBytes)
            {
               strBuffer = (TCHAR *)pucData;
               _tprintf(TEXT("ClientTest:  Response received: %s\n"), strBuffer);
               LocalFreeMemory(pucData);
            }
            else
            {
               _putts(TEXT("ClientTest:  Response packet not received\n"));
            }

            _putts(TEXT("ClientTest:  Sending second test packet\n"));

            DoPostReceiveBuffer(TdiHandle, 128);
            strBuffer = TEXT("Last Packet");
            DoSendDatagram(TdiHandle, pRemoteAddr, (PUCHAR)strBuffer, sizeof(TCHAR) * (1 + _tcslen(strBuffer)));
            Sleep(300);
            ulNumBytes = DoFetchReceiveBuffer(TdiHandle, &pucData);
            if (ulNumBytes)
            {
               strBuffer = (TCHAR *)pucData;
               _tprintf(TEXT("ClientTest:  Response received: %s\n"), strBuffer);
               LocalFreeMemory(pucData);
            }
            else
            {
               _putts(TEXT("ClientTest:  Response packet not received\n"));
            }
            Sleep(50);
            DoCloseAddress(TdiHandle);
         }
         else
         {
            _putts(TEXT("ClientTest:  unable to open address object\n"));
         }

         //
         // adjust addresses...
         //
         switch (ulType)
         {
            case TDI_ADDRESS_TYPE_IPX:
            {
               PTA_IPX_ADDRESS pAddr = (PTA_IPX_ADDRESS)pRemoteAddr;
               pAddr->Address[0].Address[0].Socket = CONN_SERVER_PORT;
               
               pAddr = (PTA_IPX_ADDRESS)pTransAddr;
               pAddr->Address[0].Address[0].Socket = CONN_CLIENT_PORT;
               break;
            }
            case TDI_ADDRESS_TYPE_IP:
            {
               PTA_IP_ADDRESS pAddr = (PTA_IP_ADDRESS)pRemoteAddr;
               pAddr->Address[0].Address[0].sin_port = CONN_SERVER_PORT;
               
               pAddr = (PTA_IP_ADDRESS)pTransAddr;
               pAddr->Address[0].Address[0].sin_port = CONN_CLIENT_PORT;
               break;
            }
         }

         //
         // establish a connection
         //
         _putts(TEXT("ClientTest:  Attempt to establish a connection\n"));
         TdiHandle = DoOpenEndpoint(pConnDeviceName, pTransAddr);
         if (TdiHandle)
         {
            DoEnableEventHandler(TdiHandle, TDI_EVENT_CONNECT);
            DoEnableEventHandler(TdiHandle, TDI_EVENT_DISCONNECT);
            DoEnableEventHandler(TdiHandle, TDI_EVENT_ERROR);
            DoEnableEventHandler(TdiHandle, TDI_EVENT_RECEIVE);

            if (DoConnect(TdiHandle, pRemoteAddr, 20) == STATUS_SUCCESS)
            {
               _putts(TEXT("ClientTest:  Sending first packet over connection\n"));

               //
               // do a connected send/receive test
               //
               TCHAR *strBuffer = TEXT("This is only a test");

               DoSend(TdiHandle, (PUCHAR)strBuffer, sizeof(TCHAR) * (1 + _tcslen(strBuffer)), 0);

               //
               // wait for response
               //
               for (ULONG ulWait = 0; ulWait < 100; ulWait++)
               {
                  Sleep(10);
                  PUCHAR   pucData;
                  ULONG    ulNumBytes = DoReceive(TdiHandle, &pucData);
                  if (ulNumBytes)
                  {
                     _tprintf(TEXT("ClientTest:  Response received: %s\n"), (TCHAR *)pucData);
                     LocalFreeMemory(pucData);
                     break;
                  }
               }
               _putts(TEXT("ClientTest:  Sending second packet over connection\n"));

               strBuffer = TEXT("Last Packet");

               DoSend(TdiHandle, (PUCHAR)strBuffer, sizeof(TCHAR) * (1 + _tcslen(strBuffer)), 0);

               //
               // wait for response
               //
               for (ULONG ulWait = 0; ulWait < 100; ulWait++)
               {
                  Sleep(10);
                  PUCHAR   pucData;
                  ULONG    ulNumBytes = DoReceive(TdiHandle, &pucData);
                  if (ulNumBytes)
                  {
                     _tprintf(TEXT("ClientTest:  Response received: %s\n"), (TCHAR *)pucData);
                     LocalFreeMemory(pucData);
                     break;
                  }
               }

               //
               // shut down the connection
               //
               _putts(TEXT("ClientTest:  closing connection\n"));

               DoDisconnect(TdiHandle, TDI_DISCONNECT_RELEASE);
            }
            else
            {
               _putts(TEXT("ClientTest:  failed to establish connection\n"));
            }
            DoCloseEndpoint(TdiHandle);
         }
         else
         {
            _putts(TEXT("ClientTest:  failed to open endpoint\n"));
         }

      }
      else
      {
         _putts(TEXT("Unable to find remote server"));
      }

      if (ulType == TDI_ADDRESS_TYPE_NETBIOS)
      {
         _putts(TEXT("ClientTest: get provider status\n"));
         TdiHandle = DoOpenControl(pDataDeviceName);
         if (TdiHandle)
         {
            PADAPTER_STATUS   pStatus = (PADAPTER_STATUS)DoTdiQuery(TdiHandle, TDI_QUERY_ADAPTER_STATUS);
            if (pStatus)
            {
               DoPrintAdapterStatus(pStatus);
               LocalFreeMemory(pStatus);
            }

            DoCloseControl(TdiHandle);
         }
      }
   }

   if (ulType != TDI_ADDRESS_TYPE_NETBIOS)
   {
      _putts(TEXT("ClientTest: get provider statistics\n"));

      TdiHandle = DoOpenControl(pDataDeviceName);
      if (TdiHandle)
      {

         PTDI_PROVIDER_STATISTICS   pStats 
                                    = (PTDI_PROVIDER_STATISTICS)DoTdiQuery(TdiHandle, 
                                                                           TDI_QUERY_PROVIDER_STATISTICS);
         if (pStats)
         {
            DoPrintProviderStats(pStats);
            LocalFreeMemory(pStats);
         }
         DoCloseControl(TdiHandle);
      }
   }
   LocalFreeMemory(pDeviceName);
   LocalFreeMemory(pTransAddr);
}


/////////////////////////////////////////////////
//
// Function:   FindServer
//
// Arguments:  pDataDeviceName -- name of data device to open
//             pTransAddr      -- address of data device to open
//             pRemoteAddr     -- on return, address of remote device
//
// Returns:    TRUE if able to establish communication with server,
//             FALSE if it times out
//
// Descript:   This function is called by the client to find a server
//             to participate with it in the tests.
//
/////////////////////////////////////////////////

BOOLEAN
FindServer(TCHAR              *pDataDeviceName, 
           PTRANSPORT_ADDRESS pTransAddr, 
           PTRANSPORT_ADDRESS pRemoteAddr)
{
   //
   // set up remote and local address for broadcast/multicast search for server
   //
   pRemoteAddr->Address[0].AddressLength = pTransAddr->Address[0].AddressLength;
   pRemoteAddr->Address[0].AddressType   = pTransAddr->Address[0].AddressType;

   switch (pTransAddr->Address[0].AddressType)
   {
      case TDI_ADDRESS_TYPE_IP:
      {
         PTDI_ADDRESS_IP   pTdiAddressIp
                           = (PTDI_ADDRESS_IP)pTransAddr->Address[0].Address;
         ULONG             ulAddr = pTdiAddressIp->in_addr;

         pTdiAddressIp->sin_port = DGRAM_CLIENT_PORT;

         
         pTdiAddressIp = (PTDI_ADDRESS_IP)pRemoteAddr->Address[0].Address;
         pTdiAddressIp->in_addr = 0xFFFF0000 | ulAddr;
         pTdiAddressIp->sin_port = DGRAM_SERVER_PORT;
      }
      break;

      case TDI_ADDRESS_TYPE_IPX:
      {
         PTDI_ADDRESS_IPX  pTdiAddressIpx
                           = (PTDI_ADDRESS_IPX)pTransAddr->Address[0].Address;
         ULONG TempNetwork = pTdiAddressIpx->NetworkAddress;
         pTdiAddressIpx->Socket = DGRAM_CLIENT_PORT;

         pTdiAddressIpx = (PTDI_ADDRESS_IPX)pRemoteAddr->Address[0].Address;
         pTdiAddressIpx->NetworkAddress = TempNetwork;
         pTdiAddressIpx->Socket = DGRAM_SERVER_PORT;
         memset(pTdiAddressIpx->NodeAddress, 0xFF, 6);
      }
      break;

      case TDI_ADDRESS_TYPE_NETBIOS:
      {
         PTDI_ADDRESS_NETBIOS pTdiAddressNetbios
                              = (PTDI_ADDRESS_NETBIOS)pRemoteAddr->Address[0].Address;

         pTdiAddressNetbios->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
         memcpy(pTdiAddressNetbios->NetbiosName, "SERVER", 7 );     // NOTE:  ascii string
      }
      break;


      default:
         _putts(TEXT("FindServer:  invalid address type\n"));
         return FALSE;
   }
   
   //
   // try to find server program to test against
   //
   BOOLEAN  fSuccessful = FALSE;
   ULONG    TdiHandle;

   _putts(TEXT("FindServer:  try to find remote test server\n"));

   while (TRUE)
   {
      TdiHandle = DoOpenAddress(pDataDeviceName, pTransAddr);
      if (!TdiHandle)
      {
         _putts(TEXT("FindServer:  unable to open address object\n"));
         break;
      }
      DoEnableEventHandler(TdiHandle, TDI_EVENT_ERROR);
      DoEnableEventHandler(TdiHandle, TDI_EVENT_RECEIVE_DATAGRAM);

      //
      // send broadcast query
      //
      _putts(TEXT("FindServer:  send first packet (broadcast)\n"));

      ULONG    ulBuffer = 0x12345678;
      DoSendDatagram(TdiHandle, pRemoteAddr, (PUCHAR)&ulBuffer, sizeof(ULONG));

      //
      // wait for first response
      //
      for (ULONG ulCount = 0; ulCount < 100; ulCount++)
      {
         Sleep(10);
         PUCHAR   pucData;
         ULONG    ulNumBytes = DoReceiveDatagram(TdiHandle, NULL, pRemoteAddr, &pucData);
         if (ulNumBytes)
         {
            if (ulNumBytes == 4)
            {
               PULONG   pulValue = (PULONG)pucData;
               if (*pulValue == 0x98765432)
               {
                  _putts(TEXT("FindServer: first response received\n"));
                  fSuccessful = TRUE;
               }
            }
            LocalFreeMemory(pucData);
            //
            // break out of loop if received response
            //
            if (fSuccessful)
            {
               break;
            }
         }
      }

      //
      // timed out -- no response
      //
      if (!fSuccessful)
      {
         _putts(TEXT("FindServer:  did not receive first response\n"));
         break;
      }

      //
      // send second message
      //
      fSuccessful = FALSE;
      ulBuffer = 0x22222222;
      _putts(TEXT("FindServer: send second packet (directed)\n"));

      DoSendDatagram(TdiHandle, pRemoteAddr, (PUCHAR)&ulBuffer, sizeof(ULONG));

      //
      // wait for second response
      //
      for (ULONG ulCount = 0; ulCount < 50; ulCount++)
      {
         Sleep(10);
         PUCHAR   pucData;
         ULONG    ulNumBytes = DoReceiveDatagram(TdiHandle, NULL, NULL, &pucData);
         if (ulNumBytes)
         {
            if (ulNumBytes == 4)
            {
               PULONG   pulValue = (PULONG)pucData;
               if (*pulValue == 0x33333333)
               {
                  _putts(TEXT("FindServer: second response received\n"));
                  fSuccessful = TRUE;
               }
            }
            LocalFreeMemory(pucData);
            //
            // break out if got response
            //
            if (fSuccessful)
            {
               break;
            }
         }
      }
      break;
   }

   if (!fSuccessful)
   {
      _putts(TEXT("FindServer:  second response not received\n"));

   }
   if (TdiHandle)
   {
      DoCloseAddress(TdiHandle);
   }
   return fSuccessful;
}

///////////////////////////////////////////////////////////////////////////////
// end of file tdisample.cpp
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sys\tdikd\tdikd.c ===
#ifndef DBG
#define DBG 1
#endif
#define SRVDBG 1
#define SRVKD 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <windef.h>
#include <winbase.h>
#include <ntosp.h>
#include <wdbgexts.h>

#include <stdlib.h>

#define NT
#include <tdikrnl.h>
#include <cxport.h>
#include <ndis.h>
#include <netpnp.h>
#include <tdipnp.h>
#include <tdidebug.h>

WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };

#define    ERRPRT     dprintf

#define    NL      1
#define    NONL    0

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;            // is debuggee a CHK build?

#define PROV_SIZE       sizeof(TDI_PROVIDER_RESOURCE) + 32

CHAR                    provBuf[PROV_SIZE];
TDI_PROVIDER_RESOURCE   *pProvider = (TDI_PROVIDER_RESOURCE *) provBuf;

typedef struct _TDI_EXEC_PARAMS {
    LIST_ENTRY  Linkage;
    UINT        Signature;
    PLIST_ENTRY ClientList;
    PLIST_ENTRY ProviderList;
    PLIST_ENTRY RequestList;
    TDI_SERIALIZED_REQUEST Request;
    PETHREAD    *CurrentThread;
    CTEEvent    *RequestCTEEvent;
    PBOOLEAN    SerializeFlag;
    BOOLEAN     ResetSerializeFlag;

} TDI_EXEC_PARAMS, *PTDI_EXEC_PARAMS;

typedef struct
{
    char    Name[16];
    int     Val;
} DBG_LEVEL;

#if 0
DBG_LEVEL DbgLevel[] = {
    {"RXFRAME",  DBG_RXFRAME     },
    {"TXFRAME",  DBG_TXFRAME     },
    {"NDIS",  DBG_NDIS        },
    {"IRMAC",  DBG_IRMAC       },
    {"IRLAP",  DBG_IRLAP       },
    {"IRLAPLOG",  DBG_IRLAPLOG    },
    {"IRLMP",  DBG_IRLMP       },
    {"IRLMP_CONN",  DBG_IRLMP_CONN  },
    {"IRLMP_CRED",  DBG_IRLMP_CRED  },
    {"IRLMP_IAS",  DBG_IRLMP_IAS   },
    {"DISCOVERY",  DBG_DISCOVERY   },
    {"TDI",  DBG_TDI         },
    {"TDI_IRP",  DBG_TDI_IRP     },
    {"ALLOC",  DBG_ALLOC       },
    {"TIMER ",  DBG_TIMER       },
    {"PRINT",  DBG_PRINT       },
    {"ADDRESS",  DBG_ADDR        },
    {"REFERENCE",  DBG_REF         },        
    {"FUNCTION",  DBG_FUNCTION    },
    {"WARN",  DBG_WARN        },
    {"ERROR",  DBG_ERROR       }};

char *IrlmpState[] =
    {"LINK_DISCONNECTED",
     "LINK_DISCONNECTING",
     "LINK_IN_DISCOVERY",
     "LINK_CONNECTING",
     "LINK_READY"};
     
char *LsapState[] =
    {"LSAP_DISCONNECTED",          
     "LSAP_IRLAP_CONN_PEND", 
     "LSAP_LMCONN_CONF_PEND",
     "LSAP_CONN_RESP_PEND",  
     "LSAP_CONN_REQ_PEND",   
     "LSAP_EXCLUSIVEMODE_PEND",  
     "LSAP_MULTIPLEXEDMODE_PEND",
     "LSAP_READY",               
     "LSAP_NO_TX_CREDIT"};

char *ConnObjState[] =     
    {"IRDA_CONN_CREATED",
     "IRDA_CONN_CLOSING",
     "IRDA_CONN_OPENING", 
     "IRDA_CONN_OPEN"};
     
#endif 

void
TDIDumpDevice(
              TDI_PROVIDER_RESOURCE *prov
              );

void
TDIDumpAddress(
              TDI_PROVIDER_RESOURCE *prov
              );
void
TDIDumpProvider(
                TDI_PROVIDER_RESOURCE *prov
                );

/*
 * Print out an optional message, an ANSI_STRING, and maybe a new-line
 */
BOOL
PrintStringA( IN LPSTR msg OPTIONAL, IN PANSI_STRING pStr, IN BOOL nl )
{
    PCHAR    StringData;
    ULONG    BytesRead;

    if( msg )
        dprintf( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    StringData = (PCHAR)LocalAlloc( LPTR, pStr->Length + 1 );

    if( StringData == NULL ) {
        ERRPRT( "Out of memory!\n" );
        return FALSE;
    }

    ReadMemory((ULONG) pStr->Buffer,
               StringData,
               pStr->Length,
               &BytesRead );

    if ( BytesRead ) {
        StringData[ pStr->Length ] = '\0';
        dprintf("%s%s", StringData, nl ? "\n" : "" );
    }

    LocalFree((HLOCAL)StringData);

    return BytesRead;
}

/*
 * Get 'size' bytes from the debuggee program at 'dwAddress' and place it
 * in our address space at 'ptr'.  Use 'type' in an error printout if necessary
 */
BOOL
GetData( IN LPVOID ptr, IN DWORD dwAddress, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count = size;

    while( size > 0 ) {

    if (count >= 3000)
        count = 3000;

        b = ReadMemory((ULONG) dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count ) {
            ERRPRT( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
            return FALSE;
        }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG)ptr + count);
    }

    return TRUE;
}

/*
 * Follow a LIST_ENTRY list beginning with a head at dwListHeadAddr in the debugee's
 * address space.  For each element in the list, print out the pointer value at 'offset'
 */
BOOL
PrintListEntryList( IN DWORD dwListHeadAddr, IN LONG offset )
{
    LIST_ENTRY    ListEntry;
    ULONG i=0;
    BOOL retval = TRUE;
    ULONG count = 20;

    if( !GetData( &ListEntry, dwListHeadAddr, sizeof( ListEntry ), "LIST_ENTRY" ) )
        return FALSE;

    while( count-- ) {

        if( (DWORD)ListEntry.Flink == dwListHeadAddr || (DWORD)ListEntry.Flink == 0 )
            break;

        if( !GetData( &ListEntry, (DWORD)ListEntry.Flink, sizeof( ListEntry ), "ListEntry" ) ) {
            retval = FALSE;
            break;
        }

        dprintf( "%16X%s", (LONG)ListEntry.Flink + offset, (i && !(i&3)) ? "\n" : "" );
        i++;
    }


    if( count == 0 && (DWORD)ListEntry.Flink != dwListHeadAddr && ListEntry.Flink ) {
        dprintf( "\nTruncated list dump\n" );

    } else if( ! ( i && !(i&3) ) ) {
        dprintf( "\n" );
    }

    return retval;
}



/*
 * Print out a single HEX character
 */
VOID
PrintHexChar( IN UCHAR c )
{
    dprintf( "%c%c", "0123456789abcdef"[ (c>>4)&0xf ], "0123456789abcdef"[ c&0xf ] );
}

/*
 * Print out 'buf' of 'cbuf' bytes as HEX characters
 */
VOID
PrintHexBuf( IN PUCHAR buf, IN ULONG cbuf )
{
    while( cbuf-- ) {
        PrintHexChar( *buf++ );
        dprintf( " " );
    }
}


/*
 * Fetch the null terminated UNICODE string at dwAddress into buf
 */
BOOL
GetString( IN DWORD dwAddress, IN LPSTR buf, IN ULONG MaxChars )
{
    do {
        if( !GetData( buf, dwAddress, sizeof( *buf ), "Character" ) )
            return FALSE;

        dwAddress += sizeof( *buf );

    } while( --MaxChars && *buf++ != '\0' );

    return TRUE;
}

char *mystrtok ( char *string, char * control )
{
    static unsigned char *str;
    char *p, *s;

    if( string )
        str = string;

    if( str == NULL || *str == '\0' )
        return NULL;

    //
    // Skip leading delimiters...
    //
    for( ; *str; str++ ) {
        for( s=control; *s; s++ ) {
            if( *str == *s )
                break;
        }
        if( *s == '\0' )
            break;
    }

    //
    // Was it was all delimiters?
    //
    if( *str == '\0' ) {
        str = NULL;
        return NULL;
    }

    //
    // We've got a string, terminate it at first delimeter
    //
    for( p = str+1; *p; p++ ) {
        for( s = control; *s; s++ ) {
            if( *p == *s ) {
                s = str;
                *p = '\0';
                str = p+1;
                return s;
            }
        }
    }

    //
    // We've got a string that ends with the NULL
    //
    s = str;
    str = NULL;
    return s;
}

DECLARE_API( help )
{
    int i;

    dprintf("TDI extenstions:\n");

    dprintf("   All                dumps All Lists\n");
    dprintf("   Providers          dumps Providers List\n");
    dprintf("   Clients            dumps Clients List\n");
    dprintf("   Request            dumps Request List\n");
    dprintf("   Address            dumps Provider Addresses\n");
    dprintf("   Devices            dumps Provider Device Objects\n");
    dprintf("   ProviderReady      dumps Provider Device Objects\n");
    dprintf("   item               formats a TDI_REQUEST structure\n");
}

#if 0
DECLARE_API( dbgmsgs )
{
    DWORD   p;
    DWORD   Last, First;
    char    DbgMsg[MAX_MSG_LEN];
    ULONG   Read;
    char    *DbgMsgs;
    
    if (!GetData(&Last,
                 GetExpression("irda!Last"),
                 sizeof(Last), "DWORD"))
    {
        dprintf("error\n");
        return;
    }                 


    if (!GetData(&First,
                 GetExpression("irda!First"),
                 sizeof(Last), "DWORD"))
    {
        dprintf("error\n");
        return;
    }                 

                 

    DbgMsgs = (char *) GetExpression("irda!dbgmsgs");

    dprintf("\n\n");
    
    while (First != Last)
    {
       if (!GetString((ULONG) (DbgMsgs + First * MAX_MSG_LEN),
                  DbgMsg, MAX_MSG_LEN))
            break;
        /*
        ReadMemory((ULONG) (DbgMsgs + First * MAX_MSG_LEN), 
                    DbgMsg, MAX_MSG_LEN, &Read); */
        dprintf("%s", DbgMsg);
        First++;
        if (First == LOG_MSG_CNT)
            First = 0;
    }
}

DECLARE_API( dbg )
{
    int i;
    int col = 0;
    DWORD DbgSettings;
    char argbuf[ MAX_PATH ];
    char *p;
    DWORD   dwAddress;
    DWORD   Written;
    
    dwAddress = GetExpression("irda!dbgsettings");
    
    if (!GetData(&DbgSettings,
                 dwAddress,
                 sizeof(DbgSettings), "DWORD"))
    {
        dprintf("error\n");
        return;
    }
        
    if (!args || !*args)
    {    
    
        dprintf("Current settings:\n");
    
        for (i = 0; i < sizeof(DbgLevel)/sizeof(DBG_LEVEL); i++)
        {
            if (DbgSettings & DbgLevel[i].Val)
            {
                dprintf("  %s", DbgLevel[i].Name);
                if (col == 4)
                {
                    col = 0;
                    dprintf("\n");
                }
                else
                {
                    col ++;
                }
            }
        }
        if (col != 0)
            dprintf("\n");
        
        col = 0;    
    
        dprintf("Available settings:\n");
        for (i = 0; i < sizeof(DbgLevel)/sizeof(DBG_LEVEL); i++)
        {
            if (!(DbgSettings & DbgLevel[i].Val))
            {
                dprintf("  %s", DbgLevel[i].Name);
        
                if (col == 4)
                {
                    col = 0;
                    dprintf("\n");
                }
                else
                {
                    col++;
                }
            }    
        }
    
        if (col != 0)
            dprintf("\n");    
            
        return;
    }        
    
    strcpy( argbuf, args );
    
    for (p = mystrtok( argbuf, " \t,;" ); 
         p && *p; 
         p = mystrtok(NULL, " \t,;")) 
    {
        for (i = 0; i < sizeof(DbgLevel)/sizeof(DBG_LEVEL); i++)
        {
            if (strcmp(p, DbgLevel[i].Name) == 0)
            {
                if (DbgSettings & DbgLevel[i].Val)
                {
                    DbgSettings &= ~DbgLevel[i].Val;
                }
                else
                {
                    DbgSettings |= DbgLevel[i].Val;                
                }
            }
        }       
    }
    
    WriteMemory(dwAddress, &DbgSettings, sizeof(DWORD), &Written);
}


VOID
DumpIrpList(LIST_ENTRY *pIrpList)
{
    LIST_ENTRY          IrpList, *pListEntry, ListEntry;
    IRP                 *pIrp;

    if (!GetData(&IrpList,
                 (DWORD) pIrpList,
                 sizeof(LIST_ENTRY), "LIST_ENTRY"))
    {
        return;
    }
    
    for (pListEntry = IrpList.Flink;
         pListEntry != pIrpList;
         pListEntry = ListEntry.Flink)
    {
    
        if (!GetData(&ListEntry,
                 (DWORD) pListEntry,
                 sizeof(LIST_ENTRY), "LIST_ENTRY"))
        {
            return;
        }
        
        pIrp = CONTAINING_RECORD(pListEntry, IRP, Tail.Overlay.ListEntry);
        
        dprintf("  %x\n", pIrp);
    }     
}
#endif 

#define PROV_TYPE       1
#define CLIENT_TYPE     2
#define NEITHER         3

DECLARE_API( request )
{
    LIST_ENTRY              List, *pList, *start;
    TDI_EXEC_PARAMS         TdiExec;
    TDI_SERIALIZED_REQUEST  Request;
    BOOLEAN                 ElementTypeProvider = NEITHER;
    TDI_NOTIFY_PNP_ELEMENT  Client;
    INT                     i = 1;
    
    pList = (PLIST_ENTRY) GetExpression("tdi!PnpHandlerRequestList");

    if (!GetData(&List,
                 (DWORD) pList,
                 sizeof(LIST_ENTRY), "REQUEST_LIST"))
    {
        return;
    }
    
    if (List.Flink == List.Blink)
    {
        dprintf("No Requests\n");
        return;
    }  
    
    start = pList;
    pList = List.Flink;

    while (pList != start)
    {
        if (!GetData(&List,
                 (DWORD) pList,
                 sizeof(LIST_ENTRY), "REQUEST_LIST"))
        {
            return;
        }
        
        if (!GetData(&TdiExec,
                 (DWORD) pList,
                 sizeof(TDI_EXEC_PARAMS), "EXEC PARAMS"))
        {
            return;
        }
        
                
        if(0x1234cdef != TdiExec.Signature) {
            dprintf("signature is BAD - %d not 0x1234cdef\r\n", TdiExec.Signature);
            return;
        }

        if (!GetData(&Request,
                     (DWORD) &TdiExec.Request,
                     sizeof (TDI_SERIALIZED_REQUEST), "REQUEST")) {
            return;
        }


        dprintf("%d. Request(%X) Element @ %x\t Type: ", i++, Request.Element);
        
        switch (Request.Type) {
        
        case TDI_REGISTER_HANDLERS_PNP:
            
            dprintf("TDI_REGISTER_HANDLERS_PNP\n");
            ElementTypeProvider = CLIENT_TYPE;
            break;

        case TDI_DEREGISTER_HANDLERS_PNP:
            dprintf("TDI_DEREGISTER_HANDLERS_PNP\n");
            ElementTypeProvider = CLIENT_TYPE;
            
            break;
        
        case TDI_REGISTER_PNP_POWER_EVENT:
            dprintf("TDI_REGISTER_PNP_POWER_EVENT\n");
            ElementTypeProvider = PROV_TYPE;
            break;

        case TDI_REGISTER_ADDRESS_PNP:
            dprintf("TDI_REGISTER_ADDRESS_PNP\n");
            ElementTypeProvider = PROV_TYPE;
            break;

        case TDI_DEREGISTER_ADDRESS_PNP:
            dprintf("TDI_DEREGISTER_ADDRESS_PNP\n");
            ElementTypeProvider = PROV_TYPE;
            break;

        case TDI_REGISTER_DEVICE_PNP:
            
            dprintf("TDI_REGISTER_DEVICE_PNP\n");
            ElementTypeProvider = PROV_TYPE;
            break;

        case TDI_DEREGISTER_DEVICE_PNP:
            dprintf("TDI_DEREGISTER_DEVICE_PNP\n");
            ElementTypeProvider = PROV_TYPE;
            break;

        case TDI_NDIS_IOCTL_HANDLER_PNP:
            dprintf("TDI_NDIS_IOCTL_HANDLER_PNP\n");
            ElementTypeProvider = PROV_TYPE;
            break;

        case TDI_ENUMERATE_ADDRESSES:
            dprintf("TDI_ENUMERATE_ADDRESSES\n");
            ElementTypeProvider = CLIENT_TYPE;
            break;

        case TDI_REGISTER_PROVIDER_PNP:

            dprintf("TDI_REGISTER_PROVIDER_PNP\n");
            ElementTypeProvider = PROV_TYPE;
            break;

        case TDI_DEREGISTER_PROVIDER_PNP:
            dprintf("TDI_DEREGISTER_PROVIDER_PNP\n");
            ElementTypeProvider = PROV_TYPE;
            break;

        case TDI_PROVIDER_READY_PNP:
            
            dprintf("TDI_PROVIDER_READY_PNP\n");
            ElementTypeProvider = PROV_TYPE;
            break;

        default:

            dprintf("TDI - UNKNOWN REQUEST TYPE!!!\n");
            ElementTypeProvider = NEITHER;
            break;
        
        }

        if (PROV_TYPE == ElementTypeProvider) {

            if (!GetData(pProvider,
                         (DWORD) Request.Element,
                         PROV_SIZE, "PROVIDER_RESOURCE")) {
                return;
            }
            
            if(TDI_RESOURCE_DEVICE == pProvider->Common.Type) {
                
                TDIDumpDevice(pProvider);
    
            } else if (TDI_RESOURCE_NET_ADDRESS == pProvider->Common.Type) {
                
                TDIDumpAddress(pProvider);
            
            } else if (TDI_RESOURCE_PROVIDER == pProvider->Common.Type) {
                
                TDIDumpProvider(pProvider);
    
            } else {
                dprintf("Unknown type: %x\n", ElementTypeProvider);
                return;
            }


        } else if (CLIENT_TYPE == ElementTypeProvider) {
            
            if (!GetData(&Client,
                         (DWORD) Request.Element,
                         sizeof (TDI_NOTIFY_PNP_ELEMENT), "CLIENT_RESOURCE")) {
                return;
            }
            dprintf("Its a client!\n Need to add some code for this \n");

        } else {
            dprintf("Unknown element type on request list\n");
        }

        dprintf("\n--------------------------------------------------------\n");

        //Print(TdiExec.Request);
        pList = List.Flink;    

    }
}
/*
typedef struct _TDI_PROVIDER_RESOURCE {
        TDI_PROVIDER_COMMON              Common;

    // defined in netpnp.h
    PNET_PNP_EVENT           PnpPowerEvent;

    // Each TDI Client gets back and tells us what the status
        NTSTATUS                 Status;

    // These are mostly Address Specific.
    PTDI_PNP_CONTEXT         Context1;
    PTDI_PNP_CONTEXT         Context2;

    KEVENT                   PowerSyncEvent;
    ULONG                    PowerHandlers;
    PVOID                    PreviousContext;

    union {
                TDI_PROVIDER_DEVICE                     Device;
                TDI_PROVIDER_NET_ADDRESS        NetAddress;
        } Specific;
*/

DECLARE_API( providers )
{
    LIST_ENTRY              List, *pList, *start;
    
    pList = (PLIST_ENTRY) GetExpression("tdi!PnpHandlerProviderList");

    if (!GetData(&List,
                 (DWORD) pList,
                 sizeof(LIST_ENTRY), "PROVIDER_LIST"))
    {
        return;
    }
    
    if (List.Flink == List.Blink)
    {
        dprintf("No Providers\n");
        return;
    } 

    dprintf("---------------------------------------------------------------------\n");    
    start = pList;
    pList = List.Flink;

    while (List.Flink != start)
    {

        if (!GetData(&List,
                 (DWORD) pList,
                 sizeof(LIST_ENTRY), "PROVIDER_LIST"))
        {
            return;
        }
        
        if (!GetData(pProvider,
                 (DWORD) pList,
                 PROV_SIZE, "PROVIDER_RESOURCE"))
        {
            return;
        }        
        
        dprintf("Entry:     %X\n", pList);
        
        if(TDI_RESOURCE_DEVICE == pProvider->Common.Type) {
            
            TDIDumpDevice(pProvider);

        } else if (TDI_RESOURCE_NET_ADDRESS == pProvider->Common.Type) {
            
            TDIDumpAddress(pProvider);
        
        } else if (TDI_RESOURCE_PROVIDER == pProvider->Common.Type) {
            
            TDIDumpProvider(pProvider);

        } else {
            dprintf("Unknown type: %x\n", pProvider->Common.Type);
            return;
        }

        dprintf("---------------------------------------------------------------------\n");
        //Print(TdiExec.Request);
        pList = List.Flink;    

    }
    
}

DECLARE_API( devices )
{
    LIST_ENTRY              List, *pList, *start;
    
    pList = (PLIST_ENTRY) GetExpression("tdi!PnpHandlerProviderList");

    if (!GetData(&List,
                 (DWORD) pList,
                 sizeof(LIST_ENTRY), "PROVIDER_LIST"))
    {
        return;
    }
    
    if (List.Flink == List.Blink)
    {
        dprintf("No Devices\n");
        return;
    } 
        
    start = pList;
    pList = List.Flink;
    
    dprintf("---------------------------------------------------------------------\n");
    
    while (List.Flink != start)
    {
        
        if (!GetData(&List,
                 (DWORD) pList,
                 sizeof(LIST_ENTRY), "PROVIDER_LIST"))
        {
            return;
        }
        
        if (!GetData(pProvider,
                     (DWORD) pList,
                     PROV_SIZE, "PROVIDER_RESOURCE"))
        {
            return;
        }
        
        if(TDI_RESOURCE_DEVICE == pProvider->Common.Type) {
        
            dprintf("Entry:     %X\n", pList);
            
            TDIDumpDevice(pProvider);
            dprintf("---------------------------------------------------------------------\n");
        } 

        //Print(TdiExec.Request);
        pList = List.Flink;    

    }
}

DECLARE_API( providerready )
{
    LIST_ENTRY              List, *pList, *start;
    
    pList = (PLIST_ENTRY) GetExpression("tdi!PnpHandlerProviderList");

    if (!GetData(&List,
                 (DWORD) pList,
                 sizeof(LIST_ENTRY), "PROVIDER_LIST"))
    {
        return;
    }
    
    if (List.Flink == List.Blink)
    {
        dprintf("No Devices\n");
        return;
    } 
        
    start = pList;
    pList = List.Flink;
            
    dprintf("---------------------------------------------------------------------\n");

    while (List.Flink != start)
    {
        if (!GetData(&List,
                 (DWORD) pList,
                 sizeof(LIST_ENTRY), "PROVIDER_LIST"))
        {
            return;
        }
        
        if (!GetData(pProvider,
                 (DWORD) pList,
                 PROV_SIZE, "PROVIDER_RESOURCE"))
        {
            return;
        }
        
        if (TDI_RESOURCE_PROVIDER == pProvider->Common.Type) {
            dprintf("Entry:     %X\n", pList);
            TDIDumpProvider(pProvider);
            dprintf("---------------------------------------------------------------------\n");

        }


        //Print(TdiExec.Request);
        pList = List.Flink;    

    }
}

DECLARE_API( addresses )
{
    LIST_ENTRY              List, *pList, *start;
    
    pList = (PLIST_ENTRY) GetExpression("tdi!PnpHandlerProviderList");

    if (!GetData(&List,
                 (DWORD) pList,
                 sizeof(LIST_ENTRY), "PROVIDER_LIST"))
    {
        return;
    }
    
    if (List.Flink == List.Blink)
    {
        dprintf("No Devices\n");
        return;
    } 
        
    start = pList;
    pList = List.Flink;
    dprintf("---------------------------------------------------------------------\n");
    while (List.Flink != start)
    {   
        if (!GetData(&List,
                 (DWORD) pList,
                 sizeof(LIST_ENTRY), "PROVIDER_LIST"))
        {
            return;
        }
        
        if (!GetData(pProvider,
                     (DWORD) pList,
                      PROV_SIZE, "PROVIDER_RESOURCE"))
        {
            return;
        }
        
        if (TDI_RESOURCE_NET_ADDRESS == pProvider->Common.Type) {
            dprintf("Entry:     %X\n", pList);        
            TDIDumpAddress(pProvider);
            dprintf("---------------------------------------------------------------------\n");            
        } 

        //Print(TdiExec.Request);
        pList = List.Flink;    

    }
}

void
TDIDumpDevice(
              TDI_PROVIDER_RESOURCE *pProvider
              )
{
    CHAR *Buffer;
    
    Buffer = malloc (sizeof(WCHAR) * pProvider->Specific.Device.DeviceName.MaximumLength);

    if (!Buffer) {
        
        dprintf("Cant alloc memory\n");
        return;

    }

    if (!GetData(Buffer,
             (DWORD) pProvider->Specific.Device.DeviceName.Buffer,
             pProvider->Specific.Device.DeviceName.MaximumLength, "PROVIDER_LIST"))
    {
        
        free(Buffer);
        return;
    
    }

    dprintf("Device:    %ws\n", Buffer);
    free(Buffer);
    return;

}

void
TDIDumpAddress(
               TDI_PROVIDER_RESOURCE *prov
               )
{
    int j;

    //dprintf ("ADDRESS: len %d ", prov->Specific.NetAddress.Address.AddressLength);

    if (prov->Specific.NetAddress.Address.AddressType == TDI_ADDRESS_TYPE_IP) {
        dprintf("Type:      IP\n");
        dprintf("Address:   %d.%d.%d.%d\n",
            prov->Specific.NetAddress.Address.Address[2],
            prov->Specific.NetAddress.Address.Address[3],
            prov->Specific.NetAddress.Address.Address[4],
            prov->Specific.NetAddress.Address.Address[5]);
    } else if (prov->Specific.NetAddress.Address.AddressType == TDI_ADDRESS_TYPE_NETBIOS) {
        if (prov->Specific.NetAddress.Address.Address[2] == '\0') {
            dprintf("Type:      NETBIOS reserved\n");
            dprintf("Address:   %02x %02x %02x %02x %02x %02x\n",
                        (ULONG)(prov->Specific.NetAddress.Address.Address[12]),
                        (ULONG)(prov->Specific.NetAddress.Address.Address[13]),
                        (ULONG)(prov->Specific.NetAddress.Address.Address[14]),
                        (ULONG)(prov->Specific.NetAddress.Address.Address[15]),
                        (ULONG)(prov->Specific.NetAddress.Address.Address[16]),
                        (ULONG)(prov->Specific.NetAddress.Address.Address[17]));
        } else {
            dprintf("Type:      NETBIOS\n");        
            dprintf("Address:   %.16s\n", prov->Specific.NetAddress.Address.Address+2);
        }
    } else {
        dprintf("Type:      %d\n", prov->Specific.NetAddress.Address.AddressType);
        dprintf("Address:   ");
 
        for (j = 0; j < prov->Specific.NetAddress.Address.AddressLength; j++) {
            dprintf ("%02x ", (ULONG)(prov->Specific.NetAddress.Address.Address[j]));
        }
        dprintf ("\n");
    }

    dprintf("Context1:  %x\n", prov->Context1);
    dprintf("Context2:  %x\n", prov->Context2);

}

void
TDIDumpProvider(
                TDI_PROVIDER_RESOURCE *pProvider
                )
{

    CHAR *Buffer;

    Buffer = malloc (sizeof(WCHAR) * pProvider->Specific.Device.DeviceName.MaximumLength);

    if (!Buffer) {
        
        dprintf("Cant alloc memory\n");
        return;

    }

    if (!GetData(Buffer,
             (DWORD) pProvider->Specific.Device.DeviceName.Buffer,
             pProvider->Specific.Device.DeviceName.MaximumLength, "PROVIDER_LIST"))
    {
        
        free(Buffer);
        return;
    
    }

    dprintf("Provider:  %ws\n", Buffer);
    if (pProvider->ProviderReady) {
        
        dprintf("Ready:     yes\n");

    } else {
        
        dprintf("Ready:     no\n");        
    }

    free(Buffer);
    return;



}


DECLARE_API( clients )
{
    LIST_ENTRY              List, *pList, *start;
    TDI_NOTIFY_PNP_ELEMENT  client;
    CHAR                    *Buffer;

    pList = (PLIST_ENTRY) GetExpression("tdi!PnpHandlerClientList");

    if (!GetData(&List,
                 (DWORD) pList,
                 sizeof(LIST_ENTRY), "CLIENT_LIST1"))
    {
        return;
    }
    
    if (List.Flink == List.Blink)
    {
        dprintf("No Clients\n");
        return;
    } 
        
    start = pList;
    pList = List.Flink;
    

    dprintf("---------------------------------------------------------------------\n");    
    
    while (List.Flink != start)
    {
        if (!GetData(&List,
                 (DWORD) pList,
                 sizeof(LIST_ENTRY), "CLIENT_LIST2"))
        {
            return;
        }
        
        dprintf("Entry:                %x\n", pList);                
        
        if (!GetData(&client,
                 (DWORD) pList,
                 sizeof(TDI_NOTIFY_PNP_ELEMENT), "CLIENT_RESOURCE"))
        {
            return;
        }
        
        Buffer = malloc (sizeof(WCHAR) * client.ElementName.MaximumLength);

        if (!Buffer) {
    
            dprintf("Cant alloc memory\n");
            return;

        }


        if (!GetData(Buffer,
                     (DWORD) client.ElementName.Buffer,
                     client.ElementName.MaximumLength, "CLIENT_LIST3"))
        {
    
            free(Buffer);
            return;

        }

        dprintf("Name:                 %ws\n", Buffer);        
        free(Buffer);

        dprintf("Version:              %x.%x\n", (client.TdiVersion), (0xff & (client.TdiVersion >> 8)));        

        if (TDI_VERSION_ONE == client.TdiVersion) {

            dprintf("BindHandler:          %lx\n", client.Bind.BindHandler);
            
            dprintf("UnBindHandler:        %lx\n", client.Bind.UnbindHandler);

        } else {

            dprintf("BindingHandler:       %lx\n", client.BindingHandler);


        }
        dprintf("AddAddressHandler:    %lx\n", client.AddressElement.AddHandler);
        dprintf("DeleteAddressHandler: %lx\n", client.AddressElement.DeleteHandler);
        
        //dprintf("List of Interested Providers: %lx\n", client.AddressElement.ListofProviders);


        if (TDI_VERSION_ONE != client.TdiVersion) {
            
            dprintf("PnPPowerHandler:      %lx\n", client.PnpPowerHandler);

        }

        dprintf("---------------------------------------------------------------------\n");    

        //Print(TdiExec.Request);
        pList = List.Flink;    

    }
}

DECLARE_API( dbgmsgs )
{
    DWORD   p;
    DWORD   Last, First;
    char    DbgMsg[MAX_MSG_LEN];
    ULONG   Read;
    char    *DbgMsgs;

    if (!GetData(&Last,
                 GetExpression("tdi!Last"),
                 sizeof(Last), "DWORD"))
    {
        dprintf("1. error\n");
        return;
    }


    if (!GetData(&First,
                 GetExpression("tdi!First"),
                 sizeof(Last), "DWORD"))
    {
        dprintf("2. error\n");
        return;
    }



    DbgMsgs = (char *) GetExpression("tdi!dbgmsgs");

    dprintf("\n\n");

    while (First != Last)
    {
       if (!GetString((ULONG) (DbgMsgs + First * MAX_MSG_LEN),
                  DbgMsg, MAX_MSG_LEN))
            break;
        /*
        ReadMemory((ULONG) (DbgMsgs + First * MAX_MSG_LEN),
                    DbgMsg, MAX_MSG_LEN, &Read); */
        dprintf("%s", DbgMsg);
        First++;
        if (First == LOG_MSG_CNT)
            First = 0;
    }
}

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

DECLARE_API( version )
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf(
        "%s SMB Extension dll for Build %d debugging %s kernel for Build %d\n",
        kind,
        VER_PRODUCTBUILD,
        SavedMajorVersion == 0x0c ? "Checked" : "Free",
        SavedMinorVersion
    );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sys\tdipnp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    tdipnp.h

Abstract:

    This module contains the definitions for the PnP related code
        in the TDI driver.

Author:

    Henry Sanders (henrysa) 11 Oct 1995

Environment:

    Kernel mode

Revision History:



--*/

#ifndef _TDIPNP_
#define _TDIPNP_

// Define the types possible for a TDI_NOTIFY_ELEMENT structure.

#define TDI_NOTIFY_DEVICE                               0
#define TDI_NOTIFY_NET_ADDRESS                  1
#define TDI_NOTIFY_PNP_HANDLERS         2

// And the types possible for a TDI_PROVIDER_RESOURCE structure.

#define TDI_RESOURCE_DEVICE                             0
#define TDI_RESOURCE_NET_ADDRESS                1
#define TDI_RESOURCE_POWER              2
#define TDI_RESOURCE_PROVIDER           3

//
// Define the types of bind requests possible.

#define TDI_REGISTER_BIND_NOTIFY                0
#define TDI_DEREGISTER_BIND_NOTIFY              1
#define TDI_REGISTER_DEVICE                             2
#define TDI_DEREGISTER_DEVICE                   3
#define TDI_REGISTER_ADDRESS_NOTIFY             4
#define TDI_DEREGISTER_ADDRESS_NOTIFY   5
#define TDI_REGISTER_ADDRESS                    6
#define TDI_DEREGISTER_ADDRESS                  7
#define TDI_REGISTER_HANDLERS_PNP       8
#define TDI_DEREGISTER_HANDLERS_PNP     9
#define TDI_REGISTER_PNP_POWER_EVENT    10
#define TDI_REGISTER_ADDRESS_PNP        11
#define TDI_DEREGISTER_ADDRESS_PNP      12
#define TDI_REGISTER_DEVICE_PNP         13
#define TDI_DEREGISTER_DEVICE_PNP       14
#define TDI_NDIS_IOCTL_HANDLER_PNP      15
#define TDI_ENUMERATE_ADDRESSES         16
#define TDI_REGISTER_PROVIDER_PNP       17
#define TDI_DEREGISTER_PROVIDER_PNP     18
#define TDI_PROVIDER_READY_PNP          19


#define TDI_MAX_BIND_REQUEST                    TDI_DEREGISTER_DEVICE
#define TDI_MAX_ADDRESS_REQUEST         TDI_DEREGISTER_ADDRESS

//
// This is the definition of the common part of a TDI_NOTIFY_ELEMENT structure
//

typedef struct _TDI_NOTIFY_COMMON {
        LIST_ENTRY                                      Linkage;
        UCHAR                                           Type;
} TDI_NOTIFY_COMMON, *PTDI_NOTIFY_COMMON;

//
// The definition of the TDI_NOTIFY_BIND structure.
//

typedef struct _TDI_NOTIFY_BIND {
    TDI_BIND_HANDLER                    BindHandler;
    TDI_UNBIND_HANDLER                  UnbindHandler;
} TDI_NOTIFY_BIND, *PTDI_NOTIFY_BIND;

//
// The definition of a TDI_NOTIFY_ADDRESS structure,
//
typedef struct _TDI_NOTIFY_ADDRESS {
    union {
        struct {
            TDI_ADD_ADDRESS_HANDLER             AddHandler;
            TDI_DEL_ADDRESS_HANDLER             DeleteHandler;

        };
        struct {
            TDI_ADD_ADDRESS_HANDLER_V2          AddHandlerV2;
            TDI_DEL_ADDRESS_HANDLER_V2          DeleteHandlerV2;

        };
    };
} TDI_NOTIFY_ADDRESS, *PTDI_NOTIFY_ADDRESS;

//
// This is the definition of a TDI_NOTIFY_ELEMENT stucture.
//

typedef struct _TDI_NOTIFY_ELEMENT {
        TDI_NOTIFY_COMMON                       Common;
        union {
                TDI_NOTIFY_BIND                 BindElement;
                TDI_NOTIFY_ADDRESS              AddressElement;
        } Specific;
} TDI_NOTIFY_ELEMENT, *PTDI_NOTIFY_ELEMENT;


//
// This is the definition of the common part of a TDI_PROVIDER_RESOURCE structure.
//

typedef struct _TDI_NOTIFY_PNP_ELEMENT TDI_NOTIFY_PNP_ELEMENT, *PTDI_NOTIFY_PNP_ELEMENT ;

typedef struct _TDI_PROVIDER_COMMON {
        LIST_ENTRY                                      Linkage;
        UCHAR                                           Type;
        PTDI_NOTIFY_PNP_ELEMENT                         pNotifyElement;
        NTSTATUS                                        ReturnStatus;
} TDI_PROVIDER_COMMON, *PTDI_PROVIDER_COMMON;

//
// The definition of the TDI_PROVIDER_DEVICE structure.
//

typedef struct _TDI_PROVIDER_DEVICE {
        UNICODE_STRING                          DeviceName;
} TDI_PROVIDER_DEVICE, *PTDI_PROVIDER_DEVICE;

//
// The definition of the TDI_PROVIDER_NET_ADDRESS structure.
//

typedef struct _TDI_PROVIDER_NET_ADDRESS {
        TA_ADDRESS                              Address;
} TDI_PROVIDER_NET_ADDRESS, *PTDI_PROVIDER_NET_ADDRESS;

//
// This is the definition of a TDI_PROVIDER_RESOURCE stucture.
//

typedef struct _TDI_PROVIDER_RESOURCE {

        TDI_PROVIDER_COMMON              Common;

    // defined in netpnp.h
    PNET_PNP_EVENT           PnpPowerEvent;

    //
    // Now, we allow TDI to return PENDING and complete later
    // with this handler.
    //
    ProviderPnPPowerComplete PnPCompleteHandler;

    // Each TDI Client gets back and tells us what the status
        NTSTATUS                 Status;

    // These are mostly Address Specific.
    UNICODE_STRING           DeviceName;
    PTDI_PNP_CONTEXT         Context1;
    PTDI_PNP_CONTEXT         Context2;

    ULONG                    PowerHandlers;

    //Indicates if the Provider has called TDIProviderReady
    //
    ULONG                    ProviderReady;

    PVOID                    PreviousContext;

    // Debugging Information
    PVOID                   pCallersAddress;
    union {
                TDI_PROVIDER_DEVICE                     Device;
                TDI_PROVIDER_NET_ADDRESS        NetAddress;
        } Specific;

} TDI_PROVIDER_RESOURCE, *PTDI_PROVIDER_RESOURCE;

//
// Structure of a bind list request.
//

typedef struct _TDI_SERIALIZED_REQUEST {
        LIST_ENTRY                              Linkage;
        PVOID                                   Element;
        UINT                                    Type;
        PKEVENT                                 Event;
    BOOLEAN                 Pending;

} TDI_SERIALIZED_REQUEST, *PTDI_SERIALIZED_REQUEST;

//
// Power Management and PnP related extensions
//

// This structure stores pointers to the handlers for Pnp/PM events
// for the TDI clients

typedef struct _TDI_EXEC_PARAMS TDI_EXEC_PARAMS, *PTDI_EXEC_PARAMS;


typedef struct _TDI_NOTIFY_PNP_ELEMENT {
    TDI_NOTIFY_COMMON       Common;
    USHORT                  TdiVersion;
    USHORT                  Unused;
    UNICODE_STRING          ElementName;
    union {
        TDI_BINDING_HANDLER     BindingHandler;
        TDI_NOTIFY_BIND         Bind;
    };

    TDI_NOTIFY_ADDRESS      AddressElement;
    TDI_PNP_POWER_HANDLER   PnpPowerHandler;
    //
    // We need to maintain a list of providers in memory
    // for Power Mgmt. and Wake up on LAN.
    //
    PWSTR*                  ListofProviders;
    // The way we store stuff above is a MULTI_SZ string with pointers before
    // the MULTI_SZ starts to individual strings.
    //
    ULONG                   NumberofEntries;


    // This contains a list of bindings we should ignore when sending
    // notifications.
    PWSTR                   ListofBindingsToIgnore;

    // When we register a provider, we want to insure we have the 
    // space to store the information to deregister it.  This way
    // deregister will not fail under low memory conditions.
    PTDI_EXEC_PARAMS         pTdiDeregisterExecParams;

} TDI_NOTIFY_PNP_ELEMENT, *PTDI_NOTIFY_PNP_ELEMENT;



//
// Since the Remote Boot folks require that TDI not go to the
// registry and also sometimes the disk might get powered down
// before the netcards (bug in power management), lets store
// the bindings in non-paged memory (what a waste).
//

typedef struct _TDI_OPEN_BLOCK {
    struct _TDI_OPEN_BLOCK  *NextOpenBlock;
    PTDI_NOTIFY_PNP_ELEMENT pClient;
    PTDI_PROVIDER_RESOURCE  pProvider;
    UNICODE_STRING          ProviderName;

} TDI_OPEN_BLOCK, *PTDI_OPEN_BLOCK;

//
// Detailed description of the usage of the above structure.
//
//  _____________________               _____________________
//  |   Linkage         |-------------->|   Linkage         |
//  |   pClient         |--->TDI Client |   pClient         |
//  |   pProvider       |--->Transport  |   pProvider       |
//  |   pNextClient     |-------------->|   pNextClient     |
//  |   pNextProvider   |               |   pNextProvider   |
//  |___________________|               |___________________|



// External defintions for global variables.

extern KSPIN_LOCK               TDIListLock;

extern LIST_ENTRY               PnpHandlerProviderList;
extern LIST_ENTRY       PnpHandlerClientList;
extern LIST_ENTRY               PnpHandlerRequestList;

NTSTATUS
TdiPnPHandler(
    IN  PUNICODE_STRING         UpperComponent,
    IN  PUNICODE_STRING         LowerComponent,
    IN  PUNICODE_STRING         BindList,
    IN  PVOID                   ReconfigBuffer,
    IN  UINT                    ReconfigBufferSize,
    IN  UINT                    Operation
    );

#endif // _TDIPNP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sys\tdi.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tdi.c

Abstract:

    This module contains code which assists the process of writing an NT
    TDI client.

Author:

    David Beaver (dbeaver) 15 June 1991

Environment:

    Kernel mode

Revision History:


--*/

#pragma warning(push)
#pragma warning(disable:4115)
#include <ntosp.h>
#include <zwapi.h>
#include <ndis.h>
#include <tdikrnl.h>
#pragma warning(pop)

#include "tdipnp.h"

#if DBG

#include "tdidebug.h"

ULONG TdiDebug;

#define IF_TDIDBG(sts) \
    if ((TdiDebug & sts) != 0)

#define TDI_DEBUG_NAMES         0x00000001
#define TDI_DEBUG_DISPATCH      0x00000002
#define TDI_DEBUG_MAP           0x00000004

#else

#define IF_TDIDBG(sts) \
    if (0)
#endif

extern
VOID
CTEpInitialize(
    VOID
    );

KSPIN_LOCK TdiMappingAddressLock;
PVOID TdiMappingAddress;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Temporary entry point needed to initialize the TDI wrapper driver.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

Return Value:

   STATUS_SUCCESS

--*/

{
    //
    // Note: This function isn't called but is needed to keep the
    // linker happy.
    //

    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(RegistryPath);

    return STATUS_SUCCESS;

} // DriverEntry


NTSTATUS
DllInitialize(
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Initialize internal module state.

Arguments:

    RegistryPath - unused.

Return Value:

    Status of the initialization attempt.

--*/

{
    UNREFERENCED_PARAMETER(RegistryPath);

    KeInitializeSpinLock(&TDIListLock);
    InitializeListHead(&PnpHandlerClientList);
    InitializeListHead(&PnpHandlerProviderList);
    InitializeListHead(&PnpHandlerRequestList);

    CTEpInitialize();

    KeInitializeSpinLock(&TdiMappingAddressLock);
    TdiMappingAddress = MmAllocateMappingAddress(PAGE_SIZE, 'mIDT');
    if (TdiMappingAddress == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NdisRegisterTdiCallBack(TdiRegisterDeviceObject, TdiPnPHandler);

#if DBG
    //
    // If a debug build store a limited number of messages.
    //

    DbgMsgInit();
#endif
    return STATUS_SUCCESS;
} // DllInitialize


NTSTATUS
DllUnload(
    VOID
    )

/*++

Routine Description:

    Clean up internal module state.

Arguments:

    none.

Return Value:

    STATUS_SUCCESS.

--*/

{
    //
    // Indicate to NDIS TDI is about to be unloaded.
    //
    NdisDeregisterTdiCallBack();
        
    if (TdiMappingAddress != NULL) {
        MmFreeMappingAddress(TdiMappingAddress, 'mIDT');
        TdiMappingAddress = NULL;
    }
    return STATUS_SUCCESS;
} // DllUnload


NTSTATUS
TdiMapUserRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine maps a user request from the NtDeviceIoControlFile format
    to the kernel mode request format. It does this by probing and locking all
    buffers of interest, copying parameter sets to the stack pointer as
    appropriate, and generally preparing for the kernel IO form.

Arguments:

    Irp - pointer to the irp containing this request.

Return Value:

    NTSTATUS - status of operation. STATUS_UNSUCCESSFUL if the request could
    not be mapped, STATUS_NOT_IMPLEMENTED if the IOCTL is not recognized
    (allowing driver writers to extend the supported IOCTLs if needed), and
    STATUS_SUCCESS if the request was mapped successfully.

--*/

{

    NTSTATUS Status;
    DeviceObject;
    
    Status = STATUS_INVALID_PARAMETER;

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_TDI_ACCEPT:

            if (Irp->RequestorMode == UserMode) {
                return STATUS_NOT_IMPLEMENTED;
            }

            IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            IrpSp->MinorFunction = TDI_ACCEPT;

            Status = STATUS_SUCCESS;
            break;

        case IOCTL_TDI_ACTION:
        

#if defined(_WIN64)
            if (IoIs32bitProcess(Irp)) {
                return STATUS_NOT_IMPLEMENTED;
            }
#endif // _WIN64
                
            IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            IrpSp->MinorFunction = TDI_ACTION;

            Status = STATUS_SUCCESS;
            break;
        
        case IOCTL_TDI_CONNECT:
        {
            PTDI_REQUEST_CONNECT userRequest;
            PTDI_REQUEST_KERNEL_CONNECT request;
            PTDI_CONNECTION_INFORMATION connInfo;
            PCHAR ptr;

            if (Irp->RequestorMode == UserMode) {
                return STATUS_NOT_IMPLEMENTED;
            }

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength == sizeof(TDI_REQUEST_CONNECT) ) {

                IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                IrpSp->MinorFunction = TDI_CONNECT;

                userRequest =
                    (PTDI_REQUEST_CONNECT)Irp->AssociatedIrp.SystemBuffer;
                connInfo = userRequest->RequestConnectionInformation;

                ptr = (PCHAR)(connInfo + 1);

                connInfo->UserData = ptr;
                ptr += connInfo->UserDataLength;
                connInfo->Options = ptr;
                ptr += connInfo->OptionsLength;
                connInfo->RemoteAddress = ptr;

                request = (PTDI_REQUEST_KERNEL_CONNECT)&IrpSp->Parameters;
                request->RequestConnectionInformation = connInfo;

                request->ReturnConnectionInformation = NULL;

                Status = STATUS_SUCCESS;

            }
            break;
        }

        case IOCTL_TDI_DISCONNECT:
        {
            if (Irp->RequestorMode == UserMode) {
                return STATUS_NOT_IMPLEMENTED;
            }

            IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            IrpSp->MinorFunction = TDI_DISCONNECT;

            Status = STATUS_SUCCESS;
            break;
        }

        case IOCTL_TDI_LISTEN:
        {
            PTDI_REQUEST_LISTEN userRequest;
            PTDI_REQUEST_KERNEL_LISTEN request;

            if (Irp->RequestorMode == UserMode) {
                return STATUS_NOT_IMPLEMENTED;
            }

            //
            // fix for 123633
            //

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength == sizeof(TDI_REQUEST_LISTEN)) {

                userRequest =
                    (PTDI_REQUEST_LISTEN)Irp->AssociatedIrp.SystemBuffer;

                IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                IrpSp->MinorFunction = TDI_LISTEN;

                request = (PTDI_REQUEST_KERNEL_LISTEN)&IrpSp->Parameters;
                request->RequestFlags = userRequest->ListenFlags;

                Status = STATUS_SUCCESS;

            }
            break;
        }

        case IOCTL_TDI_QUERY_INFORMATION:
        {
            PTDI_REQUEST_QUERY_INFORMATION userRequest;
            PTDI_REQUEST_KERNEL_QUERY_INFORMATION request;
            PTDI_CONNECTION_INFORMATION connInfo;
            UINT    RemainingSize;
            PCHAR ptr;

#if defined(_WIN64)
            if (IoIs32bitProcess(Irp)) {
                return STATUS_NOT_IMPLEMENTED;
            }
#endif // _WIN64

            RemainingSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
            //
            // 123634
            //
            if (RemainingSize >= sizeof(TDI_REQUEST_QUERY_INFORMATION)) {

                userRequest =
                    (PTDI_REQUEST_QUERY_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

                IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                IrpSp->MinorFunction = TDI_QUERY_INFORMATION;

                request = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION)&IrpSp->Parameters;
                request->QueryType = userRequest->QueryType;
                RemainingSize -= sizeof(TDI_REQUEST_QUERY_INFORMATION);

                if (RemainingSize >= sizeof(TDI_CONNECTION_INFORMATION))
                {
                    connInfo = (PTDI_CONNECTION_INFORMATION)(userRequest + 1);
                    ptr = (PCHAR)(connInfo + 1);

                    //
                    // The user buffer is crafted to look as shown below
                    // -------------------------------------------------
                    // | user req | connInfo | user data | options data|
                    // -------------------------------------------------
                    // | remote addr |
                    // ---------------
                    // The TDI_CONNECTION_INFORMATION (connInfo) structure
                    // contains the length of the various fields shown
                    // after it. We need to verify the length of these fields
                    // against the size of the buffer user passed in.
                    //

                    RemainingSize -= sizeof(TDI_CONNECTION_INFORMATION);
                    
                    if (RemainingSize < (UINT) connInfo->UserDataLength) {
                        return STATUS_INVALID_PARAMETER;
                    }

                    RemainingSize -= (UINT) connInfo->UserDataLength;

                    if (RemainingSize < (UINT) connInfo->OptionsLength) {
                        return STATUS_INVALID_PARAMETER;
                    }

                    RemainingSize -= (UINT) connInfo->OptionsLength;

                    if (RemainingSize < (UINT) connInfo->RemoteAddressLength) {
                        return STATUS_INVALID_PARAMETER;
                    }

                    //
                    // now that the length has been validated, set
                    // the fields in connInfo
                    //
                    connInfo->UserData = ptr;
                    ptr += connInfo->UserDataLength;
                    connInfo->Options = ptr;
                    ptr += connInfo->OptionsLength;
                    connInfo->RemoteAddress = ptr;
                    request->RequestConnectionInformation = connInfo;
                }
                else
                {
                    request->RequestConnectionInformation = NULL;
                }

                Status = STATUS_SUCCESS;

            }
            break;
        }

        case IOCTL_TDI_RECEIVE:
        {
            PTDI_REQUEST_RECEIVE userRequest;
            PTDI_REQUEST_KERNEL_RECEIVE request;
            ULONG receiveLength;

            if (Irp->RequestorMode == UserMode) {
                return STATUS_NOT_IMPLEMENTED;
            }

            //
            // 123635
            //

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength == sizeof(TDI_REQUEST_RECEIVE)) {

                userRequest =
                        (PTDI_REQUEST_RECEIVE)Irp->AssociatedIrp.SystemBuffer;
                receiveLength =
                        IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

                IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                IrpSp->MinorFunction = TDI_RECEIVE;

                request = (PTDI_REQUEST_KERNEL_RECEIVE)&IrpSp->Parameters;
                request->ReceiveLength = receiveLength;
                request->ReceiveFlags = userRequest->ReceiveFlags;

                Status = STATUS_SUCCESS;

            }
            break;
        }

        case IOCTL_TDI_RECEIVE_DATAGRAM:
        {
            PTDI_REQUEST_RECEIVE_DATAGRAM userRequest;
            PTDI_REQUEST_KERNEL_RECEIVEDG request;
            ULONG receiveLength;

            if (Irp->RequestorMode == UserMode) {
                return STATUS_NOT_IMPLEMENTED;
            }

            //
            // 123636
            //
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength == sizeof(TDI_REQUEST_RECEIVE_DATAGRAM)) {

                userRequest =
                        (PTDI_REQUEST_RECEIVE_DATAGRAM)Irp->AssociatedIrp.SystemBuffer;
                receiveLength =
                        IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

                IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                IrpSp->MinorFunction = TDI_RECEIVE_DATAGRAM;

                request = (PTDI_REQUEST_KERNEL_RECEIVEDG)&IrpSp->Parameters;
                request->ReceiveLength = receiveLength;
                request->ReceiveFlags = userRequest->ReceiveFlags;
                request->ReceiveDatagramInformation = userRequest->ReceiveDatagramInformation;
                request->ReturnDatagramInformation = userRequest->ReturnInformation;

                Status = STATUS_SUCCESS;

            }
            break;
        }

        case IOCTL_TDI_SEND:
        {
            PTDI_REQUEST_SEND userRequest;
            PTDI_REQUEST_KERNEL_SEND request;
            ULONG sendLength;

            if (Irp->RequestorMode == UserMode) {
                return STATUS_NOT_IMPLEMENTED;
            }

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength == sizeof(TDI_REQUEST_SEND)) {

                userRequest =
                        (PTDI_REQUEST_SEND)Irp->AssociatedIrp.SystemBuffer;
                sendLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

                IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                IrpSp->MinorFunction = TDI_SEND;

                request = (PTDI_REQUEST_KERNEL_SEND)&IrpSp->Parameters;
                request->SendLength = sendLength;
                request->SendFlags = userRequest->SendFlags;

                Status = STATUS_SUCCESS;

            }
            break;
        }

        case IOCTL_TDI_SEND_DATAGRAM:
        {
            PTDI_REQUEST_SEND_DATAGRAM userRequest;
            PTDI_REQUEST_KERNEL_SENDDG request;
            ULONG sendLength;

            if (Irp->RequestorMode == UserMode) {
                return STATUS_NOT_IMPLEMENTED;
            }

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength == sizeof(TDI_REQUEST_SEND_DATAGRAM)) {

                sendLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

                IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                IrpSp->MinorFunction = TDI_SEND_DATAGRAM;

                request = (PTDI_REQUEST_KERNEL_SENDDG)&IrpSp->Parameters;
                request->SendLength = sendLength;

                userRequest = (PTDI_REQUEST_SEND_DATAGRAM)Irp->AssociatedIrp.SystemBuffer;
                request->SendDatagramInformation = userRequest->SendDatagramInformation;
                Status = STATUS_SUCCESS;
            }
            break;
        }

        case IOCTL_TDI_SET_EVENT_HANDLER:

            //
            // Because this request will enable direct callouts from the
            // transport provider at DISPATCH_LEVEL to a client-specified
            // routine, this request is only valid in kernel mode, denying
            // access to this request in user mode.
            //

            Status = STATUS_INVALID_PARAMETER;
            break;

        case IOCTL_TDI_SET_INFORMATION:
        {
            PTDI_REQUEST_SET_INFORMATION userRequest;
            PTDI_REQUEST_KERNEL_SET_INFORMATION request;

#if defined(_WIN64)
            if (IoIs32bitProcess(Irp)) {
                return STATUS_NOT_IMPLEMENTED;
            }
#endif // _WIN64

            //
            // 123637
            //
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength == sizeof(TDI_REQUEST_SET_INFORMATION)) {

                userRequest = 
                    (PTDI_REQUEST_SET_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
                    
                IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                IrpSp->MinorFunction = TDI_SET_INFORMATION;

                request = (PTDI_REQUEST_KERNEL_SET_INFORMATION)&IrpSp->Parameters;
                request->SetType = userRequest->SetType;
                request->RequestConnectionInformation = NULL;

                Status = STATUS_SUCCESS;

            }
            break;
        }

        case IOCTL_TDI_ASSOCIATE_ADDRESS:
        {
            PTDI_REQUEST_ASSOCIATE_ADDRESS userRequest;
            PTDI_REQUEST_KERNEL_ASSOCIATE request;

            if (Irp->RequestorMode == UserMode) {
                return STATUS_NOT_IMPLEMENTED;
            }

            //
            // 123637
            //
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength == sizeof(TDI_REQUEST_ASSOCIATE_ADDRESS)) {

                IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                IrpSp->MinorFunction = TDI_ASSOCIATE_ADDRESS;

                userRequest =
                    (PTDI_REQUEST_ASSOCIATE_ADDRESS)Irp->AssociatedIrp.SystemBuffer;
                request = (PTDI_REQUEST_KERNEL_ASSOCIATE)&IrpSp->Parameters;
                request->AddressHandle = userRequest->AddressHandle;

                Status = STATUS_SUCCESS;

            }
            break;
        }

        case IOCTL_TDI_DISASSOCIATE_ADDRESS:
        {
            if (Irp->RequestorMode == UserMode) {
                return STATUS_NOT_IMPLEMENTED;
            }

            IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            IrpSp->MinorFunction = TDI_DISASSOCIATE_ADDRESS;

            Status = STATUS_SUCCESS;
            break;
        }

        default:
            Status = STATUS_NOT_IMPLEMENTED;
            break;
    }

    return Status;
}


NTSTATUS
TdiDefaultConnectHandler(
    IN PVOID TdiEventContext,
    IN LONG RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN LONG UserDataLength,
    IN PVOID UserData,
    IN LONG OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext,
    OUT PIRP *AcceptIrp
    )

/*++

Routine Description:

    This routine is called when a connect request has completed. The connection
    is fully functional when the indication occurs.

Arguments:

    TdiEventContext - the context value passed in by the user in the Set Event Handler call

    RemoteAddressLength,

    RemoteAddress,

    UserDataLength,

    UserData,

    OptionsLength,

    Options,

    ConnectionId

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    UNREFERENCED_PARAMETER (TdiEventContext);
    UNREFERENCED_PARAMETER (RemoteAddressLength);
    UNREFERENCED_PARAMETER (RemoteAddress);
    UNREFERENCED_PARAMETER (UserDataLength);
    UNREFERENCED_PARAMETER (UserData);
    UNREFERENCED_PARAMETER (OptionsLength);
    UNREFERENCED_PARAMETER (Options);
    UNREFERENCED_PARAMETER (ConnectionContext);
    UNREFERENCED_PARAMETER (AcceptIrp);
    
    return STATUS_INSUFFICIENT_RESOURCES;       // do nothing
}


NTSTATUS
TdiDefaultDisconnectHandler(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN LONG DisconnectDataLength,
    IN PVOID DisconnectData,
    IN LONG DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    )

/*++

Routine Description:

    This routine is used as the default disconnect event handler
    for the transport endpoint. It is pointed to by a field in the
    TP_ENDPOINT structure for an endpoint when the endpoint is
    created, and also whenever the TdiSetEventHandler request is
    submitted with a NULL EventHandler field.

Arguments:

    TransportEndpoint - Pointer to open file object.

    Context - Typeless pointer specifying connection context.

    DisconnectIndicators - Value indicating reason for disconnection indication.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    UNREFERENCED_PARAMETER (TdiEventContext);
    UNREFERENCED_PARAMETER (ConnectionContext);
    UNREFERENCED_PARAMETER (DisconnectDataLength);
    UNREFERENCED_PARAMETER (DisconnectData);
    UNREFERENCED_PARAMETER (DisconnectInformationLength);
    UNREFERENCED_PARAMETER (DisconnectInformation);
    UNREFERENCED_PARAMETER (DisconnectFlags);

    return STATUS_SUCCESS;              // do nothing but return successfully.

} /* DefaultDisconnectHandler */


NTSTATUS
TdiDefaultErrorHandler(
    IN PVOID TdiEventContext,           // the endpoint's file object.
    IN NTSTATUS Status                // status code indicating error type.
    )

/*++

Routine Description:

    This routine is used as the default error event handler for
    the transport endpoint.  It is pointed to by a field in the
    TP_ENDPOINT structure for an endpoint when the endpoint is
    created, and also whenever the TdiSetEventHandler request is
    submitted with a NULL EventHandler field.

Arguments:

    TransportEndpoint - Pointer to open file object.

    Status - Status code indicated by this event.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    UNREFERENCED_PARAMETER (TdiEventContext);
    UNREFERENCED_PARAMETER (Status);

    return STATUS_SUCCESS;              // do nothing but return successfully.

} /* DefaultErrorHandler */


NTSTATUS
TdiDefaultReceiveHandler(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,                      // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket            // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    )

/*++

Routine Description:

    This routine is used as the default receive event handler for
    the transport endpoint.  It is pointed to by a field in the
    TP_ENDPOINT structure for an endpoint when the endpoint is
    created, and also whenever the TdiSetEventHandler request is
    submitted with a NULL EventHandler field.

Arguments:

    TdiEventContext - Pointer to the client-provided context value specified
        in the TdiSetEventHandler call for TDI_EVENT_RECEIVE.

    ConnectionContext - The client-supplied context associated with
        the connection on which this connection-oriented TSDU was received.

    ReceiveFlags - Bitflags which indicate the circumstances surrounding
        this TSDU's reception.

    BytesIndicated - The number of bytes of this TSDU that are being presented
        to the client in this indication.This value is always less than
        or equal to BytesAvailable.

    BytesAvailable - The total number of bytes of this TSDU presently
        available from the transport.

    BytesTaken - Return value indicating the number of bytes of data that the
        client copied from the indication data.

    Tsdu - Pointer to an MDL chain that describes the (first) part of the
        (partially) received Transport Service Data Unit, less headers.

    IoRequestPacket - Pointer to a location where the event handler may
        chose to return a pointer to an I/O Request Packet (IRP) to satisfy
        the incoming data.  If returned, this IRP must be formatted as a
        valid TdiReceive request, except that the ConnectionId field of
        the TdiRequest is ignored and is automatically filled in by the
        transport provider.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    UNREFERENCED_PARAMETER (TdiEventContext);
    UNREFERENCED_PARAMETER (ConnectionContext);
    UNREFERENCED_PARAMETER (ReceiveFlags);
    UNREFERENCED_PARAMETER (BytesIndicated);
    UNREFERENCED_PARAMETER (BytesAvailable);
    UNREFERENCED_PARAMETER (BytesTaken);
    UNREFERENCED_PARAMETER (Tsdu);
    UNREFERENCED_PARAMETER (IoRequestPacket);

    return STATUS_DATA_NOT_ACCEPTED;    // no handler in place.

} /* DefaultReceiveHandler */


NTSTATUS
TdiDefaultRcvDatagramHandler(
    IN PVOID TdiEventContext,       // the event context
    IN LONG SourceAddressLength,    // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN LONG OptionsLength,          // options for the receive
    IN PVOID Options,               //
    IN ULONG ReceiveDatagramFlags,  //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    )

/*++

Routine Description:

    This routine is used as the default receive datagram event
    handler for the transport endpoint.  It is pointed to by a
    field in the TP_ENDPOINT structure for an endpoint when the
    endpoint is created, and also whenever the TdiSetEventHandler
    request is submitted with a NULL EventHandler field.

Arguments:

    TdiEventContext - Pointer to the client-provided context value specified
        in the TdiSetEventHandler call for TDI_EVENT_RECEIVE_DATAGRAM.

    DestinationAddress - Pointer to the network name of the destination
        to which the datagram was directed.

    SourceAddress - Pointer to the network name of the source from which
        the datagram originated.

    Tsap - Transport service access point on which this datagram was received.

    ReceiveIndicators - Bitflags which indicate the circumstances surrounding
        this TSDU's reception.

    Tsdu - Pointer to an MDL chain that describes the (first) part of the
        (partially) received Transport Service Data Unit, less headers.

    IoRequestPacket - Pointer to a location where the event handler may
        chose to return a pointer to an I/O Request Packet (IRP) to satisfy
        the incoming data.  If returned, this IRP must be formatted as a
        valid TdiReceiveDatagram request.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    UNREFERENCED_PARAMETER (TdiEventContext);
    UNREFERENCED_PARAMETER (SourceAddressLength);
    UNREFERENCED_PARAMETER (SourceAddress);
    UNREFERENCED_PARAMETER (OptionsLength);
    UNREFERENCED_PARAMETER (Options);
    UNREFERENCED_PARAMETER (ReceiveDatagramFlags);
    UNREFERENCED_PARAMETER (BytesIndicated);
    UNREFERENCED_PARAMETER (BytesAvailable);
    UNREFERENCED_PARAMETER (BytesTaken);
    UNREFERENCED_PARAMETER (Tsdu);
    UNREFERENCED_PARAMETER (IoRequestPacket);

    return STATUS_DATA_NOT_ACCEPTED;    // no handler in place.

} /* DefaultRcvDatagramHandler */


NTSTATUS
TdiDefaultRcvExpeditedHandler(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,          //
    IN ULONG BytesIndicated,        // number of bytes in this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used by indication routine
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    )

/*++

Routine Description:

    This routine is used as the default expedited receive event handler
    for the transport endpoint.  It is pointed to by a field in the
    TP_ENDPOINT structure for an endpoint when the endpoint is
    created, and also whenever the TdiSetEventHandler request is
    submitted with a NULL EventHandler field.

Arguments:

    TdiEventContext - Pointer to the client-provided context value specified
        in the TdiSetEventHandler call for TDI_EVENT_RECEIVE.

    ConnectionContext - The client-supplied context associated with
        the connection on which this connection-oriented TSDU was received.

    ReceiveFlags - Bitflags which indicate the circumstances surrounding
        this TSDU's reception.

    BytesIndicated - The number of bytes of this TSDU that are being presented
        to the client in this indication.This value is always less than
        or equal to BytesAvailable.

    BytesAvailable - The total number of bytes of this TSDU presently
        available from the transport.

    BytesTaken - Return value indicating the number of bytes of data that the
        client copied from the indication data.

    Tsdu - Pointer to an MDL chain that describes the (first) part of the
        (partially) received Transport Service Data Unit, less headers.

    IoRequestPacket - Pointer to a location where the event handler may
        chose to return a pointer to an I/O Request Packet (IRP) to satisfy
        the incoming data.  If returned, this IRP must be formatted as a
        valid TdiReceive request, except that the ConnectionId field of
        the TdiRequest is ignored and is automatically filled in by the
        transport provider.

Return Value:

    NTSTATUS - status of operation.

--*/
{
    UNREFERENCED_PARAMETER (TdiEventContext);
    UNREFERENCED_PARAMETER (ConnectionContext);
    UNREFERENCED_PARAMETER (ReceiveFlags);
    UNREFERENCED_PARAMETER (BytesIndicated);
    UNREFERENCED_PARAMETER (BytesAvailable);
    UNREFERENCED_PARAMETER (BytesTaken);
    UNREFERENCED_PARAMETER (Tsdu);
    UNREFERENCED_PARAMETER (IoRequestPacket);

    return STATUS_DATA_NOT_ACCEPTED;

} /* DefaultRcvExpeditedHandler */

NTSTATUS
TdiDefaultChainedReceiveHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG ReceiveLength,
    IN ULONG StartingOffset,
    IN PMDL  Tsdu,
    IN PVOID TsduDescriptor
    )

/*++

Routine Description:

    This routine is used as the default chanied receive event handler
    for the transport endpoint.  It is pointed to by a field in the
    TP_ENDPOINT structure for an endpoint when the endpoint is
    created, and also whenever the TdiSetEventHandler request is
    submitted with a NULL EventHandler field.

Arguments:

    TdiEventContext - Pointer to the client-provided context value specified
        in the TdiSetEventHandler call for TDI_EVENT_CHAINED_RECEIVE.

    ConnectionContext - The client-supplied context associated with
        the connection on which this connection-oriented TSDU was received.

    ReceiveFlags - Bitflags which indicate the circumstances surrounding
        this TSDU's reception.

    ReceiveLength - The length in bytes of client data in the TSDU.

    StartingOffset - The offset, in bytes from the beginning of the TSDU,
        at which the client data begins.

    Tsdu - Pointer to an MDL chain that describes the entire received
        Transport Service Data Unit.

    TsduDescriptor - A descriptor for the TSDU which must be passed to
        TdiReturnChainedReceives in order to return the TSDU for reuse.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    UNREFERENCED_PARAMETER (TdiEventContext);
    UNREFERENCED_PARAMETER (ConnectionContext);
    UNREFERENCED_PARAMETER (ReceiveFlags);
    UNREFERENCED_PARAMETER (ReceiveLength);
    UNREFERENCED_PARAMETER (StartingOffset);
    UNREFERENCED_PARAMETER (Tsdu);
    UNREFERENCED_PARAMETER (TsduDescriptor);

    return STATUS_DATA_NOT_ACCEPTED;

} /* DefaultChainedReceiveHandler */


NTSTATUS
TdiDefaultChainedRcvDatagramHandler(
    IN PVOID TdiEventContext,
    IN LONG SourceAddressLength,
    IN PVOID SourceAddress,
    IN LONG OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG ReceiveDatagramLength,
    IN ULONG StartingOffset,
    IN PMDL  Tsdu,
    IN PVOID TsduDescriptor
    )

/*++

Routine Description:

    This routine is used as the default chained receive datagram
    event handler for the transport endpoint. It is pointed to by
    a field in the TP_ENDPOINT structure for an endpoint when the
    endpoint is created, and also whenever the TdiSetEventHandler
    request is submitted with a NULL EventHandler field.

Arguments:

    TdiEventContext - Pointer to the client-provided context value specified
        in the TdiSetEventHandler call for TDI_EVENT_CHAINED_RECEIVE_DATAGRAM.

    SourceAddressLength - The length of the source network address.

    SourceAddress - Pointer to the network address of the source from which
        the datagram originated.

    OptionsLength - The length of the transport options accompanying this TSDU.

    Options - Pointer to the transport options accompanying this TSDU.

    ReceiveDatagramFlags - Bitflags which indicate the circumstances
        surrounding this TSDU's reception.

    ReceiveDatagramLength - The length, in bytes, of the client data in
        this TSDU.

    StartingOffset - The offset, in bytes from the start of the TSDU, at
        which the client data begins.

    Tsdu - Pointer to an MDL chain that describes the received Transport
        Service Data Unit.

    TsduDescriptor - A descriptor for the TSDU which must be passed to
        TdiReturnChainedReceives in order to return the TSDU for reuse.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    UNREFERENCED_PARAMETER (TdiEventContext);
    UNREFERENCED_PARAMETER (SourceAddressLength);
    UNREFERENCED_PARAMETER (SourceAddress);
    UNREFERENCED_PARAMETER (OptionsLength);
    UNREFERENCED_PARAMETER (Options);
    UNREFERENCED_PARAMETER (ReceiveDatagramFlags);
    UNREFERENCED_PARAMETER (ReceiveDatagramLength);
    UNREFERENCED_PARAMETER (StartingOffset);
    UNREFERENCED_PARAMETER (Tsdu);
    UNREFERENCED_PARAMETER (TsduDescriptor);

    return STATUS_DATA_NOT_ACCEPTED;

} /* DefaultChainedRcvDatagramHandler */


NTSTATUS
TdiDefaultChainedRcvExpeditedHandler(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG ReceiveLength,
    IN ULONG StartingOffset,
    IN PMDL  Tsdu,
    IN PVOID TsduDescriptor
    )

/*++

Routine Description:

    This routine is used as the default chained expedited receive event
    handler for the transport endpoint.  It is pointed to by a field
    in the TP_ENDPOINT structure for an endpoint when the endpoint is
    created, and also whenever the TdiSetEventHandler request is
    submitted with a NULL EventHandler field.

Arguments:

    TdiEventContext - Pointer to the client-provided context value specified
        in the TdiSetEventHandler call for TDI_EVENT_CHAINED_RECEIVE_EXPEDITED.

    ConnectionContext - The client-supplied context associated with
        the connection on which this connection-oriented TSDU was received.

    ReceiveFlags - Bitflags which indicate the circumstances surrounding
        this TSDU's reception.

    ReceiveLength - The length in bytes of client data in the TSDU.

    StartingOffset - The offset, in bytes from the beginning of the TSDU,
        at which the client data begins.

    Tsdu - Pointer to an MDL chain that describes the entire received
        Transport Service Data Unit.

    TsduDescriptor - A descriptor for the TSDU which must be passed to
        TdiReturnChainedReceives in order to return the TSDU for reuse.

Return Value:

    NTSTATUS - status of operation.

--*/
{
    UNREFERENCED_PARAMETER (TdiEventContext);
    UNREFERENCED_PARAMETER (ConnectionContext);
    UNREFERENCED_PARAMETER (ReceiveFlags);
    UNREFERENCED_PARAMETER (ReceiveLength);
    UNREFERENCED_PARAMETER (StartingOffset);
    UNREFERENCED_PARAMETER (Tsdu);
    UNREFERENCED_PARAMETER (TsduDescriptor);

    return STATUS_DATA_NOT_ACCEPTED;

} /* DefaultRcvExpeditedHandler */


NTSTATUS
TdiDefaultSendPossibleHandler (
    IN PVOID TdiEventContext,
    IN PVOID ConnectionContext,
    IN ULONG BytesAvailable)

/*++

Routine Description:

Arguments:

    TdiEventContext - the context value passed in by the user in the Set Event Handler call

    ConnectionContext - connection context of connection which can be sent on

    BytesAvailable - number of bytes which can now be sent

Return Value:

    ignored by the transport

--*/

{
    UNREFERENCED_PARAMETER (TdiEventContext);
    UNREFERENCED_PARAMETER (ConnectionContext);
    UNREFERENCED_PARAMETER (BytesAvailable);

    return STATUS_SUCCESS;
}

VOID
TdiBuildNetbiosAddress(
    IN PUCHAR NetbiosName,
    IN BOOLEAN IsGroupName,
    IN OUT PTA_NETBIOS_ADDRESS NetworkName
    )

/*++

Routine Description:

    This routine builds a TA_NETBIOS_ADDRESS structure in the locations pointed
    to by NetworkName. All fields are filled out.

Arguments:

    NetbiosName - Pointer to a 16-byte buffer where the a netbios name is
                    supplied.

    IsGroupName - TRUE if this name is a group name, false otherwise.

    NetworkName - A pointer to a TA_NETBIOS_ADDRESS structure that is to
                    receive the buid TDI address.

Return Value:

    none.

--*/

{
    //IF_TDIDBG (TDI_DEBUG_NAMES) {
    //   DbgPrint ("TdiBuildNetBIOSAddress:  Entered.\n");
    //}

    NetworkName->TAAddressCount = 1;
    NetworkName->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    NetworkName->Address[0].AddressLength = sizeof (TDI_ADDRESS_NETBIOS);

    if (IsGroupName) {
        NetworkName->Address[0].Address[0].NetbiosNameType =
                                               TDI_ADDRESS_NETBIOS_TYPE_GROUP;
    } else {
        NetworkName->Address[0].Address[0].NetbiosNameType =
                                               TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    }

    RtlCopyMemory (
        NetworkName->Address[0].Address[0].NetbiosName,
        NetbiosName,
        16);

} /* TdiBuildNetbiosAddress */


NTSTATUS
TdiBuildNetbiosAddressEa (
    IN PUCHAR Buffer,
    IN BOOLEAN IsGroupName,
    IN PUCHAR NetbiosName
    )

/*++

Routine Description:

   Builds an EA describing a Netbios address in the buffer supplied by the
   user.

Arguments:

    Buffer - pointer to a buffer that the ea is to be built in. This buffer
        must be at least 40 bytes long.

    IsGroupName - true if the netbios name is a group name, false otherwise.

    NetbiosName - the netbios name to be inserted in the EA to be built.

Return Value:

    An informative error code if something goes wrong. STATUS_SUCCESS if the
    ea is built properly.

--*/

{
    PFILE_FULL_EA_INFORMATION EaBuffer;
    PTA_NETBIOS_ADDRESS TAAddress;
    ULONG Length;

#if DBG
    IF_TDIDBG (TDI_DEBUG_NAMES) {
        DbgPrint ("TdiBuildNetbiosAddressEa: Entered\n ");
    }
#endif
    
    try {
        Length = FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +
                        TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                        sizeof (TA_NETBIOS_ADDRESS);
        EaBuffer = (PFILE_FULL_EA_INFORMATION)Buffer;

        if (EaBuffer == NULL) {
            return STATUS_UNSUCCESSFUL;
        }

        EaBuffer->NextEntryOffset = 0;
        EaBuffer->Flags = 0;
        EaBuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
        EaBuffer->EaValueLength = sizeof (TA_NETBIOS_ADDRESS);

        RtlCopyMemory (
            EaBuffer->EaName,
            TdiTransportAddress,
            EaBuffer->EaNameLength + 1);

        TAAddress = (PTA_NETBIOS_ADDRESS)&EaBuffer->EaName[EaBuffer->EaNameLength+1];

        TdiBuildNetbiosAddress (
            NetbiosName,
            IsGroupName,
            TAAddress);

    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // Couldn't touch the passed parameters; just return an error
        // status.
        //

        return GetExceptionCode();
    }

    return STATUS_SUCCESS;

} /* TdiBuildNetbiosAddressEa */


NTSTATUS
TdiCopyMdlToBuffer(
    IN PMDL SourceMdlChain,
    IN ULONG SourceOffset,
    IN PVOID DestinationBuffer,
    IN ULONG DestinationOffset,
    IN ULONG DestinationBufferSize,
    OUT PULONG BytesCopied
    )

/*++

Routine Description:

    This routine copies data described by the source MDL chain starting at
    the source offset, into a flat buffer specified by the SVA starting at
    the destination offset.  A maximum of DestinationBufferSize bytes can
    be copied.  The actual number of bytes copied is returned in BytesCopied.

Arguments:

    SourceMdlChain - Pointer to a chain of MDLs describing the source data.

    SourceOffset - Number of bytes to skip in the source data.

    DestinationBuffer - Pointer to a flat buffer to copy the data to.

    DestinationOffset - Number of leading bytes to skip in the destination buffer.

    DestinationBufferSize - Size of the output buffer, including the offset.

    BytesCopied - Pointer to a longword where the actual number of bytes
        transferred will be returned.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PUCHAR Dest, Src;
    ULONG SrcBytesLeft, DestBytesLeft, BytesSkipped=0;

//    IF_TDIDBG (TDI_DEBUG_MAP) {
//       DbgPrint ("TdiCopyMdlToBuffer:  Entered.\n");
//  }

    ASSERT( DestinationBufferSize >= DestinationOffset );

    *BytesCopied = 0;

    //
    // Skip source bytes.
    //

    if ((Src = MmGetSystemAddressForMdlSafe (SourceMdlChain, NormalPagePriority)) == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    SrcBytesLeft = MmGetMdlByteCount (SourceMdlChain);
    while (BytesSkipped < SourceOffset) {
        if (SrcBytesLeft > (SourceOffset - BytesSkipped)) {
            // PANIC ("TdiCopyMdlToBuffer: Skipping part of this MDL.\n");
            SrcBytesLeft -= (SourceOffset - BytesSkipped);
            Src += (SourceOffset - BytesSkipped);
            BytesSkipped = SourceOffset;
            break;
        } else if (SrcBytesLeft == (SourceOffset - BytesSkipped)) {
            // PANIC ("TdiCopyMdlToBuffer: Skipping this exact MDL.\n");
            SourceMdlChain = SourceMdlChain->Next;
            if (SourceMdlChain == NULL) {
                //PANIC ("TdiCopyMdlToBuffer: MDL chain was all header.\n");
                return STATUS_SUCCESS;          // no bytes copied.
            }
            BytesSkipped = SourceOffset;
            if ((Src = MmGetSystemAddressForMdlSafe (SourceMdlChain, NormalPagePriority)) == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            SrcBytesLeft = MmGetMdlByteCount (SourceMdlChain);
            break;
        } else {
            // PANIC ("TdiCopyMdlToBuffer: Skipping all of this MDL & more.\n");
            BytesSkipped += SrcBytesLeft;
            SourceMdlChain = SourceMdlChain->Next;
            if (SourceMdlChain == NULL) {
                //PANIC ("TdiCopyMdlToBuffer: Premature end of MDL chain.\n");
                return STATUS_SUCCESS;          // no bytes copied.
            }
            if ((Src = MmGetSystemAddressForMdlSafe (SourceMdlChain, NormalPagePriority)) == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            SrcBytesLeft = MmGetMdlByteCount (SourceMdlChain);
        }
    }

    // PANIC ("TdiCopyMdlToBuffer: done skipping source bytes.\n");

    //
    // Skip destination bytes.
    //

    Dest = (PUCHAR)DestinationBuffer + DestinationOffset;
    DestBytesLeft = DestinationBufferSize - DestinationOffset;

    //
    // Copy source data into the destination buffer until it's full or
    // we run out of data, whichever comes first.
    //

    while (DestBytesLeft && SourceMdlChain) {
        if (SrcBytesLeft == 0) {
            // PANIC ("TdiCopyMdlToBuffer: MDL is empty, skipping to next one.\n");
            SourceMdlChain = SourceMdlChain->Next;
            if (SourceMdlChain == NULL) {
                // PANIC ("TdiCopyMdlToBuffer: But there are no more MDLs.\n");
                return STATUS_SUCCESS;
            }
            if ((Src = MmGetSystemAddressForMdlSafe (SourceMdlChain, NormalPagePriority)) == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            SrcBytesLeft = MmGetMdlByteCount (SourceMdlChain);
            continue;                   // skip 0-length MDL's.
        }
        // PANIC ("TdiCopyMdlToBuffer: Copying a chunk.\n");
        if (DestBytesLeft == SrcBytesLeft) {
            // PANIC ("TdiCopyMdlToBuffer: Copying exact amount.\n");
            RtlCopyBytes (Dest, Src, DestBytesLeft);
            *BytesCopied += DestBytesLeft;
            return STATUS_SUCCESS;
        } else if (DestBytesLeft < SrcBytesLeft) {
            // PANIC ("TdiCopyMdlToBuffer: Buffer overflow, copying some.\n");
            RtlCopyBytes (Dest, Src, DestBytesLeft);
            *BytesCopied += DestBytesLeft;
            return STATUS_BUFFER_OVERFLOW;
        } else {
            // PANIC ("TdiCopyMdlToBuffer: Copying all of this MDL, & more.\n");
            RtlCopyBytes (Dest, Src, SrcBytesLeft);
            *BytesCopied += SrcBytesLeft;
            DestBytesLeft -= SrcBytesLeft;
            Dest += SrcBytesLeft;
            SrcBytesLeft = 0;
        }
    }

    return SourceMdlChain == NULL ? STATUS_SUCCESS : STATUS_BUFFER_OVERFLOW;
} /* TdiCopyMdlToBuffer */


NTSTATUS
TdiCopyBufferToMdl (
    IN PVOID SourceBuffer,
    IN ULONG SourceOffset,
    IN ULONG SourceBytesToCopy,
    IN PMDL DestinationMdlChain,
    IN ULONG DestinationOffset,
    IN PULONG BytesCopied
    )

/*++

Routine Description:

    This routine copies data described by the source buffer to the MDL chain
    described by the DestinationMdlChain. The

Arguments:

    SourceBuffer - pointer to the source buffer

    SourceOffset - Number of bytes to skip in the source data.

    SourceBytesToCopy - number of bytes to copy from the source buffer

    DestinationMdlChain - Pointer to a chain of MDLs describing the
            destination buffers.

    DestinationOffset - Number of bytes to skip in the destination data.

    BytesCopied - Pointer to a longword where the actual number of bytes
        transferred will be returned.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PUCHAR Dest, Src;
    ULONG DestBytesLeft, BytesSkipped=0;

    //IF_TDIDBG (TDI_DEBUG_MAP) {
    //    DbgPrint ("TdiCopyBufferToMdl:  Entered.\n");
    //}

    *BytesCopied = 0;

    if (SourceBytesToCopy == 0) {
        return STATUS_SUCCESS;
    }

    if (DestinationMdlChain == NULL) {
        // No MDL to copy to. Output buffer was zero length.
        return STATUS_BUFFER_OVERFLOW;
    }

    //
    // Skip Destination bytes.
    //

    if ((Dest = MmGetSystemAddressForMdlSafe (DestinationMdlChain, NormalPagePriority)) == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    DestBytesLeft = MmGetMdlByteCount (DestinationMdlChain);
    while (BytesSkipped < DestinationOffset) {
        if (DestBytesLeft > (DestinationOffset - BytesSkipped)) {
            // PANIC ("TdiCopyMdlToBuffer: Skipping part of this MDL.\n");
            DestBytesLeft -= (DestinationOffset - BytesSkipped);
            Dest += (DestinationOffset - BytesSkipped);
            BytesSkipped = DestinationOffset;
            break;
        } else if (DestBytesLeft == (DestinationOffset - BytesSkipped)) {
            // PANIC ("TdiCopyMdlToBuffer: Skipping this exact MDL.\n");
            DestinationMdlChain = DestinationMdlChain->Next;
            if (DestinationMdlChain == NULL) {
                //PANIC ("TdiCopyMdlToBuffer: MDL chain was all header.\n");
                return STATUS_BUFFER_OVERFLOW;          // no bytes copied.
            }
            BytesSkipped = DestinationOffset;
            if ((Dest = MmGetSystemAddressForMdlSafe (DestinationMdlChain, NormalPagePriority)) == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            DestBytesLeft = MmGetMdlByteCount (DestinationMdlChain);
            break;
        } else {
            // PANIC ("TdiCopyMdlToBuffer: Skipping all of this MDL & more.\n");
            BytesSkipped += DestBytesLeft;
            DestinationMdlChain = DestinationMdlChain->Next;
            if (DestinationMdlChain == NULL) {
                //PANIC ("TdiCopyMdlToBuffer: Premature end of MDL chain.\n");
                return STATUS_BUFFER_OVERFLOW;          // no bytes copied.
            }
            if ((Dest = MmGetSystemAddressForMdlSafe (DestinationMdlChain, NormalPagePriority)) == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            DestBytesLeft = MmGetMdlByteCount (DestinationMdlChain);
        }
    }

    // PANIC ("TdiCopyMdlToBuffer: done skipping source bytes.\n");

    //
    // Skip source bytes.
    //

    Src = (PUCHAR)SourceBuffer + SourceOffset;

    //
    // Copy source data into the destination buffer until it's full or
    // we run out of data, whichever comes first.
    //

    while ((SourceBytesToCopy != 0) && (DestinationMdlChain != NULL)) {
        if (DestBytesLeft == 0) {
            // PANIC ("TdiCopyMdlToBuffer: MDL is empty, skipping to next one.\n");
            DestinationMdlChain = DestinationMdlChain->Next;
            if (DestinationMdlChain == NULL) {
                // PANIC ("TdiCopyMdlToBuffer: But there are no more MDLs.\n");
                return STATUS_BUFFER_OVERFLOW;
            }
            Dest = MmGetSystemAddressForMdlSafe (DestinationMdlChain, NormalPagePriority);
            if (Dest == NULL) {
                return STATUS_BUFFER_OVERFLOW;
            }
            DestBytesLeft = MmGetMdlByteCount (DestinationMdlChain);
            continue;                   // skip 0-length MDL's.
        }

        // PANIC ("TdiCopyMdlToBuffer: Copying a chunk.\n");
        if (DestBytesLeft >= SourceBytesToCopy) {
            // PANIC ("TdiCopyMdlToBuffer: Copying exact amount.\n");
            RtlCopyBytes (Dest, Src, SourceBytesToCopy);
            *BytesCopied += SourceBytesToCopy;
            return STATUS_SUCCESS;
        } else {
            // PANIC ("TdiCopyMdlToBuffer: Copying all of this MDL, & more.\n");
            RtlCopyBytes (Dest, Src, DestBytesLeft);
            *BytesCopied += DestBytesLeft;
            SourceBytesToCopy -= DestBytesLeft;
            Src += DestBytesLeft;
            DestBytesLeft = 0;
        }
    }

    return SourceBytesToCopy == 0 ? STATUS_SUCCESS : STATUS_BUFFER_OVERFLOW;

} /* TdiCopyBufferToMdl */


NTSTATUS
TdiCopyMdlChainToMdlChain (
    IN PMDL SourceMdlChain,
    IN ULONG SourceOffset,
    IN PMDL DestinationMdlChain,
    IN ULONG DestinationOffset,
    OUT PULONG BytesCopied
    )

/*++

Routine Description:

    This routine copies data described by the source MDL chain to the MDL chain
    described by the DestinationMdlChain.

Arguments:

    SourceMdlChain - Pointer to a chain of MDLs describing the source buffers.

    SourceOffset - Number of initial bytes to skip in the source data.

    DestinationMdlChain - Pointer to a chain of MDLs describing the
            destination buffers.

    DestinationOffset - Number of initial bytes to skip in the destination data.

    BytesCopied - Pointer to a longword where the actual number of bytes
        transferred will be returned.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    PUCHAR Dest, Src;
    ULONG DestBytesLeft, SrcBytesLeft, BytesSkipped;
    ULONG CopyAmount;

    *BytesCopied = 0;

    if (DestinationMdlChain == NULL) {
        // No MDL to copy to.
        return STATUS_BUFFER_OVERFLOW;
    }

    //
    // Skip Destination bytes.
    //
    BytesSkipped = 0;
    if ((Dest = MmGetSystemAddressForMdlSafe (DestinationMdlChain, NormalPagePriority)) == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    DestBytesLeft = MmGetMdlByteCount (DestinationMdlChain);

    while (BytesSkipped < DestinationOffset) {

        if (DestBytesLeft > (DestinationOffset - BytesSkipped)) {
            // the desired offset resides within this MDL.
            Dest += (DestinationOffset - BytesSkipped);
            DestBytesLeft -= (DestinationOffset - BytesSkipped);
            break;
        }

        // skip over this MDL
        BytesSkipped += DestBytesLeft;
        DestinationMdlChain = DestinationMdlChain->Next;
        if (DestinationMdlChain == NULL) {
            return STATUS_BUFFER_OVERFLOW;
        }
        if ((Dest = MmGetSystemAddressForMdlSafe (DestinationMdlChain, NormalPagePriority)) == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        DestBytesLeft = MmGetMdlByteCount (DestinationMdlChain);
    }

    //
    // Skip source bytes.
    //
    BytesSkipped = 0;
    if ((Src = MmGetSystemAddressForMdlSafe (SourceMdlChain, NormalPagePriority)) == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    SrcBytesLeft = MmGetMdlByteCount (SourceMdlChain);

    while (BytesSkipped < SourceOffset) {

        if (SrcBytesLeft > (SourceOffset - BytesSkipped)) {
            // the desired offset resides within this MDL.
            Src += (SourceOffset - BytesSkipped);
            SrcBytesLeft -= (SourceOffset - BytesSkipped);
            break;
        }

        // skip over this MDL
        BytesSkipped += SrcBytesLeft;
        SourceMdlChain = SourceMdlChain->Next;
        if (SourceMdlChain == NULL) {
            return STATUS_BUFFER_OVERFLOW;
        }

        if ((Src = MmGetSystemAddressForMdlSafe (SourceMdlChain, NormalPagePriority)) == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        SrcBytesLeft = MmGetMdlByteCount (SourceMdlChain);
    }


    //
    // Copy source data into the destination buffer until it's full or
    // we run out of data, whichever comes first.
    //

    while ((SourceMdlChain != NULL) && (DestinationMdlChain != NULL)) {
        if (SrcBytesLeft == 0)
        {
            SourceMdlChain = SourceMdlChain->Next;
            if (SourceMdlChain == NULL) {
                return STATUS_SUCCESS;
            }

            Src = MmGetSystemAddressForMdlSafe (SourceMdlChain, NormalPagePriority);
            if (Src == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            SrcBytesLeft = MmGetMdlByteCount (SourceMdlChain);
            continue;
        }

        if (DestBytesLeft == 0) {
            DestinationMdlChain = DestinationMdlChain->Next;
            if (DestinationMdlChain == NULL) {
                return STATUS_BUFFER_OVERFLOW;
            }

            Dest = MmGetSystemAddressForMdlSafe (DestinationMdlChain, NormalPagePriority);
            if (Dest == NULL) {
                return STATUS_BUFFER_OVERFLOW;
            }
            DestBytesLeft = MmGetMdlByteCount (DestinationMdlChain);
            continue;
        }

        CopyAmount = ((DestBytesLeft > SrcBytesLeft)? SrcBytesLeft: DestBytesLeft);
        RtlCopyBytes (Dest, Src, CopyAmount);

        SrcBytesLeft -= CopyAmount;
        Src += CopyAmount;

        DestBytesLeft -= CopyAmount;
        Dest += CopyAmount;

        *BytesCopied += CopyAmount;
    }

    return SourceMdlChain == NULL ? STATUS_SUCCESS : STATUS_BUFFER_OVERFLOW;

} /* TdiCopyMdlChainToMdlChain */


VOID
TdiCopyBufferToMdlWithReservedMappingAtDpcLevel(
    IN PVOID SourceBuffer,
    IN PMDL TargetMdl,
    IN ULONG TargetOffset,
    IN ULONG BytesToCopy
    )

/*++

Routine Description:

    This routine copies data from a given virtual address to the location
    described by a given MDL. The transfer is performed using a reserved PTE,
    and is guaranteed to succeed.

Arguments:

    SourceBuffer - the virtual address for the source of the transfer.

    TargetMdl - the MDL describing the target of the transfer.

    TargetOffset - the offset at which to begin transferring into the target.

    BytesToCopy - the number of bytes to transfer.

Return Value:

    NTSTATUS - status of operation.

--*/
{
    ULONG PartialEnd;
    UCHAR PartialMdlSpace[sizeof(MDL) + sizeof(PFN_NUMBER)];
    PMDL PartialMdl = (PMDL)PartialMdlSpace;
    PVOID PartialVa;
    ULONG TargetEnd;

    //
    // Use the reserved PTE to copy from each page in the given range,
    // with a partial MDL mapping at most one page at a time.
    //

    MmInitializeMdl(PartialMdl, NULL, PAGE_SIZE);

    KeAcquireSpinLockAtDpcLevel(&TdiMappingAddressLock);
    for (TargetEnd = TargetOffset + BytesToCopy; TargetOffset < TargetEnd;
         SourceBuffer = (PUCHAR)SourceBuffer + (PartialEnd - TargetOffset),
         TargetOffset = PartialEnd) {

        //
        // The location from which to copy next is in TargetOffset,
        // which is a relative offset from the VA described by TargetMdl.
        // The location at which we want to stop copying on this iteration
        // is the end of the page containing TargetOffset, again expressed
        // as a relative offset from the VA described by TargetMdl.
        // To compute the latter location, we
        //
        // - add PAGE_SIZE bytes to TargetOffset, adjust to include
        //   TargetMdl->ByteOffset (giving an absolute offset from
        //   TargetMdl->StartVa), and save the result in PartialEnd,
        //
        // - page-align PartialEnd, yielding the absolute offset from
        //   TargetMdl->StartVa to the first page after TargetOffset,
        //
        // - adjust PartialEnd to exclude the byte-offset of TargetMdl,
        //   giving us a relative offset from the VA described by TargetMdl.
        //
        // N.B. After the first block, all blocks will be PAGE_SIZE bytes
        // except (possibly) the last. We could take advantage of this fact
        // to optimize the code below.
        //

        PartialEnd = TargetOffset + PAGE_SIZE + MmGetMdlByteOffset(TargetMdl);
        PartialEnd = PtrToUlong(PAGE_ALIGN(PartialEnd));
        PartialEnd -= MmGetMdlByteOffset(TargetMdl);

        if (PartialEnd > TargetEnd) {
            PartialEnd = TargetEnd;
        }

        //
        // Build an MDL to describe the current block, use the reserved PTE
        // to map its page, and copy over its contents from the source VA.
        //

        IoBuildPartialMdl(TargetMdl, PartialMdl,
                          (PUCHAR)MmGetMdlVirtualAddress(TargetMdl) +
                          TargetOffset,
                          PartialEnd - TargetOffset);
        PartialVa = MmMapLockedPagesWithReservedMapping(TdiMappingAddress,
                                                        'mIDT', PartialMdl,
                                                        MmCached);
        ASSERT(PartialVa != NULL);
        RtlCopyMemory(PartialVa, SourceBuffer, PartialEnd - TargetOffset);

        //
        // Release the reserved mapping, clean up the partial MDL,
        // and advance the source VA to the next block.
        //

        MmUnmapReservedMapping(TdiMappingAddress, 'mIDT', PartialMdl);
        MmPrepareMdlForReuse(PartialMdl);
    }
    KeReleaseSpinLockFromDpcLevel(&TdiMappingAddressLock);
}


NTSTATUS
TdiOpenNetbiosAddress (
    IN OUT PHANDLE FileHandle,
    IN PUCHAR Buffer,
    IN PVOID DeviceName,
    IN PVOID Address)

/*++

Routine Description:

   Opens an address on the given file handle and device.

Arguments:

    FileHandle - the returned handle to the file object that is opened.

    Buffer - pointer to a buffer that the ea is to be built in. This buffer
        must be at least 40 bytes long.

    DeviceName - the Unicode string that points to the device object.

    Name - the address to be registered. If this pointer is NULL, the routine
        will attempt to open a "control channel" to the device; that is, it
        will attempt to open the file object with a null ea pointer, and if the
        transport provider allows for that, will return that handle.

Return Value:

    An informative error code if something goes wrong. STATUS_SUCCESS if the
    returned file handle is valid.

--*/
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PFILE_FULL_EA_INFORMATION EaBuffer;
    TA_NETBIOS_ADDRESS NetbiosAddress;
    PSZ Name;
    ULONG Length;

#if DBG    
    IF_TDIDBG (TDI_DEBUG_NAMES) {
        DbgPrint ("TdiOpenNetbiosAddress: Opening ");
        if (Address == NULL) {
            DbgPrint (" Control Channel");
        } else {
            DbgPrint (Address);
        }
        DbgPrint (".\n");
    }
#endif
    
    if (Address != NULL) {
        Name = (PSZ)Address;
        try {
            Length = FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +
                                        TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                                        sizeof(TA_NETBIOS_ADDRESS);
            EaBuffer = (PFILE_FULL_EA_INFORMATION)Buffer;

            if (EaBuffer == NULL) {
                return STATUS_UNSUCCESSFUL;
            }

            EaBuffer->NextEntryOffset = 0;
            EaBuffer->Flags = 0;
            EaBuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
            EaBuffer->EaValueLength = sizeof (TA_NETBIOS_ADDRESS);

            RtlCopyMemory(
                EaBuffer->EaName,
                TdiTransportAddress,
                EaBuffer->EaNameLength + 1
                );

            //
            // Create a copy of the NETBIOS address descriptor in a local
            // first, in order to avoid alignment problems.
            //

            NetbiosAddress.TAAddressCount = 1;
            NetbiosAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
            NetbiosAddress.Address[0].AddressLength =
                                                sizeof (TDI_ADDRESS_NETBIOS);
            NetbiosAddress.Address[0].Address[0].NetbiosNameType =
                                            TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
            RtlCopyMemory(
                NetbiosAddress.Address[0].Address[0].NetbiosName,
                Name,
                16
                );

            RtlCopyMemory (
                &EaBuffer->EaName[EaBuffer->EaNameLength + 1],
                &NetbiosAddress,
                sizeof(TA_NETBIOS_ADDRESS)
                );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // Couldn't touch the passed parameters; just return an error
            // status.
            //

            return GetExceptionCode();
        }
    } else {
        EaBuffer = NULL;
        Length = 0;
    }

    InitializeObjectAttributes (
        &ObjectAttributes,
        DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    Status = NtCreateFile (
                 FileHandle,
                 FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES, // desired access.
                 &ObjectAttributes,     // object attributes.
                 &IoStatusBlock,        // returned status information.
                 0,                     // block size (unused).
                 0,                     // file attributes.
                 FILE_SHARE_READ | FILE_SHARE_WRITE, // share access.
                 FILE_CREATE,           // create disposition.
                 0,                     // create options.
                 EaBuffer,                  // EA buffer.
                 Length);                    // EA length.


    if (!NT_SUCCESS( Status )) {
#if DBG    
        IF_TDIDBG (TDI_DEBUG_NAMES) {
            DbgPrint ("TdiOpenNetbiosEndpoint:  FAILURE, NtCreateFile returned status %lx.\n", Status);
        }
#endif
        return Status;
    }

    
    Status = IoStatusBlock.Status;

    if (!(NT_SUCCESS( Status ))) {
#if DBG
        IF_TDIDBG (TDI_DEBUG_NAMES) {
            DbgPrint ("TdiOpenNetbiosEndpoint:  FAILURE, IoStatusBlock.Status contains status code=%lx.\n", Status);
        }
#endif        
    }

    
    return Status;
} /* TdiOpenNetbiosAddress */



VOID
TdiReturnChainedReceives(
    IN PVOID *TsduDescriptors,
    IN ULONG  NumberOfTsdus
    )

/*++

Routine Description:

   Used by a TDI client to return ownership of a set of chained receive TSDUs
   to the NDIS layer. This routine may only be called if the client took
   ownership of the TSDUs by returning STATUS_PENDING to one of the
   CHAINED_RECEIVE indications.

Arguments:

    TsduDescriptors - An array of TSDU descriptors. Each descriptor was
        provided in one of the CHAINED_RECEIVE indications. The descriptors
        are actually pointers to the NDIS_PACKETS containing the TSDUs.

    NumberOfTsdus - The count of TSDU descriptors in the TsduDescriptors array.

Return Value:

    None.
--*/

{
    NdisReturnPackets(
        (PNDIS_PACKET *) TsduDescriptors,
        (UINT) NumberOfTsdus
        );
}

VOID
TdiInitialize(
    VOID
    )

/*++

Routine Description:

    An empty initialization routine for backward compatibility.

Arguments:

    Nothing.

Return Value:

    None.

--*/

{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sys\tdipnp.c ===
/*++
Copyright (c) 1993  Microsoft Corporation

Module Name:

    tdipnp.c

Abstract:

    TDI routines for supporting PnP in transports and transport clients.

Author:

    Henry Sanders (henrysa)           Oct. 10, 1995

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    henrysa     10-10-95    created
    shreem      01-23-97    bug #33975
    adube       01-01-01    maintenance mode - windows xp

Notes:

Change from the previous approach:

    1. Processing the TDI_REQUEST is done in a different function.
    2. Requests can be queued while another thread is notifying its clients/providers
    3. These are then dequeued by the and run on a different thread using CTE functions.

--*/


#pragma warning(push)
#pragma warning(disable:4115) // named type definition in parenthesis ntddk.h
#pragma warning(disable:4514) // unreferenced inline function ntdef.h

#include <ntddk.h>
#include <ndis.h>
#include <tdi.h>
#include <tdikrnl.h>
#include <cxport.h>
#include <ndispnp.h>

#pragma warning(pop)

#include "tdipnp.h"
#include "tdidebug.h"


#ifdef DBG

CHAR         DbgMsgs[LOG_MSG_CNT][MAX_MSG_LEN];
UINT         First, Last;
CTELock      DbgLock;

ULONG TdiDebugEx = TDI_DEBUG_ERROR;


ULONG TdiMemLog =
                   //LOG_NOTIFY    |
                   //LOG_REGISTER  |
                   //LOG_POWER     |
                    0;

ULONG TdiLogOutput = LOG_OUTPUT_BUFFER /*| LOG_OUTPUT_DEBUGGER*/;

#endif

KSPIN_LOCK      TDIListLock;


LIST_ENTRY      PnpHandlerRequestList;
LIST_ENTRY      PnpHandlerProviderList;
LIST_ENTRY      PnpHandlerClientList;
PTDI_OPEN_BLOCK OpenList = NULL;
BOOLEAN         PnpHandlerRequestInProgress;
PETHREAD        PnpHandlerRequestThread;
UINT            PrevRequestType     = 0;
ULONG           ProvidersRegistered = 0;
ULONG           ProvidersReady      = 0;
ULONG           EventScheduled      = 0;


// structure private to tdipnp.c. used to marshall parms to a CTE event

typedef struct _TDI_EXEC_PARAMS {
    LIST_ENTRY  Linkage;
    UINT        Signature;
    PLIST_ENTRY ClientList;
    PLIST_ENTRY ProviderList;
    PLIST_ENTRY RequestList;
    TDI_SERIALIZED_REQUEST Request;
    PETHREAD    *CurrentThread;
    CTEEvent    *RequestCTEEvent;
    PBOOLEAN    SerializeFlag;
    BOOLEAN     ResetSerializeFlag;
    PVOID       pCallersAddress;
    PVOID       pCallersCaller;
    PETHREAD    pCallerThread;
    
} TDI_EXEC_PARAMS, *PTDI_EXEC_PARAMS;

typedef struct {
    PVOID   ExecParm;
    UINT    Type;
    PVOID   Element;
    PVOID   Thread;
} EXEC_PARM;

// Keep a short list of current and last few requests that TDI has processed.
// (Debug purposes only. Current request isn't store anyware during processing)
#define   EXEC_CNT   8
EXEC_PARM TrackExecs[EXEC_CNT];
int       NextExec;

EXEC_PARM TrackExecCompletes[EXEC_CNT];
int NextExecComplete;

CTEEvent       BindEvent;
CTEEvent       AddressEvent;

CTEEvent       PnpHandlerEvent;

PWSTR StrRegTdiBindList = L"Bind";
PWSTR StrRegTdiLinkage = L"\\Linkage";
PWSTR StrRegTdiBindingsBasicPath  = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\";

#define MAX_UNICODE_BUFLEN 256

// private function prototypes

NTSTATUS
TdiExecuteRequest(
                CTEEvent *Event,
                PVOID pTdiExecParams
                );

BOOLEAN
TdipIsSzInMultiSzSafe (
    IN PCWSTR pszSearchString,
    IN PCWSTR pmsz);

VOID
TdipRemoveMultiSzFromSzArray (
    IN PWSTR pmszToRemove,
    IN OUT PWSTR* pszArray,
    IN ULONG ItemsInArray,
    OUT ULONG* pRemainingItems);

VOID
TdipRemoveMultiSzFromMultiSz (
    IN PCWSTR pmszToRemove,
    IN OUT PWSTR pmszToModify);

NTSTATUS
TdipAddMultiSzToMultiSz(
    IN PUNICODE_STRING pmszAdd,
    IN PCWSTR pmszModify,
    OUT PWSTR* ppmszOut);


VOID
TdipGetMultiSZList(
    PWSTR **ListPointer,
    PWSTR BaseKeyName,
    PUNICODE_STRING DeviceName,
    PWSTR Linkage,
    PWSTR ParameterKeyName,
    PUINT NumEntries
    );

BOOLEAN
TdipMultiSzStrStr(
        PWSTR *TdiClientBindingList,
        PUNICODE_STRING DeviceName
        );

BOOLEAN
TdipBuildProviderList(
                      PTDI_NOTIFY_PNP_ELEMENT    NotifyElement
                      );

PTDI_PROVIDER_RESOURCE
LocateProviderContext(
                      PUNICODE_STRING   ProviderName
                      );


// end private protos

#if DBG

VOID
TdipPrintMultiSz (
    IN PCWSTR pmsz);

VOID
TdiDumpAddress(
    IN PTA_ADDRESS Addr
    )
{
    int j;

    TDI_DEBUG(ADDRESS, ("len %d ", Addr->AddressLength));

    if (Addr->AddressType == TDI_ADDRESS_TYPE_IP) {
        TDI_DEBUG(ADDRESS, ("IP %d.%d.%d.%d\n",
            Addr->Address[2],
            Addr->Address[3],
            Addr->Address[4],
            Addr->Address[5]));
    } else if (Addr->AddressType == TDI_ADDRESS_TYPE_NETBIOS) {
        if (Addr->Address[2] == '\0') {
            TDI_DEBUG(ADDRESS, ("NETBIOS reserved %2x %2x %2x %2x %2x %2x\n",
                        (ULONG)(Addr->Address[12]),
                        (ULONG)(Addr->Address[13]),
                        (ULONG)(Addr->Address[14]),
                        (ULONG)(Addr->Address[15]),
                        (ULONG)(Addr->Address[16]),
                        (ULONG)(Addr->Address[17])));
        } else {
            TDI_DEBUG(ADDRESS, ("NETBIOS %.16s\n", Addr->Address+2));
        }
    } else {
        TDI_DEBUG(ADDRESS, ("type %d ", Addr->AddressType));
        for (j = 0; j < Addr->AddressLength; j++) {
            TDI_DEBUG(ADDRESS, ("%2x ", (ULONG)(Addr->Address[j])));
        }
        TDI_DEBUG(ADDRESS, ("\n"));
    }
}
#else
#define TdiDumpAddress(d)   (0)
#define TdipPrintMultiSz(p)
#endif

NTSTATUS
TdiNotifyPnpClientList (
                        PLIST_ENTRY ListHead,
                        PVOID       Info,
                        BOOLEAN     Added
                        )

/*++

    Routine Description:

    Arguments:

        ListHead            - Head of list to walk.
        Info                - Information describing the provider that changed.
        Added               - True if a provider was added, false otherwise

    Return Value:

--*/
{
    PLIST_ENTRY             Current;
    PTDI_PROVIDER_COMMON    ProviderCommon;
    PTDI_NOTIFY_PNP_ELEMENT NotifyPnpElement;
    PTDI_PROVIDER_RESOURCE  Provider;
    NTSTATUS                Status, ReturnStatus = STATUS_SUCCESS;

    TDI_DEBUG(FUNCTION, ("++ TdiNotifyPnpClientList\n"));

    Current = ListHead->Flink;

    // The Info parameter is actually a pointer to a PROVIDER_COMMON
    // structure, so get back to that so that we can find out what kind of
    // provider this is.

    ProviderCommon = (PTDI_PROVIDER_COMMON)Info;

    Provider = CONTAINING_RECORD(
                                 ProviderCommon,
                                 TDI_PROVIDER_RESOURCE,
                                 Common
                                 );

    if (Provider->Common.Type == TDI_RESOURCE_DEVICE) {
        TDI_DEBUG(PROVIDERS, ("Got new (de)registration for device %wZ\n", &Provider->Specific.Device.DeviceName));
    } else if (Provider->Common.Type == TDI_RESOURCE_NET_ADDRESS) {
        TDI_DEBUG(PROVIDERS, ("Got new (de)registration for address "));
        TdiDumpAddress(&Provider->Specific.NetAddress.Address);
    }


    // Walk the  input client list, and for every element in it
    // notify the client.

    while (Current != ListHead) {

        NotifyPnpElement = CONTAINING_RECORD(
                                             Current,
                                             TDI_NOTIFY_PNP_ELEMENT,
                                             Common.Linkage
                                             );

        CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);
        Provider->Common.pNotifyElement = NotifyPnpElement; //Debugging info

        if (Provider->Common.Type == TDI_RESOURCE_DEVICE) {


            if (TDI_VERSION_ONE == NotifyPnpElement->TdiVersion) {

                if (Added) {

                    if (NotifyPnpElement->Bind.BindHandler) {

                        TDI_LOG(LOG_NOTIFY, ("V1 bind %wZ to %wZ\n",
                            &Provider->Specific.Device.DeviceName,
                                             &NotifyPnpElement->ElementName));

                        (*(NotifyPnpElement->Bind.BindHandler))(
                                                           &Provider->Specific.Device.DeviceName
                                                           );
                    }
                } else {
                    if (NotifyPnpElement->Bind.UnbindHandler) {

                        TDI_LOG(LOG_NOTIFY, ("V1 unbind %wZ from %wZ\n",
                                &Provider->Specific.Device.DeviceName,
                                &NotifyPnpElement->ElementName));

                        (*(NotifyPnpElement->Bind.UnbindHandler))(
                                                             &Provider->Specific.Device.DeviceName
                                                             );
                    }
                }

            } else {


                if (NULL != NotifyPnpElement->BindingHandler)   {
                    // Remove any providers from the list that we are supposed
                    // to ignore.
                    //
                    TdipRemoveMultiSzFromSzArray (
                            NotifyPnpElement->ListofBindingsToIgnore,
                            NotifyPnpElement->ListofProviders,
                            NotifyPnpElement->NumberofEntries,
                            &NotifyPnpElement->NumberofEntries);

                    // This is a device object provider.
                    // This must be a notify bind element.

                    if (TdipMultiSzStrStr (
                                           NotifyPnpElement->ListofProviders,
                                           &Provider->Specific.Device.DeviceName
                                           )) {

                        if (Added) {

                            TDI_LOG(LOG_NOTIFY, ("Bind %wZ to %wZ\n",
                                    &Provider->Specific.Device.DeviceName,
                                    &NotifyPnpElement->ElementName));

                            (*(NotifyPnpElement->BindingHandler))(
                                                                  TDI_PNP_OP_ADD,
                                                                  &Provider->Specific.Device.DeviceName,
                                                                  (PWSTR) (NotifyPnpElement->ListofProviders + NotifyPnpElement->NumberofEntries)
                                                                  );
                        } else {

                            TDI_LOG(LOG_NOTIFY, ("Unbind %wZ from %wZ\n",
                                    &Provider->Specific.Device.DeviceName,
                                    &NotifyPnpElement->ElementName));

                            (*(NotifyPnpElement->BindingHandler))(
                                                                  TDI_PNP_OP_DEL,
                                                                  &Provider->Specific.Device.DeviceName,
                                                                  (PWSTR) (NotifyPnpElement->ListofProviders + NotifyPnpElement->NumberofEntries)
                                                                  );
                        }

                    }  else {
                        
                        TDI_DEBUG(BIND, ("The Client %wZ wasnt interested in this Provider %wZ!\r\n",
                                         &NotifyPnpElement->ElementName, &Provider->Specific.Device.DeviceName));
                    }
                }
            }
        } else if (Provider->Common.Type == TDI_RESOURCE_NET_ADDRESS) {

            // This is a notify net address element. If this is
            // an address coming in, call the add address handler,
            // otherwise call delete address handler.


            if (TDI_VERSION_ONE == NotifyPnpElement->TdiVersion) {

                if (Added && (NULL != NotifyPnpElement->AddressElement.AddHandler)) {

                    TDI_LOG(LOG_NOTIFY, ("Add address v1 %wZ to %wZ\n",
                                        &Provider->DeviceName,
                                        &NotifyPnpElement->ElementName));

                    (*(NotifyPnpElement->AddressElement.AddHandler))(
                                                                     &Provider->Specific.NetAddress.Address
                                                                     );

                } else if (!Added && (NULL != NotifyPnpElement->AddressElement.DeleteHandler)) {

                    TDI_LOG(LOG_NOTIFY, ("Del address v1 %wZ from %wZ\n",
                                        &Provider->DeviceName,
                                        &NotifyPnpElement->ElementName));

                    (*(NotifyPnpElement->AddressElement.DeleteHandler))(
                                                                        &Provider->Specific.NetAddress.Address
                                                                        );
                }
            } else {


                if (Added && (NULL != NotifyPnpElement->AddressElement.AddHandlerV2)) {

                    TDI_LOG(LOG_NOTIFY, ("Add address %wZ to %wZ\n",
                                        &Provider->DeviceName,
                                        &NotifyPnpElement->ElementName));

                    (*(NotifyPnpElement->AddressElement.AddHandlerV2))(
                                                                       &Provider->Specific.NetAddress.Address,
                                                                       &Provider->DeviceName,
                                                                       Provider->Context2
                                                                       );

                    TDI_DEBUG(ADDRESS, ("Address Handler Called: ADD!\n"));

                } else if (!Added && (NULL != NotifyPnpElement->AddressElement.DeleteHandlerV2)) {

                    TDI_LOG(LOG_NOTIFY, ("Del address %wZ from %wZ\n",
                                        &Provider->DeviceName,
                                        &NotifyPnpElement->ElementName));

                    (*(NotifyPnpElement->AddressElement.DeleteHandlerV2))(
                                                                          &Provider->Specific.NetAddress.Address,
                                                                          &Provider->DeviceName,
                                                                          Provider->Context2                                                                          );
                }
            }

        } else if (Provider->Common.Type == TDI_RESOURCE_POWER) {

            // RESOURCE_POWER

            if (NotifyPnpElement->PnpPowerHandler) {

                TDI_DEBUG(POWER, ("PnPPower Handler Called!\n"));

                TDI_LOG(LOG_NOTIFY | LOG_POWER,
                        ("Power event %d to %wZ\n",
                        Provider->PnpPowerEvent->NetEvent,
                        &NotifyPnpElement->ElementName));

                Status = (*(NotifyPnpElement->PnpPowerHandler)) (
                                                                 &Provider->Specific.Device.DeviceName,
                                                                 Provider->PnpPowerEvent,
                                                                 Provider->Context1,
                                                                 Provider->Context2
                                                                 );
                if (STATUS_PENDING == Status) {

                    TDI_DEBUG(POWER, ("Client returned PENDING  (%d) ++\n", Provider->PowerHandlers));
                    ReturnStatus = STATUS_PENDING;

                } else {
                    //
                    // Record the return value only if it is not SUCCESS or PENDING.
                    //
                    if (!NT_SUCCESS(Status)) {
                        Provider->Status = Status;
                        TDI_DEBUG(POWER, ("Client: %wZ returned %x\n", &NotifyPnpElement->ElementName, Provider->Status));
                        //
                        // For easier routing of failures.
                        //
                        DbgPrint("Client: %wZ returned %x\n", &NotifyPnpElement->ElementName, Provider->Status);
                    }

                    InterlockedDecrement((PLONG)&Provider->PowerHandlers);

                    TDI_DEBUG(POWER, ("Client returned Immediately (%d) : ++\n", Provider->PowerHandlers));

                }

            }
        } else if (Provider->Common.Type == TDI_RESOURCE_PROVIDER && Provider->ProviderReady) {
            //
            // First inform the clients about this provider and then if
            // ProvidersRegistered == ProvidersReady call again with NULL.
            //

            if ((TDI_VERSION_ONE != NotifyPnpElement->TdiVersion) &&
                (NULL != NotifyPnpElement->BindingHandler))  {

                        TDI_LOG(LOG_NOTIFY, ("%wZ ready, notify %wZ\n",
                                &Provider->Specific.Device.DeviceName,
                                &NotifyPnpElement->ElementName));

                        (*(NotifyPnpElement->BindingHandler))(
                                                              TDI_PNP_OP_PROVIDERREADY,
                                                              &Provider->Specific.Device.DeviceName,
                                                              NULL
                                                              );

                        if (ProvidersReady == ProvidersRegistered) {

                            TDI_LOG(LOG_NOTIFY, ("NETREADY to %wZ\n", &NotifyPnpElement->ElementName));

                            (*(NotifyPnpElement->BindingHandler))(
                                                                  TDI_PNP_OP_NETREADY,
                                                                  NULL,
                                                                  NULL
                                                                  );
                        } else {

                            TDI_DEBUG(BIND, ("************** Registered:%d + Ready %d\n", ProvidersRegistered, ProvidersReady));

                        }
            } else {

                TDI_DEBUG(PROVIDERS, ("%wZ has a NULL BindHandler\n", &NotifyPnpElement->ElementName));


            }


        }

        // Get the next one.

        Current = Current->Flink;

        Provider->Common.pNotifyElement = NULL; //Debugging info
        Provider->Common.ReturnStatus = ReturnStatus; // Debugging info            

    }

    
    TDI_DEBUG(FUNCTION, ("-- TdiNotifyPnpClientList : %lx\n", ReturnStatus));

    return ReturnStatus;
}


VOID
TdiNotifyNewPnpClient(
                      PLIST_ENTRY   ListHead,
                      PVOID     Info
                      )

/*++

    Routine Description:

        Called when a new client is added and we want to notify it of existing
        providers. The client can be for either binds or net addresses. We
        walk the specified input list, and notify the client about each entry in
        it.

    Arguments:

        ListHead            - Head of list to walk.
        Info                - Information describing the new client to be notified.

    Return Value:



--*/

{
    PLIST_ENTRY             CurrentEntry;
    PTDI_NOTIFY_COMMON      NotifyCommon;
    PTDI_PROVIDER_RESOURCE  Provider;
    PTDI_NOTIFY_PNP_ELEMENT NotifyPnpElement;
    
    TDI_DEBUG(FUNCTION, ("++ TdiNotifyNewPnpClient\n"));

    CurrentEntry = ListHead->Flink;

    // The info is actually a pointer to a client notify element. Cast
    // it to the common type.

    NotifyCommon = (PTDI_NOTIFY_COMMON)Info;

    NotifyPnpElement = CONTAINING_RECORD(
                                         NotifyCommon,
                                         TDI_NOTIFY_PNP_ELEMENT,
                                         Common
                                         );

    TDI_DEBUG(CLIENTS, ("New handler set registered by %wZ\n", &NotifyPnpElement->ElementName));

    // Walk the input provider list, and for every element in it notify
    // the new client.

    while (CurrentEntry != ListHead) {

        // If the new client is for bind notifys, set up to call it's bind
        // handler.

        // Put the current provider element into the proper form.

        Provider = CONTAINING_RECORD(
                                     CurrentEntry,
                                     TDI_PROVIDER_RESOURCE,
                                     Common.Linkage
                                     );

        CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

        if (Provider->Common.Type == TDI_RESOURCE_DEVICE) {
            if (TDI_VERSION_ONE == NotifyPnpElement->TdiVersion ) {

                if (NotifyPnpElement->Bind.BindHandler) {

                    TDI_LOG(LOG_NOTIFY, ("V1 bind %wZ to %wZ\n",
                            &Provider->Specific.Device.DeviceName,
                            &NotifyPnpElement->ElementName));

                    (*(NotifyPnpElement->Bind.BindHandler))(
                                                       &Provider->Specific.Device.DeviceName
                                                       );

                }

            } else {

                if (NULL != NotifyPnpElement->BindingHandler) {

                    // This is a bind notify client.
                    if (TdipMultiSzStrStr(
                                          NotifyPnpElement->ListofProviders,
                                          &Provider->Specific.Device.DeviceName
                                          )) {


                        TDI_DEBUG(BIND, ("Telling new handlers to bind to %wZ\n", &Provider->Specific.Device.DeviceName));

                        TDI_LOG(LOG_NOTIFY, ("bind(new) %wZ to %wZ\n",
                                &Provider->Specific.Device.DeviceName,
                                             &NotifyPnpElement->ElementName));

                        (*(NotifyPnpElement->BindingHandler))(
                                                              TDI_PNP_OP_ADD,
                                                              &Provider->Specific.Device.DeviceName,
                                                              (PWSTR) (NotifyPnpElement->ListofProviders + NotifyPnpElement->NumberofEntries)
                                                              );

                    } else {
                        TDI_DEBUG(BIND, ("The Client %wZ wasnt interested in this Provider %wZ!\r\n",
                                         &NotifyPnpElement->ElementName, &Provider->Specific.Device.DeviceName));
                    }

                } else {
                    TDI_DEBUG(BIND, ("The client %wZ has a NULL Binding Handler\n", &NotifyPnpElement->ElementName));
                }
            }

        } else if (Provider->Common.Type == TDI_RESOURCE_NET_ADDRESS) {
            // This is an address notify client.
            // cant be TDI_RESOURCE_POWER coz we never put it on the list! - ShreeM

            if (TDI_VERSION_ONE == NotifyPnpElement->TdiVersion) {

                if (NULL != NotifyPnpElement->AddressElement.AddHandler) {

                    TDI_LOG(LOG_NOTIFY, ("Add address v1 %wZ to %wZ\n",
                                        &Provider->DeviceName,
                                        &NotifyPnpElement->ElementName));

                    (*(NotifyPnpElement->AddressElement.AddHandler))(
                                                                     &Provider->Specific.NetAddress.Address
                                                                     );
                }
            } else {



                if (NotifyPnpElement->AddressElement.AddHandlerV2) {

                    TdiDumpAddress(&Provider->Specific.NetAddress.Address);

                    TDI_LOG(LOG_NOTIFY, ("Add address(2) %wZ to %wZ\n",
                                        &Provider->DeviceName,
                                        &NotifyPnpElement->ElementName));

                    (*(NotifyPnpElement->AddressElement.AddHandlerV2))(
                                                                       &Provider->Specific.NetAddress.Address,
                                                                       &Provider->DeviceName,
                                                                       Provider->Context2
                                                                       );
                }
            }
        }

        // And do the next one.

        CurrentEntry = CurrentEntry->Flink;

    }

    //
    // Now the providers who are ready.
    //

    if (NULL == NotifyPnpElement->BindingHandler)   {
        //
        // If the Bindhandler is NULL, further action is pointless.
        //
        TDI_DEBUG(PROVIDERS, ("%wZ has a NULL BindHandler!!\n", &NotifyPnpElement->ElementName));
        TDI_DEBUG(FUNCTION, ("-- TdiNotifyNewPnpClient\n"));
        return;

    }

    if (TDI_VERSION_ONE == NotifyPnpElement->TdiVersion)   {
        //
        // If the Bindhandler is NULL, further action is pointless.
        //
        TDI_DEBUG(PROVIDERS, ("This is a TDI v.1 client!\n"));
        TDI_DEBUG(FUNCTION, ("-- TdiNotifyNewPnpClient\n"));
        return;
    }

    // Otherwise, we can start the loop again.
    // Yes, maintaining different lists for addresses, providers, and devices
    // might be more efficient and I will do this later.

    CurrentEntry = ListHead->Flink;

    while (CurrentEntry != ListHead) {

        Provider = CONTAINING_RECORD(
                                     CurrentEntry,
                                     TDI_PROVIDER_RESOURCE,
                                     Common.Linkage
                                     );

        CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);



        if (Provider->Common.Type == TDI_RESOURCE_PROVIDER && Provider->ProviderReady) {

            //
            // First inform the clients about this provider and then if
            // ProvidersRegistered == ProvidersReady call again with NULL.
            //

            TDI_LOG(LOG_NOTIFY, ("%wZ ready2, notify %wZ\n",
                    &Provider->Specific.Device.DeviceName,
                    &NotifyPnpElement->ElementName));

            (*(NotifyPnpElement->BindingHandler))(
                                                  TDI_PNP_OP_PROVIDERREADY,
                                                  &Provider->Specific.Device.DeviceName,
                                                  NULL
                                                  );
        }

        // And do the next one.

        CurrentEntry = CurrentEntry->Flink;

    }

    if (ProvidersReady == ProvidersRegistered) {

        TDI_LOG(LOG_NOTIFY, ("NETREADY2 to %wZ\n", &NotifyPnpElement->ElementName));

        (*(NotifyPnpElement->BindingHandler))(
                                              TDI_PNP_OP_NETREADY,
                                              NULL,
                                              NULL
                                              );
    } else {

        TDI_DEBUG(PROVIDERS, ("Provider Ready Status: Registered:%d + Ready:%d\n", ProvidersRegistered, ProvidersReady));

    }

    TDI_DEBUG(FUNCTION, ("-- TdiNotifyNewPnpClient\n"));

}



VOID
TdiNotifyAddresses(
    PLIST_ENTRY ListHead,
    PVOID       Info
    )

/*++

Routine Description:

    Called when a client wants to know about all the TDI Addresses

Arguments:

    ListHead            - Head of list to walk.
    Info                - Information describing the new client to be notified.

Return Value:



--*/

{
    PLIST_ENTRY             CurrentEntry;
    PTDI_NOTIFY_COMMON      NotifyCommon;
    PTDI_PROVIDER_RESOURCE  Provider;
    PTDI_NOTIFY_PNP_ELEMENT NotifyPnpElement;

    TDI_DEBUG(FUNCTION, ("++ TdiNotifyAddresses\n"));

    CurrentEntry = ListHead->Flink;

    // The info is actually a pointer to a client notify element. Cast
    // it to the common type.

    NotifyCommon = (PTDI_NOTIFY_COMMON)Info;

    NotifyPnpElement = CONTAINING_RECORD(
                        NotifyCommon,
                        TDI_NOTIFY_PNP_ELEMENT,
                        Common
                        );

    TDI_DEBUG(CLIENTS, ("%wZ wants to know about all the addresses\n", &NotifyPnpElement->ElementName));

    // Walk the input provider list, and for every element in it notify
    // the new client.

    while (CurrentEntry != ListHead) {

        // If the new client is for bind notifys, set up to call it's bind
        // handler.

        // Put the current provider element into the proper form.

        Provider = CONTAINING_RECORD(
                            CurrentEntry,
                            TDI_PROVIDER_RESOURCE,
                            Common.Linkage
                            );

        if (Provider->Common.Type == TDI_RESOURCE_NET_ADDRESS) {

            if (NotifyPnpElement->AddressElement.AddHandlerV2) {

               TDI_DEBUG(ADDRESS, ("Add Address Handler\n"));

                TDI_DEBUG(CLIENTS, ("Telling new handlers about address: "));
                TdiDumpAddress(&Provider->Specific.NetAddress.Address);

                (*(NotifyPnpElement->AddressElement.AddHandlerV2))(
                    &Provider->Specific.NetAddress.Address,
                    &Provider->DeviceName,
                    Provider->Context2
                    );

            }
        }

        // And do the next one.

        CurrentEntry = CurrentEntry->Flink;

    }

    TDI_DEBUG(FUNCTION, ("-- TdiNotifyAddresses\n"));

}


VOID
TdiHandlePnpOperation(
    PLIST_ENTRY ListHead,
    PVOID       Info
    )
{
    PLIST_ENTRY             Current;
    PTDI_NOTIFY_PNP_ELEMENT NotifyPnpElement = NULL;
    PTDI_PROVIDER_RESOURCE  ProviderElement = NULL;
    PTDI_NCPA_BINDING_INFO  NCPABindingInfo;
    NTSTATUS                Status = STATUS_SUCCESS;
    NET_PNP_EVENT           NetEvent;
    ULONG                   Operation;
    BOOLEAN                 DeviceRegistered = FALSE;
    BOOLEAN                 ClientFound = FALSE;

    TDI_DEBUG(FUNCTION, ("---------------------------> ++ TdiHandlePnpOperation!!\n"));

    ASSERT(NULL != Info);
    ASSERT(NULL != ListHead);

    Current = ListHead->Flink;

    // The Info parameter is actually a pointer to TDI_NCPA_BINDING_INFO
    // structure.

    NCPABindingInfo = (PTDI_NCPA_BINDING_INFO) Info;
    Operation       = (ULONG) NCPABindingInfo->PnpOpcode;

    // Walk the input client list, and see if that is the client we are looking for.

    while (Current != ListHead) {

        NotifyPnpElement = CONTAINING_RECORD(
                        Current,
                        TDI_NOTIFY_PNP_ELEMENT,
                        Common.Linkage
                        );


        if (!RtlCompareUnicodeString(
                                NCPABindingInfo->TdiClientName,
                                &NotifyPnpElement->ElementName,
                                TRUE)
                                    ) {
           TDI_DEBUG(NCPA, ("Found the TDI client for the message from NCPA\n"));
           ClientFound = TRUE;
           break;

        }

        Current = Current->Flink;

    }

    if (!ClientFound) {
        //
        // Cant do much if the client's handlers are not registered.
        //

        return;

    } else {

        //
        // Let's update the ListofProviders for this client.
        // Add a new provider to the Client's list of Providers...
        //
        if (NotifyPnpElement->ListofProviders) {

            TDI_DEBUG(NCPA, ("Before this BIND - Client %wZ was interested in %lx Providers\n", &NotifyPnpElement->ElementName,
                                                                                        NotifyPnpElement->NumberofEntries));

            ExFreePool(NotifyPnpElement->ListofProviders);

            TDI_DEBUG(NCPA, ("Freed the previous List of Providers\n"));


        } else {

            TDI_DEBUG(NCPA, ("List of providers was NULL for %wZ\n", &NotifyPnpElement->ElementName));

        }

        TdipBuildProviderList(
                              (PTDI_NOTIFY_PNP_ELEMENT) NotifyPnpElement
                              );

        TDI_DEBUG(NCPA, ("Built New BindList - %wZ is interested in %lx Providers after BIND\n",    &NotifyPnpElement->ElementName,
                         NotifyPnpElement->NumberofEntries));

    }

    //
    // If it is a reconfigure, or an add or delete ignore binding,
    // don't see if device (provider) is registered.
    //
    if ((RECONFIGURE == Operation) || (ADD_IGNORE_BINDING == Operation) ||
            (DEL_IGNORE_BINDING == Operation))
    {
       goto DeviceNotRequired;
    }

    //
    // If we are here, the client exists. Check if the provider has registered the device
    //

    Current = PnpHandlerProviderList.Flink;

    while (Current != &PnpHandlerProviderList) {

       ProviderElement = CONTAINING_RECORD(
                                           Current,
                                           TDI_PROVIDER_RESOURCE,
                                           Common.Linkage
                                           );

       if (ProviderElement->Common.Type != TDI_RESOURCE_DEVICE) {
          Current = Current->Flink;
          continue;
       }

       if (!RtlCompareUnicodeString(NCPABindingInfo->TdiProviderName,
                                    &ProviderElement->Specific.Device.DeviceName,
                                    TRUE)) {
          TDI_DEBUG(NCPA, ("Provider is registered with TDI\n"));
          DeviceRegistered = TRUE;
          break;

       }

       Current = Current->Flink;

    }

    if (!DeviceRegistered) {

        if (NULL != NotifyPnpElement->BindingHandler) {
            TDI_LOG(LOG_NOTIFY,
                    ("Device is not registered, doing OP_UPDATE, %wZ to %wZ\n",
                    NCPABindingInfo->TdiProviderName,
                    &NotifyPnpElement->ElementName));
            (*(NotifyPnpElement->BindingHandler))(
                  TDI_PNP_OP_UPDATE,
                  NCPABindingInfo->TdiProviderName,
                  (PWSTR) (NotifyPnpElement->ListofProviders + NotifyPnpElement->NumberofEntries)
                  );
        } else {
            TDI_DEBUG(NCPA, ("Device is not registered, the BindHandler was NULL\n"));
        }

        return;

    }

DeviceNotRequired:

    //
    // We need to manufacture a NET_PNP_EVENT here.
    //
    RtlZeroMemory (NetEvent.TdiReserved, sizeof(NetEvent.TdiReserved));

    //
    // Depending on the NetEvent, we call a different handler.
    //
    switch (Operation) {

        case BIND:
           //
           // First check if the TDI Client is interested in the Provider
           //

            if (TdipMultiSzStrStr(
                                  NotifyPnpElement->ListofProviders,
                                  &ProviderElement->Specific.Device.DeviceName
                                  )) {
                TDI_DEBUG(NCPA, ("The Client %wZ is interested in provider %wZ\n",  &NotifyPnpElement->ElementName,
                                                                            &ProviderElement->Specific.Device.DeviceName
                                                                            ));

            } else {

                TDI_DEBUG(NCPA, ("RANDOM BIND CALL!!!\n"));
                TDI_DEBUG(NCPA, ("The Client %wZ is NOT interested in provider %wZ\n",  &NotifyPnpElement->ElementName,
                                                                            &ProviderElement->Specific.Device.DeviceName
                                                                            ));
            }


            if (NULL != NotifyPnpElement->BindingHandler) {

                TDI_LOG(LOG_NOTIFY, ("Pnp Bind %wZ to %wZ\n",
                        NCPABindingInfo->TdiProviderName,
                        &NotifyPnpElement->ElementName));

                (*(NotifyPnpElement->BindingHandler))(
                                                      TDI_PNP_OP_ADD,
                                                      NCPABindingInfo->TdiProviderName,
                                                      (PWSTR) (NotifyPnpElement->ListofProviders + NotifyPnpElement->NumberofEntries)
                                                      );
                //
                // Here we should also update the NotifyElement's buffer.
                //

            } else {

                TDI_DEBUG(NCPA, ("The BindHandler was NULL\n"));

            }

           break;

        case UNBIND:

           //
           // The plan is to do a QueryRemove first and then call UnBind.
           //

           if (NotifyPnpElement->PnpPowerHandler) {

              TDI_DEBUG(POWER, ("UNBind Handler Called!: First QueryRemoveDevice\n"));

              NetEvent.NetEvent = NetEventQueryRemoveDevice;
              NetEvent.Buffer = NULL;
              NetEvent.BufferLength = 0;

              // The TDI Client should look at the OpCode in NetEvent and decide how to use the buffer.
              Status = (*(NotifyPnpElement->PnpPowerHandler)) (
                    NCPABindingInfo->TdiProviderName,
                    &NetEvent,
                    NULL,
                    NULL
                    );

              if (STATUS_PENDING == Status) {
                 TDI_DEBUG(POWER, ("Client returned PENDING for QueryPower!\n"));
                 //DbgBreakPoint();
              }
           } else {
              TDI_DEBUG(NCPA, ("The PnpPowerHandler was NULL\n"));

           }

           //
           // OK, now call the UNBIND HANDLER anyway
           //

        case UNBIND_FORCE:

           // RDR returns PENDING all the time, we need a mechanism to fix this.
           // if (((STATUS_PENDING == Status) || (STATUS_SUCCESS == Status)) && (NULL != NotifyPnpElement->BindingHandler)) {
           if ((STATUS_SUCCESS == Status) && (NULL != NotifyPnpElement->BindingHandler)) {

              TDI_LOG(LOG_NOTIFY, ("Pnp Unbind %wZ from %wZ\n",
                      NCPABindingInfo->TdiProviderName,
                      &NotifyPnpElement->ElementName));

              (*(NotifyPnpElement->BindingHandler))(
                  TDI_PNP_OP_DEL,
                  NCPABindingInfo->TdiProviderName,
                  (PWSTR) (NotifyPnpElement->ListofProviders + NotifyPnpElement->NumberofEntries)
                  );
           } else {
              TDI_DEBUG(NCPA, ("The BindHandler was NULL\n"));
           }

           break;

        case RECONFIGURE:

           //
           // If the Reconfigure Buffer is NULL, we are notifying it of a NetEventBindList
           // Otherwise we are notifying it of a NetEventReconfig. Need to do the dirty work
           // of setting up the NET_PNP_EVENT accordingly.
           //
           TDI_DEBUG(POWER, ("Reconfigure Called.\n"));

           //
           // If the ReconfigBufferLength greater than 0, its Reconfig
           //
           if (NCPABindingInfo->ReconfigBufferSize) {

               NetEvent.BufferLength = NCPABindingInfo->ReconfigBufferSize;
                 NetEvent.Buffer = NCPABindingInfo->ReconfigBuffer;
                 NetEvent.NetEvent = NetEventReconfigure;

           } else {
               //
               // Else, its a BindOrder change
               //

               NetEvent.BufferLength = NCPABindingInfo->BindList->Length;
               NetEvent.Buffer = NCPABindingInfo->BindList->Buffer;
               NetEvent.NetEvent = NetEventBindList;

           }


           if (NotifyPnpElement->PnpPowerHandler) {

               // The TDI Client should look at the OpCode in NetEvent and decide how to use the buffer.

               TDI_LOG(LOG_NOTIFY, ("Pnp Reconfig %wZ to %wZ\n",
                       NCPABindingInfo->TdiProviderName,
                       &NotifyPnpElement->ElementName));

               Status = (*(NotifyPnpElement->PnpPowerHandler)) (
                                                                NCPABindingInfo->TdiProviderName,
                                                                &NetEvent,
                                                                NULL,
                                                                NULL
                                                                );
               if (STATUS_PENDING == Status) {
                   TDI_DEBUG(POWER, ("Client returned PENDING for QueryPower!\n"));
                   //DbgBreakPoint();
               }

           } else {
              TDI_DEBUG(NCPA, ("The PnpPowerHandler was NULL\n"));

           }

           break;

        case ADD_IGNORE_BINDING:
            {
                // We are being told to add a binding to a list of bindings
                // to ignore for this client.  These are bindings we will
                // not indicate to the client.
                //
                PWSTR pmszNewIgnoreList;

                ASSERT (NCPABindingInfo->BindList);

                // If a non-null bindlist was given...
                if (NCPABindingInfo->BindList)
                {
                    TDI_DEBUG(BIND, ("Adding the following multi-sz to the ignore list\n"));
                    //TdipPrintMultiSz (NCPABindingInfo->BindList->Buffer);

                    // We need to add some bindings to our list of
                    // bindings to ignore.
                    //
                    TdipAddMultiSzToMultiSz (NCPABindingInfo->BindList,
                            NotifyPnpElement->ListofBindingsToIgnore,
                            &pmszNewIgnoreList);

                    if (pmszNewIgnoreList)
                    {
                        // If we have a new list, free the old one.
                        //
                        if (NotifyPnpElement->ListofBindingsToIgnore)
                        {
                            ExFreePool (NotifyPnpElement->ListofBindingsToIgnore);
                        }
                        NotifyPnpElement->ListofBindingsToIgnore = pmszNewIgnoreList;

                        TDI_DEBUG(BIND, ("Printing new ignore list\n"));
                        TdipPrintMultiSz (NotifyPnpElement->ListofBindingsToIgnore);
                    }
                }
                break;
            }

        case DEL_IGNORE_BINDING:

            // We are being told to remove bindings from a list of bindings
            // to ignore for this client.  These are bindings we will
            // now indicate to the client if we need to.
            //

            // If we don't have a current list of bindings to ignore
            // or the bindlist sent was NULL then there is no work to do.
            // We assert on a NULL BindList because it shouldn't happen.

            ASSERT(NCPABindingInfo->BindList);
            if (NotifyPnpElement->ListofBindingsToIgnore &&
                    NCPABindingInfo->BindList)
            {
                TDI_DEBUG(BIND, ("Removing the following multi-sz from the ignore list\n"));
                //TdipPrintMultiSz (NCPABindingInfo->BindList->Buffer);

                // We need to remove some bindings from our list of bindings
                // to ignore.
                //
                TdipRemoveMultiSzFromMultiSz (NCPABindingInfo->BindList->Buffer,
                        NotifyPnpElement->ListofBindingsToIgnore);

                // If the list of bindings to ignore is now empty,
                // free the memory.
                //
                if (*NotifyPnpElement->ListofBindingsToIgnore)
                {
                    ExFreePool (NotifyPnpElement->ListofBindingsToIgnore);
                    NotifyPnpElement->ListofBindingsToIgnore = NULL;
                }

                TDI_DEBUG(BIND, ("Printing new ignore list\n"));
                TdipPrintMultiSz (NotifyPnpElement->ListofBindingsToIgnore);
            }
            break;
    }

    TDI_DEBUG(FUNCTION, ("---------------------------> -- TdiHandlePnpOperation!!\n"));

}

NTSTATUS
TdiExecuteRequest(
                IN CTEEvent     *Event,
                IN PVOID        pParams
    )

/*++
  Routine Description:

  Called by TdiHandleSerializedRequest to execute the request.
  It has been made another function, so that a worker thread can
  execute this function.

Parameters:
    CTEEvent (Event) : If this is NULL, it means that we have
                       been called directly from TdiHandleSerializedRequest.
                       Otherwise, it is called from the WorkerThread
    PVOID (pParams)  : This can NEVER be NULL. It tells this function
                       of the work that needs to be done.

Output:
    NT_STATUS.

--*/

{
    PTDI_PROVIDER_RESOURCE  ProviderElement, Context;
    PTDI_NOTIFY_COMMON      NotifyElement;
    KIRQL                   OldIrql;
    PLIST_ENTRY             List;
    PTDI_EXEC_PARAMS        pTdiExecParams, pNextParams = NULL;
    NTSTATUS                Status = STATUS_SUCCESS;
    PTDI_NOTIFY_PNP_ELEMENT PnpNotifyElement = NULL;

    TDI_DEBUG(FUNCTION2, ("++ TdiExecuteRequest\n"));

    // we are in trouble if pParams is NULL
    ASSERT(NULL != pParams);
    pTdiExecParams = (PTDI_EXEC_PARAMS) pParams;

    if (NULL == pTdiExecParams) {

       TDI_DEBUG(PARAMETERS, ("TDIExecRequest: params NULL\n"));
       DbgBreakPoint();

    }

    if(0x1234cdef != pTdiExecParams->Signature) {
       TDI_DEBUG(PARAMETERS, ("signature is BAD - %d not 0x1234cdef\r\n", pTdiExecParams->Signature));
       DbgBreakPoint();
    }


    KeAcquireSpinLock(
       &TDIListLock,
       &OldIrql
       );

    if (pTdiExecParams->Request.Event != NULL) {
        *(pTdiExecParams->CurrentThread) = PsGetCurrentThread();
    }

    // DEBUG TRACKING ++++++++++++++++++
    TrackExecs[NextExec].ExecParm = pTdiExecParams;
    TrackExecs[NextExec].Type = pTdiExecParams->Request.Type;
    TrackExecs[NextExec].Element = pTdiExecParams->Request.Element;
    TrackExecs[NextExec].Thread = pTdiExecParams->CurrentThread;
    if (++NextExec == EXEC_CNT) NextExec = 0;
    // DEBUG TRACKING ++++++++++++++++++

    PrevRequestType = pTdiExecParams->Request.Type;

    KeReleaseSpinLock(
        &TDIListLock,
        OldIrql
        );

    switch (pTdiExecParams->Request.Type) {

        case TDI_REGISTER_HANDLERS_PNP:

             // This is a client register bind or address handler request.

             // Insert this one into the registered client list.
            NotifyElement = (PTDI_NOTIFY_COMMON)pTdiExecParams->Request.Element;


            InsertTailList(
                pTdiExecParams->ClientList,
                &NotifyElement->Linkage
                );

            //
            // Generate the list of new TDI_OPEN_BLOCKS caused by the new
            // Client. If the provider isnt here, we set it to NULL for now.
            //
            TdipBuildProviderList(
                                  (PTDI_NOTIFY_PNP_ELEMENT) NotifyElement
                                  );

             // Call TdiNotifyNewClient to notify this new client of all
             // all existing providers.

            TdiNotifyNewPnpClient(
                pTdiExecParams->ProviderList,
                pTdiExecParams->Request.Element
                );

            break;

        case TDI_DEREGISTER_HANDLERS_PNP:

             // This is a client deregister request. Pull him from the
             // client list, free it, and we're done.

            NotifyElement = (PTDI_NOTIFY_COMMON)pTdiExecParams->Request.Element;

            CTEAssert(NotifyElement->Linkage.Flink != (PLIST_ENTRY)UlongToPtr(0xabababab));
            CTEAssert(NotifyElement->Linkage.Blink != (PLIST_ENTRY)UlongToPtr(0xefefefef));


            RemoveEntryList(&NotifyElement->Linkage);

            NotifyElement->Linkage.Flink = (PLIST_ENTRY)UlongToPtr(0xabababab);
            NotifyElement->Linkage.Blink = (PLIST_ENTRY)UlongToPtr(0xefefefef);

            // for the new handlers, we also have the name there.

            PnpNotifyElement = (PTDI_NOTIFY_PNP_ELEMENT)pTdiExecParams->Request.Element;

            // the name can be NULL, as in the case of TCP/IP.
            if (NULL != PnpNotifyElement->ElementName.Buffer) {
                ExFreePool(PnpNotifyElement->ElementName.Buffer);
            }

            if (NULL != PnpNotifyElement->ListofProviders) {
                ExFreePool(PnpNotifyElement->ListofProviders);
            }

            ExFreePool(NotifyElement);

            break;

        case TDI_REGISTER_PROVIDER_PNP:
            InterlockedIncrement((PLONG)&ProvidersRegistered);

        case TDI_REGISTER_DEVICE_PNP:

        case TDI_REGISTER_ADDRESS_PNP:

             // A provider is registering a device or address. Add him to
             // the appropriate provider list, and then notify all
             // existing clients of the new device.

            ProviderElement = (PTDI_PROVIDER_RESOURCE) pTdiExecParams->Request.Element;

            InsertTailList(
                pTdiExecParams->ProviderList,
                &ProviderElement->Common.Linkage
                );


             // Call TdiNotifyClientList to do the hard work.

            TdiNotifyPnpClientList(
                pTdiExecParams->ClientList,
                pTdiExecParams->Request.Element,
                TRUE
                );

            break;



        case TDI_DEREGISTER_PROVIDER_PNP:
                InterlockedDecrement((PLONG)&ProvidersRegistered);
         case TDI_DEREGISTER_DEVICE_PNP:
        case TDI_DEREGISTER_ADDRESS_PNP:

             // A provider device or address is deregistering. Pull the
             // resource from the provider list, and notify clients that
             // he's gone.

            ProviderElement = (PTDI_PROVIDER_RESOURCE)pTdiExecParams->Request.Element;

            CTEAssert(ProviderElement->Common.Linkage.Flink != (PLIST_ENTRY)UlongToPtr(0xabababab));
            CTEAssert(ProviderElement->Common.Linkage.Blink != (PLIST_ENTRY)UlongToPtr(0xefefefef));


            RemoveEntryList(&ProviderElement->Common.Linkage);

            ProviderElement->Common.Linkage.Flink = (PLIST_ENTRY) UlongToPtr(0xabababab);
            ProviderElement->Common.Linkage.Blink = (PLIST_ENTRY) UlongToPtr(0xefefefef);

            //
            // Dont have to tell the clients if this is a ProviderDeregister.
            //
            if (pTdiExecParams->Request.Type == TDI_DEREGISTER_PROVIDER_PNP) {

                if (ProviderElement->ProviderReady) {
                    InterlockedDecrement((PLONG)&ProvidersReady);
                }

            } else {

                TdiNotifyPnpClientList(
                    pTdiExecParams->ClientList,
                    pTdiExecParams->Request.Element,
                    FALSE
                    );

            }

             // Free the tracking structure we had.

            if  (pTdiExecParams->Request.Type == TDI_DEREGISTER_DEVICE_PNP) {
                ExFreePool(ProviderElement->Specific.Device.DeviceName.Buffer);
            }

            if (ProviderElement->DeviceName.Buffer) {
                ExFreePool(ProviderElement->DeviceName.Buffer);
                ProviderElement->DeviceName.Buffer = NULL;
                ProviderElement->DeviceName.Length = 0;
                ProviderElement->DeviceName.MaximumLength = 0;
            }

            if (ProviderElement->Context2) {
                ExFreePool(ProviderElement->Context2);
                ProviderElement->Context2 = NULL;
            }

            ExFreePool(ProviderElement);

            break;


        case TDI_REGISTER_PNP_POWER_EVENT:

             // Inform all the Clients of the Power Event, which has come from
             // a transport...

            ProviderElement = (PTDI_PROVIDER_RESOURCE)pTdiExecParams->Request.Element;


            /*
            KeInitializeEvent(
                        &ProviderElement->PowerSyncEvent,
                        SynchronizationEvent,
                        FALSE
                        );
            */
            //
            // Figure out how many clients we are going to inform.
            //
            {

               PLIST_ENTRY                Current;
               PTDI_NOTIFY_PNP_ELEMENT    NotifyPnpElement;

               ProviderElement->PowerHandlers = 1;

               Current = pTdiExecParams->ClientList->Flink;

               while (Current != pTdiExecParams->ClientList) {

                     NotifyPnpElement = CONTAINING_RECORD(
                                                          Current,
                                                          TDI_NOTIFY_PNP_ELEMENT,
                                                          Common.Linkage
                                                          );

                     // RESOURCE_POWER
                     if (NotifyPnpElement->PnpPowerHandler) {

                        ProviderElement->PowerHandlers++;
                     }
                     // Get the next one.

                     TDI_DEBUG(POWER, ("%d PowerCallBacks expected\n", ProviderElement->PowerHandlers));

                     Current = Current->Flink;
               }
            }

            TDI_LOG(LOG_POWER, ("%X, %d resources to notify\n",
                    ProviderElement, ProviderElement->PowerHandlers));

            Status = TdiNotifyPnpClientList(
                                            pTdiExecParams->ClientList,
                                            pTdiExecParams->Request.Element,
                                            FALSE            // NOP: this param is ignored
                                            );

            TDI_DEBUG(POWER, ("The client list returned %lx\n", Status));

            TDI_LOG(LOG_POWER, ("%X, NotityClients returned %X\n",
                    ProviderElement, Status));

            if (!InterlockedDecrement((PLONG)&ProviderElement->PowerHandlers)) {

               PTDI_PROVIDER_RESOURCE    Temp;

               TDI_DEBUG(POWER, ("Power Handlers All done...\n", ProviderElement->PowerHandlers));

               Temp =
               Context = *((PTDI_PROVIDER_RESOURCE *) ProviderElement->PnpPowerEvent->TdiReserved);

               //
               // Loop thru and see if there are any previous contexts associated
               // with this netpnp event, in which case, pop it.
               //

               Status = ProviderElement->Status;

               if (Temp->PreviousContext) {

                  while (Temp->PreviousContext) {

                     Context = Temp;
                     Temp = Temp->PreviousContext;

                  }

                  Context->PreviousContext = NULL; //pop the last guy

               } else {
                  //
                  // This was the only pointer in the TdiReserved and we dont need it anymore
                  //
                  RtlZeroMemory(ProviderElement->PnpPowerEvent->TdiReserved,
                                sizeof(ProviderElement->PnpPowerEvent->TdiReserved));
               }

               TDI_LOG(LOG_POWER, ("%X, pnp power complete, Call completion at %X\n",
                       ProviderElement, ProviderElement->PnPCompleteHandler));

               if (pTdiExecParams->Request.Pending && (*(ProviderElement->PnPCompleteHandler))) {
                   (*(ProviderElement->PnPCompleteHandler))(
                                                       ProviderElement->PnpPowerEvent,
                                                       ProviderElement->Status
                                                       );

               }

            } else {

                TDI_DEBUG(POWER, ("At least one of them is pending \n STATUS from ExecuteHAndler:%x\n", Status));

                TDI_LOG(LOG_POWER, ("%X, a client didn't complete pnp power sync\n",
                        ProviderElement));

            }

            TDI_DEBUG(POWER, ("<<<<NET NET NET>>>>> : Returning %lx\n", Status));

            break;

        case TDI_NDIS_IOCTL_HANDLER_PNP:

                TdiHandlePnpOperation(
                        pTdiExecParams->ClientList,
                        pTdiExecParams->Request.Element
                        );

                break;

        case TDI_ENUMERATE_ADDRESSES:

            // Insert this one into the registered client list.
            NotifyElement = (PTDI_NOTIFY_COMMON)pTdiExecParams->Request.Element;

            // Call TdiNotifyNewClient to notify this new client of all
            // all existing providers.

            TdiNotifyAddresses(
                               pTdiExecParams->ProviderList,
                               pTdiExecParams->Request.Element
                               );

            break;

        case TDI_PROVIDER_READY_PNP:
            //
            // Loop through and tell each client about it.
            //
            InterlockedIncrement((PLONG)&ProvidersReady);
            ProviderElement = (PTDI_PROVIDER_RESOURCE)pTdiExecParams->Request.Element;
            ProviderElement->ProviderReady = TRUE;
            TdiNotifyPnpClientList(
                pTdiExecParams->ClientList,
                pTdiExecParams->Request.Element,
                TRUE
                );

            break;

        default:
            
            TDI_DEBUG(ERROR, ("unknown switch statement\n"));

            KdBreakPoint();
            
            break;
    }

     // If there was an event specified with this request, signal
     // it now. This should only be a client deregister request, which
     // needs to block until it's completed.

    if (pTdiExecParams->Request.Event != NULL) {

        //
        // If we had this thread marked to prevent re-entrant requests, then
        // clear that. Note that we do this BEFORE we set the event below to
        // let the thread go, since it may immediately resubmit another request.
        //

        *(pTdiExecParams->CurrentThread) = NULL;

        KeSetEvent(pTdiExecParams->Request.Event, 0, FALSE);
    }

    KeAcquireSpinLock(
           &TDIListLock,
           &OldIrql
           );

    // DEBUG TRACKING ++++++++++++++++++
    TrackExecCompletes[NextExecComplete].ExecParm = pTdiExecParams;
    TrackExecCompletes[NextExecComplete].Type = pTdiExecParams->Request.Type;
    TrackExecCompletes[NextExecComplete].Element = pTdiExecParams->Request.Element;
    TrackExecCompletes[NextExecComplete].Thread = pTdiExecParams->CurrentThread;
    if (++NextExecComplete == EXEC_CNT) NextExecComplete = 0;
    // DEBUG TRACKING ++++++++++++++++++


    //
    // If this request occured on a worker thread
    // reset the EventScheduled to FALSE
    //

    if (Event != NULL) {

        EventScheduled = FALSE;
    }

    if (!IsListEmpty(pTdiExecParams->RequestList)) {

        if (EventScheduled == FALSE) {

            //
            // The following should indicate that no new events should be created.
            //

            EventScheduled = TRUE;

            // The request list isn't empty. Pull the next one from
            // the list and process it.

            List = RemoveHeadList(pTdiExecParams->RequestList);
            pNextParams = CONTAINING_RECORD(List, TDI_EXEC_PARAMS, Linkage);

            KeReleaseSpinLock(
                &TDIListLock,
                OldIrql
                );

            // Schedule a thread to deal with this work
            // To fix bug# 33975
            if(0x1234cdef != pNextParams->Signature) {
                TDI_DEBUG(PARAMETERS, ("2 Signature is BAD - %d not 0x1234cdef\r\n", pTdiExecParams->Signature));
                DbgBreakPoint();
            }

            ASSERT(pNextParams != NULL);
            ASSERT(0x1234cdef == pNextParams->Signature);

            PrevRequestType = pNextParams->Request.Type;

            CTEInitEvent(pNextParams->RequestCTEEvent, TdiExecuteRequest);
            CTEScheduleEvent(pNextParams->RequestCTEEvent, pNextParams);

        } else {

            KeReleaseSpinLock(
                &TDIListLock,
                OldIrql
                );
        }

        ExFreePool(pTdiExecParams);

    } else {

        // The request list is empty. Clear the flag and we're done.
        // IMP: Since Serializataion can be bypassed
        // (the TdiSerializeRequest allows one type of request to bypass 
        // serialization), 
        // we need to make sure there are no other worker threads 
        // currently processing TdiRequests

        if (pTdiExecParams->ResetSerializeFlag && EventScheduled == FALSE) {

            *(pTdiExecParams->SerializeFlag) = FALSE;
        } else {
            TDI_LOG(LOG_POWER, ("Not resetting serialized flag\n"));
        }

        PrevRequestType = 0;

        KeReleaseSpinLock(
            &TDIListLock,
            OldIrql
            );

        ExFreePool(pTdiExecParams);
    }


    TDI_DEBUG(FUNCTION2, ("-- TdiExecuteRequest\n"));

    return Status;

}


NTSTATUS
TdiHandleSerializedRequest (
    PVOID       RequestInfo,
    UINT        RequestType
)

/*++

Routine Description:

    Called when we want to process a request relating to one of the
    lists we manage. We look to see if we are currently processing such
    a request - if we are, we queue this for later. Otherwise we'll
    remember that we are doing this, and we'll process this request.
    When we're done we'll look to see if any more came in while we were
    busy.

Arguments:

    RequestInfo         - Reqeust specific information.
    RequestType         - The type of the request.

Return Value:

    Request completion status.


--*/

{
    KIRQL                   OldIrql;
    PLIST_ENTRY             ClientList;
    PLIST_ENTRY             ProviderList;
    PLIST_ENTRY             RequestList;
    PBOOLEAN                SerializeFlag;
    PETHREAD                *RequestThread;
    CTEEvent                *pEvent;
    PTDI_EXEC_PARAMS        pTdiExecParams;
    NTSTATUS                Status = STATUS_SUCCESS;
    PVOID                   pCallersAddress;
    PVOID                   pCallersCallers;
    PETHREAD                pCallerThread;

    TDI_DEBUG(FUNCTION2, ("++ TdiHandleSerializedRequest\n"));

    // Initialize tracking information
    RtlGetCallersAddress(&pCallersAddress, &pCallersCallers);
    pCallerThread = PsGetCurrentThread ();
    
    KeAcquireSpinLock(
        &TDIListLock,
        &OldIrql
        );

    // means PnP handlers
    if (RequestType > TDI_MAX_ADDRESS_REQUEST) {

        ClientList      = &PnpHandlerClientList;
        ProviderList    = &PnpHandlerProviderList;
        RequestList     = &PnpHandlerRequestList;
        SerializeFlag   = &PnpHandlerRequestInProgress;
        RequestThread   = &PnpHandlerRequestThread;
        pEvent          = &PnpHandlerEvent;

    } else {

       TDI_DEBUG(FUNCTION2, ("-- TdiHandleSerializedRequest\n"));
       TDI_DEBUG(PARAMETERS, ("TDIHANDLESERIALIZEDREQUEST: BAD Request!!\r\n"));

       KeReleaseSpinLock(
           &TDIListLock,
           OldIrql
           );

       return STATUS_UNSUCCESSFUL;
    }

    // We only need to allocate memory if this isn't a deregister call.
    if (RequestType != TDI_DEREGISTER_HANDLERS_PNP) {
        pTdiExecParams = (PTDI_EXEC_PARAMS)ExAllocatePoolWithTag(
                                                NonPagedPool,
                                                sizeof(TDI_EXEC_PARAMS),
                                                'aIDT'
                                                );

        if (NULL == pTdiExecParams) {

            KeReleaseSpinLock(
                &TDIListLock,
                OldIrql
                );

            TDI_DEBUG(FUNCTION2, ("-- TdiHandleSerializedRequest : INSUFFICIENT RESOURCES\n"));

            return STATUS_INSUFFICIENT_RESOURCES;

        }
    } else {
        // We preallocated memory during register for this deregister call
        // so that it won't fail sue to low memory conditions.
        pTdiExecParams = ((PTDI_NOTIFY_PNP_ELEMENT)RequestInfo)->pTdiDeregisterExecParams;
    }

    RtlZeroMemory(&pTdiExecParams->Request, sizeof(TDI_SERIALIZED_REQUEST));

    // Got the request.
    pTdiExecParams->Request.Element    = RequestInfo;
    pTdiExecParams->Request.Type       = RequestType;
    pTdiExecParams->Request.Event      = NULL;

    // marshal params into a structure
    // Set the Request Structure, so that we can process it in the TdiExecute function.
    pTdiExecParams->ClientList      = ClientList;
    pTdiExecParams->ProviderList    = ProviderList;
    pTdiExecParams->RequestList     = RequestList;
    pTdiExecParams->SerializeFlag   = SerializeFlag;
    pTdiExecParams->RequestCTEEvent = pEvent;
    pTdiExecParams->CurrentThread   = RequestThread;
    pTdiExecParams->Signature       = 0x1234cdef;
    pTdiExecParams->ResetSerializeFlag = TRUE;
    pTdiExecParams->pCallersAddress = pCallersAddress;
    pTdiExecParams->pCallersCaller = pCallersCallers;
    pTdiExecParams->pCallerThread = pCallerThread;


    // If we're not already here, handle it right away.

    if ((!(*SerializeFlag)) ||
        (((PrevRequestType == TDI_REGISTER_PNP_POWER_EVENT) ||
         (PrevRequestType == TDI_NDIS_IOCTL_HANDLER_PNP)) &&
          (RequestType == TDI_REGISTER_PNP_POWER_EVENT))  ) {

        if (*SerializeFlag == TRUE) {

            // A request is currently executing so don't
            // reset the serialize flag when this one
            // completes!!
            pTdiExecParams->ResetSerializeFlag = FALSE;
        }

        *SerializeFlag = TRUE;
        PrevRequestType = RequestType;

        // We're done with the lock for now, so free it.

        KeReleaseSpinLock(
            &TDIListLock,
            OldIrql
            );

         // Figure out and execute the type of request we have here.

         Status = TdiExecuteRequest(NULL, pTdiExecParams);

         TDI_LOG(LOG_REGISTER, ("-TdiSerialized sync\n"));

         return Status;

    } else {

        // We're already running, so we'll have to queue. If this is a
        // deregister bind or address notify call, we'll see if the issueing
        // thread is the same one that is currently busy. If so, we'll fail
        // to avoid deadlock. Otherwise for deregister calls we'll block until
        // it's done.

       //
        // For Nt5, we have devicename and a context coming in along with net addresses/device objects.
       // It is the transport's responsibility to ensure that these are correct.
       // The Register_PNP_Handlers on the other hand need not be made synch.
       //

        if (
            pTdiExecParams->Request.Type == TDI_DEREGISTER_HANDLERS_PNP ||
            pTdiExecParams->Request.Type == TDI_NDIS_IOCTL_HANDLER_PNP
            ) {

            // This is a deregister request. See if it's the same thread
            // that's busy. If not, block for it to complete.

            if (*RequestThread  == PsGetCurrentThread()) {

                // It's the same one, so give up now.
                KeReleaseSpinLock(
                                &TDIListLock,
                                OldIrql
                                );
                //
                // we only need to free memory if request type is not
                // TDI_DEREGISTER_HANDLERS_PNP since we only allocate memory
                // if request type is not TDI_DEREGISTER_HANDLERS_PNP.
                //
                if (pTdiExecParams->Request.Type != TDI_DEREGISTER_HANDLERS_PNP){
                    ExFreePool(pTdiExecParams);
                }

                TDI_DEBUG(FUNCTION2, ("-- TdiHandleSerializedRequest: Network Busy\n"));

                TDI_LOG(LOG_ERROR, ("-TdiSerializedRequest rc=busy\n"));

                return STATUS_NETWORK_BUSY;

            } else {
                // He's not currently busy, go ahead and block.

                KEVENT          Event;
                NTSTATUS        Status;

                KeInitializeEvent(
                            &Event,
                            SynchronizationEvent,
                            FALSE
                            );

                pTdiExecParams->Request.Event = &Event;

                // Put this guy on the end of the request list.

                InsertTailList(pTdiExecParams->RequestList, &pTdiExecParams->Linkage);

                KeReleaseSpinLock(
                                &TDIListLock,
                                OldIrql
                                );

                TDI_LOG(LOG_REGISTER, ("TdiSerializedRequest blocked\n"));

                Status = KeWaitForSingleObject(
                                            &Event,
                                            UserRequest,
                                            KernelMode,
                                            FALSE,
                                            NULL
                                            );

                // I don't know what we'd do is the wait failed....

                TDI_DEBUG(FUNCTION2, ("-- TdiHandleSerializedRequest\n"));

                TDI_LOG(LOG_REGISTER, ("-TdiSerializeRequest rc=0\n"));

                return STATUS_SUCCESS;
            }
        } else {

            // This isn't a deregister request, so there's no special handling
            // necessary. Just put the request on the end of the list.

            InsertTailList(pTdiExecParams->RequestList, &pTdiExecParams->Linkage);



            if (TDI_REGISTER_PNP_POWER_EVENT == pTdiExecParams->Request.Type) {

                //
                // For the PnP/PM event, there is now a completion handler, so
                // we can return pending here only for this case.
                // The other cases, we assume success.
                //

                pTdiExecParams->Request.Pending = TRUE;

                KeReleaseSpinLock(
                                &TDIListLock,
                                OldIrql
                                );


                TDI_DEBUG(FUNCTION2, ("-- TdiHandleSerializedRequest\n"));

                TDI_LOG(LOG_REGISTER, ("-TdiSerialzied Pending\n"));

                return STATUS_PENDING;

            }

            KeReleaseSpinLock(
                &TDIListLock,
                OldIrql
                );

            TDI_LOG(LOG_REGISTER, ("-TdiSerialized sync~sync\n"));

            return STATUS_SUCCESS;
        }
    }

}

NTSTATUS
TdiRegisterNotificationHandler(
    IN TDI_BIND_HANDLER     BindHandler,
    IN TDI_UNBIND_HANDLER   UnbindHandler,
    OUT HANDLE              *BindingHandle
)

/*++

Routine Description:

    This function is called when a TDI client wants to register for
    notification of the arrival of TDI providers. We allocate a
    TDI_NOTIFY_ELEMENT for the provider and then call the serialized
    worker routine to do the real work.

Arguments:

    BindHandler         - A pointer to the routine to be called when
                            a new provider arrives.
    UnbindHandler       - A pointer to the routine to be called when a
                            provider leaves.
    BindingHandle       - A handle we pass back that identifies this
                            client to us.

Return Value:

    The status of the attempt to register the client.

--*/


{

    TDI_CLIENT_INTERFACE_INFO tdiInterface;

    RtlZeroMemory(&tdiInterface, sizeof(tdiInterface));

    tdiInterface.MajorTdiVersion    =   1;
    tdiInterface.MinorTdiVersion    =   0;
    tdiInterface.BindHandler        =   BindHandler;
    tdiInterface.UnBindHandler      =   UnbindHandler;

    return (TdiRegisterPnPHandlers(
                    &tdiInterface,
                    sizeof(tdiInterface),
                    BindingHandle
                    ));

}

NTSTATUS
TdiDeregisterNotificationHandler(
    IN HANDLE               BindingHandle
)

/*++

Routine Description:

    This function is called when a TDI client wants to deregister a
    previously registered bind notification handler. All we really
    do is call TdiHandleSerializedRequest, which does the hard work.

Arguments:

    BindingHandle       - A handle we passed back to the client
                            on the register call. This is really
                            a pointer to the notify element.

Return Value:

    The status of the attempt to deregister the client.

--*/

{
    return (TdiDeregisterPnPHandlers(
                        BindingHandle));
}


NTSTATUS
TdiRegisterDeviceObject(
    IN PUNICODE_STRING      DeviceName,
    OUT HANDLE              *RegistrationHandle
)

/*++

Routine Description:

    Called when a TDI provider wants to register a device object.

Arguments:

    DeviceName          - Name of the device to be registered.

    RegistrationHandle  - A handle we pass back to the provider,
                            identifying this registration.

Return Value:

    The status of the attempt to register the provider.

--*/


{
    PTDI_PROVIDER_RESOURCE  NewResource;
    NTSTATUS                Status;
    PWCHAR                  Buffer;

    TDI_DEBUG(FUNCTION, ("++ TdiRegisterDeviceObject\n"));
    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    // First, try and allocate the needed resource.

    NewResource = (PTDI_PROVIDER_RESOURCE)ExAllocatePoolWithTag(
                                        NonPagedPool,
                                        sizeof(TDI_PROVIDER_RESOURCE),
                                        'cIDT'
                                        );

    // If we couldn't get it, fail the request.
    if (NewResource == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(NewResource, sizeof(TDI_PROVIDER_RESOURCE));

    // Try and get a buffer to hold the name.

    Buffer = (PWCHAR)ExAllocatePoolWithTag(
                                NonPagedPool,
                                DeviceName->MaximumLength,
                                'dIDT'
                                );

    if (Buffer == NULL) {
        ExFreePool(NewResource);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    // Fill in the basic stuff.
    NewResource->Common.Type = TDI_RESOURCE_DEVICE;
    NewResource->Specific.Device.DeviceName.MaximumLength =
                        DeviceName->MaximumLength;

    NewResource->Specific.Device.DeviceName.Buffer = Buffer;

    RtlCopyUnicodeString(
                        &NewResource->Specific.Device.DeviceName,
                        DeviceName
                        );

    *RegistrationHandle = (HANDLE)NewResource;

    TDI_DEBUG(PROVIDERS, ("Registering Device Object\n"));

    Status = TdiHandleSerializedRequest(
                        NewResource,
                        TDI_REGISTER_DEVICE_PNP
                        );

    CTEAssert(STATUS_SUCCESS == Status);

    if (STATUS_SUCCESS != Status) {
        ExFreePool(Buffer);
        ExFreePool(NewResource);
        *RegistrationHandle = NULL;
    }

    TDI_DEBUG(FUNCTION, ("-- TdiRegisterDeviceObject\n"));
    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    TDI_LOG(LOG_REGISTER, ("-RegisterDeviceObject rc=%X h=%X %wZ\n",
            Status, NewResource, DeviceName));

    return Status;

}

NTSTATUS
TdiDeregisterDeviceObject(
    IN HANDLE               RegistrationHandle
)

/*++

Routine Description:

    This function is called when a TDI provider want's to deregister
    a device object.

Arguments:

    RegistrationHandle  - A handle we passed back to the provider
                            on the register call. This is really
                            a pointer to the resource element.

Return Value:

    The status of the attempt to deregister the provider.

--*/

{
    NTSTATUS        Status;

    TDI_DEBUG(FUNCTION, ("++ TdiDERegisterDeviceObject\n"));
    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    CTEAssert(RegistrationHandle);

    Status = TdiHandleSerializedRequest(
                        RegistrationHandle,
                        TDI_DEREGISTER_DEVICE_PNP
                        );


    TDI_DEBUG(FUNCTION, ("-- TdiDERegisterDeviceObject\n"));
    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    TDI_LOG(LOG_REGISTER, ("TdiDeregisterDeviceObject rc=%d\n", Status));

    return Status;

}


NTSTATUS
TdiRegisterAddressChangeHandler(
    IN TDI_ADD_ADDRESS_HANDLER      AddHandler,
    IN TDI_DEL_ADDRESS_HANDLER      DeleteHandler,
    OUT HANDLE                      *BindingHandle
)

/*++

Routine Description:

    This function is called when a TDI client wants to register for
    notification of the arrival of network addresses. We allocate a
    TDI_NOTIFY_ELEMENT for the provider and then call the serialized
    worker routine to do the real work.

Arguments:

    AddHandler          - A pointer to the routine to be called when
                            a new address arrives.
    DeleteHandler       - A pointer to the routine to be called when an
                            address leaves.
    BindingHandle       - A handle we pass back that identifies this
                            client to us.

Return Value:

    The status of the attempt to register the client.

--*/


{
    TDI_CLIENT_INTERFACE_INFO tdiInterface;

    RtlZeroMemory(&tdiInterface, sizeof(tdiInterface));

    tdiInterface.MajorTdiVersion =      1;
    tdiInterface.MinorTdiVersion =      0;
    tdiInterface.AddAddressHandler =    AddHandler;
    tdiInterface.DelAddressHandler =    DeleteHandler;

    return (TdiRegisterPnPHandlers(
                    &tdiInterface,
                    sizeof(tdiInterface),
                    BindingHandle
                    ));

}

NTSTATUS
TdiDeregisterAddressChangeHandler(
    IN HANDLE               BindingHandle
)

/*++

Routine Description:

    This function is called when a TDI client wants to deregister a
    previously registered address change notification handler. All we
    really do is call TdiHandleSerializedRequest, which does the hard work.

Arguments:

    BindingHandle       - A handle we passed back to the client
                            on the register call. This is really
                            a pointer to the notify element.

Return Value:

    The status of the attempt to deregister the client.

--*/

{
    return (TdiDeregisterPnPHandlers(
                        BindingHandle));

}

NTSTATUS
TdiRegisterNetAddress(
    IN PTA_ADDRESS      Address,
    IN PUNICODE_STRING  DeviceName,
    IN PTDI_PNP_CONTEXT Context2,
    OUT HANDLE          *RegistrationHandle
)

/*++

Routine Description:

    Called when a TDI provider wants to register a new net address.

Arguments:

    Address         - New net address to be registered.
    Context1        - Protocol defined context1.  For example,
                      TCPIP will pass the list of IP addresses associated
                      with this device.
    Context2        - Protocol defined context2.  For example, TCPIP may pass
                      the PDO of the device on which this PnP event is being notified.

    RegistrationHandle  - A handle we pass back to the provider,
                            identifying this registration.

Return Value:

    The status of the attempt to register the provider.

--*/


{
    PTDI_PROVIDER_RESOURCE  NewResource;
    NTSTATUS                Status;

    TDI_DEBUG(FUNCTION, ("++ TdiRegisterNetAddress\n"));

    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    // First, try and allocate the needed resource.

    NewResource = (PTDI_PROVIDER_RESOURCE)ExAllocatePoolWithTag(
                                        NonPagedPool,
                                        FIELD_OFFSET(
                                            TDI_PROVIDER_RESOURCE,
                                            Specific.NetAddress
                                            ) +
                                        FIELD_OFFSET(TA_ADDRESS, Address) +
                                        Address->AddressLength,
                                        'eIDT'
                                        );

    // If we couldn't get it, fail the request.
    if (NewResource == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(
                  NewResource,
                  FIELD_OFFSET(
                               TDI_PROVIDER_RESOURCE,
                               Specific.NetAddress
                               ) +
                  FIELD_OFFSET(
                               TA_ADDRESS,
                               Address
                               ) +
                  Address->AddressLength
                  );

    // Fill in the basic stuff.
    NewResource->Common.Type = TDI_RESOURCE_NET_ADDRESS;
    NewResource->Specific.NetAddress.Address.AddressLength =
                        Address->AddressLength;

    NewResource->Specific.NetAddress.Address.AddressType =
                        Address->AddressType;

    RtlCopyMemory(
                NewResource->Specific.NetAddress.Address.Address,
                Address->Address,
                Address->AddressLength
                );

    *RegistrationHandle = (HANDLE)NewResource;


    // Now call HandleBindRequest to handle this one.

    // we have to fill in the contexts here

    if (DeviceName) {

        NewResource->DeviceName.Buffer = ExAllocatePoolWithTag(
                                                               NonPagedPool,
                                                               DeviceName->MaximumLength,
                                                               'uIDT'
                                                               );

        if (NULL == NewResource->DeviceName.Buffer) {

            ExFreePool(NewResource);
            return STATUS_INSUFFICIENT_RESOURCES;

        }

        RtlCopyMemory(
                      NewResource->DeviceName.Buffer,
                      DeviceName->Buffer,
                      DeviceName->MaximumLength
                      );

        NewResource->DeviceName.Length = DeviceName->Length;
        NewResource->DeviceName.MaximumLength = DeviceName->MaximumLength;

    } else {
        NewResource->DeviceName.Buffer = NULL;
    }

    if (Context2) {

        NewResource->Context2 = ExAllocatePoolWithTag(
                                                NonPagedPool,
                                                FIELD_OFFSET(TDI_PNP_CONTEXT, ContextData)
                                                + Context2->ContextSize,
                                                'vIDT'
                                                );
        if (NULL == NewResource->Context2) {

            if (NewResource->DeviceName.Buffer) {
                ExFreePool(NewResource->DeviceName.Buffer);
            }
            ExFreePool(NewResource);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        NewResource->Context2->ContextType = Context2->ContextType;
        NewResource->Context2->ContextSize = Context2->ContextSize;
        RtlCopyMemory(
                NewResource->Context2->ContextData,
                Context2->ContextData,
                Context2->ContextSize
                );
    } else {
        NewResource->Context2 = NULL;
    }

    Status = TdiHandleSerializedRequest(
                        NewResource,
                        TDI_REGISTER_ADDRESS_PNP
                        );


    CTEAssert(STATUS_SUCCESS == Status);

    if (STATUS_SUCCESS != Status) {

       *RegistrationHandle = NULL;

       TDI_DEBUG(ERROR, ("Freeing Contexts due to failure!!\n"));

        if (NewResource->DeviceName.Buffer) {
           TDI_DEBUG(ERROR, ("Freeing context1: %x", NewResource->DeviceName));

            ExFreePool(NewResource->DeviceName.Buffer);
            NewResource->DeviceName.Buffer = NULL;
        }

        if (NewResource->Context2) {
           TDI_DEBUG(ERROR, ("Freeing context2: %x", NewResource->Context2));

            ExFreePool(NewResource->Context2);
            NewResource->Context2 = NULL;
        }

        TDI_DEBUG(ERROR, ("Freeing Provider: %x", NewResource));

        ExFreePool(NewResource);
    }

    TDI_DEBUG(FUNCTION, ("-- TdiRegisterNetAddress\n"));

    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    TDI_LOG(LOG_REGISTER, ("-RegisterNetAddress rc=%d h=%X %wZ\n",
            Status, *RegistrationHandle, DeviceName));

    return Status;

}

NTSTATUS
TdiDeregisterNetAddress(
    IN HANDLE               RegistrationHandle
)

/*++

Routine Description:

    This function is called when a TDI provider wants to deregister
    a net addres.

Arguments:

    RegistrationHandle  - A handle we passed back to the provider
                            on the register call. This is really
                            a pointer to the resource element.

Return Value:

    The status of the attempt to deregister the provider.

--*/

{
    NTSTATUS            Status;

    TDI_DEBUG(FUNCTION, ("++ TdiDERegisterNetAddress\n"));

    CTEAssert(RegistrationHandle);

    if (NULL == RegistrationHandle) {
        TDI_DEBUG(ERROR, ("NULL Address Deregistration\n"));
    }

    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    CTEAssert(((PTDI_PROVIDER_RESOURCE)RegistrationHandle)->Common.Linkage.Flink != (PLIST_ENTRY)UlongToPtr(0xabababab));
    CTEAssert(((PTDI_PROVIDER_RESOURCE)RegistrationHandle)->Common.Linkage.Blink != (PLIST_ENTRY)UlongToPtr(0xefefefef));


    Status = TdiHandleSerializedRequest(
                        RegistrationHandle,
                        TDI_DEREGISTER_ADDRESS_PNP
                        );

    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    TDI_DEBUG(FUNCTION, ("-- TdiDERegisterNetAddress\n"));

    return Status;

}

// The PnP/PM extension code

NTSTATUS
TdiRegisterPnPHandlers(
    IN PTDI_CLIENT_INTERFACE_INFO ClientInterfaceInfo,
    IN ULONG InterfaceInfoSize,
    OUT HANDLE *BindingHandle
    )

/*++

Routine Description:

    This function is called when a TDI client wants to register
    its set of PnP/PM handlers

Arguments:

    ClientName
    BindingHandler
    AddAddressHandler
    DelAddressHandler
    PowerHandler
    BindingHandle

Return Value:

    The status of the client's attempt to register the handlers.

--*/
{
    PTDI_NOTIFY_PNP_ELEMENT NewElement;
    NTSTATUS                Status;
    PWCHAR                  Buffer = NULL;

    TDI_DEBUG(FUNCTION, ("++ TdiRegisterPnPHandlers\n"));

    //
    // Check that this is a TDI 2.0 Client
    //

    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    if (ClientInterfaceInfo->MajorTdiVersion > 2)
    {

       TDI_DEBUG(PROVIDERS, ("TDI Client: Bad Version!\n"));
        return TDI_STATUS_BAD_VERSION;

    }

    //
    // Check that ClientInfoLength is enough.
    //

    if (InterfaceInfoSize < sizeof(TDI_CLIENT_INTERFACE_INFO))
    {
       TDI_DEBUG(PROVIDERS, ("TDI Client Info length was incorrect\n"));
       return TDI_STATUS_BAD_CHARACTERISTICS;

    }

    // First, try and allocate the needed resource.

    NewElement = (PTDI_NOTIFY_PNP_ELEMENT)ExAllocatePoolWithTag(
                                        NonPagedPool,
                                        sizeof(TDI_NOTIFY_PNP_ELEMENT),
                                        'fIDT'
                                        );

    // If we couldn't get it, fail the request.
    if (NewElement == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Allocate space for the deregister exec request.
    NewElement->pTdiDeregisterExecParams = (PTDI_EXEC_PARAMS)ExAllocatePoolWithTag(
                                            NonPagedPool,
                                            sizeof(TDI_EXEC_PARAMS),
                                            'aIDT'
                                            );

    if (NULL == NewElement->pTdiDeregisterExecParams) {

        ExFreePool(NewElement);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(NewElement->pTdiDeregisterExecParams, sizeof (TDI_EXEC_PARAMS));

    // Try and get a buffer to hold the name, if required.

    if (NULL != ClientInterfaceInfo->ClientName) {

        Buffer = (PWCHAR)ExAllocatePoolWithTag(
                            NonPagedPool,
                            ClientInterfaceInfo->ClientName->MaximumLength,
                            'gIDT'
                            );


        if (Buffer == NULL) {
            ExFreePool(NewElement->pTdiDeregisterExecParams);
            ExFreePool(NewElement);
            return STATUS_INSUFFICIENT_RESOURCES;
        }


        NewElement->ElementName.Length = ClientInterfaceInfo->ClientName->Length;
        NewElement->ElementName.MaximumLength = ClientInterfaceInfo->ClientName->MaximumLength;
        NewElement->ElementName.Buffer = Buffer;

        RtlCopyUnicodeString(
                &NewElement->ElementName,
                ClientInterfaceInfo->ClientName
                );
    } else {

        NewElement->ElementName.Length = 0;
        NewElement->ElementName.MaximumLength = 0;
        NewElement->ElementName.Buffer = NULL;

    }

    // Fill in the basic stuff.

    NewElement->TdiVersion = ClientInterfaceInfo->TdiVersion;

    NewElement->Common.Type = TDI_NOTIFY_PNP_HANDLERS;

    if (TDI_VERSION_ONE == ClientInterfaceInfo->TdiVersion) {

        NewElement->Bind.BindHandler   = ClientInterfaceInfo->BindHandler;
        NewElement->Bind.UnbindHandler = ClientInterfaceInfo->UnBindHandler;
        NewElement->AddressElement.AddHandler = ClientInterfaceInfo->AddAddressHandler;
        NewElement->AddressElement.DeleteHandler = ClientInterfaceInfo->DelAddressHandler;
        NewElement->PnpPowerHandler = NULL;

    } else {

        NewElement->BindingHandler      = ClientInterfaceInfo->BindingHandler;
        NewElement->AddressElement.AddHandlerV2 = ClientInterfaceInfo->AddAddressHandlerV2;
        NewElement->AddressElement.DeleteHandlerV2 = ClientInterfaceInfo->DelAddressHandlerV2;
        NewElement->PnpPowerHandler = ClientInterfaceInfo->PnPPowerHandler;

    }

    NewElement->ListofBindingsToIgnore = NULL;

    // Now call HandleBindRequest to handle this one.

    *BindingHandle = (HANDLE)NewElement;

    TDI_DEBUG(PROVIDERS, ("TDI.SYS: Registering PnPHandlers ..."));

    Status = TdiHandleSerializedRequest(
                        NewElement,
                        TDI_REGISTER_HANDLERS_PNP
                        );

    CTEAssert(STATUS_SUCCESS == Status);

    if (Status != STATUS_SUCCESS) {

       if (Buffer) {
           ExFreePool(Buffer);
       }

       ExFreePool(NewElement->pTdiDeregisterExecParams);
       ExFreePool(NewElement);

       *BindingHandle = NULL;

       TDI_DEBUG(PROVIDERS, ("... NOT SUCCESS (%x)!\n", Status));

    } else {

        TDI_DEBUG(PROVIDERS, ("... SUCCESS!\n"));


    }

    TDI_DEBUG(FUNCTION, ("-- TdiRegisterPnPHandlers\n"));
    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    TDI_LOG(LOG_REGISTER, ("-RegisterPnpHandlers rc=%d h=%X %wZ\n",
            Status, *BindingHandle, ClientInterfaceInfo->ClientName));

    return Status;

}

VOID
TdiPnPPowerComplete(
    IN HANDLE BindingHandle,
    //IN PUNICODE_STRING DeviceName,
    IN PNET_PNP_EVENT PnpPowerEvent,
    IN NTSTATUS Status
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{

    PTDI_PROVIDER_RESOURCE Provider, Context;

    UNREFERENCED_PARAMETER(BindingHandle);
    
    TDI_DEBUG(FUNCTION, ("++ TdiPnPPowerComplete\n"));

    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    ASSERT (NULL != PnpPowerEvent);

    Context = *((PTDI_PROVIDER_RESOURCE *) PnpPowerEvent->TdiReserved);

    TDI_LOG(LOG_POWER, ("TdiPnpPowerComplete for %X\n", Context));

    if (NULL != Context) {


       while(Context->PreviousContext) {
          Context = Context->PreviousContext;
       }

       Provider = Context;

       ASSERT(Provider->PowerHandlers != 0);

       //
       // Return Status only if Status was not SUCCESS.
       //

       if (Status != STATUS_SUCCESS) {
          Provider->Status = Status;
       }

       if (!InterlockedDecrement((PLONG)&Provider->PowerHandlers)) {

          TDI_DEBUG(POWER, ("Calling ProtocolPnPCompletion handler\n"));
          

          if (Provider->PreviousContext) {

              while (Provider->PreviousContext) {

                  Context = Provider;
                  Provider = Provider->PreviousContext;

              }

              Context->PreviousContext = NULL; //pop the last guy
              Status = STATUS_SUCCESS;

          } else {
              //
              // This was the only pointer in the TdiReserved and we dont need it anymore
              //
              RtlZeroMemory(PnpPowerEvent->TdiReserved,
                            sizeof(PnpPowerEvent->TdiReserved));
          }


          if (Provider->PnPCompleteHandler != NULL) {

             TDI_LOG(LOG_POWER, ("%X, pnp power complete, Call completion at %X\n",
                      Provider, Provider->PnPCompleteHandler));


              (*(Provider->PnPCompleteHandler))(
                                                PnpPowerEvent,
                                                Status
                                                );

              TDI_DEBUG(POWER, ("Done calling %wZ's ProtocolPnPCompletion handler\n", &Provider->Specific.Device.DeviceName));

              TDI_DEBUG(POWER, ("The Previous Context at this point is %lx\n", Provider->PreviousContext));
              //DbgBreakPoint();

          }


          ExFreePool(Provider->Specific.Device.DeviceName.Buffer);

          if (Provider->Context1) {
              ExFreePool(Provider->Context1);
              Provider->Context1 = NULL;
          }

          if (Provider->Context2) {
              ExFreePool(Provider->Context2);
              Provider->Context2 = NULL;
          }

          ExFreePool(Provider); // free resources anyways

       } else {

           TDI_DEBUG(POWER, ("There are %d callbacks remaining for %wZ\n", Provider->PowerHandlers, &Provider->Specific.Device.DeviceName));

       }

    } else {

       TDI_DEBUG(POWER, ("This was called separately, so we just return\n"));

    }

    TDI_DEBUG(FUNCTION, ("-- TdiPnPPowerComplete\n"));
    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    return ;

}

NTSTATUS
TdiDeregisterPnPHandlers(
    IN HANDLE BindingHandle
    )

/*++

Routine Description:

Arguments:

Return Value:

    The status of the attempt to deregister the provider.

--*/
{
    NTSTATUS        Status;

    TDI_DEBUG(FUNCTION, ("++ TdiDERegisterPnPHandlers\n"));

    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    Status = TdiHandleSerializedRequest(
                        BindingHandle,
                        TDI_DEREGISTER_HANDLERS_PNP
        );

    TDI_DEBUG(FUNCTION, ("-- TdiDERegisterPnPHandlers\n"));

    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    return Status;
}


NTSTATUS
TdiPnPPowerRequest(
    IN PUNICODE_STRING DeviceName,
    IN PNET_PNP_EVENT PnpPowerEvent,
    IN PTDI_PNP_CONTEXT Context1,
    IN PTDI_PNP_CONTEXT Context2,
    IN ProviderPnPPowerComplete ProtocolCompletionHandler
    )

/*++

Routine Description:

Arguments:
      DeviceName
      PowerEvent: Choice of QUERYPOWER/SETPOWER

Return Value:

    The status of the attempt to deregister the provider.

--*/
{
    PTDI_PROVIDER_RESOURCE  NewResource, Context;
    NTSTATUS                Status;
    PWCHAR                  Buffer;

    TDI_DEBUG(FUNCTION, ("++ TdiPnPPowerRequest\n"));

    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    CTEAssert(ProtocolCompletionHandler);

    // First, try and allocate the needed resource.

    NewResource = (PTDI_PROVIDER_RESOURCE)ExAllocatePoolWithTag(
                                        NonPagedPool,
                                        sizeof(TDI_PROVIDER_RESOURCE),
                                        'hIDT'
                                        );

    // If we couldn't get it, fail the request.
    if (NewResource == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Try and get a buffer to hold the name.

    Buffer = (PWCHAR)ExAllocatePoolWithTag(
                                NonPagedPool,
                                DeviceName->MaximumLength,
                                'iIDT'
                                );

    if (Buffer == NULL) {
        ExFreePool(NewResource);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

     // Fill in the basic stuff.
    NewResource->Common.Type    = TDI_RESOURCE_POWER;
    NewResource->Specific.Device.DeviceName.MaximumLength =
                        DeviceName->MaximumLength;

    NewResource->Specific.Device.DeviceName.Buffer = Buffer;

    NewResource->PnPCompleteHandler = ProtocolCompletionHandler;

    Context =  *((PTDI_PROVIDER_RESOURCE *) PnpPowerEvent->TdiReserved);

    if (NULL == Context) {

       TDI_DEBUG(POWER, ("New NetPnP Event\n"));

        TDI_LOG(LOG_POWER, ("New pnp event %X, %wZ\n", NewResource, DeviceName));

       *((PVOID *) PnpPowerEvent->TdiReserved) = (PVOID) NewResource;

    } else {

       //
       // This NetPnp structure has looped thru before
       // Loop thru and find out the last one.
       //
       while (Context->PreviousContext) {
          Context = Context->PreviousContext;
       }

       Context->PreviousContext = NewResource;

       TDI_LOG(LOG_POWER, ("pnp event linking %X to %X, %wZ\n",
               Context, NewResource, DeviceName));
    }

    NewResource->PreviousContext = NULL;

    NewResource->PnpPowerEvent  = PnpPowerEvent;
    NewResource->Status     = STATUS_SUCCESS;

    // Note: These pointers must be good for the duration of this call.
    if (Context1) {

        NewResource->Context1 = ExAllocatePoolWithTag(
                                                NonPagedPool,
                                                FIELD_OFFSET(TDI_PNP_CONTEXT, ContextData)
                                                + Context1->ContextSize,
                                                'xIDT'
                                                );

        if (NULL == NewResource->Context1) {

            if (Context) {
                Context->PreviousContext = NULL;
            }

            ExFreePool(NewResource);
            ExFreePool(Buffer);
            return STATUS_INSUFFICIENT_RESOURCES;

        }

        NewResource->Context1->ContextSize = Context1->ContextSize;
        NewResource->Context1->ContextType = Context1->ContextType;

        RtlCopyMemory(
                NewResource->Context1->ContextData,
                Context1->ContextData,
                Context1->ContextSize
                );

    } else {
        NewResource->Context1 = NULL;
    }

    if (Context2) {

        NewResource->Context2 = ExAllocatePoolWithTag(
                                                NonPagedPool,
                                                FIELD_OFFSET(TDI_PNP_CONTEXT, ContextData)
                                                + Context2->ContextSize,
                                                'yIDT'
                                                );
        if (NULL == NewResource->Context2) {

            ExFreePool(Buffer);

            if (NewResource->Context1) {
                ExFreePool(NewResource->Context1);
            }

            if (Context) {

                Context->PreviousContext = NULL;
            }

            ExFreePool(NewResource);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        NewResource->Context2->ContextSize = Context2->ContextSize;
        NewResource->Context2->ContextType = Context2->ContextType;
        RtlCopyMemory(
                NewResource->Context2->ContextData,
                Context2->ContextData,
                Context2->ContextSize
                );

    } else {
        NewResource->Context2 = NULL;
    }


    RtlCopyUnicodeString(
                        &NewResource->Specific.Device.DeviceName,
                        DeviceName
                        );


    // Now call HandleBindRequest to handle this one.

    Status = TdiHandleSerializedRequest(
                        NewResource,
                        TDI_REGISTER_PNP_POWER_EVENT
                        );

    //
    // If TdiHandleSerialized returns PENDING, then the contexts and Resource
    // structures are freed up in the TdiPnPComplete call.
    //
    if (STATUS_PENDING != Status) {

        Status = NewResource->Status; // The status is stored in the newresource.

        ExFreePool(Buffer);

        if (NewResource->Context1) {
            ExFreePool(NewResource->Context1);
            NewResource->Context1 = NULL;
        }

        if (NewResource->Context2) {
            ExFreePool(NewResource->Context2);
            NewResource->Context2 = NULL;
        }

        if (Context) {
            Context->PreviousContext = NULL;
        }

        TDI_LOG(LOG_POWER, ("%X completed sync, Status %X\n",
                NewResource, Status));

        ExFreePool(NewResource); // free resources anyways

    }

    TDI_DEBUG(FUNCTION, ("-- TdiPnPPowerRequest : %lx\n", Status));
    
    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    return Status;

}


// This function is private between NDIS and TDI
NTSTATUS
TdiMakeNCPAChanges(
    IN TDI_NCPA_BINDING_INFO NcpaBindingInfo
    )

{
    UNREFERENCED_PARAMETER(NcpaBindingInfo);
    
    return STATUS_NOT_IMPLEMENTED;
}


//+---------------------------------------------------------------------------
//  Purpose: Count the number of bytes of a double NULL terminated
//           multi-sz, including all NULLs except for the final terminating
//           NULL.
//
//  Arguments:
//      pmsz [in] The multi-sz to count bytes for.
//
//  Returns: The count of bytes.
//
ULONG
TdipCbOfMultiSzSafe (
    IN PCWSTR pmsz)
{
    ULONG cchTotal = 0;
    ULONG cch;

    // NULL strings have zero length by definition.
    if (!pmsz)
    {
        return 0;
    }

    while (*pmsz)
    {
        cch = (ULONG) wcslen (pmsz) + 1;
        cchTotal += cch;
        pmsz += cch;
    }

    // Return the count of bytes.
    return cchTotal * sizeof (WCHAR);
}

//+---------------------------------------------------------------------------
//  Purpose: Search for a string in a multi-sz.
//
//  Arguments:
//      psz  [in] The string to search for.
//      pmsz [in] The multi-sz search in.
//
//  Returns: TRUE if string was found in the multi-sz.
//
BOOLEAN
TdipIsSzInMultiSzSafe (
    IN PCWSTR pszSearchString,
    IN PCWSTR pmsz)
{
    if (!pmsz || !pszSearchString)
    {
        return FALSE;
    }

    while (*pmsz)
    {
        if (0 == _wcsicmp (pmsz, pszSearchString))
        {
            return TRUE;
        }
        pmsz += wcslen (pmsz) + 1;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//  Purpose: Remove strings in a multi-sz list from an array of strings.
//
//  Arguments:
//      pmszToRemove    [in] The strings we need to remove.
//      pszArray        [inout] The array of strings to modify.
//      ItemsInArray    [in] The number of items in the array.
//      pRemainingItems [out] The number of items remaining in the array
//                            after we have removed all items that
//                            match pmszToRemove.
//
//  Returns: nothing
//
VOID
TdipRemoveMultiSzFromSzArray (
    IN PWSTR pmszToRemove,
    IN OUT PWSTR* pszArray,
    IN ULONG ItemsInArray,
    OUT ULONG* pRemainingItems)
{
    PWSTR pszScan;
    ULONG i, j;
    ULONG ItemsRemoved;

    ASSERT(pRemainingItems);

    *pRemainingItems = ItemsInArray;

    if (!pszArray || !pszArray[0] ||
            !pmszToRemove || !*pmszToRemove)
    {
        return;
    }

    // Go through the string array.
    //
    ItemsRemoved = 0;
    for (i = 0; pszArray[i]; i++)
    {
        // Check each string in the remove multi-sz against
        // the current array string.
        //
        pszScan = pmszToRemove;
        while (*pszScan)
        {
            if (0 == _wcsicmp (pszScan, pszArray[i]))
            {
                ItemsRemoved++;

                // The string needs to be removed.
                // Just move the indexes down one slot.
                //
                for (j = i; pszArray[j]; j++)
                {
                    pszArray[j] = pszArray[j + 1];
                }

                // If we removed the last item in the list, get out of the
                // loop. Note that the next entry is also NULL which
                // will cause us to get out of our paraent for loop as
                // well.
                //
                if (!pszArray[i])
                {
                    break;
                }

                // Reset the scan string since the current indexed
                // entry is now the next entry.  This means we run the
                // scan again.
                pszScan = pmszToRemove;
            }
            else
            {
                pszScan += wcslen (pszScan) + 1;
            }
        }
    }

    // Update the count of items in the array.
    *pRemainingItems = ItemsInArray - ItemsRemoved;
}

//+---------------------------------------------------------------------------
//  Purpose: Remove a multi-sz of strings from another multi-sz of strings.
//
//  Arguments:
//      pmszToRemove [in] The strings to remove.
//      pmszToModify [in] The list to modify.
//
//  Returns: nothing.
//
VOID
TdipRemoveMultiSzFromMultiSz (
    IN PCWSTR pmszToRemove,
    IN OUT PWSTR pmszToModify)
{
    BOOLEAN fRemoved;
    PCWSTR pszScan;
    if (!pmszToModify || !pmszToRemove || !*pmszToRemove)
    {
        return;
    }

    // Look for each pmszToRemove string in pmsz.  When it is found, move
    // the remaining part of the pmsz over it.
    //
    while (*pmszToModify)
    {
        fRemoved = FALSE;

        pszScan = pmszToRemove;
        while (*pszScan)
        {
            ULONG cchScan = (ULONG) wcslen (pszScan);
            if (0 == _wcsicmp (pmszToModify, pszScan))
            {
                PWSTR  pmszRemain = pmszToModify + cchScan + 1;

                // Count the remaining bytes including the final terminator;
                INT cbRemain = TdipCbOfMultiSzSafe (pmszRemain) + sizeof (WCHAR);

                RtlMoveMemory (pmszToModify, pmszRemain, cbRemain);

                fRemoved = TRUE;

                break;
            }
            pszScan += cchScan + 1;
        }

        // If we didn't remove the current modify string, advance our
        // pointer.
        //
        if (!fRemoved)
        {
            pmszToModify += wcslen (pmszToModify) + 1;
        }
    }
}


//+---------------------------------------------------------------------------
//  Purpose: Adds a multi-sz of strings to another multi-sz.
//
//  Arguments:
//      pUniStringToAdd -    [in] The Unicode string that contains the multisz.
//      pmszModify [in] The multi-sz to add to.
//
//  Returns: NT status code. Either STATUS_SUCCESS or
//           STATUS_INSUFFICIENT_RESOURCES
//
NTSTATUS
TdipAddMultiSzToMultiSz (
    IN PUNICODE_STRING pUniStringToAdd,
    IN PCWSTR pmszModify,
    OUT PWSTR* ppmszOut)
{
    NTSTATUS status = STATUS_SUCCESS;
    PCWSTR pszScan;
    ULONG cbNeeded;
    PCWSTR pmszAdd = NULL;

    ASSERT(ppmszOut);

    // Initialize the output parameters.
    //
    *ppmszOut = NULL;

    pmszAdd = pUniStringToAdd->Buffer;
    ASSERT(pmszAdd);

    // Validate the input - all multisz have 2 End -Of -String
    // characters at the end of the unicode string
    //
    {
        ULONG LenWchar = pUniStringToAdd->Length/2; // Length is in bytes
        if(LenWchar <= 2) // is Multisz long enough for our checks 
        {
            return (STATUS_INVALID_PARAMETER);
        }
        
        
        if (pmszAdd[LenWchar -1] != 0) // is Multisz null terminated
        {
            return (STATUS_INVALID_PARAMETER);
        }
        
        if (pmszAdd[LenWchar-2] != 0)  // is the last string in multisz null terminated
        {
            return (STATUS_INVALID_PARAMETER);
        }

    }
    // Go through the multi-sz to add and compute how much space we need.
    //
    
    for (pszScan = pmszAdd, cbNeeded = 0; *pszScan; pszScan += wcslen (pszScan) + 1)
    {
        // Check if the string is already present in the pmszModify.
        // If it is not, add its size to our total.
        if (!TdipIsSzInMultiSzSafe (pszScan, pmszModify))
        {
            cbNeeded += (ULONG) ((wcslen (pszScan) + 1) * sizeof (WCHAR));
        }
    }

    // If we have something to add...
    //
    if (cbNeeded)
    {
        ULONG cbDataSize;
        ULONG cbAllocSize;
        PWSTR pmszNew;

        // Get size of current multi-sz.
        cbDataSize = TdipCbOfMultiSzSafe (pmszModify);

        // Enough space for the old data plus the new string and NULL, and for the
        // second trailing NULL (multi-szs are double-terminated)
        cbAllocSize = cbDataSize + cbNeeded + sizeof (WCHAR);

        pmszNew = (PWSTR)ExAllocatePoolWithTag (
                NonPagedPool, cbAllocSize, 'jIDT');

        if (pmszNew)
        {
            ULONG cchOffset;

            cchOffset = cbDataSize / sizeof (WCHAR);
            RtlZeroMemory (pmszNew, cbAllocSize);

            // Copy the current buffer into the new buffer.
            RtlCopyMemory (pmszNew, pmszModify, cbDataSize);

            pszScan = pmszAdd;
            while (*pszScan)
            {
                // Check if the string is already present in the new buffer.
                if (!TdipIsSzInMultiSzSafe (pszScan, pmszNew))
                {
                    wcscpy (pmszNew + cchOffset, pszScan);
                    cchOffset += (ULONG) (wcslen (pmszNew +
                                                  cchOffset) + 1);
                }

                pszScan += wcslen (pszScan) + 1;
            }

            *ppmszOut = pmszNew;
        }
        else
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            TDI_DEBUG(ERROR, ("TdipAddMultiSzToMultiSz: Insufficient resources\n"));
        }
    }

    return status;
}

//+---------------------------------------------------------------------------
//  Purpose: Prints the contents of a multi-sz list.
//
//  Arguments:
//      pmsz [in] The multi-sz to print.
//
//  Returns: nothing.
//
#if DBG
VOID
TdipPrintMultiSz (
    IN PCWSTR pmsz)
{
    if (pmsz && *pmsz)
    {
        while (*pmsz)
        {
            TDI_DEBUG(BIND, ("%S\n", pmsz));
            pmsz += wcslen (pmsz) + 1;
        }
    }
}
#endif

BOOLEAN
TdipMultiSzStrStr(
        PWSTR *TdiClientBindingList,
        PUNICODE_STRING DeviceName
        )
{
    int i;

    TDI_DEBUG(FUNCTION2, ("++ TdipMultiSzStrStr\n"));

    // look for the string in the multiszstring
    if( TdiClientBindingList == NULL ) {
        return FALSE;
    }

    //
    // Check to see if this device is one of the devices
    //  we're interested in.
    //
    for( i=0; TdiClientBindingList[i]; i++ ) {
        if( DeviceName->Length / sizeof( WCHAR ) != wcslen( TdiClientBindingList[i] ) ) {
            continue;
        }
        if( _wcsnicmp( DeviceName->Buffer,
                      TdiClientBindingList[i],
                      DeviceName->Length / sizeof( WCHAR ) ) == 0 ) {
            break;
        }
    }

    //
    // If we hit the end of the list, then DeviceName is not a device we're
    //  interested in.
    //
    if( TdiClientBindingList[i] == NULL ) {

       TDI_DEBUG(FUNCTION2, ("-- TdipMultiSzStrStr: NULL\n"));

       return FALSE;
    }

    TDI_DEBUG(FUNCTION2, ("-- TdipMultiSzStrStr\n"));

    return TRUE;
}

VOID
TdipGetMultiSZList(
    OUT PWSTR **ListPointer,
    IN  PWSTR BaseKeyName,
    IN  PUNICODE_STRING DeviceName,
    IN  PWSTR Linkage,
    IN  PWSTR ParameterKeyName,
    OUT PUINT NumEntries
    )

/*++

Routine Description:

    This routine queries a registry value key for its MULTI_SZ values.

Arguments:

    ListPointer - Pointer to receive the pointer.
    ParameterKeyValue - Name of the value parameter to query.

Return Value:

    none.

--*/
{
    UNICODE_STRING unicodeKeyName;
    UNICODE_STRING unicodeParamPath;
    OBJECT_ATTRIBUTES objAttributes;
    HANDLE keyHandle;
    WCHAR  ParamBuffer[MAX_UNICODE_BUFLEN];

    ULONG lengthNeeded;
    ULONG i;
    ULONG numberOfEntries;
    NTSTATUS status;

    PWCHAR regEntry;
    PWCHAR dataEntry;
    PWSTR *ptrEntry;
    PCHAR newBuffer;
    PKEY_VALUE_FULL_INFORMATION infoBuffer = NULL;

    TDI_DEBUG(FUNCTION2, ("++ TdipGetMultiSzList\n"));

    unicodeParamPath.Length = 0;
    unicodeParamPath.MaximumLength = MAX_UNICODE_BUFLEN;
    unicodeParamPath.Buffer = ParamBuffer;

    // BaseKeyName :\\Registry\\Machine\\System\\CurrentControlSet\\Services\\";
    RtlAppendUnicodeToString(&unicodeParamPath, BaseKeyName);

    // Add DeviceName to it.
    RtlAppendUnicodeStringToString(&unicodeParamPath, DeviceName);

    // Add Linkage to it.
    RtlAppendUnicodeToString(&unicodeParamPath, Linkage);

    RtlInitUnicodeString( &unicodeKeyName, ParameterKeyName );

    InitializeObjectAttributes(
                        &objAttributes,
                        &unicodeParamPath,
                        OBJ_CASE_INSENSITIVE |
                        OBJ_KERNEL_HANDLE,
                        NULL,
                        NULL
                        );

    status = ZwOpenKey(
                    &keyHandle,
                    KEY_QUERY_VALUE,
                    &objAttributes
                    );

    if ( !NT_SUCCESS(status) ) {
        TDI_DEBUG(REGISTRY, ("tdi.sys Cannot open key: %x!!\n", status));
        goto use_default;
    }

    status = ZwQueryValueKey(
                        keyHandle,
                        &unicodeKeyName,
                        KeyValueFullInformation,
                        NULL,
                        0,
                        &lengthNeeded
                        );

    if ( status != STATUS_BUFFER_TOO_SMALL ) {
        ZwClose( keyHandle );
        TDI_DEBUG(REGISTRY, ("tdi.sys Cannot query buffer!!\n"));
        goto use_default;
    }

    infoBuffer = ExAllocatePoolWithTag(
                        NonPagedPool,
                        lengthNeeded,
                        'jIDT'
                        );

    if ( infoBuffer == NULL ) {
        ZwClose( keyHandle );
        TDI_DEBUG(REGISTRY, ("tdi.sys Cannot alloc buffer!!\n"));

        goto use_default;
    }

    status = ZwQueryValueKey(
                        keyHandle,
                        &unicodeKeyName,
                        KeyValueFullInformation,
                        infoBuffer,
                        lengthNeeded,
                        &lengthNeeded
                        );

    ZwClose( keyHandle );

    if ( !NT_SUCCESS(status) ) {
        TDI_DEBUG(REGISTRY, ("tdi.sys Cannot query buffer (2) !!\n"));

        goto freepool_and_use_default;
    }

    //
    // Figure out how many entries there are.
    //
    // numberOfEntries should be total number of entries + 1.  The extra
    // one is for the NULL sentinel entry.
    //

    lengthNeeded = infoBuffer->DataLength;
    if ( lengthNeeded <= sizeof(WCHAR) ) {

        //
        // No entries on the list.  Use default.
        //

        goto freepool_and_use_default;
    }

    dataEntry = (PWCHAR)((PCHAR)infoBuffer + infoBuffer->DataOffset);
    for ( i = 0, regEntry = dataEntry, numberOfEntries = 0;
        i < lengthNeeded;
        i += sizeof(WCHAR) ) {

        if ( *regEntry++ == L'\0' ) {
            numberOfEntries++;
        }
    }

    //
    // Allocate space needed for the array of pointers.  This is in addition
    // to the ones in the default list.
    //

    newBuffer = ExAllocatePoolWithTag(
                            NonPagedPool,
                            lengthNeeded +
                            (numberOfEntries) *
                            sizeof( PWSTR ),
                            'kIDT'
                            );

    if ( newBuffer == NULL ) {
        goto freepool_and_use_default;
    }

    //
    // Copy the names
    //

    regEntry = (PWCHAR)(newBuffer + (numberOfEntries) * sizeof(PWSTR));

    RtlCopyMemory(
            regEntry,
            dataEntry,
            lengthNeeded
            );

    //
    // Free the info buffer
    //

    ExFreePool(infoBuffer);

    ptrEntry = (PWSTR *) newBuffer;

    //
    // Build the array of pointers.  If numberOfEntries is 1, then
    // it means that the list is empty.
    //

    if ( numberOfEntries > 1 ) {

        *ptrEntry++ = regEntry++;

        //
        // Skip the first WCHAR and the last 2 NULL terminators.
        //

        for ( i = 3*sizeof(WCHAR) ; i < lengthNeeded ; i += sizeof(WCHAR) ) {
            if ( *regEntry++ == L'\0' ) {
                *ptrEntry++ = regEntry;
            }
        }
    }

    *ptrEntry = NULL;
    *ListPointer = (PWSTR *)newBuffer;
    TDI_DEBUG(FUNCTION2, ("-- TdipGetMultiSzList\n"));
    *NumEntries = numberOfEntries;
    return;

freepool_and_use_default:

    ExFreePool(infoBuffer);     // doesnt get freed otherwise

use_default:

    *ListPointer = NULL;
    *NumEntries = 0;
    TDI_DEBUG(REGISTRY, ("GetRegStrings: There was an error : returning NULL\r\n"));
    TDI_DEBUG(FUNCTION2, ("-- TdipGetMultiSzList: error\n"));

    return;

} // TdipGetMultiSZList


NTSTATUS
TdiPnPHandler(
    IN  PUNICODE_STRING         UpperComponent,
    IN  PUNICODE_STRING         LowerComponent,
    IN  PUNICODE_STRING         BindList,
    IN  PVOID                   ReconfigBuffer,
    IN  UINT                    ReconfigBufferSize,
    IN  UINT                    Operation
    )
{
    PTDI_NCPA_BINDING_INFO  NdisElement;
    NTSTATUS                Status = STATUS_SUCCESS;

    TDI_DEBUG(FUNCTION, ("++ TdiPnPHandler\n"));
    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    NdisElement = ExAllocatePoolWithTag(
                        NonPagedPool,
                        sizeof(TDI_NCPA_BINDING_INFO),
                        'kIDT'
                        );

    if (NdisElement == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NdisElement->TdiClientName      = UpperComponent;
    NdisElement->TdiProviderName    = LowerComponent;
    NdisElement->BindList           = BindList;
    NdisElement->ReconfigBuffer     = ReconfigBuffer;
    NdisElement->ReconfigBufferSize = ReconfigBufferSize;
    NdisElement->PnpOpcode          = Operation;

    Status = TdiHandleSerializedRequest(
                NdisElement,
                TDI_NDIS_IOCTL_HANDLER_PNP
                );

    ExFreePool(NdisElement);

    TDI_DEBUG(FUNCTION, ("-- TdiPnPHandler\n"));
    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    return Status;

}


/*++

Routine Description:
    Call the AddAddress handler of the client along with all the
    registered TDI addresses.

Arguments:

    Input: Handle to the client context
    Output: NTSTATUS = Success/Failure

Return Value:

    none.

--*/

NTSTATUS
TdiEnumerateAddresses(
    IN HANDLE BindingHandle
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;

    TDI_DEBUG(FUNCTION, ("++ TdiEnumerateAddresses\n"));

    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    // Now call HandleBindRequest to handle this one.

    Status = TdiHandleSerializedRequest(
                        BindingHandle,
                        TDI_ENUMERATE_ADDRESSES
                        );

    TDI_DEBUG(FUNCTION, ("-- TdiEnumerateAddresses\n"));
    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    TDI_LOG(LOG_REGISTER, ("-TdiEnumerateAddresses %d\n", Status));

    return Status;

}

/*++

Routine Description:
    Register a generic provider with TDI.
    Each transport is a provider and teh devices that it registers are
    what constitute a transport. When a transport thinks it has all the
    devices ready, it calls TdiNetReady API.

Arguments:

    Input: Device Name
    Output: Handle to be used in future references.

Return Value:

none.

*/
NTSTATUS
TdiRegisterProvider(
    PUNICODE_STRING ProviderName,
    HANDLE  *ProviderHandle
    )
{

    PTDI_PROVIDER_RESOURCE  NewResource;
    NTSTATUS                Status;
    PWCHAR                  Buffer;

    TDI_DEBUG(FUNCTION, ("++ TdiRegisterProvider\n"));

    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    // make sure that the transports arent screwing us.
    CTEAssert(ProviderName);
    CTEAssert(ProviderName->Buffer);
    CTEAssert(ProviderHandle);

    TDI_DEBUG(PROVIDERS, (" %wZ provider is being Registered\n", ProviderName));

    // First, try and allocate the needed resource.
    NewResource = (PTDI_PROVIDER_RESOURCE)ExAllocatePoolWithTag(
                                        NonPagedPool,
                                        sizeof(TDI_PROVIDER_RESOURCE),
                                        'cIDT'
                                        );

    // If we couldn't get it, fail the request.
    if (NewResource == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Try and get a buffer to hold the name.
    Buffer = (PWCHAR)ExAllocatePoolWithTag(
                                NonPagedPool,
                                ProviderName->MaximumLength,
                                'dIDT'
                                );

    if (Buffer == NULL) {
        ExFreePool(NewResource);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Fill in the basic stuff.
    RtlZeroMemory(
                  NewResource,
                  sizeof(TDI_PROVIDER_RESOURCE)
                  );

    NewResource->Common.Type = TDI_RESOURCE_PROVIDER;
    NewResource->Specific.Device.DeviceName.MaximumLength =
                        ProviderName->MaximumLength;

    NewResource->Specific.Device.DeviceName.Buffer = Buffer;

    RtlCopyUnicodeString(
                        &NewResource->Specific.Device.DeviceName,
                        ProviderName
                        );

    *ProviderHandle = (HANDLE)NewResource;

    TDI_DEBUG(PROVIDERS, ("Registering Device Object\n"));


    NewResource->Context1 = NULL;
    NewResource->Context2 = NULL;

    Status = TdiHandleSerializedRequest(
                        NewResource,
                        TDI_REGISTER_PROVIDER_PNP
                        );

    CTEAssert(STATUS_SUCCESS == Status);

    if (STATUS_SUCCESS != Status) {
        ExFreePool(Buffer);
        ExFreePool(NewResource);
        *ProviderHandle = NULL;
    }


    TDI_DEBUG(FUNCTION, ("-- TdiRegisterProvider\n"));

    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    TDI_LOG(LOG_REGISTER, ("-RegisterProvider rc=%d h=%X %wZ\n",
            Status, *ProviderHandle, ProviderName));

    return Status;

}


/*++

Routine Description:
    Indicate that a registered provider is ready.
    This means that it thinks that all its devices are
    ready to be used.

Arguments:

    Input: Handle to the client context
    Output: NTSTATUS = Success/Failure

Return Value:

    none.


*/
NTSTATUS
TdiProviderReady(
    HANDLE      ProviderHandle
    )
{

    PTDI_PROVIDER_RESOURCE  ProvResource = ProviderHandle;
    NTSTATUS                Status;

    TDI_DEBUG(FUNCTION, ("++ TdiProviderReady\n"));

    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    CTEAssert(ProviderHandle);

    TDI_DEBUG(PROVIDERS, (" %wZ provider is READY\n", &ProvResource->Specific.Device.DeviceName));

    CTEAssert(!ProvResource->ProviderReady); // doing it twice?


    Status = TdiHandleSerializedRequest(
                    ProvResource,
                    TDI_PROVIDER_READY_PNP
                    );

    TDI_DEBUG(FUNCTION, ("-- TdiProviderReady\n"));

    CTEAssert(KeGetCurrentIrql() < DISPATCH_LEVEL);

    TDI_LOG(LOG_REGISTER, ("-TdiProviderReady rc=%d %wZ\n",
            Status, &ProvResource->Specific.Device.DeviceName));

    return Status;

}


/*++

Routine Description:
    Deregister a generic provider with TDI.

Arguments:

    Inpute: Handle to the provider structure.

Return Value:

    none.


*/
NTSTATUS
TdiDeregisterProvider(
    HANDLE  ProviderHandle
    )
{

    PTDI_PROVIDER_RESOURCE  ProvResource = ProviderHandle;
    NTSTATUS                Status;

    TDI_DEBUG(FUNCTION, ("++ TdiDeregisterProvider\n"));

    CTEAssert(ProviderHandle);

    TDI_DEBUG(PROVIDERS, (" %wZ provider is being Deregistered\n", &ProvResource->Specific.Device.DeviceName));

    Status = TdiHandleSerializedRequest(
                    ProvResource,
                    TDI_DEREGISTER_PROVIDER_PNP
                    );

    TDI_DEBUG(FUNCTION, ("-- TdiDeregisterProvider\n"));

    return Status;

}

//
// Input:   New Client
//          Pointer to the OpenList
// Output:  success/failure (boolean)
//
// This function takes in the new client and builds all the OPEN structures that
// need to be built (all the providers that this client is bound to). If the
// provider doesnt exist at this time, we just point it to NULL and change it
// when the provider (deviceobject) registers itself.
//
//

BOOLEAN
TdipBuildProviderList(
                  PTDI_NOTIFY_PNP_ELEMENT    NotifyElement
                  )
{
    TDI_DEBUG(FUNCTION2, ("++ TdipBuildOpenList\n"));

    TdipGetMultiSZList(
                &NotifyElement->ListofProviders,
                StrRegTdiBindingsBasicPath,
                &NotifyElement->ElementName,
                StrRegTdiLinkage,
                StrRegTdiBindList,
                (PUINT) &NotifyElement->NumberofEntries
                );

    // look for the string in the multiszstring
    if (NotifyElement->ListofProviders == NULL) {
        return FALSE;
    }

    TDI_DEBUG(BIND, ("Added %d Entries\n", NotifyElement->NumberofEntries));

    TDI_DEBUG(FUNCTION2, ("-- TdipBuildOpenList\n"));
    return TRUE;

}

//
// Takes provider (devicename) and returns a pointer to the
// internal provider structure if it exists.
//
PTDI_PROVIDER_RESOURCE
LocateProviderContext(
                      PUNICODE_STRING   ProviderName
                      )
{

    PLIST_ENTRY                 Current;
    PTDI_PROVIDER_RESOURCE      ProviderElement = NULL;

    TDI_DEBUG(FUNCTION2, ("++ LocateProviderContext\n"));

    Current = PnpHandlerProviderList.Flink;

    while (Current != &PnpHandlerProviderList) {

        ProviderElement = CONTAINING_RECORD(
                                            Current,
                                            TDI_PROVIDER_RESOURCE,
                                            Common.Linkage
                                            );

        if (ProviderElement->Common.Type != TDI_RESOURCE_DEVICE) {
            Current = Current->Flink;
            continue;
        }

        if (!RtlCompareUnicodeString(
                              ProviderName,
                              &ProviderElement->Specific.Device.DeviceName,
                              TRUE)) {
            TDI_DEBUG(BIND, ("Provider is registered with TDI\n"));
            break;

        }

        Current = Current->Flink;

    }

    TDI_DEBUG(FUNCTION2, ("-- LocateProviderContext\n"));

    return ProviderElement;
}

#if DBG

//
// Cool new memory logging functions added to keep track of the store
// and forward functionality in TDI (while debugging).
//

VOID
DbgMsgInit()
{

    First = 0;
    Last = 0;

    CTEInitLock(&DbgLock);

}

VOID
DbgMsg(CHAR *Format, ...)
{
    va_list         Args;
    CTELockHandle   LockHandle;
    CHAR            Temp[MAX_MSG_LEN];
    LONG           numCharWritten;

    va_start(Args, Format);

    numCharWritten = _vsnprintf(Temp, MAX_MSG_LEN, Format, Args);

    if (numCharWritten < 0)
    {
        return;
    }

    // Zero Terminate the string
    //
    Temp[numCharWritten] = '\0';

    if (TdiLogOutput & LOG_OUTPUT_DEBUGGER)
    {
        DbgPrint(Temp);
    }

    if (TdiLogOutput & LOG_OUTPUT_BUFFER)
    {
        CTEGetLock(&DbgLock, &LockHandle);

        RtlZeroMemory(DbgMsgs[Last], MAX_MSG_LEN);
        strcpy(DbgMsgs[Last], Temp);

        Last++;

        if (Last == LOG_MSG_CNT)
            Last = 0;

        if (First == Last) {
            First++;
            if (First == LOG_MSG_CNT)
                First = 0;
        }

        CTEFreeLock(&DbgLock, LockHandle);
    }

    va_end(Args);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sys\cxport.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    cxport.c

Abstract:

    Common Transport Environment utility functions for the NT environment

Author:

    Mike Massa (mikemas)           Aug 11, 1993

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     08-11-93    created

Notes:

--*/

#pragma warning(push)
#pragma warning(disable:4115) // named type definition in parentheses ntddk.h
#include <ntddk.h>
#pragma warning(pop)

#include <ndis.h>
#include <cxport.h>
#include <tdistat.h>


//
// Mark pageable code
//
#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, CTELogEvent)

#endif // ALLOC_PRAGMA


//
// Local variables
//
ULONG CTEpTimeIncrement = 0;   // used to convert kernel clock ticks to 100ns.
LIST_ENTRY CTEBlockListHead;
KSPIN_LOCK CTEBlockSpinLock;

    // Used in the conversion of 100ns times to milliseconds.
static LARGE_INTEGER Magic10000 = {0xe219652c, 0xd1b71758};



//
// Macros
//
//++
//
// LARGE_INTEGER
// CTEConvertMillisecondsTo100ns(
//     IN LARGE_INTEGER MsTime
//     );
//
// Routine Description:
//
//     Converts time expressed in hundreds of nanoseconds to milliseconds.
//
// Arguments:
//
//     MsTime - Time in milliseconds.
//
// Return Value:
//
//     Time in hundreds of nanoseconds.
//
//--

#define CTEConvertMillisecondsTo100ns(MsTime) \
            RtlExtendedIntegerMultiply(MsTime, 10000)


//++
//
// LARGE_INTEGER
// CTEConvert100nsToMilliseconds(
//     IN LARGE_INTEGER HnsTime
//     );
//
// Routine Description:
//
//     Converts time expressed in hundreds of nanoseconds to milliseconds.
//
// Arguments:
//
//     HnsTime - Time in hundreds of nanoseconds.
//
// Return Value:
//
//     Time in milliseconds.
//
//--

#define SHIFT10000 13
extern LARGE_INTEGER Magic10000;

#define CTEConvert100nsToMilliseconds(HnsTime) \
            RtlExtendedMagicDivide((HnsTime), Magic10000, SHIFT10000)


//
// Local functions
//
VOID
CTEpInitialize(
    VOID
    )
/*++

Routine Description:

    Initializes internal module state.

Arguments:

    None.

Return Value:

    None.

--*/

{
    CTEpTimeIncrement = KeQueryTimeIncrement();
    KeInitializeSpinLock(&CTEBlockSpinLock);
    InitializeListHead(&CTEBlockListHead);
}

VOID
CTEpEventHandler(
    IN PVOID  Context
    )
/*++

Routine Description:

    Internal handler for scheduled CTE Events. Conforms to calling convention
    for ExWorkerThread handlers. Calls the CTE handler registered for this
    event.

Arguments:

    Context  - Work item to process.

Return Value:

    None.

--*/

{
    CTEEvent      *Event;
    CTELockHandle  Handle;
    CTEEventRtn    Handler;
    PVOID          Arg;


#if DBG
    KIRQL StartingIrql;

    StartingIrql = KeGetCurrentIrql();
#endif

    Event = (CTEEvent *) Context;

    CTEGetLock(&(Event->ce_lock), &Handle);
    ASSERT(Event->ce_scheduled);
    Handler = Event->ce_handler;
    Arg = Event->ce_arg;
    Event->ce_scheduled = 0;
    CTEFreeLock(&(Event->ce_lock), Handle);

    Handler(Event, Arg);

#if DBG
    if (KeGetCurrentIrql() != StartingIrql) {
        DbgPrint(
            "CTEpEventHandler: routine %lx , event %lx returned at raised IRQL\n",
            Handler, Event
            );
        DbgBreakPoint();
    }
#endif
}


VOID
CTEpTimerHandler(
    IN PKDPC  Dpc,
    IN PVOID  DeferredContext,
    IN PVOID  SystemArgument1,
    IN PVOID  SystemArgument2
    )
/*++

Routine Description:

    Internal handler for scheduled CTE Timers. Conforms to calling convention
    for NT DPC handlers. Calls the CTE handler registered for this timer.

Arguments:

    Dpc              - Pointer to the DPC routine being run.
    DeferredContext  - Private context for this instance of the DPC.
    SystemArgument1  - Additional argument.
    SystemArgument2  - Additional argument.

Return Value:

    None.

--*/

{
    CTETimer *Timer;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    Timer = (CTETimer *) DeferredContext;
    (*Timer->t_handler)((CTEEvent *)Timer, Timer->t_arg);
}


//
// Exported functions.
//
int
CTEInitialize(
    VOID
    )

/*++

Routine Description:

    An empty initialization routine for backward compatibility.

Arguments:

    None.

Return Value:

    Non-zero.

--*/

{
    return 1;
}

void
CTEInitEvent(
    CTEEvent    *Event,
    CTEEventRtn  Handler
    )
/*++

Routine Description:

    Initializes a CTE Event variable.

Arguments:

    Event   - Event variable to initialize.
    Handler - Handler routine for this event variable.

Return Value:

    None.

--*/

{
    ASSERT(Handler != NULL);

    Event->ce_handler = Handler;
    Event->ce_scheduled = 0;
    CTEInitLock(&(Event->ce_lock));
    ExInitializeWorkItem(&(Event->ce_workitem), CTEpEventHandler, Event);
}


int
CTEScheduleCriticalEvent(
    IN CTEEvent    *Event,
    IN void        *Argument  OPTIONAL
    )

/*++

Routine Description:

    Schedules a routine to be executed later in a different context. In the
    NT environment, the event is implemented using Executive worker threads.

Arguments:

    Event    - Pointer to a CTE Event variable
    Argument - An argument to pass to the event handler when it is called

Return Value:

    0 if the event could not be scheduled. Nonzero otherwise.

--*/

{
    CTELockHandle  Handle;
    
    CTEGetLock(&(Event->ce_lock), &Handle);

    if (!(Event->ce_scheduled)) {
        Event->ce_scheduled = 1;
        Event->ce_arg = Argument;

        ExQueueWorkItem(
            &(Event->ce_workitem),
            CriticalWorkQueue
            );
    }

    CTEFreeLock(&(Event->ce_lock), Handle);

    return(1);
}


int
CTEScheduleEvent(
    IN CTEEvent    *Event,
    IN void        *Argument  OPTIONAL
    )

/*++

Routine Description:

    Schedules a routine to be executed later in a different context. In the
    NT environment, the event is implemented using Executive worker threads.

Arguments:

    Event    - Pointer to a CTE Event variable
    Argument - An argument to pass to the event handler when it is called

Return Value:

    0 if the event could not be scheduled. Nonzero otherwise.

--*/

{
    CTELockHandle  Handle;

    CTEGetLock(&(Event->ce_lock), &Handle);

    if (!(Event->ce_scheduled)) {
        Event->ce_scheduled = 1;
        Event->ce_arg = Argument;

        ExQueueWorkItem(
            &(Event->ce_workitem),
            DelayedWorkQueue
            );
    }

    CTEFreeLock(&(Event->ce_lock), Handle);

    return(1);
}




int
CTEScheduleDelayedEvent(
    IN CTEEvent    *Event,
    IN void        *Argument  OPTIONAL
    )

/*++

Routine Description:

    Schedules a routine to be executed later in a different context. In the
    NT environment, the event is implemented using Executive worker threads.

Arguments:

    Event    - Pointer to a CTE Event variable
    Argument - An argument to pass to the event handler when it is called

Return Value:

    0 if the event could not be scheduled. Nonzero otherwise.

--*/

{
    CTELockHandle  Handle;

    CTEGetLock(&(Event->ce_lock), &Handle);

    if (!(Event->ce_scheduled)) {
        Event->ce_scheduled = 1;
        Event->ce_arg = Argument;

        ExQueueWorkItem(
            &(Event->ce_workitem),
            DelayedWorkQueue
            );
    }

    CTEFreeLock(&(Event->ce_lock), Handle);

    return(1);
}

void
CTEInitTimer(
    CTETimer    *Timer
    )
/*++

Routine Description:

    Initializes a CTE Timer variable.

Arguments:

    Timer   - Timer variable to initialize.

Return Value:

    None.

--*/

{
    Timer->t_handler = NULL;
    Timer->t_arg = NULL;
    KeInitializeDpc(&(Timer->t_dpc), CTEpTimerHandler, Timer);
    KeInitializeTimer(&(Timer->t_timer));
}


void *
CTEStartTimer(
    CTETimer      *Timer,
    unsigned long  DueTime,
    CTEEventRtn    Handler,
    void          *Context
    )

/*++

Routine Description:

    Sets a CTE Timer for expiration.

Arguments:

    Timer    - Pointer to a CTE Timer variable.
    DueTime  - Time in milliseconds after which the timer should expire.
    Handler  - Timer expiration handler routine.
    Context  - Argument to pass to the handler.

Return Value:

    0 if the timer could not be set. Nonzero otherwise.

--*/

{
    LARGE_INTEGER  LargeDueTime;

    ASSERT(Handler != NULL);

    //
    // Convert milliseconds to hundreds of nanoseconds and negate to make
    // an NT relative timeout.
    //
    LargeDueTime.HighPart = 0;
    LargeDueTime.LowPart = DueTime;
    LargeDueTime = CTEConvertMillisecondsTo100ns(LargeDueTime);
    LargeDueTime.QuadPart = -LargeDueTime.QuadPart;

    Timer->t_handler = Handler;
    Timer->t_arg = Context;

    KeSetTimer(
        &(Timer->t_timer),
        LargeDueTime,
        &(Timer->t_dpc)
        );

    return((void *) 1);
}


unsigned long
CTESystemUpTime(
    void
    )

/*++

Routine Description:

    Provides the time since system boot in milliseconds.

Arguments:

    None.

Return Value:

    The time since boot in milliseconds.

--*/

{
    LARGE_INTEGER TickCount;

    //
    // Get tick count and convert to hundreds of nanoseconds.
    //
#pragma warning(push)
#pragma warning(disable:4127) // condition expression constant
    
    KeQueryTickCount(&TickCount);

#pragma warning(pop)    
    
    TickCount = RtlExtendedIntegerMultiply(
                    TickCount,
                    (LONG) CTEpTimeIncrement
                    );

    TickCount = CTEConvert100nsToMilliseconds(TickCount);

    return(TickCount.LowPart);
}


uint
CTEBlock(
    IN CTEBlockStruc *BlockEvent
    )
{
    NTSTATUS Status;

    Status = KeWaitForSingleObject(
                 &(BlockEvent->cbs_event),
                 UserRequest,
                 KernelMode,
                 FALSE,
                 NULL
                 );

    if (!NT_SUCCESS(Status)) {
        BlockEvent->cbs_status = Status;
    }

    return(BlockEvent->cbs_status);
}

uint
CTEBlockWithTracker(
    IN CTEBlockStruc *BlockEvent,
    IN CTEBlockTracker *BlockTracker,
    IN void *Context
    )
{
    uint Status;

    CTEInsertBlockTracker(BlockTracker, Context);
    Status = CTEBlock(BlockEvent);
    CTERemoveBlockTracker(BlockTracker);

    return Status;
}

void
CTEInsertBlockTracker(
    IN CTEBlockTracker *BlockTracker,
    IN void *Context
    )
{
    KIRQL OldIrql;

    BlockTracker->cbt_thread = KeGetCurrentThread();
    BlockTracker->cbt_context = Context;

    KeAcquireSpinLock(&CTEBlockSpinLock, &OldIrql);
    InsertTailList(&CTEBlockListHead, &BlockTracker->cbt_link);
    KeReleaseSpinLock(&CTEBlockSpinLock, OldIrql);
}

void
CTERemoveBlockTracker(
    IN CTEBlockTracker *BlockTracker
    )
{
    KIRQL OldIrql;
    KeAcquireSpinLock(&CTEBlockSpinLock, &OldIrql);
    RemoveEntryList(&BlockTracker->cbt_link);
    KeReleaseSpinLock(&CTEBlockSpinLock, OldIrql);
}

void
CTESignal(
    IN CTEBlockStruc *BlockEvent,
    IN uint Status
    )
{
    BlockEvent->cbs_status = Status;
    KeSetEvent(&(BlockEvent->cbs_event), 0, FALSE);
    return;
}


BOOLEAN
CTEInitString(
    IN OUT PNDIS_STRING   DestinationString,
    IN     char          *SourceString
    )

/*++

Routine Description:

    Converts a C style ASCII string to an NDIS_STRING. Resources needed for
    the NDIS_STRING are allocated and must be freed by a call to
    CTEFreeString.

Arguments:

    DestinationString - A pointer to an NDIS_STRING variable with no
                        associated data buffer.

    SourceString      - The C style ASCII string source.


Return Value:

    TRUE if the initialization succeeded. FALSE otherwise.

--*/

{
    STRING AnsiString;
    ULONG UnicodeLength;

    RtlInitString(&AnsiString, SourceString);
    
    // calculate size of unicoded ansi string + 2 for NULL terminator
    UnicodeLength = RtlAnsiStringToUnicodeSize(&AnsiString) + 2;
    
    // allocate storage for the unicode string
    DestinationString->Buffer = ExAllocatePool(NonPagedPool, UnicodeLength);

    if (DestinationString->Buffer == NULL) {
        DestinationString->MaximumLength = 0;
        return(FALSE);
    }
    
    DestinationString->MaximumLength = (USHORT) UnicodeLength;
    
    // Finally, convert the string to unicode
    RtlAnsiStringToUnicodeString(DestinationString, &AnsiString, FALSE);

    return(TRUE);
}


BOOLEAN
CTEAllocateString(
    PNDIS_STRING     String,
    unsigned short   MaximumLength
    )

/*++

Routine Description:

    Allocates a data buffer for Length characters in an uninitialized
    NDIS_STRING. The allocated space must be freed by a call to CTEFreeString.


Arguments:

    String  - A pointer to an NDIS_STRING variable with no
                  associated data buffer.

    Length  - The maximum length of the string. In Unicode, this is a
                  byte count.

Return Value:

    TRUE if the initialization succeeded. FALSE otherwise.

--*/

{
    String->Buffer = ExAllocatePool(
                         NonPagedPool,
                         MaximumLength + sizeof(UNICODE_NULL)
                         );

    if (String->Buffer == NULL) {
        return(FALSE);
    }

    String->Length = 0;
    String->MaximumLength = MaximumLength + sizeof(UNICODE_NULL);

    return(TRUE);
}



LONG
CTELogEvent(
    IN PVOID             LoggerId,
    IN ULONG             EventCode,
    IN ULONG             UniqueEventValue,
    IN USHORT            NumStrings,
    IN PVOID             StringsList,        OPTIONAL
    IN ULONG             DataSize,
    IN PVOID             Data                OPTIONAL
    )

/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.


Arguments:

    LoggerId          - Pointer to the driver object logging this event.

    EventCode         - Identifies the error message.

    UniqueEventValue  - Identifies this instance of a given error message.

    NumStrings        - Number of unicode strings in strings list.

    DataSize          - Number of bytes of data.

    Strings           - Array of pointers to unicode strings (PWCHAR).

    Data              - Binary dump data for this message, each piece being
                        aligned on word boundaries.

Return Value:

    TDI_SUCCESS                  - The error was successfully logged.
    TDI_BUFFER_TOO_SMALL         - The error data was too large to be logged.
    TDI_NO_RESOURCES             - Unable to allocate memory.

Notes:

    This code is paged and may not be called at raised IRQL.

--*/
{
    PIO_ERROR_LOG_PACKET  ErrorLogEntry;
    ULONG                 PaddedDataSize;
    ULONG                 PacketSize;
    ULONG                 TotalStringsSize = 0;
    USHORT                i;
    PWCHAR               *Strings;
    PWCHAR                Tmp;


    PAGED_CODE();

    Strings = (PWCHAR *) StringsList;

    //
    // Sum up the length of the strings
    //
    for (i=0; i<NumStrings; i++) {
        PWCHAR currentString;
        ULONG  stringSize;

        stringSize = sizeof(UNICODE_NULL);
        currentString = Strings[i];

        while (*currentString++ != UNICODE_NULL) {
            stringSize += sizeof(WCHAR);
        }

        TotalStringsSize += stringSize;
    }

    if (DataSize % sizeof(ULONG)) {
        PaddedDataSize = DataSize +
                     (sizeof(ULONG) - (DataSize % sizeof(ULONG)));
    }
    else {
        PaddedDataSize = DataSize;
    }

    PacketSize = TotalStringsSize + PaddedDataSize;

    if (PacketSize > CTE_MAX_EVENT_LOG_DATA_SIZE) {
        return(TDI_BUFFER_TOO_SMALL);         // Too much error data
    }

    //
    // Now add in the size of the log packet, but subtract 4 from the data
    // since the packet struct contains a ULONG for data.
    //
    if (PacketSize > sizeof(ULONG)) {
        PacketSize += sizeof(IO_ERROR_LOG_PACKET) - sizeof(ULONG);
    }
    else {
        PacketSize += sizeof(IO_ERROR_LOG_PACKET);
    }

    ASSERT(PacketSize <= ERROR_LOG_MAXIMUM_SIZE);

    ErrorLogEntry = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(
                                               (PDRIVER_OBJECT) LoggerId,
                                               (UCHAR) PacketSize
                                               );

    if (ErrorLogEntry == NULL) {
        return(TDI_NO_RESOURCES);
    }

    //
    // Fill in the necessary log packet fields.
    //
    ErrorLogEntry->UniqueErrorValue = UniqueEventValue;
    ErrorLogEntry->ErrorCode = EventCode;
    ErrorLogEntry->NumberOfStrings = NumStrings;
    ErrorLogEntry->StringOffset = sizeof(IO_ERROR_LOG_PACKET) +
                                  (USHORT) PaddedDataSize - sizeof(ULONG);
    ErrorLogEntry->DumpDataSize = (USHORT) PaddedDataSize;

    //
    // Copy the Dump Data to the packet
    //
    if (DataSize > 0) {
        RtlMoveMemory(
            (PVOID) ErrorLogEntry->DumpData,
            Data,
            DataSize
            );
    }

    //
    // Copy the strings to the packet.
    //
    Tmp =  (PWCHAR) ((char *) ErrorLogEntry +
                              ErrorLogEntry->StringOffset +
                              PaddedDataSize);

    for (i=0; i<NumStrings; i++) {
        PWCHAR wchPtr = Strings[i];

        while( (*Tmp++ = *wchPtr++) != UNICODE_NULL);
    }

    IoWriteErrorLogEntry(ErrorLogEntry);

    return(TDI_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sys\tdidebug.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tdidebug.h

Abstract:

    This module contains code which assists the process of debugging an NT
    TDI client.

Author:

    David Beaver (dbeaver) 28 June 1991

Environment:

    Kernel mode

Revision History:

    All code moved in from other XNS and NBF locations at creation


--*/
#if !defined _TDI_DEBUG_H
#define _TDI_DEBUG_H

#if DBG
#include <stdarg.h>
#include <stdio.h>
#include <cxport.h>
VOID
TdiPrintf(
    char *Format,
    ...
    );

VOID
TdiFormattedDump(
    PCHAR far_p,
    ULONG  len
    );

VOID
TdiHexDumpLine(
    PCHAR       pch,
    ULONG       len,
    PCHAR       s,
    PCHAR       t
    );

#endif


VOID
TdiPrintUString(
    PUNICODE_STRING pustr
    );

//
// The various Dbg print codes..
// Add as required.
//

#define TDI_DEBUG_FUNCTION            0x00000001
#define TDI_DEBUG_PARAMETERS          0x00000002
#define TDI_DEBUG_NCPA                0x00000004
#define TDI_DEBUG_CLIENTS             0x00000008
#define TDI_DEBUG_PROVIDERS           0x00000010
#define TDI_DEBUG_POWER               0x00000020
#define TDI_DEBUG_BIND                0x00000040
#define TDI_DEBUG_ADDRESS             0x00000080
#define TDI_DEBUG_REGISTRY            0x00000100
#define TDI_DEBUG_ERROR               0x00000200
#define TDI_DEBUG_FUNCTION2           0x10000000

#define LOG_ERROR                     0x00000001
#define LOG_NOTIFY                    0x00000002
#define LOG_REGISTER                  0x00000004
#define LOG_POWER                     0x00000008

#define LOG_OUTPUT_DEBUGGER           1
#define LOG_OUTPUT_BUFFER             2

#define LOG_MSG_CNT     70
#define MAX_MSG_LEN     200

#if DBG

CHAR         DbgMsgs[LOG_MSG_CNT][MAX_MSG_LEN];
UINT         First, Last;
CTELock      DbgLock;

//
// In memory logging functions.
//
VOID
DbgMsgInit();

VOID
DbgMsg(CHAR *Format, ...);


extern ULONG    TdiDebugEx;
extern ULONG    TdiMemLog;

//
// Print to the in-memory buffer anyways.
//

#define TDI_DEBUG(_Flag, _Print) { \
    if (TdiDebugEx & (TDI_DEBUG_ ## _Flag)) { \
        DbgPrint ("TDI: "); \
        DbgPrint _Print; \
    }   \
}

#define TDI_LOG(flgs, format) {  \
        if (flgs & TdiMemLog) {  \
            DbgMsg format;       \
        }                        \
}


#else

#define TDI_DEBUG(_Flag, _Print) (0)
#define TDI_LOG(a,b) (0)

#endif


#endif //_TDI_DEBUG_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\common\sec.h ===
//****************************************************************************
//
//  Module:     UNIMDM
//  File:       SEC.H
//
//  Copyright (c) 1992-1996, Microsoft Corporation, all rights reserved
//
//  Revision History
//
//
//  3/27/96     JosephJ             Created
//
//
//  Description: Security-related helper functions
//
//****************************************************************************
PSECURITY_DESCRIPTOR AllocateSecurityDescriptor (
	PSID_IDENTIFIER_AUTHORITY pSIA,
	DWORD dwRID,
	DWORD dwRights,
	PSID pSidOwner,
	PSID pSidGroup
	);
void FreeSecurityDescriptor(PSECURITY_DESCRIPTOR pSD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\common\proj.h ===
//
// proj.h:  Includes all files that are to be part of the precompiled
//             header.
//

#ifndef __PROJ_H__
#define __PROJ_H__

#define STRICT
#define NOWINDOWSX

#define UNICODE
#define _UNICODE    // so we can use CRT TCHAR routines


//#define PROFILE_TRACES         // Profile the mass modem install case


#if DBG > 0 && !defined(DEBUG)
#define DEBUG
#endif
#if DBG > 0 && !defined(FULL_DEBUG)
#define FULL_DEBUG
#endif

#ifdef DEBUG
#define SZ_MODULEA  "ROVCOMM"
#define SZ_MODULEW  TEXT("ROVCOMM")
#endif

#include <windows.h>
#include <windowsx.h>
#include <rovcomm.h>
#include <regstr.h>
#include <tchar.h>

#define NORTL

#endif  //!__PROJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\common\rovmem.c ===
//
// Copyright (c) Microsoft Corporation 1993-1995
//
// mem.c
//
// This file contains memory management and dynamic 
// array functions.
//
// History:
//  09-27-94 ScottH     Taken from commctrl
//  04-29-95 ScottH     Taken from briefcase and cleaned up
//  


#include "proj.h"
#include <rovcomm.h>

#include <debugmem.h>

#ifndef NOMEM

//////////////////////////////////////////////////////////////////

#ifdef WINNT

/*----------------------------------------------------------
Purpose: Wide-char version of SetStringA

Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC SetStringW(
    LPWSTR FAR * ppszBuf,
    LPCWSTR psz)             // NULL to free *ppszBuf
    {
    BOOL bRet = FALSE;

    ASSERT(ppszBuf);

    // Free the buffer?
    if (!psz)
        {
        // Yes
        if (*ppszBuf)
            {
            FREE_MEMORY(*ppszBuf);
            *ppszBuf = NULL;
            }
        bRet = TRUE;
        }
    else
        {
        // No; (re)allocate and set buffer
        UINT cb = CbFromCchW(lstrlenW(psz)+1);

        if (*ppszBuf)
            {
            // Need to reallocate?
            if (cb > SIZE_OF_MEMORY(*ppszBuf))
                {
                // Yes
                LPWSTR pszT = (LPWSTR)REALLOCATE_MEMORY(*ppszBuf, cb );
                if (pszT)
                    {
                    *ppszBuf = pszT;
                    bRet = TRUE;
                    }
                }
            else
                {
                // No
                bRet = TRUE;
                }
            }
        else
            {
            *ppszBuf = (LPWSTR)ALLOCATE_MEMORY( cb);
            if (*ppszBuf)
                {
                bRet = TRUE;
                }
            }

        if (bRet)
            {
            ASSERT(*ppszBuf);
            lstrcpyW(*ppszBuf, psz);
            }
        }
    return bRet;
    }


/*----------------------------------------------------------
Purpose: Wide-char version of CatStringA

Returns: TRUE on success
Cond:    --
*/
BOOL 
PRIVATE 
MyCatStringW(
    IN OUT LPWSTR FAR * ppszBuf,
    IN     LPCWSTR     psz,                 OPTIONAL
    IN     BOOL        bMultiString)
    {
    BOOL bRet = FALSE;

    ASSERT(ppszBuf);

    // Free the buffer?
    if ( !psz )
        {
        // Yes
        if (*ppszBuf)
            {
            FREE_MEMORY(*ppszBuf);
            *ppszBuf = NULL;
            }
        bRet = TRUE;
        }
    else
        {
        // No; (re)allocate and set buffer
        LPWSTR pszBuf = *ppszBuf;
        UINT cch;

        cch = lstrlenW(psz) + 1;        // account for null

        if (bMultiString)
            {
            cch++;                      // account for second null
            }

        if (pszBuf)
            {
            UINT cchExisting;
            LPWSTR pszT;

            // Figure out how much of the buffer has been used

            // Is this a multi-string (one with strings with a double-null
            // terminator)?
            if (bMultiString)
                {
                // Yes
                UINT cchT;

                cchExisting = 0;
                pszT = (LPWSTR)pszBuf;
                while (0 != *pszT)
                    {
                    cchT = lstrlenW(pszT) + 1;
                    cchExisting += cchT;
                    pszT += cchT;
                    }
                }
            else
                {
                // No; (don't need to count null because it is already 
                // counted in cch)
                cchExisting = lstrlenW(pszBuf);
                }

            // Need to reallocate?
            if (CbFromCchW(cch + cchExisting) > SIZE_OF_MEMORY(pszBuf))
                {
                // Yes; realloc at least MAX_BUF to cut down on the amount
                // of calls in the future
                cch = cchExisting + max(cch, MAX_BUF);

                pszT = (LPWSTR)REALLOCATE_MEMORY(pszBuf,
                                            CbFromCchW(cch));
                if (pszT)
                    {
                    pszBuf = pszT;
                    *ppszBuf = pszBuf;
                    bRet = TRUE;
                    }
                }
            else
                {
                // No
                bRet = TRUE;
                }

            pszBuf += cchExisting;
            }
        else
            {
            cch = max(cch, MAX_BUF);

            pszBuf = (LPWSTR)ALLOCATE_MEMORY( CbFromCchW(cch));
            if (pszBuf)
                {
                bRet = TRUE;
                }

            *ppszBuf = pszBuf;
            }

        if (bRet)
            {
            ASSERT(pszBuf);

            lstrcpyW(pszBuf, psz);

            if (bMultiString)
                {
                pszBuf[lstrlenW(psz) + 1] = 0;  // Add second null terminator
                }
            }
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Wide-char version of CatStringA

Returns: TRUE on success
Cond:    --
*/
BOOL 
PUBLIC 
CatStringW(
    IN OUT LPWSTR FAR * ppszBuf,
    IN     LPCWSTR     psz)
    {
    return MyCatStringW(ppszBuf, psz, FALSE);
    }

/*----------------------------------------------------------
Purpose: Wide-char version of CatMultiStringA

Returns: TRUE on success
Cond:    --
*/
BOOL 
PUBLIC 
CatMultiStringW(
    IN OUT LPWSTR FAR * ppszBuf,
    IN     LPCWSTR     psz)
    {
    return MyCatStringW(ppszBuf, psz, TRUE);
    }

#endif // WINNT


/*----------------------------------------------------------
Purpose: Copies psz into *ppszBuf.  Will alloc or realloc *ppszBuf
         accordingly.

         If psz is NULL, this function frees *ppszBuf.  This is
         the preferred method of freeing the allocated buffer.

Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC SetStringA(
    LPSTR FAR * ppszBuf,
    LPCSTR psz)             // NULL to free *ppszBuf
    {
    BOOL bRet = FALSE;

    ASSERT(ppszBuf);

    // Free the buffer?
    if (!psz)
        {
        // Yes
        if (ppszBuf)
            {
            FREE_MEMORY(*ppszBuf);
            *ppszBuf = NULL;
            }
        bRet = TRUE;
        }
    else
        {
        // No; (re)allocate and set buffer
        UINT cb = CbFromCchA(lstrlenA(psz)+1);

        if (*ppszBuf)
            {
            // Need to reallocate?
            if (cb > SIZE_OF_MEMORY(*ppszBuf))
                {
                // Yes
                LPSTR pszT = (LPSTR)REALLOCATE_MEMORY(*ppszBuf, cb);
                if (pszT)
                    {
                    *ppszBuf = pszT;
                    bRet = TRUE;
                    }
                }
            else
                {
                // No
                bRet = TRUE;
                }
            }
        else
            {
            *ppszBuf = (LPSTR)ALLOCATE_MEMORY( cb);
            if (*ppszBuf)
                {
                bRet = TRUE;
                }
            }

        if (bRet)
            {
            ASSERT(*ppszBuf);
            lstrcpyA(*ppszBuf, psz);
            }
        }
    return bRet;
    }


/*----------------------------------------------------------
Purpose: Concatenates psz onto *ppszBuf.  Will alloc or 
         realloc *ppszBuf accordingly.

         If bMultiString is TRUE, psz will be appended with
         a null terminator separating the existing string
         and new string.  A double-null terminator will
         be tacked on the end, too.

         To free, call MyCatString(ppszBuf, NULL).

Returns: TRUE on success
Cond:    --
*/
BOOL 
PRIVATE 
MyCatStringA(
    IN OUT LPSTR FAR * ppszBuf,
    IN     LPCSTR      psz,             OPTIONAL
    IN     BOOL        bMultiString)
    {
    BOOL bRet = FALSE;

    ASSERT(ppszBuf);

    // Free the buffer?
    if ( !psz )
        {
        // Yes
        if (*ppszBuf)
            {
            FREE_MEMORY(*ppszBuf);
            *ppszBuf = NULL;
            }
        bRet = TRUE;
        }
    else
        {
        // No; (re)allocate and set buffer
        LPSTR pszBuf = *ppszBuf;
        UINT cch;

        cch = lstrlenA(psz) + 1;        // account for null

        if (bMultiString)
            {
            cch++;                      // account for second null
            }

        if (pszBuf)
            {
            UINT cchExisting;
            LPSTR pszT;

            // Figure out how much of the buffer has been used

            // Is this a multi-string (one with strings with a double-null
            // terminator)?
            if (bMultiString)
                {
                // Yes
                UINT cchT;

                cchExisting = 0;
                pszT = (LPSTR)pszBuf;
                while (0 != *pszT)
                    {
                    cchT = lstrlenA(pszT) + 1;
                    cchExisting += cchT;
                    pszT += cchT;
                    }
                }
            else
                {
                // No; (don't need to count null because it is already 
                // counted in cch)
                cchExisting = lstrlenA(pszBuf);
                }

            // Need to reallocate?
            if (CbFromCchA(cch + cchExisting) > SIZE_OF_MEMORY(pszBuf))
                {
                // Yes; realloc at least MAX_BUF to cut down on the amount
                // of calls in the future
                cch = cchExisting + max(cch, MAX_BUF);

                pszT = (LPSTR)REALLOCATE_MEMORY(pszBuf,
                                            CbFromCchA(cch));
                if (pszT)
                    {
                    pszBuf = pszT;
                    *ppszBuf = pszBuf;
                    bRet = TRUE;
                    }
                }
            else
                {
                // No
                bRet = TRUE;
                }

            pszBuf += cchExisting;
            }
        else
            {
            cch = max(cch, MAX_BUF);

            pszBuf = (LPSTR)ALLOCATE_MEMORY( CbFromCchA(cch));
            if (pszBuf)
                {
                bRet = TRUE;
                }

            *ppszBuf = pszBuf;
            }

        if (bRet)
            {
            ASSERT(pszBuf);

            lstrcpyA(pszBuf, psz);

            if (bMultiString)
                {
                pszBuf[lstrlenA(psz) + 1] = 0;  // Add second null terminator
                }
            }
        }
    return bRet;
    }


/*----------------------------------------------------------
Purpose: Concatenates psz onto *ppszBuf.  Will alloc or 
         realloc *ppszBuf accordingly.

         To free, call CatString(ppszBuf, NULL).

Returns: TRUE on success
Cond:    --
*/
BOOL 
PUBLIC 
CatStringA(
    IN OUT LPSTR FAR * ppszBuf,
    IN     LPCSTR      psz)             OPTIONAL
    {
    return MyCatStringA(ppszBuf, psz, FALSE);
    }


/*----------------------------------------------------------
Purpose: Concatenates psz onto *ppszBuf.  Will alloc or 
         realloc *ppszBuf accordingly.

         psz will be appended with a null terminator separating 
         the existing string and new string.  A double-null 
         terminator will be tacked on the end, too.

         To free, call CatMultiString(ppszBuf, NULL).

Returns: TRUE on success
Cond:    --
*/
BOOL 
PUBLIC 
CatMultiStringA(
    IN OUT LPSTR FAR * ppszBuf,
    IN     LPCSTR      psz)
    {
    return MyCatStringA(ppszBuf, psz, TRUE);
    }




#endif // NOMEM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\common\sec.c ===
//****************************************************************************
//
//  Module:     UNIMDM
//  File:       SEC.C
//
//  Copyright (c) 1992-1996, Microsoft Corporation, all rights reserved
//
//  Revision History
//
//
//  3/27/96     JosephJ             Created
//
//
//  Description: Security-related helper functions
//
//****************************************************************************
#include "proj.h"
#include "sec.h"

#include <debugmem.h>


//****************************************************************************
// Description: This procedure will allocate and initialize a security
// descriptor with the specificed attributes.
//
// Returns: pointer to an allocated and initialized security descriptor.
//      If NULL, GetLastError() will return the appropriate error code.
//
// History:
//  3/27/96	JosephJ	Created
//****************************************************************************/
//
PSECURITY_DESCRIPTOR AllocateSecurityDescriptor (
	PSID_IDENTIFIER_AUTHORITY pSIA,
	DWORD dwRID,
	DWORD dwRights,
	PSID pSidOwner,
	PSID pSidGroup
	)
{
    PSID     pObjSid    = NULL;
    PACL     pDacl        = NULL;
	PSECURITY_DESCRIPTOR pSD = NULL;

	pSD = ALLOCATE_MEMORY( SECURITY_DESCRIPTOR_MIN_LENGTH+256);

	if (!pSD) goto end_fail;

    // Set up the SID for the admins that will be allowed to have
    // access. This SID will have 1 sub-authority
    if (!AllocateAndInitializeSid(
			pSIA,
			1,
			dwRID, 0, 0, 0, 0, 0, 0, 0,
			&pObjSid
		))
	{
		goto end_fail;
	}

    // Set up the DACL that will allow all processes with the above SID 
    // access specified in dwRights. It should be large enough to hold all ACEs.
	//
	{
    	DWORD    cbDaclSize = sizeof(ACCESS_ALLOWED_ACE) +
			 						GetLengthSid(pObjSid) +
			 						sizeof(ACL);

		pDacl = (PACL)ALLOCATE_MEMORY( cbDaclSize );
		if (!pDacl)
		{
			goto end_fail; 
		}

		if ( !InitializeAcl( pDacl,  cbDaclSize, ACL_REVISION2 ) )
		{
			goto end_fail;
		}
	}

	// Add the ACE to the DACL
	//
	if ( !AddAccessAllowedAce( pDacl, ACL_REVISION2, dwRights, pObjSid))
	{
		goto end_fail;
	}

	// Create the security descriptor and put the DACL in it.
	//
	if ( !InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION ))
	{
		goto end_fail;
	}

	if ( !SetSecurityDescriptorDacl(pSD, TRUE, pDacl, FALSE ) )
	{
		goto end_fail;
	}

	// Set owner for the descriptor
	//
	if ( !SetSecurityDescriptorOwner( pSD, pSidOwner, FALSE) )
	{
		goto end_fail;
	}

	// Set group for the descriptor
	//
	if ( !SetSecurityDescriptorGroup( pSD, pSidGroup, FALSE) )
	{
		goto end_fail;
	}

	FreeSid(pObjSid);
    return pSD;
	

end_fail:
    {
		DWORD dwRetCode = GetLastError();

		if (pDacl) 		{ FREE_MEMORY(pDacl); pDacl=0;}

		if (pObjSid) 	{ FreeSid(pObjSid); pObjSid=0;}

		if (pSD)		{ FREE_MEMORY(pSD); pSD=0;}

		SetLastError(dwRetCode);
	}
	return NULL;
}


//****************************************************************************
// Description: Frees a security descriptor previously allocated by
// 				AllocateSecurityDescriptor.
//
// History:
//  3/27/96	JosephJ	Created
//****************************************************************************/
void FreeSecurityDescriptor(PSECURITY_DESCRIPTOR pSD)
{
    PSID     pObjSid    = NULL;
    PACL     pDacl        = NULL;
	BOOL	fGotAcl=FALSE, fByDefault=FALSE; 


	// Free Dacl, if user had allocated it.
	if (GetSecurityDescriptorDacl(pSD, &fGotAcl, &pDacl, &fByDefault ))
	{
		if (fGotAcl && !fByDefault && pDacl)
		{
			FREE_MEMORY(pDacl);
		}
	}
	else
	{
		ASSERT(FALSE); // We should not be calling this function with such
						// an pSD.
	}

	FREE_MEMORY(pSD);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\common\rovcomm.c ===
//
// Copyright (c) Microsoft Corporation 1993-1995
//
// rovcomm.c
//
// This files contains common utility and helper functions.
//
// History:
//  08-06-93 ScottH     Transferred from twin code
//  04-26-95 ScottH     Transferred and expanded from Briefcase code
//  09-21-95 ScottH     Ported to NT
//


#include "proj.h"
#include "rovcomm.h"

#include <debugmem.h>


extern CHAR const FAR c_szNewline[];

#define DEBUG_PRINT_BUFFER_LEN 1030

#ifdef WINNT

//
//  These are some helper functions for handling Unicode strings
//

/*----------------------------------------------------------
Purpose: This function converts a wide-char string to a multi-byte
         string.

         If pszBuf is non-NULL and the converted string can fit in
         pszBuf, then *ppszAnsi will point to the given buffer.
         Otherwise, this function will allocate a buffer that can
         hold the converted string.

         If pszWide is NULL, then *ppszAnsi will be freed.  Note
         that pszBuf must be the same pointer between the call
         that converted the string and the call that frees the
         string.

Returns: TRUE
         FALSE (if out of memory)

Cond:    --
*/
BOOL PUBLIC AnsiFromUnicode(
    LPSTR * ppszAnsi,
    LPCWSTR pwszWide,        // NULL to clean up
    LPSTR pszBuf,
    int cchBuf)
    {
    BOOL bRet;

    // Convert the string?
    if (pwszWide)
        {
        // Yes; determine the converted string length
        int cch;
        LPSTR psz;

        cch = WideCharToMultiByte(CP_ACP, 0, pwszWide, -1, NULL, 0, NULL, NULL);

        // String too big, or is there no buffer?
        if (cch > cchBuf || NULL == pszBuf)
            {
            // Yes; allocate space
            cchBuf = cch + 1;
            psz = (LPSTR)ALLOCATE_MEMORY( CbFromCchA(cchBuf));
            }
        else
            {
            // No; use the provided buffer
            ASSERT(pszBuf);
            psz = pszBuf;
            }

        if (psz)
            {
            // Convert the string
            cch = WideCharToMultiByte(CP_ACP, 0, pwszWide, -1, psz, cchBuf, NULL, NULL);
            bRet = (0 < cch);
            }
        else
            {
            bRet = FALSE;
            }

        *ppszAnsi = psz;
        }
    else
        {
        // No; was this buffer allocated?
        if (*ppszAnsi && pszBuf != *ppszAnsi)
            {
            // Yes; clean up
            FREE_MEMORY(*ppszAnsi);
            *ppszAnsi = NULL;
            }
        bRet = TRUE;
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: This function converts a multi-byte string to a
         wide-char string.

         If pszBuf is non-NULL and the converted string can fit in
         pszBuf, then *ppszWide will point to the given buffer.
         Otherwise, this function will allocate a buffer that can
         hold the converted string.

         If pszAnsi is NULL, then *ppszWide will be freed.  Note
         that pszBuf must be the same pointer between the call
         that converted the string and the call that frees the
         string.

Returns: TRUE
         FALSE (if out of memory)

Cond:    --
*/
BOOL PUBLIC UnicodeFromAnsi(
    LPWSTR * ppwszWide,
    LPCSTR pszAnsi,           // NULL to clean up
    LPWSTR pwszBuf,
    int cchBuf)
    {
    BOOL bRet;

    // Convert the string?
    if (pszAnsi)
        {
        // Yes; determine the converted string length
        int cch;
        LPWSTR pwsz;
        int cchAnsi = lstrlenA(pszAnsi)+1;

        cch = MultiByteToWideChar(CP_ACP, 0, pszAnsi, cchAnsi, NULL, 0);

        // String too big, or is there no buffer?
        if (cch > cchBuf || NULL == pwszBuf)
            {
            // Yes; allocate space
            cchBuf = cch + 1;
            pwsz = (LPWSTR)ALLOCATE_MEMORY( CbFromCchW(cchBuf));
            }
        else
            {
            // No; use the provided buffer
            ASSERT(pwszBuf);
            pwsz = pwszBuf;
            }

        if (pwsz)
            {
            // Convert the string
            cch = MultiByteToWideChar(CP_ACP, 0, pszAnsi, cchAnsi, pwsz, cchBuf);
            bRet = (0 < cch);
            }
        else
            {
            bRet = FALSE;
            }

        *ppwszWide = pwsz;
        }
    else
        {
        // No; was this buffer allocated?
        if (*ppwszWide && pwszBuf != *ppwszWide)
            {
            // Yes; clean up
            FREE_MEMORY(*ppwszWide);
            *ppwszWide = NULL;
            }
        bRet = TRUE;
        }

    return bRet;
    }

#endif // WINNT


#ifndef NOSTRING
// WARNING: all of these APIs do not setup DS, so you can not access
// any data in the default data seg of this DLL.
//
// do not create any global variables... talk to chrisg if you don't
// understand this

//#define  STDCALL


/*----------------------------------------------------------
Purpose: Case sensitive character comparison for DBCS

Returns: FALSE if they match, TRUE if no match
Cond:    --
*/
BOOL NEAR  ChrCmp(
    WORD w1,
    WORD wMatch)
    {
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
        {
        if (IsDBCSLeadByte(LOBYTE(w1)))
            {
            return(w1 != wMatch);
            }
        return FALSE;
        }
    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Case insensitive character comparison for DBCS

Returns: FALSE if match, TRUE if not
Cond:    --
*/
BOOL NEAR  ChrCmpI(
    WORD w1,
    WORD wMatch)
    {
    CHAR sz1[3], sz2[3];

    if (IsDBCSLeadByte(sz1[0] = LOBYTE(w1)))
        {
        sz1[1] = HIBYTE(w1);
        sz1[2] = '\0';
        }
    else
        sz1[1] = '\0';

    *(WORD FAR *)sz2 = wMatch;
    sz2[2] = '\0';
    return lstrcmpiA(sz1, sz2);
    }


#ifndef WIN32

/*----------------------------------------------------------
Purpose: strnicmp

         Swiped from the C 7.0 runtime sources.

Returns:
Cond:
*/
int PUBLIC lstrnicmp(
    LPCSTR psz1,
    LPCSTR psz2,
    UINT count)
    {
    int ch1;
    int ch2;
    int result = 0;

    if (count)
        {
        do
            {
            ch1 = (int)LOWORD(AnsiLower((LPSTR)MAKELONG(*psz1, 0)));
            ch2 = (int)LOWORD(AnsiLower((LPSTR)MAKELONG(*psz2, 0)));
            psz1 = AnsiNext(psz1);
            psz2 = AnsiNext(psz2);
            } while (--count && ch1 && ch2 && !ChrCmp((WORD)ch1, (WORD)ch2));
        result = ch1 - ch2;
        }
    return(result);
    }

/*----------------------------------------------------------
Purpose: strncmp

         Swiped from the C 7.0 runtime sources.

Returns:
Cond:
*/
int PUBLIC lstrncmp(
    LPCSTR psz1,
    LPCSTR psz2,
    UINT count)
    {
    int ch1;
    int ch2;
    int result = 0;

    if (count)
        {
        do
            {
            ch1 = (int)*psz1;
            ch2 = (int)*psz2;
            psz1 = AnsiNext(psz1);
            psz2 = AnsiNext(psz2);
            } while (--count && ch1 && ch2 && !ChrCmp((WORD)ch1, (WORD)ch2));
        result = ch1 - ch2;
        }
    return(result);
    }

#endif // WIN32


#ifdef WINNT

/*----------------------------------------------------------
Purpose: Wide-char wrapper for AnsiToIntA.

Returns: see AnsiToIntA
Cond:    --
*/
BOOL PUBLIC AnsiToIntW(
    LPCWSTR pwszString,
    int FAR * piRet)
    {
    CHAR szBuf[MAX_BUF];
    LPSTR pszString;
    BOOL bRet;
    
    pszString = NULL; 
    bRet = AnsiFromUnicode(&pszString, pwszString, szBuf, ARRAYSIZE(szBuf));

    if (bRet)
        {
            if (pszString == NULL)
            {
                bRet = FALSE;
            } else
            {
                bRet = AnsiToIntA(pszString, piRet);
                AnsiFromUnicode(&pszString, NULL, szBuf, 0);
            }
        }
    return bRet;
    }

/*----------------------------------------------------------
Purpose: Wide-char wrapper for AnsiChrA.

Returns: see AnsiChrA
Cond:    --
*/
LPWSTR PUBLIC AnsiChrW(
    LPCWSTR pwsz,
    WORD wMatch)
    {
    for ( ; *pwsz; pwsz = CharNextW(pwsz))
        {
        if (!ChrCmp(*(WORD FAR *)pwsz, wMatch))
            return (LPWSTR)pwsz;
        }
    return NULL;
    }

#endif // WINNT


/*----------------------------------------------------------
Purpose: Find last occurrence (case sensitive) of wide
         character in wide-char string.

Returns: Pointer to the last occurrence of character in
         string or NULL if character is not found.
Cond:    --
*/
LPWSTR
PUBLIC
AnsiRChrW(
    LPCWSTR pwsz,
    WORD wMatch)
{
    LPWSTR  pwszEnd;

    if (pwsz && *pwsz)
    {
        for (pwszEnd = (LPWSTR)pwsz + lstrlen(pwsz) - 1;
             pwsz <= pwszEnd;
             pwszEnd = CharPrevW(pwsz, pwszEnd))
        {
            if (!ChrCmp(*(WORD FAR *)pwszEnd, wMatch))
                return(pwszEnd);

            // CharPrevW() won't go to char preceding pwsz...
            if (pwsz == pwszEnd)
                break;
        }
    }

    return(NULL);
}


/*----------------------------------------------------------
Purpose: My verion of atoi.  Supports hexadecimal too.

         If this function returns FALSE, *piRet is set to 0.

Returns: TRUE if the string is a number, or contains a partial number
         FALSE if the string is not a number

Cond:    --
*/
BOOL PUBLIC AnsiToIntA(
    LPCSTR pszString,
    int FAR * piRet)
    {
    #define IS_DIGIT(ch)    InRange(ch, '0', '9')

    BOOL bRet;
    int n;
    BOOL bNeg = FALSE;
    LPCSTR psz;
    LPCSTR pszAdj;

    // Skip leading whitespace
    //
    for (psz = pszString; *psz == ' ' || *psz == '\n' || *psz == '\t'; psz = AnsiNext(psz))
        ;

    // Determine possible explicit signage
    //
    if (*psz == '+' || *psz == '-')
        {
        bNeg = (*psz == '+') ? FALSE : TRUE;
        psz++;
        }

    // Or is this hexadecimal?
    //
    pszAdj = AnsiNext(psz);
    if (*psz == '0' && (*pszAdj == 'x' || *pszAdj == 'X'))
        {
        // Yes

        // (Never allow negative sign with hexadecimal numbers)
        bNeg = FALSE;
        psz = AnsiNext(pszAdj);

        pszAdj = psz;

        // Do the conversion
        //
        for (n = 0; ; psz = AnsiNext(psz))
            {
            if (IS_DIGIT(*psz))
                n = 0x10 * n + *psz - '0';
            else
                {
                CHAR ch = *psz;
                int n2;

                if (ch >= 'a')
                    ch -= 'a' - 'A';

                n2 = ch - 'A' + 0xA;
                if (n2 >= 0xA && n2 <= 0xF)
                    n = 0x10 * n + n2;
                else
                    break;
                }
            }

        // Return TRUE if there was at least one digit
        bRet = (psz != pszAdj);
        }
    else
        {
        // No
        pszAdj = psz;

        // Do the conversion
        for (n = 0; IS_DIGIT(*psz); psz = AnsiNext(psz))
            n = 10 * n + *psz - '0';

        // Return TRUE if there was at least one digit
        bRet = (psz != pszAdj);
        }

    *piRet = bNeg ? -n : n;

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Find first occurrence of character in string

Returns: Pointer to the first occurrence of ch in
Cond:    --
*/
LPSTR PUBLIC AnsiChrA(
    LPCSTR psz,
    WORD wMatch)
    {
    for ( ; *psz; psz = AnsiNext(psz))
        {
        if (!ChrCmp(*(WORD FAR *)psz, wMatch))
            return (LPSTR)psz;
        }
    return NULL;
    }

#endif // NOSTRING


#ifndef NODIALOGHELPER

/*----------------------------------------------------------
Purpose: Sets the rectangle with the bounding extent of the given string.
Returns: Rectangle
Cond:    --
*/
void PUBLIC SetRectFromExtentW(
    HDC hdc,
    LPRECT lprect,
    LPCWSTR lpcwsz)
    {
    SIZE size;

    GetTextExtentPointW(hdc, lpcwsz, lstrlenW(lpcwsz), &size);
    SetRect(lprect, 0, 0, size.cx, size.cy);
    }

/*----------------------------------------------------------
Purpose: Sets the rectangle with the bounding extent of the given string.
Returns: Rectangle
Cond:    --
*/
void PUBLIC SetRectFromExtentA(
    HDC hdc,
    LPRECT lprect,
    LPCSTR lpcsz)
    {
    SIZE size;

    GetTextExtentPointA(hdc, lpcsz, lstrlenA(lpcsz), &size);
    SetRect(lprect, 0, 0, size.cx, size.cy);
    }

#endif // NODIALOGHELPER


#ifndef NODRAWTEXT

#pragma data_seg(DATASEG_READONLY)

CHAR const FAR c_szEllipses[] = "...";

#pragma data_seg()

// Global variables
int g_cxLabelMargin = 0;
int g_cxBorder = 0;
int g_cyBorder = 0;

COLORREF g_clrHighlightText = 0;
COLORREF g_clrHighlight = 0;
COLORREF g_clrWindowText = 0;
COLORREF g_clrWindow = 0;

HBRUSH g_hbrHighlight = 0;
HBRUSH g_hbrWindow = 0;


/*----------------------------------------------------------
Purpose: Get the system metrics we need
Returns: --
Cond:    --
*/
void PUBLIC GetCommonMetrics(
    WPARAM wParam)      // wParam from WM_WININICHANGE
    {
    if ((wParam == 0) || (wParam == SPI_SETNONCLIENTMETRICS))
        {
        g_cxBorder = GetSystemMetrics(SM_CXBORDER);
        g_cyBorder = GetSystemMetrics(SM_CYBORDER);

        g_cxLabelMargin = (g_cxBorder * 2);
        }
    }


/*----------------------------------------------------------
Purpose: Sees whether the entire string will fit in *prc.
         If not, compute the numbder of chars that will fit
         (including ellipses).  Returns length of string in
         *pcchDraw.

         Taken from COMMCTRL.

Returns: TRUE if the string needed ellipses
Cond:    --
*/
BOOL PRIVATE NeedsEllipses(
    HDC hdc,
    LPCSTR pszText,
    RECT * prc,
    int * pcchDraw,
    int cxEllipses)
    {
    int cchText;
    int cxRect;
    int ichMin, ichMax, ichMid;
    SIZE siz;

    cxRect = prc->right - prc->left;

    cchText = lstrlenA(pszText);

    if (cchText == 0)
        {
        *pcchDraw = cchText;
        return FALSE;
        }

    GetTextExtentPointA(hdc, pszText, cchText, &siz);

    if (siz.cx <= cxRect)
        {
        *pcchDraw = cchText;
        return FALSE;
        }

    cxRect -= cxEllipses;

    // If no room for ellipses, always show first character.
    //
    ichMax = 1;
    if (cxRect > 0)
        {
        // Binary search to find character that will fit
        ichMin = 0;
        ichMax = cchText;
        while (ichMin < ichMax)
            {
            // Be sure to round up, to make sure we make progress in
            // the loop if ichMax == ichMin + 1.
            //
            ichMid = (ichMin + ichMax + 1) / 2;

            GetTextExtentPointA(hdc, &pszText[ichMin], ichMid - ichMin, &siz);

            if (siz.cx < cxRect)
                {
                ichMin = ichMid;
                cxRect -= siz.cx;
                }
            else if (siz.cx > cxRect)
                {
                ichMax = ichMid - 1;
                }
            else
                {
                // Exact match up up to ichMid: just exit.
                //
                ichMax = ichMid;
                break;
                }
            }

        // Make sure we always show at least the first character...
        //
        if (ichMax < 1)
            ichMax = 1;
        }

    *pcchDraw = ichMax;
    return TRUE;
    }


#define CCHELLIPSES     3
#define DT_LVWRAP       (DT_CENTER | DT_WORDBREAK | DT_NOPREFIX | DT_EDITCONTROL)


#ifdef WINNT

/*----------------------------------------------------------
Purpose: Wide-char wrapper for MyDrawTextA.

Returns: see MyDrawTextA
Cond:    --
*/
void PUBLIC MyDrawTextW(
    HDC hdc,
    LPCWSTR pwszText,
    RECT FAR* prc,
    UINT flags,
    int cyChar,
    int cxEllipses,
    COLORREF clrText,
    COLORREF clrTextBk)
    {
    CHAR szBuf[MAX_BUF];
    LPSTR pszText;
    BOOL bRet;

    pszText = NULL;
    bRet = AnsiFromUnicode(&pszText, pwszText, szBuf, ARRAYSIZE(szBuf));

    if (bRet)
        {
        MyDrawTextA(hdc, pszText, prc, flags, cyChar, cxEllipses, clrText, clrTextBk);
        AnsiFromUnicode(&pszText, NULL, szBuf, 0);
        }
    }

#endif // WINNT


/*----------------------------------------------------------
Purpose: Draws text the shell's way.

         Taken from COMMCTRL.

Returns: --

Cond:    This function requires TRANSPARENT background mode
         and a properly selected font.
*/
void PUBLIC MyDrawTextA(
    HDC hdc,
    LPCSTR pszText,
    RECT FAR* prc,
    UINT flags,
    int cyChar,
    int cxEllipses,
    COLORREF clrText,
    COLORREF clrTextBk)
    {
    int cchText;
    COLORREF clrSave;
    COLORREF clrSaveBk;
    UINT uETOFlags = 0;
    RECT rc;
    CHAR ach[MAX_PATH + CCHELLIPSES];

    // REVIEW: Performance idea:
    // We could cache the currently selected text color
    // so we don't have to set and restore it each time
    // when the color is the same.
    //
    if (!pszText)
        return;

    rc = *prc;

    // If needed, add in a little extra margin...
    //
    if (IsFlagSet(flags, MDT_EXTRAMARGIN))
        {
        rc.left  += g_cxLabelMargin * 3;
        rc.right -= g_cxLabelMargin * 3;
        }
    else
        {
        rc.left  += g_cxLabelMargin;
        rc.right -= g_cxLabelMargin;
        }

    if (IsFlagSet(flags, MDT_ELLIPSES) &&
        NeedsEllipses(hdc, pszText, &rc, &cchText, cxEllipses))
        {
        hmemcpy(ach, pszText, cchText);
        lstrcpyA(ach + cchText, c_szEllipses);

        pszText = ach;

        // Left-justify, in case there's no room for all of ellipses
        //
        ClearFlag(flags, (MDT_RIGHT | MDT_CENTER));
        SetFlag(flags, MDT_LEFT);

        cchText += CCHELLIPSES;
        }
    else
        {
        cchText = lstrlenA(pszText);
        }

    if (IsFlagSet(flags, MDT_TRANSPARENT))
        {
        clrSave = SetTextColor(hdc, 0x000000);
        }
    else
        {
        uETOFlags |= ETO_OPAQUE;

        if (IsFlagSet(flags, MDT_SELECTED))
            {
            clrSave = SetTextColor(hdc, g_clrHighlightText);
            clrSaveBk = SetBkColor(hdc, g_clrHighlight);

            if (IsFlagSet(flags, MDT_DRAWTEXT))
                {
                FillRect(hdc, prc, g_hbrHighlight);
                }
            }
        else
            {
            if (clrText == CLR_DEFAULT && clrTextBk == CLR_DEFAULT)
                {
                clrSave = SetTextColor(hdc, g_clrWindowText);
                clrSaveBk = SetBkColor(hdc, g_clrWindow);

                if (IsFlagSet(flags, MDT_DRAWTEXT | MDT_DESELECTED))
                    {
                    FillRect(hdc, prc, g_hbrWindow);
                    }
                }
            else
                {
                HBRUSH hbr;

                if (clrText == CLR_DEFAULT)
                    clrText = g_clrWindowText;

                if (clrTextBk == CLR_DEFAULT)
                    clrTextBk = g_clrWindow;

                clrSave = SetTextColor(hdc, clrText);
                clrSaveBk = SetBkColor(hdc, clrTextBk);

                if (IsFlagSet(flags, MDT_DRAWTEXT | MDT_DESELECTED))
                    {
                    hbr = CreateSolidBrush(GetNearestColor(hdc, clrTextBk));
                    if (hbr)
                        {
                        FillRect(hdc, prc, hbr);
                        DeleteObject(hbr);
                        }
                    else
                        FillRect(hdc, prc, GetStockObject(WHITE_BRUSH));
                    }
                }
            }
        }

    // If we want the item to display as if it was depressed, we will
    // offset the text rectangle down and to the left
    if (IsFlagSet(flags, MDT_DEPRESSED))
        OffsetRect(&rc, g_cxBorder, g_cyBorder);

    if (IsFlagSet(flags, MDT_DRAWTEXT))
        {
        UINT uDTFlags = DT_LVWRAP;

        if (IsFlagClear(flags, MDT_CLIPPED))
            uDTFlags |= DT_NOCLIP;

        DrawTextA(hdc, pszText, cchText, &rc, uDTFlags);
        }
    else
        {
        if (IsFlagClear(flags, MDT_LEFT))
            {
            SIZE siz;

            GetTextExtentPointA(hdc, pszText, cchText, &siz);

            if (IsFlagSet(flags, MDT_CENTER))
                rc.left = (rc.left + rc.right - siz.cx) / 2;
            else
                {
                ASSERT(IsFlagSet(flags, MDT_RIGHT));
                rc.left = rc.right - siz.cx;
                }
            }

        if (IsFlagSet(flags, MDT_VCENTER))
            {
            // Center vertically
            rc.top += (rc.bottom - rc.top - cyChar) / 2;
            }

        if (IsFlagSet(flags, MDT_CLIPPED))
            uETOFlags |= ETO_CLIPPED;

        ExtTextOutA(hdc, rc.left, rc.top, uETOFlags, prc, pszText, cchText, NULL);
        }

    if (flags & (MDT_SELECTED | MDT_DESELECTED | MDT_TRANSPARENT))
        {
        SetTextColor(hdc, clrSave);
        if (IsFlagClear(flags, MDT_TRANSPARENT))
            SetBkColor(hdc, clrSaveBk);
        }
    }
#endif // NODRAWTEXT





#ifndef NOMESSAGESTRING

typedef va_list *   LPVA_LIST;



#ifdef WINNT

#define IsPointerResouceId(_p) (((ULONG_PTR)_p) <= 0xffff)


/*----------------------------------------------------------
Purpose: Wide-char version of ConstructVMessageStringA

Returns: see ConstructVMessageStringA
Cond:    --
*/
LPWSTR PUBLIC ConstructVMessageStringW(
    HINSTANCE hinst,
    LPCWSTR pwszMsg,
    va_list FAR * ArgList)
    {
    WCHAR wszTemp[MAX_BUF];
    LPWSTR pwszRet;
    LPWSTR pwszRes;

    if (!IsPointerResouceId(pwszMsg)) {

        pwszRes = (LPWSTR)pwszMsg;

    } else {

        if ((((ULONG_PTR)pwszMsg) != 0) && LoadStringW(hinst, (DWORD)(ULONG_PTR)pwszMsg, wszTemp, ARRAYSIZE(wszTemp))) {

            pwszRes = wszTemp;

        } else {

            pwszRes = NULL;
        }
    }

    if (pwszRes) {

        if (!FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                           pwszRes, 0, 0, (LPWSTR)&pwszRet, 0, (LPVA_LIST)ArgList))
            {
            pwszRet = NULL;
            }
        }
    else
        {
        // Bad parameter
        pwszRet = NULL;
        }

    return pwszRet;      // free with LocalFree()
    }

/*----------------------------------------------------------
Purpose: Wide-char version of ConstructMessageA.

Returns: see ConstructMessageA
Cond:    --
*/
BOOL CPUBLIC ConstructMessageW(
    LPWSTR FAR * ppwsz,
    HINSTANCE hinst,
    LPCWSTR pwszMsg, ...)
    {
    BOOL bRet;
    LPWSTR pwszRet;
    va_list ArgList;

    va_start(ArgList, pwszMsg);

    pwszRet = ConstructVMessageStringW(hinst, pwszMsg, &ArgList);

    va_end(ArgList);

    *ppwsz = NULL;

    if (pwszRet)
        {
        bRet = SetStringW(ppwsz, pwszRet);
        LocalFree(pwszRet);
        }
    else
        bRet = FALSE;

    return bRet;
    }

/*----------------------------------------------------------
Purpose: Wide-char version of MsgBoxA

Returns: See MsgBoxA
Cond:    --
*/
int CPUBLIC MsgBoxW(
    HINSTANCE hinst,
    HWND hwndOwner,
    LPCWSTR pwszText,
    LPCWSTR pwszCaption,
    HICON hicon,            // May be NULL
    DWORD dwStyle, ...)
    {
    int iRet = -1;
    int ids;
    WCHAR wszCaption[MAX_BUF];
    LPWSTR pwszRet;
    va_list ArgList;

    va_start(ArgList, dwStyle);

    pwszRet = ConstructVMessageStringW(hinst, pwszText, &ArgList);

    va_end(ArgList);

    if (pwszRet)
        {
        // Is pszCaption a resource ID?
        if (IsPointerResouceId(pwszCaption))
            {
            // Yes; load it
            ids = LOWORD(pwszCaption);
            SzFromIDSW(hinst, ids, wszCaption, ARRAYSIZE(wszCaption));
            pwszCaption = wszCaption;
            }

        // Invoke dialog
        if (pwszCaption)
            {
            MSGBOXPARAMSW mbp;

            mbp.cbSize = sizeof(mbp);
            mbp.hwndOwner = hwndOwner;
            mbp.hInstance = hinst;
            mbp.lpszText = pwszRet;
            mbp.lpszCaption = pwszCaption;
            mbp.dwStyle = dwStyle | MB_SETFOREGROUND;
            mbp.lpszIcon = MAKEINTRESOURCEW(hicon);
            mbp.lpfnMsgBoxCallback = NULL;
            mbp.dwLanguageId = LANG_NEUTRAL;

            iRet = MessageBoxIndirectW(&mbp);
            }
        LocalFree(pwszRet);
        }

    return iRet;
    }

#endif // WINNT


/*----------------------------------------------------------
Purpose: Load the string (if necessary) and format the string
         properly.

Returns: A pointer to the allocated string containing the formatted
         message or
         NULL if out of memory

Cond:    free pointer with FREE_MEMORY()
*/
LPSTR PUBLIC ConstructVMessageStringA(
    HINSTANCE hinst,
    LPCSTR pszMsg,
    va_list FAR * ArgList)
    {
    CHAR szTemp[MAX_BUF];
    LPSTR pszRet;
    LPSTR pszRes;

    if (!IsPointerResouceId(pszMsg)) {

        pszRes = (LPSTR)pszMsg;

    } else {

        if ((((ULONG_PTR)pszMsg) != 0) && LoadStringA(hinst, (DWORD)(ULONG_PTR)pszMsg, szTemp, ARRAYSIZE(szTemp))) {

            pszRes = szTemp;

        } else {

            pszRes = NULL;
        }
    }

    if (pszRes)
        {
        if (!FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                           pszRes, 0, 0, (LPSTR)&pszRet, 0, (LPVA_LIST)ArgList))
            {
            pszRet = NULL;
            }
        }
    else
        {
        // Bad parameter
        pszRet = NULL;
        }

    return pszRet;      // free with FREE_MEMORY()
    }


/*----------------------------------------------------------
Purpose: Constructs a formatted string.  The returned string
         must be freed using GFree().

Returns: TRUE on success

Cond:    Free pointer with GFree()
*/
BOOL CPUBLIC ConstructMessageA(
    LPSTR FAR * ppsz,
    HINSTANCE hinst,
    LPCSTR pszMsg, ...)
    {
    BOOL bRet;
    LPSTR pszRet;
    va_list ArgList;

    va_start(ArgList, pszMsg);

    pszRet = ConstructVMessageStringA(hinst, pszMsg, &ArgList);

    va_end(ArgList);

    *ppsz = NULL;

    if (pszRet)
        {
        bRet = SetStringA(ppsz, pszRet);
        LocalFree(pszRet);
        }
    else
        bRet = FALSE;

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Invoke a message box.

Returns: ID of button that terminated the dialog
Cond:    --
*/
int CPUBLIC MsgBoxA(
    HINSTANCE hinst,
    HWND hwndOwner,
    LPCSTR pszText,
    LPCSTR pszCaption,
    HICON hicon,            // May be NULL
    DWORD dwStyle, ...)
    {
    int iRet = -1;
    int ids;
    CHAR szCaption[MAX_BUF];
    LPSTR pszRet;
    va_list ArgList;

    va_start(ArgList, dwStyle);

    pszRet = ConstructVMessageStringA(hinst, pszText, &ArgList);

    va_end(ArgList);

    if (pszRet)
        {
        // Is pszCaption a resource ID?
        if (IsPointerResouceId(pszCaption))
            {
            // Yes; load it
            ids = LOWORD(pszCaption);
            SzFromIDSA(hinst, ids, szCaption, SIZECHARS(szCaption));
            pszCaption = szCaption;
            }

        // Invoke dialog
        if (pszCaption)
            {
#ifdef WIN32

            MSGBOXPARAMSA mbp;

            mbp.cbSize = sizeof(mbp);
            mbp.hwndOwner = hwndOwner;
            mbp.hInstance = hinst;
            mbp.lpszText = pszRet;
            mbp.lpszCaption = pszCaption;
            mbp.dwStyle = dwStyle | MB_SETFOREGROUND;
            mbp.lpszIcon = MAKEINTRESOURCEA(hicon);
            mbp.lpfnMsgBoxCallback = NULL;
            mbp.dwLanguageId = LANG_NEUTRAL;

            iRet = MessageBoxIndirectA(&mbp);

#else   // WIN32

            iRet = MessageBox(hwndOwner, pszRet, pszCaption, LOWORD(dwStyle));
#endif
            }
        LocalFree(pszRet);
        }

    return iRet;
    }

#endif // NOMESSAGESTRING


#if !defined(NODEBUGHELP) && defined(DEBUG)

// Globals
DWORD g_dwBreakFlags = 0;
DWORD g_dwDumpFlags  = 0;
DWORD g_dwTraceFlags = 0;
LONG  g_dwIndent     = 0;

#pragma data_seg(DATASEG_READONLY)

#ifdef WINNT
extern WCHAR const FAR c_wszNewline[];
extern WCHAR const FAR c_wszTrace[];
extern WCHAR const FAR c_wszAssertFailed[];
#endif // WINNT

extern CHAR const FAR c_szNewline[];
extern CHAR const FAR c_szTrace[];
extern CHAR const FAR c_szAssertFailed[];


#pragma data_seg()

/*----------------------------------------------------------
Purpose: Return English reason for the debug break
Returns: String
Cond:    --
*/
LPCSTR PRIVATE GetReasonString(
    DWORD flag)      // One of BF_ flags
    {
    LPCSTR psz;

    if (IsFlagSet(flag, BF_ONOPEN))
        psz = "BREAK ON OPEN\r\n";

    else if (IsFlagSet(flag, BF_ONCLOSE))
        psz = "BREAK ON CLOSE\r\n";

    else if (IsFlagSet(flag, BF_ONRUNONCE))
        psz = "BREAK ON RUNONCE\r\n";

    else if (IsFlagSet(flag, BF_ONVALIDATE))
        psz = "BREAK ON VALIDATION FAILURE\r\n";

    else if (IsFlagSet(flag, BF_ONTHREADATT))
        psz = "BREAK ON THREAD ATTACH\r\n";

    else if (IsFlagSet(flag, BF_ONTHREADDET))
        psz = "BREAK ON THREAD DETACH\r\n";

    else if (IsFlagSet(flag, BF_ONPROCESSATT))
        psz = "BREAK ON PROCESS ATTACH\r\n";

    else if (IsFlagSet(flag, BF_ONPROCESSDET))
        psz = "BREAK ON PROCESS DETACH\r\n";

    else if (IsFlagSet(flag, BF_ONAPIENTER))
        psz = "BREAK ON API ENTER\r\n";

    else
        psz = c_szNewline;

    return psz;
    }


/*----------------------------------------------------------
Purpose: Perform a debug break based on the flag
Returns: --
Cond:    --
*/
void PUBLIC CommonDebugBreak(
    DWORD flag)      // One of BF_ flags
    {
    if (IsFlagSet(g_dwBreakFlags, flag))
        {
        TRACE_MSG(TF_ALWAYS, GetReasonString(flag));
        DebugBreak();
        }
    }

/*----------------------------------------------------------
Purpose: Assert failed
Returns: --
Cond:    --
*/
void PUBLIC CommonAssertFailed(
    LPCSTR pszFile,
    int line)
    {
    LPCSTR psz;
    CHAR ach[256];

    // Strip off path info from filename string, if present.
    //
    for (psz = pszFile + lstrlenA(pszFile); psz != pszFile; psz=AnsiPrev(pszFile, psz))
        {
        if ((AnsiPrev(pszFile, psz) != (psz-2)) && *(psz - 1) == '\\')
            break;
        }
    wsprintfA(ach, c_szAssertFailed, psz, line);
    OutputDebugStringA(ach);

    if (IsFlagSet(g_dwBreakFlags, BF_ONVALIDATE))
        DebugBreak();
    }


#ifdef WINNT



/*----------------------------------------------------------
Purpose: Determine id debug should be displayed
Returns: --
Cond:    --
*/
BOOL WINAPI
DisplayDebug(
    DWORD flag
    )

{
    return (IsFlagSet(g_dwTraceFlags, flag));

}

/*----------------------------------------------------------
Purpose: Wide-char version of CommonAssertMsgA
Returns: --
Cond:    --
*/
void CPUBLIC CommonAssertMsgW(
    BOOL f,
    LPCWSTR pwszMsg, ...)
    {
    WCHAR ach[DEBUG_PRINT_BUFFER_LEN];    // Largest path plus extra
    va_list vArgs;

    if (!f)
        {
        int cch;

        lstrcpyW(ach, c_wszTrace);
        cch = lstrlenW(ach);
        va_start(vArgs, pwszMsg);
        wvsprintfW(&ach[cch], pwszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);
        }
    }

/*----------------------------------------------------------
Purpose: Wide-char version of CommonDebugMsgA
Returns: --
Cond:    --
*/
void CPUBLIC CommonDebugMsgW(
    DWORD flag,
    LPCSTR pszMsg, ...)
{
    WCHAR ach[DEBUG_PRINT_BUFFER_LEN];    // Largest path plus extra
    va_list vArgs;
    DWORD dwLastError = GetLastError ();   // Save the last error

    if (IsFlagSet(g_dwTraceFlags, flag))
    {
     int cch;
     WCHAR wszBuf[MAX_BUF];
     LPWSTR pwsz;

        WCHAR wszBlank[] = L"                                                  ";
        wszBlank[g_dwIndent < 0 ? 0 : g_dwIndent] = L'\0';

#ifdef PROFILE_TRACES
        const static WCHAR szTemplate[]=TEXT("[%lu] ");
        static DWORD dwTickLast;
        static DWORD dwTickNow = 0;

        if (!dwTickNow)
        {
            lstrcpy(szTemplate, TEXT("[%lu] "));
            dwTickLast = GetTickCount();
        }
        dwTickNow = GetTickCount();
        wsprintf(ach, szTemplate, dwTickNow - dwTickLast);
        dwTickLast = dwTickNow;

        lstrcatW(ach, c_wszTrace);
#else
        lstrcpyW(ach, c_wszTrace);
#endif
        lstrcat(ach,wszBlank);

        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, ARRAYSIZE(wszBuf)))
        {
            wvsprintfW(&ach[cch], pwsz, vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
        }

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);
    }

    SetLastError (dwLastError); // Restore the last error
}

/*----------------------------------------------------------
Purpose: Wide-char version of Dbg_SafeStrA

Returns: String ptr
Cond:    --
*/
LPCWSTR PUBLIC Dbg_SafeStrW(
    LPCWSTR pwsz)
    {
    if (pwsz)
        return pwsz;
    else
        return L"NULL";
    }

#endif // WINNT


/*----------------------------------------------------------
Purpose: Assert failed message only
Returns: --
Cond:    --
*/
void CPUBLIC CommonAssertMsgA(
    BOOL f,
    LPCSTR pszMsg, ...)
    {
    CHAR ach[DEBUG_PRINT_BUFFER_LEN];    // Largest path plus extra
    va_list vArgs;

    if (!f)
        {
        int cch;

        lstrcpyA(ach, c_szTrace);
        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);
        }
    }


/*----------------------------------------------------------
Purpose: Debug spew
Returns: --
Cond:    --
*/
void CPUBLIC CommonDebugMsgA(
    DWORD flag,
    LPCSTR pszMsg, ...)
{
 CHAR ach[DEBUG_PRINT_BUFFER_LEN];    // Largest path plus extra
 va_list vArgs;
 DWORD dwLastError = GetLastError ();

    if (IsFlagSet(g_dwTraceFlags, flag))
    {
        int cch;
        char szBlank[] = "                                                  ";

        ASSERT( g_dwIndent >= 0);
        szBlank[g_dwIndent < 0 ? 0 : g_dwIndent] = 0;

        lstrcpyA(ach, c_szTrace);

        lstrcatA(ach, szBlank);

        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);
        wvsprintfA(&ach[cch], pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);
    }

    SetLastError (dwLastError);
}


#ifdef WANT_OLE_SUPPORT
/*----------------------------------------------------------
Purpose: Returns the string form of an known interface ID.

Returns: String ptr
Cond:    --
*/
LPCSTR PUBLIC Dbg_GetRiidName(
    REFIID riid)
    {
    int i;

    for (i = 0; i < ARRAYSIZE(c_rgriidmap); i++)
        {
        if (IsEqualIID(riid, c_rgriidmap[i].riid))
            return c_rgriidmap[i].psz;
        }
    return "Unknown riid";
    }
#endif

#ifdef __SCODE_H__

/*----------------------------------------------------------
Purpose: Returns the string form of an scode given an hresult.

Returns: String ptr
Cond:    --
*/
LPCSTR PUBLIC Dbg_GetScode(
    HRESULT hres)
    {
    int i;
    SCODE sc;

    sc = GetScode(hres);
    for (i = 0; i < ARRAYSIZE(c_rgscodemap); i++)
        {
        if (sc == c_rgscodemap[i].sc)
            return c_rgscodemap[i].psz;
        }
    return "Unknown scode";
    }

#endif // __SCODE_H__


/*----------------------------------------------------------
Purpose: Returns a string safe enough to print...and I don't
         mean swear words.

Returns: String ptr
Cond:    --
*/
LPCSTR PUBLIC Dbg_SafeStrA(
    LPCSTR psz)
    {
    if (psz)
        return psz;
    else
        return "NULL";
    }

#endif  // !defined(NODEBUGHELP) && defined(DEBUG)



/*----------------------------------------------------------
Purpose: Entry-point to handle any necessary initialization
         of the common data structures and functions.

Returns: TRUE on success

Cond:    --
*/
BOOL PUBLIC RovComm_Init(
    HINSTANCE hinst)
    {
    BOOL bRet = TRUE;

#ifndef NODRAWTEXT
    GetCommonMetrics(0);
#endif


    bRet = RovComm_ProcessIniFile();


    return bRet;
    }


/*----------------------------------------------------------
Purpose: Entry-point to handle termination.

Returns: TRUE on success

Cond:    --
*/
BOOL PUBLIC RovComm_Terminate(
    HINSTANCE hinst)
    {

    return TRUE;
    }



/*----------------------------------------------------------
Purpose: Returns TRUE iff user has admin priveleges

Returns: --
Cond:    --
*/
BOOL  PUBLIC IsAdminUser(void)
{
    HKEY hkey;

    if(RegOpenKeyEx(HKEY_USERS, TEXT(".DEFAULT"), 0, KEY_WRITE, &hkey) == 0)
    {
        RegCloseKey(hkey);
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\common\rovini.c ===
//
// Copyright (c) Microsoft Corporation 1993-1995
//
// rovini.c
//
// This file contains profile (.ini) routines.
// Meant to be used in conjunction with rovcomm.c.
//
// History:
//  08-06-93 ScottH     Transferred from twin code
//  05-05-95 ScottH     Made generic from Briefcase code
//


#include "proj.h"
#include <rovcomm.h>

#ifndef NOPROFILE

#pragma data_seg(DATASEG_READONLY)

// (c_szRovIniFile and c_szRovIniSecDebugUI are defined in rovdbg.h)
extern WCHAR const FAR c_szRovIniFile[];
extern WCHAR const FAR c_szRovIniSecDebugUI[];

TCHAR const FAR c_szZero[] = TEXT("0");
TCHAR const FAR c_szIniKeyBreakFlags[] = TEXT("BreakFlags");
TCHAR const FAR c_szIniKeyTraceFlags[] = TEXT("TraceFlags");
TCHAR const FAR c_szIniKeyDumpFlags[] = TEXT("DumpFlags");

#pragma data_seg()


// Some of the .ini processing code was pimped from the sync engine.
//

typedef struct _INIKEYHEADER
    {
    LPCTSTR pszSectionName;
    LPCTSTR pszKeyName;
    LPCTSTR pszDefaultRHS;
    } INIKEYHEADER;

typedef struct _BOOLINIKEY
    {
    INIKEYHEADER ikh;
    LPDWORD puStorage;
    DWORD dwFlag;
    } BOOLINIKEY;

typedef struct _INTINIKEY
    {
    INIKEYHEADER ikh;
    LPDWORD puStorage;
    } INTINIKEY;


// Some of these macros taken from prefs.h in Pen project...
//
#define PutIniIntCmp(idsSection, idsKey, nNewValue, nSave) \
    if ((nNewValue) != (nSave)) PutIniInt(idsSection, idsKey, nNewValue)

#define WritePrivateProfileInt(szApp, szKey, i, lpFileName) \
    {CHAR sz[7]; \
    WritePrivateProfileString(szApp, szKey, SzFromInt(sz, i), lpFileName);}


#ifdef SHARED_DLL
#pragma data_seg(DATASEG_PERINSTANCE)
#endif

// Array of keys with Integer RHSs to be processed by ProcessIniFile()

static INTINIKEY s_rgiik[] =
    {
        {
        { c_szRovIniSecDebugUI,    c_szIniKeyTraceFlags, TEXT("0x20000")},
        &g_dwTraceFlags
        },

        {
        { c_szRovIniSecDebugUI,    c_szIniKeyDumpFlags, c_szZero },
        &g_dwDumpFlags
        },

        {
        { c_szRovIniSecDebugUI,    c_szIniKeyBreakFlags, TEXT("0x1") },
        &g_dwBreakFlags
        },

    };


#ifdef SHARED_DLL
#pragma data_seg()
#endif


/* Boolean TRUE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCTSTR s_rgpszTrue[] =
    {
    TEXT("1"),
    TEXT("On"),
    TEXT("True"),
    TEXT("Y"),
    TEXT("Yes")
    };

/* Boolean FALSE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCTSTR s_rgpszFalse[] =
    {
    TEXT("0"),
    TEXT("Off"),
    TEXT("False"),
    TEXT("N"),
    TEXT("No")
    };




/*----------------------------------------------------------
Purpose: Determines whether a string corresponds to a boolean
          TRUE value.
Returns: The boolean value (TRUE or FALSE)
Cond:    --
*/
BOOL PRIVATE IsIniYes(
    LPCTSTR psz)
    {
    int i;
    BOOL bNotFound = TRUE;
    BOOL bResult;

    ASSERT(psz);

    /* Is the value TRUE? */

    for (i = 0; i < ARRAYSIZE(s_rgpszTrue); i++)
        {
        if (IsSzEqual(psz, s_rgpszTrue[i]))
            {
            bResult = TRUE;
            bNotFound = FALSE;
            break;
            }
        }

    /* Is the value FALSE? */

    if (bNotFound)
        {
        for (i = 0; i < ARRAYSIZE(s_rgpszFalse); i++)
            {
            if (IsSzEqual(psz, s_rgpszFalse[i]))
                {
                bResult = FALSE;
                bNotFound = FALSE;
                break;
                }
            }

        /* Is the value a known string? */

        if (bNotFound)
            {
            /* No.  Whine about it. */

            TRACE_MSG(TF_WARNING, "IsIniYes() called on unknown Boolean RHS '%s'.", psz);
            bResult = FALSE;
            }
        }

    return bResult;
    }


#if 0   // (use this as an example)
/*----------------------------------------------------------
Purpose: Process keys with boolean RHSs.
Returns: --
Cond:    --
*/
void PRIVATE ProcessBooleans(void)
    {
    int i;

    for (i = 0; i < ARRAYSIZE(s_rgbik); i++)
        {
        DWORD dwcbKeyLen;
        TCHAR szRHS[MAX_BUF];
        BOOLINIKEY * pbik = &(s_rgbik[i]);
        LPCTSTR lpcszRHS;

        /* Look for key. */

        dwcbKeyLen = GetPrivateProfileString(pbik->ikh.pszSectionName,
                                   pbik->ikh.pszKeyName, TEXT(""), szRHS,
                                   SIZECHARS(szRHS), c_szRovIniFile);

        if (dwcbKeyLen)
            lpcszRHS = szRHS;
        else
            lpcszRHS = pbik->ikh.pszDefaultRHS;

        if (IsIniYes(lpcszRHS))
            {
            if (IsFlagClear(*(pbik->puStorage), pbik->dwFlag))
                TRACE_MSG(TF_GENERAL, "ProcessIniFile(): %s set in %s![%s].",
                         pbik->ikh.pszKeyName,
                         c_szRovIniFile,
                         pbik->ikh.pszSectionName);

            SetFlag(*(pbik->puStorage), pbik->dwFlag);
            }
        else
            {
            if (IsFlagSet(*(pbik->puStorage), pbik->dwFlag))
                TRACE_MSG(TF_GENERAL, "ProcessIniFile(): %s cleared in %s![%s].",
                         pbik->ikh.pszKeyName,
                         c_szRovIniFile,
                         pbik->ikh.pszSectionName);

            ClearFlag(*(pbik->puStorage), pbik->dwFlag);
            }
        }
    }
#endif


/*----------------------------------------------------------
Purpose: Process keys with integer RHSs.
Returns: --
Cond:    --
*/
void PRIVATE ProcessIntegers(void)
    {
    int i;

    for (i = 0; i < ARRAYSIZE(s_rgiik); i++)
        {
        DWORD dwcbKeyLen;
        TCHAR szRHS[MAX_BUF];
        INTINIKEY * piik = &(s_rgiik[i]);
        LPCTSTR lpcszRHS;

        /* Look for key. */

        dwcbKeyLen = GetPrivateProfileString(piik->ikh.pszSectionName,
                                   piik->ikh.pszKeyName, TEXT(""), szRHS,
                                   SIZECHARS(szRHS), c_szRovIniFile);

        if (dwcbKeyLen)
            lpcszRHS = szRHS;
        else
            lpcszRHS = piik->ikh.pszDefaultRHS;

        AnsiToInt(lpcszRHS, (int FAR *)piik->puStorage);

        TRACE_MSG(TF_GENERAL, "ProcessIniFile(): %s set to %#08x.",
                 piik->ikh.pszKeyName, *(piik->puStorage));
        }
    }


/*----------------------------------------------------------
Purpose: Process initialization file
Returns: TRUE if initialization is successful
Cond:    --
*/
BOOL PUBLIC RovComm_ProcessIniFile(void)
    {
    BOOL bResult = TRUE;

    // Currently, all integer keys are for DEBUG use only.
    //
    ProcessIntegers();

    return bResult;
    }


#endif // NOPROFILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\common\rovdi.c ===
//
// Copyright (c) Microsoft Corporation 1993-1995
//
// rovdi.c
//
// This files contains Device Installer wrappers that we commonly use.
//
// History:
//  11-13-95 ScottH     Separated from NT modem class installer
//

#define REENUMERATE_PORT

#include "proj.h"
#include "rovcomm.h"
#include <cfgmgr32.h>

#include <debugmem.h>

#define MAX_REG_KEY_LEN         128
#define CB_MAX_REG_KEY_LEN      (MAX_REG_KEY_LEN * sizeof(TCHAR))


//-----------------------------------------------------------------------------------
//  Port mapping functions
//-----------------------------------------------------------------------------------

#define CPORTPAIR   8

#ifdef REENUMERATE_PORT
typedef struct tagPORTPAIR
{
    DEVNODE devNode;
    WCHAR   szPortName[MAX_BUF];
    WCHAR   szFriendlyName[MAX_BUF];
} PORTPAIR, FAR * LPPORTPAIR;
#else // REENUMERATE_PORT not defined
typedef struct tagPORTPAIR
{
    CHAR    szPortName[MAX_BUF];
    CHAR    szFriendlyName[MAX_BUF];
} PORTPAIR, FAR * LPPORTPAIR;
#endif // REENUMERATE_PORT

typedef struct tagPORTMAP
    {
    LPPORTPAIR      rgports;    // Alloc
    int             cports;
    } PORTMAP, FAR * LPPORTMAP;


/*----------------------------------------------------------
Purpose: Performs a local realloc my way

Returns: TRUE on success
Cond:    --
*/
BOOL PRIVATE MyReAlloc(
    LPVOID FAR * ppv,
    int cbOld,
    int cbNew)
    {
    LPVOID pv = (LPVOID)ALLOCATE_MEMORY( cbNew);

    if (pv)
        {
        CopyMemory(pv, *ppv, min(cbOld, cbNew));
        FREE_MEMORY(*ppv);
        *ppv = pv;
        }

    return (NULL != pv);
    }


#ifdef REENUMERATE_PORT
/*----------------------------------------------------------
Purpose: Device enumerator callback.  Adds another device to the
         map table.

Returns: TRUE to continue enumeration
Cond:    --
*/
BOOL
CALLBACK
PortMap_Add (
    HPORTDATA hportdata,
    LPARAM lParam)
{
 BOOL bRet;
 PORTDATA pd;

    pd.cbSize = sizeof(pd);
    bRet = PortData_GetProperties (hportdata, &pd);
    if (bRet)
    {
     LPPORTMAP pmap = (LPPORTMAP)lParam;
     LPPORTPAIR ppair;
     int cb;
     int cbUsed;

        // Time to reallocate the table?
        cb = (int)SIZE_OF_MEMORY(pmap->rgports);
        cbUsed = pmap->cports * sizeof(*ppair);
        if (cbUsed >= cb)
        {
            // Yes
            cb += (CPORTPAIR * sizeof(*ppair));

            bRet = MyReAlloc((LPVOID FAR *)&pmap->rgports, cbUsed, cb);
        }


        if (bRet)
        {
            ppair = &pmap->rgports[pmap->cports++];

#ifdef UNICODE
            lstrcpy(ppair->szPortName, pd.szPort);
            lstrcpy(ppair->szFriendlyName, pd.szFriendly);
#else
            WideCharToMultiByte(CP_ACP, 0, pd.szPort, -1, ppair->szPortName, SIZECHARS(ppair->szPortName), 0, 0);
            WideCharToMultiByte(CP_ACP, 0, pd.szFriendly, -1, ppair->szFriendlyName, SIZECHARS(ppair->szFriendlyName), 0, 0);
#endif

            DEBUG_CODE( TRACE_MSG(TF_GENERAL, "Added %s <-> %s to portmap",
                        ppair->szPortName, ppair->szFriendlyName); )
        }
    }

    return bRet;
}
#else  //REENUMERATE_PORT not defined
/*----------------------------------------------------------
Purpose: Device enumerator callback.  Adds another device to the
         map table.

Returns: TRUE to continue enumeration
Cond:    --
*/
BOOL
CALLBACK
PortMap_Add(
    HPORTDATA hportdata,
    LPARAM lParam)
    {
    BOOL bRet;
    PORTDATA pd;

    pd.cbSize = sizeof(pd);
    bRet = PortData_GetProperties(hportdata, &pd);
    if (bRet)
        {
        LPPORTMAP pmap = (LPPORTMAP)lParam;
        LPPORTPAIR ppair;
        int cb;
        int cbUsed;

        // Time to reallocate the table?
        cb = SIZE_OF_MEMORY(pmap->rgports);
        cbUsed = pmap->cports * sizeof(*ppair);
        if (cbUsed >= cb)
            {
            // Yes
            cb += (CPORTPAIR * sizeof(*ppair));

            bRet = MyReAlloc((LPVOID FAR *)&pmap->rgports, cbUsed, cb);
            }


        if (bRet)
            {
            ppair = &pmap->rgports[pmap->cports++];

#ifdef UNICODE
            // Fields of LPPORTPAIR are always ANSI
            WideCharToMultiByte(CP_ACP, 0, pd.szPort, -1, ppair->szPortName, SIZECHARS(ppair->szPortName), 0, 0);
            WideCharToMultiByte(CP_ACP, 0, pd.szFriendly, -1, ppair->szFriendlyName, SIZECHARS(ppair->szFriendlyName), 0, 0);
#else
            lstrcpy(ppair->szPortName, pd.szPort);
            lstrcpy(ppair->szFriendlyName, pd.szFriendly);
#endif

            DEBUG_CODE( TRACE_MSG(TF_GENERAL, "Added %s <-> %s to portmap",
                        ppair->szPortName, ppair->szFriendlyName); )
            }
        }

    return bRet;
    }
#endif // REENUMERATE_PORT


#ifdef REENUMERATE_PORT
void
PortMap_InitDevInst (LPPORTMAP pmap)
{
 DWORD      dwDeviceIDListSize = 4*1024;     // start with 4k TCHAR space
 TCHAR     *szDeviceIDList = NULL;
 CONFIGRET  cr;

    if (NULL == pmap ||
        0 >= pmap->cports)
    {
//  BRL 9/4/98, bug 217715
//        ASSERT(0);
        return;
    }

    // First, get the list of all devices
    do
    {
        szDeviceIDList = ALLOCATE_MEMORY(
                                     dwDeviceIDListSize*sizeof(TCHAR));
        if (NULL == szDeviceIDList)
        {
            break;
        }

        cr = CM_Get_Device_ID_List (NULL,
                                    szDeviceIDList,
                                    dwDeviceIDListSize,
                                    CM_GETIDLIST_FILTER_NONE);
        if (CR_SUCCESS != cr)
        {
            FREE_MEMORY(szDeviceIDList);
            szDeviceIDList = NULL;

            if (CR_BUFFER_SMALL != cr ||
                CR_SUCCESS != CM_Get_Device_ID_List_Size (&dwDeviceIDListSize,
                                                          NULL,
                                                          CM_GETIDLIST_FILTER_NONE))
            {
                break;
            }
        }
    } while (CR_SUCCESS != cr);

    // If we got the list, look for all
    // devices that have a port name, and
    // update the port map
    if (NULL != szDeviceIDList)
    {
     DEVINST devInst;
     DWORD  cbData;
     DWORD  dwRet;
     int    cbRemaining = pmap->cports;
     //int    i;
     HKEY   hKey;
     LPPORTPAIR pPort, pLast = pmap->rgports + (pmap->cports-1);
     TCHAR *szDeviceID;
     PORTPAIR   portTemp;
     TCHAR  szPort[MAX_BUF];

        for (szDeviceID = szDeviceIDList;
             *szDeviceID && 0 < cbRemaining;
             szDeviceID += lstrlen(szDeviceID)+1)
        {
            // First, locate the devinst
            if (CR_SUCCESS != CM_Locate_DevInst (&devInst,
                                                 szDeviceID,
                                                 CM_LOCATE_DEVNODE_NORMAL))
            {
                // We couldn't locate this devnode;
                // go to the next one;
                TRACE_MSG(TF_ERROR, "Could not locate devnode for %s.", szDeviceID);
                continue;
            }

            // Then, open the registry key for the devinst
            if (CR_SUCCESS != CM_Open_DevNode_Key (devInst,
                                                   KEY_QUERY_VALUE,
                                                   0,
                                                   RegDisposition_OpenExisting,
                                                   &hKey,
                                                   CM_REGISTRY_HARDWARE))
            {
                TRACE_MSG(TF_ERROR, "Could not open hardware key for %s.", szDeviceID);
                continue;
            }

            // Now, try to read the "PortName"
            cbData = sizeof (szPort);
            dwRet = RegQueryValueEx (hKey,
                                     REGSTR_VAL_PORTNAME,
                                     NULL,
                                     NULL,
                                     (PBYTE)szPort,
                                     &cbData);
            RegCloseKey (hKey);
            if (ERROR_SUCCESS != dwRet)
            {
                TRACE_MSG(TF_ERROR, "Could not read PortName for %s.", szDeviceID);
                continue;
            }

            // If we got here, we have a PortName;
            // look for it in our map, and if we find
            // it, update the devNode and FriendlyName
            for (/*i = 0, */pPort = pmap->rgports;
                 /*i < cbRemaining*/pPort <= pLast;
                 /*i++, */pPort++)
            {
                if (0 == lstrcmpiW (szPort, pPort->szPortName))
                {
                    // Found the port;
                    // first, initialize the DevInst
                    pPort->devNode = devInst;

                    // then, if possible, update the friendly name
                    cbData = sizeof(szPort);
                    if (CR_SUCCESS ==
                        CM_Get_DevNode_Registry_Property (devInst,
                                                          CM_DRP_FRIENDLYNAME,
                                                          NULL,
                                                          (PVOID)szPort,
                                                          &cbData,
                                                          0))
                    {
                        lstrcpyW (pPort->szFriendlyName, szPort);
                    }

                    // This is an optimization, so that next time
                    // we don't cycle throught the whole list
                    if (0 < --cbRemaining)
                    {
                        // move this item to the
                        // end of the array
                        portTemp = *pPort;
                        *pPort = *pLast;
                        *pLast = portTemp;
                        pLast--;
                    }

                    break;
                }
            }
        }

        FREE_MEMORY(szDeviceIDList);
    }
}


/*----------------------------------------------------------
Purpose: Wide-char version.  This function creates a port map
         table that maps port names to friendly names, and
         vice-versa.

Returns: TRUE on success
Cond:    --
*/
BOOL
APIENTRY
PortMap_Create (
    OUT HPORTMAP FAR * phportmap)
{
 LPPORTMAP pmap;

    pmap = (LPPORTMAP)ALLOCATE_MEMORY( sizeof(*pmap));
    if (pmap)
    {
        // Initially alloc 8 entries
        pmap->rgports = (LPPORTPAIR)ALLOCATE_MEMORY( CPORTPAIR*sizeof(*pmap->rgports));
        if (pmap->rgports)
        {
            // Fill the map table
            EnumeratePorts (PortMap_Add, (LPARAM)pmap);
            PortMap_InitDevInst (pmap);
        }
        else
        {
            // Error
            FREE_MEMORY(pmap);
            pmap = NULL;
        }
    }

    *phportmap = (HPORTMAP)pmap;

    return (NULL != pmap);
}
#else  // REENUMERATE_PORT not defined
BOOL
APIENTRY
PortMap_Create(
    OUT HPORTMAP FAR * phportmap)
    {
    LPPORTMAP pmap;

    pmap = (LPPORTMAP)ALLOCATE_MEMORY( sizeof(*pmap));
    if (pmap)
        {
        // Initially alloc 8 entries
        pmap->rgports = (LPPORTPAIR)ALLOCATE_MEMORY( CPORTPAIR*sizeof(*pmap->rgports));
        if (pmap->rgports)
            {
            // Fill the map table
            EnumeratePorts(PortMap_Add, (LPARAM)pmap);
            }
        else
            {
            // Error
            FREE_MEMORY(pmap);
            pmap = NULL;
            }
        }

    *phportmap = (HPORTMAP)pmap;

    return (NULL != pmap);
    }
#endif // REENUMERATE_PORT


/*----------------------------------------------------------
Purpose: Gets the count of ports on the system.

Returns: see above
Cond:    --
*/
DWORD
APIENTRY
PortMap_GetCount(
    IN HPORTMAP hportmap)
    {
    DWORD dwRet;
    LPPORTMAP pmap = (LPPORTMAP)hportmap;

    try
        {
        dwRet = pmap->cports;
        }
    except (EXCEPTION_EXECUTE_HANDLER)
        {
        dwRet = 0;
        }

    return dwRet;
    }



#ifdef REENUMERATE_PORT
/*----------------------------------------------------------
Purpose: Gets the friendly name given the port name and places
         a copy in the supplied buffer.

         If no port name is found, the contents of the supplied
         buffer is not changed.

         Wide-char version.

Returns: TRUE on success
         FALSE if the port name is not found
Cond:    --
*/
BOOL
APIENTRY
PortMap_GetFriendlyW (
    IN  HPORTMAP hportmap,
    IN  LPCWSTR  pwszPortName,
    OUT LPWSTR   pwszBuf,
    IN  DWORD    cchBuf)
{
 LPPORTMAP pmap = (LPPORTMAP)hportmap;

    ASSERT(pmap);
    ASSERT(pwszPortName);
    ASSERT(pwszBuf);

    try
    {
     LPPORTPAIR pport = pmap->rgports;
     int cports = pmap->cports;
     int i;

        for (i = 0; i < cports; i++, pport++)
        {
            if (0 == lstrcmpiW (pwszPortName, pport->szPortName))
            {
                lstrcpynW (pwszBuf, pport->szFriendlyName, cchBuf);
                return TRUE;
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return FALSE;
}


/*----------------------------------------------------------
Purpose: Gets the friendly name given the port name and places
         a copy in the supplied buffer.

         If no port name is found, the contents of the supplied
         buffer is not changed.

Returns: TRUE on success
         FALSE if the port name is not found
Cond:    --
*/
BOOL
APIENTRY
PortMap_GetFriendlyA (
    IN  HPORTMAP hportmap,
    IN  LPCSTR   pszPortName,
    OUT LPSTR    pszBuf,
    IN  DWORD    cchBuf)
{
 BOOL bRet;

    ASSERT(pszPortName);
    ASSERT(pszBuf);

    try
    {
     WCHAR szPort[MAX_BUF_MED];
     WCHAR szBuf[MAX_BUF];

        MultiByteToWideChar (CP_ACP, 0, pszPortName, -1, szPort, SIZECHARS(szPort));

        bRet = PortMap_GetFriendlyW (hportmap, szPort, szBuf, SIZECHARS(szBuf));

        if (bRet)
        {
            WideCharToMultiByte (CP_ACP, 0, szBuf, -1, pszBuf, cchBuf, 0, 0);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError (ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Gets the port name given the friendly name and places
         a copy in the supplied buffer.

         If no friendly name is found, the contents of the supplied
         buffer is not changed.

         Wide-char version.

Returns: TRUE on success
         FALSE if the friendly name is not found
Cond:    --
*/
BOOL
APIENTRY
PortMap_GetPortNameW (
    IN  HPORTMAP hportmap,
    IN  LPCWSTR  pwszFriendly,
    OUT LPWSTR   pwszBuf,
    IN  DWORD    cchBuf)
{
 LPPORTMAP pmap = (LPPORTMAP)hportmap;

    ASSERT(pmap);
    ASSERT(pwszFriendly);
    ASSERT(pwszBuf);

    try
    {
     LPPORTPAIR pport = pmap->rgports;
     int cports = pmap->cports;
     int i;

        for (i = 0; i < cports; i++, pport++)
        {
            if (0 == lstrcmpiW (pwszFriendly, pport->szFriendlyName))
            {
                lstrcpynW (pwszBuf, pport->szPortName, cchBuf);
                return TRUE;
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return FALSE;
}


/*----------------------------------------------------------
Purpose: Gets the port name given the friendly name and places
         a copy in the supplied buffer.

         If no friendly name is found, the contents of the supplied
         buffer is not changed.

Returns: TRUE
         FALSE if the friendly name is not found

Cond:    --
*/
BOOL
APIENTRY
PortMap_GetPortNameA (
    IN  HPORTMAP hportmap,
    IN  LPCSTR   pszFriendly,
    OUT LPSTR    pszBuf,
    IN  DWORD    cchBuf)
{
 BOOL bRet;

    ASSERT(pszFriendly);
    ASSERT(pszBuf);

    try
    {
     WCHAR szFriendly[MAX_BUF];
     WCHAR szBuf[MAX_BUF_MED];

        MultiByteToWideChar(CP_ACP, 0, pszFriendly, -1, szFriendly, SIZECHARS(szFriendly));

        bRet = PortMap_GetPortNameW (hportmap, szFriendly, szBuf, SIZECHARS(szBuf));

        if (bRet)
        {
            WideCharToMultiByte(CP_ACP, 0, szBuf, -1, pszBuf, cchBuf, 0, 0);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        bRet = FALSE;
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Gets the device instance, given the port name

Returns: TRUE
         FALSE if the friendly name is not found

Cond:    --
*/
BOOL
APIENTRY
PortMap_GetDevNodeW (
    IN  HPORTMAP hportmap,
    IN  LPCWSTR  pszPortName,
    OUT LPDWORD  pdwDevNode)
{
 LPPORTMAP pmap = (LPPORTMAP)hportmap;

    ASSERT(pmap);
    ASSERT(pszPortName);
    ASSERT(pdwDevNode);

    try
    {
     LPPORTPAIR pport = pmap->rgports;
     int cports = pmap->cports;
     int i;

        for (i = 0; i < cports; i++, pport++)
        {
            if (0 == lstrcmpiW (pszPortName, pport->szPortName))
            {
                *pdwDevNode = pport->devNode;
                return TRUE;
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return FALSE;
}


BOOL
APIENTRY
PortMap_GetDevNodeA (
    IN  HPORTMAP hportmap,
    IN  LPCSTR   pszPortName,
    OUT LPDWORD  pdwDevNode)
{
 BOOL bRet;

    ASSERT(pszPortName);
    ASSERT(pdwDevNode);

    try
    {
     WCHAR szPort[MAX_BUF];

        MultiByteToWideChar(CP_ACP, 0, pszPortName, -1, szPort, SIZECHARS(szPort));

        bRet = PortMap_GetDevNodeW (hportmap, szPort, pdwDevNode);
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        bRet = FALSE;
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return bRet;
}

#else  // REENUMERATE_PORT not defined
/*----------------------------------------------------------
Purpose: Gets the friendly name given the port name and places
         a copy in the supplied buffer.

         If no port name is found, the contents of the supplied
         buffer is not changed.

         Wide-char version.

Returns: TRUE on success
         FALSE if the port name is not found
Cond:    --
*/
BOOL
APIENTRY
PortMap_GetFriendlyW(
    IN  HPORTMAP hportmap,
    IN  LPCWSTR pwszPortName,
    OUT LPWSTR pwszBuf,
    IN  DWORD cchBuf)
    {
    BOOL bRet;

    ASSERT(pwszPortName);
    ASSERT(pwszBuf);

    try
        {
        CHAR szPort[MAX_BUF_MED];
        CHAR szBuf[MAX_BUF];

        WideCharToMultiByte(CP_ACP, 0, pwszPortName, -1, szPort, SIZECHARS(szPort), 0, 0);

        bRet = PortMap_GetFriendlyA(hportmap, szPort, szBuf, SIZECHARS(szBuf));

        if (bRet)
            {
            MultiByteToWideChar(CP_ACP, 0, szBuf, -1, pwszBuf, cchBuf);
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER)
        {
        SetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Gets the friendly name given the port name and places
         a copy in the supplied buffer.

         If no port name is found, the contents of the supplied
         buffer is not changed.

Returns: TRUE on success
         FALSE if the port name is not found
Cond:    --
*/
BOOL
APIENTRY
PortMap_GetFriendlyA(
    IN  HPORTMAP hportmap,
    IN  LPCSTR pszPortName,
    OUT LPSTR pszBuf,
    IN  DWORD cchBuf)
    {
    LPPORTMAP pmap = (LPPORTMAP)hportmap;

    ASSERT(pmap);
    ASSERT(pszPortName);
    ASSERT(pszBuf);

    try
        {
        LPPORTPAIR pport = pmap->rgports;
        int cports = pmap->cports;
        int i;

        for (i = 0; i < cports; i++, pport++)
            {
            if (0 == lstrcmpiA(pszPortName, pport->szPortName))
                {
                lstrcpynA(pszBuf, pport->szFriendlyName, cchBuf);
                return TRUE;
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER)
        {
        SetLastError(ERROR_INVALID_PARAMETER);
        }

    return FALSE;
    }


/*----------------------------------------------------------
Purpose: Gets the port name given the friendly name and places
         a copy in the supplied buffer.

         If no friendly name is found, the contents of the supplied
         buffer is not changed.

         Wide-char version.

Returns: TRUE on success
         FALSE if the friendly name is not found
Cond:    --
*/
BOOL
APIENTRY
PortMap_GetPortNameW(
    IN  HPORTMAP hportmap,
    IN  LPCWSTR pwszFriendly,
    OUT LPWSTR pwszBuf,
    IN  DWORD cchBuf)
    {
    BOOL bRet;

    ASSERT(pwszFriendly);
    ASSERT(pwszBuf);

    try
        {
        CHAR szFriendly[MAX_BUF];
        CHAR szBuf[MAX_BUF_MED];

        WideCharToMultiByte(CP_ACP, 0, pwszFriendly, -1, szFriendly, SIZECHARS(szFriendly), 0, 0);

        bRet = PortMap_GetPortNameA(hportmap, szFriendly, szBuf, SIZECHARS(szBuf));

        if (bRet)
            {
            MultiByteToWideChar(CP_ACP, 0, szBuf, -1, pwszBuf, cchBuf);
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER)
        {
        bRet = FALSE;
        SetLastError(ERROR_INVALID_PARAMETER);
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Gets the port name given the friendly name and places
         a copy in the supplied buffer.

         If no friendly name is found, the contents of the supplied
         buffer is not changed.

Returns: TRUE
         FALSE if the friendly name is not found

Cond:    --
*/
BOOL
APIENTRY
PortMap_GetPortNameA(
    IN  HPORTMAP hportmap,
    IN  LPCSTR pszFriendly,
    OUT LPSTR pszBuf,
    IN  DWORD cchBuf)
    {
    LPPORTMAP pmap = (LPPORTMAP)hportmap;

    ASSERT(pmap);
    ASSERT(pszFriendly);
    ASSERT(pszBuf);

    try
        {
        LPPORTPAIR pport = pmap->rgports;
        int cports = pmap->cports;
        int i;

        for (i = 0; i < cports; i++, pport++)
            {
            if (0 == lstrcmpiA(pszFriendly, pport->szFriendlyName))
                {
                lstrcpynA(pszBuf, pport->szPortName, cchBuf);
                return TRUE;
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER)
        {
        SetLastError(ERROR_INVALID_PARAMETER);
        }

    return FALSE;
    }
#endif // REENUMERATE_PORT

/*----------------------------------------------------------
Purpose: Frees a port map

Returns: --
Cond:    --
*/
BOOL
APIENTRY
PortMap_Free(
    IN  HPORTMAP hportmap)
    {
    LPPORTMAP pmap = (LPPORTMAP)hportmap;

    if (pmap)
        {
        if (pmap->rgports)
            FREE_MEMORY(pmap->rgports);

        FREE_MEMORY(pmap);
        }
    return TRUE;
    }


//-----------------------------------------------------------------------------------
//  Port enumeration functions
//-----------------------------------------------------------------------------------


#pragma data_seg(DATASEG_READONLY)

TCHAR const FAR c_szSerialComm[] = TEXT("HARDWARE\\DEVICEMAP\\SERIALCOMM");

#pragma data_seg()


/*----------------------------------------------------------
Purpose: Enumerates all the ports on the system and calls pfnDevice.

         pfnDevice can terminate the enumeration by returning FALSE.

Returns: NO_ERROR if at least one port was found
Cond:    --
*/
#ifdef _USE_SERIAL_INTERFACE
DWORD
APIENTRY
EnumeratePorts(
    IN  ENUMPORTPROC pfnDevice,
    IN  LPARAM lParam)              OPTIONAL
{
 DWORD dwRet = NO_ERROR;
 HDEVINFO hdi;
 GUID guidSerialInterface = {0xB115ED80L, 0x46DF, 0x11D0, 0xB4, 0x65, 0x00,
     0x00, 0x1A, 0x18, 0x18, 0xE6};
 DWORD dwIndex = 0;
 SP_DEVICE_INTERFACE_DATA devInterfaceData;
 SP_DEVINFO_DATA devInfoData;
 HKEY hKeyDev = INVALID_HANDLE_VALUE;
 PORTDATA pd;
 BOOL bContinue;
 DWORD dwType;
 DWORD cbData;

    // First build a list of all the device that suppoort serial port interface
    hdi = SetupDiGetClassDevs (&guidSerialInterface, NULL, NULL, DIGCF_DEVICEINTERFACE);
    if (INVALID_HANDLE_VALUE == hdi)
    {
        dwRet = GetLastError ();
        goto _ErrRet;
    }

    pd.cbSize = sizeof (PORTDATA);
    devInterfaceData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);
    devInfoData.cbSize = sizeof (SP_DEVINFO_DATA);
    // Enumerate the interface devices
    for (dwIndex = 0;
         SetupDiEnumInterfaceDevice (hdi, NULL, &guidSerialInterface, dwIndex, &devInterfaceData);
         dwIndex++)
    {
        // For each interface device, get the parent device node
        if (SetupDiGetDeviceInterfaceDetail (hdi, &devInterfaceData, NULL, 0, NULL, &devInfoData) ||
            ERROR_INSUFFICIENT_BUFFER == GetLastError ())
        {
            // open the registry key for the node ...
            hKeyDev = SetupDiOpenDevRegKey (hdi, &devInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DEV, KEY_READ);
            if (INVALID_HANDLE_VALUE == hKeyDev)
            {
                dwRet = GetLastError ();
                continue;
            }

            // ... and get the value for PortName
            cbData = sizeof(pd.szPort);
            dwRet = RegQueryValueEx (hKeyDev, TEXT("PortName"), NULL, &dwType, &pd.szPort, &cbData);
            RegCloseKey(hKeyDev);
            if (ERROR_SUCCESS == dwRet)
            {
                pd.nSubclass = PORT_SUBCLASS_SERIAL;
                // now, try to get the friendly name from the dev node
                if (!SetupDiGetDeviceRegistryProperty (hdi, &devInfoData, SPDRP_FRIENDLYNAME,
                    NULL, &pd.szFriendly, sizeof (pd.szFriendly), NULL))
                {
                    // if unsuccessfull, just copy the port name
                    // to the friendly name
                    lstrcpy(pd.szFriendly, pd.szPort);
                }

                // call the callback
                bContinue = pfnDevice((HPORTDATA)&pd, lParam);

                // Continue?
                if ( !bContinue )
                {
                    // No
                    break;
                }
            }
        }
        else
        {
            dwRet = GetLastError ();
        }
    }

_ErrRet:
    if (INVALID_HANDLE_VALUE != hdi)
    {
        SetupDiDestroyDeviceInfoList (hdi);
    }

    return dwRet;
}
#else  // not defined _USE_SERIAL_INTERFACE
DWORD
APIENTRY
EnumeratePorts(
    IN  ENUMPORTPROC pfnDevice,
    IN  LPARAM lParam)              OPTIONAL
{
 DWORD dwRet;
 HKEY hkeyEnum;

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, c_szSerialComm, &hkeyEnum);
    if (NO_ERROR == dwRet)
    {
     BOOL bContinue;
     PORTDATA pd;
     DWORD iSubKey;
     TCHAR szValue[MAX_BUF];
     DWORD cbValue;
     DWORD cbData;
     DWORD dwType;

        dwRet = ERROR_PATH_NOT_FOUND;       // assume no ports

        iSubKey = 0;

        cbValue = sizeof(szValue) / sizeof(TCHAR);
        cbData = sizeof(pd.szPort);

        while (NO_ERROR == RegEnumValue(hkeyEnum, iSubKey++, szValue, &cbValue,
                            NULL, &dwType, (LPBYTE)pd.szPort, &cbData))
        {
            if (REG_SZ == dwType)
            {
                // Friendly name is the same as the port name right now
                dwRet = NO_ERROR;

                pd.nSubclass = PORT_SUBCLASS_SERIAL;
                lstrcpy(pd.szFriendly, pd.szPort);

                bContinue = pfnDevice((HPORTDATA)&pd, lParam);

                // Continue?
                if ( !bContinue )
                {
                    // No
                    break;
                }
            }

            cbValue = sizeof(szValue);
            cbData = sizeof(pd.szPort);
        }

        RegCloseKey(hkeyEnum);
    }

    return dwRet;
}
#endif  // _USE_SERIAL_INTERFACE



/*----------------------------------------------------------
Purpose: This function fills the given buffer with the properties
         of the particular port.

         Wide-char version.

Returns: TRUE on success
Cond:    --
*/
BOOL
APIENTRY
PortData_GetPropertiesW(
    IN  HPORTDATA       hportdata,
    OUT LPPORTDATA_W    pdataBuf)
    {
    BOOL bRet = FALSE;

    ASSERT(hportdata);
    ASSERT(pdataBuf);

    if (hportdata && pdataBuf)
        {
        // Is the handle to a Widechar version?
        if (sizeof(PORTDATA_W) == pdataBuf->cbSize)
            {
            // Yes
            LPPORTDATA_W ppd = (LPPORTDATA_W)hportdata;

            pdataBuf->nSubclass = ppd->nSubclass;

            lstrcpynW(pdataBuf->szPort, ppd->szPort, SIZECHARS(pdataBuf->szPort));
            lstrcpynW(pdataBuf->szFriendly, ppd->szFriendly, SIZECHARS(pdataBuf->szFriendly));

            bRet = TRUE;
            }
        else if (sizeof(PORTDATA_A) == pdataBuf->cbSize)
            {
            // No; this is the Ansi version
            LPPORTDATA_A ppd = (LPPORTDATA_A)hportdata;

            pdataBuf->nSubclass = ppd->nSubclass;

            MultiByteToWideChar(CP_ACP, 0, ppd->szPort, -1, pdataBuf->szPort, SIZECHARS(pdataBuf->szPort));
            MultiByteToWideChar(CP_ACP, 0, ppd->szFriendly, -1, pdataBuf->szFriendly, SIZECHARS(pdataBuf->szFriendly));

            bRet = TRUE;
            }
        else
            {
            // Some invalid size
            ASSERT(0);
            }
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: This function fills the given buffer with the properties
         of the particular port.

Returns: TRUE on success
Cond:    --
*/
BOOL
APIENTRY
PortData_GetPropertiesA(
    IN  HPORTDATA       hportdata,
    OUT LPPORTDATA_A    pdataBuf)
    {
    BOOL bRet = FALSE;

    ASSERT(hportdata);
    ASSERT(pdataBuf);

    if (hportdata && pdataBuf)
        {
        // Is the handle to a Widechar version?
        if (sizeof(PORTDATA_W) == pdataBuf->cbSize)
            {
            // Yes
            LPPORTDATA_W ppd = (LPPORTDATA_W)hportdata;

            pdataBuf->nSubclass = ppd->nSubclass;

            WideCharToMultiByte(CP_ACP, 0, ppd->szPort, -1, pdataBuf->szPort, SIZECHARS(pdataBuf->szPort), NULL, NULL);
            WideCharToMultiByte(CP_ACP, 0, ppd->szFriendly, -1, pdataBuf->szFriendly, SIZECHARS(pdataBuf->szFriendly), NULL, NULL);

            bRet = TRUE;
            }
        else if (sizeof(PORTDATA_A) == pdataBuf->cbSize)
            {
            // No; this is the Ansi version
            LPPORTDATA_A ppd = (LPPORTDATA_A)hportdata;

            pdataBuf->nSubclass = ppd->nSubclass;

            lstrcpynA(pdataBuf->szPort, ppd->szPort, SIZECHARS(pdataBuf->szPort));
            lstrcpynA(pdataBuf->szFriendly, ppd->szFriendly, SIZECHARS(pdataBuf->szFriendly));

            bRet = TRUE;
            }
        else
            {
            // Some invalid size
            ASSERT(0);
            }
        }

    return bRet;
    }


//-----------------------------------------------------------------------------------
//  DeviceInstaller wrappers and support functions
//-----------------------------------------------------------------------------------

#pragma data_seg(DATASEG_READONLY)

static TCHAR const c_szBackslash[]      = TEXT("\\");
static TCHAR const c_szSeparator[]      = TEXT("::");
static TCHAR const c_szFriendlyName[]   = TEXT("FriendlyName"); // REGSTR_VAL_FRIENDLYNAME
static TCHAR const c_szDeviceType[]     = TEXT("DeviceType");   // REGSTR_VAL_DEVTYPE
static TCHAR const c_szAttachedTo[]     = TEXT("AttachedTo");
static TCHAR const c_szPnPAttachedTo[]  = TEXT("PnPAttachedTo");
static TCHAR const c_szDriverDesc[]     = TEXT("DriverDesc");   // REGSTR_VAL_DRVDESC
static TCHAR const c_szManufacturer[]   = TEXT("Manufacturer");
static TCHAR const c_szRespKeyName[]    = TEXT("ResponsesKeyName");

TCHAR const c_szRefCount[]       = TEXT("RefCount");
TCHAR const c_szResponses[]      = TEXT("Responses");

#define DRIVER_KEY      REGSTR_PATH_SETUP TEXT("\\Unimodem\\DeviceSpecific")
#define RESPONSES_KEY   TEXT("\\Responses")

#pragma data_seg()


/*----------------------------------------------------------
Purpose: This function returns the bus type on which the device
         can be enumerated.

Returns: TRUE on success

Cond:    --
*/
#include <initguid.h>
#include <wdmguid.h>

BOOL
PUBLIC
CplDiGetBusType(
    IN  HDEVINFO        hdi,
    IN  PSP_DEVINFO_DATA pdevData,          OPTIONAL
    OUT LPDWORD         pdwBusType)
{
 BOOL bRet = TRUE;
 ULONG ulStatus, ulProblem = 0;
#ifdef DEBUG
 CONFIGRET cr;
#endif

#ifdef DEBUG
 TCHAR *szBuses[] = {TEXT("BUS_TYPE_UNKNOWN"),
                     TEXT("BUS_TYPE_ROOT"),
                     TEXT("BUS_TYPE_PCMCIA"),
                     TEXT("BUS_TYPE_SERENUM"),
                     TEXT("BUS_TYPE_LPTENUM"),
                     TEXT("BUS_TYPE_OTHER"),
                     TEXT("BUS_TYPE_ISAPNP")};
#endif // DEBUG

    DBG_ENTER(CplDiGetBusType);

    ASSERT(hdi && INVALID_HANDLE_VALUE != hdi);
    ASSERT(pdwBusType);

#ifdef DEBUG
    cr = CM_Get_DevInst_Status (&ulStatus, &ulProblem, pdevData->DevInst, 0);
    if ((CR_SUCCESS == cr) &&
#else
    if (CR_SUCCESS == CM_Get_DevInst_Status (&ulStatus, &ulProblem, pdevData->DevInst, 0) &&
#endif
        (ulStatus & DN_ROOT_ENUMERATED))
    {
        *pdwBusType = BUS_TYPE_ROOT;
        TRACE_MSG(TF_GENERAL, "CplDiGetBusType: BUS_TYPE_ROOT");
    }
    else
    {
     GUID guid;
#ifdef DEBUG
     if (CR_SUCCESS != cr)
     {
         TRACE_MSG(TF_ERROR, "CM_Get_DevInst_Status failed: %#lx.", cr);
     }
#endif
        // either CM_Get_DevInst_Status failed, which means that the device
        // is plug & play and not present (i.e. plugged out),
        // or the device is not root-enumerated;
        // either way, it's a plug & play device.
        *pdwBusType = BUS_TYPE_OTHER;   // the default

        // If the next call fails, it means that the device is
        // BIOS / firmware enumerated; this is OK - we just return BUT_TYPE_OTHER
        if (SetupDiGetDeviceRegistryProperty (hdi, pdevData, SPDRP_BUSTYPEGUID, NULL,
                                              (PBYTE)&guid, sizeof(guid), NULL))
        {
         int i;
         struct
         {
             GUID const *pguid;
             DWORD dwBusType;
         } BusTypes[] = {{&GUID_BUS_TYPE_SERENUM, BUS_TYPE_SERENUM},
                         {&GUID_BUS_TYPE_PCMCIA, BUS_TYPE_PCMCIA},
                         {&GUID_BUS_TYPE_ISAPNP, BUS_TYPE_ISAPNP}};

            TRACE_MSG(TF_GENERAL, "Bus GUID is {%lX-%lX-%lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}.",
                      guid.Data1, (LONG)guid.Data2, (LONG)guid.Data3, (LONG)guid.Data4[0],
                      (LONG)guid.Data4[1], (LONG)guid.Data4[2], (LONG)guid.Data4[3],
                      (LONG)guid.Data4[4], (LONG)guid.Data4[5], (LONG)guid.Data4[6], (LONG)guid.Data4[7]);

            for (i = 0;
                 i < sizeof (BusTypes) / sizeof (BusTypes[0]);
                 i ++)
            {
                if (IsEqualGUID (BusTypes[i].pguid, &guid))
                {
                    *pdwBusType = BusTypes[i].dwBusType;
                    break;
                }
            }
        }
#ifdef DEBUG
        else
        {
            TRACE_MSG (TF_ERROR, "SetupDiGetDeviceRegistryProperty failed: %#lx.", GetLastError ());
        }
#endif
    }

#ifdef DEBUG
    TRACE_MSG(TF_GENERAL, "CplDiGetBusType: bus is %s", szBuses[*pdwBusType]);
#endif //DEBUG
    DBG_EXIT_BOOL(CplDiGetBusType, bRet);
    return bRet;
}


/*----------------------------------------------------------
Purpose: This function returns the name of the common driver
         type key for the given driver.  We'll use the
         driver description string, since it's unique per
         driver but not per installation (the friendly name
         is the latter).

Returns: TRUE on success
         FALSE on error
Cond:    --
*/
BOOL
PRIVATE
OLD_GetCommonDriverKeyName(
    IN  HKEY        hkeyDrv,
    IN  DWORD       cbKeyName,
    OUT LPTSTR      pszKeyName)
    {
    BOOL    bRet = FALSE;      // assume failure
    LONG    lErr;

    lErr = RegQueryValueEx(hkeyDrv, c_szDriverDesc, NULL, NULL,
                                            (LPBYTE)pszKeyName, &cbKeyName);
    if (lErr != ERROR_SUCCESS)
    {
        TRACE_MSG(TF_WARNING, "RegQueryValueEx(DriverDesc) failed: %#08lx.", lErr);
        goto exit;
    }

    bRet = TRUE;

exit:
    return(bRet);

    }


/*----------------------------------------------------------
Purpose: This function tries to open the *old style* common
         Responses key for the given driver, which used only
         the driver description string for a key name.
         The key is opened with READ access.

Returns: TRUE on success
         FALSE on error
Cond:    --
*/
BOOL
PRIVATE
OLD_OpenCommonResponsesKey(
    IN  HKEY        hkeyDrv,
    OUT PHKEY       phkeyResp)
    {
    BOOL    bRet = FALSE;       // assume failure
    LONG    lErr;
    TCHAR   szComDrv[MAX_REG_KEY_LEN];
    TCHAR   szPath[2*MAX_REG_KEY_LEN];

    *phkeyResp = NULL;

    // Get the name (*old style*) of the common driver key.
    if (!OLD_GetCommonDriverKeyName(hkeyDrv, sizeof(szComDrv) / sizeof(TCHAR), szComDrv))
    {
        TRACE_MSG(TF_ERROR, "OLD_GetCommonDriverKeyName() failed.");
        goto exit;
    }

    TRACE_MSG(TF_WARNING, "OLD_GetCommonDriverKeyName(): %s", szComDrv);

    // Construct the path to the (*old style*) Responses key.
    lstrcpy(szPath, DRIVER_KEY TEXT("\\"));
    lstrcat(szPath, szComDrv);
    lstrcat(szPath, RESPONSES_KEY);

    // Open the (*old style*) Responses key.
    lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szPath, 0, KEY_READ, phkeyResp);

    if (lErr != ERROR_SUCCESS)
    {
        TRACE_MSG(TF_ERROR, "RegOpenKeyEx(Responses) failed: %#08lx.", lErr);
        goto exit;
    }

    bRet = TRUE;

exit:
    return(bRet);
}


/*----------------------------------------------------------
Purpose: This function finds the name of the common driver
         type key for the given driver.  First it'll look for
         the new style key name ("ResponsesKeyName" value),
         and if that doesn't exist then it'll look for the
         old style key name ("Description" value), both of
         which are stored in the driver node.

NOTE:    The given driver key handle is assumed to contain
         at least the Description value.

Returns: TRUE on success
         FALSE on error
Cond:    --
*/
BOOL
PUBLIC
FindCommonDriverKeyName(
    IN  HKEY                hkeyDrv,
    IN  DWORD               cbKeyName,
    OUT LPTSTR              pszKeyName)
{
    BOOL    bRet = TRUE;      // assume *success*
    LONG    lErr;

    // Is the (new style) key name is registered in the driver node?
    lErr = RegQueryValueEx(hkeyDrv, c_szRespKeyName, NULL, NULL,
                                        (LPBYTE)pszKeyName, &cbKeyName);
    if (lErr == ERROR_SUCCESS)
    {
        goto exit;
    }

    // No. The key name will be in the old style: just the Description.
    lErr = RegQueryValueEx(hkeyDrv, c_szDriverDesc, NULL, NULL,
                                        (LPBYTE)pszKeyName, &cbKeyName);
    if (lErr == ERROR_SUCCESS)
    {
        goto exit;
    }

    // Couldn't get a key name!!  Something's wrong....
    ASSERT(0);
    bRet = FALSE;

exit:
    return(bRet);
}


/*----------------------------------------------------------
Purpose: This function returns the name of the common driver
         type key for the given driver.  The key name is the
         concatenation of 3 strings found in the driver node
         of the registry: the driver description, the manu-
         facturer, and the provider.  (The driver description
         is used since it's unique per driver but not per
         installation (the "friendly" name is the latter).

NOTE:    The component substrings are either read from the
         driver's registry key, or from the given driver info
         data.  If pdrvData is given, the strings it contains
         are assumed to be valid (non-NULL).

Returns: TRUE on success
         FALSE on error
Cond:    --
*/
BOOL
PUBLIC
GetCommonDriverKeyName(
    IN  HKEY                hkeyDrv,    OPTIONAL
    IN  PSP_DRVINFO_DATA    pdrvData,   OPTIONAL
    IN  DWORD               cbKeyName,
    OUT LPTSTR              pszKeyName)
    {
    BOOL    bRet = FALSE;      // assume failure
    LONG    lErr;
    DWORD   dwByteCount, cbData;
    TCHAR   szDescription[MAX_REG_KEY_LEN];
    TCHAR   szManufacturer[MAX_REG_KEY_LEN];
    TCHAR   szProvider[MAX_REG_KEY_LEN];
    LPTSTR  lpszDesc, lpszMfct, lpszProv;

    dwByteCount = 0;
    lpszDesc = NULL;
    lpszMfct = NULL;
    lpszProv = NULL;

    if (hkeyDrv)
    {
        // First see if it's already been registered in the driver node.
        lErr = RegQueryValueEx(hkeyDrv, c_szRespKeyName, NULL, NULL,
                                            (LPBYTE)pszKeyName, &cbKeyName);
        if (lErr == ERROR_SUCCESS)
        {
            bRet = TRUE;
            goto exit;
        }

        // Responses key doesn't exist - read its components from the registry.
        cbData = sizeof(szDescription);
        lErr = RegQueryValueEx(hkeyDrv, c_szDriverDesc, NULL, NULL,
                                            (LPBYTE)szDescription, &cbData);
        if (lErr == ERROR_SUCCESS)
        {
            // Is the Description string *alone* too long to be a key name?
            // If so then we're hosed - fail the call.
            if (cbData > CB_MAX_REG_KEY_LEN)
            {
                goto exit;
            }

            dwByteCount = cbData;
            lpszDesc = szDescription;

            cbData = sizeof(szManufacturer);
            lErr = RegQueryValueEx(hkeyDrv, c_szManufacturer, NULL, NULL,
                                            (LPBYTE)szManufacturer, &cbData);
            if (lErr == ERROR_SUCCESS)
            {
                // only use the manufacturer name if total string size is ok
                cbData += sizeof(c_szSeparator);
                if ((dwByteCount + cbData) <= CB_MAX_REG_KEY_LEN)
                {
                    dwByteCount += cbData;
                    lpszMfct = szManufacturer;
                }
            }

            cbData = sizeof(szProvider);
            lErr = RegQueryValueEx(hkeyDrv, REGSTR_VAL_PROVIDER_NAME, NULL, NULL,
                                            (LPBYTE)szProvider, &cbData);
            if (lErr == ERROR_SUCCESS)
            {
                // only use the provider name if total string size is ok
                cbData += sizeof(c_szSeparator);
                if ((dwByteCount + cbData) <= CB_MAX_REG_KEY_LEN)
                {
                    dwByteCount += cbData;
                    lpszProv = szProvider;
                }
            }
        }
    }

    // Weren't able to read key name components out of the driver node.
    // Get them from the driver info data if one was given.
    if (pdrvData && !dwByteCount)
    {
        lpszDesc = pdrvData->Description;

        if (!lpszDesc || !lpszDesc[0])
        {
            // Didn't get a Description string.  Fail the call.
            goto exit;
        }

        dwByteCount = CbFromCch(lstrlen(lpszDesc)+1);

        // Is the Description string *alone* too long to be a key name?
        // If so then we're hosed - fail the call.
        if (dwByteCount > CB_MAX_REG_KEY_LEN)
        {
            goto exit;
        }

        cbData = sizeof(c_szSeparator)
                    + CbFromCch(lstrlen(pdrvData->MfgName)+1);
        if ((dwByteCount + cbData) <= CB_MAX_REG_KEY_LEN)
        {
            dwByteCount += cbData;
            lpszMfct = pdrvData->MfgName;
        }

        cbData = sizeof(c_szSeparator)
                    + CbFromCch(lstrlen(pdrvData->ProviderName)+1);
        if ((dwByteCount + cbData) <= CB_MAX_REG_KEY_LEN)
        {
            dwByteCount += cbData;
            lpszProv = pdrvData->ProviderName;
        }
    }

    // By now we should have a Description string.  If not, fail the call.
    if (!lpszDesc || !lpszDesc[0])
    {
        goto exit;
    }

    // Construct the key name string out of its components.
    lstrcpy(pszKeyName, lpszDesc);

    if (lpszMfct && *lpszMfct)
    {
        lstrcat(pszKeyName, c_szSeparator);
        lstrcat(pszKeyName, lpszMfct);
    }

    if (lpszProv && *lpszProv)
    {
        lstrcat(pszKeyName, c_szSeparator);
        lstrcat(pszKeyName, lpszProv);
    }

    // Write the key name to the driver node (we know it's not there already).
    if (hkeyDrv)
    {
        lErr = RegSetValueEx(hkeyDrv, c_szRespKeyName, 0, REG_SZ,
                        (LPBYTE)pszKeyName, CbFromCch(lstrlen(pszKeyName)+1));
        if (lErr != ERROR_SUCCESS)
        {
            TRACE_MSG(TF_ERROR, "RegSetValueEx(RespKeyName) failed: %#08lx.", lErr);
            ASSERT(0);
        }
    }

    bRet = TRUE;

exit:
    return(bRet);

    }


/*----------------------------------------------------------
Purpose: This function creates the common driver type key
         for the given driver, or opens it if it already
         exists, with the requested access.

NOTE:    Either hkeyDrv or pdrvData must be provided.

Returns: TRUE on success
         FALSE on error
Cond:    --
*/
BOOL
PUBLIC
OpenCommonDriverKey(
    IN  HKEY                hkeyDrv,    OPTIONAL
    IN  PSP_DRVINFO_DATA    pdrvData,   OPTIONAL
    IN  REGSAM              samAccess,
    OUT PHKEY               phkeyComDrv)
    {
    BOOL    bRet = FALSE;       // assume failure
    LONG    lErr;
    HKEY    hkeyDrvInfo = NULL;
    TCHAR   szComDrv[MAX_REG_KEY_LEN];
    TCHAR   szPath[2*MAX_REG_KEY_LEN];
    DWORD   dwDisp;

    if (!GetCommonDriverKeyName(hkeyDrv, pdrvData, sizeof(szComDrv) / sizeof(TCHAR), szComDrv))
    {
        TRACE_MSG(TF_ERROR, "GetCommonDriverKeyName() failed.");
        goto exit;
    }

    TRACE_MSG(TF_WARNING, "GetCommonDriverKeyName(): %s", szComDrv);

    // Construct the path to the common driver key.
    lstrcpy(szPath, DRIVER_KEY TEXT("\\"));
    lstrcat(szPath, szComDrv);

    // Create the common driver key - it'll be opened if it already exists.
    lErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szPath, 0, NULL,
            REG_OPTION_NON_VOLATILE, samAccess, NULL, phkeyComDrv, &dwDisp);
    if (lErr != ERROR_SUCCESS)
    {
        TRACE_MSG(TF_ERROR, "RegCreateKeyEx(%s) failed: %#08lx.", szPath, lErr);
        goto exit;
    }

    bRet = TRUE;

exit:
    return(bRet);

    }


/*----------------------------------------------------------
Purpose: This function opens or creates the common Responses
         key for the given driver, based on the given flags.

Returns: TRUE on success
         FALSE on error
Cond:    --
*/
BOOL
PUBLIC
OpenCommonResponsesKey(
    IN  HKEY        hkeyDrv,
    IN  CKFLAGS     ckFlags,
    IN  REGSAM      samAccess,
    OUT PHKEY       phkeyResp,
    OUT LPDWORD     lpdwExisted)
{
    BOOL    bRet = FALSE;       // assume failure
    LONG    lErr;
    HKEY    hkeyComDrv = NULL;
    DWORD   dwRefCount, cbData;

    *phkeyResp = NULL;

    if (!OpenCommonDriverKey(hkeyDrv, NULL, KEY_ALL_ACCESS, &hkeyComDrv))
    {
        TRACE_MSG(TF_ERROR, "OpenCommonDriverKey() failed.");
        goto exit;
    }

    if ((CKFLAG_OPEN | CKFLAG_CREATE) == (ckFlags & (CKFLAG_OPEN | CKFLAG_CREATE)))
    {
        ckFlags &= ~CKFLAG_CREATE;
    }

    // Create or open the common Responses key.
    if (ckFlags & CKFLAG_OPEN)
    {
        lErr = RegOpenKeyEx(hkeyComDrv, c_szResponses, 0, samAccess, phkeyResp);
        if (lErr != ERROR_SUCCESS)
        {
            TRACE_MSG(TF_ERROR, "RegOpenKeyEx(common drv) failed: %#08lx.", lErr);
            ckFlags &= ~CKFLAG_OPEN;
            ckFlags |= CKFLAG_CREATE;
        }
    }

    if (ckFlags & CKFLAG_CREATE)
    {
        lErr = RegCreateKeyEx(hkeyComDrv, c_szResponses, 0, NULL,
                REG_OPTION_NON_VOLATILE, samAccess, NULL, phkeyResp, lpdwExisted);
        if (lErr != ERROR_SUCCESS)
        {
            TRACE_MSG(TF_ERROR, "RegCreateKeyEx(%s) failed: %#08lx.", c_szResponses, lErr);
            ASSERT(0);
            goto exit;
        }

        // Create or increment a common Responses key reference count value.
        cbData = sizeof(dwRefCount);
        if (*lpdwExisted == REG_OPENED_EXISTING_KEY)
        {
            lErr = RegQueryValueEx(hkeyComDrv, c_szRefCount, NULL, NULL,
                                                    (LPBYTE)&dwRefCount, &cbData);

            // To accomodate modems installed before this reference count
            // mechanism was added (post-Beta2), if the reference count doesn't
            // exist then just ignore it & install anyways. In this case the
            // shared Responses key will never be removed.
            if (lErr == ERROR_SUCCESS)
            {
                ASSERT(dwRefCount);                 // expecting non-0 ref count
                ASSERT(cbData == sizeof(DWORD));    // expecting DWORD ref count
                dwRefCount++;                       // increment ref count
            }
            else
            {
                if (lErr == ERROR_FILE_NOT_FOUND)
                    dwRefCount = 0;
                else
                {
                    // some error other than key doesn't exist
                    TRACE_MSG(TF_ERROR, "RegQueryValueEx(RefCount) failed: %#08lx.", lErr);
                    goto exit;
                }
            }
        }
        else dwRefCount = 1;

        if (dwRefCount)
        {
            lErr = RegSetValueEx(hkeyComDrv, c_szRefCount, 0, REG_DWORD,
                                                  (LPBYTE)&dwRefCount, cbData);
            if (lErr != ERROR_SUCCESS)
            {
                TRACE_MSG(TF_ERROR, "RegSetValueEx(RefCount) failed: %#08lx.", lErr);
                ASSERT(0);
                goto exit;
            }
        }

    }

    bRet = TRUE;

exit:
    if (!bRet)
    {
        // something failed - close any open Responses key
        if (*phkeyResp)
            RegCloseKey(*phkeyResp);
    }

    if (hkeyComDrv)
        RegCloseKey(hkeyComDrv);

    return(bRet);

}


/*----------------------------------------------------------
Purpose: This function finds the Responses key for the given
         modem driver and returns an open hkey to it.  The
         Responses key may exist in the common driver type
         key, or it may be in the individual driver key.
         The key is opened with READ access.

Returns: TRUE on success
         FALSE on error
Cond:    --
*/
BOOL
PUBLIC
OpenResponsesKey(
    IN  HKEY        hkeyDrv,
    OUT PHKEY       phkeyResp)
    {
    LONG    lErr;

    // Try to open the common Responses subkey.
    if (!OpenCommonResponsesKey(hkeyDrv, CKFLAG_OPEN, KEY_READ, phkeyResp, NULL))
    {
        TRACE_MSG(TF_ERROR, "OpenCommonResponsesKey() failed, assume non-existent.");

        // Failing that, open the *old style* common Responses subkey.
        if (!OLD_OpenCommonResponsesKey(hkeyDrv, phkeyResp))
        {
            // Failing that, try to open a Responses subkey in the driver node.
            lErr = RegOpenKeyEx(hkeyDrv, c_szResponses, 0, KEY_READ, phkeyResp);
            if (lErr != ERROR_SUCCESS)
            {
                TRACE_MSG(TF_ERROR, "RegOpenKeyEx() failed: %#08lx.", lErr);
                return (FALSE);
            }
        }
    }

    return(TRUE);

    }


/*----------------------------------------------------------
Purpose: This function deletes a registry key and all of
         its subkeys.  A registry key that is opened by an
         application can be deleted without error by another
         application in both Windows 95 and Windows NT.
         This is by design.  This code makes no attempt to
         check or recover from partial deletions.

NOTE:    Adapted from sample code in the MSDN Knowledge Base
         article #Q142491.

Returns: ERROR_SUCCESS on success
         WIN32 error code on error
Cond:    --
*/
DWORD
PRIVATE
RegDeleteKeyNT(
    IN  HKEY    hStartKey,
    IN  LPTSTR  pKeyName)
{
   DWORD   dwRtn, dwSubKeyLength;
   LPTSTR  pSubKey = NULL;
   TCHAR   szSubKey[MAX_REG_KEY_LEN]; // this should be dynamic.
   HKEY    hKey;

   // do not allow NULL or empty key name
   if (pKeyName && lstrlen(pKeyName))
   {
      if ((dwRtn = RegOpenKeyEx(hStartKey, pKeyName,
         0, KEY_ALL_ACCESS, &hKey)) == ERROR_SUCCESS)
      {
         while (dwRtn == ERROR_SUCCESS)
         {
            dwSubKeyLength = sizeof(szSubKey) / sizeof(TCHAR);
            dwRtn = RegEnumKeyEx( hKey,
                                  0,       // always index zero
                                  szSubKey,
                                  &dwSubKeyLength,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL );

            if (dwRtn == ERROR_NO_MORE_ITEMS)
            {
               dwRtn = RegDeleteKey(hStartKey, pKeyName);
               break;
            }
            else if (dwRtn == ERROR_SUCCESS)
               dwRtn = RegDeleteKeyNT(hKey, szSubKey);
         }

         RegCloseKey(hKey);
         // Do not save return code because error
         // has already occurred
      }
   }
   else
      dwRtn = ERROR_BADKEY;

   return dwRtn;
}


/*----------------------------------------------------------
Purpose: This function deletes the common driver key (or
         decrements its reference count) associated with the
         driver given by name.

Returns: TRUE on success
         FALSE on error
Cond:    --
*/
BOOL
PUBLIC
DeleteCommonDriverKeyByName(
    IN  LPTSTR      pszKeyName)
{
 BOOL    bRet = FALSE;       // assume failure
 LONG    lErr;
 TCHAR   szPath[2*MAX_REG_KEY_LEN];
 HKEY    hkeyComDrv, hkeyPrnt;
 DWORD   dwRefCount, cbData;
 ULONG   uLength;

    // Construct the path to the driver's common key and open it.
    lstrcpy(szPath, DRIVER_KEY TEXT("\\"));

    uLength = (sizeof(szPath) / sizeof(TCHAR)) - lstrlen(szPath);
    if ((ULONG)lstrlen(pszKeyName) <= uLength)
    {
        lstrcat(szPath, pszKeyName);
    }

    lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szPath, 0, KEY_ALL_ACCESS,
                                                                &hkeyComDrv);
    if (lErr != ERROR_SUCCESS)
    {
        TRACE_MSG(TF_ERROR, "RegOpenKeyEx() failed: %#08lx.", lErr);
        goto exit;
    }

    // Check the common driver key reference count and decrement
    // it or delete the key (& the Responses subkey).
    cbData = sizeof(dwRefCount);
    lErr = RegQueryValueEx(hkeyComDrv, c_szRefCount, NULL, NULL,
                                            (LPBYTE)&dwRefCount, &cbData);

    // To accomodate modems installed before this reference count
    // mechanism was added (post-Beta2), if the reference count doesn't
    // exist then just ignore it. In this case the shared Responses key
    // will never be removed.
    if (lErr == ERROR_SUCCESS)
    {
        ASSERT(dwRefCount);         // expecting non-0 ref count
        if (--dwRefCount)
        {
            lErr = RegSetValueEx(hkeyComDrv, c_szRefCount, 0, REG_DWORD,
                                                  (LPBYTE)&dwRefCount, cbData);
            if (lErr != ERROR_SUCCESS)
            {
                TRACE_MSG(TF_ERROR, "RegSetValueEx(RefCount) failed: %#08lx.", lErr);
                ASSERT(0);
                goto exit;
            }
        }
        else
        {
            lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, DRIVER_KEY, 0,
                                            KEY_ENUMERATE_SUB_KEYS, &hkeyPrnt);
            if (lErr != ERROR_SUCCESS)
            {
                TRACE_MSG(TF_ERROR, "RegOpenKeyEx(Prnt) failed: %#08lx.", lErr);
                goto exit;
            }

            lErr = RegDeleteKeyNT(hkeyPrnt, pszKeyName);

            if (lErr != ERROR_SUCCESS)
            {
                TRACE_MSG(TF_ERROR, "RegDeleteKeyNT(ComDrv) failed: %#08lx.", lErr);
                goto exit;
            }
        }
    }
    else if (lErr != ERROR_FILE_NOT_FOUND)
    {
        // some error other than key doesn't exist
        TRACE_MSG(TF_ERROR, "RegQueryValueEx(RefCount) failed: %#08lx.", lErr);
        goto exit;
    }

    bRet = TRUE;

exit:
    return(bRet);

}


/*----------------------------------------------------------
Purpose: This function deletes the common driver key (or
         decrements its reference count) associated with the
         driver given by driver key.

Returns: TRUE on success
         FALSE on error
Cond:    --
*/
BOOL
PUBLIC
DeleteCommonDriverKey(
    IN  HKEY        hkeyDrv)
{
 BOOL    bRet = FALSE;
 TCHAR   szComDrv[MAX_REG_KEY_LEN];


    // Get the name of the common driver key for this driver.
    if (!GetCommonDriverKeyName(hkeyDrv, NULL, sizeof(szComDrv) / sizeof(TCHAR), szComDrv))
    {
        TRACE_MSG(TF_ERROR, "GetCommonDriverKeyName() failed.");
        goto exit;
    }

    if (!DeleteCommonDriverKeyByName(szComDrv))
    {
        TRACE_MSG(TF_ERROR, "DeleteCommonDriverKey() failed.");
    }

    bRet = TRUE;

exit:
    return(bRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\inc\bustype.h ===
#ifndef __BUSTYPE_H__
#define __BUSTYPE_H__

// These ordinal values are bus types for CplDiGetBusType
#define BUS_TYPE_ROOT       1
#define BUS_TYPE_PCMCIA     2
#define BUS_TYPE_SERENUM    3
#define BUS_TYPE_LPTENUM    4
#define BUS_TYPE_OTHER      5
#define BUS_TYPE_ISAPNP     6

#ifndef PUBLIC
#define PUBLIC FAR PASCAL
#endif //PUBILC


BOOL
PUBLIC
CplDiGetBusType(
    IN  HDEVINFO        hdi,
    IN  PSP_DEVINFO_DATA pdevData,          OPTIONAL
    OUT LPDWORD         pdwBusType);

#endif __BUSTYPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\inc\rovdi.h ===
//
// Copyright (c) Microsoft Corporation 1993-1996
//
// rovdi.h
//
// History:
//  11-13-95 ScottH     Separated from NT modem class installer
//

#ifndef __ROVDI_H__
#define __ROVDI_H__

#ifdef WINNT

#define REENUMERATE_PORT

#include <setupapi.h>

#include <bustype.h>


//------------------------------------------------------------------------
//------------------------------------------------------------------------


//
// Enumerate ports
//
DECLARE_HANDLE32(HPORTDATA);

typedef BOOL (WINAPI FAR * ENUMPORTPROC)(HPORTDATA hportdata, LPARAM lParam);

DWORD
APIENTRY 
EnumeratePorts(
    IN  ENUMPORTPROC pfnDevice,
    IN  LPARAM lParam);             OPTIONAL


typedef struct tagPORTDATA_A
    {
    DWORD   cbSize;
    DWORD   nSubclass;
    CHAR    szPort[MAX_BUF];
    CHAR    szFriendly[MAX_BUF];
    } PORTDATA_A, FAR * LPPORTDATA_A;

typedef struct tagPORTDATA_W
    {
    DWORD   cbSize;
    DWORD   nSubclass;
    WCHAR   szPort[MAX_BUF];
    WCHAR   szFriendly[MAX_BUF];
    } PORTDATA_W, FAR * LPPORTDATA_W;
#ifdef UNICODE
#define PORTDATA        PORTDATA_W
#define LPPORTDATA      LPPORTDATA_W
#else
#define PORTDATA        PORTDATA_A
#define LPPORTDATA      LPPORTDATA_A
#endif

// Port subclass values
#define PORT_SUBCLASS_PARALLEL       0
#define PORT_SUBCLASS_SERIAL         1


BOOL
APIENTRY
PortData_GetPropertiesW(
    IN  HPORTDATA       hportdata,
    OUT LPPORTDATA_W    pdataBuf);
BOOL
APIENTRY
PortData_GetPropertiesA(
    IN  HPORTDATA       hportdata,
    OUT LPPORTDATA_A    pdataBuf);
#ifdef UNICODE
#define PortData_GetProperties      PortData_GetPropertiesW
#else
#define PortData_GetProperties      PortData_GetPropertiesA
#endif


//
// These set of routines map friendly names of ports to 
// (non-friendly) port names, and vice-versa.
//

DECLARE_HANDLE32(HPORTMAP);

BOOL 
APIENTRY
PortMap_Create(
    OUT HPORTMAP FAR * phportmap);

DWORD
APIENTRY
PortMap_GetCount(
    IN HPORTMAP hportmap);

BOOL
APIENTRY
PortMap_GetFriendlyW(
    IN  HPORTMAP hportmap,
    IN  LPCWSTR pwszPortName,
    OUT LPWSTR pwszBuf,
    IN  DWORD cchBuf);
BOOL
APIENTRY
PortMap_GetFriendlyA(
    IN  HPORTMAP hportmap,
    IN  LPCSTR pszPortName,
    OUT LPSTR pszBuf,
    IN  DWORD cchBuf);
#ifdef UNICODE
#define PortMap_GetFriendly     PortMap_GetFriendlyW
#else
#define PortMap_GetFriendly     PortMap_GetFriendlyA
#endif


BOOL
APIENTRY
PortMap_GetPortNameW(
    IN  HPORTMAP hportmap,
    IN  LPCWSTR pwszFriendly,
    OUT LPWSTR pwszBuf,
    IN  DWORD cchBuf);
BOOL
APIENTRY
PortMap_GetPortNameA(
    IN  HPORTMAP hportmap,
    IN  LPCSTR pszFriendly,
    OUT LPSTR pszBuf,
    IN  DWORD cchBuf);
#ifdef UNICODE
#define PortMap_GetPortName     PortMap_GetPortNameW
#else
#define PortMap_GetPortName     PortMap_GetPortNameA
#endif

#ifdef REENUMERATE_PORT
BOOL
APIENTRY
PortMap_GetDevNodeW(
    IN  HPORTMAP hportmap,
    IN  LPCWSTR pszPortName,
    OUT LPDWORD pdwDevNode);
BOOL
APIENTRY
PortMap_GetDevNodeA(
    IN  HPORTMAP hportmap,
    IN  LPCSTR pszPortName,
    OUT LPDWORD pdwDevNode);
#ifdef UNICODE
#define PortMap_GetDevNode     PortMap_GetDevNodeW
#else
#define PortMap_GetDevNode     PortMap_GetDevNodeW
#endif
#endif //REENUMERATE_PORT
BOOL 
APIENTRY
PortMap_Free(
    IN  HPORTMAP hportmap);


//-----------------------------------------------------------------------------------
//  Wrappers to insulate us a little bit if we need it.  We need it.
//-----------------------------------------------------------------------------------

#define CplDiCreateDeviceInfoList       SetupDiCreateDeviceInfoList
#define CplDiGetDeviceInfoListClass     SetupDiGetDeviceInfoListClass
#define CplDiCreateDeviceInfo           SetupDiCreateDeviceInfo
#define CplDiOpenDeviceInfo             SetupDiOpenDeviceInfo
#define CplDiGetDeviceInstanceId        SetupDiGetDeviceInstanceId
#define CplDiDeleteDeviceInfo           SetupDiDeleteDeviceInfo
#define CplDiEnumDeviceInfo             SetupDiEnumDeviceInfo
#define CplDiDestroyDeviceInfoList      SetupDiDestroyDeviceInfoList    
#define CplDiRegisterDeviceInfo         SetupDiRegisterDeviceInfo
#define CplDiBuildDriverInfoList        SetupDiBuildDriverInfoList
#define CplDiEnumDriverInfo             SetupDiEnumDriverInfo
#define CplDiGetSelectedDriver          SetupDiGetSelectedDriver
#define CplDiSetSelectedDriver          SetupDiSetSelectedDriver
#define CplDiGetDriverInfoDetail        SetupDiGetDriverInfoDetail
#define CplDiDestroyDriverInfoList      SetupDiDestroyDriverInfoList
#define CplDiGetClassDevs               SetupDiGetClassDevs
#define CplDiGetClassDescription        SetupDiGetClassDescription
#define CplDiOpenClassRegKey            SetupDiOpenClassRegKey
#define CplDiCreateDevRegKey            SetupDiCreateDevRegKey
#define CplDiOpenDevRegKey              SetupDiOpenDevRegKey
#define CplDiGetHwProfileList           SetupDiGetHwProfileList
#define CplDiGetDeviceRegistryProperty  SetupDiGetDeviceRegistryProperty
#define CplDiSetDeviceRegistryProperty  SetupDiSetDeviceRegistryProperty
#define CplDiGetClassInstallParams      SetupDiGetClassInstallParams
#define CplDiSetClassInstallParams      SetupDiSetClassInstallParams

/*#ifdef DEBUG
BOOL
CplDiSetDeviceInstallParams(
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,
    IN PSP_DEVINSTALL_PARAMS   DeviceInstallParams
    );
BOOL
CplDiGetDeviceInstallParams(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,
    OUT PSP_DEVINSTALL_PARAMS   DeviceInstallParams
    );
#else*/
#define CplDiGetDeviceInstallParams     SetupDiGetDeviceInstallParams
#define CplDiSetDeviceInstallParams     SetupDiSetDeviceInstallParams
//#endif //DEBUG

#define CplDiGetDriverInstallParams     SetupDiGetDriverInstallParams
#define CplDiSetDriverInstallParams     SetupDiSetDriverInstallParams
#define CplDiClassNameFromGuid          SetupDiClassNameFromGuid
#define CplDiClassGuidsFromName         SetupDiClassGuidsFromName
#define CplDiGetHwProfileFriendlyName   SetupDiGetHwProfileFriendlyName
#define CplDiGetWizardPage              SetupDiGetWizardPage
#define CplDiGetSelectedDevice          SetupDiGetSelectedDevice
#define CplDiSetSelectedDevice          SetupDiSetSelectedDevice
#define CplDiInstallDevice              SetupDiInstallDevice
#define CplDiCallClassInstaller         SetupDiCallClassInstaller
#define CplDiRemoveDevice               SetupDiRemoveDevice
#define CplDiGetActualSectionToInstall  SetupDiGetActualSectionToInstall


// Functions to support common device Responses key:

// Common key flags for OpenCommonResponseskey() and OpenCommonDriverKey().
typedef enum
{
    CKFLAG_OPEN = 0x0001,
    CKFLAG_CREATE = 0x0002
    
} CKFLAGS;


BOOL
PUBLIC
OpenCommonDriverKey(
    IN  HKEY                hkeyDrv,    OPTIONAL
    IN  PSP_DRVINFO_DATA    pdrvData,   OPTIONAL
    IN  REGSAM              samAccess,
    OUT PHKEY               phkeyComDrv);

    
BOOL
PUBLIC
OpenCommonResponsesKey(
    IN  HKEY        hkeyDrv,
    IN  CKFLAGS     ckFlags,
    IN  REGSAM      samAccess,
    OUT PHKEY       phkeyResp,
    OUT LPDWORD     lpdwExisted);


BOOL
PUBLIC
OpenResponsesKey(
    IN  HKEY        hkeyDrv,
    OUT PHKEY       phkeyResp);


BOOL
PUBLIC
FindCommonDriverKeyName(
    IN  HKEY                hkeyDrv,
    IN  DWORD               cbKeyName,
    OUT LPTSTR              pszKeyName);

    
BOOL
PUBLIC
GetCommonDriverKeyName(
    IN  HKEY                hkeyDrv,    OPTIONAL
    IN  PSP_DRVINFO_DATA    pdrvData,   OPTIONAL
    IN  DWORD               cbKeyName,
    OUT LPTSTR              pszKeyName);


BOOL
PUBLIC
DeleteCommonDriverKey(
    IN  HKEY        hkeyDrv);


BOOL
PUBLIC
DeleteCommonDriverKeyByName(
    IN  LPTSTR      pszKeyName);

#endif // WINNT

#endif __ROVDI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\inc\rovcomm.h ===
//
// Copyright (c) Microsoft Corporation 1993-1995
//
// rovcomm.h
//
// Declares common and useful data structures, macros and functions.
// These items are broken down into the following sections.  Defining
// the associated flags will inhibit definition of the indicated
// items.
//
// NORTL            - run-time library functions
// NOBASICS         - basic macros
// NOMEM            - memory management, dynamic array functions
// NODA             - dynamic array functions
// NOSHAREDHEAP     - shared heap functions
// NOFILEINFO       - FileInfo functions
// NOCOLORHELP      - helper macros to derive COLOR_ values from state
// NODRAWTEXT       - enhanced version of DrawText
// NODIALOGHELPER   - dialog helper functions
// NOMESSAGESTRING  - construct message string functions
// NOSTRING         - string functions
// NOPATH           - path whacking functions
// NODEBUGHELP      - debug routines
// NOSYNC           - synchronization (critical sections, etc.)
// NOPROFILE        - profile (.ini) support functions
// NODI             - setup API Device Installer wrappers
//
// Optional defines are:
//
// WANT_SHELL_SUPPORT   - include SH* function support
// SZ_MODULEA           - debug string prepended to debug spew
// SZ_MODULEW           - (wide-char) debug string prepended to debug spew
// SHARED_DLL           - DLL is in shared memory (may require 
//                        per-instance data)
// SZ_DEBUGSECTION      - .ini section name for debug options
// SZ_DEBUGINI          - .ini name for debug options
//
// This is the "master" header.  The associated files are:
//
//  rovcomm.c
//  rovpath.c
//  rovmem.c, rovmem.h
//  rovini.c
//
// If you want debug macros, be sure to include rovdbg.h in one (and 
// only one) of your project source files.  This contains the three function
// helpers.
//
// History:
//  04-26-95 ScottH     Transferred from Briefcase code
//                      Added controlling defines
//

#ifndef __ROVCOMM_H__
#define __ROVCOMM_H__

#ifdef RC_INVOKED
// Turn off a bunch of stuff to ensure that RC files compile OK
#define NOMEM
#define NODA
#define NOSHAREDHEAP
#define NOFILEINFO
#define NOCOLORHELP
#define NODRAWTEXT
#define NODIALOGHELPER
#define NOMESSAGESTRING
#define NOSTRING
#define NOPATH
#define NODEBUGHELP
#define NOSYNC
#define NOPROFILE
#define NODI
#endif // RC_INVOKED

#ifdef JUSTDEBUGSTUFF
#define NORTL
#define NOMEM
#define NODA
#define NOSHAREDHEAP
#define NOFILEINFO
#define NOCOLORHELP
#define NODRAWTEXT
#define NODIALOGHELPER
#define NOMESSAGESTRING
#define NOPROFILE
#define NOSTRING
#define NOPATH
#define NOSYNC
#define NODI
#endif // JUSTDEBUGSTUFF

#ifdef _INC_OLE
#define WANT_OLE_SUPPORT
#endif

// Check for any conflicting defines...

#if !defined(WANT_SHELL_SUPPORT) && !defined(NOFILEINFO)
#pragma message("FileInfo routines need WANT_SHELL_SUPPORT.  Not providing FileInfo routines.")
#define NOFILEINFO
#endif

#if !defined(NOFILEINFO) && defined(NOMEM)
#pragma message("FileInfo routines need NOMEM undefined.  Overriding.")
#undef NOMEM
#endif

#if !defined(NOFILEINFO) && defined(NOMESSAGESTRING)
#pragma message("FileInfo routines need NOMESSAGESTRING undefined.  Overriding.")
#undef NOMESSAGESTRING
#endif

#if !defined(NOFILEINFO) && defined(NOSTRING)
#pragma message("FileInfo routines need NOSTRING undefined.  Overriding.")
#undef NOSTRING
#endif

#if !defined(NOMESSAGESTRING) && defined(NOMEM)
#pragma message("ConstructMessage routines need NOMEM undefined.  Overriding.")
#undef NOMEM
#endif

#if !defined(NOPATH) && defined(NOSTRING)
#pragma message("Path routines need NOSTRING undefined.  Overriding.")
#undef NOSTRING
#endif

#if !defined(NODA) && defined(NOMEM)
#pragma message("Dynamic Array routines need NOMEM undefined.  Overriding.")
#undef NOMEM
#endif

#if !defined(NOSHAREDHEAP) && defined(NOMEM)
#pragma message("Shared memory routines need NOMEM undefined.  Overriding.")
#undef NOMEM
#endif

#if !defined(NOPROFILE) && defined(NODEBUGHELP)
#pragma message("Debug profiling routines need NODEBUGHELP undefined.  Overriding.")
#undef NODEBUGHELP
#endif

#if !defined(NOPROFILE) && defined(NOSTRING)
#pragma message("Private profile needs NOSTRING undefined.  Overriding.")
#undef NOSTRING
#endif

#if DBG > 0 && !defined(DEBUG)
#define DEBUG
#endif
#if DBG > 0 && !defined(FULL_DEBUG)
#define FULL_DEBUG
#endif


// Other include files...

#if !defined(NOFILEINFO) && !defined(_SHLOBJ_H_)
#include <shlobj.h>
#endif

#if !defined(NODEBUGHELP) && !defined(_VA_LIST_DEFINED)
#include <stdarg.h>
#endif

#if !defined(WINNT)
#define WIN95
#else
#undef WIN95
#endif


//
// Basics
//
#ifndef NOBASICS

#define Unref(x)        x

#ifdef DEBUG
#define INLINE
#define DEBUG_CODE(x)   x
#else
#define INLINE          __inline
#define DEBUG_CODE(x)   
#endif

#ifdef UNICODE
#define SZ_MODULE       SZ_MODULEW
#else
#define SZ_MODULE       SZ_MODULEA
#endif // UNICODE

#ifndef OPTIONAL
#define OPTIONAL
#endif
#ifndef IN
#define IN
#endif
#ifndef OUT
#define OUT
#endif

// General flag macros
//
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))  
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))  

#define InRange(id, idFirst, idLast)  ((UINT)(id-idFirst) <= (UINT)(idLast-idFirst))

// Standard buffer lengths
//
#define MAX_BUF                     260
#define MAX_BUF_MSG                 520
#define MAX_BUF_MED                 64
#define MAX_BUF_SHORT               32
#define MAX_BUF_REG                 128         // Should be same as MAX_REG_KEY_LEN
#define MAX_BUF_ID                  128

#define NULL_CHAR                   '\0'
#define ARRAYSIZE(rg)               (sizeof(rg) / sizeof((rg)[0]))
#define ARRAY_ELEMENTS(rg)          ARRAYSIZE(rg)
#define SIZECHARS(rg)               ARRAYSIZE(rg)

// Comparison return values
//
#define CMP_GREATER                 1
#define CMP_LESSER                  (-1)
#define CMP_EQUAL                   0

// Count of characters to count of bytes
//
#define CbFromCchW(cch)             ((cch)*sizeof(WCHAR))
#define CbFromCchA(cch)             ((cch)*sizeof(CHAR))
#ifdef UNICODE
#define CbFromCch       CbFromCchW
#else  // UNICODE
#define CbFromCch       CbFromCchA
#endif // UNICODE

// 64-bit macros
//
#define HIDWORD(_qw)                (DWORD)((_qw)>>32)
#define LODWORD(_qw)                (DWORD)(_qw)

// Calling declarations
//
#define PUBLIC                      FAR PASCAL
#define CPUBLIC                     FAR CDECL
#define PRIVATE                     NEAR PASCAL

// Range of resource ID indexes are 0x000 - 0x7ff
#define IDS_BASE                    0x1000
#define IDS_ERR_BASE                (IDS_BASE + 0x0000)
#define IDS_OOM_BASE                (IDS_BASE + 0x0800)
#define IDS_MSG_BASE                (IDS_BASE + 0x1000)
#define IDS_RANDO_BASE              (IDS_BASE + 0x1800)
#define IDS_COMMON_BASE             (IDS_BASE + 0x2000)

// Resource string IDs for FileInfo
#define IDS_BYTES                   (IDS_COMMON_BASE + 0x000)
#define IDS_ORDERKB                 (IDS_COMMON_BASE + 0x001)
#define IDS_ORDERMB                 (IDS_COMMON_BASE + 0x002)
#define IDS_ORDERGB                 (IDS_COMMON_BASE + 0x003)
#define IDS_ORDERTB                 (IDS_COMMON_BASE + 0x004)
#define IDS_DATESIZELINE            (IDS_COMMON_BASE + 0x005)


#ifndef DECLARE_STANDARD_TYPES
// For a type "FOO", define the standard derived types PFOO, CFOO, and PCFOO.
//
#define DECLARE_STANDARD_TYPES(type)      typedef type FAR *P##type; \
                                          typedef const type C##type; \
                                          typedef const type FAR *PC##type;
#endif

// Zero-initialize data-item
//
#define ZeroInitSize(pobj, cb)      MyZeroMemory(pobj, cb)
#define ZeroInit(pobj)              MyZeroMemory(pobj, sizeof(*(pobj)))

// Copy chunk of memory
//
#define BltByte(pdest, psrc, cb)    MyMoveMemory(pdest, psrc, cb)

// Porting macros
//
#ifdef WIN32

#define ISVALIDHINSTANCE(hinst)     ((BOOL)(hinst != NULL))
#define LOCALOF(lp)                 (lp)
#define OFFSETOF(lp)                (lp)

#define DATASEG_READONLY            ".text"
#define DATASEG_PERINSTANCE         ".instanc"
#define DATASEG_SHARED              ".data"

#else   // WIN32

#define ISVALIDHINSTANCE(hinst)     ((UINT)hinst >= (UINT)HINSTANCE_ERROR)
#define LOCALOF(lp)                 ((HLOCAL)OFFSETOF(lp))

#define DATASEG_READONLY            "_TEXT"
#define DATASEG_PERINSTANCE
#define DATASEG_SHARED

typedef LPCSTR  LPCTSTR;
typedef LPSTR   LPTSTR;
typedef char    TCHAR;

#endif  // WIN32

#define LocalFreePtr(p)             LocalFree((HLOCAL)OFFSETOF(p))

typedef UINT FAR *LPUINT;

#endif // NOBASICS


//
// Run-time library replacements
//
#ifdef NORTL

// (implemented privately)
LPWSTR 
PUBLIC 
lmemmoveW(
    LPWSTR dst, 
    LPCWSTR src, 
    DWORD count);
LPSTR   
PUBLIC 
lmemmoveA(
    LPSTR dst, 
    LPCSTR src, 
    DWORD count);
#ifdef UNICODE
#define lmemmove    lmemmoveW
#else
#define lmemmove    lmemmoveA
#endif // UNICODE

LPWSTR   
PUBLIC 
lmemsetW(
    LPWSTR dst, 
    WCHAR val, 
    DWORD count);
LPSTR   
PUBLIC 
lmemsetA(
    LPSTR dst, 
    CHAR val, 
    DWORD count);
#ifdef UNICODE
#define lmemset     lmemsetW
#else
#define lmemset     lmemsetA
#endif // UNICODE

#define MyZeroMemory(p, cb)             lmemset((LPTSTR)(p), 0, cb)
#define MyMoveMemory(pdest, psrc, cb)   lmemmove((LPTSTR)(pdest), (LPCTSTR)(psrc), cb)

#else // NORTL

#define MyZeroMemory                    ZeroMemory
#define MyMoveMemory                    MoveMemory

#endif // NORTL


//
// Memory and dynamic array functions
//
#ifndef NOMEM
#include "rovmem.h"
#endif // NOMEM


//
// Message string helpers
//
#ifndef NOMESSAGESTRING

#if !defined(WIN32) && !defined(LANG_NEUTRAL)
#define LANG_NEUTRAL    0x00
#endif

LPWSTR   
PUBLIC 
ConstructVMessageStringW(
    HINSTANCE hinst, 
    LPCWSTR pwszMsg, 
    va_list FAR * ArgList);
LPSTR   
PUBLIC 
ConstructVMessageStringA(
    HINSTANCE hinst, 
    LPCSTR pszMsg, 
    va_list FAR * ArgList);
#ifdef UNICODE
#define ConstructVMessageString     ConstructVMessageStringW
#else  // UNICODE
#define ConstructVMessageString     ConstructVMessageStringA
#endif // UNICODE

BOOL    
CPUBLIC 
ConstructMessageW(
    LPWSTR FAR * ppwsz, 
    HINSTANCE hinst, 
    LPCWSTR pwszMsg, ...);
BOOL    
CPUBLIC 
ConstructMessageA(
    LPSTR FAR * ppsz, 
    HINSTANCE hinst, 
    LPCSTR pszMsg, ...);
#ifdef UNICODE
#define ConstructMessage        ConstructMessageW
#else  // UNICODE
#define ConstructMessage        ConstructMessageA
#endif // UNICODE

#define SzFromIDSW(hinst, ids, pwszBuf, cchBuf)  (LoadStringW(hinst, ids, pwszBuf, cchBuf), pwszBuf)
#define SzFromIDSA(hinst, ids, pszBuf, cchBuf)   (LoadStringA(hinst, ids, pszBuf, cchBuf), pszBuf)

#ifdef UNICODE
#define SzFromIDS               SzFromIDSW
#else  // UNICODE
#define SzFromIDS               SzFromIDSA
#endif // UNICODE

int 
CPUBLIC 
MsgBoxW(
    HINSTANCE hinst, 
    HWND hwndOwner, 
    LPCWSTR pwszText, 
    LPCWSTR pwszCaption, 
    HICON hicon, 
    DWORD dwStyle, ...);
int 
CPUBLIC 
MsgBoxA(
    HINSTANCE hinst, 
    HWND hwndOwner, 
    LPCSTR pszText, 
    LPCSTR pszCaption, 
    HICON hicon, 
    DWORD dwStyle, ...);
#ifdef UNICODE
#define MsgBox        MsgBoxW
#else  // UNICODE
#define MsgBox        MsgBoxA
#endif // UNICODE

// Additional MB_ flags
#define MB_WARNING      (MB_OK | MB_ICONWARNING)
#define MB_INFO         (MB_OK | MB_ICONINFORMATION)
#define MB_ERROR        (MB_OK | MB_ICONERROR)
#define MB_QUESTION     (MB_YESNO | MB_ICONQUESTION)

#endif // NOMESSAGESTRING


//
// String functions
//
#ifndef NOSTRING

BOOL    
PUBLIC 
AnsiToIntW(
    LPCWSTR pszString, 
    int FAR * piRet);
BOOL    
PUBLIC 
AnsiToIntA(
    LPCSTR pszString, 
    int FAR * piRet);
#ifdef UNICODE
#define AnsiToInt   AnsiToIntW
#else
#define AnsiToInt   AnsiToIntA
#endif // UNICODE

LPWSTR   
PUBLIC 
AnsiChrW(
    LPCWSTR psz, 
    WORD wMatch);
LPSTR   
PUBLIC 
AnsiChrA(
    LPCSTR psz, 
    WORD wMatch);
#ifdef UNICODE
#define AnsiChr     AnsiChrW
#else
#define AnsiChr     AnsiChrA
#endif // UNICODE

LPWSTR   
PUBLIC 
AnsiRChrW(
    LPCWSTR psz, 
    WORD wMatch);
#ifdef UNICODE
#define AnsiRChr     AnsiRChrW
#else
#define AnsiRChr     
#endif // UNICODE

#define IsSzEqual(sz1, sz2)         (BOOL)(lstrcmpi(sz1, sz2) == 0)
#define IsSzEqualC(sz1, sz2)        (BOOL)(lstrcmp(sz1, sz2) == 0)

#ifdef WIN32
#define lstrnicmp(sz1, sz2, cch)    (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE, sz1, cch, sz2, cch) - 2)
#define lstrncmp(sz1, sz2, cch)     (CompareString(LOCALE_USER_DEFAULT, 0, sz1, cch, sz2, cch) - 2)
#else
int     PUBLIC lstrnicmp(LPCSTR psz1, LPCSTR psz2, UINT count);
int     PUBLIC lstrncmp(LPCSTR psz1, LPCSTR psz2, UINT count);
#endif // WIN32

#define IsSzEqualN(sz1, sz2, cch)   (BOOL)(0 == lstrnicmp(sz1, sz2, cch))
#define IsSzEqualNC(sz1, sz2, cch)  (BOOL)(0 == lstrncmp(sz1, sz2, cch))

#endif // NOSTRING


//
// FileInfo functions
//
#if !defined(NOFILEINFO) && defined(WIN95)

// FileInfo struct that contains file time/size info
//
typedef struct _FileInfo
    {
    HICON   hicon;
    FILETIME ftMod;
    DWORD   dwSize;         // size of the file
    DWORD   dwAttributes;   // attributes
    LPARAM  lParam;
    LPSTR   pszDisplayName; // points to the display name
    CHAR    szPath[1];      
    } FileInfo;

#define FIGetSize(pfi)          ((pfi)->dwSize)
#define FIGetPath(pfi)          ((pfi)->szPath)
#define FIGetDisplayName(pfi)   ((pfi)->pszDisplayName)
#define FIGetAttributes(pfi)    ((pfi)->dwAttributes)
#define FIIsFolder(pfi)         (IsFlagSet((pfi)->dwAttributes, SFGAO_FOLDER))

// Flags for FICreate
#define FIF_DEFAULT             0x0000
#define FIF_ICON                0x0001
#define FIF_DONTTOUCH           0x0002
#define FIF_FOLDER              0x0004

HRESULT PUBLIC FICreate(LPCSTR pszPath, FileInfo ** ppfi, UINT uFlags);
BOOL    PUBLIC FISetPath(FileInfo ** ppfi, LPCSTR pszPathNew, UINT uFlags);
BOOL    PUBLIC FIGetInfoString(FileInfo * pfi, LPSTR pszBuf, int cchBuf);
void    PUBLIC FIFree(FileInfo * pfi);

void    PUBLIC FileTimeToDateTimeString(LPFILETIME pft, LPSTR pszBuf, int cchBuf);

#endif // NOFILEINFO


//
// Color-from-owner-draw-state macros
//
#ifndef NOCOLORHELP

#define ColorText(nState)           (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT)
#define ColorBk(nState)             (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHT : COLOR_WINDOW)
#define ColorMenuText(nState)       (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHTTEXT : COLOR_MENUTEXT)
#define ColorMenuBk(nState)         (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHT : COLOR_MENU)
#define GetImageDrawStyle(nState)   (((nState) & ODS_SELECTED) ? ILD_SELECTED : ILD_NORMAL)

#endif // NOCOLORHELP


//
// Dialog helper functions
//
#ifndef NODIALOGHELPER

// Sets the dialog handle in the given data struct on first
// message that the dialog gets (WM_SETFONT).
//
#define SetDlgHandle(hwnd, msg, lp)     if((msg)==WM_SETFONT) (lp)->hdlg=(hwnd);

#define DoModal         DialogBoxParam

VOID    
PUBLIC 
SetRectFromExtentW(
    HDC hdc, 
    LPRECT lprc, 
    LPCWSTR lpcwsz);
VOID    
PUBLIC 
SetRectFromExtentA(
    HDC hdc, 
    LPRECT lprc, 
    LPCSTR lpcsz);
#ifdef UNICODE
#define SetRectFromExtent     SetRectFromExtentW
#else
#define SetRectFromExtent     SetRectFromExtentA
#endif // UNICODE

#endif // NODIALOGHELPER


//
// Enhanced form of DrawText()
//
#ifndef NODRAWTEXT

// Flags for MyDrawText()
#define MDT_DRAWTEXT        0x00000001                                  
#define MDT_ELLIPSES        0x00000002                                  
#define MDT_LINK            0x00000004                                  
#define MDT_SELECTED        0x00000008                                  
#define MDT_DESELECTED      0x00000010                                  
#define MDT_DEPRESSED       0x00000020                                  
#define MDT_EXTRAMARGIN     0x00000040                                  
#define MDT_TRANSPARENT     0x00000080
#define MDT_LEFT            0x00000100
#define MDT_RIGHT           0x00000200
#define MDT_CENTER          0x00000400
#define MDT_VCENTER         0x00000800
#define MDT_CLIPPED         0x00001000

#ifndef CLR_DEFAULT         // (usually defined in commctrl.h)
#define CLR_DEFAULT         0xFF000000L
#endif

void    
PUBLIC 
MyDrawTextW(
    HDC hdc, 
    LPCWSTR pwszText, 
    RECT FAR* prc, 
    UINT flags, 
    int cyChar, 
    int cxEllipses, 
    COLORREF clrText, 
    COLORREF clrTextBk);
void    
PUBLIC 
MyDrawTextA(
    HDC hdc, 
    LPCSTR pszText, 
    RECT FAR* prc, 
    UINT flags, 
    int cyChar, 
    int cxEllipses, 
    COLORREF clrText, 
    COLORREF clrTextBk);
#ifdef UNICODE
#define MyDrawText      MyDrawTextW
#else
#define MyDrawText      MyDrawTextA
#endif // UNICODE


void    PUBLIC GetCommonMetrics(WPARAM wParam);

extern int g_cxLabelMargin;
extern int g_cxBorder;
extern int g_cyBorder;

extern COLORREF g_clrHighlightText;
extern COLORREF g_clrHighlight;
extern COLORREF g_clrWindowText;
extern COLORREF g_clrWindow;

extern HBRUSH g_hbrHighlight;
extern HBRUSH g_hbrWindow;

#endif // NODRAWTEXT

//
// Synchronization
//
#ifndef NOSYNC


// Safe version of MsgWaitMultipleObjects()
//
DWORD   PUBLIC MsgWaitObjectsSendMessage(DWORD cObjects, LPHANDLE phObjects, DWORD dwTimeout);

#else // NOSYNC


#endif // NOSYNC


//
// Path whacking functions
//
#if !defined(NOPATH) && defined(WIN95)

BOOL    PUBLIC WPPathIsRoot(LPCSTR pszPath);
BOOL    PUBLIC WPPathIsUNC(LPCSTR pszPath);
LPSTR   PUBLIC WPRemoveBackslash(LPSTR lpszPath);
LPSTR   PUBLIC WPRemoveExt(LPCSTR pszPath, LPSTR pszBuf);
LPSTR   PUBLIC WPFindNextComponentI(LPCSTR lpszPath);
void    PUBLIC WPMakePresentable(LPSTR pszPath);
BOOL    PUBLIC WPPathsTooLong(LPCSTR pszFolder, LPCSTR pszName);
void    PUBLIC WPCanonicalize(LPCSTR pszPath, LPSTR pszBuf);
LPSTR   PUBLIC WPFindFileName(LPCSTR pPath);
BOOL    PUBLIC WPPathExists(LPCSTR pszPath);
LPCSTR  PUBLIC WPFindEndOfRoot(LPCSTR pszPath);
BOOL    PUBLIC WPPathIsPrefix(LPCSTR lpcszPath1, LPCSTR lpcszPath2);

#ifdef WANT_SHELL_SUPPORT
LPSTR   PUBLIC WPGetDisplayName(LPCSTR pszPath, LPSTR pszBuf);

// Events for WPNotifyShell
typedef enum _notifyshellevent
    {
    NSE_CREATE       = 0,
    NSE_MKDIR,
    NSE_UPDATEITEM,
    NSE_UPDATEDIR
    } NOTIFYSHELLEVENT;

void    PUBLIC WPNotifyShell(LPCSTR pszPath, NOTIFYSHELLEVENT nse, BOOL bDoNow);
#endif // WANT_SHELL_SUPPORT

#endif // !defined(NOPATH) && defined(WIN95)


//
// Profile (.ini) support functions
//
// (Currently all profile functions are for DEBUG use only
#ifndef DEBUG
#define NOPROFILE
#endif
#ifndef NOPROFILE

#ifndef SZ_DEBUGINI
#pragma message("SZ_DEBUGINI is not #defined.  Assuming \"rover.ini\".")
#define SZ_DEBUGINI         "rover.ini"
#endif
#ifndef SZ_DEBUGSECTION
#pragma message("SZ_DEBUGSECTION is not #defined.  Assuming [Debug].")
#define SZ_DEBUGSECTION     "Debug"
#endif

BOOL    PUBLIC RovComm_ProcessIniFile(void);

#else // NOPROFILE

#define RovComm_ProcessIniFile()    TRUE

#endif // NOPROFILE


//
// Debug helper functions
//


// Break flags
#define BF_ONVALIDATE       0x00000001
#define BF_ONOPEN           0x00000002
#define BF_ONCLOSE          0x00000004
#define BF_ONRUNONCE        0x00000008
#define BF_ONTHREADATT      0x00000010
#define BF_ONTHREADDET      0x00000020
#define BF_ONPROCESSATT     0x00000040
#define BF_ONPROCESSDET     0x00000080
#define BF_ONAPIENTER       0x00000100

// Trace flags
#define TF_ALWAYS           0x00000000
#define TF_WARNING          0x00000001
#define TF_ERROR            0x00000002
#define TF_GENERAL          0x00000004      // Standard messages
#define TF_FUNC             0x00000008      // Trace function calls
// (Upper 16 bits reserved for user)

#if defined(NODEBUGHELP) || !defined(DEBUG)

#define DEBUG_BREAK  (void)0
#define ASSERT(f)
#define EVAL(f)      (f)
#define ASSERT_MSG    {}
#define DEBUG_MSG     {}
#define TRACE_MSGA    {}
#define TRACE_MSGW    {}
#ifdef UNICODE
#define TRACE_MSG   TRACE_MSGW
#else
#define TRACE_MSG   TRACE_MSGA
#endif

#define VERIFY_SZ(f, szFmt, x)          (f)
#define VERIFY_SZ2(f, szFmt, x1, x2)    (f)

#define DBG_ENTER(fn)
#define DBG_ENTER_SZ(fn, sz)
#define DBG_ENTER_DTOBJ(fn, pdtobj, sz)
#define DBG_ENTER_RIID(fn, riid)   
#define DBG_ENTER_UL(fn, ul)   

#define DBG_EXIT(fn)                            
#define DBG_EXIT_TYPE(fn, dw, pfnStrFromType)
#define DBG_EXIT_INT(fn, n)
#define DBG_EXIT_BOOL(fn, b)
#define DBG_EXIT_US(fn, us)
#define DBG_EXIT_UL(fn, ul)
#define DBG_EXIT_DWORD      DBG_EXIT_UL
#define DBG_EXIT_PTR(fn, ptr)                            
#define DBG_EXIT_HRES(fn, hres)   

#else // defined(NODEBUGHELP) || !defined(DEBUG)

extern DWORD g_dwDumpFlags;
extern DWORD g_dwBreakFlags;
extern DWORD g_dwTraceFlags;
extern LONG  g_dwIndent;

// Debugging macros
//
#ifndef SZ_MODULEA
#error SZ_MODULEA is not #defined
#endif
#if defined(UNICODE) && !defined(SZ_MODULEW)
#error SZ_MODULEW is not #defined
#endif

#define DEBUG_CASE_STRING(x)    case x: return #x

#define DEBUG_STRING_MAPW(x)    { x, TEXT(#x) }
#define DEBUG_STRING_MAPA(x)    { x, #x }
#ifdef UNICODE
#define DEBUG_STRING_MAP    DEBUG_STRING_MAPW
#else  // UNICODE
#define DEBUG_STRING_MAP    DEBUG_STRING_MAPA
#endif // UNICODE

#define ASSERTSEG

// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg) \
    static const CHAR ASSERTSEG sz[] = msg;

void    PUBLIC CommonDebugBreak(DWORD flag);
void    PUBLIC CommonAssertFailed(LPCSTR szFile, int line);

void    
CPUBLIC 
CommonAssertMsgW(
    BOOL f, 
    LPCWSTR pwszMsg, ...);
void    
CPUBLIC 
CommonAssertMsgA(
    BOOL f, 
    LPCSTR pszMsg, ...);
#ifdef UNICODE
#define CommonAssertMsg      CommonAssertMsgW
#else
#define CommonAssertMsg      CommonAssertMsgA
#endif // UNICODE

BOOL WINAPI
DisplayDebug(
    DWORD flag
    );


void    
CPUBLIC 
CommonDebugMsgW(
    DWORD mask, 
    LPCSTR pszMsg, ...);
void    
CPUBLIC 
CommonDebugMsgA(
    DWORD mask, 
    LPCSTR pszMsg, ...);
#ifdef UNICODE
#define CommonDebugMsg      CommonDebugMsgW
#else
#define CommonDebugMsg      CommonDebugMsgA
#endif // UNICODE

LPCWSTR  
PUBLIC 
Dbg_SafeStrW(
    LPCWSTR pwsz);
LPCSTR  
PUBLIC 
Dbg_SafeStrA(
    LPCSTR psz);
#ifdef UNICODE
#define Dbg_SafeStr      Dbg_SafeStrW
#else
#define Dbg_SafeStr      Dbg_SafeStrA
#endif // UNICODE

#define DEBUG_BREAK     CommonDebugBreak

// ASSERT(f)  -- Generate "assertion failed in line x of file.c"
//               message if f is NOT true.
//
#define ASSERT(f)                                                       \
    {                                                                   \
        DEBUGTEXT(szFile, __FILE__);                                    \
        if (!(f))                                                       \
            CommonAssertFailed(szFile, __LINE__);                       \
    }
#define EVAL        ASSERT

// ASSERT_MSG(f, msg, args...)  -- Generate wsprintf-formatted 
//                          messsage w/params if f is NOT true.
//
#define ASSERT_MSG   CommonAssertMsg

// TRACE_MSG(mask, msg, args...) - Generate wsprintf-formatted msg using
//                          specified debug mask.  System debug mask
//                          governs whether message is output.
//
#define TRACE_MSGW   CommonDebugMsgW
#define TRACE_MSGA   CommonDebugMsgA
#define TRACE_MSG    CommonDebugMsg

// VERIFY_SZ(f, msg, arg)  -- Generate wsprintf-formatted msg w/ 1 param
//                          if f is NOT true 
//
#define VERIFY_SZ(f, szFmt, x)   ASSERT_MSG(f, szFmt, x)


// VERIFY_SZ2(f, msg, arg1, arg2)  -- Generate wsprintf-formatted msg w/ 2
//                          param if f is NOT true 
//
#define VERIFY_SZ2(f, szFmt, x1, x2)   ASSERT_MSG(f, szFmt, x1, x2)



// DBG_ENTER(fn)  -- Generates a function entry debug spew for
//                          a function 
//
#define DBG_ENTER(fn)                  \
    TRACE_MSG(TF_FUNC, "> " #fn "()");\
    g_dwIndent+=2


// DBG_ENTER_SZ(fn, sz)  -- Generates a function entry debug spew for
//                          a function that accepts a string as one of its
//                          parameters.
//
#define DBG_ENTER_SZ(fn, sz)                  \
    TRACE_MSG(TF_FUNC, "> " #fn "(..., \"%s\",...)", Dbg_SafeStr(sz)); \
    g_dwIndent+=2


// DBG_ENTER_UL(fn, ul)  -- Generates a function entry debug spew for
//                          a function that accepts a DWORD as one of its
//                          parameters.
//
#define DBG_ENTER_UL(fn, ul)                  \
    TRACE_MSG(TF_FUNC, "> " #fn "(..., %#08lx,...)", (ULONG)(ul)); \
    g_dwIndent+=2


#ifdef WANT_OLE_SUPPORT
// DBG_ENTER_RIID(fn, riid)  -- Generates a function entry debug spew for
//                          a function that accepts an riid as one of its
//                          parameters.
//
#define DBG_ENTER_RIID(fn, riid)                  \
    TRACE_MSG(TF_FUNC, "> " #fn "(..., %s,...)", Dbg_GetRiidName(riid)); \
    g_dwIndent+=2
#endif


// DBG_EXIT(fn)  -- Generates a function exit debug spew 
//
#define DBG_EXIT(fn)                              \
        g_dwIndent-=2;                            \
        TRACE_MSG(TF_FUNC, "< " #fn "()")

// DBG_EXIT_TYPE(fn, dw, pfnStrFromType)  -- Generates a function exit debug 
//                          spew for functions that return <type>.
//
#define DBG_EXIT_TYPE(fn, dw, pfnStrFromType)                   \
        g_dwIndent-=2;                                           \
        TRACE_MSG(TF_FUNC, "< " #fn "() with %s", (LPCTSTR)pfnStrFromType(dw))

// DBG_EXIT_INT(fn, us)  -- Generates a function exit debug spew for
//                          functions that return an INT.
//
#define DBG_EXIT_INT(fn, n)                       \
        g_dwIndent-=2;                             \
        TRACE_MSG(TF_FUNC, "< " #fn "() with %d", (int)(n))

// DBG_EXIT_BOOL(fn, b)  -- Generates a function exit debug spew for
//                          functions that return a boolean.
//
#define DBG_EXIT_BOOL(fn, b)                      \
        g_dwIndent-=2;                             \
        TRACE_MSG(TF_FUNC, "< " #fn "() with %s", (b) ? (LPTSTR)TEXT("TRUE") : (LPTSTR)TEXT("FALSE"))

// DBG_EXIT_US(fn, us)  -- Generates a function exit debug spew for
//                          functions that return a USHORT.
//
#define DBG_EXIT_US(fn, us)                       \
        g_dwIndent-=2;                             \
        TRACE_MSG(TF_FUNC, "< " #fn "() with %#x", (USHORT)(us))

// DBG_EXIT_UL(fn, ul)  -- Generates a function exit debug spew for
//                          functions that return a ULONG.
//
#define DBG_EXIT_UL(fn, ul)                   \
        g_dwIndent-=2;                         \
        TRACE_MSG(TF_FUNC, "< " #fn "() with %#08lx", (ULONG)(ul))
#define DBG_EXIT_DWORD      DBG_EXIT_UL

// DBG_EXIT_PTR(fn, pv)  -- Generates a function exit debug spew for
//                          functions that return a pointer.
//
#define DBG_EXIT_PTR(fn, pv)                   \
        g_dwIndent-=2;                          \
        TRACE_MSG(TF_FUNC, "< " #fn "() with %#lx", (LPVOID)(pv))

// DBG_EXIT_HRES(fn, hres)  -- Generates a function exit debug spew for
//                          functions that return an HRESULT.
//
#define DBG_EXIT_HRES(fn, hres)     DBG_EXIT_TYPE(fn, hres, Dbg_GetScode)

#endif // defined(NODEBUGHELP) || !defined(DEBUG)


//
// Standard functions
// 

BOOL    PUBLIC RovComm_Init(HINSTANCE hinst);
BOOL    PUBLIC RovComm_Terminate(HINSTANCE hinst);


// Admin related
BOOL PUBLIC IsAdminUser(void);

//
// Device Installer wrappers and helper functions
//

#ifndef NODI

#include <rovdi.h>

#endif // NODI

LONG
QueryModemForCountrySettings(
    HKEY    ModemRegKey,
    BOOL    ForceRequery
    );

typedef LONG (*lpQueryModemForCountrySettings)(
    HKEY    ModemRegKey,
    BOOL    ForceRequery
    );



#endif // __ROVCOMM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\inc\rovdbg.h ===
//
// Copyright (c) Microsoft Corporation 1993-1995
//
// rovdbg.h
//
// Provides debug macro code that is needed to allow the binary to
// link.
//
// This file should be included by only one source in your project.
// If you get multiple redefinitions of the supplied functions, then
// you are not doing something right.  Sorry to be so blunt.
//
// These functions are not declared if NODEBUGHELP is defined.
//
// History:
//  09-21-95 ScottH     Created
//

#ifndef __ROVDBG_H__
#define __ROVDBG_H__

#if !defined(__ROVCOMM_H__)
#error ROVCOMM.H must be included to use the common debug macros!
#endif

#if !defined(NODEBUGHELP) && defined(DEBUG)

#pragma data_seg(DATASEG_READONLY)

#ifndef NOPROFILE

WCHAR const FAR c_szRovIniFile[] = SZ_DEBUGINI;
WCHAR const FAR c_szRovIniSecDebugUI[] = SZ_DEBUGSECTION;

#endif 

#ifdef WINNT

// We don't use the TEXT() macro's here, because we want to define these as
// Unicode even when were in a non-unicode module.
WCHAR const FAR c_wszNewline[] = L"\r\n";
WCHAR const FAR c_wszTrace[] = L"t " SZ_MODULEW L" ";
WCHAR const FAR c_wszAssertFailed[] = SZ_MODULEW L"  Assertion failed in %s on line %d\r\n";

#endif // WINNT

CHAR const FAR c_szNewline[] = "\r\n";
CHAR const FAR c_szTrace[] = "t " SZ_MODULEA " ";
CHAR const FAR c_szAssertFailed[] = SZ_MODULEA "  Assertion failed in %s on line %d\r\n";

#pragma data_seg()


#endif  // !defined(NODEBUGHELP) && defined(DEBUG)

#endif __ROVDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\inc\modemp.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1995
//
// File: modemp.h
//
// This files contains the private modem structures and defines shared
// between Unimodem components.
//
//---------------------------------------------------------------------------

#ifndef __MODEMP_H__
#define __MODEMP_H__


typedef DCB     WIN32DCB;
typedef DCB *   LPWIN32DCB;


#define COMMCONFIG_VERSION_1 1


//------------------------------------------------------------------------
//------------------------------------------------------------------------


//
// Registry forms of the MODEMDEVCAPS and MODEMSETTINGS structures.  
// These should match the ones in unimodem\mcx\internal.h.
//

// The portion of the MODEMDEVCAPS that is saved in the registry 
// as Properties
typedef struct _RegDevCaps
    {
    DWORD   dwDialOptions;          // bitmap of supported values
    DWORD   dwCallSetupFailTimer;   // maximum in seconds
    DWORD   dwInactivityTimeout;    // maximum in the units specified in the InactivityScale value
    DWORD   dwSpeakerVolume;        // bitmap of supported values
    DWORD   dwSpeakerMode;          // bitmap of supported values
    DWORD   dwModemOptions;         // bitmap of supported values
    DWORD   dwMaxDTERate;           // maximum value in bit/s
    DWORD   dwMaxDCERate;           // maximum value in bit/s
    } REGDEVCAPS, FAR * LPREGDEVCAPS;

// The portion of the MODEMSETTINGS that is saved in the registry 
// as Default
typedef struct _RegDevSettings
    {
    DWORD   dwCallSetupFailTimer;       // seconds
    DWORD   dwInactivityTimeout;        // units specified in the InactivityScale value
    DWORD   dwSpeakerVolume;            // level
    DWORD   dwSpeakerMode;              // mode
    DWORD   dwPreferredModemOptions;    // bitmap
    } REGDEVSETTINGS, FAR * LPREGDEVSETTINGS;


//
// DeviceType defines
//

#define DT_NULL_MODEM       0
#define DT_EXTERNAL_MODEM   1
#define DT_INTERNAL_MODEM   2
#define DT_PCMCIA_MODEM     3
#define DT_PARALLEL_PORT    4
#define DT_PARALLEL_MODEM   5

//------------------------------------------------------------------------
//------------------------------------------------------------------------

#ifdef UNICODE
#define drvCommConfigDialog     drvCommConfigDialogW
#define drvGetDefaultCommConfig drvGetDefaultCommConfigW
#define drvSetDefaultCommConfig drvSetDefaultCommConfigW
#else
#define drvCommConfigDialog     drvCommConfigDialogA
#define drvGetDefaultCommConfig drvGetDefaultCommConfigA
#define drvSetDefaultCommConfig drvSetDefaultCommConfigA
#endif

DWORD 
APIENTRY 
drvCommConfigDialog(
    IN     LPCTSTR      pszFriendlyName,
    IN     HWND         hwndOwner,
    IN OUT LPCOMMCONFIG pcc);

DWORD 
APIENTRY 
drvGetDefaultCommConfig(
    IN     LPCTSTR      pszFriendlyName,
    IN     LPCOMMCONFIG pcc,
    IN OUT LPDWORD      pdwSize);

DWORD 
APIENTRY 
drvSetDefaultCommConfig(
    IN LPTSTR       pszFriendlyName,
    IN LPCOMMCONFIG pcc,
    IN DWORD        dwSize);


//------------------------------------------------------------------------
//------------------------------------------------------------------------

// These are the flags for MODEM_INSTALL_WIZARD
#define MIWF_DEFAULT            0x00000000
#define MIWF_INSET_WIZARD       0x00000001      // hwndWizardDlg must be owner's 
                                                //  wizard frame
#define MIWF_BACKDOOR           0x00000002      // enter wizard thru last page

// The ExitButton field can be:
//
//      PSBTN_BACK
//      PSBTN_NEXT
//      PSBTN_FINISH
//      PSBTN_CANCEL

#endif  // __MODEMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\inc\rovmem.h ===
//
// Copyright (c) Microsoft Corporation 1993-1995
//
// rovmem.h
//
// Memory management functions.
//
// History:
//  09-27-94 ScottH     Partially taken from commctrl
//  04-29-95 ScottH     Taken from briefcase and cleaned up
//

// This file is included by <rovcomm.h>

#ifndef _ROVMEM_H_
#define _ROVMEM_H_

//
// Memory routines
//

BOOL    
PUBLIC 
SetStringW(
    LPWSTR FAR * ppwszBuf, 
    LPCWSTR pwsz);
BOOL    
PUBLIC 
SetStringA(
    LPSTR FAR * ppszBuf, 
    LPCSTR psz);
#ifdef UNICODE
#define SetString   SetStringW
#else  // UNICODE
#define SetString   SetStringA
#endif // UNICODE


//      (Re)allocates *ppszBuf and concatenates psz onto *ppszBuf 
//
BOOL 
PUBLIC 
CatStringW(
    IN OUT LPWSTR FAR * ppszBuf,
    IN     LPCWSTR     psz);
BOOL 
PUBLIC 
CatStringA(
    IN OUT LPSTR FAR * ppszBuf,
    IN     LPCSTR      psz);
#ifdef UNICODE
#define CatString   CatStringW
#else  // UNICODE
#define CatString   CatStringA
#endif // UNICODE


BOOL 
PUBLIC 
CatMultiStringW(
    IN OUT LPWSTR FAR * ppszBuf,
    IN     LPCWSTR     psz);
BOOL 
PUBLIC 
CatMultiStringA(
    IN OUT LPSTR FAR * ppszBuf,
    IN     LPCSTR      psz);
#ifdef UNICODE
#define CatMultiString      CatMultiStringW
#else  // UNICODE
#define CatMultiString      CatMultiStringA
#endif // UNICODE


#endif // _ROVMEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\inc\umdmmini.h ===
#ifdef __cplusplus
extern "C" {
#endif

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    umdmmini.h

Abstract:

    Nt 5.0 unimodem miniport interface


    The miniport driver is guarenteed that only one action command will
    be austanding at one time. If an action command is called, no more
    commands will be issued until the miniport indicates that it has
    complete processing of the current command.

    UmAbortCurrentCommand() may be called while a command is currently executing
    to infor the miniport that the TSP would like it to complete the current command
    so that it may issue some other command. The miniport may complete the as soon
    as is apropreate.

    The Overlapped callback and Timer callbacks are not synchronized by the TSP
    and may be called at anytime. It is the responsibily of the mini dirver to
    protect its data structures from re-entrancy issues.


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/



#define ERROR_UNIMODEM_RESPONSE_TIMEOUT     (20000)
#define ERROR_UNIMODEM_RESPONSE_ERROR       (20001)
#define ERROR_UNIMODEM_RESPONSE_NOCARRIER   (20002)
#define ERROR_UNIMODEM_RESPONSE_NODIALTONE  (20003)
#define ERROR_UNIMODEM_RESPONSE_BUSY        (20004)
#define ERROR_UNIMODEM_RESPONSE_NOANSWER    (20005)
#define ERROR_UNIMODEM_RESPONSE_BAD         (20006)

#define ERROR_UNIMODEM_MODEM_EVENT_TIMEOUT  (20007)
#define ERROR_UNIMODEM_INUSE                (20008)

#define ERROR_UNIMODEM_MISSING_REG_KEY      (20009)

#define ERROR_UNIMODEM_NOT_IN_VOICE_MODE    (20010)
#define ERROR_UNIMODEM_NOT_VOICE_MODEM      (20011)
#define ERROR_UNIMODEM_BAD_WAVE_REQUEST     (20012)

#define ERROR_UNIMODEM_GENERAL_FAILURE      (20013)

#define ERROR_UNIMODEM_RESPONSE_BLACKLISTED (20014)
#define ERROR_UNIMODEM_RESPONSE_DELAYED     (20015)

#define ERROR_UNIMODEM_BAD_COMMCONFIG       (20016)
#define ERROR_UNIMODEM_BAD_TIMEOUT          (20017)
#define ERROR_UNIMODEM_BAD_FLAGS            (20018)
#define ERROR_UNIMODEM_BAD_PASSTHOUGH_MODE  (20019)

#define ERROR_UNIMODEM_DIAGNOSTICS_NOT_SUPPORTED  (20020)

//
//  Callback from unimodem miniport to client.
//
//  uses for completion of outstanding commands and notification
//  of unsolisited events
//
//  Parameters:
//
//     Conetext    - Opaque value passed to OpenModem
//     MessageType - Identifies type of callback
//     dwParam1    - message specific
//     dwParam2    - message specific

//
//  Completion of a pending command
//
//    dwParam1 is the Final status
//
//    dwParam2 if a data connection, may point to a UM_NEGOTIATED_OPTIONS structure
//             only valid during call
//
#define    MODEM_ASYNC_COMPLETION     (0x01)

#define    MODEM_RING                 (0x02)
#define    MODEM_DISCONNECT           (0x03)
#define    MODEM_HARDWARE_FAILURE     (0x04)

//
//  the some unrecogized data has been received from the modem
//
//  dwParam is a pointer to the SZ string.
//
#define    MODEM_UNRECOGIZED_DATA     (0x05)


//
//  dtmf detected, dwParam1 id the ascii value of the detect tone 0-9,a-d,#,*
//
#define    MODEM_DTMF_START_DETECTED  (0x06)
#define    MODEM_DTMF_STOP_DETECTED   (0x07)


//
//  handset state change
//
//    dwParam1 = 0 for on hook or 1 for offhook
//
#define    MODEM_HANDSET_CHANGE       (0x0a)


//
//  reports the distinctive time times
//
//  dwParam1 id the ring time in ms
//
#define    MODEM_RING_ON_TIME         (0x0b)
#define    MODEM_RING_OFF_TIME        (0x0c)


//
//  caller id info recieved
//
//    dwParam1 is pointer to SZ that represents the name/number
//
#define    MODEM_CALLER_ID_DATE       (0x0d)
#define    MODEM_CALLER_ID_TIME       (0x0e)
#define    MODEM_CALLER_ID_NUMBER     (0x0f)
#define    MODEM_CALLER_ID_NAME       (0x10)
#define    MODEM_CALLER_ID_MESG       (0x11)

#define    MODEM_CALLER_ID_OUTSIDE           "O"
#define    MODEM_CALLER_ID_PRIVATE           "P"

#define    MODEM_POWER_RESUME         (0x12)

//
//  return good response string
//
//  dwParam1 id a resonse type defined below
//  dwparam2 is a PSZ to the response string.
//
#define    MODEM_GOOD_RESPONSE        (0x13)

#define    MODEM_USER_REMOVE          (0x14)

#define    MODEM_DLE_START            (0x20)

#define    MODEM_HANDSET_OFFHOOK      (MODEM_DLE_START +  0)
#define    MODEM_HANDSET_ONHOOK       (MODEM_DLE_START +  1)

#define    MODEM_DLE_RING             (MODEM_DLE_START +  2)
#define    MODEM_RINGBACK             (MODEM_DLE_START +  3)

#define    MODEM_2100HZ_ANSWER_TONE   (MODEM_DLE_START +  4)
#define    MODEM_BUSY                 (MODEM_DLE_START +  5)

#define    MODEM_FAX_TONE             (MODEM_DLE_START +  6)
#define    MODEM_DIAL_TONE            (MODEM_DLE_START +  7)

#define    MODEM_SILENCE              (MODEM_DLE_START +  8)
#define    MODEM_QUIET                (MODEM_DLE_START +  9)

#define    MODEM_1300HZ_CALLING_TONE  (MODEM_DLE_START + 10)
#define    MODEM_2225HZ_ANSWER_TONE   (MODEM_DLE_START + 11)

#define    MODEM_LOOP_CURRENT_INTERRRUPT  (MODEM_DLE_START + 12)
#define    MODEM_LOOP_CURRENT_REVERSAL    (MODEM_DLE_START + 13)


typedef VOID (*LPUMNOTIFICATIONPROC)(
    HANDLE    Context,
    DWORD     MessageType,
    ULONG_PTR  dwParam1,
    ULONG_PTR  dwParam2
    );


typedef VOID (OVERLAPPEDCOMPLETION)(
    struct _UM_OVER_STRUCT  *UmOverlapped
    );



//
//  Extended definition for overlapped structirs returned from the completion
//  port.
//
//

typedef struct _UM_OVER_STRUCT {
    //
    //  standard overlapped strunct
    //
    OVERLAPPED    Overlapped;

    struct _UM_OVER_STRUCT  *Next;

    PVOID         OverlappedPool;

    HANDLE        FileHandle;

    //
    //  private completion routine filled in prior to the i/o operation being submitted
    //  to the I/o function (ReadFile). Will be called when the i/o is removed from completion
    //  port by unimodem class driver
    //
//    OVERLAPPEDCOMPLETION   *PrivateCompleteionHandler;
    LPOVERLAPPED_COMPLETION_ROUTINE PrivateCompleteionHandler;

    //
    //  Private context supplied for use of callback function
    //
    HANDLE        Context1;

    //
    //  Private context supplied for use of callback function
    //
    HANDLE        Context2;


    } UM_OVER_STRUCT, *PUM_OVER_STRUCT;


//
//  Command Option structure
//

#define UM_BASE_OPTION_CLASS   (0x00)

typedef struct _UM_COMMAND_OPTION {
    //
    //  specifies which option class
    //
    //  UM_BASE_OPTION_CLASS
    //
    DWORD    dwOptionClass;

    //
    //  Commands specific option flags
    //
    DWORD    dwFlags;

    //
    //  link to next option class
    //
    struct _UM_COMMAND_OPTION  *Next;

    //
    //  count in bytes of any additional ddata immediatly following this structure
    //
    DWORD    cbOptionDataSize;

} UM_COMMAND_OPTION, *PUM_COMMAND_OPTION;


//
//  Negotiated connection options
//
typedef struct _UM_NEGOTIATED_OPTIONS {

    //
    //  DCE rate
    //
    DWORD    DCERate;

    //
    //  compression, errorcontrol
    //
    DWORD    ConnectionOptions;

} UM_NEGOTIATED_OPTIONS, *PUM_NEGOTIATED_OPTIONS;



#define RESPONSE_OK             0x0
#define RESPONSE_LOOP           0x1
#define RESPONSE_CONNECT        0x2
#define RESPONSE_ERROR          0x3
#define RESPONSE_NOCARRIER      0x4
#define RESPONSE_NODIALTONE     0x5
#define RESPONSE_BUSY           0x6
#define RESPONSE_NOANSWER       0x7
#define RESPONSE_RING           0x8

#define RESPONSE_DRON           0x11
#define RESPONSE_DROF           0x12

#define RESPONSE_DATE           0x13
#define RESPONSE_TIME           0x14
#define RESPONSE_NMBR           0x15
#define RESPONSE_NAME           0x16
#define RESPONSE_MESG           0x17

#define RESPONSE_RINGA          0x18
#define RESPONSE_RINGB          0x19
#define RESPONSE_RINGC          0x1A

#define RESPONSE_SIERRA_DLE     0x1b

#define RESPONSE_BLACKLISTED    0x1c
#define RESPONSE_DELAYED        0x1d

#define RESPONSE_DIAG           0x1e

#define RESPONSE_V8             0x1f

#define RESPONSE_VARIABLE_FLAG  0x80

#define RESPONSE_START          RESPONSE_OK
#define RESPONSE_END            RESPONSE_V8



typedef
HANDLE
(*PFNUMINITIALIZEMODEMDRIVER)(
    void *ValidationObject
    );

HANDLE WINAPI
UmInitializeModemDriver(
    void *ValidationObject
    );
/*++

Routine Description:

    This routine is called to initialize the modem driver.
    It maybe called multiple times. After the first call a reference count will simply
    be incremented. UmDeinitializeModemDriver() must be call and equal number of times.

Arguments:

    ValidationObject - opaque handle to a validation object which much
                       be processed properly to "prove" that this is a
                       Microsoft(tm)-certified driver.

Return Value:

    returns a handle to Driver instance which is passed to UmOpenModem()
    or NULL for failure



--*/


typedef
VOID
(*PFNUMDEINITIALIZEMODEMDRIVER) (
    HANDLE      ModemDriverHandle
    );

VOID WINAPI
UmDeinitializeModemDriver(
    HANDLE    DriverInstanceHandle
    );
/*++

Routine Description:

    This routine is called to de-initialize the modem driver.

    Must be called the same number of time as UmInitializeModemDriver()

Arguments:

    DriverInstanceHandle - Handle returned by UmInitialmodemDriver

Return Value:

    None


--*/

typedef
HANDLE
(*PFNUMOPENMODEM) (
    HANDLE      ModemDriverHandle,
    HANDLE      ExtensionBindingHandle,
    HKEY        ModemRegistry,
    HANDLE      CompletionPort,
    LPUMNOTIFICATIONPROC  AsyncNotificationProc,
    HANDLE      AsyncNotifcationContext,
    DWORD       DebugDeviceId,
    HANDLE     *CommPortHandle
    );


HANDLE WINAPI
UmOpenModem(
    HANDLE      ModemDriverHandle,
    HANDLE      ExtensionBindingHandle,
    HKEY        ModemRegistry,
    HANDLE      CompletionPort,
    LPUMNOTIFICATIONPROC  AsyncNotificationProc,
    HANDLE      AsyncNotificationContext,
    DWORD       DebugDeviceId,
    HANDLE     *CommPortHandle
    );
/*++

Routine Description:

    This routine is called to open a device supported by the miniport.
    The driver will determine it phyical device/kernel mode driver by
    accessing the registry key supplied.

Arguments:

    ModemDriverHandle - Returned from UmInitializemodem()

    ExtensionBindingHandle - Reserved, must be NULL.

    ModemRegistry  - An open registry key to specific devices registry info

    CompletionPort - Handle to a completeion port that the miniport may associate to
                     anydevice file handles that it opens

    AsyncNotificationProc - Address of a callback function to recieve async notifications

    AsyncNotificationContext - Context value passed as first parameter callback function

    DebugDeviceId  - instance of device to be used in displaying debug info

    CommPortHandle - Pointer to a handle that will receive the file handle of the open comm port

Return Value:

    NULL for failure or

    Handle to be used in subsequent calls to other miniport functinos.

--*/


typedef
VOID
(*PFNUMCLOSEMODEM)(
    HANDLE    ModemHandle
    );

VOID WINAPI
UmCloseModem(
    HANDLE    ModemHandle
    );
/*++

Routine Description:

    This routine is called to close a modem handle retuned by OpenModem

Arguments:

    ModemHandle - Handle returned by OpenModem

Return Value:

    None

--*/

typedef
VOID
(*PFNUMABORTCURRENTMODEMCOMMAND)(
    HANDLE    ModemHandle
    );

VOID WINAPI
UmAbortCurrentModemCommand(
    HANDLE    ModemHandle
    );
/*++

Routine Description:

    This routine is called to abort a current pending command being handled by the miniport.
    This routine should attempt to get the current command to complete as soon as possible.
    This service is advisory. It is meant to tell the driver that port driver wants to cancel
    the current operation. The Port driver must still wait for the async completion of the
    command being canceled, and that commands way infact return successfully. The miniport
    should abort in such a way that the device is in a known state and can accept future commands


Arguments:

    ModemHandle - Handle returned by OpenModem

Return Value:

    None

--*/



typedef
DWORD
(*PFNUMINITMODEM)(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    LPCOMMCONFIG  CommConfig
    );

DWORD WINAPI
UmInitModem(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    LPCOMMCONFIG  CommConfig
    );
/*++

Routine Description:

    This routine is called to initialize the modem to a known state using the parameters
    supplied in the CommConfig structure. If some settings do not apply to the actual hardware
    then they can be ignored.

Arguments:

    ModemHandle - Handle returned by OpenModem

    CommandsOptionList - List option blocks, only flags used
       Flags   - Optional init parameters. Not currently used and must be zero

    CommConfig  - CommConig structure with MODEMSETTINGS structure.

Return Value:

    ERROR_SUCCESS if successfull
    ERROR_IO_PENDING If pending, will be completed later with a call to the AsyncHandler

    or other specific error


--*/



#define MONITOR_FLAG_CALLERID            (1 << 0)
#define MONITOR_FLAG_DISTINCTIVE_RING    (1 << 1)
#define MONITOR_VOICE_MODE          (1 << 2)

typedef
DWORD
(*PFNUMMONITORMODEM)(
    HANDLE    ModemHandle,
    DWORD     MonitorFlags,
    PUM_COMMAND_OPTION  CommandOptionList
    );

DWORD WINAPI
UmMonitorModem(
    HANDLE    ModemHandle,
    DWORD     MonitorFlags,
    PUM_COMMAND_OPTION  CommandOptionList
    );
/*++

Routine Description:

    This routine is called to clause the modem to monitor for incomming calls.
    The successful completion of the function simply indicated the monitoring was
    correctly initiated, not that a ring as appeared. Rings are indicated through
    the async completion rountine separatly.

Arguments:

    ModemHandle - Handle returned by OpenModem

    MonitorFlags - Specifies options, may be zero of more the following

         MONITOR_FLAG_CALLERID - enable caller ID reporting
         MONITOR_FLAG_DISTINCTIVE_RING - enable distinctive ring reporting


    CommandsOptionList - None currently supported, should be NULL


Return Value:

    ERROR_IO_PENDING If pending, will be completed later with a call to the AsyncHandler

    or other specific error



--*/



#define    ANSWER_FLAG_DATA                 (1 << 0)
#define    ANSWER_FLAG_VOICE                (1 << 1)
#define    ANSWER_FLAG_VOICE_TO_DATA        (1 << 2)


typedef
DWORD
(*PFNUMANSWERMODEM) (
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    DWORD     AnswerFlags
    );

DWORD WINAPI
UmAnswerModem(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    DWORD     AnswerFlags
    );
/*++

Routine Description:

    This routine is called to answer an incomming call,

Arguments:

    ModemHandle - Handle returned by OpenModem

    CommandsOptionList - List option blocks, only flags used

      Flags -  One of the following

        ANSWER_FLAG_DATA              - Answer as data call
        ANSWER_FLAG_VOICE             - Answer as interactiver voice

Return Value:

    ERROR_IO_PENDING If pending, will be completed later with a call to the AsyncHandler

    or other specific error



--*/



//
//  dial as data
//
#define    DIAL_FLAG_DATA                         (1 << 0)

//
//  dial as interactive voice, return success immedialy after digits are dialed
//
#define    DIAL_FLAG_INTERACTIVE_VOICE            (1 << 1)

//
//  dial as automated voice, return success only after ring back goes away
//
#define    DIAL_FLAG_AUTOMATED_VOICE              (1 << 2)

//
//  uses DTMF, otherwise use pulse
//
#define    DIAL_FLAG_TONE                         (1 << 3)

//
//  Enable blind dial
//
#define    DIAL_FLAG_BLIND                        (1 << 4)


//
//  orginate the call, don't inlcude a semicolon at end of dial string, no lineDials()
//
#define    DIAL_FLAG_ORIGINATE                    (1 << 5)


//
//  set on the first call to DialModem() for a voice call. If additional calls(lineDial)
//  are made then this flag should be clear
//
#define    DIAL_FLAG_VOICE_INITIALIZE             (1 << 6)




typedef
DWORD
(*PFNUMDIALMODEM)(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    LPSTR     szNumber,
    DWORD     DialFlags
    );

DWORD WINAPI
UmDialModem(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    LPSTR     szNumber,
    DWORD     DialFlags
    );
/*++

Routine Description:

    This routine is called to dial a call

Arguments:

    ModemHandle - Handle returned by OpenModem

    CommandsOptionList - List option blocks, only flags used

Return Value:

    ERROR_IO_PENDING If pending, will be completed later with a call to the AsyncHandler

    or other specific error


--*/



//
//  the call is a connected data call, driver will lower DTR or +++ ect.
//
#define  HANGUP_FLAGS_CONNECTED_DATA_CALL               (1 << 0)

//
//  issue special voice hangup command if present, used for sierra modems
//
#define  HANGUP_FLAGS_VOICE_CALL                        (1 << 1)

typedef
DWORD // WINAPI
(*PFNUMHANGUPMODEM)(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    DWORD     HangupFlags
    );

DWORD WINAPI
UmHangupModem(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    DWORD     HangupFlags
    );
/*++

Routine Description:

    This routine is called to hangup a call

Arguments:

    ModemHandle - Handle returned by OpenModem

    CommandsOptionList - List option blocks, only flags used

        Flags - see above

Return Value:

    ERROR_IO_PENDING If pending, will be completed later with a call to the AsyncHandler

    or other specific error


--*/

typedef
HANDLE
(*PFNUMDUPLICATEDEVICEHANDLE)(
    HANDLE    ModemHandle,
    HANDLE    ProcessHandle
    );


HANDLE WINAPI
UmDuplicateDeviceHandle(
    HANDLE    ModemHandle,
    HANDLE    ProcessHandle
    );
/*++

Routine Description:

    This routine is called to duplicate the actual device handle that the miniport is using
    to communicate to the deivce. CloseHandle() must be called on the handle before a new
    call may be placed.

Arguments:

    ModemHandle - Handle returned by OpenModem

    ProcessHandle - Handle of process wanting handle

Return Value:

    Valid handle of NULL if failure

--*/



#define PASSTHROUUGH_MODE_OFF          (0x00)
#define PASSTHROUUGH_MODE_ON           (0x01)
#define PASSTHROUUGH_MODE_ON_DCD_SNIFF (0x02)


typedef
DWORD
(*PFNUMSETPASSTHROUGHMODE)(
    HANDLE    ModemHandle,
    DWORD     PasssthroughMode
    );

DWORD WINAPI
UmSetPassthroughMode(
    HANDLE    ModemHandle,
    DWORD     PasssthroughMode
    );
/*++

Routine Description:

    This routine is called to set the passsthrough mode

Arguments:

    ModemHandle - Handle returned by OpenModem

Return Value:

    ERROR_SUCCESS or other specific error


--*/




typedef
DWORD
(*PFNUMGENERATEDIGIT)(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    LPSTR     DigitString
    );


DWORD WINAPI
UmGenerateDigit(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    LPSTR     DigitString
    );
/*++

Routine Description:

    This routine is called to generate DTMF tones once a call is connected

Arguments:

    ModemHandle - Handle returned by OpenModem

    CommandsOptionList - List option blocks, only flags used
       Flags   - Optional init parameters. Not currently used and must be zero


    DigitString - Digits to dial


Return Value:

    ERROR_IO_PENDING If pending, will be completed later with a call to the AsyncHandler

    or other specific error



--*/

typedef
DWORD
(*PFNUMSETSPEAKERPHONESTATE)(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    DWORD     CurrentMode,
    DWORD     NewMode,
    DWORD     Volume,
    DWORD     Gain
    );

DWORD WINAPI
UmSetSpeakerPhoneState(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    DWORD     CurrentMode,
    DWORD     NewMode,
    DWORD     Volume,
    DWORD     Gain
    );
/*++

Routine Description:

    This routine is called to set the state of the speaker phone. The new speaker phone state will
    be set based on the new mode. Current mode may be used to determine how to get from current
    state to the new state. If CurrentState and NewState are the same then the volume and gain
    will be adjusted.

Arguments:

    ModemHandle - Handle returned by OpenModem

    CommandsOptionList - List option blocks, only flags used
       Flags   - Optional init parameters. Not currently used and must be zero


    CurrentMode - TAPI constant representing the current speaker phone state

    NewMode     - TAPI constant represent the new desired state

    Volume      - Speaker phone volume

    Gain        - Speaker phone volume

Return Value:

    ERROR_IO_PENDING If pending, will be completed later with a call to the AsyncHandler

    or other specific error



--*/

typedef
DWORD
(*PFNUMISSUECOMMAND)(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    LPSTR     ComandToIssue,
    LPSTR     TerminationSequnace,
    DWORD     MaxResponseWaitTime
    );

DWORD WINAPI
UmIssueCommand(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    LPSTR     ComandToIssue,
    LPSTR     TerminationSequnace,
    DWORD     MaxResponseWaitTime
    );
/*++

Routine Description:

    This routine is called to issue an arbartary commadn to the modem

Arguments:

    ModemHandle - Handle returned by OpenModem

    CommandsOptionList - List option blocks, only flags used
       Flags   - Optional init parameters. Not currently used and must be zero


    CommandToIssue - Null terminated Command to be sent to the modem

    TerminationSequence - Null terminated string to look for to indicate the end of a response

    MaxResponseWaitTime - Time in MS to wait for a response match

Return Value:

    ERROR_IO_PENDING If pending, will be completed later with a call to the AsyncHandler

    or other specific error



--*/



//
//  Start playback
//
#define  WAVE_ACTION_START_PLAYBACK       (0x00)

//
//  Start RECORD
//
#define  WAVE_ACTION_START_RECORD         (0x01)

//
//  Start DUPLEX
//
#define  WAVE_ACTION_START_DUPLEX         (0x02)


//
//  Stop streaming
//
#define  WAVE_ACTION_STOP_STREAMING       (0x04)

//
//  Abort streaming
//
#define  WAVE_ACTION_ABORT_STREAMING      (0x05)


//
//  enable wave actions to handset
//
#define  WAVE_ACTION_OPEN_HANDSET         (0x06)

//
//  disable handset actions
//
#define  WAVE_ACTION_CLOSE_HANDSET        (0x07)




//
//  Set if the audiocommand are for the handset instead of the line
//
#define  WAVE_ACTION_USE_HANDSET           (1 << 31)

typedef
DWORD
(*PFNUMWAVEACTION)(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    DWORD     WaveActionFlags
    );

DWORD WINAPI
UmWaveAction(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    DWORD               WaveAction
    );
/*++

Routine Description:

    Executes a specific wave related action

Arguments:

    ModemHandle - Handle returned by OpenModem

    CommandsOptionList - List option blocks, only flags used

        Flags - see above

    WaveAction  - Specifies actions to take

Return Value:

    ERROR_IO_PENDING If pending, will be completed later with a call to the AsyncHandler

    or other specific error


--*/


// Prefix Text by a date and time stamp.
#define LOG_FLAG_PREFIX_TIMESTAMP (1<<0)

typedef
VOID
(*PFNUMLOGSTRINGA)(
    HANDLE   ModemHandle,
    DWORD    LogFlags,
    LPCSTR   Text
    );


VOID WINAPI
UmLogStringA(
    HANDLE   ModemHandle,
    DWORD    LogFlags,
    LPCSTR   Text
    );

/*++
Routine description:

     This routine is called to add arbitrary ASCII text to the log.
     If logging is not enabled, no action is performed. The format and
     location of the log is mini-driver specific. This function completes
     synchronously and the caller is free to reuse the Text buffer after
     the call returns.

Arguments:

    ModemHandle - Handle returned by OpenModem

    Flags  see above

    Text  ASCII text to be added to the log.

Return Value:

    None

--*/

typedef
DWORD
(*PFNUMGETDIAGNOSTICS)(
    HANDLE    ModemHandle,
    DWORD    DiagnosticType,    // Reserved, must be zero.
    BYTE    *Buffer,
    DWORD    BufferSize,
    LPDWORD  UsedSize
    );

DWORD WINAPI
UmGetDiagnostics(
    HANDLE    ModemHandle,
    DWORD    DiagnosticType,    // Reserved, must be zero.
    BYTE    *Buffer,
    DWORD    BufferSize,
    LPDWORD  UsedSize
    );

/*++
Routine description:


This routine requests raw diagnostic information on the last call from
the modem and if it is successful copies up-to BufferSize bytes of this
information into the supplied buffer, Buffer, and sets *UsedSize to the number
of bytes actually copied.

Note that is *UsedSize == BufferSize on successful return, it is likely but not
certain that there is more information than could be copied over.
The latter information is lost.


The format of this information is the ascii tagged format documented in the
documentation for the AT#UD command. The minidriver presents a single string
containing all the tags, stripping out any AT-specific prefix (such as "DIAG")
that modems may prepend for multi-line reporting of diagnostic information.
The TSP should be able to deal with malformed tags, unknown tags, an possibly
non-printable characters, including possibly embedded null characters in the
buffer. The buffer is not null terminated.


The recommended point to call this function is after completion of
UmHangupModem. This function should not be called when there is a call
in progress. If this function is called when a call is in progress the result
and side-effects are undefined, and could include failure of the call.
The TSP should not expect information about a call to be preserved after
UmInitModem, UmCloseModem and UmOpenModem.


Return Value:

ERROR_SUCCESS if successful.

ERROR_IO_PENDING if pending, will be called by a later call to AsyncHandler.
         The TSP must guarantee that the locations pointed to by UsedSize
         and Buffer are valid until the async completion. The TSP can use
         UmAbortCurrentCommand to abort the the UmGetDiagnostics command,
         but must still guarantee the locations are valid until async
         completion of UmGetDiagnostics.

Other return values represent other failures.

--*/



typedef
VOID
(*PFNUMLOGDIAGNOSTICS)(
    HANDLE   ModemHandle,
    LPVARSTRING  VarString
    );


VOID WINAPI
UmLogDiagnostics(
    HANDLE   ModemHandle,
    LPVARSTRING  VarString
    );

/*++
Routine description:

     This routine is called to write the translated diagnostic info to the
     minidriver log

Arguments:

    ModemHandle - Handle returned by OpenModem

    Flags  see above

    Text  ASCII text to be added to the log.

Return Value:

    None

--*/


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\sample\inf\makefile.inc ===
_LNG=$(LANGUAGE)
_INX=.
STAMP=stampinf -f $@ -d date -v 

$(O)\mdmfake.inf: mdmfake.inx
    copy $(_INX)\$(@B).inx $@
    $(STAMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\inf\usa\inf\makefile.inc ===
# USA INF files.
# Last update 7/28/00 CPICCINI
# Keep everything alphabetized for easy maintenance.

_INX=.
STAMP=stampinf -f $@ -d date -v
_INF=obj\$(TARGET_DIRECTORY)

make_infs:$(_INF)\mdm3com.inf \
          $(_INF)\mdm3cpcm.inf \
          $(_INF)\mdm5674a.inf \
	  $(_INF)\mdmadc.inf \
          $(_INF)\mdmairte.inf \
          $(_INF)\mdmaiwa.inf \
          $(_INF)\mdmaiwa3.inf \
          $(_INF)\mdmaiwa4.inf \
          $(_INF)\mdmaiwa5.inf \
          $(_INF)\mdmaiwat.inf \
          $(_INF)\mdmar1.inf \
          $(_INF)\mdmarch.inf \
          $(_INF)\mdmarn.inf \
	  $(_INF)\mdmati.inf \
          $(_INF)\mdmatm2k.inf \
          $(_INF)\mdmatt.inf \
	  $(_INF)\Mdmaus.inf \
          $(_INF)\mdmboca.inf \
          $(_INF)\mdmbsb.inf \
          $(_INF)\mdmbug3.inf \
          $(_INF)\MDMBW561.INF \
          $(_INF)\mdmc26a.inf \
          $(_INF)\mdmcdp.inf \
          $(_INF)\mdmchipv.inf \
          $(_INF)\mdmcm28.inf \
          $(_INF)\mdmcodex.inf \
          $(_INF)\mdmcom1.inf \
          $(_INF)\mdmcommu.inf \
          $(_INF)\mdmcomp.inf \
          $(_INF)\mdmcpq.inf \
          $(_INF)\mdmcpq2.inf \
          $(_INF)\mdmcpv.inf \
          $(_INF)\mdmcrtix.inf \
          $(_INF)\mdmdcm5.inf \
          $(_INF)\mdmdcm6.inf \
          $(_INF)\mdmdf56F.inf \
          $(_INF)\mdmdgitn.inf \
          $(_INF)\mdmdp2.inf \
          $(_INF)\mdmdsi.inf \
          $(_INF)\mdmdyna.inf \
          $(_INF)\mdmeiger.inf \
          $(_INF)\mdmelsa.inf \
          $(_INF)\mdmeric.inf \
          $(_INF)\mdmeric2.inf \
          $(_INF)\mdmetech.inf \
          $(_INF)\mdmexp.inf \
          $(_INF)\mdmfj2.inf \
          $(_INF)\mdmgal.inf \
          $(_INF)\mdmgatew.inf \
          $(_INF)\mdmgcs.inf \
          $(_INF)\mdmgen.inf \
          $(_INF)\mdmgl001.inf \
          $(_INF)\mdmgl002.inf \
          $(_INF)\mdmgl003.inf \
          $(_INF)\mdmgl004.inf \
          $(_INF)\mdmgl005.inf \
          $(_INF)\mdmgl006.inf \
          $(_INF)\mdmgl007.inf \
          $(_INF)\mdmgl008.inf \
          $(_INF)\mdmgl009.inf \
          $(_INF)\mdmgl010.inf \
          $(_INF)\mdmgsm.inf \
          $(_INF)\mdmhaeu.inf \
          $(_INF)\mdmhandy.inf \
          $(_INF)\mdmhay2.inf \
          $(_INF)\mdmhayes.inf \
          $(_INF)\mdmico.inf \
          $(_INF)\mdminfot.inf \
          $(_INF)\mdmintel.inf \
          $(_INF)\mdmiodat.inf \
          $(_INF)\mdmisdn.inf \
          $(_INF)\mdmjf56e.inf \
          $(_INF)\mdmke.inf \
          $(_INF)\mdmkortx.inf \
          $(_INF)\mdmlasat.inf \
          $(_INF)\mdmlasno.inf \
          $(_INF)\mdmlucnt.inf \
          $(_INF)\mdmmc288.inf \
          $(_INF)\Mdmmcd.inf \
	  $(_INF)\mdmmcom.inf \
          $(_INF)\Mdmmct.inf \
          $(_INF)\mdmmega.inf \
          $(_INF)\mdmmetri.inf \
          $(_INF)\mdmmhrtz.inf \
          $(_INF)\mdmmhza.inf \
          $(_INF)\mdmmhzel.inf \
          $(_INF)\mdmmhzk1.inf \
          $(_INF)\mdmminij.inf \
          $(_INF)\mdmmod.inf \
          $(_INF)\mdmmoto.inf \
          $(_INF)\mdmmoto1.inf \
          $(_INF)\mdmmotou.inf \
          $(_INF)\mdmmts.inf \
          $(_INF)\mdmneuhs.inf \
          $(_INF)\mdmnis1u.inf \
          $(_INF)\mdmnis2u.inf \
          $(_INF)\mdmnis3t.inf \
          $(_INF)\mdmnis5t.inf \
          $(_INF)\mdmnokia.inf \
          $(_INF)\mdmnova.inf \
          $(_INF)\mdmntt1.INF \
          $(_INF)\MDMNTTD2.INF \
          $(_INF)\MDMNTTD6.INF \
          $(_INF)\mdmnttme.inf \
          $(_INF)\mdmnttp.inf \
          $(_INF)\mdmnttp2.inf \
          $(_INF)\mdmnttte.inf \
          $(_INF)\mdmolic.inf \
          $(_INF)\mdmomrn3.inf \
          $(_INF)\mdmoptn.inf \
          $(_INF)\mdmosi.inf \
          $(_INF)\mdmpace.inf \
          $(_INF)\mdmpbit.inf \
          $(_INF)\mdmpenr.inf \
          $(_INF)\MDMPIN.INF \
          $(_INF)\mdmpn1.inf \
          $(_INF)\mdmpp.inf \
          $(_INF)\mdmpsion.inf \
          $(_INF)\mdmracal.inf \
          $(_INF)\mdmrock.inf \
          $(_INF)\mdmrock3.inf \
          $(_INF)\mdmrock4.inf \
          $(_INF)\mdmrock5.inf \
          $(_INF)\mdmsetup.inf \
          $(_INF)\mdmsier.inf \
          $(_INF)\mdmsiil6.inf \
          $(_INF)\mdmsii64.inf \
          $(_INF)\mdmsmart.inf \
          $(_INF)\mdmsonyu.inf \
          $(_INF)\mdmspq28.inf \
          $(_INF)\mdmsun1.inf \
          $(_INF)\mdmsun2.inf \
          $(_INF)\mdmsupr3.inf \
          $(_INF)\mdmsupra.inf \
          $(_INF)\mdmsuprv.inf \
          $(_INF)\mdmtdk.inf \
          $(_INF)\mdmtdkj2.inf \
          $(_INF)\mdmtdkj3.inf \
          $(_INF)\mdmtdkj4.inf \
          $(_INF)\mdmtdkj5.inf \
          $(_INF)\mdmtdkj6.inf \
          $(_INF)\mdmtdkj7.inf \
          $(_INF)\mdmtexas.inf \
          $(_INF)\mdmti.inf \
          $(_INF)\mdmtkr.inf \
          $(_INF)\mdmtosh.inf \
          $(_INF)\mdmtron.inf \
          $(_INF)\mdmusrf.inf \
          $(_INF)\mdmusrg.inf \
          $(_INF)\mdmusrk1.inf \
          $(_INF)\mdmusrsp.inf \
          $(_INF)\mdmvdot.inf \
          $(_INF)\mdmvv.inf \
          $(_INF)\mdmwhql0.inf \
          $(_INF)\mdmx5560.inf \
          $(_INF)\mdmzoom.inf \
          $(_INF)\mdmzyp.inf \
          $(_INF)\mdmzyxel.inf \
          $(_INF)\mdmzyxlg.inf \
          $(_INF)\mfsupra.inf \
          $(_INF)\modemcsa.inf

!IFDEF SERVERINF
!IFDEF BINPLACE_CMD
BINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b srvinf)
!ENDIF
!ENDIF

#
# Explicit dependencies. We do it this way instead of trying to use rules
# because !#@&^$#% nmake doesn't allow multiple 'source' extensions
# when defining a rule, and we need to express a dependency between
# .txt OR .inx to the final .inf.
#

#
# 'Standard' (win95-style) infs. The rules are all the same.
#

#INFs

$(_INF)\mdm3com.inf: $(_INX)\mdm3com.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdm5674a.inf: $(_INX)\mdm5674a.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmadc.inf: $(_INX)\mdmadc.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmairte.inf: $(_INX)\mdmairte.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmaiwa.inf: $(_INX)\mdmaiwa.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmaiwa3.inf: $(_INX)\mdmaiwa3.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmaiwa4.inf: $(_INX)\mdmaiwa4.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmaiwa5.inf: $(_INX)\mdmaiwa5.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmaiwat.inf: $(_INX)\mdmaiwat.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmar1.inf: $(_INX)\mdmar1.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmarch.inf: $(_INX)\mdmarch.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmarn.inf: $(_INX)\mdmarn.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmati.inf: $(_INX)\mdmati.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\MDMAtm2k.inf: $(_INX)\MDMAtm2k.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmatt.inf: $(_INX)\mdmatt.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmaus.inf: $(_INX)\mdmaus.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmbug3.inf: $(_INX)\mdmbug3.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmboca.inf: $(_INX)\mdmboca.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmbsb.inf: $(_INX)\mdmbsb.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmbw561.inf: $(_INX)\mdmbw561.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmc26a.inf: $(_INX)\mdmc26a.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmcdp.inf: $(_INX)\mdmcdp.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmchipv.inf: $(_INX)\mdmchipv.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmcm28.inf: $(_INX)\mdmcm28.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmcodex.inf: $(_INX)\mdmcodex.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmcom1.inf: $(_INX)\mdmcom1.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmcommu.inf: $(_INX)\mdmcommu.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmcomp.inf: $(_INX)\mdmcomp.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmcpq.inf: $(_INX)\mdmcpq.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmcpq2.inf: $(_INX)\mdmcpq2.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmcpv.inf: $(_INX)\mdmcpv.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmcrtix.inf: $(_INX)\mdmcrtix.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmdcm5.inf: $(_INX)\mdmdcm5.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmdcm6.inf: $(_INX)\mdmdcm6.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmdf56f.inf: $(_INX)\mdmdf56f.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmdgitn.inf: $(_INX)\mdmdgitn.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmdp2.inf: $(_INX)\mdmdp2.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmdsi.inf: $(_INX)\mdmdsi.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmdyna.inf: $(_INX)\mdmdyna.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmeiger.inf: $(_INX)\mdmeiger.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmelsa.inf: $(_INX)\mdmelsa.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmeric.inf: $(_INX)\mdmeric.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmeric2.inf: $(_INX)\mdmeric2.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmetech.inf: $(_INX)\mdmetech.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmexp.inf: $(_INX)\mdmexp.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmfj2.inf: $(_INX)\mdmfj2.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmgal.inf: $(_INX)\mdmgal.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmgatew.inf: $(_INX)\mdmgatew.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmgcs.inf: $(_INX)\mdmgcs.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmgen.inf: $(_INX)\mdmgen.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmgl001.inf: $(_INX)\mdmgl001.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmgl002.inf: $(_INX)\mdmgl002.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmgl003.inf: $(_INX)\mdmgl003.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmgl004.inf: $(_INX)\mdmgl004.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmgl005.inf: $(_INX)\mdmgl005.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmgl006.inf: $(_INX)\mdmgl006.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmgl007.inf: $(_INX)\mdmgl007.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmgl008.inf: $(_INX)\mdmgl008.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmgl009.inf: $(_INX)\mdmgl009.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmgl010.inf: $(_INX)\mdmgl010.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmgsm.inf: $(_INX)\mdmgsm.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmhaeu.inf: $(_INX)\mdmhaeu.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmhandy.inf: $(_INX)\mdmhandy.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmhay2.inf: $(_INX)\mdmhay2.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmhayes.inf: $(_INX)\mdmhayes.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmico.inf: $(_INX)\mdmico.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdminfot.inf: $(_INX)\mdminfot.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmintel.inf: $(_INX)\mdmintel.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmiodat.inf: $(_INX)\mdmiodat.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmisdn.inf: $(_INX)\mdmisdn.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmjf56e.inf: $(_INX)\mdmjf56e.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmke.inf: $(_INX)\mdmke.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmkortx.inf: $(_INX)\mdmkortx.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmlasat.inf: $(_INX)\mdmlasat.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmlasno.inf: $(_INX)\mdmlasno.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmlucnt.inf: $(_INX)\mdmlucnt.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmmc288.inf: $(_INX)\mdmmc288.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmmcd.inf: $(_INX)\mdmmcd.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmmct.inf: $(_INX)\mdmmct.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmmcom.inf: $(_INX)\mdmmcom.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmmega.inf: $(_INX)\mdmmega.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmmetri.inf: $(_INX)\mdmmetri.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmmhrtz.inf: $(_INX)\mdmmhrtz.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmmhza.inf: $(_INX)\mdmmhza.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmmhzel.inf: $(_INX)\mdmmhzel.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmmhzk1.inf: $(_INX)\mdmmhzk1.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)


$(_INF)\mdmminij.inf: $(_INX)\mdmminij.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmmod.inf: $(_INX)\mdmmod.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmmoto.inf: $(_INX)\mdmmoto.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmmoto1.inf: $(_INX)\mdmmoto1.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmmotou.inf: $(_INX)\mdmmotou.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmmts.inf: $(_INX)\mdmmts.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmneuhs.inf: $(_INX)\mdmneuhs.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmnis1u.inf: $(_INX)\mdmnis1u.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmnis2u.inf: $(_INX)\mdmnis2u.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmnis3t.inf: $(_INX)\mdmnis3t.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmnis5t.inf: $(_INX)\mdmnis5t.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmnokia.inf: $(_INX)\mdmnokia.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmnova.inf: $(_INX)\mdmnova.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmntt1.inf: $(_INX)\mdmntt1.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmnttd2.inf: $(_INX)\mdmnttd2.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmnttd6.inf: $(_INX)\mdmnttd6.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmnttme.inf: $(_INX)\mdmnttme.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmnttp.inf: $(_INX)\mdmnttp.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmnttp2.inf: $(_INX)\mdmnttp2.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmnttte.inf: $(_INX)\mdmnttte.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmolic.inf: $(_INX)\mdmolic.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmomrn3.inf: $(_INX)\mdmomrn3.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmoptn.inf: $(_INX)\mdmoptn.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmosi.inf: $(_INX)\mdmosi.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmpace.inf: $(_INX)\mdmpace.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmpbit.inf: $(_INX)\mdmpbit.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmpenr.inf: $(_INX)\mdmpenr.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmpin.inf: $(_INX)\mdmpin.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmpn1.inf: $(_INX)\mdmpn1.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmpp.inf: $(_INX)\mdmpp.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmpsion.inf: $(_INX)\mdmpsion.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmracal.inf: $(_INX)\mdmracal.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmrock.inf: $(_INX)\mdmrock.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmrock3.inf: $(_INX)\mdmrock3.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmrock4.inf: $(_INX)\mdmrock4.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmrock5.inf: $(_INX)\mdmrock5.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmsetup.inf: $(_INX)\mdmsetup.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmsier.inf: $(_INX)\mdmsier.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmsiil6.inf: $(_INX)\mdmsiil6.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmsii64.inf: $(_INX)\mdmsii64.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmsmart.inf: $(_INX)\mdmsmart.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmsonyu.inf: $(_INX)\mdmsonyu.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmspq28.inf: $(_INX)\mdmspq28.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmsun1.inf: $(_INX)\mdmsun1.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmsun2.inf: $(_INX)\mdmsun2.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmsupr3.inf: $(_INX)\mdmsupr3.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmsupra.inf: $(_INX)\mdmsupra.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmsuprv.inf: $(_INX)\mdmsuprv.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmtdk.inf: $(_INX)\mdmtdk.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmtdkj2.inf: $(_INX)\mdmtdkj2.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmtdkj3.inf: $(_INX)\mdmtdkj3.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmtdkj4.inf: $(_INX)\mdmtdkj4.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmtdkj5.inf: $(_INX)\mdmtdkj5.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmtdkj6.inf: $(_INX)\mdmtdkj6.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmtdkj7.inf: $(_INX)\mdmtdkj7.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmtexas.inf: $(_INX)\mdmtexas.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmti.inf: $(_INX)\mdmti.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmtkr.inf: $(_INX)\mdmtkr.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmtosh.inf: $(_INX)\mdmtosh.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmtron.inf: $(_INX)\mdmtron.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmusrf.inf: $(_INX)\mdmusrf.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmusrg.inf: $(_INX)\mdmusrg.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmusrk1.inf: $(_INX)\mdmusrk1.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmusrsp.inf: $(_INX)\mdmusrsp.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmvdot.inf: $(_INX)\mdmvdot.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmvv.inf: $(_INX)\mdmvv.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmwhql0.inf: $(_INX)\mdmwhql0.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmx5560.inf: $(_INX)\mdmx5560.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmzoom.inf: $(_INX)\mdmzoom.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmzyp.inf: $(_INX)\mdmzyp.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmzyxel.inf: $(_INX)\mdmzyxel.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdmzyxlg.inf: $(_INX)\mdmzyxlg.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mfsupra.inf: $(_INX)\mfsupra.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\modemcsa.inf: $(_INX)\modemcsa.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

#386 only

make_386_infs:  $(_INF)\mdm3cisa.inf \
	  	$(_INF)\mdm3cpcm.inf \

!IFDEF SERVERINF
!IFDEF BINPLACE_CMD
BINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b srvinf)
!ENDIF
!ENDIF

#
# Explicit dependencies. We do it this way instead of trying to use rules
# because !#@&^$#% nmake doesn't allow multiple 'source' extensions
# when defining a rule, and we need to express a dependency between
# .txt OR .inx to the final .inf.
#

#
# 'Standard' (win95-style) infs. The rules are all the same.
#

#INFs

$(_INF)\mdm3cisa.inf: $(_INX)\mdm3cisa.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdm3com.inf: $(_INX)\mdm3com.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mdm3cpcm.inf: $(_INX)\mdm3cpcm.inx
    copy $(_INX)\$(@B).inx $(_INF)\$(@B).inf
    $(STAMP)
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\sample\sys\init.c ===
/*
 * UNIMODEM "Fakemodem" controllerless driver illustrative example
 *
 * (C) 2000 Microsoft Corporation
 * All Rights Reserved
 *
 */

#include "fakemodem.h"

#if DBG
ULONG DebugFlags=255;
#endif

UNICODE_STRING   DriverEntryRegPath;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,FakeModemAddDevice)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS status;

    RTL_QUERY_REGISTRY_TABLE paramTable[3];
    ULONG zero = 0;
    ULONG debugLevel = 0;
    ULONG shouldBreak = 0;
    PWCHAR path;

    D_INIT(DbgPrint("FAKEMODEM: DriverEntry\n");)

    // Since the registry path parameter is a "counted" UNICODE string, it
    // might not be zero terminated.  For a very short time allocate memory
    // to hold the registry path zero terminated so that we can use it to
    // delve into the registry.

    path = ALLOCATE_PAGED_POOL(RegistryPath->Length+sizeof(WCHAR));

    if (path != NULL) 
    {
        RtlZeroMemory(&paramTable[0],sizeof(paramTable));
        RtlZeroMemory(path,RegistryPath->Length+sizeof(WCHAR));
        RtlMoveMemory(path,RegistryPath->Buffer,RegistryPath->Length);

        paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[0].Name = L"BreakOnEntry";
        paramTable[0].EntryContext = &shouldBreak;
        paramTable[0].DefaultType = REG_DWORD;
        paramTable[0].DefaultData = &zero;
        paramTable[0].DefaultLength = sizeof(ULONG);

        paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[1].Name = L"DebugFlags";
        paramTable[1].EntryContext = &debugLevel;
        paramTable[1].DefaultType = REG_DWORD;
        paramTable[1].DefaultData = &zero;
        paramTable[1].DefaultLength = sizeof(ULONG);


        // If the Debugflags registry key is not set then
        // provide full debugging information

        if (!NT_SUCCESS(RtlQueryRegistryValues(
                        RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL, 
                        path, &paramTable[0], NULL, NULL))) 
        {
            shouldBreak = 0;
            debugLevel = 255;
        }

        FREE_POOL(path);
    }

#if DBG
    DebugFlags = debugLevel;
#endif

    if (shouldBreak) 
    {
        DbgBreakPoint();
    }

    // Pnp driver entry point

    DriverObject->DriverExtension->AddDevice = FakeModemAddDevice;

    // Initialize the driver object with driver's entry points

    DriverObject->DriverUnload = FakeModemUnload;

    DriverObject->MajorFunction[IRP_MJ_CREATE]            = FakeModemOpen;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]             = FakeModemClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]           = FakeModemCleanup;
    DriverObject->MajorFunction[IRP_MJ_WRITE]             = FakeModemWrite;
    DriverObject->MajorFunction[IRP_MJ_READ]              = FakeModemRead;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]    = FakeModemIoControl;
    DriverObject->MajorFunction[IRP_MJ_PNP]               = FakeModemPnP;
    DriverObject->MajorFunction[IRP_MJ_POWER]             = FakeModemPower;

    D_INIT(DbgPrint("FAKEMODEM: End of DriverEntry\n");)

    return STATUS_SUCCESS;
}

VOID
FakeModemUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    D_INIT(DbgPrint("FAKEMODEM: FakeModemUnload()\n");)

    return;
}

NTSTATUS
FakeModemAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    )
{
    NTSTATUS           status=STATUS_SUCCESS;
    PDEVICE_OBJECT     Fdo;
    PDEVICE_EXTENSION  DeviceExtension;
    UNICODE_STRING     DeviceName;

    D_INIT(DbgPrint("FAKEMODEM: Fakemodem Add Device\n");)

    // Create our functional device object (FDO)
    
    status=IoCreateDevice(DriverObject, sizeof(DEVICE_EXTENSION), NULL, 
            FILE_DEVICE_SERIAL_PORT, FILE_AUTOGENERATED_DEVICE_NAME, 
            FALSE, &Fdo);

    if (status != STATUS_SUCCESS) 
    {
        return status;
    }

    Fdo->Flags |= DO_BUFFERED_IO;
    DeviceExtension = Fdo->DeviceExtension;
    DeviceExtension->DeviceObject = Fdo;

    // Attach our FDO to the PDO supplied
    
    DeviceExtension->LowerDevice = IoAttachDeviceToDeviceStack(Fdo, Pdo);
    if (NULL == DeviceExtension->LowerDevice) 
    {
        // Could not attach

        IoDeleteDevice(Fdo);
        return STATUS_UNSUCCESSFUL;
    }

    //  Try to create a ComX for it. don't care if it fails
    //  modem.sys creates a name for device that unimodem will use
    

    FakeModemHandleSymbolicLink(Pdo, TRUE, 
            &DeviceExtension->InterfaceNameString, Fdo);

    //  Initialise the spinlock
    
    KeInitializeSpinLock(&DeviceExtension->SpinLock);

    //  Initialize the device extension

    DeviceExtension->ReferenceCount=1;
    DeviceExtension->Removing=FALSE;
    DeviceExtension->Started=FALSE;
    DeviceExtension->OpenCount=0;
    KeInitializeEvent(&DeviceExtension->RemoveEvent, NotificationEvent, FALSE);

    //  Initialize the read and write queues

    InitializeListHead(&DeviceExtension->ReadQueue);
    DeviceExtension->CurrentReadIrp=NULL;

    InitializeListHead(&DeviceExtension->WriteQueue);
    DeviceExtension->CurrentWriteIrp=NULL;

    InitializeListHead(&DeviceExtension->MaskQueue);
    DeviceExtension->CurrentMaskIrp=NULL;

    // Clear this flag so the device object can be used

    Fdo->Flags &= ~(DO_DEVICE_INITIALIZING);

    return STATUS_SUCCESS;

}

NTSTATUS 
GetRegistryKeyValue (
    IN HANDLE Handle,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN ULONG DataLength
    )
{
    UNICODE_STRING keyName;
    ULONG length;
    PKEY_VALUE_FULL_INFORMATION fullInfo;

    NTSTATUS ntStatus = STATUS_NO_MEMORY;

    RtlInitUnicodeString (&keyName, KeyNameString);

    length = sizeof(KEY_VALUE_FULL_INFORMATION) + KeyNameStringLength + 
        DataLength;

    fullInfo = ExAllocatePool(PagedPool, length);

    if (fullInfo) 
    {
        ntStatus = ZwQueryValueKey(Handle, &keyName, 
                KeyValueFullInformation, fullInfo, length, &length);

        if (NT_SUCCESS(ntStatus)) 
        {
            // If there is enough room in the data buffer, copy the output

            if (DataLength >= fullInfo->DataLength) 
            {
                RtlCopyMemory(Data, 
                        ((PUCHAR) fullInfo) + fullInfo->DataOffset, 
                        fullInfo->DataLength);
            }
        }

        ExFreePool(fullInfo);
    }

    return ntStatus;
}

NTSTATUS
FakeModemHandleSymbolicLink(
    PDEVICE_OBJECT      Pdo,
    BOOLEAN             Create,
    PUNICODE_STRING     InterfaceName,
    PDEVICE_OBJECT      Fdo
    )

{

    UNICODE_STRING     SymbolicLink;
    ULONG              StringLength;
    NTSTATUS           Status;
    WCHAR              ComPort[80];
    HANDLE             keyHandle;
    RTL_QUERY_REGISTRY_TABLE paramTable[1];

    D_INIT(DbgPrint("FAKEMODEM: HandleSymbolicLink\n");)

    Status = IoOpenDeviceRegistryKey(Pdo, PLUGPLAY_REGKEY_DEVICE, 
            STANDARD_RIGHTS_READ, &keyHandle);

    SymbolicLink.Length=0;
    SymbolicLink.MaximumLength=sizeof(WCHAR)*256;
    SymbolicLink.Buffer=ExAllocatePool(PagedPool,
            SymbolicLink.MaximumLength+sizeof(WCHAR));

    if (SymbolicLink.Buffer == NULL) 
    {
        ZwClose(keyHandle);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(SymbolicLink.Buffer, SymbolicLink.MaximumLength);
    RtlAppendUnicodeToString(&SymbolicLink, L"\\");
    RtlAppendUnicodeToString(&SymbolicLink, OBJECT_DIRECTORY);
    RtlAppendUnicodeToString(&SymbolicLink, L"\\");

    Status=GetRegistryKeyValue(keyHandle, L"PortName", 
            sizeof(L"PortName") / sizeof(WCHAR), ComPort, sizeof(ComPort) / sizeof(WCHAR));

    D_INIT(DbgPrint("FAKEMODEM: PortName %ws\n",ComPort);)

    if (Status != STATUS_SUCCESS) 
    {
        ExFreePool(SymbolicLink.Buffer);
        ZwClose(keyHandle);
        return Status;
    }

    RtlAppendUnicodeToString(&SymbolicLink, ComPort);

    ZwClose(keyHandle);

    if (Create) 
    {
        UNICODE_STRING     PdoName;

        PdoName.Length=0;
        PdoName.MaximumLength=sizeof(WCHAR)*256;
        PdoName.Buffer=ExAllocatePool(PagedPool,
                PdoName.MaximumLength+sizeof(WCHAR));

        if (PdoName.Buffer == NULL) 
        {
            ExFreePool(SymbolicLink.Buffer);

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(PdoName.Buffer,PdoName.MaximumLength);

        Status=IoGetDeviceProperty(Pdo, DevicePropertyPhysicalDeviceObjectName,
                (ULONG)PdoName.MaximumLength, PdoName.Buffer, &StringLength);

        if (!NT_SUCCESS(Status)) 
        {
            D_INIT(DbgPrint("FAKEMODEM: IoGetDeviceProperty() failed %08lx\n",
                        Status);)

            ExFreePool(SymbolicLink.Buffer);

            return Status;
        }

        PdoName.Length+=(USHORT)StringLength-sizeof(UNICODE_NULL);
        D_INIT(DbgPrint("FAKEMODEM: PdoName: %ws\n",PdoName.Buffer);)
        Status=IoCreateSymbolicLink(&SymbolicLink, &PdoName);
        Status=IoRegisterDeviceInterface(Pdo, &GUID_CLASS_MODEM, NULL, 
                InterfaceName);

        if (NT_SUCCESS(Status))
        {
            IoSetDeviceInterfaceState(InterfaceName, TRUE);
        } else
        {
            D_INIT(DbgPrint("FAKEMODEM: IoRegisterDeviceInterface() failed %08lx\n",Status);)
        }


        Status = RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP, L"SERIALCOMM",
                                     PdoName.Buffer, REG_SZ, ComPort,
                                     (wcslen(ComPort) + 1) * sizeof(WCHAR));

        if (!NT_SUCCESS(Status))
        {
            D_INIT(DbgPrint("FAKEMODEM: RtlWriteRegistryValue() failed %08lx\n",Status);)
            ExFreePool(SymbolicLink.Buffer);
            ExFreePool(PdoName.Buffer);

            return Status;
        }
        
        ExFreePool(PdoName.Buffer);

    } else {

        Status=IoDeleteSymbolicLink(&SymbolicLink);

        D_INIT(DbgPrint("FAKEMODEM: Deleted symbolic link\n");)

    }

    ExFreePool(SymbolicLink.Buffer);

    D_INIT(DbgPrint("FAKEMODEM: End of handle symbolic link\n");)
    return Status;

}

NTSTATUS
QueryDeviceCaps(
    PDEVICE_OBJECT    Pdo,
    PDEVICE_CAPABILITIES   Capabilities
    )

{

    PDEVICE_OBJECT       deviceObject=Pdo;
    PIRP                 irp;
    PIO_STACK_LOCATION   NextSp;
    KEVENT               Event;
    NTSTATUS             Status;

    // Get a pointer to the top most device object in the stack of 
    // devices, beginning with the deviceObject.

    while (deviceObject->AttachedDevice) 
    {
        deviceObject = deviceObject->AttachedDevice;
    }

    // Begin by allocating the IRP for this request.  Do not charge 
    // quota to the current process for this IRP.

    irp = IoAllocateIrp(
#if DBG
            (UCHAR)(deviceObject->StackSize+1),
#else
            deviceObject->StackSize,
#endif
            FALSE);

    if (irp == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

#if DBG
    {
        //  Setup a current stack location, so the debug code can see the 
        //  MJ value

        PIO_STACK_LOCATION   irpSp=IoGetNextIrpStackLocation(irp);

        irpSp->MajorFunction=IRP_MJ_PNP;
        IoSetNextIrpStackLocation(irp);
    }
#endif

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;

    RtlZeroMemory(Capabilities,sizeof(DEVICE_CAPABILITIES));

    Capabilities->Size=sizeof(DEVICE_CAPABILITIES);
    Capabilities->Version=1;
    Capabilities->Address=-1;
    Capabilities->UINumber=-1;

    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and parameters are set.

    NextSp = IoGetNextIrpStackLocation(irp);

    NextSp->MajorFunction=IRP_MJ_PNP;
    NextSp->MinorFunction=IRP_MN_QUERY_CAPABILITIES;
    NextSp->Parameters.DeviceCapabilities.Capabilities=Capabilities;

    Status=WaitForLowerDriverToCompleteIrp(deviceObject, irp, FALSE );

    IoFreeIrp(irp);

    return Status;

}

NTSTATUS
ModemSetRegistryKeyValue(
        IN PDEVICE_OBJECT   Pdo,
        IN ULONG            DevInstKeyType,
        IN PWCHAR           KeyNameString,
        IN ULONG            DataType,
        IN PVOID            Data,
        IN ULONG            DataLength)
{

    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    HANDLE Handle;
    UNICODE_STRING keyName;

    PAGED_CODE();

    D_ERROR(DbgPrint("MODEM: Current IRQL %d\n",KeGetCurrentIrql());)

    ntStatus = IoOpenDeviceRegistryKey(Pdo, DevInstKeyType, KEY_ALL_ACCESS, 
            &Handle);

    if (NT_SUCCESS(ntStatus))
    {
        RtlInitUnicodeString(&keyName,KeyNameString);

        ntStatus = ZwSetValueKey(Handle, &keyName, 0, DataType, Data, 
                DataLength);

        if (!NT_SUCCESS(ntStatus))
        {
            D_ERROR(DbgPrint("MODEM: Could not set value, %08lx\n",ntStatus);)
        }

    } else
    {
        ZwClose(Handle);

        D_ERROR(DbgPrint("MODEM: Could not open dev registry key, %08lx\n",
                    ntStatus);)
    }


    return ntStatus;
}

NTSTATUS 
ModemGetRegistryKeyValue (
    IN PDEVICE_OBJECT   Pdo,
    IN ULONG            DevInstKeyType,
    IN PWCHAR KeyNameString,
    IN PVOID Data,
    IN ULONG DataLength
    )
{
    UNICODE_STRING              keyName;
    ULONG                       length;
    PKEY_VALUE_PARTIAL_INFORMATION     PartialInfo;

    NTSTATUS                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    HANDLE                      Handle;

    PAGED_CODE();


    ntStatus = IoOpenDeviceRegistryKey(Pdo, DevInstKeyType, 
            STANDARD_RIGHTS_READ, &Handle);

    if (NT_SUCCESS(ntStatus)) 
    {

        RtlInitUnicodeString (&keyName, KeyNameString);

        length = sizeof(KEY_VALUE_FULL_INFORMATION) + DataLength;

        PartialInfo = ALLOCATE_PAGED_POOL(length);

        if (PartialInfo) 
        {
            ntStatus = ZwQueryValueKey (Handle, &keyName, 
                    KeyValuePartialInformation, PartialInfo, length, &length);

            if (NT_SUCCESS(ntStatus)) 
            {
                //
                // If there is enough room in the data buffer, copy the output
                //

                if (DataLength >= PartialInfo->DataLength) 
                {
                    RtlCopyMemory (Data, PartialInfo->Data, 
                            PartialInfo->DataLength);
                }
            } else 
            {

                D_ERROR(DbgPrint("MODEM: could not query value, %08lx\n",
                            ntStatus);)
            }

            FREE_POOL(PartialInfo);
        }

        ZwClose(Handle);

    } else {

        D_ERROR(DbgPrint("MODEM: could open device reg key, %08lx\n",ntStatus);)
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\sample\sys\fakemodem.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    fakemodem.h

Environment:

    Kernel mode

--*/

#define INITGUID

#include <stddef.h>
#include <stdarg.h>
#include <stdio.h>
#include <ntddk.h>
#include <ntddser.h>
#include <wmistr.h>
#include <wmilib.h>
#include <windef.h>
#include <wmistr.h>
#include <wdmguid.h>
#include <string.h>

#ifdef DEFINE_GUID

DEFINE_GUID(GUID_CLASS_MODEM,0x2c7089aa, 0x2e0e,0x11d1,0xb1, 0x14, 0x00, 0xc0, 0x4f, 0xc2, 0xaa, 0xe4);

#endif //DEFINE_GUID

#define PNP_DEBUG 1

#define ALLOCATE_PAGED_POOL(_y)  ExAllocatePoolWithTag(PagedPool,_y,'wkaF')

#define ALLOCATE_NONPAGED_POOL(_y) ExAllocatePoolWithTag(NonPagedPool,_y,'wkaF')

#define FREE_POOL(_x) {ExFreePool(_x);_x=NULL;};


#define DO_TYPE_PDO   ' ODP'
#define DO_TYPE_FDO   ' ODF'

#define DO_TYPE_DEL_PDO   'ODPx'
#define DO_TYPE_DEL_FDO   'ODFx'

#define DEVICE_OBJECT_NAME_LENGTH 128

extern ULONG  DebugFlags;

#if DBG
#define DEBUG_FLAG_ERROR  0x0001
#define DEBUG_FLAG_INIT   0x0002
#define DEBUG_FLAG_PNP    0x0004
#define DEBUG_FLAG_POWER  0x0008
#define DEBUG_FLAG_WMI    0x0010
#define DEBUG_FLAG_TRACE  0x0020


#define D_INIT(_x)  if (DebugFlags & DEBUG_FLAG_INIT) {_x}
#define D_PNP(_x)   if (DebugFlags & DEBUG_FLAG_PNP) {_x}
#define D_POWER(_x) if (DebugFlags & DEBUG_FLAG_POWER) {_x}
#define D_TRACE(_x) if (DebugFlags & DEBUG_FLAG_TRACE) {_x}
#define D_ERROR(_x) if (DebugFlags & DEBUG_FLAG_ERROR) {_x}
#define D_WMI(_x) if (DebugFlags & DEBUG_FLAG_WMI) {_x}

#else

#define D_INIT(_x)  {}
#define D_PNP(_x)   {}
#define D_POWER(_x) {}
#define D_TRACE(_x) {}
#define D_ERROR(_x) {}
#define D_WMI(_x) {}

#endif


#define OBJECT_DIRECTORY L"DosDevices"

#define READ_BUFFER_SIZE  128

#define COMMAND_MATCH_STATE_IDLE   0
#define COMMAND_MATCH_STATE_GOT_A  1
#define COMMAND_MATCH_STATE_GOT_T  2



typedef struct _DEVICE_EXTENSION 
{

    ULONG            DoType;
    KSPIN_LOCK       SpinLock;
    PDEVICE_OBJECT   DeviceObject;
    LONG             ReferenceCount;
    UNICODE_STRING   InterfaceNameString;
    ULONG            OpenCount;
    BOOLEAN          Removing;
    BOOLEAN          Started;
    KEVENT           RemoveEvent;
    LIST_ENTRY       HoldList;
    LIST_ENTRY       RestartList;
    KEVENT           PdoStartEvent;
    KDPC             ReadDpc;
    PIRP             CurrentReadIrp;
    LIST_ENTRY       ReadQueue;
    PIRP             CurrentWriteIrp;
    LIST_ENTRY       WriteQueue;
    PIRP             CurrentMaskIrp;
    LIST_ENTRY       MaskQueue;
    ULONG            CurrentMask;
    PDEVICE_OBJECT   Pdo;
    PDEVICE_OBJECT   LowerDevice;
    SERIAL_TIMEOUTS  CurrentTimeouts;
    ULONG            ReadBufferBegin;
    ULONG            ReadBufferEnd;
    ULONG            BytesInReadBuffer;
    UCHAR            CommandMatchState;
    BOOLEAN          ConnectCommand;
    BOOLEAN          IgnoreNextChar;
    BOOLEAN          CapsQueried;
    ULONG            ModemStatus;
    BOOLEAN          CurrentlyConnected;
    BOOLEAN          ConnectionStateChanged;
    UCHAR            ReadBuffer[READ_BUFFER_SIZE];
    DEVICE_POWER_STATE  SystemPowerStateMap[PowerSystemMaximum];
    SYSTEM_POWER_STATE SystemWake;
    DEVICE_POWER_STATE DeviceWake;
    BOOLEAN  WakeOnRingEnabled;
    ERESOURCE OpenCloseResource;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


extern UNICODE_STRING   DriverEntryRegPath;

#define RemoveReferenceForDispatch  RemoveReference
#define RemoveReferenceForIrp       RemoveReference

// Function prototypes

NTSTATUS
DriverEntry(
        IN PDRIVER_OBJECT DriverObject,
        IN PUNICODE_STRING RegistryPath
           );

VOID
FakeModemUnload(
        IN PDRIVER_OBJECT DriverObject
               );

NTSTATUS
FakeModemAddDevice(
        IN PDRIVER_OBJECT DriverObject,
        IN PDEVICE_OBJECT Pdo
                  );

NTSTATUS
GetRegistryKeyValue (
        IN HANDLE Handle,
        IN PWCHAR KeyNameString,
        IN ULONG KeyNameStringLength,
        IN PVOID Data,
        IN ULONG DataLength
                    );

NTSTATUS
FakeModemHandleSymbolicLink(
        PDEVICE_OBJECT      Pdo,
        BOOLEAN             Create,
        PUNICODE_STRING     InterfaceName,
        PDEVICE_OBJECT      Fdo
                           );

NTSTATUS
QueryDeviceCaps(
        PDEVICE_OBJECT    Pdo,
        PDEVICE_CAPABILITIES   Capabilities
               );

NTSTATUS
ModemSetRegistryKeyValue(
        IN PDEVICE_OBJECT   Pdo,
        IN ULONG            DevInstKeyType,
        IN PWCHAR           KeyNameString,
        IN ULONG            DataType,
        IN PVOID            Data,
        IN ULONG            DataLength);

NTSTATUS
ModemGetRegistryKeyValue (
        IN PDEVICE_OBJECT   Pdo,
        IN ULONG            DevInstKeyType,
        IN PWCHAR KeyNameString,
        IN PVOID Data,
        IN ULONG DataLength
                         );

NTSTATUS
FakeModemIoControl(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
                  );

NTSTATUS
FakeModemOpen(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
             );

NTSTATUS
FakeModemClose(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
              );

NTSTATUS
FakeModemCleanup(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
                );

void
FakeModemKillPendingIrps(
        PDEVICE_OBJECT DeviceObject
                        );

NTSTATUS
ForwardIrp(
        PDEVICE_OBJECT   NextDevice,
        PIRP   Irp
          );

NTSTATUS
FakeModemAdapterIoCompletion(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PKEVENT pdoIoCompletedEvent
                            );

NTSTATUS
WaitForLowerDriverToCompleteIrp(
        PDEVICE_OBJECT    TargetDeviceObject,
        PIRP              Irp,
        PKEVENT           Event
                               );

NTSTATUS
FakeModemPnP(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
            );

NTSTATUS
FakeModemDealWithResources(
        IN PDEVICE_OBJECT   Fdo,
        IN PIRP             Irp
                          );

VOID
DevicePowerCompleteRoutine(
        PDEVICE_OBJECT    DeviceObject,
        IN UCHAR MinorFunction,
        IN POWER_STATE PowerState,
        IN PVOID Context,
        IN PIO_STATUS_BLOCK IoStatus
                          );

NTSTATUS
FakeModemPower(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
              );

NTSTATUS
FakeModemRead(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
             );

NTSTATUS
FakeModemWrite(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
              );

VOID
WriteIrpWorker(
        IN PDEVICE_OBJECT  DeviceObject
              );

VOID
ProcessWriteBytes(
        PDEVICE_EXTENSION   DeviceExtension,
        PUCHAR              Characters,
        ULONG               Length
                 );

VOID
PutCharInReadBuffer(
        PDEVICE_EXTENSION   DeviceExtension,
        UCHAR               Character
                   );

VOID
ReadIrpWorker(
        PDEVICE_OBJECT  DeviceObject
             );

VOID
TryToSatisfyRead(
        PDEVICE_EXTENSION  DeviceExtension
                );

VOID
WriteCancelRoutine(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
                  );

VOID
ReadCancelRoutine(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
                 );

VOID
ProcessConnectionStateChange(
        IN PDEVICE_OBJECT  DeviceObject
                            );

NTSTATUS
CheckStateAndAddReference(
        PDEVICE_OBJECT   DeviceObject,
        PIRP             Irp
                         );

VOID
RemoveReferenceAndCompleteRequest(
        PDEVICE_OBJECT    DeviceObject,
        PIRP              Irp,
        NTSTATUS          StatusToReturn
                                 );

VOID
RemoveReference(
        PDEVICE_OBJECT    DeviceObject
               );

VOID
FakeModemKillAllReadsOrWrites(
        IN PDEVICE_OBJECT DeviceObject,
        IN PLIST_ENTRY QueueToClean,
        IN PIRP *CurrentOpIrp
                             );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\sample\sys\ioctl.c ===
/*
 * UNIMODEM "Fakemodem" controllerless driver illustrative example
 *
 * (C) 2000 Microsoft Corporation
 * All Rights Reserved
 *
 */

#include "fakemodem.h"

NTSTATUS
FakeModemIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS          status=STATUS_UNSUCCESSFUL;
    KIRQL             OldIrql;
    PIO_STACK_LOCATION  IrpSp;

    Irp->IoStatus.Information = 0;

    //  make sure the device is ready for irp's

    status=CheckStateAndAddReference( DeviceObject, Irp);

    if (STATUS_SUCCESS != status) 
    {
        //  not accepting irp's. The irp has already been complted
        return status;

    }

    IrpSp=IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_SERIAL_GET_WAIT_MASK: {

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < 
                    sizeof(ULONG)) 
            {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            *((PULONG)Irp->AssociatedIrp.SystemBuffer)=
                deviceExtension->CurrentMask;

            Irp->IoStatus.Information=sizeof(ULONG);

            break;
        }

        case IOCTL_SERIAL_SET_WAIT_MASK: {

            PIRP    CurrentWaitIrp=NULL;
            ULONG NewMask;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < 
                    sizeof(ULONG)) {

                status = STATUS_BUFFER_TOO_SMALL;
                break;

            } else {

                KeAcquireSpinLock( &deviceExtension->SpinLock, &OldIrql);

                //  get rid of the current wait

                CurrentWaitIrp=deviceExtension->CurrentMaskIrp;

                deviceExtension->CurrentMaskIrp=NULL;

                Irp->IoStatus.Information=sizeof(ULONG);

                //  save the new mask

                NewMask = *((ULONG *)Irp->AssociatedIrp.SystemBuffer);

                deviceExtension->CurrentMask=NewMask;

                D_TRACE(DbgPrint("FAKEMODEM: set wait mask, %08lx\n",NewMask);)

                KeReleaseSpinLock( &deviceExtension->SpinLock, OldIrql);

                if (CurrentWaitIrp != NULL) {

                    D_TRACE(DbgPrint("FAKEMODEM: set wait mask- complete wait\n");)

                    *((PULONG)CurrentWaitIrp->AssociatedIrp.SystemBuffer)=0;

                    CurrentWaitIrp->IoStatus.Information=sizeof(ULONG);

                    RemoveReferenceAndCompleteRequest(
                        deviceExtension->DeviceObject,
                        CurrentWaitIrp, STATUS_SUCCESS);
                }

            }

            break;
        }

        case IOCTL_SERIAL_WAIT_ON_MASK: {

            PIRP    CurrentWaitIrp=NULL;

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < 
                    sizeof(ULONG)) {

                status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            D_TRACE(DbgPrint("FAKEMODEM: wait on mask\n");)

            KeAcquireSpinLock(&deviceExtension->SpinLock, &OldIrql);

            //
            //  capture the current irp if any
            //
            CurrentWaitIrp=deviceExtension->CurrentMaskIrp;

            deviceExtension->CurrentMaskIrp=NULL;


            if (deviceExtension->CurrentMask == 0) {
                //
                // can only set if mask is not zero
                //
                status=STATUS_UNSUCCESSFUL;

            } else {

                deviceExtension->CurrentMaskIrp=Irp;

                Irp->IoStatus.Status=STATUS_PENDING;
                IoMarkIrpPending(Irp);
#if DBG
                Irp=NULL;
#endif

                status=STATUS_PENDING;
            }

            KeReleaseSpinLock(
                &deviceExtension->SpinLock,
                OldIrql
                );

            if (CurrentWaitIrp != NULL) {

                D_TRACE(DbgPrint("FAKEMODEM: wait on mask- complete wait\n");)

                *((PULONG)CurrentWaitIrp->AssociatedIrp.SystemBuffer)=0;

                CurrentWaitIrp->IoStatus.Information=sizeof(ULONG);

                RemoveReferenceAndCompleteRequest(
                    deviceExtension->DeviceObject,
                    CurrentWaitIrp, STATUS_SUCCESS);
            }


            break;
        }

        case IOCTL_SERIAL_PURGE: {

            ULONG Mask=*((PULONG)Irp->AssociatedIrp.SystemBuffer);

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(ULONG)) {

                status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            if (Mask & SERIAL_PURGE_RXABORT) {

                KeAcquireSpinLock(
                    &deviceExtension->SpinLock,
                    &OldIrql
                    );

                while ( !IsListEmpty(&deviceExtension->ReadQueue)) {

                    PLIST_ENTRY         ListElement;
                    KIRQL               CancelIrql;

                    ListElement=RemoveHeadList(
                        &deviceExtension->ReadQueue
                        );

                    Irp=CONTAINING_RECORD(ListElement,IRP,
                            Tail.Overlay.ListEntry);

                    IoAcquireCancelSpinLock(&CancelIrql);

                    if (Irp->Cancel) {
                        //
                        //  this one has been canceled
                        //
                        Irp->IoStatus.Information=STATUS_CANCELLED;

                        IoReleaseCancelSpinLock(CancelIrql);

                        continue;
                    }

                    IoSetCancelRoutine( Irp, NULL);

                    IoReleaseCancelSpinLock(CancelIrql);

                    KeReleaseSpinLock( &deviceExtension->SpinLock, OldIrql);

                    Irp->IoStatus.Information=0;

                    RemoveReferenceAndCompleteRequest(
                        deviceExtension->DeviceObject, Irp, STATUS_CANCELLED);

                    KeAcquireSpinLock( &deviceExtension->SpinLock, &OldIrql);
                }

                Irp=NULL;

                if (deviceExtension->CurrentReadIrp != NULL) 
                {
                    //
                    // get the current one
                    //
                    Irp=deviceExtension->CurrentReadIrp;

                    deviceExtension->CurrentReadIrp=NULL;

                }

                KeReleaseSpinLock( &deviceExtension->SpinLock, OldIrql);

                if (Irp != NULL) {

                    Irp->IoStatus.Information=0;

                    RemoveReferenceAndCompleteRequest(
                        deviceExtension->DeviceObject, Irp, STATUS_CANCELLED);
                }


            }


            break;
        }


        case IOCTL_SERIAL_GET_MODEMSTATUS: {


            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(ULONG)) {

                status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            Irp->IoStatus.Information=sizeof(ULONG);

            *((PULONG)Irp->AssociatedIrp.SystemBuffer)=
                deviceExtension->ModemStatus;

            break;
        }

        case IOCTL_SERIAL_SET_TIMEOUTS: {

            PSERIAL_TIMEOUTS NewTimeouts =
                ((PSERIAL_TIMEOUTS)(Irp->AssociatedIrp.SystemBuffer));


            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SERIAL_TIMEOUTS)) {

                status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            RtlCopyMemory(
                &deviceExtension->CurrentTimeouts, NewTimeouts,
                sizeof(PSERIAL_TIMEOUTS));

            Irp->IoStatus.Information = sizeof(PSERIAL_TIMEOUTS);

            break;
        }

        case IOCTL_SERIAL_GET_TIMEOUTS: {

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SERIAL_TIMEOUTS)) {

                status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            RtlCopyMemory(
                Irp->AssociatedIrp.SystemBuffer,
                &deviceExtension->CurrentTimeouts, sizeof(PSERIAL_TIMEOUTS));

            Irp->IoStatus.Information = sizeof(PSERIAL_TIMEOUTS);


            break;
        }

        case IOCTL_SERIAL_GET_COMMSTATUS: {

            PSERIAL_STATUS SerialStatus=(PSERIAL_STATUS)Irp->AssociatedIrp.SystemBuffer;

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SERIAL_STATUS)) {

                status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            RtlZeroMemory( SerialStatus, sizeof(SERIAL_STATUS));

            KeAcquireSpinLock( &deviceExtension->SpinLock, &OldIrql);

            SerialStatus->AmountInInQueue=deviceExtension->BytesInReadBuffer;

            KeReleaseSpinLock( &deviceExtension->SpinLock, OldIrql);


            Irp->IoStatus.Information = sizeof(SERIAL_STATUS);

            break;
        }

        case IOCTL_SERIAL_SET_DTR:
        case IOCTL_SERIAL_CLR_DTR: {


            KeAcquireSpinLock( &deviceExtension->SpinLock, &OldIrql);

            if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_DTR) {
                //
                //  raising DTR
                //
                deviceExtension->ModemStatus=SERIAL_DTR_STATE | SERIAL_DSR_STATE;

                D_TRACE(DbgPrint("FAKEMODEM: Set DTR\n");)

            } else {
                //
                //  dropping DTR, drop connection if there is one
                //
                D_TRACE(DbgPrint("FAKEMODEM: Clear DTR\n");)

                if (deviceExtension->CurrentlyConnected == TRUE) {
                    //
                    //  not connected any more
                    //
                    deviceExtension->CurrentlyConnected=FALSE;

                    deviceExtension->ConnectionStateChanged=TRUE;
                }
            }


            KeReleaseSpinLock( &deviceExtension->SpinLock, OldIrql);

            ProcessConnectionStateChange( DeviceObject);


            break;
        }

        default:

            status=STATUS_SUCCESS;

    }

    if (status != STATUS_PENDING) {
        //
        //  complete now if not pending
        //
        RemoveReferenceAndCompleteRequest( DeviceObject, Irp, status);
    }


    RemoveReferenceForDispatch(DeviceObject);

    return status;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\sample\sys\pnp.c ===
/*
 * UNIMODEM "Fakemodem" controllerless driver illustrative example
 *
 * (C) 2000 Microsoft Corporation
 * All Rights Reserved
 *
 */

#include "fakemodem.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,FakeModemPnP)
#pragma alloc_text(PAGE,FakeModemDealWithResources)
#endif


NTSTATUS
ForwardIrp(
    PDEVICE_OBJECT   NextDevice,
    PIRP   Irp
    )

{
    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(NextDevice, Irp);

}


NTSTATUS
FakeModemAdapterIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT pdoIoCompletedEvent
    )
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    KeSetEvent(pdoIoCompletedEvent, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
WaitForLowerDriverToCompleteIrp(
   PDEVICE_OBJECT    TargetDeviceObject,
   PIRP              Irp,
   PKEVENT           Event
   )

{
    NTSTATUS         Status;

    KeResetEvent(Event);

    IoSetCompletionRoutine(Irp, FakeModemAdapterIoCompletion, Event, TRUE, 
            TRUE, TRUE);

    Status = IoCallDriver(TargetDeviceObject, Irp);

    if (Status == STATUS_PENDING) 
    {
         D_ERROR(DbgPrint("MODEM: Waiting for PDO\n");)

         KeWaitForSingleObject(Event, Executive, KernelMode, FALSE, NULL);
    }

    return Irp->IoStatus.Status;

}

NTSTATUS
FakeModemPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    KEVENT pdoStartedEvent;
    NTSTATUS status;
    PDEVICE_RELATIONS deviceRelations = NULL;
    PDEVICE_RELATIONS *DeviceRelations;

    ULONG newRelationsSize, oldRelationsSize = 0;

    switch (irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE:

            D_PNP(DbgPrint("FAKEMODEM: IRP_MN_START_DEVICE\n");)

            //  Send this down to the PDO first so the bus driver can setup
            //  our resources so we can talk to the hardware

            KeInitializeEvent(&deviceExtension->PdoStartEvent, 
                    SynchronizationEvent, FALSE);

            IoCopyCurrentIrpStackLocationToNext(Irp);

            status=WaitForLowerDriverToCompleteIrp(
                    deviceExtension->LowerDevice, Irp, 
                    &deviceExtension->PdoStartEvent);

            if (status == STATUS_SUCCESS) 
            {
                deviceExtension->Started=TRUE;
                //
                //  do something useful with resources
                //
                FakeModemDealWithResources(DeviceObject, Irp);
            }


            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information=0L;

            IoCompleteRequest(Irp, IO_NO_INCREMENT);

            return status;

        case IRP_MN_QUERY_DEVICE_RELATIONS: {

            PDEVICE_RELATIONS    CurrentRelations=
                (PDEVICE_RELATIONS)Irp->IoStatus.Information;

            D_PNP(DbgPrint("FAKEMODEM: IRP_MN_QUERY_DEVICE_RELATIONS type=%d\n",irpSp->Parameters.QueryDeviceRelations.Type);)
            D_PNP(DbgPrint("                                         Information=%08lx\n",Irp->IoStatus.Information);)

            switch (irpSp->Parameters.QueryDeviceRelations.Type ) 
            {
                case TargetDeviceRelation:

                default: {

                    IoCopyCurrentIrpStackLocationToNext(Irp);

                    return IoCallDriver(deviceExtension->LowerDevice, Irp);

                }
            }

        }

        case IRP_MN_QUERY_REMOVE_DEVICE:

            D_PNP(DbgPrint("FAKEMODEM: IRP_MN_QUERY_REMOVE_DEVICE\n");)

            deviceExtension->Removing=TRUE;

            return ForwardIrp(deviceExtension->LowerDevice,Irp);


        case IRP_MN_CANCEL_REMOVE_DEVICE:

            D_PNP(DbgPrint("FAKEMODEM: IRP_MN_CANCEL_REMOVE_DEVICE\n");)

            deviceExtension->Removing=FALSE;

            return ForwardIrp(deviceExtension->LowerDevice,Irp);


        case IRP_MN_SURPRISE_REMOVAL:

            // Fall through

        case IRP_MN_REMOVE_DEVICE: {

            ULONG    NewReferenceCount;
            NTSTATUS StatusToReturn;

            D_PNP(DbgPrint("FAKEMODEM: IRP_MN_REMOVE_DEVICE\n");)

            //  the device is going away, block new requests
            
            deviceExtension->Removing=TRUE;

            // Complete all pending requests

            FakeModemKillPendingIrps(DeviceObject);

            // send it down to the PDO
            
            IoCopyCurrentIrpStackLocationToNext(Irp);

            StatusToReturn=IoCallDriver(deviceExtension->LowerDevice, Irp);

            //  remove the ref for the AddDevice

            NewReferenceCount=InterlockedDecrement
                (&deviceExtension->ReferenceCount);

            if (NewReferenceCount != 0) {
            
                //  Still have outstanding request, wait
           
                D_PNP(DbgPrint("FAKEMODEM: IRP_MN_REMOVE_DEVICE- waiting for refcount to drop, %d\n",NewReferenceCount);)

                KeWaitForSingleObject(&deviceExtension->RemoveEvent, 
                        Executive, KernelMode, FALSE, NULL);

                D_PNP(DbgPrint("FAKEMODEM: IRP_MN_REMOVE_DEVICE- Done waiting\n");)
            }

            ASSERT(deviceExtension->ReferenceCount == 0);

            IoDetachDevice(deviceExtension->LowerDevice);

            IoDeleteDevice(DeviceObject);

            D_PNP(DbgPrint("FAKEMODEM: IRP_MN_REMOVE_DEVICE %08lx\n",StatusToReturn);)

            return StatusToReturn;
        }


        case IRP_MN_QUERY_STOP_DEVICE:

            D_PNP(DbgPrint("FAKEMODEM: IRP_MN_QUERY_STOP_DEVICE\n");)

            if (deviceExtension->OpenCount != 0) {
                
                //  no can do
                
                D_PNP(DbgPrint("FAKEMODEM: IRP_MN_QUERY_STOP_DEVICE -- failing\n");)

                Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;

                IoCompleteRequest( Irp, IO_NO_INCREMENT);

                return STATUS_UNSUCCESSFUL;
            }

            deviceExtension->Started=FALSE;

            return ForwardIrp(deviceExtension->LowerDevice,Irp);


        case IRP_MN_CANCEL_STOP_DEVICE:

            D_PNP(DbgPrint("FAKEMODEM: IRP_MN_CANCEL_STOP_DEVICE\n");)

            deviceExtension->Started=TRUE;

            return ForwardIrp(deviceExtension->LowerDevice,Irp);

        case IRP_MN_STOP_DEVICE:

            D_PNP(DbgPrint("FAKEMODEM: IRP_MN_STOP_DEVICE\n");)

            deviceExtension->Started=FALSE;

            return ForwardIrp(deviceExtension->LowerDevice,Irp);

        case IRP_MN_QUERY_CAPABILITIES: {

            ULONG   i;
            KEVENT  WaitEvent;

            // Send this down to the PDO first

            KeInitializeEvent(&WaitEvent, SynchronizationEvent, FALSE);

            IoCopyCurrentIrpStackLocationToNext(Irp);

            status=WaitForLowerDriverToCompleteIrp
                (deviceExtension->LowerDevice, Irp, &WaitEvent);

            irpSp = IoGetCurrentIrpStackLocation(Irp);

            for (i = PowerSystemUnspecified; i < PowerSystemMaximum;   i++) 
            {
                deviceExtension->SystemPowerStateMap[i]=PowerDeviceD3;
            }

            for (i = PowerSystemWorking; i < PowerSystemHibernate;  i++) {

                D_POWER(DbgPrint("FAKEMODEM: DevicePower for System %d is %d\n",i,irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceState[i]);)
                deviceExtension->SystemPowerStateMap[i]=irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceState[i];
            }

            deviceExtension->SystemPowerStateMap[PowerSystemWorking]=PowerDeviceD0;

            deviceExtension->SystemWake=irpSp->Parameters.DeviceCapabilities.Capabilities->SystemWake;
            deviceExtension->DeviceWake=irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceWake;

            D_POWER(DbgPrint("FAKEMODEM: DeviceWake=%d, SystemWake=%d\n",
                        deviceExtension->DeviceWake,
                        deviceExtension->SystemWake);)

            IoCompleteRequest( Irp, IO_NO_INCREMENT);

            return status;

        }

        default:

            D_PNP(DbgPrint("FAKEMODEM: PnP IRP, MN func=%d\n",irpSp->MinorFunction);)

            return ForwardIrp(deviceExtension->LowerDevice,Irp);



    }

    // If device has started again then we can continue processing

    if (deviceExtension->Started)
    {
        WriteIrpWorker(DeviceObject);
    }


    return STATUS_SUCCESS;
}





NTSTATUS
FakeModemDealWithResources(
    IN PDEVICE_OBJECT   Fdo,
    IN PIRP             Irp
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG count;
    ULONG i;


    PCM_RESOURCE_LIST pResourceList;
    PCM_PARTIAL_RESOURCE_LIST pPartialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartialResourceDesc;
    
    PCM_FULL_RESOURCE_DESCRIPTOR pFullResourceDesc = NULL;
    
    //  Get resource list
    
    pResourceList = irpSp->Parameters.StartDevice.AllocatedResources;

    if (pResourceList != NULL) {

        pFullResourceDesc   = &pResourceList->List[0];

    } else {

        pFullResourceDesc=NULL;

    }

    
    // Ok, if we have a full resource descriptor.  Let's take it apart.
    
    if (pFullResourceDesc) {

        pPartialResourceList    = &pFullResourceDesc->PartialResourceList;
        pPartialResourceDesc    = pPartialResourceList->PartialDescriptors;
        count                   = pPartialResourceList->Count;


        // Pull out the stuff that is in the full descriptor.

        // Now run through the partial resource descriptors looking for the
        // port interrupt, and clock rate.


        for (i = 0;     i < count;     i++, pPartialResourceDesc++) {

            switch (pPartialResourceDesc->Type) {

                case CmResourceTypeMemory: {

                    D_PNP(DbgPrint("FAKEMODEM: Memory resource at %x, length %d, addressSpace=%d\n",
                                    pPartialResourceDesc->u.Memory.Start.LowPart,
                                    pPartialResourceDesc->u.Memory.Length,
                                    pPartialResourceDesc->Flags
                                    );)
                    break;
                }


                case CmResourceTypePort: {

                    D_PNP(DbgPrint("FAKEMODEM: Port resource at %x, length %d, addressSpace=%d\n",
                                    pPartialResourceDesc->u.Port.Start.LowPart,
                                    pPartialResourceDesc->u.Port.Length,
                                    pPartialResourceDesc->Flags
                                    );)
                    break;
                }

                case CmResourceTypeDma: {

                    D_PNP(DbgPrint("FAKEMODEM: DMA channel %d, port %d, addressSpace=%d\n",
                                    pPartialResourceDesc->u.Dma.Channel,
                                    pPartialResourceDesc->u.Dma.Port
                                    );)

                    break;


                    break;
                }


                case CmResourceTypeInterrupt: {

                    D_PNP(DbgPrint("FAKEMODEM: Interrupt resource, level=%d, vector=%d, %s\n",
                                   pPartialResourceDesc->u.Interrupt.Level,
                                   pPartialResourceDesc->u.Interrupt.Vector,
                                   (pPartialResourceDesc->Flags & CM_RESOURCE_INTERRUPT_LATCHED) ? "Latched" : "Level"
                                   );)

                    break;
                }

        
                default: {

                    D_PNP(DbgPrint("FAKEMODEM: Other resources\n");)
                    break;
                }
            }
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\sample\sys\util.c ===
/*
 * UNIMODEM "Fakemodem" controllerless driver illustrative example
 *
 * (C) 2000 Microsoft Corporation
 * All Rights Reserved
 *
 */

#include "fakemodem.h"


NTSTATUS
CheckStateAndAddReference(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    )
{
    PDEVICE_EXTENSION    DeviceExtension=(PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    KIRQL                OldIrql;
    BOOLEAN              DriverReady;

    InterlockedIncrement(&DeviceExtension->ReferenceCount);

    DriverReady=(!DeviceExtension->Removing) && (DeviceExtension->Started);

    if (!DriverReady) {
        //
        //  driver not accepting requests
        //
        RemoveReferenceAndCompleteRequest( DeviceObject, Irp,
            STATUS_UNSUCCESSFUL);

        return STATUS_UNSUCCESSFUL;

    }

    InterlockedIncrement(&DeviceExtension->ReferenceCount);

    return STATUS_SUCCESS;

}


VOID
RemoveReferenceAndCompleteRequest(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp,
    NTSTATUS          StatusToReturn
    )

{

    PDEVICE_EXTENSION    DeviceExtension=(PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    KIRQL                OldIrql;
    LONG                 NewReferenceCount;

    NewReferenceCount=InterlockedDecrement(&DeviceExtension->ReferenceCount);

    if (NewReferenceCount == 0) {
        //
        //  device is being removed, set event
        //
        ASSERT(DeviceExtension->Removing);

        D_PNP(DbgPrint("FAKEMODEM: RemoveReferenceAndCompleteRequest: setting event\n");)

        KeSetEvent( &DeviceExtension->RemoveEvent, 0, FALSE);

    }

    Irp->IoStatus.Status = StatusToReturn;

    IoCompleteRequest( Irp, IO_SERIAL_INCREMENT);

    return;


}



VOID
RemoveReference(
    PDEVICE_OBJECT    DeviceObject
    )

{
    PDEVICE_EXTENSION    DeviceExtension=(PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    LONG                 NewReferenceCount;

    NewReferenceCount=InterlockedDecrement(&DeviceExtension->ReferenceCount);

    D_TRACE(
        if (DeviceExtension->Removing) {DbgPrint("FAKEMODEM: RemoveReference: %d\n",NewReferenceCount);}
        )

    if (NewReferenceCount == 0) {
        //
        //  device is being removed, set event
        //
        ASSERT(DeviceExtension->Removing);

        D_PNP(DbgPrint("FAKEMODEM: RemoveReference: setting event\n");)

        KeSetEvent( &DeviceExtension->RemoveEvent, 0, FALSE);

    }

    return;

}


VOID 
FakeModemKillAllReadsOrWrites(
        IN PDEVICE_OBJECT DeviceObject,
        IN PLIST_ENTRY QueueToClean,
        IN PIRP *CurrentOpIrp
)
{
    KIRQL cancelIrql;
    PDRIVER_CANCEL cancelRoutine;


    IoAcquireCancelSpinLock(&cancelIrql);

    while (!IsListEmpty(QueueToClean)) 
    {

        PIRP currentLastIrp = CONTAINING_RECORD(
                QueueToClean->Blink, IRP, Tail.Overlay.ListEntry);

        RemoveEntryList(QueueToClean->Blink);

        cancelRoutine = currentLastIrp->CancelRoutine;
        currentLastIrp->CancelIrql = cancelIrql;
        currentLastIrp->CancelRoutine = NULL;
        currentLastIrp->Cancel = TRUE;

        cancelRoutine( DeviceObject, currentLastIrp);

        IoAcquireCancelSpinLock(&cancelIrql);


    }


    if (*CurrentOpIrp)
    {
        cancelRoutine = (*CurrentOpIrp)->CancelRoutine;
        (*CurrentOpIrp)->Cancel = TRUE;

        if (cancelRoutine)
        {
            (*CurrentOpIrp)->CancelRoutine = NULL;
            (*CurrentOpIrp)->CancelIrql = cancelIrql;

            cancelRoutine( DeviceObject, *CurrentOpIrp);

        } else
        {
            IoReleaseCancelSpinLock(cancelIrql);
        }
    } else
    {
        IoReleaseCancelSpinLock(cancelIrql);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\sample\sys\readwrit.c ===
/*
 * UNIMODEM "Fakemodem" controllerless driver illustrative example
 *
 * (C) 2000 Microsoft Corporation
 * All Rights Reserved
 *
 * The code in this module simply supports the very basic AT command parser.
 * This code should be completely replaced with the actual code to support
 * your controllerless modem.
 */


#include "fakemodem.h"

NTSTATUS
FakeModemRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS          status=STATUS_UNSUCCESSFUL;
    KIRQL             OldIrql;
    KIRQL             CancelIrql;

    Irp->IoStatus.Information = 0;

    //
    //  make sure the device is ready for irp's
    //
    status=CheckStateAndAddReference( DeviceObject, Irp);

    if (STATUS_SUCCESS != status) {
        //
        //  not accepting irp's. The irp has already been completed
        //
        return status;

    }

    Irp->IoStatus.Status=STATUS_PENDING;
    IoMarkIrpPending(Irp);

    KeAcquireSpinLock(&deviceExtension->SpinLock, &OldIrql);

    //
    //  make irp cancelable
    //
    IoAcquireCancelSpinLock(&CancelIrql);

    IoSetCancelRoutine(Irp, ReadCancelRoutine);

    IoReleaseCancelSpinLock(CancelIrql);

    //
    //  put it on queue
    //
    InsertTailList(&deviceExtension->ReadQueue, &Irp->Tail.Overlay.ListEntry);

    KeReleaseSpinLock(&deviceExtension->SpinLock, OldIrql);


    //
    //  call the real work function to process the irps
    //
    ReadIrpWorker( DeviceObject);

    RemoveReferenceForDispatch(DeviceObject);

    return STATUS_PENDING;

}


NTSTATUS
FakeModemWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS          status=STATUS_UNSUCCESSFUL;
    KIRQL             OldIrql;
    KIRQL             CancelIrql;


    Irp->IoStatus.Information = 0;

    //  make sure the device is ready for irp's

    status=CheckStateAndAddReference( DeviceObject, Irp);

    if (STATUS_SUCCESS != status) {
    
        //  not accepting irp's. The irp has already been complted
   
        return status;

    }

    Irp->IoStatus.Status=STATUS_PENDING;
    IoMarkIrpPending(Irp);

    KeAcquireSpinLock( &deviceExtension->SpinLock, &OldIrql);

    //  make irp cancelable
    IoAcquireCancelSpinLock(&CancelIrql);

    IoSetCancelRoutine(Irp, WriteCancelRoutine);

    IoReleaseCancelSpinLock(CancelIrql);

    //  put it on queue
    InsertTailList( &deviceExtension->WriteQueue, &Irp->Tail.Overlay.ListEntry);

    KeReleaseSpinLock(&deviceExtension->SpinLock, OldIrql);


    //  call the real work function to process the irps
    if (deviceExtension->Started)
    {
        WriteIrpWorker(DeviceObject);
    }

    RemoveReferenceForDispatch(DeviceObject);

    return STATUS_PENDING;


}



VOID
WriteIrpWorker(
    IN PDEVICE_OBJECT  DeviceObject
    )

{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS          status=STATUS_UNSUCCESSFUL;
    KIRQL             OldIrql;


    KeAcquireSpinLock( &deviceExtension->SpinLock, &OldIrql);

    if (deviceExtension->CurrentWriteIrp != NULL) {
        //  already in use
        goto Exit;
    }

    while (!IsListEmpty(&deviceExtension->WriteQueue)) {

        PLIST_ENTRY         ListElement;
        PIRP                Irp;
        PIO_STACK_LOCATION  IrpSp;
        KIRQL               CancelIrql;

        ListElement=RemoveHeadList( &deviceExtension->WriteQueue);

        Irp=CONTAINING_RECORD(ListElement,IRP,Tail.Overlay.ListEntry);

        IoAcquireCancelSpinLock(&CancelIrql);

        if (Irp->Cancel) {
            //  this one has been canceled
            Irp->IoStatus.Information=STATUS_CANCELLED;

            IoReleaseCancelSpinLock(CancelIrql);

            continue;
        }

        IoSetCancelRoutine(
            Irp,
            NULL
            );

        IoReleaseCancelSpinLock(CancelIrql);

        deviceExtension->CurrentWriteIrp=Irp;

        IrpSp=IoGetCurrentIrpStackLocation(Irp);

        ProcessWriteBytes( deviceExtension, Irp->AssociatedIrp.SystemBuffer,
            IrpSp->Parameters.Write.Length);

        KeReleaseSpinLock( &deviceExtension->SpinLock, OldIrql);

        Irp->IoStatus.Information = IrpSp->Parameters.Write.Length;

        RemoveReferenceAndCompleteRequest( DeviceObject, Irp, STATUS_SUCCESS);

        KeAcquireSpinLock( &deviceExtension->SpinLock, &OldIrql);

        deviceExtension->CurrentWriteIrp=NULL;

    }

Exit:

    KeReleaseSpinLock( &deviceExtension->SpinLock, OldIrql);

    TryToSatisfyRead( deviceExtension);

    ReadIrpWorker( DeviceObject);

    ProcessConnectionStateChange( DeviceObject);

    return;
}

VOID
ProcessWriteBytes(
    PDEVICE_EXTENSION   DeviceExtension,
    PUCHAR              Characters,
    ULONG               Length
    )

{

    UCHAR               CurrentCharacter;

    while (Length != 0) {

        CurrentCharacter=*Characters++;

        Length--;

        PutCharInReadBuffer( DeviceExtension, CurrentCharacter);


        switch (DeviceExtension->CommandMatchState) {

            case COMMAND_MATCH_STATE_IDLE:

                if ((CurrentCharacter == 'a') || (CurrentCharacter == 'A')) {
                    //  got an A
                    DeviceExtension->CommandMatchState=COMMAND_MATCH_STATE_GOT_A;

                    DeviceExtension->ConnectCommand=FALSE;

                    DeviceExtension->IgnoreNextChar=FALSE;

                }

            break;

            case COMMAND_MATCH_STATE_GOT_A:

                if ((CurrentCharacter == 't') || (CurrentCharacter == 'T')) {
                    //  got an T
                    DeviceExtension->CommandMatchState=COMMAND_MATCH_STATE_GOT_T;

                } else {

                    if (CurrentCharacter == '\r') {

                        DeviceExtension->CommandMatchState=COMMAND_MATCH_STATE_IDLE;
                    }
                }

            break;

            case COMMAND_MATCH_STATE_GOT_T:

                if (!DeviceExtension->IgnoreNextChar) {
                    //  the last char was not a special char
                    //  check for CONNECT command
                    if ((CurrentCharacter == 'A') || (CurrentCharacter == 'a')) {

                        DeviceExtension->ConnectCommand=TRUE;
                    }

                    if ((CurrentCharacter == 'D') || (CurrentCharacter == 'd')) {

                        DeviceExtension->ConnectCommand=TRUE;
                    }
                }

                DeviceExtension->IgnoreNextChar=FALSE;


                if ((CurrentCharacter == '&')
                    ||
                    (CurrentCharacter == '/')
                    ||
                    (CurrentCharacter == '\\')
                    ||
                    (CurrentCharacter == '+')
                    ||
                    (CurrentCharacter == '%')) {

                    //  these characters are part of are used in init
                    //  strings and may be proceeding an A or D
                    //  which we don't want to misinterpret as a dial or answer
                    DeviceExtension->IgnoreNextChar=TRUE;
                }



                if (CurrentCharacter == '\r') {
                    //
                    //  got a CR, send a response to the command
                    //
                    DeviceExtension->CommandMatchState=COMMAND_MATCH_STATE_IDLE;

                    if (DeviceExtension->ConnectCommand) {
                        //
                        //  place <cr><lf>CONNECT<cr><lf>  in the buffer
                        //
                        PutCharInReadBuffer(DeviceExtension,'\r');
                        PutCharInReadBuffer(DeviceExtension,'\n');

                        PutCharInReadBuffer(DeviceExtension,'C');
                        PutCharInReadBuffer(DeviceExtension,'O');
                        PutCharInReadBuffer(DeviceExtension,'N');
                        PutCharInReadBuffer(DeviceExtension,'N');
                        PutCharInReadBuffer(DeviceExtension,'E');
                        PutCharInReadBuffer(DeviceExtension,'C');
                        PutCharInReadBuffer(DeviceExtension,'T');

                        PutCharInReadBuffer(DeviceExtension,'\r');
                        PutCharInReadBuffer(DeviceExtension,'\n');

                        //
                        //  connected now raise CD
                        //
                        DeviceExtension->CurrentlyConnected=TRUE;

                        DeviceExtension->ConnectionStateChanged=TRUE;

                    } else {
                        
                        //  place <cr><lf>OK<cr><lf>  in the buffer
                       
                        PutCharInReadBuffer(DeviceExtension,'\r');
                        PutCharInReadBuffer(DeviceExtension,'\n');
                        PutCharInReadBuffer(DeviceExtension,'O');
                        PutCharInReadBuffer(DeviceExtension,'K');
                        PutCharInReadBuffer(DeviceExtension,'\r');
                        PutCharInReadBuffer(DeviceExtension,'\n');
                    }
                }


            break;

            default:

            break;

        }
    }

    return;

}


VOID
PutCharInReadBuffer(
    PDEVICE_EXTENSION   DeviceExtension,
    UCHAR               Character
    )

{

    if (DeviceExtension->BytesInReadBuffer < READ_BUFFER_SIZE) {
        
        //  room in buffer
        DeviceExtension->ReadBuffer[DeviceExtension->ReadBufferEnd]=Character;
        DeviceExtension->ReadBufferEnd++;
        DeviceExtension->ReadBufferEnd %= READ_BUFFER_SIZE;
        DeviceExtension->BytesInReadBuffer++;

    }

    return;

}



VOID
ReadIrpWorker(
    PDEVICE_OBJECT  DeviceObject
    )

{


    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS          status=STATUS_UNSUCCESSFUL;
    KIRQL             OldIrql;


    KeAcquireSpinLock( &deviceExtension->SpinLock, &OldIrql);


    while ((deviceExtension->CurrentReadIrp == NULL)
           && !IsListEmpty(&deviceExtension->ReadQueue)) {

        PLIST_ENTRY         ListElement;
        PIRP                Irp;
        PIO_STACK_LOCATION  IrpSp;
        KIRQL               CancelIrql;

        ListElement=RemoveHeadList( &deviceExtension->ReadQueue);

        Irp=CONTAINING_RECORD(ListElement,IRP,Tail.Overlay.ListEntry);

        IoAcquireCancelSpinLock(&CancelIrql);

        if (Irp->Cancel) {
            //  this one has been canceled
            Irp->IoStatus.Information=STATUS_CANCELLED;

            IoReleaseCancelSpinLock(CancelIrql);

            continue;
        }

        IoSetCancelRoutine(Irp, NULL);
        IoReleaseCancelSpinLock(CancelIrql);
        deviceExtension->CurrentReadIrp=Irp;
        KeReleaseSpinLock(&deviceExtension->SpinLock, OldIrql);
        TryToSatisfyRead( deviceExtension);
        KeAcquireSpinLock(&deviceExtension->SpinLock, &OldIrql);
    }

    KeReleaseSpinLock( &deviceExtension->SpinLock, OldIrql);

    return;
}


VOID
TryToSatisfyRead(
    PDEVICE_EXTENSION  DeviceExtension
    )

{
    NTSTATUS          status=STATUS_UNSUCCESSFUL;
    KIRQL             OldIrql;
    PIRP              Irp=NULL;
    PIO_STACK_LOCATION  IrpSp;
    ULONG             BytesToMove;
    ULONG             FirstHalf;
    ULONG             SecondHalf;

    KeAcquireSpinLock(
        &DeviceExtension->SpinLock,
        &OldIrql
        );

    if ((DeviceExtension->CurrentReadIrp != NULL) && (DeviceExtension->BytesInReadBuffer > 0)) {
        //
        //  there is an IRP and there are characters waiting
        //
        Irp=DeviceExtension->CurrentReadIrp;

        IrpSp=IoGetCurrentIrpStackLocation(Irp);

        BytesToMove=IrpSp->Parameters.Read.Length < DeviceExtension->BytesInReadBuffer ?
                    IrpSp->Parameters.Read.Length : DeviceExtension->BytesInReadBuffer;

        if (DeviceExtension->ReadBufferBegin+BytesToMove > READ_BUFFER_SIZE) {
            //
            //  the buffer is wrapped around, have move in two pieces
            //
            FirstHalf=READ_BUFFER_SIZE-DeviceExtension->ReadBufferBegin;

            SecondHalf=BytesToMove-FirstHalf;

            RtlCopyMemory(
                Irp->AssociatedIrp.SystemBuffer,
                &DeviceExtension->ReadBuffer[DeviceExtension->ReadBufferBegin],
                FirstHalf);

            RtlCopyMemory(
                (PUCHAR)Irp->AssociatedIrp.SystemBuffer+FirstHalf,
                &DeviceExtension->ReadBuffer[0], SecondHalf);

        } else {
            //
            //  can do it all at once
            //
            RtlCopyMemory(
                Irp->AssociatedIrp.SystemBuffer,
                &DeviceExtension->ReadBuffer[DeviceExtension->ReadBufferBegin],
                BytesToMove);
        }

        //
        //  fix up queue pointers
        //
        DeviceExtension->BytesInReadBuffer-=BytesToMove;

        DeviceExtension->ReadBufferBegin+= BytesToMove;

        DeviceExtension->ReadBufferBegin %= READ_BUFFER_SIZE;

        Irp->IoStatus.Information=BytesToMove;


    }


    KeReleaseSpinLock( &DeviceExtension->SpinLock, OldIrql);

    if (Irp != NULL) {
        //
        //  if irp isn't null, then we handled one
        //
        RemoveReferenceAndCompleteRequest(
            DeviceExtension->DeviceObject, Irp, STATUS_SUCCESS);

        DeviceExtension->CurrentReadIrp=NULL;

    }



    return;
}



VOID
WriteCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{


    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS          status=STATUS_UNSUCCESSFUL;
    KIRQL             OldIrql;


    //
    //  release the cancel spinlock to avaoid deadlocks with deviceextension spinlock
    //
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    KeAcquireSpinLock( &deviceExtension->SpinLock, &OldIrql);

    if (Irp->IoStatus.Information != STATUS_CANCELLED) {
        //
        //  the irp is still in the queue, remove it
        //
        RemoveEntryList( &Irp->Tail.Overlay.ListEntry);
    }

    KeReleaseSpinLock( &deviceExtension->SpinLock, OldIrql);

    Irp->IoStatus.Information = 0;

    RemoveReferenceAndCompleteRequest( DeviceObject, Irp, STATUS_CANCELLED);

    return;

}



VOID
ReadCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{


    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS          status=STATUS_UNSUCCESSFUL;
    KIRQL             OldIrql;

    //  release the cancel spinlock to avoid deadlocks with deviceextension spinlock
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    KeAcquireSpinLock( &deviceExtension->SpinLock, &OldIrql);

    if (Irp->IoStatus.Information != STATUS_CANCELLED) {
        //  the irp is still in the queue, remove it
        RemoveEntryList( &Irp->Tail.Overlay.ListEntry);
    }

    KeReleaseSpinLock( &deviceExtension->SpinLock, OldIrql);

    Irp->IoStatus.Information = 0;

    RemoveReferenceAndCompleteRequest( DeviceObject, Irp, STATUS_CANCELLED);

    return;

}



VOID
ProcessConnectionStateChange(
    IN PDEVICE_OBJECT  DeviceObject
    )

{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    KIRQL             OldIrql;
    PIRP              CurrentWaitIrp=NULL;


    KeAcquireSpinLock( &deviceExtension->SpinLock, &OldIrql);

    if (deviceExtension->ConnectionStateChanged) {
        //
        //  state changed
        //
        deviceExtension->ConnectionStateChanged=FALSE;

        if (deviceExtension->CurrentlyConnected) {
            //
            //  now it is connected, raise CD
            //
            deviceExtension->ModemStatus |= SERIAL_DCD_STATE;


        } else {
            //
            //  not  connected any more, clear CD
            //
            deviceExtension->ModemStatus &= ~(SERIAL_DCD_STATE);

        }


        if (deviceExtension->CurrentMask & SERIAL_EV_RLSD) {
            //
            //  app want's to know about these changes, tell it
            //
            CurrentWaitIrp=deviceExtension->CurrentMaskIrp;

            deviceExtension->CurrentMaskIrp=NULL;

        }

    }

    KeReleaseSpinLock( &deviceExtension->SpinLock, OldIrql);

    if (CurrentWaitIrp != NULL) {

        D_TRACE(DbgPrint("FAKEMODEM: ProcessConectionState\n");)

        *((PULONG)CurrentWaitIrp->AssociatedIrp.SystemBuffer)=SERIAL_EV_RLSD;

        CurrentWaitIrp->IoStatus.Information=sizeof(ULONG);

        RemoveReferenceAndCompleteRequest(
            deviceExtension->DeviceObject, CurrentWaitIrp, STATUS_SUCCESS);

    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\sample\sys\open.c ===
/*
 * UNIMODEM "Fakemodem" controllerless driver illustrative example
 *
 * (C) 2000 Microsoft Corporation
 * All Rights Reserved
 *
 */

#include "fakemodem.h"

NTSTATUS
FakeModemOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS          status=STATUS_UNSUCCESSFUL;
    KIRQL             OldIrql;

    
    //  make sure the device is ready for irp's
    
    status=CheckStateAndAddReference( DeviceObject, Irp);

    if (STATUS_SUCCESS != status) {
        
        //  not accepting irp's. The irp has already been complted
        
        return status;

    }

    KeAcquireSpinLock(&deviceExtension->SpinLock, &OldIrql);

    deviceExtension->OpenCount++;

    if (deviceExtension->OpenCount != 1) {
        //
        //  serial devices are exclusive
        //
        status=STATUS_ACCESS_DENIED;

        deviceExtension->OpenCount--;

    } else {
        //
        //  ok to open, init some stuff
        //
        deviceExtension->ReadBufferBegin=0;

        deviceExtension->ReadBufferEnd=0;

        deviceExtension->BytesInReadBuffer=0;

        deviceExtension->CommandMatchState=COMMAND_MATCH_STATE_IDLE;

        deviceExtension->ModemStatus=SERIAL_DTR_STATE | SERIAL_DSR_STATE;

        deviceExtension->CurrentlyConnected=FALSE;

        deviceExtension->ConnectionStateChanged=FALSE;

    }

    KeReleaseSpinLock( &deviceExtension->SpinLock, OldIrql);


    Irp->IoStatus.Information = 0;

    RemoveReferenceAndCompleteRequest( DeviceObject, Irp, status);

    RemoveReferenceForDispatch(DeviceObject);

    return status;
}

NTSTATUS
FakeModemClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS          status=STATUS_SUCCESS;
    KIRQL             OldIrql;

    KeAcquireSpinLock(&deviceExtension->SpinLock, &OldIrql);
    deviceExtension->OpenCount--;
    KeReleaseSpinLock(&deviceExtension->SpinLock, OldIrql);

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest( Irp, IO_SERIAL_INCREMENT);

    return status;
}


NTSTATUS
FakeModemCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PDEVICE_EXTENSION extension = DeviceObject->DeviceExtension;

    NTSTATUS          status=STATUS_SUCCESS;

    FakeModemKillPendingIrps(DeviceObject);

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest( Irp, IO_SERIAL_INCREMENT);

    return status;

}


void
FakeModemKillPendingIrps(
    PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_EXTENSION pDeviceExtension = DeviceObject->DeviceExtension;
    KIRQL oldIrql;

    // Kill all reads

    FakeModemKillAllReadsOrWrites(DeviceObject,
            &pDeviceExtension->ReadQueue, &pDeviceExtension->CurrentReadIrp);

    // Kill all writes

    FakeModemKillAllReadsOrWrites(DeviceObject,
            &pDeviceExtension->WriteQueue, &pDeviceExtension->CurrentWriteIrp);

    // Remove any mask operations

    FakeModemKillAllReadsOrWrites(DeviceObject,
            &pDeviceExtension->MaskQueue, &pDeviceExtension->CurrentMaskIrp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\serialui\cstrings.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1996
//
// File: cstrings.h
//
//---------------------------------------------------------------------------

#ifndef _CSTRINGS_H_
#define _CSTRINGS_H_

extern TCHAR const FAR c_szWinHelpFile[];

// Registry key names

extern TCHAR const FAR c_szPortClass[];
extern TCHAR const FAR c_szDeviceDesc[];
extern TCHAR const FAR c_szPortName[];
extern TCHAR const FAR c_szFriendlyName[];
extern TCHAR const FAR c_szDCB[];

#endif  // _CSTRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\sample\sys\power.c ===
/*
 * UNIMODEM "Fakemodem" controllerless driver illustrative example
 *
 * (C) 2000 Microsoft Corporation
 * All Rights Reserved
 *
 */

#include "fakemodem.h"

#ifdef FAKEMODEM_POWER
VOID
DevicePowerCompleteRoutine(
    PDEVICE_OBJECT    DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )

{
    D_POWER(DbgPrint("FAKEMODEM: PoRequestPowerIrp: completion %08lx\n",IoStatus->Status);)

    return;
}
#endif


NTSTATUS
FakeModemPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS    status;

    POWER_STATE  PowerState;

    D_POWER(DbgPrint("FAKEMODEM: Power IRP, MN func=%d\n",irpSp->MinorFunction);)

#ifdef FAKEMODEM_POWER
    switch (irpSp->MinorFunction) {

        case IRP_MN_SET_POWER:

            D_POWER(DbgPrint("FAKEMODEM: IRP_MN_SET_POWER, Type=%s, state=%d\n",irpSp->Parameters.Power.Type == SystemPowerState ? "SystemPowerState" : "DevicePowerState",irpSp->Parameters.Power.State.SystemState);)

            if (irpSp->Parameters.Power.Type == SystemPowerState) {
                //
                //  system power state change
                //
                //
                //  request the change in device power state based on systemstate map
                //
                PowerState.DeviceState=deviceExtension->SystemPowerStateMap[irpSp->Parameters.Power.State.SystemState];


                PoRequestPowerIrp( deviceExtension->Pdo, IRP_MN_SET_POWER,
                    PowerState, DevicePowerCompleteRoutine, Irp, NULL);


            }  else {
                //
                //  changing device state
                //
                PoSetPowerState( deviceExtension->Pdo,
                    irpSp->Parameters.Power.Type,
                    irpSp->Parameters.Power.State);

            }

            break;

        case IRP_MN_QUERY_POWER:

            D_POWER(DbgPrint("FAKEMODEM: IRP_MN_QUERY_POWER, Type=%s, state=%d\n",irpSp->Parameters.Power.Type == SystemPowerState ? "SystemPowerState" : "DevicePowerState",irpSp->Parameters.Power.State.DeviceState);)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            break;

        default:

            D_POWER(DbgPrint("FAKEMODEM: Power IRP, MN func=%d\n",irpSp->MinorFunction);)

            break;

    }
#endif



    PoStartNextPowerIrp(Irp);

    IoSkipCurrentIrpStackLocation(Irp);

    status=PoCallDriver(deviceExtension->LowerDevice, Irp);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\serialui\dlgids.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by TEMPLATE.RC
//
#define IDD_ADV_PORT                    101
#define IDD_PORTSETTINGS                119
#define IDC_DEFAULTS                    1000
#define IDC_RXFIFO_USAGE                1003
#define IDC_TXFIFO_USAGE                1004
#define IDC_LBL_RXFIFO                  1005
#define IDC_LBL_RXFIFO_LO               1006
#define IDC_LBL_RXFIFO_HI               1007
#define IDC_FIFO_USAGE                  1008
#define IDC_LBL_TXFIFO                  1009
#define IDC_LBL_TXFIFO_LO               1010
#define IDC_LBL_TXFIFO_HI               1011
#define IDC_PS_PORT                     1046
#define IDC_PS_LBL_BAUDRATE             1047
#define IDC_PS_BAUDRATE                 1048
#define IDC_PS_LBL_DATABITS             1049
#define IDC_PS_DATABITS                 1050
#define IDC_PS_LBL_PARITY               1051
#define IDC_PS_PARITY                   1052
#define IDC_PS_LBL_STOPBITS             1053
#define IDC_PS_STOPBITS                 1054
#define IDC_PS_LBL_FLOWCTL              1055
#define IDC_PS_FLOWCTL                  1056
#define IDC_PS_PB_RESTORE               1058
#define IDC_PS_ADVANCED                 1059
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1061
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\serialui\cstrings.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1996
//
// File: cstrings.c
//
//  This file contains read-only string constants
//
// History:
//  12-23-93 ScottH     Created 
//  11-06-95 ScottH     Ported to NT
//
//---------------------------------------------------------------------------

#include "proj.h"

#pragma data_seg(DATASEG_READONLY)

TCHAR const FAR c_szWinHelpFile[] = TEXT("devmgr.hlp");

// Registry key names

TCHAR const FAR c_szPortClass[] = TEXT("ports");
TCHAR const FAR c_szDeviceDesc[] = TEXT("DeviceDesc");
TCHAR const FAR c_szPortName[] = TEXT("PortName");
TCHAR const FAR c_szFriendlyName[] = REGSTR_VAL_FRIENDLYNAME;
TCHAR const FAR c_szDCB[] = TEXT("DCB");

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\serialui\dll.h ===
//
// dll.h
//

#ifndef __DLL_H__
#define __DLL_H__

extern HINSTANCE g_hinst;

#ifdef WIN32

// Notes:
//  1. Never "return" from the critical section.
//  2. Never "SendMessage" or "Yield" from the critical section.
//  3. Never call USER API which may yield.
//  4. Always make the critical section as small as possible.
//  5. Critical sections in Win95 block across processes.  In NT
//     they are per-process only, so use mutexes instead.
// 

#define WIN32_CODE(x)       x

void PUBLIC Dll_EnterExclusive(void);
void PUBLIC Dll_LeaveExclusive(void);
extern BOOL g_bExclusive;
extern BOOL g_bAdminUser;
#define	USER_IS_ADMIN()	(g_bAdminUser)

#define ENTER_X()    Dll_EnterExclusive();
#define LEAVE_X()    Dll_LeaveExclusive();
#define ASSERT_X()   ASSERT(g_bExclusive)

#else   // WIN32

#define WIN32_CODE(x)

#define ENTER_X()    
#define LEAVE_X()    
#define ASSERT_X()   

#endif  // WIN32

#endif  //!__DLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\serialui\dll.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1995
//
// File: dll.c
//
//  This file contains the library entry points 
//
// History:
//  12-23-93 ScottH     Created
//   9-22-95 ScottH     Ported to NT
//
//---------------------------------------------------------------------------


#include "proj.h"         
#include <rovdbg.h>         // debug assertion code

// Global data
//
BOOL g_bAdminUser;

#ifdef WIN32

CRITICAL_SECTION g_csDll = { 0 };

#endif  // WIN32


/*----------------------------------------------------------
Purpose: Initialize the DLL
Returns: 
Cond:    --
*/
BOOL PRIVATE Dll_Initialize(void)
    {
    BOOL bRet = TRUE;

    InitCommonControls();

    return bRet;
    }



/*----------------------------------------------------------
Purpose: Attach a process to this DLL
Returns: --
Cond:    --
*/
BOOL PRIVATE Dll_ProcessAttach(HINSTANCE hDll)
    {
    BOOL bSuccess = TRUE;

    __try {

        InitializeCriticalSection(&g_csDll);

    } __except (EXCEPTION_EXECUTE_HANDLER ) {

        return FALSE;
    }

        g_bAdminUser = IsAdminUser();

    if (bSuccess)
        {
		g_hinst = hDll;

        DEBUG_MEMORY_PROCESS_ATTACH("serialui");

#ifdef DEBUG

		// We do this simply to load the debug .ini flags
		//
		RovComm_ProcessIniFile();

		TRACE_MSG(TF_GENERAL, "Process Attach (hDll = %lx)",  hDll);
		DEBUG_BREAK(BF_ONPROCESSATT);

#endif

		bSuccess = Dll_Initialize();

       }
    return bSuccess;
    }


/*----------------------------------------------------------
Purpose: Detach a process from the DLL
Returns: --
Cond:    --
*/
BOOL PRIVATE Dll_ProcessDetach(HINSTANCE hDll)
    {
    BOOL bSuccess = TRUE;

	ASSERT(hDll == g_hinst);

	DEBUG_CODE( TRACE_MSG(TF_GENERAL, "Process Detach (hDll = %lx)",
		 hDll); )

	DEBUG_CODE( DEBUG_BREAK(BF_ONPROCESSDET); )


        DEBUG_MEMORY_PROCESS_DETACH();

        DeleteCriticalSection(&g_csDll);


    return bSuccess;
    }



HINSTANCE g_hinst = 0;


// **************************************************************************
// WIN32 specific code
// **************************************************************************

#ifdef WIN32

#ifdef DEBUG
BOOL g_bExclusive=FALSE;
#endif


/*----------------------------------------------------------
Purpose: Enter an exclusive section
Returns: --
Cond:    --
*/
void PUBLIC Dll_EnterExclusive(void)
    {
    EnterCriticalSection(&g_csDll);

#ifdef DEBUG
    g_bExclusive = TRUE;
#endif
    }


/*----------------------------------------------------------
Purpose: Leave an exclusive section
Returns: --
Cond:    --
*/
void PUBLIC Dll_LeaveExclusive(void)
    {
#ifdef DEBUG
    g_bExclusive = FALSE;
#endif

    LeaveCriticalSection(&g_csDll);
    }


/*----------------------------------------------------------
Purpose: Win32 Libmain
Returns: --
Cond:    --
*/
BOOL APIENTRY LibMain(
    HANDLE hDll, 
    DWORD dwReason,  
    LPVOID lpReserved)
    {
    switch(dwReason)
        {
    case DLL_PROCESS_ATTACH:
        Dll_ProcessAttach(hDll);
        break;

    case DLL_PROCESS_DETACH:
        Dll_ProcessDetach(hDll);
        break;

    case DLL_THREAD_ATTACH:

#ifdef DEBUG

        DEBUG_BREAK(BF_ONTHREADATT);

#endif

        break;

    case DLL_THREAD_DETACH:

#ifdef DEBUG

        DEBUG_BREAK(BF_ONTHREADDET);

#endif

        break;

    default:
        break;
        } 
    
    return TRUE;
    } 


#else   // WIN32



#endif  // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\serialui\port.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1996
//
// File: port.c
//
// This files contains the dialog code for the Port Settings property page.
//
// History:
//   2-09-94 ScottH     Created
//  11-06-95 ScottH     Ported to NT
//
//---------------------------------------------------------------------------


#include "proj.h"           

// This is the structure that is used to fill the 
// max speed listbox
typedef struct _Bauds
    {
    DWORD   dwDTERate;
    int     ids;
    } Bauds;

static Bauds g_rgbauds[] = {
        { 110L,         IDS_BAUD_110     },
        { 300L,         IDS_BAUD_300     },
        { 1200L,        IDS_BAUD_1200    },
        { 2400L,        IDS_BAUD_2400    },
        { 4800L,        IDS_BAUD_4800    },
        { 9600L,        IDS_BAUD_9600    },
        { 19200,        IDS_BAUD_19200   },
        { 38400,        IDS_BAUD_38400   },
        { 57600,        IDS_BAUD_57600   },
        { 115200,       IDS_BAUD_115200  },
        { 230400,       IDS_BAUD_230400  },
        { 460800,       IDS_BAUD_460800  },
        { 921600,       IDS_BAUD_921600  },
        };

// Command IDs for the parity listbox
#define CMD_PARITY_EVEN         1
#define CMD_PARITY_ODD          2
#define CMD_PARITY_NONE         3
#define CMD_PARITY_MARK         4
#define CMD_PARITY_SPACE        5

// Command IDs for the flow control listbox
#define CMD_FLOWCTL_XONXOFF      1
#define CMD_FLOWCTL_HARDWARE     2
#define CMD_FLOWCTL_NONE         3

// This table is the generic port settings table
// that is used to fill the various listboxes
typedef struct _PortValues
    {
    union {
        BYTE bytesize;
        BYTE cmd;
        BYTE stopbits;
        };
    int ids;
    } PortValues, FAR * LPPORTVALUES;


#pragma data_seg(DATASEG_READONLY)

// This is the structure that is used to fill the data bits listbox
static PortValues s_rgbytesize[] = {
        { 5,  IDS_BYTESIZE_5  },
        { 6,  IDS_BYTESIZE_6  },
        { 7,  IDS_BYTESIZE_7  },
        { 8,  IDS_BYTESIZE_8  },
        };

// This is the structure that is used to fill the parity listbox
static PortValues s_rgparity[] = {
        { CMD_PARITY_EVEN,  IDS_PARITY_EVEN  },
        { CMD_PARITY_ODD,   IDS_PARITY_ODD   },
        { CMD_PARITY_NONE,  IDS_PARITY_NONE  },
        { CMD_PARITY_MARK,  IDS_PARITY_MARK  },
        { CMD_PARITY_SPACE, IDS_PARITY_SPACE },
        };

// This is the structure that is used to fill the stopbits listbox
static PortValues s_rgstopbits[] = {
        { ONESTOPBIT,   IDS_STOPBITS_1   },
        { ONE5STOPBITS, IDS_STOPBITS_1_5 },
        { TWOSTOPBITS,  IDS_STOPBITS_2   },
        };

// This is the structure that is used to fill the flow control listbox
static PortValues s_rgflowctl[] = {
        { CMD_FLOWCTL_XONXOFF,  IDS_FLOWCTL_XONXOFF  },
        { CMD_FLOWCTL_HARDWARE, IDS_FLOWCTL_HARDWARE },
        { CMD_FLOWCTL_NONE,     IDS_FLOWCTL_NONE     },
        };

#pragma data_seg()


typedef struct tagPORT
    {
    HWND hdlg;              // dialog handle
    HWND hwndBaudRate;
    HWND hwndDataBits;
    HWND hwndParity;
    HWND hwndStopBits;
    HWND hwndFlowCtl;

    LPPORTINFO pportinfo;   // pointer to shared working buffer
    
    } PORT, FAR * PPORT;

    
// This structure contains the default settings for the dialog
static struct _DefPortSettings
    {
    int  iSelBaud;
    int  iSelDataBits;
    int  iSelParity;
    int  iSelStopBits;
    int  iSelFlowCtl;
    } s_defportsettings;

// These are default settings
#define DEFAULT_BAUDRATE            9600L
#define DEFAULT_BYTESIZE            8
#define DEFAULT_PARITY              CMD_PARITY_NONE
#define DEFAULT_STOPBITS            ONESTOPBIT
#define DEFAULT_FLOWCTL             CMD_FLOWCTL_NONE


#define Port_GetPtr(hwnd)           (PPORT)GetWindowLongPtr(hwnd, DWLP_USER)
#define Port_SetPtr(hwnd, lp)       (PPORT)SetWindowLongPtr(hwnd, DWLP_USER, (ULONG_PTR)(lp))

UINT WINAPI FeFiFoFum(HWND hwndOwner, LPCTSTR pszPortName);


/*----------------------------------------------------------
Purpose: Fills the baud rate combobox with the possible baud
         rates that Windows supports.
Returns: --
Cond:    --
*/
void PRIVATE Port_FillBaud(
    PPORT this)
    {
    HWND hwndCB = this->hwndBaudRate;
    WIN32DCB FAR * pdcb = &this->pportinfo->dcb;
    int i;
    int n;
    int iMatch = -1;
    int iDef = -1;
    int iSel;
    TCHAR sz[MAXMEDLEN];

    // Fill the listbox
    for (i = 0; i < ARRAYSIZE(g_rgbauds); i++)
        {
        n = ComboBox_AddString(hwndCB, SzFromIDS(g_hinst, g_rgbauds[i].ids, sz, SIZECHARS(sz)));
        ComboBox_SetItemData(hwndCB, n, g_rgbauds[i].dwDTERate);

        // Keep our eyes peeled for important values
        if (DEFAULT_BAUDRATE == g_rgbauds[i].dwDTERate)
            {
            iDef = n;
            }
        if (pdcb->BaudRate == g_rgbauds[i].dwDTERate)
            {
            iMatch = n;
            }
        }

    ASSERT(-1 != iDef);
    s_defportsettings.iSelBaud = iDef;

    // Does the DCB baudrate exist in our list of baud rates?
    if (-1 == iMatch)
        {
        // No; choose the default
        iSel = iDef;
        }
    else 
        {
        // Yes; choose the matched value
        ASSERT(-1 != iMatch);
        iSel = iMatch;
        }
    ComboBox_SetCurSel(hwndCB, iSel);
    }


/*----------------------------------------------------------
Purpose: Fills the bytesize combobox with the possible byte sizes.
Returns: --
Cond:    --
*/
void PRIVATE Port_FillDataBits(
    PPORT this)
    {
    HWND hwndCB = this->hwndDataBits;
    WIN32DCB FAR * pdcb = &this->pportinfo->dcb;
    int i;
    int iSel;
    int n;
    int iMatch = -1;
    int iDef = -1;
    TCHAR sz[MAXMEDLEN];

    // Fill the listbox
    for (i = 0; i < ARRAYSIZE(s_rgbytesize); i++)
        {
        n = ComboBox_AddString(hwndCB, SzFromIDS(g_hinst, s_rgbytesize[i].ids, sz, SIZECHARS(sz)));
        ComboBox_SetItemData(hwndCB, n, s_rgbytesize[i].bytesize);

        // Keep our eyes peeled for important values
        if (DEFAULT_BYTESIZE == s_rgbytesize[i].bytesize)
            {
            iDef = n;
            }
        if (pdcb->ByteSize == s_rgbytesize[i].bytesize)
            {
            iMatch = n;
            }
        }

    ASSERT(-1 != iDef);
    s_defportsettings.iSelDataBits = iDef;

    // Does the DCB value exist in our list?
    if (-1 == iMatch)
        {
        // No; choose the default
        iSel = iDef;
        }
    else 
        {
        // Yes; choose the matched value
        ASSERT(-1 != iMatch);
        iSel = iMatch;
        }
    ComboBox_SetCurSel(hwndCB, iSel);
    }


/*----------------------------------------------------------
Purpose: Fills the parity combobox with the possible settings.
Returns: --
Cond:    --
*/
void PRIVATE Port_FillParity(
    PPORT this)
    {
    HWND hwndCB = this->hwndParity;
    WIN32DCB FAR * pdcb = &this->pportinfo->dcb;
    int i;
    int iSel;
    int n;
    int iMatch = -1;
    int iDef = -1;
    TCHAR sz[MAXMEDLEN];

    // Fill the listbox
    for (i = 0; i < ARRAYSIZE(s_rgparity); i++)
        {
        n = ComboBox_AddString(hwndCB, SzFromIDS(g_hinst, s_rgparity[i].ids, sz, SIZECHARS(sz)));
        ComboBox_SetItemData(hwndCB, n, s_rgparity[i].cmd);

        // Keep our eyes peeled for important values
        if (DEFAULT_PARITY == s_rgparity[i].cmd)
            {
            iDef = n;
            }
        switch (s_rgparity[i].cmd)
            {
        case CMD_PARITY_EVEN:
            if (EVENPARITY == pdcb->Parity)
                iMatch = n;
            break;

        case CMD_PARITY_ODD:
            if (ODDPARITY == pdcb->Parity)
                iMatch = n;
            break;

        case CMD_PARITY_NONE:
            if (NOPARITY == pdcb->Parity)
                iMatch = n;
            break;

        case CMD_PARITY_MARK:
            if (MARKPARITY == pdcb->Parity)
                iMatch = n;
            break;

        case CMD_PARITY_SPACE:
            if (SPACEPARITY == pdcb->Parity)
                iMatch = n;
            break;

        default:
            ASSERT(0);
            break;
            }
        }

    ASSERT(-1 != iDef);
    s_defportsettings.iSelParity = iDef;

    // Does the DCB value exist in our list?
    if (-1 == iMatch)
        {
        // No; choose the default
        iSel = iDef;
        }
    else 
        {
        // Yes; choose the matched value
        ASSERT(-1 != iMatch);
        iSel = iMatch;
        }
    ComboBox_SetCurSel(hwndCB, iSel);
    }


/*----------------------------------------------------------
Purpose: Fills the stopbits combobox with the possible settings.
Returns: --
Cond:    --
*/
void PRIVATE Port_FillStopBits(
    PPORT this)
    {
    HWND hwndCB = this->hwndStopBits;
    WIN32DCB FAR * pdcb = &this->pportinfo->dcb;
    int i;
    int iSel;
    int n;
    int iMatch = -1;
    int iDef = -1;
    TCHAR sz[MAXMEDLEN];

    // Fill the listbox
    for (i = 0; i < ARRAYSIZE(s_rgstopbits); i++)
        {
        n = ComboBox_AddString(hwndCB, SzFromIDS(g_hinst, s_rgstopbits[i].ids, sz, SIZECHARS(sz)));
        ComboBox_SetItemData(hwndCB, n, s_rgstopbits[i].stopbits);

        // Keep our eyes peeled for important values
        if (DEFAULT_STOPBITS == s_rgstopbits[i].stopbits)
            {
            iDef = n;
            }
        if (pdcb->StopBits == s_rgstopbits[i].stopbits)
            {
            iMatch = n;
            }
        }

    ASSERT(-1 != iDef);
    s_defportsettings.iSelStopBits = iDef;

    // Does the DCB value exist in our list?
    if (-1 == iMatch)
        {
        // No; choose the default
        iSel = iDef;
        }
    else 
        {
        // Yes; choose the matched value
        ASSERT(-1 != iMatch);
        iSel = iMatch;
        }
    ComboBox_SetCurSel(hwndCB, iSel);
    }


/*----------------------------------------------------------
Purpose: Fills the flow control combobox with the possible settings.
Returns: --
Cond:    --
*/
void PRIVATE Port_FillFlowCtl(
    PPORT this)
    {
    HWND hwndCB = this->hwndFlowCtl;
    WIN32DCB FAR * pdcb = &this->pportinfo->dcb;
    int i;
    int iSel;
    int n;
    int iMatch = -1;
    int iDef = -1;
    TCHAR sz[MAXMEDLEN];

    // Fill the listbox
    for (i = 0; i < ARRAYSIZE(s_rgflowctl); i++)
        {
        n = ComboBox_AddString(hwndCB, SzFromIDS(g_hinst, s_rgflowctl[i].ids, sz, SIZECHARS(sz)));
        ComboBox_SetItemData(hwndCB, n, s_rgflowctl[i].cmd);

        // Keep our eyes peeled for important values
        if (DEFAULT_FLOWCTL == s_rgflowctl[i].cmd)
            {
            iDef = n;
            }
        switch (s_rgflowctl[i].cmd)
            {
        case CMD_FLOWCTL_XONXOFF:
            if (TRUE == pdcb->fOutX && FALSE == pdcb->fOutxCtsFlow)
                iMatch = n;
            break;

        case CMD_FLOWCTL_HARDWARE:
            if (FALSE == pdcb->fOutX && TRUE == pdcb->fOutxCtsFlow)
                iMatch = n;
            break;

        case CMD_FLOWCTL_NONE:
            if (FALSE == pdcb->fOutX && FALSE == pdcb->fOutxCtsFlow)
                iMatch = n;
            break;

        default:
            ASSERT(0);
            break;
            }
        }

    ASSERT(-1 != iDef);
    s_defportsettings.iSelFlowCtl = iDef;

    // Does the DCB value exist in our list?
    if (-1 == iMatch)
        {
        // No; choose the default
        iSel = iDef;
        }
    else 
        {
        // Yes; choose the matched value
        ASSERT(-1 != iMatch);
        iSel = iMatch;
        }
    ComboBox_SetCurSel(hwndCB, iSel);
    }


/*----------------------------------------------------------
Purpose: WM_INITDIALOG Handler
Returns: FALSE when we assign the control focus
Cond:    --
*/
BOOL PRIVATE Port_OnInitDialog(
    PPORT this,
    HWND hwndFocus,
    LPARAM lParam)              // expected to be PROPSHEETINFO 
    {
    LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
    HWND hwnd = this->hdlg;

    ASSERT((LPTSTR)lppsp->lParam);

    this->pportinfo = (LPPORTINFO)lppsp->lParam;

    // Save away the window handles
    this->hwndBaudRate = GetDlgItem(hwnd, IDC_PS_BAUDRATE);
    this->hwndDataBits = GetDlgItem(hwnd, IDC_PS_DATABITS);
    this->hwndParity = GetDlgItem(hwnd, IDC_PS_PARITY);
    this->hwndStopBits = GetDlgItem(hwnd, IDC_PS_STOPBITS);
    this->hwndFlowCtl = GetDlgItem(hwnd, IDC_PS_FLOWCTL);

    Port_FillBaud(this);
    Port_FillDataBits(this);
    Port_FillParity(this);
    Port_FillStopBits(this);
    Port_FillFlowCtl(this);

#if !defined(SUPPORT_FIFO)

    // Hide and disable the Advanced button
    ShowWindow(GetDlgItem(hwnd, IDC_PS_ADVANCED), FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_PS_ADVANCED), FALSE);

#endif

    return TRUE;   // allow USER to set the initial focus
    }

/*----------------------------------------------------------
Purpose: WM_COMMAND Handler
Returns: --
Cond:    --
*/
void PRIVATE Port_OnCommand(
    PPORT this,
    int id,
    HWND hwndCtl,
    UINT uNotifyCode)
    {
    HWND hwnd = this->hdlg;
    
    switch (id)
        {
    case IDC_PS_PB_RESTORE:
        // Set the values to the default settings
        ComboBox_SetCurSel(this->hwndBaudRate, s_defportsettings.iSelBaud);
        ComboBox_SetCurSel(this->hwndDataBits, s_defportsettings.iSelDataBits);
        ComboBox_SetCurSel(this->hwndParity, s_defportsettings.iSelParity);
        ComboBox_SetCurSel(this->hwndStopBits, s_defportsettings.iSelStopBits);
        ComboBox_SetCurSel(this->hwndFlowCtl, s_defportsettings.iSelFlowCtl);
        break;

#ifdef SUPPORT_FIFO

    case IDC_PS_ADVANCED:
        FeFiFoFum(this->hdlg, this->pportinfo->szFriendlyName);
        break;

#endif

    default:
        switch (uNotifyCode) {
        case CBN_SELCHANGE:
           PropSheet_Changed(GetParent(hwnd), hwnd);
           break;
        }
        break;
        }
    }


/*----------------------------------------------------------
Purpose: PSN_APPLY handler
Returns: --
Cond:    --
*/
void PRIVATE Port_OnApply(
    PPORT this)
    {
    int iSel;
    BYTE cmd;
    WIN32DCB FAR * pdcb = &this->pportinfo->dcb;

    // Determine new speed settings
    iSel = ComboBox_GetCurSel(this->hwndBaudRate);
    pdcb->BaudRate = (DWORD)ComboBox_GetItemData(this->hwndBaudRate, iSel);


    // Determine new byte size
    iSel = ComboBox_GetCurSel(this->hwndDataBits);
    pdcb->ByteSize = (BYTE)ComboBox_GetItemData(this->hwndDataBits, iSel);


    // Determine new parity settings
    iSel = ComboBox_GetCurSel(this->hwndParity);
    cmd = (BYTE)ComboBox_GetItemData(this->hwndParity, iSel);
    switch (cmd)
        {
    case CMD_PARITY_EVEN:
        pdcb->fParity = TRUE;
        pdcb->Parity = EVENPARITY;
        break;

    case CMD_PARITY_ODD:
        pdcb->fParity = TRUE;
        pdcb->Parity = ODDPARITY;
        break;

    case CMD_PARITY_NONE:
        pdcb->fParity = FALSE;
        pdcb->Parity = NOPARITY;
        break;

    case CMD_PARITY_MARK:
        pdcb->fParity = TRUE;
        pdcb->Parity = MARKPARITY;
        break;

    case CMD_PARITY_SPACE:
        pdcb->fParity = TRUE;
        pdcb->Parity = SPACEPARITY;
        break;

    default:
        ASSERT(0);
        break;
        }

    // Determine new stopbits setting
    iSel = ComboBox_GetCurSel(this->hwndStopBits);
    pdcb->StopBits = (BYTE)ComboBox_GetItemData(this->hwndStopBits, iSel);


    // Determine new flow control settings
    iSel = ComboBox_GetCurSel(this->hwndFlowCtl);
    cmd = (BYTE)ComboBox_GetItemData(this->hwndFlowCtl, iSel);
    switch (cmd)
        {
    case CMD_FLOWCTL_XONXOFF:
        pdcb->fOutX = TRUE;
        pdcb->fInX = TRUE;
        pdcb->fOutxCtsFlow = FALSE;
        pdcb->fRtsControl = RTS_CONTROL_DISABLE;
        break;

    case CMD_FLOWCTL_HARDWARE:
        pdcb->fOutX = FALSE;
        pdcb->fInX = FALSE;
        pdcb->fOutxCtsFlow = TRUE;
        pdcb->fRtsControl = RTS_CONTROL_HANDSHAKE;
        break;

    case CMD_FLOWCTL_NONE:
        pdcb->fOutX = FALSE;
        pdcb->fInX = FALSE;
        pdcb->fOutxCtsFlow = FALSE;
        pdcb->fRtsControl = RTS_CONTROL_DISABLE;
        break;

    default:
        ASSERT(0);      // should never be here
        break;
        }

    this->pportinfo->idRet = IDOK;
    }


/*----------------------------------------------------------
Purpose: WM_NOTIFY handler
Returns: varies
Cond:    --
*/
LRESULT PRIVATE Port_OnNotify(
    PPORT this,
    int idFrom,
    NMHDR FAR * lpnmhdr)
    {
    LRESULT lRet = 0;
    
    switch (lpnmhdr->code)
        {
    case PSN_SETACTIVE:
        break;

    case PSN_KILLACTIVE:
        // N.b. This message is not sent if user clicks Cancel!
        // N.b. This message is sent prior to PSN_APPLY
        //
        break;

    case PSN_APPLY:
        Port_OnApply(this);
        break;

    default:
        break;
        }

    return lRet;
    }


/////////////////////////////////////////////////////  EXPORTED FUNCTIONS

static BOOL s_bPortRecurse = FALSE;

LRESULT INLINE Port_DefProc(
    HWND hDlg, 
    UINT msg,
    WPARAM wParam,
    LPARAM lParam) 
    {
    ENTER_X()
        {
        s_bPortRecurse = TRUE;
        }
    LEAVE_X()

    return DefDlgProc(hDlg, msg, wParam, lParam); 
    }

// Context help header file and arrays for devmgr ports tab
// Created 2/21/98 by WGruber NTUA and DoronH NTDEV

//
// "Port Settings" Dialog Box
//

#define IDH_NOHELP  ((DWORD)-1)

#define IDH_DEVMGR_PORTSET_ADVANCED 15840   // "&Advanced" (Button)
#define IDH_DEVMGR_PORTSET_BPS      15841   // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_DATABITS 15842   // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_PARITY   15843   // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_STOPBITS 15844   // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_FLOW     15845   // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_DEFAULTS 15892   // "&Restore Defaults" (Button)


#pragma data_seg(DATASEG_READONLY)
const static DWORD rgHelpIDs[] = {                              // old winhelp IDs
        IDC_STATIC,             IDH_NOHELP, 
        IDC_PS_PORT,            IDH_NOHELP,
        IDC_PS_LBL_BAUDRATE,    IDH_DEVMGR_PORTSET_BPS,         // IDH_PORT_BAUD,
        IDC_PS_BAUDRATE,        IDH_DEVMGR_PORTSET_BPS,         // IDH_PORT_BAUD,
        IDC_PS_LBL_DATABITS,    IDH_DEVMGR_PORTSET_DATABITS,    // IDH_PORT_DATA,
        IDC_PS_DATABITS,        IDH_DEVMGR_PORTSET_DATABITS,    // IDH_PORT_DATA,
        IDC_PS_LBL_PARITY,      IDH_DEVMGR_PORTSET_PARITY,      // IDH_PORT_PARITY,
        IDC_PS_PARITY,          IDH_DEVMGR_PORTSET_PARITY,      // IDH_PORT_PARITY,
        IDC_PS_LBL_STOPBITS,    IDH_DEVMGR_PORTSET_STOPBITS,    // IDH_PORT_STOPBITS,
        IDC_PS_STOPBITS,        IDH_DEVMGR_PORTSET_STOPBITS,    // IDH_PORT_STOPBITS,
        IDC_PS_LBL_FLOWCTL,     IDH_DEVMGR_PORTSET_FLOW,        // IDH_PORT_FLOW,
        IDC_PS_FLOWCTL,         IDH_DEVMGR_PORTSET_FLOW,        // IDH_PORT_FLOW,
        IDC_PS_PB_RESTORE,      IDH_DEVMGR_PORTSET_DEFAULTS,    // IDH_PORT_RESTORE,
        IDC_PS_ADVANCED,        IDH_DEVMGR_PORTSET_ADVANCED,
        0, 0 };
#pragma data_seg()

/*----------------------------------------------------------
Purpose: Real dialog proc
Returns: varies
Cond:    --
*/
LRESULT Port_DlgProc(
    PPORT this,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
    {

    switch (message)
        {
        HANDLE_MSG(this, WM_INITDIALOG, Port_OnInitDialog);
        HANDLE_MSG(this, WM_COMMAND, Port_OnCommand);
        HANDLE_MSG(this, WM_NOTIFY, Port_OnNotify);

        case WM_HELP:
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, c_szWinHelpFile, HELP_WM_HELP, (ULONG_PTR)(LPVOID)rgHelpIDs);
            return 0;
    
        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, c_szWinHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPVOID)rgHelpIDs);
            return 0;

        default:
            return Port_DefProc(this->hdlg, message, wParam, lParam);
        }
    }


/*----------------------------------------------------------
Purpose: Dialog Wrapper
Returns: varies
Cond:    --
*/
INT_PTR CALLBACK Port_WrapperProc(
    HWND hDlg,          // std params
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
    {
    PPORT this;

    // Cool windowsx.h dialog technique.  For full explanation, see
    //  WINDOWSX.TXT.  This supports multiple-instancing of dialogs.
    //
    ENTER_X()
        {
        if (s_bPortRecurse)
            {
            s_bPortRecurse = FALSE;
            LEAVE_X()
            return FALSE;
            }
        }
    LEAVE_X()

    this = Port_GetPtr(hDlg);
    if (this == NULL)
        {
        if (message == WM_INITDIALOG)
            {
            this = (PPORT)LocalAlloc(LPTR, sizeof(PORT));
            if (!this)
                {
                MsgBox(g_hinst,
                       hDlg, 
                       MAKEINTRESOURCE(IDS_OOM_PORT), 
                       MAKEINTRESOURCE(IDS_CAP_PORT),
                       NULL,
                       MB_ERROR);
                EndDialog(hDlg, IDCANCEL);
                return (BOOL)Port_DefProc(hDlg, message, wParam, lParam);
                }
            this->hdlg = hDlg;
            Port_SetPtr(hDlg, this);
            }
        else
            {
            return (BOOL)Port_DefProc(hDlg, message, wParam, lParam);
            }
        }

    if (message == WM_DESTROY)
        {
        Port_DlgProc(this, message, wParam, lParam);
        LocalFree((HLOCAL)OFFSETOF(this));
        Port_SetPtr(hDlg, NULL);
        return 0;
        }

    return SetDlgMsgResult(hDlg, message, Port_DlgProc(this, message, wParam, lParam));
    }


#ifdef SUPPORT_FIFO

//
// Advanced Port Settings
//

#pragma data_seg(DATASEG_READONLY)

// Fifo related strings

TCHAR const FAR c_szSettings[] = TEXT("Settings");
TCHAR const FAR c_szComxFifo[] = TEXT("Fifo");
TCHAR const FAR c_szEnh[] = TEXT("386Enh");
TCHAR const FAR c_szSystem[] = TEXT("system.ini");

//
// "Advanced Communications Port Properties" Dialog Box
//
#define IDH_DEVMGR_PORTSET_ADV_USEFIFO  16885   // "&Use FIFO buffers (requires 16550 compatible UART)" (Button)
#define IDH_DEVMGR_PORTSET_ADV_TRANS    16842   // "" (msctls_trackbar32)
//  #define IDH_DEVMGR_PORTSET_ADV_DEVICES  161027  // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_ADV_RECV     16821   // "" (msctls_trackbar32)
// #define IDH_DEVMGR_PORTSET_ADV_NUMBER   16846    // "" (ComboBox)
#define IDH_DEVMGR_PORTSET_ADV_DEFAULTS 16844


const DWORD rgAdvHelpIDs[] =
{
    IDC_STATIC              IDW_NOHELP,

    IDC_FIFO_USAGE,         IDH_DEVMGR_PORTSET_ADV_USEFIFO, // "Use FIFO buffers (requires 16550 compatible UART)" (Button)

    IDC_LBL_RXFIFO,         IDH_NOHELP,                     // "&Receive Buffer:" (Static)
    IDC_RXFIFO_USAGE,       IDH_DEVMGR_PORTSET_ADV_RECV,    // "" (msctls_trackbar32)
    IDC_LBL_RXFIFO_LO,      IDH_NOHELP,                     // "Low (%d)" (Static)
    IDC_LBL_RXFIFO_HI,      IDH_NOHELP,                     // "High (%d)" (Static)

    IDC_LBL_TXFIFO,         IDH_NOHELP,                     // "&Transmit Buffer:" (Static)
    IDC_TXFIFO_USAGE,       IDH_DEVMGR_PORTSET_ADV_TRANS,   // "" (msctls_trackbar32)
    IDC_LBL_TXFIFO_LO,      IDH_NOHELP,                     // "Low (%d)" (Static)
    IDC_LBL_TXFIFO_HI,      IDH_NOHELP,                     // "High (%d)" (Static)

    IDC_DEFAULTS,           IDH_DEVMGR_PORTSET_ADV_DEFAULTS,// "&Restore Defaults" (Button)
    0, 0
};

#pragma data_seg()


/*----------------------------------------------------------
Purpose: Set the dialog controls

Returns: --
Cond:    --
*/
void DisplayAdvSettings(
    HWND hDlg,
    BYTE RxTrigger,
    BYTE TxTrigger,
    BOOL bUseFifo)
    {
    SendDlgItemMessage(hDlg, IDC_RXFIFO_USAGE, TBM_SETRANGE, 0, 0x30000);
    SendDlgItemMessage(hDlg, IDC_TXFIFO_USAGE, TBM_SETRANGE, 0, 0x30000);

    // Use FIFO?
    if ( !bUseFifo ) 
        {
        // No
        EnableWindow(GetDlgItem(hDlg, IDC_LBL_RXFIFO), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LBL_RXFIFO_LO), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LBL_RXFIFO_HI), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RXFIFO_USAGE), FALSE);

        EnableWindow(GetDlgItem(hDlg, IDC_LBL_TXFIFO), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LBL_TXFIFO_LO), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LBL_TXFIFO_HI), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_TXFIFO_USAGE), FALSE);
        CheckDlgButton(hDlg, IDC_FIFO_USAGE, FALSE);
        } 
    else 
        {
        CheckDlgButton(hDlg, IDC_FIFO_USAGE, TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_LBL_RXFIFO), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_LBL_RXFIFO_LO), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_LBL_RXFIFO_HI), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_RXFIFO_USAGE), TRUE);

        EnableWindow(GetDlgItem(hDlg, IDC_LBL_TXFIFO), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_LBL_TXFIFO_LO), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_LBL_TXFIFO_HI), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_TXFIFO_USAGE), TRUE);
        SendDlgItemMessage(hDlg, IDC_RXFIFO_USAGE, TBM_SETPOS,
            TRUE, RxTrigger);
        SendDlgItemMessage(hDlg, IDC_TXFIFO_USAGE, TBM_SETPOS,
            TRUE, TxTrigger/4);
        }
    }


typedef struct tagSETTINGS 
    {
    BYTE fifoon;
    BYTE txfifosize;
    BYTE dsron;
    BYTE rxtriggersize;
    } SETTINGS;

typedef enum 
    {
    ACT_GET,
    ACT_SET
    } ACTION;

BYTE RxTriggerValues[4]={0,0x40,0x80,0xC0};


/*----------------------------------------------------------
Purpose: Gets or sets the advanced settings of the port

Returns: --
Cond:    --
*/
void GetSetAdvSettings(
    LPCTSTR pszPortName,
    BYTE FAR *RxTrigger,
    BYTE FAR *TxTrigger,
    BOOL FAR * pbUseFifo,
    ACTION action)
    {
    LPFINDDEV pfd;
    DWORD cbData;
    SETTINGS settings;
    TCHAR szFifo[256];
    TCHAR OnStr[2] = TEXT("0");

    ASSERT(pszPortName);

    // In Win95, the FIFO settings were (wrongfully) stored in the 
    // device key.  I've changed this to look in the driver key. 
    // (scotth)

    if (FindDev_Create(&pfd, c_pguidPort, c_szFriendlyName, pszPortName) ||
        FindDev_Create(&pfd, c_pguidPort, c_szPortName, pszPortName) ||
        FindDev_Create(&pfd, c_pguidModem, c_szPortName, pszPortName))
        {
        switch (action)
            {
        case ACT_GET:
            ASSERT(4 == sizeof(SETTINGS));

            cbData = sizeof(SETTINGS);
            if (ERROR_SUCCESS != RegQueryValueEx(pfd->hkeyDrv, c_szSettings, NULL,
                NULL, (LPBYTE)&settings, &cbData)) 
                {
                // Default settings if not in registry
                settings.fifoon = 0x02;
                settings.dsron = 0;
                settings.txfifosize = 16;
                settings.rxtriggersize = 0x80;
                }
            if (!settings.fifoon)
                *pbUseFifo = FALSE;
            else
                *pbUseFifo = TRUE;
            settings.rxtriggersize = settings.rxtriggersize % 0xC1;
            *RxTrigger = settings.rxtriggersize/0x40;
            *TxTrigger = settings.txfifosize % 17;
            break;

        case ACT_SET:
            if (FALSE == *pbUseFifo)
                settings.fifoon = 0;
            else
                settings.fifoon = 2;

            settings.rxtriggersize = RxTriggerValues[*RxTrigger];
            settings.dsron = 0;
            settings.txfifosize = (*TxTrigger)*5+1;
            RegSetValueEx(pfd->hkeyDrv, c_szSettings, 0, REG_BINARY,
                (LPBYTE)&settings, sizeof(SETTINGS));
            break;

        default:
            ASSERT(0);
            break;
            }

        cbData = sizeof(szFifo) - 6;    // leave room for "fifo" on the end
        RegQueryValueEx(pfd->hkeyDrv, c_szPortName, NULL, NULL, (LPBYTE)szFifo,
            &cbData);

        FindDev_Destroy(pfd);

        lstrcat(szFifo, c_szComxFifo);
        if (*pbUseFifo)
            WritePrivateProfileString(c_szEnh, szFifo, NULL, c_szSystem);
        else
            WritePrivateProfileString(c_szEnh, szFifo, OnStr, c_szSystem);
        }
    }



/*----------------------------------------------------------
Purpose: Dialog proc for advanced port settings

Returns: standard
Cond:    --
*/
BOOL CALLBACK AdvPort_DlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
    {
    BOOL bRet = FALSE;
    BYTE rxtrigger, txtrigger;
    BOOL bUseFifo;
    LPCTSTR pszPortName;

    switch (uMsg) 
        {
    case WM_INITDIALOG:
        pszPortName = (LPCTSTR)lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (ULONG_PTR)pszPortName);

        GetSetAdvSettings(pszPortName, &rxtrigger, &txtrigger, &bUseFifo, ACT_GET);
        DisplayAdvSettings(hDlg, rxtrigger, txtrigger, bUseFifo);
        break;

    case WM_COMMAND:
        pszPortName = (LPCTSTR)GetWindowLongPtr(hDlg, DWLP_USER);
        if (!pszPortName)
            {
            ASSERT(0);
            break;
            }

        switch (wParam) 
            {
        case IDOK:
            if (IsDlgButtonChecked(hDlg, IDC_FIFO_USAGE))
                bUseFifo = TRUE;
            else
                bUseFifo = FALSE;

            rxtrigger = (BYTE)SendDlgItemMessage(hDlg,
                IDC_RXFIFO_USAGE, TBM_GETPOS, 0, 0);
            txtrigger = (BYTE)SendDlgItemMessage(hDlg,
                IDC_TXFIFO_USAGE, TBM_GETPOS, 0, 0);

            GetSetAdvSettings(pszPortName, &rxtrigger, &txtrigger, &bUseFifo, ACT_SET);

            // Fall thru
            //  |    |
            //  v    v

        case IDCANCEL:
            EndDialog(hDlg, IDOK == wParam);
            break;

        case IDC_FIFO_USAGE:
            if (!IsDlgButtonChecked(hDlg, IDC_FIFO_USAGE))
                DisplayAdvSettings(hDlg, 0, 0, FALSE);
            else 
                {
                EnableWindow(GetDlgItem(hDlg, IDC_LBL_RXFIFO), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_LBL_RXFIFO_LO), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_LBL_RXFIFO_HI), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_RXFIFO_USAGE), TRUE);

                EnableWindow(GetDlgItem(hDlg, IDC_LBL_TXFIFO), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_LBL_TXFIFO_LO), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_LBL_TXFIFO_HI), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_TXFIFO_USAGE), TRUE);
                }
            break;

        case IDC_DEFAULTS:
            DisplayAdvSettings(hDlg, 2, 12, TRUE);
            break;
            }
        break;

    case WM_HELP:
        WinHelp(((LPHELPINFO)lParam)->hItemHandle, c_szWinHelpFile, HELP_WM_HELP, (DWORD)(LPVOID)rgAdvHelpIDs);
        return 0;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, c_szWinHelpFile, HELP_CONTEXTMENU, (DWORD)(LPVOID)rgAdvHelpIDs);
        return 0;

    default:
        break;
        }
    return bRet;
    }


/*----------------------------------------------------------
Purpose: Private entry point to show the Advanced Fifo dialog

Returns: IDOK or IDCANCEL

Cond:    --
*/
UINT WINAPI FeFiFoFum(
    HWND hwndOwner,
    LPCTSTR pszPortName)
    {
    UINT uRet = (UINT)-1;

    // Invoke the advanced dialog
    if (pszPortName)
        {
        uRet = DialogBoxParam(g_hinst, MAKEINTRESOURCE(IDD_ADV_PORT), 
                hwndOwner, AdvPort_DlgProc, (LPARAM)pszPortName);
        }
    return uRet;
    }

#endif // SUPPORT_FIFO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\serialui\serialui.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1996
//
// File: serialui.c
//
// This files contains the DLL entry-points.
//
// Much of this file contains the code that builds the default property dialog
// for serial ports.
//
// History:
//   1-12-94 ScottH     Created
//   8-15-94 ScottH     Split from modemui.dll
//  11-06-95 ScottH     Ported to NT
//
//---------------------------------------------------------------------------


#include "proj.h"     // common headers

#define INITGUID
#include <objbase.h>
#include <initguid.h>
#include <devguid.h>

#pragma data_seg(DATASEG_READONLY)

LPGUID c_pguidModem     = (LPGUID)&GUID_DEVCLASS_MODEM;

// (scotth):  it looks like for the NT SUR release, that there
// will be no Port class key or GUID.  So we have to hack something
// up.
#ifdef DCB_IN_REGISTRY
LPGUID c_pguidPort      = (LPGUID)&GUID_DEVCLASS_PORT;
#else
LPGUID c_pguidPort      = (LPGUID)NULL;
#endif

#pragma data_seg()


#define MAX_PROP_PAGES  8          // Define a reasonable limit


#ifdef DEBUG

//-----------------------------------------------------------------------------------
//  Debug routines
//-----------------------------------------------------------------------------------

/*----------------------------------------------------------
Purpose: Dumps the DCB struct
Returns: --
Cond:    --
*/
void PRIVATE DumpDCB(
    LPWIN32DCB pdcb)
    {
    ASSERT(pdcb);

    if (IsFlagSet(g_dwDumpFlags, DF_DCB))
        {
        int i;
        LPDWORD pdw = (LPDWORD)pdcb;

        TRACE_MSG(TF_ALWAYS, "DCB  %08lx %08lx %08lx %08lx", pdw[0], pdw[1], pdw[2], pdw[3]);
        pdw += 4;
        for (i = 0; i < sizeof(WIN32DCB)/sizeof(DWORD); i += 4, pdw += 4)
            {
            TRACE_MSG(TF_ALWAYS, "     %08lx %08lx %08lx %08lx", pdw[0], pdw[1], pdw[2], pdw[3]);
            }
        }
    }

#endif //DEBUG


//-----------------------------------------------------------------------------------
//  
//-----------------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Composes a string of the format "baud,parity,data,stopbit"

Returns: --
Cond:    --
*/
void PRIVATE ComposeModeComString(
    LPCOMMCONFIG pcc,
    LPTSTR pszBuffer)
    {
    WIN32DCB FAR * pdcb = &pcc->dcb;
    TCHAR chParity;
    LPCTSTR pszStop;
    TCHAR chFlow;

    const static TCHAR rgchParity[] = {'n', 'o', 'e', 'm', 's'};
    const static LPCTSTR rgpszStop[] = {TEXT("1"), TEXT("1.5"), TEXT("2")};
    
    // Parity
//    ASSERT(!pdcb->fParity && NOPARITY == pdcb->Parity || pdcb->fParity);
    ASSERT(0 <= pdcb->Parity && ARRAYSIZE(rgchParity) > pdcb->Parity);

    if (0 <= pdcb->Parity && ARRAYSIZE(rgchParity) > pdcb->Parity)
        {
        chParity = rgchParity[pdcb->Parity];
        }
    else
        {
        chParity = rgchParity[0];   // Safety net
        }

    // Stop bits
    ASSERT(0 <= pdcb->StopBits && ARRAYSIZE(rgpszStop) > pdcb->StopBits);

    if (0 <= pdcb->StopBits && ARRAYSIZE(rgpszStop) > pdcb->StopBits)
        {
        pszStop = rgpszStop[pdcb->StopBits];
        }
    else
        {
        pszStop = rgpszStop[0];   // Safety net
        }

    // Flow control
    if (FALSE != pdcb->fOutX && FALSE == pdcb->fOutxCtsFlow)
        {
        chFlow = 'x';       // XON/XOFF flow control
        }
    else if (FALSE == pdcb->fOutX && FALSE != pdcb->fOutxCtsFlow)
        {
        chFlow = 'p';       // Hardware flow control
        }
    else
        {
        chFlow = ' ';       // No flow control
        }

    wsprintf(pszBuffer, TEXT("%ld,%c,%d,%s,%c"), pdcb->BaudRate, chParity, pdcb->ByteSize,
        pszStop, chFlow);
    }


/*----------------------------------------------------------
Purpose: Initialize the port info.

Returns: --
Cond:    --
*/
void PRIVATE InitializePortInfo(
    LPCTSTR pszFriendlyName,
    LPPORTINFO pportinfo,
    LPCOMMCONFIG pcc)
    {
    ASSERT(pportinfo);
    ASSERT(pcc);

    // Read-only fields
    pportinfo->pcc = pcc;

    CopyMemory(&pportinfo->dcb, &pcc->dcb, sizeof(pportinfo->dcb));

    lstrcpyn(pportinfo->szFriendlyName, pszFriendlyName, SIZECHARS(pportinfo->szFriendlyName));
    }



/*----------------------------------------------------------
Purpose: Gets a WIN32DCB from the registry.

Returns: One of the ERROR_ values
Cond:    --
*/
DWORD 
PRIVATE 
RegQueryDCB(
    IN  LPFINDDEV      pfd,
    OUT WIN32DCB FAR * pdcb)
    {
    DWORD dwRet = ERROR_BADKEY;

#ifdef DCB_IN_REGISTRY

    DWORD cbData;

    ASSERT(pdcb);

    // Does the DCB key exist in the driver key?
    if (ERROR_SUCCESS == RegQueryValueEx(pfd->hkeyDrv, c_szDCB, NULL, NULL, NULL, &cbData))
        {
        // Yes; is the size in the registry okay?  
        if (sizeof(*pdcb) < cbData)
            {
            // No; the registry has bogus data
            dwRet = ERROR_BADDB;
            }
        else
            {
            // Yes; get the DCB from the registry
            if (ERROR_SUCCESS == RegQueryValueEx(pfd->hkeyDrv, c_szDCB, NULL, NULL, (LPBYTE)pdcb, &cbData))
                {
                if (sizeof(*pdcb) == pdcb->DCBlength)
                    {
                    dwRet = NO_ERROR;
                    }
                else
                    {
                    dwRet = ERROR_BADDB;
                    }
                }
            else
                {
                dwRet = ERROR_BADKEY;
                }
            }
        }

#else

    static TCHAR const FAR c_szDefaultDCBString[] = TEXT("9600,n,8,1");
    
    TCHAR sz[MAX_BUF_MED];
    TCHAR szKey[MAX_BUF_SHORT];

    lstrcpy(szKey, pfd->szPort);
    lstrcat(szKey, TEXT(":"));

    GetProfileString(c_szPortClass, szKey, c_szDefaultDCBString, sz, SIZECHARS(sz));

    TRACE_MSG(TF_GENERAL, "DCB string is \"%s\"", sz);

    // Convert the DCB string to a DCB structure
    if ( !BuildCommDCB(sz, pdcb) )
        {
        dwRet = GetLastError();

        ASSERT(NO_ERROR != dwRet);
        }
    else
        {
        dwRet = NO_ERROR;
        }

#endif

    return dwRet;
    }


/*----------------------------------------------------------
Purpose: Save the DCB to the permanent storage

Returns: win32 error
Cond:    --
*/
DWORD
PRIVATE
RegSetDCB(
    IN  LPFINDDEV      pfd,
    IN  WIN32DCB FAR * pdcb)
    {
    DWORD dwRet;

#ifdef DCB_IN_REGISTRY

    DWORD cbData;

    // Write the DCB to the driver key
    cbData = sizeof(WIN32DCB);
    dwRet = RegSetValueEx(pfd->hkeyDrv, c_szDCB, 0, REG_BINARY, (LPBYTE)&pcc->dcb, cbData);

#else

    dwRet = NO_ERROR;

#endif

    return dwRet;
    }


/*----------------------------------------------------------
Purpose: Frees the portinfo struct

Returns: --
Cond:    --
*/
void PRIVATE FreePortInfo(
    LPPORTINFO pportinfo)
    {
    if (pportinfo)
        {
        if (pportinfo->pcc)
            LocalFree(LOCALOF(pportinfo->pcc));

        LocalFree(LOCALOF(pportinfo));
        }
    }


/*----------------------------------------------------------
Purpose: Release the data associated with the Port Settings page
Returns: --
Cond:    --
*/
UINT CALLBACK PortSettingsCallback(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp)
    {
    DBG_ENTER("PortSettingsCallback");

    if (PSPCB_RELEASE == uMsg)
        {
        LPPORTINFO pportinfo = (LPPORTINFO)ppsp->lParam;
        LPCOMMCONFIG pcc;

        ASSERT(pportinfo);

        pcc = pportinfo->pcc;

        if (IDOK == pportinfo->idRet)
            {
            // Save the changes back to the commconfig struct
            TRACE_MSG(TF_GENERAL, "Saving DCB");

            CopyMemory(&pcc->dcb, &pportinfo->dcb, sizeof(pcc->dcb));

            DEBUG_CODE( DumpDCB(&pcc->dcb); )

            // Are we releasing from the Device Mgr?
            if (IsFlagSet(pportinfo->uFlags, SIF_FROM_DEVMGR))
                {
                // Yes; save the commconfig now as well
                drvSetDefaultCommConfig(pportinfo->szFriendlyName, pcc, pcc->dwSize);

                // Free the portinfo struct only when called from the Device Mgr
                FreePortInfo(pportinfo);
                }
            }

        TRACE_MSG(TF_GENERAL, "Releasing the Port Settings page");
        }

    DBG_EXIT("PortSettingsCallback");
    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Add the port settings page.  

Returns: ERROR_ value

Cond:    --
*/
DWORD PRIVATE AddPortSettingsPage(
    LPPORTINFO pportinfo,
    LPFNADDPROPSHEETPAGE pfnAdd, 
    LPARAM lParam)
    {
    DWORD dwRet = ERROR_NOT_ENOUGH_MEMORY;
    PROPSHEETPAGE   psp;
    HPROPSHEETPAGE  hpage;

    ASSERT(pportinfo);
    ASSERT(pfnAdd);

    // Add the Port Settings property page
    //
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USECALLBACK;
    psp.hInstance = g_hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PORTSETTINGS);
    psp.pfnDlgProc = Port_WrapperProc;
    psp.lParam = (LPARAM)pportinfo;
    psp.pfnCallback = PortSettingsCallback;
    
    hpage = CreatePropertySheetPage(&psp);
    if (hpage)
        {
        if (!pfnAdd(hpage, lParam))
            DestroyPropertySheetPage(hpage);
        else
            dwRet = NO_ERROR;
        }
    
    return dwRet;
    }


/*----------------------------------------------------------
Purpose: Function that is called by EnumPropPages entry-point to
         add property pages.

Returns: TRUE on success
         FALSE on failure

Cond:    --
*/
BOOL CALLBACK AddInstallerPropPage(
    HPROPSHEETPAGE hPage, 
    LPARAM lParam)
    {
    PROPSHEETHEADER FAR * ppsh = (PROPSHEETHEADER FAR *)lParam;
 
    if (ppsh->nPages < MAX_PROP_PAGES)
        {
        ppsh->phpage[ppsh->nPages] = hPage;
        ++ppsh->nPages;
        return(TRUE);
        }
    return(FALSE);
    }


/*----------------------------------------------------------
Purpose: Bring up property sheet for a serial port

Returns: ERROR_ value
Cond:    --
*/
DWORD PRIVATE DoProperties(
    LPCTSTR pszFriendlyName,
    HWND hwndParent,
    LPCOMMCONFIG pcc)
    {
    DWORD dwRet;
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE hpsPages[MAX_PROP_PAGES];
    LPPORTINFO pportinfo;

    // Initialize the PropertySheet Header
    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_PROPTITLE;
    psh.hwndParent = hwndParent;
    psh.hInstance = g_hinst;
    psh.nPages = 0;
    psh.nStartPage = 0;
    psh.phpage = (HPROPSHEETPAGE FAR *)hpsPages;

    // Allocate the working buffer
    //
    pportinfo = (LPPORTINFO)LocalAlloc(LPTR, sizeof(*pportinfo));
    if (pportinfo)
        {
        InitializePortInfo(pszFriendlyName, pportinfo, pcc);
        psh.pszCaption = pportinfo->szFriendlyName;

        DEBUG_CODE( DumpDCB(&pcc->dcb); )

        dwRet = AddPortSettingsPage(pportinfo, AddInstallerPropPage, (LPARAM)&psh);

        if (NO_ERROR == dwRet)
            {
            // Show the property sheet
            PropertySheet(&psh);

            dwRet = (IDOK == pportinfo->idRet) ? NO_ERROR : ERROR_CANCELLED;
            }

        // Clear the pcc field so FreePortInfo does not prematurely free it,
        // since we did not allocate it.
        pportinfo->pcc = NULL;
        FreePortInfo(pportinfo);
        }
    else
        {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        }
    
    return dwRet;
    }


#ifdef WIN95

// The Device Manager allows DLLs to add pages to the properties
// of a device.  EnumPropPages is the entry-point that it would
// call to add pages.  
//
// This is not implemented in NT.


/*----------------------------------------------------------
Purpose: Derives a PORTINFO struct from a device info.

Returns: TRUE on success

Cond:    --
*/
BOOL PRIVATE DeviceInfoToPortInfo(
    LPDEVICE_INFO pdi,
    LPPORTINFO pportinfo)
    {
    BOOL bRet = FALSE;
    LPFINDDEV pfd;
    COMMCONFIG ccDummy;
    LPCOMMCONFIG pcommconfig;
    DWORD cbSize;
    DWORD cbData;
    TCHAR szFriendly[MAXFRIENDLYNAME];

    // Find the device by looking for the device description.  (Note the
    // device description is not always the same as the friendly name.)

    if (FindDev_Create(&pfd, c_pguidPort, c_szDeviceDesc, pdi->szDescription))
        {
        cbData = sizeof(szFriendly);
        if (ERROR_SUCCESS == RegQueryValueEx(pfd->hkeyDev, c_szFriendlyName, NULL, NULL, 
                                             (LPBYTE)szFriendly, &cbData))
            {
            ccDummy.dwProviderSubType = PST_RS232;
            cbSize = sizeof(COMMCONFIG);
            drvGetDefaultCommConfig(szFriendly, &ccDummy, &cbSize);

            pcommconfig = (LPCOMMCONFIG)LocalAlloc(LPTR, (UINT)cbSize);
            if (pcommconfig)
                {
                // Get the commconfig from the registry
                pcommconfig->dwProviderSubType = PST_RS232;
                if (NO_ERROR == drvGetDefaultCommConfig(szFriendly, pcommconfig, 
                    &cbSize))
                    {
                    // Initialize the modem info from the commconfig
                    InitializePortInfo(szFriendly, pportinfo, pcommconfig);

                    SetFlag(pportinfo->uFlags, SIF_FROM_DEVMGR);
                    bRet = TRUE;
                    }
                else
                    {
                    // Failure
                    LocalFree(LOCALOF(pcommconfig));
                    }

                // pcommconfig is freed in ReleasePortSettingsPage
                }
            }
        FindDev_Destroy(pfd);
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: EnumDevicePropPages entry-point.  This entry-point
         gets called only when the Device Manager asks for 
         additional property pages.  

Returns: TRUE on success
         FALSE if pages could not be added
Cond:    --
*/
BOOL WINAPI EnumPropPages(
    LPDEVICE_INFO pdi, 
    LPFNADDPROPSHEETPAGE pfnAdd, 
    LPARAM lParam)              // Don't touch the lParam value, just pass it on!
    {
    BOOL bRet = FALSE;
    LPPORTINFO pportinfo;

    DBG_ENTER("EnumPropPages");

    ASSERT(pdi);
    ASSERT(pfnAdd);

    pportinfo = (LPPORTINFO)LocalAlloc(LPTR, sizeof(*pportinfo));
    if (pportinfo)
        {
        // Convert the device info struct to a portinfo.
        bRet = DeviceInfoToPortInfo(pdi, pportinfo);
        if (bRet)
            {
            AddPortSettingsPage(pportinfo, pfnAdd, lParam);
            }
        else
            {
            // Failed
            FreePortInfo(pportinfo);
            }
        // pportinfo is freed in ReleasePortSettingsPage
        }

    DBG_EXIT_BOOL("EnumPropPages", bRet);

    return bRet;
    }
#endif


/*----------------------------------------------------------
Purpose: Invokes the serial port configuration dialog.  

Returns: One of the ERROR_ values
Cond:    --
*/
DWORD 
PRIVATE 
MyCommConfigDialog(
    IN     LPFINDDEV    pfd,
    IN     LPCTSTR      pszFriendlyName,
    IN     HWND         hwndOwner,
    IN OUT LPCOMMCONFIG pcc)
    {
    DWORD dwRet;
    
    ASSERT(pfd);
    // (Wrapper should have checked these first)
    ASSERT(pszFriendlyName);
    ASSERT(pcc);
    ASSERT(sizeof(*pcc) <= pcc->dwSize);

    dwRet = DoProperties(pszFriendlyName, hwndOwner, pcc);

    return dwRet;
    }


/*----------------------------------------------------------
Purpose: Gets the default COMMCONFIG for the specified device.
         This API doesn't require a handle.

         If the caller passed in a null device name or a null
         commconfig pointer, this function will set *pdwSize to
         the minimum COMMCONFIG size.  Calling this function
         a second time (after setting the dwSize and dwProviderSubType
         fields) will verify if the size is correct.

         So generally, when getting a commconfig for serial ports,
         the process is:

         COMMCONFIG ccDummy;
         LPCOMMCONFIG pcc;
         DWORD dwSize = sizeof(*pcc);

         // Determine real size of COMMCONFIG for RS-232 subtype
         ccDummy.dwProviderSubType = PST_RS232;
         GetDefaultCommConfig(pszFriendlyName, &ccDummy, &dwSize);

         // Allocate real commconfig struct and initialize
         pcc = LocalAlloc(LPTR, dwSize);
         if (pcc)
            {
            pcc->dwProviderSubType = PST_RS232;
            GetDefaultCommConfig(pszFriendlyName, pcc, &dwSize);
            ....
            }

Returns: One of the ERROR_ values in winerror.h

Cond:    --
*/
DWORD 
PRIVATE 
MyGetDefaultCommConfig(
    IN  LPFINDDEV   pfd,
    IN  LPCTSTR     pszFriendlyName,
    OUT LPCOMMCONFIG pcc,
    OUT LPDWORD     pdwSize)
    {
    DWORD dwRet;
    
    ASSERT(pfd);
    // (Wrapper should have checked these first)
    ASSERT(pszFriendlyName);
    ASSERT(pcc);
    ASSERT(pdwSize);
    ASSERT(sizeof(*pcc) <= *pdwSize);

    *pdwSize = sizeof(*pcc);

    // Initialize the commconfig structure
    pcc->dwSize = *pdwSize;
    pcc->wVersion = COMMCONFIG_VERSION_1;
    pcc->dwProviderSubType = PST_RS232;
    pcc->dwProviderOffset = 0;
    pcc->dwProviderSize = 0;

    dwRet = RegQueryDCB(pfd, &pcc->dcb);

    DEBUG_CODE( DumpDCB(&pcc->dcb); )

    return dwRet;
    }


/*----------------------------------------------------------
Purpose: Sets the default COMMCONFIG for the specified device.
         This API doesn't require a handle.  This function
         strictly modifies the registry.  Use SetCommConfig
         to set the COMMCONFIG of an open device.

         If the dwSize parameter or the dwSize field are invalid 
         sizes (given the dwProviderSubType field in COMMCONFIG), 
         then this function fails.

Returns: One of the ERROR_ return values

Cond:    --
*/
DWORD 
PRIVATE 
MySetDefaultCommConfig(
    IN LPFINDDEV    pfd,
    IN LPCTSTR      pszFriendlyName,
    IN LPCOMMCONFIG pcc)
    {
    DWORD dwRet;
    TCHAR szValue[MAX_BUF_SHORT];
    TCHAR szKey[MAX_BUF_SHORT];

    ASSERT(pfd);
    // (Wrapper should have checked these first)
    ASSERT(pszFriendlyName);
    ASSERT(pcc);
    ASSERT(sizeof(*pcc) <= pcc->dwSize);

    ASSERT(0 == pcc->dwProviderSize);
    ASSERT(0 == pcc->dwProviderOffset);

    dwRet = RegSetDCB(pfd, &pcc->dcb);

    if (NO_ERROR == dwRet)
        {
        // For Win 3.1 compatibility, write some info to win.ini
        lstrcpy(szKey, pfd->szPort);
        lstrcat(szKey, TEXT(":"));

        // Delete the old win.ini entry first
        WriteProfileString(c_szPortClass, szKey, NULL);

        ComposeModeComString(pcc, szValue);
        WriteProfileString(c_szPortClass, szKey, szValue);

#ifdef WIN95
            {
            DWORD dwRecipients;

            // Send a broadcast proclaiming that the win.ini has changed
            // (Use the internal BroadcastSystemMessage to avoid deadlocks.
            // SendMessageTimeout would be more appropriate, but that is
            // not exported for 16-bit dlls.  PostMessage is not good because
            // lParam is a pointer.)

            dwRecipients = BSM_APPLICATIONS;
            BroadcastSystemMessage(BSF_NOHANG, &dwRecipients, WM_WININICHANGE, 
                NULL, (LPARAM)c_szPortClass);
            }
#else
            {
            SendNotifyMessage(HWND_BROADCAST, WM_WININICHANGE, 0, (LPARAM)c_szPortClass);
            }
#endif
        }


    DEBUG_CODE( DumpDCB(&pcc->dcb); )
        
    return dwRet;
    }


//-----------------------------------------------------------------------------------
//  Entry-points provided for KERNEL32 APIs
//-----------------------------------------------------------------------------------


DWORD 
APIENTRY 
#ifdef UNICODE
drvCommConfigDialogA(
    IN     LPCSTR       pszFriendlyName,
    IN     HWND         hwndOwner,
    IN OUT LPCOMMCONFIG pcc)
#else
drvCommConfigDialogW(
    IN     LPCWSTR      pszFriendlyName,
    IN     HWND         hwndOwner,
    IN OUT LPCOMMCONFIG pcc)
#endif
    {
    return ERROR_CALL_NOT_IMPLEMENTED;
    }


/*----------------------------------------------------------
Purpose: Entry point for CommConfigDialog

Returns: standard error value in winerror.h
Cond:    --
*/
DWORD 
APIENTRY 
drvCommConfigDialog(
    IN     LPCTSTR      pszFriendlyName,
    IN     HWND         hwndOwner,
    IN OUT LPCOMMCONFIG pcc)
    {
    DWORD dwRet;
    LPFINDDEV pfd;

    DEBUG_CODE( TRACE_MSG(TF_FUNC, "drvCommConfigDialog(%s, ...) entered",
                Dbg_SafeStr(pszFriendlyName)); )

    // We support friendly names (eg, "Communications Port (COM1)") or 
    // portname values (eg, "COM1").

    if (NULL == pszFriendlyName || 
        NULL == pcc)
        {
        dwRet = ERROR_INVALID_PARAMETER;
        }
    // Is the size sufficient?
    else if (sizeof(*pcc) > pcc->dwSize)
        {
        // No
        dwRet = ERROR_INSUFFICIENT_BUFFER;
        }
    else if (FindDev_Create(&pfd, c_pguidPort, c_szFriendlyName, pszFriendlyName) ||
        FindDev_Create(&pfd, c_pguidPort, c_szPortName, pszFriendlyName) ||
        FindDev_Create(&pfd, c_pguidModem, c_szPortName, pszFriendlyName))
        {
        dwRet = MyCommConfigDialog(pfd, pszFriendlyName, hwndOwner, pcc);

        FindDev_Destroy(pfd);
        }
    else
        {
        dwRet = ERROR_BADKEY;
        }

    DBG_EXIT_DWORD("drvCommConfigDialog", dwRet);

    return dwRet;
    }


DWORD 
APIENTRY 
#ifdef UNICODE
drvGetDefaultCommConfigA(
    IN     LPCSTR       pszFriendlyName,
    IN     LPCOMMCONFIG pcc,
    IN OUT LPDWORD      pdwSize)
#else
drvGetDefaultCommConfigW(
    IN     LPCWSTR      pszFriendlyName,
    IN     LPCOMMCONFIG pcc,
    IN OUT LPDWORD      pdwSize)
#endif
    {
    return ERROR_CALL_NOT_IMPLEMENTED;
    }


/*----------------------------------------------------------
Purpose: Entry point for GetDefaultCommConfig

Returns: standard error value in winerror.h
Cond:    --
*/
DWORD 
APIENTRY 
drvGetDefaultCommConfig(
    IN     LPCTSTR      pszFriendlyName,
    IN     LPCOMMCONFIG pcc,
    IN OUT LPDWORD      pdwSize)
    {
    DWORD dwRet;
    LPFINDDEV pfd;

    DEBUG_CODE( TRACE_MSG(TF_FUNC, "drvGetDefaultCommConfig(%s, ...) entered",
                Dbg_SafeStr(pszFriendlyName)); )

    // We support friendly names (eg, "Communications Port (COM1)") or 
    // portname values (eg, "COM1").

    if (NULL == pszFriendlyName || 
        NULL == pcc || 
        NULL == pdwSize)
        {
        dwRet = ERROR_INVALID_PARAMETER;
        }
    // Is the size sufficient?
    else if (sizeof(*pcc) > *pdwSize)
        {
        // No; return correct value
        dwRet = ERROR_INSUFFICIENT_BUFFER;
        *pdwSize = sizeof(*pcc);
        }
    else if (FindDev_Create(&pfd, c_pguidPort, c_szFriendlyName, pszFriendlyName) ||
        FindDev_Create(&pfd, c_pguidPort, c_szPortName, pszFriendlyName) ||
        FindDev_Create(&pfd, c_pguidModem, c_szPortName, pszFriendlyName))
        {
        dwRet = MyGetDefaultCommConfig(pfd, pszFriendlyName, pcc, pdwSize);

        FindDev_Destroy(pfd);
        }
    else
        {
        dwRet = ERROR_BADKEY;
        }

    DBG_EXIT_DWORD("drvGetDefaultCommConfig", dwRet);

    return dwRet;
    }


DWORD 
APIENTRY 
#ifdef UNICODE
drvSetDefaultCommConfigA(
    IN LPSTR        pszFriendlyName,
    IN LPCOMMCONFIG pcc,
    IN DWORD        dwSize)           
#else
drvSetDefaultCommConfigW(
    IN LPWSTR       pszFriendlyName,
    IN LPCOMMCONFIG pcc,
    IN DWORD        dwSize)           
#endif
    {
    return ERROR_CALL_NOT_IMPLEMENTED;
    }


/*----------------------------------------------------------
Purpose: Entry point for SetDefaultCommConfig

Returns: standard error value in winerror.h
Cond:    --
*/
DWORD 
APIENTRY 
drvSetDefaultCommConfig(
    IN LPTSTR       pszFriendlyName,
    IN LPCOMMCONFIG pcc,
    IN DWORD        dwSize)
    {
    DWORD dwRet;
    LPFINDDEV pfd;


    DEBUG_CODE( TRACE_MSG(TF_FUNC, "drvSetDefaultCommConfig(%s, ...) entered",
                Dbg_SafeStr(pszFriendlyName)); )

    // We support friendly names (eg, "Communications Port (COM1)") or 
    // portname values (eg, "COM1").

    if (NULL == pszFriendlyName || 
        NULL == pcc)
        {
        dwRet = ERROR_INVALID_PARAMETER;
        }
    // Is the size sufficient?
    else if ((sizeof(*pcc) > pcc->dwSize) || (sizeof(*pcc) > dwSize))
        {
        // No
        dwRet = ERROR_INSUFFICIENT_BUFFER;
        }
    else if (FindDev_Create(&pfd, c_pguidPort, c_szFriendlyName, pszFriendlyName) ||
        FindDev_Create(&pfd, c_pguidPort, c_szPortName, pszFriendlyName) ||
        FindDev_Create(&pfd, c_pguidModem, c_szPortName, pszFriendlyName))
        {
        dwRet = MySetDefaultCommConfig(pfd, pszFriendlyName, pcc);

        FindDev_Destroy(pfd);
        }
    else
        {
        dwRet = ERROR_BADKEY;
        }

    DBG_EXIT_DWORD("drvSetDefaultCommConfig", dwRet);

    return dwRet;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\serialui\proj.h ===
//
// proj.h:  Includes all files that are to be part of the precompiled
//             header.
//

#ifndef __PROJ_H__
#define __PROJ_H__



//
// Private Defines
//

//#define SUPPORT_FIFO                // Win95 only: support Advanced FIFO dialog
//#define DCB_IN_REGISTRY             // Plug-and-play: The port driver info is stored in the registry


#define STRICT

#if DBG > 0 && !defined(DEBUG)
#define DEBUG
#endif
#if DBG > 0 && !defined(FULL_DEBUG)
#define FULL_DEBUG
#endif

#define UNICODE

// Defines for rovcomm.h

#define NODA
#define NOSHAREDHEAP
#define NOFILEINFO
#define NOCOLORHELP
#define NODRAWTEXT
#define NOPATH
#define NOSYNC
#ifndef DEBUG
#define NOPROFILE
#endif

#define SZ_MODULEA      "SERIALUI"
#define SZ_MODULEW      TEXT("SERIALUI")

#ifdef DEBUG
#define SZ_DEBUGSECTION TEXT("SERIALUI")
#define SZ_DEBUGINI     TEXT("unimdm.ini")
#endif // DEBUG

// Includes

#define USECOMM

#include <windows.h>        
#include <windowsx.h>

#include <winerror.h>
#include <commctrl.h>       // needed by shlobj.h and our progress bar
#include <prsht.h>          // Property sheet stuff
#include <rovcomm.h>
#include <modemp.h>
#include <shellapi.h>       // for registration functions
#include <regstr.h>

#ifdef WIN95
#include <setupx.h>         // PnP setup/installer services
#else
#include <setupapi.h>       // PnP setup/installer services
#endif

#define MAXBUFLEN       MAX_BUF
#define MAXMSGLEN       MAX_BUF_MSG
#define MAXMEDLEN       MAX_BUF_MED
#define MAXSHORTLEN     MAX_BUF_SHORT

#ifndef LINE_LEN
#define LINE_LEN        MAXBUFLEN
#endif

#include <debugmem.h>

// local includes
//
#include "dll.h"
#include "cstrings.h"       // Read-only string constants
#include "util.h"           // Utility functions
#include "serialui.h"
#include "rcids.h"
#include "dlgids.h"

//****************************************************************************
// 
//****************************************************************************


// Dump flags
#define DF_DCB              0x00000001
#define DF_MODEMSETTINGS    0x00000002
#define DF_DEVCAPS          0x00000004

#endif  //!__PROJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\serialui\rcids.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by SYNCUI.RC
//

// Icon values
//
#define IDI_NULL_MODEM                  700
#define IDI_EXTERNAL_MODEM              701
#define IDI_INTERNAL_MODEM              702
#define IDI_PCMCIA_MODEM                703

// Bitmap values
//
#define IDB_ACTIONS                     108
#define IDB_SMALLACTIONS_MASK           111
#define IDB_CONTAIN                     801
#define IDB_CONTAIN_MASK                802
#define IDB_ACTIONS_MASK                803
#define IDB_SMALLACTIONS                804
#define IDB_MENU_MASK                   806
#define IDB_MENU                        806

// Random stuff
//
#define IDS_NULL_MODEM                  180
#define IDS_EXTERNAL_MODEM              181
#define IDS_INTERNAL_MODEM              182
#define IDS_PCMCIA_MODEM                183
#define IDS_PARALLEL_MODEM              184
#define IDS_PARALLEL_PORT               185

#define IDS_BAUD_110                    200
#define IDS_BAUD_1200                   201
#define IDS_BAUD_2400                   202
#define IDS_BAUD_4800                   203
#define IDS_BAUD_9600                   204
#define IDS_BAUD_14400                  205
#define IDS_BAUD_19200                  206
#define IDS_BAUD_38400                  207
#define IDS_BAUD_56K                    208
#define IDS_BAUD_128K                   209
#define IDS_BAUD_115200                 210
#define IDS_BAUD_57600                  211
#define IDS_BAUD_FASTEST                212
#define IDS_BAUD_075                    213
#define IDS_BAUD_134_5                  214     
#define IDS_BAUD_150                    215     
#define IDS_BAUD_300                    216     
#define IDS_BAUD_600                    217     
#define IDS_BAUD_1800                   218     
#define IDS_BAUD_7200                   219     
#define IDS_BAUD_230400                 220
#define IDS_BAUD_460800                 221
#define IDS_BAUD_921600                 222

#define IDS_BYTESIZE_4                  240
#define IDS_BYTESIZE_5                  241
#define IDS_BYTESIZE_6                  242
#define IDS_BYTESIZE_7                  243
#define IDS_BYTESIZE_8                  244

#define IDS_PARITY_EVEN                 250
#define IDS_PARITY_ODD                  251
#define IDS_PARITY_NONE                 252
#define IDS_PARITY_MARK                 253
#define IDS_PARITY_SPACE                254
#define IDS_STOPBITS_1                  255
#define IDS_STOPBITS_1_5                256
#define IDS_STOPBITS_2                  257

#define IDS_FLOWCTL_XONXOFF             260
#define IDS_FLOWCTL_HARDWARE            261
#define IDS_FLOWCTL_NONE                262

#define IDS_LOGFILE                     270
                                          
// Messages
//
                                        
// Captions                             
//
#define IDS_CAP_GENERAL                 340
#define IDS_CAP_SETTINGS                341
#define IDS_CAP_PORT                    342

// Formatted strings
//

// Error strings
//

// Out-of-memory strings
//
#define IDS_OOM_GENERAL                 460
#define IDS_OOM_SETTINGS                461
#define IDS_OOM_PORT                    462
                                        
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         105
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\serialui\serialui.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: serialui.h
//
// This files contains the shared prototypes and macros.
//
// History:
//  02-03-94 ScottH     Created
//
//---------------------------------------------------------------------------


#ifndef __SERIALUI_H__
#define __SERIALUI_H__

#define MAXPORTNAME     13
#define MAXFRIENDLYNAME LINE_LEN        // LINE_LEN is defined in setupx.h

// Internal structure shared between port property pages.
//
typedef struct _PORTINFO
    {
    UINT            uFlags;             // One of SIF_* values
    WIN32DCB        dcb;
    LPCOMMCONFIG    pcc;                // Read-only
    int             idRet;

    TCHAR            szFriendlyName[MAXFRIENDLYNAME];
    } PortInfo, FAR * LPPORTINFO;

// PortInfo Flags
#define SIF_FROM_DEVMGR         0x0001


extern LPGUID c_pguidModem;
extern LPGUID c_pguidPort;

//-------------------------------------------------------------------------
//  PORT.C
//-------------------------------------------------------------------------

INT_PTR CALLBACK Port_WrapperProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#endif // __SERIALUI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\serialui\util.h ===
//
// util.h: Declares data, defines and struct types for common code
//            module.
//
//

#ifndef __UTIL_H__
#define __UTIL_H__

#if defined(DEBUG) && defined(WIN95)
LPCTSTR PUBLIC Dbg_GetReterr(RETERR ret);
#endif 

//
// FINDDEV structure
//
typedef struct tagFINDDEV
    {
    HDEVINFO        hdi;
    SP_DEVINFO_DATA devData;
    HKEY            hkeyDrv;
    TCHAR           szPort[MAX_BUF_SHORT];
    } FINDEV, FAR * LPFINDDEV;

BOOL 
PUBLIC 
FindDev_Create(
    OUT LPFINDDEV FAR * ppfinddev,
    IN  LPGUID      pguidClass,
    IN  LPCTSTR     pszValueName,
    IN  LPCTSTR     pszValue);

BOOL 
PUBLIC 
FindDev_Destroy(
    IN LPFINDDEV this);


#endif // __UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\command.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    command.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"


#define  NONE_COMMAND                "None"
#define  NONE_COMMAND_LENGTH         (sizeof(NONE_COMMAND)-1)

#define  NORESPONSE_COMMAND          "NoResponse"
#define  NORESPONSE_COMMAND_LENGTH   (sizeof(NORESPONSE_COMMAND)-1)

#define  COMMAND_STATE_IDLE                    1
#define  COMMAND_STATE_WAIT_FOR_RESPONSE       2
#define  COMMAND_STATE_GET_NEXT_COMMAND        3
#define  COMMAND_STATE_SET_TIMER               4
#define  COMMAND_STATE_WRITE_COMMAND           5
#define  COMMAND_STATE_HANDLE_READ_COMPLETION  6
#define  COMMAND_STATE_COMPLETE_COMMAND        7



#define  COMMAND_OBJECT_SIG  (0x4f434d55)  //UMCO

BOOL WINAPI
StartCommandAsyncProcessing(
    PCOMMAND_STATE     CommandState
    );

VOID
CommandResultHandler(
    HANDLE      Context,
    DWORD       Status
    );


BOOL
UmWriteFile(
    HANDLE    FileHandle,
    HANDLE    OverlappedPool,
    PVOID     Buffer,
    DWORD     BytesToWrite,
    LPOVERLAPPED_COMPLETION_ROUTINE CompletionHandler,
    PVOID     Context
    )

{

    PUM_OVER_STRUCT   UmOverlapped;
    BOOL              bResult;

    UmOverlapped=AllocateOverStruct(OverlappedPool);

    if (UmOverlapped == NULL) {

        return FALSE;

    }

    UmOverlapped->Context1=Context;

    bResult=UnimodemWriteFileEx(
       FileHandle,
       Buffer,
       BytesToWrite,
       &UmOverlapped->Overlapped,
       CompletionHandler
       );

    if (!bResult && GetLastError() == ERROR_IO_PENDING) {


        bResult=TRUE;

    }

    return bResult;

}

VOID
CommandObjectClose(
    POBJECT_HEADER  Object
    )

{
    PCOMMAND_STATE        CommandState=(PCOMMAND_STATE)Object;

    D_INIT(UmDpf(CommandState->Debug,"CommandObjectClose ref=%d",CommandState->Header.ReferenceCount);)

    PurgeComm(
        CommandState->FileHandle,
        PURGE_TXABORT | PURGE_TXCLEAR
        );


    return;

}




VOID
CommandObjectCleanUp(
    POBJECT_HEADER  Object
    )

{
    PCOMMAND_STATE        CommandState=(PCOMMAND_STATE)Object;

    D_INIT(UmDpf(CommandState->Debug,"CommandObjectCleanup");)


    if (CommandState->TimerHandle != NULL) {

        FreeUnimodemTimer(
            CommandState->TimerHandle
            );
    }


    return;

}




POBJECT_HEADER WINAPI
InitializeCommandObject(
    POBJECT_HEADER     OwnerObject,
    HANDLE             FileHandle,
    HANDLE             CompletionPort,
    POBJECT_HEADER     ResponseObject,
    OBJECT_HANDLE      Debug
    )

{

    PCOMMAND_STATE        CommandState;
    OBJECT_HANDLE         ObjectHandle;

    ObjectHandle=CreateObject(
        sizeof(*CommandState),
        OwnerObject,
        COMMAND_OBJECT_SIG,
        CommandObjectCleanUp,
        CommandObjectClose
        );

    if (ObjectHandle == NULL) {

        return NULL;
    }

    CommandState=(PCOMMAND_STATE)ReferenceObjectByHandle(ObjectHandle);

    CommandState->State=COMMAND_STATE_IDLE;
    CommandState->FileHandle=FileHandle;
    CommandState->CompletionPort=CompletionPort;

    CommandState->ResponseObject=ResponseObject;

    CommandState->Debug=Debug;

    //
    //  create a timer
    //
    CommandState->TimerHandle=CreateUnimodemTimer(CompletionPort);

    if (CommandState->TimerHandle == NULL) {
        //
        //  could not get a time, close the handle to the object
        //
        CloseObjectHandle(ObjectHandle,NULL);

        ObjectHandle=NULL;

    }

    //
    //  done accessing the object
    //
    RemoveReferenceFromObject(&CommandState->Header);


    return ObjectHandle;

}




VOID
WriteCompletionHandler(
    DWORD              Error,
    DWORD              BytesWritten,
    LPOVERLAPPED       Overlapped
    )

{
    PUM_OVER_STRUCT    UmOverlapped=(PUM_OVER_STRUCT)Overlapped;

    PCOMMAND_STATE     CommandState=(PCOMMAND_STATE)UmOverlapped->Context1;

    D_TRACE(UmDpf(CommandState->Debug,"Write Complete\n");)

    if (Error != ERROR_SUCCESS) {

        LogString(CommandState->Debug, IDS_WRITEFAILED, Error);
    }

#if DBG
    InterlockedDecrement(&CommandState->OutStandingWrites);
#endif

    RemoveReferenceFromObject(
        &CommandState->Header
        );

    FreeOverStruct(UmOverlapped);

    return;

}


BOOL
DoStringsMatch(
    LPCSTR     String1,
    LPCSTR     String2,
    ULONG     Length
    )

{
    BOOL      ReturnValue=TRUE;

    CHAR      Char1;
    CHAR      Char2;

    while (Length > 0) {

        Char1=*String1;
        Char2=*String2;

        if ((Char1 != '\0') && (Char2 != '\0')) {

            if (toupper(Char1) != toupper(Char2)) {

                return FALSE;
            }

        } else {
            //
            //  got to null in one of the strings, are they both null?
            //
            ReturnValue = (Char1 == Char2 );
            break;
        }

        String1++;
        String2++;
        Length--;
    }

    //
    //
    return ReturnValue;
}



VOID WINAPI
CommandTimerHandler(
    HANDLE              Context,
    HANDLE              Context2
    )

{
    PCOMMAND_STATE     CommandState=(PCOMMAND_STATE)Context;

    CommandResultHandler(
        CommandState,
        ERROR_SUCCESS
        );

    return;

}


VOID
CommandResultHandler(
    HANDLE      Context,
    DWORD       Status
    )
{

    PCOMMAND_STATE     CommandState;

    BOOL              bResult;
    PUCHAR            NextCommand;
    BOOL              ExitLoop=FALSE;


//    D_TRACE(DebugPrint("UNIMDMAT: Command Result\n");)

    CommandState=(PCOMMAND_STATE)Context;

    AddReferenceToObject(
        &CommandState->Header
        );


    while (!ExitLoop) {

        switch (CommandState->State) {

            case  COMMAND_STATE_GET_NEXT_COMMAND:

                if (CommandState->CurrentCommand == NULL) {
                    //
                    //  first command
                    //
                    CommandState->CurrentCommand=CommandState->Commands;

                } else {
                    //
                    //  get next command
                    //
                    CommandState->CurrentCommand=CommandState->CurrentCommand+lstrlenA(CommandState->CurrentCommand)+1;
                }

                if ((*CommandState->CurrentCommand != '\0')
                    &&
                    (!DoStringsMatch(CommandState->CurrentCommand,NONE_COMMAND,NONE_COMMAND_LENGTH) )) {
                    //
                    //  not empty string, and not "None"
                    //
                    ExpandMacros(
                        CommandState->CurrentCommand,
                        CommandState->ExpandedCommand,
                        &CommandState->ExpandedCommandLength,
                        NULL,
                        0);

                    CommandState->State=COMMAND_STATE_SET_TIMER;

                } else {
                    //
                    //  Done sending commands, send async completion
                    //
                    CommandState->State=COMMAND_STATE_COMPLETE_COMMAND;

                    break;
                }
                break;

            case COMMAND_STATE_SET_TIMER:

                AddReferenceToObject(
                    &CommandState->Header
                    );

                SetUnimodemTimer(
                    CommandState->TimerHandle,
                    10,
                    CommandTimerHandler,
                    CommandState,
                    NULL
                    );

                CommandState->State=COMMAND_STATE_WRITE_COMMAND;
                ExitLoop=TRUE;

                break;

            case COMMAND_STATE_WRITE_COMMAND: {

                BOOL   NextCommandIsNoResponse;

                //
                //  remove ref for timer
                //
                RemoveReferenceFromObject(
                    &CommandState->Header
                    );

                NextCommand=CommandState->CurrentCommand+lstrlenA(CommandState->CurrentCommand)+1;

                NextCommandIsNoResponse=DoStringsMatch(NextCommand,NORESPONSE_COMMAND,NORESPONSE_COMMAND_LENGTH);

                if (!NextCommandIsNoResponse) {
                    //
                    //  register a callback with the response engine
                    //
                    AddReferenceToObject(
                        &CommandState->Header
                        );

                    RegisterCommandResponseHandler(
                        CommandState->ResponseObject,
                        CommandState->ExpandedCommand,
                        CommandResultHandler,
                        Context,
                        CommandState->Timeout,
                        *NextCommand == '\0' ?  CommandState->Flags :  CommandState->Flags & ~(RESPONSE_FLAG_STOP_READ_ON_GOOD_RESPONSE | RESPONSE_FLAG_ONLY_CONNECT | RESPONSE_FLAG_ONLY_CONNECT_SUCCESS)
                        );

                }



                PrintString(
                    CommandState->Debug,
                    CommandState->ExpandedCommand,
                    CommandState->ExpandedCommandLength,
                    (CommandState->Flags & RESPONSE_DO_NOT_LOG_NUMBER) ? PS_SEND_SECURE : PS_SEND
                    );

                //
                //  add ref for write
                //
                AddReferenceToObject(
                    &CommandState->Header
                    );

#if DBG
                CommandState->TimeLastCommandSent=GetTickCount();
#endif

                D_TRACE(UmDpf(CommandState->Debug,"Written %d bytes\n",lstrlenA(CommandState->ExpandedCommand));)
                D_TRACE(UmDpf(CommandState->Debug,"Sent: %s\n",CommandState->ExpandedCommand);)

                bResult=UmWriteFile(
                    CommandState->FileHandle,
                    CommandState->CompletionPort,
                    CommandState->ExpandedCommand,
                    lstrlenA(CommandState->ExpandedCommand), //CommandState->ExpandedCommandLength,
                    WriteCompletionHandler,
                    CommandState
                    );

                if (!bResult) {
                    //
                    //  write failed
                    //
//                    RegisterCommandResponseHandler(
//                        CommandState->ResponseObject,
//                        NULL,
//                        NULL,
//                        NULL,
//                        0,
//                        0
//                        );

                    //
                    //  for failed write
                    //
                    RemoveReferenceFromObject(
                        &CommandState->Header
                        );
                } else {
#if DBG
                    InterlockedIncrement(&CommandState->OutStandingWrites);
#endif
                }

                if (NextCommandIsNoResponse) {
                    //
                    //  next command is no response, just complete the command now
                    //
                    if (CommandState->Flags & RESPONSE_FLAG_STOP_READ_ON_CONNECT) {

                        StopResponseEngine(
                            CommandState->ResponseObject,
                            NULL
                            );
                    }

                    CommandState->State=COMMAND_STATE_COMPLETE_COMMAND;
                    break;

                }

                CommandState->State=COMMAND_STATE_HANDLE_READ_COMPLETION;
                ExitLoop=TRUE;

                break;
            }

            case COMMAND_STATE_HANDLE_READ_COMPLETION:

#if DBG
                D_TRACE(UmDpf(CommandState->Debug,"CommandResultHandler: Response took  %d ms",GetTickCount()-CommandState->TimeLastCommandSent);)
#endif
                //
                //  remove ref for the read callback
                //
                RemoveReferenceFromObject(
                    &CommandState->Header
                    );

                if (Status == ERROR_SUCCESS) {
                    //
                    //  send the next command
                    //
                    CommandState->State=COMMAND_STATE_GET_NEXT_COMMAND;

                    break;
                }

                if (Status == ERROR_UNIMODEM_RESPONSE_TIMEOUT) {
                    //
                    //  we did not get a response, purge the transmit incase the serial
                    //  driver can't send the characters out, such as flow control off
                    //
                    PurgeComm(
                        CommandState->FileHandle,
                        PURGE_TXABORT | PURGE_TXCLEAR
                        );

                }

                //
                //  failed, complete it with the current status
                //
                CommandState->State=COMMAND_STATE_COMPLETE_COMMAND;

                break;


            case COMMAND_STATE_COMPLETE_COMMAND: {

                //
                //  done
                //
                COMMANDRESPONSE       *CompletionHandler=CommandState->CompletionHandler;

                CommandState->CompletionHandler=NULL;

                CommandState->State=COMMAND_STATE_IDLE;
#if 1
                CommandState->Commands=NULL;

                CommandState->CurrentCommand=NULL;
#endif

                (*CompletionHandler)(
                    CommandState->CompletionContext,
                    Status
                    );

                ExitLoop=TRUE;
                break;
            }

            default:

                ASSERT(0);
                break;
        }
    }

    RemoveReferenceFromObject(
        &CommandState->Header
        );

    return;
}



LONG WINAPI
IssueCommand(
    OBJECT_HANDLE      ObjectHandle,
    LPSTR              Command,
    COMMANDRESPONSE   *CompletionHandler,
    HANDLE             CompletionContext,
    DWORD              Timeout,
    DWORD              Flags
    )

{

    PCOMMAND_STATE    CommandState;

    BOOL              ResponseRunning;
    BOOL              bResult;
    LONG              lResult=ERROR_IO_PENDING;

    CommandState=(PCOMMAND_STATE)ReferenceObjectByHandle(ObjectHandle);

    ResponseRunning=IsResponseEngineRunning(
        CommandState->ResponseObject
        );

    if (ResponseRunning) {
        //
        //  The response engine is ready to go
        //
        CommandState->CompletionHandler=CompletionHandler;

        CommandState->CompletionContext=CompletionContext;

        CommandState->Timeout=Timeout;

        CommandState->Flags=Flags;

        ASSERT(Command != NULL);

        CommandState->Commands=Command;

        CommandState->CurrentCommand=NULL;


        ASSERT(COMMAND_STATE_IDLE == CommandState->State);

        CommandState->State=COMMAND_STATE_GET_NEXT_COMMAND;

        //
        //  queue a call to the result handler to get things going
        //
        bResult=StartCommandAsyncProcessing(CommandState);

        if (!bResult) {
            //
            //  failed to get started
            //
            CommandState->State=COMMAND_STATE_IDLE;

            CommandState->CompletionHandler=NULL;

            lResult=ERROR_NOT_ENOUGH_MEMORY;
        }

    } else {
        //
        //  response engine is not running
        //
        D_ERROR(UmDpf(CommandState->Debug,"IssueCommand: Response Engine not running");)

        lResult=ERROR_NOT_READY;
    }

    //
    //  remove the opening ref
    //
    RemoveReferenceFromObject(
        &CommandState->Header
        );

    return lResult;

}







VOID  WINAPI
CommandAsyncProcessingHandler(
    DWORD              ErrorCode,
    DWORD              Bytes,
    LPOVERLAPPED       dwParam
    )

{
    PUM_OVER_STRUCT    UmOverlapped=(PUM_OVER_STRUCT)dwParam;
    COMMANDRESPONSE   *Handler;

    PCOMMAND_STATE     CommandState=(PCOMMAND_STATE)UmOverlapped->Context2;

    Handler=UmOverlapped->Context1;

    (*Handler)(
        UmOverlapped->Context2,
        (DWORD)UmOverlapped->Overlapped.Internal
        );

    FreeOverStruct(UmOverlapped);

    RemoveReferenceFromObject(
        &CommandState->Header
        );


    return;

}





BOOL WINAPI
StartCommandAsyncProcessing(
    PCOMMAND_STATE     CommandState
    )

{
    BOOL               bResult;

    PUM_OVER_STRUCT UmOverlapped;

    UmOverlapped=AllocateOverStruct(CommandState->CompletionPort);

    if (UmOverlapped == NULL) {

        return FALSE;
    }

    UmOverlapped->Context1=CommandResultHandler;

    UmOverlapped->Context2=CommandState;

    UmOverlapped->Overlapped.Internal=ERROR_SUCCESS;

    AddReferenceToObject(
        &CommandState->Header
        );


    bResult=UnimodemQueueUserAPC(
        &UmOverlapped->Overlapped,
        CommandAsyncProcessingHandler
        );

    if (!bResult) {

        RemoveReferenceFromObject(
            &CommandState->Header
            );

        FreeOverStruct(UmOverlapped);
    }

    return bResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\serialui\util.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1996
//
// File: util.c
//
//  This files contains all common utility routines
//
// History:
//  12-23-93 ScottH     Created
//  09-22-95 ScottH     Ported to NT
//
//---------------------------------------------------------------------------

#include "proj.h"     // common headers


//-----------------------------------------------------------------------------------
//  Wrapper that finds a device instance
//-----------------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Enumerates the HKEY_LOCAL_MACHINE branch and finds the
         device matching the given class and value.  If there
         are duplicate devices that match both criteria, only the
         first device is returned. 

         Returns TRUE if the device was found.

Returns: see above
Cond:    --
*/
BOOL 
PRIVATE 
FindDev_Find(
    IN  LPFINDDEV   pfinddev,
    IN  LPGUID      pguidClass,         OPTIONAL
    IN  LPCTSTR     pszValueName,
    IN  LPCTSTR     pszValue)
    {
    BOOL bRet = FALSE;
    TCHAR szKey[MAX_BUF];
    TCHAR szName[MAX_BUF];
    HDEVINFO hdi;
	DWORD dwRW = KEY_READ;

    ASSERT(pfinddev);
    ASSERT(pszValueName);
    ASSERT(pszValue);

	if (USER_IS_ADMIN()) dwRW |= KEY_WRITE;

    // (scotth): hack to support no device instances because
    // ports do not have a class GUID.  This should be fixed after SUR.

    // Is there a class GUID?
    if (pguidClass)
        {
        // Yes; use it
        hdi = CplDiGetClassDevs(pguidClass, NULL, NULL, 0);
        if (INVALID_HANDLE_VALUE != hdi)
            {
            SP_DEVINFO_DATA devData;
            DWORD iIndex = 0;
            HKEY hkey;

            // Look for the modem that has the matching value
            devData.cbSize = sizeof(devData);
            while (CplDiEnumDeviceInfo(hdi, iIndex, &devData))
                {
                hkey = CplDiOpenDevRegKey(hdi, &devData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, dwRW);
                if (INVALID_HANDLE_VALUE != hkey)
                    {
                    // Does the value match?
                    DWORD cbData = sizeof(szName);
                    if (NO_ERROR == RegQueryValueEx(hkey, pszValueName, NULL, NULL, 
                                                    (LPBYTE)szName, &cbData) &&
                        IsSzEqual(pszValue, szName))
                        {
                        // Yes
                        pfinddev->hkeyDrv = hkey;
                        pfinddev->hdi = hdi;
                        BltByte(&pfinddev->devData, &devData, sizeof(devData));

                        // Don't close the driver key or free the DeviceInfoSet, 
                        // but exit
                        bRet = TRUE;
                        break;
                        }
                    RegCloseKey(hkey);
                    }

                iIndex++;
                }

            // Free the DeviceInfoSet if nothing was found.  Otherwise, we will
            // retain these handles so the caller can make use of this.
            if ( !bRet )
                {
                CplDiDestroyDeviceInfoList(hdi);
                }
            }
        }
    else
        {
        // No; HACK ALERT!  Hmm, it must be a port class in SUR.
#pragma data_seg(DATASEG_READONLY)
        static TCHAR const FAR c_szSerialComm[] = TEXT("HARDWARE\\DEVICEMAP\\SERIALCOMM");
#pragma data_seg()

        HKEY hkeyEnum;
        DWORD iSubKey;
        TCHAR szName2[MAX_BUF];
        DWORD cbName;
        DWORD cbData;
        DWORD dwType;
        DWORD dwRet;

        dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, c_szSerialComm, &hkeyEnum);
        if (NO_ERROR == dwRet)
            {
            ZeroInit(pfinddev);

            iSubKey = 0;

            cbName = sizeof(szName2) / sizeof(TCHAR);
            cbData = sizeof(pfinddev->szPort) / sizeof(TCHAR);

            while (NO_ERROR == RegEnumValue(hkeyEnum, iSubKey++, szName2, 
                                            &cbName, NULL, &dwType, 
                                            (LPBYTE)pfinddev->szPort, &cbData))
                {
                if (REG_SZ == dwType &&
                    0 == lstrcmpi(pfinddev->szPort, pszValue))
                    {
                    bRet = TRUE;
                    break;
                    }

                cbName = sizeof(szName2);
                cbData = sizeof(pfinddev->szPort);
                }
            RegCloseKey(hkeyEnum);
            }
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Creates a FINDDEV structure given the device class,
         and a valuename and its value.

Returns: TRUE if the device is found in the system

Cond:    --
*/
BOOL 
PUBLIC 
FindDev_Create(
    OUT LPFINDDEV FAR * ppfinddev,
    IN  LPGUID      pguidClass,         OPTIONAL
    IN  LPCTSTR     pszValueName,
    IN  LPCTSTR     pszValue)
    {
    BOOL bRet;
    LPFINDDEV pfinddev;

    DEBUG_CODE( TRACE_MSG(TF_FUNC, " > FindDev_Create(....%s, %s, ...)",
                Dbg_SafeStr(pszValueName), Dbg_SafeStr(pszValue)); )

    ASSERT(ppfinddev);
    ASSERT(pszValueName);
    ASSERT(pszValue);

    pfinddev = (LPFINDDEV)LocalAlloc(LPTR, sizeof(*pfinddev));
    if (NULL == pfinddev)
        {
        bRet = FALSE;
        }
    else
        {
        bRet = FindDev_Find(pfinddev, pguidClass, pszValueName, pszValue);

        if (FALSE == bRet)
            {
            // Didn't find anything 
            FindDev_Destroy(pfinddev);
            pfinddev = NULL;
            }
        }

    *ppfinddev = pfinddev;

    DBG_EXIT_BOOL(FindDev_Create, bRet);

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Destroys a FINDDEV structure

Returns: TRUE on success
Cond:    --
*/
BOOL 
PUBLIC 
FindDev_Destroy(
    IN LPFINDDEV this)
    {
    BOOL bRet;

    if (NULL == this)
        {
        bRet = FALSE;
        }
    else
        {
        if (this->hkeyDrv)
            RegCloseKey(this->hkeyDrv);

        if (this->hdi && INVALID_HANDLE_VALUE != this->hdi)
            CplDiDestroyDeviceInfoList(this->hdi);

        LocalFreePtr(this);

        bRet = TRUE;
        }

    return bRet;
    }


//-----------------------------------------------------------------------------------
//  Debug functions
//-----------------------------------------------------------------------------------


#ifdef DEBUG

#pragma data_seg(DATASEG_READONLY)

#ifdef WIN95
struct _RETERRMAP
    {
    RETERR ret;
    LPCTSTR psz;
    } const c_rgreterrmap[] = {
        { NO_ERROR,                                    "NO_ERROR" },
        { DI_ERROR,                              "DI_ERROR" },
        { ERR_DI_INVALID_DEVICE_ID,              "ERR_DI_INVALID_DEVICE_ID" },
        { ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST, "ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST" },
        { ERR_DI_REG_API,                        "ERR_DI_REG_API" },
        { ERR_DI_LOW_MEM,                        "ERR_DI_LOW_MEM" },
        { ERR_DI_BAD_DEV_INFO,                   "ERR_DI_BAD_DEV_INFO" },
        { ERR_DI_INVALID_CLASS_INSTALLER,        "ERR_DI_INVALID_CLASS_INSTALLER" },
        { ERR_DI_DO_DEFAULT,                     "ERR_DI_DO_DEFAULT" },
        { ERR_DI_USER_CANCEL,                    "ERR_DI_USER_CANCEL" },
        { ERR_DI_NOFILECOPY,                     "ERR_DI_NOFILECOPY" },
        { ERR_DI_BAD_CLASS_INFO,                 "ERR_DI_BAD_CLASS_INFO" },
    };
#endif

#pragma data_seg()

#ifdef WIN95
/*----------------------------------------------------------
Purpose: Returns the string form of a RETERR.

Returns: String ptr
Cond:    --
*/
LPCTSTR PUBLIC Dbg_GetReterr(
    RETERR ret)
    {
    int i;

    for (i = 0; i < ARRAY_ELEMENTS(c_rgreterrmap); i++)
        {
        if (ret == c_rgreterrmap[i].ret)
            return c_rgreterrmap[i].psz;
        }
    return "Unknown RETERR";
    }
#endif // WIN95

#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\command.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    command.h

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/


POBJECT_HEADER WINAPI
InitializeCommandObject(
    POBJECT_HEADER     OwnerObject,
    HANDLE             FileHandle,
    HANDLE             CompletionPort,
    POBJECT_HEADER     ResponseObject,
    OBJECT_HANDLE      Debug
    );


LONG WINAPI
IssueCommand(
    OBJECT_HANDLE      ObjectHandle,
    LPSTR              Command,
    COMMANDRESPONSE   *CompletionHandler,
    HANDLE             CompletionContext,
    DWORD              Timeout,
    DWORD              Flags
    );


BOOL
UmWriteFile(
    HANDLE    FileHandle,
    HANDLE    OverlappedPool,
    PVOID     Buffer,
    DWORD     BytesToWrite,
    LPOVERLAPPED_COMPLETION_ROUTINE CompletionHandler,
    PVOID     Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\common.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    openclos.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"




BOOL WINAPI
InitializeModemCommonList(
    PCOMMON_MODEM_LIST    CommonList
    )

{
    D_TRACE(DebugPrint("InitializeModemCommonList");)

    CommonList->ListHead=NULL;

    InitializeCriticalSection(
        &CommonList->CriticalSection
        );

    return TRUE;

}

VOID WINAPI
RemoveCommonList(
    PCOMMON_MODEM_LIST    CommonList
    )

{

    EnterCriticalSection(&CommonList->CriticalSection);

    //
    //  we go through the list removing the final reference count from the modem
    //
    while (CommonList->ListHead != NULL) {
        //
        //  The call to RemoveReferenceToCommon() will change CommonList->ListHead
        //  so this is not an infinite loop
        //
        ASSERT(CommonList->ListHead->Reference == 1);

        RemoveReferenceToCommon(
            CommonList,
            CommonList->ListHead
            );

    }

    LeaveCriticalSection(&CommonList->CriticalSection);

    DeleteCriticalSection(&CommonList->CriticalSection);

    return;

}

PSTR WINAPI
LoadDialElement(
    HKEY     hKey,
    LPCSTR     SubKeyName
    )

{

    CHAR     szTemp[MAX_PATH];
    CHAR     szTemp2[MAX_PATH];
    DWORD    dwSize;
    DWORD    dwType;
    LONG     Result;
    PSTR     StringToReturn;

    dwSize=sizeof(szTemp);

    Result=RegQueryValueExA(
        hKey,
        SubKeyName,
        NULL,
        &dwType,
        (VOID *)szTemp,
        &dwSize
        );

    if (Result != ERROR_SUCCESS || dwType != REG_SZ || dwSize == 0) {

        return NULL;
    }

    ExpandMacros(szTemp, szTemp2, NULL, NULL, 0);

    StringToReturn=ALLOCATE_MEMORY(lstrlenA(szTemp2) + 1);

    if (StringToReturn) lstrcpyA(StringToReturn,szTemp2);

    return StringToReturn;

}




COMMON_MODEM_LIST    gCommonList;

CONST CHAR szAnswer[] = "Answer";
CONST CHAR szMonitor[]= "Monitor";
CONST CHAR szInit[]   = "Init";
CONST CHAR szHangup[] = "Hangup";

CONST CHAR szSettings[] = "Settings";

CONST CHAR DialComponents[COMMON_DIAL_MAX_INDEX+1][20] =
                                    { {"Prefix"},
                                      {"DialPrefix"},
                                      {"Blind_On"},
                                      {"Blind_Off"},
                                      {"Tone"},
                                      {"Pulse"},
                                      {"DialSuffix"},
                                      {"Terminator"}};

const CHAR  VoiceCommands[COMMON_MAX_COMMANDS-COMMON_FIRST_VOICE_COMMAND][30] = {
                 {"EnableCallerID"},
                 {"EnableDistinctiveRing"},
                 {"VoiceDialNumberSetup"},
                 {"AutoVoiceDialNumberSetup"},
                 {"VoiceAnswer"},
                 {"GenerateDigit"},
                 {"SpeakerPhoneEnable"},
                 {"SpeakerPhoneDisable"},
                 {"SpeakerPhoneMute"},
                 {"SpeakerPhoneUnMute"},
                 {"SpeakerPhoneSetVolumeGain"},
                 {"VoiceHangup"},
                 {"VoiceToDataAnswer"},
                 {"StartPlay"},
                 {"StopPlay"},
                 {"StartRecord"},
                 {"StopRecord"},
                 {"LineSetPlayFormat"},
                 {"LineSetRecordFormat"},
                 {"StartDuplex"},
                 {"StopDuplex"},
                 {"LineSetDuplexFormat"},
                 {"OpenHandset"},
                 {"CloseHandset"},
                 {"HandsetSetPlayFormat"},
                 {"HandsetSetRecordFormat"},
                 {"HandsetSetDuplexFormat"},
                 {"OptionalInit"}
                 };

PVOID WINAPI
OpenCommonModemInfo(
    OBJECT_HANDLE         Debug,
    PCOMMON_MODEM_LIST    CommonList,
    HKEY    hKey
    )

{

    CHAR    IdString[MAX_PATH];
    DWORD   dwRetSize;
    LONG    Result;
    DWORD   dwType;
    PCOMMON_MODEM_INFO   pCommon;
    HKEY                 hSettingsKey;
    UINT                 i;

    dwRetSize = MAX_PATH;

    //
    //  get the inf file name from the registry
    //
    Result=RegQueryValueExA(
        hKey,
        "InfPath",
        NULL,
        &dwType,
        (VOID *)IdString,
        &dwRetSize
        );


    if (ERROR_SUCCESS != Result) {

        return NULL;
    }

    if (dwType != REG_SZ) 
    {
        return NULL;
    }

    lstrcatA(IdString,"\\");

    dwRetSize = MAX_PATH - lstrlenA(IdString);

    //
    //  get the inf section name from the registry
    //
    Result=RegQueryValueExA(
        hKey,
        "InfSection",
        NULL,
        &dwType,
        (VOID *)&IdString[lstrlenA(IdString)],
        &dwRetSize
        );

    if (ERROR_SUCCESS != Result) {

        return NULL;
    }

    if (dwType != REG_SZ)
    {

        return NULL;
    }

    //
    //  the name is now "inf-name\inf-section"
    //
    D_TRACE(DebugPrint("Common modem info name is %s",IdString);)



    //
    //  see if this one is already around
    //
    EnterCriticalSection(&CommonList->CriticalSection);

    pCommon=CommonList->ListHead;

    while (pCommon != NULL) {

        if (lstrcmpA(IdString, pCommon->IdString) == 0) {
            //
            //  found, up the ref count and return
            //
            pCommon->Reference++;

            D_TRACE(DebugPrint("Found Common modem info Match, ref=%d",pCommon->Reference);)

            LeaveCriticalSection(&CommonList->CriticalSection);

            return pCommon;
        }

        pCommon=pCommon->Next;
    }


    //
    //  did not find it on the list, need to build a new one
    //
    pCommon=ALLOCATE_MEMORY(sizeof(COMMON_MODEM_INFO));

    if (pCommon == NULL) {

        LeaveCriticalSection(&CommonList->CriticalSection);

        return NULL;
    }

    ZeroMemory(pCommon,sizeof(COMMON_MODEM_INFO));

    lstrcpyA(pCommon->IdString, IdString);


    D_TRACE(DebugPrint("Creating new Common modem info");)


    //
    //  build the response list
    //
    pCommon->ResponseList=NewerBuildResponsesLinkedList(hKey);

    if (pCommon->ResponseList == NULL) {

        D_TRACE(DebugPrint("Could not build response list");)
        LogString(Debug, IDS_NO_RESPONSES);
        goto Fail;
    }

    //
    //  get statis init string
    //
    pCommon->ModemCommands[COMMON_INIT_COMMANDS]=NewLoadRegCommands(hKey, szInit);

    if (pCommon->ModemCommands[COMMON_INIT_COMMANDS] == NULL) {

        D_TRACE(DebugPrint("Could not load init string");)
        LogString(Debug, IDS_MISSING_COMMAND, szInit);
        goto Fail;
    }

    //
    //  get monitor string
    //
    pCommon->ModemCommands[COMMON_MONITOR_COMMANDS]=NewLoadRegCommands(hKey, szMonitor);

    if (pCommon->ModemCommands[COMMON_MONITOR_COMMANDS] == NULL) {

        D_TRACE(DebugPrint("Could not load Monitor string");)
        LogString(Debug, IDS_MISSING_COMMAND, szMonitor);
        goto Fail;
    }

    //
    //  get answer string
    //
    pCommon->ModemCommands[COMMON_ANSWER_COMMANDS]=NewLoadRegCommands(hKey, szAnswer);

    if (pCommon->ModemCommands[COMMON_ANSWER_COMMANDS] == NULL) {

        D_TRACE(DebugPrint("Could not Load Answer string");)
        LogString(Debug, IDS_MISSING_COMMAND, szAnswer);
        goto Fail;
    }
#if 1
    //
    //  get hangup string
    //
    pCommon->ModemCommands[COMMON_HANGUP_COMMANDS]=NewLoadRegCommands(hKey, szHangup);

    if (pCommon->ModemCommands[COMMON_HANGUP_COMMANDS] == NULL) {

        D_TRACE(DebugPrint("Could not load hangup string");)
//        goto Fail;
    }
#endif

    for (i=COMMON_FIRST_VOICE_COMMAND; i < COMMON_MAX_COMMANDS; i++) {

        pCommon->ModemCommands[i]=NewLoadRegCommands(hKey, VoiceCommands[i-COMMON_FIRST_VOICE_COMMAND]);

        if (pCommon->ModemCommands[i] == NULL) {

            D_TRACE(DebugPrint("Could not load %s string",VoiceCommands[i-COMMON_FIRST_VOICE_COMMAND]);)
        }
    }





    if (RegOpenKeyA(hKey, szSettings, &hSettingsKey)==ERROR_SUCCESS) {

        for (i=0; i<COMMON_DIAL_MAX_INDEX+1; i++) {

            pCommon->DialComponents[i]=LoadDialElement(hSettingsKey,
						       DialComponents[i]);
            D_TRACE(if (pCommon->DialComponents[i] == NULL) {
                       DebugPrint("Could not load %s",
                              DialComponents[i]);
                    }
            )
        }

        RegCloseKey(hSettingsKey);
    }


    //
    //  set the reference count to 2 here so that when the modem is closed
    //  the common block will stick around until explicitly freed
    //
    pCommon->Reference=2;

    pCommon->Next=CommonList->ListHead;

    CommonList->ListHead=pCommon;

    LeaveCriticalSection(&CommonList->CriticalSection);

    return pCommon;

Fail:

    //
    //  free any dial commands we loaded
    //
    for (i=0; i<COMMON_DIAL_MAX_INDEX+1; i++) {

        if (pCommon->DialComponents[i] != NULL) {

            FREE_MEMORY(pCommon->DialComponents[i]);
        }
    }

    //
    //  free and modem commands that we loaded
    //
    for (i=0; i<COMMON_MAX_COMMANDS; i++) {

        if (pCommon->ModemCommands[i] != NULL) {

            FREE_MEMORY(pCommon->ModemCommands[i]);
        }
    }


    //
    //  get rid of the response list if we got it
    //
    if (pCommon->ResponseList != NULL) {

        FreeResponseMatch(pCommon->ResponseList);
    }



    FREE_MEMORY(pCommon);
    pCommon = NULL;

    LeaveCriticalSection(&CommonList->CriticalSection);

    return NULL;
}



VOID WINAPI
RemoveReferenceToCommon(
    PCOMMON_MODEM_LIST    CommonList,
    HANDLE                hCommon
    )

{
    PCOMMON_MODEM_INFO  pCommon=(PCOMMON_MODEM_INFO)hCommon;
    PCOMMON_MODEM_INFO  Current;
    PCOMMON_MODEM_INFO  Prev;
    UINT                i;

    ASSERT(pCommon != NULL);

    EnterCriticalSection(&CommonList->CriticalSection);

    pCommon->Reference--;

    if (pCommon->Reference > 0) {
        //
        //  not done with it yet
        //
        D_TRACE(DebugPrint("RemoveReferenceToCommon, ref=%d",
		       pCommon->Reference);)

        LeaveCriticalSection(&CommonList->CriticalSection);

        return;
    }

    //
    //  ref count is zero get rid of the common block
    //

    Prev=NULL;
    Current=CommonList->ListHead;

    while (Current != NULL) {

        if (Current == pCommon) {

            if (Prev == NULL) {

                CommonList->ListHead=Current->Next;

            } else {

                Prev->Next=Current->Next;
            }
            break;
        }

        Prev=Current;

        Current=Current->Next;

    }

    ASSERT(Current != NULL);

    LeaveCriticalSection(&CommonList->CriticalSection);

    D_TRACE(DebugPrint("RemoveReferenceToCommon, removing common, %s",
		   pCommon->IdString);)

    //
    //  free any dial commands we loaded
    //
    for (i=0; i<COMMON_DIAL_MAX_INDEX+1; i++) {

        if (pCommon->DialComponents[i] != NULL) {

            FREE_MEMORY(pCommon->DialComponents[i]);
        }
    }

    //
    //  free and modem commands that we loaded
    //
    for (i=0; i<COMMON_MAX_COMMANDS; i++) {

        if (pCommon->ModemCommands[i] != NULL) {

            FREE_MEMORY(pCommon->ModemCommands[i]);
        }
    }


    //
    //  get rid of the response list if we got it
    //
    if (pCommon->ResponseList != NULL) {

        FreeResponseMatch(pCommon->ResponseList);
    }



    FREE_MEMORY(pCommon);
    pCommon = NULL;

    return;
}




HANDLE WINAPI
GetCommonResponseList(
    HANDLE      hCommon
    )

{
    PCOMMON_MODEM_INFO  pCommon=(PCOMMON_MODEM_INFO)hCommon;

    return (HANDLE)pCommon->ResponseList;

}

#if 0
DWORD
_inline
GetMultiSZLength(
    PSTR    MultiSZ
    )

{
    PUCHAR  Temp;

    Temp=MultiSZ;

    while (1) {

        if (*Temp++ == '\0') {

            if (*Temp++ == '\0') {

                break;
            }
        }
    }

    return Temp-MultiSZ;

}
#endif

PSTR WINAPI
GetCommonCommandStringCopy(
    HANDLE      hCommon,
    UINT        Index,
    LPSTR       PrependStrings,
    LPSTR       AppendStrings
    )

{
    PCOMMON_MODEM_INFO pCommon=(PCOMMON_MODEM_INFO)hCommon;
    PSTR               Commands;
    PSTR               pTemp;
    ULONG_PTR          NewCommandLength;
    ULONG_PTR          AppendLength=0;
    ULONG_PTR          PrependLength=0;

    pTemp=pCommon->ModemCommands[Index];

    if (pTemp == NULL) {

        return NULL;

    }

    while (1) {

        if (*pTemp++ == '\0') {

            if (*pTemp++ == '\0') {

                break;
            }
        }
    }


    NewCommandLength=pTemp-pCommon->ModemCommands[Index];

    if (AppendStrings != NULL) {
        //
        //  strings to be appened
        //
        pTemp=AppendStrings;

        while (1) {

            if (*pTemp++ == '\0') {

                if (*pTemp++ == '\0') {

                    break;
                }
            }
        }

        AppendLength=pTemp-AppendStrings;
    }

    if (PrependStrings != NULL) {
        //
        //  strings to be appened
        //
        pTemp=PrependStrings;

        while (1) {

            if (*pTemp++ == '\0') {

                if (*pTemp++ == '\0') {

                    break;
                }
            }
        }

        PrependLength=pTemp-PrependStrings;
    }


    Commands=ALLOCATE_MEMORY((DWORD)(NewCommandLength+AppendLength+PrependLength));

    if (NULL == Commands) {

        D_TRACE(DebugPrint("GetCommonCommandStringCopy: Alloc failed");)

        return NULL;
    }


    CopyMemory(Commands,PrependStrings,PrependLength);

    if (PrependLength == 0) {

        PrependLength++;
    }

    CopyMemory(&Commands[PrependLength-1],pCommon->ModemCommands[Index],NewCommandLength);

    CopyMemory(&Commands[(PrependLength-1)+(NewCommandLength-1)],AppendStrings,AppendLength);

    return Commands;

}

BOOL WINAPI
IsCommonCommandSupported(
    HANDLE      hCommon,
    UINT        Index
    )

{
    PCOMMON_MODEM_INFO pCommon=(PCOMMON_MODEM_INFO)hCommon;

    return (pCommon->ModemCommands[Index] != NULL);
}


DWORD WINAPI
GetCommonDialComponent(
    HANDLE  hCommon,
    PSTR    DestString,
    DWORD   DestLength,
    DWORD   Index
    )

{
    PCOMMON_MODEM_INFO  pCommon=(PCOMMON_MODEM_INFO)hCommon;
    DWORD   Length;

    if (pCommon->DialComponents[Index] == NULL) {

        lstrcpyA(DestString,"");

        return 0;
    }

    Length=lstrlenA(pCommon->DialComponents[Index])+1;

    if (Length+1 > DestLength) {

        return 0;
    }

    lstrcpyA(
        DestString,
        pCommon->DialComponents[Index]
        );

    return Length;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\common.h ===
#define COMMON_INIT_COMMANDS                     0
#define COMMON_MONITOR_COMMANDS                  1
#define COMMON_ANSWER_COMMANDS                   2
#define COMMON_HANGUP_COMMANDS                   3

#define COMMON_FIRST_VOICE_COMMAND               4

#define COMMON_ENABLE_CALLERID_COMMANDS          4
#define COMMON_ENABLE_DISTINCTIVE_RING_COMMANDS  5
#define COMMON_VOICE_DIAL_SETUP_COMMANDS         6
#define COMMON_AUTOVOICE_DIAL_SETUP_COMMANDS     7
#define COMMON_VOICE_ANSWER_COMMANDS             8
#define COMMON_GENERATE_DIGIT                    9
#define COMMON_SPEAKERPHONE_ENABLE              10
#define COMMON_SPEAKERPHONE_DISABLE             11
#define COMMON_SPEAKERPHONE_MUTE                12
#define COMMON_SPEAKERPHONE_UNMUTE              13
#define COMMON_SPEAKERPHONE_VOLGAIN             14
#define COMMON_VOICE_HANGUP_COMMANDS            15
#define COMMON_VOICE_TO_DATA_ANSWER             16
#define COMMON_START_PLAY                       17
#define COMMON_STOP_PLAY                        18
#define COMMON_START_RECORD                     19
#define COMMON_STOP_RECORD                      20
#define COMMON_LINE_SET_PLAY_FORMAT             21
#define COMMON_LINE_SET_RECORD_FORMAT           22

#define COMMON_START_DUPLEX                     23
#define COMMON_STOP_DUPLEX                      24
#define COMMON_LINE_SET_DUPLEX_FORMAT           25

#define COMMON_OPEN_HANDSET                     26
#define COMMON_CLOSE_HANDSET                    27

#define COMMON_HANDSET_SET_PLAY_FORMAT             28
#define COMMON_HANDSET_SET_RECORD_FORMAT           29
#define COMMON_HANDSET_SET_DUPLEX_FORMAT           30

#define COMMON_OPTIONAL_INIT                       31

#define COMMON_MAX_COMMANDS     32




#define COMMON_DIAL_COMMOND_PREFIX      0
#define COMMON_DIAL_PREFIX              1
#define COMMON_DIAL_BLIND_ON            2
#define COMMON_DIAL_BLIND_OFF           3
#define COMMON_DIAL_TONE                4
#define COMMON_DIAL_PULSE               5
#define COMMON_DIAL_SUFFIX              6
#define COMMON_DIAL_TERMINATION         7

#define COMMON_DIAL_MAX_INDEX           COMMON_DIAL_TERMINATION

typedef struct _COMMON_MODEM_INFO {

    struct _COMMON_MODEM_INFO * Next;
    UINT                        Reference;

    CHAR                        IdString[MAX_PATH];

    PVOID                       ResponseList;

    PSTR                        ModemCommands[COMMON_MAX_COMMANDS];

    PSTR                        DialComponents[COMMON_DIAL_MAX_INDEX+1];

} COMMON_MODEM_INFO, *PCOMMON_MODEM_INFO;

typedef struct _COMMON_MODEM_LIST {

    PCOMMON_MODEM_INFO volatile ListHead;

    CRITICAL_SECTION            CriticalSection;

} COMMON_MODEM_LIST, *PCOMMON_MODEM_LIST;

extern COMMON_MODEM_LIST    gCommonList;


BOOL WINAPI
InitializeModemCommonList(
    PCOMMON_MODEM_LIST    CommonList
    );

VOID WINAPI
RemoveCommonList(
    PCOMMON_MODEM_LIST    CommonList
    );



PVOID WINAPI
OpenCommonModemInfo(
    OBJECT_HANDLE         Debug,
    PCOMMON_MODEM_LIST    CommonList,
    HKEY    hKey
    );

VOID WINAPI
RemoveReferenceToCommon(
    PCOMMON_MODEM_LIST    CommonList,
    HANDLE                hCommon
    );



HANDLE WINAPI
GetCommonResponseList(
    HANDLE      hCommon
    );

PSTR WINAPI
GetCommonCommandStringCopy(
    HANDLE      hCommon,
    UINT        Index,
    LPSTR       PrependStrings,
    LPSTR       AppendStrings
    );

DWORD WINAPI
GetCommonDialComponent(
    HANDLE  hCommon,
    PSTR    DestString,
    DWORD   DestLength,
    DWORD   Index
    );


BOOL WINAPI
IsCommonCommandSupported(
    HANDLE      hCommon,
    UINT        Index
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\debug.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    openclos.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"

#define LOGGING_ON  1


CONST CHAR UnicodeBOM[] = { 0xff, 0xfe };

VOID WINAPIV
DebugPrint(
    LPSTR    FormatString,
    ...
    )

{
    va_list        VarArg;
    CHAR           OutBuffer[1024];


    wsprintfA(
        OutBuffer,
        "UNIMDMAT: "
        );

    va_start(VarArg,FormatString);

    wvsprintfA(
        OutBuffer+lstrlenA(OutBuffer),
        FormatString,
        VarArg
        );

    lstrcatA(OutBuffer,"\n");

    OutputDebugStringA(OutBuffer);

    return;

}






#define MAX_LOG_SIZE  (128 * 1024)
#define LOG_TEMP_BUFFER_SIZE (4096)



VOID WINAPI
ResizeLogFile(
    HANDLE    FileHandle
    );


#define  DEBUG_OBJECT_SIG  ('BDMU')  //UMDB


typedef struct _DEBUG_OBJECT {

    OBJECT_HEADER         Header;

    HINSTANCE             ModuleHandle;

    HANDLE                LogFile;

    DWORD                 DeviceId;

    HKEY                  ModemRegKey;

    BOOL                  CurrentLoggingState;
    BOOL                  WorkstationMachine;

} DEBUG_OBJECT, *PDEBUG_OBJECT;


VOID
DebugObjectClose(
    POBJECT_HEADER  Object
    )

{

    return;

}




VOID
DebugObjectCleanUp(
    POBJECT_HEADER  Object
    )

{
    PDEBUG_OBJECT      DebugObject=(PDEBUG_OBJECT)Object;


    if (DebugObject->LogFile != NULL) {

        CloseHandle(
            DebugObject->LogFile
            );
    }


    return;

}





OBJECT_HANDLE WINAPI
InitializeDebugObject(
    POBJECT_HEADER     OwnerObject,
    HKEY               ModemRegKey,
    HINSTANCE          ModuleHandle,
    DWORD              DeviceId
    )

{

    PDEBUG_OBJECT      DebugObject;
    OBJECT_HANDLE      ObjectHandle;


    ObjectHandle=CreateObject(
        sizeof(DEBUG_OBJECT),
        OwnerObject,
        DEBUG_OBJECT_SIG,
        DebugObjectCleanUp,
        DebugObjectClose
        );

    if (ObjectHandle == NULL) {

        return NULL;
    }

    //
    //  reference the handle to get a pointer to the object
    //
    DebugObject=(PDEBUG_OBJECT)ReferenceObjectByHandle(ObjectHandle);


    //
    //  intialize the object
    //
    DebugObject->ModuleHandle=ModuleHandle;

    DebugObject->DeviceId=DeviceId;

    DebugObject->LogFile=NULL;

    DebugObject->ModemRegKey=ModemRegKey;

    DebugObject->CurrentLoggingState=0;

    DebugObject->WorkstationMachine= WinntIsWorkstation();


    CheckForLoggingStateChange(ObjectHandle);

    //
    //  release the reference to the object
    //
    RemoveReferenceFromObject(&DebugObject->Header);

    return ObjectHandle;

}


VOID WINAPIV
LogPrintf(
    OBJECT_HANDLE  Object,
    LPCSTR          FormatString,
    ...
    )

{
    DWORD          BytesWritten;
    BOOL           Result;
    va_list        VarArg;
    SYSTEMTIME     SysTime;
//  char           OutBuffer[1024];
    char           *OutBuffer;
    UNICODE_STRING UncBuffer;
    STRING         AnsiString;

    PDEBUG_OBJECT  DebugObject=(PDEBUG_OBJECT)ReferenceObjectByHandle(Object);

    if (DebugObject->LogFile == NULL) {

        RemoveReferenceFromObject(
            &DebugObject->Header
            );


        return;
    }

    _try {

        OutBuffer = (char *)_alloca(1024);

    } _except (EXCEPTION_EXECUTE_HANDLER) {

        return;
    }

    va_start(VarArg,FormatString);

    GetLocalTime(
        &SysTime
        );

    wsprintfA(
        OutBuffer,
        "%02d-%02d-%04d %02d:%02d:%02d.%03d - ",
        SysTime.wMonth,
        SysTime.wDay,
        SysTime.wYear,
        SysTime.wHour,
        SysTime.wMinute,
        SysTime.wSecond,
        SysTime.wMilliseconds
        );


    wvsprintfA(
        OutBuffer+lstrlenA(OutBuffer),
        FormatString,
        VarArg
        );

    RtlInitAnsiString(&AnsiString,OutBuffer);
    RtlAnsiStringToUnicodeString(&UncBuffer,&AnsiString,TRUE);

    Result=WriteFile(
           DebugObject->LogFile,
           UncBuffer.Buffer,
           UncBuffer.Length,
           &BytesWritten,
           NULL
           );

    RtlFreeUnicodeString(&UncBuffer);

#if DBG
    if (!Result) {

        UmDpf(Object,"Write to log failed.");
    }
#endif

    ResizeLogFile(
       DebugObject->LogFile
       );

    RemoveReferenceFromObject(
        &DebugObject->Header
        );

    return;


}




#if 0
VOID WINAPI
FlushLog(
    OBJECT_HANDLE  Object
    )

{

    PDEBUG_OBJECT  DebugObject=(PDEBUG_OBJECT)ReferenceObjectByHandle(Object);

    if (DebugObject->LogFile != NULL) {

        FlushFileBuffers(DebugObject->LogFile);
    }

    RemoveReferenceFromObject(
        &DebugObject->Header
        );


    return;

}
#endif

VOID WINAPI
CheckForLoggingStateChange(
    OBJECT_HANDLE  Object
    )

{

    PDEBUG_OBJECT  DebugObject=(PDEBUG_OBJECT)ReferenceObjectByHandleAndLock(Object);
    HKEY           ModemRegKey=DebugObject->ModemRegKey;

    CONST TCHAR szLogging[]     = TEXT("Logging");
    CONST TCHAR szLoggingPath[] = TEXT("LoggingPath");



    if (ModemRegKey != NULL) {

        TCHAR    FileName[256];

        LONG    lResult;
        DWORD   dwRetSize;
        DWORD   dwType;
        BOOL    bLogging=0;
        BOOL    UseLog;
        DWORD   dwBytesWritten = 0;
        //
        // Read the Logging line from the registry and turn on logging if it is present and set to 1.
        //
        dwRetSize = sizeof(BYTE);

        lResult = RegQueryValueEx(
            ModemRegKey,
            szLogging,
            NULL,
            &dwType,
            (LPSTR)&bLogging,
            &dwRetSize
            );

        if ((ERROR_SUCCESS != lResult) && (sizeof(BYTE) != dwRetSize)) {


            bLogging = 0;
        }

        //
        //  We will always create a log file one a workstation machine, and either
        //  append or overwrite depending on the registry setting
        //
        //  On server we create a log file or not depending on the registry setting.
        //
        UseLog=DebugObject->WorkstationMachine || (bLogging == LOGGING_ON);


        if (UseLog != DebugObject->CurrentLoggingState) {
            //
            //  state change
            //
            DebugObject->CurrentLoggingState=UseLog;

            if (DebugObject->LogFile != NULL) {
                //
                //  file is currently open
                //
                CloseHandle(DebugObject->LogFile);
                DebugObject->LogFile=NULL;
            }


            if (UseLog) {

                dwRetSize = sizeof(FileName);

                lResult=RegQueryValueEx(
                    ModemRegKey,
                    szLoggingPath,
                    NULL,
                    &dwType,
                    FileName,
                    &dwRetSize
                    );

                if ((lResult == ERROR_SUCCESS) && (dwType == REG_SZ)) {

                    DebugObject->LogFile=CreateFile(
                        FileName,
                        GENERIC_WRITE | GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        (bLogging != LOGGING_ON) ? CREATE_ALWAYS : OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

                    if (INVALID_HANDLE_VALUE == DebugObject->LogFile) {

                        DebugObject->LogFile=NULL;

                    } else {

                        if (bLogging != LOGGING_ON)
                        {
                            WriteFile(
                                    DebugObject->LogFile,
                                    UnicodeBOM,
                                    sizeof(UnicodeBOM),
                                    &dwBytesWritten,
                                    NULL);
                        } else
                        {
                            if (GetFileSize(DebugObject->LogFile,NULL) == 0)
                            {
                                WriteFile(
                                        DebugObject->LogFile,
                                        UnicodeBOM,
                                        sizeof(UnicodeBOM),
                                        &dwBytesWritten,
                                        NULL);
                            } else
                            {
                            
                                SetFilePointer(
                                        DebugObject->LogFile,
                                        0,
                                        NULL,
                                        FILE_END
                                        );
                            }
                        }
                    }
                }
            }
        }
    }


    RemoveReferenceFromObjectAndUnlock(
        &DebugObject->Header
        );


    return;

}



VOID WINAPI
LogString(
    OBJECT_HANDLE  Object,
    DWORD          StringID,
    ...
    )

{



    DWORD          BytesWritten;
    BOOL           Result;
    va_list        VarArg;
    SYSTEMTIME     SysTime;
    char           OutBuffer[1024];
    char           FormatString[256];
    int            Length;
    UNICODE_STRING UncBuffer;
    STRING         AnsiString;

    PDEBUG_OBJECT  DebugObject=(PDEBUG_OBJECT)ReferenceObjectByHandleAndLock(Object);

    if (DebugObject->LogFile == NULL) {

        RemoveReferenceFromObjectAndUnlock(
            &DebugObject->Header
            );

        return;
    }

    Length=LoadStringA(
        DebugObject->ModuleHandle,
        StringID,
        FormatString,
        sizeof(FormatString)
        );

    if (Length == 0) {

#if DBG
        lstrcpyA(FormatString,"Bad String resource");
#else

        RemoveReferenceFromObjectAndUnlock(
            &DebugObject->Header
            );


        return;
#endif

    }



    va_start(VarArg,StringID);

    GetLocalTime(
        &SysTime
        );

    wsprintfA(
        OutBuffer,
        "%02d-%02d-%04d %02d:%02d:%02d.%03d - ",
        SysTime.wMonth,
        SysTime.wDay,
        SysTime.wYear,
        SysTime.wHour,
        SysTime.wMinute,
        SysTime.wSecond,
        SysTime.wMilliseconds
        );


    wvsprintfA(
        OutBuffer+lstrlenA(OutBuffer),
        FormatString,
        VarArg
        );

    RtlInitAnsiString(&AnsiString,OutBuffer);
    RtlAnsiStringToUnicodeString(&UncBuffer,&AnsiString,TRUE);

    Result=WriteFile(
           DebugObject->LogFile,
           UncBuffer.Buffer,
           UncBuffer.Length,
           &BytesWritten,
           NULL
           );

    RtlFreeUnicodeString(&UncBuffer);

#if DBG
    if (!Result) {

        UmDpf(Object,"Write to log failed.");
    }
#endif

    ResizeLogFile(
       DebugObject->LogFile
       );

    RemoveReferenceFromObjectAndUnlock(
        &DebugObject->Header
        );


    return;


}





VOID WINAPI
ResizeLogFile(
    HANDLE    FileHandle
    )

{

    DWORD      FileSize;
    OVERLAPPED OverLapped;
    DWORD      BytesRead;
    BOOL       bResult;
    BOOL       bBytesMoved = 1;
    UINT       i;
    DWORD      DestFileOffset;
    DWORD      SourceFileOffset;
    DWORD      BytesToMove;
    UCHAR      TempBuffer[LOG_TEMP_BUFFER_SIZE];
    DWORD      dwBytesWritten;

    FileSize=GetFileSize(FileHandle,NULL);

    if (FileSize < MAX_LOG_SIZE) {

        return;

    }

    D_TRACE(DebugPrint("Resizing log File, size=%d",FileSize);)

    OverLapped.hEvent=NULL;
    OverLapped.OffsetHigh=0;
    OverLapped.Offset=FileSize-(MAX_LOG_SIZE/2);


    bResult=ReadFile(
        FileHandle,
        TempBuffer,
        LOG_TEMP_BUFFER_SIZE,
        &BytesRead,
        &OverLapped
        );


    if (!bResult) {

        return;

    }

    //
    //  find the first character following a line feed
    //
    for (i=0; i < LOG_TEMP_BUFFER_SIZE; i++) {

        if (TempBuffer[i] == '\n') {

            break;

        }
    }

    //
    //  source starts first char after LF
    //
    SourceFileOffset=(FileSize-(MAX_LOG_SIZE/2)) + i;
    // SourceFileOffset=(FileSize-(MAX_LOG_SIZE/2)) + i + 2;

    DestFileOffset=0;

    BytesToMove=FileSize-SourceFileOffset;

    while (BytesToMove > 0) {

        DWORD   BytesNow;
        DWORD   BytesWritten;


        OverLapped.hEvent=NULL;
        OverLapped.OffsetHigh=0;
        OverLapped.Offset=SourceFileOffset;

        BytesNow= BytesToMove < LOG_TEMP_BUFFER_SIZE ? BytesToMove : LOG_TEMP_BUFFER_SIZE;

        bResult=ReadFile(
            FileHandle,
            TempBuffer,
            BytesNow,
            &BytesRead,
            &OverLapped
            );

        if (!bResult || BytesRead != BytesNow) {
            //
            // something bad happened, truncate the file
            //
            DestFileOffset=0;

            break;

        }

        OverLapped.hEvent=NULL;
        OverLapped.OffsetHigh=0;
        OverLapped.Offset=DestFileOffset;

        if (bBytesMoved == 1)
        {
            TempBuffer[0] = UnicodeBOM[0];
            TempBuffer[1] = UnicodeBOM[1];

            bBytesMoved = 0;
        }


        bResult=WriteFile(
            FileHandle,
            TempBuffer,
            BytesRead,
            &BytesWritten,
            &OverLapped
            );

        if (!bResult || BytesWritten != BytesNow) {
            //
            // something bad happened, truncate the file
            //
            DestFileOffset=0;

            break;

        }


        BytesToMove-=BytesRead;
        SourceFileOffset+=BytesRead;
        DestFileOffset+=BytesRead;

    }

    SetFilePointer(
        FileHandle,
        DestFileOffset,
        NULL,
        FILE_BEGIN
        );

    SetEndOfFile(
        FileHandle
        );


    return;

}

VOID WINAPIV
UmDpf(
    OBJECT_HANDLE   Object,
    LPSTR    FormatString,
    ...
    )

{

    PDEBUG_OBJECT  DebugObject=(PDEBUG_OBJECT)ReferenceObjectByHandleAndLock(Object);
    va_list        VarArg;
    CHAR           OutBuffer[1024];


    wsprintfA(
        OutBuffer,
        "%d - UNIMDMAT: ",
        DebugObject->DeviceId
        );

    va_start(VarArg,FormatString);

    wvsprintfA(
        OutBuffer+lstrlenA(OutBuffer),
        FormatString,
        VarArg
        );

    lstrcatA(OutBuffer,"\n");

    OutputDebugStringA(OutBuffer);

    RemoveReferenceFromObjectAndUnlock(
        &DebugObject->Header
        );


    return;

}




//****************************************************************************
// PrintString
// dwOption:
//      PS_SEND - Send prefix used
//      PS_SEND_SECURE - Send prefix used and numbers replaced with #s
//      PS_RECV - Recv prefix used
// Send the response string to VxDWin and Log
// We only care about seeing 50 chars under RETAIL, 
// and MAXSTRINGLENGTH * MAX_DBG_CHARS_PER_BIN_CHAR under DEBUG
//  - any number chars on a dialing line will be changed to #.
//  - this includes X3 -> X#.  The extra code to handle this isn't
//  - worth it.
//****************************************************************************

#define CR                  '\r'        // 0x0D
#define LF                  '\n'        // 0x0A


#define MAX_DBG_CHARS_PER_BIN_CHAR  4

#if DBG
#define RAWRESPONSELEN  300
#else
#define RAWRESPONSELEN  300  // good number for remaining chars on a line after the time stamp
#endif

void WINAPI
PrintString(
    OBJECT_HANDLE  Object,
    CONST  CHAR *pchStr,
    DWORD  dwLength,
    DWORD  dwOption
    )
{
    char temp[RAWRESPONSELEN + 1];
    CONST char *src;
    char *dest;
    CONST static char szHex[] = "0123456789abcdef";
    int i;


    PDEBUG_OBJECT  DebugObject=(PDEBUG_OBJECT)ReferenceObjectByHandleAndLock(Object);

#if !DBG
    if (DebugObject->LogFile == NULL) {

        goto Exit;
    }
#endif


    i = dwLength;
    src = pchStr;
    dest = temp;
    
    while (i-- && (dest - temp < RAWRESPONSELEN - MAX_DBG_CHARS_PER_BIN_CHAR)) {

        // ascii printable chars are between 0x20 and 0x7e, inclusive
        if (*src >= 0x20 && *src <= 0x7e) {

#if DBG // only blank out digits under RETAIL
            *dest++ = *src;
#else
            //
            // printable text
            //
            if ( ((PS_SEND_SECURE == dwOption) || (PS_RECV_SECURE == dwOption)) && isdigit(*src)) {

                *dest++ = '#';

            } else {

                *dest++ = *src;
            }
#endif

    	} else {
            //
    	    //  binary
            //
    	    switch (*src) {

        	    case CR:
                    *dest++ = '<'; *dest++ = 'c'; *dest++ = 'r'; *dest++ = '>';

                    break;

                case 0x10:

                    *dest++ = '<'; *dest++ = 'D'; *dest++ = 'L'; *dest++ = 'E' ;*dest++ = '>';

                    break;

                case LF:

                    *dest++ = '<'; *dest++ = 'l'; *dest++ = 'f'; *dest++ = '>';
                    break;

                default:
                    *dest++ = '<';
                    *dest++ = szHex[(*src>>4) & 0xf];
                    *dest++ = szHex[*src & 0xf];
                    *dest++ = '>';
                    break;
    	    }
    	}
        src++;

    } // while

    *dest = 0;

    switch (dwOption)
    {
    case PS_SEND:
    case PS_SEND_SECURE:

	LogString(Object, IDS_MSGLOG_COMMAND, temp);
	D_TRACE(UmDpf(Object, "Send: %s\r\n", temp);)

	break;

    case PS_RECV:
    case PS_RECV_SECURE:
	{

	    char  Response[128];
	    char  EmptyResponse[128];
	    INT   StringLength;


	    StringLength=LoadStringA(
		DebugObject->ModuleHandle,
		IDS_MSGLOG_RAWRESPONSE,
		Response,
		sizeof(Response)
		);

	    if (StringLength == 0) {

                goto Exit;
	    }

	    StringLength=LoadStringA(
		DebugObject->ModuleHandle,
		IDS_MSGLOG_EMPTYRESPONSE,
		EmptyResponse,
		sizeof(EmptyResponse)
		);

	    if (StringLength == 0) {

                goto Exit;

	    }

	    LogPrintf(
                Object,
		Response,
		dwLength ? temp : EmptyResponse
		);


	    D_TRACE(UmDpf(Object,Response,
			   dwLength ? temp : EmptyResponse);)
	}

	break;
    }

Exit:

    RemoveReferenceFromObjectAndUnlock(
        &DebugObject->Header
        );

    return;

}


//****************************************************************************
//  void PrintCommSettings(DCB * pDcb)
//
//  Function: Dumps a portion of the Ring0 DCB.
//****************************************************************************

void WINAPI
PrintCommSettings(
    OBJECT_HANDLE  Object,
    DCB * pDcb
    )
{
    CONST char achParity[] = "NOEMS";
    CONST char *aszStopBits[] = { "1", "1.5", "2" };




    LogPrintf(
	Object,
	"%d,%d,%c,%s, ctsfl=%d, rtsctl=%d\r\n",
	pDcb->BaudRate,
	pDcb->ByteSize,
        achParity[pDcb->Parity],
	aszStopBits[pDcb->StopBits],
        pDcb->fOutxCtsFlow,
	pDcb->fRtsControl
	);

    D_TRACE(UmDpf(Object,
		   "%d,%d,%c,%s, ctsfl=%d, rtsctl=%d",
		   pDcb->BaudRate,
		   pDcb->ByteSize,
                   achParity[pDcb->Parity],
		   aszStopBits[pDcb->StopBits],
		   pDcb->fOutxCtsFlow,
		   pDcb->fRtsControl
		   );)
}




VOID WINAPI
PrintGoodResponse(
    OBJECT_HANDLE  Object,
    DWORD  ResponseState
    )

{

    char  Response[128];
    char  ResponseType[128];
    DWORD StringID;
    INT   StringLength;

    PDEBUG_OBJECT  DebugObject=(PDEBUG_OBJECT)ReferenceObjectByHandleAndLock(Object);

#if !DBG
    if (DebugObject->LogFile == NULL) {

        goto Exit;
    }
#endif

    // StringID=(ResponseState >= RESPONSE_START || ResponseState <= RESPONSE_END)
    StringID=(ResponseState <= RESPONSE_END)
	 ? (IDS_RESP_OK + ResponseState)  : IDS_RESP_UNKNOWN;


    StringLength=LoadStringA(
        DebugObject->ModuleHandle,
        IDS_MSGLOG_RESPONSE,
        Response,
        sizeof(Response)
        );

    if (StringLength == 0) {

        goto Exit;
    }

    StringLength=LoadStringA(
        DebugObject->ModuleHandle,
        StringID,
        ResponseType,
        sizeof(ResponseType)
        );

    if (StringLength == 0) {

        goto Exit;
    }

    LogPrintf(
        Object,
        Response,
        ResponseType
        );


    D_TRACE(UmDpf(Object,Response,ResponseType);)

    D_TRACE(UmDpf(Object,"Good Response");)

Exit:

    RemoveReferenceFromObjectAndUnlock(
                    &DebugObject->Header
                    );

    return;

}

VOID
LogDleCharacter(
    OBJECT_HANDLE  Object,
    UCHAR          RawCharacter,
    UCHAR          DleValue
    )

{
    PDEBUG_OBJECT  DebugObject=(PDEBUG_OBJECT)ReferenceObjectByHandleAndLock(Object);
    char  EmptyResponse[128];
    INT   StringLength;

#if !DBG
    if (DebugObject->LogFile == NULL) {

        goto Exit;
    }
#endif


    if ((DleValue >= DTMF_0) && (DleValue <= DTMF_END)) {

    	StringLength=LoadStringA(
            DebugObject->ModuleHandle,
            IDS_DLE_DTMF_0+DleValue,
            EmptyResponse,
            sizeof(EmptyResponse)
            );

    } else {

        if ((DleValue >= DLE_ETX) && (DleValue <= DLE_LOOPRV)) {

        	StringLength=LoadStringA(
                DebugObject->ModuleHandle,
                IDS_DLE_ETX+(DleValue-DLE_ETX),
                EmptyResponse,
                sizeof(EmptyResponse)
                );

        } else {

            StringLength=LoadStringA(
                DebugObject->ModuleHandle,
                IDS_STRING256,
                EmptyResponse,
                sizeof(EmptyResponse)
                );
        }

    }

    LogString(Object, IDS_MSGLOG_VOICE_DLERECEIVED,RawCharacter,EmptyResponse);

#if !DBG
Exit:
#endif

    RemoveReferenceFromObjectAndUnlock(
        &DebugObject->Header
        );

    return;

}



VOID WINAPI
LogFileVersion(
    OBJECT_HANDLE  Object,
    LPTSTR         FileName
    )

{

    PDEBUG_OBJECT  DebugObject=(PDEBUG_OBJECT)ReferenceObjectByHandleAndLock(Object);

    TCHAR          FullPathName[MAX_PATH];

    DWORD          VersionFileInfoSize;
    DWORD          Dummy;

    PVOID          VersionInfo;

    TCHAR          Root[]=TEXT("\\");

    BOOL           bResult;

    CHAR           FileVerString[256];

    VS_FIXEDFILEINFO *FixedFileInfo;
    DWORD             FixedInfoSize;
    int            StringSize;

#if !DBG
    if (DebugObject->LogFile == NULL) {

        goto Exit;
    }
#endif

    StringSize=LoadString(
        DebugObject->ModuleHandle,
        IDS_FILE_VER_STRING,
        FileVerString,
        sizeof(FileVerString)
        );

    if (StringSize == 0) {
        //
        //  can't get string
        //
        goto Exit;
    }

    GetSystemDirectory(FullPathName,sizeof(FullPathName));

    lstrcat(FullPathName,TEXT("\\"));

    if ((ULONG)lstrlen(FileName) < (ULONG)((sizeof(FullPathName) / sizeof(TCHAR)) - lstrlen(FullPathName)))
    {
        lstrcat(FullPathName,FileName);
    }

    VersionFileInfoSize=GetFileVersionInfoSize(
        FullPathName,
        &Dummy
        );

    if (VersionFileInfoSize == 0) {

        goto Exit;

    }

    VersionInfo=ALLOCATE_MEMORY(VersionFileInfoSize);

    if (VersionInfo == NULL) {

        goto Exit;

    }

    bResult=GetFileVersionInfo(
        FullPathName,
        0,
        VersionFileInfoSize,
        VersionInfo
        );

    if (!bResult) {

        goto NoInfo;

    }

    bResult=VerQueryValue(
        VersionInfo,
        Root,
        &FixedFileInfo,
        &FixedInfoSize
        );

    if (!bResult || (FixedInfoSize == 0)) {

        goto NoInfo;
    }

    LogPrintf(
        Object,
        FileVerString,
        FullPathName,
        HIWORD(FixedFileInfo->dwFileVersionMS),
        LOWORD(FixedFileInfo->dwFileVersionMS),
        HIWORD(FixedFileInfo->dwFileVersionLS),
        FixedFileInfo->dwFileFlags & VS_FF_DEBUG ? " - Debug" : "",
        FixedFileInfo->dwFileFlags & VS_FF_PRERELEASE ? " - Beta" : ""
        );

    FREE_MEMORY(VersionInfo);

    goto Exit;


NoInfo:

    StringSize=LoadString(
        DebugObject->ModuleHandle,
        IDS_NO_FILE_VER,
        FileVerString,
        sizeof(FileVerString)
        );

    if (StringSize != 0) {
        //
        //
        //
        LogPrintf(
            Object,
            "File: %s, Could not retrieve version Info\r\n",
            FullPathName
            );

    }


    FREE_MEMORY(VersionInfo);

Exit:

    RemoveReferenceFromObjectAndUnlock(
        &DebugObject->Header
        );

    return;


}








VOID WINAPI
LogPortStats(
    OBJECT_HANDLE  Object,
    HANDLE         FileHandle
    )

{
    BOOLEAN   bResult;
    LONG      lResult;
    DWORD        BytesTransfered;
    SERIALPERF_STATS   serialstats;

    ZeroMemory(&serialstats,sizeof(serialstats));

    lResult = SyncDeviceIoControl(
                FileHandle,
                IOCTL_SERIAL_GET_STATS,
                NULL,
                0,
                &serialstats,
                sizeof(SERIALPERF_STATS),
                &BytesTransfered
                );

    if (lResult != ERROR_SUCCESS) {

        return;
    }


    LogString(Object,IDS_MSGLOG_STATISTICS);


    LogString(
        Object,
        IDS_MSGLOG_READSTATS,
        serialstats.ReceivedCount
        );


    LogString(
        Object,
        IDS_MSGLOG_WRITESTATS,
        serialstats.TransmittedCount
        );

    if (serialstats.FrameErrorCount) {

        LogString(
              Object,
              IDS_MSGLOG_FRAMEERRORSTATS,
              serialstats.FrameErrorCount
              );
    }

    if (serialstats.SerialOverrunErrorCount) {

        LogString(
              Object,
              IDS_MSGLOG_SERIALOVERRUNERRORSTATS,
              serialstats.SerialOverrunErrorCount
              );
    }

    if (serialstats.BufferOverrunErrorCount) {

        LogString(
              Object,
              IDS_MSGLOG_BUFFEROVERRUNERRORSTATS,
              serialstats.BufferOverrunErrorCount
              );
    }

    if (serialstats.ParityErrorCount) {

        LogString(
              Object,
              IDS_MSGLOG_PARITYERRORSTATS,
              serialstats.ParityErrorCount
              );
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\debug.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    openclos.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

extern DWORD  DebugFlags;

#define  DEBUG_FLAG_ERROR   (0x0001)
#define  DEBUG_FLAG_INIT    (0x0002)
#define  DEBUG_FLAG_TRACE   (0x0004)


#ifdef ASSERT
#undef ASSERT
#endif // ASSERT



#if DBG

#define  D_INIT(_z)   {if (DebugFlags & DEBUG_FLAG_INIT) {_z}}

#define  D_TRACE(_z)  {if (DebugFlags & DEBUG_FLAG_TRACE) {_z}}

#define  D_ERROR(_z)  {if (DebugFlags & DEBUG_FLAG_ERROR) {_z}}


#define  ASSERT(_x) { if(!(_x)){DebugPrint("ASSERT: (%s) File: %s, Line: %d \n\r",#_x,__FILE__,__LINE__);DebugBreak();}}

#else

#define  D_INIT(_z)   {}

#define  D_TRACE(_z)  {}

#define  D_ERROR(_z) {}

#define  ASSERT(_x) {}

#endif


VOID WINAPIV
DebugPrint(
    LPSTR    FormatString,
    ...
    );



OBJECT_HANDLE WINAPI
InitializeDebugObject(
    POBJECT_HEADER     OwnerObject,
    HKEY               ModemRegKey,
    HINSTANCE          ModuleHandle,
    DWORD              DeviceId
    );



VOID WINAPIV
LogPrintf(
    OBJECT_HANDLE  Object,
    LPCSTR          FormatString,
    ...
    );
#if 0
VOID WINAPI
FlushLog(
    OBJECT_HANDLE  Object
    );
#endif

VOID WINAPI
LogString(
    OBJECT_HANDLE  Object,
    DWORD          StringID,
    ...
    );


// PrintString Options
#define PS_SEND        0
#define PS_SEND_SECURE 1
#define PS_RECV        2
#define PS_RECV_SECURE 3




void WINAPI
PrintString(
    OBJECT_HANDLE  Object,
    CONST  CHAR   *pchStr,
    DWORD  dwLength,
    DWORD  dwOption
    );

void WINAPI
PrintCommSettings(
    OBJECT_HANDLE  Object,
    DCB * pDcb
    );



VOID WINAPIV
UmDpf(
    OBJECT_HANDLE   Object,
    LPSTR    FormatString,
    ...
    );

VOID WINAPI
LogFileVersion(
    OBJECT_HANDLE  Object,
    LPTSTR         FileName
    );

VOID WINAPI
PrintGoodResponse(
    OBJECT_HANDLE  Object,
    DWORD  ResponseState
    );

VOID
LogDleCharacter(
    OBJECT_HANDLE  Object,
    UCHAR          RawCharacter,
    UCHAR          DleValue
    );



VOID WINAPI
LogPortStats(
    OBJECT_HANDLE  Object,
    HANDLE         FileHandle
    );

VOID WINAPI
CheckForLoggingStateChange(
    OBJECT_HANDLE  Object
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\dle.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dle.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/


OBJECT_HANDLE WINAPI
InitializeDleHandler(
    POBJECT_HEADER     OwnerObject,
    HANDLE             FileHandle,
    HANDLE             CompletionPort,
    LPUMNOTIFICATIONPROC  AsyncNotificationProc,
    HANDLE             AsyncNotificationContext,
    OBJECT_HANDLE      Debug
    );

LONG WINAPI
StartDleMonitoring(
    OBJECT_HANDLE  ObjectHandle
    );

DWORD WINAPI
ControlDleShielding(
    HANDLE    FileHandle,
    DWORD     StartStop
    );



LONG WINAPI
RegisterETXCallback(
    OBJECT_HANDLE  ObjectHandle,
    COMMANDRESPONSE   *Handler,
    HANDLE             Context,
    DWORD              Timeout
    );


LONG WINAPI
StopDleMonitoring(
    OBJECT_HANDLE  ObjectHandle,
    HANDLE         Event
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\event.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    event.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"


#define  MODEM_EVENT_OBJECT_SIG  ('EMMU')  //UMME

typedef struct _MODEM_EVENT {

    OBJECT_HEADER         Header;

    HANDLE                FileHandle;
    HANDLE                CompletionPort;

    OBJECT_HANDLE         Debug;

    HANDLE                Timer;

    DWORD                 CurrentMask;

    DWORD                 CurrentWaitId;

    COMMANDRESPONSE      *Handler;
    HANDLE                Context;

    BOOL                  TimerSet;


} MODEM_EVENT, *PMODEM_EVENT;


VOID
ModemEventObjectClose(
    POBJECT_HEADER  Object
    )

{

    PMODEM_EVENT       ModemEventObject=(PMODEM_EVENT)Object;

    D_INIT(UmDpf(ModemEventObject->Debug,"ModemEventObjectClose ref=%d",ModemEventObject->Header.ReferenceCount);)

    SetCommMask(
        ModemEventObject->FileHandle,
        0
        );

    ModemEventObject->Handler=NULL;


    return;

}




VOID
ModemEventObjectCleanUp(
    POBJECT_HEADER  Object
    )

{
    PMODEM_EVENT       ModemEventObject=(PMODEM_EVENT)Object;

    D_INIT(UmDpf(ModemEventObject->Debug,"ModemEventObjectCleanup");)

    FreeUnimodemTimer(
        ModemEventObject->Timer
        );

    return;

}




OBJECT_HANDLE WINAPI
InitializeModemEventObject(
    POBJECT_HEADER     OwnerObject,
    OBJECT_HANDLE      Debug,
    HANDLE             FileHandle,
    HANDLE             CompletionPort
    )

{

    PMODEM_EVENT       ModemEventObject;
    OBJECT_HANDLE      ObjectHandle;
    HANDLE             TimerHandle;

    //
    //  create a timer
    //
    TimerHandle=CreateUnimodemTimer(CompletionPort);

    if (TimerHandle == NULL) {

        return NULL;
    }

    ObjectHandle=CreateObject(
        sizeof(*ModemEventObject),
        OwnerObject,
        MODEM_EVENT_OBJECT_SIG,
        ModemEventObjectCleanUp,
        ModemEventObjectClose
        );



    if (ObjectHandle == NULL) {

        FreeUnimodemTimer(
            TimerHandle
            );

        return NULL;
    }

    //
    //  reference the handle to get a pointer to the object
    //
    ModemEventObject=(PMODEM_EVENT)ReferenceObjectByHandle(ObjectHandle);


    //
    //  intialize the object
    //
    ModemEventObject->FileHandle=FileHandle;
    ModemEventObject->CompletionPort=CompletionPort;

    ModemEventObject->Debug=Debug;

    ModemEventObject->Timer=TimerHandle;

    //
    //  release the reference to the object
    //
    RemoveReferenceFromObject(&ModemEventObject->Header);



    return ObjectHandle;

}

VOID
ModemEventHandler(
    DWORD              ErrorCode,
    DWORD              BytesRead,
    LPOVERLAPPED       Overlapped
    )


{
    PUM_OVER_STRUCT    UmOverlapped=(PUM_OVER_STRUCT)Overlapped;

    PMODEM_EVENT       ModemEventObject=(PMODEM_EVENT)UmOverlapped->Context1;
    COMMANDRESPONSE   *Handler=NULL;
    HANDLE             Context;
    BOOL               Canceled;
    BOOL               WaitSucceeded=FALSE;

    LockObject(
        &ModemEventObject->Header
        );


    D_ERROR(if (ErrorCode != 0) UmDpf(ModemEventObject->Debug,"ModemEventHandler: Error=%d, mask=%08lx, %08lx", ErrorCode,UmOverlapped->Overlapped.Offset,(PVOID)UmOverlapped);)

    D_TRACE(UmDpf(ModemEventObject->Debug,"ModemEventHandler: Error=%d, mask=%08lx, %08lx", ErrorCode,UmOverlapped->Overlapped.Offset,(PVOID)UmOverlapped);)
    //
    //  see if it has been canceled
    //
    if (ModemEventObject->Handler != NULL) {
        //
        //  Make sure it was not canceled and set again quickly
        //
        if (ModemEventObject->CurrentWaitId == (DWORD)((ULONG_PTR)UmOverlapped->Context2)) {
            //
            //  capture the handler and context values
            //
            Handler=ModemEventObject->Handler;
            Context=ModemEventObject->Context;

            ModemEventObject->Handler=NULL;

            WaitSucceeded=(ModemEventObject->CurrentMask & UmOverlapped->Overlapped.Offset);

            SetCommMask(
                ModemEventObject->FileHandle,
                0
                );

        } else {

            D_TRACE(UmDpf(ModemEventObject->Debug,"ModemEventHandler: old io, current=%d,this=%d", ModemEventObject->CurrentWaitId,(ULONG_PTR)UmOverlapped->Context2);)

        }
    }

    //
    //  is this for the current wait
    //
    if (ModemEventObject->CurrentWaitId == (ULONG_PTR)UmOverlapped->Context2) {
        //
        //  if the timer is set kill it
        //
        if (ModemEventObject->TimerSet) {

            Canceled=CancelUnimodemTimer(
                ModemEventObject->Timer
                );

            if (Canceled) {
                //
                //  killed it, remove the ref
                //
                ModemEventObject->TimerSet=FALSE;

                RemoveReferenceFromObject(
                    &ModemEventObject->Header
                    );

            } else {

                D_ERROR(UmDpf(ModemEventObject->Debug,"ModemEventHandler: CancelUnimodemTimer failed");)

            }

        }
    }
    //
    //  relese the lock and call the handler
    //
    UnlockObject(&ModemEventObject->Header);

    if (Handler != NULL) {

        (*Handler)(
            Context,
            WaitSucceeded ? ERROR_SUCCESS : ERROR_UNIMODEM_MODEM_EVENT_TIMEOUT
            );
    }

    //
    //  remove ref for i/o
    //
    RemoveReferenceFromObject(
        &ModemEventObject->Header
        );

    FreeOverStruct(UmOverlapped);

    return;
}



VOID WINAPI
ModemEventTimeoutHandler(
    OBJECT_HANDLE       ObjectHandle,
    HANDLE              Context2
    )

{

    PMODEM_EVENT       ModemEventObject=(PMODEM_EVENT)ObjectHandle;

    LockObject(
        &ModemEventObject->Header
        );

    D_TRACE(UmDpf(ModemEventObject->Debug,"ModemEventTimeoutHandler");)

    LogString(ModemEventObject->Debug,IDS_WAITEVENT_TIMEOUT);

    //
    //  the timer has expired, so it isn't set anymore
    //
    ModemEventObject->TimerSet=FALSE;

    if (ModemEventObject->CurrentWaitId == (ULONG_PTR)Context2) {
        //
        //  this will cause the wait to complete and regular code path to run
        //
        SetCommMask(
            ModemEventObject->FileHandle,
            0
            );
    }

    //
    //  remove ref for timer
    //
    RemoveReferenceFromObjectAndUnlock(
        &ModemEventObject->Header
        );


    return;
}


BOOL WINAPI
WaitForModemEvent(
    OBJECT_HANDLE      Object,
    DWORD              WaitMask,
    DWORD              Timeout,
    COMMANDRESPONSE   *Handler,
    HANDLE             Context
    )

{

    PMODEM_EVENT       ModemEventObject=(PMODEM_EVENT)ReferenceObjectByHandleAndLock(Object);
    BOOL               bResult=FALSE;
    BOOL               Canceled;
    PUM_OVER_STRUCT    UmOverlapped;


    ASSERT(ModemEventObject->Handler == NULL);

    ModemEventObject->CurrentMask=WaitMask;

    ModemEventObject->CurrentWaitId++;

    ModemEventObject->Handler=Handler;
    ModemEventObject->Context=Context;


    bResult=SetCommMask(
        ModemEventObject->FileHandle,
        WaitMask
        );

    if (!bResult) {

        D_ERROR(UmDpf(ModemEventObject->Debug,"WaitForModemEvent: SetCommMask() Failed");)

        RemoveReferenceFromObjectAndUnlock(
            &ModemEventObject->Header
            );

        return bResult;
    }


    UmOverlapped=AllocateOverStruct(ModemEventObject->CompletionPort);

    if (UmOverlapped == NULL) {

        RemoveReferenceFromObjectAndUnlock(
            &ModemEventObject->Header
            );

        return FALSE;
    }



    UmOverlapped->Context1=ModemEventObject;

    UmOverlapped->Context2=(HANDLE)ULongToPtr(ModemEventObject->CurrentWaitId); // sundown: zero-extension.



    if (Timeout != INFINITE) {

        AddReferenceToObject(
            &ModemEventObject->Header
            );

        SetUnimodemTimer(
            ModemEventObject->Timer,
            Timeout,
            ModemEventTimeoutHandler,
            ModemEventObject,
            (HANDLE)ULongToPtr(ModemEventObject->CurrentWaitId) // sundown: zero-extension
            );

        ModemEventObject->TimerSet=TRUE;
    }


    //
    //  add a ref for the io
    //
    AddReferenceToObject(
        &ModemEventObject->Header
        );


    UmOverlapped->Overlapped.Offset=0;

    bResult=UnimodemWaitCommEventEx(
        ModemEventObject->FileHandle,
        &UmOverlapped->Overlapped.Offset,
        &UmOverlapped->Overlapped,
        ModemEventHandler
        );


    if (!bResult) {
        //
        // wait failed, kill timer
        //
        D_ERROR(UmDpf(ModemEventObject->Debug,"WaitForModemEvent: WaitCommEvent() Failed, %08lx",(PVOID)UmOverlapped);)

        ModemEventObject->CurrentWaitId++;

        ModemEventObject->Handler=NULL;

        if (ModemEventObject->TimerSet == TRUE) {
            //
            //  we set a timer for this wait, kill it now
            //
            Canceled=CancelUnimodemTimer(
                ModemEventObject->Timer
                );

            if (Canceled) {
                //
                //  killed it, remove the ref
                //
                ModemEventObject->TimerSet=FALSE;

                RemoveReferenceFromObject(
                    &ModemEventObject->Header
                    );
            }
        }

        //
        //  remove  ref for io
        //
        RemoveReferenceFromObject(
            &ModemEventObject->Header
            );

        //
        //  the the overlapped struct, since the io did not get started
        //
        FreeOverStruct(UmOverlapped);


    }
    //
    //  remove opening ref
    //
    RemoveReferenceFromObjectAndUnlock(
        &ModemEventObject->Header
        );

    return bResult;

}



BOOL WINAPI
CancelModemEvent(
    OBJECT_HANDLE       ObjectHandle
    )

{

    PMODEM_EVENT       ModemEventObject;
    BOOL               bResult;
    BOOL               Canceled;

    ModemEventObject=(PMODEM_EVENT)ReferenceObjectByHandleAndLock(ObjectHandle);

    D_TRACE(UmDpf(ModemEventObject->Debug,"CancelModemEvent: ");)

    if (ModemEventObject->Handler != NULL) {
        //
        //  event hasn't gone off yet, caused the wait to complete
        //
        SetCommMask(
            ModemEventObject->FileHandle,
            0
            );

        ModemEventObject->Handler=NULL;

        bResult=TRUE;

    } else {
        //
        //  missed it
        //
        bResult=FALSE;
    }

    //
    //  if the timer is set kill it
    //
    if (ModemEventObject->TimerSet) {

        Canceled=CancelUnimodemTimer(
            ModemEventObject->Timer
            );

        if (Canceled) {
            //
            //  killed it, remove the ref
            //
            ModemEventObject->TimerSet=FALSE;

            RemoveReferenceFromObject(
                &ModemEventObject->Header
                );

        } else {

            D_ERROR(UmDpf(ModemEventObject->Debug,"CancelModemEvent: CancelUnimodemTimer() failed");)

        }
    }

    //
    //  remove ref for opening ref
    //
    RemoveReferenceFromObjectAndUnlock(
        &ModemEventObject->Header
        );

    return bResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\event.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    event.h

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#define  MODEM_EVENT_SIG  (0x56454d55)  //UMMC

OBJECT_HANDLE WINAPI
InitializeModemEventObject(
    POBJECT_HEADER     OwnerObject,
    OBJECT_HANDLE      Debug,
    HANDLE             FileHandle,
    HANDLE             CompletionPort
    );

BOOL WINAPI
WaitForModemEvent(
    OBJECT_HANDLE      Object,
    DWORD              WaitMask,
    DWORD              Timeout,
    COMMANDRESPONSE   *Handler,
    HANDLE             Context
    );

BOOL WINAPI
CancelModemEvent(
    OBJECT_HANDLE       ObjectHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\dialansw.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dialansw.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"

#define NULL_MODEM_RETRIES  4

#define HAYES_COMMAND_LENGTH        40

#define CALLER_ID_WAIT_TIME    (3*1000)

VOID WINAPI
AnswerTimerHandler(
    HANDLE              Context,
    HANDLE              Context2
    );

VOID WINAPI
CDWaitTimerHandler(
    HANDLE              Context,
    HANDLE              Context2
    );


LONG WINAPI
HandleDataConnection(
    PMODEM_CONTROL   ModemControl,
    PDATA_CONNECTION_DETAILS    Details
    );

LPSTR WINAPI
CreateDialCommands(
    OBJECT_HANDLE     Debug,
    HANDLE            CommonInfo,
    DWORD             ModemOptionsCaps,
    DWORD             PreferredModemOptions,
    LPSTR             szPhoneNumber,
    BOOL              fOriginate,
    DWORD             DialOptions
    );


PSTR WINAPI
ConcatenateMultiSz(
    LPSTR       PrependStrings,
    LPSTR       AppendStrings
    );


DWORD
GetTimeDelta(
    DWORD    FirstTime,
    DWORD    LaterTime
    )

{
    DWORD   ElapsedTime;

    if (LaterTime < FirstTime) {
        //
        //  roll over
        //
        ElapsedTime=LaterTime + (0xffffffff-FirstTime) + 1;

    } else {
        //
        //  no rollover, just get the difference
        //
        ElapsedTime=LaterTime-FirstTime;

    }

    ASSERT(ElapsedTime < (1*60*60*1000));

    return ElapsedTime;
}



VOID
DisconnectHandler(
    HANDLE      Context,
    DWORD       Status
    )

{

    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)Context;
    DWORD             ModemStatus;

    D_TRACE(UmDpf(ModemControl->Debug,"DisconnectHandler\n");)

    GetCommModemStatus(
        ModemControl->FileHandle,
        &ModemStatus
        );

    LogString(ModemControl->Debug, IDS_MSGLOG_REMOTEHANGUP,ModemStatus);

    if (ModemControl->RegInfo.DeviceType != DT_NULL_MODEM) {

        if (ModemStatus & MS_RLSD_ON) {

            LogString(ModemControl->Debug, IDS_DISCONNECT_RLSD_HIGH);
        }

        if ((ModemStatus & (MS_DSR_ON | MS_CTS_ON)) != (MS_DSR_ON | MS_CTS_ON) ) {

            LogString(ModemControl->Debug, IDS_DISCONNECT_DSR_CTS);
        }
    }

    LockObject(&ModemControl->Header);

    ModemControl->ConnectionState = CONNECTION_STATE_DATA_REMOTE_DISCONNECT;

    SetPassthroughMode(
        ModemControl->FileHandle,
        MODEM_NOPASSTHROUGH
        );


    UnlockObject(&ModemControl->Header);

    (*ModemControl->NotificationProc)(
        ModemControl->NotificationContext,
        MODEM_DISCONNECT,
        0,
        0
        );

    return;

}

VOID WINAPI
ConnectionTimerHandler(
    HANDLE              Context,
    HANDLE              Context2
    )

{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)Context;
    DWORD             BytesTransfered;
    LONG              lResult;
    SERIALPERF_STATS   serialstats;

    lResult = SyncDeviceIoControl(
                ModemControl->FileHandle,
                IOCTL_SERIAL_GET_STATS,
                NULL,
                0,
                &serialstats,
                sizeof(SERIALPERF_STATS),
                &BytesTransfered
                );

    if (lResult == ERROR_SUCCESS) {

        DWORD    CurrentTime=GetTickCount();

        if (Context2 == NULL) {

            DWORD    ElapsedTime;
            DWORD    BytesReadDelta    = serialstats.ReceivedCount-ModemControl->LastBytesRead;
            DWORD    BytesWrittenDelta = serialstats.TransmittedCount-ModemControl->LastBytesWritten;
            DWORD    ReadRate=0;
            DWORD    WriteRate=0;


            ElapsedTime=GetTimeDelta(ModemControl->LastTime,CurrentTime);

            //
            //  ms to seconds
            //
            ElapsedTime=ElapsedTime/1000;

            if (ElapsedTime!=0) {

                ReadRate=BytesReadDelta/ElapsedTime;
                WriteRate=BytesWrittenDelta/ElapsedTime;
            }


            LogString(ModemControl->Debug,IDS_RW_STATS,serialstats.ReceivedCount,ReadRate,serialstats.TransmittedCount,WriteRate );
        }

        ModemControl->LastBytesRead=serialstats.ReceivedCount;
        ModemControl->LastBytesWritten=serialstats.TransmittedCount;
        ModemControl->LastTime=CurrentTime;
    }

    //
    //  set the timer again
    //
    SetUnimodemTimer(
        ModemControl->ConnectionTimer,
        (Context2 != NULL) ? 30*1000 :
#if DBG
        1*60*1000,
#else
        2*60*1000,
#endif
        ConnectionTimerHandler,
        ModemControl,
        NULL
        );

    return;
}




VOID
AnswerCompleteHandler(
    HANDLE      Context,
    DWORD       Status
    )

{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)Context;
    DWORD             ModemStatus;
    DWORD             TimeOut;
    DATA_CONNECTION_DETAILS    Details;
    UM_NEGOTIATED_OPTIONS      UmNegOptions;
    BOOL              ExitLoop=FALSE;
    ULONG_PTR          CompletionParam2=0;
    BOOL              bResult;


    ASSERT(COMMAND_TYPE_ANSWER == ModemControl->CurrentCommandType);

    D_TRACE(UmDpf(ModemControl->Debug,"AnswerCompleteHandler: %d, State=%d",Status,ModemControl->DialAnswer.State);)


    AddReferenceToObject(
        &ModemControl->Header
        );


    LockObject(&ModemControl->Header);

    while (!ExitLoop) {

        switch (ModemControl->DialAnswer.State) {

            case DIALANSWER_STATE_ABORTED:

                FREE_MEMORY(ModemControl->CurrentCommandStrings);

                ModemControl->ConnectionState=CONNECTION_STATE_NONE;

                Status=ERROR_CANCELLED;

                ModemControl->DialAnswer.State=DIALANSWER_STATE_COMPLETE_COMMAND;

                break;


            case DIALANSWER_STATE_SEND_COMMANDS:

                CancelModemEvent(
                    ModemControl->ModemEvent
                    );

                ModemControl->DialAnswer.State=DIALANSWER_STATE_SENDING_COMMANDS;

                ModemControl->CurrentCommandStrings=ModemControl->DialAnswer.DialString;
                ModemControl->DialAnswer.DialString=NULL;

                // The timeout was originally hardcoded.  Now, we change the
                // timeout based on the CallSetupFailTimer.

                if (ModemControl->RegInfo.DeviceType != DT_NULL_MODEM) {

                    D_TRACE(UmDpf(ModemControl->Debug,"AnswerCompleteHandler: Timercap=%d, timer=%d",ModemControl->RegInfo.dwCallSetupFailTimerCap,ModemControl->CallSetupFailTimer);)

                    if ((ModemControl->RegInfo.dwCallSetupFailTimerCap != 0)
                        &&
                        (ModemControl->CallSetupFailTimer > 10)) {

                        TimeOut=ModemControl->CallSetupFailTimer*1000+20000;

                    } else {

                        TimeOut=60*1000;

                    }

                } else {
                    //
                    //  null modem
                    //
                    TimeOut=2*1000;

                }
                // TimeOut=20*1000;

                Status=IssueCommand(
                    ModemControl->CommandState,
                    ModemControl->CurrentCommandStrings,
                    AnswerCompleteHandler,
                    ModemControl,
                    TimeOut,
                    ModemControl->DialAnswer.CommandFlags
                    );

                if (Status == ERROR_IO_PENDING) {
                    //
                    //  pended, don't exit loop. if error next state will handle error
                    //
                    ExitLoop=TRUE;
                }

                break;


            case DIALANSWER_STATE_SENDING_COMMANDS:

                FREE_MEMORY(ModemControl->CurrentCommandStrings);

                if (Status != ERROR_SUCCESS) {

                    ModemControl->ConnectionState=CONNECTION_STATE_NONE;
                }

                ModemControl->DialAnswer.State=DIALANSWER_STATE_COMPLETE_COMMAND;

                break;


            case DIALANSWER_STATE_SEND_ORIGINATE_COMMANDS:

                CancelModemEvent(
                    ModemControl->ModemEvent
                    );


                CancelConnectionTimer(
                    ModemControl
                    );


                ModemControl->CurrentCommandStrings=ModemControl->DialAnswer.DialString;
                ModemControl->DialAnswer.DialString=NULL;

                ModemControl->DialAnswer.State=DIALANSWER_STATE_SENDING_ORIGINATE_COMMANDS;

                if (ModemControl->RegInfo.DeviceType != DT_NULL_MODEM) {

                    D_TRACE(UmDpf(ModemControl->Debug,"AnswerCompleteHandler: Timercap=%d, timer=%d",ModemControl->RegInfo.dwCallSetupFailTimerCap,ModemControl->CallSetupFailTimer);)

                    if ((ModemControl->RegInfo.dwCallSetupFailTimerCap != 0)
                        &&
                        (ModemControl->CallSetupFailTimer > 10)) {

                        TimeOut=ModemControl->CallSetupFailTimer*1000+20000;

                    } else {

                        TimeOut=60*1000;

                    }

                } else {
                    //
                    //  null modem
                    //
                    TimeOut=2*1000;

                }

                Status=IssueCommand(
                    ModemControl->CommandState,
                    ModemControl->CurrentCommandStrings,
                    AnswerCompleteHandler,
                    ModemControl,
                    TimeOut,
                    ModemControl->DialAnswer.CommandFlags | RESPONSE_FLAG_ONLY_CONNECT_SUCCESS
                    );

                if (Status == ERROR_IO_PENDING) {
                    //
                    //  Pended, don't exit loop. if error the next state will handle error
                    //
                    ExitLoop=TRUE;
                }


                break;




            case DIALANSWER_STATE_SENDING_ORIGINATE_COMMANDS:

                if (Status != ERROR_SUCCESS) {

                    ModemControl->DialAnswer.Retry--;

                    if (ModemControl->DialAnswer.Retry > 0) {
                        //
                        //  try again
                        //
                        ModemControl->DialAnswer.State=DIALANSWER_STATE_SEND_ORIGINATE_COMMANDS;

                        //
                        //  we are going to retry the command. we need to put the current commands
                        //  strings back into the dialstring.

                        //
                        ModemControl->DialAnswer.DialString=ModemControl->CurrentCommandStrings;
                        ModemControl->CurrentCommandStrings=NULL;

                        break;

                    }

                    FREE_MEMORY(ModemControl->CurrentCommandStrings);

                    ModemControl->DialAnswer.State=DIALANSWER_STATE_COMPLETE_COMMAND;

                    ModemControl->ConnectionState=CONNECTION_STATE_NONE;

                    break;

                }


                FREE_MEMORY(ModemControl->CurrentCommandStrings);

                if (ModemControl->RegInfo.DeviceType != DT_NULL_MODEM) {
                    //
                    //  real modem, make sure the CD is high before proceeding
                    //
                    bResult=GetCommModemStatus(
                        ModemControl->FileHandle,
                        &ModemStatus
                        );

                    if (!bResult) {

                        Status = ERROR_UNIMODEM_GENERAL_FAILURE;

                        ModemControl->DialAnswer.State=DIALANSWER_STATE_COMPLETE_COMMAND;

                        ModemControl->ConnectionState=CONNECTION_STATE_NONE;

                        break;
                    }


                    if ((ModemStatus & MS_RLSD_ON)) {
                        //
                        //  CD is high complete the connection
                        //
                        ModemControl->DialAnswer.State=DIALANSWER_STATE_COMPLETE_DATA_CONNECTION;

                        break;
                    }

                    //
                    //  set a timer and check the modem status again later
                    //
                    ModemControl->DialAnswer.CDWaitStartTime=GetTickCount();

                    SetUnimodemTimer(
                        ModemControl->CurrentCommandTimer,
                        20,
                        CDWaitTimerHandler,
                        ModemControl,
                        NULL
                        );

                    D_TRACE(UmDpf(ModemControl->Debug,"AnswerCompleteHandler: Connected, but CD low");)

                    LogString(ModemControl->Debug, IDS_WAIT_FOR_CD);

                    ModemControl->DialAnswer.State=DIALANSWER_STATE_WAIT_FOR_CD;
                    ExitLoop=TRUE;
                    break;

                } else {
                    //
                    //  NULL modem
                    //
                    ModemControl->DialAnswer.State=DIALANSWER_STATE_COMPLETE_DATA_CONNECTION;

                    break;
                }


                break;

            case DIALANSWER_STATE_WAIT_FOR_CD:

                bResult=GetCommModemStatus(
                    ModemControl->FileHandle,
                    &ModemStatus
                    );

                if (!bResult) {

                    Status = ERROR_UNIMODEM_GENERAL_FAILURE;

                    ModemControl->DialAnswer.State=DIALANSWER_STATE_COMPLETE_COMMAND;

                    ModemControl->ConnectionState=CONNECTION_STATE_NONE;

                    break;
                }


                if ((ModemStatus & MS_RLSD_ON)) {
                    //
                    //  CD is high complete the connection
                    //
                    LogString(ModemControl->Debug, IDS_CD_WENT_HIGH);

                    ModemControl->DialAnswer.State=DIALANSWER_STATE_COMPLETE_DATA_CONNECTION;

                    break;
                }

                if (GetTimeDelta(ModemControl->DialAnswer.CDWaitStartTime,GetTickCount()) <= (5 * 1000 )) {
                    //
                    //  hasn't gone up yet, wait some more
                    //
                    LogString(ModemControl->Debug, IDS_CD_STILL_LOW);

                    SetUnimodemTimer(
                        ModemControl->CurrentCommandTimer,
                        20,
                        CDWaitTimerHandler,
                        ModemControl,
                        NULL
                        );

                    ModemControl->DialAnswer.State=DIALANSWER_STATE_WAIT_FOR_CD;
                    ExitLoop=TRUE;

                } else {
                    //
                    //  Waited long enough, just proceed with the connection
                    //
                    LogString(ModemControl->Debug, IDS_CD_STAYED_LOW);

                    ModemControl->DialAnswer.State=DIALANSWER_STATE_COMPLETE_DATA_CONNECTION;
                }

                break;


            case DIALANSWER_STATE_COMPLETE_DATA_CONNECTION:

                ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

                ModemControl->ConnectionState=CONNECTION_STATE_DATA;


                SetPassthroughMode(
                    ModemControl->FileHandle,
                    MODEM_DCDSNIFF
                    );


                bResult=WaitForModemEvent(
                    ModemControl->ModemEvent,
                    (ModemControl->RegInfo.DeviceType == DT_NULL_MODEM) ? EV_DSR : EV_RLSD,
                    INFINITE,
                    DisconnectHandler,
                    ModemControl
                    );


                if (!bResult) {

                    Status = ERROR_UNIMODEM_GENERAL_FAILURE;

                    ModemControl->DialAnswer.State=DIALANSWER_STATE_COMPLETE_COMMAND;

                    ModemControl->ConnectionState=CONNECTION_STATE_NONE;

                    break;
                }


                HandleDataConnection(
                    ModemControl,
                    &Details
                    );

                //
                //  create and set a timer to log the current read/write bytes
                //
                ASSERT(ModemControl->ConnectionTimer == NULL);

                ModemControl->ConnectionTimer=CreateUnimodemTimer(ModemControl->CompletionPort);

                if (ModemControl->ConnectionTimer != NULL) {

                    AddReferenceToObject(
                        &ModemControl->Header
                        );

                    ConnectionTimerHandler(
                        ModemControl,
                        (HANDLE)(UINT_PTR)-1
                        );

                }


                UmNegOptions.DCERate=Details.DCERate;
                UmNegOptions.ConnectionOptions=Details.Options;

                ModemControl->DialAnswer.State=DIALANSWER_STATE_COMPLETE_COMMAND;

                Status=ERROR_SUCCESS;

                CompletionParam2=(ULONG_PTR)(&UmNegOptions);

                break;

            case DIALANSWER_STATE_SEND_VOICE_SETUP_COMMANDS:

                CancelModemEvent(
                    ModemControl->ModemEvent
                    );

                StartDleMonitoring(ModemControl->Dle);

                //
                //  set next state
                //
                ModemControl->DialAnswer.State=DIALANSWER_STATE_DIAL_VOICE_CALL;

                ModemControl->CurrentCommandStrings=ModemControl->DialAnswer.VoiceDialSetup;
                ModemControl->DialAnswer.VoiceDialSetup=NULL;

                Status=IssueCommand(
                    ModemControl->CommandState,
                    ModemControl->CurrentCommandStrings,
                    AnswerCompleteHandler,
                    ModemControl,
                    5*1000,
                    0
                    );

                if (Status == ERROR_IO_PENDING) {
                    //
                    //  Pended, don't exit loop. if error the next state will handle error
                    //
                    ExitLoop=TRUE;
                }


                break;


            case DIALANSWER_STATE_DIAL_VOICE_CALL:


                if (ModemControl->CurrentCommandStrings != NULL) {
                    //
                    //  voice answer jumps straight to this state, so there is not current command
                    //
                    FREE_MEMORY(ModemControl->CurrentCommandStrings);

                } else {
                    //
                    //  if we did jump here from voice answer this was not canceled yey
                    //
                    CancelModemEvent(
                        ModemControl->ModemEvent
                        );

                    //
                    //  turn on the dle monitoring as well
                    //
                    StartDleMonitoring(ModemControl->Dle);
                }


                if (Status != STATUS_SUCCESS) {

                    Status = ERROR_UNIMODEM_GENERAL_FAILURE;

                    ModemControl->DialAnswer.State=DIALANSWER_STATE_COMPLETE_COMMAND;

                    ModemControl->ConnectionState=CONNECTION_STATE_NONE;

                    break;
                }


                ModemControl->CurrentCommandStrings=ModemControl->DialAnswer.DialString;
                ModemControl->DialAnswer.DialString=NULL;

                ModemControl->DialAnswer.State=DIALANSWER_STATE_SENT_VOICE_COMMANDS;

                Status=IssueCommand(
                    ModemControl->CommandState,
                    ModemControl->CurrentCommandStrings,
                    AnswerCompleteHandler,
                    ModemControl,
                    60*1000,
                    ModemControl->DialAnswer.CommandFlags
                    );

                if (Status == ERROR_IO_PENDING) {
                    //
                    //  Pended, don't exit loop. if error the next state will handle error
                    //
                    ExitLoop=TRUE;
                }

                break;


            case DIALANSWER_STATE_SENT_VOICE_COMMANDS:


                FREE_MEMORY(ModemControl->CurrentCommandStrings);

                ModemControl->ConnectionState=CONNECTION_STATE_VOICE;

                if (Status != ERROR_SUCCESS) {

                    ModemControl->ConnectionState=CONNECTION_STATE_NONE;

                }

                ModemControl->DialAnswer.State=DIALANSWER_STATE_COMPLETE_COMMAND;

                break;

            case DIALANSWER_STATE_CHECK_RING_INFO: {

                DWORD    RingCount;
                DWORD    LastRingTime;
                DWORD    TimeSinceRing;

                GetRingInfo(
                    ModemControl->ReadState,
                    &RingCount,
                    &LastRingTime
                    );

                if ((RingCount == 1) && IsCommonCommandSupported(ModemControl->CommonInfo,COMMON_ENABLE_CALLERID_COMMANDS)) {
                    //
                    //  this is the first ring, and the modem support caller id
                    //
                    TimeSinceRing=GetTimeDelta(
                        LastRingTime,
                        GetTickCount()
                        );

                    if (TimeSinceRing < CALLER_ID_WAIT_TIME) {
                        //
                        //  less than 4 seconds since ring, start timer
                        //

                        LogString(ModemControl->Debug, IDS_ANSWER_DELAY,CALLER_ID_WAIT_TIME - TimeSinceRing);

                        SetUnimodemTimer(
                            ModemControl->CurrentCommandTimer,
                            CALLER_ID_WAIT_TIME - TimeSinceRing,
                            AnswerTimerHandler,
                            ModemControl,
                            NULL
                            );

                        ExitLoop=TRUE;
                        break;

                    } else {
                        //
                        //  more than four seconds, just answer now
                        //
                        ModemControl->DialAnswer.State=ModemControl->DialAnswer.PostCIDAnswerState;
                    }


                }  else {
                    //
                    //  Either we have not gotten a ring, or we have gotten more than one,
                    //  answer right now.
                    //
                    ModemControl->DialAnswer.State=ModemControl->DialAnswer.PostCIDAnswerState;

                }


                break;
            }

            case DIALANSWER_STATE_COMPLETE_COMMAND:

                ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

                UnlockObject(&ModemControl->Header);

                (*ModemControl->NotificationProc)(
                    ModemControl->NotificationContext,
                    MODEM_ASYNC_COMPLETION,
                    Status,
                    CompletionParam2
                    );

                RemoveReferenceFromObject(
                    &ModemControl->Header
                    );


                LockObject(&ModemControl->Header);

                ExitLoop=TRUE;

                break;

            default:

                break;

        }

    }


    RemoveReferenceFromObjectAndUnlock(
        &ModemControl->Header
        );

//    UnlockObject(&ModemControl->Header);

    return;

}

VOID WINAPI
AnswerTimerHandler(
    HANDLE              Context,
    HANDLE              Context2
    )

{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)Context;

    LogString(ModemControl->Debug, IDS_ANSWER_PROCEED);

    ModemControl->DialAnswer.State=ModemControl->DialAnswer.PostCIDAnswerState;

    AnswerCompleteHandler(
        ModemControl,
        ERROR_SUCCESS
        );

    return;
};



VOID WINAPI
CDWaitTimerHandler(
    HANDLE              Context,
    HANDLE              Context2
    )

{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)Context;

    AnswerCompleteHandler(
        ModemControl,
        ERROR_SUCCESS
        );
}

DWORD WINAPI
UmAnswerModem(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    DWORD     AnswerFlags
    )
/*++

Routine Description:

    This routine is called to initialize the modem to a known state using the parameters
    supplied in the CommConfig structure. If some settings do not apply to the actual hardware
    then they can be ignored.

Arguments:

    ModemHandle - Handle returned by OpenModem

    CommandsOptionList - List option blocks, only flags used
       Flags   - Optional init parameters. Not currently used and must be zero

    CommConfig  - CommConig structure with MODEMSETTINGS structure.

Return Value:

    ERROR_SUCCESS if successfull
    ERROR_IO_PENDING If pending, will be completed later with a call to the AsyncHandler

    or other specific error


--*/

{

    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)ReferenceObjectByHandleAndLock(ModemHandle);
    LONG              lResult;
    LPSTR             Commands;
    BOOL              bResult;


    ASSERT(ModemControl->CurrentCommandType == COMMAND_TYPE_NONE);

    if (ModemControl->CurrentCommandType != COMMAND_TYPE_NONE) {

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_UNIMODEM_INUSE;
    }

    if ((AnswerFlags & ANSWER_FLAG_VOICE) && (AnswerFlags & (ANSWER_FLAG_DATA | ANSWER_FLAG_VOICE_TO_DATA))) {

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_UNIMODEM_BAD_FLAGS;
    }

    LogString(ModemControl->Debug, IDS_MSGLOG_ANSWER);

    ModemControl->DialAnswer.DialString=NULL;
    ModemControl->CurrentCommandStrings=NULL;

    ModemControl->DialAnswer.Retry=1;

    if (AnswerFlags & ANSWER_FLAG_VOICE) {
        //
        //  answer in voice mode
        //
        ASSERT(!(AnswerFlags & (ANSWER_FLAG_DATA | ANSWER_FLAG_VOICE_TO_DATA)));

        SetVoiceReadParams(
            ModemControl->ReadState,
            ModemControl->RegInfo.VoiceBaudRate,
            4096*2
            );


        ModemControl->DialAnswer.PostCIDAnswerState=DIALANSWER_STATE_DIAL_VOICE_CALL;
        ModemControl->DialAnswer.State=DIALANSWER_STATE_CHECK_RING_INFO;

        ModemControl->DialAnswer.DialString=GetCommonCommandStringCopy(
            ModemControl->CommonInfo,
            COMMON_VOICE_ANSWER_COMMANDS,
            NULL,
            NULL
            );

    } else {
        //
        //  answer in data mode
        //
        ModemControl->DialAnswer.PostCIDAnswerState=DIALANSWER_STATE_SEND_ORIGINATE_COMMANDS;
        ModemControl->DialAnswer.State=DIALANSWER_STATE_CHECK_RING_INFO;

        ModemControl->DialAnswer.DialString=GetCommonCommandStringCopy(
            ModemControl->CommonInfo,
            (AnswerFlags & ANSWER_FLAG_VOICE_TO_DATA) ? COMMON_VOICE_TO_DATA_ANSWER : COMMON_ANSWER_COMMANDS,
            NULL,
            NULL
            );

    }

    if (ModemControl->DialAnswer.DialString == NULL) {

        ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

        LogString(ModemControl->Debug, IDS_MSGERR_FAILED_ANSWER);

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_NOT_ENOUGH_MEMORY;

    }


    ModemControl->CurrentCommandType=COMMAND_TYPE_ANSWER;

    ModemControl->DialAnswer.CommandFlags=(AnswerFlags & (ANSWER_FLAG_DATA | ANSWER_FLAG_VOICE_TO_DATA)) ? RESPONSE_FLAG_STOP_READ_ON_CONNECT : 0;

    SetMinimalPowerState(
        ModemControl->Power,
        0
        );

    CheckForLoggingStateChange(ModemControl->Debug);

    bResult=StartAsyncProcessing(
        ModemControl,
        AnswerCompleteHandler,
        ModemControl,
        ERROR_SUCCESS
        );


    if (!bResult) {
        //
        //  failed
        //
        ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

        FREE_MEMORY(ModemControl->DialAnswer.DialString);

        LogString(ModemControl->Debug, IDS_MSGERR_FAILED_ANSWER);

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_NOT_ENOUGH_MEMORY;

    }

    RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

    return ERROR_IO_PENDING;

}





DWORD WINAPI
UmDialModem(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    LPSTR     szNumber,
    DWORD     DialFlags
    )


/*++

Routine Description:

    This routine is called to initialize the modem to a known state using the parameters
    supplied in the CommConfig structure. If some settings do not apply to the actual hardware
    then they can be ignored.

Arguments:

    ModemHandle - Handle returned by OpenModem

    CommandsOptionList - List option blocks, only flags used
       Flags   - Optional init parameters. Not currently used and must be zero


Return Value:

    ERROR_SUCCESS if successfull
    ERROR_IO_PENDING If pending, will be completed later with a call to the AsyncHandler

    or other specific error


--*/

{

    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)ReferenceObjectByHandleAndLock(ModemHandle);
    LONG              lResult;
    LPSTR             Commands;
    BOOL              Originate=(DialFlags & DIAL_FLAG_ORIGINATE);
    DWORD             IssueCommandFlags=0;
    BOOL              bResult;

    ASSERT(ModemControl->CurrentCommandType == COMMAND_TYPE_NONE);

    if (ModemControl->CurrentCommandType != COMMAND_TYPE_NONE) {

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_UNIMODEM_INUSE;
    }

    ModemControl->CurrentCommandStrings=NULL;

    ModemControl->DialAnswer.DialString=NULL;
    ModemControl->DialAnswer.VoiceDialSetup=NULL;
    //
    //  Check for voice modem only things
    //
    if (!(ModemControl->RegInfo.VoiceProfile & VOICEPROF_CLASS8ENABLED)) {
        //
        //  not a voice modem, better not have these flags set
        //
        if (DialFlags & (DIAL_FLAG_VOICE_INITIALIZE | DIAL_FLAG_AUTOMATED_VOICE)) {
            //
            //  can't do this
            //
            RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

            return ERROR_UNIMODEM_NOT_VOICE_MODEM;
        }

        if (DialFlags & DIAL_FLAG_INTERACTIVE_VOICE) {
            //
            //  Non-voice modem placing interactive voice call, Dialer hack
            //
            if (!(DialFlags & DIAL_FLAG_ORIGINATE)) {
                //
                //  not originating, need semicolon
                //

                CHAR    DialSuffix[HAYES_COMMAND_LENGTH];
                DWORD   Length;

                Length=GetCommonDialComponent(
                    ModemControl->CommonInfo,
                    DialSuffix,
                    HAYES_COMMAND_LENGTH,
                    COMMON_DIAL_SUFFIX
                    );

                if (Length <= 1) {
                    //
                    //  modem does not support semicolon, have to originate
                    //
                    Originate=TRUE;
                }
            }

            //
            //  change to data dial
            //
            DialFlags &= ~(DIAL_FLAG_INTERACTIVE_VOICE);
            DialFlags |= DIAL_FLAG_DATA;

        }

    } else {
        //
        //  voice modem, maybe do something usefull
        //

    }


    //
    //  cirrus modem's dialing voice calls need to have a semi-colon at the end
    //
    if (ModemControl->RegInfo.VoiceProfile & VOICEPROF_CIRRUS) {

       if (DialFlags & (DIAL_FLAG_VOICE_INITIALIZE | DIAL_FLAG_AUTOMATED_VOICE)) {

           Originate=FALSE;
       }
    }

    LogString(ModemControl->Debug, IDS_MSGLOG_DIAL);

    if (szNumber != NULL) {
        //
        //  got a number, build dial strings
        //
        IssueCommandFlags |= RESPONSE_DO_NOT_LOG_NUMBER;

        ModemControl->NoLogNumber = TRUE;

        ModemControl->DialAnswer.DialString=CreateDialCommands(
            ModemControl->Debug,
            ModemControl->CommonInfo,
            ModemControl->RegInfo.dwModemOptionsCap,
            ModemControl->CurrentPreferredModemOptions,
            szNumber,
            Originate,
            ((DialFlags & DIAL_FLAG_TONE) ? MDM_TONE_DIAL : 0 ) |
            ((DialFlags & DIAL_FLAG_BLIND) ? MDM_BLIND_DIAL : 0 )
            );


        if (ModemControl->DialAnswer.DialString == NULL) {
            //
            //  Failed to get dial strings
            //
            RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

            return ERROR_UNIMODEM_MISSING_REG_KEY;

        }

    } else {
        //
        //  no phone number, only acceptable if voice init
        //
        if (!(DialFlags & DIAL_FLAG_VOICE_INITIALIZE)) {

            RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

            return ERROR_UNIMODEM_MISSING_REG_KEY;

        }
    }




    ModemControl->DialAnswer.State=DIALANSWER_STATE_SEND_ORIGINATE_COMMANDS;

    if (DialFlags & DIAL_FLAG_VOICE_INITIALIZE) {
        //
        //  first call to dial for a voice call, send the voice setup strings
        //

        SetVoiceReadParams(
            ModemControl->ReadState,
            ModemControl->RegInfo.VoiceBaudRate,
            4096*2
            );

        if (DialFlags & DIAL_FLAG_AUTOMATED_VOICE) {

            ASSERT(!(DialFlags & DIAL_FLAG_DATA));

            ModemControl->DialAnswer.VoiceDialSetup=GetCommonCommandStringCopy(
                ModemControl->CommonInfo,
                COMMON_AUTOVOICE_DIAL_SETUP_COMMANDS,
                NULL,
                NULL
                );

            if (ModemControl->DialAnswer.VoiceDialSetup == NULL) {
                //
                //  failed, probably becuase of old inf, set the interactive flag
                //
                DialFlags |= DIAL_FLAG_INTERACTIVE_VOICE;

            } else {

                DialFlags &= ~DIAL_FLAG_INTERACTIVE_VOICE;

            }

        }


        if (DialFlags & DIAL_FLAG_INTERACTIVE_VOICE) {

            ASSERT(!(DialFlags & DIAL_FLAG_DATA));

            ModemControl->DialAnswer.VoiceDialSetup=GetCommonCommandStringCopy(
                ModemControl->CommonInfo,
                COMMON_VOICE_DIAL_SETUP_COMMANDS,
                NULL,
                NULL
                );


            if (ModemControl->DialAnswer.VoiceDialSetup == NULL) {

                FREE_MEMORY(ModemControl->DialAnswer.DialString);

                RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

                return ERROR_UNIMODEM_MISSING_REG_KEY;

            }


        }

        ModemControl->DialAnswer.State=DIALANSWER_STATE_SEND_VOICE_SETUP_COMMANDS;

    }

    ModemControl->DialAnswer.Retry=1;

    if ((DialFlags & DIAL_FLAG_DATA)) {

        if ((DialFlags & DIAL_FLAG_ORIGINATE)) {
            //
            //  data call and originating
            //
            IssueCommandFlags |= RESPONSE_FLAG_STOP_READ_ON_CONNECT;

            ModemControl->DialAnswer.State=DIALANSWER_STATE_SEND_ORIGINATE_COMMANDS;

            if (ModemControl->RegInfo.DeviceType == DT_NULL_MODEM) {
                //
                //  allow a retry on null modems
                //
                ModemControl->DialAnswer.Retry=NULL_MODEM_RETRIES;
            }

        } else {

            ModemControl->DialAnswer.State=DIALANSWER_STATE_SEND_COMMANDS;
        }
    }


    ModemControl->CurrentCommandType=COMMAND_TYPE_ANSWER;

    ModemControl->DialAnswer.CommandFlags=IssueCommandFlags;

    SetMinimalPowerState(
        ModemControl->Power,
        0
        );

    CheckForLoggingStateChange(ModemControl->Debug);

    bResult=StartAsyncProcessing(
        ModemControl,
        AnswerCompleteHandler,
        ModemControl,
        ERROR_SUCCESS
        );


    if (!bResult) {
        //
        //  failed
        //
        ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

        if (ModemControl->DialAnswer.DialString != NULL) {

            FREE_MEMORY(ModemControl->DialAnswer.DialString);
        }

        if (ModemControl->DialAnswer.VoiceDialSetup != NULL) {

            FREE_MEMORY(ModemControl->DialAnswer.VoiceDialSetup);
        }

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_NOT_ENOUGH_MEMORY;

    }

    RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

    return ERROR_IO_PENDING;


}






LONG WINAPI
HandleDataConnection(
    PMODEM_CONTROL   ModemControl,
    PDATA_CONNECTION_DETAILS    Details
    )

{

    BOOL                       bResult;

    UCHAR                      TempBuffer[sizeof(COMMCONFIG)+sizeof(MODEMSETTINGS)-sizeof(TCHAR)];

    LPCOMMCONFIG               CommConfig=(LPCOMMCONFIG)TempBuffer;
    DWORD                      CommConfigSize=sizeof(TempBuffer);
    LPMODEMSETTINGS            ModemSettings;

    GetDataConnectionDetails(
        ModemControl->ReadState,
        Details
        );

    if (Details->DCERate == 0) {

        DCB Dcb;

        bResult=GetCommState(ModemControl->FileHandle, &Dcb);

        if (!bResult) {

            D_TRACE(UmDpf(ModemControl->Debug,"was unable to get the comm state!");)
            return GetLastError();
        }

        // Did we have any DTE rate info reported
        //
        if (Details->DTERate != 0) {

            // Yes, use it.
            //
            Details->DCERate = Details->DTERate;

            if (Details->DTERate != Dcb.BaudRate)

            // set DCB
            //
            D_TRACE(UmDpf(ModemControl->Debug,"adjusting DTE to match reported DTE");)

            Dcb.BaudRate = Details->DTERate;
            PrintCommSettings(ModemControl->Debug,&Dcb);

            bResult=SetCommState(ModemControl->FileHandle, &Dcb);

            if (!bResult) {

                D_TRACE(UmDpf(ModemControl->Debug,"was unable to set the comm state!");)
                return GetLastError();
            }

        } else {
            //
            // No, use the current DTE baud rate
            //
            D_TRACE(UmDpf(ModemControl->Debug,"using current DTE");)
            Details->DCERate = Dcb.BaudRate;
        }
    }


    if (Details->DCERate != 0) {

        LogString(ModemControl->Debug, IDS_MSGLOG_CONNECTEDBPS, Details->DCERate);

    } else {

        if (Details->DTERate != 0) {

            LogString(ModemControl->Debug, IDS_MSGLOG_CONNECTEDBPS, Details->DTERate);

        } else {

            LogString(ModemControl->Debug, IDS_MSGLOG_CONNECTED);
        }
    }

    if (Details->Options & MDM_ERROR_CONTROL) {

        if (Details->Options & MDM_CELLULAR) {

            LogString(ModemControl->Debug, IDS_MSGLOG_CELLULAR);

        } else {

            LogString(ModemControl->Debug, IDS_MSGLOG_ERRORCONTROL);
        }

    } else {

        LogString(ModemControl->Debug, IDS_MSGLOG_UNKNOWNERRORCONTROL);
    }

    if (Details->Options & MDM_COMPRESSION) {

        LogString(ModemControl->Debug, IDS_MSGLOG_COMPRESSION);

    } else {

        LogString(ModemControl->Debug, IDS_MSGLOG_UNKNOWNCOMPRESSION);
    }


    bResult=GetCommConfig(
        ModemControl->FileHandle,
        CommConfig,
        &CommConfigSize
        );

    if (bResult) {

        ModemSettings=(LPMODEMSETTINGS)(((LPBYTE)CommConfig)+CommConfig->dwProviderOffset);

        ModemSettings->dwNegotiatedModemOptions |= (Details->Options &
    						    (MDM_COMPRESSION |
    						     MDM_ERROR_CONTROL |
    						     MDM_CELLULAR
                                                         ));

        ModemSettings->dwNegotiatedDCERate=Details->DCERate;

        {
            LONG    lResult;
            DWORD   BytesTransfered;

            lResult=SyncDeviceIoControl(
                ModemControl->FileHandle,
                IOCTL_SERIAL_SET_COMMCONFIG,
                CommConfig,
                CommConfigSize,
                NULL,
                0,
                &BytesTransfered
                );

            bResult= (lResult == ERROR_SUCCESS);


        }

        if (!bResult) {

            D_TRACE(UmDpf(ModemControl->Debug,"HandleDataConnection: SetCommConfig failed! %d",GetLastError());)

            return GetLastError();
        }

    } else {

        D_TRACE(UmDpf(ModemControl->Debug,"HandleDataConnection: GetCommConfig failed! %d",GetLastError());)

        return GetLastError();
    }


    return ERROR_SUCCESS;

}


VOID WINAPI
ConnectAbortWriteCompletionHandler(
    DWORD              ErrorCode,
    DWORD              BytesWritten,
    LPOVERLAPPED       Overlapped
    )

{

    PUM_OVER_STRUCT    UmOverlapped=(PUM_OVER_STRUCT)Overlapped;

    D_TRACE(DebugPrint("UNIMDMAT: Write Complete\n");)

    FreeOverStruct(UmOverlapped);

    return;

}



VOID  WINAPI
AbortDialAnswer(
    DWORD              ErrorCode,
    DWORD              Bytes,
    LPOVERLAPPED       dwParam
    )

{
    PUM_OVER_STRUCT    UmOverlapped=(PUM_OVER_STRUCT)dwParam;
    PMODEM_CONTROL     ModemControl=UmOverlapped->Context1;


    UCHAR     AbortString[]="\r";

    switch (ModemControl->DialAnswer.State) {

        case DIALANSWER_STATE_SEND_ORIGINATE_COMMANDS:
        case DIALANSWER_STATE_SEND_COMMANDS:
        case DIALANSWER_STATE_SEND_VOICE_SETUP_COMMANDS:
            //
            //  The commands have not been sent yet, change state
            //
            ModemControl->DialAnswer.State=DIALANSWER_STATE_ABORTED;

            break;


        case DIALANSWER_STATE_SENDING_ORIGINATE_COMMANDS:
        case DIALANSWER_STATE_SENDING_COMMANDS:
        case DIALANSWER_STATE_DIAL_VOICE_CALL:
            //
            //  The commands have been send, send a <cr> to attempt to abort
            //
            LogString(ModemControl->Debug,IDS_ABORTING_COMMAND);

            PrintString(
                ModemControl->Debug,
                AbortString,
                1,
                PS_SEND
                );

            //
            //  sleep for a while so the modem can process the at command
            //  and will see the CR as an abort character and not another CR on
            //  the end of the commands string
            //
            Sleep(300);

            UmWriteFile(
                ModemControl->FileHandle,
                ModemControl->CompletionPort,
                AbortString,
                1,
                ConnectAbortWriteCompletionHandler,
                ModemControl
                );

            break;

        default:
            //
            //  just let things proceed as normal
            //
            break;
    }

    FreeOverStruct(UmOverlapped);

    return;

}





//****************************************************************************
// LPSTR CreateDialCommands(MODEMINFORMATION *pModemInfo, LPSTR szPhoneNumber,
//                          BOOL *fOriginate)
//
// Function: Create the dial strings in memory ala:
//              "<prefix> <blind_on/off> <dial prefix> <phonenumber> <dial suffix> <terminator>"
//              ...  more dial strings for long phone numbers...
//              "" <- final null of a doubly null terminated list
//
//  if no dial prefix, then return NULL
//  if no dial suffix, then don't do any commands after the first dial command
//
//  Set fOriginate to TRUE if these dial strings will cause a connection origination.
//                    FALSE otherwise.
//
//  break lines longer then HAYES_COMMAND_LENGTH
//
//  WARNING - this function is reall cheesy and hacked.  The main reason for this
//  is that it attempts to be memory (read: stack) optimized.
//
//  szPhoneNumber is a null terminated string of digits (0-9, $, @, W), with a possible
//  ';' at the end.  The semicolon can only be at the end.
//
//  Examples:
//
//  ""         -> originate          -> ATX_DT<cr>         fOriginate = TRUE
//  ";"        -> dialtone detection -> ATX_DT;<cr>        fOriginate = FALSE
//  "5551212"  -> dial and originate -> ATX_DT5551212<cr>  fOriginate = TRUE
//  "5551212;" -> dial               -> ATX_DT5551212;<cr> fOriginate = FALSE
//  "123456789012345678901234567890123456789012345678901234567890"
//             -> dial and originate -> ATX_DT12345678901234567890123456789012;<cr>
//                                      ATX_DT3456789012345678901234567890<cr>
//                                                         fOriginate = TRUE
//  "123456789012345678901234567890123456789012345678901234567890;"
//             -> dial               -> ATX_DT12345678901234567890123456789012;<cr>
//                                      ATX_DT3456789012345678901234567890;<cr>
//                                                         fOriginate = FALSE
//
// Returns: NULL on failure.
//          A null terminated buffer of the dial command on success.
//****************************************************************************

LPSTR WINAPI
CreateDialCommands(
    OBJECT_HANDLE     Debug,
    HANDLE            CommonInfo,
    DWORD             ModemOptionsCaps,
    DWORD             PreferredModemOptions,
    LPSTR             szPhoneNumber,
    BOOL              fOriginate,
    DWORD             DialOptions
    )
{
    DWORD   dwSize;
    DWORD   dwType;
    CHAR   pszDialPrefix[HAYES_COMMAND_LENGTH + 1];    // ex. "ATX4DT" or "ATX3DT"
    CHAR   pszDialSuffix[HAYES_COMMAND_LENGTH + 1];    // ex. ";<cr>"
    CHAR   pszOrigSuffix[HAYES_COMMAND_LENGTH + 1];    // ex. "<cr>"
    LPSTR  pchDest, pchSrc;
    LPSTR  pszzDialCommands = NULL;
    CHAR   pszShortTemp[2];
    CONST char szDialPrefix[] = "DialPrefix";
    CONST char szDialSuffix[] = "DialSuffix";
    CONST char szTone[] = "Tone";
    CONST char szPulse[] = "Pulse";
    DWORD    Length;

    BOOL     fHaveDialSuffix=TRUE;


    lstrcpyA(pszDialPrefix,"");
    //
    // read in prefix
    //
    GetCommonDialComponent(
        CommonInfo,
        pszDialPrefix,
        HAYES_COMMAND_LENGTH,
        COMMON_DIAL_COMMOND_PREFIX
        );


    //
    // do we support blind dialing and do we need to set the blind dialing state?
    //
    if ((MDM_BLIND_DIAL & ModemOptionsCaps)
          &&
          ((DialOptions & MDM_BLIND_DIAL) != (PreferredModemOptions & MDM_BLIND_DIAL))) {

        //
        // read in blind options
        //
        Length=GetCommonDialComponent(
            CommonInfo,
            pszDialPrefix+lstrlenA(pszDialPrefix),
            HAYES_COMMAND_LENGTH,
            DialOptions & MDM_BLIND_DIAL ? COMMON_DIAL_BLIND_ON : COMMON_DIAL_BLIND_OFF
            );

        if (Length == 0) {

            D_TRACE(UmDpf(Debug,"Could not get blind dial setting: %s.",DialOptions & MDM_BLIND_DIAL ? "Blind_On" : "Blind_Off");)

            goto Failure;
        }
    }


    // read in dial prefix

    Length=GetCommonDialComponent(
        CommonInfo,
        pszDialPrefix+lstrlenA(pszDialPrefix),
        HAYES_COMMAND_LENGTH,
        COMMON_DIAL_PREFIX
        );

    if (Length == 0) {

        D_TRACE(UmDpf(Debug,"Did not get 'DialPrefix'");)
        goto Failure;
    }

    //
    // can we do tone or pulse dialing?
    //
    if (MDM_TONE_DIAL & ModemOptionsCaps) {
        //
        // read in dial mode (tone or pulse)
        //
        Length=GetCommonDialComponent(
            CommonInfo,
            pszDialPrefix+lstrlenA(pszDialPrefix),
            HAYES_COMMAND_LENGTH,
            DialOptions & MDM_TONE_DIAL ? COMMON_DIAL_TONE : COMMON_DIAL_PULSE
            );

        if (Length == 0) {

            D_TRACE(UmDpf(Debug,"'%s' wasn't REG_SZ.",DialOptions & MDM_TONE_DIAL ? "Tone" : "Pulse");)

            goto Failure;
        }

    }

    //
    // read in dial suffix
    //
    Length=GetCommonDialComponent(
        CommonInfo,
        pszDialSuffix,
        HAYES_COMMAND_LENGTH,
        COMMON_DIAL_SUFFIX
        );

    if (Length <= 1) {

        if (!fOriginate) {
            //
            //  Not originating need semicolon
            //
            goto Failure;
        }

        D_TRACE(UmDpf(Debug,"Failed to get %s.", szDialSuffix);)
        lstrcpyA(pszDialSuffix, "");
        fHaveDialSuffix = FALSE;

    }

    //
    // read in prefix terminator
    //
    Length=GetCommonDialComponent(
        CommonInfo,
        pszOrigSuffix,
        HAYES_COMMAND_LENGTH,
        COMMON_DIAL_TERMINATION
        );

    if (Length != 0) {

        lstrcatA(pszDialSuffix, pszOrigSuffix);
        ASSERT(lstrlenA(pszOrigSuffix) <= lstrlenA(pszDialSuffix));
    }


    if ((lstrlenA(pszDialPrefix) + lstrlenA(pszDialSuffix)) > HAYES_COMMAND_LENGTH)
    {
        D_TRACE(UmDpf(Debug,"Dial Prefix and Dial Suffix is greater than HAYES_COMMAND_LENGTH");)

        goto Failure;
    }

    // allocate space for the phone number lines
    {
      DWORD dwBytesAlreadyTaken = lstrlenA(pszDialPrefix) + lstrlenA(pszDialSuffix);
      DWORD dwAvailBytesPerLine = (HAYES_COMMAND_LENGTH - dwBytesAlreadyTaken);
      DWORD dwPhoneNumLen       = lstrlenA(szPhoneNumber);
      DWORD dwNumLines          = dwPhoneNumLen ? (dwPhoneNumLen / dwAvailBytesPerLine +
  						 (dwPhoneNumLen % dwAvailBytesPerLine ? 1 : 0))
  					      : 1;  // handle null string
      dwSize                    = dwPhoneNumLen + dwNumLines * (dwBytesAlreadyTaken + 1) + 1;
    }

    D_TRACE(UmDpf(Debug,"Allocate %d bytes for Dial Commands.", dwSize);)

    pszzDialCommands = (LPSTR)ALLOCATE_MEMORY(dwSize);

    if (pszzDialCommands == NULL) {

        D_TRACE(UmDpf(Debug,"ran out of memory and failed an Allocate!");)
        goto Failure;
    }

    pchDest = pszzDialCommands;  // point to the beginning of the commands

    // build dial line(s):
    // do we have a dial suffix
    if (!fHaveDialSuffix) {

        // did we not want to originate?
        ASSERT(fOriginate);

        // build it
        lstrcpyA(pchDest, pszDialPrefix);
        lstrcatA(pchDest, szPhoneNumber);
        lstrcatA(pchDest, pszDialSuffix);

    } else {
        // we have a dial suffix.

        // populate new pszzDialCommands with semi-colons as necessary.

        // go through and add suffixi, making sure lines don't exceed HAYES_COMMAND_LENGTH
        pchSrc = szPhoneNumber;     // moves a character at a time.
        pszShortTemp[1] = 0;

        // prime the pump
        lstrcpyA(pchDest, pszDialPrefix);

        // step through the source
        while (*pchSrc) {

            if (lstrlenA(pchDest) + lstrlenA(pszDialSuffix) + 1 > HAYES_COMMAND_LENGTH) {

                // finish up this string
                lstrcatA(pchDest, pszDialSuffix);

                // begin a new string
                pchDest += lstrlenA(pchDest) + 1;
                lstrcpyA(pchDest, pszDialPrefix);

            } else {

                // copy char
                pszShortTemp[0] = *pchSrc;
                lstrcatA(pchDest, pszShortTemp);
                pchSrc++;
            }
        }

        // conclude with the approprate Suffix.
        lstrcatA(pchDest, (fOriginate ? pszOrigSuffix : pszDialSuffix));
    }

    return pszzDialCommands;

Failure:

    if (pszzDialCommands) {

        FREE_MEMORY(pszzDialCommands);
    }

    return NULL;
}


char *
ConstructNewPreDialCommands(
     HKEY hkDrv,
     DWORD dwNewProtoOpt
     )
//
//  1. Extract Bearermode and protocol info
//  2. Depending on  whether bearermode is GSM or ISDN or ANALOG,
//     construct the appropriate key name (Protoco\GSM, Protocol\ISDN or
//     NULL).
//  3. If NON-NULL, call read-commands.
//  4. Do the in-place macro translation.
//
{
    char *szzCommands = NULL;
    UINT u = 0;
    UINT uBearerMode = MDM_GET_BEARERMODE(dwNewProtoOpt);
    UINT uProtocolInfo = MDM_GET_PROTOCOLINFO(dwNewProtoOpt);
    char *szKey  =  NULL;
    char *szProtoKey = NULL;
    UINT cCommands = 0;
    char rgchTmp[256];

    switch(uBearerMode)
    {
        case MDM_BEARERMODE_ANALOG:
            break;

        case MDM_BEARERMODE_GSM:
            szKey = "PROTOCOL\\GSM";
            break;

        case MDM_BEARERMODE_ISDN:
            szKey = "PROTOCOL\\ISDN";
            break;

        default:
            break;
    }

    if (!szKey) goto end;

    //
    // Determine protocol key (TODO: this should all be consolidated under
    // the mini driver!).
    //
    switch(uProtocolInfo)
    {

    case MDM_PROTOCOL_AUTO_1CH:            szProtoKey = "AUTO_1CH";
        break;
    case MDM_PROTOCOL_AUTO_2CH:            szProtoKey = "AUTO_2CH";
        break;

    case MDM_PROTOCOL_HDLCPPP_56K:         szProtoKey = "HDLC_PPP_56K";
        break;
    case MDM_PROTOCOL_HDLCPPP_64K:         szProtoKey = "HDLC_PPP_64K";
        break;

    case MDM_PROTOCOL_HDLCPPP_112K:        szProtoKey = "HDLC_PPP_112K";
        break;
    case MDM_PROTOCOL_HDLCPPP_112K_PAP:    szProtoKey = "HDLC_PPP_112K_PAP";
        break;
    case MDM_PROTOCOL_HDLCPPP_112K_CHAP:   szProtoKey = "HDLC_PPP_112K_CHAP";
        break;
    case MDM_PROTOCOL_HDLCPPP_112K_MSCHAP: szProtoKey = "HDLC_PPP_112K_MSCHAP";
        break;

    case MDM_PROTOCOL_HDLCPPP_128K:        szProtoKey = "HDLC_PPP_128K";
        break;
    case MDM_PROTOCOL_HDLCPPP_128K_PAP:    szProtoKey = "HDLC_PPP_128K_PAP";
        break;
    case MDM_PROTOCOL_HDLCPPP_128K_CHAP:   szProtoKey = "HDLC_PPP_128K_CHAP";
        break;
    case MDM_PROTOCOL_HDLCPPP_128K_MSCHAP: szProtoKey = "HDLC_PPP_128K_MSCHAP";
        break;

    case MDM_PROTOCOL_V120_64K:            szProtoKey = "V120_64K";
        break;
    case MDM_PROTOCOL_V120_56K:            szProtoKey = "V120_56K";
        break;
    case MDM_PROTOCOL_V120_112K:           szProtoKey = "V120_112K";
        break;
    case MDM_PROTOCOL_V120_128K:           szProtoKey = "V120_128K";
        break;

    case MDM_PROTOCOL_X75_64K:             szProtoKey = "X75_64K";
        break;
    case MDM_PROTOCOL_X75_128K:            szProtoKey = "X75_128K";
        break;
    case MDM_PROTOCOL_X75_T_70:            szProtoKey = "X75_T_70";
        break;
    case MDM_PROTOCOL_X75_BTX:             szProtoKey = "X75_BTX";
        break;

    case MDM_PROTOCOL_V110_1DOT2K:         szProtoKey = "V110_1DOT2K";
        break;
    case MDM_PROTOCOL_V110_2DOT4K:         szProtoKey = "V110_2DOT4K";
        break;
    case MDM_PROTOCOL_V110_4DOT8K:         szProtoKey = "V110_4DOT8K";
        break;
    case MDM_PROTOCOL_V110_9DOT6K:         szProtoKey = "V110_9DOT6K";
        break;
    case MDM_PROTOCOL_V110_12DOT0K:        szProtoKey = "V110_12DOT0K";
        break;
    case MDM_PROTOCOL_V110_14DOT4K:        szProtoKey = "V110_14DOT4K";
        break;
    case MDM_PROTOCOL_V110_19DOT2K:        szProtoKey = "V110_19DOT2K";
        break;
    case MDM_PROTOCOL_V110_28DOT8K:        szProtoKey = "V110_28DOT8K";
        break;
    case MDM_PROTOCOL_V110_38DOT4K:        szProtoKey = "V110_38DOT4K";
        break;
    case MDM_PROTOCOL_V110_57DOT6K:        szProtoKey = "V110_57DOT6K";
        break;
    //
    // for japanese PIAFS
    //
    case MDM_PROTOCOL_PIAFS_INCOMING:      szProtoKey = "PIAFS_INCOMING";
        break;
    case MDM_PROTOCOL_PIAFS_OUTGOING:      szProtoKey = "PIAFS_OUTGOING";
        break;
    //
    //  for isdn modem that can v34 or the digital channel
    //
    case MDM_PROTOCOL_ANALOG_V34:          szProtoKey = "ANALOG_V34";
        break;
    //
    // The following two are GSM specific, but we don't bother to assert that
    // here -- if we find the key under the chosen protocol, we use it.
    //
    case MDM_PROTOCOL_ANALOG_RLP:        szProtoKey = "ANALOG_RLP";
        break;
    case MDM_PROTOCOL_ANALOG_NRLP:       szProtoKey = "ANALOG_NRLP";
        break;
    case MDM_PROTOCOL_GPRS:              szProtoKey = "GPRS";
        break;

    default:
        goto end;

    };
    

    if ( (lstrlenA(szKey) + lstrlenA(szProtoKey) + sizeof "\\")
          > sizeof(rgchTmp))
    {
        return NULL;
    }

    wsprintfA(rgchTmp, "%s\\%s", szKey, szProtoKey);

    szzCommands=NewLoadRegCommands(
        hkDrv,
        rgchTmp
        );

end:
    return szzCommands;
}



DWORD
_inline
GetMultiSZLength(
    PSTR    MultiSZ
    )

{
    PUCHAR  Temp;

    Temp=MultiSZ;

    while (1) {

        if (*Temp++ == '\0') {

            if (*Temp++ == '\0') {

                break;
            }
        }
    }

    return (DWORD)(Temp-MultiSZ);

}

PSTR WINAPI
ConcatenateMultiSz(
    LPSTR       PrependStrings,
    LPSTR       AppendStrings
    )

{
    PSTR               Commands;
    PSTR               pTemp;
    DWORD              AppendLength=0;
    DWORD              PrependLength=0;


    if (AppendStrings != NULL) {
        //
        //  strings to be appened
        //
        AppendLength=GetMultiSZLength(AppendStrings);
    }

    if (PrependStrings != NULL) {
        //
        //  strings to be prepened
        //
        PrependLength=GetMultiSZLength(PrependStrings);
    }

    if ((AppendLength + PrependLength) == (DWORD)0)
    {
        D_TRACE(DebugPrint("string length is NULL .. no need to allocate");)
        return NULL;
    }


    Commands=ALLOCATE_MEMORY((DWORD)(AppendLength+PrependLength));

    if (NULL == Commands) {

        D_TRACE(DebugPrint("GetCommonCommandStringCopy: Alloc failed");)

        return NULL;
    }


    CopyMemory(Commands,PrependStrings,PrependLength);

    if (PrependLength == 0) {

        PrependLength++;
    }

    CopyMemory(&Commands[(PrependLength-1)],AppendStrings,AppendLength);

    return Commands;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\hangup.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    hangup.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"


#define HANGUP_STATE_DATA_CONNECTION        1
#define HANGUP_STATE_LOWERED_DTR            2
#define HANGUP_STATE_SENT_PLUSES            3
#define HANGUP_STATE_COMMAND_MODE           4
#define HANGUP_STATE_SENT_HANGUP_COMMAND    5
#define HANGUP_STATE_GET_RESPONSE           6
#define HANGUP_STATE_FAILURE                7
#define HANGUP_STATE_HANGUP_NULL_MODEM      8
#define HANGUP_STATE_HANGUP_NULL_MODEM_DONE 9



VOID WINAPI
HangupWriteCompletionHandler(
    DWORD              ErrorCode,
    DWORD              BytesWritten,
    LPOVERLAPPED       Overlapped
    );

VOID
HangupHandler(
    PMODEM_CONTROL    ModemControl,
    DWORD             Status
    );

VOID
HangupHandlerFirstStep(
    PMODEM_CONTROL    ModemControl,
    DWORD             Status
    );


VOID
CancelConnectionTimer(
    PMODEM_CONTROL    ModemControl
    )

{
    if (ModemControl->ConnectionTimer != NULL) {

        CancelUnimodemTimer(
            ModemControl->ConnectionTimer
            );

        FreeUnimodemTimer(
            ModemControl->ConnectionTimer
            );

        ModemControl->ConnectionTimer=NULL;

        RemoveReferenceFromObject(&ModemControl->Header);

    }
    return;

}




DWORD WINAPI
UmHangupModem(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    DWORD     Flags
    )

{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)ReferenceObjectByHandleAndLock(ModemHandle);
    LONG              lResult=ERROR_IO_PENDING;
    DWORD             ModemStatus;
    BOOL              bResult;


    ASSERT(ModemControl->CurrentCommandType == COMMAND_TYPE_NONE);

    if (ModemControl->CurrentCommandType != COMMAND_TYPE_NONE) {

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_UNIMODEM_INUSE;
    }

    LogString(ModemControl->Debug, IDS_MSGLOG_HANGUP);


    ModemControl->CurrentCommandStrings=NULL;

    SetPassthroughMode(
        ModemControl->FileHandle,
        MODEM_NOPASSTHROUGH_INC_SESSION_COUNT
        );


    if (ModemControl->RegInfo.DeviceType != DT_NULL_MODEM) {

        GetCommModemStatus(
            ModemControl->FileHandle,
            &ModemStatus
            );


        if (ModemStatus & MS_RLSD_ON) {

            ModemControl->Hangup.State = HANGUP_STATE_DATA_CONNECTION;

        } else {

            if (ModemControl->ConnectionState == CONNECTION_STATE_DATA_REMOTE_DISCONNECT) {

                ModemControl->Hangup.State = HANGUP_STATE_GET_RESPONSE;

            } else {

                ModemControl->Hangup.State = HANGUP_STATE_COMMAND_MODE;
                ModemControl->Hangup.Retry = 3;
            }

        }

    } else {
        //
        //  Null modem, just assume it a connected
        //
        ModemControl->Hangup.State = HANGUP_STATE_HANGUP_NULL_MODEM;

    }

    ModemControl->CurrentCommandType=COMMAND_TYPE_HANGUP;

    bResult=StartAsyncProcessing(
        ModemControl,
        HangupHandlerFirstStep,
        ModemControl,
        ERROR_SUCCESS
        );


    if (!bResult) {
        //
        //  failed
        //
        ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_NOT_ENOUGH_MEMORY;

    }

    RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

    return lResult;

}



VOID
HangupHandlerFirstStep(
    PMODEM_CONTROL    ModemControl,
    DWORD             Status
    )
{

    CancelModemEvent(
        ModemControl->ModemEvent
        );

    CancelConnectionTimer(
        ModemControl
        );

    HangupHandler(
       ModemControl,
       ERROR_SUCCESS
       );

    return;

}


VOID
HangupHandler(
    PMODEM_CONTROL    ModemControl,
    DWORD             Status
    )

{

    DWORD    BytesWritten;
    BOOL     ExitLoop=FALSE;
    DWORD             ModemStatus=0;
    BOOL     bResult;

    D_TRACE(UmDpf(ModemControl->Debug,"HangupHandler: %d, state=%d",Status,ModemControl->Hangup.State);)


    AddReferenceToObject(
        &ModemControl->Header
        );


    while (!ExitLoop) {

        switch (ModemControl->Hangup.State) {

            case HANGUP_STATE_DATA_CONNECTION:

                PurgeComm(
                    ModemControl->FileHandle,
                    PURGE_RXCLEAR | PURGE_TXCLEAR
                    );

                LogString(ModemControl->Debug, IDS_MSGLOG_HARDWAREHANGUP);
                //
                //  lower DTR
                //
                bResult=WaitForModemEvent(
                    ModemControl->ModemEvent,
                    (ModemControl->RegInfo.DeviceType == DT_NULL_MODEM) ? EV_DSR : EV_RLSD,
                    10*1000,
                    HangupHandler,
                    ModemControl
                    );

                if (!bResult) {
                    //
                    //  failed,
                    //
                    ModemControl->Hangup.State=HANGUP_STATE_FAILURE;

                    break;
                }



                EscapeCommFunction(ModemControl->FileHandle, CLRDTR);

                ModemControl->Hangup.State=HANGUP_STATE_LOWERED_DTR;

                ExitLoop=TRUE;

                break;

            case HANGUP_STATE_LOWERED_DTR:

                EscapeCommFunction(ModemControl->FileHandle, SETDTR);

                GetCommModemStatus(
                    ModemControl->FileHandle,
                    &ModemStatus
                    );

                if (ModemStatus & MS_RLSD_ON) {
                    //
                    //  CD is still high after 10 seconds, try send +++
                    //  and see if the modem responds.
                    //
                    LogString(ModemControl->Debug, IDS_MSGWARN_FAILEDDTRDROPPAGE);

                    PrintString(
                        ModemControl->Debug,
                        "+++",
                        3,
                        PS_SEND
                        );


                    UmWriteFile(
                        ModemControl->FileHandle,
                        ModemControl->CompletionPort,
                        "+++",
                        3,
                        HangupWriteCompletionHandler,
                        ModemControl
                        );

                    //
                    //  wait another 10 seconds for CD to drop from +++
                    //
                    bResult=WaitForModemEvent(
                        ModemControl->ModemEvent,
                        EV_RLSD,
                        10*1000,
                        HangupHandler,
                        ModemControl
                        );

                    if (!bResult) {
                        //
                        //  failed,
                        //
                        ModemControl->Hangup.State=HANGUP_STATE_FAILURE;

                        break;
                    }



                    ModemControl->Hangup.State = HANGUP_STATE_SENT_PLUSES;
                    ModemControl->Hangup.Retry = 3;

                    ExitLoop=TRUE;

                } else {

                    LogString(ModemControl->Debug, IDS_HANGUP_CD_LOW);

                    ModemControl->Hangup.State = HANGUP_STATE_GET_RESPONSE;
                    ModemControl->Hangup.Retry = 3;

                }
                break;

            case HANGUP_STATE_GET_RESPONSE:

                ModemControl->Hangup.State = HANGUP_STATE_COMMAND_MODE;
                ModemControl->Hangup.Retry = 3;

                StartResponseEngine(
                   ModemControl->ReadState,
                   ModemControl
                   );

                RegisterCommandResponseHandler(
                    ModemControl->ReadState,
                    "",
                    HangupHandler,
                    ModemControl,
                    1000,
                    0
                    );

                ExitLoop=TRUE;
                break;

            case HANGUP_STATE_SENT_PLUSES:
            case HANGUP_STATE_COMMAND_MODE:

                StartResponseEngine(
                    ModemControl->ReadState,
                    ModemControl
                    );


                ModemControl->CurrentCommandStrings=NULL;

                if (ModemControl->ConnectionState == CONNECTION_STATE_VOICE) {
                    //
                    //  voice call see if there is a voice hangup command
                    //
                    ModemControl->CurrentCommandStrings=GetCommonCommandStringCopy(
                        ModemControl->CommonInfo,
                        COMMON_VOICE_HANGUP_COMMANDS,
                        NULL,
                        NULL
                        );

                }

                if (ModemControl->CurrentCommandStrings == NULL) {
                    //
                    //  either it wasn't a voice call,  or the voice hangupkey is empty(old inf)
                    //
                    ModemControl->CurrentCommandStrings=GetCommonCommandStringCopy(
                        ModemControl->CommonInfo,
                        COMMON_HANGUP_COMMANDS,
                        NULL,
                        NULL
                        );
                }

                Status=IssueCommand(
                    ModemControl->CommandState,
                    ModemControl->CurrentCommandStrings,
                    HangupHandler,
                    ModemControl,
                    5*1000,
                    0
                    );

                if (Status != ERROR_IO_PENDING) {
                    //
                    //  failed
                    //
                    ModemControl->Hangup.State=HANGUP_STATE_FAILURE;

                    break;
                }


                ModemControl->Hangup.State = HANGUP_STATE_SENT_HANGUP_COMMAND;

                ExitLoop=TRUE;

                break;


            case HANGUP_STATE_SENT_HANGUP_COMMAND:

                FREE_MEMORY(ModemControl->CurrentCommandStrings);

                ModemControl->CurrentCommandStrings=NULL;

                if (ModemControl->ConnectionState == CONNECTION_STATE_VOICE) {
                    //
                    //  voice call stop dle monitoring
                    //
                    StopDleMonitoring(ModemControl->Dle,NULL);
                }

                if ((Status == ERROR_SUCCESS) || (ModemControl->Hangup.Retry == 0)) {

                    ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

                    ModemControl->ConnectionState = CONNECTION_STATE_NONE;

                    (*ModemControl->NotificationProc)(
                        ModemControl->NotificationContext,
                        MODEM_ASYNC_COMPLETION,
                        Status,
                        0
                        );

                    //
                    //  remove the reference added, when async processing was queued
                    //
                    RemoveReferenceFromObject(&ModemControl->Header);

                    ExitLoop=TRUE;

                } else {

                    ModemControl->Hangup.Retry--;

                    ModemControl->Hangup.State = HANGUP_STATE_COMMAND_MODE;

                }

                break;


            case HANGUP_STATE_HANGUP_NULL_MODEM:

                PurgeComm(
                    ModemControl->FileHandle,
                    PURGE_RXCLEAR | PURGE_TXCLEAR
                    );

                LogString(ModemControl->Debug, IDS_MSGLOG_HARDWAREHANGUP);
                //
                //  lower DTR
                //
                bResult=WaitForModemEvent(
                    ModemControl->ModemEvent,
                    EV_DSR,
                    2*1000,
                    HangupHandler,
                    ModemControl
                    );

                if (!bResult) {
                    //
                    //  failed,
                    //
                    ModemControl->Hangup.State=HANGUP_STATE_FAILURE;

                    break;
                }

                EscapeCommFunction(ModemControl->FileHandle, CLRDTR);

                ModemControl->Hangup.State=HANGUP_STATE_HANGUP_NULL_MODEM_DONE;

                ExitLoop=TRUE;

                break;

            case HANGUP_STATE_HANGUP_NULL_MODEM_DONE:

                ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

                ModemControl->ConnectionState = CONNECTION_STATE_NONE;

                StartResponseEngine(
                    ModemControl->ReadState,
                    ModemControl
                    );


                //
                //  raise dtr again
                //
                EscapeCommFunction(ModemControl->FileHandle, SETDTR);

                //
                //  always return success
                //
                (*ModemControl->NotificationProc)(
                    ModemControl->NotificationContext,
                    MODEM_ASYNC_COMPLETION,
                    ERROR_SUCCESS,
                    0
                    );

                RemoveReferenceFromObject(&ModemControl->Header);

                ExitLoop=TRUE;

                break;

            case HANGUP_STATE_FAILURE:

                if (ModemControl->CurrentCommandStrings != NULL) {

                    FREE_MEMORY(ModemControl->CurrentCommandStrings);
                }

                ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

                ModemControl->ConnectionState = CONNECTION_STATE_NONE;

                (*ModemControl->NotificationProc)(
                    ModemControl->NotificationContext,
                    MODEM_ASYNC_COMPLETION,
                    ERROR_UNIMODEM_GENERAL_FAILURE,
                    0
                    );

                (*ModemControl->NotificationProc)(
                    ModemControl->NotificationContext,
                    MODEM_HARDWARE_FAILURE,
                    0,
                    0
                    );


                //
                //  remove the reference added, when async processing was queued
                //
                RemoveReferenceFromObject(&ModemControl->Header);

                ExitLoop=TRUE;


                break;

            default:

                break;

        }
    }

    RemoveReferenceFromObject(&ModemControl->Header);

    return;
}









VOID WINAPI
HangupWriteCompletionHandler(
    DWORD              ErrorCode,
    DWORD              BytesWritten,
    LPOVERLAPPED       Overlapped
    )

{

    PUM_OVER_STRUCT    UmOverlapped=(PUM_OVER_STRUCT)Overlapped;

    D_TRACE(DebugPrint("UNIMDMAT: Write Complete\n");)

    FreeOverStruct(UmOverlapped);

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\dle.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dle.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"

#include <devioctl.h>
#include <ntddmodm.h>


#define  DLE_BUFFER_SIZE    16

#define  DLE_STATE_STARTING            1
#define  DLE_STATE_HANDLE_COMPLETION   2
#define  DLE_STATE_FAILURE             3
#define  DLE_STATE_STOPPING            4
#define  DLE_STATE_STOPPED             5

#define  STATE_DTMF_NONE           0
#define  STATE_DTMF_START          1
#define  STATE_DTMF_RECEIVING      2



//deefine  DLE_SHIELD                0x21
//#define  DLE_PAIR                  0x22
//#define  DLE_OFHOOK_IS101          0x48  //is-101 value

//       00          01          02          03          04          05          06          07
//       08          09          0a          0b          0c          0d          0e          0f

BYTE DefaultDleTable[128]={
//0
         DLE_______, DLE_______, DLE_______, DLE_ETX   , DLE_______, DLE_______, DLE_______, DLE_______,
         DLE_______, DLE_______, DLE_______, DLE_______, DLE_______, DLE_______, DLE_______, DLE_______,
//1
         DLE_______, DLE_______, DLE_______, DLE_______, DLE_______, DLE_______, DLE_______, DLE_______,
         DLE_______, DLE_______, DLE_______, DLE_______, DLE_______, DLE_______, DLE_______, DLE_______,
//2
         DLE_______, DLE_______, DLE_______, DTMF_POUND, DLE_______, DLE_______, DLE_______, DLE_______,
         DLE_______, DLE_______, DTMF_STAR , DLE_______, DLE_______, DLE_______, DLE_______, DTMF_START,
//3
         DTMF_0    , DTMF_1    , DTMF_2    , DTMF_3    , DTMF_4    , DTMF_5    , DTMF_6    , DTMF_7    ,
         DTMF_8    , DTMF_9    , DLE_______, DLE_______, DLE_______, DLE_______, DLE_______, DLE_______,
//4
         DLE_______, DTMF_A    , DTMF_B    , DTMF_C    , DTMF_D    , DTMF_STAR , DTMF_POUND, DLE_______,
         DLE_OFHOOK, DLE_______, DLE_______, DLE_______, DLE_LOOPRV, DLE_______, DLE_FAX   , DLE_______,
//5
         DLE_______, DLE_______, DLE_RING  , DLE_SILENC, DLE_______, DLE_______, DLE_______, DLE_______,
         DLE_______, DLE_______, DLE_______, DLE_______, DLE_______, DLE_______, DLE_______, DLE_______,
//6
         DLE_______, DLE_ANSWER, DLE_BUSY  , DLE_FAX   , DLE_DIALTN, DLE_DATACT, DLE_BELLAT, DLE_______,
         DLE_ONHOOK, DLE_______, DLE_______, DLE_______, DLE_LOOPIN, DLE_______, DLE_______, DLE_______,
//7
         DLE_______, DLE_QUIET , DLE_RINGBK, DLE_SILENC, DLE_OFHOOK, DLE_______, DLE_______, DLE_______,
         DLE_______, DLE_______, DLE_______, DLE_______, DLE_______, DLE_______, DTMF_END  , DLE_______
                                                                                };

#define  DLE_OBJECT_SIG  ('LDMU')  //UMDL

typedef struct _DLE_OBJECT {

    OBJECT_HEADER          Header;

    HANDLE                 FileHandle;
    HANDLE                 CompletionPort;

    LPUMNOTIFICATIONPROC   AsyncNotificationProc;
    HANDLE                 AsyncNotificationContext;

    OBJECT_HANDLE          Debug;

    DWORD                  State;

    HANDLE                 StopEvent;


    DWORD                  DTMFState;
    BYTE                   LastDTMF;


    CHAR                   DleBuffer[DLE_BUFFER_SIZE];

} DLE_OBJECT, *PDLE_OBJECT;


VOID WINAPI
DleMatchHandler(
    PDLE_OBJECT        DleObject,
    BYTE               DleValue
    );

VOID WINAPI
HandleDTMF(
    PDLE_OBJECT         DleObject,
    BYTE                Character
    );



VOID WINAPI
DleHandler(
    DWORD              ErrorCode,
    DWORD              Bytes,
    LPOVERLAPPED       Overlapped
    );




DWORD WINAPI
ControlDleDetection(
    HANDLE    FileHandle,
    DWORD     StartStop
    );


VOID
DleObjectClose(
    POBJECT_HEADER  Object
    )

{

    PDLE_OBJECT        DleObject=(PDLE_OBJECT)Object;

    D_TRACE(UmDpf(DleObject->Debug,"DleObjectClose ref=%d",DleObject->Header.ReferenceCount);)

    if (DleObject->State != DLE_STATE_STOPPED) {

        DleObject->State = DLE_STATE_STOPPING;

    }

    ControlDleDetection(
        DleObject->FileHandle,
        MODEM_DLE_MONITORING_OFF
        );


    return;

}




VOID
DleObjectCleanUp(
    POBJECT_HEADER  Object
    )

{

    PDLE_OBJECT        DleObject=(PDLE_OBJECT)Object;

    D_TRACE(UmDpf(DleObject->Debug,"DleObjectCleanup");)

    return;

}


OBJECT_HANDLE WINAPI
InitializeDleHandler(
    POBJECT_HEADER     OwnerObject,
    HANDLE             FileHandle,
    HANDLE             CompletionPort,
    LPUMNOTIFICATIONPROC  AsyncNotificationProc,
    HANDLE             AsyncNotificationContext,
    OBJECT_HANDLE      Debug
    )

{

    PDLE_OBJECT        DleObject;
    OBJECT_HANDLE      ObjectHandle;

    ObjectHandle=CreateObject(
        sizeof(*DleObject),
        OwnerObject,
        DLE_OBJECT_SIG,
        DleObjectCleanUp,
        DleObjectClose
        );

    if (ObjectHandle == NULL) {

        return NULL;
    }

    //
    //  reference the handle to get a pointer to the object
    //
    DleObject=(PDLE_OBJECT)ReferenceObjectByHandle(ObjectHandle);


    //
    //  intialize the object
    //
    DleObject->FileHandle=FileHandle;
    DleObject->CompletionPort=CompletionPort;


    DleObject->AsyncNotificationProc=AsyncNotificationProc;
    DleObject->AsyncNotificationContext=AsyncNotificationContext;

    DleObject->Debug=Debug;

    DleObject->State=0;

    DleObject->DTMFState=STATE_DTMF_NONE;

    //
    //  release the reference to the object
    //
    RemoveReferenceFromObject(&DleObject->Header);


    return ObjectHandle;

}


DWORD WINAPI
ControlDleDetection(
    HANDLE    FileHandle,
    DWORD     StartStop
    )


/*++

Routine Description:


Arguments:


Return Value:



--*/

{
    DWORD       BytesTransfered;

    return SyncDeviceIoControl(
        FileHandle,
        IOCTL_MODEM_SET_DLE_MONITORING,
        &StartStop,
        sizeof(StartStop),
        NULL,
        0,
        &BytesTransfered
        );

}


DWORD WINAPI
ControlDleShielding(
    HANDLE    FileHandle,
    DWORD     StartStop
    )


/*++

Routine Description:


Arguments:


Return Value:



--*/

{
    DWORD       BytesTransfered;

    return SyncDeviceIoControl(
        FileHandle,
        IOCTL_MODEM_SET_DLE_SHIELDING,
        &StartStop,
        sizeof(StartStop),
        NULL,
        0,
        &BytesTransfered
        );

}




LONG WINAPI
StartDleMonitoring(
    OBJECT_HANDLE  ObjectHandle
    )

{
    PDLE_OBJECT     DleObject;
    LONG            lResult;

    PUM_OVER_STRUCT UmOverlapped;


    DleObject=(PDLE_OBJECT)ReferenceObjectByHandleAndLock(ObjectHandle);

    UmOverlapped=AllocateOverStruct(DleObject->CompletionPort);

    if (UmOverlapped == NULL) {

        RemoveReferenceFromObjectAndUnlock(&DleObject->Header);

        return ERROR_NOT_ENOUGH_MEMORY;

    }


    lResult=ControlDleDetection(
        DleObject->FileHandle,
        MODEM_DLE_MONITORING_ON
        );

    if (lResult != ERROR_SUCCESS) {

        RemoveReferenceFromObjectAndUnlock(&DleObject->Header);

        return lResult;
    }

    //
    //  clear out the current read so the next read irp will be monitored when it completes
    //
    PurgeComm(
        DleObject->FileHandle,
        PURGE_RXABORT
        );

    DleObject->State=DLE_STATE_STARTING;

    //
    //  Kick the handler
    //
    UmOverlapped->Context1=DleObject;
    UmOverlapped->Overlapped.Internal=ERROR_SUCCESS;

    AddReferenceToObject(
        &DleObject->Header
        );


    UnimodemQueueUserAPC(
        (LPOVERLAPPED)UmOverlapped,
        DleHandler
        );


    RemoveReferenceFromObjectAndUnlock(&DleObject->Header);

    return ERROR_SUCCESS;

}


LONG WINAPI
StopDleMonitoring(
    OBJECT_HANDLE  ObjectHandle,
    HANDLE         Event
    )

{
    PDLE_OBJECT     DleObject;
    LONG            lResult;


    DleObject=(PDLE_OBJECT)ReferenceObjectByHandleAndLock(ObjectHandle);

    if (DleObject->State != DLE_STATE_STOPPED) {

        DleObject->State = DLE_STATE_STOPPING;

        lResult=ControlDleDetection(
            DleObject->FileHandle,
            MODEM_DLE_MONITORING_OFF
            );

        PurgeComm(
            DleObject->FileHandle,
            PURGE_RXABORT
            );

        if (Event != NULL) {
            //
            //  caller wants to wait for stop to complete
            //
            DleObject->StopEvent=Event;

            UnlockObject(
                &DleObject->Header
                );

            //
            //  event will be set when state machine reaches stopped state
            //
            WaitForSingleObjectEx(
                Event,
                INFINITE,
                TRUE
                );

            LockObject(
                &DleObject->Header
                );

            DleObject->StopEvent=NULL;
        }


    }

    RemoveReferenceFromObjectAndUnlock(&DleObject->Header);

    return ERROR_SUCCESS;

}



VOID WINAPI
DleHandler(
    DWORD              ErrorCode,
    DWORD              Bytes,
    LPOVERLAPPED       Overlapped
    )

{

    PUM_OVER_STRUCT    UmOverlapped=(PUM_OVER_STRUCT)Overlapped;

    PDLE_OBJECT     DleObject;
    BOOL            ExitLoop=FALSE;
    DWORD           BytesRead;
    BOOL            bResult;

    DleObject=(PDLE_OBJECT)UmOverlapped->Context1;

    AddReferenceToObject(
        &DleObject->Header
        );

    LockObject(
        &DleObject->Header
        );


    D_TRACE(UmDpf(DleObject->Debug,"DleHandler");)

    while (!ExitLoop) {

        switch (DleObject->State) {


            case DLE_STATE_STARTING: {

                ReinitOverStruct(UmOverlapped);

                UmOverlapped->Context1=DleObject;

                DleObject->State=DLE_STATE_HANDLE_COMPLETION;

                bResult=UnimodemDeviceIoControlEx(
                    DleObject->FileHandle,
                    IOCTL_MODEM_GET_DLE,
                    NULL,
                    0,
                    DleObject->DleBuffer,
                    sizeof(DleObject->DleBuffer),
                    &UmOverlapped->Overlapped,
                    DleHandler
                    );



                if (!bResult && GetLastError() != ERROR_IO_PENDING) {

                    D_TRACE(UmDpf(DleObject->Debug,"DeviceIoControl failed- %08lx",GetLastError());)

                    DleObject->State=DLE_STATE_FAILURE;

                    break;

                }

                ExitLoop=TRUE;

                break;
            }

            case DLE_STATE_HANDLE_COMPLETION: {

                DWORD   i;

                bResult=GetOverlappedResult(
                    DleObject->FileHandle,
                    &UmOverlapped->Overlapped,
                    &BytesRead,
                    FALSE
                    );


                if (!bResult) {

                    D_TRACE(UmDpf(DleObject->Debug,"DeviceIoControl failed- %08lx",GetLastError());)

                    DleObject->State=DLE_STATE_FAILURE;

                    break;
                }


                ASSERT(BytesRead <= sizeof(DleObject->DleBuffer));

                for (i=0; i<BytesRead; i++) {

                    DleMatchHandler(
                        DleObject,
                        DleObject->DleBuffer[i]
                        );


                }



                DleObject->State=DLE_STATE_STARTING;

                break;
            }

            case DLE_STATE_FAILURE: {

                UnlockObject(
                    &DleObject->Header
                    );


                (*DleObject->AsyncNotificationProc)(
                    DleObject->AsyncNotificationContext,
                    MODEM_HARDWARE_FAILURE,
                    0,
                    0
                    );

                LockObject(
                    &DleObject->Header
                    );

                DleObject->State=DLE_STATE_STOPPED;

                break;

            }

            case DLE_STATE_STOPPING: {

                DleObject->State=DLE_STATE_STOPPED;

                break;

            }


            case DLE_STATE_STOPPED: {

                D_TRACE(UmDpf(DleObject->Debug,"DLE_STATE_STOPPED");)

                if (DleObject->StopEvent != NULL) {
                    //
                    //  signal event so the stop engine code will run
                    //
                    SetEvent(DleObject->StopEvent);
                }


                RemoveReferenceFromObject(
                    &DleObject->Header
                    );

                ExitLoop=TRUE;

                FreeOverStruct(UmOverlapped);

                break;

            }




            default:

                ASSERT(0);

                ExitLoop=TRUE;

                break;

        }
    }


    RemoveReferenceFromObjectAndUnlock(&DleObject->Header);

    return;

}


VOID WINAPI
DleMatchHandler(
    PDLE_OBJECT        DleObject,
    BYTE               RawValue
    )
/*++

Routine Description:

    posts appropreate message to window for DLE

Arguments:


Return Value:



--*/

{

    BYTE               DleValue=DLE_______;


    if (RawValue <= 127) {

        DleValue=DefaultDleTable[RawValue];
    }

    D_TRACE(UmDpf(DleObject->Debug,"Unimodem: DleMatchHandler: Got Dle =%x",DleValue);)

    LogDleCharacter(DleObject->Debug, RawValue, DleValue);

    if (((DleValue >= DTMF_0) && (DleValue <= DTMF_END))) {

        HandleDTMF(
            DleObject,
            DleValue
            );

        return;
    }


    if (DleValue != DLE_______) {


        UnlockObject(
            &DleObject->Header
            );


        (*DleObject->AsyncNotificationProc)(
            DleObject->AsyncNotificationContext,
            MODEM_DLE_START+(DleValue-DLE_OFHOOK),
            DleValue,
            0
            );

        LockObject(
            &DleObject->Header
            );

    }

    return;
}







UCHAR WINAPI
ConvertToDTMF(
    UCHAR   Character
    )

{
    if (Character >= DTMF_0 && Character <= DTMF_9) {

        return Character-DTMF_0+'0';

    } else {

        if (Character >= DTMF_A && Character <= DTMF_D) {

            return Character-DTMF_A+'A';

        } else {

            if (Character == DTMF_STAR) {

                return '*';

            } else {

                return '#';

            }
        }
    }

    return 0;

}

VOID WINAPI
HandleDTMF(
    PDLE_OBJECT         DleObject,
    BYTE                Character
    )
/*++

Routine Description:


Arguments:


Return Value:



--*/

{


    switch (DleObject->DTMFState) {

        case STATE_DTMF_NONE:

             if (Character == DTMF_START) {

                 DleObject->DTMFState=STATE_DTMF_START;

             } else {
                 //
                 //  rockwell does not have start and stop characters
                 //
                 if ((Character >= DTMF_0 && Character <= DTMF_POUND)) {

                    DleObject->LastDTMF=Character;

                    D_TRACE(UmDpf(DleObject->Debug,"Unimodem: HandleDTMF: StartTone= %0x time=%d",Character,(DWORD)GetTickCount());)

                    //
                    //  We send one message that means both an up and down
                    //  event occured. We do this becuase the shell post message
                    //  service seems to post the messages in a reverse order to
                    //  the order that we called the service. Which means that
                    //  you get the tone end before tone start
                    //

                    UnlockObject(
                        &DleObject->Header
                        );


                    (*DleObject->AsyncNotificationProc)(
                        DleObject->AsyncNotificationContext,
                        MODEM_DTMF_START_DETECTED,
                        ConvertToDTMF(Character),
                        GetTickCount()
                        );

                    (*DleObject->AsyncNotificationProc)(
                        DleObject->AsyncNotificationContext,
                        MODEM_DTMF_STOP_DETECTED,
                        ConvertToDTMF(Character),
                        GetTickCount()
                        );

                    LockObject(
                        &DleObject->Header
                        );


                } else {

                    D_TRACE(UmDpf(DleObject->Debug,"Unimodem: HandleDTMF: ERROR: NONE got %0x",Character);)
                }

            }

            break;

        case STATE_DTMF_START:

            if (Character >= DTMF_0 && Character <= DTMF_POUND) {

               DleObject->LastDTMF=Character;
               DleObject->DTMFState=STATE_DTMF_RECEIVING;

               D_TRACE(UmDpf(DleObject->Debug,"Unimodem: HandleDTMF: StartTone= %0x",Character);)

               UnlockObject(
                   &DleObject->Header
                   );


               (*DleObject->AsyncNotificationProc)(
                   DleObject->AsyncNotificationContext,
                   MODEM_DTMF_START_DETECTED,
                   ConvertToDTMF(Character),
                   GetTickCount()
                   );


               LockObject(
                   &DleObject->Header
                   );



            } else {

               DleObject->DTMFState=STATE_DTMF_NONE;

               D_TRACE(UmDpf(DleObject->Debug,"Unimodem: HandleDTMF: ERROR: START got %0x",Character);)
            }

            break;

        case STATE_DTMF_RECEIVING:

            if (Character == DleObject->LastDTMF) {

               DleObject->DTMFState=STATE_DTMF_RECEIVING;

            } else {

                //
                // added check for start w/o end for compaq modem
                // which will lose an end if a wave opreration is initiated
                //
                if ((Character == DTMF_END)  || (Character == DTMF_START)) {

                    D_TRACE(UmDpf(DleObject->Debug,"Unimodem: HandleDTMF: EndTone= %0x",DleObject->LastDTMF);)

                    if (Character == DTMF_END) {

                        DleObject->DTMFState=STATE_DTMF_NONE;

                    } else {

                        DleObject->DTMFState=STATE_DTMF_START;

                    }

                    UnlockObject(
                        &DleObject->Header
                        );


                    (*DleObject->AsyncNotificationProc)(
                        DleObject->AsyncNotificationContext,
                        MODEM_DTMF_STOP_DETECTED,
                        ConvertToDTMF(DleObject->LastDTMF),
                        GetTickCount()
                        );


                    LockObject(
                        &DleObject->Header
                        );




                } else {

                    D_TRACE(UmDpf(DleObject->Debug,"Unimodem: HandleDTMF: ERROR: RECEIVING got %0x",Character);)

                }
            }

            break;

        default:


            D_TRACE(UmDpf(DleObject->Debug,"Unimodem: HandleDTMF: ERROR: Bad State");)

    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\initmon.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    initmon.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"


#define MONITOR_STATE_IDLE                0
#define MONITOR_STATE_SEND_COMMANDS       1
#define MONITOR_STATE_WAIT_FOR_RESPONSE   2


#define INIT_STATE_IDLE                         0
#define INIT_STATE_SEND_COMMANDS                1
#define INIT_STATE_WAIT_FOR_RESPONSE            2
#define INIT_STATE_SEND_PROTOCOL_COMMANDS       3
#define INIT_STATE_SEND_COUNTRY_SELECT_COMMANDS 4
#define INIT_STATE_SEND_USER_COMMANDS           5
#define INIT_STATE_DONE_ISSUEING_COMMAND        6
#define INIT_STATE_COMPLETE_COMMAND             7


LONG WINAPI
CreateCountrySetCommand(
    HKEY       hKeyModem,
    LPSTR     *Command
    );



VOID
InitCompleteHandler(
    HANDLE      Context,
    DWORD       Status
    )

{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)Context;
    BOOL              ExitLoop=FALSE;
    DWORD             ModemStatus=0;

    ASSERT(COMMAND_TYPE_INIT == ModemControl->CurrentCommandType);

    D_INIT(UmDpf(ModemControl->Debug,"InitCompleteHandler\n");)


    while (!ExitLoop) {

        switch (ModemControl->Init.State) {

            case INIT_STATE_SEND_COMMANDS: {

                DWORD     InitTimeout=2000;

                if (ModemControl->RegInfo.DeviceType != DT_NULL_MODEM) {

                    GetCommModemStatus(
                        ModemControl->FileHandle,
                        &ModemStatus
                        );

                    if (!(ModemStatus & MS_DSR_ON)) {

                        LogString(ModemControl->Debug, IDS_INIT_DSR_LOW);
                    }

                    if (!(ModemStatus & MS_CTS_ON)) {

                        LogString(ModemControl->Debug, IDS_INIT_CTS_LOW);
                    }

                    if ((ModemStatus & MS_RLSD_ON)) {

                        LogString(ModemControl->Debug, IDS_INIT_RLSD_HIGH);
                    }
                }


                CancelModemEvent(
                    ModemControl->ModemEvent
                    );


                ModemControl->Init.State=INIT_STATE_WAIT_FOR_RESPONSE;

                Status=IssueCommand(
                    ModemControl->CommandState,
                    ModemControl->CurrentCommandStrings,
                    InitCompleteHandler,
                    ModemControl,
                    InitTimeout,
                    0
                    );

                if (Status == ERROR_IO_PENDING) {
                    //
                    //  command will complete later
                    //
                    ExitLoop=TRUE;
                }

                break;
            }

            case INIT_STATE_WAIT_FOR_RESPONSE:

                if ((Status == ERROR_UNIMODEM_RESPONSE_TIMEOUT) || (Status == ERROR_UNIMODEM_RESPONSE_BAD)) {
                    //
                    //  the modem did not respond, give it one more chance
                    //
                    ModemControl->Init.RetryCount--;

                    if (ModemControl->Init.RetryCount > 0) {
                        //
                        //  more tries
                        //
                        LogString(ModemControl->Debug, IDS_INIT_RETRY);

                        ModemControl->Init.State=INIT_STATE_SEND_COMMANDS;

                        ModemControl->ConnectionState=CONNECTION_STATE_NONE;

                        {

                            DCB   Dcb;
                            BOOL  bResult;
                            //
                            //  set the comstate again
                            //
                            bResult=GetCommState(ModemControl->FileHandle, &Dcb);

                            if (bResult) {

                                PrintCommSettings(ModemControl->Debug,&Dcb);

                                bResult=SetCommState(ModemControl->FileHandle, &Dcb);

                            }  else {

                                D_TRACE(UmDpf(ModemControl->Debug,"was unable to get the comm state!");)
                            }

                        }
                        break;
                    }
                }

                //
                //  go here to see if we have any more commands
                //
                ModemControl->Init.State=INIT_STATE_DONE_ISSUEING_COMMAND;

                break;


            case INIT_STATE_SEND_PROTOCOL_COMMANDS:

                ModemControl->CurrentCommandStrings=ModemControl->Init.ProtocolInit;

                ModemControl->Init.ProtocolInit=NULL;

                ModemControl->Init.State=INIT_STATE_DONE_ISSUEING_COMMAND;

                LogString(ModemControl->Debug, IDS_SEND_PROTOCOL);

                Status=IssueCommand(
                    ModemControl->CommandState,
                    ModemControl->CurrentCommandStrings,
                    InitCompleteHandler,
                    ModemControl,
                    30*1000,
                    0
                    );

                if (Status == ERROR_IO_PENDING) {
                    //
                    //  command will complete later
                    //
                    ExitLoop=TRUE;
                }

                break;

            case INIT_STATE_SEND_COUNTRY_SELECT_COMMANDS:

                ModemControl->CurrentCommandStrings=ModemControl->Init.CountrySelect;

                ModemControl->Init.CountrySelect=NULL;

                ModemControl->Init.State=INIT_STATE_DONE_ISSUEING_COMMAND;

                LogString(ModemControl->Debug, IDS_SEND_COUNTRY_SELECT);

                Status=IssueCommand(
                    ModemControl->CommandState,
                    ModemControl->CurrentCommandStrings,
                    InitCompleteHandler,
                    ModemControl,
                    5*1000,
                    0
                    );

                if (Status == ERROR_IO_PENDING) {
                    //
                    //  command will complete later
                    //
                    ExitLoop=TRUE;
                }


                break;

            case INIT_STATE_SEND_USER_COMMANDS:

                ModemControl->CurrentCommandStrings=ModemControl->Init.UserInit;

                ModemControl->Init.UserInit=NULL;

                ModemControl->Init.State=INIT_STATE_DONE_ISSUEING_COMMAND;

                LogString(ModemControl->Debug, IDS_SEND_USER);

                Status=IssueCommand(
                    ModemControl->CommandState,
                    ModemControl->CurrentCommandStrings,
                    InitCompleteHandler,
                    ModemControl,
                    20*1000,
                    // 5*1000,
                    0
                    );

                if (Status == ERROR_IO_PENDING) {
                    //
                    //  command will complete later
                    //
                    ExitLoop=TRUE;
                }

                break;

            case INIT_STATE_DONE_ISSUEING_COMMAND:
                //
                //  One of our commands has completed. Proceed with additional commands if any
                //
                FREE_MEMORY(ModemControl->CurrentCommandStrings);

                if (Status == STATUS_SUCCESS) {
                    //
                    //  it work see if there are other commands to be sent
                    //
                    if ((ModemControl->Init.ProtocolInit != NULL)) {

                        ModemControl->Init.State=INIT_STATE_SEND_PROTOCOL_COMMANDS;

                        break;
                    }
/*
                    if ((ModemControl->Init.CountrySelect != NULL)) {

                        ModemControl->Init.State=INIT_STATE_SEND_COUNTRY_SELECT_COMMANDS;

                        break;
                    }
*/


                    if ((ModemControl->Init.UserInit != NULL)) {

                        ModemControl->Init.State=INIT_STATE_SEND_USER_COMMANDS;

                        break;
                    }
                }

                ModemControl->Init.State=INIT_STATE_COMPLETE_COMMAND;

                break;


            case INIT_STATE_COMPLETE_COMMAND:

                ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

                ModemControl->ConnectionState=CONNECTION_STATE_NONE;

                //
                //  clean this up incase of a failure somewhere above
                //
                if (ModemControl->Init.ProtocolInit != NULL) {

                    FREE_MEMORY(ModemControl->Init.ProtocolInit);
                }

                if (ModemControl->Init.CountrySelect != NULL) {

                    FREE_MEMORY(ModemControl->Init.CountrySelect);
                }

                if (ModemControl->Init.UserInit != NULL) {

                    FREE_MEMORY(ModemControl->Init.UserInit);
                }


                (*ModemControl->NotificationProc)(
                    ModemControl->NotificationContext,
                    MODEM_ASYNC_COMPLETION,
                    Status,
                    0
                    );

                RemoveReferenceFromObject(
                    &ModemControl->Header
                    );

                ExitLoop=TRUE;

                break;

            default:

                ASSERT(0);
                break;

        }
    }

    return;

}




DWORD WINAPI
UmInitModem(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    LPCOMMCONFIG  CommConfig
    )
/*++

Routine Description:

    This routine is called to initialize the modem to a known state using the parameters
    supplied in the CommConfig structure. If some settings do not apply to the actual hardware
    then they can be ignored.

Arguments:

    ModemHandle - Handle returned by OpenModem

    CommandsOptionList - List option blocks, only flags used
       Flags   - Optional init parameters. Not currently used and must be zero

    CommConfig  - CommConig structure with MODEMSETTINGS structure.

Return Value:

    ERROR_SUCCESS if successfull
    ERROR_IO_PENDING If pending, will be completed later with a call to the AsyncHandler

    or other specific error


--*/

{

    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)ReferenceObjectByHandleAndLock(ModemHandle);
    LONG              lResult;
    LPSTR             Commands;
    LPMODEMSETTINGS   ModemSettings;
    LPSTR             DynamicInit;
    BOOL              bResult;
    DWORD             BytesTransfered;

    ASSERT(ModemControl->CurrentCommandType == COMMAND_TYPE_NONE);

    if (ModemControl->CurrentCommandType != COMMAND_TYPE_NONE) {

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_UNIMODEM_INUSE;
    }

    SetPassthroughMode(
        ModemControl->FileHandle,
        MODEM_NOPASSTHROUGH_INC_SESSION_COUNT
        );

    SyncDeviceIoControl(
        ModemControl->FileHandle,
        IOCTL_SERIAL_CLEAR_STATS,
        NULL,
        0,
        NULL,
        0,
        &BytesTransfered
        );


    lResult=StartResponseEngine(
        ModemControl->ReadState,
        ModemControl
        );

    if (CommConfig == NULL) {

        CommConfig=ModemControl->RegInfo.CommConfig;
    }

    if (CommConfig->dwProviderOffset == 0) {

        D_ERROR(UmDpf(ModemControl->Debug,"UmInitModem: dwProviderOffset is zero");)

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_UNIMODEM_BAD_COMMCONFIG;
    }

    ModemSettings=(LPMODEMSETTINGS)(((LPBYTE)CommConfig)+CommConfig->dwProviderOffset);


    if (ModemSettings->dwPreferredModemOptions & MDM_FLOWCONTROL_HARD) {

        D_TRACE(UmDpf(ModemControl->Debug,"UmInitModem: enabling rts/cts control in DCB");)

        CommConfig->dcb.fOutxCtsFlow=1;
        CommConfig->dcb.fRtsControl=RTS_CONTROL_HANDSHAKE;

        CommConfig->dcb.fOutX=FALSE;
        CommConfig->dcb.fInX=FALSE;

    } else {

        CommConfig->dcb.fOutxCtsFlow=0;
        CommConfig->dcb.fRtsControl=RTS_CONTROL_ENABLE;
    }


    CommConfig->dcb.fBinary = 1;
    CommConfig->dcb.fDtrControl = DTR_CONTROL_ENABLE;
    CommConfig->dcb.fDsrSensitivity  = FALSE;
    CommConfig->dcb.fOutxDsrFlow = FALSE;


    PrintCommSettings(
        ModemControl->Debug,
        &CommConfig->dcb
        );

    SetCommConfig(
        ModemControl->FileHandle,
        CommConfig,
        CommConfig->dwSize
        );

    EscapeCommFunction(ModemControl->FileHandle, SETDTR);

    DynamicInit=CreateSettingsInitEntry(
        ModemControl->ModemRegKey,
        ModemSettings->dwPreferredModemOptions,
        ModemControl->RegInfo.dwModemOptionsCap,
        ModemControl->RegInfo.dwCallSetupFailTimerCap,
        ModemSettings->dwCallSetupFailTimer,
        ModemControl->RegInfo.dwInactivityTimeoutCap,
        ModemControl->RegInfo.dwInactivityScale,
        ModemSettings->dwInactivityTimeout,
        ModemControl->RegInfo.dwSpeakerVolumeCap,
        ModemSettings->dwSpeakerVolume,
        ModemControl->RegInfo.dwSpeakerModeCap,
        ModemSettings->dwSpeakerMode
        );

    if (DynamicInit == NULL) {

        if (ModemControl->RegInfo.DeviceType != DT_NULL_MODEM) {
            //
            //  Only a major problem if a real modem
            //
            LogString(ModemControl->Debug, IDS_MSGERR_FAILED_INITSTRINGCONSTRUCTION);

            RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

            return ERROR_UNIMODEM_MISSING_REG_KEY;
        }

    }

    ModemControl->CurrentPreferredModemOptions=ModemSettings->dwPreferredModemOptions;
    ModemControl->CallSetupFailTimer=ModemSettings->dwCallSetupFailTimer;

    ModemControl->CurrentCommandStrings=GetCommonCommandStringCopy(
        ModemControl->CommonInfo,
        COMMON_INIT_COMMANDS,
        NULL,
        DynamicInit
        );

    if (DynamicInit != NULL) {

        FREE_MEMORY(DynamicInit);
    }

    if (ModemControl->CurrentCommandStrings == NULL) {
        //
        //  failed to get init string
        //
        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_UNIMODEM_MISSING_REG_KEY;
    }

    ModemControl->Init.ProtocolInit=ConstructNewPreDialCommands(
        ModemControl->ModemRegKey,
        ModemControl->CurrentPreferredModemOptions
        );

    CreateCountrySetCommand(
        ModemControl->ModemRegKey,
        &ModemControl->Init.CountrySelect
        );

    ModemControl->Init.UserInit=CreateUserInitEntry(
        ModemControl->ModemRegKey
        );

    ModemControl->Init.RetryCount=3;

    ModemControl->CurrentCommandType=COMMAND_TYPE_INIT;

    ModemControl->Init.State=INIT_STATE_SEND_COMMANDS;

    LogString(ModemControl->Debug,IDS_MSGLOG_INIT);

    bResult=StartAsyncProcessing(
        ModemControl,
        InitCompleteHandler,
        ModemControl,
        ERROR_SUCCESS
        );


    if (!bResult) {
        //
        //  failed
        //
        ModemControl->Init.State=INIT_STATE_IDLE;

        ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

        FREE_MEMORY(ModemControl->CurrentCommandStrings);

        if (ModemControl->Init.ProtocolInit != NULL) {

            FREE_MEMORY(ModemControl->Init.ProtocolInit);
        }

        if (ModemControl->Init.CountrySelect != NULL) {

            FREE_MEMORY(ModemControl->Init.CountrySelect);
        }

        if (ModemControl->Init.UserInit != NULL) {

            FREE_MEMORY(ModemControl->Init.UserInit);
        }


        LogString(ModemControl->Debug, IDS_MSGERR_FAILED_INIT);

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_NOT_ENOUGH_MEMORY;

    }

    RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

    return ERROR_IO_PENDING;

}




VOID
PowerOffHandler(
    HANDLE      Context,
    DWORD       Status
    )

{

    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)Context;
    DWORD             ModemStatus=0;

    D_TRACE(UmDpf(ModemControl->Debug,"UNIMDMAT: DSR drop, modem turned off\n");)



    GetCommModemStatus(
        ModemControl->FileHandle,
        &ModemStatus
        );

    if ((ModemStatus & MS_DSR_ON)) {
        //
        //  Hmm, DSR is now high, Ignore it, wait again
        //
        LogString(ModemControl->Debug, IDS_NO_DSR_DROP);

        WaitForModemEvent(
            ModemControl->ModemEvent,
            EV_DSR,
            INFINITE,
            PowerOffHandler,
            ModemControl
            );

        return;
    }

    LogString(ModemControl->Debug, IDS_DSR_DROP);

    (*ModemControl->NotificationProc)(
        ModemControl->NotificationContext,
        MODEM_HARDWARE_FAILURE,
        0,
        0
        );


    return;

}




VOID
MonitorCompleteHandler(
    HANDLE      Context,
    DWORD       Status
    )

{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)Context;

    ASSERT(COMMAND_TYPE_MONITOR == ModemControl->CurrentCommandType);

    D_INIT(UmDpf(ModemControl->Debug,"MonitorCompleteHandler\n");)


    switch (ModemControl->MonitorState) {

        case MONITOR_STATE_SEND_COMMANDS:

            CancelModemEvent(
                ModemControl->ModemEvent
                );

            ResetRingInfo(ModemControl->ReadState);

            ModemControl->MonitorState=MONITOR_STATE_WAIT_FOR_RESPONSE;

            Status=IssueCommand(
                ModemControl->CommandState,
                ModemControl->CurrentCommandStrings,
                MonitorCompleteHandler,
                ModemControl,
                2000,
                0
                );

            if (Status == ERROR_IO_PENDING) {

                break;
            }

            //
            //  if it did not pend,  fall though with error returned
            //


        case MONITOR_STATE_WAIT_FOR_RESPONSE:

            FREE_MEMORY(ModemControl->CurrentCommandStrings);

            ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;



            if (Status == ERROR_SUCCESS) {
                //
                //  if monitioring worked, watch for DSR drop
                //
                if (ModemControl->RegInfo.DeviceType != DT_NULL_MODEM) {
                    //
                    //  Watch for DSR to drop on real modems only
                    //
                    WaitForModemEvent(
                        ModemControl->ModemEvent,
                        EV_DSR,
                        INFINITE,
                        PowerOffHandler,
                        ModemControl
                        );
                }
            }


#if 1
            SetMinimalPowerState(
                ModemControl->Power,
                1
                );

            StartWatchingForPowerUp(
                ModemControl->Power
                );
#endif

            (*ModemControl->NotificationProc)(
                ModemControl->NotificationContext,
                MODEM_ASYNC_COMPLETION,
                Status,
                0
                );


            RemoveReferenceFromObject(
                &ModemControl->Header
                );

            break;

        default:

            ASSERT(0);
            break;

    }


    return;

}




DWORD WINAPI
UmMonitorModem(
    HANDLE    ModemHandle,
    DWORD     MonitorFlags,
    PUM_COMMAND_OPTION  CommandOptionList
    )
/*++

Routine Description:

    This routine is called to initialize the modem to a known state using the parameters
    supplied in the CommConfig structure. If some settings do not apply to the actual hardware
    then they can be ignored.

Arguments:

    ModemHandle - Handle returned by OpenModem

    CommandsOptionList - List option blocks, only flags used
       Flags   - Optional init parameters. Not currently used and must be zero

    CommConfig  - CommConig structure with MODEMSETTINGS structure.

Return Value:

    ERROR_SUCCESS if successfull
    ERROR_IO_PENDING If pending, will be completed later with a call to the AsyncHandler

    or other specific error


--*/

{

    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)ReferenceObjectByHandleAndLock(ModemHandle);

    LONG              lResult;
    LPSTR             Commands;
    LPSTR             DistRingCommands;
    LPSTR             MonitorCommands;
    BOOL              bResult;

    ASSERT(ModemControl->CurrentCommandType == COMMAND_TYPE_NONE);

    if (ModemControl->CurrentCommandType != COMMAND_TYPE_NONE) {

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_UNIMODEM_INUSE;
    }

    Commands=NULL;

    if (MonitorFlags & MONITOR_FLAG_CALLERID) {
        //
        //  enable caller ID
        //
        Commands=GetCommonCommandStringCopy(
            ModemControl->CommonInfo,
            COMMON_ENABLE_CALLERID_COMMANDS,
            NULL,
            NULL
            );
    }

    if (MonitorFlags & MONITOR_FLAG_DISTINCTIVE_RING) {
        //
        //  enable distinctive ring
        //
        DistRingCommands=GetCommonCommandStringCopy(
            ModemControl->CommonInfo,
            COMMON_ENABLE_DISTINCTIVE_RING_COMMANDS,
            Commands,
            NULL
            );

        if (DistRingCommands != NULL) {

            if (Commands != NULL) {

                FREE_MEMORY(Commands);
            }

            Commands = DistRingCommands;
        }

    }

    LogString(ModemControl->Debug, IDS_MSGLOG_MONITOR);

    MonitorCommands=GetCommonCommandStringCopy(
        ModemControl->CommonInfo,
        COMMON_MONITOR_COMMANDS,
        Commands,
        NULL
        );

    if (Commands != NULL) {

        FREE_MEMORY(Commands);
    }


    if (MonitorCommands == NULL) {

        LogString(ModemControl->Debug, IDS_MSGERR_FAILED_MONITOR);

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_UNIMODEM_MISSING_REG_KEY;

    }

    ModemControl->CurrentCommandStrings=MonitorCommands;


    ModemControl->CurrentCommandType=COMMAND_TYPE_MONITOR;

    ModemControl->MonitorState=MONITOR_STATE_SEND_COMMANDS;

    bResult=StartAsyncProcessing(
        ModemControl,
        MonitorCompleteHandler,
        ModemControl,
        ERROR_SUCCESS
        );


    if (!bResult) {
        //
        //  failed
        //
        ModemControl->MonitorState=MONITOR_STATE_IDLE;

        ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

        FREE_MEMORY(ModemControl->CurrentCommandStrings);

        LogString(ModemControl->Debug, IDS_MSGERR_FAILED_MONITOR);

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_NOT_ENOUGH_MEMORY;

    }

    RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

    return ERROR_IO_PENDING;

}




VOID  WINAPI
AsyncProcessingHandler(
    DWORD              ErrorCode,
    DWORD              Bytes,
    LPOVERLAPPED       dwParam
    )

{
    PUM_OVER_STRUCT    UmOverlapped=(PUM_OVER_STRUCT)dwParam;
    COMMANDRESPONSE   *Handler;


    Handler=UmOverlapped->Context1;

    (*Handler)(
        UmOverlapped->Context2,
        (DWORD)UmOverlapped->Overlapped.Internal
        );

    return;

}


BOOL WINAPI
StartAsyncProcessing(
    PMODEM_CONTROL     ModemControl,
    COMMANDRESPONSE   *Handler,
    HANDLE             Context,
    DWORD              Status
    )

{
    BOOL               bResult;

    PUM_OVER_STRUCT UmOverlapped=ModemControl->AsyncOverStruct;

    UmOverlapped->Context1=Handler;

    UmOverlapped->Context2=Context;

    UmOverlapped->Overlapped.Internal=Status;

    AddReferenceToObject(
        &ModemControl->Header
        );

    bResult=UnimodemQueueUserAPC(
        &UmOverlapped->Overlapped,
        AsyncProcessingHandler
        );

    if (!bResult) {
        //
        //  failed, get rid of ref
        //
        RemoveReferenceFromObject(
            &ModemControl->Header
            );
    }

    return bResult;

}













int strncmpi(char *dst, char *src, long count);


#define HAYES_COMMAND_LENGTH        1024

typedef struct _INIT_COMMANDS {

    LPSTR    Buffer;

    LPSTR    CurrentCommand;

    DWORD    BufferSize;

    DWORD    CompleteCommandSize;

    CHAR     Prefix[HAYES_COMMAND_LENGTH];
    DWORD    PrefixLength;

    CHAR     Terminator[HAYES_COMMAND_LENGTH];
    DWORD    TerminatorLength;


} INIT_COMMANDS,  *PINIT_COMMANDS;

BOOL
CreateCommand(
    HKEY           hKeyModem,
    HKEY           hSettings,
    LPCSTR          pszRegName,
    DWORD          dwNumber,
    PINIT_COMMANDS Commands
    );


CONST char szBlindOn[] = "Blind_On";
CONST char szBlindOff[] = "Blind_Off";


extern CONST char szSettings[];
CONST char szPrefix[]       = "Prefix";
CONST char szTerminator[]   = "Terminator";




//****************************************************************************
// BOOL CreateSettingsInitEntry(MODEMINFORMATION *)
//
// Function: Creates a Settings\Init section in the registry, ala:
//           Settings\Init\0 = "AT ... <cr>"
//           Settings\Init\1 = "AT ... <cr>"
//           ...
//
// Returns: TRUE on success
//          FALSE on failure (note: leaves SettingsInit key in registry, if created.  Not harmful)
//
// Note:    Trusted function - don't need to verify hPort...
//****************************************************************************

LPSTR WINAPI
CreateSettingsInitEntry(
    HKEY       ModemKey,
    DWORD      dwOptions,
    DWORD      dwCaps,
    DWORD      dwCallSetupFailTimerCap,
    DWORD      dwCallSetupFailTimerSetting,
    DWORD      dwInactivityTimeoutCap,
    DWORD      dwInactivityScale,
    DWORD      dwInactivityTimeoutSetting,
    DWORD      dwSpeakerVolumeCap,
    DWORD      dwSpeakerVolumeSetting,
    DWORD      dwSpeakerModeCap,
    DWORD      dwSpeakerModeSetting
    )

{
    CHAR    pszTemp[HAYES_COMMAND_LENGTH + 1];
    CHAR    pszCommand[HAYES_COMMAND_LENGTH + 1];
    DWORD   dwResult;
    HKEY    hSettingsKey = NULL;
    DWORD   dwType;
    DWORD   dwSize;

    LPSTR   ReturnValue=NULL;

    CONST static char szCallSetupFailTimer[] = "CallSetupFailTimer";
    CONST static char szInactivityTimeout[]  = "InactivityTimeout";
    CONST static char szSpeakerVolume[]      = "SpeakerVolume";
    CONST static char szSpeakerMode[]        = "SpeakerMode";
    CONST static char szFlowControl[]        = "FlowControl";
    CONST static char szErrorControl[]       = "ErrorControl";
    CONST static char szCompression[]        = "Compression";
    CONST static char szModulation[]         = "Modulation";
    CONST static char szCCITT[]              = "_CCITT";
    CONST static char szBell[]               = "_Bell";
    CONST static char szCCITT_V23[]          = "_CCITT_V23";
    CONST static char szSpeedNegotiation[]   = "SpeedNegotiation";
    CONST static char szLow[]                = "_Low";
    CONST static char szMed[]                = "_Med";
    CONST static char szHigh[]               = "_High";
    CONST static char szSpkrModeDial[]       = "_Dial";
    CONST static char szSetup[]              = "_Setup";
    CONST static char szForced[]             = "_Forced";
    CONST static char szCellular[]           = "_Cellular";
    CONST static char szHard[]               = "_Hard";
    CONST static char szSoft[]               = "_Soft";
    CONST static char szOff[]                = "_Off";
    CONST static char szOn[]                 = "_On";

    INIT_COMMANDS     Commands;


    Commands.Buffer=NULL;

    // get Settings key
    //
    if (RegOpenKeyA(ModemKey, szSettings, &hSettingsKey)
        != ERROR_SUCCESS)
    {
        D_ERROR(DebugPrint("RegOpenKey failed when opening %s.", szSettings);)
        return ReturnValue;
    }

    // read in prefix and terminator
    //
    dwSize = HAYES_COMMAND_LENGTH;
    if (RegQueryValueExA(hSettingsKey, szPrefix, NULL, &dwType, (VOID *)pszTemp, &dwSize)
        != ERROR_SUCCESS)
    {
        D_ERROR(DebugPrint("RegQueryValueEx failed when opening %s.", szPrefix);)
        goto Failure;
    }

    if (dwType != REG_SZ)
    {
        D_ERROR(DebugPrint("'%s' wasn't REG_SZ.", szPrefix);)
        goto Failure;
    }

    ExpandMacros(pszTemp, Commands.Prefix, NULL, NULL, 0);

    Commands.PrefixLength=lstrlenA(Commands.Prefix);


    dwSize = HAYES_COMMAND_LENGTH;
    if (RegQueryValueExA(hSettingsKey, szTerminator, NULL, &dwType, (VOID *)pszTemp, &dwSize)
        != ERROR_SUCCESS)
    {
        D_ERROR(DebugPrint("RegQueryValueEx failed when opening %s.", szTerminator);)
        goto Failure;
    }

    if (dwType != REG_SZ)
    {
        D_ERROR(DebugPrint("'%s' wasn't REG_SZ.", szTerminator);)
        goto Failure;
    }

    ExpandMacros(pszTemp, Commands.Terminator, NULL, NULL, 0);

    Commands.TerminatorLength= lstrlenA(Commands.Terminator);


    ASSERT (lstrlenA(Commands.Prefix) + lstrlenA(Commands.Terminator) <= HAYES_COMMAND_LENGTH);

    Commands.BufferSize=HAYES_COMMAND_LENGTH+1+1;

    Commands.CompleteCommandSize=0;

    Commands.Buffer=ALLOCATE_MEMORY(Commands.BufferSize);

    if (Commands.Buffer == NULL) {

        goto Failure;
    }

    Commands.CurrentCommand=Commands.Buffer;


    // set temp length to 0 and initialize first command string for use in CreateCommand()
    //
    lstrcpyA(Commands.CurrentCommand, Commands.Prefix);

    // CallSetupFailTimer
    //
    if (dwCallSetupFailTimerCap)
    {
      if (!CreateCommand(ModemKey,
                         hSettingsKey,
                         szCallSetupFailTimer,
                         dwCallSetupFailTimerSetting,
                         &Commands))
      {
        goto Failure;
      }
    }

    // InactivityTimeout
    //
    if (dwInactivityTimeoutCap)
    {
      DWORD dwInactivityTimeout;

      // Convert from seconds to the units used on the modem, rounding up if not an exact division.
      //
      if (dwInactivityTimeoutSetting > dwInactivityTimeoutCap) {
          //
          //  cap at max
          //
          dwInactivityTimeoutSetting= dwInactivityTimeoutCap;
      }

      dwInactivityTimeout = dwInactivityTimeoutSetting / dwInactivityScale +
                            (dwInactivityTimeoutSetting % dwInactivityScale ? 1 : 0);

      if (!CreateCommand(ModemKey, hSettingsKey,  szInactivityTimeout,
                         dwInactivityTimeout,
                          &Commands))
      {
        goto Failure;
      }
    }

    // SpeakerVolume
    if (dwSpeakerVolumeCap)
    {
      lstrcpyA(pszCommand, szSpeakerVolume);
      switch (dwSpeakerVolumeSetting)
      {
        case MDMVOL_LOW:
          lstrcatA(pszCommand, szLow);
          break;
        case MDMVOL_MEDIUM:
          lstrcatA(pszCommand, szMed);
          break;
        case MDMVOL_HIGH:
          lstrcatA(pszCommand, szHigh);
          break;
        default:
          D_ERROR(DebugPrint("invalid SpeakerVolume.");)
      }

      if (!CreateCommand(ModemKey, hSettingsKey,  pszCommand, 0,
                            &Commands))
      {
        goto Failure;
      }
    }

    // SpeakerMode
    //
    if (dwSpeakerModeCap)
    {
      lstrcpyA(pszCommand, szSpeakerMode);
      switch (dwSpeakerModeSetting)
      {
        case MDMSPKR_OFF:
          lstrcatA(pszCommand, szOff);
          break;
        case MDMSPKR_DIAL:
          lstrcatA(pszCommand, szSpkrModeDial);
          break;
        case MDMSPKR_ON:
          lstrcatA(pszCommand, szOn);
          break;
        case MDMSPKR_CALLSETUP:
          lstrcatA(pszCommand, szSetup);
          break;
        default:
          D_ERROR(DebugPrint("invalid SpeakerMode.");)
      }

      if (!CreateCommand(ModemKey, hSettingsKey,  pszCommand, 0,
                            &Commands))
      {
        goto Failure;
      }
    }

    // PreferredModemOptions

    // NOTE: ERRORCONTROL MUST BE DONE BEFORE COMPRESSION BECAUSE OF ZYXEL MODEMS
    // NOTE: THEY HAVE A SINGLE SET OF COMMANDS FOR BOTH EC AND COMP, AND WE CAN
    // NOTE: ONLY DO THINGS IF WE HAVE THIS ORDER.  UGLY BUT TRUE.

    //
    // - ErrorControl (On,Off,Forced)
    //
    if (dwCaps & MDM_ERROR_CONTROL) {

        lstrcpyA(pszCommand, szErrorControl);

        switch (dwOptions & (MDM_ERROR_CONTROL | MDM_FORCED_EC | MDM_CELLULAR)) {

          case MDM_ERROR_CONTROL:
            lstrcatA(pszCommand, szOn);
            break;

          case MDM_ERROR_CONTROL | MDM_FORCED_EC:
            lstrcatA(pszCommand, szForced);
            break;

          case MDM_ERROR_CONTROL | MDM_CELLULAR:
            lstrcatA(pszCommand, szCellular);
            break;

          case MDM_ERROR_CONTROL | MDM_FORCED_EC | MDM_CELLULAR:
            lstrcatA(pszCommand, szCellular);
            lstrcatA(pszCommand, szForced);
            break;

          default: // no error control
            lstrcatA(pszCommand, szOff);
            break;

        }

        if (!CreateCommand(ModemKey, hSettingsKey,  pszCommand, 0,
                              &Commands))
        {
          goto Failure;
        }
    }

    //
    // - Compression (On,Off)
    //
    if (dwCaps & MDM_COMPRESSION) {

        lstrcpyA(pszCommand, szCompression);
        lstrcatA(pszCommand, (dwOptions & MDM_COMPRESSION ? szOn : szOff));

        if (!CreateCommand(ModemKey, hSettingsKey,  pszCommand, 0,
                              &Commands))
        {
          goto Failure;
        }
    }

    // - FlowControl
    //
    if (dwCaps & (MDM_FLOWCONTROL_HARD | MDM_FLOWCONTROL_SOFT))
    {
      lstrcpyA(pszCommand, szFlowControl);
      switch (dwOptions & (MDM_FLOWCONTROL_HARD | MDM_FLOWCONTROL_SOFT))
      {
        case MDM_FLOWCONTROL_HARD:
          lstrcatA(pszCommand, szHard);
          break;
        case MDM_FLOWCONTROL_SOFT:
          lstrcatA(pszCommand, szSoft);
          break;
        case MDM_FLOWCONTROL_HARD | MDM_FLOWCONTROL_SOFT:
          if (dwCaps & MDM_FLOWCONTROL_HARD)
          {
            lstrcatA(pszCommand, szHard);
          }
          else
          {
            lstrcatA(pszCommand, szSoft);
          }
          break;
        default:
          lstrcatA(pszCommand, szOff);
      }
      if (!CreateCommand(ModemKey, hSettingsKey,  pszCommand, 0,
                            &Commands))
      {
        goto Failure;
      }
    }

    // - CCITT Override
    //
    if (dwCaps & MDM_CCITT_OVERRIDE)
    {
      lstrcpyA(pszCommand, szModulation);
      if (dwOptions & MDM_CCITT_OVERRIDE)
      {
        // use szCCITT or V.23
        if (dwCaps & MDM_V23_OVERRIDE && dwOptions & MDM_V23_OVERRIDE)
        {
          lstrcatA(pszCommand, szCCITT_V23);
        }
        else
        {
          lstrcatA(pszCommand, szCCITT);
        }
      }
      else
      {
        lstrcatA(pszCommand, szBell);
      }
      if (!CreateCommand(ModemKey, hSettingsKey,  pszCommand, 0,
                            &Commands))
      {
        goto Failure;
      }
    }

    // - SpeedAdjust
    //
    if (dwCaps & MDM_SPEED_ADJUST)
    {
      lstrcpyA(pszCommand, szSpeedNegotiation);
      lstrcatA(pszCommand, (dwOptions & MDM_SPEED_ADJUST ? szOn : szOff));
      if (!CreateCommand(ModemKey, hSettingsKey,  pszCommand, 0L,
                            &Commands))
      {
        goto Failure;
      }
    }

    // - Blind Dial
    //
    if (dwCaps & MDM_BLIND_DIAL)
    {
      lstrcpyA(pszCommand, (dwOptions & MDM_BLIND_DIAL ? szBlindOn : szBlindOff));
      if (!CreateCommand(ModemKey, hSettingsKey,  pszCommand, 0,
                            &Commands))
      {
        goto Failure;
      }
    }

    // finish the current command line by passing in a NULL command name
    if (!CreateCommand(ModemKey, hSettingsKey,  NULL, 0,
                          &Commands))
    {
      goto Failure;
    }

    // Success

    ReturnValue=Commands.Buffer;

Failure:
    // close keys
    RegCloseKey(hSettingsKey);

    if (ReturnValue == NULL) {
        //
        //  failed, free strings
        //
        if (Commands.Buffer != NULL) {

            FREE_MEMORY(Commands.Buffer);
        }
    }

    return ReturnValue;
}


//****************************************************************************
// LPSTR CreateUserInitEntry(HKEY       hKeyModem)
//
// Function: Appends user init string
//
// Returns: new string on success
//          NULL on failure
//
//****************************************************************************

LPSTR WINAPI
CreateUserInitEntry(
    HKEY       hKeyModem
    )
{
    CHAR    pszTemp[HAYES_COMMAND_LENGTH + 1];
    HKEY    hSettingsKey = NULL;
    DWORD   dwSize;
    DWORD   dwType;
    CONST static char szUserInit[] = "UserInit";

    INIT_COMMANDS     Commands;

    // get Settings key
    //
    if (RegOpenKeyA(hKeyModem, szSettings, &hSettingsKey)
        != ERROR_SUCCESS)
    {
        D_ERROR(DebugPrint("RegOpenKey failed when opening %s.", szSettings);)
        return NULL;
    }

    // read in prefix and terminator
    //
    dwSize = HAYES_COMMAND_LENGTH;
    if (RegQueryValueExA(hSettingsKey, szPrefix, NULL, &dwType, (VOID *)pszTemp, &dwSize)
        != ERROR_SUCCESS)
    {
        D_ERROR(DebugPrint("RegQueryValueEx failed when opening %s.", szPrefix);)
        RegCloseKey(hSettingsKey);
        return NULL;
    }

    if (dwType != REG_SZ)
    {
        D_ERROR(DebugPrint("'%s' wasn't REG_SZ.", szPrefix);)
        RegCloseKey(hSettingsKey);
        return NULL;
    }

    ExpandMacros(pszTemp, Commands.Prefix, NULL, NULL, 0);

    Commands.PrefixLength=lstrlenA(Commands.Prefix);


    dwSize = HAYES_COMMAND_LENGTH;
    if (RegQueryValueExA(hSettingsKey, szTerminator, NULL, &dwType, (VOID *)pszTemp, &dwSize)
        != ERROR_SUCCESS)
    {
        D_ERROR(DebugPrint("RegQueryValueEx failed when opening %s.", szTerminator);)
        RegCloseKey(hSettingsKey);
        return NULL;
    }

    if (dwType != REG_SZ)
    {
        D_ERROR(DebugPrint("'%s' wasn't REG_SZ.", szTerminator);)
        RegCloseKey(hSettingsKey);
        return NULL;
    }

    ExpandMacros(pszTemp, Commands.Terminator, NULL, NULL, 0);

    Commands.TerminatorLength= lstrlenA(Commands.Terminator);

    if (lstrlenA(Commands.Prefix) + lstrlenA(Commands.Terminator) > HAYES_COMMAND_LENGTH)
    {
        D_ERROR(DebugPrint("Command prefix and terminator is greater than HAYES_COMMAND_LENGTH");)
        RegCloseKey(hSettingsKey);
        return NULL;
    } 

    RegCloseKey(hSettingsKey);

    //
    // now get the UserInit string, if there is one...
    //

    // get the UserInit string length (including null), don't ExpandMacros on it
    //
    if (RegQueryValueExA(hKeyModem, szUserInit, NULL, &dwType, NULL, &dwSize)
         != ERROR_SUCCESS)
    {
        D_ERROR(DebugPrint("RegQueryValueEx failed when opening %s (this can be okay).", szUserInit);)
        return NULL;  // it is okay to not have a UserInit
    }
    else
    {
        LPSTR pszUserInit;
        DWORD  UserStringLength;

        if (dwType != REG_SZ)
        {
            D_ERROR(DebugPrint("'%s' wasn't REG_SZ.", szUserInit);)
            return NULL;  // this is not okay
        }

        // check for 0 length string
        //
        if (dwSize == 1)
        {
            D_ERROR(DebugPrint("ignoring zero length %s entry.", szUserInit);)
            return NULL;
        }

        UserStringLength=dwSize + Commands.PrefixLength + Commands.TerminatorLength + 1;

        // we allow the size of this string to be larger than 40 chars, because the user
        // should have enough knowledge about what the modem can do, if they are using this
        // allocate enough for if we need to add a prefix and terminator
        //
        pszUserInit = (LPSTR)ALLOCATE_MEMORY(UserStringLength);

        if (pszUserInit == NULL) {

            D_ERROR(DebugPrint("unable to allocate memory for building the UserInit string.");)
            return NULL;
        }

        if (RegQueryValueExA(hKeyModem, szUserInit, NULL, &dwType, (VOID *)pszUserInit, &dwSize)
            != ERROR_SUCCESS)
        {
            D_ERROR(DebugPrint("RegQueryValueEx failed when opening %s.", szUserInit);)
            FREE_MEMORY(pszUserInit);
            return NULL;  // it is not okay at this point
        }

        if (dwType != REG_SZ)
        {
            D_ERROR(DebugPrint("Type in User init is not REG_SZ");)
            FREE_MEMORY(pszUserInit);
            return NULL;
        }

        // check for prefix
        //
        if (strncmpi(pszUserInit, Commands.Prefix, Commands.PrefixLength))
        {
            // prepend a prefix string
            lstrcpyA(pszUserInit, Commands.Prefix);

            // reload string; it's easier than shifting...
            if (RegQueryValueExA(hKeyModem, szUserInit, NULL, &dwType, (VOID *)(pszUserInit+Commands.PrefixLength), &dwSize)
                != ERROR_SUCCESS)
            {
              D_ERROR(DebugPrint("RegQueryValueEx failed when opening %s.", szUserInit);)
              FREE_MEMORY(pszUserInit);
              return NULL;  // it is not okay at this point
            }
        }

        // check for terminator
        //
        if (strncmpi(pszUserInit+lstrlenA(pszUserInit)-Commands.TerminatorLength,
                     Commands.Terminator, Commands.TerminatorLength))
        {
            // append a terminator
            //
            lstrcatA(pszUserInit, Commands.Terminator);
        }

	return pszUserInit;
    }
}

//****************************************************************************
// BOOL CreateCommand(HKEY hKeyModem, HKEY hSettings, HKEY hInit,
//                    LPSTR pszRegName, DWORD dwNumber, LPSTR pszPrefix,
//                    LPSTR pszTerminator, LPDWORD pdwCounter,
//                    LPSTR pszString)
//
// Function: Creates a command string
//
// Returns: TRUE on success, FALSE otherwise
//
// Note:    if pszRegName is NULL then it is the last command
//****************************************************************************

BOOL
CreateCommand(
    HKEY           hKeyModem,
    HKEY           hSettings,
    LPCSTR         pszRegName,
    DWORD          dwNumber,
    PINIT_COMMANDS Commands
    )
{
    CHAR    pszCommand[HAYES_COMMAND_LENGTH + 1];
    CHAR    pszCommandExpanded[HAYES_COMMAND_LENGTH + 1];
    CHAR    pszNumber[16];
    DWORD   dwCommandLength;
    DWORD   dwSize;
    DWORD   dwType;
    struct _ModemMacro  ModemMacro;
    CONST static char szUserInit[] = "UserInit";
    CONST static char szNumberMacro[] = "<#>";


    // do we really have a command to add?
    //
    if (pszRegName) {

        // read in command text (ie. SpeakerMode_Off = "M0")
        //
        dwSize = HAYES_COMMAND_LENGTH;
        if (RegQueryValueExA(hSettings, pszRegName, NULL, &dwType, (VOID *)pszCommand, &dwSize)
            != ERROR_SUCCESS)
        {
          D_ERROR(DebugPrint("RegQueryValueEx failed when opening %s.  Continuing...", pszRegName);)
          return TRUE;  // we will not consider this fatal
        }

        if (dwType != REG_SZ)
        {
          D_ERROR(DebugPrint("'%s' wasn't REG_SZ.", pszRegName);)
          return FALSE;
        }

        // expand macros pszCommandExpanded <= pszCommand
        //
        lstrcpyA(ModemMacro.MacroName, szNumberMacro);

        wsprintfA(ModemMacro.MacroValue, "%d", dwNumber);

        dwCommandLength = dwSize;

        if (!ExpandMacros(pszCommand, pszCommandExpanded, &dwCommandLength, &ModemMacro, 1))
        {
          D_ERROR(DebugPrint("ExpandMacro Error. State <- Unknown");)
          return FALSE;
        }

        // check string + new command + terminator, flush if too big and start a new one.
        // will new command fit on existing string?  If not, flush it and start new one.
        //
        if (lstrlenA(Commands->CurrentCommand) + lstrlenA(pszCommandExpanded) + Commands->TerminatorLength
            > HAYES_COMMAND_LENGTH) {

            LPSTR    TempBuffer;

            lstrcatA(Commands->CurrentCommand, Commands->Terminator);

            //
            //  add the total length of new command
            //
            Commands->CompleteCommandSize+=lstrlenA(Commands->CurrentCommand)+1;

            //
            //  Filled the current buffer
            //
            TempBuffer=REALLOCATE_MEMORY(
                Commands->Buffer,
                Commands->BufferSize+HAYES_COMMAND_LENGTH + 1 + 1
                );

            if (TempBuffer != NULL) {

                Commands->Buffer=TempBuffer;
                Commands->BufferSize+=(HAYES_COMMAND_LENGTH + 1 + 1);

            } else {

                return FALSE;

            }

            //
            //  start the next command
            //
            Commands->CurrentCommand=Commands->Buffer+Commands->CompleteCommandSize;

            //
            //  put in prefix
            //
            lstrcpyA(Commands->CurrentCommand, Commands->Prefix);

        }

        lstrcatA(Commands->CurrentCommand, pszCommandExpanded);
    }
    else
    {
        // finish off the current string
        //
        lstrcatA(Commands->CurrentCommand, Commands->Terminator);

        //
        //  add the total length of new command
        //
        Commands->CompleteCommandSize+=lstrlenA(Commands->CurrentCommand)+1;

        //
        //  start the next command
        //
        Commands->CurrentCommand=Commands->Buffer+Commands->CompleteCommandSize;

        //
        //  add second null terminator
        //
        *(Commands->Buffer+Commands->CompleteCommandSize)='\0';
    }

    return TRUE;
}





LONG WINAPI
CreateCountrySetCommand(
    HKEY       hKeyModem,
    LPSTR     *Command
    )
{
    CHAR       TempCommands[32];
    LPSTR      RealCommands;

    wsprintfA(TempCommands,"at+gci?\r");

    RealCommands = ALLOCATE_MEMORY( lstrlenA(TempCommands)+2);

    if (RealCommands == NULL) {

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    lstrcpy(RealCommands,TempCommands);

    *Command=RealCommands;

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\init.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    umdmmini.h

Abstract:

    Nt 5.0 unimodem miniport interface


    The miniport driver is guarenteed that only one action command will
    be austanding at one time. If an action command is called, no more
    commands will be issued until the miniport indicates that it has
    complete processing of the current command.

    UmAbortCurrentCommand() may be called while a command is currently executing
    to infor the miniport that the TSP would like it to complete the current command
    so that it may issue some other command. The miniport may complete the as soon
    as is apropreate.

    The Overlapped callback and Timer callbacks are not synchronized by the TSP
    and may be called at anytime. It is the responsibily of the mini dirver to
    protect its data structures from re-entrancy issues.


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"


DWORD  DebugFlags=0;//DEBUG_FLAG_INIT | DEBUG_FLAG_TRACE | DEBUG_FLAG_ERROR;

CONST TCHAR  UnimodemRegPath[]=REGSTR_PATH_SETUP TEXT("\\Unimodem");


DRIVER_CONTROL   DriverControl;



BOOL APIENTRY
DllMain(
    HANDLE hDll,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    TCHAR szLib[MAX_PATH];

    switch(dwReason) {

        case DLL_PROCESS_ATTACH:

#if DBG
            {
                CONST static TCHAR  UnimodemRegistryPath[]=REGSTR_PATH_SETUP TEXT("\\Unimodem");
                LONG    lResult;
                HKEY    hKey;
                DWORD   Type;
                DWORD   Size;

                lResult=RegOpenKeyEx(
		    HKEY_LOCAL_MACHINE,
		    UnimodemRegistryPath,
		    0,
		    KEY_READ,
		    &hKey
		    );


                if (lResult == ERROR_SUCCESS) {

                    Size = sizeof(DebugFlags);

                    RegQueryValueEx(
                        hKey,
                        TEXT("DebugFlags"),
                        NULL,
                        &Type,
                        (LPBYTE)&DebugFlags,
                        &Size
                        );

                    RegCloseKey(hKey);
                }
            }
#endif

            DEBUG_MEMORY_PROCESS_ATTACH("UNIMDMAT");

            D_INIT(DebugPrint("ProcessAttach\n");)

            DisableThreadLibraryCalls(hDll);
            //
            //  initial global data
            //
            InitializeCriticalSection(
                &DriverControl.Lock
                );


            DriverControl.Signature=DRIVER_CONTROL_SIG;

            DriverControl.ReferenceCount=0;

            DriverControl.ModemList=NULL;

            DriverControl.ModuleHandle=hDll;

            lstrcpy(szLib,TEXT("modemui.dll"));
	        DriverControl.ModemUiModuleHandle=LoadLibrary(szLib);

            break;

        case DLL_PROCESS_DETACH:

            D_INIT(DebugPrint("ProcessDeattach\n");)

            // ASSERT(DriverControl.ReferenceCount == 0);
            //
            //  clean up
            //

            UmDeinitializeModemDriver(NULL);

            DeleteCriticalSection(
                &DriverControl.Lock
                );

            if (DriverControl.ModemUiModuleHandle != NULL) {

                FreeLibrary(DriverControl.ModemUiModuleHandle);
            }

            DEBUG_MEMORY_PROCESS_DETACH();

            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:

        default:
              break;

    }

    return TRUE;

}


VOID
UmWorkerThread(
    PDRIVER_CONTROL   DriverControl
    )

{

    BOOL           bResult;
    DWORD          BytesTransfered;
    DWORD          CompletionKey;
    LPOVERLAPPED   OverLapped;
    DWORD          WaitResult=WAIT_IO_COMPLETION;

    PUM_OVER_STRUCT UmOverlapped;

    D_INIT(DebugPrint("UmWorkThread:  starting\n");)

    while (WaitResult != WAIT_OBJECT_0) {

        WaitResult=WaitForSingleObjectEx(
            DriverControl->ThreadStopEvent,
            INFINITE,
            TRUE
            );


    }

    D_INIT(DebugPrint("UmWorkThread:  Exitting\n");)

    ExitThread(0);

}



HANDLE WINAPI
UmInitializeModemDriver(
    void *ValidationObject
    )
/*++

Routine Description:

    This routine is called to initialize the modem driver.
    It maybe called multiple times. After the first call a reference count will simply
    be incremented. UmDeinitializeModemDriver() must be call and equal number of times.

Arguments:

    ValidationObject - opaque handle to a validation object which much
                       be processed properly to "prove" that this is a
                       Microsoft(tm)-certified driver.

Return Value:

    returns a handle to Driver instance which is passed to UmOpenModem()
    or NULL for failure



--*/

{

    HANDLE    ReturnValue=&DriverControl;

    EnterCriticalSection(
        &DriverControl.Lock
        );

    DriverControl.ReferenceCount++;

    if ( DriverControl.ReferenceCount == 1) {
        //
        // First call, do init stuff
        //
        InitializeModemCommonList(
            &DriverControl.CommonList
            );


        DriverControl.CompletionPort=UmPlatformInitialize();


        if (DriverControl.CompletionPort == NULL) {

            DriverControl.ReferenceCount--;

            RemoveCommonList(
                &DriverControl.CommonList
                );

            ReturnValue=NULL;

        }
    }


    LeaveCriticalSection(
        &DriverControl.Lock
        );


    return ReturnValue;

}


HANDLE WINAPI
GetCompletionPortHandle(
    HANDLE       DriverHandle
    )

{
    PDRIVER_CONTROL    DriverCtrl=(PDRIVER_CONTROL)DriverHandle;

    ASSERT( DRIVER_CONTROL_SIG == DriverCtrl->Signature);

    return DriverCtrl->CompletionPort;

}

HANDLE WINAPI
GetCommonList(
    HANDLE       DriverHandle
    )

{
    PDRIVER_CONTROL    DriverCtrl=(PDRIVER_CONTROL)DriverHandle;

    ASSERT( DRIVER_CONTROL_SIG == DriverCtrl->Signature);

    return &DriverCtrl->CommonList;

}


HANDLE WINAPI
GetDriverModuleHandle(
    HANDLE       DriverHandle
    )

{
    PDRIVER_CONTROL    DriverCtrl=(PDRIVER_CONTROL)DriverHandle;

    ASSERT( DRIVER_CONTROL_SIG == DriverCtrl->Signature);

    return DriverCtrl->ModuleHandle;

}



VOID WINAPI
UmDeinitializeModemDriver(
    HANDLE    DriverInstanceHandle
    )
/*++

Routine Description:

    This routine is called to de-initialize the modem driver.

    Must be called the same number of time as UmInitializeModemDriver()

Arguments:

    DriverInstanceHandle - Handle returned by UmInitialmodemDriver

Return Value:

    None


--*/

{

    if (&DriverControl.Lock != NULL)
    {

        EnterCriticalSection(
            &DriverControl.Lock
            );

        // ASSERT(DriverControl.ReferenceCount != 0);

        DriverControl.ReferenceCount--;

        if ( DriverControl.ReferenceCount == 0) {
            //
            // Last reference, free stuff
            //

            UmPlatformDeinitialize(DriverControl.CompletionPort);

            RemoveCommonList(
                &DriverControl.CommonList
                );
        }

        LeaveCriticalSection(
            &DriverControl.Lock
            );
    }



    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\logids.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by log.rc
//
#define IDS_RESP_OK                     1
#define IDS_RESP_INFORMATIVE            2
#define IDS_RESP_CONNECT                3
#define IDS_RESP_ERROR                  4
#define IDS_RESP_NO_CARRIER             5
#define IDS_RESP_NO_DIALTONE            6
#define IDS_RESP_BUSY                   7
#define IDS_RESP_NO_ANSWER              8
#define IDS_RESP_RING                   9
#define IDS_RESP_SSV                    10
#define IDS_RESP_SMD                    11
#define IDS_RESP_SFA                    12
#define IDS_RESP_SRA                    13
#define IDS_RESP_SRQ                    14
#define IDS_RESP_SRC                    15
#define IDS_RESP_STO                    16
#define IDS_RESP_SVM                    17
#define IDS_RESP_DRON                   18
#define IDS_RESP_DROF                   19
#define IDS_RESP_DATE                   20
#define IDS_RESP_TIME                   21
#define IDS_RESP_NMBR                   22
#define IDS_RESP_NAME                   23
#define IDS_RESP_MESG                   24
#define IDS_RESP_UNKNOWN                50



#define IDS_MSGLOG_CONNECTED                       51
#define IDS_MSGLOG_CONNECTEDBPS                    52
#define IDS_MSGLOG_UNKNOWNERRORCONTROL             53
#define IDS_MSGLOG_CELLULAR                        54
#define IDS_MSGLOG_ERRORCONTROL                    55
#define IDS_MSGLOG_COMPRESSION                     56
#define IDS_MSGLOG_UNKNOWNCOMPRESSION              57

#define IDS_MSGPERF_WRDESC                         59
#define IDS_MSGPERF_WRNAME                         60
#define IDS_MSGPERF_WRREG                          61
#define IDS_MSGPERF_RDDESC                         62
#define IDS_MSGPERF_RDNAME                         63
#define IDS_MSGPERF_RDREG                          64
#define IDS_MSGPERF_UNITS                          65

#define IDS_MSGLOG_STATISTICS                      67
#define IDS_MSGLOG_READSTATS                       68
#define IDS_MSGLOG_WRITESTATS                      69
#define IDS_MSGLOG_FRAMEERRORSTATS                 71
#define IDS_MSGLOG_SERIALOVERRUNERRORSTATS         73
#define IDS_MSGLOG_BUFFEROVERRUNERRORSTATS         74
#define IDS_MSGLOG_PARITYERRORSTATS                75

#define IDS_MSGERR_FAILED_INITSTRINGCONSTRUCTION   77
#define IDS_MSGERR_FAILED_INIT                     78
#define IDS_MSGERR_FAILED_DIALSTRINGCONSTRUCTION   79
#define IDS_MSGERR_FAILED_DIAL                     80
#define IDS_MSGERR_FAILED_MONITOR                  81
#define IDS_MSGERR_FAILED_ANSWER                   82
#define IDS_MSGERR_FAILED_HANGUP                   83
#define IDS_MSGERR_FAILED_FLUSH                    84
#define IDS_MSGERR_FAILED_RESPONSE                 85

#define IDS_MSGERR_FAILED_VOICE_ANSWER             87

#define IDS_MSGERR_FAILED_VOICE_DIALSETUP          89

#define IDS_MSGERR_FAILED_VOICE_COMMAND            91

#define IDS_MSGERR_FAILED_VOICE_STARTWAVE          93
#define IDS_MSGERR_FAILED_VOICE_STOPWAVE           94
#define IDS_MSGERR_FAILED_VOICE_SETFORMAT          95

#define IDS_MSGERR_FAILED_VOICE_WAVEOPEN           97

#define IDS_MSGERR_FAILED_VOICE_WAVECLOSE          99

#define IDS_MSGERR_FAILED_VOICE_SPEAKERPHONECOMMAND 202

#define IDS_MSGERR_FAILED_VOICE_GENERATEDTMF       203


#define IDS_MSGWARN_UNRECOGNIZEDRESPONSE           204
#define IDS_MSGWARN_FAILEDTOQUERYVALUE             205
#define IDS_MSGWARN_FAILEDDTRDROPPAGE              206
#define IDS_MSGWARN_PREVIOUSCONNECTIONNOTHUNGUP    207

#define IDS_MSGLOG_OPENED                          211
#define IDS_MSGLOG_DRIVERDESC                      212
#define IDS_MSGLOG_INFPATH                         213
#define IDS_MSGLOG_INFSECTION                      214
#define IDS_MSGLOG_CLOSED                          215



#define IDS_MSGLOG_DIAL                                    216
#define IDS_MSGLOG_MONITOR                                 217
#define IDS_MSGLOG_ANSWER                                  218
#define IDS_MSGLOG_INIT                                    219
#define IDS_MSGLOG_HANGUP                                  220


#define IDS_MSGLOG_VOICE_ANSWER                            221

#define IDS_MSGLOG_VOICE_DIALSETUP                         222

#define IDS_MSGLOG_VOICE_COMMAND                           223


#define IDS_MSGLOG_VOICE_STARTWAVE                         224
#define IDS_MSGLOG_VOICE_STOPWAVE                          225

#define IDS_MSGLOG_VOICE_SETWAVEFORMAT                     226

#define IDS_MSGLOG_VOICE_WAVEOPEN                          227

#define IDS_MSGLOG_VOICE_WAVECLOSE                         228

#define IDS_MSGLOG_VOICE_SPEAKERPHONECOMMAND               229

#define IDS_MSGLOG_VOICE_GENTERAEDTMF                      230

#define IDS_MSGLOG_VOICE_DLERECEIVED                       231


#define IDS_MSGLOG_HARDWAREHANGUP                          232
#define IDS_MSGLOG_REMOTEHANGUP                            233
#define IDS_MSGLOG_COMMAND                                 234
#define IDS_MSGLOG_RAWRESPONSE                             235
#define IDS_MSGLOG_EMPTYRESPONSE                           236
#define IDS_MSGLOG_RESPONSE                                237
#define IDS_MSGLOG_DIAGNOSTICS                             500
#define IDS_MSGLOG_MODEMDIAGNOSTICS                        501
#define IDS_MSGLOG_DONTKNOWTOFORMAT                        502
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\logdiag.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    misc.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"
#include <unimodem.h>
#include "mdmdiag.rch"

DWORD
FormatLineDiagnostics(
    PMODEM_CONTROL               ModemControl,
    LINEDIAGNOSTICSOBJECTHEADER *lpDiagnosticsHeader
    );


#define		STRINGTABLE_MAXLENGTH		0x0100

#define		DIAGMASK_TSP				0x0100

#define	ERROR_TRANSDIAG_SUCCESS				0x00
#define	ERROR_TRANSDIAG_INVALID_PARAMETER	0x01
#define	ERROR_TRANSDIAG_KEY_UNKNOWN			0x02
#define	ERROR_TRANSDIAG_VALUE_WRONG_FORMAT	0x03

#define		DIAGVALUE_RESERVED			0
#define		DIAGVALUE_DECIMAL			1
#define		DIAGVALUE_HEXA				2
#define		DIAGVALUE_STRING			3
#define		DIAGVALUE_TABLE				4
#define		DIAGVALUE_VERSIONFORMAT		5
#define		DIAGVALUE_BYTES				6

typedef	struct	_DIAGTRANSLATION
{
	DWORD	dwKeyCode;			// key value
	DWORD	dwValueType;		// value type, indicates how to format the value
	DWORD	dwParam;			// STRINGTABLE entry with value translations if
								// dwValueType == DIAGVALUE_TABLE
}	DIAGTRANSLATION, *LPDIAGTRANSLATION;


//
//	Builds the diagnostic translation table. 
//		lpDestTable - an array of DIAGTRANSLATION structures
//		dwDestLength - number of items of the array
//	Returns ERROR_SUCCESS on success, 
//		otherwise an error value (ERROR_INVALID_PARAMETER)
//
DWORD	GetDiagTranslationTable(LPDIAGTRANSLATION lpTable,
								DWORD	dwItemCount);

DWORD	ValidateFormat(DWORD dwKey, DWORD dwValue, DWORD dwValueType, 
						LPDIAGTRANSLATION lpFormatTable, 
						DWORD dwFormatItemCount);

//  translation table for MODEM_KEYTYPE_STANDARD_DIAGNOSTICS
//
static DIAGTRANSLATION g_aTableStatusReport[]	= {
    {0x00, DIAGVALUE_VERSIONFORMAT, 0},
    {0x01, DIAGVALUE_TABLE,         STRINGTABLE_CALLSETUPREPORT},
    {0x02, DIAGVALUE_TABLE,         STRINGTABLE_MULTIMEDIAMODES},
    {0x03, DIAGVALUE_TABLE,         STRINGTABLE_DTEDCEMODES},
    {0x04, DIAGVALUE_STRING,        0},
    {0x05, DIAGVALUE_STRING,        0},
    {0x10, DIAGVALUE_DECIMAL,       0},
    {0x11, DIAGVALUE_DECIMAL,       0},
    {0x12, DIAGVALUE_DECIMAL,       0},
    {0x13, DIAGVALUE_DECIMAL,       0},
    {0x14, DIAGVALUE_DECIMAL,       0},
    {0x15, DIAGVALUE_DECIMAL,       0},
    {0x16, DIAGVALUE_DECIMAL,       0},
    {0x17, DIAGVALUE_DECIMAL,       0},
    {0x18, DIAGVALUE_HEXA,          0},
    {0x20, DIAGVALUE_TABLE,         STRINGTABLE_MODULATIONSCHEMEACTIVE},
    {0x21, DIAGVALUE_TABLE,         STRINGTABLE_MODULATIONSCHEMEACTIVE},
    {0x22, DIAGVALUE_DECIMAL,       0},
    {0x23, DIAGVALUE_DECIMAL,       0},
    {0x24, DIAGVALUE_DECIMAL,       0},
    {0x25, DIAGVALUE_DECIMAL,       0},
    {0x26, DIAGVALUE_DECIMAL,       0},
    {0x27, DIAGVALUE_DECIMAL,       0},
    {0x30, DIAGVALUE_DECIMAL,       0},
    {0x31, DIAGVALUE_DECIMAL,       0},
    {0x32, DIAGVALUE_DECIMAL,       0},
    {0x33, DIAGVALUE_DECIMAL,       0},
    {0x34, DIAGVALUE_DECIMAL,       0},
    {0x35, DIAGVALUE_DECIMAL,       0},
    {0x40, DIAGVALUE_TABLE,         STRINGTABLE_ERRORCONTROLACTIVE},
    {0x41, DIAGVALUE_DECIMAL,       0},
    {0x42, DIAGVALUE_DECIMAL,       0},
    {0x43, DIAGVALUE_DECIMAL,       0},
    {0x44, DIAGVALUE_TABLE,         STRINGTABLE_COMPRESSIONACTIVE},
    {0x45, DIAGVALUE_DECIMAL,       0},
    {0x50, DIAGVALUE_TABLE,         STRINGTABLE_FLOWCONTROL},
    {0x51, DIAGVALUE_TABLE,         STRINGTABLE_FLOWCONTROL},
    {0x52, DIAGVALUE_DECIMAL,       0},
    {0x53, DIAGVALUE_DECIMAL,       0},
    {0x54, DIAGVALUE_DECIMAL,       0},
    {0x55, DIAGVALUE_DECIMAL,       0},
    {0x56, DIAGVALUE_DECIMAL,       0},
    {0x57, DIAGVALUE_DECIMAL,       0},
    {0x58, DIAGVALUE_DECIMAL,       0},
    {0x59, DIAGVALUE_DECIMAL,       0},
    {0x60, DIAGVALUE_TABLE,         STRINGTABLE_CALLCLEARED},
    {0x61, DIAGVALUE_DECIMAL,       0},
    //
    //  translation table for MODEM_KEYTYPE_AT_COMMAND_RESPONSE
    //
    {DIAGMASK_TSP + 0x01, DIAGVALUE_BYTES, 0	},
    //
    //  end of table
    //
    {0x00, DIAGVALUE_RESERVED,       0}
};

/**********************************************************************************/
//
//	Converts an array with consecutive non empty structures to
//	an addressable array whose entries correspond to the dwKeyCode
//	Last entry in the source table should have dwValueType == DIAGVALUE_RESERVED
//	Returns number of items needed for table translation
//
/**********************************************************************************/
DWORD	DiagTable2Array(LPDIAGTRANSLATION lpSourceTable,
						LPDIAGTRANSLATION lpDestTable,
						DWORD	dwDestLength)
{
	DWORD	dwItems = 0;
	if (lpSourceTable == NULL)
		return dwItems;

		// make all entries empty
	if (lpDestTable != NULL)
		memset(lpDestTable, 0, sizeof(DIAGTRANSLATION) * dwDestLength);

		// spread the source entries 
	while (lpSourceTable->dwValueType != DIAGVALUE_RESERVED)
	{
				// copy the structure
		if (lpDestTable != NULL &&
			lpSourceTable->dwKeyCode < dwDestLength)
		{
			lpDestTable[lpSourceTable->dwKeyCode] = *lpSourceTable;
		}
		lpSourceTable++;
		dwItems = max(dwItems, lpSourceTable->dwKeyCode+1);
	}

	return dwItems;
}


/**********************************************************************************/
//
//	Builds the diagnostic translation table
//		lpDestTable - an array of DIAGTRANSLATION structures
//		dwDestLength - number of items of the array
//	Returns number of items needed for table translation
//
/**********************************************************************************/
DWORD	GetDiagTranslationTable(LPDIAGTRANSLATION lpTable,
								DWORD	dwItemCount)
{
	return DiagTable2Array(	g_aTableStatusReport, 
							lpTable, dwItemCount);
}



/**********************************************************************************/
//	DWORD	ValidateFormat(DWORD dwKey, DWORD dwValue, DWORD dwValueType, 
//							LPDIAGFORMAT lpFormatTable, 
//							DWORD dwFormatItemCount)
//
//	Validates the format found for the given key and value. Looks in the table
//	and returns ERROR_TRANSDIAG_SUCCESS if:
//		- the key is valid (was found in the array)
//		- the valueType is the same as that given in the array[key]
//
//	dwKey				- key
//	dwValue				- value (in the format given by dwValueType). If 
//						  a string then dwValue is pointer to that string
//	dwValueType			- the type found for the value
//	lpFormatTable		- table with DIAGFORMAT structures used in validating the data
//	dwFormatItemCount	- number of items in lpFormatTable
//
//	Returns ERROR_TRANSDIAG_SUCCESS on success
//		otherwise an error value: 
//					ERROR_TRANSDIAG_XXXX
//
/**********************************************************************************/
DWORD	ValidateFormat(DWORD dwKey, DWORD dwValue, DWORD dwValueType, 
						LPDIAGTRANSLATION lpFormatTable, 
						DWORD dwFormatItemCount)
{
	if (lpFormatTable == NULL)
		return ERROR_TRANSDIAG_INVALID_PARAMETER;
		
	if (dwKey >= dwFormatItemCount ||
		lpFormatTable[dwKey].dwKeyCode != dwKey)
		return ERROR_TRANSDIAG_KEY_UNKNOWN;

	if ((dwValueType & fPARSEKEYVALUE_ASCIIZ_STRING) == 
			fPARSEKEYVALUE_ASCIIZ_STRING)
	{
		if (lpFormatTable[dwKey].dwValueType != DIAGVALUE_STRING)
			return ERROR_TRANSDIAG_VALUE_WRONG_FORMAT;
	}

	return ERROR_TRANSDIAG_SUCCESS;
}





void
PostConnectionInfo(
    PMODEM_CONTROL  ModemControl,
    LPVARSTRING     lpVarString
    )
{

    LINEDIAGNOSTICS	*lpLineDiagnostics	= NULL;

    if ((lpVarString->dwStringFormat == STRINGFORMAT_BINARY)
        &&
        (lpVarString->dwStringSize >= sizeof(LINEDIAGNOSTICS))) {

        lpLineDiagnostics = (LINEDIAGNOSTICS *)((LPBYTE) lpVarString + lpVarString->dwStringOffset);

        // parse the linked structures and look for diagnostics
        // stuff
        //
        while (lpLineDiagnostics != NULL)
        {
            // LogPrintf(ModemControl->Debug,"Diagnostics\r\n");
            LogString(ModemControl->Debug,IDS_MSGLOG_DIAGNOSTICS);
            if (lpLineDiagnostics->hdr.dwSig != LDSIG_LINEDIAGNOSTICS) {

                D_ERROR(UmDpf(ModemControl->Debug,"Invalid diagnostic signature: 0x%08lx\r\n",
                lpLineDiagnostics->hdr.dwSig);)
                goto NextStructure;
            }

            D_TRACE(UmDpf(
                ModemControl->Debug,"DeviceClassID:  %s\r\n",
                ((lpLineDiagnostics->dwDomainID == DOMAINID_MODEM) ? "DOMAINID_MODEM" : "Unknown")
                );)

            D_TRACE(UmDpf(
                ModemControl->Debug,"ResultCode:     %s\r\n",
                ((lpLineDiagnostics->dwResultCode == LDRC_UNKNOWN) ? "LDRC_UNKNOWN" : "Unknown")
                );)


            D_TRACE(UmDpf(
                ModemControl->Debug,
                ("Raw Diagnostic Offset: %ld\r\n"),
                lpLineDiagnostics->dwRawDiagnosticsOffset
                );)

            if (IS_VALID_RAWDIAGNOSTICS_HDR( RAWDIAGNOSTICS_HDR(lpLineDiagnostics))) {

//            DumpMemory(
//                (LPBYTE)RAWDIAGNOSTICS_DATA(lpLineDiagnostics),
//                RAWDIAGNOSTICS_DATA_SIZE(
//                RAWDIAGNOSTICS_HDR(lpLineDiagnostics)));
            }
            else
            {
                D_TRACE(UmDpf(
                    ModemControl->Debug,
                    "Invalid Raw Diagnostic signature: 0x%08lx\r\n",
                    RAWDIAGNOSTICS_HDR(lpLineDiagnostics)->dwSig
                    );)
            }

            D_TRACE(UmDpf(
                ModemControl->Debug,
                "Parsed Diagnostic Offset: %ld\r\n",
                lpLineDiagnostics->dwParsedDiagnosticsOffset
                );)

            if (IS_VALID_PARSEDDIAGNOSTICS_HDR(PARSEDDIAGNOSTICS_HDR(lpLineDiagnostics))) {

//                DumpMemory(
//                    (LPBYTE)PARSEDDIAGNOSTICS_HDR(lpLineDiagnostics),
//                    PARSEDDIAGNOSTICS_HDR(lpLineDiagnostics)->dwTotalSize
//                    );

                FormatLineDiagnostics(ModemControl,PARSEDDIAGNOSTICS_HDR(lpLineDiagnostics));
            }
            else
            {
                D_TRACE(UmDpf(ModemControl->Debug,
                    ("Invalid Parsed Diagnostic signature: 0x%08lx\r\n"),
                    PARSEDDIAGNOSTICS_HDR(lpLineDiagnostics)->dwSig
                    );)

            }


            //	get next structure, if any
NextStructure:
            if (lpLineDiagnostics->hdr.dwNextObjectOffset != 0) {

                lpLineDiagnostics	= (LINEDIAGNOSTICS *)
                (((LPBYTE) lpLineDiagnostics) +
                lpLineDiagnostics->hdr.dwNextObjectOffset);
            } else {

                lpLineDiagnostics	= NULL;
            }
        }
    }
}


#define MAX_STRING_BUFFER   256

DWORD
FormatLineDiagnostics(
    PMODEM_CONTROL               ModemControl,
    LINEDIAGNOSTICSOBJECTHEADER *lpDiagnosticsHeader
    )
{
    DWORD	dwReturnValue	= ERROR_SUCCESS;
    DIAGTRANSLATION	structDiagTranslation;
    LPDIAGTRANSLATION	lpDiagTable	= NULL;
    DWORD	dwEntryCount;
    DWORD	dwStringTableEntry	= 0;
    const	TCHAR	szUnknownFormat[] = TEXT("Don't know to format (0x%08lx, 0x%08lx) for tag 0x%08lx\r\n");
    LPTSTR	lpszFormatBuffer	= NULL;
    LPTSTR	lpszCodeString		= NULL;
    LINEDIAGNOSTICS_PARSEREC *lpParsedDiagnostics = NULL;
    DWORD	dwDiagnosticsItems;
    DWORD	dwIndex;

    if (lpDiagnosticsHeader == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    //  array of LINEDIAGNOSTICS_PARSEREC
    lpParsedDiagnostics	= (LINEDIAGNOSTICS_PARSEREC *)
        (((LPBYTE)lpDiagnosticsHeader) + sizeof(LINEDIAGNOSTICSOBJECTHEADER));

    dwDiagnosticsItems	= lpDiagnosticsHeader->dwParam;

    //	Formatting table
    dwEntryCount = GetDiagTranslationTable(NULL, 0);

    lpDiagTable	= (LPDIAGTRANSLATION) ALLOCATE_MEMORY( dwEntryCount*sizeof(lpDiagTable[0]));

    if (lpDiagTable == NULL)
    {
        dwReturnValue	= GetLastError();
        goto EndFunction;
    }

    GetDiagTranslationTable(lpDiagTable, dwEntryCount);

    //	writing buffers
    lpszFormatBuffer	= (LPTSTR) ALLOCATE_MEMORY( MAX_STRING_BUFFER);
    lpszCodeString		= (LPTSTR) ALLOCATE_MEMORY( MAX_STRING_BUFFER);

    if (lpszFormatBuffer == NULL || lpszCodeString == NULL) {

        dwReturnValue	= GetLastError();
        goto EndFunction;
    }

    // LogPrintf(ModemControl->Debug,"Modem Diagnostics:\r\n");
    LogString(ModemControl->Debug, IDS_MSGLOG_MODEMDIAGNOSTICS);
    for (dwIndex = 0; dwIndex < dwDiagnosticsItems; dwIndex++) {

        DWORD	dwKey;
        DWORD	dwValue;

        dwKey	= lpParsedDiagnostics[dwIndex].dwKey;
        dwValue	= lpParsedDiagnostics[dwIndex].dwValue;

        lpszFormatBuffer[0]	= 0;
        lpszCodeString[0]	= 0;

        if (lpParsedDiagnostics[dwIndex].dwKeyType != MODEM_KEYTYPE_STANDARD_DIAGNOSTICS &&
            lpParsedDiagnostics[dwIndex].dwKeyType != MODEM_KEYTYPE_AT_COMMAND_RESPONSE) {

            D_ERROR(UmDpf(ModemControl->Debug,"LogDiag: bad keytype\n");)

            goto UnknownFormat;
        }

        if (lpParsedDiagnostics[dwIndex].dwKeyType == MODEM_KEYTYPE_AT_COMMAND_RESPONSE) {

            dwKey = dwKey | DIAGMASK_TSP;
        }

        //	check is in range
        if (dwKey >= dwEntryCount) {

            D_ERROR(UmDpf(ModemControl->Debug,"LogDiag: key past tabled length %d\n",dwKey);)

            goto UnknownFormat;
        }

        // Get translate structure and verify is a valid structure
        //
        structDiagTranslation = lpDiagTable[dwKey];

        if (structDiagTranslation.dwValueType == DIAGVALUE_RESERVED ||
            structDiagTranslation.dwKeyCode != dwKey) {

            D_ERROR(UmDpf(ModemControl->Debug,"LogDiag: Bad table entry, %d\n",dwKey);)

            goto UnknownFormat;
        }



        // The format string taken from the main StringTable
        //
        dwStringTableEntry = STRINGTABLE_STATUSREPORT + dwKey;

        if (LoadString(
            GetDriverModuleHandle(ModemControl->ModemDriver),
                dwStringTableEntry,
                lpszFormatBuffer,
                MAX_STRING_BUFFER) == 0) {

            D_ERROR(UmDpf(ModemControl->Debug,"LogDiag: Could not load format string\n");)

            goto UnknownFormat;
        }

        lstrcatA(lpszFormatBuffer,"\r\n");

        //
        // Get the entry in the attached string table, if the case
        //
        if (structDiagTranslation.dwValueType == DIAGVALUE_TABLE) {

            dwStringTableEntry = structDiagTranslation.dwParam + dwValue;

            if (LoadString(
                    GetDriverModuleHandle(ModemControl->ModemDriver),
                    dwStringTableEntry,
                    lpszCodeString,
                    MAX_STRING_BUFFER) == 0) {

                D_ERROR(UmDpf(ModemControl->Debug,"LogDiag: Could not load code string\n");)

                goto UnknownFormat;
            }
        }

        	// Format the output
        switch(structDiagTranslation.dwValueType)
        {
            case DIAGVALUE_DECIMAL:
                LogPrintf(ModemControl->Debug,lpszFormatBuffer, dwValue);
                break;


            case DIAGVALUE_HEXA:
                wsprintf(lpszCodeString, "%08lx",dwValue);
                LogPrintf(ModemControl->Debug,lpszFormatBuffer, lpszCodeString);

                break;

            case DIAGVALUE_STRING:
                LogPrintf(
                    ModemControl->Debug,lpszFormatBuffer,
                    ((LPBYTE)lpDiagnosticsHeader) + dwValue
                    );

                break;

            case DIAGVALUE_BYTES:
            {
            	LPTSTR	lpCurrentChar;

            	CopyMemory((LPBYTE) lpszCodeString,
            				((LPBYTE)lpDiagnosticsHeader) + dwValue,
            				min(sizeof(TCHAR) *
            						(1+lstrlen( (LPTSTR) ((LPBYTE)lpDiagnosticsHeader) + dwValue)),
            					MAX_STRING_BUFFER) );
            	lpCurrentChar = lpszCodeString;
            	while (*lpCurrentChar != 0)
            	{
            		if (!isprint(*lpCurrentChar))
            			*lpCurrentChar = '.';
            		lpCurrentChar++;
            	}
            	LogPrintf(ModemControl->Debug,lpszFormatBuffer, lpszCodeString);
            }

            break;

            case DIAGVALUE_TABLE:
                LogPrintf(ModemControl->Debug,lpszFormatBuffer, lpszCodeString);
                break;

            case DIAGVALUE_VERSIONFORMAT:
                wsprintf(lpszCodeString, "%d.%d", (int) (dwValue >> 16), (int) (dwValue & 0x0000FFFF));
                LogPrintf(ModemControl->Debug,lpszFormatBuffer, lpszCodeString);

                break;

            default:
                D_ERROR(UmDpf(ModemControl->Debug,"LogDiag: hit default for valuetype %d\n",structDiagTranslation.dwValueType);)

            	goto UnknownFormat;
        }

    continue;

UnknownFormat:

        // LogPrintf(ModemControl->Debug,
        LogString(ModemControl->Debug,
           IDS_MSGLOG_DONTKNOWTOFORMAT,
           lpParsedDiagnostics[dwIndex].dwKey,
           lpParsedDiagnostics[dwIndex].dwValue,
           lpParsedDiagnostics[dwIndex].dwKeyType
           );

        continue;
    }


EndFunction:

    if (lpDiagTable != NULL) {

        FREE_MEMORY( lpDiagTable);
    }

    if (lpszFormatBuffer != NULL) {

        FREE_MEMORY( lpszFormatBuffer);
    }

    if (lpszCodeString != NULL) {

        FREE_MEMORY( lpszCodeString);
    }

	return dwReturnValue;
}

VOID WINAPI
UmLogDiagnostics(
    HANDLE   ModemHandle,
    LPVARSTRING  VarString
    )

/*++
Routine description:

     This routine is called to write the translated diagnostic info to the
     minidriver log

Arguments:

    ModemHandle - Handle returned by OpenModem


Return Value:

    None

--*/

{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)ReferenceObjectByHandleAndLock(ModemHandle);

    PostConnectionInfo(ModemControl,VarString);

    RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\internal.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    umdmmini.h

Abstract:

    Nt 5.0 unimodem miniport interface


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#define USE_PLATFORM
#define USE_APC 1
//#define UNICODE 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windows.h>
#include <windowsx.h>

#include <regstr.h>

#include <tapi.h>
#include <tspi.h>

#include <umdmmini.h>

#include <mcx.h>

#include <devioctl.h>
#include <ntddmodm.h>
#include <ntddser.h>

#include <uniplat.h>

#ifdef USE_PLAT

#undef UnimodemReadFileEx
#undef UnimodemWriteFileEx

#else

#define UnimodemReadFileEx  ReadFileEx
#define UnimodemWriteFileEx WriteFileEx

#endif

#include <debugmem.h>

#include "object.h"

#include "common.h"

#include "read.h"

#include "event.h"

#include "command.h"

#include "dle.h"

#include "debug.h"

#include "power.h"

#include "remove.h"

#include "logids.h"

#include "resource.h"


#define  DRIVER_CONTROL_SIG  (0x43444d55)  //UMDC




#define RESPONSE_FLAG_STOP_READ_ON_CONNECT        (1<<0)
#define RESPONSE_FLAG_STOP_READ_ON_GOOD_RESPONSE  (1<<1)
#define RESPONSE_FLAG_SINGLE_BYTE_READS           (1<<2)
#define RESPONSE_FLAG_ONLY_CONNECT                (1<<3)
#define RESPONSE_DO_NOT_LOG_NUMBER                (1<<4)
#define RESPONSE_FLAG_ONLY_CONNECT_SUCCESS        (1<<5)

typedef struct _DRIVER_CONTROL {

    DWORD                  Signature;

    CRITICAL_SECTION       Lock;

    DWORD                  ReferenceCount;

    struct _MODEM_CONTROL *ModemList;

    HANDLE                 CompletionPort;

    HANDLE                 ThreadHandle;

    HANDLE                 ThreadStopEvent;

    COMMON_MODEM_LIST      CommonList;

    HANDLE                 ModuleHandle;

    HINSTANCE              ModemUiModuleHandle;

} DRIVER_CONTROL, *PDRIVER_CONTROL;




#define  MODEM_CONTROL_SIG  (0x434d4d55)  //UMMC


typedef struct _SPEAKERPHONE_SPEC {

    DWORD                       SpeakerPhoneVolMax;
    DWORD                       SpeakerPhoneVolMin;

    DWORD                       SpeakerPhoneGainMax;
    DWORD                       SpeakerPhoneGainMin;

} SPEAKERPHONE_SPEC, *PSPEAKERPHONE_SPEC;


#define MAX_ABORT_STRING_LENGTH 20

typedef struct _MODEM_REG_INFO {

    DWORD                  VoiceProfile;
    BYTE                   DeviceType;

    LPCOMMCONFIG           CommConfig;


    DWORD                  dwModemOptionsCap;
    DWORD                  dwCallSetupFailTimerCap;
    DWORD                  dwInactivityTimeoutCap;
    DWORD                  dwSpeakerVolumeCap;
    DWORD                  dwSpeakerModeCap;

    DWORD                  dwInactivityScale;

    DWORD                  VoiceBaudRate;

    DWORD                  CompatibilityFlags;
    DWORD                  dwWaitForCDTime;

    LPSTR                  CallerIDPrivate;
    LPSTR                  CallerIDOutside;
    LPSTR                  VariableTerminator;

    SPEAKERPHONE_SPEC      SpeakerPhoneSpec;

    UCHAR                  RecordAbort[MAX_ABORT_STRING_LENGTH];
    DWORD                  RecordAbortLength;

    UCHAR                  DuplexAbort[MAX_ABORT_STRING_LENGTH];
    DWORD                  DuplexAbortLength;


    UCHAR                  PlayAbort[MAX_ABORT_STRING_LENGTH];
    DWORD                  PlayAbortLength;

    UCHAR                  PlayTerminate[MAX_ABORT_STRING_LENGTH];
    DWORD                  PlayTerminateLength;


} MODEM_REG_INFO, *PMODEM_REG_INFO;



#define  READ_BUFFER_SIZE         1024


#define  COMMAND_TYPE_NONE             0
#define  COMMAND_TYPE_INIT             1
#define  COMMAND_TYPE_MONITOR          2
#define  COMMAND_TYPE_DIAL             3
#define  COMMAND_TYPE_ANSWER           4
#define  COMMAND_TYPE_HANGUP           5
#define  COMMAND_TYPE_GENERATE_DIGIT   6
#define  COMMAND_TYPE_SET_SPEAKERPHONE 7
#define  COMMAND_TYPE_USER_COMMAND     8
#define  COMMAND_TYPE_WAVE_ACTION      9
#define  COMMAND_TYPE_SETPASSTHROUGH  10
#define  COMMAND_TYPE_DIAGNOSTIC      11

#define  CONNECTION_STATE_NONE                     0
#define  CONNECTION_STATE_DATA                     1
#define  CONNECTION_STATE_DATA_REMOTE_DISCONNECT   2
#define  CONNECTION_STATE_VOICE                    3
#define  CONNECTION_STATE_PASSTHROUGH              4
#define  CONNECTION_STATE_HANDSET_OPEN             5

typedef struct _MODEM_CONTROL {

    OBJECT_HEADER          Header;

    struct _MODEM_CONTROL *Next;

    HANDLE                 CloseEvent;

    PDRIVER_CONTROL        ModemDriver;

    HKEY                   ModemRegKey;

    LPUMNOTIFICATIONPROC   NotificationProc;
    HANDLE                 NotificationContext;

    HANDLE                 FileHandle;

    HANDLE                 CompletionPort;

    HANDLE                 CommonInfo;

    MODEM_REG_INFO         RegInfo;

    OBJECT_HANDLE          ReadState;

    OBJECT_HANDLE          CommandState;

    OBJECT_HANDLE          Debug;

    OBJECT_HANDLE          ModemEvent;

    OBJECT_HANDLE          Dle;

    OBJECT_HANDLE          Power;

    OBJECT_HANDLE          Remove;

    DWORD                  CurrentPreferredModemOptions;
    DWORD                  CallSetupFailTimer;

    PUM_OVER_STRUCT        AsyncOverStruct;

    LPBYTE                 CurrentCommandStrings;
    HANDLE                 CurrentCommandTimer;

    BYTE                   CurrentCommandType;

    struct {

        DWORD                  CDWaitStartTime;

        DWORD                  CommandFlags;

        DWORD                  State;

        DWORD                  Retry;

        DWORD                  PostCIDAnswerState;

        LPBYTE                 VoiceDialSetup;
        LPBYTE                 DialString;

    } DialAnswer;



    BOOL                   NoLogNumber;

    DWORD                  ConnectionState;

    HANDLE                 ConnectionTimer;
    DWORD                  LastBytesRead;
    DWORD                  LastBytesWritten;
    DWORD                  LastTime;

    DWORD                  PrePassthroughConnectionState;

    DWORD                  MonitorState;

    union {

        struct {

            DWORD          State;

            DWORD          RetryCount;

            LPBYTE         ProtocolInit;

            LPBYTE         UserInit;

            LPBYTE         CountrySelect;
        } Init;

        struct {

            DWORD          State;

            LPBYTE         Buffer;

            DWORD          BufferLength;

            LPDWORD        BytesUsed;

        } Diagnostic;

        struct {

            DWORD          State;

            DWORD          Retry;

        } Hangup;

        struct {

            DWORD          State;

            DWORD          CurrentDigit;

            LPSTR          DigitString;

            BOOL           Abort;

        } GenerateDigit;

        struct {

            DWORD          State;

            DWORD          WaitTime;

        } UserCommand;

        struct {

            DWORD          State;

        } SpeakerPhone;


    };



    struct {
        //
        //  wave stuff
        //
        PUM_OVER_STRUCT        OverStruct;

        DWORD                  State;

        PUCHAR                 StartCommand;

        BOOL                   PlayTerminateOrAbort;

        BYTE                   StreamType;

#if DBG
        DWORD                  FlushedBytes;
#endif


    } Wave;



} MODEM_CONTROL, *PMODEM_CONTROL;


#define  COMMAND_OBJECT_SIG  (0x4f434d55)  //UMCO

typedef struct _COMMAND_STATE {

    OBJECT_HEADER          Header;

    DWORD                  State;

    HANDLE                 FileHandle;
    HANDLE                 CompletionPort;


    COMMANDRESPONSE       *CompletionHandler;
    HANDLE                 CompletionContext;

    LPSTR                  Commands;

    LPSTR                  CurrentCommand;

    POBJECT_HEADER         ResponseObject;

    DWORD                  Timeout;

    DWORD                  Flags;

    OBJECT_HANDLE          Debug;

    HANDLE                 TimerHandle;

    DWORD                  ExpandedCommandLength;
    BYTE                   ExpandedCommand[READ_BUFFER_SIZE];

#if DBG

    DWORD                  TimeLastCommandSent;
    DWORD                  OutStandingWrites;
#endif

} COMMAND_STATE, *PCOMMAND_STATE;

//
//  compatibility flags
//
#define COMPAT_FLAG_LOWER_DTR        (0x00000001)    // lower DTR and sleep before closeing com port




HANDLE WINAPI
GetCompletionPortHandle(
    HANDLE       DriverHandle
    );

HANDLE WINAPI
GetCommonList(
    HANDLE       DriverHandle
    );

HANDLE WINAPI
GetDriverModuleHandle(
    HANDLE       DriverHandle
    );



/* Modem State Structure */
#pragma pack(1)
typedef struct _REGMSS {
    BYTE  bResponseState;       // See below
    BYTE  bNegotiatedOptions;   // bitmap, 0 = no info, matches MDM_ options for now, since what we are
                                // interested in fits in 8 bits (error-correction (ec and cell) and compression)
    DWORD dwNegotiatedDCERate;  // 0 = no info
    DWORD dwNegotiatedDTERate;  // 0 = no info and if dwNegotiatedDCERate is 0 on connect, then
                                // the dte baudrate is actually changed.
} REGMSS;
#pragma pack()

#define MSS_FLAGS_DCE_RATE   (1 << 0)
#define MSS_FLAGS_DTE_RATE   (1 << 1)
#define MSS_FLAGS_SIERRA     (1 << 2)

typedef struct _MSS {
                               // interested in fits in 8 bits (error-correction (ec and cell) and compression)
//    DWORD dwNegotiatedDCERate;  // 0 = no info
//    DWORD dwNegotiatedDTERate;  // 0 = no info and if dwNegotiatedDCERate is 0 on connect, then
                                // the dte baudrate is actually changed.

    ULONG NegotiatedRate;
    BYTE  bResponseState;       // See below
    BYTE  bNegotiatedOptions;   // bitmap, 0 = no info, matches MDM_ options for now, since what we are
    BYTE  Flags;

} MSS, *PMSS;


#define  READ_OBJECT_SIG  (0x4f524d55)  //UMRO

typedef struct _READ_STATE {

    OBJECT_HEADER          Header;

    HANDLE                 FileHandle;
    HANDLE                 CompletionPort;

    BYTE                  State;

    BYTE                  StateAfterGoodRead;

    PVOID                  MatchingContext;

    DWORD                  CurrentMatchingLength;

    DWORD                  BytesInReceiveBuffer;

    COMMANDRESPONSE       *ResponseHandler;

    HANDLE                 ResponseHandlerContext;

    DWORD                  ResponseId;

    DWORD                  ResponseFlags;

    PVOID                  ResponseList;

    HANDLE                 Timer;

    PUM_OVER_STRUCT        UmOverlapped;

    OBJECT_HANDLE          Debug;

    DWORD                  DCERate;
    DWORD                  DTERate;
    DWORD                  ModemOptions;

    LPUMNOTIFICATIONPROC   AsyncNotificationProc;
    HANDLE                 AsyncNotificationContext;

    DWORD                  PossibleResponseLength;

    HANDLE                 StopEvent;

    LPSTR                  CallerIDPrivate;
    LPSTR                  CallerIDOutside;
    LPSTR                  VariableTerminator;
    DWORD                  VariableTerminatorLength;

    HANDLE                 Busy;

    MSS                    Mss;

    DWORD                  CurrentCommandLength;

    DWORD                  RingCount;
    DWORD                  LastRingTime;

    PUCHAR                 DiagBuffer;
    DWORD                  DiagBufferLength;
    DWORD                  AmountOfDiagBufferUsed;

    BYTE                   ReceiveBuffer[READ_BUFFER_SIZE];

    BYTE                   CurrentCommand[READ_BUFFER_SIZE];

    HKEY                   ModemRegKey;

    OBJECT_HANDLE          ModemControl;

} READ_STATE, *PREAD_STATE;


#define  GOOD_RESPONSE          0

#define  UNRECOGNIZED_RESPONSE  1

#define  PARTIAL_RESPONSE       2

#define  POSSIBLE_RESPONSE      3

#define  ECHO_RESPONSE          4

#define DIALANSWER_STATE_SEND_COMMANDS              0
#define DIALANSWER_STATE_SENDING_COMMANDS           1
#define DIALANSWER_STATE_WAIT_FOR_CD                2
#define DIALANSWER_STATE_SEND_VOICE_SETUP_COMMANDS        4
#define DIALANSWER_STATE_SENT_VOICE_COMMANDS     5

#define DIALANSWER_STATE_SEND_ORIGINATE_COMMANDS    6
#define DIALANSWER_STATE_SENDING_ORIGINATE_COMMANDS 7


#define DIALANSWER_STATE_ABORTED                    8

#define DIALANSWER_STATE_COMPLETE_COMMAND           9
#define DIALANSWER_STATE_COMPLETE_DATA_CONNECTION   10

#define DIALANSWER_STATE_CHECK_RING_INFO            11
#define DIALANSWER_STATE_DIAL_VOICE_CALL            12

typedef struct _NODE_TRACKING {

    PVOID         NodeArray;
    ULONG         NextFreeNodeIndex;
    ULONG         TotalNodes;
    ULONG         NodeSize;
    ULONG         GrowthSize;

} NODE_TRACKING, *PNODE_TRACKING;


typedef struct _MATCH_NODE {

    USHORT    FollowingCharacter;
    USHORT    NextAltCharacter;
    USHORT    Mss;

    UCHAR     Character;
    UCHAR     Depth;

} MATCH_NODE, *PMATCH_NODE;

typedef struct _ROOT_MATCH {

    NODE_TRACKING MatchNode;

    NODE_TRACKING MssNode;

} ROOT_MATCH, *PROOT_MATCH;



DWORD
MatchResponse(
    PROOT_MATCH    RootOfTree,
    PUCHAR         StringToMatch,
    DWORD          LengthToMatch,
    MSS           *Mss,
    PSTR           CurrentCommand,
    DWORD          CurrentCommandLength,
    PVOID         *MatchingContext
    );


VOID  WINAPI
AbortDialAnswer(
    DWORD              ErrorCode,
    DWORD              Bytes,
    LPOVERLAPPED       dwParam
    );




LONG WINAPI
IssueCommand(
    OBJECT_HANDLE      ObjectHandle,
    LPSTR              Command,
    COMMANDRESPONSE   *CompletionHandler,
    HANDLE             CompletionContext,
    DWORD              TimeOut,
    DWORD              Flags
    );



LPSTR WINAPI
CreateSettingsInitEntry(
    HKEY       ModemKey,
    DWORD      dwOptions,
    DWORD      dwCaps,
    DWORD      dwCallSetupFailTimerCap,
    DWORD      dwCallSetupFailTimerSetting,
    DWORD      dwInactivityTimeoutCap,
    DWORD      dwInactivityScale,
    DWORD      dwInactivityTimeoutSetting,
    DWORD      dwSpeakerVolumeCap,
    DWORD      dwSpeakerVolumeSetting,
    DWORD      dwSpeakerModeCap,
    DWORD      dwSpeakerModeSetting
    );

LPSTR WINAPI
CreateUserInitEntry(
    HKEY       hKeyModem
    );

#define DT_NULL_MODEM       0
#define DT_EXTERNAL_MODEM   1
#define DT_INTERNAL_MODEM   2
#define DT_PCMCIA_MODEM     3
#define DT_PARALLEL_PORT    4
#define DT_PARALLEL_MODEM   5


HANDLE WINAPI
OpenDeviceHandle(
    OBJECT_HANDLE  Debug,
    HKEY     ModemRegKey,
    BOOL     Tsp
    );

LONG WINAPI
SetPassthroughMode(
    HANDLE    FileHandle,
    DWORD     PassThroughMode
    );

typedef struct _ModemMacro {
    CHAR  MacroName[MAX_PATH];
    CHAR  MacroValue[MAX_PATH];
} MODEMMACRO;

#define LMSCH   '<'
#define RMSCH   '>'

#define CR_MACRO            "<cr>"
#define CR_MACRO_LENGTH     4
#define LF_MACRO            "<lf>"
#define LF_MACRO_LENGTH     4

#define CR                  '\r'        // 0x0D
#define LF                  '\n'        // 0x0A



BOOL
ExpandMacros(
    LPSTR pszRegResponse,
    LPSTR pszExpanded,
    LPDWORD pdwValLen,
    MODEMMACRO * pMdmMacro,
    DWORD cbMacros
    );


LPSTR WINAPI
NewLoadRegCommands(
    HKEY  hKey,
    LPCSTR szRegCommand
    );

PVOID WINAPI
NewerBuildResponsesLinkedList(
    HKEY    hKey
    );

VOID
FreeResponseMatch(
    PVOID   Root
    );


BOOL WINAPI
StartAsyncProcessing(
    PMODEM_CONTROL     ModemControl,
    COMMANDRESPONSE   *Handler,
    HANDLE             Context,
    DWORD              Status
    );



//
// dwVoiceProfile bit defintions right from the registry
//
#define VOICEPROF_CLASS8ENABLED           0x00000001  // this is the TSP behavior switch
#define VOICEPROF_HANDSET                 0x00000002  // phone device has handset
#define VOICEPROF_SPEAKER                 0x00000004  // phone device has speaker/mic
#define VOICEPROF_HANDSETOVERRIDESSPEAKER 0x00000008  // this is for Presario
#define VOICEPROF_SPEAKERBLINDSDTMF       0x00000010  // this is for Presario

#define VOICEPROF_SERIAL_WAVE             0x00000020  // wave output uses serial driver
#define VOICEPROF_CIRRUS                  0x00000040  // to dial in voice mode the ATDT string must
                                                      // end with a ";"

#define VOICEPROF_NO_CALLER_ID            0x00000080  // modem does not support caller id

#define VOICEPROF_MIXER                   0x00000100  // modem has speaker mixer

#define VOICEPROF_ROCKWELL_DIAL_HACK      0x00000200  // on voice calls force blind dial after
                                                      // dial tone detection. Rockwell modems
                                                      // will do dial tone detection after
                                                      // one dial string

#define VOICEPROF_RESTORE_SPK_AFTER_REC   0x00000400  // reset speaker phone after record
#define VOICEPROF_RESTORE_SPK_AFTER_PLAY  0x00000800  // reset speaker phone after play

#define VOICEPROF_NO_DIST_RING            0x00001000  // modem does not support distinctive ring
#define VOICEPROF_NO_CHEAP_RING           0x00002000  // modem does not use cheap ring ring
                                                      // ignored if VOICEPROF_NO_DISTRING is set
#define VOICEPROF_TSP_EAT_RING            0x00004000  // TSP should eat a ring when dist ring enabled
#define VOICEPROF_MODEM_EATS_RING         0x00008000  // modem eats a ring when dist ring enabled

#define VOICEPROF_MONITORS_SILENCE        0x00010000  // modem monitors silence
#define VOICEPROF_NO_GENERATE_DIGITS      0x00020000  // modem does not generate DTMF digits
#define VOICEPROF_NO_MONITOR_DIGITS       0x00040000  // modem does not monitor DTMF digits

#define VOICEPROF_SET_BAUD_BEFORE_WAVE    0x00080000  // The baud rate will be set before wave start
                                                      // other wise it will be set after the wave start command

#define VOICEPROF_RESET_BAUDRATE          0x00100000  // If set, the baudrate will be reset
                                                      // after the wave stop command is issued
                                                      // used to optimize the number of commands
                                                      // sent if the modem can autobaud at the
                                                      // higher rate

#define VOICEPROF_MODEM_OVERRIDES_HANDSET 0x00200000  // If set, the handset is disconnected when
                                                      // the modem is active

#define VOICEPROF_NO_SPEAKER_MIC_MUTE     0x00400000  // If set, the speakerphone cannot mute the
                                                      // the microphone

#define VOICEPROF_SIERRA                  0x00800000
#define VOICEPROF_WAIT_AFTER_DLE_ETX      0x01000000  // wait for response after record end



//
//  dle translation values
//

#define  DTMF_0                    0x00
#define  DTMF_1                    0x01

#define  DTMF_2                    0x02
#define  DTMF_3                    0x03

#define  DTMF_4                    0x04
#define  DTMF_5                    0x05

#define  DTMF_6                    0x06
#define  DTMF_7                    0x07

#define  DTMF_8                    0x08
#define  DTMF_9                    0x09

#define  DTMF_A                    0x0a
#define  DTMF_B                    0x0b

#define  DTMF_C                    0x0c
#define  DTMF_D                    0x0d

#define  DTMF_STAR                 0x0e
#define  DTMF_POUND                0x0f

#define  DTMF_START                0x10
#define  DTMF_END                  0x11



#define  DLE_ETX                   0x20

#define  DLE_OFHOOK                0x21  //rockwell value

#define  DLE_ONHOOK                0x22

#define  DLE_RING                  0x23
#define  DLE_RINGBK                0x24

#define  DLE_ANSWER                0x25
#define  DLE_BUSY                  0x26

#define  DLE_FAX                   0x27
#define  DLE_DIALTN                0x28


#define  DLE_SILENC                0x29
#define  DLE_QUIET                 0x2a


#define  DLE_DATACT                0x2b
#define  DLE_BELLAT                0x2c

#define  DLE_LOOPIN                0x2d
#define  DLE_LOOPRV                0x2e

#define  DLE_______                0xff

BOOL WINAPI
SetVoiceBaudRate(
    HANDLE          FileHandle,
    OBJECT_HANDLE   Debug,
    DWORD           BaudRate
    );

VOID
DisconnectHandler(
    HANDLE      Context,
    DWORD       Status
    );

VOID WINAPI
ConnectionTimerHandler(
    HANDLE              Context,
    HANDLE              Context2
    );

VOID
CancelConnectionTimer(
    PMODEM_CONTROL    ModemControl
    );

DWORD
GetTimeDelta(
    DWORD    FirstTime,
    DWORD    LaterTime
    );

VOID WINAPI
MiniDriverAsyncCommandCompleteion(
    PMODEM_CONTROL    ModemControl,
    ULONG_PTR         Status,
    ULONG_PTR         Param2
    );


char *
ConstructNewPreDialCommands(
     HKEY hkDrv,
     DWORD dwNewProtoOpt
     );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\object.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    object.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"

#if DBG

#define  HANDLE_TO_OBJECT(__ObjectHandle) ((POBJECT_HEADER)(~(ULONG_PTR)__ObjectHandle))

#define  OBJECT_TO_HANDLE(__Object) ((OBJECT_HANDLE)(~(ULONG_PTR)__Object))

#else

#define  HANDLE_TO_OBJECT(__ObjectHandle) ((POBJECT_HEADER)__ObjectHandle)

#define  OBJECT_TO_HANDLE(__Object) ((OBJECT_HANDLE)__Object)


#endif

OBJECT_HANDLE WINAPI
CreateObject(
    DWORD             Size,
    POBJECT_HEADER    Owner,
    DWORD             Signature,
    OBJECTCLEANUP    *ObjectCleanup,
    OBJECTCLEANUP    *ObjectClose
    )

{

    POBJECT_HEADER    Header;


    if (Size < sizeof(OBJECT_HEADER)) {

        return NULL;
    }

    //
    //  allocate memory for the object
    //
    Header=ALLOCATE_MEMORY(Size);

    if (Header == NULL) {

        return NULL;
    }

    _try {

        InitializeCriticalSection(
            &Header->Lock
            );

    } _except(EXCEPTION_EXECUTE_HANDLER ) {

        FREE_MEMORY(Header);

        return NULL;
    }


    Header->Signature=Signature;

#if DBG
    Header->Signature2=Signature;
    Header->This=Header;
#endif

    Header->ReferenceCount=1;

    Header->OwnerObject=Owner;

    if (Owner != NULL) {

        AddReferenceToObject(
            Owner
            );

    }

    Header->CleanUpRoutine=ObjectCleanup;

    Header->CloseRoutine=ObjectClose;

    return OBJECT_TO_HANDLE(Header);



}


VOID WINAPI
LockObject(
    POBJECT_HEADER    Header
    )

{

    ASSERT(Header->This == Header);

    EnterCriticalSection(
        &Header->Lock
        );

}


VOID WINAPI
UnlockObject(
    POBJECT_HEADER    Header
    )

{
    ASSERT(Header->This == Header);

    LeaveCriticalSection(
        &Header->Lock
        );

}

VOID WINAPI
AddReferenceToObject(
    POBJECT_HEADER    Header
    )

{
    ASSERT(Header->This == Header);

    EnterCriticalSection(
        &Header->Lock
        );

    Header->ReferenceCount++;

    ASSERT(Header->ReferenceCount < 30);

    LeaveCriticalSection(
        &Header->Lock
        );


}

POBJECT_HEADER WINAPI
ReferenceObjectByHandle(
    OBJECT_HANDLE     ObjectHandle
    )

{

    POBJECT_HEADER    Header=HANDLE_TO_OBJECT(ObjectHandle);

    ASSERT(Header->This == Header);

    EnterCriticalSection(
        &Header->Lock
        );

    ASSERT(!(Header->dwFlags & OBJECT_FLAG_CLOSED));

    Header->ReferenceCount++;

    ASSERT(Header->ReferenceCount < 20);

    LeaveCriticalSection(
        &Header->Lock
        );


    return Header;

}


POBJECT_HEADER WINAPI
ReferenceObjectByHandleAndLock(
    OBJECT_HANDLE     ObjectHandle
    )

{

    POBJECT_HEADER    Header=HANDLE_TO_OBJECT(ObjectHandle);

    ASSERT(Header->This == Header);

    EnterCriticalSection(
        &Header->Lock
        );

    ASSERT(!(Header->dwFlags & OBJECT_FLAG_CLOSED));

    Header->ReferenceCount++;

    ASSERT(Header->ReferenceCount < 30);


    return Header;

}

VOID WINAPI
RemoveReferenceFromObjectAndUnlock(
    POBJECT_HEADER    Header
    )

{
    ASSERT(Header->This == Header);

    Header->ReferenceCount--;

    if (Header->ReferenceCount == 0) {
        //
        //  ref count has gone to zero, cleanup
        //
        OBJECTCLEANUP         *CleanUpRoutine=Header->CleanUpRoutine;
        HANDLE                 CloseWaitEvent=Header->CloseWaitEvent;
        POBJECT_HEADER         Owner=Header->OwnerObject;

        ASSERT(Header->dwFlags & OBJECT_FLAG_CLOSED);

        LeaveCriticalSection(
            &Header->Lock
            );

        DeleteCriticalSection(
            &Header->Lock
            );

#if DBG
        FillMemory(
            Header,
            sizeof(*Header),
            0xca
            );
#endif


        (*CleanUpRoutine)(
            Header
            );

        if (CloseWaitEvent != NULL) {

            SetEvent(
                CloseWaitEvent
                );

        }

        if (Owner != NULL) {

            RemoveReferenceFromObject(
                Owner
                );
        }

        FREE_MEMORY(Header);

        return;
    }

    LeaveCriticalSection(
        &Header->Lock
        );


}


VOID WINAPI
RemoveReferenceFromObject(
    POBJECT_HEADER    Header
    )

{

    ASSERT(Header->This == Header);

    EnterCriticalSection(
        &Header->Lock
        );

    Header->ReferenceCount--;

    if (Header->ReferenceCount == 0) {
        //
        //  ref count has gone to zero, cleanup
        //
        OBJECTCLEANUP         *CleanUpRoutine=Header->CleanUpRoutine;
        HANDLE                 CloseWaitEvent=Header->CloseWaitEvent;
        POBJECT_HEADER         Owner=Header->OwnerObject;

        ASSERT(Header->dwFlags & OBJECT_FLAG_CLOSED);

        LeaveCriticalSection(
            &Header->Lock
            );

        DeleteCriticalSection(
            &Header->Lock
            );

#if DBG
        FillMemory(
            Header,
            sizeof(*Header),
            0xca
            );
#endif


        (*CleanUpRoutine)(
            Header
            );

        if (CloseWaitEvent != NULL) {

            SetEvent(
                CloseWaitEvent
                );

        }


        if (Owner != NULL) {

            RemoveReferenceFromObject(
                Owner
                );
        }

        FREE_MEMORY(Header);

        return;
    }

    LeaveCriticalSection(
        &Header->Lock
        );


}


VOID WINAPI
CloseObject(
    POBJECT_HEADER    Header,
    HANDLE            WaitEvent
    )

{

    ASSERT(Header->This == Header);

    EnterCriticalSection(
        &Header->Lock
        );

    ASSERT(!(Header->dwFlags & OBJECT_FLAG_CLOSED));

    Header->CloseWaitEvent=WaitEvent;

    (*Header->CloseRoutine)(
        Header
        );
#if DBG
    Header->CloseRoutine=(OBJECTCLEANUP*)OBJECT_HEADER_CLOSEROUTINE_CHKVAL;
#endif

    Header->dwFlags |= OBJECT_FLAG_CLOSED;

    LeaveCriticalSection(
        &Header->Lock
        );


    RemoveReferenceFromObject(
        Header
        );

    return;

}



VOID WINAPI
CloseObjectHandle(
    OBJECT_HANDLE     ObjectHandle,
    HANDLE            WaitEvent
    )

{

    POBJECT_HEADER    Header=HANDLE_TO_OBJECT(ObjectHandle);

    ASSERT(Header->This == Header);

    CloseObject(
        Header,
        WaitEvent
        );

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\misc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    misc.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"

#define USER_COMMAND_STATE_SENDCOMMAND        1
#define USER_COMMAND_STATE_WAIT_FOR_RESPONSE  2





HANDLE WINAPI
UmDuplicateDeviceHandle(
    HANDLE    ModemHandle,
    HANDLE    ProcessHandle
    )
/*++

Routine Description:

    This routine is called to duplicate the actual device handle that the miniport is using
    to communicate to the deivce. CloseHandle() must be called on the handle before a new
    call may be placed.

Arguments:

    ModemHandle - Handle returned by OpenModem

    ProcessHandle - Handle of process wanting handle

Return Value:

    Valid handle of NULL if failure

--*/

{

    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)ReferenceObjectByHandleAndLock(ModemHandle);

    HANDLE            NewFileHandle;
    HANDLE            DuplicateFileHandle=NULL;
    BOOL              bResult;


    //
    //  open the device again
    //
    NewFileHandle=OpenDeviceHandle(
        ModemControl->Debug,
        ModemControl->ModemRegKey,
        FALSE
        );

    if (NewFileHandle != INVALID_HANDLE_VALUE) {

        bResult=DuplicateHandle(
            GetCurrentProcess(),
            NewFileHandle,
            ProcessHandle,
            &DuplicateFileHandle,
            0L,
            FALSE,
            DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE
            );

        if (!bResult) {

            D_INIT(UmDpf(ModemControl->Debug,"UmDuplicateDeviceHandle: DuplicateHandle Failed %d\n",GetLastError());)

            DuplicateFileHandle=NULL;
        }
    }

    RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

    return DuplicateFileHandle;

}









VOID WINAPI
UmAbortCurrentModemCommand(
    HANDLE    ModemHandle
    )
/*++

Routine Description:

    This routine is called to abort a current pending command being handled by the miniport.
    This routine should attempt to get the current command to complete as soon as possible.
    This service is advisory. It is meant to tell the driver that port driver wants to cancel
    the current operation. The Port driver must still wait for the async completion of the
    command being canceled, and that commands way infact return successfully. The miniport
    should abort in such a way that the device is in a known state and can accept future commands


Arguments:

    ModemHandle - Handle returned by OpenModem

Return Value:

    None

--*/

{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)ReferenceObjectByHandleAndLock(ModemHandle);

    PUM_OVER_STRUCT UmOverlapped;
    BOOL            bResult;

    switch (ModemControl->CurrentCommandType) {

        case COMMAND_TYPE_ANSWER:

            UmOverlapped=AllocateOverStruct(ModemControl->CompletionPort);

            if (UmOverlapped != NULL) {

                UmOverlapped->Context1=ModemControl;

                bResult=UnimodemQueueUserAPC(
                    &UmOverlapped->Overlapped,
                    AbortDialAnswer
                    );


                if (!bResult) {

                    FreeOverStruct(UmOverlapped);
                }
            }

            break;

        case COMMAND_TYPE_GENERATE_DIGIT:

            ModemControl->GenerateDigit.Abort=TRUE;

            break;

        default:

            break;

    }

    RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

    return;

}


VOID
AsyncWaitForModemEvent(
    PMODEM_CONTROL    ModemControl,
    DWORD             Status
    )

{
    WaitForModemEvent(
        ModemControl->ModemEvent,
        (ModemControl->RegInfo.DeviceType == DT_NULL_MODEM) ? EV_DSR : EV_RLSD,
        INFINITE,
        DisconnectHandler,
        ModemControl
        );

    RemoveReferenceFromObject(
        &ModemControl->Header
        );

    return;
}


DWORD WINAPI
UmSetPassthroughMode(
    HANDLE    ModemHandle,
    DWORD     PassthroughMode
    )
/*++

Routine Description:

    This routine is called to set the passsthrough mode

Arguments:

    ModemHandle - Handle returned by OpenModem

Return Value:

    ERROR_SUCCESS or other specific error


--*/


{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)ReferenceObjectByHandleAndLock(ModemHandle);
    HANDLE            WaitEvent;

    ASSERT(ModemControl->CurrentCommandType == COMMAND_TYPE_NONE);

    if (ModemControl->CurrentCommandType != COMMAND_TYPE_NONE) {

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_UNIMODEM_INUSE;
    }

    ModemControl->CurrentCommandType=COMMAND_TYPE_SETPASSTHROUGH;

    switch (PassthroughMode) {

        case PASSTHROUUGH_MODE_ON:

            LogString(ModemControl->Debug, IDS_PASSTHROUGH_ON);

            WaitEvent=CreateEvent(
                NULL,
                TRUE,
                FALSE,
                NULL
                );

            if (WaitEvent != NULL) {

                UnlockObject(&ModemControl->Header);

                CancelModemEvent(
                    ModemControl->ModemEvent
                    );


                StopResponseEngine(
                    ModemControl->ReadState,
                    WaitEvent
                    );

                ResetEvent(WaitEvent);

                if (ModemControl->ConnectionState == CONNECTION_STATE_VOICE) {

                    StopDleMonitoring(
                        ModemControl->Dle,
                        WaitEvent
                        );

                }

                LockObject(&ModemControl->Header);

                ModemControl->PrePassthroughConnectionState=ModemControl->ConnectionState;

                ModemControl->ConnectionState=CONNECTION_STATE_PASSTHROUGH;

                CloseHandle(WaitEvent);

                ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

                SetPassthroughMode(
                    ModemControl->FileHandle,
                    MODEM_PASSTHROUGH
                    );

                RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

                return ERROR_SUCCESS;

            } else {
                //
                //  failed to allocate event
                //
                ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

                RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

                return GetLastError();

            }

            break;


        case PASSTHROUUGH_MODE_OFF:
            //
            //  exit passthrough mode
            //
            LogString(ModemControl->Debug, IDS_PASSTHROUGH_OFF);

            if (ModemControl->ConnectionState != CONNECTION_STATE_PASSTHROUGH) {
                //
                //  not in passthrough modem just return success
                //
                ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

                RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

                return ERROR_SUCCESS;
            }

            SetPassthroughMode(
                    ModemControl->FileHandle,
                    MODEM_NOPASSTHROUGH
                    );


            if (ModemControl->PrePassthroughConnectionState == CONNECTION_STATE_VOICE) {

                StartDleMonitoring(
                    ModemControl->Dle
                    );

                StartResponseEngine(
                    ModemControl->ReadState,
                    ModemControl
                    );

                ModemControl->ConnectionState=ModemControl->PrePassthroughConnectionState;

            }
            break;

        case PASSTHROUUGH_MODE_ON_DCD_SNIFF:

            LogString(ModemControl->Debug, IDS_PASSTHROUGH_ON_SNIFF);

            if (ModemControl->ConnectionState == CONNECTION_STATE_PASSTHROUGH) {
                //
                //  We will only go to this state if it was in passthrough mode already
                //
                DWORD   ModemStatus;

                GetCommModemStatus(
                    ModemControl->FileHandle,
                    &ModemStatus
                    );

                if (!(ModemStatus & MS_RLSD_ON)) {

                    LogString(ModemControl->Debug, IDS_PASSTHROUGH_CD_LOW);
                }



                SetPassthroughMode(
                    ModemControl->FileHandle,
                    MODEM_DCDSNIFF
                    );

                //
                //  switch to async thread so we will get the APC
                //
                StartAsyncProcessing(
                    ModemControl,
                    AsyncWaitForModemEvent,
                    ModemControl,
                    ERROR_SUCCESS
                    );


                ModemControl->ConnectionState=CONNECTION_STATE_DATA;

            } else {

                D_ERROR(UmDpf(ModemControl->Debug,"UmSetPassthroughModem: DCD_SNIFF bad state\n");)

                ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

                RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

                return ERROR_UNIMODEM_BAD_PASSTHOUGH_MODE;
            }

            break;
    }

    ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

    RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

    return ERROR_SUCCESS;

}




VOID
IssueCommandCompleteHandler(
    HANDLE      Context,
    DWORD       Status
    )

{

    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)Context;
    BOOL              ExitLoop=FALSE;


    ASSERT(COMMAND_TYPE_USER_COMMAND == ModemControl->CurrentCommandType);

    D_INIT(UmDpf(ModemControl->Debug,"UNIMDMAT: IssueCommandCompleteHandler\n");)

    while (!ExitLoop) {

        switch (ModemControl->UserCommand.State) {

            case USER_COMMAND_STATE_SENDCOMMAND:

                ModemControl->UserCommand.State=USER_COMMAND_STATE_WAIT_FOR_RESPONSE;

                Status=IssueCommand(
                    ModemControl->CommandState,
                    ModemControl->CurrentCommandStrings,
                    IssueCommandCompleteHandler,
                    ModemControl,
                    ModemControl->UserCommand.WaitTime,
                    0
                    );

                if (Status == ERROR_IO_PENDING) {

                    ExitLoop=TRUE;

                }

                break;

            case USER_COMMAND_STATE_WAIT_FOR_RESPONSE:

                FREE_MEMORY(ModemControl->CurrentCommandStrings);

                ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

                (*ModemControl->NotificationProc)(
                    ModemControl->NotificationContext,
                    MODEM_ASYNC_COMPLETION,
                    Status,
                    0
                    );

                RemoveReferenceFromObject(
                    &ModemControl->Header
                    );


                ExitLoop=TRUE;

                break;

            default:

                ASSERT(0);

                ExitLoop=TRUE;

                break;

        }
    }




}


DWORD WINAPI
UmIssueCommand(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    LPSTR     CommandToIssue,
    LPSTR     TerminationSequnace,
    DWORD     MaxResponseWaitTime
    )
/*++

Routine Description:

    This routine is called to issue an arbartary commadn to the modem

Arguments:

    ModemHandle - Handle returned by OpenModem

    CommandsOptionList - List option blocks, only flags used
       Flags   - Optional init parameters. Not currently used and must be zero


    CommandToIssue - Null terminated Command to be sent to the modem

    TerminationSequence - Null terminated string to look for to indicate the end of a response

    MaxResponseWaitTime - Time in MS to wait for a response match

Return Value:

    ERROR_IO_PENDING If pending, will be completed later with a call to the AsyncHandler

    or other specific error



--*/


{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)ReferenceObjectByHandleAndLock(ModemHandle);
    LONG              lResult;
    LPSTR             Commands;
    DWORD             CommandLength;
    BOOL              bResult;

    ASSERT(ModemControl->CurrentCommandType == COMMAND_TYPE_NONE);

    if (ModemControl->CurrentCommandType != COMMAND_TYPE_NONE) {

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_UNIMODEM_INUSE;
    }

    if (MaxResponseWaitTime > 60*1000) {

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_UNIMODEM_BAD_TIMEOUT;
    }


    CommandLength=lstrlenA(CommandToIssue);

    ModemControl->CurrentCommandStrings=ALLOCATE_MEMORY(CommandLength+2);

    if (ModemControl->CurrentCommandStrings == NULL) {

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    lstrcpyA(
        ModemControl->CurrentCommandStrings,
        CommandToIssue
        );

    //
    //  add second null terminator
    //
    ModemControl->CurrentCommandStrings[CommandLength+1]='\0';


    ModemControl->CurrentCommandType=COMMAND_TYPE_USER_COMMAND;

    ModemControl->UserCommand.State=USER_COMMAND_STATE_SENDCOMMAND;

    ModemControl->UserCommand.WaitTime=MaxResponseWaitTime;

    bResult=StartAsyncProcessing(
        ModemControl,
        IssueCommandCompleteHandler,
        ModemControl,
        ERROR_SUCCESS
        );


    if (!bResult) {
        //
        //  failed
        //
        ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

        FREE_MEMORY(ModemControl->CurrentCommandStrings);

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_NOT_ENOUGH_MEMORY;

    }

    RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

    return ERROR_IO_PENDING;

}



LONG WINAPI
SetPassthroughMode(
    HANDLE    FileHandle,
    DWORD     PassThroughMode
    )


/*++

Routine Description:


Arguments:


Return Value:



--*/

{
    LONG  lResult;

    DWORD BytesReturned;

    lResult=SyncDeviceIoControl(
        FileHandle,
        IOCTL_MODEM_SET_PASSTHROUGH,
        &PassThroughMode,
        sizeof(PassThroughMode),
        NULL,
        0,
        &BytesReturned
        );

    return lResult;

}







VOID WINAPI
UmLogStringA(
    HANDLE   ModemHandle,
    DWORD    LogFlags,
    LPCSTR   Text
    )

/*++
Routine description:

     This routine is called to add arbitrary ASCII text to the log.
     If logging is not enabled, no action is performed. The format and
     location of the log is mini-driver specific. This function completes
     synchronously and the caller is free to reuse the Text buffer after
     the call returns.

Arguments:

    ModemHandle - Handle returned by OpenModem

    Flags  see above

    Text  ASCII text to be added to the log.

Return Value:

    None

--*/

{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)ReferenceObjectByHandleAndLock(ModemHandle);

    LogPrintf(
        ModemControl->Debug,
        Text
        );


    RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

    return;

}



#define  DIAGNOSTIC_STATE_SEND_COMMANDS       1
#define  DIAGNOSTIC_STATE_WAIT_FOR_RESPONSE   2


VOID
DiagnosticCompleteHandler(
    HANDLE      Context,
    DWORD       Status
    )

{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)Context;

    ASSERT(COMMAND_TYPE_DIAGNOSTIC == ModemControl->CurrentCommandType);

    D_INIT(UmDpf(ModemControl->Debug,"UNIMDMAT: DiagnosticCompleteHandler\n");)


    switch (ModemControl->Diagnostic.State) {

        case DIAGNOSTIC_STATE_SEND_COMMANDS:

            if (ModemControl->RegInfo.dwModemOptionsCap & MDM_DIAGNOSTICS) {

                ModemControl->Diagnostic.State=DIAGNOSTIC_STATE_WAIT_FOR_RESPONSE;

                SetDiagInfoBuffer(
                    ModemControl->ReadState,
                    ModemControl->Diagnostic.Buffer,
                    ModemControl->Diagnostic.BufferLength
                    );


                Status=IssueCommand(
                    ModemControl->CommandState,
                    ModemControl->CurrentCommandStrings,
                    DiagnosticCompleteHandler,
                    ModemControl,
                    10000,
                    0
                    );

                if (Status == ERROR_IO_PENDING) {

                    break;
                }

                //
                //  if it did not pend,  fall though with error returned
                //

             } else {

                Status=ERROR_UNIMODEM_DIAGNOSTICS_NOT_SUPPORTED;
             }



        case DIAGNOSTIC_STATE_WAIT_FOR_RESPONSE:

            FREE_MEMORY(ModemControl->CurrentCommandStrings);

            ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

            *ModemControl->Diagnostic.BytesUsed=ClearDiagBufferAndGetCount(ModemControl->ReadState);

            (*ModemControl->NotificationProc)(
                ModemControl->NotificationContext,
                MODEM_ASYNC_COMPLETION,
                Status,
                0
                );

            RemoveReferenceFromObject(
                &ModemControl->Header
                );



            break;

        default:

            ASSERT(0);
            break;

    }


    return;

}




DWORD WINAPI
UmGetDiagnostics(
    HANDLE    ModemHandle,
    DWORD    DiagnosticType,    // Reserved, must be zero.
    BYTE    *Buffer,
    DWORD    BufferSize,
    LPDWORD  UsedSize
    )

/*++
Routine description:


This routine requests raw diagnostic information on the last call from the modem and if it is
successful copies up-to BufferSize bytes of this information into the supplied buffer,
Buffer, and sets *UsedSize to the number of bytes actually copied.

Note that is *UsedSize == BufferSize on successful return, it is likely but not certain
that there is more information than could be copied over. The latter information is lost.


The format of this information is the ascii tagged format documented in the documentation
for the AT#UD command. The minidriver presents a single string containing all the tags,
stripping out any AT-specific prefix (such as "DIAG") that modems may prepend for
multi-line reporting of diagnostic information. The TSP should be able to deal with
malformed tags, unknown tags, an possibly non-printable characters, including possibly embedded
null characters in the buffer. The buffer is not null terminated.


The recommended point to call this function is after completion of UmHangupModem.
This function should not be called when there is a call in progress. If this function
is called when a call is in progress the result and side-effects are undefined, and
could include failure of the call. The TSP should not expect information about a
call to be preserved after UmInitModem, UmCloseModem and UmOpenModem.


Return Value:


ERROR_IO_PENDING if pending, will be called by a later call to AsyncHandler.
         The TSP must guarantee that the locations pointed to by UsedSize
         and Buffer are valid until the async completion. The TSP can use
         UmAbortCurrentCommand to abort the the UmGetDiagnostics command, but must
         still guarantee the locations are valid until async completion of UmGetDiagnostics.

Other return values represent other failures.

--*/

{

    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)ReferenceObjectByHandleAndLock(ModemHandle);
    CONST static CHAR Diagnostic[]="at#ud\r\0";
    LPSTR             Commands;
    BOOL              bResult;


    Commands=ALLOCATE_MEMORY(sizeof(Diagnostic));

    if (Commands == NULL) {

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_NOT_ENOUGH_MEMORY;

    }

    lstrcpyA(Commands,Diagnostic);


    ModemControl->CurrentCommandStrings=Commands;


    ModemControl->CurrentCommandType=COMMAND_TYPE_DIAGNOSTIC;

    ModemControl->Diagnostic.State=DIAGNOSTIC_STATE_SEND_COMMANDS;

    ModemControl->Diagnostic.Buffer=Buffer;

    ModemControl->Diagnostic.BufferLength=BufferSize;

    ModemControl->Diagnostic.BytesUsed=UsedSize;

    *UsedSize=0;

    bResult=StartAsyncProcessing(
        ModemControl,
        DiagnosticCompleteHandler,
        ModemControl,
        ERROR_SUCCESS
        );


    if (!bResult) {
        //
        //  failed
        //
        ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

        FREE_MEMORY(ModemControl->CurrentCommandStrings);

//        LogString(ModemControl->Debug, IDS_MSGERR_FAILED_Diagnostic);

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_NOT_ENOUGH_MEMORY;

    }

    RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);


    return ERROR_IO_PENDING;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\object.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    umdmmini.h

Abstract:

    Nt 5.0 unimodem miniport interface


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/


typedef VOID (OBJECTCLEANUP)(
    struct _OBJECT_HEADER  *ObjectHeader
    );



#define OBJECT_FLAG_CLOSED    (1 << 0)


typedef struct _OBJECT_HEADER  {

    DWORD                  Signature;

    CRITICAL_SECTION       Lock;

    DWORD                  ReferenceCount;

    struct _OBJECT_HEADER *OwnerObject;

    HANDLE                 CloseWaitEvent;

    OBJECTCLEANUP         *CleanUpRoutine;

    OBJECTCLEANUP         *CloseRoutine;

    DWORD                  dwFlags;
#if DBG
    PVOID                  This;
    DWORD                  Signature2;
#endif

} OBJECT_HEADER, *POBJECT_HEADER;


typedef    PVOID  OBJECT_HANDLE;

#if DBG

#if defined(_WIN64)

#define OBJECT_HEADER_CLOSEROUTINE_CHKVAL ((PVOID)0xcdcdcdcdcdcdcdcd)

#else  // !_WIN64

#define OBJECT_HEADER_CLOSEROUTINE_CHKVAL ((PVOID)0xcdcdcdcd)

#endif // !_WIN64

#endif 

OBJECT_HANDLE WINAPI
CreateObject(
    DWORD             Size,
    POBJECT_HEADER    Owner,
    DWORD             Signature,
    OBJECTCLEANUP    *ObjectCleanup,
    OBJECTCLEANUP    *ObjectClose
    );

VOID WINAPI
LockObject(
    POBJECT_HEADER    Header
    );

VOID WINAPI
UnlockObject(
    POBJECT_HEADER    Header
    );

VOID WINAPI
AddReferenceToObject(
    POBJECT_HEADER    Header
    );

VOID WINAPI
RemoveReferenceFromObject(
    POBJECT_HEADER    Header
    );

VOID WINAPI
CloseObject(
    POBJECT_HEADER    Header,
    HANDLE            WaitEvent
    );

POBJECT_HEADER WINAPI
ReferenceObjectByHandle(
    OBJECT_HANDLE     ObjectHandle
    );

VOID WINAPI
CloseObjectHandle(
    OBJECT_HANDLE     ObjectHandle,
    HANDLE            WaitEvent
    );


POBJECT_HEADER WINAPI
ReferenceObjectByHandleAndLock(
    OBJECT_HANDLE     ObjectHandle
    );

VOID WINAPI
RemoveReferenceFromObjectAndUnlock(
    POBJECT_HEADER    Header
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\openclos.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    openclos.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"



LONG WINAPI
ReadRegistryInfo(
    PMODEM_REG_INFO     RegInfo,
    HKEY                ModemRegKey,
    HANDLE              FileHandle
    );

VOID
ModemObjectClose(
    POBJECT_HEADER  Object
    );

VOID
ModemObjectCleanUp(
    POBJECT_HEADER  Object
    );



//TCHAR cszFriendlyName[] = TEXT("DriverDesc");
CONST TCHAR cszFriendlyName[] = TEXT("FriendlyName");

CONST char szDriverDesc[] = "DriverDesc";
CONST char szInfPath[] = "InfPath";
CONST char szInfSection[] = "InfSection";
CONST char szMatchingId[] = "MatchingDeviceId";



HANDLE WINAPI
UmOpenModem(
    HANDLE      ModemDriverHandle,
    HANDLE      ExtensionBindingHandle,
    HKEY        ModemRegistry,
    HANDLE      CompletionPort,
    LPUMNOTIFICATIONPROC  AsyncNotificationProc,
    HANDLE      AsyncNotificationContext,
    DWORD       DebugDeviceId,
    HANDLE     *CommPortHandle
    )
/*++

Routine Description:

    This routine is called to open a device supported by the miniport.
    The driver will determine it phyical device/kernel mode driver by
    accessing the registry key supplied.

Arguments:

    ModemDriverHandle - Returned from UmInitializemodem()

    ExtensionBindingHandle - Reserved, must be NULL.

    ModemRegistry  - An open registry key to specific devices registry info

    CompletionPort - Handle to a completeion port that the miniport may associate to
                     anydevice file handles that it opens

    AsyncNotificationProc - Address of a callback function to recieve async notifications

    AsyncNotificationContext - Context value passed as first parameter callback function

    DebugDeviceId  - instance of device to be used in displaying debug info

    CommPortHandle - Pointer to a handle that will receive the file handle of the open comm port

Return Value:

    NULL for failure or

    Handle to be used in subsequent calls to other miniport functinos.

--*/


{
    PMODEM_CONTROL    ModemControl;
    BOOL              bResult;
    LONG              lResult;

    OBJECT_HANDLE     ObjectHandle;

    if (ExtensionBindingHandle)
    {
        return NULL;
    }


    ObjectHandle=CreateObject(
        sizeof(*ModemControl),
        NULL,
        MODEM_CONTROL_SIG,
        ModemObjectCleanUp,
        ModemObjectClose
        );

    if (ObjectHandle == NULL) {

        return NULL;
    }

    //
    //  reference the handle to get a pointer to the object
    //
    ModemControl=(PMODEM_CONTROL)ReferenceObjectByHandle(ObjectHandle);




    ModemControl->Debug=InitializeDebugObject(
        NULL,
        ModemRegistry,
        GetDriverModuleHandle(ModemDriverHandle),
        DebugDeviceId
        );

    if (ModemControl->Debug == NULL) {

        goto CleanUp000;
    }

    ModemControl->CloseEvent=CreateEvent(
            NULL,
            TRUE,
            FALSE,
            NULL
            );

    if (ModemControl->CloseEvent == NULL) {

        goto CleanUp000;
    }


    LogFileVersion(
        ModemControl->Debug,
        "tapisrv.dll"
        );

    LogFileVersion(
        ModemControl->Debug,
        "unimdm.tsp"
        );

    LogFileVersion(
        ModemControl->Debug,
        "unimdmat.dll"
        );

    LogFileVersion(
        ModemControl->Debug,
        "uniplat.dll"
        );

    LogFileVersion(
        ModemControl->Debug,
        "drivers\\modem.sys"
        );

    LogFileVersion(
        ModemControl->Debug,
        "modemui.dll"
        );

    LogFileVersion(
        ModemControl->Debug,
        "mdminst.dll"
        );

    {

        CHAR    TempBuffer[256];
        DWORD   dwType;
        DWORD   dwRetSize;

        //
        // Write out some inf identification info for PSS
        //
        dwRetSize = sizeof(TempBuffer);

        if (RegQueryValueExA(ModemRegistry, szDriverDesc, NULL,
                             &dwType, TempBuffer, &dwRetSize) == ERROR_SUCCESS) {

            LogString(ModemControl->Debug, IDS_MSGLOG_DRIVERDESC, TempBuffer);
        }

        dwRetSize = sizeof(TempBuffer);

        if (RegQueryValueExA(ModemRegistry, szInfPath, NULL,
                             &dwType, TempBuffer, &dwRetSize) == ERROR_SUCCESS) {

            LogString(ModemControl->Debug, IDS_MSGLOG_INFPATH, TempBuffer);
        }

        dwRetSize = sizeof(TempBuffer);

        if (RegQueryValueExA(ModemRegistry, szInfSection, NULL,
                             &dwType, TempBuffer, &dwRetSize) == ERROR_SUCCESS) {

            LogString(ModemControl->Debug, IDS_MSGLOG_INFSECTION, TempBuffer);
        }

        dwRetSize = sizeof(TempBuffer);

        if (RegQueryValueExA(ModemRegistry, szMatchingId, NULL,
                             &dwType, TempBuffer, &dwRetSize) == ERROR_SUCCESS) {

            LogString(ModemControl->Debug, IDS_MSGLOG_DEVICEID, TempBuffer);
        }

    }

    //
    //  save the parameters
    //
    ModemControl->ModemRegKey=ModemRegistry;

    ModemControl->NotificationProc=AsyncNotificationProc;

    ModemControl->NotificationContext=AsyncNotificationContext;

    ModemControl->ModemDriver=ModemDriverHandle;

    //
    //  open the device
    //
    ModemControl->FileHandle=OpenDeviceHandle(
        ModemControl->Debug,
        ModemRegistry,
        TRUE
        );

    if (ModemControl->FileHandle == INVALID_HANDLE_VALUE) {

        LogString(ModemControl->Debug,IDS_OPEN_FAILURE, GetLastError());

        goto CleanUp000;

    }


    ModemControl->CompletionPort=CreateOverStructPool(GetCompletionPortHandle(ModemDriverHandle),16);

    ModemControl->AsyncOverStruct=AllocateOverStruct(ModemControl->CompletionPort);

    if (ModemControl->AsyncOverStruct == NULL) {

        D_INIT(DebugPrint("UNIMDMAT: Could not allocate OverStruct\n");)

        goto CleanUp000;
    }


    ModemControl->CommonInfo=OpenCommonModemInfo(
        ModemControl->Debug,
        GetCommonList(ModemDriverHandle),
        ModemRegistry
        );

    if (ModemControl->CommonInfo == NULL) {

        D_INIT(DebugPrint("UNIMDMAT: Could not Common info\n");)

        goto CleanUp000;
    }


    lResult=ReadRegistryInfo(
        &ModemControl->RegInfo,
        ModemRegistry,
        ModemControl->FileHandle
        );

    if (lResult != ERROR_SUCCESS) {

        D_ERROR(DebugPrint("UNIMDMAT: ReadRegistryInf() failed\n");)

        goto CleanUp000;
    }


    SetCommConfig(
        ModemControl->FileHandle,
        ModemControl->RegInfo.CommConfig,
        ModemControl->RegInfo.CommConfig->dwSize
        );


    if (ModemControl->RegInfo.VoiceProfile & VOICEPROF_CLASS8ENABLED) {

        ModemControl->Wave.OverStruct=AllocateOverStruct(ModemControl->CompletionPort);

        if (ModemControl->Wave.OverStruct == NULL) {

            D_ERROR(DebugPrint("UNIMDMAT: Could not allocate OverStruct\n");)

            goto CleanUp000;
        }
    }

    ModemControl->CurrentCommandTimer=CreateUnimodemTimer(ModemControl->CompletionPort);

    if (ModemControl->CurrentCommandTimer == NULL) {

        D_ERROR(DebugPrint("UNIMDMAT: Could not allocate CurrentCommandTimer\n");)

        goto CleanUp000;
    }

    ModemControl->ReadState=InitializeReadHandler(
        &ModemControl->Header,
        ModemControl->FileHandle,
        ModemControl->CompletionPort,
        AsyncNotificationProc,
        AsyncNotificationContext,
        GetCommonResponseList(ModemControl->CommonInfo),
        ModemControl->RegInfo.CallerIDPrivate,
        ModemControl->RegInfo.CallerIDOutside,
        ModemControl->RegInfo.VariableTerminator,
        ModemControl->Debug,
        ModemRegistry
        );

    if (ModemControl->ReadState == NULL) {

        goto CleanUp000;
    }


    ModemControl->CommandState=InitializeCommandObject(
        &ModemControl->Header,
        ModemControl->FileHandle,
        ModemControl->CompletionPort,
        ModemControl->ReadState,
        ModemControl->Debug
        );

    if (ModemControl->CommandState == NULL) {

        goto CleanUp000;
    }

    ModemControl->ModemEvent=InitializeModemEventObject(
        &ModemControl->Header,
        ModemControl->Debug,
        ModemControl->FileHandle,
        ModemControl->CompletionPort
        );

    if (ModemControl->ModemEvent == NULL) {

        goto CleanUp000;
    }

    ModemControl->Dle=InitializeDleHandler(
        &ModemControl->Header,
        ModemControl->FileHandle,
        ModemControl->CompletionPort,
        AsyncNotificationProc,
        AsyncNotificationContext,
        ModemControl->Debug
        );

    if (ModemControl->Dle == NULL) {

        goto CleanUp000;
    }

    ModemControl->Power=CreatePowerObject(
        &ModemControl->Header,
        ModemControl->FileHandle,
        ModemControl->CompletionPort,
        AsyncNotificationProc,
        AsyncNotificationContext,
        ModemControl->Debug
        );

    if (ModemControl->Power == NULL) {

        goto CleanUp000;
    }


    ModemControl->Remove=CreateRemoveObject(
        &ModemControl->Header,
        ModemControl->FileHandle,
        ModemControl->CompletionPort,
        AsyncNotificationProc,
        AsyncNotificationContext,
        ModemControl->Debug
        );

    if (ModemControl->Remove == NULL) {

        goto CleanUp000;
    }


    if (CommPortHandle != NULL) {
        //
        //  return file handle for ipc stuff
        //
        *CommPortHandle=ModemControl->FileHandle;
    }

    //
    //  release the reference to the object
    //
    RemoveReferenceFromObject(&ModemControl->Header);


    return ObjectHandle;


CleanUp000:

    {
        HANDLE            Event=ModemControl->CloseEvent;

        D_INIT(DebugPrint("UNIMDMAT: UmOpenModem- cleanup\n");)

        //
        //  release the reference to the object
        //
        RemoveReferenceFromObject(&ModemControl->Header);


        CloseObject(
            &ModemControl->Header,
            Event
            );

        if (Event != NULL) {

            WaitForSingleObject(
                Event,
                INFINITE
                );

            CloseHandle(Event);
        }
    }


    return NULL;



}


#define DOSDEVICEROOT TEXT("\\\\.\\")

HANDLE WINAPI
OpenDeviceHandle(
    OBJECT_HANDLE  Debug,
    HKEY     ModemRegKey,
    BOOL     Tsp
    )

{
    LONG     lResult;
    DWORD    Type;
    DWORD    Size;

    HANDLE   FileHandle;
//    TCHAR    FriendlyName[MAX_PATH];
//

    LPWSTR   FriendlyName;

    FriendlyName = ALLOCATE_MEMORY(MAX_PATH * 2);

    if (FriendlyName == NULL)
    {
        D_INIT(UmDpf(Debug,"UNIMDMAT: Could not allocate memory for friendly name\n");)

        return INVALID_HANDLE_VALUE;
    }

    lstrcpyW(FriendlyName,L"\\\\.\\");

    Size=MAX_PATH-((lstrlenW(FriendlyName)+1));
    //
    //  read the friendly name from the registry
    //
    lResult=RegQueryValueExW(
        ModemRegKey,
        L"FriendlyName",
        NULL,
        &Type,
        (LPBYTE)(FriendlyName+lstrlenW(FriendlyName)),
        &Size
        );

    if ((lResult != ERROR_SUCCESS) || (Type != REG_SZ)) {

        D_INIT(UmDpf(Debug,"UNIMDMAT: Could not read Friendly Name from Registry %08lx\n",lResult);)

        return INVALID_HANDLE_VALUE;

    }

    if (Tsp) {

        lstrcatW(FriendlyName,L"\\Tsp");

    } else {

        lstrcatW(FriendlyName,L"\\Client");
    }

    D_INIT(UmDpf(Debug,"Opening %ws\n",FriendlyName);)

    //
    //  open the modem device using the friendly name
    //
    FileHandle=CreateFileW(
        FriendlyName,
        GENERIC_WRITE | GENERIC_READ,
        FILE_SHARE_WRITE | FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_OVERLAPPED,
        NULL
        );

    if (FileHandle == INVALID_HANDLE_VALUE) {

        D_INIT(UmDpf(Debug,"UNIMDMAT: Failed to open (%ws). %08lx\n",FriendlyName,GetLastError());)

    }

    FREE_MEMORY(FriendlyName);

    return FileHandle;

}


typedef DWORD APIENTRY
PRIVATEGETDEFCOMMCONFIG(
    HKEY  hKey,
    LPCOMMCONFIG pcc,
    LPDWORD pdwSize
    );


#define DEFAULT_INACTIVITY_SCALE 10    // == decasecond units

LONG WINAPI
ReadRegistryInfo(
    PMODEM_REG_INFO     RegInfo,
    HKEY                ModemRegKey,
    HANDLE              FileHandle
    )

{
    LONG      lResult;
    DWORD     Size;
    DWORD     Type;
    HINSTANCE hLib;

    DWORD     dwCCSize;
    LPCOMMCONFIG   CommConfig;

    PRIVATEGETDEFCOMMCONFIG *pfnPrivateDefCommConfig;

    CONST static TCHAR szInactivityScale[] = TEXT("InactivityScale");

    CONST static TCHAR szCDWaitPeriod[]    = TEXT("CDWaitPeriod");
    CONST static TCHAR szCompatFlags[]     = TEXT("CompatibilityFlags");

    CONST static TCHAR szVariableTerminator[] =TEXT("VariableTerminator");
    CONST static TCHAR szCallerIDPrivate[]    =TEXT("CallerIDPrivate");
    CONST static TCHAR szCallerIDOutside[]    =TEXT("CallerIDOutside");


    UCHAR    szTemp[MAX_PATH];
    UCHAR    szExpanded[MAX_PATH];

    TCHAR    FriendlyName[MAX_PATH];
    TCHAR    szLib[MAX_PATH];


    Size=sizeof(FriendlyName);

    lResult=RegQueryValueEx(
        ModemRegKey,
        cszFriendlyName,
        NULL,
        &Type,
        (LPBYTE)FriendlyName,
        &Size
        );

    if ((lResult != ERROR_SUCCESS) || (Type != REG_SZ)) {

        D_INIT(DebugPrint("UNIMDMAT: Could not read Friendly Name from Registry %08lx\n",lResult);)

        return ERROR_INVALID_DATA;

    }

    dwCCSize = sizeof(MODEMSETTINGS)+FIELD_OFFSET(COMMCONFIG, wcProviderData);

    CommConfig = (LPCOMMCONFIG)ALLOCATE_MEMORY((UINT)dwCCSize);

    if (CommConfig == NULL) {

        return ERROR_OUTOFMEMORY;
    }

    RegInfo->CommConfig=NULL;

    hLib=LoadLibrary(TEXT("modemui.dll"));


    if (hLib) {

        pfnPrivateDefCommConfig = (PVOID)GetProcAddress(hLib,"UnimodemGetDefaultCommConfig");

        if (pfnPrivateDefCommConfig != NULL) {

            CommConfig->dwProviderSubType = PST_MODEM;

            lResult=(*pfnPrivateDefCommConfig)(ModemRegKey, CommConfig, &dwCCSize);

            if (ERROR_SUCCESS == lResult) {

                RegInfo->CommConfig=CommConfig;
            }

        }

        FreeLibrary(hLib);

    }


    if (RegInfo->CommConfig == NULL) {

        CommConfig->dwProviderSubType = PST_MODEM;

        lResult=GetDefaultCommConfig(
            FriendlyName,
            CommConfig,
            &dwCCSize
            );

        if (TRUE == lResult) {

            RegInfo->CommConfig=CommConfig;

        } else {

            FREE_MEMORY(CommConfig);

            return GetLastError();
        }

    }

#define ALLOCATEMODEM_TEMP_SIZE   512

    // Get some capabilities from modem.sys.
    {
        BYTE       TempBuffer[ALLOCATEMODEM_TEMP_SIZE];
        LPCOMMPROP lpCommProp = (LPCOMMPROP) TempBuffer;

        lpCommProp->dwProvSpec1 = COMMPROP_INITIALIZED;
        lpCommProp->wPacketLength = ALLOCATEMODEM_TEMP_SIZE;

        if (GetCommProperties(FileHandle, lpCommProp) == TRUE) {

            LPMODEMDEVCAPS lpModemDevCaps = (LPMODEMDEVCAPS)
                                                &lpCommProp->wcProvChar[0];

            RegInfo->dwModemOptionsCap       = lpModemDevCaps->dwModemOptions;
            RegInfo->dwCallSetupFailTimerCap = lpModemDevCaps->dwCallSetupFailTimer;
            RegInfo->dwInactivityTimeoutCap  = lpModemDevCaps->dwInactivityTimeout;
            RegInfo->dwSpeakerVolumeCap      = lpModemDevCaps->dwSpeakerVolume;
            RegInfo->dwSpeakerModeCap        = lpModemDevCaps->dwSpeakerMode;


        } else {

//            MCXPRINTF1("GetCommProperties() failed with %d", GetLastError());

            RegInfo->dwModemOptionsCap = 0;
            RegInfo->dwCallSetupFailTimerCap = 0;
            RegInfo->dwInactivityTimeoutCap = 0;
            RegInfo->dwSpeakerVolumeCap = 0;
            RegInfo->dwSpeakerModeCap = 0;
        }
    }

    Size = sizeof(DWORD);

    lResult = RegQueryValueEx(
        ModemRegKey,
        szInactivityScale,
        NULL,
        &Type,
        (PBYTE)&RegInfo->dwInactivityScale,
        &Size
        );

    if ((Size != sizeof(DWORD))
        ||
        (lResult  != ERROR_SUCCESS)
        ||
        (0 == RegInfo->dwInactivityScale)) {

        // reg query failed
        //
        RegInfo->dwInactivityScale = DEFAULT_INACTIVITY_SCALE;
    }

    //
    // Read in the compat flags
    //
    Size = sizeof(RegInfo->CompatibilityFlags);

    lResult = RegQueryValueEx(
        ModemRegKey,
        szCompatFlags,
        NULL,
        &Type,
        (PBYTE)&RegInfo->CompatibilityFlags,
        &Size
        );

    if (Size != sizeof(RegInfo->CompatibilityFlags) ||
        lResult  != ERROR_SUCCESS )
    {
        // reg query failed
        //
        RegInfo->CompatibilityFlags=0;

    }

    //
    // Read in the device type value
    //
    Size = sizeof(RegInfo->DeviceType);

    lResult = RegQueryValueEx(
        ModemRegKey,
        TEXT("DeviceType"),
        NULL,
        &Type,
        (PBYTE)&RegInfo->DeviceType,
        &Size
        );

    if (Size != sizeof(RegInfo->DeviceType) ||
        lResult  != ERROR_SUCCESS ) {

        //
        // reg query failed
        //
        RegInfo->DeviceType=DT_EXTERNAL_MODEM;

    }



    //
    // Read in the CD wait period
    //
    Size = sizeof(DWORD);

    lResult = RegQueryValueExA(
        ModemRegKey,
        szCDWaitPeriod,
        NULL,
        &Type,
        (PBYTE)&RegInfo->dwWaitForCDTime,
        &Size
        );

    if (Size != sizeof(DWORD) ||
        lResult  != ERROR_SUCCESS ||
        0 == RegInfo->dwWaitForCDTime)
    {
      // reg query failed
      //
      RegInfo->dwWaitForCDTime=5000;

    }



    //
    //  get the voice profile dword
    //
    Size = sizeof(DWORD);

    lResult = RegQueryValueEx(
        ModemRegKey,
        TEXT("VoiceProfile"),
        NULL,
        &Type,
        (PBYTE)&RegInfo->VoiceProfile,
        &Size
        );

    if ((Size != sizeof(DWORD))
        ||
        (lResult  != ERROR_SUCCESS)) {
        //
        // reg query failed
        //
        RegInfo->VoiceProfile=0;

    }

    //
    //  get the voice baudrate
    //
    Size = sizeof(DWORD);

    lResult = RegQueryValueEx(
        ModemRegKey,
        TEXT("VoiceBaudRate"),
        NULL,
        &Type,
        (PBYTE)&RegInfo->VoiceBaudRate,
        &Size
        );

    if ((Size != sizeof(DWORD))
        ||
        (lResult  != ERROR_SUCCESS)) {
        //
        // reg query failed
        //
        RegInfo->VoiceBaudRate=38400;

    }


    Size=sizeof(SPEAKERPHONE_SPEC);

    lResult=RegQueryValueEx(
        ModemRegKey,
        TEXT("SpeakerPhoneSpecs"),
        NULL,
        &Type,
        (LPBYTE)&RegInfo->SpeakerPhoneSpec,
        &Size
        );


    if (lResult != ERROR_SUCCESS || Type != REG_BINARY || Size < sizeof(SPEAKERPHONE_SPEC)) {

//        VPRINTF(("Unimodem: Could not get Speakerphone Vol specs!\n"));

    }



    //
    // Read the priate string return for calller ID
    //
    Size = MAX_PATH;

    lResult=RegQueryValueExA(
        ModemRegKey,
        szVariableTerminator,
        NULL,
        &Type,
        szTemp,
        &Size
        );

    if ((lResult == ERROR_SUCCESS) && (Type==REG_SZ)) {

        ExpandMacros(szTemp, szExpanded, NULL, NULL, 0);

        RegInfo->VariableTerminator = ALLOCATE_MEMORY(lstrlenA(szExpanded)+1);

        // allocate some memory
        if (RegInfo->VariableTerminator != NULL) {

            lstrcpyA(RegInfo->VariableTerminator, szExpanded);

        }

    } else {
        //
        //  default it to <cr><lf>
        //
        RegInfo->VariableTerminator = ALLOCATE_MEMORY(lstrlenA("\r\n")+1);

        if (RegInfo->VariableTerminator != NULL) {

            lstrcpyA(RegInfo->VariableTerminator, "\r\n");
        }
    }




    //
    // Read the priate string return for calller ID
    //
    Size = MAX_PATH;

    lResult=RegQueryValueExA(
        ModemRegKey,
        szCallerIDPrivate,
        NULL,
        &Type,
        szTemp,
        &Size
        );

    if ((lResult == ERROR_SUCCESS) && (Type==REG_SZ)) {

        ExpandMacros(szTemp, szExpanded, NULL, NULL, 0);

        RegInfo->CallerIDPrivate = ALLOCATE_MEMORY(lstrlenA(szExpanded)+1);

        // allocate some memory
        if (RegInfo->CallerIDPrivate != NULL) {

            lstrcpyA(RegInfo->CallerIDPrivate, szExpanded);

        }

    }


    //
    // Read the out of seriver area string return for calller ID
    //
    Size = MAX_PATH;

    lResult=RegQueryValueExA(
        ModemRegKey,
        szCallerIDOutside,
        NULL,
        &Type,
        szTemp,
        &Size
        );

    if ((lResult == ERROR_SUCCESS) && (Type==REG_SZ)) {

        ExpandMacros(szTemp, szExpanded, NULL, NULL, 0);

        RegInfo->CallerIDOutside= ALLOCATE_MEMORY(lstrlenA(szExpanded)+1);

        // allocate some memory
        if (RegInfo->CallerIDOutside != NULL) {

            lstrcpyA(RegInfo->CallerIDOutside, szExpanded);

        }

    }








    if (RegInfo->VoiceProfile & VOICEPROF_SERIAL_WAVE) {

        //
        // Read terminator serial playback
        //
        Size = MAX_PATH;

        lResult=RegQueryValueExA(
            ModemRegKey,
            "TerminatePlay",
            NULL,
            &Type,
            szTemp,
            &Size
            );

        if ((lResult == ERROR_SUCCESS) && (Type==REG_SZ)) {

            ExpandMacros(szTemp, szExpanded, NULL, NULL, 0);

            if (lstrlenA(szExpanded)+1 < MAX_ABORT_STRING_LENGTH) {

                lstrcpyA(
                    RegInfo->PlayTerminate+1,
                    szExpanded
                    );

                RegInfo->PlayTerminate[0]=0;

                RegInfo->PlayTerminateLength=lstrlenA(szExpanded)+1;
            }

        }

        //
        // Read terminator serial playback
        //
        Size = MAX_PATH;


        lResult=RegQueryValueExA(
            ModemRegKey,
            "AbortPlay",
            NULL,
            &Type,
            szTemp,
            &Size
            );

        if ((lResult == ERROR_SUCCESS) && (Type==REG_SZ)) {

            ExpandMacros(szTemp, szExpanded, NULL, NULL, 0);

            if (lstrlenA(szExpanded)+1 < MAX_ABORT_STRING_LENGTH) {

                lstrcpyA(
                    RegInfo->PlayAbort+1,
                    szExpanded
                    );

                RegInfo->PlayAbort[0]=0;

                RegInfo->PlayAbortLength=lstrlenA(szExpanded)+1;
            }

        }


        //
        // Read terminator serial playback
        //
        Size = MAX_PATH;


        lResult=RegQueryValueExA(
            ModemRegKey,
            "TerminateRecord",
            NULL,
            &Type,
            szTemp,
            &Size
            );

        if ((lResult == ERROR_SUCCESS) && (Type==REG_SZ)) {

            ExpandMacros(szTemp, szExpanded, NULL, NULL, 0);

            if (lstrlenA(szExpanded)+1 < MAX_ABORT_STRING_LENGTH) {

                lstrcpyA(
                    RegInfo->RecordAbort,
                    szExpanded
                    );

                RegInfo->RecordAbortLength=lstrlenA(szExpanded);
            }

        }

        //
        // Read terminator serial playback
        //
        Size = MAX_PATH;


        lResult=RegQueryValueExA(
            ModemRegKey,
            "TerminateDuplex",
            NULL,
            &Type,
            szTemp,
            &Size
            );

        if ((lResult == ERROR_SUCCESS) && (Type==REG_SZ)) {

            ExpandMacros(szTemp, szExpanded, NULL, NULL, 0);

            if (lstrlenA(szExpanded)+1 < MAX_ABORT_STRING_LENGTH) {

                lstrcpyA(
                    RegInfo->DuplexAbort+1,
                    szExpanded
                    );

                RegInfo->DuplexAbort[0]=0;

                RegInfo->DuplexAbortLength=lstrlenA(szExpanded)+1;
            }

        }

    }




    return ERROR_SUCCESS;

}


VOID WINAPI
FreeRegistryInfo(
    PMODEM_REG_INFO     RegInfo
    )

{

    if (RegInfo->CommConfig != NULL) {

        FREE_MEMORY(RegInfo->CommConfig);

    }

    if (RegInfo->CallerIDPrivate != NULL) {

        FREE_MEMORY(RegInfo->CallerIDPrivate);

    }

    if (RegInfo->CallerIDOutside != NULL) {

        FREE_MEMORY(RegInfo->CallerIDOutside);

    }

    if (RegInfo->VariableTerminator != NULL) {

        FREE_MEMORY(RegInfo->VariableTerminator);

    }

}



VOID WINAPI
UmCloseModem(
    HANDLE    ModemHandle
    )
/*++

Routine Description:

    This routine is called to close a modem handle retuned by OpenModem

Arguments:

    ModemHandle - Handle returned by OpenModem

Return Value:

    None

--*/

{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)ReferenceObjectByHandleAndLock(ModemHandle);
    HANDLE            Event=ModemControl->CloseEvent;

    D_INIT(UmDpf(ModemControl->Debug,"UmCloseModem");)

    RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

    CloseObjectHandle(
        ModemHandle,
        Event
        );

    WaitForSingleObject(
        Event,
        INFINITE
        );

    CloseHandle(Event);

    return;

}


VOID  WINAPI
TimerCancelHandler(
    DWORD              ErrorCode,
    DWORD              Bytes,
    LPOVERLAPPED       dwParam
    )

{
    PUM_OVER_STRUCT    UmOverlapped=(PUM_OVER_STRUCT)dwParam;
    PMODEM_CONTROL     ModemControl=UmOverlapped->Context1;

    CancelConnectionTimer(ModemControl);

    //
    //  remove ref for this routine
    //
    RemoveReferenceFromObject(&ModemControl->Header);

    FreeOverStruct(UmOverlapped);

    return;

}


VOID
ModemObjectClose(
    POBJECT_HEADER  Object
    )

{

    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)Object;

    D_INIT(if (ModemControl->Debug != NULL) UmDpf(ModemControl->Debug,"ModemObjectClose ref=%d",ModemControl->Header.ReferenceCount);)


    if (ModemControl->ConnectionTimer != NULL) {
        //
        //  the connection timer is still around, schedule the async thread to cancel it
        //
        PUM_OVER_STRUCT UmOverlapped;

        UmOverlapped=AllocateOverStruct(ModemControl->CompletionPort);

        if (UmOverlapped != NULL) {

            BOOL  bResult;

            UmOverlapped->Context1=ModemControl;

            AddReferenceToObject(
                &ModemControl->Header
                );

            bResult=UnimodemQueueUserAPC(
                &UmOverlapped->Overlapped,
                TimerCancelHandler
                );

            if (!bResult) {

                RemoveReferenceFromObject(
                    &ModemControl->Header
                    );
            }
        }
    }

    if (ModemControl->CurrentCommandTimer != NULL) {

        FreeUnimodemTimer(ModemControl->CurrentCommandTimer);
        ModemControl->CurrentCommandTimer=NULL;
    }

    if (ModemControl->Dle != NULL) {

        CloseObjectHandle(
            ModemControl->Dle,
            NULL
            );

        ModemControl->Dle = NULL;
    }

    if (ModemControl->Remove != NULL) {

        CloseObjectHandle(
            ModemControl->Remove,
            NULL
            );

        ModemControl->Remove=NULL;
    }


    if (ModemControl->Power != NULL) {

        CloseObjectHandle(
            ModemControl->Power,
            NULL
            );

        ModemControl->Power=NULL;
    }


    if (ModemControl->ModemEvent != NULL) {

        CloseObjectHandle(
            ModemControl->ModemEvent,
            NULL
            );

        ModemControl->ModemEvent=NULL;
    }

    if (ModemControl->CommandState != NULL) {

        CloseObjectHandle(
            ModemControl->CommandState,
            NULL
            );

        ModemControl->CommandState=NULL;
    }

    if (ModemControl->ReadState != NULL) {

        CloseObjectHandle(
            ModemControl->ReadState,
            NULL
            );

        ModemControl->ReadState=NULL;
    }

    return;
}

VOID
ModemObjectCleanUp(
    POBJECT_HEADER  Object
    )

{

    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)Object;

    D_INIT(UmDpf(ModemControl->Debug,"ModemObjectCleanup");)

    if (ModemControl->Wave.OverStruct != NULL) {

        FreeOverStruct(ModemControl->Wave.OverStruct);
        ModemControl->Wave.OverStruct=NULL;
    }

    if (ModemControl->AsyncOverStruct != NULL) {

        FreeOverStruct(ModemControl->AsyncOverStruct);
        ModemControl->AsyncOverStruct=NULL;
    }


    if (ModemControl->FileHandle != INVALID_HANDLE_VALUE) {

        PurgeComm(
            ModemControl->FileHandle,
            PURGE_RXABORT | PURGE_TXABORT | PURGE_RXCLEAR | PURGE_TXCLEAR
            );


        if (ModemControl->RegInfo.CompatibilityFlags & COMPAT_FLAG_LOWER_DTR) {
            //
            //  For USR 33.6 modem that stop working after being open and closed
            //
            LogString(ModemControl->Debug, IDS_USR_DTR_HACK);

            EscapeCommFunction(ModemControl->FileHandle, CLRDTR);

            Sleep(100);

        }

        LogPortStats(
            ModemControl->Debug,
            ModemControl->FileHandle
            );

        CloseHandle(ModemControl->FileHandle);
    }

    if (ModemControl->CommonInfo != NULL) {

        RemoveReferenceToCommon(
            GetCommonList(ModemControl->ModemDriver),
            ModemControl->CommonInfo
            );
    }

    FreeRegistryInfo(
        &ModemControl->RegInfo
        );

    CloseObjectHandle(
        ModemControl->Debug,
        NULL
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\power.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    power.h

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/



OBJECT_HANDLE WINAPI
CreatePowerObject(
    POBJECT_HEADER     OwnerObject,
    HANDLE             FileHandle,
    HANDLE             CompletionPort,
    LPUMNOTIFICATIONPROC  AsyncNotificationProc,
    HANDLE             AsyncNotificationContext,
    OBJECT_HANDLE      Debug
    );

LONG WINAPI
SetMinimalPowerState(
    OBJECT_HANDLE  ObjectHandle,
    DWORD          DevicePowerLevel
    );

LONG WINAPI
StopWatchingForPowerUp(
    OBJECT_HANDLE  ObjectHandle
    );

LONG WINAPI
StartWatchingForPowerUp(
    OBJECT_HANDLE  ObjectHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\read.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    read.h

Abstract:

    Nt 5.0 unimodem miniport interface


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/


typedef struct _DATA_CONNECTION_DETAILS {

    DWORD    DTERate;
    DWORD    DCERate;
    DWORD    Options;

} DATA_CONNECTION_DETAILS, *PDATA_CONNECTION_DETAILS;


typedef VOID (COMMANDRESPONSE)(
    HANDLE                   Context,
    DWORD                    Status
    );


BOOL WINAPI
RegisterCommandResponseHandler(
    OBJECT_HANDLE      ReadState,
    LPSTR              Command,
    COMMANDRESPONSE   *Handler,
    HANDLE             Context,
    DWORD              Timeout,
    DWORD              Flags
    );

OBJECT_HANDLE WINAPI
InitializeReadHandler(
    POBJECT_HEADER     OwnerObject,
    HANDLE             FileHandle,
    HANDLE             CompletionPort,
    LPUMNOTIFICATIONPROC  AsyncNotificationProc,
    HANDLE             AsyncNotificationContext,
    PVOID              ResponseList,
    LPSTR              CallerIDPrivate,
    LPSTR              CallerIDOutside,
    LPSTR              VariableTerminator,
    OBJECT_HANDLE      Debug,
    HKEY               ModemRegKey
    );



LONG WINAPI
StartResponseEngine(
    OBJECT_HANDLE      Object,
    HANDLE             Context
    );

LONG WINAPI
StopResponseEngine(
    OBJECT_HANDLE  ObjectHandle,
    HANDLE         Event
    );

VOID WINAPI
GetDataConnectionDetails(
    OBJECT_HANDLE  ObjectHandle,
    PDATA_CONNECTION_DETAILS   Details
    );



BOOL WINAPI
IsResponseEngineRunning(
    OBJECT_HANDLE  ObjectHandle
    );

BOOL WINAPI
SetVoiceReadParams(
    OBJECT_HANDLE  ObjectHandle,
    DWORD          BaudRate,
    DWORD          ReadBufferSize
    );


VOID
SetDiagInfoBuffer(
    OBJECT_HANDLE      ObjectHandle,
    PUCHAR             Buffer,
    DWORD              BufferSize
    );


DWORD
ClearDiagBufferAndGetCount(
    OBJECT_HANDLE      ObjectHandle
    );


VOID
ResetRingInfo(
    OBJECT_HANDLE      ObjectHandle
    );

VOID
GetRingInfo(
    OBJECT_HANDLE      ObjectHandle,
    LPDWORD            RingCount,
    LPDWORD            LastRingTime
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\remove.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    remove.h

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/



OBJECT_HANDLE WINAPI
CreateRemoveObject(
    POBJECT_HEADER     OwnerObject,
    HANDLE             FileHandle,
    HANDLE             CompletionPort,
    LPUMNOTIFICATIONPROC  AsyncNotificationProc,
    HANDLE             AsyncNotificationContext,
    OBJECT_HANDLE      Debug
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_RESP_RINGA                  25
#define IDS_RESP_RINGB                  26
#define IDS_RESP_RINGC                  27
#define IDS_RESP_SIERRA                 28
#define IDS_RESP_BLACKLISTED            29
#define IDS_RESP_DELAYED                30
#define IDS_RESP_DIAG                   31
#define IDS_RESP_ECHO                   49
#define IDD_DIALOG1                     102
#define IDS_DLE_DTMF_0                  238
#define IDS_DLE_DTMF_1                  239
#define IDS_DLE_DTMF_2                  240
#define IDS_STRING241                   241
#define IDS_STRING242                   242
#define IDS_STRING243                   243
#define IDS_STRING244                   244
#define IDS_STRING245                   245
#define IDS_STRING246                   246
#define IDS_STRING247                   247
#define IDS_STRING248                   248
#define IDS_STRING249                   249
#define IDS_STRING250                   250
#define IDS_STRING251                   251
#define IDS_STRING252                   252
#define IDS_STRING253                   253
#define IDS_STRING254                   254
#define IDS_STRING255                   255
#define IDS_STRING256                   256
#define IDS_STRING257                   257
#define IDS_STRING258                   258
#define IDS_STRING259                   259
#define IDS_STRING260                   260
#define IDS_STRING261                   261
#define IDS_STRING262                   262
#define IDS_STRING263                   263
#define IDS_STRING264                   264
#define IDS_STRING265                   265
#define IDS_STRING266                   266
#define IDS_STRING267                   267
#define IDS_STRING268                   268
#define IDS_STRING269                   269
#define IDS_DLE_ETX                     271
#define IDS_STRING272                   272
#define IDS_STRING273                   273
#define IDS_STRING274                   274
#define IDS_STRING275                   275
#define IDS_STRING276                   276
#define IDS_STRING277                   277
#define IDS_STRING278                   278
#define IDS_STRING279                   279
#define IDS_STRING280                   280
#define IDS_STRING281                   281
#define IDS_STRING282                   282
#define IDS_STRING283                   283
#define IDS_STRING284                   284
#define IDS_DLE_LCR                     285
#define IDS_WAIT_FOR_CD                 300
#define IDS_CD_WENT_HIGH                301
#define IDS_HANGUP_CD_LOW               302
#define IDS_WRITEFAILED                 303
#define IDS_DSR_DROP                    304
#define IDS_RESPONSE_TIMEOUT            305
#define IDS_ABORTING_COMMAND            306
#define IDS_USR_DTR_HACK                307
#define IDS_INIT_RETRY                  308
#define IDS_UNRECOGNISED_CONNECT        309
#define IDS_POWER_RESUME                310
#define IDS_NO_DSR_DROP                 311
#define IDS_NO_RESPONSES                312
#define IDS_MISSING_COMMAND             313
#define IDS_OPEN_FAILURE                314
#define IDS_OPEN_HANDSET                315
#define IDS_PASSTHROUGH_ON              316
#define IDS_PASSTHROUGH_OFF             317
#define IDS_PASSTHROUGH_ON_SNIFF        318
#define IDS_PASSTHROUGH_CD_LOW          319
#define IDS_INIT_DSR_LOW                320
#define IDS_INIT_RLSD_HIGH              321
#define IDS_RW_STATS                    322
#define IDS_ANSWER_DELAY                323
#define IDS_ANSWER_PROCEED              324
#define IDS_CD_STILL_LOW                325
#define IDS_CD_STAYED_LOW               326
#define IDS_INIT_CTS_LOW                327
#define IDS_DISCONNECT_DSR_CTS          328
#define IDS_DISCONNECT_RLSD_HIGH        329
#define IDS_SEND_PROTOCOL               330
#define IDS_SEND_USER                   331
#define IDS_USER_REMOVAL                332
#define IDS_WAITEVENT_TIMEOUT           333
#define IDS_FILE_VER_STRING             334
#define IDS_NO_FILE_VER                 335
#define IDS_SEND_COUNTRY_SELECT         336
#define IDS_MSGLOG_DEVICEID             337
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\power.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    power.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"

#include <devioctl.h>
#include <ntddmodm.h>



#define  MODEM_POWER_SIG  (0x4f504d55)  //UMPO

typedef struct _POWER_OBJECT {

    OBJECT_HEADER          Header;

    HANDLE                 FileHandle;
    HANDLE                 CompletionPort;

    LPUMNOTIFICATIONPROC   AsyncNotificationProc;
    HANDLE                 AsyncNotificationContext;

    OBJECT_HANDLE          Debug;

    DWORD                  State;

    HANDLE                 StopEvent;

} POWER_OBJECT, *PPOWER_OBJECT;


#define POWER_STATE_IDLE                0
#define POWER_STATE_SEND_IOCTL          1
#define POWER_STATE_WAITING_FOR_RESUME  2
#define POWER_STATE_STOPPING            3
#define POWER_STATE_STOPPED             4
#define POWER_STATE_FAILURE             5


LONG WINAPI
SendPowerIoctl(
    HANDLE    FileHandle,
    DWORD     IoctlCode,
    DWORD     InputValue
    );



VOID
PowerObjectClose(
    POBJECT_HEADER  Object
    )

{

    PPOWER_OBJECT        PowerObject=(PPOWER_OBJECT)Object;

    D_TRACE(UmDpf(PowerObject->Debug,"PowerObjectClose ref=%d",PowerObject->Header.ReferenceCount);)

    if (PowerObject->State != POWER_STATE_STOPPED) {

        PowerObject->State = POWER_STATE_STOPPING;

        SendPowerIoctl(
            PowerObject->FileHandle,
            IOCTL_MODEM_WATCH_FOR_RESUME,
            0
            );
    }

    return;

}




VOID
PowerObjectCleanUp(
    POBJECT_HEADER  Object
    )

{

    PPOWER_OBJECT        PowerObject=(PPOWER_OBJECT)Object;

    D_TRACE(UmDpf(PowerObject->Debug,"PowerObjectCleanup");)

    return;

}


OBJECT_HANDLE WINAPI
CreatePowerObject(
    POBJECT_HEADER     OwnerObject,
    HANDLE             FileHandle,
    HANDLE             CompletionPort,
    LPUMNOTIFICATIONPROC  AsyncNotificationProc,
    HANDLE             AsyncNotificationContext,
    OBJECT_HANDLE      Debug
    )

{

    PPOWER_OBJECT        PowerObject;
    OBJECT_HANDLE      ObjectHandle;


    ObjectHandle=CreateObject(
        sizeof(*PowerObject),
        OwnerObject,
        MODEM_POWER_SIG,
        PowerObjectCleanUp,
        PowerObjectClose
        );

    if (ObjectHandle == NULL) {

        return NULL;
    }

    //
    //  reference the handle to get a pointer to the object
    //
    PowerObject=(PPOWER_OBJECT)ReferenceObjectByHandle(ObjectHandle);


    //
    //  intialize the object
    //
    PowerObject->FileHandle=FileHandle;
    PowerObject->CompletionPort=CompletionPort;

    PowerObject->State=POWER_STATE_STOPPED;

    PowerObject->AsyncNotificationProc=AsyncNotificationProc;
    PowerObject->AsyncNotificationContext=AsyncNotificationContext;

    PowerObject->Debug=Debug;

    //
    //  release the reference to the object
    //
    RemoveReferenceFromObject(&PowerObject->Header);


    return ObjectHandle;

}




LONG WINAPI
SendPowerIoctl(
    HANDLE    FileHandle,
    DWORD     IoctlCode,
    DWORD     InputValue
    )


/*++

Routine Description:


Arguments:


Return Value:



--*/

{
    DWORD       BytesTransfered;


    return SyncDeviceIoControl(
        FileHandle,
        IoctlCode,
        &InputValue,
        sizeof(InputValue),
        NULL,
        0,
        &BytesTransfered
        );




}




LONG WINAPI
SetMinimalPowerState(
    OBJECT_HANDLE  ObjectHandle,
    DWORD          DevicePowerLevel
    )

{
    PPOWER_OBJECT     PowerObject;
    LONG              lResult;


    PowerObject=(PPOWER_OBJECT)ReferenceObjectByHandleAndLock(ObjectHandle);

    lResult=SendPowerIoctl(
        PowerObject->FileHandle,
        IOCTL_MODEM_SET_MIN_POWER,
        DevicePowerLevel
        );

    RemoveReferenceFromObjectAndUnlock(&PowerObject->Header);

    return lResult;

}





VOID WINAPI
PowerCompletionHandler(
    DWORD              ErrorCode,
    DWORD              BytesRead,
    LPOVERLAPPED       Overlapped
    )


{
    PUM_OVER_STRUCT    UmOverlapped=(PUM_OVER_STRUCT)Overlapped;

    PPOWER_OBJECT      PowerObject;

    BOOL               bResult;
    BOOL               ExitLoop=FALSE;

    PowerObject=(PPOWER_OBJECT)UmOverlapped->Context1;


    LockObject(
        &PowerObject->Header
        );


    AddReferenceToObject(
        &PowerObject->Header
        );


    while (!ExitLoop) {

        switch (PowerObject->State) {

            case POWER_STATE_SEND_IOCTL: {

                DWORD    WatchCode=1;

                ReinitOverStruct(UmOverlapped);

                UmOverlapped->Context1=PowerObject;

                PowerObject->State=POWER_STATE_WAITING_FOR_RESUME;

                bResult=UnimodemDeviceIoControlEx(
                    PowerObject->FileHandle,
                    IOCTL_MODEM_WATCH_FOR_RESUME,
                    &WatchCode,
                    sizeof(WatchCode),
                    NULL,
                    0,
                    &UmOverlapped->Overlapped,
                    PowerCompletionHandler
                    );



                if (!bResult && GetLastError() != ERROR_IO_PENDING) {

                    D_TRACE(UmDpf(PowerObject->Debug,"DeviceIoControl failed- %08lx",GetLastError());)

                    PowerObject->State=POWER_STATE_FAILURE;

                    break;

                }

                ExitLoop=TRUE;


                break;

            }

            case POWER_STATE_WAITING_FOR_RESUME: {

                DWORD    BytesRead2;

                bResult=GetOverlappedResult(
                    PowerObject->FileHandle,
                    &UmOverlapped->Overlapped,
                    &BytesRead2,
                    FALSE
                    );


                if (!bResult) {

                    D_TRACE(UmDpf(PowerObject->Debug,"DeviceIoControl failed- %08lx",GetLastError());)

                    PowerObject->State=POWER_STATE_FAILURE;

                    break;
                }

                UnlockObject(
                    &PowerObject->Header
                    );

                D_TRACE(UmDpf(PowerObject->Debug,"PowerCompleteHandler: Resume");)

                LogString(PowerObject->Debug, IDS_POWER_RESUME);

                (*PowerObject->AsyncNotificationProc)(
                    PowerObject->AsyncNotificationContext,
                    MODEM_POWER_RESUME,
                    0,
                    0
                    );

                LockObject(
                    &PowerObject->Header
                    );

                PowerObject->State=POWER_STATE_SEND_IOCTL;

                break;
            }

            case POWER_STATE_FAILURE: {

                UnlockObject(
                    &PowerObject->Header
                    );

                (*PowerObject->AsyncNotificationProc)(
                    PowerObject->AsyncNotificationContext,
                    MODEM_HARDWARE_FAILURE,
                    0,
                    0
                    );

                LockObject(
                    &PowerObject->Header
                    );

                PowerObject->State=POWER_STATE_STOPPED;

                break;

            }

            case POWER_STATE_STOPPING: {

                PowerObject->State=POWER_STATE_STOPPED;

                break;

            }


            case POWER_STATE_STOPPED: {

                RemoveReferenceFromObject(
                    &PowerObject->Header
                    );

                ExitLoop=TRUE;

                FreeOverStruct(UmOverlapped);


                break;

            }


            default: {

                ASSERT(0);

                ExitLoop=TRUE;

                break;
            }

        }
    }

    RemoveReferenceFromObjectAndUnlock(&PowerObject->Header);

    return;
}



LONG WINAPI
StopWatchingForPowerUp(
    OBJECT_HANDLE  ObjectHandle
    )

{
    PPOWER_OBJECT     PowerObject;
    LONG              lResult=ERROR_SUCCESS;


    PowerObject=(PPOWER_OBJECT)ReferenceObjectByHandleAndLock(ObjectHandle);

    if (PowerObject->State != POWER_STATE_STOPPED) {

        PowerObject->State = POWER_STATE_STOPPING;

        lResult=SendPowerIoctl(
            PowerObject->FileHandle,
            IOCTL_MODEM_WATCH_FOR_RESUME,
            0
            );
    }

    RemoveReferenceFromObjectAndUnlock(&PowerObject->Header);

    return lResult;

}

LONG WINAPI
StartWatchingForPowerUp(
    OBJECT_HANDLE  ObjectHandle
    )

{

    PPOWER_OBJECT     PowerObject;
    LONG              lResult=ERROR_SUCCESS;
    PUM_OVER_STRUCT   UmOverlapped;
    BOOL              bResult;

    PowerObject=(PPOWER_OBJECT)ReferenceObjectByHandleAndLock(ObjectHandle);

    if (PowerObject->State == POWER_STATE_STOPPED) {

        UmOverlapped=AllocateOverStruct(PowerObject->CompletionPort);

        if (UmOverlapped == NULL) {

            RemoveReferenceFromObjectAndUnlock(&PowerObject->Header);

            return ERROR_NOT_ENOUGH_MEMORY;

        }

        UmOverlapped->Context1=PowerObject;

        AddReferenceToObject(
            &PowerObject->Header
            );


        D_TRACE(UmDpf(PowerObject->Debug,"StartWatchingForPowerUp");)

        PowerObject->State=POWER_STATE_SEND_IOCTL;

        bResult=UnimodemQueueUserAPC(
            (LPOVERLAPPED)UmOverlapped,
            PowerCompletionHandler
            );

    }

    RemoveReferenceFromObjectAndUnlock(&PowerObject->Header);

    return lResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\read.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    read.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"


#define  READ_STATE_FAILURE                   0

#define  READ_STATE_INITIALIZING              1
#define  READ_STATE_MATCHING                  2


#define  READ_STATE_STOPPED                   3
#define  READ_STATE_STOPPING                  4

#define  READ_STATE_CLEANUP                   5
#define  READ_STATE_CLEANUP2                  6
#define  READ_STATE_VARIABLE_MATCH            7
#define  READ_STATE_VARIABLE_MATCH_REST       8

#define  READ_STATE_READ_SOME_DATA            9
#define  READ_STATE_GOT_SOME_DATA            10

#define  READ_STATE_POSSIBLE_RESPONSE        11


CHAR
ctox(
        BYTE c
        );

VOID WINAPI
HandleGoodResponse(
    PREAD_STATE    ReadState,
    MSS           *Mss
    );




VOID WINAPI
ReadCompletionHandler(
    DWORD              ErrorCode,
    DWORD              BytesRead2,
    LPOVERLAPPED       Overlapped
    );






VOID WINAPI
ReportMatchString(
    PREAD_STATE    ReadState,
    BYTE           ResponseState,
    BYTE           *Response,
    DWORD          ResponseLength
    );


VOID
ResetRingInfo(
    OBJECT_HANDLE      ObjectHandle
    )

{
    PREAD_STATE        ReadState;

    ReadState=(PREAD_STATE)ReferenceObjectByHandleAndLock(ObjectHandle);

    ReadState->RingCount=0;

    RemoveReferenceFromObjectAndUnlock(&ReadState->Header);

    return;

}


VOID
GetRingInfo(
    OBJECT_HANDLE      ObjectHandle,
    LPDWORD            RingCount,
    LPDWORD            LastRingTime
    )

{

    PREAD_STATE        ReadState;

    ReadState=(PREAD_STATE)ReferenceObjectByHandleAndLock(ObjectHandle);

    *RingCount=ReadState->RingCount;
    *LastRingTime=ReadState->LastRingTime;

    RemoveReferenceFromObjectAndUnlock(&ReadState->Header);

    return;

}

VOID
SetDiagInfoBuffer(
    OBJECT_HANDLE      ObjectHandle,
    PUCHAR             Buffer,
    DWORD              BufferSize
    )

{
    PREAD_STATE        ReadState;

    ReadState=(PREAD_STATE)ReferenceObjectByHandleAndLock(ObjectHandle);

    ReadState->DiagBuffer=Buffer;
    ReadState->DiagBufferLength=BufferSize;
    ReadState->AmountOfDiagBufferUsed=0;

    RemoveReferenceFromObjectAndUnlock(&ReadState->Header);

    return;
}

DWORD
ClearDiagBufferAndGetCount(
    OBJECT_HANDLE      ObjectHandle
    )

{
    PREAD_STATE        ReadState;
    DWORD              ReturnValue;

    ReadState=(PREAD_STATE)ReferenceObjectByHandleAndLock(ObjectHandle);

    ReadState->DiagBuffer=NULL;

    ReturnValue=ReadState->AmountOfDiagBufferUsed;

    ReadState->AmountOfDiagBufferUsed=0;

    RemoveReferenceFromObjectAndUnlock(&ReadState->Header);

    return ReturnValue;


}


VOID
PostResultHandler(
    DWORD      ErrorCode,
    DWORD      Bytes,
    LPOVERLAPPED  dwParam
    )

{
    PUM_OVER_STRUCT    UmOverlapped=(PUM_OVER_STRUCT)dwParam;
    COMMANDRESPONSE   *Handler;


    Handler=UmOverlapped->Context1;

    (*Handler)(
        UmOverlapped->Context2,
        (DWORD)UmOverlapped->Overlapped.Internal
        );

    FreeOverStruct(UmOverlapped);

    return;

}


VOID WINAPI
DeliverCommandResult(
    HANDLE             CompletionPort,
    COMMANDRESPONSE   *Handler,
    HANDLE             Context,
    DWORD              Status
    )

{
    BOOL               bResult;

    PUM_OVER_STRUCT UmOverlapped;

    UmOverlapped=AllocateOverStruct(CompletionPort);

    if (UmOverlapped != NULL) {

        UmOverlapped->Context1=Handler;

        UmOverlapped->Context2=Context;

        UmOverlapped->Overlapped.Internal=Status;

        bResult=UnimodemQueueUserAPC(
            (LPOVERLAPPED)UmOverlapped,
            PostResultHandler
            );

        if (bResult) {

            return;

        }

        FreeOverStruct(UmOverlapped);
    }

//    D_TRACE(UmDpf(ReadState->Debug,"DeliverCommandResponse: calling handler directly");)

    (*Handler)(
        Context,
        Status
        );

    return;

}




VOID
AsyncNotifHandler(
    DWORD      ErrorCode,
    DWORD      Bytes,
    LPOVERLAPPED  dwParam
    )

{
    PUM_OVER_STRUCT UmOverlapped=(PUM_OVER_STRUCT)dwParam;
    PREAD_STATE     ReadState;

    LPUMNOTIFICATIONPROC   AsyncNotificationProc;
    HANDLE                 AsyncNotificationContext;

    ReadState=UmOverlapped->Context1;

    AsyncNotificationProc   = ReadState->AsyncNotificationProc;
    AsyncNotificationContext= ReadState->AsyncNotificationContext;

    RemoveReferenceFromObject (&ReadState->Header);

    AsyncNotificationProc (
        AsyncNotificationContext,
        (DWORD)((DWORD_PTR)UmOverlapped->Context2),
        UmOverlapped->Overlapped.Internal,
        UmOverlapped->Overlapped.InternalHigh);

    FreeOverStruct(UmOverlapped);

    return;

}



VOID WINAPI
ResponseTimeoutHandler(
    POBJECT_HEADER      Object,
    HANDLE              Context2
    )

{

    PREAD_STATE        ReadState=(PREAD_STATE)Object;

    LockObject(
        &ReadState->Header
        );

    D_TRACE(UmDpf(ReadState->Debug,"ResponseTimeout");)

    if (ReadState->ResponseHandler != NULL && ReadState->ResponseId == (DWORD)((ULONG_PTR)Context2)) {

        COMMANDRESPONSE   *Handler;
        HANDLE             Context;


        //
        //  capture the handler
        //
        Handler=ReadState->ResponseHandler;
        Context=ReadState->ResponseHandlerContext;

        //
        //  invalidate the handler
        //
        ReadState->ResponseHandler=NULL;

        LogString(ReadState->Debug,IDS_RESPONSE_TIMEOUT);

        //
        //  drop the lock and call back
        //
        UnlockObject(
            &ReadState->Header
            );

        DeliverCommandResult(
            ReadState->CompletionPort,
            Handler,
            Context,
            ERROR_UNIMODEM_RESPONSE_TIMEOUT
            );

        return;


    }

    UnlockObject(
        &ReadState->Header
        );

}


BOOL WINAPI
RegisterCommandResponseHandler(
    OBJECT_HANDLE      ObjectHandle,
    LPSTR              Command,
    COMMANDRESPONSE   *Handler,
    HANDLE             Context,
    DWORD              Timeout,
    DWORD              Flags
    )

{
    PREAD_STATE        ReadState;

    BOOL               bReturn=TRUE;

    DWORD              WaitResult;

    ReadState=(PREAD_STATE)ReferenceObjectByHandleAndLock(ObjectHandle);


    if (Handler != NULL) {
        //
        // registering a new handler
        //

        UnlockObject(
            &ReadState->Header
            );


        do {

            WaitResult=WaitForSingleObjectEx(
                ReadState->Busy,
                INFINITE,
                TRUE
                );

        } while (WaitResult != WAIT_OBJECT_0);

        LockObject(
            &ReadState->Header
            );



        ReadState->DTERate=0;
        ReadState->DCERate=0;
        ReadState->ModemOptions=0;

        ReadState->ResponseHandler=Handler;
        ReadState->ResponseHandlerContext=Context;

        ReadState->ResponseFlags=Flags;

        ReadState->ResponseId++;

        lstrcpyA(
            ReadState->CurrentCommand,
            Command
            );

        ReadState->CurrentCommandLength=lstrlenA(ReadState->CurrentCommand);

        SetUnimodemTimer(
            ReadState->Timer,
            Timeout,
            ResponseTimeoutHandler,
            ReadState,
            (HANDLE)ULongToPtr(ReadState->ResponseId) // sundown: zero-extension
            );

    } else {
        //
        //  want to cancel current handler
        //
        if (ReadState->ResponseHandler != NULL) {
            //
            //  hasn't run yet
            //
            BOOL               Canceled;

            Canceled=CancelUnimodemTimer(
                ReadState->Timer
                );

            ReadState->ResponseHandler=NULL;

            if (Canceled) {
                //
                //  invalidate the handler
                //


            }

        } else {
            //
            //  handler already called
            //
            bReturn=FALSE;
        }

    }

    RemoveReferenceFromObjectAndUnlock(&ReadState->Header);

    return bReturn;

}




VOID
ReadObjectClose(
    POBJECT_HEADER  Object
    )

{

    PREAD_STATE        ReadState=(PREAD_STATE)Object;

    D_TRACE(UmDpf(ReadState->Debug,"ReadObjectClose ref=%d",ReadState->Header.ReferenceCount);)

    if (ReadState->State != READ_STATE_STOPPED) {

        ReadState->State = READ_STATE_STOPPING;


    }


    PurgeComm(
        ReadState->FileHandle,
        PURGE_RXABORT
        );



    return;

}




VOID
ReadObjectCleanUp(
    POBJECT_HEADER  Object
    )

{

    PREAD_STATE        ReadState=(PREAD_STATE)Object;

    D_TRACE(UmDpf(ReadState->Debug,"ReadObjectCleanup");)

    if (ReadState->Busy != NULL) {

        CloseHandle(ReadState->Busy);
    }


    if (ReadState->Timer != NULL) {

        FreeUnimodemTimer(
            ReadState->Timer
            );
    }


    if (ReadState->UmOverlapped != NULL) {

        FreeOverStruct(ReadState->UmOverlapped);
        ReadState->UmOverlapped=NULL;
    }



    return;

}



BOOL WINAPI
IsResponseEngineRunning(
    OBJECT_HANDLE  ObjectHandle
    )

{

    PREAD_STATE        ReadState;
    BOOL               bResult;


    ReadState=(PREAD_STATE)ReferenceObjectByHandleAndLock(ObjectHandle);

    bResult=(ReadState->State != READ_STATE_STOPPED);

    RemoveReferenceFromObjectAndUnlock(&ReadState->Header);

    return bResult;
}


BOOL WINAPI
SetVoiceReadParams(
    OBJECT_HANDLE  ObjectHandle,
    DWORD          BaudRate,
    DWORD          ReadBufferSize
    )

{

    PREAD_STATE        ReadState;
    BOOL               bResult=TRUE;


    ReadState=(PREAD_STATE)ReferenceObjectByHandleAndLock(ObjectHandle);

    SetVoiceBaudRate(
        ReadState->FileHandle,
        ReadState->Debug,
        BaudRate
        );


    PurgeComm(
        ReadState->FileHandle,
        PURGE_RXABORT | PURGE_TXABORT
        );

    SetupComm(
        ReadState->FileHandle,
        ReadBufferSize,
        4096
        );

    RemoveReferenceFromObjectAndUnlock(&ReadState->Header);

    return bResult;
}




VOID WINAPI
GetDataConnectionDetails(
    OBJECT_HANDLE  ObjectHandle,
    PDATA_CONNECTION_DETAILS   Details
    )

{

    PREAD_STATE        ReadState;

    ReadState=(PREAD_STATE)ReferenceObjectByHandleAndLock(ObjectHandle);

    Details->DTERate=ReadState->DTERate;
    Details->DCERate=ReadState->DCERate;
    Details->Options=ReadState->ModemOptions;

    RemoveReferenceFromObjectAndUnlock(&ReadState->Header);

}

OBJECT_HANDLE WINAPI
InitializeReadHandler(
    POBJECT_HEADER     OwnerObject,
    HANDLE             FileHandle,
    HANDLE             CompletionPort,
    LPUMNOTIFICATIONPROC  AsyncNotificationProc,
    HANDLE             AsyncNotificationContext,
    PVOID              ResponseList,
    LPSTR              CallerIDPrivate,
    LPSTR              CallerIDOutside,
    LPSTR              VariableTerminator,
    OBJECT_HANDLE      Debug,
    HKEY               ModemRegKey
    )

{

    PREAD_STATE        ReadState;
    OBJECT_HANDLE      ObjectHandle;


    ObjectHandle=CreateObject(
        sizeof(*ReadState),
        OwnerObject,
        READ_OBJECT_SIG,
        ReadObjectCleanUp,
        ReadObjectClose
        );

    if (ObjectHandle == NULL) {

        return NULL;
    }


    //
    //  reference the handle to get a pointer to the object
    //
    ReadState=(PREAD_STATE)ReferenceObjectByHandle(ObjectHandle);

    ReadState->ModemRegKey = ModemRegKey;

    ReadState->Timer=CreateUnimodemTimer(CompletionPort);

    if (ReadState->Timer == NULL) {

        CloseObjectHandle(ObjectHandle,NULL);
        ObjectHandle=NULL;

        goto End;

    }

    ReadState->UmOverlapped=AllocateOverStruct(CompletionPort);

    if (ReadState->UmOverlapped == NULL) {

        CloseObjectHandle(ObjectHandle,NULL);
        ObjectHandle=NULL;

        goto End;

    }

    ReadState->Busy=CreateEvent(
        NULL,
        TRUE,
        TRUE,
        NULL
        );

    if (ReadState->Busy == NULL) {

        CloseObjectHandle(ObjectHandle,NULL);
        ObjectHandle=NULL;

        goto End;
    }


    ReadState->State=READ_STATE_STOPPED;
    ReadState->FileHandle=FileHandle;
    ReadState->CompletionPort=CompletionPort;

    ReadState->ResponseList=ResponseList;

    ReadState->AsyncNotificationProc=AsyncNotificationProc;
    ReadState->AsyncNotificationContext=AsyncNotificationContext;

    ReadState->Debug=Debug;

    ReadState->ResponseId=0;

    ReadState->CallerIDPrivate=CallerIDPrivate;
    ReadState->CallerIDOutside=CallerIDOutside;

    ReadState->VariableTerminator=VariableTerminator;

    ReadState->VariableTerminatorLength=0;

    if (ReadState->VariableTerminator != NULL) {

        ReadState->VariableTerminatorLength=lstrlenA(ReadState->VariableTerminator);
    }


End:
    RemoveReferenceFromObject(&ReadState->Header);

    return ObjectHandle;



}


LONG WINAPI
StartResponseEngine(
    OBJECT_HANDLE  ObjectHandle,
    HANDLE         Context
)
{

    BOOL            bResult;
    COMMTIMEOUTS    CommTimeouts;

    PUM_OVER_STRUCT UmOverlapped;

    PREAD_STATE        ReadState;

    PMODEM_CONTROL  ModemControl = (PMODEM_CONTROL)Context;

    ReadState=(PREAD_STATE)ReferenceObjectByHandleAndLock(ObjectHandle);

    if (ReadState->State != READ_STATE_STOPPED) {

        RemoveReferenceFromObjectAndUnlock(&ReadState->Header);

        return ERROR_SUCCESS;
    }

    PurgeComm(
        ReadState->FileHandle,
        PURGE_RXABORT
        );


    CommTimeouts.ReadIntervalTimeout=20;
//    CommTimeouts.ReadIntervalTimeout=0;
    CommTimeouts.ReadTotalTimeoutMultiplier=0;
    CommTimeouts.ReadTotalTimeoutConstant=0;
    CommTimeouts.WriteTotalTimeoutMultiplier=10;
    CommTimeouts.WriteTotalTimeoutConstant=2000;

    bResult=SetCommTimeouts(
        ReadState->FileHandle,
        &CommTimeouts
        );

    if (!bResult) {

        D_TRACE(UmDpf(ReadState->Debug,"SetCommTimeouts failed- %08lx\n",GetLastError());)

        RemoveReferenceFromObjectAndUnlock(&ReadState->Header);

        return GetLastError();

    }



    UmOverlapped=ReadState->UmOverlapped;


    UmOverlapped->Context1=ReadState;

    ReadState->State=READ_STATE_INITIALIZING;

    ReadState->CurrentMatchingLength=0;

    ReadState->MatchingContext=NULL;

    ReadState->CurrentCommand[0]='\0';

    ReadState->ModemControl=(OBJECT_HANDLE)Context;

    AddReferenceToObject(
        &ReadState->Header
        );

    RemoveReferenceFromObjectAndUnlock(&ReadState->Header);

    D_TRACE(UmDpf(ReadState->Debug,"StartResponseEngine");)

    SetEvent(ReadState->Busy);

    bResult=UnimodemQueueUserAPC(
        (LPOVERLAPPED)UmOverlapped,
        ReadCompletionHandler
        );

    return ERROR_SUCCESS;

}

LONG WINAPI
StopResponseEngine(
    OBJECT_HANDLE  ObjectHandle,
    HANDLE         Event
    )

{

    PREAD_STATE        ReadState;

    ReadState=(PREAD_STATE)ReferenceObjectByHandleAndLock(ObjectHandle);

    D_TRACE(UmDpf(ReadState->Debug,"StopResponseEngine");)

    if (ReadState->State != READ_STATE_STOPPED) {
        //
        //  not stopped currently, change state so it will stop the next time the code runs
        //
        ReadState->State = READ_STATE_STOPPING;

        //
        //  this will cause the outstanding read to complete
        //
        PurgeComm(
            ReadState->FileHandle,
            PURGE_RXABORT
            );


        if (Event != NULL) {
            //
            //  caller wants to wait for stop to complete
            //
            ReadState->StopEvent=Event;

            UnlockObject(
                &ReadState->Header
                );

            //
            //  event will be set when state machine reaches stopped state
            //
            WaitForSingleObjectEx(
                Event,
                INFINITE,
                TRUE
                );

            LockObject(
                &ReadState->Header
                );

            ReadState->StopEvent=NULL;
        }


    }


    RemoveReferenceFromObjectAndUnlock(&ReadState->Header);

    return ERROR_SUCCESS;

}

VOID WINAPI
ReadCompletionHandler(
    DWORD              ErrorCode,
    DWORD              BytesRead,
    LPOVERLAPPED       Overlapped
    )


{
    PUM_OVER_STRUCT    UmOverlapped=(PUM_OVER_STRUCT)Overlapped;

    PREAD_STATE        ReadState;

    BOOL               bResult;
    BOOL               ExitLoop=FALSE;
    MSS                Mss;
    COMSTAT            ComStat;
    DWORD              BytesToRead;
    DWORD              CommErrors;


    ReadState=(PREAD_STATE)UmOverlapped->Context1;


    LockObject(
        &ReadState->Header
        );


    AddReferenceToObject(
        &ReadState->Header
        );

    while (!ExitLoop) {

//        D_TRACE(UmDpf(ReadState->Debug,"Read Complete loop, State=%d, %d",ReadState->State,GetTickCount());)

        switch (ReadState->State) {

            case READ_STATE_INITIALIZING:

                ReadState->CurrentMatchingLength=0;

                ReadState->MatchingContext=NULL;

                ReadState->BytesInReceiveBuffer=0;

                ReadState->PossibleResponseLength=0;

                ReadState->State=READ_STATE_READ_SOME_DATA;


                ReadState->StateAfterGoodRead=READ_STATE_MATCHING;
                //
                //  go start reading
                //
                break;

            case READ_STATE_MATCHING: {

                DWORD      MatchResult;
                DWORD      dwCountrycode = 0;
                DWORD      dwCurrentCountry = 0;
                int        i = 0;
                int        j = 0;
                BOOL       bFoundgci = FALSE;
                LPSTR      lpTempBuffer;
                DWORD      dwValue = 0;
                DWORD      dwType = 0;
                DWORD      dwSize = 0;
                LONG       lResult = 0;


                if (ReadState->CurrentMatchingLength < ReadState->BytesInReceiveBuffer) {

                    ReadState->CurrentMatchingLength++;

                    MatchResult=MatchResponse(
                        ReadState->ResponseList,
                        ReadState->ReceiveBuffer,
                        ReadState->CurrentMatchingLength,
                        &Mss,
                        ReadState->CurrentCommand,
                        ReadState->CurrentCommandLength,
                        &ReadState->MatchingContext
                        );


                    lpTempBuffer = ReadState->ReceiveBuffer;

                    D_TRACE(UmDpf(ReadState->Debug,"Buffer read: %s\n",lpTempBuffer);)

                    while((lpTempBuffer[0] != '\0')
                            && ((ReadState->BytesInReceiveBuffer - i) >= 6)
                            && (!bFoundgci))
                    {
                        if ((lpTempBuffer[0] == 'G') 
                                && (lpTempBuffer[1] == 'C') 
                                && (lpTempBuffer[2] == 'I') 
                                && (lpTempBuffer[3] == ':'))
                        {
                            bFoundgci = TRUE;

                            MatchResult = GOOD_RESPONSE;

                            PrintString(
                                    ReadState->Debug,
                                    ReadState->ReceiveBuffer,
                                    ReadState->BytesInReceiveBuffer,
                                    PS_RECV);
                        } else
                        {
                            i++;
                            lpTempBuffer++;
                        }
                    }

                    switch (MatchResult) {

                        case GOOD_RESPONSE:

                            if (!bFoundgci)
                            {

                                D_TRACE(UmDpf(ReadState->Debug,"Good response");)

                                ReportMatchString(
                                    ReadState,
                                    (UCHAR)(Mss.bResponseState & ((UCHAR)(~RESPONSE_VARIABLE_FLAG))),
                                    ReadState->ReceiveBuffer,
                                    (DWORD)ReadState->CurrentMatchingLength
                                    );

                                PrintString(
                                    ReadState->Debug,
                                    ReadState->ReceiveBuffer,
                                    ReadState->CurrentMatchingLength,
                                    PS_RECV
                                    );

                                PrintGoodResponse(
                                    ReadState->Debug,
                                    Mss.bResponseState & ~RESPONSE_VARIABLE_FLAG
                                    );

                                if (Mss.bResponseState & RESPONSE_VARIABLE_FLAG) {
                                    //
                                    //  Matched the first part of a caller ID string
                                    //
                                    D_TRACE(UmDpf(ReadState->Debug,"Got variable response");)

                                    CopyMemory(
                                        &ReadState->Mss,
                                        &Mss,
                                        sizeof(MSS)
                                        );

    
                                    ReadState->State=READ_STATE_VARIABLE_MATCH;

                                    break;
                                }

                                HandleGoodResponse(
                                    ReadState,
                                    &Mss
                                    );

                                MoveMemory(
                                    ReadState->ReceiveBuffer,
                                    ReadState->ReceiveBuffer+ReadState->CurrentMatchingLength,
                                    ReadState->BytesInReceiveBuffer-ReadState->CurrentMatchingLength
                                    );

                                ReadState->BytesInReceiveBuffer-=ReadState->CurrentMatchingLength;

                                ReadState->CurrentMatchingLength=0;
                                ReadState->MatchingContext=NULL;
                            } else
                            {
                                for(j=1;j<=4;j++)
                                {
                                    lpTempBuffer++;
                                }

                                if (lpTempBuffer[0] == ' ')
                                {
                                    lpTempBuffer++;
                                }

                                D_TRACE(UmDpf(ReadState->Debug,"dwCountryCode to parse: (%c) (%c)\n",lpTempBuffer[0],lpTempBuffer[1]);)
                                dwCountrycode = ctox(lpTempBuffer[0]);
                                dwCountrycode *= 16;
                                dwCountrycode += ctox(lpTempBuffer[1]);
                    
                                D_TRACE(UmDpf(ReadState->Debug,"dwCountryCode: %0.2x\n",dwCountrycode);)

                                dwSize = sizeof(dwValue);

                                lResult = RegQueryValueEx(
                                        ReadState->ModemRegKey,
                                        TEXT("CheckedForCountrySelect"),
                                        NULL,
                                        &dwType,
                                        (BYTE*)&dwValue,
                                        &dwSize);

                                if ((lResult == ERROR_SUCCESS) && (dwType == REG_DWORD) && (dwValue == 1))
                                {
                                    dwSize = sizeof(dwCurrentCountry);

                                    lResult = RegQueryValueEx(
                                            ReadState->ModemRegKey,
                                            TEXT("MSCurrentCountry"),
                                            NULL,
                                            &dwType,
                                            (BYTE*)&dwCurrentCountry,
                                            &dwSize);
                            

                                    if ((lResult == ERROR_SUCCESS) && (dwType == REG_DWORD) && (dwCurrentCountry != dwCountrycode))
                                    {
                                        RegSetValueEx(
                                                ReadState->ModemRegKey,
                                                TEXT("MSCurrentCountry"),
                                                0,
                                                REG_DWORD,
                                                (BYTE*)&dwCountrycode,
                                                sizeof(dwCountrycode)
                                                );
                                    }
                                }
                                        

                                Mss.bResponseState = RESPONSE_OK;

                                CopyMemory(
                                    &ReadState->Mss,
                                    &Mss,
                                    sizeof(MSS)
                                    );
    
                                HandleGoodResponse(
                                    ReadState,
                                    &Mss
                                    );
                                        
                                MoveMemory(
                                    ReadState->ReceiveBuffer,
                                    ReadState->ReceiveBuffer+ReadState->CurrentMatchingLength,
                                    ReadState->BytesInReceiveBuffer-ReadState->CurrentMatchingLength
                                    );

                                ReadState->BytesInReceiveBuffer=0;

                                ReadState->CurrentMatchingLength=0;
                                ReadState->MatchingContext=NULL;

                            }

                            break;


                        case ECHO_RESPONSE:
                            {
                                PMODEM_CONTROL ModemControl = (PMODEM_CONTROL)ReadState->ModemControl;

                                D_TRACE(UmDpf(ReadState->Debug,"Echo response");)

                                if ((ModemControl->DialAnswer.State == DIALANSWER_STATE_SEND_COMMANDS)
                                    || (ModemControl->DialAnswer.State == DIALANSWER_STATE_SENDING_COMMANDS)
                                    || (ModemControl->DialAnswer.State == DIALANSWER_STATE_SEND_ORIGINATE_COMMANDS)
                                    || (ModemControl->DialAnswer.State == DIALANSWER_STATE_SENDING_ORIGINATE_COMMANDS))
                                {
                                    dwType = 0;
                                    dwValue = 0;
                                    dwSize = sizeof(DWORD);

                                    lResult = RegQueryValueEx(ModemControl->ModemRegKey,
                                                              TEXT("Unmasknumber"),
                                                              NULL,
                                                              &dwType,
                                                              (BYTE*)&dwValue,
                                                              &dwSize);

                                    if ((lResult == ERROR_SUCCESS) && (dwType == REG_DWORD) && (dwValue == 1))
                                    {
                                        PrintString(
                                            ReadState->Debug,
                                            ReadState->ReceiveBuffer,
                                            ReadState->CurrentMatchingLength,
                                            PS_RECV
                                        );
                                    } else
                                    {
                                        if (ModemControl->NoLogNumber)
                                        {
                                            PrintString(
                                                ReadState->Debug,
                                                ReadState->ReceiveBuffer,
                                                ReadState->CurrentMatchingLength,
                                                PS_RECV_SECURE
                                            );
                                        } else
                                        {
                                            PrintString(
                                                ReadState->Debug,
                                                ReadState->ReceiveBuffer,
                                                ReadState->CurrentMatchingLength,
                                                PS_RECV
                                            );
                                        }

                                        ModemControl->NoLogNumber = FALSE;
                                    }
                                }

                                LogString(ReadState->Debug, IDS_RESP_ECHO);

                                MoveMemory(
                                    ReadState->ReceiveBuffer,
                                    ReadState->ReceiveBuffer+ReadState->CurrentMatchingLength,
                                    ReadState->BytesInReceiveBuffer-ReadState->CurrentMatchingLength
                                    );

                                ReadState->BytesInReceiveBuffer-=ReadState->CurrentMatchingLength;

                                ReadState->CurrentMatchingLength=0;
                                ReadState->MatchingContext=NULL;

                            }

                            break;


                        case POSSIBLE_RESPONSE:

                            D_TRACE(UmDpf(ReadState->Debug,"Possible response");)

                            CopyMemory(
                                &ReadState->Mss,
                                &Mss,
                                sizeof(MSS)
                                );

                            ReadState->PossibleResponseLength=ReadState->CurrentMatchingLength;

                            if (ReadState->PossibleResponseLength == ReadState->BytesInReceiveBuffer) {
                                //
                                //  we have used up all the bytes in the buffer, need some more
                                //
                                COMMTIMEOUTS    CommTimeouts;

                                ComStat.cbInQue=0;

                                bResult=ClearCommError(
                                    ReadState->FileHandle,
                                    &CommErrors,
                                    &ComStat
                                    );

                                if (ComStat.cbInQue == 0) {

                                    ReadState->State=READ_STATE_READ_SOME_DATA;

                                    ReadState->StateAfterGoodRead=READ_STATE_POSSIBLE_RESPONSE;

                                    //
                                    //  limit the amount of time we will wait for the next character
                                    //
                                    CommTimeouts.ReadIntervalTimeout=MAXULONG;
                                    CommTimeouts.ReadTotalTimeoutMultiplier=MAXULONG;
                                    CommTimeouts.ReadTotalTimeoutConstant=100;
                                    CommTimeouts.WriteTotalTimeoutMultiplier=10;
                                    CommTimeouts.WriteTotalTimeoutConstant=2000;

                                    bResult=SetCommTimeouts(
                                        ReadState->FileHandle,
                                        &CommTimeouts
                                        );
                                }

                            }

                            break;


                        case PARTIAL_RESPONSE:
//                            D_TRACE(UmDpf(ReadState->Debug,"Possible response");)

//                            ReadState->State=READ_STATE_DO_READ;

                            break;

                        case UNRECOGNIZED_RESPONSE:

                            D_TRACE(UmDpf(ReadState->Debug,"Unrecognized response");)

                            if (ReadState->PossibleResponseLength != 0) {
                                //
                                //  got a possible response use it
                                //
                                D_TRACE(UmDpf(ReadState->Debug,"using possible response");)

                                ReportMatchString(
                                    ReadState,
                                    (UCHAR)(ReadState->Mss.bResponseState & (BYTE)(~RESPONSE_VARIABLE_FLAG)),
                                    ReadState->ReceiveBuffer,
                                    (DWORD)ReadState->PossibleResponseLength
                                    );


                                PrintString(
                                    ReadState->Debug,
                                    ReadState->ReceiveBuffer,
                                    ReadState->PossibleResponseLength,
                                    PS_RECV
                                    );

                                PrintGoodResponse(
                                    ReadState->Debug,
                                    ReadState->Mss.bResponseState & ~RESPONSE_VARIABLE_FLAG
                                    );

                                HandleGoodResponse(
                                    ReadState,
                                    &ReadState->Mss
                                    );

                                if (((int)ReadState->BytesInReceiveBuffer -
                                        (int)ReadState->PossibleResponseLength) > 0)
                                {
                                    MoveMemory(
                                    ReadState->ReceiveBuffer,
                                    ReadState->ReceiveBuffer+ReadState->PossibleResponseLength,
                                    ReadState->BytesInReceiveBuffer-ReadState->PossibleResponseLength
                                    );
                                
                                    ReadState->BytesInReceiveBuffer-=ReadState->PossibleResponseLength;
                                } else
                                {
                                    ReadState->BytesInReceiveBuffer = 0;
                                }


                                ReadState->CurrentMatchingLength=0;
                                ReadState->MatchingContext=NULL;

                                ReadState->PossibleResponseLength=0;

                                break;
                            }



                            if (ReadState->ResponseFlags & RESPONSE_FLAG_STOP_READ_ON_CONNECT) {
                                //
                                //  we were expecting a connect response because we were trying to connect,
                                //  but we got something we did not recognize, see if CD is high.
                                //  If it is then assume the connection was established
                                //
                                DWORD    ModemStatus=0;

                                GetCommModemStatus(
                                    ReadState->FileHandle,
                                    &ModemStatus
                                    );


                                if (!(ModemStatus & MS_RLSD_ON)) {
                                    //
                                    //  not high, sleep a little while
                                    //
                                    Sleep(20);

                                    GetCommModemStatus(
                                        ReadState->FileHandle,
                                        &ModemStatus
                                        );
                                }


                                if ((ModemStatus & MS_RLSD_ON)) {
                                    //
                                    //  CD is high, assume the connect worked
                                    //
                                    ZeroMemory(&Mss,sizeof(Mss));

                                    Mss.bResponseState=RESPONSE_CONNECT;

                                    PrintString(
                                        ReadState->Debug,
                                        ReadState->ReceiveBuffer,
                                        ReadState->BytesInReceiveBuffer,
                                        PS_RECV
                                        );

                                    LogString(ReadState->Debug, IDS_UNRECOGNISED_CONNECT);

                                    HandleGoodResponse(
                                        ReadState,
                                        &Mss
                                        );

                                    //
                                    //  reset the character counts since response engine is stopping
                                    //
                                    ReadState->BytesInReceiveBuffer=0;

                                    ReadState->CurrentMatchingLength=0;
                                    ReadState->MatchingContext=NULL;

                                    break;

                                } else {
                                    //
                                    //  connecting, but CD is still not high,
                                    //  send to the cleanup handler in hope it can get re-synced
                                    //
                                    ReadState->State=READ_STATE_CLEANUP;

                                    break;

                                }
                            }




                            ReadState->State=READ_STATE_CLEANUP;


                            if ((ReadState->ResponseHandler != NULL)) {

                                COMMANDRESPONSE   *Handler;
                                HANDLE             Context;

                                CancelUnimodemTimer(
                                    ReadState->Timer
                                    );

                                //
                                //  capture the handler
                                //
                                Handler=ReadState->ResponseHandler;
                                Context=ReadState->ResponseHandlerContext;

                                //
                                //  invalidate the handler
                                //
                                ReadState->ResponseHandler=NULL;

                                //
                                //  drop the lock and call back
                                //
                                UnlockObject(
                                    &ReadState->Header
                                    );

                                DeliverCommandResult(
                                    ReadState->CompletionPort,
                                    Handler,
                                    Context,
                                    ERROR_UNIMODEM_RESPONSE_BAD
                                    );


                                LockObject(
                                    &ReadState->Header
                                    );



                            }


                            break;

                        default:

                            break;

                    } // switch (matchresult)

                } else {
                    //
                    //  need more characters to keep matching
                    //
                    ReadState->State=READ_STATE_READ_SOME_DATA;

                    ReadState->StateAfterGoodRead=READ_STATE_MATCHING;

                }

                break;
            }

            case READ_STATE_POSSIBLE_RESPONSE: {
                //
                //  we got a possible response and needed to read more characters
                //
                COMMTIMEOUTS    CommTimeouts;

                if (ReadState->PossibleResponseLength == ReadState->BytesInReceiveBuffer) {
                    //
                    //  did not get anymore characters, assume that is is all we are going to get
                    //
                    D_TRACE(UmDpf(ReadState->Debug,"using possible response");)

                    PrintString(
                        ReadState->Debug,
                        ReadState->ReceiveBuffer,
                        ReadState->PossibleResponseLength,
                        PS_RECV
                        );

                    PrintGoodResponse(
                        ReadState->Debug,
                        ReadState->Mss.bResponseState & ~RESPONSE_VARIABLE_FLAG
                        );

                    HandleGoodResponse(
                        ReadState,
                        &ReadState->Mss
                        );

                    MoveMemory(
                        ReadState->ReceiveBuffer,
                        ReadState->ReceiveBuffer+ReadState->PossibleResponseLength,
                        ReadState->BytesInReceiveBuffer-ReadState->PossibleResponseLength
                        );

                    ReadState->BytesInReceiveBuffer-=ReadState->PossibleResponseLength;

                    ReadState->CurrentMatchingLength=0;
                    ReadState->MatchingContext=NULL;

                    ReadState->PossibleResponseLength=0;

                }

                CommTimeouts.ReadIntervalTimeout=20;
                CommTimeouts.ReadTotalTimeoutMultiplier=0;
                CommTimeouts.ReadTotalTimeoutConstant=0;
                CommTimeouts.WriteTotalTimeoutMultiplier=10;
                CommTimeouts.WriteTotalTimeoutConstant=2000;

                bResult=SetCommTimeouts(
                    ReadState->FileHandle,
                    &CommTimeouts
                    );



                ReadState->State=READ_STATE_MATCHING;

                break;

            }


            case READ_STATE_CLEANUP: {

                    COMMTIMEOUTS    CommTimeouts;

                    ResetEvent(ReadState->Busy);

                    //
                    //  log whatever showed up
                    //
                    PrintString(
                        ReadState->Debug,
                        ReadState->ReceiveBuffer,
                        ReadState->BytesInReceiveBuffer,
                        PS_RECV
                        );

                    LogString(ReadState->Debug, IDS_RESP_UNKNOWN);

                    ReadState->BytesInReceiveBuffer=0;

                    ReadState->CurrentMatchingLength=0;
                    ReadState->MatchingContext=NULL;

                    CommTimeouts.ReadIntervalTimeout=MAXULONG;
                    CommTimeouts.ReadTotalTimeoutMultiplier=MAXULONG;
                    CommTimeouts.ReadTotalTimeoutConstant=200;
                    CommTimeouts.WriteTotalTimeoutMultiplier=10;
                    CommTimeouts.WriteTotalTimeoutConstant=2000;

                    bResult=SetCommTimeouts(
                        ReadState->FileHandle,
                        &CommTimeouts
                        );

                    if (!bResult) {

                        D_TRACE(UmDpf(ReadState->Debug,"SetCommTimeouts failed- %08lx",GetLastError());)

                        ReadState->State=READ_STATE_FAILURE;

                        break;

                    }


                    ReinitOverStruct(UmOverlapped);

                    UmOverlapped->Context1=ReadState; //ReadObjectHandle;

                    BytesToRead=sizeof(ReadState->ReceiveBuffer);

                    ReadState->State=READ_STATE_CLEANUP2;

                    bResult=UnimodemReadFileEx(
                        ReadState->FileHandle,
                        ReadState->ReceiveBuffer+ReadState->BytesInReceiveBuffer,
                        BytesToRead,
                        &UmOverlapped->Overlapped,
                        ReadCompletionHandler
                        );


                    if (!bResult) {

                        D_TRACE(UmDpf(ReadState->Debug,"ReadFile failed- %08lx",GetLastError());)

                        ReadState->State=READ_STATE_FAILURE;

                        break;

                    }

                    ExitLoop=TRUE;

                    break;


                }

            case READ_STATE_CLEANUP2: {

                    COMMTIMEOUTS    CommTimeouts;

                    if ((ErrorCode != ERROR_SUCCESS) && (ErrorCode != ERROR_OPERATION_ABORTED)) {

                        D_TRACE(UmDpf(ReadState->Debug,"ReadFile failed- %08lx",GetLastError());)

                        ReadState->State=READ_STATE_FAILURE;

                        break;
                    }

                    if (BytesRead == 0) {
                        //
                        //  emptied the buffer
                        //
                        ReadState->State=READ_STATE_MATCHING;

                        CommTimeouts.ReadIntervalTimeout=20;
                        CommTimeouts.ReadTotalTimeoutMultiplier=0;
                        CommTimeouts.ReadTotalTimeoutConstant=0;
                        CommTimeouts.WriteTotalTimeoutMultiplier=10;
                        CommTimeouts.WriteTotalTimeoutConstant=2000;

                        bResult=SetCommTimeouts(
                            ReadState->FileHandle,
                            &CommTimeouts
                            );

                        SetEvent(ReadState->Busy);

                        if (ReadState->ResponseFlags & RESPONSE_FLAG_STOP_READ_ON_CONNECT) {
                            //
                            //  we were expecting a connect response because we were trying to connect,
                            //  but we got something we did not recognize, see if CD is high.
                            //  If it is then assume the connection was established
                            //
                            DWORD    ModemStatus=0;

                            GetCommModemStatus(
                                ReadState->FileHandle,
                                &ModemStatus
                                );


                            if (!(ModemStatus & MS_RLSD_ON)) {
                                //
                                //  not high, sleep a little while
                                //
                                Sleep(20);

                                GetCommModemStatus(
                                    ReadState->FileHandle,
                                    &ModemStatus
                                    );
                            }


                            if ((ModemStatus & MS_RLSD_ON)) {
                                //
                                //  CD is high, assume the connect worked
                                //
                                ZeroMemory(&Mss,sizeof(Mss));

                                Mss.bResponseState=RESPONSE_CONNECT;

                                PrintString(
                                    ReadState->Debug,
                                    ReadState->ReceiveBuffer,
                                    ReadState->BytesInReceiveBuffer,
                                    PS_RECV
                                    );

                                LogString(ReadState->Debug, IDS_UNRECOGNISED_CONNECT);

                                HandleGoodResponse(
                                    ReadState,
                                    &Mss
                                    );

                                //
                                //  reset the character counts since response engine is stopping
                                //
                                ReadState->BytesInReceiveBuffer=0;

                                ReadState->CurrentMatchingLength=0;
                                ReadState->MatchingContext=NULL;

                                break;

                            }
                        }

                    } else {

                        ReadState->BytesInReceiveBuffer=BytesRead;

                        ReadState->State=READ_STATE_CLEANUP;
                    }

                }
                break;

            case READ_STATE_VARIABLE_MATCH: {

                //
                //  get rid fixed part
                //
                MoveMemory(
                    ReadState->ReceiveBuffer,
                    ReadState->ReceiveBuffer+ReadState->CurrentMatchingLength,
                    ReadState->BytesInReceiveBuffer-ReadState->CurrentMatchingLength
                    );

                ReadState->BytesInReceiveBuffer-=ReadState->CurrentMatchingLength;

                ReadState->CurrentMatchingLength=0;
                ReadState->MatchingContext=NULL;

                ReadState->State=READ_STATE_VARIABLE_MATCH_REST;

                break;

            }

            case READ_STATE_VARIABLE_MATCH_REST: {

                CHAR    TempBuffer[READ_BUFFER_SIZE];

                if (ReadState->BytesInReceiveBuffer > ReadState->CurrentMatchingLength) {

                    ReadState->CurrentMatchingLength++;

                    if (ReadState->CurrentMatchingLength >= (DWORD)ReadState->VariableTerminatorLength) {

                        LONG    Match;

                        Match=memcmp(
                            &ReadState->ReceiveBuffer[ReadState->CurrentMatchingLength-ReadState->VariableTerminatorLength],
                            ReadState->VariableTerminator,
                            ReadState->VariableTerminatorLength
                            );

                        if (Match == 0) {
                            //
                            //  found the terminator
                            //
                            BYTE    InfoType;

                            D_TRACE(UmDpf(ReadState->Debug,"Got complete variable response");)

                            PrintString(
                                ReadState->Debug,
                                ReadState->ReceiveBuffer,
                                ReadState->CurrentMatchingLength,
                                PS_RECV
                                );

                            CopyMemory(
                                TempBuffer,
                                ReadState->ReceiveBuffer,
                                ReadState->CurrentMatchingLength-ReadState->VariableTerminatorLength
                                );

                            //
                            //  null terminate
                            //
                            TempBuffer[ReadState->CurrentMatchingLength-ReadState->VariableTerminatorLength]='\0';


                            InfoType=(ReadState->Mss.bResponseState & ~RESPONSE_VARIABLE_FLAG);

                            switch (InfoType) {

                                case RESPONSE_DRON:
                                case RESPONSE_DROF: {

                                    DWORD           Value=0;
                                    LPSTR           Temp=TempBuffer;
                                    PUM_OVER_STRUCT UmOverlapped2;

                                    while (*Temp != '\0') {

                                        Value=Value*10+(*Temp-'0');

                                        Temp++;
                                    }

                                    UmOverlapped2=AllocateOverStruct(ReadState->CompletionPort);

                                    if (UmOverlapped2 != NULL)
                                    {
                                        AddReferenceToObject (&ReadState->Header);

                                        UmOverlapped2->Context1 = ReadState;
                                        UmOverlapped2->Context2 = (HANDLE)UlongToPtr((InfoType == RESPONSE_DRON) ? MODEM_RING_ON_TIME : MODEM_RING_OFF_TIME);
                                        UmOverlapped2->Overlapped.Internal = Value;
                                        UmOverlapped2->Overlapped.InternalHigh = 0;

                                        if (!UnimodemQueueUserAPC ((LPOVERLAPPED)UmOverlapped2, AsyncNotifHandler))
                                        {
                                            FreeOverStruct(UmOverlapped2);
                                            RemoveReferenceFromObject (&ReadState->Header);
                                        }
                                    }

                                    break;
                                }

                                case RESPONSE_DATE:
                                case RESPONSE_TIME:
                                case RESPONSE_NMBR:
                                case RESPONSE_NAME:
                                case RESPONSE_MESG: {

                                    PUM_OVER_STRUCT UmOverlapped2;
                                    DWORD           dwLen;

                                    //
                                    //  caller id related
                                    //
                                    if (InfoType == RESPONSE_NMBR) {

                                        BOOL    Match2;

                                        if (ReadState->CallerIDPrivate != NULL) {

                                             Match2=lstrcmpiA(TempBuffer,ReadState->CallerIDPrivate);

                                             if (Match2 == TRUE) {

                                                 lstrcpyA(TempBuffer,MODEM_CALLER_ID_OUTSIDE);

                                             }
                                        }

                                        if (ReadState->CallerIDOutside != NULL) {

                                             Match2=lstrcmpiA(TempBuffer,ReadState->CallerIDOutside);

                                             if (Match2 == TRUE) {

                                                 lstrcpyA(TempBuffer,MODEM_CALLER_ID_OUTSIDE);

                                             }
                                        }
                                    }


                                    dwLen = lstrlenA(TempBuffer);
                                    UmOverlapped2=AllocateOverStructEx(ReadState->CompletionPort,dwLen+1);

                                    if (UmOverlapped2 != NULL)
                                    {
                                     char *pTemp = (char*)UmOverlapped2+sizeof(*UmOverlapped2);

                                        
                                        AddReferenceToObject (&ReadState->Header);
                                        UmOverlapped2->Context1 = ReadState;
                                        UmOverlapped2->Context2 = (HANDLE)ULongToPtr((DWORD)((InfoType-RESPONSE_DATE)+MODEM_CALLER_ID_DATE)); // sundown: zero-extension
                                        lstrcpyA (pTemp, TempBuffer);
                                        UmOverlapped2->Overlapped.Internal = (ULONG_PTR)pTemp;
                                        UmOverlapped2->Overlapped.InternalHigh = dwLen;

                                        if (!UnimodemQueueUserAPC ((LPOVERLAPPED)UmOverlapped2, AsyncNotifHandler))
                                        {
                                            FreeOverStruct(UmOverlapped2);
                                            RemoveReferenceFromObject (&ReadState->Header);
                                        }
                                    }

                                    break;
                                }

                                case RESPONSE_DIAG: {

                                    DWORD    BytesToCopy;

                                    if (ReadState->DiagBuffer != NULL) {
                                        //
                                        //  we have a buffer for the diagnostic info
                                        //
                                        BytesToCopy=ReadState->DiagBufferLength - ReadState->AmountOfDiagBufferUsed;

                                        BytesToCopy= BytesToCopy < ReadState->CurrentMatchingLength-ReadState->VariableTerminatorLength ?
                                                         BytesToCopy : ReadState->CurrentMatchingLength-ReadState->VariableTerminatorLength;

                                        CopyMemory(
                                            ReadState->DiagBuffer+ReadState->AmountOfDiagBufferUsed,
                                            ReadState->ReceiveBuffer,
                                            BytesToCopy
                                            );

                                        ReadState->AmountOfDiagBufferUsed+=BytesToCopy;
                                    }

                                    break;
                                }
#if 0
                                case RESPONSE_V8: {

                                    break;
                                }

                                default:
                                   ASSERT(0);
                                   break;
#endif

                            }


                            MoveMemory(
                                ReadState->ReceiveBuffer,
                                ReadState->ReceiveBuffer+ReadState->CurrentMatchingLength,
                                ReadState->BytesInReceiveBuffer-ReadState->CurrentMatchingLength
                                );

                            ReadState->BytesInReceiveBuffer-=ReadState->CurrentMatchingLength;

                            ReadState->CurrentMatchingLength=0;
                            ReadState->MatchingContext=NULL;



                            ReadState->State=READ_STATE_MATCHING;
                        }
                    }

                } else {
                    //
                    //  read more characters
                    //

                    ReadState->State=READ_STATE_READ_SOME_DATA;

                    ReadState->StateAfterGoodRead=READ_STATE_VARIABLE_MATCH_REST;

                    break;

                }



                break;

            }


            case READ_STATE_FAILURE: {

                PUM_OVER_STRUCT UmOverlapped2;

                ReadState->State=READ_STATE_STOPPING;

                UmOverlapped2 = AllocateOverStruct (ReadState->CompletionPort);
                if (UmOverlapped2 != NULL)
                {
                    AddReferenceToObject (&ReadState->Header);
                    UmOverlapped2->Context1 = ReadState;
                    UmOverlapped2->Context2 = (HANDLE)MODEM_HARDWARE_FAILURE;
                    UmOverlapped2->Overlapped.Internal = 0;
                    UmOverlapped2->Overlapped.InternalHigh = 0;

                    if (!UnimodemQueueUserAPC ((LPOVERLAPPED)UmOverlapped2, AsyncNotifHandler))
                    {
                        FreeOverStruct(UmOverlapped2);
                        RemoveReferenceFromObject (&ReadState->Header);
                    }
                }

                break;
            }


            case READ_STATE_STOPPING: {

                COMMANDRESPONSE   *Handler=NULL;
                HANDLE             Context;

                ReadState->State=READ_STATE_STOPPED;

                if (ReadState->ResponseHandler != NULL) {
                    //
                    //  there is a command response handler
                    //
                    CancelUnimodemTimer(
                        ReadState->Timer
                        );

                    //
                    //  capture the handler
                    //
                    Handler=ReadState->ResponseHandler;
                    Context=ReadState->ResponseHandlerContext;

                    //
                    //  invalidate the handler
                    //
                    ReadState->ResponseHandler=NULL;
                }


                UnlockObject(
                    &ReadState->Header
                    );

                if (Handler != NULL) {

                    DeliverCommandResult(
                        ReadState->CompletionPort,
                        Handler,
                        Context,
                        ERROR_UNIMODEM_GENERAL_FAILURE
                        );
                }

                LockObject(
                    &ReadState->Header
                    );


                break;
            }

            case READ_STATE_STOPPED:

                D_TRACE(UmDpf(ReadState->Debug,"READ_STATE_STOPPED");)

                if (ReadState->StopEvent != NULL) {
                    //
                    //  signal event so the stop engine code will run
                    //
                    SetEvent(ReadState->StopEvent);
                }

                RemoveReferenceFromObject(
                    &ReadState->Header
                    );

                SetEvent(ReadState->Busy);

                ExitLoop=TRUE;

                break;


            case READ_STATE_READ_SOME_DATA:

                ReadState->State=READ_STATE_GOT_SOME_DATA;

                ReinitOverStruct(UmOverlapped);

                UmOverlapped->Context1=ReadState;

                bResult=ClearCommError(
                    ReadState->FileHandle,
                    &CommErrors,
                    &ComStat
                    );

                if (sizeof(ReadState->ReceiveBuffer) == ReadState->BytesInReceiveBuffer) {
                    //
                    //  buffer is full
                    //
                    ReadState->State=READ_STATE_CLEANUP;

                    break;
                }

                BytesToRead=sizeof(ReadState->ReceiveBuffer)-ReadState->BytesInReceiveBuffer;

                if (bResult && (ComStat.cbInQue > 0)) {
                    //
                    //  characters are wating in the serial driver, read as many as posible.
                    //
                    BytesToRead=ComStat.cbInQue < BytesToRead ? ComStat.cbInQue : BytesToRead;

                    D_TRACE(UmDpf(ReadState->Debug,"Reading %d bytes from driver",BytesToRead);)

                } else {
                    //
                    //  serial driver is empty, just read one character to start things off
                    //
                    BytesToRead=1;
                }

                if (ReadState->ResponseFlags & RESPONSE_FLAG_SINGLE_BYTE_READS) {
                    //
                    //  client wants single byte reads
                    //
                    BytesToRead=1;
                }

                bResult=UnimodemReadFileEx(
                    ReadState->FileHandle,
                    ReadState->ReceiveBuffer+ReadState->BytesInReceiveBuffer,
                    BytesToRead,
                    &UmOverlapped->Overlapped,
                    ReadCompletionHandler
                    );


                if (!bResult) {

                    D_TRACE(UmDpf(ReadState->Debug,"ReadFile failed- %08lx",GetLastError());)

                    ReadState->State=READ_STATE_FAILURE;

                    break;

                } else {

                    ExitLoop=TRUE;
                }

                break;

            case READ_STATE_GOT_SOME_DATA:

                if ((ErrorCode != ERROR_SUCCESS) && (ErrorCode != ERROR_OPERATION_ABORTED)) {

                    D_TRACE(UmDpf(ReadState->Debug,"ReadFile failed- %08lx",GetLastError());)

                    ReadState->State=READ_STATE_FAILURE;

                    break;
                }

                ReadState->BytesInReceiveBuffer+=BytesRead;

                ReadState->State=ReadState->StateAfterGoodRead;
#if DBG
                ReadState->StateAfterGoodRead=READ_STATE_FAILURE;
#endif
                break;



            default:

                ExitLoop=TRUE;

                break;

        }
    }


    RemoveReferenceFromObjectAndUnlock(
        &ReadState->Header
        );

    return;

}



VOID WINAPI
ReportMatchString(
    PREAD_STATE    ReadState,
    BYTE           ResponseState,
    BYTE           *Response,
    DWORD          ResponseLength
    )

{
    PBYTE            TempBuffer;
    PUM_OVER_STRUCT UmOverlapped;

    UmOverlapped=AllocateOverStructEx(ReadState->CompletionPort,ResponseLength+1);

    if (UmOverlapped != NULL)
    {
        TempBuffer=(char*)UmOverlapped+sizeof(*UmOverlapped);

        CopyMemory(
            TempBuffer,
            Response,
            ResponseLength
            );
        TempBuffer[ResponseLength]='\0';

        AddReferenceToObject (&ReadState->Header);

        UmOverlapped->Context1 = ReadState;
        UmOverlapped->Context2 = (HANDLE)MODEM_GOOD_RESPONSE;
        UmOverlapped->Overlapped.Internal = (ULONG_PTR)ResponseState;
        UmOverlapped->Overlapped.InternalHigh = (ULONG_PTR)TempBuffer;

        if (!UnimodemQueueUserAPC ((LPOVERLAPPED)UmOverlapped, AsyncNotifHandler))
        {
            FreeOverStruct(UmOverlapped);
            RemoveReferenceFromObject (&ReadState->Header);
        }
    }

    return;

}



VOID WINAPI
HandleGoodResponse(
    PREAD_STATE    ReadState,
    MSS           *Mss
    )

{
    DWORD          Status;
    BOOL           ReportResponse=TRUE;


    if ( Mss->bResponseState != RESPONSE_SIERRA_DLE) {
        //
        // negotiated modem options...  only allow compression and error correction results
        //
        ReadState->ModemOptions |= (Mss->bNegotiatedOptions &
                                                             (MDM_COMPRESSION |
                                                              MDM_ERROR_CONTROL |
                                                              MDM_CELLULAR));

        // check for DCE and DTE info
        if (Mss->Flags & MSS_FLAGS_DCE_RATE) {

            ReadState->DCERate = Mss->NegotiatedRate;

        }

        if (Mss->Flags & MSS_FLAGS_DTE_RATE) {

            ReadState->DTERate = Mss->NegotiatedRate;
        }

    }



    switch (Mss->bResponseState) {

        case RESPONSE_OK:

            if (ReadState->ResponseFlags & RESPONSE_FLAG_ONLY_CONNECT) {
                //
                //  only report success on receipt of a connect message
                //  used for cirrus
                //
                ReportResponse=FALSE;

            } else {
               if (ReadState->ResponseFlags & RESPONSE_FLAG_ONLY_CONNECT_SUCCESS) {
                    //
                    //  if we abort a connection attempt by sending <cr>, some motorola
                    //  modems return OK which we think means that it succeeded.
                    //  With this a OK result on a connect attempt will result in a failure
                    //
                    Status=ERROR_UNIMODEM_RESPONSE_NOCARRIER;
                    break;
                }
            }


            Status=ERROR_SUCCESS;

            break;

        case RESPONSE_CONNECT:

            if (ReadState->ResponseFlags & RESPONSE_FLAG_STOP_READ_ON_CONNECT) {

                ReadState->State = READ_STATE_STOPPING;
            }

            Status=ERROR_SUCCESS;
            break;

        case RESPONSE_ERROR:

            Status=ERROR_UNIMODEM_RESPONSE_ERROR;

            break;

        case RESPONSE_NOCARRIER:

            Status=ERROR_UNIMODEM_RESPONSE_NOCARRIER;

            break;

        case RESPONSE_NODIALTONE:

            Status=ERROR_UNIMODEM_RESPONSE_NODIALTONE;

            break;

        case RESPONSE_BUSY:

            Status=ERROR_UNIMODEM_RESPONSE_BUSY;

            break;

        case RESPONSE_NOANSWER:

            Status=ERROR_UNIMODEM_RESPONSE_NOANSWER;

            break;

        case RESPONSE_BLACKLISTED:

            Status=ERROR_UNIMODEM_RESPONSE_BLACKLISTED;

            break;

        case RESPONSE_DELAYED:

            Status=ERROR_UNIMODEM_RESPONSE_DELAYED;

            break;

        case RESPONSE_RING:
        case RESPONSE_RINGA:
        case RESPONSE_RINGB:
        case RESPONSE_RINGC:
        {
            PUM_OVER_STRUCT UmOverlapped;

            ReportResponse=FALSE;

            if (ReadState->RingCount > 0) {
                //
                //  Ring count is more than one, check to see when the last ring showed up
                //
                DWORD   RingTimeDelta;

                RingTimeDelta=GetTimeDelta(ReadState->LastRingTime,GetTickCount());

                if (RingTimeDelta > 20 * 1000) {
                    //
                    //  more than 20 seconds have passed since the last ring, probably a new call
                    //
                    ReadState->RingCount=0;

                }
            }

            ReadState->RingCount++;
            ReadState->LastRingTime=GetTickCount();

            //
            //  report the ring,
            //
            //  if it is distictive ring, report in dwparam1.
            //
            UmOverlapped=AllocateOverStruct(ReadState->CompletionPort);

            if (UmOverlapped != NULL)
            {
                AddReferenceToObject (&ReadState->Header);
                UmOverlapped->Context1 = ReadState;
                UmOverlapped->Context2 = (HANDLE)MODEM_RING;
                UmOverlapped->Overlapped.Internal = (Mss->bResponseState == RESPONSE_RING ? 0 : (Mss->bResponseState - RESPONSE_RINGA) +1)*100;
                UmOverlapped->Overlapped.InternalHigh = 0;

                if (!UnimodemQueueUserAPC ((LPOVERLAPPED)UmOverlapped, AsyncNotifHandler))
                {
                    FreeOverStruct(UmOverlapped);
                    RemoveReferenceFromObject (&ReadState->Header);
                }
            }

            break;
        }

        case RESPONSE_LOOP:

            ReportResponse=FALSE;

            break;

        case RESPONSE_DRON:
        case RESPONSE_DROF:

        case RESPONSE_DATE:
        case RESPONSE_TIME:
        case RESPONSE_NMBR:
        case RESPONSE_NAME:
        case RESPONSE_MESG:

        default:

            ReportResponse=FALSE;

            break;

    }

    if (ReportResponse && (ReadState->ResponseHandler != NULL)) {

        COMMANDRESPONSE   *Handler;
        HANDLE             Context;
        BOOL               Canceled;


        if (ReadState->ResponseFlags & RESPONSE_FLAG_STOP_READ_ON_GOOD_RESPONSE) {

            if (Status == ERROR_SUCCESS) {

                ReadState->State = READ_STATE_STOPPING;
            }
        }


        //
        //  Not ignoring this response
        //
        Canceled=CancelUnimodemTimer(
            ReadState->Timer
            );

        if (Canceled) {

            //  remove ref

        }
        ReadState->ResponseFlags=0;

        //
        //  capture the handler
        //
        Handler=ReadState->ResponseHandler;
        Context=ReadState->ResponseHandlerContext;

        //
        //  invalidate the handler
        //
        ReadState->ResponseHandler=NULL;
        ReadState->ResponseHandlerContext=NULL;

        //
        //  drop the lock and call back
        //
        UnlockObject(
            &ReadState->Header
            );

        DeliverCommandResult(
            ReadState->CompletionPort,
            Handler,
            Context,
            Status
            );

        LockObject(
            &ReadState->Header
            );


    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\speaker.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    speaker.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"

#include <stdlib.h>




LPSTR WINAPI
BuildDigitCommands(
    PMODEM_CONTROL    ModemControl,
    CHAR              Digit
    );

LONG
BuildSpeakerPhoneCommands(
    PMODEM_CONTROL    ModemControl,
    DWORD             OldTapiPhoneHookSwitchMode,
    DWORD             NewTapiPhoneHookSwitchMode,
    DWORD             Volume,
    DWORD             Gain,
    LPSTR            *CommandsStrings
    );



#define   GENERATE_DIGIT_STATE_SEND_COMMANDS       1
#define   GENERATE_DIGIT_STATE_WAIT_FOR_RESPONSE   2

#define   SPEAKERPHONE_STATE_SEND_COMMAND          1
#define   SPEAKERPHONE_STATE_WAIT_FOR_RESPONSE     2


VOID
GenerateDigitsCompleteHandler(
    HANDLE      Context,
    DWORD       Status
    )

{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)Context;
    BOOL              ExitLoop=FALSE;

    ASSERT(COMMAND_TYPE_GENERATE_DIGIT == ModemControl->CurrentCommandType);

    D_INIT(UmDpf(ModemControl->Debug,"UNIMDMAT: GenerateDigitsCompleteHandler\n");)

    while (!ExitLoop) {

        switch (ModemControl->GenerateDigit.State) {

            case GENERATE_DIGIT_STATE_SEND_COMMANDS:

                ModemControl->GenerateDigit.State=GENERATE_DIGIT_STATE_WAIT_FOR_RESPONSE;

                Status=IssueCommand(
                    ModemControl->CommandState,
                    ModemControl->CurrentCommandStrings,
                    GenerateDigitsCompleteHandler,
                    ModemControl,
                    2000,
                    0
                    );

                if (Status == ERROR_IO_PENDING) {
                    //
                    //  Wait for response
                    //
                    ExitLoop=TRUE;

                    break;
                }
                //
                //  failed  fall through
                //


           case GENERATE_DIGIT_STATE_WAIT_FOR_RESPONSE:

                FREE_MEMORY(ModemControl->CurrentCommandStrings);

                ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

                if ((Status == ERROR_SUCCESS) && !ModemControl->GenerateDigit.Abort) {

                    ModemControl->GenerateDigit.CurrentDigit++;

                    if (ModemControl->GenerateDigit.DigitString[ModemControl->GenerateDigit.CurrentDigit] != '\0') {
                        //
                        //  send the next digit
                        //
                        ModemControl->CurrentCommandStrings=BuildDigitCommands(
                            ModemControl,
                            ModemControl->GenerateDigit.DigitString[ModemControl->GenerateDigit.CurrentDigit]
                            );


                        if (ModemControl->CurrentCommandStrings != NULL) {
                            //
                            //  got strings
                            //
                            ModemControl->GenerateDigit.State=GENERATE_DIGIT_STATE_SEND_COMMANDS;

                            ModemControl->CurrentCommandType=COMMAND_TYPE_GENERATE_DIGIT;

                            break;

                        } else {

                            Status=ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }
                }


                ExitLoop=TRUE;

                FREE_MEMORY(ModemControl->GenerateDigit.DigitString);

                (*ModemControl->NotificationProc)(
                    ModemControl->NotificationContext,
                    MODEM_ASYNC_COMPLETION,
                    Status,
                    0
                    );

                //
                //  remove ref for starting async processing
                //
                RemoveReferenceFromObject(
                    &ModemControl->Header
                    );


                break;

            default:

                ASSERT(0);
                break;

        }

    }

    return;


}




DWORD WINAPI
UmGenerateDigit(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    LPSTR     DigitString
    )
/*++

Routine Description:

    This routine is called to generate DTMF tones once a call is connected

Arguments:

    ModemHandle - Handle returned by OpenModem

    CommandsOptionList - List option blocks, only flags used
       Flags   - Optional init parameters. Not currently used and must be zero


    GenerateDigit.DigitString - Digits to dial


Return Value:

    ERROR_IO_PENDING If pending, will be completed later with a call to the AsyncHandler

    or other specific error



--*/

{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)ReferenceObjectByHandleAndLock(ModemHandle);
    LONG              lResult;
    LPSTR             Commands;
    BOOL              bResult;
    DWORD             BufferSize;

    ASSERT(ModemControl->CurrentCommandType == COMMAND_TYPE_NONE);

    if (ModemControl->CurrentCommandType != COMMAND_TYPE_NONE) {

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_UNIMODEM_INUSE;
    }

    BufferSize=lstrlenA(DigitString)+sizeof(CHAR);

    ModemControl->GenerateDigit.DigitString=ALLOCATE_MEMORY(BufferSize);

    if (ModemControl->GenerateDigit.DigitString == NULL) {
        //
        //  could not get memory
        //
        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    lstrcpyA(ModemControl->GenerateDigit.DigitString,DigitString);

    ModemControl->GenerateDigit.CurrentDigit=0;

    ModemControl->CurrentCommandStrings=BuildDigitCommands(
        ModemControl,
        ModemControl->GenerateDigit.DigitString[ModemControl->GenerateDigit.CurrentDigit]
        );


    if (ModemControl->CurrentCommandStrings == NULL) {

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_UNIMODEM_MISSING_REG_KEY;

    }


    ModemControl->CurrentCommandType=COMMAND_TYPE_GENERATE_DIGIT;

    ModemControl->GenerateDigit.State=GENERATE_DIGIT_STATE_SEND_COMMANDS;

    ModemControl->GenerateDigit.Abort=FALSE;

    bResult=StartAsyncProcessing(
        ModemControl,
        GenerateDigitsCompleteHandler,
        ModemControl,
        ERROR_SUCCESS
        );


    if (!bResult) {
        //
        //  failed
        //
        ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

        FREE_MEMORY(ModemControl->CurrentCommandStrings);

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_NOT_ENOUGH_MEMORY;

    }

    RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

    return ERROR_IO_PENDING;


}



#define HAYES_COMMAND_LENGTH        40

LPSTR WINAPI
BuildDigitCommands(
    PMODEM_CONTROL    ModemControl,
    CHAR              Digit
    )
{

    char              *pszzCmdInMem;

    DWORD              DestLength;

    PUCHAR             RealCommands;
    PUCHAR             SourceCommand;
    PUCHAR             DestCommand;

    MODEMMACRO         MacroList[1];


    LogString(ModemControl->Debug,IDS_MSGLOG_VOICE_GENTERAEDTMF);

    pszzCmdInMem=GetCommonCommandStringCopy(
        ModemControl->CommonInfo,
        COMMON_GENERATE_DIGIT,
        NULL,
        NULL
        );


    if (!pszzCmdInMem) {

        LogString(ModemControl->Debug,IDS_MSGERR_FAILED_VOICE_GENERATEDTMF);

        return NULL;

    }


    RealCommands = ALLOCATE_MEMORY( (HAYES_COMMAND_LENGTH + 1) * 10);

    if (RealCommands == NULL) {

        LogString(ModemControl->Debug,IDS_MSGERR_FAILED_VOICE_GENERATEDTMF);

        FREE_MEMORY(pszzCmdInMem);

        return NULL;

    }


    lstrcpyA(MacroList[0].MacroName,"<Digit>");

    MacroList[0].MacroValue[0]=Digit;
    MacroList[0].MacroValue[1]='\0';


    SourceCommand=pszzCmdInMem;

    DestCommand=RealCommands;

    while (*SourceCommand != '\0') {

        ExpandMacros(
            SourceCommand,
            DestCommand,
            &DestLength,
            MacroList,
            1
            );

        SourceCommand+=lstrlenA(SourceCommand)+1;

        DestCommand+=DestLength+1;

    }

    *DestCommand='\0';

    FREE_MEMORY(pszzCmdInMem);

    pszzCmdInMem=RealCommands;





    return pszzCmdInMem;
}



VOID
SetSpeakerPhoneCompleteHandler(
    HANDLE      Context,
    DWORD       Status
    )

{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)Context;
    BOOL              ExitLoop=FALSE;

    ASSERT(COMMAND_TYPE_SET_SPEAKERPHONE == ModemControl->CurrentCommandType);

    D_INIT(UmDpf(ModemControl->Debug,"UNIMDMAT: SetSpeakerPhoneCompleteHandler\n");)

    while (!ExitLoop) {

        switch (ModemControl->SpeakerPhone.State) {

            case SPEAKERPHONE_STATE_SEND_COMMAND:

                ModemControl->SpeakerPhone.State=SPEAKERPHONE_STATE_WAIT_FOR_RESPONSE;

                if (ModemControl->CurrentCommandStrings != NULL) {

                    Status=IssueCommand(
                        ModemControl->CommandState,
                        ModemControl->CurrentCommandStrings,
                        SetSpeakerPhoneCompleteHandler,
                        ModemControl,
                        2000,
                        0
                        );

                    if (Status == ERROR_IO_PENDING) {

                        ExitLoop=TRUE;

                    }
                }

                break;

            case SPEAKERPHONE_STATE_WAIT_FOR_RESPONSE:

                if (ModemControl->CurrentCommandStrings != NULL) {

                    FREE_MEMORY(ModemControl->CurrentCommandStrings);
                }

                ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

                (*ModemControl->NotificationProc)(
                    ModemControl->NotificationContext,
                    MODEM_ASYNC_COMPLETION,
                    Status,
                    0
                    );

                RemoveReferenceFromObject(
                    &ModemControl->Header
                    );


                ExitLoop=TRUE;

                break;

            default:

                ASSERT(0);
                break;

        }
    }

    return;

}

DWORD WINAPI
UmSetSpeakerPhoneState(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    DWORD     CurrentMode,
    DWORD     NewMode,
    DWORD     Volume,
    DWORD     Gain
    )
/*++

Routine Description:

    This routine is called to set the state of the speaker phone. The new speaker phone state will
    be set based on the new mode. Current mode may be used to determine how to get from current
    state to the new state. If CurrentState and NewState are the same then the volume and gain
    will be adjusted.

Arguments:

    ModemHandle - Handle returned by OpenModem

    CommandsOptionList - List option blocks, only flags used
       Flags   - Optional init parameters. Not currently used and must be zero


    CurrentMode - TAPI constant representing the current speaker phone state

    NewMode     - TAPI constant represent the new desired state

    Volume      - Speaker phone volume

    Gain        - Speaker phone volume

Return Value:

    ERROR_IO_PENDING If pending, will be completed later with a call to the AsyncHandler

    or other specific error



--*/

{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)ReferenceObjectByHandleAndLock(ModemHandle);
    LONG              lResult;
    LPSTR             Commands;
    BOOL              bResult;

    ASSERT(ModemControl->CurrentCommandType == COMMAND_TYPE_NONE);

    if (ModemControl->CurrentCommandType != COMMAND_TYPE_NONE) {

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_UNIMODEM_INUSE;
    }

    ModemControl->CurrentCommandType=COMMAND_TYPE_SET_SPEAKERPHONE;


    //
    //  limit to tapi max
    //
    if (Volume > 0xffff) {

        Volume = 0xffff;
    }

    //
    //  limit to tapi max
    //
    if (Gain > 0xffff) {

        Gain = 0xffff;
    }

    lResult=BuildSpeakerPhoneCommands(
        ModemControl,
        CurrentMode,
        NewMode,
        Volume,
        Gain,
        &ModemControl->CurrentCommandStrings
        );

    if (lResult == ERROR_SUCCESS) {

        ModemControl->SpeakerPhone.State=SPEAKERPHONE_STATE_SEND_COMMAND;

        bResult=StartAsyncProcessing(
            ModemControl,
            SetSpeakerPhoneCompleteHandler,
            ModemControl,
            ERROR_SUCCESS
            );


        if (!bResult) {
            //
            //  failed
            //
            ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

            if (ModemControl->CurrentCommandStrings != NULL) {

                FREE_MEMORY(ModemControl->CurrentCommandStrings);
            }

            RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

            return ERROR_NOT_ENOUGH_MEMORY;

        }

    } else {

        ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

    return ERROR_IO_PENDING;


}


#define SPEAKERPHONE_ONHOOK    0
#define SPEAKERPHONE_MICMUTE   1
#define SPEAKERPHONE_OFFHOOK   2



DWORD
AdjustVolume(
    DWORD    Value,
    DWORD    Max,
    DWORD    Min
    )

{

    DWORD    Temp;

    Temp=0x10000 / (abs(Max - Min)+1);

    if (Max >= Min) {

        return Min + (Value / (Temp+1));

    } else {

        return Min - (Value / (Temp+1));
    }


}


//
//  0 0 0 0 0
//  | | | | |
//  | | | |  ----Vol/gain
//  | | |  ------mute
//  | |  --------unmute
//  |  ----------enable
//   ------------disable
//

#define      SET_VOLUME_GAIN        0x01
#define      MUTE_MIC               0x02
#define      UNMUTE_MIC             0x04
#define      ENABLE_SPEAKER_PHONE   0x08
#define      DISABLE_SPEAKER_PHONE  0x10


CONST UCHAR StateChangeTable[3][3]={ { 0x00, 0x0b, 0x0d },
                                     { 0x10, 0x01, 0x05 },
                                     { 0x10, 0x03, 0x01 }};



UCHAR
ConvertTapiToInternal(
    DWORD     TapiMode
    )

{

    switch (TapiMode) {

       case PHONEHOOKSWITCHMODE_ONHOOK:

           return SPEAKERPHONE_ONHOOK;

       case PHONEHOOKSWITCHMODE_SPEAKER:

           return SPEAKERPHONE_MICMUTE;

       case PHONEHOOKSWITCHMODE_MICSPEAKER:

           return SPEAKERPHONE_OFFHOOK;

       default:

           return SPEAKERPHONE_ONHOOK;

    }
}





LONG
BuildSpeakerPhoneCommands(
    PMODEM_CONTROL    ModemControl,
    DWORD             OldTapiPhoneHookSwitchMode,
    DWORD             NewTapiPhoneHookSwitchMode,
    DWORD             Volume,
    DWORD             Gain,
    LPSTR            *CommandsStrings
    )
{

    char *pszzCmdInMem=NULL;

    DWORD              DestLength;

    PUCHAR             RealCommands;
    PUCHAR             SourceCommand;
    PUCHAR             DestCommand;

    LPSTR              TempCommand;

    UCHAR              Delta;

    MODEMMACRO         MacroList[2];


    *CommandsStrings=NULL;

    Delta=StateChangeTable[ConvertTapiToInternal(OldTapiPhoneHookSwitchMode)][ConvertTapiToInternal(NewTapiPhoneHookSwitchMode)];

    LogString(ModemControl->Debug,IDS_MSGLOG_VOICE_SPEAKERPHONECOMMAND);

    D_TRACE(UmDpf(ModemControl->Debug,"SetSpeakerPhoneState: Prev=%d New=%d Delta=%d\n", ConvertTapiToInternal(OldTapiPhoneHookSwitchMode), ConvertTapiToInternal(NewTapiPhoneHookSwitchMode), Delta);)

//        if (Delta == SET_VOLUME_GAIN
//            &&
//            hPort->mi_SpeakerPhoneState.Volume == SpeakerPhone->Volume
//            &&
//           hPort->mi_SpeakerPhoneState.Gain == SpeakerPhone->Gain
//            ) {
//
//            Delta=0;
//        }
//
//        hPort->mi_SpeakerPhoneState=*SpeakerPhone;

    if (Delta == 0) {

        return ERROR_SUCCESS;

    }


    if (Delta & ENABLE_SPEAKER_PHONE) {

        pszzCmdInMem=GetCommonCommandStringCopy(
            ModemControl->CommonInfo,
            COMMON_SPEAKERPHONE_ENABLE,
            NULL,
            NULL
            );


        if (!pszzCmdInMem) {

            return ERROR_UNIMODEM_MISSING_REG_KEY;

        }
    }



    if (Delta & DISABLE_SPEAKER_PHONE) {

        TempCommand=pszzCmdInMem;

        pszzCmdInMem=GetCommonCommandStringCopy(
            ModemControl->CommonInfo,
            COMMON_SPEAKERPHONE_DISABLE,
            pszzCmdInMem,
            NULL
            );


        if (TempCommand != NULL) {

            FREE_MEMORY(TempCommand);
        }

        if (!pszzCmdInMem) {

            return ERROR_UNIMODEM_MISSING_REG_KEY;

        }

    }

    if (Delta & MUTE_MIC) {

        TempCommand=pszzCmdInMem;

        pszzCmdInMem=GetCommonCommandStringCopy(
            ModemControl->CommonInfo,
            COMMON_SPEAKERPHONE_MUTE,
            pszzCmdInMem,
            NULL
            );

        if (TempCommand != NULL) {

            FREE_MEMORY(TempCommand);
        }


        if (!pszzCmdInMem) {

            return ERROR_UNIMODEM_MISSING_REG_KEY;

        }

    }


    if (Delta & UNMUTE_MIC) {

        TempCommand=pszzCmdInMem;

        pszzCmdInMem=GetCommonCommandStringCopy(
            ModemControl->CommonInfo,
            COMMON_SPEAKERPHONE_UNMUTE,
            pszzCmdInMem,
            NULL
            );

        if (TempCommand != NULL) {

            FREE_MEMORY(TempCommand);
        }


        if (!pszzCmdInMem) {

            return ERROR_UNIMODEM_MISSING_REG_KEY;
        }

    }


    if (Delta & SET_VOLUME_GAIN) {

        TempCommand=pszzCmdInMem;

        pszzCmdInMem=GetCommonCommandStringCopy(
            ModemControl->CommonInfo,
            COMMON_SPEAKERPHONE_VOLGAIN,
            pszzCmdInMem,
            NULL
            );

        if (TempCommand != NULL) {

            FREE_MEMORY(TempCommand);
        }


        if (!pszzCmdInMem) {

            return ERROR_UNIMODEM_MISSING_REG_KEY;
        }

    }



    RealCommands = ALLOCATE_MEMORY((HAYES_COMMAND_LENGTH + 1) * 10);

    if (RealCommands == NULL) {

        FREE_MEMORY(pszzCmdInMem);

        return ERROR_UNIMODEM_MISSING_REG_KEY;

    }


    lstrcpyA(MacroList[0].MacroName,"<Vol>");

//    ltoa(
//        AdjustVolume(
//            Volume,
//            ModemControl->RegInfo.SpeakerPhoneSpec.SpeakerPhoneVolMax,
//            ModemControl->RegInfo.SpeakerPhoneSpec.SpeakerPhoneVolMin
//            ),
//        MacroList[0].MacroValue,
//        10
//        );

    wsprintfA(
        MacroList[0].MacroValue,
        "%d",
        AdjustVolume(
            Volume,
            ModemControl->RegInfo.SpeakerPhoneSpec.SpeakerPhoneVolMax,
            ModemControl->RegInfo.SpeakerPhoneSpec.SpeakerPhoneVolMin
            )
        );


    lstrcpyA(MacroList[1].MacroName,"<Gain>");

//    ltoa(
//        AdjustVolume(
//            Gain,
//            ModemControl->RegInfo.SpeakerPhoneSpec.SpeakerPhoneGainMax,
//            ModemControl->RegInfo.SpeakerPhoneSpec.SpeakerPhoneGainMin
//            ),
//        MacroList[1].MacroValue,
//        10
//        );

    wsprintfA(
        MacroList[1].MacroValue,
        "%d",
        AdjustVolume(
            Gain,
            ModemControl->RegInfo.SpeakerPhoneSpec.SpeakerPhoneGainMax,
            ModemControl->RegInfo.SpeakerPhoneSpec.SpeakerPhoneGainMin
            )
        );



    SourceCommand=pszzCmdInMem;

    DestCommand=RealCommands;

    while (*SourceCommand != '\0') {

        ExpandMacros(
            SourceCommand,
            DestCommand,
            &DestLength,
            MacroList,
            2
            );

        SourceCommand+=lstrlenA(SourceCommand)+1;

        DestCommand+=DestLength+1;

    }

    *DestCommand='\0';

    FREE_MEMORY(pszzCmdInMem);

    *CommandsStrings=RealCommands;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\remove.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    remove.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"


#define  MODEM_REMOVE_SIG  ('MRMU')  //UMRM

typedef struct _REMOVE_OBJECT {

    OBJECT_HEADER          Header;

    HANDLE                 FileHandle;
    HANDLE                 CompletionPort;

    LPUMNOTIFICATIONPROC   AsyncNotificationProc;
    HANDLE                 AsyncNotificationContext;

    HANDLE                 CloseWaitEvent;

    OBJECT_HANDLE          Debug;

    PVOID                  RemoveHandle;

} REMOVE_OBJECT, *PREMOVE_OBJECT;




VOID
RemoveObjectClose(
    POBJECT_HEADER  Object
    )

{

    PREMOVE_OBJECT        RemoveObject=(PREMOVE_OBJECT)Object;

    D_TRACE(UmDpf(RemoveObject->Debug,"RemoveObjectClose ref=%d",RemoveObject->Header.ReferenceCount);)

    if (RemoveObject->RemoveHandle != NULL) {

        StopMonitoringHandle(RemoveObject->RemoveHandle);
    }

    SetEvent(RemoveObject->CloseWaitEvent);

    return;

}




VOID
RemoveObjectCleanUp(
    POBJECT_HEADER  Object
    )

{

    PREMOVE_OBJECT        RemoveObject=(PREMOVE_OBJECT)Object;

    D_TRACE(UmDpf(RemoveObject->Debug,"RemoveObjectCleanup");)

    CloseHandle(RemoveObject->CloseWaitEvent);

    return;

}

VOID
RemoveCallBack(
    POBJECT_HEADER  Object
    )

{

    PREMOVE_OBJECT        RemoveObject=(PREMOVE_OBJECT)Object;
    HANDLE                CloseWaitEvent=RemoveObject->CloseWaitEvent;

    D_TRACE(UmDpf(RemoveObject->Debug,"RemoveCallback: device removed");)

    LogString(RemoveObject->Debug,IDS_USER_REMOVAL);

    (*RemoveObject->AsyncNotificationProc)(
        RemoveObject->AsyncNotificationContext,
        MODEM_USER_REMOVE,
        0,
        0
        );

    //
    //  wait for the object to be closed
    //
    WaitForSingleObject(CloseWaitEvent,20*1000);


    return;

}


OBJECT_HANDLE WINAPI
CreateRemoveObject(
    POBJECT_HEADER     OwnerObject,
    HANDLE             FileHandle,
    HANDLE             CompletionPort,
    LPUMNOTIFICATIONPROC  AsyncNotificationProc,
    HANDLE             AsyncNotificationContext,
    OBJECT_HANDLE      Debug
    )

{

    PREMOVE_OBJECT        RemoveObject;
    OBJECT_HANDLE         ObjectHandle;
    HANDLE                CloseWaitEvent;


    CloseWaitEvent=CreateEvent(
        NULL,
        TRUE,
        FALSE,
        NULL
        );

    if (CloseWaitEvent == NULL) {

        return NULL;
    }

    ObjectHandle=CreateObject(
        sizeof(*RemoveObject),
        OwnerObject,
        MODEM_REMOVE_SIG,
        RemoveObjectCleanUp,
        RemoveObjectClose
        );

    if (ObjectHandle == NULL) {

        CloseHandle(CloseWaitEvent);

        return NULL;
    }

    //
    //  reference the handle to get a pointer to the object
    //
    RemoveObject=(PREMOVE_OBJECT)ReferenceObjectByHandle(ObjectHandle);


    //
    //  intialize the object
    //
    RemoveObject->FileHandle=FileHandle;
    RemoveObject->CompletionPort=CompletionPort;

    RemoveObject->AsyncNotificationProc=AsyncNotificationProc;
    RemoveObject->AsyncNotificationContext=AsyncNotificationContext;

    RemoveObject->Debug=Debug;

    RemoveObject->CloseWaitEvent=CloseWaitEvent;

    RemoveObject->RemoveHandle=MonitorHandle(FileHandle,RemoveCallBack,RemoveObject);

    //
    //  release the reference to the object
    //
    RemoveReferenceFromObject(&RemoveObject->Header);

    return ObjectHandle;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    openclos.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"


#include <regstr.h>

#define CMD_INDEX_START  1

typedef struct _DEF_RESPONSES {
    LPSTR    Response;
    MSS   Mss;

} DEF_RESPONSE, *PDEF_RESPONSE;

const DEF_RESPONSE   DefResponses[]=
    {{"<cr><lf>OK<cr><lf>"   ,0,RESPONSE_OK,0,0},
     {"<cr><lf>RING<cr><lf>" ,0,RESPONSE_RING,0,0},
     {"<cr><lf>ERROR<cr><lf>",0,RESPONSE_ERROR,0,0},
     {"<cr><lf>BUSY<cr><lf>" ,0,RESPONSE_BUSY,0,0}};



LPSTR WINAPI
NewLoadRegCommands(
    HKEY  hKey,
    LPCSTR szRegCommand
    )
{
    LPSTR   pszzNew, pszStr;
    ULONG   ulAllocSize = 0;
    HKEY    hKeyCommand;
    DWORD   dwIndex;
    char    szValue[12];
    DWORD   dwType;
    ULONG   dwSize;

    LONG    lResult;

    // Initialise pointers

    pszzNew = NULL;
    pszStr = NULL;

    // open the key

    lResult=RegOpenKeyA(
        hKey,
        szRegCommand,
        &hKeyCommand
        );

    if (lResult !=  ERROR_SUCCESS) {

        D_ERROR(DebugPrint("was unable to open the '%s' key in LoadRegCommands.", szRegCommand);)
        return NULL;
    }

    // Calculate size of the registry command, including null-terminators for each command.
    //
    dwIndex = CMD_INDEX_START;

    do {

        wsprintfA(szValue, "%d", dwIndex);

        lResult=RegQueryValueExA(
            hKeyCommand,
            szValue,
            NULL,
            &dwType,
            NULL,
            &dwSize
            );

        if (lResult == ERROR_SUCCESS) {

            if (dwType != REG_SZ) {

                D_ERROR(DebugPrint("command wasn't REG_SZ in LoadRegCommands.");)
                pszzNew = NULL;
                goto Exit;
            }

            ulAllocSize += dwSize;
        }

        dwIndex++;

    } while(lResult == ERROR_SUCCESS);



    if (lResult != ERROR_FILE_NOT_FOUND) {

        D_ERROR(DebugPrint("RegQueryValueEx in LoadRegCommands failed for a reason besides ERROR_FILE_NOT_FOUND.");)
        pszzNew = NULL;
        goto Exit;
    }


    // Allocate
    //
    ulAllocSize++;  // double-null terminator accounting
    pszzNew = (LPSTR)ALLOCATE_MEMORY(ulAllocSize);

    //
    // Check errors for either the Alloc or ReAlloc
    //
    if (pszzNew == NULL) {

        D_ERROR(DebugPrint("had a failure doing an alloc or a realloc in LoadRegCommands. Heap size %d",
      	     ulAllocSize);)
        goto Exit;  // pszzNew already NULL
    }

    // Set pszStr to point to the next location to load.
    pszStr = pszzNew;

    while (*pszStr)  // move to next open slot in buffer if need be (append only)
    {
      pszStr += lstrlenA(pszStr) + 1;
    }

    // Did we go to far?
    //
    ASSERT ((ULONG)(pszStr - pszzNew) < ulAllocSize);

    // Read in and add strings to the (rest of the) buffer.
    //
    dwIndex = CMD_INDEX_START;

    dwSize = ulAllocSize - (DWORD)(pszStr - pszzNew);

    do {

        wsprintfA(szValue, "%d", dwIndex);

        lResult = RegQueryValueExA(
            hKeyCommand,
            szValue,
            NULL,
            NULL,
            (VOID *)pszStr,
            &dwSize
            );

        if (lResult == ERROR_SUCCESS) {

            pszStr += dwSize;  // includes terminating null
        }

        dwIndex++;
        dwSize = ulAllocSize - (DWORD)(pszStr - pszzNew);

    } while (lResult == ERROR_SUCCESS);


    if (lResult != ERROR_FILE_NOT_FOUND) {

        D_ERROR(DebugPrint("2nd RegQueryValueEx in LoadRegCommands failed for a reason besides ERROR_FILE_NOT_FOUND.");)
        FREE_MEMORY(pszzNew);
        pszzNew = NULL;
        goto Exit;
    }

    // Did we go to far?
    //
    ASSERT ((ULONG)(pszStr - pszzNew) < ulAllocSize);

    // no need to put in the final double-null null, size this buffer was already zerod.

Exit:
    RegCloseKey(hKeyCommand);
    return pszzNew;
}




int Mystrncmp(char *dst, char *src, long count)
{
    DWORD   CharactersMatched=0;

    while (count) {

	if (*dst != *src) {

	    return 0;
        }

	if (*src == 0) {

            return CharactersMatched;
        }

	dst++;
	src++;
	count--;
        CharactersMatched++;

    }
    return CharactersMatched;
}

int strncmpi(char *dst, char *src, long count)
{
    while (count) {
	if (toupper(*dst) != toupper(*src))
	    return 1;
	if (*src == 0)
	    return 0;
	dst++;
	src++;
	count--;
    }
    return 0;
}





CHAR
ctox(
    BYTE    c
    )

{

    if ( (c >= '0') && (c <= '9')) {

        return c-'0';

    }

    if ( (c >= 'A') && (c <= 'F')) {

        return (c-'A')+10;
    }

    if ( (c >= 'a') && (c <= 'f')) {

        return (c-'a')+10;
    }

    return 0;
}


BOOL
ExpandMacros(LPSTR pszRegResponse,
    LPSTR pszExpanded,
    LPDWORD pdwValLen,
    MODEMMACRO * pMdmMacro,
    DWORD cbMacros)
{
    LPSTR  pszValue;
    DWORD  cbTmp;
    BOOL   bFound;
    LPSTR  pchTmp;
    DWORD  i;

    pszValue = pszExpanded;

    for ( ; *pszRegResponse; ) {
        //
        // check for a macro
        //
        if ( *pszRegResponse == LMSCH ) {

            // <cr>
            //
            if (!strncmpi(pszRegResponse,CR_MACRO,CR_MACRO_LENGTH)) {

                *pszValue++ = CR;
                pszRegResponse += CR_MACRO_LENGTH;
                continue;
            }

            // <lf>
            //
            if (!strncmpi(pszRegResponse,LF_MACRO,LF_MACRO_LENGTH)) {

                *pszValue++ = LF;
                pszRegResponse += LF_MACRO_LENGTH;
                continue;
            }

            // <hxx>
            //
            if ((pszRegResponse[1] == 'h' || pszRegResponse[1] == 'H')
                &&
                isxdigit(pszRegResponse[2])
                &&
                isxdigit(pszRegResponse[3])
                &&
                pszRegResponse[4] == RMSCH ) {

                *pszValue++ = (char) ((ctox(pszRegResponse[2]) << 4) + ctox(pszRegResponse[3]));
                pszRegResponse += 5;
                continue;
            }

            // <macro>
            //
            if (pMdmMacro) {

                bFound = FALSE;

                // Check for a matching macro.
                //
                for (i = 0; i < cbMacros; i++) {

                    cbTmp = lstrlenA(pMdmMacro[i].MacroName);
                    if (!strncmpi(pszRegResponse, pMdmMacro[i].MacroName, cbTmp)) {

                        pchTmp = pMdmMacro[i].MacroValue;

                        while (*pchTmp) {

                            *pszValue++ = *pchTmp++;
                        }

                        pszRegResponse += cbTmp;
                        bFound = TRUE;
                        break;
                    }
                }

                // Did we get a match?
                //
                if (bFound) {

                    continue;
                }
            }  // <macro>
        } // LMSCH

          // No matches, copy the character verbatim.
          //
          *pszValue++ = *pszRegResponse++;
    } // for

    *pszValue = 0;
    if (pdwValLen)
    {
      *pdwValLen = (DWORD)(pszValue - pszExpanded);
    }

    return TRUE;
}








//
//
//  taken from common
//
//
//








#define TRACE_MSG(_x)

// Common key flags for OpenCommonResponseskey() and OpenCommonDriverKey().
typedef enum
{
    CKFLAG_OPEN = 0x0001,
    CKFLAG_CREATE = 0x0002
    
} CKFLAGS;

static TCHAR const  c_szBackslash[]      = TEXT("\\");
static TCHAR const  c_szSeparator[]      = TEXT("::");
static TCHAR const  c_szFriendlyName[]   = TEXT("FriendlyName"); // REGSTR_VAL_FRIENDLYNAME
static TCHAR const  c_szDeviceType[]     = TEXT("DeviceType");   // REGSTR_VAL_DEVTYPE
static TCHAR const  c_szAttachedTo[]     = TEXT("AttachedTo");
static TCHAR const  c_szDriverDesc[]     = TEXT("DriverDesc");   // REGSTR_VAL_DRVDESC
static TCHAR const  c_szManufacturer[]   = TEXT("Manufacturer");
static TCHAR const  c_szRespKeyName[]    = TEXT("ResponsesKeyName");

TCHAR const FAR c_szRefCount[]       = TEXT("RefCount");
TCHAR const FAR c_szResponses[]      = TEXT("Responses");

#define DRIVER_KEY      REGSTR_PATH_SETUP TEXT("\\Unimodem\\DeviceSpecific")
#define RESPONSES_KEY   TEXT("\\Responses")

#define MAX_REG_KEY_LEN         128
#define CB_MAX_REG_KEY_LEN      (MAX_REG_KEY_LEN * sizeof(TCHAR))

// Count of characters to count of bytes
//
#define CbFromCchW(cch)             ((cch)*sizeof(WCHAR))
#define CbFromCchA(cch)             ((cch)*sizeof(CHAR))
#ifdef UNICODE
#define CbFromCch       CbFromCchW
#else  // UNICODE
#define CbFromCch       CbFromCchA
#endif // UNICODE

#if 0
/*----------------------------------------------------------
Purpose: This function returns the name of the common driver
         type key for the given driver.  We'll use the
         driver description string, since it's unique per
         driver but not per installation (the friendly name
         is the latter).

Returns: TRUE on success
         FALSE on error
Cond:    --
*/
BOOL
OLD_GetCommonDriverKeyName(
    IN  HKEY        hkeyDrv,
    IN  DWORD       cbKeyName,
    OUT LPTSTR      pszKeyName)
    {
    BOOL    bRet = FALSE;      // assume failure
    LONG    lErr;

    lErr = RegQueryValueEx(hkeyDrv, c_szDriverDesc, NULL, NULL,
                                            (LPBYTE)pszKeyName, &cbKeyName);
    if (lErr != ERROR_SUCCESS)
    {
//        TRACE_MSG(TF_WARNING, "RegQueryValueEx(DriverDesc) failed: %#08lx.", lErr);
        goto exit;
    }

    bRet = TRUE;

exit:
    return(bRet);

    }


/*----------------------------------------------------------
Purpose: This function tries to open the *old style* common
         Responses key for the given driver, which used only
         the driver description string for a key name.
         The key is opened with READ access.

Returns: TRUE on success
         FALSE on error
Cond:    --
*/
BOOL
OLD_OpenCommonResponsesKey(
    IN  HKEY        hkeyDrv,
    OUT PHKEY       phkeyResp)
    {
    BOOL    bRet = FALSE;       // assume failure
    LONG    lErr;
    TCHAR   szComDrv[MAX_REG_KEY_LEN];
    TCHAR   szPath[2*MAX_REG_KEY_LEN];

    *phkeyResp = NULL;

    // Get the name (*old style*) of the common driver key.
    if (!OLD_GetCommonDriverKeyName(hkeyDrv, sizeof(szComDrv), szComDrv))
    {
//        TRACE_MSG(TF_ERROR, "OLD_GetCommonDriverKeyName() failed.");
        goto exit;
    }

//    TRACE_MSG(TF_WARNING, "OLD_GetCommonDriverKeyName(): %s", szComDrv);

    // Construct the path to the (*old style*) Responses key.
    lstrcpy(szPath, DRIVER_KEY TEXT("\\"));
    lstrcat(szPath, szComDrv);
    lstrcat(szPath, RESPONSES_KEY);

    // Open the (*old style*) Responses key.
    lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szPath, 0, KEY_READ, phkeyResp);
                                                                
    if (lErr != ERROR_SUCCESS)
    {
//        TRACE_MSG(TF_ERROR, "RegOpenKeyEx(Responses) failed: %#08lx.", lErr);
        goto exit;
    }

    bRet = TRUE;
    
exit:
    return(bRet);
}
#endif

/*----------------------------------------------------------
Purpose: This function finds the name of the common driver
         type key for the given driver.  First it'll look for
         the new style key name ("ResponsesKeyName" value),
         and if that doesn't exist then it'll look for the 
         old style key name ("Description" value), both of
         which are stored in the driver node.

NOTE:    The given driver key handle is assumed to contain
         at least the Description value.
         
Returns: TRUE on success
         FALSE on error
Cond:    --
*/
BOOL
FindCommonDriverKeyName(
    IN  HKEY                hkeyDrv,
    IN  DWORD               cbKeyName,
    OUT LPTSTR              pszKeyName)
{
    BOOL    bRet = TRUE;      // assume *success*
    LONG    lErr;

    // Is the (new style) key name is registered in the driver node?
    lErr = RegQueryValueEx(hkeyDrv, c_szRespKeyName, NULL, NULL, 
                                        (LPBYTE)pszKeyName, &cbKeyName);
    if (lErr == ERROR_SUCCESS)
    {
        goto exit;
    }

    // No. The key name will be in the old style: just the Description.
    lErr = RegQueryValueEx(hkeyDrv, c_szDriverDesc, NULL, NULL, 
                                        (LPBYTE)pszKeyName, &cbKeyName);
    if (lErr == ERROR_SUCCESS)
    {
        goto exit;
    }

    // Couldn't get a key name!!  Something's wrong....
    ASSERT(0);
    bRet = FALSE;    
    
exit:
    return(bRet);
}

#if 1
/*----------------------------------------------------------
Purpose: This function returns the name of the common driver
         type key for the given driver.  The key name is the
         concatenation of 3 strings found in the driver node
         of the registry: the driver description, the manu-
         facturer, and the provider.  (The driver description
         is used since it's unique per driver but not per
         installation (the "friendly" name is the latter).

NOTE:    The component substrings are either read from the 
         driver's registry key, or from the given driver info
         data.  If pdrvData is given, the strings it contains
         are assumed to be valid (non-NULL).

Returns: TRUE on success
         FALSE on error
Cond:    --
*/
BOOL
GetCommonDriverKeyName(
    IN  HKEY                hkeyDrv,    OPTIONAL
    IN  DWORD               cbKeyName,
    OUT LPWSTR              pszKeyName)
    {
    BOOL    bRet = FALSE;      // assume failure
    LONG    lErr;
    DWORD   dwByteCount, cbData;
    // TCHAR   szDescription[MAX_REG_KEY_LEN];
    // TCHAR   szManufacturer[MAX_REG_KEY_LEN];
    // TCHAR   szProvider[MAX_REG_KEY_LEN];
    LPWSTR  lpszDesc, lpszMfct, lpszProv;
    LPWSTR  lpszDescription, lpszManufacturer, lpszProvider;
    
    dwByteCount = 0;
    lpszDesc = NULL;
    lpszMfct = NULL;
    lpszProv = NULL;

    lpszDescription = (LPWSTR)ALLOCATE_MEMORY(MAX_REG_KEY_LEN * 4);
    lpszManufacturer = (LPWSTR)ALLOCATE_MEMORY(MAX_REG_KEY_LEN * 4);
    lpszProvider = (LPWSTR)ALLOCATE_MEMORY(MAX_REG_KEY_LEN * 4);

    // no memory - fail the call

    if ((lpszDescription == NULL) || (lpszManufacturer == NULL) || (lpszProvider == NULL))
    {
        goto exit;
    }

    
    if (hkeyDrv)
    {
        // First see if it's already been registered in the driver node.
        lErr = RegQueryValueExW(hkeyDrv, L"ResponsesKeyName", NULL, NULL, 
                                            (LPBYTE)pszKeyName, &cbKeyName);
        if (lErr == ERROR_SUCCESS)
        {
            bRet = TRUE;
            goto exit;
        }

        // Responses key doesn't exist - read its components from the registry.
        cbData = MAX_REG_KEY_LEN * 2;
        lErr = RegQueryValueExW(hkeyDrv, L"DriverDesc", NULL, NULL, 
                                            (LPBYTE)lpszDescription, &cbData);
        if (lErr == ERROR_SUCCESS)
        {
            // Is the Description string *alone* too long to be a key name?
            // If so then we're hosed - fail the call.
            if (cbData > (MAX_REG_KEY_LEN * 2))
            {
                goto exit;
            }

            dwByteCount = cbData;
            lpszDesc = lpszDescription;

            cbData = MAX_REG_KEY_LEN * 2;
            lErr = RegQueryValueExW(hkeyDrv, L"Manufacturer", NULL, NULL, 
                                            (LPBYTE)lpszManufacturer, &cbData);
            if (lErr == ERROR_SUCCESS)
            {
                // only use the manufacturer name if total string size is ok
                cbData += sizeof(c_szSeparator);
                if ((dwByteCount + cbData) <= (MAX_REG_KEY_LEN * 2))
                {
                    dwByteCount += cbData;
                    lpszMfct = lpszManufacturer;
                }
            }            
                
            cbData = MAX_REG_KEY_LEN * 2;
            lErr = RegQueryValueExW(hkeyDrv, L"ProviderName", NULL, NULL,
                                            (LPBYTE)lpszProvider, &cbData);
            if (lErr == ERROR_SUCCESS)
            {
                // only use the provider name if total string size is ok
                cbData += sizeof(c_szSeparator);
                if ((dwByteCount + cbData) <= (MAX_REG_KEY_LEN * 2))
                {
                    dwByteCount += cbData;
                    lpszProv = lpszProvider;
                }
            }
        }
    }

    // By now we should have a Description string.  If not, fail the call.
    if (!lpszDesc || !lpszDesc[0])
    {
        goto exit;
    }
        
    // Construct the key name string out of its components.
    lstrcpyW(pszKeyName, lpszDesc);
    
    if (lpszMfct && *lpszMfct)
    {
        lstrcatW(pszKeyName, L"::");
        lstrcatW(pszKeyName, lpszMfct);
    }
    
    if (lpszProv && *lpszProv)
    {
        lstrcatW(pszKeyName, L"::");
        lstrcatW(pszKeyName, lpszProv);
    }
    
    // Write the key name to the driver node (we know it's not there already).
    if (hkeyDrv)
    {
        lErr = RegSetValueExW(hkeyDrv, L"ResponsesKeyName" , 0, REG_SZ, 
                        (LPBYTE)pszKeyName, lstrlenW(pszKeyName));
        if (lErr != ERROR_SUCCESS)
        {
//            TRACE_MSG(TF_ERROR, "RegSetValueEx(RespKeyName) failed: %#08lx.", lErr);
            ASSERT(0);
        }
    }
    
    bRet = TRUE;
    
exit:

    if (lpszDescription != NULL)
    {
        FREE_MEMORY(lpszDescription);
    }

    if (lpszDescription != NULL)
    {
        FREE_MEMORY(lpszManufacturer);
    }

    if (lpszProvider != NULL)
    {
        FREE_MEMORY(lpszProvider);
    }

    return(bRet);
    
}

#endif
/*----------------------------------------------------------
Purpose: This function creates the common driver type key 
         for the given driver, or opens it if it already 
         exists, with the requested access.

NOTE:    Either hkeyDrv or pdrvData must be provided.

Returns: TRUE on success
         FALSE on error
Cond:    --
*/
BOOL
OpenCommonDriverKey(
    IN  HKEY                hkeyDrv,    OPTIONAL
    IN  REGSAM              samAccess,
    OUT PHKEY               phkeyComDrv)
    {
    BOOL    bRet = FALSE;       // assume failure
    LONG    lErr;
    HKEY    hkeyDrvInfo = NULL;
    // TCHAR   szComDrv[MAX_REG_KEY_LEN];
    // TCHAR   szPath[2*MAX_REG_KEY_LEN];

    LPWSTR szComDrv;
    LPWSTR szPath;
    DWORD   dwDisp;

    szComDrv = ALLOCATE_MEMORY(4*MAX_REG_KEY_LEN);
    szPath = ALLOCATE_MEMORY(4*MAX_REG_KEY_LEN);

    if ((szComDrv == NULL) || (szPath == NULL))
    {
        goto exit;
    }

    if (!GetCommonDriverKeyName(hkeyDrv, 4*MAX_REG_KEY_LEN, szComDrv))
    {
//        TRACE_MSG(TF_ERROR, "GetCommonDriverKeyName() failed.");
        goto exit;
    }

//    TRACE_MSG(TF_WARNING, "GetCommonDriverKeyName(): %s", szComDrv);

    // Construct the path to the common driver key.
    lstrcpyW(szPath, L"Software\\Microsoft\\Windows\\CurrentVersion\\Unimodem\\DeviceSpecific\\");
    lstrcatW(szPath, szComDrv);

    // Create the common driver key - it'll be opened if it already exists.
    lErr = RegCreateKeyExW(HKEY_LOCAL_MACHINE, szPath, 0, NULL,
            REG_OPTION_NON_VOLATILE, samAccess, NULL, phkeyComDrv, &dwDisp);
    if (lErr != ERROR_SUCCESS)
    {
//        TRACE_MSG(TF_ERROR, "RegCreateKeyEx(common drv) failed: %#08lx.", lErr);
        goto exit;
    }

    bRet = TRUE;

exit:

    if (szComDrv != NULL)
    {
        FREE_MEMORY(szComDrv);
    }

    if (szPath != NULL)
    {
        FREE_MEMORY(szPath);
    }
    return(bRet);

    }


/*----------------------------------------------------------
Purpose: This function opens or creates the common Responses
         key for the given driver, based on the given flags.

Returns: TRUE on success
         FALSE on error
Cond:    --
*/
BOOL
OpenCommonResponsesKey(
    IN  HKEY        hkeyDrv,
    IN  CKFLAGS     ckFlags,
    IN  REGSAM      samAccess,
    OUT PHKEY       phkeyResp,
    OUT LPDWORD     lpdwExisted)
    {
    BOOL    bRet = FALSE;       // assume failure
    LONG    lErr;
    HKEY    hkeyComDrv = NULL;
    REGSAM  sam;
    DWORD   dwRefCount, cbData;

    *phkeyResp = NULL;

    sam = (ckFlags & CKFLAG_CREATE) ? KEY_ALL_ACCESS : KEY_READ;
    if (!OpenCommonDriverKey(hkeyDrv, sam, &hkeyComDrv))
    {
//        TRACE_MSG(TF_ERROR, "OpenCommonDriverKey() failed.");
        goto exit;
    }

    lErr = RegOpenKeyEx(hkeyComDrv, c_szResponses, 0, samAccess, phkeyResp);
    if (lErr != ERROR_SUCCESS)
    {
//        TRACE_MSG(TF_ERROR, "RegOpenKeyEx(common drv) failed: %#08lx.", lErr);
        goto exit;
    }

    bRet = TRUE;

exit:
    if (!bRet)
    {
        // something failed - close any open Responses key
        if (*phkeyResp)
            RegCloseKey(*phkeyResp);
    }

    if (hkeyComDrv)
        RegCloseKey(hkeyComDrv);

    return(bRet);

    }


/*----------------------------------------------------------
Purpose: This function finds the Responses key for the given
         modem driver and returns an open hkey to it.  The
         Responses key may exist in the common driver type
         key, or it may be in the individual driver key.
         The key is opened with READ access.

Returns: TRUE on success
         FALSE on error
Cond:    --
*/
BOOL
OpenResponsesKey(
    IN  HKEY        hkeyDrv,
    OUT PHKEY       phkeyResp)
    {
    LONG    lErr;

    // Try to open the common Responses subkey.
    if (!OpenCommonResponsesKey(hkeyDrv, CKFLAG_OPEN, KEY_READ, phkeyResp, NULL))
    {
#if 0
//        TRACE_MSG(TF_ERROR, "OpenCommonResponsesKey() failed, assume non-existent.");

        // Failing that, open the *old style* common Responses subkey.
        if (!OLD_OpenCommonResponsesKey(hkeyDrv, phkeyResp))
        {
            // Failing that, try to open a Responses subkey in the driver node.
            lErr = RegOpenKeyEx(hkeyDrv, c_szResponses, 0, KEY_READ, phkeyResp);
            if (lErr != ERROR_SUCCESS)
            {
//                TRACE_MSG(TF_ERROR, "RegOpenKeyEx() failed: %#08lx.", lErr);
#endif
                return (FALSE);
#if 0
            }
        }
#endif
    }

    return(TRUE);

    }



#define   EMPTY_NODE_INDEX   (0xffff)
#define   NODE_ARRAY_GROWTH_SIZE   (4000)
#define   MSS_ARRAY_GROWTH_SIZE    (256)


VOID
ResizeNodeArray(
    PNODE_TRACKING   Tracking
    )

{

    if (Tracking->TotalNodes > 0) {
        //
        //  there is an array
        //
        PMATCH_NODE  NewArray;

        NewArray=REALLOCATE_MEMORY(Tracking->NodeArray,Tracking->NextFreeNodeIndex*Tracking->NodeSize);

        if (NewArray != NULL) {
            //
            //  it reallocated ok
            //
            Tracking->NodeArray=NewArray;
            Tracking->TotalNodes=Tracking->NextFreeNodeIndex;

        } else {
            //
            //  failed, interesting, just leave the current one in place
            //

        }
    }

    D_TRACE(DbgPrint("Node array size %d\n",Tracking->NextFreeNodeIndex*Tracking->NodeSize);)
//    DbgPrint("Node array size %d\n",Tracking->NextFreeNodeIndex*Tracking->NodeSize);

    return;
}



PVOID
GetNewNode(
   PNODE_TRACKING   Tracking
   )

{

    PVOID   NewNode;

    if (Tracking->NextFreeNodeIndex == Tracking->TotalNodes) {
        //
        //  out of nodes
        //
        PMATCH_NODE  NewArray;
        ULONG        NewSize=(Tracking->TotalNodes+Tracking->GrowthSize);

        if (NewSize > (EMPTY_NODE_INDEX-1)) {

            NewSize =  EMPTY_NODE_INDEX-1;
        }

        if (Tracking->TotalNodes == 0) {
            //
            //  no array yet, just alloc
            //
            NewArray=ALLOCATE_MEMORY(NewSize*Tracking->NodeSize);

        } else {
            //
            //  already have the array, realloc
            //
            NewArray=REALLOCATE_MEMORY(Tracking->NodeArray,NewSize*Tracking->NodeSize);
        }

        if (NewArray != NULL) {

            Tracking->NodeArray=NewArray;
            Tracking->TotalNodes=NewSize;
        } else {

            return NULL;
        }

    }

    NewNode=(PUCHAR)Tracking->NodeArray+(Tracking->NextFreeNodeIndex*Tracking->NodeSize);

    Tracking->NextFreeNodeIndex++;

    return NewNode;

}

PMATCH_NODE
GetNewMatchNode(
    PROOT_MATCH   RootMatchNode
    )

{

    PMATCH_NODE   NewNode=(PMATCH_NODE)GetNewNode(&RootMatchNode->MatchNode);

    if (NewNode != NULL) {

        NewNode->FollowingCharacter=EMPTY_NODE_INDEX;
        NewNode->NextAltCharacter=EMPTY_NODE_INDEX;
        NewNode->Mss=EMPTY_NODE_INDEX;
        NewNode->Character=0;
        NewNode->Depth=0;
    }

    return NewNode;
}


PMSS
GetNewMssNode(
    PROOT_MATCH   RootMatchNode
    )

{

    PMSS   NewNode=(PMSS)GetNewNode(&RootMatchNode->MssNode);

    if (NewNode != NULL) {

        ZeroMemory(NewNode,sizeof(MSS));

    }

    return NewNode;
}

PMATCH_NODE
GetNodeFromIndex(
    PROOT_MATCH   RootMatchNode,
    USHORT        Index
    )

{

    PMATCH_NODE NodeArray=(PMATCH_NODE)RootMatchNode->MatchNode.NodeArray;

    return  &NodeArray[Index];
}

PMATCH_NODE
GetFollowingCharacter(
    PROOT_MATCH   RootMatchNode,
    PMATCH_NODE   CurrentNode
    )

{
    PMATCH_NODE NodeArray=(PMATCH_NODE)RootMatchNode->MatchNode.NodeArray;
    USHORT      Index=CurrentNode->FollowingCharacter;

    return (Index == EMPTY_NODE_INDEX) ? NULL : &NodeArray[Index];
}


PMATCH_NODE
GetNextAltCharacter(
    PROOT_MATCH   RootMatchNode,
    PMATCH_NODE   CurrentNode
    )

{
    PMATCH_NODE NodeArray=(PMATCH_NODE)RootMatchNode->MatchNode.NodeArray;
    USHORT      Index=CurrentNode->NextAltCharacter;

    return (Index == EMPTY_NODE_INDEX) ? NULL : &NodeArray[Index];
}

USHORT
GetIndexOfNode(
    PROOT_MATCH   RootMatchNode,
    PMATCH_NODE   CurrentNode
    )

{
    PMATCH_NODE NodeArray=(PMATCH_NODE)RootMatchNode->MatchNode.NodeArray;

    return  (USHORT)((ULONG_PTR)(CurrentNode-NodeArray));

}

USHORT
GetIndexOfMssNode(
    PROOT_MATCH   RootMatchNode,
    PMSS          CurrentNode
    )

{
    PMSS NodeArray=(PMSS)RootMatchNode->MssNode.NodeArray;

    return  (USHORT)((ULONG_PTR)(CurrentNode-NodeArray));

}


PMSS
GetMssNode(
    PROOT_MATCH   RootMatchNode,
    PMATCH_NODE   CurrentNode
    )

{
    PMSS        MssArray= (PMSS)RootMatchNode->MssNode.NodeArray;

    return &MssArray[CurrentNode->Mss];

}

PMATCH_NODE
AddNextCharacterToTree(
    PROOT_MATCH   RootMatchNode,
    PMATCH_NODE   CurrentNode,
    UCHAR        NextCharacter
    )

{

    PMATCH_NODE   NewNode;
    USHORT        CurrentNodeIndex;
    UCHAR         CurrentDepth;

    //
    // save the index of the current, node incase the array is grown and it moves in memory.
    //
    CurrentNodeIndex=GetIndexOfNode(RootMatchNode,CurrentNode);
    CurrentDepth=CurrentNode->Depth;

    //
    //  get this first
    //
    NewNode=GetNewMatchNode(RootMatchNode);

    if (NewNode == NULL) {

        return FALSE;
    }

    CurrentNode=GetNodeFromIndex(RootMatchNode,CurrentNodeIndex);

    ASSERT(CurrentDepth == CurrentNode->Depth);

    //
    //  init these now;
    //
    NewNode->Character=NextCharacter;

    NewNode->Depth=CurrentDepth+1;

    if (CurrentNode->FollowingCharacter != EMPTY_NODE_INDEX) {
        //
        //  there is already one or more characters in this position,
        //  we will need to insert this in the right place
        //
        PMATCH_NODE   CurrentList;
        PMATCH_NODE   PreviousNode=NULL;

        CurrentList=GetFollowingCharacter(RootMatchNode,CurrentNode);

        while (CurrentList != NULL) {

            ASSERT(CurrentList->Character != NextCharacter);

            if (CurrentList->Character > NextCharacter) {
                //
                //  our new character belongs before the current one;
                //
                NewNode->NextAltCharacter=GetIndexOfNode(RootMatchNode,CurrentList);

                if (PreviousNode == NULL) {
                    //
                    //  first one in list
                    //
                    CurrentNode->FollowingCharacter=GetIndexOfNode(RootMatchNode,NewNode);
                    break;

                } else {
                    //
                    //  Not, the first in list, just insert it
                    //
                    if (PreviousNode != NULL)
                    {
                        PreviousNode->NextAltCharacter=GetIndexOfNode(RootMatchNode,NewNode);
                    }
                    break;

                }
            } else {
                //
                //  it goes after this one, keep looking
                //
                PreviousNode=CurrentList;
                CurrentList=GetNextAltCharacter(RootMatchNode,CurrentList);
            }

        }

        if (CurrentList == NULL) {
            //
            //  We went all the way through, This one goes at the end of the list
            //
            if (PreviousNode != NULL)
            {
                PreviousNode->NextAltCharacter=GetIndexOfNode(RootMatchNode,NewNode);
            }
        }

    } else {
        //
        //  First one, Our node will be the first one
        //
        CurrentNode->FollowingCharacter=GetIndexOfNode(RootMatchNode,NewNode);

    }

    return NewNode;

}


PMATCH_NODE
_inline
FindNextNodeFromCharacter(
    PROOT_MATCH   RootMatchNode,
    PMATCH_NODE   CurrentNode,
    UCHAR         Character
    )

{
    PMATCH_NODE   List;

    List=GetFollowingCharacter(RootMatchNode,CurrentNode);

    while (List != NULL) {

        ASSERT(List->Depth == (CurrentNode->Depth+1))

        if (List->Character == Character) {

            return List;
        }

        List=GetNextAltCharacter(RootMatchNode,List);

    }

    return NULL;

}







BOOL
AddResponseToTree(
    PROOT_MATCH    RootMatchNode,
    PSTR   ResponseToAdd,
    DWORD  ResponseLength,
    USHORT   MssIndex,
    PMATCH_NODE  RootOfTree
    )

{

    PMATCH_NODE   Current=RootOfTree;
    PMATCH_NODE   NextNode;
    DWORD         i;
    BOOL          bFound;

    for (i=0; i<ResponseLength; i++) {

        UCHAR   CurrentCharacter=(UCHAR)toupper(ResponseToAdd[i]);

        NextNode=FindNextNodeFromCharacter(
            RootMatchNode,
            Current,
            CurrentCharacter
            );

        if (NextNode != NULL) {
            //
            //  next node that this response needs already exists, proceed
            //
            Current=NextNode;

            ASSERT(Current->Character == CurrentCharacter);

        } else {
            //
            //  not found
            //
            Current=AddNextCharacterToTree(
                RootMatchNode,
                Current,
                CurrentCharacter
                );

            if (Current == NULL) {
                //
                //  failed to add node
                //
                return FALSE;
            }

            ASSERT(Current->Character == CurrentCharacter);
        }
    }

    //
    //  We got to the end node for this response. Set the MSS.
    //  It is possible that this could be in the middle of another
    //  bigger response.
    //

    //
    //  it is possible that this node already has a mss, just replace the old one. They should be
    //  the same anyway.

    Current->Mss=MssIndex;

    return TRUE;

}



DWORD
MatchResponse(
    PROOT_MATCH    RootMatchNode,
    PUCHAR         StringToMatch,
    DWORD          LengthToMatch,
    MSS           *Mss,
    PSTR           CurrentCommand,
    DWORD          CurrentCommandLength,
    PVOID         *MatchingContext
    )

{

    PMATCH_NODE   Current=RootMatchNode->MatchNode.NodeArray;
    PMATCH_NODE   NextNode;
    DWORD         i=0;
    BOOL          bFound;
    LONG          MatchedCharacters;
    UCHAR         CharToMatch;

    PMATCH_NODE   ContextNode=(PMATCH_NODE)*MatchingContext;

    //
    //  assume no context returned
    //
    *MatchingContext=NULL;

    if (LengthToMatch == 1) {
        //
        //  no contect for first match
        //
        ContextNode=NULL;
    }


    if (ContextNode != NULL) {
        //
        //  A starting node was passed in from a previous partial match
        //
        ASSERT((DWORD)ContextNode->Depth+1 == LengthToMatch);
        ASSERT(toupper(StringToMatch[ContextNode->Depth-1])==ContextNode->Character);

        Current=ContextNode;
        i=ContextNode->Depth;
    }


    for (; i<LengthToMatch; i++) {

        CharToMatch=(UCHAR)toupper(StringToMatch[i]);

        NextNode=FindNextNodeFromCharacter(
            RootMatchNode,
            Current,
            CharToMatch
            );

        if (NextNode != NULL) {
            //
            //  next node that this response needs already exists, proceed
            //
            Current=NextNode;

        } else {

            //
            //  no match, check for echo
            //
            MatchedCharacters=Mystrncmp(
                StringToMatch,
                CurrentCommand,
                LengthToMatch
                );

            if (MatchedCharacters == 0) {

                return UNRECOGNIZED_RESPONSE;
            }

            if ((DWORD)MatchedCharacters == CurrentCommandLength) {

                return ECHO_RESPONSE;

            }

            return PARTIAL_RESPONSE;

        }
    }

    if (NextNode->Mss != EMPTY_NODE_INDEX) {
        //
        //  This node represents a complete responses from the inf
        //
        *Mss= *GetMssNode(RootMatchNode,NextNode);

        if (NextNode->FollowingCharacter == EMPTY_NODE_INDEX) {
            //
            //  This is the complete response, no additional characters follow this
            //  node which could be part of a bigger response;
            //
            return GOOD_RESPONSE;

        } else {
            //
            //  There more characters following this positive match, there
            //  may be more characters that will complete the long response
            //
            return POSSIBLE_RESPONSE;
        }
    }

    if (NextNode->FollowingCharacter != EMPTY_NODE_INDEX) {
        //
        //  We have a potential match up to the current number of characters that we have
        //  matched
        //
        *MatchingContext=NextNode;
        return PARTIAL_RESPONSE;
    }

    ASSERT(0);
    return UNRECOGNIZED_RESPONSE;

}




VOID
FreeResponseMatch(
    PVOID   Root
    )

{
    PROOT_MATCH   RootMatchNode=(PROOT_MATCH)Root;

    if (RootMatchNode != NULL) {

        if (RootMatchNode->MatchNode.NodeArray != NULL) {

            FREE_MEMORY(RootMatchNode->MatchNode.NodeArray);
        }

        if (RootMatchNode->MssNode.NodeArray != NULL) {

            FREE_MEMORY(RootMatchNode->MssNode.NodeArray);
        }

        FREE_MEMORY(RootMatchNode);
    }

    return;
}


PVOID WINAPI
NewerBuildResponsesLinkedList(
    HKEY    hKey
    )
{
    DWORD   dwRegRet;
    HKEY    hKeyResponses;
    DWORD   dwValueSize, dwDataSize, dwDataType;
    DWORD   dwIndex;
    CHAR    pszValue[MAX_PATH], pszExpandedValue[MAX_PATH];
    BOOL    bResult;
    DWORD   i;

    PROOT_MATCH   RootMatchNode;
    PMATCH_NODE   NewNode;
    MSS       *NewMss;

    RootMatchNode=ALLOCATE_MEMORY(sizeof(ROOT_MATCH));

    if (RootMatchNode == NULL) {

        return NULL;
    }

    RootMatchNode->MatchNode.TotalNodes=0;
    RootMatchNode->MatchNode.NextFreeNodeIndex=0;
    RootMatchNode->MatchNode.NodeSize=sizeof(MATCH_NODE);
    RootMatchNode->MatchNode.GrowthSize=NODE_ARRAY_GROWTH_SIZE;

    RootMatchNode->MssNode.TotalNodes=0;
    RootMatchNode->MssNode.NextFreeNodeIndex=0;
    RootMatchNode->MssNode.NodeSize=sizeof(MSS);
    RootMatchNode->MssNode.GrowthSize=MSS_ARRAY_GROWTH_SIZE;


    //
    //  allocate the root of the tree.
    //
    NewNode=GetNewMatchNode(RootMatchNode);

    if (NewNode == NULL) {

        goto ExitNoKey;
    }
#if DBG
    NewNode=NULL;
#endif

    // Open the Responses key.
    //
    if (!OpenResponsesKey(hKey, &hKeyResponses)) {

        D_ERROR(DebugPrint("was unable to open the Responses key.");)
        goto Exit;
    }


    //
    //  add in the standard responses
    //
    for (i=0; i<sizeof(DefResponses)/sizeof(DEF_RESPONSE);i++) {

        NewMss=GetNewMssNode(RootMatchNode);

        if (NewMss == NULL) {

            goto Exit;
        }

        //
        //  copy the mss from the packed registry version to the aligned in mem verison
        //
        *NewMss=DefResponses[i].Mss;


        // expand <cr>, <lf>, <hxx>, and << macros
        //
        if (!ExpandMacros(DefResponses[i].Response, pszExpandedValue, &dwValueSize, NULL, 0)) {

            D_ERROR(DebugPrint("couldn't expand macro for '%s'.", pszValue);)
            goto Exit;
        }


        bResult=AddResponseToTree(
            RootMatchNode,
            pszExpandedValue,
            dwValueSize,
            GetIndexOfMssNode(RootMatchNode,NewMss),
            GetNodeFromIndex(RootMatchNode,0) //NewNode
            );

        if (!bResult) {

            FREE_MEMORY(NewMss);
            goto Exit;
        }


    }


    // Read in responses and build the list
    //
    dwIndex=0;

    while (1) {

        REGMSS    RegMss;


        dwValueSize = MAX_PATH;
        dwDataSize = sizeof(REGMSS);

        dwRegRet = RegEnumValueA(
                       hKeyResponses,
                       dwIndex,
                       pszValue,
                       &dwValueSize,
                       NULL,
                       &dwDataType,
                       (BYTE *)&RegMss,
                       &dwDataSize
                       );

        if (dwRegRet != ERROR_SUCCESS) {

            if (dwRegRet != ERROR_NO_MORE_ITEMS) {

                D_ERROR(DebugPrint("couldn't read response #%d from the registry. (error = %d)", dwIndex, dwRegRet);)
                goto Exit;
            }

            break;

        }

        if (dwDataSize != sizeof(REGMSS) || dwDataType != REG_BINARY) {
            //
            //  something is wrong with this response, just move on
            //
            D_ERROR(DebugPrint("response data from registry was in an invalid format.");)
            dwIndex++;
            continue;
        }

        NewMss=GetNewMssNode(RootMatchNode);

        if (NewMss == NULL) {

            goto Exit;
        }

        //
        //  copy the mss from the packed registry version to the aligned in mem verison
        //
        NewMss->bResponseState=      RegMss.bResponseState;
        NewMss->bNegotiatedOptions=  RegMss.bNegotiatedOptions;

        if (RegMss.dwNegotiatedDCERate != 0) {
            //
            //  the inf has a DCE speed, save that
            NewMss->NegotiatedRate=RegMss.dwNegotiatedDCERate;
            NewMss->Flags=MSS_FLAGS_DCE_RATE;

        } else {
            //
            //  no DCE, see if it DTE
            //
            if (RegMss.dwNegotiatedDTERate != 0) {

                NewMss->NegotiatedRate=RegMss.dwNegotiatedDTERate;
                NewMss->Flags=MSS_FLAGS_DTE_RATE;
            }
        }



//        NewMss->dwNegotiatedDCERate= RegMss.dwNegotiatedDCERate;
//        NewMss->dwNegotiatedDTERate= RegMss.dwNegotiatedDTERate;


        // expand <cr>, <lf>, <hxx>, and << macros
        //
        if (!ExpandMacros(pszValue, pszExpandedValue, &dwValueSize, NULL, 0)) {

            D_ERROR(DebugPrint("couldn't expand macro for '%s'.", pszValue);)
            goto Exit;
        }


        bResult=AddResponseToTree(
            RootMatchNode,
            pszExpandedValue,
            dwValueSize,
            GetIndexOfMssNode(RootMatchNode,NewMss),
            GetNodeFromIndex(RootMatchNode,0) //NewNode
            );

        if (!bResult) {

            goto Exit;
        }

        dwIndex++;
    }

    ResizeNodeArray(&RootMatchNode->MatchNode);
    ResizeNodeArray(&RootMatchNode->MssNode);


    RegCloseKey(hKeyResponses);
    return RootMatchNode;



Exit:

    RegCloseKey(hKeyResponses);

ExitNoKey:

    FreeResponseMatch(RootMatchNode);

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\debugmem\debug.h ===
typedef struct _MEMORY_HEADER {

    PVOID        SelfPointer;

    LIST_ENTRY   ListEntry;
    DWORD        RequestedSize;
    DWORD        LineNumber;
    LPSTR        File;

} MEMORY_HEADER, *PMEMORY_HEADER;

#if defined(_WIN64)
#define MEMORY_HEADER_SPTR_CHKVAL  ((PVOID)0xbbbbbbbbbbbbbbbb)
#else  // !_WIN64
#define MEMORY_HEADER_SPTR_CHKVAL  ((PVOID)0xbbbbbbbb)
#endif // !_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\debugmem\debug.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    debug.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windows.h>
#include <windowsx.h>

#include <debugmem.h>

#include "debug.h"

#define BREAK_ON_CORRUPTION 1

DEBUG_MEMORY_CONTROL_BLOCK   DebugMemoryControl;



VOID WINAPI
DebugMemoryProcessAttach(
    LPCSTR    Name
    )

{
    DebugMemoryControl.PrivateHeapHandle=HeapCreate(
        0,
        UNIMODEM_INITIAL_HEAPSIZE,
        0
        );

    InitializeCriticalSection(
        &DebugMemoryControl.MemoryListLock
        );

    InitializeListHead(&DebugMemoryControl.MemoryList);

    lstrcpyA(DebugMemoryControl.ModuleName,Name);

    DebugMemoryControl.ModuleNameLength=lstrlenA(DebugMemoryControl.ModuleName);

    return;

}


static VOID WINAPIV
DebugPrint(
    LPSTR    FormatString,
    ...
    )

{
    va_list        VarArg;
    CHAR           OutBuffer[1024];


    lstrcpyA(OutBuffer,DebugMemoryControl.ModuleName);

    lstrcatA(OutBuffer,": ");

    va_start(VarArg,FormatString);

    wvsprintfA(
        OutBuffer+lstrlenA(OutBuffer),
        FormatString,
        VarArg
        );

    lstrcatA(OutBuffer,"\n");

    OutputDebugStringA(OutBuffer);

    return;

}





PVOID WINAPI
PrivateAllocate(
    DWORD    Size,
    DWORD    Line,
    LPSTR    File
    )

{

    PMEMORY_HEADER    Memory;
    DWORD             RealSize=Size+sizeof(DWORD)+sizeof(MEMORY_HEADER);

    Memory=HeapAlloc(DebugMemoryControl.PrivateHeapHandle,HEAP_ZERO_MEMORY,RealSize);

    if (Memory == NULL) {

        return Memory;
    }

    EnterCriticalSection(&DebugMemoryControl.MemoryListLock);

    InsertHeadList(
        &DebugMemoryControl.MemoryList,
        &Memory->ListEntry
        );

    LeaveCriticalSection(&DebugMemoryControl.MemoryListLock);

    Memory->SelfPointer=Memory;

    Memory->RequestedSize=Size;
    Memory->LineNumber=Line;
    Memory->File=File;

    FillMemory(
       ((LPBYTE)(Memory+1)+Size),
       sizeof(DWORD),
       0xcc
       );

    return (LPBYTE)(Memory+1);

}

BOOL WINAPI
ValidateMemory(
    PVOID   Memory
    )

{


    PMEMORY_HEADER    Header=(PMEMORY_HEADER)((LPBYTE)Memory-sizeof(MEMORY_HEADER));

    DWORD    Size;
    LPBYTE   End;
    LPBYTE   EndValue;


    _try {

        Size=Header->RequestedSize;
        End=(LPBYTE)Memory+Size;
        EndValue=End+sizeof(DWORD);


        if (Header->SelfPointer == Header) {

            while (End < EndValue) {

                if (*End != 0xcc) {

                    DebugPrint("Memory written past end of block %p, at %p\a",Memory,End);
                    DebugPrint("Info, Size=%d, %s(%d)\a",Header->RequestedSize,Header->File,Header->LineNumber);
#ifdef BREAK_ON_CORRUPTION
                    DebugBreak();
#endif
                }

                End++;
            }
        } else {

            DebugPrint("Memory Header Corrupt for %p",Memory);
#ifdef BREAK_ON_CORRUPTION
            DebugBreak();
#endif
            return FALSE;
        }


    } _except (EXCEPTION_EXECUTE_HANDLER) {

        DebugPrint("Fault Validating memory block %p",Memory);
#ifdef BREAK_ON_CORRUPTION
        DebugBreak();
#endif
        return FALSE;
    }

    return TRUE;
}



VOID WINAPI
PrivateFree(
    PVOID   Memory
    )

{


    PMEMORY_HEADER    Header=(PMEMORY_HEADER)((LPBYTE)Memory-sizeof(MEMORY_HEADER));


    _try {

        if (ValidateMemory(Memory)) {

            Header->SelfPointer= MEMORY_HEADER_SPTR_CHKVAL;

            EnterCriticalSection(&DebugMemoryControl.MemoryListLock);

            RemoveEntryList(&Header->ListEntry);

            LeaveCriticalSection(&DebugMemoryControl.MemoryListLock);

            HeapFree(DebugMemoryControl.PrivateHeapHandle,0,Header);
        }

    } _except (EXCEPTION_EXECUTE_HANDLER) {

        DebugPrint("Fault freeing memory block %p",Memory);
    }
}


PVOID WINAPI
PrivateReallocate(
    PVOID    Memory,
    DWORD    NewSize
    )

{

    PMEMORY_HEADER    OldHeader=(PMEMORY_HEADER)((LPBYTE)Memory-sizeof(MEMORY_HEADER));

    LPBYTE   NewMemory;


    NewMemory=PrivateAllocate(
        NewSize,
        OldHeader->LineNumber,
        OldHeader->File
        );

    if (NewMemory == NULL) {

        return NewMemory;
    }

    CopyMemory(
        NewMemory,
        Memory,
        (OldHeader->RequestedSize < NewSize) ? OldHeader->RequestedSize : NewSize
        );

    PrivateFree(Memory);

    return NewMemory;

}

DWORD
PrivateSize(
    PVOID    Memory
    )

{

    PMEMORY_HEADER    Header=(PMEMORY_HEADER)((LPBYTE)Memory-sizeof(MEMORY_HEADER));

    ValidateMemory(Memory);

    return Header->RequestedSize;
}

VOID WINAPI
DebugMemoryProcessDetach(
    VOID
    )

{

    while (!IsListEmpty(&DebugMemoryControl.MemoryList)) {

        PLIST_ENTRY      ListElement;
        PMEMORY_HEADER   Header;

        ListElement=RemoveHeadList(
            &DebugMemoryControl.MemoryList
            );

        Header=CONTAINING_RECORD(ListElement,MEMORY_HEADER,ListEntry);

        DebugPrint("Leak, Size=%d, %s(%d)\a",Header->RequestedSize,Header->File,Header->LineNumber);

    }

    HeapDestroy(DebugMemoryControl.PrivateHeapHandle);

    DebugMemoryControl.PrivateHeapHandle=NULL;

    DeleteCriticalSection(&DebugMemoryControl.MemoryListLock);

    ZeroMemory(&DebugMemoryControl,sizeof(DebugMemoryControl));

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\atmini\wave.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    wave.c

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"

#define WAVE_STREAM_NONE       0
#define WAVE_STREAM_PLAYBACK   1
#define WAVE_STREAM_RECORD     2
#define WAVE_STREAM_FULLDUPLEX 3


#define WAVE_STATE_IDLE                      0
#define WAVE_STATE_FAILURE                  99

#define WAVE_STATE_START_SET_FORMAT          1
#define WAVE_STATE_START_STREAM              2
#define WAVE_STATE_COMPLETE_START            3
#define WAVE_STATE_STREAM_RUNNING            4

#define WAVE_STATE_STOP_STREAMING            10

#define WAVE_STATE_STOP_WAIT_FOR_RESPONSE    11
#define WAVE_STATE_STOPPING_PLAY             12
#define WAVE_STATE_SEND_STOP_PLAY            13

#define WAVE_STATE_STOP_DUPLEX_GOT_DLE_ETX   14
#define WAVE_STATE_STOP_CLEAR_RECIEVE_QUEUE  15
#define WAVE_STATE_STOP_SEND_STOP            16

#define WAVE_STATE_STOP_DUPLEX_GET_RESPONSE  17
#define WAVE_STATE_COMPLETE_STOP_DUPLEX      18

#define WAVE_STATE_OPEN_HANDSET                      20
#define WAVE_STATE_OPENED_HANDSET                    21

#define WAVE_STATE_CLOSE_HANDSET                     22
#define WAVE_STATE_CLOSED_HANDSET                    23

#define WAVE_STATE_HANDSET_OPEN_RETURN_RESULT        24

#define WAVE_STATE_HANDSET_OPEN_FAILED               25



BYTE    FlushBuffer[1024];


VOID
WaveDuplexStopCompleteHandler(
    HANDLE      Context,
    DWORD       Status
    );


VOID WINAPI
WaveStopWriteCompletionHandler(
    DWORD              ErrorCode,
    DWORD              BytesWritten,
    LPOVERLAPPED       Overlapped
    )

{

    PUM_OVER_STRUCT    UmOverlapped=(PUM_OVER_STRUCT)Overlapped;

    D_TRACE(DebugPrint("Write Complete\n");)

    FreeOverStruct(UmOverlapped);

    return;

}





VOID
OpenHandsetCompleteHandler(
    HANDLE      Context,
    DWORD       Status
    )

{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)Context;
    DWORD             ModemStatus;
    BOOL              ExitLoop=FALSE;

    DWORD             CommandFlags;


    ASSERT(COMMAND_TYPE_WAVE_ACTION == ModemControl->CurrentCommandType);

    D_INIT(UmDpf(ModemControl->Debug,"OpenHandsetCompleteHandler");)

    while (!ExitLoop) {

        switch (ModemControl->Wave.State) {

            case WAVE_STATE_OPEN_HANDSET:

                ASSERT(Status == ERROR_SUCCESS);

                CancelModemEvent(
                    ModemControl->ModemEvent
                    );

                StartDleMonitoring(ModemControl->Dle);

                SetVoiceBaudRate(
                    ModemControl->FileHandle,
                    ModemControl->Debug,
                    ModemControl->RegInfo.VoiceBaudRate
                    );


                ModemControl->Wave.State=WAVE_STATE_OPENED_HANDSET;

                LogString(ModemControl->Debug, IDS_OPEN_HANDSET);


                Status=IssueCommand(
                    ModemControl->CommandState,
                    ModemControl->CurrentCommandStrings,
                    OpenHandsetCompleteHandler,
                    ModemControl,
                    5*1000,
                    0
                    );


                if (Status == ERROR_IO_PENDING) {

                    ExitLoop=TRUE;

                }

                break;

            case WAVE_STATE_OPENED_HANDSET:

                FREE_MEMORY(ModemControl->CurrentCommandStrings);

                ModemControl->CurrentCommandStrings=NULL;


                if (Status == ERROR_SUCCESS) {

                    ModemControl->ConnectionState=CONNECTION_STATE_HANDSET_OPEN;
                    ModemControl->Wave.State=WAVE_STATE_HANDSET_OPEN_RETURN_RESULT;

                }  else {
                    //
                    //  did not open, try to close to make it is in class 0
                    //
                    ModemControl->Wave.State=WAVE_STATE_HANDSET_OPEN_FAILED;
                }

                break;

            case WAVE_STATE_HANDSET_OPEN_FAILED:

                ModemControl->CurrentCommandStrings=GetCommonCommandStringCopy(
                    ModemControl->CommonInfo,
                    COMMON_CLOSE_HANDSET,
                    NULL,
                    NULL
                    );

                if (ModemControl->CurrentCommandStrings == NULL) {

                    Status=ERROR_UNIMODEM_GENERAL_FAILURE;

                    ModemControl->Wave.State=WAVE_STATE_HANDSET_OPEN_RETURN_RESULT;

                    break;
                }

                ModemControl->Wave.State=WAVE_STATE_CLOSED_HANDSET;

//                LogString(ModemControl->Debug, IDS_MSGLOG_VOICE_SETWAVEFORMAT);


                Status=IssueCommand(
                    ModemControl->CommandState,
                    ModemControl->CurrentCommandStrings,
                    OpenHandsetCompleteHandler,
                    ModemControl,
                    5*1000,
                    0
                    );


                if (Status == ERROR_IO_PENDING) {

                    ExitLoop=TRUE;

                }

                break;

            case WAVE_STATE_CLOSED_HANDSET:

                FREE_MEMORY(ModemControl->CurrentCommandStrings);

                ModemControl->ConnectionState=CONNECTION_STATE_NONE;

                ModemControl->Wave.State=WAVE_STATE_IDLE;

                StopDleMonitoring(ModemControl->Dle,NULL);

                Status=ERROR_UNIMODEM_GENERAL_FAILURE;

                ModemControl->Wave.State=WAVE_STATE_HANDSET_OPEN_RETURN_RESULT;

                break;


            case WAVE_STATE_HANDSET_OPEN_RETURN_RESULT:

                ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

                ModemControl->Wave.State=WAVE_STATE_IDLE;

                (*ModemControl->NotificationProc)(
                    ModemControl->NotificationContext,
                    MODEM_ASYNC_COMPLETION,
                    Status,
                    0
                    );

                RemoveReferenceFromObject(
                    &ModemControl->Header
                    );


                ExitLoop=TRUE;

                break;


            default:

                ASSERT(0);

                ExitLoop=TRUE;

                break;

        }
    }




}




LONG WINAPI
OpenHandset(
    PMODEM_CONTROL    ModemControl
    )

{
    BOOL              bResult;


    if (ModemControl->ConnectionState != CONNECTION_STATE_NONE) {

        return ERROR_UNIMODEM_BAD_WAVE_REQUEST;
    }

    ModemControl->CurrentCommandStrings=GetCommonCommandStringCopy(
        ModemControl->CommonInfo,
        COMMON_OPEN_HANDSET,
        NULL,
        NULL
        );

    if (ModemControl->CurrentCommandStrings == NULL) {

        return ERROR_UNIMODEM_MISSING_REG_KEY;
    }

    ModemControl->Wave.State = WAVE_STATE_OPEN_HANDSET;

    ModemControl->CurrentCommandType=COMMAND_TYPE_WAVE_ACTION;

    bResult=StartAsyncProcessing(
        ModemControl,
        OpenHandsetCompleteHandler,
        ModemControl,
        ERROR_SUCCESS
        );


    if (!bResult) {
        //
        //  failed
        //
        ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

        FREE_MEMORY(ModemControl->CurrentCommandStrings);


        ModemControl->Wave.State=WAVE_STATE_IDLE;
        return  ERROR_UNIMODEM_GENERAL_FAILURE;
    }

    return  ERROR_IO_PENDING;
}

VOID
CloseHandsetCompleteHandler(
    HANDLE      Context,
    DWORD       Status
    )

{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)Context;
    DWORD             ModemStatus;
    BOOL              ExitLoop=FALSE;

    DWORD             CommandFlags;


    ASSERT(COMMAND_TYPE_WAVE_ACTION == ModemControl->CurrentCommandType);

    D_INIT(UmDpf(ModemControl->Debug,"CloseHandsetCompleteHandler");)

    while (!ExitLoop) {

        switch (ModemControl->Wave.State) {

            case WAVE_STATE_CLOSE_HANDSET:

                ASSERT(Status == ERROR_SUCCESS);

                ModemControl->Wave.State=WAVE_STATE_CLOSED_HANDSET;

//                LogString(ModemControl->Debug, IDS_MSGLOG_VOICE_SETWAVEFORMAT);


                Status=IssueCommand(
                    ModemControl->CommandState,
                    ModemControl->CurrentCommandStrings,
                    CloseHandsetCompleteHandler,
                    ModemControl,
                    5*1000,
                    0
                    );


                if (Status == ERROR_IO_PENDING) {

                    ExitLoop=TRUE;

                }

                break;

            case WAVE_STATE_CLOSED_HANDSET:

                FREE_MEMORY(ModemControl->CurrentCommandStrings);

                ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

                ModemControl->ConnectionState=CONNECTION_STATE_NONE;

                ModemControl->Wave.State=WAVE_STATE_IDLE;

                StopDleMonitoring(ModemControl->Dle,NULL);

                (*ModemControl->NotificationProc)(
                    ModemControl->NotificationContext,
                    MODEM_ASYNC_COMPLETION,
                    Status,
                    0
                    );

                RemoveReferenceFromObject(
                    &ModemControl->Header
                    );


                ExitLoop=TRUE;

                break;

            default:

                ASSERT(0);

                ExitLoop=TRUE;

                break;

        }
    }




}


LONG WINAPI
CloseHandset(
    PMODEM_CONTROL    ModemControl
    )

{
    BOOL              bResult;


    ModemControl->CurrentCommandStrings=GetCommonCommandStringCopy(
        ModemControl->CommonInfo,
        COMMON_CLOSE_HANDSET,
        NULL,
        NULL
        );

    if (ModemControl->CurrentCommandStrings == NULL) {

        return ERROR_UNIMODEM_MISSING_REG_KEY;
    }

    ModemControl->Wave.State = WAVE_STATE_CLOSE_HANDSET;

    ModemControl->CurrentCommandType=COMMAND_TYPE_WAVE_ACTION;

    bResult=StartAsyncProcessing(
        ModemControl,
        CloseHandsetCompleteHandler,
        ModemControl,
        ERROR_SUCCESS
        );


    if (!bResult) {
        //
        //  failed
        //
        ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

        FREE_MEMORY(ModemControl->CurrentCommandStrings);


        ModemControl->Wave.State=WAVE_STATE_IDLE;
        return  ERROR_UNIMODEM_GENERAL_FAILURE;
    }

    return  ERROR_IO_PENDING;

}


VOID WINAPI
WaveDuplexFlushCompletionHandler(
    DWORD              ErrorCode,
    DWORD              BytesRead,
    LPOVERLAPPED       Overlapped
    )

{

    PUM_OVER_STRUCT    UmOverlapped=(PUM_OVER_STRUCT)Overlapped;

    PMODEM_CONTROL     ModemControl=UmOverlapped->Context1;
    BOOL               bResult;
    DWORD              BytesToRead;
    COMMTIMEOUTS       CommTimeouts;
    BOOL               ExitLoop=FALSE;


    if ((ErrorCode != ERROR_SUCCESS) && (ErrorCode != ERROR_OPERATION_ABORTED)) {

        D_TRACE(UmDpf(ModemControl->Debug,"WaveStopDuplexCompletionHandler: Async ReadFileEx Failed");)

        ModemControl->Wave.State = WAVE_STATE_STOP_DUPLEX_GOT_DLE_ETX;

    }

#if DBG
    ModemControl->Wave.FlushedBytes+=BytesRead;
#endif

    while (!ExitLoop) {

        switch (ModemControl->Wave.State) {

            case WAVE_STATE_STOP_CLEAR_RECIEVE_QUEUE:

                if (BytesRead > 50) {

                    BytesToRead=sizeof(FlushBuffer);

                    ReinitOverStruct(UmOverlapped);

                    UmOverlapped->Context1=ModemControl;

                    bResult=UnimodemReadFileEx(
                        ModemControl->FileHandle,
                        FlushBuffer,
                        BytesToRead,
                        &UmOverlapped->Overlapped,
                        WaveDuplexFlushCompletionHandler
                        );


                    if (!bResult) {

                        ModemControl->Wave.State = WAVE_STATE_STOP_SEND_STOP;

                        D_TRACE(UmDpf(ModemControl->Debug,"WaveStopDuplexCompletionHandler: ReadFileEx Failed");)
                    }

                } else {

                    ModemControl->Wave.State = WAVE_STATE_STOP_SEND_STOP;

                    break;
                }

                ExitLoop=TRUE;

                break;

            case WAVE_STATE_STOP_SEND_STOP: {

                D_TRACE(UmDpf(ModemControl->Debug,"WaveStopDuplexCompletionHandler: BytesFlushed=%d",ModemControl->Wave.FlushedBytes);)

                ModemControl->Wave.State = WAVE_STATE_STOP_DUPLEX_GOT_DLE_ETX;

                CommTimeouts.ReadIntervalTimeout=00;
                CommTimeouts.ReadTotalTimeoutMultiplier=0;
                CommTimeouts.ReadTotalTimeoutConstant=5000;
                CommTimeouts.WriteTotalTimeoutMultiplier=10;
                CommTimeouts.WriteTotalTimeoutConstant=2000;

                SetCommTimeouts(
                    ModemControl->FileHandle,
                    &CommTimeouts
                    );

                PrintString(
                    ModemControl->Debug,
                    (ModemControl->Wave.StreamType == WAVE_STREAM_FULLDUPLEX) ? ModemControl->RegInfo.DuplexAbort : ModemControl->RegInfo.RecordAbort,
                    (ModemControl->Wave.StreamType == WAVE_STREAM_FULLDUPLEX) ? ModemControl->RegInfo.DuplexAbortLength : ModemControl->RegInfo.RecordAbortLength,
                    PS_SEND
                    );

                ReinitOverStruct(UmOverlapped);

                UmOverlapped->Context1=ModemControl;

                bResult=UnimodemDeviceIoControlEx(
                    ModemControl->FileHandle,
                    IOCTL_MODEM_STOP_WAVE_RECEIVE,
                    (ModemControl->Wave.StreamType == WAVE_STREAM_FULLDUPLEX) ? ModemControl->RegInfo.DuplexAbort : ModemControl->RegInfo.RecordAbort,
                    (ModemControl->Wave.StreamType == WAVE_STREAM_FULLDUPLEX) ? ModemControl->RegInfo.DuplexAbortLength : ModemControl->RegInfo.RecordAbortLength,
                    NULL,
                    0,
                    &UmOverlapped->Overlapped,
                    WaveDuplexFlushCompletionHandler
                    );

                if (!bResult) {

                    D_ERROR(UmDpf(ModemControl->Debug,"WaveStopDuplexCompletionHandler: WriteFileEx Failed");)

                    break;
                }

                ExitLoop=TRUE;

                break;
            }


            case WAVE_STATE_STOP_DUPLEX_GOT_DLE_ETX:

                WaveDuplexStopCompleteHandler(
                    ModemControl,
                    ERROR_SUCCESS
                    );

                ExitLoop=TRUE;

                break;

            default:

                ASSERT(0);

                break;
        }

    }

    return;

}




VOID
WaveDuplexStopCompleteHandler(
    HANDLE      Context,
    DWORD       Status
    )

{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)Context;
    DWORD             ModemStatus;
    BOOL              ExitLoop=FALSE;

    DWORD             CommandFlags;


    ASSERT(COMMAND_TYPE_WAVE_ACTION == ModemControl->CurrentCommandType);

    D_INIT(UmDpf(ModemControl->Debug,"WaveCompleteHandler %d",ModemControl->Wave.State);)

    while (!ExitLoop) {

        switch (ModemControl->Wave.State) {

            case WAVE_STATE_STOP_STREAMING: {

                PUM_OVER_STRUCT    NewUmOverlapped;
                COMMTIMEOUTS    CommTimeouts;
                BOOL    bResult;

                D_TRACE(UmDpf(ModemControl->Debug,"Stop DUPLEX");)

                LogString(ModemControl->Debug, IDS_MSGLOG_VOICE_STOPWAVE);

                ModemControl->CurrentCommandStrings=NULL;

                ModemControl->Wave.State=WAVE_STATE_STOP_CLEAR_RECIEVE_QUEUE;

                //
                //  stop shielding DLE's so the command will go out un shielded
                //
                ControlDleShielding(
                    ModemControl->FileHandle,
                    MODEM_DLE_SHIELDING_OFF
                    );


                SetPassthroughMode(
                    ModemControl->FileHandle,
                    MODEM_NOPASSTHROUGH_INC_SESSION_COUNT
                    );


                CommTimeouts.ReadIntervalTimeout=0xffffffff;
                CommTimeouts.ReadTotalTimeoutMultiplier=0;
                CommTimeouts.ReadTotalTimeoutConstant=0;
                CommTimeouts.WriteTotalTimeoutMultiplier=10;
                CommTimeouts.WriteTotalTimeoutConstant=2000;

                bResult=SetCommTimeouts(
                    ModemControl->FileHandle,
                    &CommTimeouts
                    );

                NewUmOverlapped=ModemControl->Wave.OverStruct;

                NewUmOverlapped->Context1=ModemControl;

#if DBG
                ModemControl->Wave.FlushedBytes=0;
#endif
                bResult=ReadFileEx(
                    ModemControl->FileHandle,
                    FlushBuffer,
                    sizeof(FlushBuffer),
                    &NewUmOverlapped->Overlapped,
                    WaveDuplexFlushCompletionHandler
                    );


                if (!bResult) {
                    //
                    //  failed, exit
                    //
                    ModemControl->Wave.State=WAVE_STATE_COMPLETE_STOP_DUPLEX;
                    break;
                }

                ExitLoop=TRUE;

                break;
            }

            case WAVE_STATE_STOP_DUPLEX_GOT_DLE_ETX: {

                LONG     lResult;

                lResult=StartResponseEngine(
                    ModemControl->ReadState,
                    ModemControl
                    );

                ModemControl->Wave.State=WAVE_STATE_STOP_DUPLEX_GET_RESPONSE;

                //
                //  wait for the response that should come out when we send the stop command
                //
                RegisterCommandResponseHandler(
                    ModemControl->ReadState,
                    "",
                    WaveDuplexStopCompleteHandler,
                    ModemControl,
                    5*1000,
                    0
                    );

                ExitLoop=TRUE;

                break;
            }


            case WAVE_STATE_STOP_DUPLEX_GET_RESPONSE: {

                ModemControl->Wave.State=WAVE_STATE_COMPLETE_STOP_DUPLEX;

                ModemControl->CurrentCommandStrings=GetCommonCommandStringCopy(
                    ModemControl->CommonInfo,
                    (ModemControl->Wave.StreamType == WAVE_STREAM_FULLDUPLEX) ? COMMON_STOP_DUPLEX : COMMON_STOP_RECORD,
                    NULL,
                    NULL
                    );

                if (ModemControl->CurrentCommandStrings != NULL) {

                    Status=IssueCommand(
                        ModemControl->CommandState,
                        ModemControl->CurrentCommandStrings,
                        WaveDuplexStopCompleteHandler,
                        ModemControl,
                        5*1000,
                        0
                        );

                    if (Status == ERROR_IO_PENDING) {
                        //
                        //  Pending, exit, will be called back
                        //
                        ExitLoop=TRUE;
                    }
                }

                break;
            }

            case  WAVE_STATE_COMPLETE_STOP_DUPLEX: {

                if (ModemControl->CurrentCommandStrings != NULL) {

                    FREE_MEMORY(ModemControl->CurrentCommandStrings);
                }

                ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

                ModemControl->Wave.State=WAVE_STATE_IDLE;

                //
                //  force the status to succes, since there is not much the upper failure
                //  can do about it anyway.
                //
                Status=ERROR_SUCCESS;


                (*ModemControl->NotificationProc)(
                    ModemControl->NotificationContext,
                    MODEM_ASYNC_COMPLETION,
                    Status,
                    0
                    );

                //
                //  remove ref for starting async processing
                //
                RemoveReferenceFromObject(
                    &ModemControl->Header
                    );



                ExitLoop=TRUE;

                break;
            }



            default:

                ASSERT(0);
                ExitLoop=TRUE;
                break;
       }

   }

   return;

}





VOID
WavePlaybackStopCompleteHandler(
    HANDLE      Context,
    DWORD       Status
    )

{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)Context;
    DWORD             ModemStatus;
    BOOL              ExitLoop=FALSE;

    DWORD             CommandFlags;


    ASSERT(COMMAND_TYPE_WAVE_ACTION == ModemControl->CurrentCommandType);

    D_INIT(UmDpf(ModemControl->Debug,"WaveCompleteHandler %d",ModemControl->Wave.State);)

    while (!ExitLoop) {

        switch (ModemControl->Wave.State) {

            case WAVE_STATE_STOP_STREAMING: {

                ModemControl->Wave.State=WAVE_STATE_STOP_WAIT_FOR_RESPONSE;
                ModemControl->CurrentCommandStrings=NULL;

                //
                //  wave driver is done
                //
                SetPassthroughMode(
                    ModemControl->FileHandle,
                    MODEM_NOPASSTHROUGH_INC_SESSION_COUNT
                    );

                //
                //  stop shielding DLE's so the command will go out un shielded
                //
                ControlDleShielding(
                    ModemControl->FileHandle,
                    MODEM_DLE_SHIELDING_OFF
                    );

                //
                //  wait for the response that should come out when we send the stop command
                //
                RegisterCommandResponseHandler(
                    ModemControl->ReadState,
                    "",
                    WavePlaybackStopCompleteHandler,
                    ModemControl,
                    10*1000,
                    0
                    );

                LogString(ModemControl->Debug, IDS_MSGLOG_VOICE_STOPWAVE);

                PrintString(
                    ModemControl->Debug,
                    ModemControl->Wave.PlayTerminateOrAbort ? ModemControl->RegInfo.PlayAbort       : ModemControl->RegInfo.PlayTerminate,
                    ModemControl->Wave.PlayTerminateOrAbort ? ModemControl->RegInfo.PlayAbortLength : ModemControl->RegInfo.PlayTerminateLength,
                    PS_SEND
                    );


                //
                //  send the proper command, depending on if the want to stop or abort
                //
                UmWriteFile(
                    ModemControl->FileHandle,
                    ModemControl->CompletionPort,
                    ModemControl->Wave.PlayTerminateOrAbort ? ModemControl->RegInfo.PlayAbort       : ModemControl->RegInfo.PlayTerminate,
                    ModemControl->Wave.PlayTerminateOrAbort ? ModemControl->RegInfo.PlayAbortLength : ModemControl->RegInfo.PlayTerminateLength,
                    WaveStopWriteCompletionHandler,
                    ModemControl
                    );

                ExitLoop=TRUE;

                break;
            }


            case WAVE_STATE_STOP_WAIT_FOR_RESPONSE: {

                ModemControl->Wave.State=WAVE_STATE_SEND_STOP_PLAY;

                ModemControl->CurrentCommandStrings=GetCommonCommandStringCopy(
                    ModemControl->CommonInfo,
                    COMMON_STOP_PLAY,
                    NULL,
                    NULL
                    );

                if (ModemControl->CurrentCommandStrings != NULL) {

                    Status=IssueCommand(
                        ModemControl->CommandState,
                        ModemControl->CurrentCommandStrings,
                        WavePlaybackStopCompleteHandler,
                        ModemControl,
                        5*1000,
                        0
                        );

                    if (Status == ERROR_IO_PENDING) {
                        //
                        //  failed, don't exit.
                        //
                        ExitLoop=TRUE;
                    }
                }

                break;

            case  WAVE_STATE_SEND_STOP_PLAY:

                if (ModemControl->CurrentCommandStrings != NULL) {

                    FREE_MEMORY(ModemControl->CurrentCommandStrings);
                }

                ModemControl->Wave.State=WAVE_STATE_IDLE;

                ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

                //
                //  force the status to succes, since there is not much the upper failure
                //  can do about it anyway.
                //
                Status=ERROR_SUCCESS;

                (*ModemControl->NotificationProc)(
                    ModemControl->NotificationContext,
                    MODEM_ASYNC_COMPLETION,
                    Status,
                    0
                    );

                //
                //  remove ref for starting async processing
                //
                RemoveReferenceFromObject(
                    &ModemControl->Header
                    );


                ExitLoop=TRUE;

                break;
            }

            default:

                ASSERT(0);
                ExitLoop=TRUE;
                break;
       }

   }

   return;

}



VOID
WaveStartCompleteHandler(
    HANDLE      Context,
    DWORD       Status
    )

{
    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)Context;
    DWORD             ModemStatus;
    BOOL              ExitLoop=FALSE;

    DWORD             CommandFlags=0;


    ASSERT(COMMAND_TYPE_WAVE_ACTION == ModemControl->CurrentCommandType);

    D_INIT(UmDpf(ModemControl->Debug,"WaveCompleteHandler %d",ModemControl->Wave.State);)

    while (!ExitLoop) {

        switch (ModemControl->Wave.State) {

            case WAVE_STATE_START_SET_FORMAT:

                ASSERT(Status == ERROR_SUCCESS);

                ControlDleShielding(
                    ModemControl->FileHandle,
                    MODEM_DLE_SHIELDING_ON
                    );

                ModemControl->Wave.State=WAVE_STATE_START_STREAM;

                LogString(ModemControl->Debug, IDS_MSGLOG_VOICE_SETWAVEFORMAT);


                Status=IssueCommand(
                    ModemControl->CommandState,
                    ModemControl->CurrentCommandStrings,
                    WaveStartCompleteHandler,
                    ModemControl,
                    5*1000,
                    0
                    );

                if (Status != ERROR_IO_PENDING) {

                    ModemControl->Wave.State=WAVE_STATE_FAILURE;

                    break;
                }

                ExitLoop=TRUE;

                break;

            case WAVE_STATE_START_STREAM:

                FREE_MEMORY(ModemControl->CurrentCommandStrings);

                ModemControl->CurrentCommandStrings=NULL;

                if (Status != ERROR_SUCCESS) {

                    ModemControl->Wave.State=WAVE_STATE_FAILURE;

                    break;
                }

                SetVoiceBaudRate(
                    ModemControl->FileHandle,
                    ModemControl->Debug,
                    ModemControl->RegInfo.VoiceBaudRate
                    );


                //
                //  get the already loaded start command
                //
                ModemControl->CurrentCommandStrings=ModemControl->Wave.StartCommand;

                ModemControl->Wave.StartCommand=NULL;

                ModemControl->Wave.State=WAVE_STATE_COMPLETE_START;

                LogString(ModemControl->Debug, IDS_MSGLOG_VOICE_STARTWAVE);

                if (ModemControl->Wave.StreamType != WAVE_STREAM_PLAYBACK) {
                    //
                    //  for record and duplex, stop the response engine
                    //
                    CommandFlags=RESPONSE_FLAG_STOP_READ_ON_CONNECT | RESPONSE_FLAG_ONLY_CONNECT | RESPONSE_FLAG_SINGLE_BYTE_READS;
                }

                Status=IssueCommand(
                    ModemControl->CommandState,
                    ModemControl->CurrentCommandStrings,
                    WaveStartCompleteHandler,
                    ModemControl,
                    5*1000,
                    CommandFlags
                    );

                if (Status != ERROR_IO_PENDING) {

                    ModemControl->Wave.State=WAVE_STATE_FAILURE;

                    break;
                }


                ExitLoop=TRUE;

                break;


            case WAVE_STATE_COMPLETE_START: {

                COMMTIMEOUTS    CommTimeouts;

                FREE_MEMORY(ModemControl->CurrentCommandStrings);

                ModemControl->CurrentCommandStrings=NULL;

                if (Status != ERROR_SUCCESS) {

                    ModemControl->Wave.State=WAVE_STATE_FAILURE;

                    break;
                }


                ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

                ModemControl->Wave.State=WAVE_STATE_STREAM_RUNNING;

                SetPassthroughMode(
                    ModemControl->FileHandle,
                    MODEM_PASSTHROUGH
                    );

                CommTimeouts.ReadIntervalTimeout=1000;
                CommTimeouts.ReadTotalTimeoutMultiplier=2;
                CommTimeouts.ReadTotalTimeoutConstant=1000;
                CommTimeouts.WriteTotalTimeoutMultiplier=10;
                CommTimeouts.WriteTotalTimeoutConstant=2000;

                SetCommTimeouts(
                    ModemControl->FileHandle,
                    &CommTimeouts
                    );

                (*ModemControl->NotificationProc)(
                    ModemControl->NotificationContext,
                    MODEM_ASYNC_COMPLETION,
                    Status,
                    0
                    );

                //
                //  remove ref for starting async processing
                //
                RemoveReferenceFromObject(
                    &ModemControl->Header
                    );


                ExitLoop=TRUE;

                break;
            }

            case WAVE_STATE_FAILURE:
                //
                //  something bad happened, return failure.
                //
                D_ERROR(UmDpf(ModemControl->Debug,"WaveCompleteHandler: WAVE_STATE_FAILURE");)

                if (ModemControl->CurrentCommandStrings != NULL) {

                    FREE_MEMORY(ModemControl->CurrentCommandStrings);
                }

                if (ModemControl->Wave.StartCommand != NULL) {

                    FREE_MEMORY(ModemControl->Wave.StartCommand);
                }


                ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

                ModemControl->Wave.State=WAVE_STATE_IDLE;

                ASSERT(Status != ERROR_SUCCESS);

                ControlDleShielding(
                    ModemControl->FileHandle,
                    MODEM_DLE_SHIELDING_OFF
                    );

                SetPassthroughMode(
                    ModemControl->FileHandle,
                    MODEM_NOPASSTHROUGH_INC_SESSION_COUNT
                    );

                (*ModemControl->NotificationProc)(
                    ModemControl->NotificationContext,
                    MODEM_ASYNC_COMPLETION,
                    Status,
                    0
                    );

                //
                //  remove ref for starting async processing
                //
                RemoveReferenceFromObject(
                    &ModemControl->Header
                    );

                ExitLoop=TRUE;

                break;


            default:

                ASSERT(0);
                ExitLoop=TRUE;
                break;
       }

   }

   return;

}



DWORD WINAPI
UmWaveAction(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    DWORD               WaveAction
    )
/*++

Routine Description:

    Executes a specific wave related action

Arguments:

    ModemHandle - Handle returned by OpenModem

    CommandsOptionList - List option blocks, only flags used

        Flags - see above

    WaveAction  - Specifies actions to take

Return Value:

    ERROR_IO_PENDING If pending, will be completed later with a call to the AsyncHandler

    or other specific error


--*/


{

    PMODEM_CONTROL    ModemControl=(PMODEM_CONTROL)ReferenceObjectByHandleAndLock(ModemHandle);
    LONG              lResult;
    LPSTR             Commands;
    BOOL              bResult;

    BOOL              Handset;
    COMMANDRESPONSE   *AsyncHandler=NULL;

    ASSERT(ModemControl->CurrentCommandType == COMMAND_TYPE_NONE);

    if (ModemControl->CurrentCommandType != COMMAND_TYPE_NONE) {

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_UNIMODEM_INUSE;
    }

    if (WaveAction == WAVE_ACTION_OPEN_HANDSET) {

        lResult=OpenHandset(
            ModemControl
            );

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return lResult;
    }

    if (WaveAction == WAVE_ACTION_CLOSE_HANDSET) {

        lResult=CloseHandset(
            ModemControl
            );

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return lResult;
    }


    if ((ModemControl->ConnectionState != CONNECTION_STATE_VOICE)
        &&
        (ModemControl->ConnectionState != CONNECTION_STATE_HANDSET_OPEN)) {

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_UNIMODEM_NOT_IN_VOICE_MODE;
    }

    Handset= ModemControl->ConnectionState == CONNECTION_STATE_HANDSET_OPEN;

    if (ModemControl->Wave.State == WAVE_STATE_IDLE) {
        //
        //  Not doing anything now
        //
        DWORD   SetFormat;
        DWORD   StartStream;

        switch (WaveAction) {

            case WAVE_ACTION_START_PLAYBACK:

                SetFormat=Handset ? COMMON_HANDSET_SET_PLAY_FORMAT : COMMON_LINE_SET_PLAY_FORMAT;
                StartStream=COMMON_START_PLAY;

                ModemControl->Wave.StreamType=WAVE_STREAM_PLAYBACK;

                break;

            case WAVE_ACTION_START_RECORD:

                SetFormat=Handset ? COMMON_HANDSET_SET_RECORD_FORMAT : COMMON_LINE_SET_RECORD_FORMAT;
                StartStream=COMMON_START_RECORD;

                ModemControl->Wave.StreamType=WAVE_STREAM_RECORD;

                break;

            case WAVE_ACTION_START_DUPLEX:

                SetFormat=Handset ? COMMON_HANDSET_SET_DUPLEX_FORMAT : COMMON_LINE_SET_DUPLEX_FORMAT;
                StartStream=COMMON_START_DUPLEX;

                ModemControl->Wave.StreamType=WAVE_STREAM_FULLDUPLEX;
                break;


            default:

                ASSERT(0);

                RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

                return ERROR_UNIMODEM_BAD_WAVE_REQUEST;

        }

        ModemControl->CurrentCommandStrings=GetCommonCommandStringCopy(
            ModemControl->CommonInfo,
            SetFormat,
            NULL,
            NULL
            );

        if (ModemControl->CurrentCommandStrings == NULL) {

            RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

            return ERROR_UNIMODEM_MISSING_REG_KEY;
        }

        ModemControl->Wave.StartCommand=GetCommonCommandStringCopy(
            ModemControl->CommonInfo,
            StartStream,
            NULL,
            NULL
            );

        if (ModemControl->Wave.StartCommand== NULL) {

            FREE_MEMORY(ModemControl->CurrentCommandStrings);

            RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

            return ERROR_UNIMODEM_MISSING_REG_KEY;
        }

        ModemControl->Wave.State = WAVE_STATE_START_SET_FORMAT;
        AsyncHandler=WaveStartCompleteHandler;


    } else {
        //
        //  must be recording or playing, and they want to stop
        //
        if (ModemControl->Wave.State == WAVE_STATE_STREAM_RUNNING) {
            //
            //  streaming
            //
            if (WaveAction == WAVE_ACTION_STOP_STREAMING) {
                //
                //  stopping, let the buffered data play out
                //
                ModemControl->Wave.PlayTerminateOrAbort=FALSE;

            } else {

                if (WaveAction == WAVE_ACTION_ABORT_STREAMING) {
                    //
                    //  Abort, clear the modem's buffer
                    //
                    ModemControl->Wave.PlayTerminateOrAbort=TRUE;

                }  else {

                    RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

                    return ERROR_UNIMODEM_BAD_WAVE_REQUEST;
                }
            }

            ModemControl->Wave.State= WAVE_STATE_STOP_STREAMING;

            if (ModemControl->Wave.StreamType == WAVE_STREAM_PLAYBACK) {

                AsyncHandler=WavePlaybackStopCompleteHandler;

            } else {

                AsyncHandler=WaveDuplexStopCompleteHandler;
            }

        } else {

            RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

            return ERROR_UNIMODEM_BAD_WAVE_REQUEST;
        }
    }


    ModemControl->CurrentCommandType=COMMAND_TYPE_WAVE_ACTION;

    bResult=StartAsyncProcessing(
        ModemControl,
        AsyncHandler,
        ModemControl,
        ERROR_SUCCESS
        );


    if (!bResult) {
        //
        //  failed
        //
        ModemControl->CurrentCommandType=COMMAND_TYPE_NONE;

        FREE_MEMORY(ModemControl->CurrentCommandStrings);

        if (ModemControl->Wave.StartCommand != NULL) {

            FREE_MEMORY(ModemControl->Wave.StartCommand);
        }

        ModemControl->Wave.State=WAVE_STATE_IDLE;

        RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

        return ERROR_NOT_ENOUGH_MEMORY;

    }

   RemoveReferenceFromObjectAndUnlock(&ModemControl->Header);

   return ERROR_IO_PENDING;


}



BOOL WINAPI
SetVoiceBaudRate(
    HANDLE          FileHandle,
    OBJECT_HANDLE   Debug,
    DWORD           BaudRate
    )

{

    DCB        Dcb;

    GetCommState(
        FileHandle,
        &Dcb
        );

    Dcb.BaudRate=BaudRate;
    Dcb.Parity=NOPARITY;
    Dcb.ByteSize=8;
    Dcb.StopBits=ONESTOPBIT;

    PrintCommSettings(
        Debug,
        &Dcb
        );

    SetCommState(
        FileHandle,
        &Dcb
        );

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\inc\tspirec.h ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		TSPIREC.H
//		Structures representing the params for each exported TSPI function.
//
//
//		NOTE: This file is automatically generated by the following command:
//				gentsp -rs tspi20_r.txt
//
//		11/16/1996  JosephJ Created
//


#define TASKDEST_TSPI_BASE      0
#define TASKID_TSPI_BASE   0

#define TASKDEST_LINEID    (TASKDEST_TSPI_BASE+0x0)
#define TASKDEST_PHONEID   (TASKDEST_TSPI_BASE+0x1)
#define TASKDEST_HDRVLINE  (TASKDEST_TSPI_BASE+0x2)
#define TASKDEST_HDRVPHONE (TASKDEST_TSPI_BASE+0x3)
#define TASKDEST_HDRVCALL  (TASKDEST_TSPI_BASE+0x4)


#define ROUTINGINFO(_TaskID,_TaskDest) \
				MAKELONG(_TaskID, _TaskDest)

#define ROUT_TASKDEST(_RInfo) \
				HIWORD(_RInfo)

#define ROUT_TASKID(_RInfo) \
				LOWORD(_RInfo)


#define  TASKID_TSPI_lineAccept                        (TASKID_TSPI_BASE+   1)
#define  TASKID_TSPI_lineAddToConference               (TASKID_TSPI_BASE+   2)
#define  TASKID_TSPI_lineAnswer                        (TASKID_TSPI_BASE+   3)
#define  TASKID_TSPI_lineBlindTransfer                 (TASKID_TSPI_BASE+   4)
#define  TASKID_TSPI_lineClose                         (TASKID_TSPI_BASE+   5)
#define  TASKID_TSPI_lineCloseCall                     (TASKID_TSPI_BASE+   6)
#define  TASKID_TSPI_lineCompleteCall                  (TASKID_TSPI_BASE+   7)
#define  TASKID_TSPI_lineCompleteTransfer              (TASKID_TSPI_BASE+   8)
#define  TASKID_TSPI_lineConditionalMediaDetection     (TASKID_TSPI_BASE+   9)
#define  TASKID_TSPI_lineDevSpecific                   (TASKID_TSPI_BASE+  10)
#define  TASKID_TSPI_lineDevSpecificFeature            (TASKID_TSPI_BASE+  11)
#define  TASKID_TSPI_lineDial                          (TASKID_TSPI_BASE+  12)
#define  TASKID_TSPI_lineDrop                          (TASKID_TSPI_BASE+  13)
#define  TASKID_TSPI_lineDropNoOwner                   (TASKID_TSPI_BASE+  14)
#define  TASKID_TSPI_lineDropOnClose                   (TASKID_TSPI_BASE+  15)
#define  TASKID_TSPI_lineForward                       (TASKID_TSPI_BASE+  16)
#define  TASKID_TSPI_lineGatherDigits                  (TASKID_TSPI_BASE+  17)
#define  TASKID_TSPI_lineGenerateDigits                (TASKID_TSPI_BASE+  18)
#define  TASKID_TSPI_lineGenerateTone                  (TASKID_TSPI_BASE+  19)
#define  TASKID_TSPI_lineGetAddressCaps                (TASKID_TSPI_BASE+  20)
#define  TASKID_TSPI_lineGetAddressID                  (TASKID_TSPI_BASE+  21)
#define  TASKID_TSPI_lineGetAddressStatus              (TASKID_TSPI_BASE+  22)
#define  TASKID_TSPI_lineGetCallAddressID              (TASKID_TSPI_BASE+  23)
#define  TASKID_TSPI_lineGetCallInfo                   (TASKID_TSPI_BASE+  24)
#define  TASKID_TSPI_lineGetCallStatus                 (TASKID_TSPI_BASE+  25)
#define  TASKID_TSPI_lineGetDevCaps                    (TASKID_TSPI_BASE+  26)
#define  TASKID_TSPI_lineGetDevConfig                  (TASKID_TSPI_BASE+  27)
#define  TASKID_TSPI_lineGetExtensionID                (TASKID_TSPI_BASE+  28)
#define  TASKID_TSPI_lineGetIcon                       (TASKID_TSPI_BASE+  29)
#define  TASKID_TSPI_lineGetID                         (TASKID_TSPI_BASE+  30)
#define  TASKID_TSPI_lineGetLineDevStatus              (TASKID_TSPI_BASE+  31)
#define  TASKID_TSPI_lineGetNumAddressIDs              (TASKID_TSPI_BASE+  32)
#define  TASKID_TSPI_lineHold                          (TASKID_TSPI_BASE+  33)
#define  TASKID_TSPI_lineMakeCall                      (TASKID_TSPI_BASE+  34)
#define  TASKID_TSPI_lineMonitorDigits                 (TASKID_TSPI_BASE+  35)
#define  TASKID_TSPI_lineMonitorMedia                  (TASKID_TSPI_BASE+  36)
#define  TASKID_TSPI_lineMonitorTones                  (TASKID_TSPI_BASE+  37)
#define  TASKID_TSPI_lineNegotiateExtVersion           (TASKID_TSPI_BASE+  38)
#define  TASKID_TSPI_lineNegotiateTSPIVersion          (TASKID_TSPI_BASE+  39)
#define  TASKID_TSPI_lineOpen                          (TASKID_TSPI_BASE+  40)
#define  TASKID_TSPI_linePark                          (TASKID_TSPI_BASE+  41)
#define  TASKID_TSPI_linePickup                        (TASKID_TSPI_BASE+  42)
#define  TASKID_TSPI_linePrepareAddToConference        (TASKID_TSPI_BASE+  43)
#define  TASKID_TSPI_lineRedirect                      (TASKID_TSPI_BASE+  44)
#define  TASKID_TSPI_lineReleaseUserUserInfo           (TASKID_TSPI_BASE+  45)
#define  TASKID_TSPI_lineRemoveFromConference          (TASKID_TSPI_BASE+  46)
#define  TASKID_TSPI_lineSecureCall                    (TASKID_TSPI_BASE+  47)
#define  TASKID_TSPI_lineSelectExtVersion              (TASKID_TSPI_BASE+  48)
#define  TASKID_TSPI_lineSendUserUserInfo              (TASKID_TSPI_BASE+  49)
#define  TASKID_TSPI_lineSetAppSpecific                (TASKID_TSPI_BASE+  50)
#define  TASKID_TSPI_lineSetCallData                   (TASKID_TSPI_BASE+  51)
#define  TASKID_TSPI_lineSetCallParams                 (TASKID_TSPI_BASE+  52)
#define  TASKID_TSPI_lineSetCallQualityOfService       (TASKID_TSPI_BASE+  53)
#define  TASKID_TSPI_lineSetCallTreatment              (TASKID_TSPI_BASE+  54)
#define  TASKID_TSPI_lineSetDefaultMediaDetection      (TASKID_TSPI_BASE+  55)
#define  TASKID_TSPI_lineSetDevConfig                  (TASKID_TSPI_BASE+  56)
#define  TASKID_TSPI_lineSetLineDevStatus              (TASKID_TSPI_BASE+  57)
#define  TASKID_TSPI_lineSetMediaControl               (TASKID_TSPI_BASE+  58)
#define  TASKID_TSPI_lineSetMediaMode                  (TASKID_TSPI_BASE+  59)
#define  TASKID_TSPI_lineSetStatusMessages             (TASKID_TSPI_BASE+  60)
#define  TASKID_TSPI_lineSetTerminal                   (TASKID_TSPI_BASE+  61)
#define  TASKID_TSPI_lineSetupConference               (TASKID_TSPI_BASE+  62)
#define  TASKID_TSPI_lineSetupTransfer                 (TASKID_TSPI_BASE+  63)
#define  TASKID_TSPI_lineSwapHold                      (TASKID_TSPI_BASE+  64)
#define  TASKID_TSPI_lineUncompleteCall                (TASKID_TSPI_BASE+  65)
#define  TASKID_TSPI_lineUnhold                        (TASKID_TSPI_BASE+  66)
#define  TASKID_TSPI_lineUnpark                        (TASKID_TSPI_BASE+  67)
#define  TASKID_TSPI_phoneClose                        (TASKID_TSPI_BASE+  68)
#define  TASKID_TSPI_phoneDevSpecific                  (TASKID_TSPI_BASE+  69)
#define  TASKID_TSPI_phoneGetButtonInfo                (TASKID_TSPI_BASE+  70)
#define  TASKID_TSPI_phoneGetData                      (TASKID_TSPI_BASE+  71)
#define  TASKID_TSPI_phoneGetDevCaps                   (TASKID_TSPI_BASE+  72)
#define  TASKID_TSPI_phoneGetDisplay                   (TASKID_TSPI_BASE+  73)
#define  TASKID_TSPI_phoneGetExtensionID               (TASKID_TSPI_BASE+  74)
#define  TASKID_TSPI_phoneGetGain                      (TASKID_TSPI_BASE+  75)
#define  TASKID_TSPI_phoneGetHookSwitch                (TASKID_TSPI_BASE+  76)
#define  TASKID_TSPI_phoneGetIcon                      (TASKID_TSPI_BASE+  77)
#define  TASKID_TSPI_phoneGetID                        (TASKID_TSPI_BASE+  78)
#define  TASKID_TSPI_phoneGetLamp                      (TASKID_TSPI_BASE+  79)
#define  TASKID_TSPI_phoneGetRing                      (TASKID_TSPI_BASE+  80)
#define  TASKID_TSPI_phoneGetStatus                    (TASKID_TSPI_BASE+  81)
#define  TASKID_TSPI_phoneGetVolume                    (TASKID_TSPI_BASE+  82)
#define  TASKID_TSPI_phoneNegotiateExtVersion          (TASKID_TSPI_BASE+  83)
#define  TASKID_TSPI_phoneNegotiateTSPIVersion         (TASKID_TSPI_BASE+  84)
#define  TASKID_TSPI_phoneOpen                         (TASKID_TSPI_BASE+  85)
#define  TASKID_TSPI_phoneSelectExtVersion             (TASKID_TSPI_BASE+  86)
#define  TASKID_TSPI_phoneSetButtonInfo                (TASKID_TSPI_BASE+  87)
#define  TASKID_TSPI_phoneSetData                      (TASKID_TSPI_BASE+  88)
#define  TASKID_TSPI_phoneSetDisplay                   (TASKID_TSPI_BASE+  89)
#define  TASKID_TSPI_phoneSetGain                      (TASKID_TSPI_BASE+  90)
#define  TASKID_TSPI_phoneSetHookSwitch                (TASKID_TSPI_BASE+  91)
#define  TASKID_TSPI_phoneSetLamp                      (TASKID_TSPI_BASE+  92)
#define  TASKID_TSPI_phoneSetRing                      (TASKID_TSPI_BASE+  93)
#define  TASKID_TSPI_phoneSetStatusMessages            (TASKID_TSPI_BASE+  94)
#define  TASKID_TSPI_phoneSetVolume                    (TASKID_TSPI_BASE+  95)
#define  TASKID_TSPI_providerGenericDialogData         (TASKID_TSPI_BASE+  96)


#if (TAPI_CURRENT_VERSION >= 0x00030000)
    #define  TASKID_TSPI_lineCreateMSPInstance         (TASKID_TSPI_BASE+  97)
    #define  TASKID_TSPI_lineCloseMSPInstance          (TASKID_TSPI_BASE+  98)
#endif

typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdCall;
	LPCSTR lpsUserUserInfo;
	DWORD dwSize;

} TASKPARAM_TSPI_lineAccept;

typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdConfCall;
	HDRVCALL hdConsultCall;

} TASKPARAM_TSPI_lineAddToConference;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdCall;
	LPCSTR lpsUserUserInfo;
	DWORD dwSize;

} TASKPARAM_TSPI_lineAnswer;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdCall;
	LPCWSTR lpszDestAddress;
	DWORD dwCountryCode;

} TASKPARAM_TSPI_lineBlindTransfer;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVLINE hdLine;

} TASKPARAM_TSPI_lineClose;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVCALL hdCall;

} TASKPARAM_TSPI_lineCloseCall;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdCall;
	LPDWORD lpdwCompletionID;
	DWORD dwCompletionMode;
	DWORD dwMessageID;

} TASKPARAM_TSPI_lineCompleteCall;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdCall;
	HDRVCALL hdConsultCall;
	HTAPICALL htConfCall;
	LPHDRVCALL lphdConfCall;
	DWORD dwTransferMode;

} TASKPARAM_TSPI_lineCompleteTransfer;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVLINE hdLine;
	DWORD dwMediaModes;
	LPLINECALLPARAMS lpCallParams;

} TASKPARAM_TSPI_lineConditionalMediaDetection;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVLINE hdLine;
	DWORD dwAddressID;
	HDRVCALL hdCall;
	LPVOID lpParams;
	DWORD dwSize;

} TASKPARAM_TSPI_lineDevSpecific;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVLINE hdLine;
	DWORD dwFeature;
	LPVOID lpParams;
	DWORD dwSize;

} TASKPARAM_TSPI_lineDevSpecificFeature;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdCall;
	LPCWSTR lpszDestAddress;
	DWORD dwCountryCode;

} TASKPARAM_TSPI_lineDial;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdCall;
	LPCSTR lpsUserUserInfo;
	DWORD dwSize;

} TASKPARAM_TSPI_lineDrop;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVCALL hdCall;

} TASKPARAM_TSPI_lineDropOnClose;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVCALL hdCall;

} TASKPARAM_TSPI_lineDropNoOwner;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVLINE hdLine;
	DWORD bAllAddresses;
	DWORD dwAddressID;
	LPLINEFORWARDLIST lpForwardList;
	DWORD dwNumRingsNoAnswer;
	HTAPICALL htConsultCall;
	LPHDRVCALL lphdConsultCall;
	LPLINECALLPARAMS lpCallParams;

} TASKPARAM_TSPI_lineForward;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVCALL hdCall;
	DWORD dwEndToEndID;
	DWORD dwDigitModes;
	LPWSTR lpsDigits;
	DWORD dwNumDigits;
	LPCWSTR lpszTerminationDigits;
	DWORD dwFirstDigitTimeout;
	DWORD dwInterDigitTimeout;

} TASKPARAM_TSPI_lineGatherDigits;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVCALL hdCall;
	DWORD dwEndToEndID;
	DWORD dwDigitMode;
	LPCWSTR lpszDigits;
	DWORD dwDuration;

} TASKPARAM_TSPI_lineGenerateDigits;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVCALL hdCall;
	DWORD dwEndToEndID;
	DWORD dwToneMode;
	DWORD dwDuration;
	DWORD dwNumTones;
	LPLINEGENERATETONE lpTones;

} TASKPARAM_TSPI_lineGenerateTone;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DWORD dwDeviceID;
	DWORD dwAddressID;
	DWORD dwTSPIVersion;
	DWORD dwExtVersion;
	LPLINEADDRESSCAPS lpAddressCaps;

} TASKPARAM_TSPI_lineGetAddressCaps;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVLINE hdLine;
	LPDWORD lpdwAddressID;
	DWORD dwAddressMode;
	LPCWSTR lpsAddress;
	DWORD dwSize;

} TASKPARAM_TSPI_lineGetAddressID;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVLINE hdLine;
	DWORD dwAddressID;
	LPLINEADDRESSSTATUS lpAddressStatus;

} TASKPARAM_TSPI_lineGetAddressStatus;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVCALL hdCall;
	LPDWORD lpdwAddressID;

} TASKPARAM_TSPI_lineGetCallAddressID;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVCALL hdCall;
	LPLINECALLINFO lpCallInfo;

} TASKPARAM_TSPI_lineGetCallInfo;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVCALL hdCall;
	LPLINECALLSTATUS lpCallStatus;

} TASKPARAM_TSPI_lineGetCallStatus;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DWORD dwDeviceID;
	DWORD dwTSPIVersion;
	DWORD dwExtVersion;
	LPLINEDEVCAPS lpLineDevCaps;

} TASKPARAM_TSPI_lineGetDevCaps;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DWORD dwDeviceID;
	LPVARSTRING lpDeviceConfig;
	LPCWSTR lpszDeviceClass;

} TASKPARAM_TSPI_lineGetDevConfig;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DWORD dwDeviceID;
	DWORD dwTSPIVersion;
	LPLINEEXTENSIONID lpExtensionID;

} TASKPARAM_TSPI_lineGetExtensionID;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DWORD dwDeviceID;
	LPCWSTR lpszDeviceClass;
	LPHICON lphIcon;

} TASKPARAM_TSPI_lineGetIcon;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVLINE hdLine;
	DWORD dwAddressID;
	HDRVCALL hdCall;
	DWORD dwSelect;
	LPVARSTRING lpDeviceID;
	LPCWSTR lpszDeviceClass;
	HANDLE hTargetProcess;

} TASKPARAM_TSPI_lineGetID;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVLINE hdLine;
	LPLINEDEVSTATUS lpLineDevStatus;

} TASKPARAM_TSPI_lineGetLineDevStatus;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVLINE hdLine;
	LPDWORD lpdwNumAddressIDs;

} TASKPARAM_TSPI_lineGetNumAddressIDs;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdCall;

} TASKPARAM_TSPI_lineHold;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVLINE hdLine;
	HTAPICALL htCall;
	LPHDRVCALL lphdCall;
	LPCWSTR lpszDestAddress;
	DWORD dwCountryCode;
	LPLINECALLPARAMS lpCallParams;

} TASKPARAM_TSPI_lineMakeCall;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVCALL hdCall;
	DWORD dwDigitModes;

} TASKPARAM_TSPI_lineMonitorDigits;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVCALL hdCall;
	DWORD dwMediaModes;

} TASKPARAM_TSPI_lineMonitorMedia;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVCALL hdCall;
	DWORD dwToneListID;
	LPLINEMONITORTONE lpToneList;
	DWORD dwNumEntries;

} TASKPARAM_TSPI_lineMonitorTones;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DWORD dwDeviceID;
	DWORD dwTSPIVersion;
	DWORD dwLowVersion;
	DWORD dwHighVersion;
	LPDWORD lpdwExtVersion;

} TASKPARAM_TSPI_lineNegotiateExtVersion;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DWORD dwDeviceID;
	DWORD dwLowVersion;
	DWORD dwHighVersion;
	LPDWORD lpdwTSPIVersion;

} TASKPARAM_TSPI_lineNegotiateTSPIVersion;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DWORD dwDeviceID;
	HTAPILINE htLine;
	LPHDRVLINE lphdLine;
	DWORD dwTSPIVersion;
	LINEEVENT lpfnEventProc;

} TASKPARAM_TSPI_lineOpen;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdCall;
	DWORD dwParkMode;
	LPCWSTR lpszDirAddress;
	LPVARSTRING lpNonDirAddress;

} TASKPARAM_TSPI_linePark;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVLINE hdLine;
	DWORD dwAddressID;
	HTAPICALL htCall;
	LPHDRVCALL lphdCall;
	LPCWSTR lpszDestAddress;
	LPCWSTR lpszGroupID;

} TASKPARAM_TSPI_linePickup;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdConfCall;
	HTAPICALL htConsultCall;
	LPHDRVCALL lphdConsultCall;
	LPLINECALLPARAMS lpCallParams;

} TASKPARAM_TSPI_linePrepareAddToConference;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdCall;
	LPCWSTR lpszDestAddress;
	DWORD dwCountryCode;

} TASKPARAM_TSPI_lineRedirect;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdCall;

} TASKPARAM_TSPI_lineReleaseUserUserInfo;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdCall;

} TASKPARAM_TSPI_lineRemoveFromConference;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdCall;

} TASKPARAM_TSPI_lineSecureCall;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVLINE hdLine;
	DWORD dwExtVersion;

} TASKPARAM_TSPI_lineSelectExtVersion;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdCall;
	LPCSTR lpsUserUserInfo;
	DWORD dwSize;

} TASKPARAM_TSPI_lineSendUserUserInfo;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVCALL hdCall;
	DWORD dwAppSpecific;

} TASKPARAM_TSPI_lineSetAppSpecific;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdCall;
	LPVOID lpCallData;
	DWORD dwSize;

} TASKPARAM_TSPI_lineSetCallData;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdCall;
	DWORD dwBearerMode;
	DWORD dwMinRate;
	DWORD dwMaxRate;
	LPLINEDIALPARAMS lpDialParams;

} TASKPARAM_TSPI_lineSetCallParams;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdCall;
	LPVOID lpSendingFlowspec;
	DWORD dwSendingFlowspecSize;
	LPVOID lpReceivingFlowspec;
	DWORD dwReceivingFlowspecSize;

} TASKPARAM_TSPI_lineSetCallQualityOfService;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdCall;
	DWORD dwTreatment;

} TASKPARAM_TSPI_lineSetCallTreatment;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVLINE hdLine;
	DWORD dwMediaModes;

} TASKPARAM_TSPI_lineSetDefaultMediaDetection;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DWORD dwDeviceID;
	LPVOID lpDeviceConfig;
	DWORD dwSize;
	LPCWSTR lpszDeviceClass;

} TASKPARAM_TSPI_lineSetDevConfig;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVLINE hdLine;
	DWORD dwStatusToChange;
	DWORD fStatus;

} TASKPARAM_TSPI_lineSetLineDevStatus;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVLINE hdLine;
	DWORD dwAddressID;
	HDRVCALL hdCall;
	DWORD dwSelect;
	LPLINEMEDIACONTROLDIGIT lpDigitList;
	DWORD dwDigitNumEntries;
	LPLINEMEDIACONTROLMEDIA lpMediaList;
	DWORD dwMediaNumEntries;
	LPLINEMEDIACONTROLTONE lpToneList;
	DWORD dwToneNumEntries;
	LPLINEMEDIACONTROLCALLSTATE lpCallStateList;
	DWORD dwCallStateNumEntries;

} TASKPARAM_TSPI_lineSetMediaControl;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVCALL hdCall;
	DWORD dwMediaMode;

} TASKPARAM_TSPI_lineSetMediaMode;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVLINE hdLine;
	DWORD dwLineStates;
	DWORD dwAddressStates;

} TASKPARAM_TSPI_lineSetStatusMessages;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVLINE hdLine;
	DWORD dwAddressID;
	HDRVCALL hdCall;
	DWORD dwSelect;
	DWORD dwTerminalModes;
	DWORD dwTerminalID;
	DWORD bEnable;

} TASKPARAM_TSPI_lineSetTerminal;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdCall;
	HDRVLINE hdLine;
	HTAPICALL htConfCall;
	LPHDRVCALL lphdConfCall;
	HTAPICALL htConsultCall;
	LPHDRVCALL lphdConsultCall;
	DWORD dwNumParties;
	LPLINECALLPARAMS lpCallParams;

} TASKPARAM_TSPI_lineSetupConference;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdCall;
	HTAPICALL htConsultCall;
	LPHDRVCALL lphdConsultCall;
	LPLINECALLPARAMS lpCallParams;

} TASKPARAM_TSPI_lineSetupTransfer;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdActiveCall;
	HDRVCALL hdHeldCall;

} TASKPARAM_TSPI_lineSwapHold;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVLINE hdLine;
	DWORD dwCompletionID;

} TASKPARAM_TSPI_lineUncompleteCall;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdCall;

} TASKPARAM_TSPI_lineUnhold;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVLINE hdLine;
	DWORD dwAddressID;
	HTAPICALL htCall;
	LPHDRVCALL lphdCall;
	LPCWSTR lpszDestAddress;

} TASKPARAM_TSPI_lineUnpark;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVPHONE hdPhone;

} TASKPARAM_TSPI_phoneClose;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVPHONE hdPhone;
	LPVOID lpParams;
	DWORD dwSize;

} TASKPARAM_TSPI_phoneDevSpecific;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVPHONE hdPhone;
	DWORD dwButtonLampID;
	LPPHONEBUTTONINFO lpButtonInfo;

} TASKPARAM_TSPI_phoneGetButtonInfo;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVPHONE hdPhone;
	DWORD dwDataID;
	LPVOID lpData;
	DWORD dwSize;

} TASKPARAM_TSPI_phoneGetData;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DWORD dwDeviceID;
	DWORD dwTSPIVersion;
	DWORD dwExtVersion;
	LPPHONECAPS lpPhoneCaps;

} TASKPARAM_TSPI_phoneGetDevCaps;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVPHONE hdPhone;
	LPVARSTRING lpDisplay;

} TASKPARAM_TSPI_phoneGetDisplay;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DWORD dwDeviceID;
	DWORD dwTSPIVersion;
	LPPHONEEXTENSIONID lpExtensionID;

} TASKPARAM_TSPI_phoneGetExtensionID;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVPHONE hdPhone;
	DWORD dwHookSwitchDev;
	LPDWORD lpdwGain;

} TASKPARAM_TSPI_phoneGetGain;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVPHONE hdPhone;
	LPDWORD lpdwHookSwitchDevs;

} TASKPARAM_TSPI_phoneGetHookSwitch;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DWORD dwDeviceID;
	LPCWSTR lpszDeviceClass;
	LPHICON lphIcon;

} TASKPARAM_TSPI_phoneGetIcon;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVPHONE hdPhone;
	LPVARSTRING lpDeviceID;
	LPCWSTR lpszDeviceClass;
	HANDLE hTargetProcess;

} TASKPARAM_TSPI_phoneGetID;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVPHONE hdPhone;
	DWORD dwButtonLampID;
	LPDWORD lpdwLampMode;

} TASKPARAM_TSPI_phoneGetLamp;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVPHONE hdPhone;
	LPDWORD lpdwRingMode;
	LPDWORD lpdwVolume;

} TASKPARAM_TSPI_phoneGetRing;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVPHONE hdPhone;
	LPPHONESTATUS lpPhoneStatus;

} TASKPARAM_TSPI_phoneGetStatus;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVPHONE hdPhone;
	DWORD dwHookSwitchDev;
	LPDWORD lpdwVolume;

} TASKPARAM_TSPI_phoneGetVolume;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DWORD dwDeviceID;
	DWORD dwTSPIVersion;
	DWORD dwLowVersion;
	DWORD dwHighVersion;
	LPDWORD lpdwExtVersion;

} TASKPARAM_TSPI_phoneNegotiateExtVersion;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DWORD dwDeviceID;
	DWORD dwLowVersion;
	DWORD dwHighVersion;
	LPDWORD lpdwTSPIVersion;

} TASKPARAM_TSPI_phoneNegotiateTSPIVersion;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DWORD dwDeviceID;
	HTAPIPHONE htPhone;
	LPHDRVPHONE lphdPhone;
	DWORD dwTSPIVersion;
	PHONEEVENT lpfnEventProc;

} TASKPARAM_TSPI_phoneOpen;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVPHONE hdPhone;
	DWORD dwExtVersion;

} TASKPARAM_TSPI_phoneSelectExtVersion;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVPHONE hdPhone;
	DWORD dwButtonLampID;
	LPPHONEBUTTONINFO lpButtonInfo;

} TASKPARAM_TSPI_phoneSetButtonInfo;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVPHONE hdPhone;
	DWORD dwDataID;
	LPVOID lpData;
	DWORD dwSize;

} TASKPARAM_TSPI_phoneSetData;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVPHONE hdPhone;
	DWORD dwRow;
	DWORD dwColumn;
	LPCWSTR lpsDisplay;
	DWORD dwSize;

} TASKPARAM_TSPI_phoneSetDisplay;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVPHONE hdPhone;
	DWORD dwHookSwitchDev;
	DWORD dwGain;

} TASKPARAM_TSPI_phoneSetGain;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVPHONE hdPhone;
	DWORD dwHookSwitchDevs;
	DWORD dwHookSwitchMode;

} TASKPARAM_TSPI_phoneSetHookSwitch;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVPHONE hdPhone;
	DWORD dwButtonLampID;
	DWORD dwLampMode;

} TASKPARAM_TSPI_phoneSetLamp;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVPHONE hdPhone;
	DWORD dwRingMode;
	DWORD dwVolume;

} TASKPARAM_TSPI_phoneSetRing;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	HDRVPHONE hdPhone;
	DWORD dwPhoneStates;
	DWORD dwButtonModes;
	DWORD dwButtonStates;

} TASKPARAM_TSPI_phoneSetStatusMessages;


typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVPHONE hdPhone;
	DWORD dwHookSwitchDev;
	DWORD dwVolume;

} TASKPARAM_TSPI_phoneSetVolume;

typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

    DWORD dwObjectID;
    DWORD  dwObjectType;
    LPVOID lpParams;
    DWORD  dwSize;

} TASKPARAM_TSPI_providerGenericDialogData;


#if (TAPI_CURRENT_VERSION >= 0x00030000)
#if 0
typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVLINE hdLine;
	HTAPICALL htCall;
	LPHDRVCALL lphdCall;
	LPCWSTR lpszDestAddress;
	DWORD dwCountryCode;
	LPLINECALLPARAMS lpCallParams;

} TASKPARAM_TSPI_lineMakeCallMSP;

typedef struct {

	DWORD dwStructSize;
	DWORD dwTaskID;

	DRV_REQUESTID dwRequestID;
	HDRVCALL hdCall;
	LPCSTR lpsUserUserInfo;
	DWORD dwSize;


} TASKPARAM_TSPI_lineAnswerMSP;
#endif
typedef struct {

    DWORD dwStructSize;
    DWORD dwTaskID;

    HDRVLINE hdLine;
    DWORD               dwAddressID;
    HTAPIMSPLINE        htMSPLine;
    LPHDRVMSPLINE       lphdMSPLine;

} TASKPARAM_TSPI_lineCreateMSPInstance;


typedef struct {

    DWORD dwStructSize;
    DWORD dwTaskID;

} TASKPARAM_TSPI_lineCloseMSPInstance;




#endif // TAPI3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\inc\debugmem.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    debugmem.h

Abstract:


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/
#ifdef __cplusplus
extern "C" {
#endif


#ifndef  _UNIMODEM_MEM_DEBUG
#define  _UNIMODEM_MEM_DEBUG  1

#define  UNIMODEM_INITIAL_HEAPSIZE  (128*1024)

//#define UNIMODEM_PRIVATE_HEAP 1

typedef struct _DEBUG_MEMORY_CONTROL_BLOCK {

    LIST_ENTRY        MemoryList;
    CRITICAL_SECTION  MemoryListLock;
    CHAR              ModuleName[256];
    DWORD             ModuleNameLength;

    HANDLE            PrivateHeapHandle;

} DEBUG_MEMORY_CONTROL_BLOCK;


extern DEBUG_MEMORY_CONTROL_BLOCK   DebugMemoryControl;

#if DBG

VOID WINAPI
DebugMemoryProcessAttach(
    LPCSTR    Name
    );

VOID WINAPI
DebugMemoryProcessDetach(
    VOID
    );



PVOID WINAPI
PrivateAllocate(
    DWORD    Size,
    DWORD    Line,
    LPSTR    File
    );

VOID WINAPI
PrivateFree(
    PVOID   Memory
    );

PVOID WINAPI
PrivateReallocate(
    PVOID    Memory,
    DWORD    NewSize
    );

BOOL WINAPI
ValidateMemory(
    PVOID   Memory
    );

DWORD
PrivateSize(
    PVOID    Memory
    );



#define  DEBUG_MEMORY_PROCESS_ATTACH(_Name) (DebugMemoryProcessAttach(_Name))

#define  DEBUG_MEMORY_PROCESS_DETACH() (DebugMemoryProcessDetach())

#define  ALLOCATE_MEMORY(_size) (PrivateAllocate(_size,__LINE__,__FILE__))

#define  FREE_MEMORY(_mem) { INT_PTR * _x=(INT_PTR *)(&_mem);PrivateFree(_mem); *_x=-1; }

#define  REALLOCATE_MEMORY(_mem,_size) PrivateReallocate(_mem,_size)

#define  VALIDATE_MEMORY(_mem) {ValidateMemory(_mem);}

#define  SIZE_OF_MEMORY(_mem) PrivateSize(_mem)

#else  // non debug


#ifdef  UNIMODEM_PRIVATE_HEAP


#define  DEBUG_MEMORY_PROCESS_ATTACH(_Name) {   \
                                                \
    DebugMemoryControl.PrivateHeapHandle=HeapCreate(                      \
        0,                                      \
        UNIMODEM_INITIAL_HEAPSIZE,              \
        0                                       \
        );                                      \
    if (DebugMemoryControl.PrivateHeapHandle == NULL) {                   \
                                                \
        DebugMemoryControl.PrivateHeapHandle=GetProcessHeap();            \
    }                                           \
}

#define  DEBUG_MEMORY_PROCESS_DETACH() {if (DebugMemoryControl.PrivateHeapHandle != GetProcessHeap()) {HeapDestroy(DebugMemoryControl.PrivateHeapHandle);}}


#else // process heap


#define  DEBUG_MEMORY_PROCESS_ATTACH(_Name) { DebugMemoryControl.PrivateHeapHandle=GetProcessHeap(); }

#define  DEBUG_MEMORY_PROCESS_DETACH() {}


#endif


#define  ALLOCATE_MEMORY(_size) (HeapAlloc(DebugMemoryControl.PrivateHeapHandle,HEAP_ZERO_MEMORY,_size))

#define  FREE_MEMORY(_mem) {INT_PTR * _x=(INT_PTR *)(&_mem);HeapFree(DebugMemoryControl.PrivateHeapHandle,0,_mem);*_x=-1;}

#define  REALLOCATE_MEMORY(_mem,_size) (HeapReAlloc(DebugMemoryControl.PrivateHeapHandle,HEAP_ZERO_MEMORY,_mem,_size))

#define  SIZE_OF_MEMORY(_mem) HeapSize(DebugMemoryControl.PrivateHeapHandle,0,_mem)

#define  VALIDATE_MEMORY(_mem) {}

#endif



#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\inc\slot.h ===
#ifdef __cplusplus
extern "C" {
#endif

//****************************************************************************
//
//  Module:     UNIMDM
//  File:       SLOT.H
//
//  Copyright (c) 1992-1996, Microsoft Corporation, all rights reserved
//
//  Revision History
//
//
//  3/25/96     JosephJ             Created
//
//
//  Description: Interface to the unimodem TSP notification mechanism:
//				 The lower level (notifXXXX) APIs
//
//****************************************************************************

#define MAX_NOTIFICATION_NAME_SIZE	256


#define SLOTNAME_UNIMODEM_NOTIFY_TSP 	TEXT("UnimodemNotifyTSP")
#define dwNFRAME_SIG (0x8cb45651L)
#define MAX_NOTIFICATION_FRAME_SIZE	512

typedef PVOID HNOTIFFRAME;

typedef PVOID HNOTIFCHANNEL;

// Server side
typedef BOOL (*PNOTIFICATION_HANDLER)(DWORD dwType, DWORD dwFlags, DWORD dwSize, PVOID pData);

#ifdef UNICODE
    #define notifCreateChannel notifCreateChannelW
#else
    #define notifCreateChannel notifCreateChannelA
#endif

HNOTIFCHANNEL notifCreateChannelA (LPCSTR lptszName, DWORD dwMaxSize, DWORD dwMaxPending);
HNOTIFCHANNEL notifCreateChannelW (LPCWSTR lptszName, DWORD dwMaxSize, DWORD dwMaxPending);
DWORD notifMonitorChannel (HNOTIFCHANNEL hChannel, PNOTIFICATION_HANDLER pHandler, DWORD dwSize, PVOID pParam);

// Client side
#ifdef UNICODE
    #define notifOpenChannel   notifOpenChannelW
#else
    #define notifOpenChannel   notifOpenChannelA
#endif

HNOTIFCHANNEL notifOpenChannelA (LPCSTR lptszName);
HNOTIFCHANNEL notifOpenChannelW (LPCWSTR lptszName);

HNOTIFFRAME
notifGetNewFrame (
    HNOTIFCHANNEL hChannel,
    DWORD  dwNotificationType,
    DWORD  dwNotificationFlags,
    DWORD  dwBufferSize,
    PVOID *ppFrameBuffer
    );

BOOL notifSendFrame (
    HNOTIFFRAME   hFrane,
    BOOL          bBlocking
    );

// Common to server and client
void notifCloseChannel (HNOTIFCHANNEL hChannel);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\inc\tspnotif.h ===
//****************************************************************************
//
//  Module:     UNIMDM
//  File:       TSPNOTIF.H
//
//  Copyright (c) 1992-1996, Microsoft Corporation, all rights reserved
//
//  Revision History
//
//
//  3/25/96     JosephJ             Created
//
//
//  Description: Interface to  the Unimodem TSP notification mechanism:
//				 the UnimodemNotifyTSP function, and related typedefs...
//				 UnimodemNotifyTSP is private export of the tsp.
//
//****************************************************************************
#ifndef _TSPNOTIF_H_

#define _TSPNOTIF_H_

#ifdef __cplusplus
extern "C" {
#endif


//------------------- Types of notifications --------------------

#define TSPNOTIF_TYPE_CHANNEL   0x1000  // Notification sent by channel

#define TSPNOTIF_TYPE_CPL       0x2000  // Modem CPL Event Notification

#define TSPNOTIF_TYPE_DEBUG     0x4000  // DEBUG Event Notification

//------------------- Common flags ------------------------------
#define fTSPNOTIF_FLAG_UNICODE	(0x1L<<31)	// If set, all embedded text is
											// in UNICODE.


#define TSP_VALID_FRAME(_frame)	((_frame)->dwSig==dwNFRAME_SIG)
#define TSP_DEBUG_FRAME(_frame)	((_frame)->dwType==TSPNOTIF_TYPE_DEBUG)
#define TSP_CPL_FRAME(_frame) 	((_frame)->dwType==TSPNOTIF_TYPE_CPL)

// --------- CHANNEL Notification Flags ---------------------
#define fTSPNOTIF_FLAG_CHANNEL_APC                      0x1

// --------- CPL Notification Structure ---------------------
#define fTSPNOTIF_FLAG_CPL_REENUM    					0x1
#define fTSPNOTIF_FLAG_CPL_DEFAULT_COMMCONFIG_CHANGE	0x2
#define fTSPNOTIF_FLAG_CPL_UPDATE_DRIVER                0x4

// The top-level client-side api to send a notification to the TSP
// If it returns FALSE, GetLastError() will report the reason for failure.
BOOL WINAPI UnimodemNotifyTSP (
    DWORD dwType,
    DWORD dwFlags,
    DWORD dwSize,
    PVOID pData,
    BOOL  bBlocking);

#ifdef __cplusplus
}
#endif
#endif  //  _TSPNOTIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\inc\umdmxfrm.h ===
//---------------------------------------------------------------------------
//
//  Module:   umdmxfrm.h
//
//  Description:
//     Header file for UMDMXFRM module
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//
//  History:   Date       Author      Comment
//             8/31/95    MMaclin
//
//@@END_MSINTERNAL
/**************************************************************************
 *
 *  Copyright (c) 1991 - 1995	Microsoft Corporation.	All Rights Reserved.
 *
 **************************************************************************/

typedef DWORD (*LPFNXFORM_INIT)(LPVOID,WORD);
typedef DWORD (*LPFNXFORM_GETPOSITION)(LPVOID, DWORD);
typedef VOID  (*LPFNXFORM_GETBUFFERSIZES)(LPVOID, DWORD, LPDWORD, LPDWORD);
typedef DWORD (*LPFNXFORM_TRANSFORM)(LPVOID, LPBYTE, DWORD, LPBYTE, DWORD);

//
// XFORM_INFO structure:
// 
// wObjectSize:         The size of the instance object to be allocated by the caller.
//                      This object will be passed to all of the following functions.
//
// lpfnInit:            This function is called each time the device is opened.
//                      It should return zero to indicate success.
//
// lpfnGetPosition:     This function is called with the number of bytes sent to the
//                      the the modem. It expects in return the corresponding number
//                      of PCM bytes
//
// lpfnGetBufferSizes:  This function is passed the number of samples and expects
//                      in return the buffers sizes (in bytes) needed to be allocated
//                      by the caller.
//
// lpfnTransform1:      This function is the first function to be called when data
//                      needs to be transformed.
//                      It is passed a pointer to the source buffer, the source buffer
//                      size (in bytes), and a pointer to the destination buffer.
//                      It expects in return the number of bytes transferred to the
//                      destination buffer.
// lpfnTransform2:      This function is the second function to be called when data
//                      needs to be transformed
//                      It is passed a pointer to the source buffer, the source buffer
//                      size (in bytes), and a pointer to the destination buffer.
//                      It expects in return the number of bytes transferred to the
//                      destination buffer.
//
typedef struct
{
    WORD                     wObjectSize;
    LPFNXFORM_INIT           lpfnInit;
    LPFNXFORM_GETPOSITION    lpfnGetPosition;
    LPFNXFORM_GETBUFFERSIZES lpfnGetBufferSizes;
    LPFNXFORM_TRANSFORM      lpfnTransformA;
    LPFNXFORM_TRANSFORM      lpfnTransformB;
} XFORM_INFO, FAR *LPXFORM_INFO;

typedef DWORD (FAR PASCAL  *LPFNXFORM_GETINFO)(DWORD, LPXFORM_INFO, LPXFORM_INFO);

// The following function must be defined and exported in the .DEF file
// It is passed an ID which correponds to a unique transform and
// expects the XFORM_INFO structure to be filled in upon returning.
// It should return zero to indicate success.
//
extern DWORD FAR PASCAL  GetXformInfo
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOuput
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\inc\uniplat.h ===
#ifdef __cplusplus
extern "C" {
#endif

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    umdmmini.h

Abstract:

    Nt 5.0 unimodem miniport interface


Author:

    Brian Lieuallen     BrianL        09/10/96

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/




HANDLE WINAPI
UmPlatformInitialize(
    VOID
    );

VOID WINAPI
UmPlatformDeinitialize(
    HANDLE    DriverInstanceHandle
    );



BOOL WINAPI
UnimodemDeviceIoControlEx(
    HANDLE       hFile,             // handle to device of interest
    DWORD        dwIoControlCode,     // control code of operation to perform
    LPVOID       lpInBuffer,          // pointer to buffer to supply input data
    DWORD        nInBufferSize,       // size of input buffer
    LPVOID       lpOutBuffer,         // pointer to buffer to receive output data
    DWORD        nOutBufferSize,      // size of output buffer
    LPOVERLAPPED lpOverlapped,        // pointer to overlapped structure for asynchronous operation
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );


BOOL
UnimodemReadFileEx(
    HANDLE    FileHandle,
    PVOID     Buffer,
    DWORD     BytesToRead,
    LPOVERLAPPED  Overlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );

BOOL WINAPI
UnimodemWriteFileEx(
    HANDLE    FileHandle,
    PVOID     Buffer,
    DWORD     BytesToWrite,
    LPOVERLAPPED  Overlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );





BOOL WINAPI
UnimodemWaitCommEventEx(
    HANDLE     FileHandle,
    LPDWORD    lpEventMask,
    LPOVERLAPPED  Overlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );


BOOL WINAPI
UnimodemQueueUserAPC(
    LPOVERLAPPED  Overlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );


typedef VOID WINAPI TIMER_CALLBACK(HANDLE,HANDLE);

HANDLE WINAPI
CreateUnimodemTimer(
    PVOID            PoolHandle
    );

VOID WINAPI
FreeUnimodemTimer(
    HANDLE                TimerHandle
    );

VOID WINAPI
SetUnimodemTimer(
    HANDLE              TimerHandle,
    DWORD               Duration,
    TIMER_CALLBACK      CallbackFunc,
    HANDLE              Context1,
    HANDLE              Context2
    );

BOOL WINAPI
CancelUnimodemTimer(
    HANDLE                TimerHandle
    );



HANDLE WINAPI
CreateOverStructPool(
    HANDLE      PlatformHandle,
    DWORD       PoolSize
    );

VOID WINAPI
DestroyOverStructPool(
    HANDLE      PoolHandle
    );

PUM_OVER_STRUCT WINAPI
AllocateOverStructEx(
    HANDLE      PoolHandle,
    DWORD       dwExtraBytes
    );
#define AllocateOverStruct(_a) (AllocateOverStructEx(_a,0))

VOID WINAPI
FreeOverStruct(
    PUM_OVER_STRUCT UmOverlapped
    );

VOID WINAPI
ReinitOverStruct(
    PUM_OVER_STRUCT UmOverlapped
    );


BOOL
StartMonitorThread(
    VOID
    );

VOID
StopMonitorThread(
    VOID
    );


LONG WINAPI
SyncDeviceIoControl(
    HANDLE    FileHandle,
    DWORD     IoctlCode,
    LPVOID    InputBuffer,
    DWORD     InputBufferLength,
    LPVOID    OutputBuffer,
    DWORD     OutputBufferLength,
    LPDWORD   BytesTransfered
    );


BOOL WINAPI
WinntIsWorkstation ();

typedef VOID WINAPI REMOVE_CALLBACK(PVOID);

PVOID
MonitorHandle(
    HANDLE    FileHandle,
    REMOVE_CALLBACK  *CallBack,
    PVOID     Context
    );

VOID
StopMonitoringHandle(
    PVOID    Context
    );


VOID
CallBeginning(
    VOID
    );

VOID
CallEnding(
    VOID
    );

VOID
ResetCallCount(
    VOID
    );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\inc\umdmext.h ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 Sample TSP Extension DLL (Win32, user mode DLL)
//
// File
//
//		EX.H
//		Defines extension APIs
//
// History
//
//		04/20/1997  JosephJ Created
//
//


typedef
void // WINAPI
(*PFNUMEXTCLOSEEXTENSIONBINDING)(
    HANDLE hBinding
    );





typedef
LONG                    // TSPI return value
(*PFNEXTENSIONCALLBACK) (
void *pvTspToken,       // Token passed into UmAcceptTSPCall
DWORD dwRoutingInfo,    // Flags that help categorize TSPI call.
    void *pTspParams    // One of almost 100 TASKPARAM_* structures.
            
);


// Following should all be migrated into a COM-style interface.

HANDLE WINAPI
UmExtOpenExtensionBinding(
    HANDLE      ModemDriverHandle,
    DWORD dwTspVersion,     // TAPI version of the TSPI.
    HKEY hKeyDevice,        // Device registry key
    ASYNC_COMPLETION,       // TSPI completion callback supplied by TAPI.
    // DWORD dwTAPILineID,     << OBSOLETE 10/13/1997
    // DWORD dwTAPIPhoneID,    << OBSOLETE 10/13/1997
    PFNEXTENSIONCALLBACK    // Callback to be used  by the minidriver
                            // to submit TSPI calls.
);

typedef
HANDLE //WINAPI
(*PFNUMEXTOPENEXTENSIONBINDING)(
    HANDLE      ModemDriverHandle,
    DWORD dwTspVersion,
    HKEY hKeyDevice,
    ASYNC_COMPLETION,
    // DWORD dwTAPILineID, << OBSOLETE 10/13/1997
    // DWORD dwTAPIPhoneID, << OBSOLETE 10/13/1997
    PFNEXTENSIONCALLBACK
    );


void WINAPI
UmExtCloseExtensionBinding(
    HANDLE hBinding
);

LONG WINAPI             // TSPI return value
UmExtAcceptTspCall(
    HANDLE hBinding,        // handle to extension binding
    void *pvTspToken,       // Token to be specified in callback.
    DWORD dwRoutingInfo,    // Flags that help categorize TSPI call
    void *pTspParams        // one of almost 100 TASKPARRAM_* structures,
    );

typedef
LONG // WINAPI
(*PFNUMEXTACCEPTTSPCALL)(
    HANDLE hBinding,
    void *pvTspToken,
    DWORD dwRoutingInfo,
    void *pTspParams
    );


void WINAPI
UmExtTspiAsyncCompletion(
    HANDLE hBinding,
    DRV_REQUESTID       dwRequestID,
    LONG                lResult
    );

typedef
void // WINAPI
(*PFNUMEXTTSPIASYNCCOMPLETION)(
    HANDLE hBinding,
    DRV_REQUESTID       dwRequestID,
    LONG                lResult
    );

//
// UmExtControl is called with the TSP's internal critical sections held --
// therefore the extension DLL must make sure that it doesn't do any
// activity that could lead to deadlock!
//
DWORD WINAPI
UmExtControl(
    HANDLE hBinding,
    DWORD  dwMsg,
    ULONG_PTR  dwParam1,
    ULONG_PTR  dwParam2,
    ULONG_PTR  dwParam3
    );

typedef
DWORD // WINAPI
(*PFNUMEXTCONTROL)(
    HANDLE hBinding,
    DWORD               dwMsg,
    ULONG_PTR               dwParam1,
    ULONG_PTR               dwParam2,
    ULONG_PTR               dwParam3
    );

//
// The UMEXTCTRL_DEVICE_STATE(ACTIVATE_LINE/PHONE_DEVICE)
// messages tell us the TAPI line- and phone-ID.
// These messages are always sent right after the extension binding
// is sent.
//

#define UMEXTCTRL_DEVICE_STATE                   1L

// dwParam1 is one of the following
#define  UMEXTPARAM_ACTIVATE_LINE_DEVICE        1L
    // dwParam2 == lineID

#define  UMEXTPARAM_ACTIVATE_PHONE_DEVICE       2L
    // dwParam2 == phoneID

void WINAPI
UmExtTspiLineEventProc(
    HANDLE hBinding,
    HTAPILINE           htLine,
    HTAPICALL           htCall,
    DWORD               dwMsg,
    ULONG_PTR               dwParam1,
    ULONG_PTR               dwParam2,
    ULONG_PTR               dwParam3
    );

typedef
void // WINAPI
(*PFNUMEXTTSPILINEEVENTPROC)(
    HANDLE hBinding,
    HTAPILINE           htLine,
    HTAPICALL           htCall,
    DWORD               dwMsg,
    ULONG_PTR               dwParam1,
    ULONG_PTR               dwParam2,
    ULONG_PTR               dwParam3
    );


void WINAPI
UmExtTspiPhoneEventProc(
    HANDLE hBinding,
    HTAPIPHONE          htPhone,
    DWORD               dwMsg,
    ULONG_PTR               dwParam1,
    ULONG_PTR               dwParam2,
    ULONG_PTR               dwParam3
    );


typedef
void // WINAPI
(*PFNUMEXTTSPIPHONEEVENTPROC)(
    HANDLE hBinding,
    HTAPIPHONE          htPhone,
    DWORD               dwMsg,
    ULONG_PTR               dwParam1,
    ULONG_PTR               dwParam2,
    ULONG_PTR               dwParam3
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\inc\vmodem.h ===
#ifndef _VMODEM_
#define _VMODEM_


//
// dwVoiceProfile bit defintions right from the registry
//
#define VOICEPROF_CLASS8ENABLED           0x00000001  // this is the TSP behavior switch
#define VOICEPROF_HANDSET                 0x00000002  // phone device has handset
#define VOICEPROF_SPEAKER                 0x00000004  // phone device has speaker/mic
#define VOICEPROF_HANDSETOVERRIDESSPEAKER 0x00000008  // this is for Presario
#define VOICEPROF_SPEAKERBLINDSDTMF       0x00000010  // this is for Presario

#define VOICEPROF_SERIAL_WAVE             0x00000020  // wave output uses serial driver
#define VOICEPROF_CIRRUS                  0x00000040  // to dial in voice mode the ATDT string must
                                                      // end with a ";"

#define VOICEPROF_NO_CALLER_ID            0x00000080  // modem does not support caller id

#define VOICEPROF_MIXER                   0x00000100  // modem has speaker mixer

#define VOICEPROF_ROCKWELL_DIAL_HACK      0x00000200  // on voice calls force blind dial after
                                                      // dial tone detection. Rockwell modems
                                                      // will do dial tone detection after
                                                      // one dial string

#define VOICEPROF_RESTORE_SPK_AFTER_REC   0x00000400  // reset speaker phone after record
#define VOICEPROF_RESTORE_SPK_AFTER_PLAY  0x00000800  // reset speaker phone after play

#define VOICEPROF_NO_DIST_RING            0x00001000  // modem does not support distinctive ring
#define VOICEPROF_NO_CHEAP_RING           0x00002000  // modem does not use cheap ring ring
                                                      // ignored if VOICEPROF_NO_DISTRING is set
#define VOICEPROF_TSP_EAT_RING            0x00004000  // TSP should eat a ring when dist ring enabled
#define VOICEPROF_MODEM_EATS_RING         0x00008000  // modem eats a ring when dist ring enabled

#define VOICEPROF_MONITORS_SILENCE        0x00010000  // modem monitors silence
#define VOICEPROF_NO_GENERATE_DIGITS      0x00020000  // modem does not generate DTMF digits
#define VOICEPROF_NO_MONITOR_DIGITS       0x00040000  // modem does not monitor DTMF digits

#define VOICEPROF_SET_BAUD_BEFORE_WAVE    0x00080000  // The baud rate will be set before wave start
                                                      // other wise it will be set after the wave start command

#define VOICEPROF_RESET_BAUDRATE          0x00100000  // If set, the baudrate will be reset
                                                      // after the wave stop command is issued
                                                      // used to optimize the number of commands
                                                      // sent if the modem can autobaud at the
                                                      // higher rate

#define VOICEPROF_MODEM_OVERRIDES_HANDSET 0x00200000  // If set, the handset is disconnected when
                                                      // the modem is active

#define VOICEPROF_NO_SPEAKER_MIC_MUTE     0x00400000  // If set, the speakerphone cannot mute the
                                                      // the microphone

#define VOICEPROF_SIERRA                  0x00800000
#define VOICEPROF_WAIT_AFTER_DLE_ETX      0x01000000  // wait for response after record end

#define VOICEPROF_NT5_WAVE_COMPAT         0x02000000  // Wave driver support on NT 5

//
//  dle translation values
//

#define  DTMF_0                    0x00
#define  DTMF_1                    0x01

#define  DTMF_2                    0x02
#define  DTMF_3                    0x03

#define  DTMF_4                    0x04
#define  DTMF_5                    0x05

#define  DTMF_6                    0x06
#define  DTMF_7                    0x07

#define  DTMF_8                    0x08
#define  DTMF_9                    0x09

#define  DTMF_A                    0x0a
#define  DTMF_B                    0x0b

#define  DTMF_C                    0x0c
#define  DTMF_D                    0x0d

#define  DTMF_STAR                 0x0e
#define  DTMF_POUND                0x0f

#define  DTMF_START                0x10
#define  DTMF_END                  0x11



#define  DLE_ETX                   0x20

#define  DLE_OFHOOK                0x21  //rockwell value

#define  DLE_ONHOOK                0x22

#define  DLE_RING                  0x23
#define  DLE_RINGBK                0x24

#define  DLE_ANSWER                0x25
#define  DLE_BUSY                  0x26

#define  DLE_FAX                   0x27
#define  DLE_DIALTN                0x28


#define  DLE_SILENC                0x29
#define  DLE_QUIET                 0x2a


#define  DLE_DATACT                0x2b
#define  DLE_BELLAT                0x2c

#define  DLE_LOOPIN                0x2d
#define  DLE_LOOPRV                0x2e

#define  DLE_______                0xff


#endif // _VMODEM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\inc\waveids.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by F:\nt\private\unimodem\nt50\serwvdrv\strings.rc
//
#define IDS_WAVEOUT_LINE                1
#define IDS_WAVEIN_LINE                 2
#define IDS_WAVEOUT_HANDSET             3
#define IDS_WAVEIN_HANDSET              4

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\mdmdbgex\extension.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    extension.c

Abstract:

    Nt 5.0 unimodem debugger extension



Author:

    Brian Lieuallen     BrianL        10/18/98

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"

WINDBG_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;


BOOL APIENTRY
DllMain(
    HANDLE hDll,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    switch(dwReason) {

        case DLL_PROCESS_ATTACH:


            DisableThreadLibraryCalls(hDll);

            break;

        case DLL_PROCESS_DETACH:


            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:

        default:
              break;

    }

    return TRUE;

}


EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
BOOLEAN                 ChkTarget;
INT                     Item;

DWORD      g_dwFilterInfo;
DWORD      g_dwIfLink;
DWORD      g_dwInIndex,g_dwOutIndex;
DWORD      g_dwCacheSize;

#define CHECK_SIZE(dwRead,dwReq,bRes){                                        \
        if((dwRead) < (dwReq))                                                \
        {                                                                     \
            dprintf("Requested %s (%d) read %d \n",#dwReq,dwReq,dwRead);      \
            dprintf("Error in %s at %d\n",__FILE__,__LINE__);                 \
            bRes = FALSE;                                                     \
        }                                                                     \
        else                                                                  \
        {                                                                     \
            bRes = TRUE;                                                      \
        }                                                                     \
    }

#define READ_MEMORY_ERROR                                                     \
        dprintf("Error in ReadMemory() in %s at line %d\n",__FILE__,__LINE__);


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;
    
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
    
    g_dwIfLink = 0;
    g_dwInIndex = g_dwOutIndex = 0;
    
    return;
}


DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
             );
}

VOID
CheckVersion(
             VOID
             )
{
    
    return;
    
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) 
    {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, 
                (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) 
    {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, 
                (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
                    VOID
                    )
{
    return &ApiVersion;
}

//
// Exported functions
//
DECLARE_API( help )

/*++

Routine Description:

    Command help for IP Filter debugger extensions.

Arguments:

    None

Return Value:

    None
    
--*/

{
    INIT_API()

    dprintf("\n\tUnimodem debugger extension commands:\n\n");
    dprintf("\n\tCompiled on " __DATE__ " at " __TIME__ "\n" );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\mdmdbgex\object.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    extension.c

Abstract:

    Nt 5.0 unimodem debugger extension



Author:

    Brian Lieuallen     BrianL        10/18/98

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"


#include "..\atmini\object.h"


DECLARE_API( miniobject )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    counted (ansi) string.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    DWORD_PTR dwObjectAddress;
    BOOL b;

    CHAR CleanupSymbol[64];
    CHAR CloseSymbol[64];
    DWORD_PTR Displacement;


    OBJECT_HEADER   Object;

    INIT_API();

    //
    // Evaluate the argument string to get the address of
    // the string to dump.
    //

    dwObjectAddress = GetExpression(lpArgumentString);

    if ( dwObjectAddress == 0 ) {

        return;
    }

    b = ReadMemory(
            dwObjectAddress,
            &Object,
            sizeof(Object),
            NULL
            );

    if ( !b ) {

        return;
    }

    //
    // Get the symbolic name of the string
    //

    GetSymbol((LPVOID)Object.CleanUpRoutine,CleanupSymbol,&Displacement);

    GetSymbol((LPVOID)Object.CloseRoutine,CloseSymbol,&Displacement);

    dprintf(
        "\r\nUnimodem Minidriver object header\r\n    Signature %c%c%c%c\r\n    RefCount %d\r\n"
        "    OwnerObject %p\r\n    Flags %08lx\r\n"
        "    Cleanup Handler - %s\r\n"
        "    Close Handler   - %s\r\n",
        (BYTE)(Object.Signature),(BYTE)(Object.Signature >> 8),(BYTE)(Object.Signature >> 16), (BYTE)(Object.Signature >> 24),
        Object.ReferenceCount,
        Object.OwnerObject,
        Object.dwFlags,
        CleanupSymbol,
        CloseSymbol
        );


    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\mdmdbgex\internal.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    extension.c

Abstract:

    Nt 5.0 unimodem debugger extension



Author:

    Brian Lieuallen     BrianL        10/18/98

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/


// The following four includes must be included for the debugging extensions
// to compile.
//
#include <nt.h>
#include <ntverp.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>


#define NOEXTAPI
#include <wdbgexts.h>
#undef DECLARE_API

#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif


#define DECLARE_API(s)                          \
    CPPMOD VOID                                 \
    s(                                          \
        HANDLE hCurrentProcess,                 \
        HANDLE hCurrentThread,                  \
        DWORD_PTR dwCurrentPc,                  \
        PWINDBG_EXTENSION_APIS lpExtensionApis, \
        LPSTR lpArgumentString                  \
     )

#define INIT_API() {                            \
    ExtensionApis = *lpExtensionApis;           \
    ExtensionCurrentProcess = hCurrentProcess;  \
    }

#define dprintf                 (ExtensionApis.lpOutputRoutine)
#define GetExpression           (ExtensionApis.lpGetExpressionRoutine)
#define GetSymbol               (ExtensionApis.lpGetSymbolRoutine)
#define Disasm                  (ExtensionApis.lpDisasmRoutine)
#define CheckControlC           (ExtensionApis.lpCheckControlCRoutine)
#define ReadMemory(a,b,c,d) \
    ((ExtensionApis.nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
    ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) ) \
  : ExtensionApis.lpReadProcessMemoryRoutine( (ULONG_PTR)(a), (b), (c), (d) ))

#define WriteMemory(a,b,c,d) \
    ((ExtensionApis.nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) ) \
  : ExtensionApis.lpWriteProcessMemoryRoutine( (ULONG_PTR)(a), (LPVOID)(b), (c), (d) ))


extern WINDBG_EXTENSION_APIS ExtensionApis;
extern HANDLE ExtensionCurrentProcess;



#include "..\inc\debugmem.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\mdminst\detect.h ===
//
// detect.h
//

#ifndef __DETECT_H__
#define __DETECT_H__


#define MAX_REG_KEY_LEN         128

#define MAX_MODEM_ID_LEN    (8 + 8)     // 8 digits in "UNIMODEM" and 8 
                                        //  hex digits in a dword


//-----------------------------------------------------------------------------------
//  Detection error values and structure
//-----------------------------------------------------------------------------------

// These are manifest constants that are roughly equivalent
// to some Win32 errors.  We use these errors privately.
#define ERROR_PORT_INACCESSIBLE     ERROR_UNKNOWN_PORT
#define ERROR_NO_MODEM              ERROR_SERIAL_NO_DEVICE


// These values are for diagnostics
#define NOT_DETECTING 0
#define DETECTING_NO_CANCEL 1
#define DETECTING_CANCEL 2

#ifdef DIAGNOSTIC
extern int g_DiagMode;
#endif //DIAGNOSTIC

BOOL
SelectNewDriver(
    IN HWND             hDlg,
    IN HDEVINFO         hdi,
    IN PSP_DEVINFO_DATA pdevData);

// This structure is a context block for the DetectSig_Compare
// function.
typedef struct
{
    DWORD DevInst;
    TCHAR szPort[LINE_LEN];
    TCHAR szHardwareID[LINE_LEN];
    TCHAR szInfName[LINE_LEN];
    TCHAR szInfSection[LINE_LEN];
} COMPARE_PARAMS, *PCOMPARE_PARAMS;


BOOL
InitCompareParams (IN  HDEVINFO          hdi,
                   IN  PSP_DEVINFO_DATA  pdevData,
                   IN  BOOL              bCmpPort,
                   OUT PCOMPARE_PARAMS pcmpParams);

BOOL
Modem_Compare (IN PCOMPARE_PARAMS pCmpParams,
               IN HDEVINFO         hdi,
               IN PSP_DEVINFO_DATA pDevData);

DWORD
CALLBACK
DetectSig_Compare(
    IN HDEVINFO         hdi,
    IN PSP_DEVINFO_DATA pdevDataNew,
    IN PSP_DEVINFO_DATA pdevDataExisting,
    IN PVOID            lParam);            OPTIONAL



HANDLE
PUBLIC
OpenDetectionLog();

void
PUBLIC
CloseDetectionLog(
    IN  HANDLE hLog);


BOOL
IsModemControlledDevice(
    IN  HANDLE FileHandle);

#endif // __DETECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\mdminst\dll.h ===
//
// dll.h
//

#ifndef __DLL_H__
#define __DLL_H__

extern HINSTANCE g_hinst;

#ifdef WIN32

// Notes:
//  1. Never "return" from the critical section.
//  2. Never "SendMessage" or "Yield" from the critical section.
//  3. Never call USER API which may yield.
//  4. Always make the critical section as small as possible.
//  5. Critical sections in Win95 block across processes.  In NT
//     they are per-process only, so use mutexes instead.
// 

#define WIN32_CODE(x)       x

void PUBLIC Dll_EnterExclusive(void);
void PUBLIC Dll_LeaveExclusive(void);
extern BOOL g_bExclusive;

#define ENTER_X()    Dll_EnterExclusive();
#define LEAVE_X()    Dll_LeaveExclusive();
#define ASSERT_X()   ASSERT(g_bExclusive)

#else   // WIN32

#define WIN32_CODE(x)

#define ENTER_X()    
#define LEAVE_X()    
#define ASSERT_X()   

#endif  // WIN32

#endif  //!__DLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\mdmdbgex\memory.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    extension.c

Abstract:

    Nt 5.0 unimodem debugger extension



Author:

    Brian Lieuallen     BrianL        10/18/98

Environment:

    User Mode     Operating Systems        : NT

Revision History:



--*/

#include "internal.h"




#include "..\debugmem\debug.h"

DECLARE_API( unimodemheap )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    counted (ansi) string.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    DWORD_PTR dwAddrString;
    BOOL b;

    MEMORY_HEADER   Header;

    INIT_API();

    //
    // Evaluate the argument string to get the address of
    // the string to dump.
    //

    dwAddrString = GetExpression(lpArgumentString);

    if ( dwAddrString == 0 ) {

        return;
    }

    b = ReadMemory(
            dwAddrString-sizeof(Header),
            &Header,
            sizeof(Header),
            NULL
            );

    if ( !b ) {

        return;
    }


    dprintf(
        "Debug Memory Header for %p\r\nRequested Size is %d\r\nFrom line %d \r\n",
        dwAddrString,
        Header.RequestedSize,
        Header.LineNumber
        );

    if ((DWORD_PTR)Header.SelfPointer != dwAddrString) {

        dprintf("Memory header SelfPointer is bad %p\r\n",Header.SelfPointer);
    }


    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\mdminst\detect.c ===
/*
 *  Detection routines for modems.
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1993-1994
 *  All rights reserved
 *
 */

#include "proj.h"

#include <devioctl.h>
#include <ntddmodm.h>

#define CR '\r'        
#define LF '\n'        

#define RESPONSE_RCV_DELAY      5000    // A long time (5 secs) because 
                                        // once we have acquired the modem 
                                        // we can afford the wait.

#define MAX_QUERY_RESPONSE_LEN  100
#define MAX_SHORT_RESPONSE_LEN  30      // echo of ATE0Q0V1<cr> and 
                                        // <cr><lf>ERROR<cr><lf> by a 
                                        // little margin

#define ATI0_LEN                30      // amount of the ATI0 query that 
                                        // we will save

#define ATI0                    0       // we will use this result completely
#define ATI4                    4       // we will use this result completely, 
                                        // if it matches the Hayes format 
                                        // (check for 'a' at beginning)

// Return values for the FindModem function
//
#define RESPONSE_USER_CANCEL    (-4)    // user requested cancel
#define RESPONSE_UNRECOG        (-3)    // got some chars, but didn't 
                                        //  understand them
#define RESPONSE_NONE           (-2)    // didn't get any chars
#define RESPONSE_FAILURE        (-1)    // internal error or port error
#define RESPONSE_OK             0       // matched with index of <cr><lf>OK<cr><lf>
#define RESPONSE_ERROR          1       // matched with index of <cr><lf>ERROR<cr><lf>

#ifdef WIN32
typedef HANDLE  HPORT;          // variable type used in FindModem
#else
typedef int     HPORT;          // variable type used in FindModem
#endif

#define IN_QUEUE_SIZE           8192
#define OUT_QUEUE_SIZE          256

#define RCV_DELAY               2000
#define CHAR_DELAY              100

#define CBR_HACK_115200         0xff00  // This is how we set 115,200 on 
                                        //  Win 3.1 because of a bug.

#define UNKNOWN_MODEM_ID    TEXT("MDMUNK")

#pragma data_seg(DATASEG_READONLY)

TCHAR const FAR c_szPortPrefix[]    = TEXT("\\\\.\\%s");  // "\\.\" in ASCII
TCHAR const FAR c_szInfPath[] = REGSTR_VAL_INFPATH;
TCHAR const FAR c_szInfSect[] = REGSTR_VAL_INFSECTION;

char const FAR c_szModemIdPrefix[] = "UNIMODEM";
char const FAR c_szNoEcho[] = "ATE0Q0V1\r";
char const FAR c_szReset[] = "ATZ\r";
char const FAR c_szATPrefix[] = "AT";
char const FAR c_szATSuffix[] = "\r";
char const FAR c_szBlindOnCheck[] = "X3";
char const FAR c_szBlindOnCheckAlternate[] = "X0";
char const FAR c_szBlindOffCheck[] = "X4";

// WARNING!  If you change these, you will have to change ALL of your
// CompatIDs!!!
char const FAR *c_aszQueries[] = { "ATI0\r", "ATI1\r", "ATI2\r",  "ATI3\r",
                                 "ATI4\r", "ATI5\r", "ATI6\r",  "ATI7\r",
                                 "ATI8\r", "ATI9\r", "ATI10\r", "AT%V\r" };

// these are mostly for #'s.  If a numeric is adjoining one of these, it 
// will not be treated as special.
// Warning: Change any of these and you have to redo all of the CRCs!!!!  
// Case insensitive compares
char const FAR *c_aszIncludes[] = { "300",
                                  "1200",
                                  "2400",                         "2,400",
                                  "9600",    "96",     "9.6",     "9,600",
                                  "12000",   "120",    "12.0",    "12,000",
                                  "14400",   "144",    "14.4",    "14,400",
                                  "16800",   "168",    "16.8",    "16,800",
                                  "19200",   "192",    "19.2",    "19,200",
                                  "21600",   "216",    "21.6",    "21,600",
                                  "24000",   "240",    "24.0",    "24,000",
                                  "26400",   "264",    "26.4",    "26,400",
                                  "28800",   "288",    "28.8",    "28,800",
                                  "31200",   "312",    "31.2",    "31,200",
                                  "33600",   "336",    "33.6",    "33,600",
                                  "36000",   "360",    "36.0",    "36,000",
                                  "38400",   "384",    "38.4",    "38,400",
                                  "9624",    "32bis",  "42bis",   "V32",
                                  "V.32",    "V.FC",   "FAST",    "FAX",
                                  "DATA",    "VOICE",  "" };

// Matches will be case-insensitive
char const FAR *c_aszExcludes[] = { "JAN", "FEB", "MAR", "APR", "MAY", "JUN",
                                    "JUL", "AUG", "SEP", "OCT", "NOV", "DEC", 
                                    "" };

// case sensitive matching
char const FAR *c_aszBails[] = { "CONNECT", "RING", "NO CARRIER", 
                                 "NO DIALTONE", "BUSY", "NO ANSWER", "=" };

// start after CBR_9600
UINT const FAR c_auiUpperBaudRates[] = { CBR_19200, CBR_38400, CBR_56000, 
                                         CBR_HACK_115200 }; 

char const FAR *c_aszResponses[] = { "\r\nOK\r\n", "\r\nERROR\r\n" };

// Some MultiTech's send 0<cr> in response to AT%V (they go 
// into numeric mode)
char const FAR *c_aszNumericResponses[] = { "0\r", "4\r" };  

char const FAR c_szHex[] = "0123456789abcdef";

struct DCE {
    char  pszStr[4];
    DWORD dwDce;
    DWORD dwAlternateDce;
} DCE_Table[] = {
    "384", 38400, 300,   // Some PDI's will report 38400, and this won't work for them.
    "360", 36000, 300,
    "336", 33600, 300,
    "312", 31200, 300,
    "288", 28800, 2400,
    "264", 26400, 2400,
    "240", 24000, 2400,
    "216", 21600, 2400,
    "192", 19200, 1200,
    "168", 16800, 1200,
    "14",  14400, 1200,
    "120", 12000, 1200,
    "9",   9600,  300,
    "2",   2400,  300,
    "1",   1200,  300,
    "3",   300,   0
};

#pragma data_seg()



#define ToUpper(ch) (IsCharLowerA(ch) ? (ch) - 'a' + 'A' : (ch))
#define ishex(ch)   ((ToUpper(ch) >= 'A' && ToUpper(ch) <= 'F') ? TRUE : FALSE)
#define isnum(num)  ((num >= '0' && num <= '9') ? TRUE : FALSE)

#ifdef SLOW_DETECT
#define MAX_TEST_TRIES 4
#else //SLOW_DETECT
#define MAX_TEST_TRIES 1
#endif //SLOW_DETECT

#define MAX_LOG_PRINTF_LEN 256
void _cdecl LogPrintf(HANDLE hLog, UINT uResourceFmt, ...);

DWORD NEAR PASCAL FindModem(PDETECTCALLBACK pdc, HPORT hPort);

#ifdef DEBUG
void HexDump( TCHAR *, LPCSTR lpBuf, DWORD cbLen);
#define	HEXDUMP(_a, _b, _c) HexDump(_a, _b, _c)
#else // !DEBUG
#define	HEXDUMP(_a, _b, _c) ((void) 0)
#endif

DWORD 
PRIVATE
IdentifyModem(
    IN  PDETECTCALLBACK pdc,
    IN  HPORT   hPort, 
    OUT LPTSTR  pszModemName, 
    IN  HANDLE  hLog, 
    OUT LPSTR   lpszATI0Result);

BOOL 
PRIVATE
TestBaudRate(
    IN  HPORT hPort, 
    IN  UINT uiBaudRate,
    IN  DWORD dwRcvDelay,
    IN  PDETECTCALLBACK pdc, 
    OUT BOOL FAR *lpfCancel);

DWORD 
NEAR PASCAL 
SetPortBaudRate(
    HPORT hPort, 
    UINT BaudRate);
int    
NEAR PASCAL 
ReadResponse(
    HPORT hPort, 
    LPBYTE lpvBuf, 
    UINT uRead, 
    BOOL fMulti,
    DWORD dwRcvDelay, 
    PDETECTCALLBACK pdc);
UINT
NEAR PASCAL 
ReadPort(
    HPORT hPort, 
    LPBYTE lpvBuf, 
    UINT uRead, 
    DWORD dwRcvDelay,
    int FAR *lpiError, 
    PDETECTCALLBACK pdc, 
    BOOL FAR *lpfCancel);


DWORD NEAR PASCAL CBR_To_Decimal(UINT uiCBR);
LPSTR NEAR ConvertToPrintable(LPCSTR pszIn, LPSTR pszOut, UINT uOut);

// Does a printf to a log, using a resource string as the format.
// WARNING: Do not try to print large strings.
void _cdecl LogPrintf(HANDLE hLog, UINT uResourceFmt, ...)
{
    char pFmt[MAX_LOG_PRINTF_LEN];
    char pOutput[MAX_LOG_PRINTF_LEN];
    UINT uCount, uWritten;
    va_list vArgs;

    if (hLog != INVALID_HANDLE_VALUE)
    {
        if (LoadStringA(g_hinst, uResourceFmt, pFmt, MAX_LOG_PRINTF_LEN))
        {
            va_start(vArgs, uResourceFmt);
            uCount = wvsprintfA(pOutput, pFmt, vArgs);
            va_end(vArgs);

            WriteFile(hLog, (LPCVOID)pOutput, uCount, &uWritten, NULL);
        }
    }
}

int FAR PASCAL mylstrncmp(LPCSTR pchSrc, LPCSTR pchDest, int count)
{
    for ( ; count && *pchSrc == *pchDest; pchSrc++, pchDest++, count--) {
        if (*pchSrc == '\0')
            return 0;
    }
    return count;
}

int FAR PASCAL mylstrncmpi(LPCSTR pchSrc, LPCSTR pchDest, int count)
{
    for ( ; count && ToUpper(*pchSrc) == ToUpper(*pchDest); pchSrc++, pchDest++, count--) {
        if (*pchSrc == '\0')
            return 0;
    }
    return count;
}

#ifdef WIN32

DWORD 
WINAPI
MyWriteComm(
    HANDLE hPort, 
    LPCVOID lpBuf,
    DWORD cbLen)
{
    COMMTIMEOUTS cto;
    DWORD        cbLenRet;

    HEXDUMP	(TEXT("Write"), lpBuf, cbLen);
    // Set comm timeout
    if (!GetCommTimeouts(hPort, &cto))
    {
      ZeroMemory(&cto, sizeof(cto));
    };

    // Allow a constant write timeout
    cto.WriteTotalTimeoutMultiplier = 0;
    cto.WriteTotalTimeoutConstant   = 1000; // 1 second
    SetCommTimeouts(hPort, &cto);

    // Synchronous write
    WriteFile(hPort, lpBuf, cbLen, &cbLenRet, NULL);
    return cbLenRet;
}

#define MyFlushComm     PurgeComm
#define MyCloseComm     CloseHandle

#else   // WIN32

#define MyWriteComm     WriteComm
#define MyCloseComm     CloseComm

#ifndef PURGE_TXCLEAR
#define PURGE_TXCLEAR   0x00000001
#endif
#ifndef PURGE_RXCLEAR
#define PURGE_RXCLEAR   0x00000002
#endif

BOOL
PRIVATE
MyFlushComm(
    HANDLE  hport,
    DWORD   dwAction)
    {
    if (IsFlagSet(dwAction, PURGE_TXCLEAR))
        {
        FlushComm((int)hport, 0);
        }

    if (IsFlagSet(dwAction, PURGE_RXCLEAR))
        {
        FlushComm((int)hport, 1);
        }

    return TRUE;
    }

#endif  // WIN32


/*----------------------------------------------------------
Purpose: Open the modem detection log.

Returns: handle to the open file
         NULL if the file could not be opened
Cond:    --
*/
HANDLE
PUBLIC
OpenDetectionLog()
{
    TCHAR szLogPath[MAX_PATH];
    UINT cch;
    HANDLE hLog;

    // open the log file
    cch = GetWindowsDirectory(szLogPath, SIZECHARS(szLogPath));
    if (0 == cch)
    {
        hLog = INVALID_HANDLE_VALUE;
    }
    else
    {                                                      
        if (*CharPrev(szLogPath, szLogPath + cch) != TEXT('\\'))
        {
            szLogPath[cch++] = (TCHAR)'\\';
        }
        LoadString(g_hinst, IDS_DET_LOG_NAME, &szLogPath[cch],
                   SIZECHARS(szLogPath) - (cch - 1));

        // error return will be HFILE_ERROR, so no need to check since 
        // we will handle that during writes
        TRACE_MSG(TF_DETECT, "Opening detection log file '%s'", (LPTSTR)szLogPath);

        hLog = CreateFile(szLogPath, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL, NULL);

        if (hLog == INVALID_HANDLE_VALUE)
        {
            TRACE_MSG(TF_ERROR, "Modem CreateFile() failed!");
        }
        else
        {
         SYSTEMTIME LocalTime;
         char szBuffer[256];

            SetFilePointer (hLog, 0, NULL, FILE_END);
            LogPrintf (hLog, IDS_DET_OK_1, "\r\n");
            GetLocalTime (&LocalTime);
            if (0 < GetDateFormatA (LOCALE_SYSTEM_DEFAULT, DATE_LONGDATE, &LocalTime,
                                    NULL, szBuffer, sizeof(szBuffer)))
            {
                LogPrintf (hLog, IDS_DET_OK_1, szBuffer);
            }
            if (0 < GetTimeFormatA (LOCALE_SYSTEM_DEFAULT, 0, &LocalTime,
                                    NULL, szBuffer, sizeof(szBuffer)))
            {
                LogPrintf (hLog, IDS_DET_OK_1, szBuffer);
            }
            LogPrintf (hLog, IDS_DET_OK_1, "\r\n");
        }
    }

    return hLog;
}


/*----------------------------------------------------------
Purpose: Closes the detection log file.

Returns: --
Cond:    --
*/
void
PUBLIC
CloseDetectionLog(
    IN  HANDLE hLog)
    {
    if (INVALID_HANDLE_VALUE != hLog)
        {
        TRACE_MSG(TF_DETECT, "Closing detection log");
        CloseHandle(hLog);
        }
    }    


/*----------------------------------------------------------
Purpose: Set the current port we're updating in the progress
         bar.
Returns: --
Cond:    --
*/
void 
PRIVATE 
DetectSetPort(
    PDETECTCALLBACK pdc,
    LPCTSTR lpcszName)
    {
    if (pdc && pdc->pfnCallback)
        {
        try
            {
            pdc->pfnCallback(DSPM_SETPORT, (LPARAM)lpcszName, pdc->lParam);
            }
        except (EXCEPTION_EXECUTE_HANDLER)
            {
            ;
            }
        }
    }


/*----------------------------------------------------------
Purpose: Set the current msg we're updating in the Detect wizard page.
Returns: --
Cond:    --
*/
void 
PUBLIC 
DetectSetStatus(
    PDETECTCALLBACK pdc,
    DWORD           nStatus)
    {
    if (pdc && pdc->pfnCallback)
        {
        try
            {
            pdc->pfnCallback(DSPM_SETSTATUS, (LPARAM)nStatus, pdc->lParam);
            }
        except (EXCEPTION_EXECUTE_HANDLER)
            {
            ;
            }
        }
    }


/*----------------------------------------------------------
Purpose: Query's whether we are supposed to cancel the detection.  Also
         yields.
Returns: TRUE if we should cancel.  FALSE otherwise.
Cond:    --
*/
BOOL 
PRIVATE 
DetectQueryCancel(
    PDETECTCALLBACK pdc)
    {
    BOOL bRet = FALSE;

    if (pdc && pdc->pfnCallback)
        {
        try
            {
            bRet = pdc->pfnCallback(DSPM_QUERYCANCEL, 0, pdc->lParam);
            }
        except (EXCEPTION_EXECUTE_HANDLER)
            {
            bRet = FALSE;
            }
        }
    return bRet;
    }

BOOL
IsModemControlledDevice(
    HANDLE     FileHandle
    )

{

    DWORD        BytesTransfered;
    BOOL         bResult;


    //
    //  send this ioctl down, if modem.sys is at the top of the chain it will return success
    //
    bResult=DeviceIoControl(
        FileHandle,
        IOCTL_MODEM_CHECK_FOR_MODEM,
        NULL,
        0,
        NULL,
        0,
        &BytesTransfered,
        NULL
        );

    if (!bResult) {

        return FALSE;
    }


    return TRUE;

}


typedef enum
{
    ENUM_NOT_FOUND = 0,
    ENUM_FOUND_OLD
} ENUM_RESULT;

// config mgr private
DWORD
CMP_WaitNoPendingInstallEvents(
    IN DWORD dwTimeout
    );


ENUM_RESULT
PnPDeviceOnPort (
    IN HDEVINFO         hdi,
    IN HPORTMAP         hportmap,
    IN LPCTSTR          pszPort)
{
 TCHAR szTemp[MAX_BUF];
 CONFIGRET cr;
 ENUM_RESULT Ret = ENUM_NOT_FOUND;

    DBG_ENTER_SZ(PnPDeviceOnPort, pszPort);

    if (NULL != hportmap)
    {
     DEVINST devInst;

        if (PortMap_GetDevNode (hportmap, pszPort, &devInst) &&
            0 != devInst)
        {
         DEVINST devInstChild;

            if (CR_SUCCESS ==
                CM_Get_Child (&devInstChild, devInst, 0))
            {
             DWORD dwConfigFlags;
             DWORD cbData = sizeof(dwConfigFlags);

                Ret = ENUM_FOUND_OLD;
                if (CR_SUCCESS ==
                    CM_Get_DevInst_Registry_Property (devInstChild, CM_DRP_CONFIGFLAGS, NULL,
                                                      &dwConfigFlags, &cbData, 0))
                {
                    TRACE_MSG(TF_GENERAL, "ConfigFlags: %#lx.", dwConfigFlags);
                    if (CONFIGFLAG_FAILEDINSTALL & dwConfigFlags)
                    {
                        TRACE_MSG(TF_GENERAL, "%s has a device whose installation failed!", pszPort);
                        Ret = ENUM_NOT_FOUND;
                    }
                }
                ELSE_TRACE ((TF_GENERAL, "CM_Get_DevInst_Registry_Property failed!"));
            }
            ELSE_TRACE ((TF_GENERAL, "CM_Get_Child failed!"));
        }
        ELSE_TRACE ((TF_GENERAL, "PortMap_GetDevNode failed!"));
    }
    ELSE_TRACE ((TF_GENERAL, "hportmap is NULL."));

    TRACE_MSG(TF_GENERAL, "Returning %s.", ENUM_NOT_FOUND==Ret?L"ENUM_NOT_FOUND":(ENUM_FOUND_OLD==Ret?L"ENUM_FOUND_OLD":L"ENUM_FOUND_NEW"));
    DBG_EXIT(PnPDeviceOnPort);
    return Ret;
}



/*----------------------------------------------------------
Purpose: This function queries the given port to find a legacy
         modem.

         If a modem is detected and we recognize it (meaning 
         we have the hardware ID in our INF files), or if we
         successfully create a generic hardware ID and 
         inf file, then this function also creates the phantom
         device instance of this modem.

         NOTE (scotth):  in Win95, this function only detected 
         the modem and returned the hardware ID and device 
         description.  For NT, this function also creates the 
         device instance.  I made this change because it is
         faster.

Returns: NO_ERROR
         ERROR_PORT_INACCESSIBLE
         ERROR_NO_MODEM
         ERROR_ACCESS_DENIED
         ERROR_CANCELLED

Cond:    --
*/
DWORD 
PUBLIC
DetectModemOnPort(
    IN  HDEVINFO            hdi,
    IN  PDETECTCALLBACK     pdc,
    IN  HANDLE              hLog, 
    IN  LPCTSTR             pszPort,
    IN  HPORTMAP            hportmap,
    OUT PSP_DEVINFO_DATA    pdevDataOut)
{
 DWORD dwRet;
 HPORT hPort;
 HCURSOR hCursor;
 DWORD cbLen;
 char szATI0Result[ATI0_LEN];
 char szASCIIPort[LINE_LEN];
 TCHAR *pszLocalHardwareID = NULL;
#ifdef PROFILE_FIRSTTIMESETUP
 DWORD dwLocal;
#endif //PROFILE_FIRSTTIMESETUP

#if defined(WIN32)
    TCHAR szPrefixedPort[MAX_BUF + sizeof(c_szPortPrefix)];
#endif
    
    DBG_ENTER(DetectModemOnPort);

    ASSERT(pszPort);

    DetectSetPort(pdc, pszPort);

#ifdef  UNICODE
    // Convert the port name to ASCII
    WideCharToMultiByte(CP_ACP, 0, pszPort, -1, szASCIIPort, SIZECHARS(szASCIIPort),
                        NULL, NULL);
#else
    lstrcpyA(szASCIIPort, pszPort);
#endif  // UNICODE

    switch (PnPDeviceOnPort (hdi,
                             hportmap,
                             pszPort))
    {
        case ENUM_FOUND_OLD:
            dwRet = ERROR_NO_MODEM;
            break;

        case ENUM_NOT_FOUND:
        {
            pszLocalHardwareID = LocalAlloc (LPTR, (MAX_MODEM_ID_LEN+1)*2*sizeof(TCHAR));   // prepare for 2 IDs
            if (NULL == pszLocalHardwareID)
            {
                dwRet = ERROR_NOT_ENOUGH_MEMORY;
                goto _Exit;
            }

    #ifdef SKIP_MOUSE_PORT
            // Is this port used by a serial mouse?
            if (0 == lstrcmpi(g_szMouseComPort, pszPort))
                {
                // Yes; skip it
                TRACE_MSG(TF_ERROR, "Serial mouse on this port, skipping");
                dwRet = ERROR_NO_MODEM;
                goto _Exit;
                }
    #endif
    
            // Open the port

    #if !defined(WIN32)
            hPort = OpenComm(pszPort, IN_QUEUE_SIZE, OUT_QUEUE_SIZE);
    #else
            wsprintf(szPrefixedPort, c_szPortPrefix, pszPort);
            hPort = CreateFile( szPrefixedPort, 
                                GENERIC_WRITE | GENERIC_READ,
                                0, NULL,
                                OPEN_EXISTING, 0, NULL);
    #endif

            if (hPort == INVALID_HANDLE_VALUE)
            {
                dwRet = GetLastError();
                if (dwRet == ERROR_ACCESS_DENIED) {
                    TRACE_MSG(TF_ERROR, "Port is in use by another app");
                    LogPrintf(hLog, IDS_DET_INUSE, szASCIIPort);
                }
                else  {
                    TRACE_MSG(TF_ERROR, "Couldn't open port");
                    LogPrintf(hLog, IDS_DET_COULDNT_OPEN, szASCIIPort);
                }
            }
            else
            {

                //
                // see if modem is controlling this device
                //
                if (IsModemControlledDevice(hPort)) {

                    TRACE_MSG(TF_ERROR, "Port is controlled by a (PnP) modem");
                    LogPrintf(hLog, IDS_DET_COULDNT_OPEN, szASCIIPort);
                    MyCloseComm(hPort);
                    dwRet=ERROR_ACCESS_DENIED;

                }
		        else
		        {
                    if (!SetupComm (hPort, IN_QUEUE_SIZE, OUT_QUEUE_SIZE))
					{
						TRACE_MSG(TF_ERROR, "SetupComm failed. Perhaps this is not really a COM port.");
						MyCloseComm(hPort);
						dwRet = ERROR_NO_MODEM;
						goto _Exit;
					}

                    TRACE_MSG(TF_DETECT, "Opened Port");

                    // Check for a modem on the port

                    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

#ifdef PROFILE_FIRSTTIMESETUP
                    dwLocal = GetTickCount ();
#endif //PROFILE_FIRSTTIMESETUP
                    dwRet = FindModem(pdc, hPort);
#ifdef PROFILE_FIRSTTIMESETUP
                    TRACE_MSG(TF_GENERAL, "PROFILE: FindModem took %lu.", GetTickCount()-dwLocal);
#endif //PROFILE_FIRSTTIMESETUP

                    if (dwRet == NO_ERROR)
                    {
                        // We have a modem.  No matter what, we must return
                        // NO_ERROR (unless the user cancels).
                        LogPrintf(hLog, IDS_DET_FOUND, szASCIIPort);

                        // Could we identify the modem?
#ifdef PROFILE_FIRSTTIMESETUP
                        dwLocal = GetTickCount ();
#endif //PROFILE_FIRSTTIMESETUP
                        dwRet = IdentifyModem(pdc, hPort, pszLocalHardwareID, hLog, szATI0Result);
#ifdef PROFILE_FIRSTTIMESETUP
                        TRACE_MSG(TF_GENERAL, "PROFILE: IdentifyModem took %lu.", GetTickCount()-dwLocal);
#endif //PROFILE_FIRSTTIMESETUP
                        if (ERROR_CANCELLED == dwRet)
                        {
                            goto _Exit;
                        }
                        if (NO_ERROR != dwRet)
                        {
                            TRACE_MSG(TF_DETECT, "Couldn't identify modem due to some kind of error.");
                            dwRet = NO_ERROR;
                            goto _AddUnknown;
                        }

                        DetectSetStatus(pdc, DSS_CHECK_FOR_COMPATIBLE);

                        // Is there a device that is compatible with this
                        // hardware ID?  If there is, this function will also
                        // create a phantom device instance with a working
                        // set of compatible drivers.
                        if (CplDiCreateCompatibleDeviceInfo (hdi,
                                                             pszLocalHardwareID,
                                                             NULL,
                                                             pdevDataOut))
                        {
                            // Yes; a device instance was created!
					        if (DetectQueryCancel(pdc))
					        {
						        TRACE_MSG(TF_DETECT, "User pressed cancel.");
						        dwRet = ERROR_CANCELLED;
					        }
                        }
                        else
                        {
                            // Doh!  No matching inf for this compat id.  Must create a generic one...
                            TRACE_MSG(TF_DETECT, "No compatible infs found. Add \"Unknown Modem\" and try again.");
    _AddUnknown:

                            if (NO_ERROR == dwRet &&
                                CatMultiString (&pszLocalHardwareID, UNKNOWN_MODEM_ID))
                            {
                                DetectSetStatus(pdc, DSS_CHECK_FOR_COMPATIBLE);

                                // Try creating a device that is compatible with
                                // the generic modem
                                if ( !CplDiCreateCompatibleDeviceInfo(hdi,
                                                                      pszLocalHardwareID,
                                                                      NULL,
                                                                      pdevDataOut) )
                                {
                                    // This still failed.  Give up.
                                    //
                                    dwRet = GetLastError();
                                    ASSERT(NO_ERROR != dwRet);
                                }
                            }
                        }

                        // Reset
                        cbLen = lstrlenA(c_szReset);
                        if (MyWriteComm(hPort, (LPBYTE)c_szReset, cbLen) == cbLen &&
                            ERROR_CANCELLED != dwRet)
                        {
                            // Now read the result of the write and ignore it
                            if (RESPONSE_OK != ReadResponse (hPort, NULL,
                                                             MAX_SHORT_RESPONSE_LEN,
                                                             FALSE, 0, pdc))
                            {
                                TRACE_MSG(TF_ERROR, "Reset result failed");
                            }
                        }
                        else
                        {
                            TRACE_MSG(TF_ERROR, "Couldn't write Reset string");
                        }
                    }
                    else
                    {
                        if (ERROR_CANCELLED != dwRet)
                        {
                            LogPrintf(hLog, IDS_DET_NOT_FOUND, szASCIIPort);
                        }
                    }

                    SetCursor(hCursor);

                    // Flush before closing becuase if there are characters stuck in the queue,
                    // serial.386 will take 30 seconds to time out.

                    MyFlushComm(hPort, PURGE_RXCLEAR | PURGE_TXCLEAR);
                    EscapeCommFunction(hPort, CLRDTR);
                    MyCloseComm(hPort);

                }

            }  // hPort < 0


    _Exit:

            if (NULL != pszLocalHardwareID)
            {
                LocalFree (pszLocalHardwareID);
            }

            break;
        }
    }

    DBG_EXIT_DWORD(DetectModemOnPort, dwRet);
    return dwRet;
}


#ifdef DIAGNOSTIC
BOOL CancelDiag (void)
{
 BOOL bRet = FALSE;

    if (DETECTING_NO_CANCEL == g_DiagMode)
    {
     MSG msg;
        while (PeekMessage (&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage (&msg);
            DispatchMessage (&msg);
        }

        bRet = (DETECTING_CANCEL == g_DiagMode);
    }

    return bRet;
}
#endif //DIAGNOSTIC

// Switch to requested baud rate and try sending ATE0Q0V1 and return whether it works or not
// Try MAX_TEST_TRIES
// Returns: TRUE on SUCCESS
//          FALSE on failure (including user cancels)
BOOL 
WINAPI
TestBaudRate (
    IN  HPORT hPort, 
    IN  UINT uiBaudRate,
    IN  DWORD dwRcvDelay, 
    IN  PDETECTCALLBACK pdc,
    OUT BOOL FAR *lpfCancel)
{
    DWORD cbLen;
    int   iTries = MAX_TEST_TRIES;

    DBG_ENTER(TestBaudRate);
    
    *lpfCancel = FALSE;

    while (iTries--)
    {
#ifdef DIAGNOSTIC
        if (CancelDiag ())
        {
            *lpfCancel = TRUE;
            break;
        }
#endif //DIAGNOSTIC

        // try new baud rate
        if (SetPortBaudRate(hPort, uiBaudRate) == NO_ERROR) 
        {
            cbLen = lstrlenA (c_szNoEcho); // Send an ATE0Q0V1<cr>

            // clear the read queue, there shouldn't be anything there
            PurgeComm(hPort, PURGE_RXCLEAR);
            if (MyWriteComm (hPort, (LPBYTE)c_szNoEcho, cbLen) == cbLen) 
            {
                switch (ReadResponse (hPort, NULL, MAX_SHORT_RESPONSE_LEN, FALSE, dwRcvDelay, pdc))
                {
                case RESPONSE_OK:
                    DBG_EXIT(TestBaudRate);
                    return TRUE;

                case RESPONSE_USER_CANCEL:
                    *lpfCancel = TRUE;
                    break;
                }
            }                                                                
        }
    }
    DBG_EXIT(TestBaudRate);
    return FALSE;
}

// Tries to figure out if there is a modem on the port.  If there is, it
// will try to find a good speed to talk to it at (300,1200,2400,9600).
// Modem will be set to echo off, result codes on, and verbose result codes. (E0Q0V1)
DWORD 
WINAPI
FindModem(
    PDETECTCALLBACK pdc,
    HPORT hPort)
{
    UINT uGoodBaudRate=0;
    BOOL fCancel = FALSE;

    DBG_ENTER(FindModem);
    
#ifdef SLOW_DETECT
    Sleep(500); // Wait, give time for modem to spew junk if any.

    DetectSetStatus(pdc, DSS_LOOKING);

    if (TestBaudRate(hPort, CBR_9600, 500, pdc, &fCancel))
    {
        uGoodBaudRate = CBR_9600;
    }
    else
    {
        if (!fCancel && TestBaudRate(hPort, CBR_2400, 500, pdc, &fCancel))
        {
            uGoodBaudRate = CBR_2400;
        }
        else
        {
            if (!fCancel && TestBaudRate(hPort, CBR_1200, 500, pdc, &fCancel))
            {
                uGoodBaudRate = CBR_1200;
            }
            else
            {
                // Hayes Accura 288 needs this much at 300bps
                if (!fCancel && TestBaudRate(hPort, CBR_300, 1000, pdc, &fCancel))  
                {
                    uGoodBaudRate = CBR_300;
                }
                else
                {
                    uGoodBaudRate = 0;
                }
            }
        }
    }
#else //SLOW_DETECT
    DetectSetStatus(pdc, DSS_LOOKING);
    if (TestBaudRate(hPort, CBR_9600, 500, pdc, &fCancel))
    {
        uGoodBaudRate = CBR_9600;
    }
    else if (!fCancel && TestBaudRate(hPort, CBR_2400, 500, pdc, &fCancel))
    {
        uGoodBaudRate = CBR_2400;
    }
#endif //SLOW_DETECT

    if (fCancel)
    {
        return ERROR_CANCELLED;
    }

    if (uGoodBaudRate)
    {
        DetectSetStatus(pdc, DSS_FOUND_MODEM);
        DBG_EXIT(FindModem);
        return NO_ERROR;
    }
    else
    {
        DetectSetStatus(pdc, DSS_FOUND_NO_MODEM);
        DBG_EXIT(FindModem);
        return ERROR_NO_MODEM;
    }
}



DWORD NEAR PASCAL SetPortBaudRate(HPORT hPort, UINT BaudRate)
{
    DCB DCB;

    DBG_ENTER_UL(SetPortBaudRate, CBR_To_Decimal(BaudRate));

    // Get a Device Control Block with current port values

    if (GetCommState(hPort, &DCB) < 0) {
        TRACE_MSG(TF_ERROR, "GetCommState failed");
        DBG_EXIT(SetPortBaudRate);
        return ERROR_PORT_INACCESSIBLE;
    }

    DCB.BaudRate = BaudRate;
    DCB.ByteSize = 8;
    DCB.Parity = 0;
    DCB.StopBits = 0;
    DCB.fBinary = 1;
    DCB.fParity = 0;
    DCB.fDtrControl = DTR_CONTROL_ENABLE;
    DCB.fDsrSensitivity  = FALSE;
    DCB.fRtsControl = RTS_CONTROL_ENABLE;
    DCB.fOutxCtsFlow = FALSE;
    DCB.fOutxDsrFlow = FALSE;
    DCB.fOutX = FALSE;
    DCB.fInX =FALSE;

    if (SetCommState(hPort, &DCB) < 0) {
        TRACE_MSG(TF_ERROR, "SetCommState failed");
        DBG_EXIT(SetPortBaudRate);
        return ERROR_PORT_INACCESSIBLE;
    }
    TRACE_MSG(TF_DETECT, "SetBaud rate to %lu", BaudRate);

    DBG_EXIT(SetPortBaudRate);
    return NO_ERROR;
}

#define MAX_RESPONSE_BURST_SIZE 8192
#define MAX_NUM_RESPONSE_READ_TRIES 30 // digicom scout needs this much + some safety
#define MAX_NUM_MULTI_TRIES 3   // Maximum number of 'q's to be sent when we aren't getting any response

// Read in response.  Handle multi-pagers.  Return a null-terminated string.
// Also returns response code.
// If lpvBuf == NULL
//      cbRead indicates the max amount to read.  Bail if more than this.
// Else
//      cbRead indicates the size of lpvBuf
// This can not be a state driven (ie. char by char) read because we
// must look for responses from the end of a sequence of chars backwards.
// This is because "ATI2" on some modems will return 
// "<cr><lf>OK<cr><lf><cr><lf>OK<cr><lf>" and we only want to pay attention
// to the final OK.  Yee haw!
// Returns:  RESPONSE_xxx
int 
WINAPI
ReadResponse (
    HPORT hPort, 
    LPBYTE lpvBuf, 
    UINT cbRead, 
    BOOL fMulti, 
    DWORD dwRcvDelay,
    PDETECTCALLBACK pdc)
{
    int  iRet = RESPONSE_UNRECOG;
    LPBYTE pszBuffer;
    BOOL fDoCopy = TRUE;
    UINT uBufferLen, uResponseLen;
    UINT uReadTries = MAX_NUM_RESPONSE_READ_TRIES;
    UINT i;
    UINT uOutgoingBufferCount = 0;
    UINT uAllocSize = lpvBuf ? MAX_RESPONSE_BURST_SIZE : cbRead;
    UINT uTotalReads = 0;
    UINT uNumMultiTriesLeft = MAX_NUM_MULTI_TRIES;
    int  iError;
    BOOL fCancel;
    BOOL fHadACommError = FALSE;

    ASSERT(cbRead);

    // do we need to adjust cbRead?
    if (lpvBuf)
    {
        cbRead--;  // preserve room for terminator
    }

    // Allocate buffer
    if (!(pszBuffer = (LPBYTE)ALLOCATE_MEMORY(uAllocSize)))
    {
        TRACE_MSG(TF_ERROR, "couldn't allocate memory.\n");
        return RESPONSE_FAILURE;
    }

    while (uReadTries--)
    {
        // Read response into buffer
        uBufferLen = ReadPort (hPort, pszBuffer, uAllocSize, dwRcvDelay, &iError, pdc, &fCancel);

        // Did the user request a cancel?
        if (fCancel)
        {
            iRet = RESPONSE_USER_CANCEL;
            goto Exit;
        }

        // any errors?
        if (iError)
        {
            fHadACommError = TRUE;
#ifdef DEBUG
            if (iError & CE_RXOVER)   TRACE_MSG(TF_DETECT, "CE_RXOVER");
            if (iError & CE_OVERRUN)  TRACE_MSG(TF_DETECT, "CE_OVERRUN");
            if (iError & CE_RXPARITY) TRACE_MSG(TF_DETECT, "CE_RXPARITY");
            if (iError & CE_FRAME)    TRACE_MSG(TF_DETECT, "CE_FRAME");
            if (iError & CE_BREAK)    TRACE_MSG(TF_DETECT, "CE_BREAK");
            //if (iError & CE_CTSTO)    TRACE_MSG(TF_DETECT, "CE_CTSTO");
            //if (iError & CE_DSRTO)    TRACE_MSG(TF_DETECT, "CE_DSRTO");
            //if (iError & CE_RLSDTO)   TRACE_MSG(TF_DETECT, "CE_RLSDTO");
            if (iError & CE_TXFULL)   TRACE_MSG(TF_DETECT, "CE_TXFULL");
            if (iError & CE_PTO)      TRACE_MSG(TF_DETECT, "CE_PTO");
            if (iError & CE_IOE)      TRACE_MSG(TF_DETECT, "CE_IOE");
            if (iError & CE_DNS)      TRACE_MSG(TF_DETECT, "CE_DNS");
            if (iError & CE_OOP)      TRACE_MSG(TF_DETECT, "CE_OOP");
            if (iError & CE_MODE)     TRACE_MSG(TF_DETECT, "CE_MODE");
#endif // DEBUG
        }

        // Did we not get any chars?
        if (uBufferLen)
        {
            uNumMultiTriesLeft = MAX_NUM_MULTI_TRIES; // reset num multi tries left, since we got some data
            uTotalReads += uBufferLen;
            HEXDUMP(TEXT("Read"), pszBuffer, uBufferLen);
            if (lpvBuf)
            {
                // fill outgoing buffer if there is room
                for (i = 0; i < uBufferLen; i++)
                {
                    if (uOutgoingBufferCount < cbRead)
                    {
                        lpvBuf[uOutgoingBufferCount++] = pszBuffer[i];
                    }
                    else
                    {
                        break;
                    }
                }
                // null terminate what we have so far
                lpvBuf[uOutgoingBufferCount] = 0;
            }
            else
            {
                if (uTotalReads >= cbRead)
                {
                    TRACE_MSG(TF_WARNING, "Bailing ReadResponse because we exceeded our maximum read allotment.");
                    goto Exit;
                }
            }

            // try to find a matching response (crude but quick)
            for (i = 0; i < ARRAYSIZE(c_aszResponses); i++)
            {
                // Verbose responses
                uResponseLen = lstrlenA(c_aszResponses[i]);

                // enough read to match this response?
                if (uBufferLen >= uResponseLen)
                {
                    if (!mylstrncmp(c_aszResponses[i], pszBuffer + uBufferLen - uResponseLen, uResponseLen))
                    {
                        iRet = i;
                        goto Exit;
                    }
                }

                // Numeric responses, for cases like when a MultiTech interprets AT%V to mean "go into numeric response mode"
                uResponseLen = lstrlenA(c_aszNumericResponses[i]);

                // enough read to match this response?
                if (uBufferLen >= uResponseLen)
                {
                    if (!mylstrncmp(c_aszNumericResponses[i], pszBuffer + uBufferLen - uResponseLen, uResponseLen))
                    {
                        DCB DCB;

                        TRACE_MSG(TF_WARNING, "went into numeric response mode inadvertantly.  Setting back to verbose.");

                        // Get current baud rate
                        if (GetCommState(hPort, &DCB) == 0) 
                        {
                            // Put modem back into Verbose response mode
                            if (!TestBaudRate (hPort, DCB.BaudRate, 0, pdc, &fCancel))
                            {
                                if (fCancel)
                                {
                                    iRet = RESPONSE_USER_CANCEL;
                                    goto Exit;
                                }
                                else
                                {
                                    TRACE_MSG(TF_ERROR, "couldn't recover contact with the modem.");
                                    // don't return error on failure, we have good info
                                }
                            }
                        }
                        else
                        {
                            TRACE_MSG(TF_ERROR, "GetCommState failed");
                            // don't return error on failure, we have good info
                        }

                        iRet = i;
                        goto Exit;
                    }
                }
            }
        }
        else
        {
            // have we received any chars at all (ie. from this or any previous reads)?
            if (uTotalReads)
            {
                if (fMulti && uNumMultiTriesLeft)
                {   // no match found, so assume it is a multi-pager, send a 'q'
                    // 'q' will catch those pagers that will think 'q' means quit.
                    // else, we will work with the pages that just need any ole' char.  
                    uNumMultiTriesLeft--;
                    TRACE_MSG(TF_DETECT, "sending a 'q' because of a multi-pager.");
                    if (MyWriteComm(hPort, "q", 1) != 1)
                    {
                        TRACE_MSG(TF_ERROR, "WriteComm failed");
                        iRet = RESPONSE_FAILURE;
                        goto Exit;
                    }
                    continue;
                }
                else
                {   // we got a response, but we didn't recognize it
                    ASSERT(iRet == RESPONSE_UNRECOG);   // check initial setting
                    goto Exit;
                }
            }
            else
            {   // we didn't get any kind of response
                iRet = RESPONSE_NONE;
                goto Exit;
            }
        }
    } // while

Exit:
    // Free local buffer
    FREE_MEMORY(pszBuffer);
    if (fHadACommError && RESPONSE_USER_CANCEL != iRet)
    {
        iRet = RESPONSE_FAILURE;
    }
    return iRet;
}


// WARNING - DO NOT CHANGE THIS FUNCTION!!!!!!  YOU WILL HAVE TO DO A LOT OF WORK IF YOU DO!!!
// WARNING - DO NOT CHANGE THIS FUNCTION!!!!!!  YOU WILL HAVE TO DO A LOT OF WORK IF YOU DO!!!
// WARNING - DO NOT CHANGE THIS FUNCTION!!!!!!  YOU WILL HAVE TO DO A LOT OF WORK IF YOU DO!!!
// WARNING - DO NOT CHANGE THIS FUNCTION!!!!!!  YOU WILL HAVE TO DO A LOT OF WORK IF YOU DO!!!
// WARNING - DO NOT CHANGE THIS FUNCTION!!!!!!  YOU WILL HAVE TO DO A LOT OF WORK IF YOU DO!!!
// WARNING - DO NOT CHANGE THIS FUNCTION!!!!!!  YOU WILL HAVE TO DO A LOT OF WORK IF YOU DO!!!
// You will have to change all of the inf files if you change the CRC results.
//
// Traverse lpszIn and copy "pure" chars to lpszOut.
// Remove any "impurities" such as:
//   - "bails" - find one of these and cancel the rest of the line
//   - numerics/hexadecimal on any line but ATI0 and possibly ATI4, and
//     not including the "includes".  Includes are only used if they
//     aren't adjoining another #.
//
void NEAR CleanseResponse(int iQueryNumber, LPSTR lpszIn, LPSTR lpszOut)
{
    LPSTR lpszSrc = lpszIn;
    LPSTR lpszDest = lpszOut;
    LPSTR FAR *lppsz;
    BOOL fBail = FALSE;
    BOOL fInclude = FALSE;
    BOOL fExclude = FALSE;
    BOOL fInBody = FALSE;
    BOOL fCopyAll;
    int j, iLen;

    // Is this query exempt?
    fCopyAll = (iQueryNumber == ATI0) ? TRUE : FALSE;

    while (*lpszSrc)
    {
        // use any CRs or LFs we get before non-CRs/no-LFs.
        if (*lpszSrc == CR || *lpszSrc == LF)
        {
            if (fInBody)
            {
                break;
            }
            else
            {
                *lpszDest++ = *lpszSrc++;
                continue;
            }
        }

        // is this the first char of the body?
        if (!fInBody)
        {
            fInBody = TRUE; // indicate that the next CR or LF means termination.
            if (iQueryNumber == ATI4 && *lpszSrc == 'a')  // Hayes format capabilities string
            {
                fCopyAll = TRUE;
                *lpszDest++ = *lpszSrc++;
                continue;
            }
        }

        if (fCopyAll) // are we jammin?  (happens for ATI0 and ATI4 when first char is 'a')
        {
            // Only do a verbatim copy of the first word of the ATI0 response.
            if (iQueryNumber == ATI0 && *lpszSrc == ' ')
            {
                fCopyAll = FALSE;
            }
            else
            {
                *lpszDest++ = *lpszSrc++;
            }
            continue;
        }

        // Do Bails
        for (j = 0; j < ARRAYSIZE(c_aszBails); j++)
        {
            if (!mylstrncmp(lpszSrc, c_aszBails[j], lstrlenA(c_aszBails[j])))
            {
                fBail = TRUE;
                break;
            }
        }        
        if (fBail)  // should we bail?
        {
            TRACE_MSG(TF_DETECT, "early bail due to Bail '%s'", (LPTSTR)c_aszBails[j]);
            break;
        }

        // Do Includes
        lppsz = (LPSTR FAR *)c_aszIncludes;
        while (**lppsz)
        {
            iLen = lstrlenA(*lppsz);
            if (!mylstrncmpi(lpszSrc, *lppsz, iLen))
            {
                // check before and after to make sure they aren't numbers.
                // catches  33489600394, 9600 won't be exempted from certain death in this case
                if (!isnum(lpszSrc[-1]) && !isnum(lpszSrc[iLen]))
                {
                    fInclude = TRUE;
                    break;
                }
                else
                {
                    TRACE_MSG(TF_DETECT, "skipped an include because it was adjoined by numbers.");
                }
            }
            lppsz++;
        }             
        if (fInclude) // should we do the include?
        {
            fInclude = FALSE;
            TRACE_MSG(TF_DETECT, "include ('%s' len = %d)", (LPTSTR)*lppsz, iLen);
            CopyMemory(lpszDest, lpszSrc, (DWORD) iLen);
            lpszSrc += iLen;
            lpszDest += iLen;
            continue;
        }   

        // Do Excludes
        lppsz = (LPSTR FAR *)c_aszExcludes;
        while (**lppsz)
        {
            iLen = lstrlenA(*lppsz);
            if (!mylstrncmpi(lpszSrc, *lppsz, iLen))
            {
                fExclude = TRUE;
                break;
            }
            lppsz++;
        }             
        if (fExclude) // should we do the exclude?
        {
            fExclude = FALSE;
            TRACE_MSG(TF_DETECT, "exclude ('%s' len = %d)", (LPTSTR)*lppsz, iLen);
            lpszSrc += iLen;
            continue;
        }   

        // Remove numbers
        if (isnum(*lpszSrc))
        {
            lpszSrc++;
            continue;
        }

        // Remove hex digits (keep only if adjoining 1 or 2 non-hex letters)
        if (ishex(*lpszSrc))
        {
            // we know there is a char or null ahead of us...
            if ((lpszSrc[1] >= 'g' && lpszSrc[1] <= 'z') ||
                (lpszSrc[1] >= 'G' && lpszSrc[1] <= 'Z'))
            {
                *lpszDest++ = *lpszSrc++;
                continue;
            }

            // is there a char before us?
            if (lpszSrc > lpszIn)
            {
                if ((lpszSrc[-1] >= 'g' && lpszSrc[-1] <= 'z') ||
                    (lpszSrc[-1] >= 'G' && lpszSrc[-1] <= 'Z'))
                {
                    *lpszDest++ = *lpszSrc++;
                    continue;
                }
            }

            // we get here if we don't want to copy the hex digit
            lpszSrc++;
            continue;
        }
        
        // Remove lone letters (ex. 4M4 - reject, 4MM - accept)
        if (IsCharAlphaA(*lpszSrc))
        {
            if (!IsCharAlphaA(lpszSrc[-1]) && !IsCharAlphaA(lpszSrc[1]))
            {
                lpszSrc++;
                continue;
            }
        }

        // Remove certain punctuation: periods, commas, and spaces
        // Will protect against things like "1992, 1993." -> "1992, 1993, 1994"
        if (*lpszSrc == '.' || *lpszSrc == ',' || *lpszSrc == ' ')
        {
            lpszSrc++;
            continue;
        }

        // whatever's left is okay to copy
        *lpszDest++ = *lpszSrc++;
     }

    *lpszSrc = 0;  // for log comparison sake
    *lpszDest = 0;
}

#define MAX_RESPONSE_FAILURES 5

// When we get here, we have found a modem on the hPort.  Our job is 
// to interogate the modem and return a hardware ID.

// returns:
//  NO_ERROR and a PnP id in pszModemName
//  ERROR_PORT_INACCESSIBLE
//  result of ATI0 query in lpszATI0Result
DWORD 
PRIVATE
IdentifyModem(
    IN  PDETECTCALLBACK pdc,
    IN  HPORT   hPort, 
    OUT LPTSTR  pszModemName, 
    IN  HANDLE  hLog, 
    OUT LPSTR   lpszATI0Result)
{
    DWORD cbLen;
    char  pszReadBuf[MAX_QUERY_RESPONSE_LEN];
    char  pszCRCBuf[MAX_QUERY_RESPONSE_LEN];
    LPSTR lpszPtr;
    char  pszPrintableBuf[MAX_QUERY_RESPONSE_LEN];
    int   iRet, i, j;
    int   iCurQuery;
    int   iResponseFailureCount;
    ULONG ulCrcTable[256], ulCrc;
    char  szASCIIModem[MAX_MODEM_ID_LEN+1];

    ASSERT(pszModemName);
    ASSERT(lpszATI0Result);
    *lpszATI0Result = (TCHAR)0; // null-terminate in case we fail
    *pszModemName = (TCHAR)0;

    DBG_ENTER(IdentifyModem);
    

    // Build CRC table
    for (i = 0; i < 256; i++)
    {
        ulCrc = i;
        for (j = 8; j > 0; j--) 
        {
            if (ulCrc & 1) 
            {
                ulCrc = (ulCrc >> 1) ^ 0xEDB88320L;
            } 
            else
            {
                ulCrc >>= 1;
            }
        }
        ulCrcTable[i] = ulCrc;
    }

    // Init ulCrc
    ulCrc = 0xFFFFFFFF;

    // Do each query.
    for (iCurQuery = 0, iResponseFailureCount = 0;
         iCurQuery < ARRAYSIZE(c_aszQueries); iCurQuery++)
    {
        DetectSetStatus(pdc, DSS_QUERYING_RESPONSES);
#ifndef PROFILE_MASSINSTALL
        TRACE_MSG(TF_DETECT, "sending query '%s'.",
                 ConvertToPrintable(c_aszQueries[iCurQuery],
                                    pszPrintableBuf,
                                    sizeof(pszPrintableBuf)));
#endif
        cbLen = lstrlenA(c_aszQueries[iCurQuery]);
        if (MyWriteComm(hPort, (LPBYTE)c_aszQueries[iCurQuery], cbLen) != cbLen) 
        {
            TRACE_MSG(TF_ERROR, "WriteComm failed");
            iRet = RESPONSE_FAILURE;  // spoof ReadResponse return for following switch handler
        }
        else
        {
            // Read in response.  Handle multi-pagers.  Return a null-terminated
            // string containing all or part of the response.  Return response
            // code.
            iRet = ReadResponse (hPort, (LPBYTE)pszReadBuf, sizeof(pszReadBuf), TRUE,
                                 RESPONSE_RCV_DELAY, pdc);

#ifdef DEBUG
            switch (iRet)
            {
            case RESPONSE_FAILURE:
                TRACE_MSG(TF_DETECT, "ReadResponse returned RESPONSE_FAILURE");
                break;
            case RESPONSE_UNRECOG:
                TRACE_MSG(TF_DETECT, "ReadResponse returned RESPONSE_UNRECOG");
                break;
            case RESPONSE_NONE:
                TRACE_MSG(TF_DETECT, "ReadResponse returned RESPONSE_NONE");
                break;
            case RESPONSE_USER_CANCEL:
                TRACE_MSG(TF_DETECT, "ReadResponse returned RESPONSE_USER_CANCEL");
                break;
            }
#endif // DEBUG
        }

        switch (iRet)
        {
        case RESPONSE_USER_CANCEL:
            return ERROR_CANCELLED;

        case RESPONSE_FAILURE:
        case RESPONSE_UNRECOG:
        case RESPONSE_NONE:
            iResponseFailureCount++;
            if (iResponseFailureCount >= MAX_RESPONSE_FAILURES)
            {
                TRACE_MSG(TF_ERROR, "had %d failed responses, aborting IdentifyModem()", iResponseFailureCount);
                return ERROR_PORT_INACCESSIBLE;
            }
            else
            {
                DCB DCB;
                BOOL fCancel;

                // Get current baud rate
                if (GetCommState(hPort, &DCB) < 0) 
                {
                    TRACE_MSG(TF_ERROR, "GetCommState failed");
                    return ERROR_PORT_INACCESSIBLE;
                }

                if (!TestBaudRate (hPort, DCB.BaudRate, 0, pdc, &fCancel))  // attempt to recover friendship with the modem
                {
                    if (fCancel)
                    {
                        return ERROR_CANCELLED;
                    }
                    else
                    {
                        TRACE_MSG(TF_ERROR, "couldn't recover contact with the modem.");
                        return ERROR_PORT_INACCESSIBLE;
                    }
                }
                iCurQuery--;    // try the same query again
            }
            break;

        case RESPONSE_OK:
        case RESPONSE_ERROR:
            CleanseResponse(iCurQuery, pszReadBuf, pszCRCBuf);
            
            if (ATI0 == iCurQuery)
            {
                ASSERT(ATI0_LEN <= sizeof(pszCRCBuf));  // make sure we are doing a legal copy
                CopyMemory(lpszATI0Result, pszCRCBuf, ATI0_LEN);
            }

            lpszPtr = (LPSTR) pszCRCBuf;

            while (*lpszPtr)
            {
                ulCrc = ((ulCrc >> 8) & 0x00FFFFFF) ^ ulCrcTable[(ulCrc ^ *lpszPtr++) & 0xFF];
            }


            LogPrintf(hLog, IDS_DET_OK_1,
                      ConvertToPrintable(c_aszQueries[iCurQuery],
                                         pszPrintableBuf,
                                         sizeof(pszPrintableBuf)));
            LogPrintf(hLog, IDS_DET_OK_2,
                      ConvertToPrintable(pszReadBuf,
                                         pszPrintableBuf,
                                         sizeof(pszPrintableBuf)));
#ifndef PROFILE_MASSINSTALL
            TRACE_MSG(TF_DETECT, "response (len=%d): %s", lstrlenA(pszReadBuf),
                     ConvertToPrintable(pszReadBuf,
                                        pszPrintableBuf,
                                        sizeof(pszPrintableBuf)));
#endif
            LogPrintf(hLog, IDS_DET_OK_1,
                      ConvertToPrintable(c_aszQueries[iCurQuery],
                                         pszPrintableBuf,
                                         sizeof(pszPrintableBuf)));
            LogPrintf(hLog, IDS_DET_OK_2,
                      ConvertToPrintable(pszCRCBuf,
                                         pszPrintableBuf,
                                         sizeof(pszPrintableBuf)));
#ifndef PROFILE_MASSINSTALL
            TRACE_MSG(TF_DETECT, "converted form   : %s",
                     ConvertToPrintable(pszCRCBuf,
                                        pszPrintableBuf,
                                        sizeof(pszPrintableBuf)));
#endif
            iResponseFailureCount = 0;  // reset count of failed responses to 0 for upcoming query
            break;
            
        default:
            TRACE_MSG(TF_ERROR, "hit a default it shouldn't have hit.");
            ASSERT(0);
            return ERROR_PORT_INACCESSIBLE;
        }
    }

    // Finish up CRC
    ulCrc ^= 0xFFFFFFFF;

    lstrcpyA(szASCIIModem, c_szModemIdPrefix);
    j = lstrlenA(szASCIIModem);

    // Convert CRC into hex text.
    for (i = 0; i < 8; i++)
    {
        szASCIIModem[i+j] = "0123456789ABCDEF"[(ulCrc>>((7-i)<<2))&0xf];
    }
    szASCIIModem[i+j] = 0; // null-terminate

    DBG_EXIT(IdentifyModem);
    TRACE_MSG(TF_DETECT, "final CRC = 0x%8lx (ascii = %s)", ulCrc, szASCIIModem);

    LogPrintf(hLog, IDS_DET_ID, szASCIIModem);

#ifdef  UNICODE
    MultiByteToWideChar(CP_ACP, 0, szASCIIModem, -1, pszModemName, MAX_MODEM_ID_LEN+1);
    // match lstrcpyn behaviour of always null-terminating the line.
    pszModemName[MAX_MODEM_ID_LEN]=0;
#else
    lstrcpynA(pszModemName, szASCIIModem, MAX_MODEM_ID_LEN+1);
#endif  // UNICODE
                          
    return NO_ERROR;
}

// returns buffer full o' data and an int.
// if dwRcvDelay is NULL, default RCV_DELAY will be used, else
// dwRcvDelay (miliseconds) will be used
// *lpfCancel will be true if we are exiting because of a user requested cancel.
UINT 
PRIVATE
ReadPort(
    HPORT   hPort, 
    LPBYTE  lpvBuf, 
    UINT    uRead, 
    DWORD   dwRcvDelay, 
    int FAR *lpiError, 
    PDETECTCALLBACK pdc, 
    BOOL FAR *lpfCancel)
{
    DWORD cb, cbLenRet;
    UINT uTotal = 0;
    DWORD tStart;
    DWORD dwDelay;
    COMSTAT comstat;
    COMMTIMEOUTS cto;
    DWORD   dwError;
    DWORD cbLeft;
#ifdef DEBUG
    DWORD dwZeroCount = 0;
#endif // DEBUG

    ASSERT(lpvBuf);
    ASSERT(uRead);
    ASSERT(lpiError);

    *lpiError = 0;
    *lpfCancel = FALSE;
    
    tStart = GetTickCount();
    dwDelay = dwRcvDelay ? dwRcvDelay : RCV_DELAY;
    
    // save space for terminator
    uRead--;
    cbLeft=uRead;


    // Set comm timeout
    if (!GetCommTimeouts(hPort, &cto))
    {
      ZeroMemory(&cto, sizeof(cto));
    };
    // Allow a constant write timeout
    cto.ReadIntervalTimeout        = 0;
    cto.ReadTotalTimeoutMultiplier = 0;
    cto.ReadTotalTimeoutConstant   = 25; 
    SetCommTimeouts(hPort, &cto);

    do
    {
        cb = 0;
        while(  cbLeft
                && ReadFile(hPort, lpvBuf + uTotal + cb, 1, &cbLenRet, NULL)
                && (cbLenRet))
        {
          ASSERT(cbLenRet==1);
          cb ++;
          cbLeft--;
        };

#ifdef DEBUG
        if (cb)
        {
           // TRACE_MSG(TF_DETECT, "ReadComm returned %d (zero count = %d)", cb, dwZeroCount);    
            dwZeroCount = 0;
        }
        else
        {
            dwZeroCount++;
        }
#endif // DEBUG

        {
            MSG msg;

            while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                DispatchMessage(&msg);
            };
        }

        if (cb == 0)  // possible error?
        {
            //*lpiError |= GetCommError(hPort, &comstat);
            dwError = 0;
            ClearCommError(hPort, &dwError, &comstat);
            *lpiError |= dwError;
#ifdef DEBUG
            if (dwError)
            {
              TRACE_MSG(TF_DETECT, "ReadComm returned %d, comstat: status = %hx, in = %u, out = %u",
                                  cb, dwError, comstat.cbInQue, comstat.cbOutQue);
            };
#endif // DEBUG
        }

        if (cb)
        {
            // successful read - add to total and reset delay
            uTotal += cb;

            if (uTotal >= uRead)
            {
                ASSERT(uTotal == uRead);
                break;
            }
            tStart = GetTickCount();
            dwDelay = CHAR_DELAY;
        }
        else
        {
            if (DetectQueryCancel(pdc))
            {
                TRACE_MSG(TF_DETECT, "User pressed cancel.");
                *lpfCancel = TRUE;
                break;
            }
        }

     // While read is successful && time since last read < delay allowed)       
    } while (cbLeft && (GetTickCount() - tStart) < dwDelay);
               
    *(lpvBuf+uTotal) = 0;
    
#ifndef PROFILE_MASSINSTALL
    TRACE_MSG(TF_DETECT, "ReadPort returning %d", uTotal);    
#endif
    return uTotal;
}


// Convert CBR format speeds to decimal.  Returns 0 on error
DWORD NEAR PASCAL CBR_To_Decimal(UINT uiCBR)
{
    DWORD dwBaudRate;

    switch (uiCBR)
    {
    case CBR_300:
        dwBaudRate = 300L;
        break;
    case CBR_1200:
        dwBaudRate = 1200L;
        break;
    case CBR_2400:
        dwBaudRate = 2400L;
        break;
    case CBR_9600:
        dwBaudRate = 9600L;
        break;
    case CBR_19200:
        dwBaudRate = 19200L;
        break;
    case CBR_38400:
        dwBaudRate = 38400L;
        break;
    case CBR_56000:
        dwBaudRate = 57600L;
        break;
    case CBR_HACK_115200:
        dwBaudRate = 115200L;
        break;
//    case CBR_110:
//    case CBR_600:
//    case CBR_4800:
//    case CBR_14400:
//    case CBR_128000:
//    case CBR_256000:
    default:
        TRACE_MSG(TF_ERROR, "An unsupported CBR_x value was used.");
        dwBaudRate = 0;
        break;
    }
    return dwBaudRate;
}

// Convert pszIn to a printable pszOut, not using more than cbOut bytes.
// WARNING: Not a DBCS function.
// Returns a pointer to the output buffer.  Always successful.
LPSTR NEAR ConvertToPrintable(LPCSTR lpszIn, LPSTR lpszOut, UINT uOut)
{
    LPSTR lpszReturn = lpszOut;

    ASSERT(lpszOut);
    ASSERT(lpszIn);
    ASSERT(uOut);

    uOut--;  // save space for the null-terminator

    while (*lpszIn)
    {
        // ascii printable chars are between 0x20 and 0x7e, inclusive                                    
        if (*lpszIn >= 0x20 && *lpszIn <= 0x7e)
        {
            // printable text
            if (uOut)
            {
                uOut--;
                *lpszOut++ = *lpszIn;
            }
            else
            {
                break;
            }
        }
        else
        {
            // binary
            if (uOut >= 4)
            {
                uOut -= 4;
                switch (*lpszIn)
                {
                case CR:
                    *lpszOut++ = '<'; *lpszOut++ = 'c'; *lpszOut++ = 'r'; *lpszOut++ = '>';
                    break;
                case LF:
                    *lpszOut++ = '<'; *lpszOut++ = 'l'; *lpszOut++ = 'f'; *lpszOut++ = '>';
                    break;
                default:
                    *lpszOut++ = '<';
                    *lpszOut++ = c_szHex[(*lpszIn>>4) & 0xf];
                    *lpszOut++ = c_szHex[*lpszIn & 0xf];
                    *lpszOut++ = '>';
                }
            }
            else
            {
                break;
            }
        }
        lpszIn++;
    }

    *lpszOut = 0; // make sure we are null-terminated

    return lpszReturn;
}



BOOL
InitCompareParams (IN  HDEVINFO         hdi,
                   IN  PSP_DEVINFO_DATA pdevData,
                   IN  BOOL             bCmpPort,
                   OUT PCOMPARE_PARAMS  pcmpParams)
{
 BOOL bRet = FALSE;
 SP_DRVINFO_DETAIL_DATA drvDetail = {sizeof(SP_DRVINFO_DETAIL_DATA),0};
 SP_DRVINFO_DATA drvData = {sizeof(SP_DRVINFO_DATA),0};
 PTCHAR pInfName;
 HKEY hKey;
 DWORD cbData;
 DWORD dwRet;

    DBG_ENTER(InitCompareParams);
    // 0. Firt, the devinst
    pcmpParams->DevInst = pdevData->DevInst;

    // 1. If need be, get the port name.
    if (bCmpPort)
    {
     CONFIGRET cr;

        if (CR_SUCCESS != (cr =
            CM_Open_DevInst_Key (pdevData->DevInst, KEY_READ, 0, RegDisposition_OpenAlways, &hKey, CM_REGISTRY_SOFTWARE)))
        {
            TRACE_MSG(TF_ERROR, "Could not open driver registry for device: %#lx.", cr);
            goto _return;
        }

        cbData = sizeof(pcmpParams->szPort);
        dwRet = RegQueryValueEx (hKey, c_szAttachedTo, NULL, NULL, (PBYTE)pcmpParams->szPort, &cbData);
        RegCloseKey (hKey);
        if (ERROR_SUCCESS != dwRet)
        {
            TRACE_MSG(TF_ERROR, "Could not read port value: %#lx.", dwRet);
            goto _return;
        }
    }
    else
    {
        pcmpParams->szPort[0] = 0;
    }

    // 2. Get the hardware ID.
    if (!SetupDiGetDeviceRegistryProperty (hdi, pdevData, SPDRP_HARDWAREID, NULL,
            (PBYTE)pcmpParams->szHardwareID, sizeof(pcmpParams->szHardwareID) / sizeof(TCHAR), NULL))
    {
        TRACE_MSG(TF_ERROR, "SetupDiGetDeviceRegistryProperty failed: %#lx.", GetLastError ());
        if (!CplDiGetHardwareID (hdi, pdevData, NULL, pcmpParams->szHardwareID, sizeof(pcmpParams->szHardwareID) / sizeof(TCHAR), NULL))
        {
            TRACE_MSG(TF_ERROR, "CplDiGetHardwareID failed: %#lx.", GetLastError ());
            goto _return;
        }
    }

    // 3. Get the INF and section from the driver.
    if (SetupDiGetSelectedDriver (hdi, pdevData, &drvData))
    {
        if (!SetupDiGetDriverInfoDetail (hdi, pdevData, &drvData, &drvDetail, sizeof(drvDetail), NULL) &&
            ERROR_INSUFFICIENT_BUFFER != GetLastError ())
        {
            TRACE_MSG(TF_ERROR, "SetupDiGetDriverInfoDetail failed: %#lx.", GetLastError ());
            goto _return;
        }

        // The InfFileName in the driver detail structure might
        // contain a full path;
        pInfName = MyGetFileTitle (drvDetail.InfFileName);

        lstrcpy (pcmpParams->szInfName, pInfName);
        lstrcpy (pcmpParams->szInfSection, drvDetail.SectionName);

        // Everything is OK.
        bRet = TRUE;
    }
    else if (ERROR_NO_DRIVER_SELECTED == GetLastError ())
    {
        // Since this device does not have any driver selected,
        // try to get the information from the registry.
        hKey = SetupDiOpenDevRegKey (hdi, pdevData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ);
        if (INVALID_HANDLE_VALUE == hKey)
        {
            TRACE_MSG(TF_ERROR, "No driver is selected and SetupDiOpenDevRegKey failed: %#lx.", GetLastError ());
            goto _return;
        }
        
        // Red the inf
        cbData = sizeof(pcmpParams->szInfName);
        dwRet = RegQueryValueEx (hKey, REGSTR_VAL_INFPATH, NULL, NULL, (PBYTE)pcmpParams->szInfName, &cbData);
        if (ERROR_SUCCESS == dwRet)
        {
            cbData = sizeof(pcmpParams->szInfSection);
            dwRet = RegQueryValueEx (hKey, REGSTR_VAL_INFSECTION, NULL, NULL, (PBYTE)pcmpParams->szInfSection, &cbData);
        }
        RegCloseKey (hKey);
        if (ERROR_SUCCESS != dwRet)
        {
            TRACE_MSG(TF_ERROR, "Could not read inf name or section: %#lx.", dwRet);
            goto _return;
        }
        // Everything is OK.
        bRet = TRUE;
    }
#ifdef DEBUG
    else
    {
        TRACE_MSG(TF_ERROR, "SetupDiGetSelectedDriver failed: %#lx.", GetLastError ());
        goto _return;
    }
#endif //DEBUG


_return:
    DBG_EXIT_BOOL_ERR(InitCompareParams, bRet);
    return bRet;
}


/*----------------------------------------------------------
Purpose: This function compares two modems based on Com name,
         hardware ID, INF name and INF section.
         The first modem is specified by pCmpParams,
         the second one by {hdi,pDevData}.

Returns: TRUE  - the modems are identical
         FALSE - the modems are different

Cond:    --
*/
BOOL
Modem_Compare (
    IN PCOMPARE_PARAMS  pCmpParams,
    IN HDEVINFO         hdi,
    IN PSP_DEVINFO_DATA pDevData)
{
 HKEY hKeyDrv = INVALID_HANDLE_VALUE;
 BOOL bRet = FALSE;
 TCHAR szTemp[LINE_LEN];
 DWORD cbData;
 DWORD dwRet;

    DBG_ENTER(Modem_Compare);

#ifdef DEBUG
    if (SetupDiGetDeviceRegistryProperty (hdi, pDevData, SPDRP_DEVICEDESC, NULL, (PBYTE)szTemp, LINE_LEN * sizeof(TCHAR), NULL) ||
        SetupDiGetDeviceInstanceId (hdi, pDevData, szTemp, LINE_LEN * sizeof(TCHAR), NULL))
    {
        TRACE_MSG (TF_GENERAL, "Comparing to %s", szTemp);
    }
#endif //DEBUG

    // 0. Check the devinst first
    if (pCmpParams->DevInst == pDevData->DevInst)
    {
        // It's the same modem!
        bRet = TRUE;
        goto _return;
    }

    // 1. Open driver key
    hKeyDrv = SetupDiOpenDevRegKey (hdi, pDevData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ);
    if (INVALID_HANDLE_VALUE == hKeyDrv)
    {
        TRACE_MSG(TF_ERROR, "Could not open driver registry for device: %#lx.", GetLastError ());
        goto _return;
    }

    // 2. Compare the ports (if need be)
    if (0 != pCmpParams->szPort[0]) // we need to compare ports
    {
        cbData = sizeof(szTemp);
        if (ERROR_SUCCESS != (dwRet =
            RegQueryValueEx (hKeyDrv, c_szAttachedTo, NULL, NULL, (PBYTE)szTemp, &cbData)))
        {
            TRACE_MSG(TF_ERROR, "Could not read port value: %#lx.", dwRet);
            goto _return;
        }

        if (0 != lstrcmpi (szTemp, pCmpParams->szPort))
        {
            TRACE_MSG(TF_GENERAL, "Ports are different: %s, %s.", pCmpParams->szPort, szTemp);
            // ports are different, so the modems are different;
            goto _return;
        }
    }

    // 3. Either don't care about ports, or
    //    modems are on the same port; compare
    //    hardware IDs.
    if (!SetupDiGetDeviceRegistryProperty (hdi, pDevData, SPDRP_HARDWAREID, NULL, (PBYTE)szTemp, sizeof(szTemp), NULL))
    {
        TRACE_MSG(TF_ERROR, "Could not get the hardware ID: %#lx.", GetLastError ());
        goto _return;
    }

    if (0 == lstrcmpi (szTemp, pCmpParams->szHardwareID))
    {
        // same hardware ID -- the modems are identical
        TRACE_MSG(TF_GENERAL, "HardwareID match: %s", szTemp);
        bRet = TRUE;
        goto _return;
    }

    TRACE_MSG(TF_GENERAL, "HardwareIDs are different: %s, %s", pCmpParams->szHardwareID, szTemp);
    // 4. Modems have different hardware IDs.
    //    That doesn't mean they're different though;
    //    compare INFs.
    ASSERT(INVALID_HANDLE_VALUE != hKeyDrv);
    cbData = sizeof(szTemp);
    if (ERROR_SUCCESS != (dwRet =
        RegQueryValueEx (hKeyDrv, REGSTR_VAL_INFPATH, NULL, NULL, (PBYTE)szTemp, &cbData)))
    {
        TRACE_MSG(TF_ERROR, "Could not read InfPath: %#lx.", dwRet);
        goto _return;
    }
    if (0 != lstrcmpi (szTemp, pCmpParams->szInfName))
    {
        TRACE_MSG(TF_GENERAL, "Different INFs: %s, %s", pCmpParams->szInfName, szTemp);
        // INFs are different, so are the modems.
        goto _return;
    }

    // 5. Modems come from the same INF.
    //    Compare the section.
    cbData = sizeof(szTemp);
    if (ERROR_SUCCESS != (dwRet =
        RegQueryValueEx (hKeyDrv, REGSTR_VAL_INFSECTION, NULL, NULL, (PBYTE)szTemp, &cbData)))
    {
        TRACE_MSG(TF_ERROR, "Could not read InfSection: %#lx.", dwRet);
        goto _return;
    }
    if (0 == lstrcmpi (szTemp, pCmpParams->szInfSection))
    {
        TRACE_MSG(TF_GENERAL, "INF/section match: %s, %s", pCmpParams->szInfName, pCmpParams->szInfSection);
        // Sections are the same, so are the modems.
        bRet = TRUE;
    }
    TRACE_MSG(TF_GENERAL, "Different sections: %s, %s", pCmpParams->szInfSection, szTemp);

_return:
    if (INVALID_HANDLE_VALUE != hKeyDrv)
    {
        RegCloseKey (hKeyDrv);
    }

    DBG_EXIT_BOOL_ERR(Modem_Compare, bRet);
    return bRet;
}


/*----------------------------------------------------------
Purpose: This function compares two modem detection signatures
         and determines if they are identical.

Returns: NO_ERROR
         ERROR_DUPLICATE_FOUND  if the modem signatures match
         other errors

Cond:    --
*/
DWORD
CALLBACK
DetectSig_Compare (
    IN HDEVINFO         hdi,
    IN PSP_DEVINFO_DATA pdevDataNew,
    IN PSP_DEVINFO_DATA pdevDataExisting,
    IN PVOID            lParam)
{
 DWORD dwRet = NO_ERROR;
#ifdef PROFILE
 DWORD dwLocal;
#endif //PROFILE

    DBG_ENTER(DetectSig_Compare);

#ifdef PROFILE
    dwLocal = GetTickCount ();
#endif //PROFILE
    if (Modem_Compare ((PCOMPARE_PARAMS)lParam, hdi, pdevDataExisting))
    {
        dwRet = ERROR_DUPLICATE_FOUND;
    }
#ifdef PROFILE
    TRACE_MSG(TF_GENERAL, "PROFILE: DetectSig_Compare took %lu ms.", GetTickCount() - dwLocal);
#endif //PROFILE

    DBG_EXIT_DWORD(DetectSig_Compare, dwRet);
    return dwRet;
}


#ifdef DEBUG
void HexDump(TCHAR *ptchHdr, LPCSTR lpBuf, DWORD cbLen)
{
    TCHAR *rgch = NULL;
	TCHAR *pc = NULL;
	TCHAR *pcMore = TEXT("");
    BOOL  bPrependSpace = FALSE;

    rgch = (TCHAR *)ALLOCATE_MEMORY(10000 * sizeof(TCHAR));

    pc = rgch;

	if ((rgch != NULL) && DisplayDebug(TF_DETECT))
    {
		pc += wsprintf(pc, TEXT("HEX DUMP(%s,%lu): ["), ptchHdr, cbLen);
		if (cbLen>1000) {pcMore = TEXT(", ..."); cbLen=1000;}

		for(;cbLen--; lpBuf++)
		{
            if (0x20 <= *lpBuf &&
                0x7E >= *lpBuf)
            {
                if (bPrependSpace)
                {
                    pc += wsprintf (pc, TEXT(" "));
                    bPrependSpace = FALSE;
                }
                pc += wsprintf (pc, TEXT("%hc"), *lpBuf);
            }
            else
            {
                bPrependSpace = TRUE;
                if ('\r' == *lpBuf)
                {
                    pc += wsprintf (pc, TEXT(" \\r"));
                }
                else if ('\n' == *lpBuf)
                {
                    pc += wsprintf(pc, TEXT(" \\n"));
                }
                else
                {
			        pc += wsprintf(pc, TEXT(" %02lx"), (unsigned long) *lpBuf);
                }
            }

			if (!((cbLen+1)%20))
			{
				pc += wsprintf(pc, TEXT("\r\n"));
			}
		}
		pc += wsprintf(pc, TEXT("]\r\n"));

		OutputDebugString(rgch);

        FREE_MEMORY(rgch);
	}
}
#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\mdminst\dll.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1995
//
// File: dll.c
//
//  This file contains the library entry points 
//
// History:
//  12-23-93 ScottH     Created
//   9-22-95 ScottH     Ported to NT
//   9-29-95 ScottH     Copied from MODEMUI
//
//---------------------------------------------------------------------------


#include "proj.h"         
#include <rovdbg.h>         // debug assertion code

// Global data
//
int g_cProcesses = 0;


/*----------------------------------------------------------
Purpose: Initialize the DLL
Returns: 
Cond:    --
*/
BOOL PRIVATE Dll_Initialize(void)
    {
    BOOL bRet = TRUE;

    InitCommonControls();

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Terminate DLL
Returns: --
Cond:    --
*/
BOOL PRIVATE Dll_Terminate(
    HINSTANCE hinst)
    {
    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Unregister window classes per process
Returns: 
Cond:    --
*/
void PRIVATE TermWindowClasses(
    HINSTANCE hinst)
    {
    }


/*----------------------------------------------------------
Purpose: Attach a process to this DLL
Returns: --
Cond:    --
*/
BOOL PRIVATE Dll_ProcessAttach(HINSTANCE hDll)
    {
    BOOL bSuccess = TRUE;


	g_hinst = hDll;

    DisableThreadLibraryCalls (hDll);

#ifdef DEBUG

	// We do this simply to load the debug .ini flags
	//
	RovComm_Init (hDll);

	TRACE_MSG(TF_GENERAL, "Process Attach [%d] (hDll = %lx)", g_cProcesses, hDll);
    TRACE_MSG(TF_GENERAL, "Command line: %s", GetCommandLine ());
	DEBUG_BREAK(BF_ONPROCESSATT);

#endif

	if (g_cProcesses++ == 0)
		{
		bSuccess = Dll_Initialize();
		}

    return bSuccess;
    }


/*----------------------------------------------------------
Purpose: Detach a process from the DLL
Returns: --
Cond:    --
*/
BOOL PRIVATE Dll_ProcessDetach(HINSTANCE hDll)
    {
    BOOL bSuccess = TRUE;

	ASSERT(hDll == g_hinst);

	DEBUG_CODE( TRACE_MSG(TF_GENERAL, "Process Detach [%d] (hDll = %lx)", 
		g_cProcesses-1, hDll); )

	DEBUG_CODE( DEBUG_BREAK(BF_ONPROCESSDET); )

	if (--g_cProcesses == 0)
		{
		bSuccess = Dll_Terminate(g_hinst);
		}

    TermWindowClasses(hDll);

    RovComm_Terminate (hDll);
    return bSuccess;
    }



HINSTANCE g_hinst = 0;





/*----------------------------------------------------------
Purpose: Win32 Libmain
Returns: --
Cond:    --
*/
BOOL APIENTRY DllMain(
    HANDLE hDll, 
    DWORD dwReason,  
    LPVOID lpReserved)
    {
    switch(dwReason)
        {
    case DLL_PROCESS_ATTACH:

        DEBUG_MEMORY_PROCESS_ATTACH("MODEM.CPL");

        Dll_ProcessAttach(hDll);
        break;

    case DLL_PROCESS_DETACH:

        Dll_ProcessDetach(hDll);

        DEBUG_MEMORY_PROCESS_DETACH();

        break;

    case DLL_THREAD_ATTACH:

#ifdef DEBUG

        DEBUG_BREAK(BF_ONTHREADATT);

#endif

        break;

    case DLL_THREAD_DETACH:

#ifdef DEBUG

        DEBUG_BREAK(BF_ONTHREADDET);

#endif

        break;

    default:
        break;
        } 
    
    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\mdminst\ci.c ===
/*
 *  CI.C -- Contains Class Installer for Modems.
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1993-1994
 *  All rights reserved
 *
 */

#include "proj.h"

#include <initguid.h>
#include <objbase.h>
#include <devguid.h>

#include <vmodem.h>
#include <msports.h>

#define DEFAULT_CALL_SETUP_FAIL_TIMEOUT     60          // seconds

typedef struct _INSTALL_PARAMS
{
    ULONG_PTR       dwFlags;
    DWORD           dwBus;
    HKEY            hKeyDev;
    HKEY            hKeyDrv;
    REGDEVCAPS      Properties;
    REGDEVSETTINGS  Defaults;
    DWORD           dwMaximumPortSpeed;
    DCB             dcb;
    TCHAR           szExtraSettings[80];
} INSTALL_PARAMS, *PINSTALL_PARAMS;


LPGUID g_pguidModem     = (LPGUID)&GUID_DEVCLASS_MODEM;
int g_iFlags = 0;

#define SAFE_DTE_SPEED 19200
static DWORD const FAR s_adwLegalBaudRates[] = { 300, 1200, 2400, 9600, 19200, 38400, 57600, 115200 };

#define REG_INSTALLATION_FLAG TEXT("INSTALLED_FLAG")

TCHAR const c_szDeviceType[]     = REGSTR_VAL_DEVTYPE;
TCHAR const c_szAttachedTo[]     = TEXT("AttachedTo");

TCHAR const c_szService[]        = REGSTR_VAL_SERVICE;

TCHAR const c_szDeviceDesc[]     = REGSTR_VAL_DEVDESC;

TCHAR const c_szManufacturer[]   = TEXT("Manufacturer");
TCHAR const c_szModel[]          = TEXT("Model");
TCHAR const c_szID[]             = TEXT("ID");

TCHAR const c_szProperties[]     = REGSTR_VAL_PROPERTIES;
TCHAR const c_szSettings[]      = TEXT("Settings");
TCHAR const c_szBlindOn[]        = TEXT("Blind_On");
TCHAR const c_szBlindOff[]       = TEXT("Blind_Off");
TCHAR const c_szDCB[]            = TEXT("DCB");
TCHAR const c_szDefault[]        = TEXT("Default");

TCHAR const c_szContention[]     = TEXT("Contention");

TCHAR const c_szAdvancedSettings[]        = TEXT("AdvancedSettings");
TCHAR const c_szMsportsAdvancedSettings[] = TEXT("msports.dll,SerialDisplayAdvancedSettings");
TCHAR const c_szModemuiEnumPropPages[]    = TEXT("modemui.dll,ModemPropPagesProvider");

TCHAR const c_szLoggingPath[] = TEXT("LoggingPath");

TCHAR const c_szFriendlyName[]   = REGSTR_VAL_FRIENDLYNAME;
TCHAR const c_szInfSerial[]      = TEXT("M2700");
TCHAR const c_szInfParallel[]    = TEXT("M2701");
TCHAR const c_szRunOnce[]        = TEXT("RunOnce");

TCHAR const c_szModemInstanceID[]= TEXT("MODEM");

TCHAR const c_szUserInit[] = TEXT("UserInit");

TCHAR const c_szMaximumPortSpeed[] = TEXT("MaximumPortSpeed");

TCHAR const c_szRespKeyName[] = TEXT("ResponsesKeyName");

#ifdef PROFILE_MASSINSTALL
HWND    g_hwnd;
DWORD   g_dwTimeSpent;
DWORD   g_dwTimeBegin;
#endif

#ifdef BUILD_DRIVER_LIST_THREAD
HANDLE g_hDriverSearchThread = NULL;
#endif //BUILD_DRIVER_LIST_THREAD


#define REG_PATH_UNIMODEM  REGSTR_PATH_SETUP TEXT("\\UNIMODEM")
#define REG_KEY_INSTALLED  TEXT("Installed")
#define REG_PATH_INSTALLED REG_PATH_UNIMODEM TEXT("\\") REG_KEY_INSTALLED

// NOTE: this is dependent on the INFSTR_PLATFORM_NTxxx defines from infstr.h
TCHAR const FAR c_szInfSectionExt[]  = TEXT(".NT");


#if !defined(WINNT)
TCHAR const FAR c_szPortDriver[]     = TEXT("PortDriver");
TCHAR const FAR c_szSerialVxd[]      = TEXT("Serial.vxd");
#endif
TCHAR const FAR c_szPortConfigDialog[] = TEXT("PortConfigDialog");
TCHAR const FAR c_szSerialUI[]       = TEXT("serialui.dll");


#ifdef INSTANT_DEVICE_ACTIVATION
DWORD gDeviceFlags = 0;
#endif // INSTANT_DEVICE_ACTIVATION

BOOL PutStuffInCache(HKEY hKeyDrv);
BOOL GetStuffFromCache(HKEY hkeyDrv);

BOOL PrepareForInstallation (
    IN HDEVINFO              hdi,
    IN PSP_DEVINFO_DATA      pdevData,
    IN PSP_DEVINSTALL_PARAMS pdevParams,
    IN PSP_DRVINFO_DATA      pdrvData,
    IN PINSTALL_PARAMS       pParams);
void FinishInstallation (PINSTALL_PARAMS pParams);
void
PUBLIC
CplDiMarkInstalled(
    IN  HKEY hKey);
BOOL
PUBLIC
CplDiHasModemBeenInstalled(
    IN  HKEY hKey);

DWORD
WINAPI
EnumeratePnP (LPVOID lpParameter);

#ifdef BUILD_DRIVER_LIST_THREAD
DWORD
WINAPI
BuildDriverList (LPVOID lpParameter);
#endif //BUILD_DRIVER_LIST_THREAD

//-----------------------------------------------------------------------------------
//  Wizard handlers
//-----------------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Adds a page to the dynamic wizard

Returns: handle to the prop sheet page
Cond:    --
*/
HPROPSHEETPAGE
PRIVATE
AddWizardPage(
    IN  PSP_INSTALLWIZARD_DATA  piwd,
    IN  HINSTANCE               hinst,
    IN  UINT                    id,
    IN  DLGPROC                 pfn,
    IN  LPTSTR                  pszHeaderTitle,     OPTIONAL
    IN  DWORD                   dwHeaderSubTitle,   OPTIONAL
    IN  LPFNPSPCALLBACK         pfnCallback,        OPTIONAL
    IN  LPARAM                  lParam)             OPTIONAL
{
 HPROPSHEETPAGE hpage = NULL;

    if (MAX_INSTALLWIZARD_DYNAPAGES > piwd->NumDynamicPages)
    {
     PROPSHEETPAGE psp;

        psp.dwSize = sizeof(psp);
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE;
        if (pfnCallback)
        {
            psp.dwFlags |= PSP_USECALLBACK;
        }

        psp.hInstance = hinst;
        psp.pszTemplate = MAKEINTRESOURCE(id);
        psp.hIcon = NULL;
        psp.pfnDlgProc = pfn;
        psp.lParam = lParam;
        psp.pfnCallback = pfnCallback;
        psp.pcRefParent = NULL;
        psp.pszTitle = MAKEINTRESOURCE(IDS_HDWWIZNAME);
        if (NULL != pszHeaderTitle)
        {
            psp.dwFlags |= PSP_USEHEADERTITLE;
            psp.pszHeaderTitle = pszHeaderTitle;
        }
        if (0 != dwHeaderSubTitle)
        {
         TCHAR szHeaderSubTitle[MAX_BUF];
            LoadString (hinst, dwHeaderSubTitle, szHeaderSubTitle, MAX_BUF);
            psp.dwFlags |=  PSP_USEHEADERSUBTITLE;
            psp.pszHeaderSubTitle = szHeaderSubTitle;
        }

        piwd->DynamicPages[piwd->NumDynamicPages] = CreatePropertySheetPage(&psp);
        if (piwd->DynamicPages[piwd->NumDynamicPages])
        {
            hpage = piwd->DynamicPages[piwd->NumDynamicPages];
            piwd->NumDynamicPages++;
        }
    }
    return hpage;
}



/*----------------------------------------------------------
Purpose: This function destroys the wizard context block
         and removes it from the InstallWizard class install
         params.

Returns: --
Cond:    --
*/
void
PRIVATE
CleanupWizard(
    IN  LPSETUPINFO psi)
    {
    ASSERT(psi);

    if (sizeof(*psi) == psi->cbSize)
        {
        TRACE_MSG(TF_GENERAL, "Destroy install wizard structures");


        // Clean up
        SetupInfo_Destroy(psi);
        }
    }


/*----------------------------------------------------------
Purpose: Callback for the standard modem wizard pages.  This
         function handles the cleanup of the pages.  Although
         the caller may call DIF_DESTROYWIZARDDATA, we do not
         depend on this to clean up.

Returns: TRUE on success
Cond:    --
*/
UINT
CALLBACK
ModemWizardCallback(
    IN  HWND            hwnd,
    IN  UINT            uMsg,
    IN  LPPROPSHEETPAGE ppsp)
    {
    UINT uRet = TRUE;

    ASSERT(ppsp);

    try
        {
        // Release everything?
        if (PSPCB_RELEASE == uMsg)
            {
            // Yes
            LPSETUPINFO psi = (LPSETUPINFO)ppsp->lParam;

            ASSERT(psi);

            if (IsFlagSet(psi->dwFlags, SIF_RELEASE_IN_CALLBACK))
                {
                CleanupWizard(psi);
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER)
        {
        ASSERT(0);
        uRet = FALSE;
        }

    return uRet;
    }


/*----------------------------------------------------------
Purpose: This function initializes the wizard pages.

Returns:
Cond:    --
*/
DWORD
PRIVATE
InitWizard(
    OUT LPSETUPINFO FAR *   ppsi,
    IN  HDEVINFO            hdi,
    IN  PSP_DEVINFO_DATA    pdevData,       OPTIONAL
    IN  PSP_INSTALLWIZARD_DATA piwd,
    IN  PMODEM_INSTALL_WIZARD pmiw)
{
    DWORD dwRet;
    LPSETUPINFO psi;

    ASSERT(ppsi);
    ASSERT(hdi && INVALID_HANDLE_VALUE != hdi);
    ASSERT(pmiw);

    dwRet = SetupInfo_Create(&psi, hdi, pdevData, piwd, pmiw);

    if (NO_ERROR == dwRet)
    {
     TCHAR szHeaderTitle[MAX_BUF];

/*
     DWORD dwThreadID;

        TRACE_MSG(TF_GENERAL, "Start PnP enumeration thread.");
        psi->hThreadPnP = CreateThread (NULL, 0,
                                        EnumeratePnP, (LPVOID)psi,
                                        0, &dwThreadID);
#ifdef DEBUG
        if (NULL == psi->hThreadPnP)
        {
            TRACE_MSG(TF_ERROR, "CreateThread (...EnumeratePnP...) failed: %#lx.", GetLastError ());
        }
#endif //DEBUG

  */

        TRACE_MSG(TF_GENERAL, "Initialize install wizard structures");

        piwd->DynamicPageFlags = DYNAWIZ_FLAG_PAGESADDED;
        LoadString (g_hinst, IDS_HEADER, szHeaderTitle, MAX_BUF);

        // Add standard modem wizard pages.  The first page will
        // also specify the cleanup callback.
        AddWizardPage(piwd,
                      g_hinst,
                      IDD_WIZ_INTRO,
                      IntroDlgProc,
                      szHeaderTitle,
                      IDS_INTRO,
                      ModemWizardCallback,
                      (LPARAM)psi);

        AddWizardPage(piwd,
                      g_hinst,
                      IDD_WIZ_SELQUERYPORT,
                      SelQueryPortDlgProc,
                      szHeaderTitle,
                      IDS_SELQUERYPORT,
                      NULL,
                      (LPARAM)psi);

        AddWizardPage(piwd,
                      g_hinst,
                      IDD_WIZ_DETECT,
                      DetectDlgProc,
                      szHeaderTitle,
                      IDS_DETECT,
                      NULL,
                      (LPARAM)psi);

        AddWizardPage(piwd,
                      g_hinst,
                      IDD_WIZ_SELMODEMSTOINSTALL,
                      SelectModemsDlgProc,
                      szHeaderTitle,
                      IDS_DETECT,
                      NULL,
                      (LPARAM)psi);

        AddWizardPage(piwd,
                      g_hinst,
                      IDD_WIZ_NOMODEM,
                      NoModemDlgProc,
                      szHeaderTitle,
                      IDS_NOMODEM,
                      NULL,
                      (LPARAM)psi);

        AddWizardPage(piwd,
                      g_hinst,
                      IDD_WIZ_NOP,
                      SelPrevPageDlgProc,
                      szHeaderTitle,
                      0,
                      NULL,
                      (LPARAM)psi);

        // Add remaining pages
        AddWizardPage(piwd,
                      g_hinst,
                      IDD_WIZ_PORTMANUAL,
                      PortManualDlgProc,
                      szHeaderTitle,
                      IDS_SELPORT,
                      NULL,
                      (LPARAM)psi);

        AddWizardPage(piwd,
                      g_hinst,
                      IDD_WIZ_PORTDETECT,
                      PortDetectDlgProc,
                      szHeaderTitle,
                      IDS_SELPORT,
                      NULL,
                      (LPARAM)psi);

        AddWizardPage(piwd,
                      g_hinst,
                      IDD_WIZ_INSTALL,
                      InstallDlgProc,
                      szHeaderTitle,
                      IDS_INSTALL,
                      NULL,
                      (LPARAM)psi);

        AddWizardPage(piwd,
                      g_hinst,
                      IDD_WIZ_DONE,
                      DoneDlgProc,
                      szHeaderTitle,
                      IDS_DONE,
                      NULL,
                      (LPARAM)psi);

        // Set the ClassInstallParams given the changes made above
        if ( !CplDiSetClassInstallParams(hdi, pdevData, PCIPOfPtr(piwd), sizeof(*piwd)) )
        {
            dwRet = GetLastError();
            ASSERT(NO_ERROR != dwRet);
        }
        else
        {
            dwRet = NO_ERROR;
        }
    }

    *ppsi = psi;

    return dwRet;
}


/*----------------------------------------------------------
Purpose: DIF_INSTALLWIZARD handler

         The modem installation wizard pages are composed in this
         function.

Returns: NO_ERROR to add wizard pages
Cond:    --
*/
DWORD
PRIVATE
ClassInstall_OnInstallWizard(
    IN  HDEVINFO                hdi,
    IN  PSP_DEVINFO_DATA        pdevData,       OPTIONAL
    IN  PSP_DEVINSTALL_PARAMS   pdevParams)
    {
    DWORD dwRet;
    SP_INSTALLWIZARD_DATA iwd;
    MODEM_INSTALL_WIZARD miw;
    PMODEM_INSTALL_WIZARD pmiw;

    DBG_ENTER(ClassInstall_OnInstallWizard);
    
    ASSERT(hdi && INVALID_HANDLE_VALUE != hdi);
    ASSERT(pdevParams);

    if (NULL != pdevData)
    {
     ULONG ulStatus, ulProblem;
        if (CR_SUCCESS == CM_Get_DevInst_Status (&ulStatus, &ulProblem, pdevData->DevInst, 0))
        {
            if (!(ulStatus & DN_ROOT_ENUMERATED))
            {
                TRACE_MSG(TF_GENERAL, "Device is not root-enumerated, returning ERROR_DI_DO_DEFAULT");
                return ERROR_DI_DO_DEFAULT;
            }
        }
    }

    iwd.ClassInstallHeader.cbSize = sizeof(iwd.ClassInstallHeader);

    if (!CplDiGetClassInstallParams(hdi, pdevData, PCIPOfPtr(&iwd), sizeof(iwd), NULL) ||
        DIF_INSTALLWIZARD != iwd.ClassInstallHeader.InstallFunction)
        {
        dwRet = ERROR_DI_DO_DEFAULT;
        goto exit;
        }

    // First check for the unattended install case.
    pmiw = (PMODEM_INSTALL_WIZARD)iwd.PrivateData;
    if (pmiw)
    {
        dwRet = NO_ERROR;
        if (IsFlagSet(pmiw->InstallParams.Flags, MIPF_NT4_UNATTEND))
        {
            UnattendedInstall(iwd.hwndWizardDlg, &pmiw->InstallParams);
        }
        else if (IsFlagSet(pmiw->InstallParams.Flags, MIPF_DRIVER_SELECTED))
        {
            if (!CplDiRegisterAndInstallModem (hdi, iwd.hwndWizardDlg, pdevData,
                                               pmiw->InstallParams.szPort, IMF_DEFAULT))
            {
                dwRet = GetLastError ();
            }
        }
        else if (IsFlagSet(pmiw->InstallParams.Flags, MIPF_CLONE_MODEM))
        {
            CloneModem (hdi, pdevData, iwd.hwndWizardDlg);
        }
        goto exit;
    }

    if (NULL == pdevParams)
    {
        dwRet = ERROR_INVALID_PARAMETER;
    }
    else
    {
        // The modem class installer allows an app to invoke it
        // different ways.
        //
        //  1) Atomically.  This allows the caller to invoke the
        //     wizard with a single call to the class installer
        //     using the DIF_INSTALLWIZARD install function.
        //
        if (NULL == pmiw)
        {
            pmiw = &miw;

            ZeroInit(pmiw);
            pmiw->cbSize = sizeof(*pmiw);
        }
        else
        {
            pmiw->PrivateData = 0;      // ensure this
        }

        // Verify the size of the optional modem install structure.
        if (sizeof(*pmiw) != pmiw->cbSize)
        {
            dwRet = ERROR_INVALID_PARAMETER;
        }
        else
        {
         LPSETUPINFO psi;

            dwRet = InitWizard(&psi, hdi, pdevData, &iwd, pmiw);
            SetFlag (psi->dwFlags, SIF_RELEASE_IN_CALLBACK);
        }
        // 07/22/1997 - EmanP
        // at this point, just return to the caller, with our
        // wizard pages added to the install wizard parameters;
        // it is up to the caller to add our pages to it's property
        // sheet, and execute the property sheet
    }

exit:
    DBG_EXIT(ClassInstall_OnInstallWizard);
    return dwRet;
    }


/*----------------------------------------------------------
Purpose: DIF_DESTROYWIZARDDATA handler

Returns: NO_ERROR
Cond:    --
*/
DWORD
PRIVATE
ClassInstall_OnDestroyWizard(
    IN  HDEVINFO                hdi,
    IN  PSP_DEVINFO_DATA        pdevData,       OPTIONAL
    IN  PSP_DEVINSTALL_PARAMS   pdevParams)
    {
    DWORD dwRet;
    SP_INSTALLWIZARD_DATA iwd;

    ASSERT(hdi && INVALID_HANDLE_VALUE != hdi);
    ASSERT(pdevParams);

    iwd.ClassInstallHeader.cbSize = sizeof(iwd.ClassInstallHeader);

#ifdef INSTANT_DEVICE_ACTIVATION
    if (DEVICE_CHANGED(gDeviceFlags))
    {
        UnimodemNotifyTSP (TSPNOTIF_TYPE_CPL,
                           fTSPNOTIF_FLAG_CPL_REENUM,
                           0, NULL, TRUE);
        // Reset the flag, so we don't notify
        // twice
        gDeviceFlags &= mDF_CLEAR_DEVICE_CHANGE;
    }
#endif // INSTANT_DEVICE_ACTIVATION

    if ( !pdevParams )
        {
        dwRet = ERROR_INVALID_PARAMETER;
        }
    else if ( !CplDiGetClassInstallParams(hdi, pdevData, PCIPOfPtr(&iwd), sizeof(iwd), NULL) ||
        DIF_INSTALLWIZARD != iwd.ClassInstallHeader.InstallFunction)
        {
        dwRet = ERROR_DI_DO_DEFAULT;
        }
    else
        {
        PMODEM_INSTALL_WIZARD pmiw = (PMODEM_INSTALL_WIZARD)iwd.PrivateData;

        dwRet = NO_ERROR;       // Assume success

        if (pmiw && sizeof(*pmiw) == pmiw->cbSize)
            {
            LPSETUPINFO psi = (LPSETUPINFO)pmiw->PrivateData;

            if (psi && !IsFlagSet(psi->dwFlags, SIF_RELEASE_IN_CALLBACK))
                {
                CleanupWizard(psi);
                }
            }
        }

    return dwRet;
    }


/*----------------------------------------------------------
Purpose: DIF_SELECTDEVICE handler

Returns: ERROR_DI_DO_DEFAULT
Cond:    --
*/
DWORD
PRIVATE
ClassInstall_OnSelectDevice(
    IN     HDEVINFO                hdi,
    IN     PSP_DEVINFO_DATA        pdevData)       OPTIONAL
{
 SP_DEVINSTALL_PARAMS devParams;
 SP_SELECTDEVICE_PARAMS sdp = {0};

    DBG_ENTER(ClassInstall_OnSelectDevice);
    
    ASSERT(hdi && INVALID_HANDLE_VALUE != hdi);

    // Get the DeviceInstallParams
    // 07/22/97 - EmanP
    // we don't need to get the class install params at this
    // point; all we need to do is set the class install params
    // for the DIF_SELECTDEVICE, so that the SelectDevice
    // wizard page (in setupapi.dll) displays our titles.
    devParams.cbSize = sizeof(devParams);
    sdp.ClassInstallHeader.cbSize = sizeof(sdp.ClassInstallHeader);
    sdp.ClassInstallHeader.InstallFunction = DIF_SELECTDEVICE;

    if (CplDiGetDeviceInstallParams(hdi, pdevData, &devParams))
    {
     ULONG ulStatus, ulProblem = 0;
        SetFlag(devParams.Flags, DI_USECI_SELECTSTRINGS);
        if (CR_SUCCESS ==
            CM_Get_DevInst_Status (&ulStatus, &ulProblem, pdevData->DevInst, 0))
        {
            if (0 == (ulStatus & DN_ROOT_ENUMERATED))
            {
                SetFlag(devParams.FlagsEx, DI_FLAGSEX_ALLOWEXCLUDEDDRVS);
            }
#ifdef DEBUG
            else
            {
                TRACE_MSG(TF_GENERAL, "Device is root-enumerated.");
            }
#endif //DEBUG
        }
#ifdef DEBUG
        else
        {
            TRACE_MSG(TF_ERROR, "CM_Get_DevInst_Status failed: %#lx.", CM_Get_DevInst_Status (&ulStatus, &ulProblem, pdevData->DevInst, 0));
        }
#endif //DEBUG

        LoadString(g_hinst, IDS_CAP_MODEMWIZARD, sdp.Title, SIZECHARS(sdp.Title));
        LoadString(g_hinst, IDS_ST_SELECT_INSTRUCT, sdp.Instructions, SIZECHARS(sdp.Instructions));
        LoadString(g_hinst, IDS_ST_MODELS, sdp.ListLabel, SIZECHARS(sdp.ListLabel));
        LoadString(g_hinst, IDS_SEL_MFG_MODEL, sdp.SubTitle, SIZECHARS(sdp.SubTitle));

        // Set the DeviceInstallParams and the ClassInstallParams
        CplDiSetDeviceInstallParams(hdi, pdevData, &devParams);
        CplDiSetClassInstallParams(hdi, pdevData, PCIPOfPtr(&sdp), sizeof(sdp));
    }

    DBG_EXIT(ClassInstall_OnSelectDevice);
    return ERROR_DI_DO_DEFAULT;
}



// This structure contains the data useful while querying each port
typedef struct tagNOTIFYPARAMS
{
    PDETECT_PROGRESS_NOTIFY DetectProgressNotify;
    PVOID                   ProgressNotifyParam;
    DWORD                   dwProgress;
    DWORD                   dwPercentPerPort;
} NOTIFYPARAMS, *PNOTIFYPARAMS;

typedef struct  tagQUERYPARAMS
    {
    HDEVINFO            hdi;
    HWND                hwnd;
    HWND                hwndOutsideWizard;
    DWORD               dwFlags;
    HANDLE              hLog;
    HPORTMAP            hportmap;
    PSP_DEVINSTALL_PARAMS pdevParams;
    DETECTCALLBACK      detectcallback;
    NOTIFYPARAMS        notifyParams;
    } QUERYPARAMS, FAR * PQUERYPARAMS;

// Flags for QUERYPARAMS
#define QPF_DEFAULT             0x00000000
#define QPF_FOUND_MODEM         0x00000001
#define QPF_USER_CANCELLED      0x00000002
#define QPF_FIND_DUPS           0x00000004
#define QPF_CONFIRM             0x00000008
#define QPF_DONT_REGISTER       0x00000010


typedef enum
{
    NOTIFY_START,
    NOTIFY_PORT_START,
    NOTIFY_PORT_DETECTED,
    NOTIFY_PORT_END,
    NOTIFY_END
} NOTIFICATION;


BOOL CancelDetectionFromNotifyProgress (PNOTIFYPARAMS pParams, NOTIFICATION notif);

extern TCHAR const c_szSerialComm[];

/*----------------------------------------------------------
Purpose: Clean up any detected modems.

Returns: --
Cond:    --
*/
void
PRIVATE
CleanUpDetectedModems(
    IN HDEVINFO     hdi,
    IN PQUERYPARAMS pparams)
    {
    // Delete any device instances we may have created
    // during this detection session.
    SP_DEVINFO_DATA devData;
    DWORD iDevice = 0;

    devData.cbSize = sizeof(devData);
    while (CplDiEnumDeviceInfo(hdi, iDevice++, &devData))
        {
        if (CplDiCheckModemFlags(pparams->hdi, &devData, MARKF_DETECTED, 0))
            {
            CplDiRemoveDevice(hdi, &devData);
            CplDiDeleteDeviceInfo(hdi, &devData);
            }
        }
    }


/*----------------------------------------------------------
Purpose: Queries the given port for a modem.

Returns: TRUE to continue
Cond:    --
*/
BOOL
PRIVATE
ReallyQueryPort(
    IN PQUERYPARAMS pparams,
    IN LPCTSTR      pszPort)
    {
    BOOL bRet = TRUE;
    DWORD dwRet = ERROR_CANCELLED;
    HDEVINFO hdi = pparams->hdi;
    SP_DEVINFO_DATA devData;
    DWORD iDevice;
#ifdef PROFILE_FIRSTTIMESETUP
 DWORD dwLocal;
#endif //PROFILE_FIRSTTIMESETUP

    DBG_ENTER_SZ(ReallyQueryPort, pszPort);
    
    // First, give a progress notification
    if (!CancelDetectionFromNotifyProgress (&(pparams->notifyParams), NOTIFY_PORT_START))
    {
        // Query the port for a modem signature
#ifdef PROFILE_FIRSTTIMESETUP
        dwLocal = GetTickCount ();
#endif //PROFILE_FIRSTTIMESETUP
        devData.cbSize = sizeof(devData);
        dwRet = DetectModemOnPort(hdi, &pparams->detectcallback, pparams->hLog,
                                  pszPort, pparams->hportmap, &devData);
#ifdef PROFILE_FIRSTTIMESETUP
        TRACE_MSG(TF_GENERAL, "PROFILE: DetectModemOnPort took %lu.", GetTickCount()-dwLocal);
#endif //PROFILE_FIRSTTIMESETUP
    }

    switch (dwRet)
    {
        case NO_ERROR:
            // Modem may have been found.  Create a device instance

            if (!CancelDetectionFromNotifyProgress (&(pparams->notifyParams), NOTIFY_PORT_DETECTED))
            {
                // 07/22/1997 - EmanP
                // just set the modem's detect signature
                // at this point; we'll do the registration
                // later (this is the expected behaviour for both
                // DIF_DETECT and DIF_FIRSTTIMESETUP)
                // What we really need here is to write the port name
                // somewhere the registration / installation code can
                // find it. Let's put it under the device instance key.
                {
                 HKEY hKeyDev;
                 CONFIGRET cr;
                    if (CR_SUCCESS == (cr =
                        CM_Open_DevInst_Key (devData.DevInst, KEY_ALL_ACCESS, 0,
                                             RegDisposition_OpenAlways, &hKeyDev,
                                             CM_REGISTRY_SOFTWARE)))
                    {
                        if (ERROR_SUCCESS != (dwRet =
                            RegSetValueEx (hKeyDev, c_szAttachedTo, 0, REG_SZ,
                                           (PBYTE)pszPort, (lstrlen(pszPort)+1)*sizeof(TCHAR))))
                        {
                            TRACE_MSG(TF_ERROR, "RegSetValueEx failed: %#lx.", dwRet);
                            SetLastError (dwRet);
                            bRet = FALSE;
                        }
                        RegCloseKey (hKeyDev);
                    }
                    else
                    {
                        TRACE_MSG(TF_ERROR, "CM_Open_DevInst_Key failed: %#lx.", cr);
                        bRet = FALSE;
                    }
                }

                if ( !bRet )
                {
                    if (IsFlagClear(pparams->pdevParams->Flags, DI_QUIETINSTALL))
                    {
                        // Something failed
                        SP_DRVINFO_DATA drvData;

                        drvData.cbSize = sizeof(drvData);
                        CplDiGetSelectedDriver(hdi, &devData, &drvData);

                        MsgBox(g_hinst,
                               pparams->hwnd,
                               MAKEINTRESOURCE(IDS_ERR_DET_REGISTER_FAILED),
                               MAKEINTRESOURCE(IDS_CAP_MODEMSETUP),
                               NULL,
                               MB_OK | MB_ICONINFORMATION,
                               drvData.Description,
                               pszPort
                               );
                    }

                    CplDiRemoveDevice(hdi, &devData);

                    // Continue with detection
                    bRet = TRUE;
                    break;
                }
                else
                {
                    SetFlag(pparams->dwFlags, QPF_FOUND_MODEM);
                    CplDiMarkModem(pparams->hdi, &devData, MARKF_DETECTED);
                    if (IsFlagSet (pparams->dwFlags, QPF_DONT_REGISTER))
                    {
                        CplDiMarkModem(pparams->hdi, &devData, MARKF_DONT_REGISTER);
                    }
                }
                if (!CancelDetectionFromNotifyProgress (&(pparams->notifyParams), NOTIFY_PORT_END))
                {
                    // only break if we got passed the two calls
                    // to CancelDetectionFromNotifyProgress, which means the user did not cancell
                    break;
                }

                // if we got here, this means that one of the
                // calls to CancelDetectionFromNotifyProgress returned FALSE, which
                // means the user cancelled, so we just fall through
            }

        case ERROR_CANCELLED:
            // User cancelled detection
            SetFlag(pparams->dwFlags, QPF_USER_CANCELLED);

            // Delete any device instances we may have created
            // during this detection session.
            CleanUpDetectedModems(hdi, pparams);

            bRet = FALSE;       // Stop querying anymore ports
            break;

        default:
            // Do nothing
            bRet = TRUE;
            break;
    }

    DBG_EXIT(ReallyQueryPort);
    return bRet;
    }


/*----------------------------------------------------------
Purpose: Callback that queries the given port for a modem.

Returns: TRUE to continue
Cond:    --
*/
BOOL
CALLBACK
QueryPort(
    IN  HPORTDATA hportdata,
    IN  LPARAM lParam)
    {
    BOOL bRet;
    PORTDATA pd;

    DBG_ENTER(QueryPort);
    
    pd.cbSize = sizeof(pd);
    bRet = PortData_GetProperties(hportdata, &pd);
    if (bRet)
        {
        // Is this a serial port?
        if (PORT_SUBCLASS_SERIAL == pd.nSubclass)
            {
            // Yes; interrogate it
            bRet = ReallyQueryPort((PQUERYPARAMS)lParam, pd.szPort);
            }
        }

    DBG_EXIT(QueryPort);
    return bRet;
    }


/*----------------------------------------------------------
Purpose: DIF_DETECT handler

Returns: NO_ERROR in all cases but serious errors.

         If a modem is detected and confirmed by the user, we
         create a device instance, register it, and associate
         the modem detection signature with it.

Cond:    --
*/
DWORD
PRIVATE
ClassInstall_OnDetect(
    IN  HDEVINFO                hdi,
    IN  PSP_DEVINSTALL_PARAMS   pdevParams)
{
    DWORD dwRet = NO_ERROR;
    DETECT_DATA dd;

    SP_DETECTDEVICE_PARAMS    DetectParams;

    DBG_ENTER(ClassInstall_OnDetect);
    
    ASSERT(hdi && INVALID_HANDLE_VALUE != hdi);
    ASSERT(pdevParams);

    DetectParams.ClassInstallHeader.cbSize = sizeof(DetectParams.ClassInstallHeader);

    if (NULL == pdevParams)
        {
        dwRet = ERROR_INVALID_PARAMETER;
        }
    else {

        BOOL  bResult;

        // 07/25/97 - EmanP
        // get the class install params for the whole set,
        // not just for this device;
        bResult=CplDiGetClassInstallParams(hdi, NULL,
            &DetectParams.ClassInstallHeader, sizeof(DetectParams), NULL);

        if (!bResult
            ||
            (DIF_DETECT != DetectParams.ClassInstallHeader.InstallFunction)
            ||
            (DetectParams.ProgressNotifyParam == NULL)
            ||
            (DetectParams.DetectProgressNotify != DetectCallback)) {


            // Set up some default values
            dd.hwndOutsideWizard = NULL;
            dd.dwFlags = DDF_DEFAULT;

            dwRet = NO_ERROR;

        } else {

            CopyMemory(
                &dd,
                DetectParams.ProgressNotifyParam,
                sizeof(DETECT_DATA)
                );


        }
    }

    if (NO_ERROR == dwRet)
        {
        QUERYPARAMS params;
        LPSETUPINFO psi = NULL;


        params.hdi = hdi;
        params.dwFlags = QPF_DEFAULT;
        params.hwndOutsideWizard = dd.hwndOutsideWizard;
        params.hwnd = pdevParams->hwndParent;
        params.pdevParams = pdevParams;
        ZeroMemory (&params.notifyParams, sizeof (NOTIFYPARAMS));

        if (IsFlagSet(dd.dwFlags, DDF_USECALLBACK))
        {
            params.detectcallback.pfnCallback = dd.pfnCallback;
            params.detectcallback.lParam = dd.lParam;
            psi = (LPSETUPINFO)GetWindowLongPtr((HWND)dd.lParam, DWLP_USER);
            if (psi)
            {
                params.hportmap = psi->hportmap;
            }
        }
        else
        {
            params.detectcallback.pfnCallback = NULL;
            params.detectcallback.lParam = 0;
            PortMap_Create (&params.hportmap);
            if (DIF_DETECT == DetectParams.ClassInstallHeader.InstallFunction)
            {
                // Only set the function pointer if
                // these are the detect parameters
                params.notifyParams.DetectProgressNotify = DetectParams.DetectProgressNotify;
                params.notifyParams.ProgressNotifyParam = DetectParams.ProgressNotifyParam;
            }

            if (CancelDetectionFromNotifyProgress (&params.notifyParams, NOTIFY_START))
            {
                // the operation got cancelled
                SetFlag(params.dwFlags, QPF_USER_CANCELLED);
                dwRet = ERROR_CANCELLED;
            }
        }

        if (IsFlagClear (params.dwFlags, QPF_USER_CANCELLED))
        {
            if (IsFlagSet(dd.dwFlags, DDF_CONFIRM))
            {
                SetFlag(params.dwFlags, QPF_CONFIRM);
            }

            // Open the detection log
            params.hLog = OpenDetectionLog();

            // Query just one port?
            if (IsFlagSet(dd.dwFlags, DDF_QUERY_SINGLE))
            {
                // Yes
                // so set the notification parameters
                // accordingly first:
                params.notifyParams.dwPercentPerPort = 100;
                if (IsFlagSet (dd.dwFlags, DDF_DONT_REGISTER))
                {
                    SetFlag (params.dwFlags, QPF_DONT_REGISTER);
                }
                ReallyQueryPort(&params, dd.szPortQuery);
            }
            else
            {
                // No; enumerate the ports and query for a modem on each port

                SetFlag(params.dwFlags, QPF_FIND_DUPS);

                EnumeratePorts(QueryPort, (LPARAM)&params);
            }
        }

        if (IsFlagClear (dd.dwFlags, DDF_USECALLBACK) &&
            NULL != params.hportmap)
        {
            // This means that we created the port map
            PortMap_Free (params.hportmap);
        }
        // Did the user cancel detection?
        if (IsFlagSet(params.dwFlags, QPF_USER_CANCELLED))
            {
            // Yes
            dwRet = ERROR_CANCELLED;
            }
        else if (CancelDetectionFromNotifyProgress (&(params.notifyParams), NOTIFY_END))
        {
            // User cancelled detection
            SetFlag(params.dwFlags, QPF_USER_CANCELLED);

            // Delete any device instances we may have created
            // during this detection session.
            CleanUpDetectedModems(params.hdi, &params);
            dwRet = ERROR_CANCELLED;
        }
        // Did we find a modem?
        else if (IsFlagSet(params.dwFlags, QPF_FOUND_MODEM))
        {
        }
        else
        {
            // No
            DetectSetStatus(&params.detectcallback, DSS_FINISHED);
        }

        CloseDetectionLog(params.hLog);
        }

    DBG_EXIT(ClassInstall_OnDetect);
    return dwRet;
}


/*----------------------------------------------------------
Purpose: DIF_FIRSTTIMESETUP handler

Returns: --.

         Remove all the root-enumerated (ie legacy) modems
         whose ports cannot be opened or are controlled by
         modem.sys.

Cond:    --
*/
void ClassInstall_OnFirstTimeSetup ()
{
 HDEVINFO hdi;

    DBG_ENTER(ClassInstall_OnFirstTimeSetup);

    hdi = CplDiGetClassDevs (g_pguidModem, TEXT("ROOT"), NULL, 0);
    if (INVALID_HANDLE_VALUE != hdi)
    {
     HKEY hkey;
     TCHAR szOnPort[LINE_LEN] = TEXT("\\\\.\\");
     DWORD cbData;
     DWORD dwIndex = 0;
     SP_DEVINFO_DATA DeviceInfoData;
     ULONG ulStatus, ulProblem = 0;
#ifdef DEBUG
     CONFIGRET cr;
     TCHAR szID[MAX_DEVICE_ID_LEN];
#endif //DEBUG

        DeviceInfoData.cbSize = sizeof (DeviceInfoData);
        while (CplDiEnumDeviceInfo (hdi, dwIndex++, &DeviceInfoData))
        {
#ifdef DEBUG
            if (CR_SUCCESS == (cr =
                CM_Get_Device_ID (DeviceInfoData.DevInst, szID, MAX_DEVICE_ID_LEN, 0)))
            {
                TRACE_MSG(TF_GENERAL, "FIRSTTIMESETUP analyzing %s", szID);
            }
            else
            {
                TRACE_MSG(TF_GENERAL, "CM_Get_Device_ID failed: %#lx.", szID);
            }
#endif
            // Even though we asked for root-enumerated modems,
            // it is still possible to get PnP modems in the list.
            // This is because BIOS-enumerated devices are actually
            // created under ROOT (don't know why, but this is how it is).
#ifdef DEBUG
            cr = CM_Get_DevInst_Status (&ulStatus, &ulProblem, DeviceInfoData.DevInst, 0);
            if (CR_SUCCESS == cr)
#else //DEBUG not defined
            if (CR_SUCCESS ==
                CM_Get_DevInst_Status (&ulStatus, &ulProblem, DeviceInfoData.DevInst, 0))
#endif //DEBUG
            {
                if (!(ulStatus & DN_ROOT_ENUMERATED))
                {
                    // If this is not root-enumerated, it's
                    // a BIOS-enumerated modem, which means it's
                    // PnP, so skip it.
                    continue;
                }
            }
#ifdef DEBUG
            else
            {
                TRACE_MSG(TF_GENERAL, "CM_Get_DevInst_Status failed: %#lx.", szID);
            }
#endif //DEBUG

            hkey = CplDiOpenDevRegKey(hdi, &DeviceInfoData,
                                      DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ);
            if (INVALID_HANDLE_VALUE != hkey)
            {
                DWORD dwType;
                cbData = sizeof(szOnPort);
                if ((ERROR_SUCCESS == RegQueryValueEx(hkey, c_szAttachedTo,
                                                     NULL, &dwType, (LPBYTE)(&szOnPort[4]), &cbData))
                    && (dwType == REG_SZ))
                {
                 HANDLE hPort;
                    // Now try to open the port
                    hPort = CreateFile (szOnPort, GENERIC_WRITE | GENERIC_READ,
                                        0, NULL, OPEN_EXISTING, 0, NULL);
                    if (INVALID_HANDLE_VALUE == hPort ||
                        IsModemControlledDevice (hPort))
                    {
                        // Looks like this device already has
                        // a registered instance attached to a port
                        // that doesn't seem to exist / work or is
                        // actually controlled by a PnP/PCMCIA modem;
                        // Mark this to be deleted (it will actually be removed
                        // during DIF_FIRSTTIMESETUP)
#ifdef DEBUG
                        if (INVALID_HANDLE_VALUE == hPort)
                        {
                         DWORD dwRet;
                            dwRet = GetLastError ();
                            TRACE_MSG(TF_ERROR, "CreateFile on %s failed: %#lx", szOnPort, GetLastError ());
                        }
                        else
                        {
                            TRACE_MSG(TF_ERROR, "CreateFile on %s succeeded!", szOnPort);
                        }
                        TRACE_MSG(TF_GENERAL, "\tto be removed");
#endif
                        CplDiCallClassInstaller(DIF_REMOVE, hdi, &DeviceInfoData);
                    }
#ifdef DEBUG
                    else
                    {
                        TRACE_MSG(TF_GENERAL, "\tto be left alone");
                    }
#endif
                    if (INVALID_HANDLE_VALUE != hPort)
                    {
                        CloseHandle (hPort);
                    }
                }
            }
        }
        CplDiDestroyDeviceInfoList (hdi);
    }

    DBG_EXIT(ClassInstall_OnFirstTimeSetup);
}



LONG WINAPI
WriteAnsiStringToReg(
    HKEY    hkey,
    LPCTSTR  EntryName,
    LPCSTR   Value
    )

{

    LPTSTR    WideBuffer;
    UINT      BufferLength;
    LONG      Result;


    BufferLength=MultiByteToWideChar(
        CP_ACP,
        MB_ERR_INVALID_CHARS,
        Value,
        -1,
        NULL,
        0
        );

    if (BufferLength == 0) {

        return GetLastError();
    }

    BufferLength=(BufferLength+1)*sizeof(WCHAR);

    WideBuffer=ALLOCATE_MEMORY(BufferLength);

    if (NULL == WideBuffer) {

       return ERROR_NOT_ENOUGH_MEMORY;
    }

    BufferLength=MultiByteToWideChar(
        CP_ACP,
        MB_ERR_INVALID_CHARS,
        Value,
        -1,
        WideBuffer,
        BufferLength
        );


    if (BufferLength == 0) {

        FREE_MEMORY(WideBuffer);
        return GetLastError();
    }


    Result=RegSetValueEx(
        hkey,
        EntryName,
        0,
        REG_SZ,
        (LPBYTE)WideBuffer,
        CbFromCch(lstrlen(WideBuffer) + 1)
        );


    FREE_MEMORY(WideBuffer);

    return Result;
}



/*----------------------------------------------------------
Purpose: This function is a workaround for the Italian SKU
         of NT whereby wait for dialtone is disabled 
         irrespective of the INF. 

         This is because the italian telephone system does not
         provide a dial tone.

         It checks for the HKEY_CURRENT_USER\Control Panel\-
         International\DefaultBlindDialFlag byte value.
         If this byte value is present and non-zero then we
         set MDM_BLIND_DIAL.

Returns: --
Cond:    --
*/
void
PRIVATE
ForceBlindDial(
    IN REGDEVCAPS FAR *     pregdevcaps,
    IN REGDEVSETTINGS FAR * pregdevsettings)
    {
    HKEY  hkeyIntl;
    DWORD dwType;
    BYTE  bFlag;
    DWORD cbData;

    if (NO_ERROR == RegOpenKey(HKEY_CURRENT_USER, TEXT("Control Panel\\International"), &hkeyIntl))
        {
        cbData = sizeof(bFlag);
        if (NO_ERROR == RegQueryValueEx(hkeyIntl, TEXT("DefaultBlindDialFlag"), NULL,
                                        &dwType, (LPBYTE)&bFlag, &cbData))
            {
            if (dwType == REG_DWORD && cbData == sizeof(bFlag) && bFlag)
                {
                pregdevsettings->dwPreferredModemOptions |= (pregdevcaps->dwModemOptions & MDM_BLIND_DIAL);
                }
            }
        RegCloseKey(hkeyIntl);
        }
    }


#define MAX_PROTOCOL_KEY_NAME   32

#define  ISDN(_pinfo)      MDM_GEN_EXTENDEDINFO(                \
                                            MDM_BEARERMODE_ISDN,\
                                            _pinfo              \
                                            )

#define  GSM(_pinfo)      MDM_GEN_EXTENDEDINFO(                \
                                            MDM_BEARERMODE_GSM,\
                                            _pinfo             \
                                            )

typedef struct
{
    TCHAR szProtocolKeyName[MAX_PROTOCOL_KEY_NAME];
    DWORD dwExtendedInfo;
} PROTOCOL_INFO;

static const PROTOCOL_INFO PriorityProtocols[] =
{
    {TEXT("ISDN\\AUTO_1CH"), ISDN(MDM_PROTOCOL_AUTO_1CH)},
    {TEXT("ISDN\\HDLC_PPP_64K"), ISDN(MDM_PROTOCOL_HDLCPPP_64K)},
    {TEXT("ISDN\\V120_64K"), ISDN(MDM_PROTOCOL_V120_64K)},
    {TEXT("ISDN\\ANALOG_V34"), ISDN(MDM_PROTOCOL_ANALOG_V34)},
    {TEXT("GSM\\ANALOG_RLP"), GSM(MDM_PROTOCOL_ANALOG_RLP)},
    {TEXT("ISDN\\PIAFS_OUTGOING"), ISDN(MDM_PROTOCOL_PIAFS_OUTGOING)}
};
#define NUM_PROTOCOLS sizeof(PriorityProtocols)/sizeof(PriorityProtocols[0])

static const TCHAR szProtocol[] = TEXT("Protocol");

/*----------------------------------------------------------
Purpose: This function writes the Default value to the driver
         key of the device instance, if no such value exists
         already.

Returns: --
Cond:    --
*/
void
PRIVATE
WriteDefaultValue(
    IN  REGDEVCAPS      *pregdevcaps,
    OUT REGDEVSETTINGS  *pregdevsettings,
    IN  PINSTALL_PARAMS  pParams)
{
    DWORD cbData = sizeof(REGDEVSETTINGS);
    DWORD dwType;

    // Do we have anything saved?
    if (pParams->dwFlags & MARKF_DEFAULTS)
    {
        CopyMemory (pregdevsettings, (PBYTE)&pParams->Defaults, cbData);
        RegSetValueEx (pParams->hKeyDrv, c_szDefault, 0, REG_BINARY,
                       (LPBYTE)pregdevsettings, cbData);
    }
    else
    {
     DWORD dwExtendedInfo = 0;
     HKEY hProt, hTemp;
     DWORD dwRet;

        dwRet = RegOpenKeyEx (pParams->hKeyDrv, szProtocol, 0, KEY_READ, &hProt);
        if (ERROR_SUCCESS == dwRet)
        {
            for (dwRet = 0; dwRet < NUM_PROTOCOLS; dwRet++)
            {
                if (ERROR_SUCCESS ==
                    RegOpenKeyEx (hProt, PriorityProtocols[dwRet].szProtocolKeyName, 0, KEY_READ, &hTemp))
                {
                    RegCloseKey (hTemp);
                    dwExtendedInfo = PriorityProtocols[dwRet].dwExtendedInfo;
                    break;
                }
            }
            RegCloseKey (hProt);
        }
        else
        {
            TRACE_MSG(TF_ERROR, "RegOpenKeyEx (Protocol) failed: %#lx.", dwRet);
        }

        if ((NO_ERROR !=    // Is there a Default value already?
                 RegQueryValueEx(pParams->hKeyDrv, c_szDefault, NULL, &dwType, (LPBYTE)pregdevsettings, &cbData))
            || (dwType != REG_BINARY))
        {
            // No; create a Default value structure
    #ifndef PROFILE_MASSINSTALL
            TRACE_MSG(TF_GENERAL, "Set drv value Default");
    #endif
            ZeroInit(pregdevsettings);

            // dwCallSetupFailTimer
            pregdevsettings->dwCallSetupFailTimer =
                                (pregdevcaps->dwCallSetupFailTimer >=
                                 DEFAULT_CALL_SETUP_FAIL_TIMEOUT) ?
                                        DEFAULT_CALL_SETUP_FAIL_TIMEOUT :
                                        pregdevcaps->dwCallSetupFailTimer;

            // dwInactivityTimeout
            pregdevsettings->dwInactivityTimeout = 0;

            // dwSpeakerVolume
            if (IsFlagSet(pregdevcaps->dwSpeakerVolume, MDMVOLFLAG_LOW))
                {
                pregdevsettings->dwSpeakerVolume = MDMVOL_LOW;
                }
            else if (IsFlagSet(pregdevcaps->dwSpeakerVolume, MDMVOLFLAG_MEDIUM))
                {
                pregdevsettings->dwSpeakerVolume = MDMVOL_MEDIUM;
                }
            else if (IsFlagSet(pregdevcaps->dwSpeakerVolume, MDMVOLFLAG_HIGH))
                {
                pregdevsettings->dwSpeakerVolume = MDMVOL_HIGH;
                }

            // dwSpeakerMode
            if (IsFlagSet(pregdevcaps->dwSpeakerMode, MDMSPKRFLAG_DIAL))
                {
                pregdevsettings->dwSpeakerMode = MDMSPKR_DIAL;
                }
            else if (IsFlagSet(pregdevcaps->dwSpeakerMode, MDMSPKRFLAG_OFF))
                {
                pregdevsettings->dwSpeakerMode = MDMSPKR_OFF;
                }
            else if (IsFlagSet(pregdevcaps->dwSpeakerMode, MDMSPKRFLAG_CALLSETUP))
                {
                pregdevsettings->dwSpeakerMode = MDMSPKR_CALLSETUP;
                }
            else if (IsFlagSet(pregdevcaps->dwSpeakerMode, MDMSPKRFLAG_ON))
                {
                pregdevsettings->dwSpeakerMode = MDMSPKR_ON;
                }

            // dwPreferredModemOptions
            pregdevsettings->dwPreferredModemOptions = pregdevcaps->dwModemOptions &
                                                        (MDM_COMPRESSION | MDM_ERROR_CONTROL |
                                                         MDM_SPEED_ADJUST | MDM_TONE_DIAL |
                                                         MDM_CCITT_OVERRIDE);
            if (IsFlagSet(pregdevcaps->dwModemOptions, MDM_FLOWCONTROL_HARD))
                {
                SetFlag(pregdevsettings->dwPreferredModemOptions, MDM_FLOWCONTROL_HARD);
                }
            else if (IsFlagSet(pregdevcaps->dwModemOptions, MDM_FLOWCONTROL_SOFT))
                {
                SetFlag(pregdevsettings->dwPreferredModemOptions, MDM_FLOWCONTROL_SOFT);
                }

            // Set the blind dial for some international modems
            ForceBlindDial(pregdevcaps, pregdevsettings);
        }
    #ifndef PROFILE_MASSINSTALL
        else
        {
            TRACE_MSG(TF_GENERAL, "Default value already exists");
        }

        if (0 != dwExtendedInfo)
        {
            pregdevsettings->dwPreferredModemOptions &=
                     ~(MDM_ERROR_CONTROL|MDM_CELLULAR|MDM_FORCED_EC);
            MDM_SET_EXTENDEDINFO(pregdevsettings->dwPreferredModemOptions, dwExtendedInfo);
        }
        // Write the new value to the registry
        cbData = sizeof(REGDEVSETTINGS);
        RegSetValueEx(pParams->hKeyDrv, c_szDefault, 0, REG_BINARY,
                      (LPBYTE)pregdevsettings, cbData);
    }
#endif
}


/*----------------------------------------------------------
Purpose: Computes a "decent" initial baud rate.

Returns: a decent/legal baudrate (legal = settable)
Cond:    --
*/
DWORD
PRIVATE
ComputeDecentBaudRate(
    IN DWORD dwMaxDTERate,  // will always be legal
    IN DWORD dwMaxDCERate)  // will not always be legal
    {
    DWORD dwRetRate;
    int   i;
    static const ceBaudRates = ARRAYSIZE(s_adwLegalBaudRates);


    dwRetRate = 2 * dwMaxDCERate;

    if (dwRetRate <= s_adwLegalBaudRates[0] || dwRetRate > s_adwLegalBaudRates[ceBaudRates-1])
        {
        dwRetRate = dwMaxDTERate;
        }
    else
        {
        for (i = 1; i < ceBaudRates; i++)
            {
            if (dwRetRate > s_adwLegalBaudRates[i-1] && dwRetRate <= s_adwLegalBaudRates[i])
                {
                break;
                }
            }

        // cap off at dwMaxDTERate
        dwRetRate = s_adwLegalBaudRates[i] > dwMaxDTERate ? dwMaxDTERate : s_adwLegalBaudRates[i];

        // optimize up to SAFE_DTE_SPEED or dwMaxDTERate if possible
        if (dwRetRate < dwMaxDTERate && dwRetRate < SAFE_DTE_SPEED)
            {
            dwRetRate = min(dwMaxDTERate, SAFE_DTE_SPEED);
            }
        }

#ifndef PROFILE_MASSINSTALL
    TRACE_MSG(TF_GENERAL, "A.I. Initial Baud Rate: MaxDCE=%ld, MaxDTE=%ld, A.I. Rate=%ld",
              dwMaxDCERate, dwMaxDTERate, dwRetRate);
#endif
    return dwRetRate;
    }


/*----------------------------------------------------------
Purpose: Write the DCB value to the driver key of the device
         instance if the value does not already exist.

Returns: --
Cond:    --
*/
void
PRIVATE
WriteDCB(
    IN  REGDEVCAPS      *pregdevcaps,
    IN  REGDEVSETTINGS  *pregdevsettings,
    IN  PINSTALL_PARAMS  pParams)
{
 DWORD cbData = sizeof(WIN32DCB);
 WIN32DCB dcb;
    DWORD dwType;

    // Do we have anything saved?
    if (pParams->dwFlags & MARKF_DCB)
    {
        RegSetValueEx (pParams->hKeyDrv, c_szDCB, 0, REG_BINARY,
                       (LPBYTE)&pParams->dcb, cbData);
        return;
    }

    // Check for DCB, if none then create one.
    if (NO_ERROR == RegQueryValueEx (pParams->hKeyDrv, c_szDCB, NULL, &dwType,
                                     (PBYTE)&dcb, &cbData) && dwType == REG_BINARY)
    {
#ifndef PROFILE_MASSINSTALL
        TRACE_MSG(TF_GENERAL, "DCB value already exists");
#endif
    }
    else
    {
#ifndef PROFILE_MASSINSTALL
        TRACE_MSG(TF_GENERAL, "Set drv value DCB");
#endif
        ZeroInit(&dcb);

        dcb.DCBlength   = sizeof(dcb);
        dcb.BaudRate    = ComputeDecentBaudRate(pregdevcaps->dwMaxDTERate,
                                                pregdevcaps->dwMaxDCERate);
        dcb.fBinary     = 1;
        dcb.fDtrControl = DTR_CONTROL_ENABLE;
        dcb.XonLim      = 0xa;
        dcb.XoffLim     = 0xa;
        dcb.ByteSize    = 8;
        dcb.XonChar     = 0x11;
        dcb.XoffChar    = 0x13;

        // Set flow control to hard unless it is specifically set to soft
        if (IsFlagSet(pregdevsettings->dwPreferredModemOptions, MDM_FLOWCONTROL_SOFT))
            {
            ASSERT(IsFlagClear(pregdevsettings->dwPreferredModemOptions, MDM_FLOWCONTROL_HARD));
            dcb.fOutX = 1;
            dcb.fInX  = 1;
            dcb.fOutxCtsFlow = 0;
            dcb.fRtsControl  = RTS_CONTROL_DISABLE;
            }
        else
            {
            dcb.fOutX = 0;
            dcb.fInX  = 0;
            dcb.fOutxCtsFlow = 1;
            dcb.fRtsControl  = RTS_CONTROL_HANDSHAKE;
            }

        // Write the new value to the registry
        TRACE_MSG(TF_GENERAL, "WriteDCB: seting baudrate to %lu", dcb.BaudRate);
        ASSERT (0 < dcb.BaudRate);
        cbData = sizeof(WIN32DCB);
        RegSetValueEx (pParams->hKeyDrv, c_szDCB, 0, REG_BINARY, (PBYTE)&dcb, cbData);
    }
}


/*----------------------------------------------------------
Purpose: Creates Default and DCB values if necessary.

Returns: TRUE on success
Cond:    --
*/
BOOL
PRIVATE
WriteDriverDefaults(
    IN  PINSTALL_PARAMS  pParams)
{
    BOOL           bRet;
    REGDEVCAPS     regdevcaps;
    REGDEVSETTINGS regdevsettings;
    DWORD          cbData;
    DWORD          dwType;

    // Get the Properties (REGDEVCAPS) structure for this device instance
    cbData = sizeof(REGDEVCAPS);
    if (NO_ERROR !=
        RegQueryValueEx (pParams->hKeyDrv, c_szProperties, NULL, &dwType,
                         (LPBYTE)&regdevcaps, &cbData) && dwType == REG_BINARY)
    {
        TRACE_MSG(TF_ERROR, "Properties value not present!!! (very bad)");
        ASSERT(0);

        bRet = FALSE;
        SetLastError(ERROR_INVALID_DATA);
    }
    else
    {
        TRACE_MSG(TF_GENERAL, "WriteDriverDefaults: Properties set\n    MaxDCE = %lu\n    MaxDTE = %lu",
                    regdevcaps.dwMaxDCERate, regdevcaps.dwMaxDTERate);

        if ((pParams->dwFlags & (MARKF_DEFAULTS | MARKF_DCB | MARKF_SETTINGS | MARKF_MAXPORTSPEED)) &&
            memcmp (&regdevcaps, &pParams->Properties, sizeof(REGDEVCAPS)))
        {
            // This means that we have new capabilities for the modem,
            // so we can't keep the old settings.
            pParams->dwFlags &= ~(MARKF_DEFAULTS | MARKF_DCB | MARKF_SETTINGS | MARKF_MAXPORTSPEED);
        }

        // Write the Default value if one doesn't exist
        WriteDefaultValue (&regdevcaps, &regdevsettings, pParams);

        // Write the DCB value if one doesn't exist
        WriteDCB (&regdevcaps, &regdevsettings, pParams);

        // Write the user init string
        if (pParams->dwFlags & MARKF_SETTINGS)
        {
            RegSetValueEx (pParams->hKeyDrv, c_szUserInit, 0, REG_SZ,
                           (PBYTE)pParams->szExtraSettings,
                           CbFromCch(lstrlen(pParams->szExtraSettings)+1));
        }

        // Write the maximum port spped
        if (pParams->dwFlags & MARKF_MAXPORTSPEED)
        {
            RegSetValueEx (pParams->hKeyDrv, c_szMaximumPortSpeed, 0, REG_DWORD,
                           (PBYTE)&pParams->dwMaximumPortSpeed,
                           sizeof(pParams->dwMaximumPortSpeed));
        }

        bRet = TRUE;
    }

    return bRet;
}



/*----------------------------------------------------------
Purpose: Write necessary stuff to the registry assuming this
         is an external PNP modem discovered by SERENUM or
         LPTENUM.

Returns: TRUE on success
Cond:    --
*/
BOOL
PRIVATE
WritePoorPNPModemInfo (
    IN  HKEY             hkeyDrv)
{
 BOOL bRet = TRUE;
 BYTE nDeviceType;

    DBG_ENTER(WritePoorPNPModemInfo);
    TRACE_MSG(TF_GENERAL, "Device is an external PnP modem");

    // Be smart--we know this is an external modem
    nDeviceType = DT_EXTERNAL_MODEM;
    RegSetValueEx(hkeyDrv, c_szDeviceType, 0, REG_BINARY, &nDeviceType, sizeof(nDeviceType));

    DBG_EXIT_BOOL_ERR(WritePoorPNPModemInfo, bRet);
    return bRet;
}



/*----------------------------------------------------------
Purpose: Write necessary stuff to the registry assuming this
         is a plug and play modem.

Returns: TRUE on success
Cond:    --
*/
BOOL
PRIVATE
WritePNPModemInfo(
    IN HDEVINFO         hdi,
    IN PSP_DEVINFO_DATA pdevData,
    IN PINSTALL_PARAMS  pParams)
{
 BYTE nDeviceType;
 TCHAR   FilterService[64];


    // Make sure the port and contention drivers are set in the
    // modem driver section if they are not already.
    TRACE_MSG(TF_GENERAL, "Device is a PnP enumerated modem");

    //
    // The modem isn't root-enumerated (i.e., it's PnP), so we most likely need
    // serial.sys as a lower filter.  If that's not the case (e.g., a controller-less
    // modem), then the INF can override.
    //
    ZeroMemory (FilterService, sizeof(FilterService));
    lstrcpy (FilterService, TEXT("serial"));

    SetupDiSetDeviceRegistryProperty(
        hdi,
        pdevData,
        SPDRP_LOWERFILTERS,
        (LPBYTE)FilterService,
        (lstrlen(FilterService)+2)*sizeof(TCHAR));


    SetupDiSetDeviceRegistryProperty(
        hdi,
        pdevData,
        SPDRP_SERVICE,
        (LPBYTE)TEXT("Modem"),
        sizeof(TEXT("Modem")));


    // Is this a PCMCIA card?
    if (BUS_TYPE_PCMCIA == pParams->dwBus)
    {
        // Yes; force the device type to be such
        nDeviceType = DT_PCMCIA_MODEM;
    }
    else
    {
        // No; default to internal modem
        nDeviceType = DT_INTERNAL_MODEM;
    }
    RegSetValueEx (pParams->hKeyDrv, c_szDeviceType, 0,
                   REG_BINARY, &nDeviceType, sizeof(nDeviceType));

    TRACE_DRV_DWORD(c_szDeviceType, nDeviceType);

    // Does this modem have a special port config dialog already?
    if (NO_ERROR !=
        RegQueryValueEx (pParams->hKeyDrv, c_szPortConfigDialog, NULL, NULL, NULL, NULL))
    {
        // No; set SERIALUI to be the provider
        RegSetValueEx (pParams->hKeyDrv, c_szPortConfigDialog, 0, REG_SZ,
                       (LPBYTE)c_szSerialUI, CbFromCch(lstrlen(c_szSerialUI)+1));

        TRACE_DRV_SZ(c_szPortConfigDialog, c_szSerialUI);
    }

    RegSetValueEx (pParams->hKeyDrv, c_szAdvancedSettings, 0, REG_SZ,
                   (LPBYTE)c_szMsportsAdvancedSettings,
                   CbFromCch(lstrlen(c_szMsportsAdvancedSettings)+1));
    return TRUE;
}

#define ROOTMODEM_SERVICE_NAME  TEXT("ROOTMODEM")

BOOL
InstallRootModemService(
    VOID
    )

{
    SC_HANDLE       schSCManager=NULL;
    SC_HANDLE       ServiceHandle;
    SERVICE_STATUS  ServiceStatus;

    schSCManager=OpenSCManager(
   		NULL,
   		NULL,
   		SC_MANAGER_ALL_ACCESS
   		);

    if (!schSCManager)
    {
   	TRACE_MSG(TF_GENERAL, "OpenSCManager() failed!");
   	return FALSE;
    }

    ServiceHandle=OpenService(
        schSCManager,
        ROOTMODEM_SERVICE_NAME,
        SERVICE_CHANGE_CONFIG|
        SERVICE_QUERY_CONFIG|
        SERVICE_QUERY_STATUS
        );

    if ((ServiceHandle != NULL)) {
        //
        //  The service exists, were done.
        //
        TRACE_MSG(TF_GENERAL, "RootModem serivce exists");

        CloseServiceHandle(ServiceHandle);

        CloseServiceHandle(schSCManager);

        return  TRUE;

    } else {
        //
        //  got an error
        //
        if (GetLastError() != ERROR_SERVICE_DOES_NOT_EXIST) {
            //
            //  some other error
            //
            CloseServiceHandle(schSCManager);

            return FALSE;

        }

        TRACE_MSG(TF_GENERAL, "RootModem service does not exist");
    }


    //
    //  try to create it
    //
    ServiceHandle=CreateService(
        schSCManager,
        ROOTMODEM_SERVICE_NAME,
        TEXT("Microsoft Legacy Modem Driver"),
        SERVICE_ALL_ACCESS,
        SERVICE_KERNEL_DRIVER,
        SERVICE_DEMAND_START,
        SERVICE_ERROR_IGNORE,
        TEXT("System32\\Drivers\\RootMdm.sys"),
        NULL,  // no group
        NULL, // no tag
        NULL, // no dependencies
        NULL, // use default device name
        NULL  // no password
        );

    if (ServiceHandle == NULL) {

        TRACE_MSG(TF_GENERAL, "CreateService() failed!");

        CloseServiceHandle(schSCManager);

        return FALSE;
    }

    TRACE_MSG(TF_GENERAL, "RootModem service created");

    CloseServiceHandle(ServiceHandle);

    CloseServiceHandle(schSCManager);

    return TRUE;

}

LONG
SetPermanentGuid(
    IN HDEVINFO         hdi,
    IN PSP_DEVINFO_DATA pdevData,   // if updated on exit, must be freed!
    IN PINSTALL_PARAMS  pParams
    )

{
        GUID    TempGuid;
        DWORD   Size;
        DWORD   Type;
        LONG    lResult;
        HKEY    hKeyDevice;


    hKeyDevice = SetupDiOpenDevRegKey (
        hdi,
        pdevData,
        DICS_FLAG_GLOBAL,
        0,
        DIREG_DEV,
        KEY_READ | KEY_WRITE
        );

    if (INVALID_HANDLE_VALUE != hKeyDevice) {

        //
        //  read the guid from the dev key, if it is there, use it
        //
        Size=sizeof(TempGuid);
        Type=REG_BINARY;

        lResult=RegQueryValueEx(
            hKeyDevice,
            TEXT("PermanentGuid"),
            NULL,
            &Type,
            (LPBYTE)&TempGuid,
            &Size
            );

        if (lResult != ERROR_SUCCESS) {
            //
            //  no guid present currently, in the dev key, read the driver key, because we
            //  used to only store it there
            //
            Size=sizeof(TempGuid);
            Type=REG_BINARY;

            lResult=RegQueryValueEx(
                pParams->hKeyDrv,
                TEXT("PermanentGuid"),
                NULL,
                &Type,
                (LPBYTE)&TempGuid,
                &Size
                );

            if (lResult != ERROR_SUCCESS) {
                //
                //  it was not in either place, create a new one
                //
                CoCreateGuid(&TempGuid);
            }
        }

        //
        //  set it in the device key
        //
        RegSetValueEx(
            hKeyDevice,
            TEXT("PermanentGuid"),
            0,
            REG_BINARY,
            (LPBYTE)&TempGuid,
            sizeof(TempGuid)
            );


        //
        //  set it in the driver key
        //
        RegSetValueEx(
            pParams->hKeyDrv,
            TEXT("PermanentGuid"),
            0,
            REG_BINARY,
            (LPBYTE)&TempGuid,
            sizeof(TempGuid)
            );

        RegCloseKey(hKeyDevice);
    }

    return ERROR_SUCCESS;



}


/*-- --------------------------------------------------------
Purp ose: Write necessary stuff to the registry assuming this
          is a root-enumerated modem.

Retu rns: --
Cond :    --
*/
BOOL
PRIVATE
WriteRootModemInfo (
     IN  HDEVINFO         hdi,
     IN  PSP_DEVINFO_DATA pdevData)
{
 BOOL bRet = TRUE;
 DWORD dwRet;
 DWORD cbData;

    ASSERT(hdi && INVALID_HANDLE_VALUE != hdi);

    TRACE_MSG(TF_GENERAL, "Device is a root-enumerated modem");

    InstallRootModemService();

    SetupDiSetDeviceRegistryProperty (hdi, pdevData, SPDRP_LOWERFILTERS,
                                      (LPBYTE)ROOTMODEM_SERVICE_NAME TEXT("\0"),
                                      sizeof(ROOTMODEM_SERVICE_NAME TEXT("\0")));

    return bRet;
}

/*----------------------------------------------------------
Purpose: Write stuff to the registry that is common for all
         modems.

Returns: --
Cond:    --
*/
BOOL
PRIVATE
WriteCommonModemInfo(
    IN HDEVINFO         hdi,
    IN PSP_DEVINFO_DATA pdevData,   // if updated on exit, must be freed!
    IN PSP_DRVINFO_DATA pdrvData,
    IN PINSTALL_PARAMS  pParams)
{
 DWORD dwID;
 TCHAR szLoggingPath[MAX_PATH];

    ASSERT(pdrvData);

    // Write the manufacturer to the  driver key
    RegSetValueEx (pParams->hKeyDrv, c_szManufacturer, 0, REG_SZ,
                   (LPBYTE)pdrvData->MfgName,
                   CbFromCch(lstrlen(pdrvData->MfgName)+1));

#ifndef PROFILE_MASSINSTALL
    TRACE_DRV_SZ(c_szManufacturer, pdrvData->MfgName);
#endif

    // Write the model to the driver key
    RegSetValueEx (pParams->hKeyDrv, c_szModel, 0, REG_SZ,
                   (LPBYTE)pdrvData->Description,
                   CbFromCch(lstrlen(pdrvData->Description)+1));

#ifndef PROFILE_MASSINSTALL
    TRACE_DRV_SZ(c_szModel, pdrvData->Description);
#endif


    RegSetValueEx (pParams->hKeyDrv, REGSTR_VAL_ENUMPROPPAGES_32, 0, REG_SZ,
                   (LPBYTE)c_szModemuiEnumPropPages,
                   CbFromCch(lstrlen(c_szModemuiEnumPropPages)+1));



    // Write a pseudo-unique ID to the driver key.  This is used as the
    // permanent TAPI line ID for this device.
    {
        DWORD   Size;
        DWORD   Type;
        LONG    lResult;


        Size=sizeof(dwID);
        Type=REG_BINARY;

        lResult=RegQueryValueEx(
            pParams->hKeyDrv,
            c_szID,
            NULL,
            &Type,
            (LPBYTE)&dwID,
            &Size
            );

        if (lResult != ERROR_SUCCESS) {

            dwID = GetTickCount();

            RegSetValueEx(
                pParams->hKeyDrv,
                c_szID,
                0,
                REG_BINARY,
                (LPBYTE)&dwID,
                sizeof(dwID)
                );
        }
    }


    SetPermanentGuid(
        hdi,
        pdevData,
        pParams
        );



#ifndef PROFILE_MASSINSTALL
    TRACE_DRV_DWORD(c_szID, dwID);
#endif

    return TRUE;
}




/*----------------------------------------------------------
Purpose: This function performs any preparation work required
         before the real installation is done.

Returns: TRUE on success
Cond:    --
*/
BOOL
PRIVATE
DoPreGamePrep(
    IN     HDEVINFO               hdi,
    IN OUT PSP_DEVINFO_DATA      *ppdevData,   // if updated on exit, must be freed!
    IN OUT PSP_DEVINSTALL_PARAMS  pdevParams,
    IN OUT PSP_DRVINFO_DATA       pdrvData,
    IN     PINSTALL_PARAMS        pParams)
{
    BOOL bRet;

    DBG_ENTER(DoPreGamePrep);
    
    ASSERT(hdi && INVALID_HANDLE_VALUE != hdi);
    ASSERT(ppdevData && *ppdevData);
    ASSERT(pdrvData);

	// NOTE: we must do this 1st thing, because the cached copy will have
	// have settings which need to be overritten, eg the attached-to port.
	if (pParams->dwFlags & MARKF_REGUSECOPY)
	{
		if (!GetStuffFromCache(pParams->hKeyDrv))
		{
			// Oh oh something happened -- fall back to old behaviour.
			pParams->dwFlags &= ~MARKF_REGUSECOPY;
		}
	}
	// (performance) possibility of not saving some stuff ahead
	// because it's already copied over from the cache

    switch (pParams->dwBus)
    {
        case BUS_TYPE_ROOT:
            // No; the modem has already been attached (detected
            // or manually selected)
            bRet = WriteRootModemInfo (hdi, *ppdevData);

            break;

        case BUS_TYPE_OTHER:
        case BUS_TYPE_PCMCIA:
        case BUS_TYPE_ISAPNP:

            bRet = WritePNPModemInfo (hdi, *ppdevData, pParams);

            break;

        case BUS_TYPE_SERENUM:
        case BUS_TYPE_LPTENUM:

            // Yes; it is an external (poor man's) plug and play modem
            bRet = WritePoorPNPModemInfo (pParams->hKeyDrv);

            break;

        default:

            ASSERT(0);
            bRet = FALSE;

            break;

    }


    if (bRet)
    {
        // Write the dynamic info to the registry that is
        // common to all modems.
        bRet = WriteCommonModemInfo (hdi, *ppdevData, pdrvData, pParams);
    }

    DBG_EXIT(DoPreGamePrep);
    return bRet;
}


/*----------------------------------------------------------
Purpose: Clean out obsolete values that are added by some
         inf files.

Returns: --
Cond:    --
*/
void
PRIVATE
WipeObsoleteValues(
    IN HKEY hkeyDrv)
{
    // These values are not used on NT

#pragma data_seg(DATASEG_READONLY)
    static TCHAR const FAR s_szDevLoader[]         = TEXT("DevLoader");
    static TCHAR const FAR s_szEnumPropPages[]     = TEXT("EnumPropPages");
    static TCHAR const FAR s_szFriendlyDriver[]    = TEXT("FriendlyDriver");
#pragma data_seg()

    RegDeleteValue(hkeyDrv, s_szDevLoader);             // used by VCOMM
    RegDeleteValue(hkeyDrv, s_szEnumPropPages);         // used by device mgr
    RegDeleteValue(hkeyDrv, s_szFriendlyDriver);        // used by VCOMM
    RegDeleteValue(hkeyDrv, c_szContention);            // used by VCOMM
}


/*----------------------------------------------------------
Purpose: This function moves the device's Responses key to
         a location that is common to all modems of the same
         type.

Returns: TRUE if success, FALSE otherwise.
Cond:    --
*/
BOOL
PRIVATE
MoveResponsesKey(
    IN  PINSTALL_PARAMS  pParams)
{
 BOOL    bRet = FALSE;       // assume failure
 LONG    lErr;
 HKEY    hkeyDrvResp = NULL;
 HKEY    hkeyComResp = NULL;

 WCHAR       achClass[MAX_PATH];
 DWORD       cchClassName = MAX_PATH;
 DWORD       cSubKeys, cbMaxSubKey, cchMaxClass;
 DWORD       cValues, cchValue, cbData, cbSecDesc;
 FILETIME    ftLastWrite;

 LPTSTR  lpValue = NULL;
 LPBYTE  lpData  = NULL;
 DWORD   ii, dwValueLen, dwType, dwDataLen, dwExisted = 0;

    // Create the Responses key that's common to all devices of this type.
    if (!OpenCommonResponsesKey (pParams->hKeyDrv,
                                 pParams->dwFlags&MARKF_SAMEDRV?CKFLAG_OPEN:CKFLAG_CREATE,
                                 KEY_WRITE, &hkeyComResp, &dwExisted))
    {
        TRACE_MSG(TF_ERROR, "OpenCommonResponsesKey() failed.");
        ASSERT(0);
        goto final_exit;
    }

	if (pParams->dwFlags & MARKF_REGUSECOPY)
	{
		if (dwExisted == REG_OPENED_EXISTING_KEY)
		{
		    bRet = TRUE;
            goto exit;
		}
		else
		{
			// Since we won't be creating the key or moving the responses
			// here, we're in serious trouble if the common responses didn't
			// already exist! We expect a previous devince install to have put
			// it there. On the free build however, we're going to move the
            // responses anyway.
			ASSERT(FALSE);
		}
	}

// Allow subsequent installations to upgrade the Responses key.
// As an optimization, we might want to avoid the upgrade when one modem
// is being installed on > 1 port in one install operation.  However this
// isn't deemed to be worth it at this time....
#if 0
    // If the key already existed, we can assume that the Responses values
    // have already been written there successfully and we're done.
    if (dwExisted == REG_OPENED_EXISTING_KEY)
    {
        bRet = TRUE;
        goto exit;
    }
#endif

    // Open the Responses subkey of the driver key.
    lErr = RegOpenKeyEx (pParams->hKeyDrv, c_szResponses, 0, KEY_READ, &hkeyDrvResp);
    if (lErr != ERROR_SUCCESS)
    {
        TRACE_MSG(TF_ERROR, "RegOpenKeyEx() failed: %#08lx.", lErr);
        ASSERT(0);
        goto exit;
    }

    // Determine the sizes of the values & data in the Responses key.
    lErr = RegQueryInfoKey (hkeyDrvResp, achClass, &cchClassName, NULL, &cSubKeys,
            &cbMaxSubKey, &cchMaxClass, &cValues, &cchValue, &cbData, &cbSecDesc,
            &ftLastWrite);
    if (lErr != ERROR_SUCCESS)
    {
        TRACE_MSG(TF_ERROR, "RegQueryInfoKey() failed: %#08lx.", lErr);
        ASSERT(0);
        goto exit;
    }

    // Not expecting Responses key to have any subkeys!
    ASSERT(cSubKeys == 0);

    // Value from RegQueryInfoKey() didn't include NULL-terminating character.
    cchValue++;

    // Allocate necessary space for Value and Data buffers.  Convert cchValue
    // character count to byte count, allowing for DBCS (double-byte chars).
    if ((lpValue = (LPTSTR)ALLOCATE_MEMORY( cchValue << 1)) == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ASSERT(0);
        goto exit;
    }

    if ((lpData = (LPBYTE)ALLOCATE_MEMORY( cbData)) == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ASSERT(0);
        goto exit;
    }

    // Enumerate driver Responses values and write them
    // to the common Responses key.
    ii = 0;
    dwValueLen = cchValue;
    dwDataLen = cbData;
    while ((lErr = RegEnumValue( hkeyDrvResp,
                                 ii,
                                 lpValue,
                                 &dwValueLen,
                                 NULL,
                                 &dwType,
                                 lpData,
                                 &dwDataLen )) != ERROR_NO_MORE_ITEMS)
    {
        if (lErr != ERROR_SUCCESS)
        {
            TRACE_MSG(TF_ERROR, "RegEnumValue() failed: %#08lx.", lErr);
            ASSERT(0);
            goto exit;
        }

        // 07/10/97 - EmanP
        // the next call should specify the actual length of the data, as
        // returned by the previous call (dwDataLen)
        lErr = RegSetValueEx(hkeyComResp, lpValue, 0, dwType, lpData, dwDataLen);
        if (lErr != ERROR_SUCCESS)
        {
            TRACE_MSG(TF_ERROR, "RegSetValueEx() failed: %#08lx.", lErr);
            ASSERT(0);
            goto exit;
        }

        // Set params for next enumeration
        ii++;
        dwValueLen = cchValue;
        dwDataLen = cbData;
    }

    bRet = TRUE;

exit:

    if (hkeyDrvResp)
        RegCloseKey(hkeyDrvResp);

    if (hkeyComResp)
        RegCloseKey(hkeyComResp);

    if (lpValue)
        FREE_MEMORY(lpValue);

    if (lpData)
        FREE_MEMORY(lpData);

    // If the move operation was successful then delete the original driver
    // Responses key.  If the move operation failed then delete the common
    // Responses key (or decrement its reference count).  This ensures that
    // if the common Responses key exists, it is complete.
    if (bRet)
    {
		if (!(pParams->dwFlags & MARKF_REGUSECOPY))
		{
			lErr = RegDeleteKey (pParams->hKeyDrv, c_szResponses);
			if (lErr != ERROR_SUCCESS)
			{
				TRACE_MSG(TF_ERROR, "RegDeleteKey(driver Responses) failed: %#08lx.", lErr);
				ASSERT(0);
			}
		}
    }
    else
    {
        if (!(pParams->dwFlags & MARKF_REGUSECOPY) &&
            !DeleteCommonDriverKey (pParams->hKeyDrv))
        {
            TRACE_MSG(TF_ERROR, "DeleteCommonDriverKey() failed.");
            // failure here just means the common key is left around
        }
    }

final_exit:

    return(bRet);

}





BOOL WINAPI
SetWaveDriverInstance(
    HKEY    ModemDriverKey
    )

{

    CONST static TCHAR  UnimodemRegPath[]=REGSTR_PATH_SETUP TEXT("\\Unimodem");

    LONG    lResult;
    HKEY    hKey;
    DWORD   Type;
    DWORD   Size;
    DWORD   VoiceProfile=0;


    Size =sizeof(VoiceProfile);

    lResult=RegQueryValueEx(
        ModemDriverKey,
        TEXT("VoiceProfile"),
        NULL,
        &Type,
        (LPBYTE)&VoiceProfile,
        &Size
        );

    if (lResult == ERROR_SUCCESS) {

        if ((VoiceProfile & 0x01) && (VoiceProfile & VOICEPROF_NT5_WAVE_COMPAT)) {
            //
            //  voice modem and supports NT5
            //
            HKEY    WaveKey;

            lResult=RegOpenKeyEx(
                ModemDriverKey,
                TEXT("WaveDriver"),
                0,
                KEY_READ | KEY_WRITE,
                &WaveKey
                );

            if (lResult == ERROR_SUCCESS) {
                //
                //  opened wavedriver key under modem key
                //
                HKEY    hKey2;
                DWORD   CurrentInstance;

                Size=sizeof(CurrentInstance);

                lResult=RegQueryValueEx(
                    ModemDriverKey,
                    TEXT("WaveInstance"),
                    NULL,
                    &Type,
                    (LPBYTE)&CurrentInstance,
                    &Size
                    );


                if (lResult != ERROR_SUCCESS) {
                    //
                    //  key does not exist, create it
                    //
                    lResult=RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        UnimodemRegPath,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hKey2
                        );

                    if (lResult == ERROR_SUCCESS) {
                        //
                        //  opened the unimodem software key
                        //
                        DWORD    NextInstance=0;

                        Size=sizeof(NextInstance);

                        lResult=RegQueryValueEx(
                            hKey2,
                            TEXT("NextWaveDriverInstance"),
                            NULL,
                            &Type,
                            (LPBYTE)&NextInstance,
                            &Size
                            );

                        if ((lResult == ERROR_SUCCESS) || (lResult == ERROR_FILE_NOT_FOUND)) {

                            lResult=RegSetValueEx(
                                WaveKey,
                                TEXT("WaveInstance"),
                                0,
                                REG_DWORD,
                                (LPBYTE)&NextInstance,
                                sizeof(NextInstance)
                                );

                            NextInstance++;

                            lResult=RegSetValueEx(
                                hKey2,
                                TEXT("NextWaveDriverInstance"),
                                0,
                                REG_DWORD,
                                (LPBYTE)&NextInstance,
                                sizeof(NextInstance)
                                );

                        }

                        RegCloseKey(hKey2);
                    }
                }

                RegCloseKey(WaveKey);
            }
        }
    }

    return TRUE;

}




/*----------------------------------------------------------
Purpose: This function does some things after the device is
         installed.  Note this function should not be used to
         add things to the driver key that are needed for the
         device to work.  The reason is because the device
         is activated in SetupDiInstallDevice -- the device
         should be ready by then.

Returns: NO_ERROR
Cond:    --
*/
BOOL
PRIVATE
DoPostGameWrapup(
    IN  HDEVINFO              hdi,
    IN  PSP_DEVINFO_DATA      pdevData,
    IN  PSP_DEVINSTALL_PARAMS pdevParams,
    IN  PINSTALL_PARAMS       pParams)
{
 BOOL bRet, bResponses;
 DWORD dwInstallFlag = 1;
 HKEY hKey;
#ifdef DEBUG
 DWORD dwRet;
#endif //DEBUG
#ifdef PROFILE
 DWORD dwLocal = GetTickCount ();
#endif //PROFILE

    DBG_ENTER(DoPostGameWrapup);
    
    ASSERT(hdi && INVALID_HANDLE_VALUE != hdi);
    ASSERT(pdevData);
    ASSERT(pdevParams);


	// If 2nd param is true, it will not really try to open or copy the
	// response key, but the reference count will be updated.
    bResponses = MoveResponsesKey (pParams);
#ifdef PROFILE
    TRACE_MSG(TF_GENERAL, "PROFILE: MoveResponsesKey took %lu ms.", GetTickCount()-dwLocal);
    dwLocal = GetTickCount ();
#endif //PROFILE

    // Clean out old values that are added by some inf files
    WipeObsoleteValues (pParams->hKeyDrv);
#ifdef PROFILE
    TRACE_MSG(TF_GENERAL, "PROFILE: WipeObsoleteValues took %lu ms.", GetTickCount()-dwLocal);
    dwLocal = GetTickCount ();
#endif //PROFILE

    // Write the Default and DCB default settings
    bRet = WriteDriverDefaults (pParams);
#ifdef PROFILE
    TRACE_MSG(TF_GENERAL, "PROFILE: WriteDriverDefaults took %lu ms.", GetTickCount()-dwLocal);
    dwLocal = GetTickCount ();
#endif //PROFILE

    if (bRet)
    {
        // Finish up with miscellaneous device installation handling

        // Does the system need to restart before the
        // modem can be used?
        if (ReallyNeedsReboot(pdevData, pdevParams))
        {
#ifdef INSTANT_DEVICE_ACTIVATION
            gDeviceFlags |= fDF_DEVICE_NEEDS_REBOOT;
#endif // !INSTANT_DEVICE_ACTIVATION
        }
    }

    // If this function failed somewhere, remove any common Responses key
    // that it created.  The driver will be removed by the caller.
    if (bResponses && !bRet)
    {
        if (!DeleteCommonDriverKey (pParams->hKeyDrv))
        {
            TRACE_MSG(TF_ERROR, "DeleteCommonDriverKey() failed.");
            // failure here just means the common key is left around
        }
    }

	if (bRet && pParams->dwFlags & MARKF_REGSAVECOPY)
	{
		if (!PutStuffInCache (pParams->hKeyDrv))
		{
			// oh oh, something happened, clear *lpdwRegType;
			pParams->dwFlags &= ~MARKF_REGSAVECOPY;
		}
#ifdef PROFILE
        TRACE_MSG(TF_GENERAL, "PROFILE: PutStuffInCache took %lu ms.", GetTickCount()-dwLocal);
#endif //PROFILE
	}

    SetWaveDriverInstance (pParams->hKeyDrv);

    if (ERROR_SUCCESS == (
#ifdef DEBUG
        dwRet =
#endif //DEBUG
        RegOpenKeyEx (HKEY_LOCAL_MACHINE, REG_PATH_INSTALLED, 0, KEY_ALL_ACCESS,&hKey)))
    {
        RegSetValueEx (hKey, NULL, 0, REG_DWORD, (PBYTE)&dwInstallFlag, sizeof(dwInstallFlag));
        RegCloseKey (hKey);
    }
    ELSE_TRACE ((TF_ERROR, "RegOpenKeyEx (%s) failed: %#lx",REG_PATH_INSTALLED, dwRet));

    if (bRet)
    {
        CplDiMarkInstalled (pParams->hKeyDrv);
    }

    {
        HMODULE   hLib;
	    TCHAR     szLib[MAX_PATH];

	    lstrcpy(szLib,TEXT("modemui.dll"));
        hLib=LoadLibrary(szLib);

        if (hLib != NULL) {

            lpQueryModemForCountrySettings  Proc;

            Proc=(lpQueryModemForCountrySettings)GetProcAddress(hLib,"QueryModemForCountrySettings");

            if (Proc != NULL) {

                Proc(pParams->hKeyDrv,TRUE);

            }

            FreeLibrary(hLib);
        }

    }

    DBG_EXIT(DoPostGameWrapup);
    return bRet;
}



UINT FileQueueCallBack (
  PVOID Context,  // context used by the default callback routine
  UINT Notification,
                  // queue notification
  UINT_PTR Param1,    // additional notification information
  UINT_PTR Param2)    // additional notification information
{
    if (SPFILENOTIFY_QUEUESCAN == Notification)
    {
        (*(DWORD*)Context)++;
        TRACE_MSG (TF_GENERAL, "\tFileQueue: file: %s.", (PTCHAR)Param1);
    }

    return NO_ERROR;
}

 
static const TCHAR sz_SerialSys[]   = TEXT("serial.sys");
static const TCHAR sz_ModemSys[]    = TEXT("modem.sys");
static const TCHAR sz_RootmdmSys[]  = TEXT("rootmdm.sys");
static const TCHAR sz_Drivers[]     = TEXT("\\Drivers");
/*----------------------------------------------------------
Purpose: DIF_INSTALLDEVICEFILES handler

Returns: NO_ERROR
         other errors

Cond:    --
*/
DWORD
PRIVATE
ClassInstall_OnInstallDeviceFiles (
    IN     HDEVINFO                hdi,
    IN     PSP_DEVINFO_DATA        pdevData,       OPTIONAL
    IN OUT PSP_DEVINSTALL_PARAMS   pdevParams)
{
 DWORD dwRet;
 TCHAR szDirectory[MAX_PATH];
 DWORD dwCount = 0;
 SP_FILE_COPY_PARAMS copyParams;
 ULONG ulStatus, ulProblem = 0;

    if (NULL == pdevParams->FileQueue)
    {
        // If there's no file queue, just
        // let setup do it's thing.
        return ERROR_DI_DO_DEFAULT;
    }

    // First, let setup figure out if there's any
    // driver(s) that this modem needs; this would
    // be a controllerless modem, and the drivers
    // would come from the INF
    if (!SetupDiInstallDriverFiles (hdi, pdevData))
    {
        return GetLastError ();
    }

    return NO_ERROR;
}



/*----------------------------------------------------------
Purpose: DIF_INSTALLDEVICE handler

Returns: NO_ERROR
         ERROR_INVALID_PARAMETER
         ERROR_DI_DO_DEFAULT

Cond:    --
*/
DWORD
PRIVATE
ClassInstall_OnInstallDevice(
    IN     HDEVINFO                hdi,
    IN     PSP_DEVINFO_DATA        pdevData,       OPTIONAL
    IN OUT PSP_DEVINSTALL_PARAMS   pdevParams)
{
 DWORD dwRet;
 SP_DRVINFO_DATA drvData = {sizeof(drvData),0};
 INSTALL_PARAMS params;
#ifdef PROFILE
 DWORD dwLocal, dwGlobal = GetTickCount ();
#endif //PROFILE

    DBG_ENTER(ClassInstall_OnInstallDevice);
    TRACE_MSG(TF_GENERAL, "hdi = %#lx, pdevData = %#lx, devinst = %#lx.", hdi, pdevData, pdevData->DevInst);
    
#ifdef PROFILE_MASSINSTALL
    g_hwnd = pdevParams->hwndParent;
#endif

    // Is this a NULL device?
    // (Ie, is it not in our INF files and did the user say "don't
    // install"?)
    if ( !CplDiGetSelectedDriver(hdi, pdevData, &drvData) )
    {
        // Yes; have the device install handle it by default
        TRACE_MSG(TF_GENERAL, "Passing installation off to device installer");

        dwRet = ERROR_DI_DO_DEFAULT;
    }
    else
    {
        // No; continue to install the modem our way
     BOOL bRet;

        dwRet = NO_ERROR;               // assume success ("I am inveencible!")

#ifdef PROFILE
        dwLocal = GetTickCount ();
#endif //PROFILE
        if (!PrepareForInstallation (hdi, pdevData, pdevParams, &drvData, &params))
        {
            dwRet = GetLastError ();
        }
        else
        {
#ifdef PROFILE
            TRACE_MSG(TF_GENERAL, "PROFILE: PrepareForInstallation took %lu ms.", GetTickCount()-dwLocal);
            dwLocal = GetTickCount ();
#endif //PROFILE
            // Write possible values to the driver key before we
            // execute the real installation.
			// Note that this may modify the dwRegType value. In particular,
			// If there was a problem getting the saved reg info info during
			// pregameprep in the REGUSECOPY case, dwRegType will be cleared.
            bRet = DoPreGamePrep(hdi, &pdevData, pdevParams, &drvData, &params);
#ifdef PROFILE
            TRACE_MSG(TF_GENERAL, "PROFILE: DoPreGamePrep took %lu ms.", GetTickCount()-dwLocal);
            dwLocal = GetTickCount ();
#endif //PROFILE
            if (bRet)
            {
                // Install the modem.  This does the real work.  We should
				if (params.dwFlags & MARKF_REGUSECOPY)
				{
                    SP_DEVINSTALL_PARAMS devParams1;

                    devParams1.cbSize = sizeof(devParams1);
                    bRet = CplDiGetDeviceInstallParams(
								hdi, pdevData, &devParams1);
                    if (bRet)
					{
						SetFlag(
							devParams1.FlagsEx,
							DI_FLAGSEX_NO_DRVREG_MODIFY
							);
        				CplDiSetDeviceInstallParams(
							hdi,
							pdevData,
							&devParams1);
					}
				}

                // be done with our stuff before we call this function.
                TRACE_MSG(TF_GENERAL, "> SetupDiInstallDevice().....");
        		bRet = CplDiInstallDevice(hdi, pdevData);
                TRACE_MSG(TF_GENERAL, "< SetupDiInstallDevice().....");
#ifdef PROFILE
                TRACE_MSG(TF_GENERAL, "PROFILE: SetupDiInstallDevice took %lu ms.", GetTickCount()-dwLocal);
                dwLocal = GetTickCount ();
#endif //PROFILE

                if (bRet)
                {
                    SP_DEVINSTALL_PARAMS devParams;

                    // Get the device install params since the installation
                    devParams.cbSize = sizeof(devParams);
                    bRet = CplDiGetDeviceInstallParams(hdi, pdevData, &devParams);
                    ASSERT(bRet);

                    if (bRet)
                    {
                        // Do some after-install things
						// See comments regarding dwRegType in PreGamePrep.
                        bRet = DoPostGameWrapup (hdi, pdevData, &devParams, &params);
#ifdef PROFILE
                        TRACE_MSG(TF_GENERAL, "PROFILE: DoPostGamePrep took %lu ms.", GetTickCount()-dwLocal);
                        dwLocal = GetTickCount ();
#endif //PROFILE
                    }
                }
                else
                {
                    TRACE_MSG(TF_ERROR, "CplDiInstallDevice returned error %#08lx", GetLastError());
                }
            }

            // Did the installation fail somewhere above?
            if ( !bRet )
            {
                // Yes; delete the driver key that we created.
                dwRet = GetLastError();

                if (NO_ERROR == dwRet)
                {
                    // Think of some reason why this failed...
                    dwRet = ERROR_NOT_ENOUGH_MEMORY;
                }

                if (ERROR_CANCELLED != dwRet)
                {
                    if (IsFlagClear (pdevParams->Flags, DI_QUIETINSTALL))
                    {
                        if (IDCANCEL ==
                            MsgBox (g_hinst,
                                    pdevParams->hwndParent,
                                    MAKEINTRESOURCE(IDS_ERR_CANT_INSTALL_MODEM),
                                    MAKEINTRESOURCE(IDS_CAP_MODEMSETUP),
                                    NULL,
                                    MB_OKCANCEL | MB_ICONINFORMATION))
                        {
                            dwRet = ERROR_CANCELLED;
                        }
                    }
                }

                // Try removing the modem since CplDiInstallDevice
                // will not always clean up completely. Leaving
                // partially filled registry entries lying around
                // can cause problems.
                /* bRet = CplDiRemoveDevice(hdi, pdevData);
                if ( !bRet )
                {
                    TRACE_MSG(TF_ERROR, "Not able to remove a modem.  Error = %#08lx.", GetLastError());
                } */

            }
            else
            {
#ifndef PROFILE_MASSINSTALL
                TRACE_MSG(TF_GENERAL, "settig gDeviceChange to TRUE");
#endif
                if (BUS_TYPE_ROOT == params.dwBus)
                {
                    gDeviceFlags|=fDF_DEVICE_ADDED;
                }
            }

            FinishInstallation (&params);
        }
    }

#ifdef PROFILE
    TRACE_MSG(TF_GENERAL, "PROFILE: TotalInstallation took %lu ms.", GetTickCount()-dwGlobal);
#endif //PROFILE
    DBG_EXIT(ClassInstall_OnInstallDevice);
    return dwRet;
}

#define SERIAL_PORT TEXT("COM")
int my_atol(LPTSTR lptsz);
void ReleasePortName (
    IN HDEVINFO         hdi,
    IN PSP_DEVINFO_DATA pdevData)
{
 HKEY  hkey = NULL;
 TCHAR szPort[MAX_REG_KEY_LEN];
 DWORD cbData;
 DWORD dwRet = NO_ERROR;
 DWORD dwBusType;

    if (!CplDiGetBusType(hdi, pdevData, &dwBusType))
    {
        TRACE_MSG(TF_ERROR, "ReleasePortName: could not get bus type: %#lx", GetLastError ());
        return;
    }

    switch (dwBusType)
    {
        case BUS_TYPE_ROOT:
        case BUS_TYPE_SERENUM:
        case BUS_TYPE_LPTENUM:
            // For these buses, we didn't
            // allocate a port name
            return;
    }

    hkey = SetupDiOpenDevRegKey (hdi,
                                 pdevData, 
                                 DICS_FLAG_GLOBAL,
                                 0,
                                 DIREG_DEV,
                                 KEY_READ);
    if (INVALID_HANDLE_VALUE != hkey)
    {
        cbData = sizeof (szPort);
        dwRet = RegQueryValueEx (hkey, REGSTR_VAL_PORTNAME, NULL,
                                 NULL, (LPBYTE)szPort, &cbData);
        RegCloseKey (hkey);
        hkey = INVALID_HANDLE_VALUE;
        if (ERROR_SUCCESS == dwRet)
        {
         TCHAR *pTchr;

            TRACE_MSG(TF_GENERAL, "Releasing %s", szPort);

            for (pTchr = szPort;
                 *pTchr && IsCharAlpha (*pTchr);
                 pTchr++);
            if (*pTchr)
            {
             DWORD dwPort = 0;
                dwPort = my_atol (pTchr);
                TRACE_MSG(TF_GENERAL, "Port number %i", dwPort);

                if (MAXDWORD != dwPort)
                {
                    *pTchr = 0;
                    if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szPort, -1, SERIAL_PORT, -1) == 2)
                    {
                     HCOMDB hComDb;
                        ComDBOpen (&hComDb);
                        if (HCOMDB_INVALID_HANDLE_VALUE != hComDb)
                        {
                            ComDBReleasePort (hComDb, dwPort);
                            ComDBClose (hComDb);
                        }
                    }
                }
            }
        }
    }
}


/*----------------------------------------------------------
Purpose: DIF_REMOVE handler

Returns: NO_ERROR
         ERROR_INVALID_PARAMETER
         ERROR_DI_DO_DEFAULT

Cond:    --
*/
DWORD
PRIVATE
ClassInstall_OnRemoveDevice(
    IN     HDEVINFO                hdi,
    IN     PSP_DEVINFO_DATA        pdevData)
{
 HKEY  hkey = NULL;
 TCHAR szComDrv[MAX_REG_KEY_LEN];
 DWORD dwRet = NO_ERROR;
 DWORD cbData;
#ifdef PROFILE
 DWORD dwLocal, dwGlobal = GetTickCount ();
#endif //PROFILE

    DBG_ENTER(ClassInstall_OnRemoveDevice);

    // First, release the port name
#ifdef PROFILE
        dwLocal = GetTickCount ();
#endif //PROFILE
    ReleasePortName (hdi, pdevData);
#ifdef PROFILE
    TRACE_MSG(TF_GENERAL, "PROFILE: RelseaPortName took %lu ms.", GetTickCount()-dwLocal);
#endif //PROFILE

    // Get the name of the common driver key for this driver, in
    // preparation for calling DeleteCommonDriverKeyByName() after the
    // device is successfully removed.
    szComDrv[0] = 0;
    hkey = CplDiOpenDevRegKey (hdi,
                               pdevData, 
                               DICS_FLAG_GLOBAL,
                               0,
                               DIREG_DRV,
                               KEY_READ);

    if (hkey != INVALID_HANDLE_VALUE)
    {
        if (!FindCommonDriverKeyName(hkey, sizeof(szComDrv) / sizeof(TCHAR), szComDrv))
        {
            TRACE_MSG(TF_ERROR, "FindCommonDriverKeyName() FAILED.");
            szComDrv[0] = 0;
        }

        RegCloseKey(hkey);
    }

#ifdef DEBUG
    else
    {
        TRACE_MSG(TF_ERROR, "CplDiOpenDevRegKey() returned error %#08lx", GetLastError());
    }
#endif

#ifdef PROFILE
        dwLocal = GetTickCount ();
#endif //PROFILE
    if (!SetupDiRemoveDevice(hdi, pdevData))
    {
        dwRet = GetLastError ();
    }
    else
    {
#ifdef PROFILE
        TRACE_MSG(TF_GENERAL, "PROFILE: SetupDiRemoveDevice took %lu ms.", GetTickCount()-dwLocal);
#endif //PROFILE

        //gDeviceFlags |= fDF_DEVICE_REMOVED;

        if (szComDrv[0] != 0)
        {                
#ifdef PROFILE
            dwLocal = GetTickCount ();
#endif //PROFILE
            if (!DeleteCommonDriverKeyByName(szComDrv))
            {
                TRACE_MSG(TF_ERROR, "DeleteCommonDriverKey() FAILED.");
            }
#ifdef PROFILE
            TRACE_MSG(TF_GENERAL, "PROFILE: DeleteCommonDriverKeyByName took %lu ms.", GetTickCount()-dwLocal);
#endif //PROFILE
        }
    }

#ifdef PROFILE
    TRACE_MSG(TF_GENERAL, "PROFILE: Total time removing modem %lu ms.", GetTickCount()-dwGlobal);
#endif //PROFILE
    DBG_EXIT_DWORD(ClassInstall_OnRemoveDevice, dwRet);
    return dwRet;
}


/*----------------------------------------------------------
Purpose: DIF_SELECTBESTCOMPATDRV

In this function, we look for driver nodes having the following characteristics:

1.  Driver ver date is older than 7/1/01 (magic date beyond which we've promised vendors that their
    Win2K submissions will be chosen on XP.

2.  INF is containing one or more services.

We'll consider such driver nodes as "suspect", and shift their rank into an untrusted range.
Then the class installer will return ERROR_DI_DO_DEFAULT, and we'll now treat these drivers
as if they're unsighed for the purposes of driver selection. Note that if we don't have an
in-box (signed) driver, then setup will still pick one of these.

Bug: #440830


Returns: NO_ERROR
         ERROR_DI_DO_DEFAULT
*/

DWORD
PRIVATE
ClassInstall_SelectBestCompatDrv(
    IN  HDEVINFO                hDevInfo,
    IN  PSP_DEVINFO_DATA        pDevData)
{
    SP_DRVINFO_DATA DrvInfoData;
    SP_DRVINFO_DETAIL_DATA DrvInfoDetailData;
    SP_DRVINSTALL_PARAMS DrvInstallParams;
    SP_INF_SIGNER_INFO InfSignerInfo;
    SYSTEMTIME SystemTime;
    INFCONTEXT infContext;
    BOOL bTrust;
    DWORD cbOutputSize = 0;
    TCHAR ActualInfSection[LINE_LEN];
    DWORD dwResult = ERROR_DI_DO_DEFAULT;
    DWORD index = 0;

    ZeroMemory(&DrvInfoData,sizeof(SP_DRVINFO_DATA));
    DrvInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

    while(SetupDiEnumDriverInfo(hDevInfo,
                                pDevData,
                                SPDIT_COMPATDRIVER,
                                index++,
                                &DrvInfoData))
    {

        bTrust = FALSE;

        // Check driver date. If the driver is younger than 1 July 2001 then this becomes a trusted driver.

        if (FileTimeToSystemTime(&DrvInfoData.DriverDate, &SystemTime))
        {
            if (!((SystemTime.wYear < 2001)
                  || ((SystemTime.wYear == 2001) && (SystemTime.wMonth < 7))))
            {
                bTrust = TRUE;
                TRACE_MSG(TF_GENERAL,"%ws is trusted based on SystemTime",DrvInfoData.Description);
            }
        }

        // Check for services section and signature.

        ZeroMemory(&DrvInfoDetailData,sizeof(SP_DRVINFO_DETAIL_DATA));
        DrvInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

        if (!SetupDiGetDriverInfoDetail(hDevInfo,
                                        pDevData,
                                        &DrvInfoData,
                                        &DrvInfoDetailData,
                                        DrvInfoDetailData.cbSize,
                                        &cbOutputSize)
            && (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
        {
            dwResult = GetLastError();
            TRACE_MSG(TF_ERROR, "SetupDiGetDriverInfoDetail failed: %#08lx", dwResult);
            goto End;
        }

        if (!bTrust)
        {
            HINF hInf = INVALID_HANDLE_VALUE;

            hInf = SetupOpenInfFile(DrvInfoDetailData.InfFileName,NULL,INF_STYLE_WIN4,NULL);

            if (hInf != INVALID_HANDLE_VALUE)
            {
                if (SetupDiGetActualSectionToInstall(hInf,
                                                     DrvInfoDetailData.SectionName,
                                                     ActualInfSection,
                                                     sizeof(ActualInfSection) / sizeof(TCHAR),
                                                     NULL,
                                                     NULL))
                {
                    if ((DWORD)lstrlen(TEXT(".Services")) 
                          < ((sizeof(ActualInfSection) / sizeof(TCHAR)) - lstrlen(ActualInfSection)))
                    {
                        lstrcat(ActualInfSection,TEXT(".Services"));

                        if (!SetupFindFirstLine(hInf,ActualInfSection, TEXT("AddService"), &infContext))
                        {
                            bTrust = TRUE;
                            TRACE_MSG(TF_GENERAL,"%ws is trusted based on no AddService",DrvInfoData.Description);
                        }
                    }
                        
                } else
                {

                    dwResult = GetLastError();
                    TRACE_MSG(TF_ERROR, "SetupDiGetActualSectionToInstall failed: %#08lx", dwResult);

                    SetupCloseInfFile(hInf);
                    goto End;
                }

                SetupCloseInfFile(hInf);
            } else
            {
                dwResult = GetLastError();
                TRACE_MSG(TF_ERROR, "SetupOpenInfFile failed: %#08lx", dwResult);
                goto End;
            }

        } 

        // If bTrust is FALSE then we consider the driver node as 
        // "suspect" and shift the rank into an untrusted range.

        if (!bTrust)
        {
            ZeroMemory(&DrvInstallParams, sizeof(SP_DRVINSTALL_PARAMS));
            DrvInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);

            if (SetupDiGetDriverInstallParams(hDevInfo,
                                              pDevData,
                                              &DrvInfoData,
                                              &DrvInstallParams))
            {
                DrvInstallParams.Rank |= DRIVER_UNTRUSTED_RANK;

                if(!SetupDiSetDriverInstallParams(hDevInfo,
                                                  pDevData,
                                                  &DrvInfoData,
                                                  &DrvInstallParams))
                {
                    dwResult = GetLastError();
                    TRACE_MSG(TF_ERROR, "SetupDiSetDriverInstallParams failed: %#08lx", dwResult);
                    goto End;
                }

                TRACE_MSG(TF_GENERAL,"%ws is untrusted\n",DrvInfoData.Description);
            } else
            {
                dwResult = GetLastError();
                TRACE_MSG(TF_ERROR, "SetupDiGetDriverInstallParams failed: %#08lx", dwResult);
                goto End;
            }

        }
    }

End:
    return dwResult;
}


/*----------------------------------------------------------
Purpose: DIF_ALLOW_INSTALL handler

Returns: NO_ERROR
         ERROR_NON_WINDOWS_NT_DRIVER

Cond:    --
*/
DWORD
PRIVATE
ClassInstall_OnAllowInstall (
    IN     HDEVINFO         hdi,
    IN     PSP_DEVINFO_DATA pdevData)
{
 DWORD dwRet = NO_ERROR;
 SP_DRVINFO_DATA drvData = {sizeof(drvData),0};
 SP_DRVINFO_DETAIL_DATA drvDetail = {sizeof(drvDetail),0};
 HINF hInf = INVALID_HANDLE_VALUE;
 TCHAR szRealSection[LINE_LEN];
 PTSTR pszExt;
 INFCONTEXT  Context;

    DBG_ENTER(ClassInstall_OnAllowInstall);

    if (!SetupDiGetSelectedDriver(hdi, pdevData, &drvData))
    {
        dwRet = GetLastError ();
        TRACE_MSG(TF_ERROR, "SetupDiGetSelectedDriver failed: %#08lx", dwRet);
        goto _Exit;
    }

    if (!SetupDiGetDriverInfoDetail (hdi, pdevData, &drvData, &drvDetail,
                                                drvDetail.cbSize, NULL))
    {
        dwRet = GetLastError();
        // ignore expected ERROR_INSUFFICIENT_BUFFER (didn't extend buffer size)
        if (ERROR_INSUFFICIENT_BUFFER == dwRet)
        {
            dwRet = NO_ERROR;
        }
        else
        {
            TRACE_MSG(TF_ERROR, "CplDiGetDriverInfoDetail returned error %#08lx", dwRet);
            goto _Exit;
        }
    }

    // try to open the INF file in order to get the HINF
    hInf = SetupOpenInfFile (drvDetail.InfFileName,
                             NULL,
                             INF_STYLE_OLDNT | INF_STYLE_WIN4,
                             NULL);

    if (INVALID_HANDLE_VALUE == hInf)
    {
        dwRet = GetLastError ();
        TRACE_MSG(TF_ERROR, "SetupOpenInfFile returned error %#08lx", dwRet);
        goto _Exit;
    }

    // Determine the complete name of the driver's INF section
    if (!SetupDiGetActualSectionToInstall (hInf, drvDetail.SectionName,
                                           szRealSection, LINE_LEN, NULL, &pszExt))
    {
        dwRet = GetLastError ();
        TRACE_MSG(TF_ERROR, "CplDiGetActualSectionToInstall returned error %#08lx", dwRet);
        goto _Exit;
    }

    // If the section name does not have an extension,
    // or the extension is not NT5, then only allow the modem
    // to install if this doesn't mean copying files.
    if (NULL == pszExt ||
        0 != lstrcmpi (pszExt, c_szInfSectionExt))
    {
        if (SetupFindFirstLine (hInf, szRealSection, TEXT("CopyFiles"), &Context))
        {
            dwRet = ERROR_NON_WINDOWS_NT_DRIVER;
        }

    }

_Exit:
    if (INVALID_HANDLE_VALUE != hInf)
    {
        SetupCloseInfFile (hInf);
    }

    DBG_EXIT_DWORD(ClassInstall_OnAllowInstall, dwRet);
    return dwRet;
}


/*----------------------------------------------------------
Purpose: This function is the class installer entry-point.

Returns:
Cond:    --
*/
DWORD
APIENTRY
ClassInstall32(
    IN DI_FUNCTION      dif,
    IN HDEVINFO         hdi,
    IN PSP_DEVINFO_DATA pdevData)       OPTIONAL
{
 DWORD dwRet = 0;
 SP_DEVINSTALL_PARAMS devParams;
#ifdef PROFILE_FIRSTTIMESETUP
 DWORD dwLocal;
#endif //PROFILE_FIRSTTIMESETUP

    DBG_ENTER_DIF(ClassInstall32, dif);

    try
    {
        // Get the DeviceInstallParams, because some of the InstallFunction
        // handlers may find some of its fields useful.  Keep in mind not
        // to set the DeviceInstallParams using this same structure at the
        // end.  The handlers may have called functions which would change the
        // DeviceInstallParams, and simply calling CplDiSetDeviceInstallParams
        // with this blanket structure would destroy those settings.
        devParams.cbSize = sizeof(devParams);
        if ( !CplDiGetDeviceInstallParams(hdi, pdevData, &devParams) )
        {
            dwRet = GetLastError();
            ASSERT(NO_ERROR != dwRet);
        }
        else
        {
            // Dispatch the InstallFunction
            switch (dif)
            {
            case DIF_ALLOW_INSTALL:
                dwRet = ClassInstall_OnAllowInstall (hdi, pdevData);
                break;

            case DIF_INSTALLDEVICEFILES:
                dwRet = ClassInstall_OnInstallDeviceFiles (hdi, pdevData, &devParams);
                break;

            case DIF_INSTALLWIZARD:
                dwRet = ClassInstall_OnInstallWizard(hdi, pdevData, &devParams);
                break;

            case DIF_DESTROYWIZARDDATA:
                dwRet = ClassInstall_OnDestroyWizard(hdi, pdevData, &devParams);
                break;

            case DIF_SELECTBESTCOMPATDRV:
                dwRet = ClassInstall_SelectBestCompatDrv(hdi, pdevData);
                break;


            case DIF_FIRSTTIMESETUP:
            case DIF_DETECT:
            {
             DWORD dwTmp, cbPorts;
             HKEY hKey;
             DWORD dwThreadID;
#ifdef PROFILE_FIRSTTIMESETUP
                dwLocal = GetTickCount ();
#endif //PROFILE_FIRSTTIMESETUP
#ifdef BUILD_DRIVER_LIST_THREAD
                // First, create a thread that will
                // build the class driver list.
                g_hDriverSearchThread = CreateThread (NULL, 0,
                                                      BuildDriverList, (LPVOID)hdi,
                                                      0, &dwThreadID);
#endif //BUILD_DRIVER_LIST_THREAD

                if (DIF_FIRSTTIMESETUP == dif)
                {
                    ClassInstall_OnFirstTimeSetup ();
                    // Try to figure out if we have to many ports;
                    // if we do, don't try to detect modems on them,
                    // we will timeout
                    dwRet = ERROR_DI_DO_DEFAULT;
                    dwTmp = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                          TEXT("HARDWARE\\DEVICEMAP\\SERIALCOMM"),
                                          0,
                                          KEY_ALL_ACCESS,
                                          &hKey);
                    if (ERROR_SUCCESS != dwTmp)
                    {
                        // Couldn't open SERIALCOMM, so no point
                        // in going on with the detection
                        TRACE_MSG(TF_ERROR, "RegOpenKeyEx (HARDWARE\\DEVICEMAP\\SERIALCOMM) failed: %#lx", dwTmp);
                        break;
                    }

                    dwTmp = RegQueryInfoKey (hKey, NULL, NULL, NULL, NULL, NULL,
                                             NULL, &cbPorts, NULL, NULL, NULL, NULL);
                    RegCloseKey (hKey);

                    if (ERROR_SUCCESS != dwTmp ||
                        MIN_MULTIPORT < cbPorts)
                    {
                        TRACE_MSG(TF_ERROR,
                                  ERROR_SUCCESS != dwTmp?"RegQueryInfoKey failed: %#lx":"Too many ports: %l",
                                  ERROR_SUCCESS != dwTmp?dwTmp:cbPorts);
                        // We either don't have any ports listed in SERIALCOMM
                        // or we have to many; anyway, don't do the detection
                        break;
                    }
                }
#ifdef DO_LEGACY_DETECT
                dwRet = ClassInstall_OnDetect(hdi, &devParams);
#endif //DO_LEGACY_DETECT

#ifdef PROFILE_FIRSTTIMESETUP
                TRACE_MSG(TF_GENERAL, "PROFILE: DIF_DETECT took %lu.", GetTickCount()-dwLocal);
#endif //PROFILE_FIRSTTIMESETUP

#ifdef BUILD_DRIVER_LIST_THREAD
                if (NULL != g_hDriverSearchThread)
                {
                    // If we didn't find any modem, no point in continuing to
                    // build the driver info list.
                    // If we found a modem, the driver search is acutally finished,
                    // so there's no harm in calling this.
                    SetupDiCancelDriverInfoSearch (hdi);
                    CloseHandle (g_hDriverSearchThread);
                }
#endif //BUILD_DRIVER_LIST_THREAD

                break;
            }


            case DIF_INSTALLDEVICE:
                //
                //
                dwRet = ClassInstall_OnInstallDevice(hdi, pdevData, &devParams);
                break;

            case DIF_REMOVE:
                // 07/09/97 - EmanP
                // Moved the code for removing the modem to the
                // class installer from the CPL
                dwRet = ClassInstall_OnRemoveDevice(hdi, pdevData);
                break;

            case DIF_SELECTDEVICE:
                dwRet = ClassInstall_OnSelectDevice(hdi, pdevData);
                break;

            case DIF_DESTROYPRIVATEDATA:
                // 07/08/97 - EmanP
                // If any devices were added / removed,
                // we should notify TSP
#ifdef INSTANT_DEVICE_ACTIVATION
                if (DEVICE_CHANGED(gDeviceFlags))
                {
                    UnimodemNotifyTSP (TSPNOTIF_TYPE_CPL,
                                       fTSPNOTIF_FLAG_CPL_REENUM,
                                       0, NULL, TRUE);
                    // Reset the flag, so we don't notify
                    // twice
                    gDeviceFlags &= mDF_CLEAR_DEVICE_CHANGE;
                }
                dwRet = NO_ERROR;
                break;
#endif // INSTANT_DEVICE_ACTIVATION

            case DIF_REGISTERDEVICE:
            {
             COMPARE_PARAMS cmpParams;

                // 07/24/97 - EmanP
                // default behaviour for DIF_REGISTERDEVICE
                // this is called by whoever called DIF_FIRSTTIMESETUP
                // to register the device and eliminate duplicates
                dwRet = NO_ERROR;
                if (!InitCompareParams (hdi, pdevData, TRUE, &cmpParams))
                {
                    dwRet = GetLastError ();
                    break;
                }

                if (!SetupDiRegisterDeviceInfo (hdi,
                                              pdevData,
                                              SPRDI_FIND_DUPS,
                                              DetectSig_Compare,
                                              (PVOID)&cmpParams,
                                              NULL))
                {
                    dwRet = GetLastError ();
                }
                break;
            }

            default:
                dwRet = ERROR_DI_DO_DEFAULT;
                break;
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
        {
        dwRet = ERROR_INVALID_PARAMETER;
        }

    DBG_EXIT_DIF_DWORD(ClassInstall32, dif, dwRet);

    return dwRet;
}


BOOL RegCopy(
		HKEY hkTo,
		HKEY hkFrom,
		DWORD dwToRegOptions,
		DWORD dwMaxDepth
		)
{
	// Note: This function is recursive and keeps open keys around,
	// Max number of open keys = twize depth of recursion.
    BOOL	fRet = FALSE;       // assume failure
    LONG	lRet;
    DWORD	cSubKeys, cValues;
	DWORD	cchMaxSubKey, cchMaxValueName;
	DWORD	cbMaxValueData;
    LPTSTR  ptszName = NULL;
    BYTE   *pbData  = NULL;
    DWORD   dwType;
    UINT    ii;
	DWORD   cbMaxName;
	BYTE	rgbTmp[256];
	BYTE	*pb=NULL;
	BOOL	fAlloc=FALSE;
	HKEY hkFromChild=NULL;
	HKEY hkToChild=NULL;

    // Get counts and sizes of values, keys and data
    lRet = RegQueryInfoKey(
					hkFrom,
					NULL,
					NULL,
					NULL,
					&cSubKeys,
            		&cchMaxSubKey,
					NULL,
					&cValues,
					&cchMaxValueName,
					&cbMaxValueData,
					NULL,
            		NULL
					);
    if (lRet != ERROR_SUCCESS) goto end;
    
	// Enough space for any Key or ValueName. '+1' is for terminating NULL.
	cbMaxName = (((cchMaxSubKey>cchMaxValueName)?cchMaxSubKey:cchMaxValueName)
				+ 1)*sizeof(TCHAR);

	// If rgbTmp is big enough, use it, else alloc.
	if ((cbMaxName+cbMaxValueData)>sizeof(rgbTmp))
	{
		pb = (BYTE*)ALLOCATE_MEMORY( cbMaxName+cbMaxValueData);
		if (!pb) goto end;
		fAlloc=TRUE;
	}
	else
	{
		pb = rgbTmp;
	}
	ptszName = (LPTSTR)pb;
	pbData   = pb+cbMaxName;


	// Note as input, cch (character counts) include terminating NULL.
	// As ouput, they don't include terminating NULL.

	for(ii=0; ii<cValues; ii++)
	{
    	DWORD   cchThisValue= cchMaxValueName+1;
		DWORD   cbThisData  = cbMaxValueData;
		lRet = RegEnumValue(
					hkFrom,
					ii,
					ptszName,
					&cchThisValue,
					NULL,
					&dwType,
					pbData,
					&cbThisData
					);
		if (lRet!=ERROR_SUCCESS) goto end;

		ASSERT(cbThisData<=cbMaxValueData);
		ASSERT(cchThisValue<=cchMaxValueName);
		lRet = RegSetValueEx(
					hkTo,
					ptszName,
					0,
					dwType,
					pbData,
					cbThisData
					);
		if (lRet!=ERROR_SUCCESS) goto end;

    }

	if (!dwMaxDepth) {fRet = TRUE; goto end;}

	// Now recurse for each key.

	for(ii=0; ii<cSubKeys; ii++)
	{
		DWORD dwDisp;

    	lRet = RegEnumKey(
					hkFrom,
					ii,
					ptszName,
					cchMaxSubKey+1
					);
		if (lRet!=ERROR_SUCCESS) goto end;

        lRet = RegOpenKeyEx(
					hkFrom,
					ptszName,
					0,
					KEY_READ,
					&hkFromChild);
		if (lRet!=ERROR_SUCCESS) goto end;

		lRet = RegCreateKeyEx(
					hkTo,
					ptszName,
					0,
					NULL,
            		dwToRegOptions,
					KEY_ALL_ACCESS,
					NULL,
					&hkToChild,
					&dwDisp
					);
		if (lRet!=ERROR_SUCCESS) goto end;
		
		fRet = RegCopy(
					hkToChild,
					hkFromChild,
					dwToRegOptions,
					dwMaxDepth-1
				);

		RegCloseKey(hkToChild); hkToChild=NULL;
		RegCloseKey(hkFromChild); hkFromChild=NULL;
    }
    fRet = TRUE;

end:
	if (fAlloc) {FREE_MEMORY(pb);pb=NULL;}
	if (hkFromChild) {RegCloseKey(hkFromChild); hkFromChild=NULL;}
	if (hkToChild)   {RegCloseKey(hkToChild); hkToChild=NULL;}

	return fRet;
}

DWORD
PRIVATE
RegDeleteKeyNT(
    IN  HKEY    hkStart,
    IN  LPCTSTR  pKeyName);

LPCTSTR szREGCACHE = REGSTR_PATH_SETUP TEXT("\\Unimodem\\RegCache");
LPCTSTR szCACHEOK = TEXT("AllOK");

BOOL PutStuffInCache(HKEY hkDrv)
{
    LONG    lErr;
	DWORD	dwExisted;
	BOOL	bRet = FALSE;
	HKEY    hkCache;

	RegDeleteKeyNT(HKEY_LOCAL_MACHINE, szREGCACHE);

	lErr = RegCreateKeyEx(
			    HKEY_LOCAL_MACHINE,
				szREGCACHE,
				0,
				NULL,
			    REG_OPTION_VOLATILE,
				KEY_ALL_ACCESS,
				NULL,
				&hkCache,
				&dwExisted);

	if (lErr != ERROR_SUCCESS)
	{
		TRACE_MSG(TF_ERROR, "RegCreateKeyEx(cache) failed: %#08lx.", lErr);
		hkCache=NULL;
		goto end;
	} 

	if (dwExisted != REG_CREATED_NEW_KEY)
	{
		TRACE_MSG(TF_ERROR, "RegCreateKeyEx(cache): key exists!");
		goto end;
	}

	bRet = RegCopy(hkCache, hkDrv, REG_OPTION_VOLATILE, 100);

	if (bRet)
	{
		// Specifically delete all things which are per-device-instance
        RegDeleteValue(hkCache, c_szFriendlyName);
        RegDeleteValue(hkCache, c_szID);
        RegDeleteValue(hkCache, c_szAttachedTo);
        RegDeleteValue(hkCache, c_szLoggingPath);
        RegDeleteValue(hkCache, REGSTR_VAL_UI_NUMBER);
        RegDeleteValue(hkCache, TEXT("PermanentGuid"));
	}

	if (bRet)
	{
			DWORD dwData;
            lErr = RegSetValueEx(
					hkCache,
					szCACHEOK,
					0,
					REG_DWORD,
					(LPBYTE)&dwData,
                	sizeof(dwData)
					);
			bRet = (lErr==ERROR_SUCCESS);
	}
end:
	if (hkCache) {RegCloseKey(hkCache); hkCache=NULL;}
	if (!bRet) 	 {RegDeleteKeyNT(HKEY_LOCAL_MACHINE, szREGCACHE);}

	return bRet;
}

BOOL GetStuffFromCache(HKEY hkDrv)
{
    LONG    lErr;
	DWORD	dwExisted;
	BOOL	bRet = FALSE;
	HKEY    hkCache;

    lErr=RegOpenKeyEx(
			HKEY_LOCAL_MACHINE,  //  handle of open key
			szREGCACHE,			//  address of name of subkey to open
			0,                  //  reserved
			KEY_READ,  			// desired security access
			&hkCache         	// address of buffer for opened handle
			);
	if (lErr!=ERROR_SUCCESS) {hkCache=0; goto end;}

	bRet = RegCopy(hkDrv, hkCache, REG_OPTION_NON_VOLATILE, 100);

	if (bRet)
	{
			DWORD dwData;
			DWORD cbData=sizeof(dwData);
    		lErr = RegQueryValueEx(
						  hkDrv,
                          szCACHEOK,
                          NULL,
                          NULL,
                          (PBYTE)&dwData,
                          &cbData
                         );
			bRet = (lErr==ERROR_SUCCESS);
			if(bRet)
			{
				RegDeleteValue(hkDrv, szCACHEOK);
			}
	}

end:
	if (hkCache) {RegCloseKey(hkCache); hkCache=NULL;}
	return bRet;
}



BOOL CancelDetectionFromNotifyProgress (PNOTIFYPARAMS pParams, NOTIFICATION notif)
{
 BOOL bNotify = TRUE;
 BOOL bRet = FALSE;  // default is don't cancel

    DBG_ENTER(CancelDetectionFromNotifyProgress);

    if (NULL == pParams->DetectProgressNotify)
    {
        // nobody to notify, just return OK
        TRACE_MSG(TF_GENERAL, "No one to notify");
        goto _ErrRet;
    }

    switch (notif)
    {
        case NOTIFY_START:
        {
         HKEY hkeyEnum;
            TRACE_MSG(TF_GENERAL, "\tNOTIFY_START");
            // Initialize the notification params
            pParams->dwProgress = 0;
            pParams->dwPercentPerPort = 0;
            // Get the number of com ports
            if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, c_szSerialComm, &hkeyEnum))
            {
                if (ERROR_SUCCESS ==
                    RegQueryInfoKey (hkeyEnum,NULL,NULL,NULL,NULL,NULL,NULL,&(pParams->dwPercentPerPort),NULL,NULL,NULL,NULL) &&
                    0 != pParams->dwPercentPerPort)
                {
                    // if we succeeded, then send a notification
                    // with progress set to 0 (we just started);
                    // this is just to give the wizard a chance to cancel
                    // early
                    pParams->dwPercentPerPort = 100 / pParams->dwPercentPerPort;
                }
                RegCloseKey(hkeyEnum);
            }
            if (0 == pParams->dwPercentPerPort)
            {
                // if any error happened, just don't do the
                // notifications anymore and return OK
                pParams->DetectProgressNotify = NULL;
                bNotify = FALSE;
            }
            break;
        }
        case NOTIFY_END:
        {
            TRACE_MSG(TF_GENERAL, "\tNOTIFY_END");
            if (100 > pParams->dwProgress)
            {
                // if we didn't notify the wizard we're finished
                // yet, do so now
                pParams->dwProgress = 100;
            }
            else
            {
                bNotify = FALSE;
            }
            break;
        }
        case NOTIFY_PORT_START:
        {
            TRACE_MSG(TF_GENERAL, "\tNOTIFY_PORT_START");
            if (3 < pParams->dwPercentPerPort)
            {
                if (20 < pParams->dwPercentPerPort)
                {
                    pParams->dwProgress += pParams->dwPercentPerPort / 20;
                }
                else
                {
                    pParams->dwProgress += 1;
                }
            }
            break;
        }
        case NOTIFY_PORT_DETECTED:
        {
            TRACE_MSG(TF_GENERAL, "\tNOTIFY_PORT_DETECTED");
            if (3 < pParams->dwPercentPerPort)
            {
                if (20 < pParams->dwPercentPerPort)
                {
                    pParams->dwProgress += pParams->dwPercentPerPort * 3 / 4;
                }
                else
                {
                    pParams->dwProgress += 1;
                }
            }
            break;
        }
        case NOTIFY_PORT_END:
        {
            TRACE_MSG(TF_GENERAL, "\tNOTIFY_PORT_END");
            pParams->dwProgress += pParams->dwPercentPerPort - 
                (pParams->dwProgress % pParams->dwPercentPerPort);
            break;
        }
        default:
        {
            TRACE_MSG(TF_GENERAL, "\tUnknown notification: %ld", notif);
            bNotify = FALSE;
            break;
        }
    }

    if (bNotify)
    {
        bRet = pParams->DetectProgressNotify (pParams->ProgressNotifyParam, pParams->dwProgress);
    }

_ErrRet:
    DBG_EXIT_BOOL_ERR(CancelDetectionFromNotifyProgress, bRet);
    return bRet;
}

/*----------------------------------------------------------
Purpose: Returns a friendly name that is guaranteed to be
         unique.  Used only for the mass install case, where
         the set of *used* friendly name instance numbers
         has already been generated.

Returns: returns UI number used in FriendlyName, or 0 on error.
Cond:    --

Note:    drvParams.PrivateData is an array of BOOL. Each element is set
         to TRUE when an instance of this modem is created.
		[brwill-050300]
*/
int
PRIVATE
GetFriendlyName(
    IN  HDEVINFO            hdi,
    IN  PSP_DEVINFO_DATA    pdevData,
    IN  PSP_DRVINFO_DATA    pdrvData,
    OUT LPTSTR              pszPropose)
{
    BOOL bRet;
    SP_DRVINSTALL_PARAMS drvParams;
    UINT ii;

    DBG_ENTER(GetFriendlyName);

    drvParams.cbSize = sizeof(drvParams);    
    bRet = CplDiGetDriverInstallParams(hdi, pdevData, pdrvData, &drvParams);
    if (!bRet)
    {
        TRACE_MSG(TF_ERROR, "CplDiGetDriverInstallParams() failed: %#08lx",
                                                            GetLastError());
        ii = 0;
        goto exit;
    }

    for (ii = 1; 
         (ii < MAX_INSTALLATIONS) && ((BYTE*)(drvParams.PrivateData))[ii];
         ii++)
        ;

    switch (ii)
    {
        case MAX_INSTALLATIONS:
            ii = 0;
            goto exit;

        case 1:
            lstrcpy(pszPropose, pdrvData->Description);
            break;

        default:    
            MakeUniqueName(pszPropose, pdrvData->Description, ii);
            break;
    }

    // Mark the instance number we just used as used.
    ((BYTE*)(drvParams.PrivateData))[ii] = TRUE;
            
exit:
    DBG_EXIT_INT(GetFriendlyName, ii);
    return ii;
}


BOOL PrepareForInstallation (
    IN HDEVINFO              hdi,
    IN PSP_DEVINFO_DATA      pdevData,
    IN PSP_DEVINSTALL_PARAMS pdevParams,
    IN PSP_DRVINFO_DATA      pdrvData,
    IN PINSTALL_PARAMS       pParams)
{
 BOOL bRet = FALSE;
 DWORD cbData;
 DWORD dwID;
 DWORD cbSize;
 DWORD dwRegType;
 TCHAR szTemp[LINE_LEN];
 TCHAR szPort[MAX_BUF_REG];
 TCHAR szFriendlyName[MAX_BUF_REG];
 CONFIGRET cr;
 DWORD  dwRet;
 int iUiNumber;
 ULONG uResult;
#ifdef PROFILE
 DWORD dwLocal = GetTickCount ();
#endif //PROFILE
 ULONG Length;

    DBG_ENTER(PrepareForInstallation);

    pParams->dwFlags = pdevParams->ClassInstallReserved;;

    // A. Get the general information.
    // 1. BusType
    if (!CplDiGetBusType (hdi, pdevData, &pParams->dwBus))
    {
        goto _Exit;
    }
#ifdef PROFILE
    TRACE_MSG(TF_GENERAL, "PROFILE: CplDiGetBusType took %lu ms.", GetTickCount()-dwLocal);
    dwLocal = GetTickCount ();
#endif //PROFILE

    // 2. Device registry key
    if (CR_SUCCESS != (cr =
        CM_Open_DevInst_Key (pdevData->DevInst, KEY_ALL_ACCESS, 0,
                             RegDisposition_OpenAlways, &pParams->hKeyDev,
                             CM_REGISTRY_HARDWARE)))
    {
        TRACE_MSG (TF_ERROR, "CM_Open_DevInst_Key (...CM_REGISTRY_HARDWARE) failed: %#lx.", cr);
        SetLastError (cr);
        goto _Exit;
    }
    //    Delete the UPPER_FILTERS value, if we have one
    RegDeleteValue (pParams->hKeyDev, REGSTR_VAL_UPPERFILTERS);

    // 3. Driver registry key
    if (CR_SUCCESS != (cr =
        CM_Open_DevInst_Key (pdevData->DevInst, KEY_ALL_ACCESS, 0,
                             RegDisposition_OpenAlways, &pParams->hKeyDrv,
                             CM_REGISTRY_SOFTWARE)))
    {
        TRACE_MSG (TF_ERROR, "CM_Open_DevInst_Key (...CM_REGISTRY_SOFTWARE) failed: %#lx.", cr);
        SetLastError (cr);
        goto _Exit;
    }

    // 4. Port
    cbData = sizeof(szPort);
    if (ERROR_SUCCESS !=
        RegQueryValueEx (pParams->hKeyDrv, c_szAttachedTo, NULL, NULL,
                         (PBYTE)szPort, &cbData))
    {
        switch (pParams->dwBus)
        {
#ifdef DEBUG
            case BUS_TYPE_ROOT:
                ASSERT (0);
                break;
#endif //DEBUG

            case BUS_TYPE_OTHER:
            case BUS_TYPE_PCMCIA:
            case BUS_TYPE_ISAPNP:
            {
             HCOMDB hComDb;
             DWORD  PortNumber;

                // Fon PnP modems (except serenum / lptenum)
                // we allocate a com name from the database.
                dwRet = ComDBOpen (&hComDb);
                if (HCOMDB_INVALID_HANDLE_VALUE == hComDb)
                {
                    TRACE_MSG(TF_ERROR, "Could not open com database: %#lx.", dwRet);
                    goto _Exit;
                }
                dwRet = ComDBClaimNextFreePort (hComDb, &PortNumber);
                ComDBClose (hComDb);
                if (NO_ERROR != dwRet)
                {
                    TRACE_MSG(TF_ERROR, "Could not claim next free port: %#lx.", dwRet);
                    SetLastError (dwRet);
                    goto _Exit;
                }
                wsprintf (szPort, TEXT("COM%d"), PortNumber);

                // Write PortName anyway, just in case.
                RegSetValueEx (pParams->hKeyDev, REGSTR_VAL_PORTNAME, 0, REG_SZ,
                               (LPBYTE)szPort,
                               (lstrlen(szPort)+1)*sizeof(TCHAR));
                break;
            }

            case BUS_TYPE_SERENUM:
            case BUS_TYPE_LPTENUM:
            {
             DEVINST diParent;
             HKEY hKey;

                // For serenum / lptenum, find the port name
                // in this devnode's parent device key, under
                // the value "PortName" (since the parent is a port).
                if (CR_SUCCESS != (cr =
                    CM_Get_Parent (&diParent, pdevData->DevInst, 0)))
                {
                    TRACE_MSG(TF_ERROR, "CM_Get_Parent failed: %#lx", cr);
                    SetLastError (cr);
                    goto _Exit;
                }

                if (CR_SUCCESS !=
                    CM_Open_DevInst_Key (diParent, KEY_READ, 0, RegDisposition_OpenExisting,
                                         &hKey, CM_REGISTRY_HARDWARE))
                {
                    TRACE_MSG(TF_GENERAL, "CM_Open_DevInst_Key failed: %#lx", cr);
                    SetLastError (cr);
                    goto _Exit;
                }

                cbData = sizeof (szPort);
                dwRet = RegQueryValueEx (hKey, REGSTR_VAL_PORTNAME, NULL, NULL,
                                         (PBYTE)szPort, &cbData);
                RegCloseKey (hKey);
                if (ERROR_SUCCESS != dwRet)
                {
                    TRACE_MSG(TF_GENERAL, "RegQueryValueEx failed: %#lx", dwRet);
                    SetLastError (dwRet);
                    goto _Exit;
                }

                break;
            }
        }

        RegSetValueEx (pParams->hKeyDrv, c_szAttachedTo, 0, REG_SZ,
                       (PBYTE)szPort,
                       CbFromCch(lstrlen(szPort)+1));
    }

    // 5. Friendly name

    // If this is a mass install we have already generated a list of used FriendlyNames,
    // otherwise we need to generate one now
    if (!(pParams->dwFlags & MARKF_MASS_INSTALL))
    {
        // Workaround for an upgrade.
	// [brwill-050300]

        RegDeleteValue(pParams->hKeyDrv, c_szFriendlyName);
        RegDeleteValue(pParams->hKeyDrv, REGSTR_VAL_UI_NUMBER);

        if (!CplDiPreProcessNames(hdi, NULL, pdevData))
        {
            TRACE_MSG(TF_ERROR, "CplDiPreProcessNames failed");
            goto _Exit;
        }
    }


    // Use our pregenerated list of names to fill in szFriendlyName
    iUiNumber = GetFriendlyName(hdi, pdevData, pdrvData, szFriendlyName);

    if(!iUiNumber)
    {
        TRACE_MSG(TF_ERROR, "GetFriendlyName failed");
        goto _Exit;
    }

    // Write the friendly name and UINumber to the driver key.
    RegSetValueEx (pParams->hKeyDrv, c_szFriendlyName, 0, REG_SZ,
                   (LPBYTE)szFriendlyName, CbFromCch(lstrlen(szFriendlyName)+1));
    RegSetValueEx (pParams->hKeyDrv, REGSTR_VAL_UI_NUMBER, 0, REG_DWORD,
                   (LPBYTE)&iUiNumber, sizeof(iUiNumber));

    // Also write the friendly name to the device registry properties so
    // that other applets (like Services and Devices) can display it.
    SetupDiSetDeviceRegistryProperty (hdi, pdevData, SPDRP_FRIENDLYNAME,
                                      (LPBYTE)szFriendlyName, CbFromCch(lstrlen(szFriendlyName)+1));

    // Also write the logging path here, since it is formed with the
    // friendly name of the modem.

    uResult = GetWindowsDirectory(szTemp, sizeof(szTemp) / sizeof(TCHAR));
    
    if (uResult == 0)
    {
        lstrcpy (szTemp, TEXT("\\ModemLog_"));
    } else
    {

        Length = sizeof(szTemp) - (lstrlen(szTemp) * sizeof(TCHAR));

        if ((DWORD)lstrlen(TEXT("\\ModemLog_")) < (Length / sizeof(TCHAR)))
        {
            lstrcat (szTemp, TEXT("\\ModemLog_"));
        } else
        {
            lstrcpy (szTemp, TEXT("\\ModemLog_"));
        }

        Length = sizeof(szTemp) - (lstrlen(szTemp) * sizeof(TCHAR));

        if ((DWORD)(lstrlen(szFriendlyName) + 4) < (Length / sizeof(TCHAR)))
        {
            lstrcat (szTemp,szFriendlyName);
            lstrcat (szTemp,TEXT(".txt"));
        } else
        {
            lstrcpy (szTemp,TEXT("\\ModemLog.txt"));
        }
    }

    RegSetValueEx (pParams->hKeyDrv, c_szLoggingPath, 0, REG_SZ, 
                   (LPBYTE)szTemp, CbFromCch(lstrlen(szTemp)+1));

    cbData = sizeof(pParams->Properties);
    if (ERROR_SUCCESS ==
        RegQueryValueEx (pParams->hKeyDrv, c_szProperties, NULL, NULL,
                         (PBYTE)&pParams->Properties, &cbData))
    {
        // B. Upgrade case; get the relevant data.
        pParams->dwFlags |= MARKF_UPGRADE;

        if (!(pdevParams->FlagsEx & DI_FLAGSEX_IN_SYSTEM_SETUP))
        {
            cbData = sizeof(szTemp);
            if (ERROR_SUCCESS ==
                RegQueryValueEx (pParams->hKeyDrv, REGSTR_VAL_DRVDESC, NULL, NULL,
                                 (LPBYTE)szTemp, &cbData))
            {
                // Is this the same driver?
                if (0 == lstrcmp (szTemp, pdrvData->Description))
                {
                    // It's the same driver.
                    // We'll go through the
                    // whole installation process (maybe the inf has
                    // changed, or the installation was broken), but
                    // we won't increase the reference count.
                    pParams->dwFlags |= MARKF_SAMEDRV;
                }
                else
                {
                    // We're upgrading the driver. At this point, we
                    // should decrement the reference count of the current
                    // installation.
                    if (FindCommonDriverKeyName (pParams->hKeyDrv, sizeof(szTemp) / sizeof(TCHAR), szTemp))
                    {
                        DeleteCommonDriverKeyByName (szTemp);
                    }				

                    RegDeleteValue (pParams->hKeyDrv, c_szRespKeyName);
                }

				dwID=0;
				cbSize=sizeof(dwID);
				dwRegType=0;

                if (ERROR_SUCCESS == RegQueryValueEx(pParams->hKeyDrv, c_szID, NULL, &dwRegType, (LPBYTE)&dwID,	&cbSize))
				{
					UnimodemNotifyTSP (TSPNOTIF_TYPE_CPL,
						   fTSPNOTIF_FLAG_CPL_UPDATE_DRIVER,
						   cbSize, (LPBYTE)&dwID, TRUE);
				}
            }
        }

		// Remove old command registry keys
        {
            static TCHAR *szKeysToDelete[] = {
                    TEXT("Responses"),
                    TEXT("Answer"),
                    TEXT("Monitor"),
                    TEXT("Init"),
                    TEXT("Hangup"),
                    TEXT("Settings"),
                    TEXT("EnableCallerID"),
                    TEXT("EnableDistinctiveRing"),
                    TEXT("VoiceDialNumberSetup"),
                    TEXT("AutoVoiceDialNumberSetup"),
                    TEXT("VoiceAnswer"),
                    TEXT("GenerateDigit"),
                    TEXT("SpeakerPhoneEnable"),
                    TEXT("SpeakerPhoneDisable"),
                    TEXT("SpeakerPhoneMute"),
                    TEXT("SpeakerPhoneUnMute"),
                    TEXT("SpeakerPhoneSetVolumeGain"),
                    TEXT("VoiceHangup"),
                    TEXT("VoiceToDataAnswer"),
                    TEXT("StartPlay"),
                    TEXT("StopPlay"),
                    TEXT("StartRecord"),
                    TEXT("StopRecord"),
                    TEXT("LineSetPlayFormat"),
                    TEXT("LineSetRecordFormat"),
                    TEXT("StartDuplex"),
                    TEXT("StopDuplex"),
                    TEXT("LineSetDuplexFormat"),
                    NULL
            };

            TCHAR **pszKey = szKeysToDelete;

            for  (;*pszKey; pszKey++)
            {
                RegDeleteKey(pParams->hKeyDrv, *pszKey);
            }

        }

        // 1. Defaults
        cbData = sizeof(pParams->Defaults);
        if (ERROR_SUCCESS ==
            RegQueryValueEx (pParams->hKeyDrv, c_szDefault, NULL, NULL,
                             (PBYTE)&pParams->Defaults, &cbData))
        {
            pParams->dwFlags |= MARKF_DEFAULTS;
            RegDeleteValue (pParams->hKeyDrv, c_szDefault);
        }

        // 2. DCB
        cbData = sizeof(pParams->dcb);
        if (ERROR_SUCCESS ==
            RegQueryValueEx (pParams->hKeyDrv, c_szDCB, NULL, NULL,
                             (PBYTE)&pParams->dcb, &cbData))
        {
            pParams->dwFlags |= MARKF_DCB;
            RegDeleteValue (pParams->hKeyDrv, c_szDCB);
        }

        // 3. Extra settings
        cbData = sizeof(pParams->szExtraSettings);
        if (ERROR_SUCCESS ==
            RegQueryValueEx (pParams->hKeyDrv, c_szUserInit, NULL, NULL,
                             (PBYTE)pParams->szExtraSettings, &cbData))
        {
            pParams->dwFlags |= MARKF_SETTINGS;
        }

        // 4. MaximumPortSpeed
        cbData = sizeof(pParams->dwMaximumPortSpeed);
        if (ERROR_SUCCESS ==
            RegQueryValueEx (pParams->hKeyDrv, c_szMaximumPortSpeed, NULL, NULL,
                             (PBYTE)&pParams->dwMaximumPortSpeed, &cbData))
        {
            pParams->dwFlags |= MARKF_MAXPORTSPEED;
        }
    }

    // D. If this is a PnP modem, is there a root-enumerated instance
    //    of it?
    if (BUS_TYPE_ROOT != pParams->dwBus)
    {
     HDEVINFO hDiRoot;

        // 1. Get a list of all ROOT-enumerated modems
        hDiRoot = CplDiGetClassDevs (g_pguidModem, TEXT("ROOT"), NULL, 0);
        if (INVALID_HANDLE_VALUE != hDiRoot)
        {
         SP_DEVINFO_DATA DeviceInfoData = {sizeof(SP_DEVINFO_DATA),0};
         COMPARE_PARAMS cmpParams;
         BOOL bCmpPort = FALSE;
         DWORD dwIndex = 0;

            if (BUS_TYPE_SERENUM == pParams->dwBus ||
                BUS_TYPE_LPTENUM == pParams->dwBus)
            {
                bCmpPort = TRUE;
            }

            if (InitCompareParams (hdi, pdevData, bCmpPort, &cmpParams))
            {
             ULONG ulStatus, ulProblem = 0;
                // 2. Enumerate all modems and compare them with the current one
                while (SetupDiEnumDeviceInfo (hDiRoot, dwIndex++, &DeviceInfoData))
                {
                    if (CR_SUCCESS != CM_Get_DevInst_Status (&ulStatus, &ulProblem, DeviceInfoData.DevInst, 0) ||
                        !(ulStatus & DN_ROOT_ENUMERATED))
                    {
                        // This is a BIOS-enumerated modem.
                        // It's a PnP modem that lives under ROOT!!!
                        continue;
                    }

                    if (Modem_Compare (&cmpParams, hDiRoot, &DeviceInfoData))
                    {
                     HKEY hKey;
                        // 3. The modems compare. Try to get the defaults and DCB from
                        //    the old one.
                        hKey = SetupDiOpenDevRegKey (hDiRoot, &DeviceInfoData, DICS_FLAG_GLOBAL,
                                                     0, DIREG_DRV, KEY_READ);
                        if (INVALID_HANDLE_VALUE != hKey)
                        {
                            cbData = sizeof(pParams->Properties);
                            if (ERROR_SUCCESS ==
                                RegQueryValueEx (hKey, c_szProperties, NULL, NULL,
                                                 (PBYTE)&pParams->Properties, &cbData))
                            {
                                cbData = sizeof(pParams->Defaults);
                                if (ERROR_SUCCESS ==
                                    RegQueryValueEx (hKey, c_szDefault, NULL, NULL,
                                                     (PBYTE)&pParams->Defaults, &cbData))
                                {
                                    pParams->dwFlags |= MARKF_DEFAULTS;
                                }

                                cbData = sizeof(pParams->dcb);
                                if (ERROR_SUCCESS ==
                                    RegQueryValueEx (hKey, c_szDCB, NULL, NULL,
                                                     (PBYTE)&pParams->dcb, &cbData))
                                {
                                    pParams->dwFlags |= MARKF_DCB;
                                }

                                cbData = sizeof(pParams->szExtraSettings);
                                if (ERROR_SUCCESS ==
                                    RegQueryValueEx (hKey, c_szUserInit, NULL, NULL,
                                                     (PBYTE)pParams->szExtraSettings, &cbData))
                                {
                                    pParams->dwFlags |= MARKF_SETTINGS;
                                }

                                cbData = sizeof(pParams->dwMaximumPortSpeed);
                                if (ERROR_SUCCESS ==
                                    RegQueryValueEx (hKey, c_szMaximumPortSpeed, NULL, NULL,
                                                     (PBYTE)&pParams->dwMaximumPortSpeed, &cbData))
                                {
                                    pParams->dwFlags |= MARKF_MAXPORTSPEED;
                                }
                            }
                            ELSE_TRACE ((TF_ERROR, "Could not get the properties of the legacy modem!"));

                            RegCloseKey (hKey);
                        }
                        ELSE_TRACE ((TF_ERROR, "SetupDiOpenDevRegKey failed: %#lx", GetLastError ()));

                        // 5. Now, remove the old one.
                        SetupDiCallClassInstaller (DIF_REMOVE, hDiRoot, &DeviceInfoData);
                        break;
                    }
                }
            }
            ELSE_TRACE ((TF_ERROR, "InitCompareParams failed: %#lx", GetLastError ()));

            CplDiDestroyDeviceInfoList (hDiRoot);
        }
        ELSE_TRACE ((TF_ERROR, "SetupDiGetClassDevs failed: %#lx", GetLastError ()));
    }

    bRet = TRUE;

_Exit:
    DBG_EXIT_BOOL_ERR(PrepareForInstallation, bRet);
    return bRet;
}


void  FinishInstallation (
    IN PINSTALL_PARAMS pParams)
{
    if (INVALID_HANDLE_VALUE != pParams->hKeyDev)
    {
        RegCloseKey (pParams->hKeyDev);
    }

    if (INVALID_HANDLE_VALUE != pParams->hKeyDrv)
    {
        RegCloseKey (pParams->hKeyDrv);
    }
}



DWORD
CMP_WaitNoPendingInstallEvents (
    IN DWORD dwTimeout);

DWORD
WINAPI
EnumeratePnP (LPVOID lpParameter)
{
 CONFIGRET cr;
 DEVINST   diRoot;
 LPSETUPINFO psi = (LPSETUPINFO)lpParameter;
 DWORD dwInstallFlag = 0;
 DWORD dwDisposition;
 HKEY hKey = INVALID_HANDLE_VALUE;
 HKEY hKeyUnimodem = INVALID_HANDLE_VALUE;
 HINSTANCE hInst;
#ifdef DEBUG
 DWORD dwRet;
#endif
 TCHAR szLib[MAX_PATH];

    //-1. First, reload the library to make sure it
    //    doesn't go away before we exit.
    lstrcpy(szLib,TEXT("mdminst.dll"));
    hInst = LoadLibrary (szLib);
    if (NULL == hInst)
    {
        TRACE_MSG(TF_GENERAL, "EnumeratePnP: LoadLibrary (mdminst.dll) failed: %#lx", GetLastError ());
        return 0;
    }

    // 0. Reset the installation flag.
    if (ERROR_SUCCESS == (
#ifdef DEBUG
        dwRet =
#endif
        RegCreateKeyEx (HKEY_LOCAL_MACHINE, REG_PATH_UNIMODEM,
                        0, NULL, 0, KEY_ALL_ACCESS, NULL,
                        &hKeyUnimodem, &dwDisposition)))
    {
        if (ERROR_SUCCESS == (
#ifdef DEBUG
            dwRet =
#endif
            RegCreateKeyEx (hKeyUnimodem, REG_KEY_INSTALLED,
                            0, NULL, REG_OPTION_VOLATILE,
                            KEY_ALL_ACCESS, NULL,
                            &hKey, &dwDisposition)))
        {
            RegSetValueEx (hKey, NULL, 0,
                           REG_DWORD, (PBYTE)&dwInstallFlag, sizeof(dwInstallFlag));
        }
        ELSE_TRACE ((TF_ERROR, "EnumeratePnP: RegCreateKeyEx(%s) failed: %#lx", REG_KEY_INSTALLED, dwRet));
    }
    ELSE_TRACE ((TF_ERROR, "EnumeratePnP: RegCreateKeyEx(%s) failed: %#lx", REG_PATH_UNIMODEM, dwRet));

    // 1. Get the root dev node
    cr = CM_Locate_DevInst_Ex (&diRoot, NULL, CM_LOCATE_DEVINST_NORMAL, NULL);
    if (CR_SUCCESS == cr &&
        !(psi->dwFlags & SIF_DETECT_CANCEL))
    {
        // 2. Reenumerate the root node
        cr = CM_Reenumerate_DevInst_Ex (diRoot, CM_REENUMERATE_SYNCHRONOUS, NULL);
        if (CR_SUCCESS == cr &&
            !(psi->dwFlags & SIF_DETECT_CANCEL))
        {
            // 3. Give user mode PnP some time to figure out
            //    there may be new events
            Sleep (1000);

            // 4. Wait for the new PnP devices to get installed.
            //    If the user cancels detection, we can get out
            //    from here.
            while (!(psi->dwFlags & SIF_DETECT_CANCEL))
            {
                if (WAIT_TIMEOUT !=
                    CMP_WaitNoPendingInstallEvents (500))
                {
                    break;
                }
            }
        }
    }

    if (INVALID_HANDLE_VALUE != hKey)
    {
     DWORD cbData = sizeof(dwInstallFlag);
        if (ERROR_SUCCESS ==
             RegQueryValueEx (hKey, NULL, NULL, NULL, (PBYTE)&dwInstallFlag, &cbData) &&
            0 != dwInstallFlag)
        {
            psi->bFoundPnP = TRUE;
        }

        RegCloseKey (hKey);
        RegDeleteKey (hKeyUnimodem, REG_KEY_INSTALLED);
    }

    if (INVALID_HANDLE_VALUE != hKeyUnimodem)
    {
        RegCloseKey (hKeyUnimodem);
    }

    FreeLibraryAndExitThread  (hInst, 0);
    return 0;
}


/*----------------------------------------------------------
Purpose: This function 

Returns: FALSE on error - couldn't mark for mass install.
         TRUE if successful.

Cond:    --
*/
void
PUBLIC
CplDiMarkInstalled(
    IN  HKEY hKey)
{
 HKEY  hKeyFlag;
 DWORD dwDisp;
 
	if (ERROR_SUCCESS ==
		RegCreateKeyEx (hKey,
						REG_INSTALLATION_FLAG,
						0,
						NULL,
						REG_OPTION_VOLATILE,
						KEY_ALL_ACCESS,
						NULL,
						&hKeyFlag,
						&dwDisp))
	{
		RegCloseKey (hKeyFlag);
		return;
	}
	TRACE_MSG(TF_ERROR, "RegCreateKeyEx (%s) failed: %#08lx", REG_INSTALLATION_FLAG, GetLastError());
}


/*----------------------------------------------------------
Purpose: This function 

Returns: FALSE on error - couldn't mark for mass install.
         TRUE if successful.

Cond:    --
*/
BOOL
PUBLIC
CplDiHasModemBeenInstalled(
    IN  HKEY hKey)
{
 HKEY hKeyFlag;

	if (ERROR_SUCCESS ==
		RegOpenKeyEx (hKey,
					  REG_INSTALLATION_FLAG,
					  0,
					  KEY_ALL_ACCESS,
					  &hKeyFlag))
	{
		RegCloseKey (hKeyFlag);
		return TRUE;
	}
	TRACE_MSG(TF_ERROR, "RegOpenKeyEx (%s) failed: %#08lx", REG_INSTALLATION_FLAG, GetLastError());

    return FALSE;    
}


#ifdef BUILD_DRIVER_LIST_THREAD
DWORD
WINAPI
BuildDriverList (LPVOID lpParameter)
{
 HDEVINFO hdi = (HDEVINFO)lpParameter;
 GUID guid;
#ifdef PROFILE_FIRSTTIMESETUP
 DWORD dwLocal;
#endif //PROFILE_FIRSTTIMESETUP

    if (!SetupDiGetDeviceInfoListClass (hdi, &guid))
    {
        TRACE_MSG(TF_ERROR, "BuildDriverList - SetupDiGetDeviceInfoListClass failed: %#lx.", GetLastError ());
        return 0;
    }

    if (!IsEqualGUID(&guid, g_pguidModem))
    {
        TRACE_MSG(TF_ERROR, "BuildDriverList - Device info list is not of class modem!");
        return 0;
    }

#ifdef PROFILE_FIRSTTIMESETUP
    dwLocal = GetTickCount ();
#endif //PROFILE_FIRSTTIMESETUP
    if (!SetupDiBuildDriverInfoList (hdi, NULL, SPDIT_CLASSDRIVER))
    {
        TRACE_MSG(TF_ERROR, "BuildDriverList - SetupDiGetDeviceInfoListClass failed: %#lx.", GetLastError ());
        return 0;
    }
#ifdef PROFILE_FIRSTTIMESETUP
    TRACE_MSG(TF_GENERAL, "PROFILE: BuildDriverList - SetupDiBuildDriverInfoList took %lu.", GetTickCount()-dwLocal);
#endif //PROFILE_FIRSTTIMESETUP

    return 1;
}
#endif //BUILD_DRIVER_LIST_THREAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\mdminst\proj.h ===
//
// proj.h:  Includes all files that are to be part of the precompiled
//             header.
//

#ifndef __PROJ_H__
#define __PROJ_H__

#define STRICT

//
// Private defines
//

#define INSTANT_DEVICE_ACTIVATION   // Devices can be installed w/o a reboot
//#define PROFILE_MASSINSTALL         // Profile the mass modem install case
//#define PROFILE



#if DBG > 0 && !defined(DEBUG)
#define DEBUG
#endif
#if DBG > 0 && !defined(FULL_DEBUG)
#define FULL_DEBUG
#endif

#define UNICODE

// Defines for rovcomm.h

#define NODA
#define NOSHAREDHEAP
#define NOFILEINFO
#define NOCOLORHELP
#define NODRAWTEXT
#define NOPATH
#define NOSYNC
#ifndef DEBUG
#define NOPROFILE
#endif

#define SZ_MODULEA      "MODEM"
#define SZ_MODULEW      TEXT("MODEM")

#ifdef DEBUG
#define SZ_DEBUGSECTION TEXT("MODEM")
#define SZ_DEBUGINI     TEXT("unimdm.ini")
#endif // DEBUG

// Includes

#include <windows.h>
#include <windowsx.h>

#include <winerror.h>
#include <commctrl.h>       // needed by shlobj.h and our progress bar
#include <prsht.h>          // Property sheet stuff
#include <rovcomm.h>

#include <setupapi.h>       // PnP setup/installer services
#include <cfgmgr32.h>
#include <unimdmp.h>
#include <modemp.h>
#include <regstr.h>

#include <debugmem.h>

#include <tspnotif.h>
#include <slot.h>

#include <winuserp.h>

// local includes
//
#include "dll.h"
#include "detect.h"
#include "modem.h"
#include "resource.h"


#ifdef DEBUG
#define ELSE_TRACE(_a)  \
    else                \
    {                   \
        TRACE_MSG _a;   \
    }
#else //DEBUG not defined
#define ELSE_TRACE(_a)
#endif //DEBUG

//****************************************************************************
//
//****************************************************************************

// Dump flags
#define DF_DCB              0x00000001
#define DF_MODEMSETTINGS    0x00000002
#define DF_DEVCAPS          0x00000004

// Trace flags
#define TF_DETECT           0x00010000
#define TF_REG              0x00020000


#define CBR_HACK_115200 0xff00  // This is how we set 115,200 on Win 3.1 because of a bug.

#define KEYBUFLEN                               256

//-----------------------------------------------
// Structure for holding the port info  (mdmdiag.c, mdmmi.c)
typedef struct _PORTSTRUCT
{
    struct _PORTSTRUCT FAR *lpNextPS;
    TCHAR pszPort[KEYBUFLEN];		// name of port in question
    TCHAR pszAttached[KEYBUFLEN];	// name of device attached to port
    TCHAR pszHardwareID[KEYBUFLEN];	// Hardware ID assigned in Registry
    TCHAR pszInfPath[KEYBUFLEN];		// Nmae of .inf file used

    WORD wIOPortBase;				// I/O base address for port
    BYTE bIRQValue;					// IRQ for given port
    BYTE nDeviceType;				//Describes what type of modem
    DWORD dnDevNode;				// DevNode used to get IRQ and I/O
    BOOL bIsModem;					// Says this is a modem or just a serial port
    BOOL bPCMCIA;					// is this a PCMCIA ?
} PORTSTRUCT, FAR * LPPORTSTRUCT;

// This structure is private data for the main modem dialog
typedef struct tagMODEMDLG
    {
    HDEVINFO    hdi;
    HDEVNOTIFY  NotificationHandle;
    int         cSel;
    DWORD       dwFlags;
    } MODEMDLG, FAR * LPMODEMDLG;


BOOL CALLBACK MoreInfoDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
    );

extern TCHAR const FAR c_szWinHelpFile[];
extern TCHAR const FAR c_szPortPrefix[];


void PUBLIC GetModemImageIndex(
    BYTE nDeviceType,
    int FAR * pindex
    );

DWORD
WINAPI
MyWriteComm(
    HANDLE hPort, 
    LPCVOID lpBuf,
    DWORD cbLen
    );

int
WINAPI
ReadResponse(
    HANDLE hPort,
    LPBYTE lpvBuf, 
    UINT cbRead, 
    BOOL fMulti,
    DWORD dwRcvDelay,
    PDETECTCALLBACK pdc
    );


BOOL
WINAPI
TestBaudRate(
    IN  HANDLE hPort,
    IN  UINT uiBaudRate,
    IN  DWORD dwRcvDelay,
    IN  PDETECTCALLBACK pdc,
    OUT BOOL FAR *lpfCancel
    );


DWORD
WINAPI
FindModem(
    PDETECTCALLBACK pdc,
    HANDLE hPort
    );


BOOL CALLBACK MdmDiagDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam
    );


#endif  //!__PROJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\mdminst\modem.h ===
//
// modem.h
//

#ifndef __MODEM_H__
#define __MODEM_H__

//****************************************************************************
//
//****************************************************************************

// Maximum number of modems that can be installed (simultaneously).  Used in
// avoiding duplicate installations.
#define MAX_INSTALLATIONS       4096


// Global flags for the CPL, and their values:
extern int g_iFlags;

#ifdef BUILD_DRIVER_LIST_THREAD
extern HANDLE g_hDriverSearchThread;
#endif //BUILD_DRIVER_LIST_THREAD

// These should match the values in MODEMUI.DLL
#define IDI_NULL_MODEM                  700
#define IDI_EXTERNAL_MODEM              701
#define IDI_INTERNAL_MODEM              702
#define IDI_PCMCIA_MODEM                703

#define LVIF_ALL                LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE

//-----------------------------------------------------------------------------------
//  Setup info values and structure
//-----------------------------------------------------------------------------------

// This structure contains the private data shared across the modem wizard
// dialogs.
typedef struct tagSETUPINFO
    {
    DWORD                   cbSize;
    DWORD                   dwFlags;        // SIF_* bitfield

    HPORTMAP                hportmap;       // List of ports on system
    TCHAR                   szPortQuery[MAX_BUF_SHORT];   // Single port to detect on
    LPTSTR                  pszPortList;    // List of ports to install on
    DWORD                   dwNrOfPorts;

    HDEVINFO                hdi;            // DeviceInfoSet
    PSP_DEVINFO_DATA        pdevData;       // May be NULL most of the time
    PSP_INSTALLWIZARD_DATA  piwd;           // InstallWizard Data
    SP_SELECTDEVICE_PARAMS  selParams;      // Cached select params
    MODEM_INSTALL_WIZARD    miw;            // Saved optional parameters

    // PnP Enumeration
    HANDLE                  hThreadPnP;
    BOOL                    bFoundPnP;

    } SETUPINFO, FAR * LPSETUPINFO;

// Flags for SETUPINFO
#define SIF_PORTS_GALORE         0x00000001     // There are > 4 ports on the system
#define SIF_DETECTED_GENERIC     0x00000002     // Standard modem detected
#define SIF_JUMPED_TO_SELECTPAGE 0x00000004     // Wizard proceeded to select modem page
#define SIF_DETECTED_MODEM       0x00000008     // A modem was detected
#define SIF_DETECTING            0x00000010     // Wizard is currently detecting
#define SIF_DETECT_CANCEL        0x00000020     // Cancel pending during detection
#define SIF_JUMP_PAST_DONE       0x00000040     // Skip the "you're done!" page
#define SIF_RELEASE_IN_CALLBACK  0x00000080     // Release the private data in the prsht callback


// Status callback for DIF_DETECT (modem specific)
typedef BOOL (CALLBACK FAR* DETECTSTATUSPROC)(DWORD nMsg, LPARAM lParam1, LPARAM lParamUser);

// Messages for DETECTSTATUSPROC
#define DSPM_SETPORT            0L
#define DSPM_SETSTATUS          1L
#define DSPM_QUERYCANCEL        2L

// lParam1 values for DSPM_SETSTATUS
#define DSS_CLEAR                   0L
#define DSS_LOOKING                 1L
#define DSS_QUERYING_RESPONSES      2L
#define DSS_CHECK_FOR_COMPATIBLE    3L
#define DSS_FOUND_MODEM             4L
#define DSS_FOUND_NO_MODEM          5L
#define DSS_FINISHED                6L
#define DSS_ENUMERATING             7L


// This structure is used for DIF_DETECT.  There is no
// defined SETUPAPI structure for DIF_DETECT, so using this
// is okay.
typedef struct tagDETECT_DATA
    {
    SP_DETECTDEVICE_PARAMS  DetectParams;

    DWORD                  dwFlags;
    TCHAR                  szPortQuery[MAX_BUF_SHORT];
    HWND                   hwndOutsideWizard;
    DETECTSTATUSPROC       pfnCallback;
    LPARAM                 lParam;              // User data for pfnCallback
    } DETECT_DATA, FAR * PDETECT_DATA;

// Flags for DETECT_DATA
#define DDF_DEFAULT         0x00000000
#define DDF_QUERY_SINGLE    0x00000001
#define DDF_CONFIRM         0x00000002
#define DDF_USECALLBACK     0x00000004
#define DDF_DONT_REGISTER   0x00000008


#ifdef INSTANT_DEVICE_ACTIVATION

// Global flags which keep track of whether a device had been added/removed/etc.
#define fDF_DEVICE_ADDED        0x1
#define fDF_DEVICE_NEEDS_REBOOT 0x2
#define fDF_DEVICE_REMOVED      0x4
// 07/09/97 - EmanP
// This is a mask used to reset the fDF_DEVICE_ADDED and fDF_DEVICE_REMOVED
// flags, so that we only notify the TSP once
#define mDF_CLEAR_DEVICE_CHANGE ~(fDF_DEVICE_ADDED | fDF_DEVICE_REMOVED)
#define DEVICE_ADDED(_flg) (_flg&fDF_DEVICE_ADDED)
#define DEVICE_REMOVED(_flg) (_flg&fDF_DEVICE_REMOVED)
#define DEVICE_CHANGED(_flg) (_flg&(fDF_DEVICE_REMOVED|fDF_DEVICE_ADDED))

extern DWORD gDeviceFlags;

#endif // INSTANT_DEVICE_ACTIVATION

//-----------------------------------------------------------------------------------
//  cpl.c
//-----------------------------------------------------------------------------------

// Constant strings
extern TCHAR const c_szAttachedTo[];

extern TCHAR const c_szDeviceType[];
extern TCHAR const c_szHardwareID[];
extern TCHAR const c_szFriendlyName[];
extern TCHAR const c_szManufacturer[];

extern TCHAR const c_szHardwareIDSerial[];
extern TCHAR const c_szHardwareIDParallel[];
extern TCHAR const c_szInfSerial[];
extern TCHAR const c_szInfParallel[];

extern TCHAR const c_szRunOnce[];

extern TCHAR const c_szResponses[];
extern TCHAR const c_szRefCount[];
extern TCHAR const c_szNextUINr[];

extern TCHAR const c_szLoggingPath[];

extern TCHAR const c_szModemInstanceID[];

extern LPGUID g_pguidModem;

//-----------------------------------------------------------------------------------
//  ci.c
//-----------------------------------------------------------------------------------

// This value is the amount of ports needed on the system
// before we will consider doing a multi-modem detection
// installation.
#define MIN_MULTIPORT       4


// Used by the class installer and detection engine
typedef struct tagDETECTCALLBACK
    {
    DETECTSTATUSPROC       pfnCallback;
    LPARAM                 lParam;              // User data for pfnCallback
    } DETECTCALLBACK, * PDETECTCALLBACK;

DWORD
PUBLIC
DetectModemOnPort(
    IN  HDEVINFO            hdi,
    IN  PDETECTCALLBACK     pdc,
    IN  HANDLE              hLog,
    IN  LPCTSTR             pszPort,
    IN  HPORTMAP            hportmap,
    OUT PSP_DEVINFO_DATA    pdevDataOut);

void
PUBLIC
DetectSetStatus(
    PDETECTCALLBACK pdc,
    DWORD           nStatus);

DWORD
WINAPI
EnumeratePnP (LPVOID lpParameter);


//-----------------------------------------------------------------------------------
//  ui.c
//-----------------------------------------------------------------------------------

INT_PTR CALLBACK SelPrevPageDlgProc(HWND   hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK IntroDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SelQueryPortDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK PortDetectDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DetectDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SelectModemsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK FoundDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NoModemDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK PortManualDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DialInfoDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK InstallDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DoneDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

ULONG_PTR
CALLBACK
CloneDlgProc(
    IN HWND hDlg,
    IN UINT message,
    IN WPARAM wParam,
    IN LPARAM lParam);

void PUBLIC   Detect_SetStatus(HWND hdlg, UINT idResource);
void PUBLIC   Detect_SetPort(HWND hdlg,LPCTSTR lpc_szName);
BOOL PUBLIC   Detect_QueryCancel(HWND hdlg);
void PUBLIC   Install_SetStatus(HWND hdlg, LPCTSTR lpctszStatus);


//-----------------------------------------------------------------------------------
//  util.c
//-----------------------------------------------------------------------------------

// Private modem properties structure
typedef struct tagMODEM_PRIV_PROP
    {
    DWORD   cbSize;
    DWORD   dwMask;     
    TCHAR   szFriendlyName[MAX_BUF_REG];
    DWORD   nDeviceType;
    TCHAR   szPort[MAX_BUF_REG];
    } MODEM_PRIV_PROP, FAR * PMODEM_PRIV_PROP;

// Mask bitfield for MODEM_PRIV_PROP
#define MPPM_FRIENDLY_NAME  0x00000001
#define MPPM_DEVICE_TYPE    0x00000002
#define MPPM_PORT           0x00000004

BOOL
PUBLIC
CplDiGetPrivateProperties(
    IN  HDEVINFO        hdi,
    IN  PSP_DEVINFO_DATA pdevData,
    OUT PMODEM_PRIV_PROP pmpp);


#ifdef WIN95
LPCTSTR
PUBLIC
StrFindInstanceName(
    IN LPCTSTR pszPath);
#endif

int
RestartDialog(
    IN HWND hwnd,
    IN PTSTR Prompt,
    IN DWORD Return);

int
RestartDialogEx(
    IN HWND hwnd,
    IN PTSTR Prompt,
    IN DWORD Return,
    IN DWORD dwReasonCode);


void
PUBLIC
MakeUniqueName(
    OUT LPTSTR  pszBuf,
    IN  LPCTSTR pszBase,
    IN  UINT    nCount);

void
PUBLIC
DoDialingProperties(
    IN HWND hwndOwner,
    IN BOOL bMiniDlg,
    IN BOOL bSilentInstall);

DWORD
PUBLIC
SetupInfo_Create(
    OUT LPSETUPINFO FAR *       ppsi,
    IN  HDEVINFO                hdi,
    IN  PSP_DEVINFO_DATA        pdevData,   OPTIONAL
    IN  PSP_INSTALLWIZARD_DATA  piwd,       OPTIONAL
    IN  PMODEM_INSTALL_WIZARD   pmiw);      OPTIONAL

DWORD
PUBLIC
SetupInfo_Destroy(
    IN  LPSETUPINFO psi);

BOOL
PUBLIC
UnattendedInstall(
    HWND hwnd,
    LPINSTALLPARAMS lpip);

void
PUBLIC
CloneModem (
    IN  HDEVINFO         hdi,
    IN  PSP_DEVINFO_DATA pdevData,
    IN  HWND             hwndDlg);

BOOL
PUBLIC
CplDiPreProcessNames(
    IN      HDEVINFO            hdi,
    IN      HWND                hwndOwner,   OPTIONAL
    OUT     PSP_DEVINFO_DATA    pdevData);


#ifdef DEBUG

LPCTSTR     PUBLIC Dbg_GetDifName(DI_FUNCTION dif);

// DBG_ENTER_DIF(fn, dif)  -- Generates a function entry debug spew for
//                          a function that accepts an InstallFunction as
//                          one of its parameters.
//
#define DBG_ENTER_DIF(fn, dif)                  \
    TRACE_MSG(TF_FUNC, "> " #fn "(...,%s,...)", Dbg_GetDifName(dif)); \
    g_dwIndent+=2

#define DBG_EXIT_DIF_DWORD(fn,dif,dw)          \
    g_dwIndent-=2;                             \
    TRACE_MSG(TF_FUNC, "< " #fn "(...,%s,...) with %#08lx", Dbg_GetDifName(dif), (ULONG)(dw))
// DBG_EXIT_BOOL_ERR(fn, b)  -- Generates a function exit debug spew for
//                          functions that return a boolean.  It also
//                          prints the GetLastError().
//
#define DBG_EXIT_BOOL_ERR(fn, b)                      \
        g_dwIndent-=2;                                \
        TRACE_MSG(TF_FUNC, "< " #fn "() with %s (%#08lx)", (b) ? (LPTSTR)TEXT("TRUE") : (LPTSTR)TEXT("FALSE"), GetLastError())

// Trace functions when writing registry values
//
#define TRACE_DEV_SZ(szName, szValue)   TRACE_MSG(TF_REG, "Set dev value %s to %s", (LPTSTR)(szName), (LPTSTR)(szValue))

#define TRACE_DRV_SZ(szName, szValue)   TRACE_MSG(TF_REG, "Set drv value %s to %s", (LPTSTR)(szName), (LPTSTR)(szValue))
#define TRACE_DRV_DWORD(szName, dw)     TRACE_MSG(TF_REG, "Set drv value %s to %#08lx", (LPTSTR)(szName), (DWORD)(dw))

#else // DEBUG

#define DBG_ENTER_DIF(fn, dif)
#define DBG_EXIT_DIF_DWORD(fn,dif,dw)
#define DBG_EXIT_BOOL_ERR(fn, b)

#define TRACE_DEV_SZ(szName, szValue)
#define TRACE_DRV_SZ(szName, szValue)
#define TRACE_DRV_DWORD(szName, dw)

#endif // DEBUG

#ifdef WINNT

#define MyYield()
#define CM_Lock(x)
#define CM_Unlock(x)

#endif // WINNT


//-----------------------------------------------------------------------------------
//  Wrappers to insulate us a little bit if we need it.  We need it.
//-----------------------------------------------------------------------------------


// This macro returns the ClassInstallHeader given a ClassInstallParams
// pointer.

#define PCIPOfPtr(p)                    ((PSP_CLASSINSTALL_HEADER)(p))

// This macro initializes the ClassInstallHeader of a ClassInstallParams
// structure.

#define CplInitClassInstallHeader(p, dif)    \
                    ((p)->cbSize = sizeof(SP_CLASSINSTALL_HEADER), \
                     (p)->InstallFunction = (dif))

BOOL
PUBLIC
CplDiIsLocalConnection(
    IN  HDEVINFO        hdi,
    IN  PSP_DEVINFO_DATA pdevData,
    OUT LPBYTE          pnPortSubclass);    OPTIONAL

BOOL
PUBLIC
CplDiInstallModem(
    IN  HDEVINFO            hdi,
    IN  PSP_DEVINFO_DATA    pdevData,       OPTIONAL
    IN  BOOL                bLocalOnly);

BOOL
PUBLIC
CplDiRegisterAndInstallModem(
    IN  HDEVINFO            hdi,
    IN  HWND                hwndOwner,      OPTIONAL
    IN  PSP_DEVINFO_DATA    pdevData,       OPTIONAL
    IN  LPCTSTR             pszPort,
    IN  DWORD               dwFlags);

BOOL
APIENTRY
CplDiInstallModemFromDriver(
    IN     HDEVINFO            hdi,
    // 07/16/97 - EmanP
    // added extra parameter (pDevInfo) for the case
    // when we get called by the hardware wizard
    IN     PSP_DEVINFO_DATA    pDevInfo,       OPTIONAL
    IN     HWND                hwndOwner,      OPTIONAL
    IN OUT DWORD              *pdwNrPorts,
    IN OUT LPTSTR FAR *        ppszPortList,   // Multi-string
    IN     DWORD               dwFlags);       // IMF_ bit field

// 07/24/97 - EmanP
// this function takes a device info set and
// a device info element. If there is no driver
// selected in the device info set, it tries to
// get a driver from the device info element and
// select it into the set
BOOL
APIENTRY
CplDiPreProcessHDI (
    IN     HDEVINFO            hdi,
    IN     PSP_DEVINFO_DATA    pDevInfo       OPTIONAL);


// Flags for CplDiInstallModemFromDriver
#define IMF_DEFAULT        0x00000000
#define IMF_QUIET_INSTALL  0x00000001
#define IMF_CONFIRM        0x00000002
#define IMF_MASS_INSTALL   0x00000004
#define IMF_REGSAVECOPY    0x00000008
#define IMF_REGUSECOPY     0x00000010
#define IMF_DONT_COMPARE   0x00000020


BOOL
PUBLIC
CplDiGetModemDevs(
    OUT HDEVINFO FAR *  phdi,
    IN  HWND            hwnd,
    IN  DWORD           dwFlags,        // DIGCF_ bit field
    OUT BOOL FAR *      pbInstalled);

BOOL
PUBLIC
CplDiCheckModemFlags(
    IN HDEVINFO          hdi,
    IN PSP_DEVINFO_DATA  pdevData,
    IN ULONG_PTR         dwSetFlags,
    IN ULONG_PTR         dwClearFlags);       // MARKF_*

void
PUBLIC
CplDiMarkModem(
    IN HDEVINFO         hdi,
    IN PSP_DEVINFO_DATA pdevData,
    IN ULONG_PTR        dwMarkFlags);       // MARKF_*

void
PUBLIC
CplDiUnmarkModem(
    IN HDEVINFO         hdi,
    IN PSP_DEVINFO_DATA pdevData,
    IN ULONG_PTR        dwMarkFlags);

// Mark flags
#define MARKF_DETECTED          0x00000001
#define MARKF_INSTALL           0x00000002
#define MARKF_MASS_INSTALL      0x00000004
#define MARKF_REGSAVECOPY       0x00000008
#define MARKF_REGUSECOPY        0x00000010
#define MARKF_DONT_REGISTER     0x00000020
#define MARKF_QUIET             0x00000040
#define MARKF_UPGRADE           0x00000080
#define MARKF_SAMEDRV           0x00000100
#define MARKF_DEFAULTS          0x00000200
#define MARKF_DCB               0x00000400
#define MARKF_SETTINGS          0x00000800
#define MARKF_MAXPORTSPEED      0x00001000


BOOL
PUBLIC
CplDiCopyScrubbedHardwareID(
    OUT LPTSTR   pszBuf,
    IN  LPCTSTR  pszIDList,         // Multi string
    IN  DWORD    cbSize);

BOOL
PUBLIC
CplDiGetHardwareID(
    IN  HDEVINFO            hdi,
    IN  PSP_DEVINFO_DATA    pdevData,       OPTIONAL
    IN  PSP_DRVINFO_DATA    pdrvData,       OPTIONAL
    OUT LPTSTR              pszHardwareIDBuf,
    IN  DWORD               cbSize,
    OUT LPDWORD             pcbSizeOut);    OPTIONAL

BOOL
PUBLIC
CplDiBuildModemDriverList(
    IN  HDEVINFO            hdi,
    IN  PSP_DEVINFO_DATA    pdevData);

BOOL
PUBLIC
CplDiCreateCompatibleDeviceInfo(
    IN  HDEVINFO    hdi,
    IN  LPCTSTR     pszHardwareID,
    IN  LPCTSTR     pszDeviceDesc,      OPTIONAL
    OUT PSP_DEVINFO_DATA pdevDataOut);

BOOL
PUBLIC
CplDiRegisterModem(
    IN  HDEVINFO            hdi,
    IN  PSP_DEVINFO_DATA    pdevData,
    IN  BOOL                bFindDups);

BOOL
APIENTRY
CplDiDetectModem(
    IN     HDEVINFO         hdi,
    // 07/07/97 - EmanP
    // added extra parameter (see definition of CplDiDetectModem
    // for explanation
    IN     PSP_DEVINFO_DATA DeviceInfoData,
    IN     LPDWORD          pdwInstallFlags,
    IN     PDETECT_DATA     pdetectdata,    OPTIONAL
    IN     HWND             hwndOwner,      OPTIONAL
    IN OUT LPDWORD          pdwFlags,                   // DMF_ bit field
    IN     HANDLE           hThreadPnP);                // OPTIONAL

// Flags for CplDiDetectModem
#define DMF_DEFAULT             0x00000000
#define DMF_CANCELLED           0x00000001
#define DMF_DETECTED_MODEM      0x00000002
#define DMF_QUIET               0x00000004
#define DMF_GOTO_NEXT_PAGE      0x00000008
#define DMF_ONE_PORT_INSTALL    0x00000010

BOOL ReallyNeedsReboot
(
    IN  PSP_DEVINFO_DATA    pdevData,
    IN  PSP_DEVINSTALL_PARAMS pdevParams
);


#ifdef UNDER_CONSTRUCTION
// Must pass in valid pointers. cch is the size, in TCHAR, of the buffer,
// including space for the final null char.
void FormatFriendlyNameForDisplay
(
    IN TCHAR szFriendly[],
    OUT TCHAR rgchDisplayName[],
    IN  UINT    cch
);
#endif UNDER_CONSTRUCTION


// Must pass in valid pointers. cch is the size, in TCHAR, of the buffer,
// including space for the final null char.
void FormatPortForDisplay
(
    IN TCHAR szPort[],
    OUT TCHAR rgchPortDisplayName[],
    IN  UINT    cch
);

void    UnformatAfterDisplay
(
    IN OUT TCHAR *psz
);

BOOL WINAPI
DetectCallback(
    PVOID    Context,
    DWORD    DetectComplete
    );

PTSTR
MyGetFileTitle (
    IN PTSTR FilePath);

#endif  // __MODEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\mdminst\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1053
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\mdminst\resource.h ===
#include "windows.h"
#include "setupapi.h"

#define IDB_MODEM                       101

#define IDC_ADD                         110
#define IDC_ALL                         1058
#define IDC_CHANGE                      1004
#define IDC_CHECKING_PORT               1001
#define IDC_CLASSICON                   1057
#define IDC_DETECT_STATUS               1000
#define IDC_DIALPROP                    1050
#define IDC_LOC                         1051
#define IDC_MESSAGE                     1054
#define IDC_MODEMLV                     113
#define IDC_NAME                        1005
#define IDC_PORTS                       1006
#define IDC_PROPERTIES                  109
#define IDC_REMOVE                      112
#define IDC_SELECTED                    1059
#define IDC_SKIPDETECT                  1001
#define IDC_ST_CHECKING_PORT            1016
#define IDC_ST_CLOSEAPPS                1012
#define IDC_ST_INSTALLING               1060
#define IDC_ST_INSTRUCT                 1010
#define IDC_ST_NEXT                     1002
#define IDC_ST_PORT                     1003
#define IDC_MODEMS			            1101
#define IDC_WHICHPORTS                  1102
#define IDC_STATIC                      -1

#define IDD_CLONE                       20010
#define IDD_MODEM                       20011
#define IDD_WIZ_DETECT                  20005
#define IDD_WIZ_DONE                    20009
#define IDD_WIZ_SELMODEMSTOINSTALL      20007
#define IDD_WIZ_INSTALL                 20008
#define IDD_WIZ_INTRO                   IDD_DYNAWIZ_FIRSTPAGE
#define IDD_WIZ_NOMODEM                 20006
#define IDD_WIZ_NOP                     IDD_DYNAWIZ_SELECT_PREVPAGE
#define IDD_WIZ_PORTDETECT              20002
#define IDD_WIZ_PORTMANUAL              IDD_DYNAWIZ_SELECT_NEXTPAGE
#define IDD_WIZ_SELQUERYPORT            20001
#define IDD_DIAG_WAIT                   20012

#define IDH_MODEM_ADD                   5001
#define IDH_MODEM_DIALING_PROPERTIES    5004
#define IDH_MODEM_INSTALLED             5000
#define IDH_MODEM_PROPERTIES            5003
#define IDH_MODEM_REMOVE                5002
#define IDH_CFG_GEN_PORT_NAME           2050	
#define IDH_DUPLICATE_NAME_MODEM        2060
#define IDH_DUPLICATE_ALL_PORTS         2061
#define IDH_DUPLICATE_SELECTED_PORTS    2062
#define IDH_DUPLICATE_PORTS_LIST        2063
#define IDH_CHOOSE_WHICH_PORTS          2064

#define IDI_MODEM                       5100
#define IDI_DIAGNOSTIC                  5200

#define IDS_ASK_REBOOTNOW               3076
#define IDS_CAP_MODEM                   3054
#define IDS_CAP_MODEMSETUP              3000
#define IDS_CAP_MODEMWIZARD             3046
#define IDS_CAP_RASCONFIG               3077
#define IDS_CPLINFO                     3019
#define IDS_CPLNAME                     3018
#define IDS_DET_COULDNT_OPEN            3040
#define IDS_DET_DTE                     3049
#define IDS_DET_FOUND                   3041
#define IDS_DET_FOUND_PNP               3050
#define IDS_DET_ID                      3043
#define IDS_DET_INUSE                   3039
#define IDS_DET_LOG_NAME                3038
#define IDS_DET_NOT_FOUND               3042
#define IDS_DET_OK_1                    3044
#define IDS_DET_OK_2                    3045
#define IDS_DETECT                      3004
#define IDS_DETECT_CHECKFORMODEM        3021
#define IDS_DETECT_COMPLETE             3031
#define IDS_DETECT_FOUNDAMODEM          3022
#define IDS_DETECT_MATCHING             3059
#define IDS_DETECT_NOMODEM              3023
#define IDS_DETECT_QUERYING             3024
#define IDS_DEVSETUP_RESTART            2010
#define IDS_DONE                        3008
#define IDS_DUP_TEMPLATE                3033
#define IDS_ENUMERATING                 3034
#define IDS_ERR_CANT_INSTALL_MODEM      3012
#define IDS_ERR_CANT_ADD_MODEM2         3068
#define IDS_ERR_CANT_COPY_FILES         3071
#define IDS_ERR_CANT_DEL_MODEM          3061
#define IDS_ERR_CANT_FIND_MODEM         3013
#define IDS_ERR_CANT_OPEN_INF_FILE      3009
#define IDS_ERR_DET_REGISTER_FAILED     3058
#define IDS_ERR_DETECTION_FAILED        3010
#define IDS_ERR_NOMODEM_NOT_ADMIN       3074
#define IDS_ERR_NOT_ADMIN               3073
#define IDS_ERR_PROPERTIES              3053
#define IDS_ERR_REGISTER_FAILED         3057
#define IDS_ERR_TOO_MANY_PORTS          3011
#define IDS_ERR_UNATTEND_CANT_INSTALL       3100
#define IDS_ERR_UNATTEND_DRIVERLIST         3105
#define IDS_ERR_UNATTEND_GENERAL_FAILURE    3101
#define IDS_ERR_UNATTEND_INF_NODESCRIPTION  3102
#define IDS_ERR_UNATTEND_INF_NOPORT         3103
#define IDS_ERR_UNATTEND_INF_NOSUCHPORT     3104
#define IDS_ERR_UNATTEND_NOPORTS            3106
#define IDS_FRIENDLYNAME_TEMPLATE       3014
#define IDS_HEADER                      3001
#define IDS_INSTALL                     3007
#define IDS_INSTALL_STATUS              3078
#define IDS_INTRO                       3002
#define IDS_LOTSAPORTS                  3067
#define IDS_MODEM                       3062
#define IDS_NEEDSRESTART                2009
#define IDS_NOMODEM                     3005
#define IDS_NOTFUNCTIONAL               2008
#define IDS_NOTPRESENT                  2007
#define IDS_OOM_CLONE                   3063
#define IDS_OOM_OPENCPL                 3069
#define IDS_PARALLEL_TEMPLATE           3036
#define IDS_PNP_MODEM                   3051
#define IDS_PORT                        2006
#define IDS_SELECTTODUP                 3065
#define IDS_SELPORT                     3006
#define IDS_SELQUERYPORT                3003
#define IDS_SERIAL_TEMPLATE             3037
#define IDS_ST_FOUND_INSTRUCT           3028
#define IDS_ST_GENERIC_INSTRUCT         3029
#define IDS_ST_MODELS                   3048
#define IDS_ST_MODEMCHANGED             3032
#define IDS_ST_MODEMFOUND               3026
#define IDS_ST_NOTDETECTED              3027
#define IDS_ST_SELECT_INSTRUCT          3047
#define IDS_UNINSTALLED                 2011
#define IDS_UNKNOWNPORT                 2012
#define IDS_WRN_CONFIRMDELETE           3060
#define IDS_WRN_DUPLICATE_MODEM         3056
#define IDS_WRN_SKIPPED_PORTS           3066
#define IDS_SEL_MFG_MODEL               3107
#define IDS_HDWWIZNAME                  1001

#define MIDM_FIRST                      0x0000
#define MIDM_CLONE                      (MIDM_FIRST + 0x0000)
#define MIDM_REMOVE                     (MIDM_FIRST + 0x0001)
#define MIDM_VIEWLOG                    (MIDM_FIRST + 0x0002)
#define MIDM_PROPERTIES                 (MIDM_FIRST + 0x0003)
#define MIDM_COPYPROPERTIES             (MIDM_FIRST + 0x0004)
#define MIDM_APPLYPROPERTIES            (MIDM_FIRST + 0x0005)

#define POPUP_CONTEXT                   100
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1052
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\mdminst\ui.c ===
/*
 *  UI.C -- Contains all UI code for modem setup.
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1993-1994
 *  All rights reserved
 *
 */

#include "proj.h"

// Instance data structure for the Port_Add callback
typedef struct tagPORTINFO
    {
    HWND    hwndLB;
    DWORD   dwFlags;        // FP_*
    PTCHAR  pszPortExclude;
    } PORTINFO, FAR * LPPORTINFO;

// Flags for PORTINFO
#define FP_PARALLEL     0x00000001
#define FP_SERIAL       0x00000002
#define FP_MODEM        0x00000004

#define Wiz_SetPtr(hDlg, lParam)    SetWindowLongPtr(hDlg, DWLP_USER, ((LPPROPSHEETPAGE)lParam)->lParam)
#define SetDlgFocus(hDlg, idc)      SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, idc), 1L)


#define WM_STARTDETECT      (WM_USER + 0x0700)
#define WM_STARTINSTALL     (WM_USER + 0x0701)
#define WM_PRESSFINISH      (WM_USER + 0x0702)


#ifdef PROFILE_MASSINSTALL            
extern DWORD    g_dwTimeBegin;
DWORD   g_dwTimeAtStartInstall;
#endif


// config mgr private
DWORD
CMP_WaitNoPendingInstallEvents(
    IN DWORD dwTimeout
    );

/*----------------------------------------------------------
Purpose: This function retrieves the wizard page shared
         instance data.  This is a SETUPINFO structure.

Returns: 
Cond:    --
*/
LPSETUPINFO
PRIVATE
Wiz_GetPtr(
    HWND hDlg)
    {
    LPSETUPINFO psi = (LPSETUPINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    return psi;
    }


/*----------------------------------------------------------
Purpose: This function does the right things to leave the 
         wizard when something goes wrong.

Returns: --
Cond:    --
*/
void
PRIVATE
Wiz_Bail(
    IN HWND         hDlg,
    IN LPSETUPINFO  psi)
    {
    ASSERT(psi);

    PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);

    // Don't say the user cancelled.  If this wizard is inside another,
    // we want the calling wizard to continue.
    psi->miw.ExitButton = PSBTN_NEXT;
    }


/*----------------------------------------------------------
Purpose: Sets the custom modem select param strings

Returns: --
Cond:    --
*/
void 
PRIVATE 
Wiz_SetSelectParams(
    LPSETUPINFO psi)
    {
    SP_DEVINSTALL_PARAMS devParams;

    // Get the DeviceInstallParams
    devParams.cbSize = sizeof(devParams);
    if (CplDiGetDeviceInstallParams(psi->hdi, psi->pdevData, &devParams))
        {
        PSP_CLASSINSTALL_HEADER pclassInstallParams = PCIPOfPtr(&psi->selParams);

        // The SelectParams are already set and stored in the 
        // SETUPINFO instance data.
        SetFlag(devParams.Flags, DI_USECI_SELECTSTRINGS | DI_SHOWOEM);

        // Specify using our GUID to make things a little faster.
        SetFlag(devParams.FlagsEx, DI_FLAGSEX_USECLASSFORCOMPAT);

        // Set the Select Device parameters
        CplDiSetDeviceInstallParams(psi->hdi, psi->pdevData, &devParams);
        CplDiSetClassInstallParams(psi->hdi, psi->pdevData, pclassInstallParams, 
                                   sizeof(psi->selParams));
        }
    }


/*----------------------------------------------------------
Purpose: Select previous page junction dialog 
Returns: varies
Cond:    --
*/
INT_PTR
CALLBACK 
SelPrevPageDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam)
    {
    NMHDR FAR *lpnm;
    LPSETUPINFO psi = Wiz_GetPtr(hDlg);

    switch(message) 
        {
    case WM_INITDIALOG:
        Wiz_SetPtr(hDlg, lParam);
        break;

    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
            {
        case PSN_SETACTIVE:
            // This dialog has no UI.  It is simply used as a junction
            // to the intro page or the "no modem found" page.
            SetDlgMsgResult(hDlg, message, 
                IsFlagSet(psi->dwFlags, SIF_JUMPED_TO_SELECTPAGE) ? 
                    IDD_WIZ_INTRO : 
                    IDD_WIZ_NOMODEM);

            return TRUE;

        case PSN_KILLACTIVE:
        case PSN_HELP:
        case PSN_WIZBACK:
        case PSN_WIZNEXT: 
            break;

        default:
            return FALSE;
            }
        break;

    default:
        return FALSE;

        } // end of switch on message

    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Intro dialog 
Returns: varies
Cond:    --
*/
INT_PTR 
CALLBACK 
IntroDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam)
    {
    NMHDR FAR *lpnm;
    LPSETUPINFO psi = Wiz_GetPtr(hDlg);

    switch(message) 
        {
    case WM_INITDIALOG:
        {
            Wiz_SetPtr(hDlg, lParam);
            psi = Wiz_GetPtr(hDlg);

            // Restore the cursor from startup hourglass
            SetCursor(LoadCursor(NULL, IDC_ARROW));     
            break;
        }

    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
            {
        case PSN_SETACTIVE: {
            DWORD dwFlags = PSWIZB_NEXT | PSWIZB_BACK;

            PropSheet_SetWizButtons(GetParent(hDlg), dwFlags);

            // Is this wizard being entered thru the last page?
            if (IsFlagSet(psi->miw.Flags, MIWF_BACKDOOR))
                {
                // Yes; skip to the last page
                PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
                }
            }
            break;

        case PSN_KILLACTIVE:
            break;

        case PSN_HELP:
            break;

        case PSN_WIZBACK:
            SetDlgMsgResult(hDlg, message, IDD_DYNAWIZ_SELECTCLASS_PAGE);
            break;

        case PSN_WIZNEXT: {
            ULONG uNextDlg;

            // Go to the last page?
            if (IsFlagSet(psi->miw.Flags, MIWF_BACKDOOR))
                {
                // Yes
                uNextDlg = IDD_WIZ_DONE;
                }

            // Skip the rest of the detection dialogs?
            else if (IsDlgButtonChecked(hDlg, IDC_SKIPDETECT)) 
                {
                // Yes; go to Select Device page
                SetFlag(psi->dwFlags, SIF_JUMPED_TO_SELECTPAGE);

                Wiz_SetSelectParams(psi);

                uNextDlg = IDD_DYNAWIZ_SELECTDEV_PAGE;
                }
            else
                {
                // No; go to detection page
                ClearFlag(psi->dwFlags, SIF_JUMPED_TO_SELECTPAGE);

                // Are there enough ports on the system to indicate
                // we should treat this like a multi-modem install?
                if (IsFlagSet(psi->dwFlags, SIF_PORTS_GALORE))
                    {
                    // Yes                   
					uNextDlg = IDD_WIZ_SELQUERYPORT;
                    }
                else
                    {
                    // No
                    uNextDlg = IDD_WIZ_DETECT;
                    }
                }

            SetDlgMsgResult(hDlg, message, uNextDlg);
            break;
            }

        default:
            return FALSE;
            }
        break;

    default:
        return FALSE;

        } // end of switch on message

    return TRUE;
    }
#if 1

BOOL WINAPI
DetectCallback(
    PVOID    Context,
    DWORD    DetectComplete
    )

{

    PDETECT_DATA pdd=(PDETECT_DATA)Context;

    return (*pdd->pfnCallback)(
        DetectComplete,
        0,
        pdd->lParam
        );

}
#endif


/*----------------------------------------------------------
Purpose: Status callback used during detection

Returns: varies
Cond:    --
*/
BOOL
CALLBACK
Detect_StatusCallback(
    IN DWORD    nMsg,
    IN LPARAM   lParam,
    IN LPARAM   lParamUser)     OPTIONAL
    {
    HWND hDlg = (HWND)lParamUser;
    LPSETUPINFO psi;
    TCHAR sz[MAX_BUF];

    CONST static UINT s_mpstatus[] =
        {
        0, IDS_DETECT_CHECKFORMODEM, IDS_DETECT_QUERYING, IDS_DETECT_MATCHING, 
        IDS_DETECT_FOUNDAMODEM, IDS_DETECT_NOMODEM, IDS_DETECT_COMPLETE,
        IDS_ENUMERATING
        };

    switch (nMsg)
        {
    case DSPM_SETPORT:
        psi = Wiz_GetPtr(hDlg);

        if (psi && sizeof(*psi) == psi->cbSize)
            {
            LPTSTR pszName = (LPTSTR)lParam;

            // Is there a friendly name?
            if ( !PortMap_GetFriendly(psi->hportmap, pszName, sz, SIZECHARS(sz)) )
                {
                // No; use port name
                lstrcpy(sz, pszName);
                }

            SetDlgItemText(hDlg, IDC_CHECKING_PORT, sz);
            }
        break;

    case DSPM_SETSTATUS:
        if (ARRAYSIZE(s_mpstatus) > lParam)
            {
            TCHAR szbuf[128];
            UINT ids = s_mpstatus[lParam];
            
            if (0 < ids)
                LoadString(g_hinst, ids, szbuf, SIZECHARS(szbuf));
            else
                *szbuf = (TCHAR)0;
            SetDlgItemText(hDlg, IDC_DETECT_STATUS, szbuf);
            }
        break;

    case DSPM_QUERYCANCEL:
        psi = Wiz_GetPtr(hDlg);

        MyYield();

        if (psi && sizeof(*psi) == psi->cbSize)
            {
            return IsFlagSet(psi->dwFlags, SIF_DETECT_CANCEL);
            }
        return FALSE;

    default:
        ASSERT(0);
        break;
        }
    return TRUE;
    }


/*----------------------------------------------------------
Purpose: WM_STARTDETECT handler

Returns: --
Cond:    --
*/
void 
PRIVATE 
Detect_OnStartDetect(
    HWND hDlg,
    LPSETUPINFO psi)
    {
    HDEVINFO hdi;
    DWORD dwFlags;
    DETECT_DATA dd;

    PSP_DETECTDEVICE_PARAMS    DetectParams=&dd.DetectParams;

    // Cause the page to be painted right away before we start detection
    InvalidateRect (GetParent (hDlg), NULL, FALSE);
    UpdateWindow (GetParent (hDlg));

    // Assume no modem was detected
    ClearFlag(psi->dwFlags, SIF_DETECTED_MODEM);

    // Set the detection parameters
    ZeroInit(&dd);

    CplInitClassInstallHeader(&DetectParams->ClassInstallHeader, DIF_DETECT);

    DetectParams->ProgressNotifyParam=&dd;
    DetectParams->DetectProgressNotify=DetectCallback;
//    DetectParams->DetectProgressNotify=NULL;


    dd.dwFlags = DDF_CONFIRM | DDF_USECALLBACK;
    dd.hwndOutsideWizard = GetParent(hDlg);
    dd.pfnCallback = Detect_StatusCallback;
    dd.lParam = (LPARAM)hDlg;

    if (IsFlagSet(psi->dwFlags, SIF_PORTS_GALORE))
        {
        dd.dwFlags |= DDF_QUERY_SINGLE | DDF_DONT_REGISTER;
        lstrcpy(dd.szPortQuery, psi->szPortQuery);
        }

    // Run detection
    SetFlag(psi->dwFlags, SIF_DETECTING);

    dwFlags = DMF_DEFAULT;
    // 07/07/97 - EmanP
    // added extra parameter (see definition of CplDiDetectModem
    // for explanation
    CplDiDetectModem(psi->hdi, psi->pdevData, &psi->dwFlags, &dd, hDlg, &dwFlags, psi->hThreadPnP);

    ClearFlag(psi->dwFlags, SIF_DETECTING);

    if (IsFlagClear(dwFlags, DMF_CANCELLED))
        {
        // Say detection is finished and enable next/back buttons
        ShowWindow(GetDlgItem(hDlg, IDC_ST_CHECKING_PORT), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_CHECKING_PORT), SW_HIDE);

        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
        }

    if (IsFlagSet(dwFlags, DMF_DETECTED_MODEM))
        {
        SetFlag(psi->dwFlags, SIF_DETECTED_MODEM);
        }

    // Did the detection fail?
    if (IsFlagClear(dwFlags, DMF_GOTO_NEXT_PAGE))
        {
        // Yes; don't bother going thru the rest of the wizard
        Wiz_Bail(hDlg, psi);
        }
    else 
        {
        // No; automatically go to next page
        PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
        }
    }


/*----------------------------------------------------------
Purpose: Detect dialog 
Returns: varies
Cond:    --
*/
INT_PTR
CALLBACK
DetectDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam)
    {
    NMHDR FAR *lpnm;
    LPSETUPINFO psi = Wiz_GetPtr(hDlg);

    switch(message) 
        {
    case WM_INITDIALOG:
        Wiz_SetPtr(hDlg, lParam);
        break;

    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
            {
        case PSN_SETACTIVE: 
            PropSheet_SetWizButtons(GetParent(hDlg), 0);

            // Reset the status controls
            ShowWindow(GetDlgItem(hDlg, IDC_ST_CHECKING_PORT), SW_SHOW);
            SetDlgItemText(hDlg, IDC_DETECT_STATUS, TEXT(""));

            ShowWindow(GetDlgItem(hDlg, IDC_CHECKING_PORT), SW_SHOW);

            PostMessage(hDlg, WM_STARTDETECT, 0, 0);
            break;

        case PSN_KILLACTIVE:
        case PSN_HELP:
        case PSN_WIZBACK:
            break;

        case PSN_WIZNEXT: {
            ULONG uNextDlg;

			EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), TRUE);

            // Was a modem detected?
            if (IsFlagSet(psi->dwFlags, SIF_DETECTED_MODEM))
            {
                uNextDlg = IDD_WIZ_SELMODEMSTOINSTALL;
            }
            else if (psi->bFoundPnP)
            {
                uNextDlg = IDD_WIZ_DONE;
            }
            else
            {
                uNextDlg = IDD_WIZ_NOMODEM;
            }
            SetDlgMsgResult(hDlg, message, uNextDlg);
            break;
            }

        case PSN_QUERYCANCEL:
            if (IsFlagSet(psi->dwFlags, SIF_DETECTING))
                {
                SetFlag(psi->dwFlags, SIF_DETECT_CANCEL);
				EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), FALSE);
				//SetCursor(LoadCursor(NULL, IDC_WAIT));
                return PSNRET_INVALID;
                }

            // FALLTHROUGH
        default:
            return FALSE;
            }
        break;

    case WM_STARTDETECT:
		{
			DWORD dwThreadID;

			TRACE_MSG(TF_GENERAL, "Start PnP enumeration thread.");
			psi->hThreadPnP = CreateThread (NULL, 0,
											EnumeratePnP, (LPVOID)psi,
											0, &dwThreadID);
		#ifdef DEBUG
			if (NULL == psi->hThreadPnP)
			{
				TRACE_MSG(TF_ERROR, "CreateThread (...EnumeratePnP...) failed: %#lx.", GetLastError ());
			}
		#endif //DEBUG

			Detect_OnStartDetect(hDlg, psi);
		}
        break;

    default:
        return FALSE;

        } // end of switch on message

    return TRUE;
    }  


/*----------------------------------------------------------
Purpose: No Modem dialog 
Returns: varies
Cond:    --
*/
INT_PTR
CALLBACK
NoModemDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam)
    {
    NMHDR FAR *lpnm;
    LPSETUPINFO psi = Wiz_GetPtr(hDlg);

    switch(message) 
        {
    case WM_INITDIALOG:
        Wiz_SetPtr(hDlg, lParam);
        break;

    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
            {
        case PSN_SETACTIVE: 
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            break;

        case PSN_KILLACTIVE: 
        case PSN_HELP:
            break;

        case PSN_WIZBACK:
            // Go back to the page that precedes the detection
            // page
            if (IsFlagSet(psi->dwFlags, SIF_PORTS_GALORE))
                {
                SetDlgMsgResult(hDlg, message, IDD_WIZ_SELQUERYPORT);
                }
            else
                {
                SetDlgMsgResult(hDlg, message, IDD_WIZ_INTRO);
                }
            break;

        case PSN_WIZNEXT: 
            Wiz_SetSelectParams(psi);
            SetDlgMsgResult(hDlg, message, IDD_DYNAWIZ_SELECTDEV_PAGE);
            break;

        default:
            return FALSE;
            }
        break;

    default:
        return FALSE;

        } // end of switch on message

    return TRUE;
    }  


/*----------------------------------------------------------
Purpose: Starts the browser dialog.  The selected modem is returned
         in psi->lpdiSelected.

Returns: --
Cond:    --
*/
BOOL
PRIVATE
SelectNewDriver(
    IN HWND             hDlg,
    IN HDEVINFO         hdi,
    IN PSP_DEVINFO_DATA pdevData)
    {
    BOOL bRet = FALSE;
    DWORD cbSize = 0;
    PSP_CLASSINSTALL_HEADER pparamsSave;
    SP_DEVINSTALL_PARAMS devParams;
    SP_DEVINSTALL_PARAMS devParamsSave;
    SP_SELECTDEVICE_PARAMS sdp;

    DBG_ENTER(SelectNewDriver);
    
    ASSERT(hdi && INVALID_HANDLE_VALUE != hdi);
    ASSERT(pdevData);

    // Determine size of buffer to save current class install params
    CplDiGetClassInstallParams(hdi, pdevData, NULL, 0, &cbSize);

    // Anything to save?
    if (0 == cbSize)
        {
        // No
        pparamsSave = NULL;
        }
    else
        {
        // Yes
        pparamsSave = (PSP_CLASSINSTALL_HEADER)ALLOCATE_MEMORY( cbSize);
        if (pparamsSave)
            {
            pparamsSave->cbSize = sizeof(*pparamsSave);

            // Save the current class install params
            CplDiGetClassInstallParams(hdi, pdevData, pparamsSave, cbSize, NULL);
            }
        }

    // Set the install params field so the class installer will show
    // custom instructions.
    CplInitClassInstallHeader(&sdp.ClassInstallHeader, DIF_SELECTDEVICE);
    CplDiSetClassInstallParams(hdi, pdevData, PCIPOfPtr(&sdp), sizeof(sdp));

    // Set the flag to show the Other... button
    devParams.cbSize = sizeof(devParams);
    if (CplDiGetDeviceInstallParams(hdi, pdevData, &devParams))
        {
        // Save the current parameters
        BltByte(&devParamsSave, &devParams, sizeof(devParamsSave));

        SetFlag(devParams.Flags, DI_SHOWOEM);
        devParams.hwndParent = hDlg;

        // Set the Select Device parameters
        CplDiSetDeviceInstallParams(hdi, pdevData, &devParams);
        }

    bRet = CplDiCallClassInstaller(DIF_SELECTDEVICE, hdi, pdevData);

    // Restore the parameters
    CplDiSetDeviceInstallParams(hdi, pdevData, &devParamsSave);

    if (pparamsSave)
        {
        // Restore the class install params
        CplDiSetClassInstallParams(hdi, pdevData, pparamsSave, cbSize);    

        FREE_MEMORY((pparamsSave));
        }

    DBG_EXIT(SelectNewDriver);
    
    return bRet;
    }


/*----------------------------------------------------------
Purpose: Get the port filtering flags, based on the selected
         driver.

         The filtering flags indicate whether to include 
         serial or parallel ports in the list.

Returns: FP_* bitfield
Cond:    --
*/
DWORD
PRIVATE
GetPortFilterFlags(
    IN  HDEVINFO            hdi,
    IN  PSP_DEVINFO_DATA    pdevData,
    IN  PSP_DRVINFO_DATA    pdrvData)
    {
    DWORD dwRet = FP_SERIAL | FP_PARALLEL | FP_MODEM;
    PSP_DRVINFO_DETAIL_DATA pdrvDetail;
    SP_DRVINFO_DETAIL_DATA drvDetailDummy;
    DWORD cbSize = 0;

    drvDetailDummy.cbSize = sizeof(drvDetailDummy);
    CplDiGetDriverInfoDetail(hdi, pdevData, pdrvData, &drvDetailDummy,
                             sizeof(drvDetailDummy), &cbSize);

    ASSERT(0 < cbSize);     // This should always be okay

    pdrvDetail = (PSP_DRVINFO_DETAIL_DATA)ALLOCATE_MEMORY( cbSize);
    if (pdrvDetail)
        {
        pdrvDetail->cbSize = sizeof(*pdrvDetail);

        if (CplDiGetDriverInfoDetail(hdi, pdevData, pdrvData, pdrvDetail,
            cbSize, NULL))
            {
            LPTSTR pszSection = pdrvDetail->SectionName;

            // If the section name indicates the type of port,
            // then filter out the other port types since it would
            // be ridiculous to list ports that don't match the
            // port subclass.

            if (IsSzEqual(pszSection, c_szInfSerial))
                {
                dwRet = FP_SERIAL;
                }
            else if (IsSzEqual(pszSection, c_szInfParallel))
                {
                dwRet = FP_PARALLEL;
                }
            }
        FREE_MEMORY((pdrvDetail));
        }

    return dwRet;
    }



BOOL
PRIVATE
IsStringInMultistringI (
    IN PTCHAR pszzMultiString,
    IN PTCHAR pszString)
{
 BOOL bRet = FALSE;

    if (NULL != pszString && NULL != pszzMultiString)
    {
        while (*pszzMultiString)
        {
            if (0 == lstrcmpi (pszzMultiString, pszString))
            {
                bRet = TRUE;
                break;
            }

            pszzMultiString += lstrlen (pszzMultiString) + 1;
        }
    }

    return bRet;
}



/*----------------------------------------------------------
Purpose: Device enumerator callback.  Adds another port to the
         listbox.

Returns: TRUE to continue enumeration
Cond:    --
*/
BOOL 
CALLBACK
Port_Add(
    HPORTDATA hportdata,
    LPARAM lParam)
{
 BOOL bRet;
 PORTDATA pd;

    pd.cbSize = sizeof(pd);
    bRet = PortData_GetProperties(hportdata, &pd);
    if (bRet)
    {
     HWND hwndLB = ((LPPORTINFO)lParam)->hwndLB;
     DWORD dwFlags = ((LPPORTINFO)lParam)->dwFlags;
     LPTSTR pszPortExclude = ((LPPORTINFO)lParam)->pszPortExclude;
     HANDLE hPort;
     TCHAR szPort[LINE_LEN] = TEXT("\\\\.\\");
     BOOL bAddPort = FALSE;

#pragma data_seg(DATASEG_READONLY)
        const static DWORD c_mpsubclass[3] = { FP_PARALLEL, FP_SERIAL, FP_MODEM };
#pragma data_seg()

        ASSERT(0 == PORT_SUBCLASS_PARALLEL);
        ASSERT(1 == PORT_SUBCLASS_SERIAL);

        lstrcpy (szPort+4, pd.szPort);

        hPort = CreateFile (szPort, GENERIC_WRITE | GENERIC_READ,
                            0, NULL, OPEN_EXISTING, 0, NULL);
        if (INVALID_HANDLE_VALUE != hPort)
        {
            if (!IsModemControlledDevice (hPort))
            {
                bAddPort = TRUE;
            }
            CloseHandle (hPort);
        }
        else if (ERROR_BUSY == GetLastError ())
        {
            TRACE_MSG(TF_GENERAL, "Open port %s failed with ERROR_BUSY. Adding the port anyway.", szPort);
            bAddPort = TRUE;
        }
#ifdef DEBUG
        else
        {
            TRACE_MSG(TF_ERROR,"Could not open %s: %#lx", pd.szPort, GetLastError());
        }
#endif DEBUG

        if (bAddPort)
        {
            // Does this port qualify to be listed AND
            // is the portname *not* the port that a mouse 
            // is connected to?
            if ((1 <= (pd.nSubclass+1)) && ((pd.nSubclass+1) <= 3) &&     // safety harness
                (c_mpsubclass[pd.nSubclass] & dwFlags) &&
                //(NULL == pszPortExclude || !IsSzEqual(pd.szPort, pszPortExclude))
                !IsStringInMultistringI (pszPortExclude, pd.szPort))
            {
                // Yes; add the friendly name to the list
                TCHAR rgchPortDisplayName[MAX_BUF];
                ASSERT(sizeof(rgchPortDisplayName)==sizeof(pd.szFriendly));

                // Add prefix spaces to get the list box sort order
                // to work right (display COM2 before COM12, etc).
                FormatPortForDisplay
                (
                    pd.szFriendly,
                    rgchPortDisplayName,
                    sizeof(rgchPortDisplayName)/sizeof(TCHAR)
                );

                ListBox_AddString(hwndLB, rgchPortDisplayName);
            }
        }
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Handles WM_COMMAND for the specific controls used
         with the port listbox (like the radio buttons).

Returns: --
Cond:    --
*/
void 
PRIVATE
Port_OnCommand(
    IN HWND     hDlg,
    IN WPARAM   wParam,
    IN LPARAM   lParam,
    IN BOOL     bWizard)
    {
    switch (GET_WM_COMMAND_ID(wParam, lParam)) 
        {
    case IDC_PORTS: 
        // Did a listbox selection change?
        if (LBN_SELCHANGE == GET_WM_COMMAND_CMD(wParam, lParam))
            {
            // Yes
            BOOL bEnable;
            HWND hwndCtl = GET_WM_COMMAND_HWND(wParam, lParam);
            int cSel = ListBox_GetSelCount(hwndCtl);
            int id;

            // Enable OK or Next button if there is at least one selection
            bEnable = (0 < cSel);
            if (bWizard)
                {
                if (bEnable)
                    {
                    PropSheet_SetWizButtons(GetParent(hDlg), 
                                            PSWIZB_BACK | PSWIZB_NEXT);
                    }
                else
                    {
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                    }
                }
            else
                {
                Button_Enable(GetDlgItem(hDlg, IDOK), bEnable);
                }

            // Choose the "Select All" button if all the entries
            // are selected
            if (cSel>1 && ListBox_GetCount(hwndCtl) == cSel)
                {
                id = IDC_ALL;
                }
            else
                {
                id = IDC_SELECTED;
                }
            CheckRadioButton(hDlg, IDC_ALL, IDC_SELECTED, id);
            }
        break;

    case IDC_ALL:
        if (BN_CLICKED == GET_WM_COMMAND_CMD(wParam, lParam))
            {
            // Select everything in the listbox
            HWND hwndCtl = GetDlgItem(hDlg, IDC_PORTS);
            int cItems = ListBox_GetCount(hwndCtl);

            ListBox_SelItemRange(hwndCtl, TRUE, 0, cItems);

            if (bWizard)
                {
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                }
            else
                {
                Button_Enable(GetDlgItem(hDlg, IDOK), TRUE);
                }
            }
        break;

    case IDC_SELECTED:
        if (BN_CLICKED == GET_WM_COMMAND_CMD(wParam, lParam))
            {
            HWND hwndCtl = GetDlgItem(hDlg, IDC_PORTS);
            int cItems = ListBox_GetCount(hwndCtl);

            // Deselect everything only if everything is currently
            // selected
            if (ListBox_GetSelCount(hwndCtl) == cItems)
                {
                ListBox_SelItemRange(hwndCtl, FALSE, 0, cItems);

                if (bWizard)
                    {
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                    }
                else
                    {
                    Button_Enable(GetDlgItem(hDlg, IDOK), FALSE);
                    }
                }
            }
        break;
        }
    }


/*----------------------------------------------------------
Purpose: Handle when the Next button is clicked (or the OK button).

Returns: --
Cond:    --
*/
void 
PRIVATE
Port_OnWizNext(
    IN HWND         hDlg,
    IN LPSETUPINFO  psi)
{
    HWND hwndLB = GetDlgItem(hDlg, IDC_PORTS);
    int cSel = ListBox_GetSelCount(hwndLB);

    // Remember the selected port for the next page
    if (0 >= cSel)
    {
        // This should never happen
        ASSERT(0);
    }
    else
    {
        TCHAR sz[MAX_BUF];
        LPINT piSel;

        piSel = (LPINT)ALLOCATE_MEMORY( cSel * sizeof(*piSel));
        if (piSel)
        {
            int i;

            ListBox_GetSelItems(hwndLB, cSel, piSel);

            // Free whatever list we have; we're starting over
            CatMultiString(&psi->pszPortList, NULL);
            psi->dwNrOfPorts = 0;

            for (i = 0; i < cSel; i++)
            {
                // Get the selected port (which is a friendly name)
                ListBox_GetText(hwndLB, piSel[i], sz);

                // Strip off prefix spaces added to get the list box sort order
                // to work right (display COM2 before COM12, etc).
                UnformatAfterDisplay(sz);

                // Convert the friendly name to a port name
                PortMap_GetPortName(psi->hportmap, sz, sz, 
                                    SIZECHARS(sz));

                // Don't worry if this fails, we'll just install
                // whatever could be added
                if (CatMultiString(&psi->pszPortList, sz))
                {
                    psi->dwNrOfPorts++;
                }
            }

            FREE_MEMORY(piSel);
        }
    }
}


/*----------------------------------------------------------
Purpose: Port dialog.  Allows the user to select a port.
Returns: varies
Cond:    --
*/
INT_PTR
CALLBACK
PortManualDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam)
    {
    NMHDR FAR *lpnm;
    LPSETUPINFO psi = Wiz_GetPtr(hDlg);

    switch(message) 
        {
    case WM_INITDIALOG:
        Wiz_SetPtr(hDlg, lParam);
        break;

    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
            {
        case PSN_SETACTIVE:
            {
            SP_DRVINFO_DATA drvData;
            PORTINFO portinfo;

            // This page will get activated invisibly if the user 
            // cancels from the dial info page.  In this condition,
            // the selected device and selected driver may be NULL.
            //
            // [ LONG: by design the propsheet mgr switches to the
            //   previous page in the array when it needs to remove
            //   a page that is currently active.  We hit this code
            //   path when the user clicks Cancel in the dial info
            //   page because ClassInstall_OnDestroyWizard explicitly 
            //   removes that page while it is currently active. ]
            //

            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);

            // The user selected a modem from the Select Device page.

            // Get the selected driver
            drvData.cbSize = sizeof(drvData);
            if (CplDiGetSelectedDriver(psi->hdi, psi->pdevData, &drvData))
                {
                // Start off by selecting only the selected ports
                CheckRadioButton(hDlg, IDC_ALL, IDC_SELECTED, IDC_SELECTED);

                // Modem name
                SetDlgItemText(hDlg, IDC_NAME, drvData.Description);

                // Fill the port listbox; special-case the parallel and
                // serial cable connections so we don't look bad
                portinfo.dwFlags = GetPortFilterFlags(psi->hdi, psi->pdevData, &drvData);
                portinfo.hwndLB = GetDlgItem(hDlg, IDC_PORTS);
#ifdef SKIP_MOUSE_PORT
                //lstrcpy(portinfo.szPortExclude, g_szMouseComPort);
                portinfo.pszPortExclude = g_szMouseComPort;
#else
                portinfo.pszPortExclude = NULL;
#endif
                ListBox_ResetContent(portinfo.hwndLB);
                EnumeratePorts(Port_Add, (LPARAM)&portinfo);

				// disable the select all button if no ports are available
				if (!ListBox_GetCount(portinfo.hwndLB))
					{	
					Button_Enable(GetDlgItem(hDlg, IDC_ALL), FALSE);
					}
				}
            else
            {
                TRACE_MSG(TF_ERROR, "SetupDiGetSelectedDriver failed: %#lx.", GetLastError ());
            }
            break;
            }
        case PSN_KILLACTIVE: 
        case PSN_HELP:
            break;

        case PSN_WIZBACK:

            Wiz_SetSelectParams(psi);

            SetDlgMsgResult(hDlg, message, IDD_DYNAWIZ_SELECTDEV_PAGE);
            break;

        case PSN_WIZNEXT: 
#ifdef PROFILE_MASSINSTALL            
            g_dwTimeBegin = GetTickCount();
#endif            
            Port_OnWizNext(hDlg, psi);
            SetDlgMsgResult(hDlg, message, IDD_WIZ_INSTALL);
            break;

        default:
            return FALSE;
            }
        break;

    case WM_COMMAND:
        Port_OnCommand(hDlg, wParam, lParam, TRUE);
        break;

    default:
        return FALSE;

        } // end of switch on message

    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Port detection dialog.  Allows the user to select a 
         single port to interrogate.

Returns: varies
Cond:    --
*/
INT_PTR
CALLBACK 
SelQueryPortDlgProc(
    IN HWND     hDlg, 
    IN UINT     message, 
    IN WPARAM   wParam, 
    IN LPARAM   lParam)
    {
    NMHDR FAR *lpnm;
    LPSETUPINFO psi = Wiz_GetPtr(hDlg);

    switch(message) 
        {
    case WM_INITDIALOG: {
        PORTINFO portinfo;

        Wiz_SetPtr(hDlg, lParam);

        psi = (LPSETUPINFO)((LPPROPSHEETPAGE)lParam)->lParam;

        // Fill the port listbox
        portinfo.dwFlags = FP_SERIAL;
        portinfo.hwndLB = GetDlgItem(hDlg, IDC_PORTS);
#ifdef SKIP_MOUSE_PORT
        //lstrcpy(portinfo.szPortExclude, g_szMouseComPort);
        portinfo.pszPortExclude = g_szMouseComPort;
#else
        portinfo.pszPortExclude = NULL;
#endif

        ListBox_ResetContent(portinfo.hwndLB);
        EnumeratePorts(Port_Add, (LPARAM)&portinfo);
        }
        break;

    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
            {
        case PSN_SETACTIVE: {
            DWORD dwFlags;
            LPTSTR psz;

            dwFlags = PSWIZB_BACK;
            if (LB_ERR != ListBox_GetCurSel(GetDlgItem(hDlg, IDC_PORTS)))
                {
                dwFlags |= PSWIZB_NEXT;
                }
            PropSheet_SetWizButtons(GetParent(hDlg), dwFlags);

            // Explanation of why we're at this page
            if (ConstructMessage(&psz, g_hinst, MAKEINTRESOURCE(IDS_LOTSAPORTS),
                                 PortMap_GetCount(psi->hportmap)))
                {
                SetDlgItemText(hDlg, IDC_NAME, psz);
                LocalFree(psz);
                }
            break;
            }
        case PSN_KILLACTIVE: 
        case PSN_HELP:
            break;

        case PSN_WIZBACK:
            break;

        case PSN_WIZNEXT: {
            HWND hwndCtl = GetDlgItem(hDlg, IDC_PORTS);
            int iSel = ListBox_GetCurSel(hwndCtl);

            ASSERT(LB_ERR != iSel);

            ListBox_GetText(hwndCtl, iSel, psi->szPortQuery);

            // Strip off prefix spaces added to get the list box sort order
            // to work right (display COM2 before COM12, etc).
            UnformatAfterDisplay(psi->szPortQuery);

            PortMap_GetPortName(psi->hportmap, psi->szPortQuery, 
                                psi->szPortQuery, 
                                SIZECHARS(psi->szPortQuery));
            }
            break;

        default:
            return FALSE;
            }
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            {
        case IDC_PORTS: 
            // Did a listbox selection change?
            if (LBN_SELCHANGE == GET_WM_COMMAND_CMD(wParam, lParam))
                {
                // Yes
                DWORD dwFlags = PSWIZB_BACK;
                HWND hwndCtl = GET_WM_COMMAND_HWND(wParam, lParam);

                if (LB_ERR != ListBox_GetCurSel(hwndCtl))
                    {
                    dwFlags |= PSWIZB_NEXT;
                    }
                PropSheet_SetWizButtons(GetParent(hDlg), dwFlags);
                }
            break;
            }
        break;

    default:
        return FALSE;

        } // end of switch on message

    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Port installation dialog.  Allows the user to select 
         the ports to install the detected modem on.

Returns: varies
Cond:    --
*/
INT_PTR
CALLBACK 
PortDetectDlgProc(
    IN HWND     hDlg, 
    IN UINT     message, 
    IN WPARAM   wParam, 
    IN LPARAM   lParam)
    {
    NMHDR FAR *lpnm;
    LPSETUPINFO psi = Wiz_GetPtr(hDlg);

    switch(message) 
        {
    case WM_INITDIALOG: {
        PORTINFO portinfo;

        Wiz_SetPtr(hDlg, lParam);

        psi = (LPSETUPINFO)((LPPROPSHEETPAGE)lParam)->lParam;

        // Start off by selecting only the selected ports
        CheckRadioButton(hDlg, IDC_ALL, IDC_SELECTED, IDC_SELECTED);

        // Fill the port listbox
        portinfo.dwFlags = FP_SERIAL;
        portinfo.hwndLB = GetDlgItem(hDlg, IDC_PORTS);
#ifdef SKIP_MOUSE_PORT
        //lstrcpy(portinfo.szPortExclude, g_szMouseComPort);
        portinfo.pszPortExclude = g_szMouseComPort;
#else
        portinfo.pszPortExclude = NULL;
#endif

        ListBox_ResetContent(portinfo.hwndLB);
        EnumeratePorts(Port_Add, (LPARAM)&portinfo);
        
        if (psi->szPortQuery)
        {
         TCHAR szDisplayName[8];
         DWORD dwIndex;
            FormatPortForDisplay (psi->szPortQuery, szDisplayName, 8);
            dwIndex = ListBox_FindString (GetDlgItem(hDlg, IDC_PORTS), -1, szDisplayName);
            if (LB_ERR != dwIndex)
            {
                ListBox_SetSel (GetDlgItem(hDlg, IDC_PORTS), TRUE, dwIndex);
            }
        }
        }
        break;

    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
            {
        case PSN_SETACTIVE: {
            DWORD dwFlags = PSWIZB_BACK;

            if (0 < ListBox_GetSelCount(GetDlgItem(hDlg, IDC_PORTS)))
                {
                dwFlags |= PSWIZB_NEXT;
                }
            PropSheet_SetWizButtons(GetParent(hDlg), dwFlags);
            }
            break;

        case PSN_KILLACTIVE: 
        case PSN_HELP:
            break;

        case PSN_WIZBACK:
            SetDlgMsgResult(hDlg, message, IDD_WIZ_SELQUERYPORT);
            break;

        case PSN_WIZNEXT: 
            Port_OnWizNext(hDlg, psi);
            break;

        default:
            return FALSE;
            }
        break;

    case WM_COMMAND:
        Port_OnCommand(hDlg, wParam, lParam, TRUE);
        break;

    default:
        return FALSE;

        } // end of switch on message

    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Start installing the modems.

Returns: --
Cond:    --
*/
void
PRIVATE
Install_OnStartInstall(
    IN  HWND        hDlg,
    IN  LPSETUPINFO psi)
{
 BOOL bRet = TRUE;

    DBG_ENTER(Install_OnStartInstall);
#ifdef PROFILE_MASSINSTALL            
    g_dwTimeAtStartInstall = GetTickCount();
#endif
    
    ASSERT(hDlg);
    ASSERT(psi);

    // Cause the page to be painted right away before we start installation
    InvalidateRect (GetParent (hDlg), NULL, FALSE);
    UpdateWindow (GetParent (hDlg));

    // Was the modem detected and is this the non-multi-port
    // case?
    if (IsFlagSet(psi->dwFlags, SIF_DETECTED_MODEM) &&
        IsFlagClear(psi->dwFlags, SIF_PORTS_GALORE))
    {
        // Yes; install the modem(s) that may have been detected
        bRet = CplDiInstallModem(psi->hdi, NULL, FALSE);
    }
    else
    {
        // No; we are either in the manual-select case or the
        // multi-modem detection case.  These are the same.
        if ( !psi->pszPortList )
        {
            ASSERT(0);      // out of memory
            bRet = FALSE;
        }
        else
        {
         DWORD dwFlags = IMF_DEFAULT;
         SP_DEVINFO_DATA devData, *pdevData = NULL;
         DWORD iDevice = 0;

            if (IsFlagClear(psi->dwFlags, SIF_DETECTED_MODEM))
            {
                pdevData = psi->pdevData;
                SetFlag(dwFlags, IMF_CONFIRM);
            }
            else
            {
                devData.cbSize = sizeof(devData);
                while (SetupDiEnumDeviceInfo(psi->hdi, iDevice++, &devData))
                {
                    if (CplDiCheckModemFlags(psi->hdi, &devData, MARKF_DETECTED, 0))
                    {
                        pdevData = &devData;
                        break;
                    }
                }
                if (NULL == pdevData)
                {
                    ASSERT(0);
                    bRet = FALSE;
                }
            }

            if (bRet)
            {
                // 07/16/97 - EmanP
                // pass in the DevInfoData to CplDiInstallModemFromDriver;
                // it is used when we're called from the hardware wizard, and
                // will be NULL at other times
                bRet = CplDiInstallModemFromDriver(psi->hdi, pdevData, hDlg, 
                                                   &psi->dwNrOfPorts,
                                                   &psi->pszPortList, dwFlags);

                // Free the list
                CatMultiString(&psi->pszPortList, NULL);
            }
        }
    }

    // Did the user cancel during install?
    if (FALSE == bRet)
    {
        // Yes; don't bother going thru the rest of the 
        // wizard
        Wiz_Bail(hDlg, psi);
    }
    else
    {
        // No; automatically go to next page
        PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
    }

    DBG_EXIT(Install_OnStartInstall);
#ifdef PROFILE_MASSINSTALL            
    TRACE_MSG(TF_GENERAL, "****** modem installation took %lu ms total. ******",
              GetTickCount() - g_dwTimeAtStartInstall);
#endif
}


/*----------------------------------------------------------
Purpose: Install a manually selected or detected modem.  

         Installation can take some time, so we display this
         page to tell the user to take a coffee break.

Returns: varies
Cond:    --
*/
INT_PTR
CALLBACK
InstallDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam)
    {
    NMHDR FAR *lpnm;
    LPSETUPINFO psi = Wiz_GetPtr(hDlg);

    switch(message) 
        {
    case WM_INITDIALOG:
        Wiz_SetPtr(hDlg, lParam);
        break;

    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
            {
        case PSN_SETACTIVE: 
            // Disable the buttons since we cannot do anything while
            // this page does the installation.
            PropSheet_SetWizButtons(GetParent(hDlg), 0);
            EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), FALSE);

            PostMessage(hDlg, WM_STARTINSTALL, 0, 0);
            SetDlgMsgResult(hDlg, DWLP_MSGRESULT , 0);
            break;

        case PSN_KILLACTIVE:
        case PSN_HELP:
        case PSN_WIZBACK:
            break;

        case PSN_WIZNEXT:
        {
         ULONG uNextDlg;

            // Set the buttons to at least go forward and cancel
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
            EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), TRUE);

            uNextDlg = IDD_WIZ_DONE;

            SetDlgMsgResult(hDlg, message, uNextDlg);
            break;
        }

        default:
            return FALSE;
            }
        break;

    case WM_STARTINSTALL: 
        Install_OnStartInstall(hDlg, psi);
        break;

    default:
        return FALSE;

        } // end of switch on message

    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Done dialog 
Returns: varies
Cond:    --
*/
INT_PTR
CALLBACK
DoneDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam)
    {
    NMHDR FAR *lpnm;
    LPSETUPINFO psi = Wiz_GetPtr(hDlg);

    switch(message) 
        {
    case WM_INITDIALOG:
        Wiz_SetPtr(hDlg, lParam);
        break;

    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
            {
        case PSN_SETACTIVE:
            // Last page, show the Finish button
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_FINISH);

            // and disable the Cancel button, since it's too late to cancel
            EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), FALSE);

            // Skip showing this page?
            if (IsFlagSet(psi->dwFlags, SIF_JUMP_PAST_DONE))
                {
                // Yes
                psi->miw.ExitButton = PSBTN_NEXT;
                PostMessage(hDlg, WM_PRESSFINISH, 0, 0);
                }
            else
                {
                psi->miw.ExitButton = PSBTN_FINISH;
                }
            break;

        case PSN_KILLACTIVE:
        case PSN_HELP:
            break;

        case PSN_WIZBACK:
            EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), TRUE);
            SetDlgMsgResult(hDlg, message, IDD_DYNAWIZ_SELECTDEV_PAGE);
            if (!SetupDiSetSelectedDriver (psi->hdi, NULL, NULL))
            {
                TRACE_MSG(TF_ERROR, "SetupDiSetSelectedDriver failed: %#lx", GetLastError ());
            }
            if (!SetupDiDestroyDriverInfoList (psi->hdi, NULL, SPDIT_CLASSDRIVER))
            {
                TRACE_MSG(TF_ERROR, "SetupDiDestroyDriverInfoList failed: %#lx", GetLastError ());
            }
            break;

        case PSN_WIZNEXT: 
            PostMessage(hDlg, WM_PRESSFINISH, 0, 0);
            break;

        case PSN_WIZFINISH:
            if (gDeviceFlags & fDF_DEVICE_NEEDS_REBOOT)
            {
             TCHAR szMsg[128];
                LoadString (g_hinst, IDS_DEVSETUP_RESTART, szMsg, sizeof(szMsg)/sizeof(TCHAR));
                RestartDialogEx (GetParent(hDlg), szMsg, EWX_REBOOT, SHTDN_REASON_MAJOR_HARDWARE | SHTDN_REASON_MINOR_INSTALLATION | SHTDN_REASON_FLAG_PLANNED);
            }

            break;

        default:
            return FALSE;
            }
        break;

    case WM_PRESSFINISH:
        PropSheet_PressButton(GetParent(hDlg), PSBTN_FINISH);
        break;

    default:
        return FALSE;

        } // end of switch on message

    return TRUE;
    }  


void
PRIVATE
GenerateExcludeList (
    IN  HDEVINFO         hdi,
    IN  PSP_DEVINFO_DATA pdevData,
    OUT PTSTR           *ppExcludeList)
{
 SP_DEVINFO_DATA devData;
 COMPARE_PARAMS cmpParams;
 int iIndex = 0;

    DBG_ENTER(GenerateExcludeList);

    CatMultiString (ppExcludeList, NULL);

    if (InitCompareParams (hdi, pdevData, FALSE, &cmpParams))
    {
        devData.cbSize = sizeof (devData);
        while (SetupDiEnumDeviceInfo (hdi, iIndex++, &devData))
        {
            if (Modem_Compare (&cmpParams, hdi, &devData))
            {
             HKEY hKey;
             DWORD cbData;
             TCHAR szPort[LINE_LEN];

                hKey = SetupDiOpenDevRegKey (hdi, &devData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ);
                if (INVALID_HANDLE_VALUE == hKey)
                {
                    TRACE_MSG (TF_ERROR, "Could not open registry key: %#lx", GetLastError ());
                    continue;
                }
                cbData = sizeof(szPort);
                if (NO_ERROR == RegQueryValueEx (hKey, c_szAttachedTo, NULL, NULL, (LPBYTE)szPort, &cbData)
                    )
                {
                    if (!IsStringInMultistringI (*ppExcludeList, szPort))
                    {
                        CatMultiString (ppExcludeList, szPort);
                    }
                }
                RegCloseKey (hKey);
            }
        }
    }

    DBG_EXIT(GenerateExcludeList);
}


/*----------------------------------------------------------
Purpose: Port dialog.  Allows the user to select a port.
Returns: varies
Cond:    --
*/
ULONG_PTR
CALLBACK 
CloneDlgProc(
    IN HWND hDlg, 
    IN UINT message, 
    IN WPARAM wParam, 
    IN LPARAM lParam)
{
    NMHDR FAR *lpnm;
    LPSETUPINFO psi = (LPSETUPINFO)GetWindowLongPtr(hDlg, DWLP_USER);
#pragma data_seg(DATASEG_READONLY)
TCHAR const FAR c_szWinHelpFileName[] = TEXT("modem.hlp");
const DWORD g_aHelpIDs_IDD_CLONE[]= {
                                     IDC_NAME, IDH_DUPLICATE_NAME_MODEM,
                                     IDC_WHICHPORTS,IDH_CHOOSE_WHICH_PORTS,
                                     IDC_ALL, IDH_DUPLICATE_ALL_PORTS,
                                     IDC_SELECTED, IDH_DUPLICATE_SELECTED_PORTS,
                                     IDC_PORTS, IDH_DUPLICATE_PORTS_LIST,
                                     IDC_MESSAGE, IDH_DUPLICATE_PORTS_LIST,
                                     0,0
                                    };
#pragma data_seg()

    switch(message) 
    {
        case WM_HELP:
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, c_szWinHelpFileName, HELP_WM_HELP, (ULONG_PTR)(LPVOID)g_aHelpIDs_IDD_CLONE);
            return 0;

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, c_szWinHelpFileName, HELP_CONTEXTMENU, (ULONG_PTR)(LPVOID)g_aHelpIDs_IDD_CLONE);
            return 0;

        case WM_INITDIALOG:
        {
         HWND hwndCtl = GetDlgItem(hDlg, IDC_PORTS);
         PORTINFO portinfo = {0};
         MODEM_PRIV_PROP mpp;
         int cItems;

            psi = (LPSETUPINFO)lParam;

            // Start off by selecting all the ports
            CheckRadioButton(hDlg, IDC_ALL, IDC_SELECTED, IDC_ALL);

            // Get the name and device type
            mpp.cbSize = sizeof(mpp);
            mpp.dwMask = MPPM_FRIENDLY_NAME | MPPM_DEVICE_TYPE | MPPM_PORT;
            if (CplDiGetPrivateProperties(psi->hdi, psi->pdevData, &mpp))
            {
             LPTSTR psz;

                // Modem name
                if (ConstructMessage(&psz, g_hinst, MAKEINTRESOURCE(IDS_SELECTTODUP),
                                     mpp.szFriendlyName))
                {
                    SetDlgItemText(hDlg, IDC_NAME, psz);
                    LocalFree(psz);
                }

                // Fill the port listbox; special-case the parallel and
                // serial cable connections so we don't look bad
                switch (mpp.nDeviceType)
                {
                    case DT_PARALLEL_PORT:
                        portinfo.dwFlags = FP_PARALLEL;
                        break;

                    case DT_PARALLEL_MODEM:
                        portinfo.dwFlags = FP_PARALLEL | FP_MODEM;
                        break;

                    default:
                        portinfo.dwFlags = FP_SERIAL | FP_MODEM;
                        break;
                }
                portinfo.hwndLB = GetDlgItem(hDlg, IDC_PORTS);
                //lstrcpy(portinfo.szPortExclude, mpp.szPort);
                GenerateExcludeList (psi->hdi,
                                     psi->pdevData,
                                     &portinfo.pszPortExclude);

                ListBox_ResetContent(portinfo.hwndLB);
                EnumeratePorts(Port_Add, (LPARAM)&portinfo);
            }
            else
            {
                // Error
                MsgBox(g_hinst, hDlg,
                       MAKEINTRESOURCE(IDS_OOM_CLONE),
                       MAKEINTRESOURCE(IDS_CAP_MODEMSETUP),
                       NULL,
                       MB_OK | MB_ICONERROR);
                EndDialog(hDlg, -1);
            }

            // Play it safe; was there no selection made?
            cItems = ListBox_GetCount(hwndCtl);
            if (0 == cItems)
            {
                // Yes; disable OK button
                Button_Enable (GetDlgItem (hDlg, IDOK), FALSE);
                Button_Enable (GetDlgItem (hDlg, IDC_ALL), FALSE);
                Button_Enable (GetDlgItem (hDlg, IDC_SELECTED), FALSE);
                // Hide some windows
                ShowWindow (hwndCtl, SW_HIDE);
                ShowWindow (GetDlgItem (hDlg, IDC_ALL), SW_HIDE);
                ShowWindow (GetDlgItem (hDlg, IDC_SELECTED), SW_HIDE);
                ShowWindow (GetDlgItem (hDlg, IDC_WHICHPORTS), SW_HIDE);
                // Show no ports message
                ShowWindow (GetDlgItem (hDlg, IDC_MESSAGE), SW_SHOW);
            }
            else
            {
                ListBox_SelItemRange(hwndCtl, TRUE, 0, cItems);
            }

            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            break;
        }

        case WM_COMMAND:
            Port_OnCommand(hDlg, wParam, lParam, FALSE);

            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            {
                case IDOK: 
                    Port_OnWizNext(hDlg, psi);

                    // Fall thru
                    //  |    |
                    //  v    v

                case IDCANCEL:
                    EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
                    break;
            }
            break;

        default:
            return FALSE;

    } // end of switch on message

    return TRUE;
}


void PUBLIC   Install_SetStatus(
	IN HWND hDlg,
	IN LPCTSTR lpctszStatus
	)
{
	if (hDlg && lpctszStatus)
	{
            SetDlgItemText(hDlg, IDC_ST_INSTALLING, lpctszStatus);
    		UpdateWindow(hDlg);
	}
}



#define WM_ENABLE_BUTTON   (WM_USER+100)

INT_PTR
CALLBACK
SelectModemsDlgProc (
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
 static BOOL bPosted = FALSE;
 NMHDR FAR *lpnm;
 LPSETUPINFO psi = Wiz_GetPtr(hDlg);
 HWND hwndDetectList = GetDlgItem(hDlg, IDC_MODEMS);

    switch (message) 
    {
        case WM_INITDIALOG:
        {
        LV_COLUMN lvcCol;

            Wiz_SetPtr(hDlg, lParam);

            hwndDetectList = GetDlgItem(hDlg, IDC_MODEMS);
            // Insert a column for the class list
            lvcCol.mask = LVCF_FMT | LVCF_WIDTH;
            lvcCol.fmt = LVCFMT_LEFT;
            lvcCol.iSubItem = 0;
            ListView_InsertColumn (hwndDetectList, 0, &lvcCol);
            lvcCol.iSubItem = 1;
            ListView_InsertColumn (hwndDetectList, 1, &lvcCol);

            ListView_SetExtendedListViewStyleEx (hwndDetectList,
                                                 LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT,
                                                 LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT);

            ListView_SetColumnWidth(hwndDetectList, 0, LVSCW_AUTOSIZE);
            ListView_SetColumnWidth(hwndDetectList, 1, LVSCW_AUTOSIZE);

            EnableWindow (GetDlgItem(hDlg, IDC_CHANGE), FALSE);

            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
            EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), TRUE);

            break;
        }

        case WM_DESTROY:
            break;

        case WM_ENABLE_BUTTON:
        {
         BOOL bEnabled = FALSE;
         int iItem = -1;
         int iItems;

            bPosted = FALSE;
            iItem = ListView_GetNextItem (hwndDetectList, -1, LVNI_SELECTED);
            if (-1 != iItem &&
                ListView_GetCheckState (hwndDetectList, iItem))
            {
                bEnabled = TRUE;
            }

            iItems = ListView_GetItemCount (hwndDetectList);
            while (--iItems >= 0)
            {
                if (ListView_GetCheckState (hwndDetectList, iItems))
                {
                    break;
                }
            }
            if (-1 == iItems)
            {
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
            }
            else
            {
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
            }

            EnableWindow (GetDlgItem(hDlg, IDC_CHANGE), bEnabled);
            break;
        }

        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_SETACTIVE:
                {
                 DWORD iDevice = 0;
                 LV_ITEM lviItem;
                 int iItem;
                 SP_DEVINFO_DATA devData = {sizeof(SP_DEVINFO_DATA),0};
                 SP_DRVINFO_DATA drvData = {sizeof(SP_DRVINFO_DATA),0};
                 TCHAR szPort[LINE_LEN];
                 HKEY hKey;
                 DWORD cbData;

                    lviItem.state = 0;
                    lviItem.stateMask = LVIS_SELECTED;

                    ListView_DeleteAllItems (hwndDetectList);
                    while (SetupDiEnumDeviceInfo (psi->hdi, iDevice++, &devData))
                    {
                        if (CplDiCheckModemFlags(psi->hdi, &devData, MARKF_DETECTED, MARKF_QUIET))
                        {
                            if (SetupDiGetSelectedDriver (psi->hdi, &devData, &drvData))
                            {
                                lviItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
                                lviItem.iItem = -1;
                                lviItem.iSubItem = 0;
                                lviItem.pszText = drvData.Description;
                                lviItem.lParam = devData.DevInst;
                                iItem = ListView_InsertItem (hwndDetectList, &lviItem);

                                if (iItem != -1)
                                {
                                    hKey = SetupDiOpenDevRegKey (psi->hdi, &devData, DICS_FLAG_GLOBAL, 0,
                                                                 DIREG_DEV, KEY_READ);
                                    if (INVALID_HANDLE_VALUE != hKey)
                                    {
                                        cbData = sizeof(szPort)/sizeof(TCHAR);
                                        if (ERROR_SUCCESS ==
                                            RegQueryValueEx (hKey, REGSTR_VAL_PORTNAME, NULL, NULL,
                                                             (PBYTE)szPort, &cbData))
                                        {
                                            lviItem.mask = LVIF_TEXT;
                                            lviItem.iItem = iItem;
                                            lviItem.iSubItem = 1;
                                            lviItem.pszText = szPort;
                                            ListView_SetItem (hwndDetectList, &lviItem);
                                        }
                                        RegCloseKey (hKey);
                                    }
                                    // set the checkbox, control uses one based index, while imageindex is zero based
                                    ListView_SetItemState (hwndDetectList, iItem,
                                                           INDEXTOSTATEIMAGEMASK(2), LVIS_STATEIMAGEMASK);
                                    ListView_SetColumnWidth(hwndDetectList, 0, LVSCW_AUTOSIZE);
                                    ListView_SetColumnWidth(hwndDetectList, 1, LVSCW_AUTOSIZE);
                                }
                            }
                        }
                    }

                    lviItem.mask = LVIF_STATE;
                    lviItem.iItem = 0;
                    lviItem.iSubItem = 0;
                    lviItem.state = LVIS_SELECTED;
                    lviItem.stateMask = LVIS_SELECTED;
                    ListView_SetItem(hwndDetectList, &lviItem);
                    ListView_EnsureVisible(hwndDetectList, 0, FALSE);
                    ListView_SetColumnWidth(hwndDetectList, 0, LVSCW_AUTOSIZE_USEHEADER);
                    SendMessage(hwndDetectList, WM_SETREDRAW, TRUE, 0L);
                    break;
                }

                case PSN_KILLACTIVE:
                case PSN_HELP:
                    break;

                case PSN_WIZBACK:
                {
                 DWORD iDevice = 0;
                 SP_DEVINFO_DATA devData = {sizeof(SP_DEVINFO_DATA),0};

                    while (SetupDiEnumDeviceInfo (psi->hdi, iDevice, &devData))
                    {
                        if (CplDiCheckModemFlags(psi->hdi, &devData, MARKF_DETECTED, 0))
                        {
                            SetupDiRemoveDevice (psi->hdi, &devData);
                            SetupDiDeleteDeviceInfo (psi->hdi, &devData);
                        }
                        else
                        {
                            iDevice++;
                        }
                    }
                    SetDlgMsgResult(hDlg, message, IDD_WIZ_INTRO);
                    break;
                }

                case PSN_WIZNEXT:
                {
                 DWORD iDevice = 0;
                 DWORD dwNumSelectedModems = 0;
                 int iItem;
                 SP_DEVINFO_DATA devData = {sizeof(SP_DEVINFO_DATA),0};
                 LVFINDINFO lvFindInfo;
                 ULONG uNextDlg;

                    lvFindInfo.flags = LVFI_PARAM;
                    while (SetupDiEnumDeviceInfo (psi->hdi, iDevice++, &devData))
                    {
                        lvFindInfo.lParam = devData.DevInst;
                        iItem = ListView_FindItem (hwndDetectList, -1, &lvFindInfo);
                        if (-1 != iItem)
                        {
                            if (ListView_GetCheckState (hwndDetectList, iItem))
                            {
                                dwNumSelectedModems++;
                                CplDiMarkModem (psi->hdi, &devData, MARKF_INSTALL);
                            }
                            else
                            {
                                CplDiUnmarkModem(psi->hdi, &devData, MARKF_DETECTED);
                            }
                        }
                    }

                    if (0 == dwNumSelectedModems)
                    {
                        PropSheet_PressButton(GetParent(hDlg), PSBTN_FINISH);
                    }
                    else
                    {
                        if (IsFlagSet(psi->dwFlags, SIF_PORTS_GALORE))
                        {
                            uNextDlg = IDD_WIZ_PORTDETECT;
                        }
                        else
                        {
                            uNextDlg = IDD_WIZ_INSTALL;
                        }
                        SetDlgMsgResult(hDlg, message, uNextDlg);
                    }
                    break;
                }

                case LVN_ITEMCHANGED:
                {
                    if (!bPosted)
                    {
                        PostMessage (hDlg, WM_ENABLE_BUTTON, 0, 0);
                        bPosted = TRUE;
                    }
                    break;
                }
            }
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_CHANGE:
                {
                 DWORD iDevice = 0;
                 SP_DEVINFO_DATA devData = {sizeof(SP_DEVINFO_DATA),0};
                 LV_ITEM lvi;
                 int iItem;

                    iItem = ListView_GetNextItem (hwndDetectList, -1, LVNI_SELECTED);
                    if (-1 != iItem)
                    {
                        lvi.mask = LVIF_PARAM;
                        lvi.iItem = iItem;
                        lvi.iSubItem = 0;
                        ListView_GetItem (hwndDetectList, &lvi);
                        while (SetupDiEnumDeviceInfo (psi->hdi, iDevice++, &devData))
                        {
                            if ((DEVINST)lvi.lParam == devData.DevInst)
                            {
                                break;
                            }
                        }

                        // Bring up the device installer browser to allow the user
                        // to select a different modem.
                        if (SelectNewDriver(hDlg, psi->hdi, &devData))
                        {
                         SP_DRVINFO_DATA drvData = {sizeof(SP_DRVINFO_DATA),0};
                            if (SetupDiGetSelectedDriver(psi->hdi, &devData, &drvData))
                            {
                             TCHAR szHardwareID[MAX_BUF_ID];
                             int cch;
                                if (CplDiGetHardwareID (psi->hdi, &devData, &drvData,
                                                        szHardwareID, sizeof(szHardwareID) / sizeof(TCHAR), NULL))
                                {
                                    cch = lstrlen (szHardwareID) + 1;
                                    szHardwareID[cch] = 0;
                                    SetupDiSetDeviceRegistryProperty (psi->hdi, &devData, SPDRP_HARDWAREID,
                                                                      (PBYTE)szHardwareID, CbFromCch(cch));
                                }

                                ListView_SetItemText (hwndDetectList, iItem, 0, drvData.Description);
                                ListView_EnsureVisible(hwndDetectList, 0, FALSE);
                                ListView_SetColumnWidth(hwndDetectList, 0, LVSCW_AUTOSIZE_USEHEADER);
                            }
                        }
                    }

                    break;
                }
            }
            break;

        default:
            return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\mdminst\util.c ===
/*
 *  UTIL.C
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1993-1994
 *  All rights reserved
 *
 */

#include "proj.h"
#include <objbase.h>

#ifdef PROFILE_MASSINSTALL            
extern DWORD g_dwTimeSpent;
extern DWORD g_dwTimeBegin;
DWORD g_dwTimeStartModemInstall;
#endif            


BYTE g_wUsedNameArray[MAX_INSTALLATIONS];


// Unattended install INF file line fields
#define FIELD_PORT              0
#define FIELD_DESCRIPTION       1
#define FIELD_MANUFACTURER      2
#define FIELD_PROVIDER          3

// Unattended install INF file lines.
typedef struct _tagModemSpec
{
    TCHAR   szPort[LINE_LEN];
    TCHAR   szDescription[LINE_LEN];
    TCHAR   szManufacturer[LINE_LEN];
    TCHAR   szProvider[LINE_LEN];

} MODEM_SPEC, FAR *LPMODEM_SPEC;


// UNATTENDED-INSTALL-RELATED-GLOBALS
// Global failure-code used by final message box to display error code.
UINT gUnattendFailID;


PTSTR
MyGetFileTitle (
    IN PTSTR FilePath)
{
 PTSTR LastComponent = FilePath;
 TCHAR CurChar;

    while(CurChar = *FilePath) {
        FilePath++;
        if((CurChar == TEXT('\\')) || (CurChar == TEXT(':'))) {
            LastComponent = FilePath;
        }
    }

    return LastComponent;
}



/*----------------------------------------------------------
Purpose: Returns a string of the form:

            "Base string #n"

         where "Base string" is pszBase and n is the nCount.

Returns: --
Cond:    --
*/
void
PUBLIC
MakeUniqueName (
    OUT LPTSTR  pszBuf,
    IN  LPCTSTR pszBase,
    IN  UINT    dwUiNumber)
{
    if (1 == dwUiNumber)
    {
        lstrcpy (pszBuf, pszBase);
    }
    else
    {
     TCHAR szTemplate[MAX_BUF_MED];

        LoadString(g_hinst, IDS_DUP_TEMPLATE, szTemplate, SIZECHARS(szTemplate));
        wsprintf(pszBuf, szTemplate, pszBase, (UINT)dwUiNumber);
    }
}


//-----------------------------------------------------------------------------------
//  DeviceInstaller wrappers and support functions
//-----------------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Returns TRUE if the given device data is one of the
         detected modems in a set.

         This function, paired with CplDiMarkModem, uses
         the devParams.ClassInstallReserved field to determine
         this.  This is not a hack -- this is what the field
         is for.

Returns: --
Cond:    --
*/
BOOL
PUBLIC
CplDiCheckModemFlags(
    IN HDEVINFO          hdi,
    IN PSP_DEVINFO_DATA  pdevData,
    IN ULONG_PTR         dwSetFlags,
    IN ULONG_PTR         dwResetFlags)       // MARKF_*
{
 SP_DEVINSTALL_PARAMS devParams;

    devParams.cbSize = sizeof(devParams);
    if (CplDiGetDeviceInstallParams(hdi, pdevData, &devParams))
    {
        if (0 != dwSetFlags &&
            IsFlagClear(devParams.ClassInstallReserved, dwSetFlags))
        {
            return FALSE;
        }

        if (0 != dwResetFlags &&
            0 != (devParams.ClassInstallReserved & dwResetFlags))
        {
            return FALSE;
        }

        return TRUE;
    }

    return FALSE;
}


/*----------------------------------------------------------
Purpose: Remembers this device instance as a detected modem
         during this detection session.

Returns: --
Cond:    --
*/
void
PUBLIC
CplDiMarkModem(
    IN HDEVINFO         hdi,
    IN PSP_DEVINFO_DATA pdevData,
    IN ULONG_PTR        dwMarkFlags)        // MARKF_*
    {
    SP_DEVINSTALL_PARAMS devParams;

    devParams.cbSize = sizeof(devParams);
    if (CplDiGetDeviceInstallParams(hdi, pdevData, &devParams))
        {
        // Use the ClassInstallReserved field as a boolean indicator
        // of whether this device in the device set is detected.
        SetFlag(devParams.ClassInstallReserved, dwMarkFlags);
        CplDiSetDeviceInstallParams(hdi, pdevData, &devParams);
        }
    }


/*----------------------------------------------------------
Purpose: Enumerates all the devices in the devinfo set and
         unmarks any devices that were previously marked as
         detected.

Returns: --
Cond:    --
*/
void
PUBLIC
CplDiUnmarkModem(
    IN HDEVINFO         hdi,
    IN PSP_DEVINFO_DATA pdevData,
    IN ULONG_PTR        dwMarkFlags)                // MARKF_*
    {
    SP_DEVINSTALL_PARAMS devParams;

    devParams.cbSize = sizeof(devParams);
    if (CplDiGetDeviceInstallParams(hdi, pdevData, &devParams))
        {
        // Clear the ClassInstallReserved field
        ClearFlag(devParams.ClassInstallReserved, dwMarkFlags);
        CplDiSetDeviceInstallParams(hdi, pdevData, &devParams);
        }
    }


/*----------------------------------------------------------
Purpose: Enumerates all the devices in the devinfo set and
         unmarks any devices that were previously marked as
         detected.

Returns: --
Cond:    --
*/
void
PRIVATE
CplDiUnmarkAllModems(
    IN HDEVINFO         hdi,
    IN ULONG_PTR        dwMarkFlags)                // MARKF_*
    {
    SP_DEVINFO_DATA devData;
    SP_DEVINSTALL_PARAMS devParams;
    DWORD iDevice = 0;

    DBG_ENTER(CplDiUnmarkAllModems);
    
    devData.cbSize = sizeof(devData);
    devParams.cbSize = sizeof(devParams);
    while (CplDiEnumDeviceInfo(hdi, iDevice++, &devData))
        {
        if (IsEqualGUID(&devData.ClassGuid, g_pguidModem) &&
            CplDiGetDeviceInstallParams(hdi, &devData, &devParams))
            {
            // Clear the ClassInstallReserved field
            ClearFlag(devParams.ClassInstallReserved, dwMarkFlags);
            CplDiSetDeviceInstallParams(hdi, &devData, &devParams);
            }
        }
    DBG_EXIT(CplDiUnmarkAllModems);
    }


/*----------------------------------------------------------
Purpose: Installs a modem that is compatible with the specified
         DeviceInfoData.

Returns: TRUE on success
Cond:    --
*/
BOOL
PRIVATE
InstallCompatModem(
    IN  HDEVINFO        hdi,
    IN  PSP_DEVINFO_DATA pdevData,
    IN  BOOL            bInstallLocalOnly)
{
 BOOL bRet = TRUE;           // Default success
 SP_DRVINFO_DATA drvData;

    ASSERT(pdevData);

    DBG_ENTER(InstallCompatModem);

    MyYield();

    // Only install it if it has a selected driver.  (Other modems
    // that were already installed in a different session may be
    // in this device info set.  We don't want to reinstall them!)

    drvData.cbSize = sizeof(drvData);
    if (CplDiCheckModemFlags(hdi, pdevData, MARKF_INSTALL, 0) &&
        CplDiGetSelectedDriver(hdi, pdevData, &drvData))
    {
        // Install the driver
        if (FALSE == bInstallLocalOnly)
        {
#ifdef PROFILE
         DWORD dwLocal = GetTickCount();
#endif //PROFILE
            TRACE_MSG(TF_GENERAL, "> SetupDiCallClassInstaller (DIF_INSTALLDEVICE).....");
            bRet = SetupDiCallClassInstaller (DIF_INSTALLDEVICE, hdi, pdevData);
            TRACE_MSG(TF_GENERAL, "< SetupDiCallClassInstaller (DIF_INSTALLDEVICE).....");
#ifdef PROFILE
            TRACE_MSG(TF_GENERAL, "PROFILE: SetupDiDiCallClassInstaller took %lu ms.", GetTickCount()-dwLocal);
#endif //PROFILE

            CplDiUnmarkModem(hdi, pdevData, MARKF_INSTALL);
        }
    }

    DBG_EXIT_BOOL_ERR(InstallCompatModem, bRet);

    return bRet;
}


/*----------------------------------------------------------
Purpose: Calls the class installer to install the modem.

Returns: TRUE if at least one modem was installed or if
         there were no new modems at all

Cond:    Caller should protect this function with CM_Lock
         and CM_Unlock (Win95 only).
*/
BOOL
PUBLIC
CplDiInstallModem(
    IN  HDEVINFO            hdi,
    IN  PSP_DEVINFO_DATA    pdevData,       OPTIONAL
    IN  BOOL                bLocalOnly)
{
 BOOL bRet;
 int cFailed = 0;
 int cNewModems;
 HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
#ifdef PROFILE
 DWORD dwLocal;
#endif //PROFILE

    DBG_ENTER(CplDiInstallModem);

    if (pdevData)
    {
        // Install the given DeviceInfoData
        cNewModems = 1;
        if ( !InstallCompatModem(hdi, pdevData, bLocalOnly) )
        {
            cFailed = 1;
        }
    }
    else
    {
     DWORD iDevice;
     SP_DEVINFO_DATA devData;
     COMPARE_PARAMS cmpParams;

        cNewModems = 0;

        // Enumerate all the DeviceInfoData elements in this device set
        devData.cbSize = sizeof(devData);
        iDevice = 0;

        while (CplDiEnumDeviceInfo(hdi, iDevice++, &devData))
        {
            if (CplDiCheckModemFlags (hdi, &devData, MARKF_DETECTED, MARKF_DONT_REGISTER))
            {
#ifdef PROFILE
                dwLocal = GetTickCount ();
#endif //PROFILE
                if (!InitCompareParams (hdi, &devData, TRUE, &cmpParams))
                {
                    continue;
                }
                if (!CplDiRegisterDeviceInfo (hdi, &devData,
                                              SPRDI_FIND_DUPS, DetectSig_Compare,
                                              (PVOID)&cmpParams, NULL))
                {
                    if (ERROR_DUPLICATE_FOUND != GetLastError())
                    {
                        TRACE_MSG(TF_ERROR,
                                  "SetupDiRegisterDeviceInfo failed: %#lx.",
                                  GetLastError ());
                        continue;
                    }
                    // so, this is a duplicate device;
                    // CplDiRegisterDeviceInfo already added the device info for
                    // the original to hdi, so all we have to do is remove the
                    // duplicate
                    CplDiRemoveDevice (hdi, &devData);
                }
                else
                {
#ifdef PROFILE
                    TRACE_MSG(TF_GENERAL, "PROFILE: SetupDiRegisterDeviceInfo took %lu ms.", GetTickCount() - dwLocal);
#endif //PROFILE
                    if ( !InstallCompatModem(hdi, &devData, bLocalOnly) )
                    {
                        cFailed++;
                    }
                }

                cNewModems++;
            }
        }
    }

    SetCursor(hcur);

    bRet = (cFailed < cNewModems || 0 == cNewModems);

    DBG_EXIT_BOOL_ERR(CplDiInstallModem, bRet);

    return bRet;
}


/*----------------------------------------------------------
Purpose: This function gets the device info set for the modem
         class.  The set may be empty, which means there are
         no modems currently installed.

         The parameter pbInstalled is set to TRUE if there
         is a modem installed on the system.

Returns: TRUE a set is created
         FALSE

Cond:    --
*/
BOOL
PUBLIC
CplDiGetModemDevs(
    OUT HDEVINFO FAR *  phdi,           OPTIONAL
    IN  HWND            hwnd,           OPTIONAL
    IN  DWORD           dwFlags,        // DIGCF_ bit field
    OUT BOOL FAR *      pbInstalled)    OPTIONAL
{
 BOOL bRet;
 HDEVINFO hdi;

    DBG_ENTER(CplDiGetModemDevs);

    *pbInstalled = FALSE;

    hdi = CplDiGetClassDevs(g_pguidModem, NULL, hwnd, dwFlags);
    if (NULL != pbInstalled &&
        INVALID_HANDLE_VALUE != hdi)
    {
     SP_DEVINFO_DATA devData;

        // Is there a modem present on the system?
        devData.cbSize = sizeof(devData);
        *pbInstalled = CplDiEnumDeviceInfo(hdi, 0, &devData);
        SetLastError (NO_ERROR);
    }

    if (NULL != phdi)
    {
        *phdi = hdi;
    }
    else if (INVALID_HANDLE_VALUE != hdi)
    {
        SetupDiDestroyDeviceInfoList (hdi);
    }

    bRet = (INVALID_HANDLE_VALUE != hdi);

    DBG_EXIT_BOOL_ERR(CplDiGetModemDevs, bRet);

    return bRet;
}


/*----------------------------------------------------------
Purpose: Take a hardware ID and copy it to the supplied buffer.
         This function changes all backslashes to ampersands.

Returns: --
Cond:    --
*/
BOOL
PUBLIC
CplDiCopyScrubbedHardwareID(
    OUT LPTSTR   pszBuf,
    IN  LPCTSTR  pszIDList,         // Multi string
    IN  DWORD    cbSize)
    {
    BOOL bRet;
    LPTSTR psz;
    LPCTSTR pszID;
    BOOL bCopied;

    ASSERT(pszBuf);
    ASSERT(pszIDList);

    bCopied = FALSE;
    bRet = TRUE;

    // Choose the first, best compatible ID.  If we cannot find
    // one, choose the first ID, and scrub it so it doesn't have
    // any backslahes.

    for (pszID = pszIDList; 0 != *pszID; pszID += lstrlen(pszID) + 1)
        {
        // Is the buffer big enough?
        if (CbFromCch(lstrlen(pszID)) >= cbSize)
            {
            // No
            bRet = FALSE;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            break;
            }
        else
            {
            // Yes; are there any backslashes?
            for (psz = (LPTSTR)pszID; 0 != *psz; psz = CharNext(psz))
                {
                if ('\\' == *psz)
                    {
                    break;
                    }
                }

            if (0 == *psz)
                {
                // No; use this ID
                lstrcpy(pszBuf, pszID);
                bCopied = TRUE;
                break;
                }
            }
        }

    // Was an ID found in the list that does not have a backslash?
    if (bRet && !bCopied)
        {
        // No; use the first one and scrub it.
        lstrcpy(pszBuf, pszIDList);

        // Clean up the hardware ID.  Some hardware IDs may
        // have an additional level to them (eg, PCMCIA\xxxxxxx).
        // We must change this sort of ID to PCMCIA&xxxxxxx.
        for (psz = pszBuf; 0 != *psz; psz = CharNext(psz))
            {
            if ('\\' == *psz)
                {
                *psz = '&';
                }
            }
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: This function returns the rank-0 (the first) hardware
         ID of the given DriverInfoData.

         If no DriverInfoData is provided, this function will
         use the selected driver.  If there is no selected
         driver, this function fails.

Returns: TRUE on success
         FALSE if the buffer is too small or another error
Cond:    --
*/
BOOL
PUBLIC
CplDiGetHardwareID(
    IN  HDEVINFO            hdi,
    IN  PSP_DEVINFO_DATA    pdevData,       OPTIONAL
    IN  PSP_DRVINFO_DATA    pdrvData,       OPTIONAL
    OUT LPTSTR              pszHardwareIDBuf,
    IN  DWORD               cbSize,
    OUT LPDWORD             pcbSizeOut)     OPTIONAL
    {
    BOOL bRet;
    PSP_DRVINFO_DETAIL_DATA  pdrvDetail;
    SP_DRVINFO_DATA drvData;
    DWORD cbSizeT = 0;

#ifndef PROFILE_MASSINSTALL
    DBG_ENTER(CplDiGetHardwareID);
#endif

    ASSERT(hdi && INVALID_HANDLE_VALUE != hdi);
    ASSERT(pszHardwareIDBuf);

    if ( !pdrvData )
        {
        pdrvData = &drvData;

        drvData.cbSize = sizeof(drvData);
        bRet = CplDiGetSelectedDriver(hdi, pdevData, &drvData);
        }
    else
        {
        bRet = TRUE;
        }

    if (bRet)
        {
        // Get the driver detail so we can get the HardwareID of
        // the selected driver
        CplDiGetDriverInfoDetail(hdi, pdevData, pdrvData, NULL, 0, &cbSizeT);

        ASSERT(0 < cbSizeT);

        pdrvDetail = (PSP_DRVINFO_DETAIL_DATA)ALLOCATE_MEMORY( cbSizeT);
        if ( !pdrvDetail )
            {
            // Out of memory
            bRet = FALSE;
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            }
        else
            {
            pdrvDetail->cbSize = sizeof(*pdrvDetail);
            bRet = CplDiGetDriverInfoDetail(hdi, pdevData, pdrvData, pdrvDetail,
                                            cbSizeT, NULL);
            if (bRet)
                {
                // Is the buffer big enough?
                bRet = CplDiCopyScrubbedHardwareID(pszHardwareIDBuf, pdrvDetail->HardwareID, cbSize);

                if (pcbSizeOut)
                    {
                    // Return the required size
                    *pcbSizeOut = CbFromCch(lstrlen(pdrvDetail->HardwareID));
                    }
                }
            FREE_MEMORY((pdrvDetail));
            }
        }

#ifndef PROFILE_MASSINSTALL
    DBG_EXIT_BOOL_ERR(CplDiGetHardwareID, bRet);
#endif
    return bRet;
    }


/*----------------------------------------------------------
Purpose: Creates a DeviceInfoData for a modem.  This function is
         used when the caller has a DeviceInfoSet and a selected
         driver from the global class driver list, but no real
         DeviceInfoData in the device-set.

Returns: TRUE on success
Cond:    --
*/
BOOL
PRIVATE
CplDiCreateInheritDeviceInfo(
    IN  HDEVINFO            hdi,
    IN  PSP_DEVINFO_DATA    pdevData,       OPTIONAL
    IN  HWND                hwndOwner,      OPTIONAL
    OUT PSP_DEVINFO_DATA    pdevDataOut)
{
    BOOL bRet;
    SP_DRVINFO_DATA drvData;
    TCHAR szHardwareID[MAX_BUF_ID];

    DBG_ENTER(CplDiCreateInheritDeviceInfo);

    ASSERT(hdi && INVALID_HANDLE_VALUE != hdi);
    ASSERT(pdevDataOut);

    // Get the selected driver
    drvData.cbSize = sizeof(drvData);
    bRet = CplDiGetSelectedDriver(hdi, pdevData, &drvData);
    if (bRet)
    {
        // Was a window owner supplied?
        if (NULL == hwndOwner)
        {
            // No; use the window owner of the DeviceInfoData to be cloned.
            SP_DEVINSTALL_PARAMS devParams;

            devParams.cbSize = sizeof(devParams);
            CplDiGetDeviceInstallParams(hdi, pdevData, &devParams);

            hwndOwner = devParams.hwndParent;
        }

        // Get the hardware ID
        bRet = CplDiGetHardwareID(hdi, pdevData, &drvData, szHardwareID, sizeof(szHardwareID) / sizeof(TCHAR), NULL);
        // (Our buffer should be big enough)
        ASSERT(bRet);

        if (bRet)
        {
            // Create a DeviceInfoData.  The Device Instance ID will be
            // something like: Root\MODEM\0000. The device
            // instance will inherit the driver settings of the global
            // class driver list.

            bRet = CplDiCreateDeviceInfo(hdi, c_szModemInstanceID, g_pguidModem,
                                         drvData.Description, hwndOwner,
                                         DICD_GENERATE_ID | DICD_INHERIT_CLASSDRVS,
                                         pdevDataOut);
        }
    }

    DBG_EXIT_BOOL_ERR(CplDiCreateInheritDeviceInfo, bRet);

    return bRet;
}


/*----------------------------------------------------------
Purpose: Creates a device instance that is compatible with the
         given hardware ID.

         This function can also obtain a device description of
         the device instance.

         If there is no compatible device, this function
         returns FALSE.

Returns: see above
Cond:    --
*/
BOOL
PUBLIC
CplDiCreateCompatibleDeviceInfo(
    IN  HDEVINFO    hdi,
    IN  LPCTSTR     pszHardwareID,
    IN  LPCTSTR     pszDeviceDesc,      OPTIONAL
    OUT PSP_DEVINFO_DATA pdevDataOut)
{
 BOOL bRet;
#ifdef PROFILE_FIRSTTIMESETUP
 DWORD dwLocal;
#endif //PROFILE_FIRSTTIMESETUP

    DBG_ENTER(CplDiCreateCompatibleDeviceInfo);

    ASSERT(hdi && INVALID_HANDLE_VALUE != hdi);
    ASSERT(pszHardwareID);
    ASSERT(pdevDataOut);

#ifdef BUILD_DRIVER_LIST_THREAD
    // First, wait for the driver search to finish;
    // this will probably return right away, since it takes
    // about 10 seconds to build the driver list, but 20 seconds
    // to compute the UNIMODEM id.
    if (NULL != g_hDriverSearchThread)
    {
        WaitForSingleObject (g_hDriverSearchThread, INFINITE);
        CloseHandle (g_hDriverSearchThread);
        g_hDriverSearchThread = NULL;
    }
#endif //BUILD_DRIVER_LIST_THREAD

    // Create a phantom device instance
    bRet = CplDiCreateDeviceInfo(hdi, c_szModemInstanceID, g_pguidModem,
                                 pszDeviceDesc, NULL,
#ifdef BUILD_DRIVER_LIST_THREAD
                                 DICD_GENERATE_ID | DICD_INHERIT_CLASSDRVS,
#else //BUILD_DRIVER_LIST_THREAD not defined
                                 DICD_GENERATE_ID,
#endif //BUILD_DRIVER_LIST_THREAD
                                 pdevDataOut);

    if (bRet)
    {
     SP_DEVINSTALL_PARAMS devParams;
     TCHAR const *pszT = pszHardwareID;
     int cch = 0, cchT;

        // Set the flag to focus on only classes that pertain to
        // modems.  This will keep CplDiBuildDriverInfoList from
        // slowing down any further once more INF files are added.
        //
        devParams.cbSize = sizeof(devParams);
        if (CplDiGetDeviceInstallParams(hdi, pdevDataOut, &devParams))
        {
            // Specify using our GUID to make things a little faster.
            SetFlag(devParams.FlagsEx, DI_FLAGSEX_USECLASSFORCOMPAT);
#ifdef BUILD_DRIVER_LIST_THREAD
            SetFlag(devParams.Flags, DI_COMPAT_FROM_CLASS);
#endif //BUILD_DRIVER_LIST_THREAD

            // Set the Select Device parameters
            CplDiSetDeviceInstallParams(hdi, pdevDataOut, &devParams);
        }

        while (*pszT)
        {
            cchT = lstrlen (pszT) + 1;
            cch += cchT;
            pszT += cchT;
        }
        cch++;

        bRet = CplDiSetDeviceRegistryProperty (hdi, pdevDataOut,
                                               SPDRP_HARDWAREID,
                                               (PBYTE)pszHardwareID,
                                               CbFromCch(cch));

        if (bRet)
        {
            // Build the compatible driver list
#ifdef PROFILE_FIRSTTIMESETUP
            dwLocal = GetTickCount ();
#endif //PROFILE_FIRSTTIMESETUP
            bRet = SetupDiBuildDriverInfoList(hdi, pdevDataOut, SPDIT_COMPATDRIVER);
#ifdef PROFILE_FIRSTTIMESETUP
            TRACE_MSG(TF_GENERAL, "PROFILE: SetupDiBuildDriverInfoList took %lu.", GetTickCount()-dwLocal);
#endif //PROFILE_FIRSTTIMESETUP
            if (bRet)
            {
             SP_DRVINFO_DATA drvDataEnum;
             SP_DRVINSTALL_PARAMS drvParams;
             DWORD dwIndex = 0;

                // Use the first driver as the compatible driver.
                drvDataEnum.cbSize = sizeof (drvDataEnum);
                drvParams.cbSize = sizeof (drvParams);
                while (bRet = CplDiEnumDriverInfo (hdi, pdevDataOut, SPDIT_COMPATDRIVER, dwIndex++, &drvDataEnum))
                {
                    if (SetupDiGetDriverInstallParams (hdi, pdevDataOut, &drvDataEnum, &drvParams))
                    {
                        if (DRIVER_HARDWAREID_RANK < drvParams.Rank)
                        {
                            // We're past hardwareID matches,
                            // so get out
                            SetLastError (ERROR_NO_MORE_ITEMS);
                            bRet = FALSE;
                            break;
                        }

                        // Set the first Rank0 driver as the selected driver
                        bRet = CplDiSetSelectedDriver(hdi, pdevDataOut, &drvDataEnum);

                        if (bRet)
                        {
                            if ( !pszDeviceDesc )
                            {
                                // Set the device description now that we
                                // have one
                                CplDiSetDeviceRegistryProperty(hdi, pdevDataOut,
                                       SPDRP_DEVICEDESC, (LPBYTE)drvDataEnum.Description,
                                       CbFromCch(lstrlen(drvDataEnum.Description)+1));
                            }
                            break;
                        }
                    }
                }
            }
        }

        // Did something fail above?
        if ( !bRet )
        {
		 DWORD dwRet = GetLastError ();
            // Yes; delete the device info we just created
            CplDiDeleteDeviceInfo(hdi, pdevDataOut);
			SetLastError (dwRet);
        }
    }

    DBG_EXIT_BOOL_ERR(CplDiCreateCompatibleDeviceInfo, bRet);

    return bRet;
}


/*----------------------------------------------------------
Purpose: This function sets the integer in the given array
         that is indexed by the numeric value of the friendly 
         name instance to TRUE.

Returns: TRUE on success
         FALSE otherwise

Cond:    --
*/
BOOL
PUBLIC
CplDiRecordNameInstance(
    IN     LPCTSTR      pszFriendlyName,
    IN OUT BYTE FAR *   lpwNameArray)
{
    BOOL    bRet = FALSE;
    LPTSTR  szInstance, psz;
    int     iInstance, ii;

    ASSERT(pszFriendlyName);
    ASSERT(*pszFriendlyName);
    
    if (szInstance = AnsiRChr(pszFriendlyName, '#'))
    {
        szInstance = CharNext(szInstance);

        if (*szInstance == 0)
            return FALSE;
            
        // Make sure that everything following '#' is numeric.
        for (psz = szInstance; *psz; psz = CharNext(psz))
        {
            ii = (int)*psz;
            if (ii < '0' || ii > '9')
            {
                goto exit;
            }
        }

        // Have an instance number on the friendly name.  Record it.
        bRet = AnsiToInt(szInstance, &iInstance);
        if (!bRet)
        {
            TRACE_MSG(TF_ERROR, "AnsiToInt() failed");    
            return FALSE;
        }
        
        if (iInstance >= MAX_INSTALLATIONS - 1)
        {
            TRACE_MSG(TF_ERROR, "Too many drivers installed.");    
            return FALSE;
        }
        
        lpwNameArray[iInstance] = TRUE;
        return TRUE;
    }

exit:
    lpwNameArray[1] = TRUE;
    return TRUE;
}


/*----------------------------------------------------------
Purpose: This function 

Returns: FALSE on error - couldn't mark for mass install.
         TRUE if successful.

Cond:    --
*/
BOOL
PUBLIC
CplDiMarkForInstall(
    IN  HDEVINFO            hdi,
    IN  PSP_DEVINFO_DATA    pdevData,
    IN  PSP_DRVINFO_DATA    pdrvData,
    IN  BOOL                bMassInstall)
{
    BOOL bRet = FALSE;              // assume failure
    SP_DRVINSTALL_PARAMS drvParams;

    DBG_ENTER(CplDiMarkForInstall);

    ZeroMemory(&drvParams,sizeof(drvParams));
    drvParams.cbSize = sizeof(drvParams);    
    bRet = CplDiGetDriverInstallParams(hdi, pdevData, pdrvData, &drvParams);
    if (!bRet)
    {
        TRACE_MSG(TF_ERROR, "CplDiGetDriverInstallParams() failed: %#08lx", GetLastError());
        goto exit;
    }


    TRACE_MSG(TF_WARNING,"%d",pdrvData->DriverType);
    TRACE_MSG(TF_WARNING,"%s",pdrvData->Description);
    TRACE_MSG(TF_WARNING,"%s",pdrvData->MfgName);
    TRACE_MSG(TF_WARNING,"%s",pdrvData->ProviderName);

    drvParams.cbSize = sizeof(drvParams);
    // drvParams.PrivateData = (ULONG_PTR)&g_wUsedNameArray[0];
    drvParams.PrivateData = (DWORD_PTR)&g_wUsedNameArray[0];
    bRet = CplDiSetDriverInstallParams(hdi, pdevData, pdrvData, &drvParams);
    if (!bRet)
    {
        TRACE_MSG(TF_ERROR, "CplDiSetDriverInstallParams() failed: %#08lx", GetLastError());
        goto exit;
    }
    
    if (bMassInstall) CplDiMarkModem(hdi, pdevData, MARKF_MASS_INSTALL);
    bRet = TRUE;

exit:
    DBG_EXIT_BOOL_ERR(CplDiMarkForInstall,bRet);
    return bRet;    
}

/*----------------------------------------------------------
Purpose: This function processes the set of modems that are
         already installed looking for a duplicate of the 
         selected driver. A list is created of the friendly name
         instance numbers that are already in use.

Returns: TRUE if successful.
         FALSE on fatal error.
         
Cond:    --
*/
BOOL
PUBLIC
CplDiPreProcessNames(
    IN      HDEVINFO            hdi,
    IN      HWND                hwndOwner,    OPTIONAL
    OUT     PSP_DEVINFO_DATA    pdevData)
{
 BOOL bRet;
 SP_DEVINFO_DATA devDataEnum = {sizeof(SP_DEVINFO_DATA), 0};
 SP_DRVINFO_DATA drvData = {sizeof(SP_DRVINFO_DATA), 0};
 HDEVINFO hdiClass = NULL;
 HKEY hkey = NULL;
 TCHAR szTemp[LINE_LEN];
 DWORD iIndex, cbData;
 LONG lErr;
 DWORD iUiNumber;
 BOOL bSet = FALSE;

    DBG_ENTER(CplDiPreProcessNames);
 
    // Get the DRVINFO_DATA for the selected driver.
    bRet = CplDiGetSelectedDriver(hdi, pdevData, &drvData);
    if (!bRet)
    {
        TRACE_MSG(TF_ERROR, "CplDiGetSelectedDriver() failed: %#08lx", GetLastError());    
        ASSERT(0);    
        goto exit;
    }


    // Assume failure at some point below.
    bRet = FALSE;   

    hdiClass = CplDiGetClassDevs (g_pguidModem, NULL, NULL, 0);
    if (hdiClass == INVALID_HANDLE_VALUE)
    {
        TRACE_MSG(TF_ERROR, "CplDiGetClassDevs() failed: %#08lx", GetLastError());
        hdiClass = NULL;
        goto exit;
    }

    if (!drvData.Description[0])
    {
        TRACE_MSG(TF_ERROR, "FAILED to get description for selected driver.");
        goto exit;
    }
    
    ZeroMemory(g_wUsedNameArray, sizeof(g_wUsedNameArray));

    // Look through all installed modem devices for instances 
    // of the selected driver.
    for (iIndex = 0;
         CplDiEnumDeviceInfo(hdiClass, iIndex, &devDataEnum);
         iIndex++)
    {
        hkey = CplDiOpenDevRegKey (hdiClass, &devDataEnum, DICS_FLAG_GLOBAL,
                                   0, DIREG_DRV, KEY_READ);
        if (hkey == INVALID_HANDLE_VALUE)
	{
            TRACE_MSG(TF_WARNING, "CplDiOpenDevRegKey() failed: %#08lx", GetLastError());
	    hkey = NULL;
            goto skip;
        }

        // The driver description should exist in the driver key.
        cbData = sizeof(szTemp);
        lErr = RegQueryValueEx (hkey, REGSTR_VAL_DRVDESC, NULL, NULL, 
                                (LPBYTE)szTemp, &cbData);
        if (lErr != ERROR_SUCCESS)
        {
            TRACE_MSG(TF_WARNING, "DriverDescription not found");
            goto skip;
        }

        // Skip this one if it isn't the right kind of modem
        if (!IsSzEqual(drvData.Description, szTemp))
            goto skip;

	// Read the UI number and add it to the list
        cbData = sizeof(iUiNumber);
        lErr = RegQueryValueEx (hkey, REGSTR_VAL_UI_NUMBER, NULL, NULL,
                         (LPBYTE)&iUiNumber, &cbData);
	if (lErr == ERROR_SUCCESS)
        {
            if (iUiNumber >= MAX_INSTALLATIONS - 1)
            {
                TRACE_MSG(TF_ERROR, "Too many drivers installed.");  
                ASSERT(0);  
                goto skip;
            }
        
            g_wUsedNameArray[iUiNumber] = TRUE;
        }
        else
        {
            TRACE_MSG(TF_WARNING, "UI number value not found, trying search the FriendlyName");

            // Read the friendly name and add it to the list of used names.
            cbData = sizeof(szTemp);
            lErr = RegQueryValueEx (hkey, c_szFriendlyName, NULL, NULL,
                                    (LPBYTE)szTemp, &cbData);
            if (lErr != ERROR_SUCCESS)
            {
                TRACE_MSG(TF_WARNING, "FriendlyName not found");
	        goto skip;
            }

            if (!CplDiRecordNameInstance (szTemp, g_wUsedNameArray))
            {
                TRACE_MSG(TF_WARNING, "CplDiRecordNameInstance() failed.");
                goto skip;
            }
        }

skip:
	if (hkey)
	{
	    RegCloseKey(hkey);
            hkey = NULL;
        }
    }

    // Check for failed CplDiEnumDeviceInfo().
    if ((lErr = GetLastError()) != ERROR_NO_MORE_ITEMS)
    {
        TRACE_MSG(TF_ERROR, "CplDiEnumDeviceInfo() failed: %#08lx", lErr);
        ASSERT(0);
        goto exit;
    }

    // Pre-processing for duplicates has succeeded
    bRet = CplDiMarkForInstall(hdi, pdevData, &drvData, FALSE);

    if ((lErr = GetLastError()) != ERROR_SUCCESS)
    {
        TRACE_MSG(TF_ERROR, "CplDiMarkForInstall() failed: %#01lx", lErr);
        bSet = TRUE;
    }
        
    
exit:           
    if (hdiClass)
    {
        CplDiDestroyDeviceInfoList(hdiClass);
    }

    if (bSet)
    {
        SetLastError(lErr);
    }

    if (hkey)
    {
        RegCloseKey(hkey);
    }
   
    DBG_EXIT_BOOL_ERR(CplDiPreProcessNames, bRet);
    return bRet;
}

/*----------------------------------------------------------
Purpose: This function processes the set of modems that are
         already installed looking for a duplicate of the 
         selected driver.  Ports on which the device has been
         installed previously are removed from the given 
         ports list.  A list is created of the friendly name
         instance numbers that are already in use.  Selected 
         driver is marked for mass install barring fatal 
         error.

NOTE:    This function will return FALSE and avoid the mass
         install at the slighest hint of an error condition.
         Mass install is just an optimization - if it can't
         be done successfully it shouldn't be attempted.

Returns: TRUE if successful.  Selected Driver marked for mass
                install (whether or not there were dups).
         FALSE on fatal error - not able to process for dups.
         
Cond:    --
*/
BOOL
PUBLIC
CplDiPreProcessDups(
    IN      HDEVINFO            hdi,
    IN      HWND                hwndOwner,      OPTIONAL
    IN OUT  DWORD              *pdwNrPorts,
    IN OUT  LPTSTR FAR         *ppszPortList,   // Multi-string
    OUT     PSP_DEVINFO_DATA    pdevData,
    OUT     DWORD FAR          *lpcDups,
    OUT     DWORD FAR          *lpdwFlags)
{
 BOOL bRet;
 SP_DEVINFO_DATA devDataEnum = {sizeof(SP_DEVINFO_DATA), 0};
 SP_DRVINFO_DATA drvData = {sizeof(SP_DRVINFO_DATA), 0};
 HDEVINFO hdiClass = NULL;
 HKEY hkey = NULL;
 TCHAR szTemp[LINE_LEN];
 DWORD iIndex, cbData, cbPortList, cbRemaining, cbCurrent;
 LONG lErr;
 LPTSTR pszPort;
 DWORD iUiNumber;

    DBG_ENTER(CplDiPreProcessDups);

    ASSERT(lpcDups);
    ASSERT(lpdwFlags);
    ASSERT(pdwNrPorts);
    ASSERT(ppszPortList);
    
    *lpcDups = 0;
        
    // Get the DEVINFO_DATA for the selected driver and retrieve it's
    // identifying info (description, manufacturer, provider).
    
    // We have a DeviceInfoSet and a selected driver.  But we have no
    // real DeviceInfoData.  Given the DeviceInfoSet, the selected driver,
    // and the global class driver list, ....
    pdevData->cbSize = sizeof(*pdevData);
    bRet = CplDiCreateInheritDeviceInfo (hdi, NULL, hwndOwner, pdevData);
    if (!bRet)
    {
        TRACE_MSG(TF_ERROR, "CplDiCreateInheritDeviceInfo() failed: %#08lx", GetLastError());
        ASSERT(0);    
        goto exit;
    }
    
    // Get the DRVINFO_DATA for the selected driver.
    bRet = CplDiGetSelectedDriver(hdi, pdevData, &drvData);
    if (!bRet)
    {
        TRACE_MSG(TF_ERROR, "CplDiGetSelectedDriver() failed: %#08lx", GetLastError());    
        ASSERT(0);    
        goto exit;
    }

    // Assume failure at some point below.
    bRet = FALSE;   

    hdiClass = CplDiGetClassDevs (g_pguidModem, NULL, NULL, 0);
    if (hdiClass == INVALID_HANDLE_VALUE)
    {
        TRACE_MSG(TF_ERROR, "CplDiGetClassDevs() failed: %#08lx", GetLastError());
        hdiClass = NULL;
        goto exit;
    }

    if (!drvData.Description[0])
    {
        TRACE_MSG(TF_ERROR, "FAILED to get description for selected driver.");
        goto exit;
    }
    
    ZeroMemory(g_wUsedNameArray, sizeof(g_wUsedNameArray));
    
    // Figure out the size of the passed in ports list
    for (pszPort = *ppszPortList, cbPortList = 0;
         *pszPort != 0;
         pszPort += lstrlen(pszPort) + 1)
    {
        cbPortList += CbFromCch(lstrlen(pszPort)+1);
    }
    cbPortList += CbFromCch(1);   // double null terminator

    // Look through all installed modem devices for instances 
    // of the selected driver.
    for (iIndex = 0;
         CplDiEnumDeviceInfo(hdiClass, iIndex, &devDataEnum);
         iIndex++)
    {
        hkey = CplDiOpenDevRegKey (hdiClass, &devDataEnum, DICS_FLAG_GLOBAL,
                                   0, DIREG_DRV, KEY_READ);
        if (hkey == INVALID_HANDLE_VALUE)
        {
            TRACE_MSG(TF_WARNING, "CplDiOpenDevRegKey() failed: %#08lx", GetLastError());
            hkey = NULL;
            goto skip;
        }

        // The driver description should exist in the driver key.
        cbData = sizeof(szTemp);
        lErr = RegQueryValueEx (hkey, REGSTR_VAL_DRVDESC, NULL, NULL, 
                                (LPBYTE)szTemp, &cbData);
        if (lErr != ERROR_SUCCESS)
        {
            TRACE_MSG(TF_WARNING, "DriverDescription not found");
            goto skip;
        }

        // Skip this one if it isn't the right kind of modem
        if (!IsSzEqual(drvData.Description, szTemp))
            goto skip;

        // See what port it's on so it can be removed from the install ports
        // list.
        cbData = sizeof(szTemp);
        lErr = RegQueryValueEx (hkey, c_szAttachedTo, NULL, NULL,
                                (LPBYTE)szTemp, &cbData);
        if (lErr != ERROR_SUCCESS)
        {
            TRACE_MSG(TF_ERROR, 
                      "Failed to read port from REG driver node. (%#08lx)",
                      lErr);
            ASSERT(0);
            goto skip;
        }

        // Try to find this port in the install ports list.
        for (pszPort = *ppszPortList, cbRemaining = cbPortList;
             *pszPort != 0;
             pszPort += cbCurrent)
        {
            cbCurrent = lstrlen(pszPort) + 1;
            cbRemaining -= cbCurrent;
            // If it's already on a port that we're trying to (re)install
            // it on, remember the portlist index so it can be removed
            // later.  Remember the index as *1-based* so that the array of
            // saved indices can be processed by stopping at 0.
            if (IsSzEqual(szTemp, pszPort))
            {
                MoveMemory (pszPort, pszPort+cbCurrent, cbRemaining);
                cbPortList -= cbCurrent;
                --*pdwNrPorts;
                ++*lpcDups;
                break;
            }
        }        

	// Read the UI number and add it to the list
        cbData = sizeof(iUiNumber);
        RegQueryValueEx (hkey, REGSTR_VAL_UI_NUMBER, NULL, NULL,
                         (LPBYTE)&iUiNumber, &cbData);
	if (lErr == ERROR_SUCCESS)
        {
            if (iUiNumber >= MAX_INSTALLATIONS - 1)
            {
                TRACE_MSG(TF_ERROR, "Too many drivers installed.");  
                ASSERT(0);  
                goto skip;
            }
        
            g_wUsedNameArray[iUiNumber] = TRUE;
        }
        else
        {
            TRACE_MSG(TF_WARNING, "UI number value not found, try searching the FriendlyName");

            // Read the friendly name and add it to the list of used names.
            cbData = sizeof(szTemp);
            lErr = RegQueryValueEx (hkey, c_szFriendlyName, NULL, NULL,
                                    (LPBYTE)szTemp, &cbData);
            if (lErr != ERROR_SUCCESS)
            {
                TRACE_MSG(TF_WARNING, "FriendlyName not found");
                goto skip;
            }

            if (!CplDiRecordNameInstance (szTemp, g_wUsedNameArray))
            {
                TRACE_MSG(TF_WARNING, "CplDiRecordNameInstance() failed.");
                goto skip;
            }
        }

skip:
        if (hkey)
        {
            RegCloseKey(hkey);
            hkey = NULL;
        }
    }

    // Check for failed CplDiEnumDeviceInfo().
    if ((lErr = GetLastError()) != ERROR_NO_MORE_ITEMS)
    {
        TRACE_MSG(TF_ERROR, "CplDiEnumDeviceInfo() failed: %#08lx", lErr);
        ASSERT(0);
        goto exit;
    }

    // Pre-processing for duplicates has succeeded so this installation
    // will be treated like a mass install (even if the number of ports
    // remaining is < MIN_MULTIPORT).
    bRet = CplDiMarkForInstall(hdi, pdevData, &drvData, TRUE);
    if (bRet)
    {
        SetFlag(*lpdwFlags, IMF_MASS_INSTALL);
    }
    
exit:           
    if (hdiClass)
    {
        CplDiDestroyDeviceInfoList(hdiClass);
    }

    if (hkey)
    {
        RegCloseKey(hkey);
    }

    if (!bRet)
    {
        CplDiDeleteDeviceInfo(hdi, pdevData);
    }
        
    DBG_EXIT_BOOL_ERR(CplDiPreProcessDups, bRet);
    return bRet;
}


/*----------------------------------------------------------
Purpose: Creates a device instance for a modem that includes
         the entire class driver list.  This function then
         creates additional device instances that are cloned
         quickly from the original

Returns:
Cond:    --
*/
BOOL
PUBLIC
CplDiBuildModemDriverList(
    IN  HDEVINFO            hdi,
    IN  PSP_DEVINFO_DATA    pdevData)
    {
#pragma data_seg(DATASEG_READONLY)
    static TCHAR const FAR c_szProvider[]     = REGSTR_VAL_PROVIDER_NAME; // TEXT("ProviderName");
#pragma data_seg()

    BOOL bRet;
    SP_DRVINFO_DATA drvDataEnum;
    SP_DEVINSTALL_PARAMS devParams;

    DBG_ENTER(CplDiBuildModemDriverList);

    ASSERT(hdi && INVALID_HANDLE_VALUE != hdi);
    ASSERT(pdevData);

    // Build a global class driver list

    // Set the flag to focus on only classes that pertain to
    // modems.  This will keep CplDiBuildDriverInfoList from
    // slowing down any further once more INF files are added.
    //
    devParams.cbSize = sizeof(devParams);
    if (CplDiGetDeviceInstallParams(hdi, NULL, &devParams))
        {
        // Specify using our GUID to make things a little faster.
        SetFlag(devParams.FlagsEx, DI_FLAGSEX_USECLASSFORCOMPAT);

        // Set the Select Device parameters
        CplDiSetDeviceInstallParams(hdi, NULL, &devParams);
        }

    bRet = CplDiBuildDriverInfoList(hdi, NULL, SPDIT_CLASSDRIVER);

    if (bRet)
        {
        SP_DRVINFO_DATA drvData;
        TCHAR szDescription[LINE_LEN];
        TCHAR szMfgName[LINE_LEN];
        TCHAR szProviderName[LINE_LEN];

        // Get the information needed to search for a matching driver
        // in the class driver list.  We need three strings:
        //
        //  Description
        //  MfgName
        //  ProviderName  (optional)
        //
        // The Description and MfgName are properties of the device
        // (SPDRP_DEVICEDESC and SPDRP_MFG).  The ProviderName is
        // stored in the driver key.

        // Try getting this info from the selected driver first.
        // Is there a selected driver?
        drvData.cbSize = sizeof(drvData);
        bRet = CplDiGetSelectedDriver(hdi, pdevData, &drvData);
        if (bRet)
            {
            // Yes
            lstrcpyn(szMfgName, drvData.MfgName, SIZECHARS(szMfgName));
            lstrcpyn(szDescription, drvData.Description, SIZECHARS(szDescription));
            lstrcpyn(szProviderName, drvData.ProviderName, SIZECHARS(szProviderName));
            }
        else
            {
            // No; grovel in the driver key
            DWORD dwType;
            HKEY hkey;

            hkey = CplDiOpenDevRegKey(hdi, pdevData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ);
            if (INVALID_HANDLE_VALUE == hkey)
                {
                bRet = FALSE;
                }
            else
                {
                DWORD cbData = sizeof(szProviderName);

                // Get the provider name
                *szProviderName = 0;
                RegQueryValueEx(hkey, c_szProvider, NULL, NULL,
                                (LPBYTE)szProviderName, &cbData);
                RegCloseKey(hkey);

                // Get the device description and manufacturer
                bRet = CplDiGetDeviceRegistryProperty(hdi, pdevData,
                            SPDRP_DEVICEDESC, &dwType, (LPBYTE)szDescription,
                            sizeof(szDescription), NULL);

                if (bRet)
                    {
                    bRet = CplDiGetDeviceRegistryProperty(hdi, pdevData,
                            SPDRP_MFG, &dwType, (LPBYTE)szMfgName,
                            sizeof(szMfgName), NULL);
                    }
                }
            }


        // Could we get the search criteria?
        if (bRet)
            {
            // Yes
            DWORD iIndex = 0;

            bRet = FALSE;       // Assume there is no match

            // Find the equivalent selected driver in this new
            // compatible driver list, and set it as the selected
            // driver for this new DeviceInfoData.

            drvDataEnum.cbSize = sizeof(drvDataEnum);
            while (CplDiEnumDriverInfo(hdi, NULL, SPDIT_CLASSDRIVER,
                                       iIndex++, &drvDataEnum))
                {
                // Is this driver a match?
                if (IsSzEqual(szDescription, drvDataEnum.Description) &&
                    IsSzEqual(szMfgName, drvDataEnum.MfgName) &&
                    (0 == *szProviderName ||
                     IsSzEqual(szProviderName, drvDataEnum.ProviderName)))
                    {
                    // Yes; set this as the selected driver
                    bRet = CplDiSetSelectedDriver(hdi, NULL, &drvDataEnum);
                    break;
                    }
                }
            }
        }

    DBG_EXIT_BOOL_ERR(CplDiBuildModemDriverList, bRet);

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Sets the modem detection signature (if there is one)
         and registers the device instance.

Returns: TRUE on success
Cond:    --
*/
BOOL
PUBLIC
CplDiRegisterModem(
    IN  HDEVINFO            hdi,
    IN  PSP_DEVINFO_DATA    pdevData,
    IN  BOOL                bFindDups)
{
 BOOL bRet = FALSE;
 DWORD dwFlags = bFindDups ? SPRDI_FIND_DUPS : 0;
 COMPARE_PARAMS cmpParams;
#ifdef PROFILE
 DWORD dwLocal;
#endif //PROFILE

    DBG_ENTER(CplDiRegisterModem);

    ASSERT(hdi && INVALID_HANDLE_VALUE != hdi);
    ASSERT(pdevData);

    // Register the device so it is not a phantom anymore
#ifdef PROFILE_MASSINSTALL
    TRACE_MSG(TF_GENERAL, "calling CplDiRegisterDeviceInfo() with SPRDI_FIND_DUPS = %#08lx", dwFlags);
#endif
#ifdef PROFILE
    dwLocal = GetTickCount ();
#endif //PROFILE
    if (bFindDups && !InitCompareParams (hdi, pdevData, TRUE, &cmpParams))
    {
        goto _return;
    }

    bRet = CplDiRegisterDeviceInfo(hdi, pdevData, dwFlags,
                                   DetectSig_Compare, 
                                   bFindDups?(PVOID)&cmpParams:NULL, NULL);
#ifdef PROFILE
    TRACE_MSG(TF_GENERAL, "PROFILE: SetupDiRegisterDeviceInfo took %lu ms.", GetTickCount() - dwLocal);
#endif //PROFILE

    if ( !bRet )
    {
        TRACE_MSG(TF_ERROR, "Failed to register the Device Instance.  Error=%#08lx.", GetLastError());
    }
    else
    {
#ifdef PROFILE_MASSINSTALL
        TRACE_MSG(TF_GENERAL, "Back from CplDiRegisterDeviceInfo().");
#endif
        // Mark it so it will be installed
        CplDiMarkModem(hdi, pdevData, MARKF_INSTALL);
    }

_return:
    DBG_EXIT_BOOL_ERR(CplDiRegisterModem, bRet);

    return bRet;
}


/*----------------------------------------------------------
Purpose: Takes a device instance and properly installs it.
         This function assures that the device has a selected
         driver and a detection signature.  It also registers
         the device instance.

Returns: TRUE on success
Cond:    --
*/
BOOL
PUBLIC
CplDiRegisterAndInstallModem(
    IN  HDEVINFO            hdi,
    IN  HWND                hwndOwner,      OPTIONAL
    IN  PSP_DEVINFO_DATA    pdevData,       OPTIONAL
    IN  LPCTSTR             pszPort,
    IN  DWORD               dwFlags)
{
 BOOL bRet;
 SP_DRVINFO_DATA drvData;
 SP_DEVINFO_DATA devData;
 int id;

    DBG_ENTER(CplDiRegisterAndInstallModem);

    ASSERT(hdi && INVALID_HANDLE_VALUE != hdi);
    ASSERT(pszPort);

    // Create the devinfo data if it wasn't given.
    if (!pdevData)
    {
        // We have a DeviceInfoSet and a selected driver.  But we have no
        // real DeviceInfoData.  Given the DeviceInfoSet, the selected driver,
        // the the global class driver list, create a DeviceInfoData that
        // we can really install.
        devData.cbSize = sizeof(devData);
        bRet = CplDiCreateInheritDeviceInfo(hdi, NULL, hwndOwner, &devData);

        if (bRet && IsFlagSet(dwFlags, IMF_MASS_INSTALL))
        {
            drvData.cbSize = sizeof(drvData);
            CplDiGetSelectedDriver(hdi, NULL, &drvData);
            CplDiMarkForInstall(hdi, &devData, &drvData, TRUE);
        }
    }
    else 
    {
        devData = *pdevData;    // (to avoid changing all references herein)
        bRet = TRUE;
    }
    
    if ( !bRet )
    {
        // Some error happened.  Tell the user.
        id = MsgBox(g_hinst,
                    hwndOwner,
                    MAKEINTRESOURCE(IDS_ERR_CANT_ADD_MODEM2),
                    MAKEINTRESOURCE(IDS_CAP_MODEMSETUP),
                    NULL,
                    MB_OKCANCEL | MB_ICONINFORMATION);
        if (IDCANCEL == id)
        {
            SetLastError(ERROR_CANCELLED);
        }
    }
    else
    {
     DWORD nErr = NO_ERROR;
     DWORD dwRet;

        if (bRet)
        {
            // Register the device as a modem device
	        BOOL bFindDups;
            HKEY hKeyDev;

            if (CR_SUCCESS == (
#ifdef DEBUG
				dwRet =
#endif //DEBUG
                CM_Open_DevInst_Key (devData.DevInst, KEY_ALL_ACCESS, 0,
                                     RegDisposition_OpenAlways, &hKeyDev,
                                     CM_REGISTRY_SOFTWARE)))
            {
                if (ERROR_SUCCESS != (dwRet =
                    RegSetValueEx (hKeyDev, c_szAttachedTo, 0, REG_SZ,
                                   (PBYTE)pszPort, (lstrlen(pszPort)+1)*sizeof(TCHAR))))
                {
                    SetLastError (dwRet);
                    bRet = FALSE;
                }
                RegCloseKey (hKeyDev);
            }
            else
            {
				TRACE_MSG(TF_ERROR, "CM_Open_DevInst_Key failed: %#lx.", dwRet);
                bRet = FALSE;
            }

            if (bRet)
            {
                // If this is the mass install case, then don't find duplicates.
                // It takes too long.  (The flag determines whether SPRDI_FIND_DUPS
                // is passed to CplDiRegisterDeviceInfo()....)
                bFindDups = IsFlagClear(dwFlags, IMF_MASS_INSTALL) && IsFlagClear(dwFlags, IMF_DONT_COMPARE);

                bRet = CplDiRegisterModem (hdi, &devData, bFindDups);
            }

            if ( !bRet )
            {
                SP_DRVINFO_DATA drvData2;

                nErr = GetLastError();        // Save the error

                drvData2.cbSize = sizeof(drvData2);
                CplDiGetSelectedDriver(hdi, &devData, &drvData2);

                // Is this a duplicate?
                if (ERROR_DUPLICATE_FOUND == nErr)
                {
                    // Yes

                    // A modem exactly like this is already installed on this
                    // port.  Ask the user if she still wants to install.
                    if (IsFlagSet(dwFlags, IMF_CONFIRM))
                    {
                        if (IDYES == MsgBox(g_hinst,
                                        hwndOwner,
                                        MAKEINTRESOURCE(IDS_WRN_DUPLICATE_MODEM),
                                        MAKEINTRESOURCE(IDS_CAP_MODEMSETUP),
                                        NULL,
                                        MB_YESNO | MB_ICONWARNING,
                                        drvData2.Description,
                                        pszPort))
                        {
                            // User wants to do it.  Register without checking
                            // for duplicates
                            bRet = CplDiRegisterModem(hdi, &devData, FALSE);

                            if ( !bRet )
                            {
                                goto WhineToUser;
                            }
                        }

                    }
                }
                else
                {
                    // No; something else failed
                    TRACE_MSG(TF_ERROR, "CplDiRegisterModem() failed: %#08lx.", nErr);

WhineToUser:
                    id = MsgBox(g_hinst,
                                hwndOwner,
                                MAKEINTRESOURCE(IDS_ERR_REGISTER_FAILED),
                                MAKEINTRESOURCE(IDS_CAP_MODEMSETUP),
                                NULL,
                                MB_OKCANCEL | MB_ICONINFORMATION,
                                drvData2.Description,
                                pszPort);
                    if (IDCANCEL == id)
                    {
                        nErr = ERROR_CANCELLED;
                    }
                }
            }

            if (bRet)
            {
					SP_DEVINSTALL_PARAMS devParams;
					devParams.cbSize = sizeof(devParams);
                    // Any flags to set?
                    if (dwFlags && CplDiGetDeviceInstallParams(
										hdi,
										&devData,
										&devParams
										))
                    {
						DWORD dwExtraMarkFlags = 0;
 						if (IsFlagSet(dwFlags, IMF_QUIET_INSTALL))
						{
								SetFlag(devParams.Flags, DI_QUIETINSTALL);
						}
 						if (IsFlagSet(dwFlags, IMF_REGSAVECOPY))
						{
							dwExtraMarkFlags = MARKF_REGSAVECOPY;
						}
						else if (IsFlagSet(dwFlags, IMF_REGUSECOPY))
						{
							dwExtraMarkFlags = MARKF_REGUSECOPY;
						}
						if (dwExtraMarkFlags)
						{
        					SetFlag(
								devParams.ClassInstallReserved,
								dwExtraMarkFlags
								);
						}
                        
                    	CplDiSetDeviceInstallParams(hdi, &devData, &devParams);
                    }


                // Install the modem
                bRet = CplDiInstallModem(hdi, &devData, FALSE);
                nErr = GetLastError();
            }
        }

        // Did anything above fail?
        if (!bRet &&
            NULL == pdevData)
        {
            // Yes; clean up
            CplDiDeleteDeviceInfo(hdi, &devData);
        }

        if (NO_ERROR != nErr)
        {
            // Set the last error to be what it really was
            SetLastError(nErr);
        }
    }

    DBG_EXIT_BOOL_ERR(CplDiRegisterAndInstallModem, bRet);

    return bRet;
}


/*----------------------------------------------------------
Purpose: Warn the user about whether she needs to reboot
         if any of the installed modems was marked as such.

Returns: --
Cond:    --
*/
void
PRIVATE
WarnUserAboutReboot(
    IN HDEVINFO hdi)
    {
    DWORD iDevice;
    SP_DEVINFO_DATA devData;
    SP_DEVINSTALL_PARAMS devParams;

    // Enumerate all the DeviceInfoData elements in this device set
    devData.cbSize = sizeof(devData);
    devParams.cbSize = sizeof(devParams);
    iDevice = 0;


    while (CplDiEnumDeviceInfo(hdi, iDevice++, &devData))
        {
        if (CplDiGetDeviceInstallParams(hdi, &devData, &devParams))
            {
            if (ReallyNeedsReboot(&devData, &devParams))
                {
#ifdef INSTANT_DEVICE_ACTIVATION
                    gDeviceFlags|= fDF_DEVICE_NEEDS_REBOOT;
#endif //!INSTANT_DEVICE_ACTIVATION
                // Yes; tell the user (once)
                /*MsgBox(g_hinst,
                       devParams.hwndParent,
                       MAKEINTRESOURCE(IDS_WRN_REBOOT2),
                       MAKEINTRESOURCE(IDS_CAP_MODEMSETUP),
                       NULL,
                       MB_OK | MB_ICONINFORMATION);*/

                break;
                }
            }
        }
    }


/*----------------------------------------------------------
Purpose: Takes a device instance and properly installs it.
         This function assures that the device has a selected
         driver and a detection signature.  It also registers
         the device instance.

         The pszPort parameter is a multi-string (ie, double-
         null termination).  This specifies the port the
         modem should be attached to.  If there are multiple
         ports specified, then this function creates device
         instances for each port.  However in the mass modem
         install case, it will preprocess the ports list and
         remove ports on which the selected modem is already 
         installed.  This is done here because it's too 
         expensive (for many ports i.e. > 100) to turn on the
         SPRDI_FIND_DUPS flag and let the setup api's do it.
         The caller's ports list is *modified* in this case.

Returns: TRUE on success
Cond:    --
*/
BOOL
APIENTRY
CplDiInstallModemFromDriver(
    IN     HDEVINFO            hdi,
    // 07/16/97 - EmanP
    // added DevInfoData as a new parameter; this is
    // passed in by the hardware wizard, and contains
    // information which is needed in this case; parameter
    // will be NULL at other times
    IN     PSP_DEVINFO_DATA    pDevInfo,       OPTIONAL
    IN     HWND                hwndOwner,      OPTIONAL
    IN OUT DWORD              *pdwNrPorts,
    IN OUT LPTSTR FAR *        ppszPortList,   // Multi-string
    IN     DWORD               dwFlags)        // IMF_ bit field
{
 BOOL bRet = FALSE;

    DBG_ENTER(CplDiInstallModemFromDriver);

    ASSERT(hdi && INVALID_HANDLE_VALUE != hdi);
    ASSERT(*ppszPortList);

    try
    {
     LPCTSTR pszPort;
     DWORD cPorts = *pdwNrPorts;
     DWORD cFailedPorts = 0;
     DWORD cSkippedPorts = 0;
     TCHAR rgtchStatusTemplate[256];
     DWORD cchStatusTemplate=0;
     BOOL  bFirstGood = TRUE;
     SP_DEVINFO_DATA devData;
     PSP_DEVINFO_DATA pdevData = NULL;
     BOOL bAllDups = FALSE;
     BOOL bSingleInstall = (1 == cPorts);

        // 07/24/1997 - EmanP
        // this will move the driver selected into the device info
        // to the device info set
        if (!CplDiPreProcessHDI (hdi, pDevInfo))
        {
            TRACE_MSG(TF_ERROR, "CplDiPreProcessHDI failed: %#lx", GetLastError ());
            goto _Exit;
        }

        if (MIN_MULTIPORT < cPorts)
        {
            // This call sets up the mass install case if it succeeds.
            if (CplDiPreProcessDups (hdi, hwndOwner, &cPorts, ppszPortList,
                                     &devData, &cSkippedPorts, &dwFlags))
            {
                pdevData = &devData;
                if ((*ppszPortList)[0] == 0)
                    bAllDups = TRUE;
            }
        }
    
        if ( !bSingleInstall && !bAllDups )
        {
			if (LoadString (g_hinst, IDS_INSTALL_STATUS,
					        rgtchStatusTemplate, SIZECHARS(rgtchStatusTemplate)))
			{
				cchStatusTemplate = lstrlen(rgtchStatusTemplate);
			}
            SetFlag(dwFlags, IMF_QUIET_INSTALL);
            ClearFlag(dwFlags, IMF_CONFIRM);
            SetFlag(dwFlags, IMF_REGSAVECOPY);
			{
				DWORD PRIVATE RegDeleteKeyNT(HKEY, LPCTSTR);
				LPCTSTR szREGCACHE =
								REGSTR_PATH_SETUP TEXT("\\Unimodem\\RegCache");
				RegDeleteKeyNT(HKEY_LOCAL_MACHINE, szREGCACHE);
			}
        }

        // Install a device for each port in the port list
        cPorts = 0;
        for (pszPort = *ppszPortList; 
             0 != *pszPort;
             pdevData = NULL,pszPort += lstrlen(pszPort)+1)
        {
		 TCHAR rgtchStatus[256];

#ifdef PROFILE_MASSINSTALL            
    g_dwTimeStartModemInstall = GetTickCount();
#endif

			// "cchStatusTemplate+lstrlen(pszPort)" slightly overestimates
			// the size of the formatted result, that's OK.
			if (cchStatusTemplate &&
                (cchStatusTemplate+lstrlen(pszPort))<SIZECHARS(rgtchStatus))
			{
				wsprintf(rgtchStatus, rgtchStatusTemplate, pszPort);
            	Install_SetStatus(hwndOwner, rgtchStatus);
			}

            bRet = CplDiRegisterAndInstallModem (hdi, hwndOwner, pdevData,
                                                 pszPort, dwFlags);

            if ( !bRet )
            {
             DWORD dwErr = GetLastError();

                cFailedPorts++;

                if (NULL != pdevData)
                {
                    SetupDiDeleteDeviceInfo (hdi, pdevData);
                }

                if (ERROR_CANCELLED == dwErr)
                {
                    // Stop because the user said so
                    break;
                }
                else if (ERROR_DUPLICATE_FOUND == dwErr)
                {
                    cSkippedPorts++;
                }
            }
		    else
			{
                cPorts++;
				if (bFirstGood && !bSingleInstall)
				{
				    // This is the 1st good install. From now on, specify the
				    // IMF_REGUSECOPY flag.
                    ClearFlag(dwFlags, IMF_REGSAVECOPY);
                    SetFlag(dwFlags, IMF_REGUSECOPY);
				    bFirstGood = FALSE;
				}
			}
#ifdef PROFILE_MASSINSTALL            
TRACE_MSG(TF_GENERAL, "***---------  %lu ms to install ONE modem  ---------***",
                GetTickCount() - g_dwTimeStartModemInstall);
TRACE_MSG(TF_GENERAL, "***---------  %lu ms TOTAL time spent installing modems  ---------***",
                GetTickCount() - g_dwTimeBegin);
#endif

        }

// ???: bRet could be either TRUE or FALSE here!!!

        if (cPorts > cFailedPorts)
        {
#ifdef PROFILE_MASSINSTALL            
TRACE_MSG(TF_GENERAL, "*** Friendly Name generation took %lu ms out of %lu ms total install time",
            g_dwTimeSpent, GetTickCount() - g_dwTimeBegin);
#endif
            
            // At least some modems were installed
            bRet = TRUE;
        }

        if (0 < cSkippedPorts && IsFlagClear(dwFlags, IMF_CONFIRM))
        {
            // Tell the user we skipped some ports
            MsgBox(g_hinst,
                    hwndOwner,
                    MAKEINTRESOURCE(IDS_WRN_SKIPPED_PORTS),
                    MAKEINTRESOURCE(IDS_CAP_MODEMSETUP),
                    NULL,
                    MB_OK | MB_ICONINFORMATION);
        }

_Exit:;
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        bRet = FALSE;
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    DBG_EXIT_BOOL_ERR(CplDiInstallModemFromDriver, bRet);

    return bRet;
}

/*----------------------------------------------------------
Purpose: Does all the dirty work to detect a modem.

Returns: TRUE on success
Cond:    --
*/
BOOL
APIENTRY
CplDiDetectModem(
    IN     HDEVINFO         hdi,
    // 07/07/97 - EmanP
    // added PSP_DEVINFO_DATA as a new parameter;
    // it is needed because
    // the hdi we get as a first parameter is not always associated
    // with the CLSID for the modem (for instance, when we are called
    // from the hardware wizard - newdev.cpl- ); in this case,
    // this parameter will not be NULL
    IN     PSP_DEVINFO_DATA DeviceInfoData,
    IN     LPDWORD          pdwInstallFlags,
    IN     PDETECT_DATA     pdetectdata,    OPTIONAL
    IN     HWND             hwndOwner,      OPTIONAL
    IN OUT LPDWORD          pdwFlags,                   // DMF_ bit field
    IN     HANDLE           hThreadPnP)                 // OPTIONAL
{
    BOOL bRet;

    DBG_ENTER(CplDiDetectModem);

    ASSERT(hdi && INVALID_HANDLE_VALUE != hdi);
    ASSERT(pdwFlags);

    try
    {
     DWORD dwFlags = *pdwFlags;

        ClearFlag(dwFlags, DMF_CANCELLED);
        ClearFlag(dwFlags, DMF_DETECTED_MODEM);
        ClearFlag(dwFlags, DMF_GOTO_NEXT_PAGE);

        // Use the given device info set as the set of detected modem
        // devices.  This device set will be empty at first.  When
        // detection is finished, we'll see if anything was added to
        // the set.

        if (pdetectdata != NULL)
        {
            CplDiSetClassInstallParams (hdi, NULL,
                &pdetectdata->DetectParams.ClassInstallHeader,
                sizeof(pdetectdata->DetectParams));
         }

        // Set the quiet flag?
        if (IsFlagSet(dwFlags, DMF_QUIET))
        {
            // Yes
         SP_DEVINSTALL_PARAMS devParams;

            devParams.cbSize = sizeof(devParams);
            // 07/07/97 - EmanP
            // use the passed in DeviceInfoData
            // instead of NULL
            if (CplDiGetDeviceInstallParams(hdi, DeviceInfoData, &devParams))
            {
                SetFlag(devParams.Flags, DI_QUIETINSTALL);
                // 07/07/97 - EmanP
                // use the passed in DeviceInfoData
                // instead of NULL
                CplDiSetDeviceInstallParams(hdi, DeviceInfoData, &devParams);
            }
        }

        // At this point, wait for PnP detection / installation
        // to finish.
        if (NULL != hThreadPnP)
        {
         MSG msg;
         DETECTCALLBACK dc = {pdetectdata->pfnCallback,pdetectdata->lParam};
         DWORD dwWaitRet;

            DetectSetStatus (&dc, DSS_ENUMERATING);

            while (1)//0 == (*pdwInstallFlags & SIF_DETECT_CANCEL))
            {
                dwWaitRet = MsgWaitForMultipleObjects (1, &hThreadPnP, FALSE, INFINITE, QS_ALLINPUT);
                if (WAIT_OBJECT_0+1 == dwWaitRet)
                {
                    // There are messages; process them.
                    while (PeekMessage (&msg, NULL, 0, 0, PM_REMOVE))
                    {
                        TranslateMessage (&msg);
                        DispatchMessage (&msg);
                    }
                }
                else
                {
                    // Something else caused the wait to finish;
                    // either the thread we're waiting on exited,
                    // or some other condition. Anyway, the waiting
                    // is over.
                    break;
                }
            }
        }

        // Start detection
        // 07/07/97 - EmanP
        // use the passed in DeviceInfoData
        // instead of NULL
        if (*pdwInstallFlags & SIF_DETECT_CANCEL)
        {
            bRet = FALSE;
            SetLastError (ERROR_CANCELLED);
        }
        else
        {
            bRet = CplDiCallClassInstaller(DIF_DETECT, hdi, DeviceInfoData);
        }

        if (bRet)
        {
         SP_DEVINFO_DATA devData;
         DWORD iDevice = 0;

            // Find the first detected modem (if there is one) in
            // the set.
            devData.cbSize = sizeof(devData);
            while (CplDiEnumDeviceInfo(hdi, iDevice++, &devData))
            {
                if (CplDiCheckModemFlags(hdi, &devData, MARKF_DETECTED, 0))
                {
                    SetFlag(dwFlags, DMF_DETECTED_MODEM);
                    break;
                }
            }

            SetFlag(dwFlags, DMF_GOTO_NEXT_PAGE);
        }

        // Did the user cancel detection?
        else if (ERROR_CANCELLED == GetLastError())
        {
            // Yes
            SetFlag(dwFlags, DMF_CANCELLED);
        }
        else
        {
            // 07/07/97 - EmanP
            // Some other error, the modem was not detected,
            // so go to the next page
            SetFlag(dwFlags, DMF_GOTO_NEXT_PAGE);
        }

        *pdwFlags = dwFlags;
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        bRet = FALSE;
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    DBG_EXIT_BOOL_ERR(CplDiDetectModem, bRet);

    return bRet;
}


/*----------------------------------------------------------
Purpose: Perform an unattended manual installation of the
         modems specified in the given INF file section.

Returns: --
Cond:    --
*/
BOOL
PRIVATE
GetInfModemData(
    HINF hInf,
    LPTSTR szSection,
    LPTSTR szPreferredFriendlyPort, // OPTIONAL
    LPMODEM_SPEC lpModemSpec,
    HPORTMAP    hportmap,
    LPBOOL      lpbFatal
    )
{
    BOOL        bRet = FALSE;       // assume failure
    INFCONTEXT  Context;
    TCHAR       szInfLine[LINE_LEN];
    LPTSTR      lpszValue;
    DWORD       dwReqSize;
    static LONG lLineCount = -1;    // flag that count hasn't been obtained yet
    TCHAR rgtchFriendlyPort[LINE_LEN];

    ZeroMemory(lpModemSpec, sizeof(MODEM_SPEC));

    *lpbFatal=FALSE;

    if (szPreferredFriendlyPort && *szPreferredFriendlyPort)
    {
        // Preferred port specified -- look for exactly that port. Not fatal
        // if you don't find it...

        bRet = SetupFindFirstLine(
                    hInf,
                    szSection,
                    szPreferredFriendlyPort,
                    &Context
                    );
        if (!bRet) goto exit;
    }
    else
    {

        if (lLineCount == -1)
        {
            if ((lLineCount = SetupGetLineCount(hInf, szSection)) < 1)
            {
                TRACE_MSG(TF_ERROR, "SetupGetLineCount() failed or found no lines");
                goto exit;
            }
        }

        // make a 0-based index out of it / decrement for next line
        if (lLineCount-- == 0L)
        {
            // no more lines
            goto exit;
        }

        // get the line
        if (!SetupGetLineByIndex(hInf, szSection, lLineCount, &Context))
        {
            TRACE_MSG(TF_ERROR, "SetupGetLineByIndex(): line %#08lX doesn't exist", lLineCount);
            goto exit;
        }
    }

    *lpbFatal=TRUE;
    bRet = FALSE;       // assume failure once again
    
    // read the key (port #)
    if (!SetupGetStringField(&Context, FIELD_PORT, rgtchFriendlyPort,
                                    ARRAYSIZE(rgtchFriendlyPort), &dwReqSize))
    {
        TRACE_MSG(TF_ERROR, "SetupGetStringField() failed: %#08lx", GetLastError());
        gUnattendFailID = IDS_ERR_UNATTEND_INF_NOPORT;
        goto exit;
    }
    ASSERT(
        !szPreferredFriendlyPort
        ||  !*szPreferredFriendlyPort 
        ||  !lstrcmpi(szPreferredFriendlyPort,  rgtchFriendlyPort)
        );

    if (!PortMap_GetPortName(
            hportmap,
            rgtchFriendlyPort,
            lpModemSpec->szPort,
            ARRAYSIZE(lpModemSpec->szPort)
            ))
    {
        TRACE_MSG(
            TF_ERROR,
            "Can't find port %s in portmap.",
            rgtchFriendlyPort
            );
        gUnattendFailID = IDS_ERR_UNATTEND_INF_NOSUCHPORT;
        goto exit;
    }

    // read the modem description
    if (!SetupGetStringField(&Context, FIELD_DESCRIPTION,
            lpModemSpec->szDescription, ARRAYSIZE(lpModemSpec->szDescription),
             &dwReqSize))
    {
        TRACE_MSG(TF_ERROR, "SetupGetStringField() failed: %#08lx", GetLastError());
        gUnattendFailID = IDS_ERR_UNATTEND_INF_NODESCRIPTION;
        goto exit;
    }

    // read the manufacturer name, if it exists
    if (!SetupGetStringField(&Context, FIELD_MANUFACTURER,
            lpModemSpec->szManufacturer, ARRAYSIZE(lpModemSpec->szManufacturer),
            &dwReqSize))
    {
        TRACE_MSG(TF_WARNING, "no manufacturer specified (%#08lx)", GetLastError());
        // optional field: don't return error
    }

    // read the provider name, if it exists
    if (!SetupGetStringField(&Context, FIELD_PROVIDER, lpModemSpec->szProvider,
                            ARRAYSIZE(lpModemSpec->szProvider), &dwReqSize))
    {
        TRACE_MSG(TF_WARNING, "no provider specified (%#08lx)", GetLastError());
        // optional field: don't return error
    }

    *lpbFatal=FALSE;
    bRet = TRUE;

exit:
    return(bRet);
}


/*----------------------------------------------------------
Purpose: Perform an unattended manual installation of the
         modems specified in the given INF file section.

Returns: --
Cond:    --
*/
BOOL
PRIVATE
UnattendedManualInstall(
    HWND hwnd,
    LPINSTALLPARAMS lpip,
    HDEVINFO hdi,
    BOOL *pbDetect,
    HPORTMAP    hportmap
    )
{
    BOOL            bRet = FALSE;       // assume failure
    BOOL            bIsModem = FALSE;   // assume INF gives no modems
    BOOL            bEnum, bFound;
    HINF            hInf = NULL;
    MODEM_SPEC      mSpec;
    SP_DRVINFO_DATA drvData;
    DWORD           dwIndex, dwErr;
    BOOL            bFatal=FALSE;

    ASSERT(pbDetect);
    *pbDetect  = FALSE;
    
    hInf = SetupOpenInfFile (lpip->szInfName, NULL, INF_STYLE_OLDNT, NULL);

    if (hInf == INVALID_HANDLE_VALUE)
    {
        TRACE_MSG(TF_ERROR, "SetupOpenInfFile() failed: %#08lx", GetLastError());
        MsgBox(g_hinst, hwnd,
               MAKEINTRESOURCE(IDS_ERR_CANT_OPEN_INF_FILE),
               MAKEINTRESOURCE(IDS_CAP_MODEMSETUP),
               NULL,
               MB_OK | MB_ICONEXCLAMATION,
               lpip->szInfName);
        hInf = NULL;
        goto exit;
    }

    if (!CplDiBuildDriverInfoList(hdi, NULL, SPDIT_CLASSDRIVER))
    {
        TRACE_MSG(TF_ERROR, "CplDiBuildDriverInfoList() failed: %#08lx", GetLastError());
        gUnattendFailID = IDS_ERR_UNATTEND_DRIVERLIST;
        goto exit;
    }

    drvData.cbSize = sizeof(drvData);

    // process each line in our INF file section
    while (GetInfModemData(hInf, lpip->szInfSect, lpip->szPort, &mSpec, hportmap, &bFatal))
    {
        // a modem was specified in the INF
        bIsModem = TRUE;
        
        // search for a match against all drivers
        bFound = FALSE;
        dwIndex = 0;
        while (bEnum = CplDiEnumDriverInfo(hdi, NULL, SPDIT_CLASSDRIVER,
                                                        dwIndex++, &drvData))
        {
            // keep looking if driver's not a match
            if (!IsSzEqual(mSpec.szDescription, drvData.Description))
                continue;

            // description matches, now check manufacturer if there is one
            if (!IsSzEqual(mSpec.szManufacturer, TEXT("\0")) &&
                !IsSzEqual(mSpec.szManufacturer, drvData.MfgName))
                continue;

            // manufacturer matches, now check provider if there is one
            if (!IsSzEqual(mSpec.szProvider, TEXT("\0")) &&
                !IsSzEqual(mSpec.szProvider, drvData.ProviderName))
                continue;

            bFound = TRUE;

            // found a match; set this as the selected driver & install it
            if (!CplDiSetSelectedDriver(hdi, NULL, &drvData))
            {
                TRACE_MSG(TF_ERROR, "CplDiSetSelectedDriver() failed: %#08lx",
                          GetLastError());
                // can't install; get out of here quick.
                goto exit;
            }

            if (!CplDiRegisterAndInstallModem(hdi, NULL, NULL, mSpec.szPort,
                                                        IMF_QUIET_INSTALL))
            {
                DWORD dwErr2 = GetLastError();
                if (ERROR_DUPLICATE_FOUND != dwErr2)
                {
                    TRACE_MSG(
                        TF_ERROR,
                        "CplDiRegisterAndInstallModem() failed: %#08lx",
                         dwErr2
                         );
                    gUnattendFailID = IDS_ERR_UNATTEND_CANT_INSTALL;
                    goto exit;
                }
                // Treate a duplicate-found error as no error.
            }

            break;
        }

        // Did CplDiEnumDriverInfo() fail on error other than "end of list"?
        if ((!bEnum) && ((dwErr = GetLastError()) != ERROR_NO_MORE_ITEMS))
        {
            TRACE_MSG(TF_ERROR, "CplDiEnumDriverInfo() failed: %#08lx", dwErr);
            goto exit;
        }

        if (!bFound)
        {
            MsgBox(g_hinst, hwnd,
                   MAKEINTRESOURCE(IDS_ERR_CANT_FIND_MODEM),
                   MAKEINTRESOURCE(IDS_CAP_MODEMSETUP),
                   NULL,
                   MB_OK | MB_ICONEXCLAMATION,
                   mSpec.szPort, mSpec.szDescription);
            goto exit;
        }

        // If port spefied, only try on specified port.
        if (*(lpip->szPort)) break;
    }

    if (bFatal) goto exit;

    // Request detection if everything succeeded but the INF didn't specify
    // any modems.
    *pbDetect  = !bIsModem;
        
    bRet = TRUE;

exit:
    if (hInf)
        SetupCloseInfFile(hInf);

    return(bRet);

}


/*----------------------------------------------------------
Purpose: Perform an unattended (UI-less) install.  UI can only be
         displayed in the case of a critical error.

Returns: --
Cond:    --
*/
BOOL
PUBLIC
UnattendedInstall(HWND hwnd, LPINSTALLPARAMS lpip)
{
 BOOL        bRet = FALSE;   // assume failure
 HDEVINFO    hdi = NULL;
 DWORD       dwFlags = 0;
 DETECT_DATA dd;
 HPORTMAP    hportmap=NULL;
 DWORD       dwPorts;
 BOOL        bInstalled;

    DBG_ENTER(UnattendedInstall);

    gUnattendFailID = IDS_ERR_UNATTEND_GENERAL_FAILURE;

    if (!CplDiGetModemDevs(&hdi, NULL, DIGCF_PRESENT, &bInstalled))
    {
           goto exit;
    }

    if (!PortMap_Create(&hportmap))
    {
        gUnattendFailID = IDS_ERR_UNATTEND_NOPORTS;
        hportmap=NULL;
        goto exit;
    } 

    dwPorts = PortMap_GetCount(hportmap);

    if (!dwPorts)
    {
        gUnattendFailID = IDS_ERR_UNATTEND_NOPORTS;
        goto exit;
    }

    // Do a "manual" install if we were given an INF file and section.
    if (lstrlen(lpip->szInfName) && lstrlen(lpip->szInfSect))
    {
           BOOL bDetect = FALSE;

        bRet = UnattendedManualInstall(hwnd, lpip, hdi, &bDetect, hportmap);

        if (!bRet || !bDetect) 
            goto exit;

        // proceed with detection: manual install function didn't fail but
        // INF didn't specify any modems.
        bRet = FALSE; // assume failure;
    }

    // No INF file & section: do a detection install.
    // Set the detection parameters
    ZeroInit(&dd);
    CplInitClassInstallHeader(&dd.DetectParams.ClassInstallHeader, DIF_DETECT);

    if (*lpip->szPort)
    {
        // Tell modem detection that we'll only be installing on one port,
        // so that it leaves us with a registered device instance instead
        // of creating a global class driver list.
        SetFlag(dwFlags, DMF_ONE_PORT_INSTALL);
        dd.dwFlags |= DDF_QUERY_SINGLE;
        if (!PortMap_GetPortName(
                hportmap,
                lpip->szPort,
                dd.szPortQuery,
                ARRAYSIZE(dd.szPortQuery)
                ))
        {
            TRACE_MSG(
                TF_ERROR,
                "Can't find port %s in portmap.",
                lpip->szPort
                );
            gUnattendFailID = IDS_ERR_UNATTEND_INF_NOSUCHPORT;
            goto exit;
        }
    }
    else
    {
        if (dwPorts > MIN_MULTIPORT)
        {
            // The machine has > MIN_MULTIPORT ports and a port *wasn't* given.
            // Warn the user.
            TRACE_MSG(TF_ERROR, "Too many ports.  Must restrict detection.");
            MsgBox(g_hinst,
                   hwnd,
                   MAKEINTRESOURCE(IDS_ERR_TOO_MANY_PORTS),
                   MAKEINTRESOURCE(IDS_CAP_MODEMSETUP),
                   NULL,
                   MB_OK | MB_ICONEXCLAMATION,
                   dwPorts);
            goto exit;
        }
    }

    // Run UI-less modem detection
    SetFlag(dwFlags, DMF_QUIET);
    // 07/07/97 - EmanP
    // added extra parameter (see definition of CplDiDetectModem
    // for explanation); NULL is OK in this case, since the hdi
    // is correctly associated with the modem CLSID
    // (by CplDiGetModemDevs at the begining of the function)
    bRet = CplDiDetectModem(hdi, NULL, NULL, &dd, NULL, &dwFlags, NULL);

    // Did the detection fail?
    if (!bRet || IsFlagClear(dwFlags, DMF_GOTO_NEXT_PAGE))
    {
        TRACE_MSG(TF_ERROR, "modem detection failed");
        MsgBox(g_hinst,
               hwnd,
               MAKEINTRESOURCE(IDS_ERR_DETECTION_FAILED),
               MAKEINTRESOURCE(IDS_CAP_MODEMWIZARD),
               NULL,
               MB_OK | MB_ICONEXCLAMATION);
    }

    // Did detection find something?
    if (IsFlagSet(dwFlags, DMF_DETECTED_MODEM))
    {
        // Install the modem(s) that were detected.  (We can assume here
        // that there's something in the device class to be installed.)
        bRet = CplDiInstallModem(hdi, NULL, FALSE);
        if (!bRet) gUnattendFailID = IDS_ERR_UNATTEND_CANT_INSTALL;
    }

exit:

    if (hportmap) {PortMap_Free(hportmap); hportmap=NULL;}


    if (!bRet)
    {
        MsgBox(g_hinst,
               hwnd,
               MAKEINTRESOURCE(gUnattendFailID),
               MAKEINTRESOURCE(IDS_CAP_MODEMSETUP),
               NULL,
               MB_OK | MB_ICONEXCLAMATION);
    }

    DBG_EXIT_BOOL_ERR(UnattendedInstall, bRet);
    return(bRet);
}



//-----------------------------------------------------------------------------------
//  SetupInfo structure functions
//-----------------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: This function creates a SETUPINFO structure.

         Use SetupInfo_Destroy to free the pointer to this structure.

Returns: NO_ERROR
         ERROR_OUTOFMEMORY

Cond:    --
*/
DWORD
PUBLIC
SetupInfo_Create(
    OUT LPSETUPINFO FAR *       ppsi,
    IN  HDEVINFO                hdi,
    IN  PSP_DEVINFO_DATA        pdevData,   OPTIONAL
    IN  PSP_INSTALLWIZARD_DATA  piwd,       OPTIONAL
    IN  PMODEM_INSTALL_WIZARD   pmiw)       OPTIONAL
    {
    DWORD dwRet;
    LPSETUPINFO psi;

    DBG_ENTER(SetupInfo_Create);
    
    ASSERT(ppsi);
    ASSERT(hdi && INVALID_HANDLE_VALUE != hdi);

    psi = (LPSETUPINFO)ALLOCATE_MEMORY( sizeof(*psi));
    if (NULL == psi)
        {
        dwRet = ERROR_OUTOFMEMORY;
        }
    else
        {
        psi->cbSize = sizeof(*psi);
        psi->pdevData = pdevData;

        // Allocate a buffer to save the INSTALLWIZARD_DATA

        dwRet = ERROR_OUTOFMEMORY;      // assume error

        psi->piwd = (PSP_INSTALLWIZARD_DATA)ALLOCATE_MEMORY( sizeof(*piwd));
        if (psi->piwd)
            {
            if (PortMap_Create(&psi->hportmap))
                {
                PSP_SELECTDEVICE_PARAMS psdp = &psi->selParams;

                // Initialize the SETUPINFO struct
                psi->hdi = hdi;

                // Is there a modem install structure that we need to save?
                if (pmiw)
                    {
                    // Yes
                    BltByte(&psi->miw, pmiw, sizeof(psi->miw));
                    }
                psi->miw.ExitButton = PSBTN_CANCEL;   // default return

                // Copy the INSTALLWIZARD_DATA
                if (piwd)
                    {
                    psi->dwFlags = piwd->PrivateFlags;
                    BltByte(psi->piwd, piwd, sizeof(*piwd));
                    }
#ifdef LEGACY_DETECT
                // Are there enough ports on the system to indicate
                // we should treat this like a multi-modem install?
                if (MIN_MULTIPORT < PortMap_GetCount(psi->hportmap))
                    {
                    // Yes
                    SetFlag(psi->dwFlags, SIF_PORTS_GALORE);
                    }
#endif
                // Initialize the SELECTDEVICE_PARAMS
                CplInitClassInstallHeader(&psdp->ClassInstallHeader, DIF_SELECTDEVICE);
                LoadString(g_hinst, IDS_CAP_MODEMWIZARD, psdp->Title, SIZECHARS(psdp->Title));
                LoadString(g_hinst, IDS_ST_SELECT_INSTRUCT, psdp->Instructions, SIZECHARS(psdp->Instructions));
                LoadString(g_hinst, IDS_ST_MODELS, psdp->ListLabel, SIZECHARS(psdp->ListLabel));

                dwRet = NO_ERROR;
                }
            }

        // Did something fail?
        if (NO_ERROR != dwRet)
            {
            // Yes; clean up
            SetupInfo_Destroy(psi);
            psi = NULL;
            }
        }

    *ppsi = psi;

    DBG_EXIT(SetupInfo_Create);
    
    return dwRet;
    }


/*----------------------------------------------------------
Purpose: This function destroys a SETUPINFO structure.

Returns: NO_ERROR
Cond:    --
*/
DWORD
PUBLIC
SetupInfo_Destroy(
    IN  LPSETUPINFO psi)
{
    DBG_ENTER(SetupInfo_Destroy);
    if (psi)
    {
        if (psi->piwd)
        {
            FREE_MEMORY((psi->piwd));
        }

        if (psi->hportmap)
        {
            PortMap_Free(psi->hportmap);
        }

        CatMultiString(&psi->pszPortList, NULL);

        FREE_MEMORY((psi));
    }

    DBG_EXIT(SetupInfo_Destroy);
    return NO_ERROR;
}



//-----------------------------------------------------------------------------------
//  Debug functions
//-----------------------------------------------------------------------------------

#ifdef DEBUG

#pragma data_seg(DATASEG_READONLY)
struct _DIFMAP
    {
    DI_FUNCTION dif;
    LPCTSTR     psz;
    } const c_rgdifmap[] = {
        DEBUG_STRING_MAP(DIF_SELECTDEVICE),
        DEBUG_STRING_MAP(DIF_INSTALLDEVICE),
        DEBUG_STRING_MAP(DIF_ASSIGNRESOURCES),
        DEBUG_STRING_MAP(DIF_PROPERTIES),
        DEBUG_STRING_MAP(DIF_REMOVE),
        DEBUG_STRING_MAP(DIF_FIRSTTIMESETUP),
        DEBUG_STRING_MAP(DIF_FOUNDDEVICE),
        DEBUG_STRING_MAP(DIF_SELECTCLASSDRIVERS),
        DEBUG_STRING_MAP(DIF_VALIDATECLASSDRIVERS),
        DEBUG_STRING_MAP(DIF_INSTALLCLASSDRIVERS),
        DEBUG_STRING_MAP(DIF_CALCDISKSPACE),
        DEBUG_STRING_MAP(DIF_DESTROYPRIVATEDATA),
        DEBUG_STRING_MAP(DIF_VALIDATEDRIVER),
        DEBUG_STRING_MAP(DIF_MOVEDEVICE),
        DEBUG_STRING_MAP(DIF_DETECT),
        DEBUG_STRING_MAP(DIF_INSTALLWIZARD),
        DEBUG_STRING_MAP(DIF_DESTROYWIZARDDATA),
        DEBUG_STRING_MAP(DIF_PROPERTYCHANGE),
        DEBUG_STRING_MAP(DIF_ENABLECLASS),
        DEBUG_STRING_MAP(DIF_DETECTVERIFY),
        DEBUG_STRING_MAP(DIF_INSTALLDEVICEFILES),
        DEBUG_STRING_MAP(DIF_UNREMOVE),
        DEBUG_STRING_MAP(DIF_SELECTBESTCOMPATDRV),
        DEBUG_STRING_MAP(DIF_ALLOW_INSTALL),
        DEBUG_STRING_MAP(DIF_REGISTERDEVICE),
        DEBUG_STRING_MAP(DIF_NEWDEVICEWIZARD_PRESELECT),
        DEBUG_STRING_MAP(DIF_NEWDEVICEWIZARD_SELECT),
        DEBUG_STRING_MAP(DIF_NEWDEVICEWIZARD_PREANALYZE),
        DEBUG_STRING_MAP(DIF_NEWDEVICEWIZARD_POSTANALYZE),
        DEBUG_STRING_MAP(DIF_NEWDEVICEWIZARD_FINISHINSTALL),
        DEBUG_STRING_MAP(DIF_UNUSED1),
        DEBUG_STRING_MAP(DIF_INSTALLINTERFACES),
        DEBUG_STRING_MAP(DIF_DETECTCANCEL),
        DEBUG_STRING_MAP(DIF_REGISTER_COINSTALLERS),
        DEBUG_STRING_MAP(DIF_ADDPROPERTYPAGE_ADVANCED),
        DEBUG_STRING_MAP(DIF_ADDPROPERTYPAGE_BASIC),
        DEBUG_STRING_MAP(DIF_RESERVED1),
        DEBUG_STRING_MAP(DIF_TROUBLESHOOTER)
        };
#pragma data_seg()


/*----------------------------------------------------------
Purpose: Returns the string form of a known InstallFunction.

Returns: String ptr
Cond:    --
*/
LPCTSTR PUBLIC Dbg_GetDifName(
    DI_FUNCTION dif)
    {
    int i;

    for (i = 0; i < ARRAYSIZE(c_rgdifmap); i++)
        {
        if (dif == c_rgdifmap[i].dif)
            return c_rgdifmap[i].psz;
        }
    return TEXT("Unknown InstallFunction");
    }

#endif // DEBUG


BOOL ReallyNeedsReboot
(
    IN  PSP_DEVINFO_DATA    pdevData,
    IN  PSP_DEVINSTALL_PARAMS pdevParams
)
{
    BOOL fRet;
    if (pdevParams->Flags & (DI_NEEDREBOOT | DI_NEEDRESTART))
    {
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
    }
    return fRet;
}

const LPCTSTR lpctszSP6 = TEXT("      ");


// Right-justifies the 'COMxxx'
// "COM1" becomes
// "  COM1"
// and
// "COM999" stays
// "COM999"
void FormatPortForDisplay
(
    IN TCHAR szPort[],
    OUT TCHAR rgchPortDisplayName[],
    IN    UINT     cch
)
{
    UINT u = lstrlen(szPort);
    TCHAR *ptch = rgchPortDisplayName;
        const UINT cbJUST = 6; // 6 == lstrlen("COM999")

        ASSERT(cch>u);

    // Right-justify the string, if it's less than cbJUST chars long.
    if (u<cbJUST && cch>=cbJUST)
    {
        ASSERT(lstrlen(lpctszSP6)>=(int)cbJUST);
        u = cbJUST-u;
        CopyMemory(ptch, lpctszSP6, u*sizeof(TCHAR));
        ptch+=u;
        cch -=u;
    }
    lstrcpyn(ptch, szPort, cch);
}

void    UnformatAfterDisplay
(
    IN OUT TCHAR *psz
)
{
    TCHAR *psz1 = psz;

    // find first non-blank.
    while(*psz1 == *lpctszSP6)
    {
        psz1++;
    }

    // move up
    do
    {
        *psz++ = *psz1;

    } while(*psz1++);
}



/*----------------------------------------------------------
Purpose: Takes a device info set and builds a driver list
         for it and selects a driver. It gets all needed
         information from the device info data.

Returns: TRUE on success
Cond:    --
*/
BOOL
APIENTRY
CplDiPreProcessHDI (
    IN     HDEVINFO            hdi,
    IN     PSP_DEVINFO_DATA    pDevInfo       OPTIONAL)
{
 SP_DRVINFO_DATA        drvData;
 SP_DEVINSTALL_PARAMS   devParams;
 SP_DRVINFO_DETAIL_DATA drvDetail;
 BOOL                   bRet = FALSE;

    DBG_ENTER(CplDiPreProcessHDI);

    drvData.cbSize = sizeof (SP_DRVINFO_DATA);
    if (CplDiGetSelectedDriver (hdi, NULL, &drvData))
    {
        // If the device info set already has a selected
        // driver, no work for us to do here
        bRet = TRUE;
        goto _ErrRet;
    }
    if (ERROR_NO_DRIVER_SELECTED != GetLastError ())
    {
        TRACE_MSG(TF_ERROR, "CplDiGetSelectedDriver failed: %#lx", GetLastError ());
        goto _ErrRet;
    }

    // We must have a device info data here
    ASSERT (NULL != pDevInfo);
    if (NULL == pDevInfo)
    {
        TRACE_MSG(TF_ERROR, "Called with invalid parameters");
        SetLastError (ERROR_INVALID_PARAMETER);
        goto _ErrRet;
    }

    // Now, get the driver selected into the device info data
    if (!CplDiGetSelectedDriver (hdi, pDevInfo, &drvData))
    {
        TRACE_MSG(TF_ERROR, "CplDiGetSelectedDriver failed: %#lx", GetLastError ());
        goto _ErrRet;
    }

    // Get the dev install params, for the inf path
    devParams.cbSize = sizeof (SP_DEVINSTALL_PARAMS);
    if (!CplDiGetDeviceInstallParams (hdi, pDevInfo, &devParams))
    {
        TRACE_MSG(TF_ERROR, "CplDiGetDeviceInstallParams failed: %#lx", GetLastError ());
        goto _ErrRet;
    }

    if (!IsFlagSet (devParams.Flags, DI_ENUMSINGLEINF))
    {
        // the install params only have a path, so get
        // the driver info detail, for the inf name
        drvDetail.cbSize = sizeof (SP_DRVINFO_DETAIL_DATA);
        if (!CplDiGetDriverInfoDetail (hdi, pDevInfo, &drvData, &drvDetail,
            sizeof (SP_DRVINFO_DETAIL_DATA), NULL) &&
            ERROR_INSUFFICIENT_BUFFER != GetLastError ())
        {
            TRACE_MSG(TF_ERROR, "CplDiGetDriverInfoDetail failed: %#lx", GetLastError ());
            goto _ErrRet;
        }

        lstrcpy (devParams.DriverPath, drvDetail.InfFileName);

        // Mark the install params to look only in one file
        SetFlag (devParams.Flags, DI_ENUMSINGLEINF);
        //devParams.Flags == DI_ENUMSINGLEINF;
    }

    ClearFlag (devParams.Flags, DI_CLASSINSTALLPARAMS);

    // Set the install params for the device info set
    if (!CplDiSetDeviceInstallParams (hdi, NULL, &devParams))
    {
        TRACE_MSG(TF_ERROR, "CplDiSetDeviceInstallParams failed: %#lx", GetLastError ());
        goto _ErrRet;
    }

    // Build the driver list for the device info set; it
    // should look in only one inf, the one we passed in
    if (!CplDiBuildDriverInfoList (hdi, NULL, SPDIT_CLASSDRIVER))
    {
        TRACE_MSG(TF_ERROR, "CplDiBuildDriverInfoList failed: %#lx", GetLastError ());
        goto _ErrRet;
    }

    // Reset the driver data; this is a documented hack
    drvData.Reserved   = 0;
    drvData.DriverType = SPDIT_CLASSDRIVER;

    // Select this driver in the device inf set
    // because the reserved field is 0, the api will
    // search the list for a driver with the other parameters
    if (!CplDiSetSelectedDriver (hdi, NULL, &drvData))
    {
        TRACE_MSG(TF_ERROR, "CplDiSetSelectedDriver failed: %#lx", GetLastError ());
        goto _ErrRet;
    }

    // If all went well so far, then try to remove the
    // device info data that is already in the registry,
    // because we'll not use it; the outcome of this
    // operation doesn't matter for the success of this
    // function
    bRet = TRUE;

_ErrRet:
    DBG_EXIT_BOOL_ERR(CplDiPreProcessHDI, bRet);
    return bRet;
}



/*----------------------------------------------------------
Purpose: Retrieves the friendly name of the device.  If there
         is no such device or friendly name, this function
         returns FALSE.

Returns: see above
Cond:    --
*/
BOOL
PUBLIC
CplDiGetPrivateProperties(
    IN  HDEVINFO        hdi,
    IN  PSP_DEVINFO_DATA pdevData,
    OUT PMODEM_PRIV_PROP pmpp)
{
 BOOL bRet = FALSE;
 HKEY hkey;

    DBG_ENTER(CplDiGetPrivateProperties);

    ASSERT(hdi && INVALID_HANDLE_VALUE != hdi);
    ASSERT(pdevData);
    ASSERT(pmpp);

    if (sizeof(*pmpp) != pmpp->cbSize)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    else
    {
        hkey = CplDiOpenDevRegKey(hdi, pdevData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ);
        if (INVALID_HANDLE_VALUE != hkey)
        {
         DWORD cbData;
         DWORD dwMask = pmpp->dwMask;
         BYTE nValue;

            pmpp->dwMask = 0;

            if (IsFlagSet(dwMask, MPPM_FRIENDLY_NAME))
            {
                // Attempt to get the friendly name
                cbData = sizeof(pmpp->szFriendlyName);
                if (NO_ERROR ==
                     RegQueryValueEx(hkey, c_szFriendlyName, NULL, NULL, (LPBYTE)pmpp->szFriendlyName, &cbData) ||
                    0 != LoadString(g_hinst, IDS_UNINSTALLED, pmpp->szFriendlyName, sizeof(pmpp->szFriendlyName)/sizeof(WCHAR)))
                {
                    SetFlag(pmpp->dwMask, MPPM_FRIENDLY_NAME);
                }
            }

            if (IsFlagSet(dwMask, MPPM_DEVICE_TYPE))
            {
                // Attempt to get the device type
                cbData = sizeof(nValue);
                if (NO_ERROR ==
                    RegQueryValueEx(hkey, c_szDeviceType, NULL, NULL, &nValue, &cbData))
                {
                    pmpp->nDeviceType = nValue;     // dword <-- byte
                    SetFlag(pmpp->dwMask, MPPM_DEVICE_TYPE);
                }
            }

            if (IsFlagSet(dwMask, MPPM_PORT))
            {
                // Attempt to get the attached port
                cbData = sizeof(pmpp->szPort);
                if (NO_ERROR ==
                     RegQueryValueEx(hkey, c_szAttachedTo, NULL, NULL, (LPBYTE)pmpp->szPort, &cbData) ||
                    0 != LoadString(g_hinst, IDS_UNKNOWNPORT, pmpp->szPort, sizeof(pmpp->szPort)/sizeof(WCHAR)))
                {
                    SetFlag(pmpp->dwMask, MPPM_PORT);
                }
            }

            bRet = TRUE;

            RegCloseKey(hkey);
        }
        ELSE_TRACE ((TF_ERROR, "SetupDiOpenDevRegKey(DIREG_DRV) failed: %#lx.", GetLastError ()));
    }

    DBG_EXIT_BOOL_ERR(CplDiGetPrivateProperties, bRet);
    return bRet;
}


int my_atol(LPTSTR lptsz)
{
 TCHAR tchr = *lptsz++;
 int   iRet = 0;

	if (!tchr) goto bail;

	do
	{
        if (IsCharAlpha (tchr) ||
            !IsCharAlphaNumeric (tchr))
        {
            goto bail;
        }

		iRet*=10;
		iRet+=(int)tchr-(int)TEXT('0');
		tchr = *lptsz++;
	} while(tchr); 

	return iRet;

bail:
	return MAXDWORD;
}


void
PUBLIC
CloneModem (
    IN  HDEVINFO         hdi,
    IN  PSP_DEVINFO_DATA pdevData,
    IN  HWND             hWnd)
{
 LPSETUPINFO psi;

    DBG_ENTER(CloneModem);
    if (NO_ERROR != SetupInfo_Create(&psi, hdi, pdevData, NULL, NULL))
    {
        // Out of memory
        MsgBox(g_hinst, hWnd,
               MAKEINTRESOURCE(IDS_OOM_CLONE),
               MAKEINTRESOURCE(IDS_CAP_MODEMSETUP),
               NULL,
               MB_OK | MB_ICONERROR);
    }
    else
    {
        if (IDOK == DialogBoxParam(g_hinst, 
                                   MAKEINTRESOURCE(IDD_CLONE),
                                   hWnd, 
                                   CloneDlgProc,
                                   (LPARAM)psi))
        {
            BOOL bRet;
            HCURSOR hcurSav = SetCursor(LoadCursor(NULL, IDC_WAIT));
            LPCTSTR pszPort;

            // Clone this modem for all the ports in the port list
            ASSERT(psi->pszPortList);

            bRet = CplDiBuildModemDriverList(hdi, pdevData);

            SetCursor(hcurSav);

            if (bRet)
            {
                // Install a device for each port in the port list
                // 07/16/97 - EmanP
                // pass in NULL for the new parameter added
                // to CplDiInstallModemFromDriver; this is equivalent
                // with the old behaviour (no extra parameter)
                CplDiInstallModemFromDriver (hdi, NULL, hWnd, 
                                             &psi->dwNrOfPorts,
                                             &psi->pszPortList,
                                             IMF_DEFAULT | IMF_DONT_COMPARE);
            }

            if (gDeviceFlags & fDF_DEVICE_NEEDS_REBOOT)
            {
             TCHAR szMsg[128];
                LoadString (g_hinst, IDS_DEVSETUP_RESTART, szMsg, sizeof(szMsg)/sizeof(TCHAR));
                RestartDialogEx (hWnd, szMsg, EWX_REBOOT, SHTDN_REASON_MAJOR_HARDWARE | SHTDN_REASON_MINOR_INSTALLATION | SHTDN_REASON_FLAG_PLANNED);
            }
        }
        SetupInfo_Destroy(psi);
    }

    DBG_EXIT(CloneModem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\modemui\cfgui.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: cfgui.h
//
// Unimodem lineConfigDialog UI.
//
// History:
//  10-24-97 JosephJ     Created
//
//---------------------------------------------------------------------------


#ifndef __CFGUI_H__
#define __CFGUI_H__


typedef struct
{
    DWORD dwDeviceType;         // One of the DT_* values;
    REGDEVCAPS devcaps;         // Modem caps from the registry.
    TCHAR      szPortName[MAXPORTNAME];
    TCHAR      szFriendlyName[MAXFRIENDLYNAME];
    MODEM_PROTOCOL_CAPS *pProtocolCaps;
    

} MODEMCAPS;

typedef struct
{
    WIN32DCB      dcb;          // From COMMCONFIG
    MODEMSETTINGS ms;          // From COMMCONFIG
    DWORD          fdwSettings; // From UMDEVCFGHDR (Terminal, manualdial, etc.)

} WORKINGCFGDATA;

#define SIG_CFGMODEMINFO 0x4e852b19

// Internal structure shared between modem property pages.
//
typedef struct _CFGMODEMINFO
{
    DWORD          dwSig;     // Must be set to SIG_CFGMODEMINFO.

    MODEMCAPS      c;         // Read-Only capabilities of modem
    WORKINGCFGDATA w;         // Working copy of data.

    UMDEVCFG       *pdcfg;    // Passed-in from outside.
    HWND           hwndParent;

    DWORD          dwMaximumPortSpeed;

    BOOL           fOK;       // Completion status

} CFGMODEMINFO, FAR * LPCFGMODEMINFO;

#define VALIDATE_CMI(pcmi) (SIG_CFGMODEMINFO == (pcmi)->dwSig)

DWORD
GetInactivityTimeoutScale(
    HKEY hkey
    );

BOOL
IsValidProtocol(
    MODEM_PROTOCOL_CAPS *pCaps,
    UINT uECSel
    );

//-------------------------------------------------------------------------
//  CFGGEN.C
//-------------------------------------------------------------------------

INT_PTR CALLBACK CfgGen_WrapperProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK CfgAdv_WrapperProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
#endif // __CFGUI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\modemui\cfgadv.c ===
//---------------------------------------------------------------------------
//
// Copyrght (c) Microsoft Corporation 1993-1994
//
// File: cfgadv.c
//
// This files contains the dialog code for the CFG Advanced property page.
//
// History:
//  10/26/1997 JosephJ Created -- adapted from the old sett.c and advsett.c
//
//---------------------------------------------------------------------------


/////////////////////////////////////////////////////  INCLUDES

#include "proj.h"         // common headers
#include "cfgui.h"


/////////////////////////////////////////////////////  CONTROLLING DEFINES


#define SIG_CFGADV     0xe66b4a8c


typedef struct
{
    DWORD dwSig;            // Must be set to SIG_CFGADV
    HWND hdlg;              // dialog handle

    LPCFGMODEMINFO pcmi;        // modeminfo struct passed in to dialog

    HWND hwndDataBits;
    HWND hwndParity;
    HWND hwndStopBits;
    HWND hwndModulations;
    
} CFGADV, FAR * PCFGADV;

void CfgAdv_OnApply(
    PCFGADV this
    );

void
CfgAdv_OnCommand(
    IN PCFGADV this,
    IN int  id,
    IN HWND hwndCtl,
    IN UINT uNotifyCode
    );

void CfgAdv_SaveAdvancedDCB(
    PCFGADV this
    );



// This table is the generic port settings table
// that is used to fill the various listboxes
typedef struct _PortValues
    {
    union {
        BYTE bytesize;
        BYTE cmd;
        BYTE stopbits;
        };
    int ids;
    } PortValues, FAR * LPPORTVALUES;

#define DEFAULT_BYTESIZE            8
#define DEFAULT_PARITY              CMD_PARITY_NONE
#define DEFAULT_STOPBITS            ONESTOPBIT

#pragma data_seg(DATASEG_READONLY)

// Command IDs for the parity listbox
#define CMD_PARITY_EVEN         1
#define CMD_PARITY_ODD          2
#define CMD_PARITY_NONE         3
#define CMD_PARITY_MARK         4
#define CMD_PARITY_SPACE        5

// This is the structure that is used to fill the data bits listbox
static PortValues s_rgbytesize[] = {
        { 4,  IDS_BYTESIZE_4  },
        { 5,  IDS_BYTESIZE_5  },
        { 6,  IDS_BYTESIZE_6  },
        { 7,  IDS_BYTESIZE_7  },
        { 8,  IDS_BYTESIZE_8  },
        };

// This is the structure that is used to fill the parity listbox
static PortValues s_rgparity[] = {
        { CMD_PARITY_EVEN,  IDS_PARITY_EVEN  },
        { CMD_PARITY_ODD,   IDS_PARITY_ODD   },
        { CMD_PARITY_NONE,  IDS_PARITY_NONE  },
        { CMD_PARITY_MARK,  IDS_PARITY_MARK  },
        { CMD_PARITY_SPACE, IDS_PARITY_SPACE },
        };

// This is the structure that is used to fill the stopbits listbox
static PortValues s_rgstopbits[] = {
        { ONESTOPBIT,   IDS_STOPBITS_1   },
        { ONE5STOPBITS, IDS_STOPBITS_1_5 },
        { TWOSTOPBITS,  IDS_STOPBITS_2   },
        };
#pragma data_seg()


#define VALID_CFGADV(_pcplgen)  ((_pcplgen)->dwSig == SIG_CFGADV)

PCFGADV CfgAdv_GetPtr(HWND hwnd)
{
    PCFGADV pCfgAdv = (PCFGADV)GetWindowLongPtr(hwnd, DWLP_USER);
    if (!pCfgAdv || VALID_CFGADV(pCfgAdv))
    {
        return pCfgAdv;
    }
    else
    {
        MYASSERT(FALSE);
        return NULL;
    }
}

void CfgAdv_SetPtr(HWND hwnd, PCFGADV pCfgAdv)
{
    if (pCfgAdv && !VALID_CFGADV(pCfgAdv))
    {
        MYASSERT(FALSE);
        pCfgAdv = NULL;
    }
   
    SetWindowLongPtr(hwnd, DWLP_USER, (ULONG_PTR) pCfgAdv);
}


void CfgAdv_FillDataBits(
    PCFGADV this);

void CfgAdv_FillParity(
    PCFGADV this);

void CfgAdv_FillStopBits(
    PCFGADV this);
    


/*----------------------------------------------------------
Purpose: WM_INITDIALOG Handler
Returns: FALSE when we assign the control focus
Cond:    --
*/
BOOL CfgAdv_OnInitDialog(
    PCFGADV this,
    HWND hwndFocus,
    LPARAM lParam)              // expected to be PROPSHEETINFO 
{
    LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
    HWND hdlg = this->hdlg;
    WNDPROC pfn=NULL;
    BOOL fRet  = FALSE;
    DWORD dwCapOptions =  0;

    MYASSERT(VALID_CFGADV(this));
    ASSERT((LPTSTR)lppsp->lParam);

    this->pcmi = (LPCFGMODEMINFO)lppsp->lParam;

    if (!VALIDATE_CMI(this->pcmi))
    {
        MYASSERT(FALSE);
        goto end;
    }

    dwCapOptions =  this->pcmi->c.devcaps.dwModemOptions;
    this->hwndDataBits = GetDlgItem(hdlg, IDC_DATABITS);
    this->hwndParity = GetDlgItem(hdlg, IDC_PARITY);
    this->hwndStopBits = GetDlgItem(hdlg, IDC_STOPBITS);
    this->hwndModulations = GetDlgItem(hdlg, IDC_CB_MOD);

    // ---------- The Advanced port settings listboxes ... -----------

    // Is this a parallel port?
    if (DT_PARALLEL_PORT == this->pcmi->c.dwDeviceType)
    {
        // Yes; hide the DCB controls

        ShowWindow(GetDlgItem(hdlg, IDC_LBL_DATABITS), SW_HIDE);
        EnableWindow(GetDlgItem(hdlg, IDC_LBL_DATABITS), FALSE);

        ShowWindow(GetDlgItem(hdlg, IDC_DATABITS), SW_HIDE);
        EnableWindow(GetDlgItem(hdlg, IDC_DATABITS), FALSE);

        ShowWindow(GetDlgItem(hdlg, IDC_LBL_PARITY), SW_HIDE);
        EnableWindow(GetDlgItem(hdlg, IDC_LBL_PARITY), FALSE);

        ShowWindow(GetDlgItem(hdlg, IDC_PARITY), SW_HIDE);
        EnableWindow(GetDlgItem(hdlg, IDC_PARITY), FALSE);

        ShowWindow(GetDlgItem(hdlg, IDC_LBL_STOPBITS), SW_HIDE);
        EnableWindow(GetDlgItem(hdlg, IDC_LBL_STOPBITS), FALSE);

        ShowWindow(GetDlgItem(hdlg, IDC_STOPBITS), SW_HIDE);
        EnableWindow(GetDlgItem(hdlg, IDC_STOPBITS), FALSE);
    }
    else
    {
        // No; initialize the DCB controls
        CfgAdv_FillDataBits(this);
        CfgAdv_FillParity(this);
        CfgAdv_FillStopBits(this);
    }


    // ------------- TERMINAL SETTINGS  --------------------
    if (FALSE == g_dwIsCalledByCpl)
    {
     DWORD fdwSettings = this->pcmi->w.fdwSettings;
    
        // Initialize the appearance of the dialog box
        CheckDlgButton(
                hdlg,
                IDC_TERMINAL_PRE,
                (fdwSettings & UMTERMINAL_PRE) ? BST_CHECKED : BST_UNCHECKED
                );
    
        CheckDlgButton(
                hdlg,
                IDC_TERMINAL_POST,
                (fdwSettings & UMTERMINAL_POST) ? BST_CHECKED : BST_UNCHECKED
                );
    }
    else
    {
     HWND hWnd;
        hWnd = GetDlgItem (hdlg, IDC_TERMINAL_PRE);
        EnableWindow (hWnd, FALSE);
        ShowWindow (hWnd, SW_HIDE);
        hWnd = GetDlgItem (hdlg, IDC_TERMINAL_POST);
        EnableWindow (hWnd, FALSE);
        ShowWindow (hWnd, SW_HIDE);
        hWnd = GetDlgItem (hdlg, IDC_TERMINALGRP);
        EnableWindow (hWnd, FALSE);
        ShowWindow (hWnd, SW_HIDE);
    }

    // --------------  MODULATION -------------------------

    // Build modulation list _and_ set it.
    if (IsFlagSet(dwCapOptions, MDM_CCITT_OVERRIDE))
    {
        int n;
        int idSet = -1;
        int idDef;
        TCHAR sz[MAXMEDLEN];
        DWORD dwOptions = this->pcmi->w.ms.dwPreferredModemOptions;

        SetWindowRedraw(this->hwndModulations, FALSE);
        ComboBox_ResetContent(this->hwndModulations);

        // add Bell
        n = ComboBox_AddString(
                        this->hwndModulations,
                        SzFromIDS(g_hinst, IDS_BELL, sz, ARRAYSIZE(sz))
                        );
        ComboBox_SetItemData(this->hwndModulations, n, 0);
        idDef = n;
        if (IsFlagClear(dwOptions, MDM_CCITT_OVERRIDE))
        {
            idSet = n;
        }

        // add CCITT
        n = ComboBox_AddString(
                    this->hwndModulations,
                    SzFromIDS(g_hinst, IDS_CCITT_V21V22, sz, ARRAYSIZE(sz))
                    );

        ComboBox_SetItemData(this->hwndModulations, n, MDM_CCITT_OVERRIDE);
        if (IsFlagSet(dwOptions, MDM_CCITT_OVERRIDE))
        {
            idSet = n;
        }

        // add V.23, if present
        if (IsFlagSet(dwCapOptions, MDM_V23_OVERRIDE))
        {
            n = ComboBox_AddString(
                    this->hwndModulations,
                    SzFromIDS(g_hinst, IDS_CCITT_V23, sz, ARRAYSIZE(sz))
                    );

            ComboBox_SetItemData(
                    this->hwndModulations,
                    n,
                    MDM_CCITT_OVERRIDE | MDM_V23_OVERRIDE
                    );
            if (    IsFlagSet(dwOptions, MDM_CCITT_OVERRIDE)
                 && IsFlagSet(dwOptions, MDM_V23_OVERRIDE))
            {
                idSet = n;
            }
        }

        // set current selection
        if (-1 == idSet)
        {
            idSet = idDef;
        }
        ComboBox_SetCurSel(this->hwndModulations, idSet);
        SetWindowRedraw(this->hwndModulations, TRUE);
    }
    else
    {
        ComboBox_Enable(this->hwndModulations, FALSE);
        EnableWindow(GetDlgItem(hdlg, IDC_LBL_MOD2), FALSE);
    }

    fRet  = TRUE;

end:

    return fRet;   // default initial focus
}


/*----------------------------------------------------------
Purpose: PSN_KILLACTIVE handler
Returns: --
Cond:    --
*/
void CfgAdv_OnSetActive(
    PCFGADV this)
{
}


/*----------------------------------------------------------
Purpose: PSN_KILLACTIVE handler
Returns: --
Cond:    --
*/
void CfgAdv_OnKillActive(
    PCFGADV this)
{
}


/*----------------------------------------------------------
Purpose: WM_NOTIFY handler
Returns: varies
Cond:    --
*/
LRESULT CfgAdv_OnNotify(
    PCFGADV this,
    int idFrom,
    NMHDR FAR * lpnmhdr)
{
    LRESULT lRet = 0;
    
    switch (lpnmhdr->code)
        {
    case PSN_SETACTIVE:
        CfgAdv_OnSetActive(this);
        break;

    case PSN_KILLACTIVE:
        // N.b. This message is not sent if user clicks Cancel!
        // N.b. This message is sent prior to PSN_APPLY
        CfgAdv_OnKillActive(this);
        break;

    case PSN_APPLY:
        CfgAdv_OnApply(this);
        break;

    default:
        break;
        }

    return lRet;
}


/*----------------------------------------------------------
Purpose: WM_DESTROY handler
Returns: --
Cond:    --
*/
void CfgAdv_OnDestroy(
    PCFGADV this)
{
}


/////////////////////////////////////////////////////  EXPORTED FUNCTIONS

static BOOL s_bCfgAdvRecurse = FALSE;

LRESULT INLINE CfgAdv_DefProc(
    HWND hDlg, 
    UINT msg,
    WPARAM wParam,
    LPARAM lParam) 
{
    ENTER_X()
        {
        s_bCfgAdvRecurse = TRUE;
        }
    LEAVE_X()

    return DefDlgProc(hDlg, msg, wParam, lParam); 
}


/*----------------------------------------------------------
Purpose: Real dialog proc
Returns: varies
Cond:    --
*/
LRESULT CfgAdv_DlgProc(
    PCFGADV this,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (message)
        {
        HANDLE_MSG(this, WM_INITDIALOG, CfgAdv_OnInitDialog);
        HANDLE_MSG(this, WM_NOTIFY, CfgAdv_OnNotify);
        HANDLE_MSG(this, WM_DESTROY, CfgAdv_OnDestroy);
        HANDLE_MSG(this, WM_COMMAND, CfgAdv_OnCommand);

    case WM_HELP:
        WinHelp(((LPHELPINFO)lParam)->hItemHandle, c_szWinHelpFile, HELP_WM_HELP, (ULONG_PTR)(LPVOID)g_aHelpIDs_IDD_CFG_ADVANCED);
        return 0;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, c_szWinHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPVOID)g_aHelpIDs_IDD_CFG_ADVANCED);
        return 0;

    default:
        return CfgAdv_DefProc(this->hdlg, message, wParam, lParam);
        }
}


/*----------------------------------------------------------
Purpose: Dialog Wrapper
Returns: varies
Cond:    --
*/
INT_PTR CALLBACK CfgAdv_WrapperProc(
    HWND hDlg,          // std params
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PCFGADV this;

    // Cool windowsx.h dialog technique.  For full explanation, see
    //  WINDOWSX.TXT.  This supports multiple-instancing of dialogs.
    //
    ENTER_X()
        {
        if (s_bCfgAdvRecurse)
            {
            s_bCfgAdvRecurse = FALSE;
            LEAVE_X()
            return FALSE;
            }
        }
    LEAVE_X()

    this = CfgAdv_GetPtr(hDlg);
    if (this == NULL)
        {
        if (message == WM_INITDIALOG)
            {
            this = (PCFGADV)ALLOCATE_MEMORY( sizeof(CFGADV));
            if (!this)
                {
                MsgBox(g_hinst,
                       hDlg, 
                       MAKEINTRESOURCE(IDS_OOM_GENERAL), 
                       MAKEINTRESOURCE(IDS_CAP_GENERAL),
                       NULL,
                       MB_ERROR);
                EndDialog(hDlg, IDCANCEL);
                return (BOOL)CfgAdv_DefProc(hDlg, message, wParam, lParam);
                }
            this->dwSig = SIG_CFGADV;
            this->hdlg = hDlg;
            CfgAdv_SetPtr(hDlg, this);
            }
        else
            {
            return (BOOL)CfgAdv_DefProc(hDlg, message, wParam, lParam);
            }
        }

    if (message == WM_DESTROY)
        {
        CfgAdv_DlgProc(this, message, wParam, lParam);
        this->dwSig = 0;
        FREE_MEMORY((HLOCAL)OFFSETOF(this));
        CfgAdv_SetPtr(hDlg, NULL);
        return 0;
        }

    return SetDlgMsgResult(
                hDlg,
                message,
                CfgAdv_DlgProc(this, message, wParam, lParam)
                );
}


/*----------------------------------------------------------
Purpose: PSN_APPLY handler
Returns: --
Cond:    --
*/
void CfgAdv_OnApply(
    PCFGADV this)
{
    LPMODEMSETTINGS pms = &this->pcmi->w.ms;
    LPDWORD pdwPreferredOptions = &pms->dwPreferredModemOptions;
    WIN32DCB FAR * pdcb = &this->pcmi->w.dcb;
    TCHAR szBuf[LINE_LEN];
    BOOL bCheck;
    MODEMSETTINGS msT;

    if (!VALIDATE_CMI(this->pcmi))
    {
        MYASSERT(FALSE);
        goto end;
    }

    // ------------- ------------------------
    if (DT_PARALLEL_PORT != this->pcmi->c.dwDeviceType)
    {
        CfgAdv_SaveAdvancedDCB(this);
    }


    // -------------------- TERMINAL ----------------------------
    if (FALSE == g_dwIsCalledByCpl)
    {
     DWORD dw = 0;
     HWND hdlg = this->hdlg;
     DWORD *pdwSettings = &(this->pcmi->w.fdwSettings);

        if(IsDlgButtonChecked(hdlg, IDC_TERMINAL_PRE))
            dw |= UMTERMINAL_PRE;
    
        if(IsDlgButtonChecked(hdlg, IDC_TERMINAL_POST))
            dw |= UMTERMINAL_POST;
    
        *pdwSettings &= ~(UMTERMINAL_PRE | UMTERMINAL_POST);
        *pdwSettings |= dw;
    }

    // -------------------- MODULATION ----------------------------
    {
        LPDWORD pdw = &this->pcmi->w.ms.dwPreferredModemOptions;

        *pdw &= ~(MDM_CCITT_OVERRIDE | MDM_V23_OVERRIDE);
        if (IsFlagSet(this->pcmi->c.devcaps.dwModemOptions, MDM_CCITT_OVERRIDE))
        {
            int iSel = ComboBox_GetCurSel(this->hwndModulations);
            *pdw |= ComboBox_GetItemData(this->hwndModulations, iSel);
        }
    }
        
end:

    // ??? this->pcmi->fOK = TRUE;
    ;

}

void
CfgAdv_OnCommand(
    IN PCFGADV this,
    IN int  id,
    IN HWND hwndCtl,
    IN UINT uNotifyCode
    )
{
#if 0
    switch(id)
    {

    case IDC_CB_SPEED:
        break;

    case IDC_CB_EC:
        break;

    case IDC_CB_COMP:
        break;

    case IDC_CB_FC:
        break;

    default:
        break;

    }
#endif
}


/*----------------------------------------------------------
Purpose: Fills the bytesize combobox with the possible byte sizes.
Returns: --
Cond:    --
*/
void CfgAdv_FillDataBits(
    PCFGADV this)
    {
    HWND hwndCB = this->hwndDataBits;
    WIN32DCB FAR * pdcb = &this->pcmi->w.dcb;
    int i;
    int iSel;
    int n;
    int iMatch = -1;
    int iDef = -1;
    TCHAR sz[MAXMEDLEN];

    // Fill the listbox
    for (i = 0; i < ARRAY_ELEMENTS(s_rgbytesize); i++)
        {
        n = ComboBox_AddString(hwndCB, SzFromIDS(g_hinst, s_rgbytesize[i].ids, sz, ARRAYSIZE(sz)));
        ComboBox_SetItemData(hwndCB, n, s_rgbytesize[i].bytesize);

        // Keep our eyes peeled for important values
        if (DEFAULT_BYTESIZE == s_rgbytesize[i].bytesize)
            {
            iDef = n;
            }
        if (pdcb->ByteSize == s_rgbytesize[i].bytesize)
            {
            iMatch = n;
            }
        }

    ASSERT(-1 != iDef);

    // Does the DCB value exist in our list?
    if (-1 == iMatch)
        {
        // No; choose the default
        iSel = iDef;
        }
    else 
        {
        // Yes; choose the matched value
        ASSERT(-1 != iMatch);
        iSel = iMatch;
        }
    ComboBox_SetCurSel(hwndCB, iSel);
    }


/*----------------------------------------------------------
Purpose: Fills the parity combobox with the possible settings.
Returns: --
Cond:    --
*/
void CfgAdv_FillParity(
    PCFGADV this)
    {
    HWND hwndCB = this->hwndParity;
    WIN32DCB FAR * pdcb = &this->pcmi->w.dcb;
    int i;
    int iSel;
    int n;
    int iMatch = -1;
    int iDef = -1;
    TCHAR sz[MAXMEDLEN];

    // Fill the listbox
    for (i = 0; i < ARRAY_ELEMENTS(s_rgparity); i++)
        {
        n = ComboBox_AddString(hwndCB, SzFromIDS(g_hinst, s_rgparity[i].ids, sz, ARRAYSIZE(sz)));
        ComboBox_SetItemData(hwndCB, n, s_rgparity[i].cmd);

        // Keep our eyes peeled for important values
        if (DEFAULT_PARITY == s_rgparity[i].cmd)
            {
            iDef = n;
            }
        switch (s_rgparity[i].cmd)
            {
        case CMD_PARITY_EVEN:
            if (EVENPARITY == pdcb->Parity)
                iMatch = n;
            break;

        case CMD_PARITY_ODD:
            if (ODDPARITY == pdcb->Parity)
                iMatch = n;
            break;

        case CMD_PARITY_NONE:
            if (NOPARITY == pdcb->Parity)
                iMatch = n;
            break;

        case CMD_PARITY_MARK:
            if (MARKPARITY == pdcb->Parity)
                iMatch = n;
            break;

        case CMD_PARITY_SPACE:
            if (SPACEPARITY == pdcb->Parity)
                iMatch = n;
            break;

        default:
            ASSERT(0);
            break;
            }
        }

    ASSERT(-1 != iDef);

    // Does the DCB value exist in our list?
    if (-1 == iMatch)
        {
        // No; choose the default
        iSel = iDef;
        }
    else 
        {
        // Yes; choose the matched value
        ASSERT(-1 != iMatch);
        iSel = iMatch;
        }
    ComboBox_SetCurSel(hwndCB, iSel);
    }


/*----------------------------------------------------------
Purpose: Fills the stopbits combobox with the possible settings.
Returns: --
Cond:    --
*/
void CfgAdv_FillStopBits(
    PCFGADV this)
    {
    HWND hwndCB = this->hwndStopBits;
    WIN32DCB FAR * pdcb = &this->pcmi->w.dcb;
    int i;
    int iSel;
    int n;
    int iMatch = -1;
    int iDef = -1;
    TCHAR sz[MAXMEDLEN];

    // Fill the listbox
    for (i = 0; i < ARRAY_ELEMENTS(s_rgstopbits); i++)
        {
        n = ComboBox_AddString(hwndCB, SzFromIDS(g_hinst, s_rgstopbits[i].ids, sz, ARRAYSIZE(sz)));
        ComboBox_SetItemData(hwndCB, n, s_rgstopbits[i].stopbits);

        // Keep our eyes peeled for important values
        if (DEFAULT_STOPBITS == s_rgstopbits[i].stopbits)
            {
            iDef = n;
            }
        if (pdcb->StopBits == s_rgstopbits[i].stopbits)
            {
            iMatch = n;
            }
        }

    ASSERT(-1 != iDef);

    // Does the DCB value exist in our list?
    if (-1 == iMatch)
        {
        // No; choose the default
        iSel = iDef;
        }
    else 
        {
        // Yes; choose the matched value
        ASSERT(-1 != iMatch);
        iSel = iMatch;
        }
    ComboBox_SetCurSel(hwndCB, iSel);
    }


void CfgAdv_SaveAdvancedDCB(
    PCFGADV this)
{
    int iSel;
    BYTE cmd;
    WIN32DCB FAR * pdcb = &this->pcmi->w.dcb;

    // Determine new byte size
    iSel = ComboBox_GetCurSel(this->hwndDataBits);
    pdcb->ByteSize = (BYTE)ComboBox_GetItemData(this->hwndDataBits, iSel);


    // Determine new parity settings
    iSel = ComboBox_GetCurSel(this->hwndParity);
    cmd = (BYTE)ComboBox_GetItemData(this->hwndParity, iSel);
    switch (cmd)
        {
    case CMD_PARITY_EVEN:
        pdcb->fParity = TRUE;
        pdcb->Parity = EVENPARITY;
        break;

    case CMD_PARITY_ODD:
        pdcb->fParity = TRUE;
        pdcb->Parity = ODDPARITY;
        break;

    case CMD_PARITY_NONE:
        pdcb->fParity = FALSE;
        pdcb->Parity = NOPARITY;
        break;

    case CMD_PARITY_MARK:
        pdcb->fParity = TRUE;
        pdcb->Parity = MARKPARITY;
        break;

    case CMD_PARITY_SPACE:
        pdcb->fParity = TRUE;
        pdcb->Parity = SPACEPARITY;
        break;

    default:
        ASSERT(0);
        break;
        }
    
    // Determine new stopbits setting
    iSel = ComboBox_GetCurSel(this->hwndStopBits);
    pdcb->StopBits = (BYTE)ComboBox_GetItemData(this->hwndStopBits, iSel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\modemui\cfgui.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: modemui.c
//
// This files contains the DLL entry-points.
//
// Much of this file contains the code that builds the default property dialog
// for modem devices.
//
// This code was originally lifted from SETUP4.DLL, which performs essentially
// the same thing, except for any device.  We don't want to have to link to
// SETUP4.DLL, so we contain a copy of this code.
//
//
// History:
//  1-12-94 ScottH      Created
//  9-20-95 ScottH      Ported to NT
//
//---------------------------------------------------------------------------


#include "proj.h"     // common headers

#include "cfgui.h"


DWORD
CMI_Load(
    LPCFGMODEMINFO pcmi,
    LPCTSTR pszFriendlyName,
    UMDEVCFG *pDevCfg,
    HWND            hwndParent
    );

void
CMI_UnLoad(
    LPCFGMODEMINFO pcmi
    );

DWORD PRIVATE CfgAddGeneralPage(
    LPCFGMODEMINFO pcmi,
    LPFNADDPROPSHEETPAGE pfnAdd,
    LPARAM lParam);

BOOL ValidateDevConfig(UMDEVCFG *pDevCfg);

DWORD
RegQueryModemCaps(
    HKEY hkeyDrv,
    MODEMCAPS *pCaps
    );


MODEM_PROTOCOL_CAPS *
GetProtocolCaps(
        HKEY hkDrv
        );

LONG
GetFriendlyProtocolName(
    DWORD    ProtocolId,
    LPTSTR   FriendlyName,
    DWORD    BufferLength,
    LPDWORD  StringLength
    );


IDSTR
rgidstrISDNCompatibleProtocols[] =
{

    {MDM_PROTOCOL_AUTO_1CH,            0, "AUTO_1CH"},
    {MDM_PROTOCOL_AUTO_2CH,            0, "AUTO_2CH"},

    {MDM_PROTOCOL_HDLCPPP_56K,         0, "HDLC_PPP_56K"},
    {MDM_PROTOCOL_HDLCPPP_64K,         0, "HDLC_PPP_64K"},

    {MDM_PROTOCOL_HDLCPPP_112K,        0, "HDLC_PPP_112K"},
    {MDM_PROTOCOL_HDLCPPP_112K_PAP,    0, "HDLC_PPP_112K_PAP"},
    {MDM_PROTOCOL_HDLCPPP_112K_CHAP,   0, "HDLC_PPP_112K_CHAP"},
    {MDM_PROTOCOL_HDLCPPP_112K_MSCHAP, 0, "HDLC_PPP_112K_MSCHAP"},

    {MDM_PROTOCOL_HDLCPPP_128K,        0, "HDLC_PPP_128K"},
    {MDM_PROTOCOL_HDLCPPP_128K_PAP,    0, "HDLC_PPP_128K_PAP"},
    {MDM_PROTOCOL_HDLCPPP_128K_CHAP,   0, "HDLC_PPP_128K_CHAP"},
    {MDM_PROTOCOL_HDLCPPP_128K_MSCHAP, 0, "HDLC_PPP_128K_MSCHAP"},

    {MDM_PROTOCOL_V120_64K,            0, "V120_64K"},
    {MDM_PROTOCOL_V120_56K,            0, "V120_56K"},
    {MDM_PROTOCOL_V120_112K,           0, "V120_112K"},
    {MDM_PROTOCOL_V120_128K,           0, "V120_128K"},

    {MDM_PROTOCOL_X75_64K,             0, "X75_64K"},
    {MDM_PROTOCOL_X75_128K,            0, "X75_128K"},
    {MDM_PROTOCOL_X75_T_70,            0, "X75_T_70"},
    {MDM_PROTOCOL_X75_BTX,             0, "X75_BTX"},

    {MDM_PROTOCOL_V110_1DOT2K,         0, "V110_1DOT2K"},
    {MDM_PROTOCOL_V110_2DOT4K,         0, "V110_2DOT4K"},
    {MDM_PROTOCOL_V110_4DOT8K,         0, "V110_4DOT8K"},
    {MDM_PROTOCOL_V110_9DOT6K,         0, "V110_9DOT6K"},
    {MDM_PROTOCOL_V110_12DOT0K,        0, "V110_12DOT0K"},
    {MDM_PROTOCOL_V110_14DOT4K,        0, "V110_14DOT4K"},
    {MDM_PROTOCOL_V110_19DOT2K,        0, "V110_19DOT2K"},
    {MDM_PROTOCOL_V110_28DOT8K,        0, "V110_28DOT8K"},
    {MDM_PROTOCOL_V110_38DOT4K,        0, "V110_38DOT4K"},
    {MDM_PROTOCOL_V110_57DOT6K,        0, "V110_57DOT6K"},
    {MDM_PROTOCOL_ANALOG_V34,          0, "ANALOG_V34"},
    {MDM_PROTOCOL_PIAFS_INCOMING,      0, "PIAFS_INCOMING"},
    {MDM_PROTOCOL_PIAFS_OUTGOING,      0, "PIAFS_OUTGOING"}

};

IDSTR
rgidstrGSMCompatibleProtocols[] =
{


    {MDM_PROTOCOL_HDLCPPP_56K,         0, "HDLC_PPP_56K"},
    {MDM_PROTOCOL_HDLCPPP_64K,         0, "HDLC_PPP_64K"},

    {MDM_PROTOCOL_V110_1DOT2K,         0, "V110_1DOT2K"},
    {MDM_PROTOCOL_V110_2DOT4K,         0, "V110_2DOT4K"},
    {MDM_PROTOCOL_V110_4DOT8K,         0, "V110_4DOT8K"},
    {MDM_PROTOCOL_V110_9DOT6K,         0, "V110_9DOT6K"},
    {MDM_PROTOCOL_V110_12DOT0K,        0, "V110_12DOT0K"},
    {MDM_PROTOCOL_V110_14DOT4K,        0, "V110_14DOT4K"},
    {MDM_PROTOCOL_V110_19DOT2K,        0, "V110_19DOT2K"},
    {MDM_PROTOCOL_V110_28DOT8K,        0, "V110_28DOT8K"},
    {MDM_PROTOCOL_V110_38DOT4K,        0, "V110_38DOT4K"},
    {MDM_PROTOCOL_ANALOG_RLP,          0, "ANALOG_RLP"},
    {MDM_PROTOCOL_ANALOG_NRLP,         0, "ANALOG_NRLP"},
    {MDM_PROTOCOL_GPRS,                0, "GPRS"}

};

#define TITLE_LEN   256
#define DEFAULT_LEN  23
/*----------------------------------------------------------
Purpose: Show the properties of a modem

Returns: winerror
Cond:    --
*/
DWORD CfgDoProperties(
        LPCWSTR         pszFriendlyName,
        HWND            hwndParent,
        LPPROPSHEETPAGE pExtPages,     // Optional; may be NULL
        DWORD           cExtPages,     // Number of external pages
        UMDEVCFG *pDevCfgIn,
        UMDEVCFG *pDevCfgOut
        )
{
    DWORD dwRet = ERROR_INVALID_PARAMETER;
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE hpsPages[MAX_PROP_PAGES];
    LPCFGMODEMINFO pcmi = NULL;
    TCHAR *pcszConnection;
    TCHAR cszConnection[TITLE_LEN];

    // Validate params...

    if (   cExtPages                        // Unsupported
        || pDevCfgIn                        // Unsupported
        || !ValidateDevConfig(pDevCfgOut))
    {
        MYASSERT(FALSE);
        goto end;
    }

    pcmi = ALLOCATE_MEMORY( sizeof(*pcmi));

    if (!pcmi)
    {
        // proper error code
        goto end;
    }

    dwRet =  CMI_Load(
                pcmi,
                pszFriendlyName,
                pDevCfgOut,
                hwndParent
                );

    if (dwRet)
    {
        goto end;
    }

    // Initialize the PropertySheet Header
    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_NOAPPLYNOW;
    psh.hwndParent = hwndParent;
    psh.hInstance = g_hinst;
    psh.nPages = 0;
    psh.nStartPage = 0;
    psh.phpage = (HPROPSHEETPAGE FAR *)hpsPages;
    psh.pszCaption = cszConnection;

    // Make sure the string is null terminated

    pcszConnection = (TCHAR *)pszFriendlyName;
    pcszConnection[MAX_BUF_REG-1] = '\0';

    lstrcpy (cszConnection, pszFriendlyName);
    if (lstrlen (cszConnection) < TITLE_LEN-DEFAULT_LEN)
    {

        if (FALSE == g_dwIsCalledByCpl)
        {
            LoadString(
                g_hinst,
                IDS_CONNECTION_PREF,
                &cszConnection[lstrlen(cszConnection)],
                TITLE_LEN-lstrlen(cszConnection)
                );

        }
        else
        {
            LoadString(
                g_hinst,
                IDS_DEFAULT_PREF,
                &cszConnection[lstrlen(cszConnection)],
                TITLE_LEN-lstrlen(cszConnection)
                );


        }
    }

    dwRet = CfgAddGeneralPage(pcmi, AddInstallerPropPage, (LPARAM)&psh);
    if (NO_ERROR == dwRet)
    {
        dwRet = AddPage(pcmi,
                    MAKEINTRESOURCE(IDD_CFG_ADVANCED),
                    CfgAdv_WrapperProc,
                    AddInstallerPropPage,
                    (LPARAM)&psh);

        if (NO_ERROR == dwRet)
        {
            // Add extra pages if any
            if ((cExtPages != 0) && (pExtPages != NULL))
            {
                AddExtraPages(pExtPages, cExtPages,  AddInstallerPropPage, (LPARAM)&psh);
            }

            // Show the property sheet
            PropertySheet(&psh);

            dwRet = (pcmi->fOK) ? NO_ERROR : ERROR_CANCELLED;
        }
    }

end:

    if (pcmi)
    {
        if (pcmi->c.pProtocolCaps)
        {
            FREE_MEMORY(pcmi->c.pProtocolCaps);
        }

        FREE_MEMORY(pcmi);
        pcmi=NULL;
    }

    return dwRet;
}

DWORD
CMI_Load(
    LPCFGMODEMINFO pcmi,
    LPCTSTR pszFriendlyName,
    UMDEVCFG *pDevCfg,
    HWND            hwndParent
    )
{
    DWORD dwRet = ERROR_INVALID_PARAMETER;
    LPCOMMCONFIG pcc = &(pDevCfg->commconfig);
    LPMODEMSETTINGS pms = PmsFromPcc(pcc);
    LPFINDDEV pfd = NULL;
    DWORD cbData;

    if (!FindDev_Create(&pfd, c_pguidModem, c_szFriendlyName, pszFriendlyName))
    {
        pfd = NULL;
        goto end;
    }


    ZeroMemory(pcmi, sizeof(*pcmi));
    pcmi->dwSig = SIG_CFGMODEMINFO;

    dwRet = RegQueryModemCaps (pfd->hkeyDrv, &(pcmi->c));

    if (ERROR_SUCCESS != dwRet) goto end;

    // Get the MaximumPortSpeed, as set by the user
    cbData = sizeof(DWORD);
    if (ERROR_SUCCESS != RegQueryValueEx (pfd->hkeyDrv, c_szMaximumPortSpeed, NULL, NULL,
                             (LPBYTE)&pcmi->dwMaximumPortSpeed, &cbData))
    {
        pcmi->dwMaximumPortSpeed = pcc->dcb.BaudRate;
    }

    pcmi->w.fdwSettings = MAKELONG(pDevCfg->dfgHdr.fwOptions, pDevCfg->dfgHdr.wWaitBong);
    pcmi->pdcfg = pDevCfg;

    BltByte(&pcmi->w.dcb, &pcc->dcb, sizeof(WIN32DCB));
    BltByte(&pcmi->w.ms, pms, sizeof(MODEMSETTINGS));
    lstrcpyn(
        pcmi->c.szFriendlyName,
        pszFriendlyName,
        SIZECHARS(pcmi->c.szFriendlyName)
        );

    pcmi->hwndParent = hwndParent;

    DEBUG_CODE( DumpModemSettings(pms); )
    DEBUG_CODE( DumpDCB(&pcc->dcb); )
    DEBUG_CODE( DumpDevCaps(&pcmi->c.devcaps); )

    dwRet = ERROR_SUCCESS;

end:
    if (pfd)
    {
        FindDev_Destroy(pfd);
        pfd = NULL;
    }

    return dwRet;
}

void
CMI_UnLoad(
    LPCFGMODEMINFO pcmi
    )
{
    ASSERT(pcmi->dwSig == SIG_CFGMODEMINFO);

    // Free any other stuff ...

    ZeroMemory(pcmi, sizeof(*pcmi));
}

/*----------------------------------------------------------
Purpose: Release the data associated with the General page
Returns: --
Cond:    --
*/
UINT CALLBACK CfgGeneralPageCallback(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp)
{
    //
    // NOTE: NO Global information is saved here!
    //

    if (PSPCB_RELEASE == uMsg)
    {
        LPCFGMODEMINFO pcmi = (LPCFGMODEMINFO)ppsp->lParam;

        ASSERT(pcmi);


        if (pcmi->fOK)
        {
            LPCOMMCONFIG pcc = &(pcmi->pdcfg->commconfig);
            LPMODEMSETTINGS pms = PmsFromPcc(pcc);
            DWORD dwRet;

            // Save the changes back to the commconfig struct
            TRACE_MSG(TF_GENERAL, "Copying DCB and MODEMSETTING back to COMMCONFIG");

            BltByte(pms, &pcmi->w.ms, sizeof(MODEMSETTINGS));
            BltByte(&pcc->dcb, &pcmi->w.dcb, sizeof(WIN32DCB));
            pcmi->pdcfg->dfgHdr.fwOptions = LOWORD(pcmi->w.fdwSettings);
            pcmi->pdcfg->dfgHdr.wWaitBong = HIWORD(pcmi->w.fdwSettings);

            DEBUG_CODE( DumpModemSettings(pms); )
            DEBUG_CODE( DumpDCB(&pcc->dcb); )

            TRACE_MSG(TF_GENERAL, "Releasing the CPL General page");
        }
    }

    return TRUE;
}



/*----------------------------------------------------------
Purpose: Add the General modems page.  The pcmi is the pointer
         to the modeminfo buffer which we can edit.

Returns: ERROR_ values

Cond:    --
*/
DWORD PRIVATE CfgAddGeneralPage(
    LPCFGMODEMINFO pcmi,
    LPFNADDPROPSHEETPAGE pfnAdd,
    LPARAM lParam)
    {
    DWORD dwRet = ERROR_NOT_ENOUGH_MEMORY;
    PROPSHEETPAGE   psp;
    HPROPSHEETPAGE  hpage;
    TCHAR sz[MAXMEDLEN];

    ASSERT(pcmi);
    ASSERT(pfnAdd);

    // Add the Port Settings property page
    //
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USECALLBACK;
    psp.hInstance = g_hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_CFG_GENERAL);
    psp.pfnDlgProc = CfgGen_WrapperProc;
    psp.lParam = (LPARAM)pcmi;
    psp.pfnCallback = CfgGeneralPageCallback;
    psp.pcRefParent = NULL;


    hpage = CreatePropertySheetPage(&psp);
    if (hpage)
        {
        if (!pfnAdd(hpage, lParam))
            DestroyPropertySheetPage(hpage);
        else
            dwRet = NO_ERROR;
        }

    return dwRet;
    }




BOOL ValidateDevConfig(UMDEVCFG *pDevCfg)
{
    BOOL fRet = FALSE;
    DWORD dwCCSize = 0;

    if (!pDevCfg || pDevCfg->dfgHdr.dwSize <= sizeof (*pDevCfg))
    {
        goto end;
    }

    if (pDevCfg->dfgHdr.dwVersion!=UMDEVCFG_VERSION)
    {
        goto end;
    }

    dwCCSize = pDevCfg->commconfig.dwSize;

    if (dwCCSize != CB_COMMCONFIGSIZE)
    {
        goto end;
    }

    if (pDevCfg->dfgHdr.dwSize !=
         (sizeof(*pDevCfg) - sizeof(pDevCfg->commconfig) + CB_COMMCONFIGSIZE))
    {
        goto end;
    }

    fRet = TRUE;

end:
    return fRet;
}


//
//
DWORD
RegQueryModemCaps(
    HKEY hkeyDrv,
    MODEMCAPS *pCaps
    )
{
    DWORD dwRet = ERROR_INVALID_PARAMETER;
    DWORD cbData;

    // Get the port name.  There are two places the port name can be:
    //
    //   1) DriverKey\AttachedTo
    //        This is for internal, external or null modems.  This
    //        port can be changed via the property sheet.
    //

    // Does this modem have a AttachedTo name?
    cbData = sizeof(pCaps->szPortName);
    dwRet = RegQueryValueEx(
                hkeyDrv,
                c_szAttachedTo,
                NULL,
                NULL,
                (LPBYTE)pCaps->szPortName,
                &cbData
                );

    if (ERROR_SUCCESS != dwRet)
    {
        lstrcpy(pCaps->szPortName,TEXT("None"));
        dwRet=ERROR_SUCCESS;
    }

    // Get the device type
    {
        BYTE nDeviceType;
        cbData = sizeof(nDeviceType);
        dwRet = RegQueryValueEx(
                        hkeyDrv,
                        c_szDeviceType,
                        NULL,
                        NULL,
                        (LPBYTE)&nDeviceType,
                        &cbData
                        );

        if (ERROR_SUCCESS != dwRet) goto end;

        pCaps->dwDeviceType = nDeviceType;
    }

    // Get the properties (a portion of the MODEMDEVCAPS structure)
    cbData = sizeof(pCaps->devcaps);
    dwRet = RegQueryValueEx(
                    hkeyDrv,
                    c_szDeviceCaps,
                    NULL,
                    NULL,
                    (LPBYTE)&pCaps->devcaps,
                    &cbData
                    );


    if (ERROR_SUCCESS != dwRet) goto end;

    pCaps->devcaps.dwInactivityTimeout *= GetInactivityTimeoutScale(
                                                hkeyDrv
                                                );

    // Get the protocol caps...
#if 0
    pCaps->pProtocolCaps =  GetProtocolCaps(hkeyDrv);
#else //1
    {
        DWORD cbSize = 0;
        pCaps->pProtocolCaps =  NULL;

        //DebugBreak();

        dwRet =  UnimodemGetExtendedCaps(
                    hkeyDrv,
                    &cbSize,
                    NULL
                    );
        if (ERROR_SUCCESS==dwRet && cbSize)
        {
            pCaps->pProtocolCaps =
                                 (MODEM_PROTOCOL_CAPS*) ALLOCATE_MEMORY(cbSize);

            if (pCaps->pProtocolCaps)
            {
                dwRet =  UnimodemGetExtendedCaps(
                            hkeyDrv,
                            &cbSize,
                            (MODEM_CONFIG_HEADER*) (pCaps->pProtocolCaps)
                            );
                if (ERROR_SUCCESS!=dwRet)
                {
                    // Ouch, error!
                    FREE_MEMORY(pCaps->pProtocolCaps);
                    pCaps->pProtocolCaps = NULL;
                }
                else
                {
                    //
                    // 3/29/1998 JosephJ: WARNING -- we could in principle
                    // get other extended capabilities objects here, but we
                    // assume that it only contains the protocol object, because
                    // we implement UnimodemGetExtendedCaps here itself.
                    // At such a point we make UnimodemGetExtendCaps return
                    // more stuff, we'll have to pick out only the protocol
                    // caps.
                    //
                    if (pCaps->pProtocolCaps->hdr.dwSig
                            !=dwSIG_MODEM_PROTOCOL_CAPS)
                    {
                        ASSERT(FALSE);
                        FREE_MEMORY(pCaps->pProtocolCaps);
                        pCaps->pProtocolCaps = NULL;
                    }
                }
            }
        }
    }
#endif // 1


end:

    return dwRet;
}


MODEM_PROTOCOL_CAPS *
GetProtocolCaps(
        HKEY hkDrv
        )
{
    MODEM_PROTOCOL_CAPS *pCaps = NULL;
    IDSTR *pidstrProtocolValues=NULL;
    UINT cProtocols=0;
    DWORD dwTotalSize = 0;

    //
    // Get the protocols supported...
    // (for now only ISDN!)
    //
    cProtocols = ReadIDSTR(
               hkDrv,
               "Protocol\\ISDN",
               rgidstrISDNCompatibleProtocols,
               (sizeof(rgidstrISDNCompatibleProtocols)
               /sizeof(rgidstrISDNCompatibleProtocols[0])),
               FALSE,
               &pidstrProtocolValues,
               NULL
               );

    if (!cProtocols)
    {
        pidstrProtocolValues=NULL;
        goto end;
    }


    // Now allocate enough space for the CAPS structure
    dwTotalSize =  sizeof(*pCaps) + sizeof(DWORD)*cProtocols;

    pCaps = ALLOCATE_MEMORY( dwTotalSize);

    if (!pCaps)
    {
        cProtocols = 0;
        goto end;
    }

    pCaps->hdr.dwSig = dwSIG_MODEM_PROTOCOL_CAPS;
    pCaps->hdr.dwTotalSize = dwTotalSize;
    pCaps->dwNumProtocols = cProtocols;
    pCaps->dwProtocolListOffset = sizeof(*pCaps);

    // set the array of protocols
    {
        DWORD *pdwDestProtocol      =
                         (DWORD*)(((BYTE*)pCaps)+pCaps->dwProtocolListOffset);
        UINT u=0;

        for (u=0;u<cProtocols;u++)
        {
            *pdwDestProtocol++ = pidstrProtocolValues[u].dwID;
        }
    }

end:

    if (pidstrProtocolValues)
    {
        FREE_MEMORY(pidstrProtocolValues);
        pidstrProtocolValues=NULL;
    }

    if (!cProtocols && pCaps)
    {
        FREE_MEMORY(pCaps);
        pCaps=NULL;
    }

    return pCaps;;
}

BOOL
IsValidProtocol(
    MODEM_PROTOCOL_CAPS *pCaps,
    UINT dwValue
    )
{
    BOOL fRet=FALSE;

    if (pCaps && pCaps->dwNumProtocols)
    {
        PROTOCOL_ITEM *pProtocolItem = (PROTOCOL_ITEM*) ( ((BYTE*)pCaps)
                               + pCaps->dwProtocolListOffset);
        UINT u = pCaps->dwNumProtocols;
        while(u--)
        {
            if (pProtocolItem->dwProtocol == dwValue)
            {
                fRet = TRUE;
                break;
            }
            pProtocolItem++;
        }
    }

    return fRet;
}


DWORD
APIENTRY
UnimodemGetExtendedCaps(
    IN        HKEY  hKey,
    IN OUT    LPDWORD pdwTotalSize,
    IN OUT    MODEM_CONFIG_HEADER *pFirstObj   // OPTIONAL
    )
{
    DWORD dwRet = ERROR_INVALID_PARAMETER;
    IDSTR **ppidstrISDNProtocols=NULL;
    IDSTR **ppidstrGSMProtocols=NULL;
    UINT cISDNProtocols=0;
    UINT cGSMProtocols=0;
    MODEM_PROTOCOL_CAPS *pCaps = NULL;
    DWORD dwNumProtocols=0;
    UINT cbTot = 0;
    UINT i;

    if (!pdwTotalSize)
    {
        // bad params..

        goto end;
    }

    cISDNProtocols = FindKeys(
                       hKey,
                       "Protocol\\ISDN",
                       rgidstrISDNCompatibleProtocols,
                       (sizeof(rgidstrISDNCompatibleProtocols)
                       /sizeof(rgidstrISDNCompatibleProtocols[0])),
                       &ppidstrISDNProtocols
                       );

    cGSMProtocols = FindKeys(
                       hKey,
                       "Protocol\\GSM",
                       rgidstrGSMCompatibleProtocols,
                       (sizeof(rgidstrGSMCompatibleProtocols)
                       /sizeof(rgidstrGSMCompatibleProtocols[0])),
                       &ppidstrGSMProtocols
                       );

    dwNumProtocols = cISDNProtocols+cGSMProtocols;

    if (!dwNumProtocols)
    {
        // Nothing to report. We suceeed.
        *pdwTotalSize = 0;
        dwRet = 0;
        goto end;
    }

    cbTot =  sizeof(MODEM_PROTOCOL_CAPS) + dwNumProtocols*sizeof(PROTOCOL_ITEM);

    for (i=0; i<cISDNProtocols; i++) {

        DWORD    SizeNeeded;

        GetFriendlyProtocolName(
            MDM_GEN_EXTENDEDINFO(MDM_BEARERMODE_ISDN, ppidstrISDNProtocols[i]->dwID),
            NULL,
            0,
            &SizeNeeded
            );

        cbTot+=SizeNeeded;

    }

    for (i=0; i<cGSMProtocols; i++) {

        DWORD    SizeNeeded;

        GetFriendlyProtocolName(
            MDM_GEN_EXTENDEDINFO(MDM_BEARERMODE_GSM, ppidstrGSMProtocols[i]->dwID),
            NULL,
            0,
            &SizeNeeded
            );

        cbTot+=SizeNeeded;

    }


    if (!pFirstObj)
    {
        //
        // Just set the size and return.
        //
        *pdwTotalSize = cbTot;
        dwRet = 0;
        goto end;
    }

    if (cbTot > *pdwTotalSize)
    {
        //
        // Not enough space....
        //
        dwRet =  ERROR_INSUFFICIENT_BUFFER;
        goto end;
    }

    *pdwTotalSize = cbTot;
    ZeroMemory(pFirstObj, cbTot);
    pCaps = (MODEM_PROTOCOL_CAPS*) pFirstObj;

    pCaps->hdr.dwSig  =  dwSIG_MODEM_PROTOCOL_CAPS;
    pCaps->hdr.dwTotalSize = cbTot;
    pCaps->hdr.dwFlags =  0;
    pCaps->dwNumProtocols = dwNumProtocols;
    pCaps->dwProtocolListOffset = sizeof(MODEM_PROTOCOL_CAPS);

    //
    // Now we fill out the protocols ... we add the BEARERMODE
    // bits (ISDN/GSM) while doing so
    //
    {
        PROTOCOL_ITEM *ProtocolItem = (PPROTOCOL_ITEM)(pCaps+1);
        LPTSTR        StringLocation=(LPTSTR)(ProtocolItem+pCaps->dwNumProtocols);
        UINT          SizeNeeded;
        UINT u=0;

        //
        // ISDN ...
        //
        for (u=0;u<cISDNProtocols;u++)
        {
            ProtocolItem->dwProtocol = MDM_GEN_EXTENDEDINFO(
                                MDM_BEARERMODE_ISDN,
                                ppidstrISDNProtocols[u]->dwID
                                );


            GetFriendlyProtocolName(
                MDM_GEN_EXTENDEDINFO(MDM_BEARERMODE_ISDN, ppidstrISDNProtocols[u]->dwID),
                StringLocation,
                cbTot-(DWORD)(((PUCHAR)StringLocation-(PUCHAR)pFirstObj)),
                &SizeNeeded
                );

            ProtocolItem->dwProtocolNameOffset=((DWORD)((PUCHAR)StringLocation-(PUCHAR)pFirstObj));

            ProtocolItem++;
            StringLocation+=SizeNeeded/sizeof(TCHAR);

        }

        //
        // GSM ...
        //
        for (u=0;u<cGSMProtocols;u++)
        {
            ProtocolItem->dwProtocol = MDM_GEN_EXTENDEDINFO(
                                MDM_BEARERMODE_GSM,
                                ppidstrGSMProtocols[u]->dwID
                                );


            GetFriendlyProtocolName(
                MDM_GEN_EXTENDEDINFO(MDM_BEARERMODE_GSM, ppidstrGSMProtocols[u]->dwID),
                StringLocation,
                cbTot-(DWORD)(((PUCHAR)StringLocation-(PUCHAR)pFirstObj)),
                &SizeNeeded
                );

            ProtocolItem->dwProtocolNameOffset=((DWORD)((PUCHAR)StringLocation-(PUCHAR)pFirstObj));

            ProtocolItem++;
            StringLocation+=SizeNeeded/sizeof(TCHAR);

        }

        //
        // We should have filled out exactly as many elements as are in
        // the DWORD protocol array.
        //
        ASSERT((ProtocolItem-((PPROTOCOL_ITEM)(pCaps+1)))==(int)pCaps->dwNumProtocols);
    }

    dwRet = 0;

    // succes -- fall through ...

end:

    if (ppidstrISDNProtocols)
    {
        FREE_MEMORY(ppidstrISDNProtocols);
        ppidstrISDNProtocols=NULL;
    }

    if (ppidstrGSMProtocols)
    {
        FREE_MEMORY(ppidstrGSMProtocols);
        ppidstrGSMProtocols=NULL;
    }

    return dwRet;

}


LONG
GetFriendlyProtocolName(
    DWORD    ProtocolId,
    LPTSTR   FriendlyName,
    DWORD    BufferLength,
    LPDWORD  StringLength
    )

{
    DWORD    i=0;

    while (s_rgErrorControl[i].dwValue != 0) {

        if (ProtocolId == s_rgErrorControl[i].dwValue) {

            break;
        }

        i++;
    }

    if (s_rgErrorControl[i].dwValue == 0) {
        //
        //  did not find protocol
        //
        ASSERT(0);

        if (FriendlyName != NULL) {

            lstrcpyn(FriendlyName,TEXT("Unknown Protocol"),BufferLength/sizeof(TCHAR));

            *StringLength = (lstrlen(FriendlyName)+1)*sizeof(TCHAR);

            return ERROR_SUCCESS;
        } else {

            *StringLength=sizeof(TEXT("Unknown Protocol"));

            return ERROR_SUCCESS;
        }
    } else {
        //
        //  found the protocol, load the string
        //
        LONG   CharactersCopied;

        if (FriendlyName != NULL) {

            CharactersCopied=LoadString(
                g_hinst,
                s_rgErrorControl[i].dwIDS,
                FriendlyName,
                BufferLength/sizeof(TCHAR)
                );

            *StringLength=(CharactersCopied+1)*sizeof(TCHAR);

            return ERROR_SUCCESS;

        } else {
            //
            //  just checking the length
            //
            TCHAR   TempBuffer[1024];


            CharactersCopied=LoadString(
                g_hinst,
                s_rgErrorControl[i].dwIDS,
                TempBuffer,
                sizeof(TempBuffer)/sizeof(TCHAR)
                );

            *StringLength=(CharactersCopied+1)*sizeof(TCHAR);

            return ERROR_SUCCESS;
        }
    }

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\modemui\country.c ===
#include "proj.h"     // common headers

#include "translate.h"

BYTE FindGCICode(DWORD CountryCode)
{
    int i;

    for (i=0;i<(sizeof(CountryTranslationTable) / sizeof(DWORD));i+=2)
    {
        if (CountryTranslationTable[i] == CountryCode)
            return ((BYTE)CountryTranslationTable[i+1]);
    }

    return 0xff;
}

DWORD FindTapi(DWORD *dwCountry)
{
    DWORD dwResult = ERROR_BADKEY;
    HKEY hKeyTapi = NULL;
    *dwCountry = 0;
                
    TRACE_MSGA(TF_GENERAL,"Find Tapi location\n");

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations"),
                     0,
                     KEY_READ,
                     &hKeyTapi) == ERROR_SUCCESS)
    {
        DWORD cbData;
        DWORD dwRet;
        CHAR szSubkeyname[1024];
        DWORD dwSubkeynamesize = 0;

        ZeroMemory(szSubkeyname,1024);
        dwSubkeynamesize = 1024;
        if (RegEnumKeyExA(hKeyTapi,0,szSubkeyname,&dwSubkeynamesize,NULL,NULL,NULL,NULL) == ERROR_SUCCESS)
        {
            HKEY hKeySub;
            DWORD dwType = 0;

            TRACE_MSGA(TF_GENERAL,"Sub Key: %s\n",szSubkeyname);

            if (RegOpenKeyExA(hKeyTapi,szSubkeyname,0,KEY_READ,&hKeySub) == ERROR_SUCCESS)
            {
                cbData = sizeof(DWORD);
                dwRet = RegQueryValueEx(hKeySub,TEXT("Country"),NULL,&dwType,(LPBYTE)dwCountry,&cbData);
                if ((dwRet == ERROR_SUCCESS) && (dwType == REG_DWORD))
                {
                    TRACE_MSGA(TF_GENERAL,"Found tapi location %d\n",(int)*dwCountry);
                    dwResult = ERROR_SUCCESS;
                } else
                {
                    TRACE_MSGA(TF_ERROR,"Could not find tapi location\n");
                }
                RegCloseKey(hKeySub);
            } else
            {
                TRACE_MSGA(TF_ERROR,"Failed to open tapi subkey\n");
            }
        } else
        {
            TRACE_MSGA(TF_ERROR,"Failed to find tapi subkey\n");
        }
        RegCloseKey(hKeyTapi);
    } else
    {
        TRACE_MSGA(TF_ERROR,"Could not open tapi reg key\n");
    }

    return(dwResult);
}



VOID WINAPI
PrintString(
    LPCSTR    lpsz
    );


VOID WINAPI
PrintString(
    LPCSTR    lpsz
    )

{
#if DBG
    char    Temp[2];
    char    Buffer[1024];
    LPSTR   Current;

    Current=Buffer;

    Buffer[0]='\0';
    Temp[1]=0;

    while (*lpsz != '\0') {

        if (*lpsz == '\r') {

            lstrcatA(Current,"<cr>");

        } else {

            if (*lpsz == '\n') {

                lstrcatA(Current,"<lf>");

            } else {

                if (*lpsz < ' ' || *lpsz > 0x7e) {

                    lstrcatA(Current,".");

                } else {

                    Temp[0]=*lpsz;
                    lstrcatA(Current,Temp);
                }
            }
        }
        lpsz++;
    }

    TRACE_MSGA(TF_GENERAL, "String :%s",Current);
#endif
    return;

}




#define MAX_MODEM_COMMAND_LENGTH     40
#define MAX_MODEM_RESPONSE_LENGTH    40

typedef struct _COMMAND_OBJECT {

    DWORD    TimeOut;
    UCHAR    CommandToSend[MAX_MODEM_COMMAND_LENGTH];
    UCHAR    ExpectedResponse[MAX_MODEM_RESPONSE_LENGTH];

} COMMAND_OBJECT, *PCOMMAND_OBJECT;


const CHAR  EchoOff[]          = "ATQ0E0V1\r";
const CHAR  OkResponse[]       = "\r\nOK\r\n";
const CHAR  OkResponse2[]      = "OK";
const CHAR  CurrentSetting[]   = "AT+GCI?\r";
const CHAR  PossibleSettings[] = "AT+GCI=?\r";
const CHAR  GciResponse[]      = "+GCI:";

CONST TCHAR cszFriendlyName[] = TEXT("FriendlyName");

BOOL WINAPI
SetComm(
    HANDLE    CommHandle,
    DWORD     BaudRate
    )

{
    DCB       Dcb;
    BOOL      bResult;

    bResult=GetCommState(
        CommHandle,
        &Dcb
        );

    if (!bResult) {

        return bResult;
    }

    Dcb.BaudRate=BaudRate;
    Dcb.Parity=0;
    Dcb.StopBits=ONESTOPBIT;
    Dcb.fBinary=TRUE;
    Dcb.ByteSize=8;
    Dcb.fOutxCtsFlow=TRUE;
    Dcb.fRtsControl=RTS_CONTROL_HANDSHAKE;	

    bResult=SetCommState(
        CommHandle,
        &Dcb
        );

    return bResult;

}

BOOL WINAPI
ReadAndWait(
    HANDLE        CommHandle,
    LPVOID        Buffer,
    DWORD         BufferLength,
    LPDWORD       BytesRead,
    BOOL          Wait
    )

{
    OVERLAPPED    OverLapped;
    BOOL          bResult;

    OverLapped.hEvent=CreateEvent(
        NULL,
        FALSE,
        FALSE,
        NULL
        );

    if (NULL == OverLapped.hEvent ) {

        return FALSE;

    }


    bResult=ReadFile(
        CommHandle,
        Buffer,
        BufferLength,
        BytesRead,
        &OverLapped
        );

    if (!bResult && GetLastError()==ERROR_IO_PENDING) {
        //
        //  operation pended
        //
        bResult=GetOverlappedResult(
            CommHandle,
            &OverLapped,
            BytesRead,
            Wait
            );

    } 

    CloseHandle(OverLapped.hEvent);

    return bResult;

}

BOOL WINAPI
WriteAndWait(
    HANDLE        CommHandle,
    LPCVOID        Buffer,
    DWORD         BufferLength,
    LPDWORD       BytesWritten
    )

{
    OVERLAPPED    OverLapped;
    BOOL          bResult;

    OverLapped.hEvent=CreateEvent(
        NULL,
        FALSE,
        FALSE,
        NULL
        );

    if (NULL == OverLapped.hEvent ) {

        return FALSE;

    }


    bResult=WriteFile(
        CommHandle,
        Buffer,
        BufferLength,
        BytesWritten,
        &OverLapped
        );

    if (!bResult && GetLastError()==ERROR_IO_PENDING) {
        //
        //  operation pended
        //
        bResult=GetOverlappedResult(
            CommHandle,
            &OverLapped,
            BytesWritten,
            TRUE
            );

    } 

    CloseHandle(OverLapped.hEvent);

    return bResult;

}





LONG WINAPI
IssueCommand(
    HANDLE           CommHandle,
    PCOMMAND_OBJECT  Command
    )

{

    BOOL           bResult;
    COMMTIMEOUTS   CommTimeouts;
    OVERLAPPED     OverLapped;
    DWORD          BytesWritten;

    CommTimeouts.ReadIntervalTimeout=50;
    CommTimeouts.ReadTotalTimeoutMultiplier=2;
    CommTimeouts.ReadTotalTimeoutConstant=Command->TimeOut;
    //CommTimeouts.WriteTotalTimeoutMultiplier=2;
    CommTimeouts.WriteTotalTimeoutMultiplier=10;
    //CommTimeouts.WriteTotalTimeoutConstant=10;
    CommTimeouts.WriteTotalTimeoutConstant=2000;

    bResult=SetCommTimeouts(
        CommHandle,
        &CommTimeouts
        );
    
    if (!bResult) {

        return GetLastError();
    }

    if (Command->CommandToSend[0] != '\0') {

        bResult=PurgeComm(
            CommHandle,
            PURGE_TXCLEAR | PURGE_RXCLEAR
            );

        if (!bResult) {

            return GetLastError();
        }
    

        OverLapped.hEvent=CreateEvent(
            NULL,
            FALSE,
            FALSE,
            NULL
            );

        if (NULL == OverLapped.hEvent ) {

            return GetLastError();
        }

        TRACE_MSGA(TF_GENERAL, "IssueCommand: Sending");
#if DBG
        PrintString(Command->CommandToSend);
#endif
        bResult=WriteFile(
            CommHandle,
            Command->CommandToSend,
            strlen(Command->CommandToSend),
            &BytesWritten,
            &OverLapped
            );

        if (!bResult && GetLastError()==ERROR_IO_PENDING) {
            //
            //  operation pended
            //
            bResult=GetOverlappedResult(
                CommHandle,
                &OverLapped,
                &BytesWritten,
                TRUE
                );

        } else {

            CloseHandle(OverLapped.hEvent);
            return GetLastError();
        }

        if (!bResult || strlen(Command->CommandToSend) != BytesWritten) {

            CloseHandle(OverLapped.hEvent);
            return GetLastError();
        }

    }

    CloseHandle(OverLapped.hEvent);

    if (strlen(Command->ExpectedResponse) > 0) {

        DWORD    ResponseLength=0;
        UCHAR    ResponseBuffer[MAX_MODEM_RESPONSE_LENGTH];


        while (ResponseLength < MAX_MODEM_RESPONSE_LENGTH ) {

            bResult=ReadAndWait(
                CommHandle,
                &ResponseBuffer[ResponseLength],
                1,
                &BytesWritten,
                TRUE
                );

            if (!bResult) {

                TRACE_MSGA(TF_ERROR,"IssueCommand: ReadFile failed, %08x",GetLastError() );

                break;
            }

            if (BytesWritten == 0) {

                TRACE_MSGA(TF_ERROR,"IssueCommand: ReadFile timed out");
                break;
            }

            ResponseLength++;

            if (_strnicmp(ResponseBuffer,Command->CommandToSend,ResponseLength)==0) {
                //
                //  match echo
                //
                if (ResponseLength == strlen(Command->CommandToSend)) {
                    //
                    //  got the whole echo
                    //
                    ResponseBuffer[ResponseLength]='\0';
                    TRACE_MSGA(TF_GENERAL, "IssueCommand: Got Echo: ");
#if DBG
                    PrintString(ResponseBuffer);
#endif
                    ResponseLength = 0;
                }

            } else {

                if (_strnicmp(ResponseBuffer,Command->ExpectedResponse,ResponseLength)==0) {
                    //
                    //  match expected response 
                    //
                    if (ResponseLength == strlen(Command->ExpectedResponse)) {
                        //
                        //  got a match
                        //
                        ResponseBuffer[ResponseLength]='\0';
                        TRACE_MSGA(TF_GENERAL, "IssueCommand: Got Response");
#if DBG
                        PrintString(ResponseBuffer);
#endif
                        return ERROR_SUCCESS;
                    }

                } else {
                    //
                    //  did not match, done.
                    //
                    Sleep(200);

                    bResult=ReadAndWait(
                        CommHandle,
                        &ResponseBuffer[ResponseLength],
                        (MAX_MODEM_RESPONSE_LENGTH-ResponseLength)-1,
                        &BytesWritten,
                        FALSE
                        );

                    ResponseLength+=BytesWritten;

                    ResponseBuffer[ResponseLength]='\0';
                    TRACE_MSGA(TF_GENERAL, "IssueCommand: Got bad Response: ");
#if DBG
                    PrintString(ResponseBuffer);
#endif

                    return ERROR_NOT_ENOUGH_MEMORY;
                }
            }
           
        } // while

        return ERROR_NOT_ENOUGH_MEMORY;

    }    

    return ERROR_SUCCESS;

}

#define DOSDEVICEROOT TEXT("\\\\.\\")

HANDLE WINAPI
OpenDeviceHandle(
    HKEY     ModemRegKey,
    BOOL     Tsp
    )

{
    LONG     lResult;
    DWORD    Type;
    DWORD    Size;

    HANDLE   FileHandle;
    TCHAR    FriendlyName[MAX_PATH];



    lstrcpy(FriendlyName,DOSDEVICEROOT);

    Size=sizeof(FriendlyName)-((lstrlen(FriendlyName)+1)*sizeof(TCHAR));
    //
    //  read the friendly name from the registry
    //
    lResult=RegQueryValueEx(
        ModemRegKey,
        cszFriendlyName,
        NULL,
        &Type,
        (LPBYTE)(FriendlyName+lstrlen(FriendlyName)),
        &Size
        );

    if ((lResult != ERROR_SUCCESS) || (Type != REG_SZ)) {

        TRACE_MSGA(TF_ERROR,"Could not read Friendly Name from Registry %08lx\n",lResult);

        return INVALID_HANDLE_VALUE;

    }

    if (Tsp) 
    {

        DWORD Length = 0;

        Length = sizeof(FriendlyName) - (lstrlen(FriendlyName) * sizeof(TCHAR));

        if ((DWORD)lstrlen(TEXT("\\Tsp")) < (Length / sizeof(TCHAR)))
        {
            lstrcat(FriendlyName,TEXT("\\Tsp"));
        } else
        {
            return INVALID_HANDLE_VALUE;
        }

    } else {

        DWORD Length = 0;

        Length = sizeof(FriendlyName) - (lstrlen(FriendlyName) * sizeof(TCHAR));

        if ((DWORD)lstrlen(TEXT("\\Client")) < (Length / sizeof(TCHAR)))
        {
            lstrcat(FriendlyName,TEXT("\\Client"));
        } else
        {
            return INVALID_HANDLE_VALUE;
        }
    }

    TRACE_MSGA(TF_GENERAL,"Opening %s\n",FriendlyName);

    //
    //  open the modem device using the friendly name
    //
    FileHandle=CreateFile(
        FriendlyName,
        GENERIC_WRITE | GENERIC_READ,
        FILE_SHARE_WRITE | FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_OVERLAPPED,
        NULL
        );

    if (FileHandle == INVALID_HANDLE_VALUE) {

        TRACE_MSGA(TF_ERROR,"Failed to open (%s). %08lx\n",FriendlyName,GetLastError());

    }

    return FileHandle;

}


CHAR
ctox(
    BYTE    c
    )

{

    if ( (c >= '0') && (c <= '9')) {

        return c-'0';

    }

    if ( (c >= 'A') && (c <= 'F')) {

        return (c-'A')+10;
    }

    if ( (c >= 'a') && (c <= 'f')) {

        return (c-'a')+10;
    }

    return 0;
}


LONG
QueryModemForCountrySettings(
    HKEY    ModemRegKey,
    BOOL    ForceRequery
    )

{
    HANDLE    FileHandle;
    LONG      lResult;
    BOOL      bResult;
    ULONG     BytesTransfered;
    CHAR      ResponseBuffer[4096];
    BYTE      Countries[2048];
    ULONG     CountryCount=0;
    DWORD     CurrentCountry=0;
    DWORD     Value;
    DWORD     Type;
    DWORD     Size;
    PVOID     TapiHandle=NULL;
    CHAR      TempCommand[4096];
    DWORD     dwCountry=0;
    BYTE      bGci = 0;
    BYTE      bNewGCI = 0;
    BOOL      bError = FALSE;

    COMMAND_OBJECT    CommandObject;

    //
    //  See if we have a predetermined country code based on the TAPI settings
    // 

    if (FindTapi(&dwCountry) == ERROR_SUCCESS)
    {
       bNewGCI = FindGCICode(dwCountry);
       if (bNewGCI != 0xff)
       {
           TRACE_MSGA(TF_GENERAL,"Predetermined country: %.2x\n",bNewGCI);
           bGci = 1;
       } else
       {
           TRACE_MSGA(TF_GENERAL,"Could not determine country\n");
           bGci = 0;
       }
    } else
    {
        TRACE_MSGA(TF_GENERAL,"Could not found tapi country code\n");
        bGci = 0;
    }
        

    //
    //  check to see if we have already queryied this modem properties
    //

    if (!ForceRequery) {
        //
        //  just a normal query request
        //
        Size=sizeof(Value);

        lResult=RegQueryValueEx(
            ModemRegKey,
            TEXT("CheckedForCountrySelect"),
            NULL,
            &Type,
            (BYTE*)&Value,
            &Size
            );

        if ((lResult == ERROR_SUCCESS) && (Type == REG_DWORD) && (Value == 1)) {
            //
            //  we have already tried to check this modems properties, the values will be in
            //  the registry
            //
            return ERROR_SUCCESS;
        }

    } else {
        //
        //  we want to force the modem to requeried again, such as the case of the driver
        //  being reinstalled
        //
        RegDeleteValue(
            ModemRegKey,
            TEXT("CheckedForCountrySelect")
            );

    }

    //
    //  try to open the device so we can send some commands
    //
    FileHandle=OpenDeviceHandle(ModemRegKey,TRUE);

    if (FileHandle == INVALID_HANDLE_VALUE) {
        //
        //  could not open the port directly, try through tapi
        //
        LONG     lResult2;
        DWORD    Type2;
        DWORD    Size2;

        TCHAR    FriendlyName[MAX_PATH];

        Size2=sizeof(FriendlyName);
        //
        //  read the friendly name from the registry
        //
        lResult2=RegQueryValueEx(
            ModemRegKey,
            cszFriendlyName,
            NULL,
            &Type2,
            (LPBYTE)FriendlyName,
            &Size2
            );

        if (lResult2 != ERROR_SUCCESS)
        {
            return lResult2;
        }

        if (Type2 != REG_SZ)
        {
            return lResult2;
        }

        FileHandle=GetModemCommHandle(FriendlyName,&TapiHandle);

        if (FileHandle == NULL) {

            return GetLastError();
        }
    }

    CommandObject.TimeOut=10000;
    lstrcpyA(CommandObject.CommandToSend,EchoOff);
    lstrcpyA(CommandObject.ExpectedResponse,OkResponse);


    //
    //  turn echo and make sure the modem is responsive.
    //
    lResult=IssueCommand(
        FileHandle,
        &CommandObject
        );

    if (lResult != ERROR_SUCCESS) {
        //
        //  the modem does not seem to be responding
        //
        goto Cleanup;
    }

    //
    //  write a value to the registry to signify that we have checked this modem for
    //  country select support.
    //
    Value=1;

    RegSetValueEx(
        ModemRegKey,
        TEXT("CheckedForCountrySelect"),
        0,
        REG_DWORD,
        (BYTE*)&Value,
        sizeof(Value)
        );


    //
    // echo should be off now
    //
    PrintString(CurrentSetting);

    WriteAndWait(
        FileHandle,
        CurrentSetting,
        lstrlenA(CurrentSetting),
        &BytesTransfered
        );

    Sleep(100);

    ZeroMemory(ResponseBuffer,sizeof(ResponseBuffer));


    ReadAndWait(
        FileHandle,
        ResponseBuffer,
        sizeof(ResponseBuffer)-1,
        &BytesTransfered,
        TRUE
        );

    if (BytesTransfered > 0) {
        //
        //  we got something back
        //
        int      Match;
        int      GciLength=lstrlenA(GciResponse);
        LPSTR    Temp=ResponseBuffer;
        LPSTR    Temp2=ResponseBuffer;
        int      count;

        PrintString(ResponseBuffer);

        while (*Temp != '\0') {
            //
            //  not the end of the string
            //
            if ((*Temp != '\r') && (*Temp != '\n')) {
                //
                //  somthing other than a CR or LF
                //
                break;
            }

            Temp++;
        }

        PrintString(Temp);

        Match=_strnicmp(Temp,GciResponse,GciLength);

        if (Match == 0) {
            //
            //  it matched the the beggining of the cgi command
            //
            //
            //  Check for the space after +GCI: response. Some modems
            //  can't follow specs.
            //
            //

            Temp2 = Temp2 + GciLength;

            count = 0;
            while(*Temp2 != '\0')
            {
                if ( ((*Temp2 >= '0') && (*Temp2 <= '9'))
                   || ((*Temp2 >= 'a') && (*Temp2 <= 'f'))
                   || ((*Temp2 >= 'A') && (*Temp2 <= 'F')))
                   {
                       count++;
                   }
                Temp2++;
            }

            if (count == 1)
            {
                if (Temp[GciLength] == ' ')
                {
                    CurrentCountry = ctox(Temp[GciLength+1]);
                } else
                {
                    CurrentCountry = ctox(Temp[GciLength]);
                }
            } else if (count == 2)
            {
                if (Temp[GciLength] == ' ')
                {
                    CurrentCountry  = ctox(Temp[ GciLength+1 ] )*16;
                    CurrentCountry += ctox(Temp[ GciLength+2 ] );
                } else
                {
                    CurrentCountry  = ctox(Temp[ GciLength   ] )*16;
                    CurrentCountry += ctox(Temp[ GciLength+1 ] );
                }
            } else
            {
                goto Cleanup;
                return lResult;
            }

        } else {
            //
            //  we did not get the expect response
            //
            goto Cleanup;

            return lResult;
        }

    } else {
        //
        //  we did not get anything back from the modem
        //
        goto Cleanup;

        return lResult;
    }

    // Set the existing country. If it fails then disable country/region pulldown
 

    wsprintfA(TempCommand,"AT+GCI=%.2x\r",CurrentCountry);

    PrintString(TempCommand);

    WriteAndWait(
        FileHandle,
        TempCommand,
        lstrlenA(TempCommand),
        &BytesTransfered
    );

    ZeroMemory(ResponseBuffer,sizeof(ResponseBuffer));

    ReadAndWait(
        FileHandle,
        ResponseBuffer,
        sizeof(ResponseBuffer)-1,
        &BytesTransfered,
        TRUE
    );

    if (BytesTransfered > 0)
    {
        // we got something
        int     Match;
        int     OkLength=lstrlenA(OkResponse2);
        LPSTR   Temp=ResponseBuffer;

        PrintString(ResponseBuffer);

        //
        //  advance past any leading CR's and LF's
        //
        while (*Temp != '\0') {
            //
            //  not the end of the string
            //
            if ((*Temp != '\r') && (*Temp != '\n')) {
                //
                //  somthing other than a CR or LF
                //
                break;
            }

            Temp++;
        }

        //
        //  we should be at the first non CR, LF
        //
        Match=_strnicmp(Temp,OkResponse2,OkLength);

        if (Match != 0)
        {
            goto Cleanup;
            return lResult;
        }

    } else
    {
        goto Cleanup;

        return lResult;
    }

    //
    //  we got the current setting of the modem, now get the possible settings
    //

    PrintString(PossibleSettings);

    WriteAndWait(
        FileHandle,
        PossibleSettings,
        lstrlenA(PossibleSettings),
        &BytesTransfered
        );

    ZeroMemory(ResponseBuffer,sizeof(ResponseBuffer));


    ReadAndWait(
        FileHandle,
        ResponseBuffer,
        sizeof(ResponseBuffer)-1,
        &BytesTransfered,
        TRUE
        );

    if (BytesTransfered > 0) {
        //
        //  we got something back
        //
        int     Match;
        int     GciLength=lstrlenA(GciResponse);
        LPSTR   Temp=ResponseBuffer;

        PrintString(ResponseBuffer);


        //
        //  advance past any leading CR's and LF's
        //
        while (*Temp != '\0') {
            //
            //  not the end of the string
            //
            if ((*Temp != '\r') && (*Temp != '\n')) {
                //
                //  somthing other than a CR or LF
                //
                break;
            }

            Temp++;
        }

        //
        //  we should be at the first non CR, LF
        //
        Match=_strnicmp(Temp,GciResponse,GciLength);

        if (Match == 0) {
            //
            //  we matched the +gci:
            //
            CHAR   Delimiters[]=",() ";
            BYTE   CountryCode;
            LPSTR  Token;
            LPSTR  StartOfCountryCodes = Temp+GciLength;

            //
            //  move past the gci: at the beggining of the response
            //
            Temp+=GciLength;

            while (*Temp != '\0') {

                if (*Temp == ')') {
                    //
                    //  change the closing paren to a null so we will stop there
                    //
                    *Temp='\0';
                    break;
                }

                Temp++;
            }


            PrintString(StartOfCountryCodes);

            Temp = StartOfCountryCodes;
            while (*Temp != '\0')
            {
                if (  ((*Temp >= '0') && (*Temp <= '9'))
                      || ((*Temp >= 'A') && (*Temp <= 'F'))
                      || ((*Temp >= 'a') && (*Temp <= 'f')))
                {
                    CountryCode = ctox(*Temp);
                    Temp++;
                    if (*Temp != '\0')
                    {
                        CountryCode *= 16;
                        CountryCode += ctox(*Temp);
                        Countries[CountryCount] = CountryCode;
                        CountryCount++;
                        Temp++;
                    }
                } else
                {

                    Temp++;
                }
            }

 
        }
    }

    // Set to tapi location if exists
    if (bGci)
    {
        wsprintfA(TempCommand,"AT+GCI=%.2x\r",bNewGCI);
        PrintString(TempCommand);
        WriteAndWait(FileHandle,TempCommand,lstrlenA(TempCommand),&BytesTransfered);
        ZeroMemory(ResponseBuffer,sizeof(ResponseBuffer));
        ReadAndWait(FileHandle,ResponseBuffer,sizeof(ResponseBuffer)-1,&BytesTransfered,TRUE);
        if (BytesTransfered > 0)
        {
            int Match;
            int OkLength=lstrlenA(OkResponse2);
            LPSTR Temp=ResponseBuffer;
            PrintString(ResponseBuffer);

            // Advance past any leading CR's and LF's
            while(*Temp != '\0')
            {
                if ((*Temp != '\r') && (*Temp != '\n'))
                {
                    break;
                }
                Temp++;
            }

            Match = _strnicmp(Temp,OkResponse2,OkLength);

            // If we get an OK then change the current country to the new gci setting
            // If not then default

            if (Match == 0)
            {
                CurrentCountry = bNewGCI;
            }
        }
    }


    //
    //  done with the modem
    //


    if (CountryCount > 1) {

        RegSetValueEx(ModemRegKey,
                      TEXT("MSCurrentCountry"),
                      0,
                      REG_DWORD,
                      (BYTE*)&CurrentCountry,
                      sizeof(CurrentCountry)
                      );

        RegSetValueEx(
            ModemRegKey,
            TEXT("CountryList"),
            0,
            REG_BINARY,
            Countries,
            CountryCount
            );

    }

Cleanup:

    CloseHandle(FileHandle);

    if (TapiHandle != NULL) {

        FreeModemCommHandle(TapiHandle);
    }

    return lResult;

}



void CountryRunOnce()
{
    HDEVINFO hdi;
    SP_DEVINFO_DATA devdata;
    int iIndex = 0;
    DWORD Value = 0;
    DWORD Type = 0;
    DWORD Size = 0;
    LONG lResult;

#ifdef DEBUG
    RovComm_ProcessIniFile();
#endif

    hdi = SetupDiGetClassDevs(c_pguidModem,NULL,NULL,0);

    if (hdi != INVALID_HANDLE_VALUE)
    {
        devdata.cbSize = sizeof(devdata);
        while(SetupDiEnumDeviceInfo(hdi,iIndex,&devdata))
        { 
            HKEY hkeyDrv;

            hkeyDrv = SetupDiOpenDevRegKey(hdi,
                                           &devdata,
                                           DICS_FLAG_GLOBAL,
                                           0,
                                           DIREG_DRV,
                                           KEY_READ | KEY_WRITE);

            if (hkeyDrv != INVALID_HANDLE_VALUE)
            {
                QueryModemForCountrySettings(hkeyDrv,TRUE);

                RegCloseKey(hkeyDrv);
            }

            iIndex++;
        }

        SetupDiDestroyDeviceInfoList(hdi);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\modemui\cpl.c ===
/*
 *  Control Panel routines for modems including the listbox dialog
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1993-1995
 *  All rights reserved
 *
 */

#include "proj.h"
#include <cpl.h>
#include <dbt.h>

#include <objbase.h>
#include <initguid.h>

// #define DIAGNOSTIC 1

#define WM_ENABLE_BUTTONS   (WM_USER+100)

#define FLAG_PROP_ENABLED   0x1
#define FLAG_DEL_ENABLED    0x2
#define FLAG_MSG_POSTED     0x4

// Column subitems
#define ICOL_MODEM      0
#define ICOL_PORT       1

#define LV_APPEND       0x7fffffff

#define PmsFromPcc(pcc) ((LPMODEMSETTINGS)(pcc)->wcProviderData)

// Global flags.  See cpl\modem.h for their values.
int g_iCPLFlags = FLAG_PROCESS_DEVCHANGE;

DWORD gDeviceFlags = 0;

int g_CurrentSubItemToSort = ICOL_MODEM;
BOOL g_bSortAscending = TRUE;

// Map driver type values to imagelist index
struct 
{
    BYTE    nDeviceType;    // DT_ value
    UINT    idi;            // icon resource ID
    int     index;          // imagelist index
} g_rgmapdt[] = {{ DT_NULL_MODEM,     IDI_NULL_MODEM,     0 },
                 { DT_EXTERNAL_MODEM, IDI_EXTERNAL_MODEM, 0 },
                 { DT_INTERNAL_MODEM, IDI_INTERNAL_MODEM, 0 },
                 { DT_PCMCIA_MODEM,   IDI_PCMCIA_MODEM,   0 },
                 { DT_PARALLEL_PORT,  IDI_NULL_MODEM,     0 },
                 { DT_PARALLEL_MODEM, IDI_EXTERNAL_MODEM, 0 } };

// Local clipboard for modem properties
struct
{
    DWORD dwIsDataValid;
    DWORD dwBaudRate;
    DWORD dwTic;
    DWORD dwCopiedOptions;
    DWORD dwPreferredModemOptions;
    TCHAR szUserInit[LINE_LEN];
    BYTE  dwLogging;
} g_PropertiesClipboard = {FALSE, 0};


// Tic structure for volume settings
#define MAX_NUM_VOLUME_TICS 4

typedef struct
{
    int  ticVolumeMax;
    struct
    {                // volume tic mapping info
        DWORD dwVolume;
        DWORD dwMode;
    } tics[MAX_NUM_VOLUME_TICS];
    
} TIC, *PTIC;


// 07/22/1997 - EmanP
// Define prorotype for InstallNewDevice, exported
// by newdev.dll, which we will now call in order
// to get to the hardware wizard, instead of calling
// the class installer directly;
// also, define constants for the name of the dll and
// the export
typedef BOOL (*PINSTNEWDEV)(HWND, LPGUID, PDWORD);

#define NEW_DEV_DLL         TEXT("hdwwiz.cpl")
#define INSTALL_NEW_DEVICE  "InstallNewDevice"

/*
BOOL
RestartComputerDlg(
    IN HWND hwndOwner );

BOOL
RestartComputer();
*/

BOOL IsSelectedModemWorking(
            HWND hwndLB,
            int iItem
        );

int
CALLBACK
ModemCpl_Compare(
    IN LPARAM lparam1,
    IN LPARAM lparam2,
    IN LPARAM lparamSort);

INT_PTR CALLBACK DiagWaitModemDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

// This structure is used to represent each modem item
// in the listview
typedef struct tagMODEMITEM
{
    DWORD           dwFlags;
    SP_DEVINFO_DATA devData;
    MODEM_PRIV_PROP mpp;
} MODEMITEM, FAR * PMODEMITEM;


#define MIF_LEGACY          0x000000001
#define MIF_NOT_PRESENT     0x000000002
#define MIF_PROBLEM         0x000000004

// Special-case alphanumeric stringcmp.
int my_lstrcmp_an(LPTSTR lptsz1, LPTSTR lptsz2);


HIMAGELIST  g_himl;


TCHAR const c_szNoUI[]           = TEXT("noui");
TCHAR const c_szOnePort[]        = TEXT("port");
TCHAR const c_szInfName[]        = TEXT("inf");
TCHAR const c_szInfSection[]     = TEXT("sect");
TCHAR const c_szRunOnce[]        = TEXT("RunOnce");
TCHAR const c_szRunWizard[]      = TEXT("add");

INT_PTR CALLBACK ModemCplDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);


/*----------------------------------------------------------
Purpose: Runs the device installer wizard
Returns: --
Cond:    --
*/
// 07/22/1997 - EmanP
// Modified DoWizard, so it will call InstallNewDevice in
// NEWDEV.DLL instead of calling ClassInstall32 directly;
// all installation should be done through the hardware wizard
void 
PRIVATE 
DoWizard (HWND hWnd)
{
 HINSTANCE hInst = NULL;
 PINSTNEWDEV pInstNewDev;
 TCHAR szLib[MAX_PATH];

    DBG_ENTER(DoWizard);

    ClearFlag (g_iCPLFlags, FLAG_PROCESS_DEVCHANGE);
    lstrcpy(szLib,NEW_DEV_DLL);
    hInst = LoadLibrary (szLib);
    if (NULL == hInst)
    {
        TRACE_MSG(TF_GENERAL, "LoadLibrary failed: %#lx", GetLastError ());
        goto _return;
    }

    pInstNewDev = (PINSTNEWDEV)GetProcAddress (hInst, INSTALL_NEW_DEVICE);
    if (NULL != pInstNewDev)
    {
        EnableWindow (hWnd, FALSE);
        pInstNewDev (hWnd, c_pguidModem, NULL);
        EnableWindow (hWnd, TRUE);
    }
    else
    {
        TRACE_MSG(TF_GENERAL, "GetProcAddress failed: %#lx", GetLastError ());
    }

    FreeLibrary (hInst);

_return:
    SetFlag (g_iCPLFlags, FLAG_PROCESS_DEVCHANGE);

    DBG_EXIT(DoWizard);
}


/*----------------------------------------------------------
Purpose: Show the Modem dialog
Returns: --
Cond:    --
*/
void 
PRIVATE
DoModem(
    IN     HWND       hwnd)
{
 PROPSHEETHEADER psh;
 PROPSHEETPAGE rgpsp[2];
 MODEMDLG md;

    DBG_ENTER(DoModem);
    
    md.hdi = INVALID_HANDLE_VALUE;
    md.cSel  = 0;
    md.dwFlags = 0;

    // Property page header
    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_PROPTITLE | PSH_NOAPPLYNOW | PSH_PROPSHEETPAGE;
    psh.hwndParent = hwnd;
    psh.hInstance = g_hinst;
    psh.pszCaption = MAKEINTRESOURCE(IDS_CPLNAME);
    psh.nPages = 1;
    psh.nStartPage = 0;
    psh.ppsp = rgpsp;

    // Pages
    rgpsp[0].dwSize = sizeof(PROPSHEETPAGE);
    rgpsp[0].dwFlags = PSP_DEFAULT;
    rgpsp[0].hInstance = g_hinst;
    rgpsp[0].pszTemplate = MAKEINTRESOURCE(IDD_MODEM);
    rgpsp[0].pfnDlgProc = ModemCplDlgProc;
    rgpsp[0].lParam = (LPARAM)&md;

    PropertySheet(&psh);

    DBG_EXIT(DoModem);
    
}

/*----------------------------------------------------------
Purpose: Gets the index to the appropriate image in the modem imagelist
WITHOUT searching the registry.

Returns: --
Cond:    --
*/
void PUBLIC GetModemImageIndex(
    BYTE nDeviceType,
    int FAR * pindex)
    {
    int i;

    for (i = 0; i < ARRAYSIZE(g_rgmapdt); i++)
        {
        if (nDeviceType == g_rgmapdt[i].nDeviceType)
            {
            *pindex = g_rgmapdt[i].index;
            return;
            }
        }
    ASSERT(0);      // We should never get here
    }


/*----------------------------------------------------------
Purpose: Gets the modem image list

Returns: TRUE on success
Cond:    --
*/
BOOL NEAR PASCAL GetModemImageList(
    HIMAGELIST FAR * phiml)
    {
    BOOL bRet = FALSE;

    ASSERT(phiml);
          
    if (NULL == g_himl)
        {
        g_himl = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
                                  GetSystemMetrics(SM_CYSMICON), 
                                  ILC_MASK, 1, 1);
        if (NULL != g_himl)
            {
            // The MODEMUI.DLL contains the icons from which we derive the list
            HINSTANCE hinst = LoadLibrary(TEXT("MODEMUI.DLL"));

            ImageList_SetBkColor(g_himl, GetSysColor(COLOR_WINDOW));

            if (ISVALIDHINSTANCE(hinst))
                {
                HICON hicon;
                int i;

                for (i = 0; i < ARRAYSIZE(g_rgmapdt); i++)
                    {
                    hicon = LoadIcon(hinst, MAKEINTRESOURCE(g_rgmapdt[i].idi));
                    g_rgmapdt[i].index = ImageList_AddIcon(g_himl, hicon);
                    }
                FreeLibrary(hinst);

                *phiml = g_himl;
                bRet = TRUE;
                }
            }
        }
    else
        {
        *phiml = g_himl;
        bRet = TRUE;
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Determine if user is an admin, and records this in
	 a global g_iCPLFlags.

Returns: --
Cond:    --
*/
VOID CheckIfAdminUser()
{
    g_bAdminUser = IsAdminUser();
}


/*----------------------------------------------------------
Purpose: Invokes the modem control panel.

	fWizard=TRUE ==> run wizard, even if there are alreay devices installed	
	fWizard=FALSE ==> run wizard only if there are no devices installed.
	fCpl=TRUE    ==> run CPL
	fCpl=FALSE    ==> don't run CPL
Returns: TRUE if the modem property sheet page should be displayed
         FALSE if it should be omited
Cond:    --
*/
BOOL WINAPI InvokeControlPanel(HWND hwnd, BOOL fCpl, BOOL fWizard)
{
    BOOL bInstalled;

    if (!CplDiGetModemDevs (NULL, hwnd, 0, &bInstalled) ||
        !bInstalled ||
        fWizard)
    {
        // If the user isn't an admin, there's nothing else
        // they can do.  If they are, run the installation wizard.
        if (!USER_IS_ADMIN())
        {
             LPTSTR lptsz = MAKEINTRESOURCE(
                                (bInstalled)
                                ? IDS_ERR_NOT_ADMIN
                                : IDS_ERR_NOMODEM_NOT_ADMIN
                           );
            MsgBox( g_hinst,
                    hwnd,
                    lptsz,
                    MAKEINTRESOURCE(IDS_CAP_MODEMSETUP),
                    NULL,
                    MB_OK | MB_ICONERROR );
            return 0;
        }
        // 07/22/1997 - EmanP
        // DoWizard doesn't need the hdi parameter any more,
        // because it calls on the hardware wizard to do the
        // installation, and the hardware wizard creates it's
        // own hdi
        DoWizard(hwnd);
        CplDiGetModemDevs (NULL, hwnd, 0, &bInstalled);
    }


    if (fCpl && bInstalled)
    {
        DoModem(hwnd);
        return 0;
    }

    return bInstalled;
}


/*----------------------------------------------------------
Purpose: Fetch the value of a command line parameter.  Also
         writes a '\0' over the '=' that precedes the value.
         
Returns: NULL if there was no "=" in the string, otherwise
         a pointer to the character following the next '='.
         
Cond:    --
*/
LPTSTR
PRIVATE
GetValuePtr(LPTSTR lpsz)
{
    LPTSTR lpszEqual;
    
    if ((lpszEqual = AnsiChr(lpsz, '=')) != NULL)
    {
        lpsz = CharNext(lpszEqual);
        lstrcpy(lpszEqual, TEXT("\0"));
    }
    
    return(lpszEqual ? lpsz : NULL);
}


/*----------------------------------------------------------
Purpose: Parse the command line.  Set flags and collect
         parameters based on its contents.

Returns: --
Cond:    --
*/
VOID
PRIVATE
ParseCmdLine(LPTSTR szCmdLine, LPINSTALLPARAMS lpip)
{
    LPTSTR  lpszParam, lpszSpace, lpszValue;
    
    ZeroMemory(lpip, sizeof(INSTALLPARAMS));
    
    while (szCmdLine && (!IsSzEqual(szCmdLine, TEXT("\0"))))
    {
        lpszParam = szCmdLine;
        if ((lpszSpace = AnsiChr(szCmdLine, ' ')) != NULL)
        {
            szCmdLine = CharNext(lpszSpace);
            lstrcpy(lpszSpace, TEXT("\0"));
        }
        else szCmdLine = NULL;
        
        // interpret any "directive" parameters
        if (IsSzEqual(lpszParam, c_szNoUI)) 
        {
            g_iCPLFlags |= FLAG_INSTALL_NOUI;
        }
        else if (lpszValue = GetValuePtr(lpszParam))
        {
            // interpret any "value" parameters (have a value following '=')            
            if (IsSzEqual(lpszParam, c_szOnePort))
            {
                if (lstrlen(lpszValue) < sizeof(lpip->szPort))
                    lstrcpy(lpip->szPort, CharUpper(lpszValue));
            }
            else if (IsSzEqual(lpszParam, c_szInfName)) 
            {
                if (lstrlen(lpszValue) < sizeof(lpip->szInfName))
                    lstrcpy(lpip->szInfName, lpszValue);
            }
            else if (IsSzEqual(lpszParam, c_szInfSection)) 
            {
                if (lstrlen(lpszValue) < sizeof(lpip->szInfSect))
                    lstrcpy(lpip->szInfSect, lpszValue);
            }
        }
        else
        {
            // ignore any parameter that wasn't recognized & skip to the next
            // parameter if there is one
            if (szCmdLine)
            {
                if ((szCmdLine = AnsiChr(szCmdLine, ' ')) != NULL)
                    szCmdLine = CharNext(szCmdLine);
            }
        }
    }
}


/*----------------------------------------------------------
Purpose: Entry-point for control panel applet

Returns: varies
Cond:    --
*/
/*  This function is no longer used in the combined "Dialing and Modems" CPl.
    I have left the code here on the off chance that the CPL_STARTWPARMS
    behavior from below might actually still be needed.


LONG 
CALLBACK 
CPlApplet(
    HWND hwnd,
    UINT Msg,
    LPARAM lParam1,
    LPARAM lParam2 )
    {
    LPNEWCPLINFO lpCPlInfo;
    LPCPLINFO lpOldCPlInfo;
    LPTSTR lpszParam;
    HDEVINFO hdi;
    BOOL bRet;
    BOOL bInstalled;
    INSTALLPARAMS InstallParams;

    switch (Msg)
        {
        case CPL_INIT:
            CheckIfAdminUser();
    		gDeviceFlags =0;
            return TRUE;

        case CPL_GETCOUNT:
            return 1;

        case CPL_INQUIRE:
            lpOldCPlInfo          = (LPCPLINFO)lParam2;
            lpOldCPlInfo->idIcon  = IDI_MODEM;
            lpOldCPlInfo->idName  = IDS_CPLNAME;
            lpOldCPlInfo->idInfo  = IDS_CPLINFO;
            lpOldCPlInfo->lData   = 1;
            break;

        case CPL_SELECT:
            // Applet has been selected, do nothing.
            break;

        case CPL_NEWINQUIRE:
            lpCPlInfo = (LPNEWCPLINFO)lParam2;
        
            lpCPlInfo->hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_MODEM));
            
            LoadString(g_hinst, IDS_CPLNAME, lpCPlInfo->szName, SIZECHARS(lpCPlInfo->szName));
            LoadString(g_hinst, IDS_CPLINFO, lpCPlInfo->szInfo,  SIZECHARS(lpCPlInfo->szInfo));
        
            lpCPlInfo->dwSize = sizeof(NEWCPLINFO);
            lpCPlInfo->lData = 1;
            break;

        case CPL_STARTWPARMS:
            lpszParam = (LPTSTR)lParam2;

            if (IsSzEqual(lpszParam, c_szRunOnce)) 
            {
                // run-once
                InvokeControlPanel(hwnd,FALSE,FALSE);
            }
            else if (IsSzEqual(lpszParam, c_szRunWizard)) 
            {
               // run wizard
               InvokeControlPanel(hwnd,FALSE,TRUE);
            }
            else
            {
                ParseCmdLine((LPTSTR)lParam2, &InstallParams);
                if (INSTALL_NOUI()) 
                {
                 HDEVINFO hdi;
                    hdi = SetupDiCreateDeviceInfoList (c_pguidModem, hwnd);
                    if (INVALID_HANDLE_VALUE != hdi)
                    {
                     MODEM_INSTALL_WIZARD miw = {sizeof(MODEM_INSTALL_WIZARD), 0};
                     SP_INSTALLWIZARD_DATA  iwd;

                        CopyMemory (&miw.InstallParams, &InstallParams, sizeof(InstallParams));
                        miw.InstallParams.Flags = MIPF_NT4_UNATTEND;

                        ZeroMemory(&iwd, sizeof(iwd));
                        iwd.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
                        iwd.ClassInstallHeader.InstallFunction = DIF_INSTALLWIZARD;
                        iwd.hwndWizardDlg = hwnd;
                        iwd.PrivateData = (LPARAM)&miw;

                       if (SetupDiSetClassInstallParams (hdi, NULL, (PSP_CLASSINSTALL_HEADER)&iwd, sizeof(iwd)))
                       {
                          // Call the class installer to invoke the installation
                          // wizard.
                          if (SetupDiCallClassInstaller (DIF_INSTALLWIZARD, hdi, NULL))
                          {
                             // Success.  The wizard was invoked and finished.
                             // Now cleanup.
                             SetupDiCallClassInstaller (DIF_DESTROYWIZARDDATA, hdi, NULL);
                          }
                       }

                       SetupDiDestroyDeviceInfoList (hdi);
                    }
                }
                else
                {
                    InvokeControlPanel(hwnd,TRUE,FALSE);
                }
            }
            break;

        case CPL_DBLCLK:
            InvokeControlPanel(hwnd, TRUE, FALSE);
            break;

        case CPL_STOP:
            // Sent once for each applet prior to the CPL_EXIT msg.
            // Perform applet specific cleanup.
            break;
       
        case CPL_EXIT:
            // Last message, sent once only, before the shell calls
            break;

        default:
            break;
        }
    return TRUE;
    } 
*/

//****************************************************************************
// 
//****************************************************************************


// Taken from devmgr.h

typedef struct
{
    int devClass;
    int dsaItem;

} LISTITEM, *LPLISTITEM;

#define BUFFERQUERY_SUCCEEDED(f)    \
            ((f) || GetLastError() == ERROR_INSUFFICIENT_BUFFER)

/*----------------------------------------------------------
Purpose: Brings up the property sheet for the modem

Returns: IDOK or IDCANCEL
Cond:    --
*/
int 
PRIVATE
DoModemProperties(
    IN HWND     hDlg,
    IN HDEVINFO hdi)
{
 int idRet = IDCANCEL;
 HWND hwndCtl = GetDlgItem(hDlg, IDC_MODEMLV);
 LV_ITEM lvi;
 int iSel;

    EnableWindow (hDlg, FALSE);
    iSel = ListView_GetNextItem(hwndCtl, -1, LVNI_SELECTED);
    if (-1 != iSel) 
    {
        COMMCONFIG ccDummy;
        COMMCONFIG * pcc;
        DWORD dwSize;
        HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
        PMODEMITEM pitem;
        DWORD dwErr = 0;

        // Get the selection
        lvi.mask = LVIF_PARAM;
        lvi.iItem = iSel;
        lvi.iSubItem = 0;
        ListView_GetItem(hwndCtl, &lvi);

        pitem = (PMODEMITEM)lvi.lParam;

        // [brwill-051000]
        // Instead of using the modem properties in modemui.dll, we
        // use the advanced hardware properties devcfg manager to change
        // the modem configuration.

        // Get default modem configuration

        ccDummy.dwProviderSubType = PST_MODEM;
        dwSize = sizeof(COMMCONFIG);
        if (!GetDefaultCommConfig(pitem->mpp.szFriendlyName, &ccDummy, &dwSize))
        {
            dwErr = GetLastError ();
        }

        pcc = (COMMCONFIG *)ALLOCATE_MEMORY( (UINT)dwSize);
        if (pcc)
        {
            pcc->dwProviderSubType = PST_MODEM;

            // Get current modem configuration

            if (GetDefaultCommConfig(pitem->mpp.szFriendlyName, pcc, &dwSize))
            {
                COMMCONFIG *pccOld = (COMMCONFIG*)ALLOCATE_MEMORY ((UINT)dwSize);
                PSP_DEVINFO_DATA pdinf;

                if (pccOld)
                {
                    CopyMemory (pccOld, pcc, dwSize);
                }

                // Change cursor

                SetCursor(hcur);
                hcur = NULL;

                // Get device information

                pdinf = &(((PMODEMITEM)lvi.lParam)->devData);

                if (pdinf != NULL)
                {
                    DWORD cchRequired;
                    LPLISTITEM pListItem;
                    LPTSTR ptszDevid;

                    pListItem = (LPLISTITEM)lvi.lParam;
                    if (BUFFERQUERY_SUCCEEDED(SetupDiGetDeviceInstanceId(hdi,pdinf,NULL,0,&cchRequired))
                            && (ptszDevid = (LPTSTR)LocalAlloc(LPTR,cchRequired*sizeof(TCHAR))))
                    {
                        if (SetupDiGetDeviceInstanceId(hdi,pdinf,ptszDevid,cchRequired,NULL))
                        {

                            // Load device manager DLL

                            TCHAR szLib[MAX_PATH];
                            HINSTANCE hDevmgr = NULL;
			    
			    lstrcpy(szLib,TEXT("devmgr.dll"));
			    hDevmgr = LoadLibrary(szLib);

                            // If successful then create a handle to
                            // the function DevicePropertiesW

                            if (hDevmgr)
                            {

                                FARPROC pfnDevProperties = (FARPROC)GetProcAddress(hDevmgr,"DevicePropertiesW");

                                // Call advanced hardware properties.

                                pfnDevProperties(hDlg,NULL,ptszDevid,FALSE);

                                // Retrieve current modem configuration.

                                // SetDefaultCommConfig(pitem->mpp.szFriendlyName, pcc, &dwSize);

                                // Notify TSP only if a setting has changed.

                                if (pccOld && GetDefaultCommConfig(pitem->mpp.szFriendlyName, pcc, &dwSize))
                                {
                                    if (memcmp(pccOld, pcc, dwSize))
                                    {
                                        UnimodemNotifyTSP (TSPNOTIF_TYPE_CPL,
                                                fTSPNOTIF_FLAG_CPL_DEFAULT_COMMCONFIG_CHANGE
#ifdef UNICODE
                                                | fTSPNOTIF_FLAG_UNICODE
#endif // UNICODE
                                                ,
                                                (lstrlen(pitem->mpp.szFriendlyName)+1)*sizeof (TCHAR),
                                                pitem->mpp.szFriendlyName,
                                                TRUE);
                                    }
                                }

                                idRet = IDOK;

                                // Update our item data (the port may have changed)
                                CplDiGetPrivateProperties(hdi, &pitem->devData, &pitem->mpp);

                                if (ListView_GetItemCount(hwndCtl) > 0)
                                {
                                    lvi.mask = LVIF_TEXT;
                                    lvi.iItem = iSel;
                                    lvi.iSubItem = ICOL_PORT;
                                    lvi.pszText = pitem->mpp.szPort;
                                    ListView_SetItem(hwndCtl, &lvi);
                                }

                                UpdateWindow(hwndCtl);


                                // Remove handle to device manager instance.

                                FreeLibrary(hDevmgr);
                            }

                            LocalFree(ptszDevid);
                        }
                    }
                }

                if (pccOld)
                {
                    FREE_MEMORY(pccOld);
                    pccOld=NULL;
                }
            }
            else
            {
                dwErr = GetLastError ();
                MsgBox(g_hinst,
                        hDlg, 
                        MAKEINTRESOURCE(IDS_ERR_PROPERTIES), 
                        MAKEINTRESOURCE(IDS_CAP_MODEM), 
                        NULL,
                        MB_OK | MB_ICONEXCLAMATION);
            }

            FREE_MEMORY((HLOCAL)pcc);
        }

        if (hcur)
            SetCursor(hcur);
    }

    EnableWindow (hDlg, TRUE);
    return idRet;
}


/*----------------------------------------------------------
Purpose: Free resources associated with the modem list
Returns: 
Cond:    --
*/
void
PRIVATE
FreeModemListData(
    IN HWND hLV)
    {
    LV_ITEM lvi;
    DWORD iIndex, cItems;
    PMODEMITEM pitem;

    // Get the modem count
    cItems = ListView_GetItemCount(hLV);
    for (iIndex = 0; iIndex < cItems; iIndex++)
        {
        lvi.mask = LVIF_PARAM;
        lvi.iItem = iIndex;
        lvi.iSubItem = 0;
        ListView_GetItem(hLV, &lvi);

        if(NULL != (pitem = (PMODEMITEM)lvi.lParam))
            {
            FREE_MEMORY(pitem);
            }
        }
    }


/*----------------------------------------------------------
Purpose: Fills the lisbox with the list of modems
Returns: 
Cond:    --
*/
// 07/22/1997 - EmanP
// removed the hdi parameter
// instead, we're building the set of installed devices
// and use it to fill the list box
VOID
PRIVATE
FillModemLB(
    IN  HWND     hDlg,
	IN  int iSel,			// preferred item  to select
	IN  int iSubItemToSort,	// preferred sorting order. (ICOL_*)
    IN OUT HDEVINFO *phdi
	)
{
 SP_DEVINFO_DATA devData;
 PMODEMITEM pitem;
 HWND    hwndCtl = GetDlgItem(hDlg, IDC_MODEMLV);
 LV_ITEM lviItem;
 DWORD   iIndex;
 int     iCount;

    DBG_ENTER(FillModemLB);
    SetWindowRedraw(hwndCtl, FALSE);

    if (INVALID_HANDLE_VALUE != *phdi)
    {
        SetupDiDestroyDeviceInfoList (*phdi);
    }

    // Remove all the old items and associated resources
    FreeModemListData(hwndCtl);
    ListView_DeleteAllItems(hwndCtl);
 
    // Generate the set with all the modems
    *phdi = CplDiGetClassDevs(c_pguidModem, NULL, NULL, 0);
    if (INVALID_HANDLE_VALUE == *phdi)
        {
            TRACE_MSG(TF_GENERAL, "SetupDiGetClassDevs failed: %#lx", GetLastError ());
            *phdi = NULL;
            DBG_EXIT(FillModemLB);
            return;
        }

    // Re-enumerate the modems
    iIndex = 0;
    
    devData.cbSize = sizeof(devData);    
    while (CplDiEnumDeviceInfo(*phdi, iIndex++, &devData)) 
    {
        // We have a modem, allocate the SP_DEVICEINFO_DATA struct for it
        pitem = (PMODEMITEM)ALLOCATE_MEMORY( sizeof(*pitem));
        if (pitem)
        {
         ULONG ulStatus, ulProblem = 0;
#ifdef DEBUG
             {
              TCHAR szDesc[256];
              DEVNODE devParent;
              CONFIGRET cr;
                if (SetupDiGetDeviceRegistryProperty (*phdi, &devData, SPDRP_DEVICEDESC,
                        NULL, (PBYTE)szDesc, 256*sizeof(TCHAR), NULL))
                {
                    TRACE_MSG (TF_GENERAL, "Processing %s", szDesc);
                }
             }
#endif
            // Get the device information
            BltByte(&pitem->devData, &devData, sizeof(devData));
        
            // Get the private properties of the modem
            pitem->mpp.cbSize = sizeof(pitem->mpp);
            pitem->mpp.dwMask = (MPPM_FRIENDLY_NAME | MPPM_DEVICE_TYPE | MPPM_PORT);

            // See if this device is present
            if (CR_NO_SUCH_DEVNODE == CM_Get_DevInst_Status (&ulStatus, &ulProblem, devData.DevInst, 0))
            {
                // The device is not present, so let the user
                // know this by putting "Not present" in the "AttachedTo" column
                TRACE_MSG(TF_GENERAL, "Device not present");
                LoadString(g_hinst, IDS_NOTPRESENT, pitem->mpp.szPort, MAX_DEVICE_ID_LEN);
                pitem->mpp.dwMask &= ~MPPM_PORT;
                pitem->dwFlags |= MIF_NOT_PRESENT;
            }
            else
            {
                if (ulStatus & DN_ROOT_ENUMERATED)
                {
                    pitem->dwFlags |= MIF_LEGACY;
                }

                if (0 != ulProblem)
                {
                    TRACE_MSG(TF_GENERAL, "Device has problem %#lu", ulProblem);
                    pitem->mpp.dwMask &= ~MPPM_PORT;
                    pitem->dwFlags |= MIF_PROBLEM;
                    LoadString (g_hinst,
                                (CM_PROB_NEED_RESTART == ulProblem)?IDS_NEEDSRESTART:IDS_NOTFUNCTIONAL,
                                pitem->mpp.szPort, MAX_DEVICE_ID_LEN);
                }
                else if (!(ulStatus & DN_DRIVER_LOADED) ||
                         !(ulStatus & DN_STARTED))
                {
                    TRACE_MSG(TF_GENERAL, "Device has status %#lx", ulStatus);
                    pitem->mpp.dwMask &= ~MPPM_PORT;
                    pitem->dwFlags |= MIF_PROBLEM;
                    LoadString (g_hinst,
                                IDS_NOTFUNCTIONAL,
                                pitem->mpp.szPort, MAX_DEVICE_ID_LEN);
                }
            }

            if (CplDiGetPrivateProperties(*phdi, &devData, &pitem->mpp) &&
                IsFlagSet(pitem->mpp.dwMask, MPPM_FRIENDLY_NAME | MPPM_DEVICE_TYPE))
            {
                int index;
    
                GetModemImageIndex(LOBYTE(LOWORD(pitem->mpp.nDeviceType)), &index);

                // Insert the modem name
                lviItem.mask = LVIF_ALL;
                lviItem.iItem = LV_APPEND;
                lviItem.iSubItem = ICOL_MODEM;
                lviItem.state = 0;
                lviItem.stateMask = 0;
                lviItem.iImage = index;
                lviItem.pszText = pitem->mpp.szFriendlyName;
                lviItem.lParam = (LPARAM)pitem;

                // (Reuse the index variable)
                index = ListView_InsertItem(hwndCtl, &lviItem);

                // Set the port column value
                lviItem.mask = LVIF_TEXT;
                lviItem.iItem = index;
                lviItem.iSubItem = ICOL_PORT;
                lviItem.pszText = pitem->mpp.szPort;

                ListView_SetItem(hwndCtl, &lviItem);
            }
            else
            {
                FREE_MEMORY(LOCALOF(pitem));
            }
        }
    }

    // Sort by the requested default
	ASSERT(iSubItemToSort==ICOL_PORT || iSubItemToSort==ICOL_MODEM);
    ListView_SortItems (hwndCtl, ModemCpl_Compare, (LPARAM)iSubItemToSort);

    // Select the requested one
	iCount = ListView_GetItemCount(hwndCtl);

    if (0 < iCount)
    {
		if (iSel>=iCount) iSel = iCount-1;
		if (iSel<0) 	   iSel = 0;
        lviItem.mask = LVIF_STATE;
        lviItem.iItem = iSel;
        lviItem.iSubItem = 0;
        lviItem.state = LVIS_SELECTED|LVIS_FOCUSED;
        lviItem.stateMask = LVIS_SELECTED|LVIS_FOCUSED;
        ListView_SetItem(hwndCtl, &lviItem);
        ListView_EnsureVisible(hwndCtl, iSel, FALSE);
    }

    //ListView_SetColumnWidth (hwndCtl, 0, LVSCW_AUTOSIZE_USEHEADER);
    //ListView_SetColumnWidth (hwndCtl, 1, LVSCW_AUTOSIZE_USEHEADER);

    SetWindowRedraw(hwndCtl, TRUE);
    DBG_EXIT(FillModemLB);
}


/*----------------------------------------------------------
Purpose: Clone a modem

Returns: --
Cond:    --
*/
void
PRIVATE
CloneModem(
    IN HWND         hDlg,
    IN LPMODEMDLG   lpmd)
{
  int iSel;
  HWND hwndCtl = GetDlgItem(hDlg, IDC_MODEMLV);

    EnableWindow (hDlg, FALSE);
    iSel = ListView_GetNextItem(hwndCtl, -1, LVNI_SELECTED);
    if (-1 != iSel) 
    {
     LV_ITEM lvi;
     HDEVINFO hdi = lpmd->hdi;
     PSP_DEVINFO_DATA pDevInfoData;
     MODEM_INSTALL_WIZARD miw = {sizeof(MODEM_INSTALL_WIZARD), 0};
     SP_INSTALLWIZARD_DATA  iwd;

        ClearFlag (g_iCPLFlags, FLAG_PROCESS_DEVCHANGE);

        lvi.mask = LVIF_PARAM;
        lvi.iItem = iSel;
        lvi.iSubItem = 0;
        ListView_GetItem(hwndCtl, &lvi);

        pDevInfoData = &(((PMODEMITEM)lvi.lParam)->devData);

        // Now, we have a device info set and a device info data.
        // Time to call the class installer (DIF_INSTALLWIZARD).
        miw.InstallParams.Flags = MIPF_CLONE_MODEM;

        ZeroMemory(&iwd, sizeof(iwd));
        iwd.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
        iwd.ClassInstallHeader.InstallFunction = DIF_INSTALLWIZARD;
        iwd.hwndWizardDlg = hDlg;
        iwd.PrivateData = (LPARAM)&miw;

        if (SetupDiSetClassInstallParams (hdi, pDevInfoData, (PSP_CLASSINSTALL_HEADER)&iwd, sizeof(iwd)))
        {
            // Call the class installer to invoke the installation
            // wizard.
            if (SetupDiCallClassInstaller (DIF_INSTALLWIZARD, hdi, pDevInfoData))
            {
                // Success.  The wizard was invoked and finished.
                // Now cleanup.
                SetupDiCallClassInstaller (DIF_DESTROYWIZARDDATA, hdi, pDevInfoData);
            }
        }

        SetFlag (g_iCPLFlags, FLAG_PROCESS_DEVCHANGE);
        // Finally, update the modems list box.
        FillModemLB(hDlg, 0, ICOL_MODEM, &lpmd->hdi);
    }
    EnableWindow (hDlg, TRUE);
}

/*----------------------------------------------------------
Purpose: Removes a modem from the modem list
Returns: --
Cond:    --
*/
void
PRIVATE
RemoveModem(
    IN HWND         hDlg,
    IN LPMODEMDLG   lpmd)
{
 int iSel;
 HWND hwndCtl = GetDlgItem(hDlg, IDC_MODEMLV);
    
    ASSERT(0<ListView_GetSelectedCount(hwndCtl));

    // Ask the user first
    if (IDYES == MsgBox(g_hinst, hDlg, 
                        MAKEINTRESOURCE(IDS_WRN_CONFIRMDELETE),
                        MAKEINTRESOURCE(IDS_CAP_MODEMSETUP), 
                        NULL, 
                        MB_YESNO | MB_QUESTION))
    {
     HCURSOR hcurSav = SetCursor(LoadCursor(NULL, IDC_WAIT));
     PMODEMITEM pitem;
     LV_ITEM lvi;
     HDEVINFO hdi = lpmd->hdi;
     HWND hWndWait, hWndName;
     DWORD dwCount;
     SP_REMOVEDEVICE_PARAMS RemoveParams = {sizeof (SP_CLASSINSTALL_HEADER),
                                            DIF_REMOVE,
                                            DI_REMOVEDEVICE_GLOBAL,
                                            0};
     SP_DEVINSTALL_PARAMS devParams = {sizeof(devParams), 0};
     DWORD devInst = 0;
     BOOL bCancel = FALSE;

        EnableWindow (hDlg, FALSE);

        hWndWait = CreateDialogParam (g_hinst, MAKEINTRESOURCE(IDD_DIAG_WAITMODEM), hDlg, DiagWaitModemDlgProc, (LPARAM)&bCancel);
        hWndName = GetDlgItem (hWndWait, IDC_NAME);

        // so that we don't process notifications
        // until we're done removing modems.
        g_iCPLFlags &= ~FLAG_PROCESS_DEVCHANGE;
        dwCount = ListView_GetSelectedCount (hwndCtl);
        if (1 == dwCount)
        {
            ShowWindow (GetDlgItem (hWndWait, IDCANCEL), SW_HIDE);
        }
        for (iSel = ListView_GetNextItem(hwndCtl, -1, LVNI_SELECTED);
             dwCount > 0 && -1 != iSel;
             dwCount--, iSel = ListView_GetNextItem(hwndCtl, iSel, LVNI_SELECTED))
        {
            if (1 == dwCount)
            {
                EnableWindow (GetDlgItem (hWndWait, IDCANCEL), FALSE);
            }

            lvi.mask = LVIF_PARAM;
            lvi.iItem = iSel;
            lvi.iSubItem = 0;
            ListView_GetItem(hwndCtl, &lvi);

            pitem = (PMODEMITEM)lvi.lParam;

            devInst = pitem->devData.DevInst;

            if (NULL != hWndName)
            {
             MSG msg;
                if (!(pitem->mpp.dwMask & MPPM_FRIENDLY_NAME))
                {
                    TRACE_MSG(TF_GENERAL,"RemoveModem: no friendly name!");
                    if (SetupDiGetDeviceRegistryProperty (hdi, &pitem->devData, SPDRP_FRIENDLYNAME, NULL,
                                                          (PBYTE)pitem->mpp.szFriendlyName,
                                                          sizeof(pitem->mpp.szFriendlyName),
                                                          NULL))
                    {
                        pitem->mpp.dwMask |= MPPM_FRIENDLY_NAME;
                    }
                    else
                    {
                        lstrcpy (pitem->mpp.szFriendlyName, TEXT("Modem"));
                        TRACE_MSG (TF_ERROR,
                                   "RemoveModem: SetupDiGetDeviceRegistryPorperty failed (%#lx).",
                                   GetLastError ());
                    }
                }

                SendMessage (hWndName, WM_SETTEXT, 0, (LPARAM)pitem->mpp.szFriendlyName);

                while (PeekMessage (&msg, NULL, 0, 0, PM_REMOVE))
                {
                    if (!IsDialogMessage (hWndWait, &msg))
                    {
                        TranslateMessage (&msg);
                        DispatchMessage (&msg);
                    }
                }

            }

            if (bCancel)
            {
                break;
            }

            // 07/09/97 - EmanP
            // Call the class installer to do the job.
#ifdef DEBUG
            if (!SetupDiSetClassInstallParams (hdi, &pitem->devData,
                                               &RemoveParams.ClassInstallHeader,
                                               sizeof(RemoveParams)))
            {
                TRACE_MSG(TF_ERROR, "SetupDiSetClassInstallParams failed: %#lx.", GetLastError ());
                // Note: if there are any post-processing co-installers,
                // they will mask any failure from the class installer,
                // so we won't get to this point.
                // Have to solve this with the SetupApi guys somehow.
                MsgBox(g_hinst, hDlg, 
                       MAKEINTRESOURCE(IDS_ERR_CANT_DEL_MODEM),
                       MAKEINTRESOURCE(IDS_CAP_MODEMSETUP), 
                       NULL, 
                       MB_OK | MB_ERROR,
                       pitem->mpp.szFriendlyName, pitem->mpp.szPort);
            }
            else if (!SetupDiCallClassInstaller(DIF_REMOVE, hdi, &pitem->devData))
#else
            if (!SetupDiSetClassInstallParams (hdi, &pitem->devData,
                                               &RemoveParams.ClassInstallHeader,
                                               sizeof(RemoveParams)) ||
                !SetupDiCallClassInstaller(DIF_REMOVE, hdi, &pitem->devData))
#endif
            {
                TRACE_MSG(TF_ERROR, "SetupDiCallClassInstaller (DIF_REMOVE) failed: %#lx.", GetLastError ());
                // Note: if there are any post-processing co-installers,
                // they will mask any failure from the class installer,
                // so we won't get to this point.
                // Have to solve this with the SetupApi guys somehow.
                MsgBox(g_hinst, hDlg, 
                       MAKEINTRESOURCE(IDS_ERR_CANT_DEL_MODEM),
                       MAKEINTRESOURCE(IDS_CAP_MODEMSETUP), 
                       NULL, 
                       MB_OK | MB_ERROR,
                       pitem->mpp.szFriendlyName, pitem->mpp.szPort);
            }
            else
            {
#ifdef DEBUG
             ULONG ulStatus, ulProblem = 0;
                if (CR_SUCCESS == CM_Get_DevInst_Status (&ulStatus, &ulProblem, devInst, 0))
                {
                    if ((ulStatus & DN_HAS_PROBLEM) &&
                        (CM_PROB_NEED_RESTART == ulProblem))
                    {
                        gDeviceFlags |= fDF_DEVICE_NEEDS_REBOOT;
                    }
                }
#endif //DEBUG
                if (SetupDiGetDeviceInstallParams (hdi, &pitem->devData, &devParams))
                {
                    if (0 != (devParams.Flags & (DI_NEEDREBOOT | DI_NEEDRESTART)))
                    {
                        gDeviceFlags |= fDF_DEVICE_NEEDS_REBOOT;
                    }
                }
            }
        }

        if (!bCancel)
        {
            DestroyWindow (hWndWait);
        }

        if (gDeviceFlags & fDF_DEVICE_NEEDS_REBOOT)
        {
         TCHAR szMsg[128];
            LoadString (g_hinst, IDS_DEVSETUP_RESTART, szMsg, sizeof(szMsg)/sizeof(TCHAR));
            RestartDialogEx (GetParent(hDlg), szMsg, EWX_REBOOT, SHTDN_REASON_MAJOR_HARDWARE | SHTDN_REASON_MINOR_INSTALLATION | SHTDN_REASON_FLAG_PLANNED);
        }

        FillModemLB(hDlg, iSel, g_CurrentSubItemToSort, &lpmd->hdi);

        EnableWindow (hDlg, TRUE);
        // now we can process notifications again
        g_iCPLFlags |= FLAG_PROCESS_DEVCHANGE;

        SetCursor(hcurSav);
    }
}




DEFINE_GUID(GUID_CLASS_MODEM,0x2c7089aa, 0x2e0e,0x11d1,0xb1, 0x14, 0x00, 0xc0, 0x4f, 0xc2, 0xaa, 0xe4);
/*----------------------------------------------------------
Purpose: WM_INITDIALOG handler

Returns: FALSE when we assign the control focus
Cond:    --
*/
BOOL
PRIVATE
ModemCpl_OnInitDialog(
    IN HWND         hDlg,
    IN HWND         hwndFocus,
    IN LPARAM       lParam)
{
    HIMAGELIST himl;
    LV_COLUMN lvcol;
    LPMODEMDLG lpmd;
    TCHAR sz[MAX_BUF];
    HWND hwndCtl;
    int cxList;
    RECT r;

    CheckIfAdminUser();

    if (!USER_IS_ADMIN())
    {
       // Don't let the non-admin user add modems
        Button_Enable(GetDlgItem(hDlg, IDC_ADD), FALSE);
        Button_Enable(GetDlgItem(hDlg, IDC_REMOVE), FALSE);
        Button_Enable(GetDlgItem(hDlg, IDC_PROPERTIES), FALSE);
    }

    SetWindowLongPtr(hDlg, DWLP_USER, ((LPPROPSHEETPAGE)lParam)->lParam);
    lpmd = (LPMODEMDLG)((LPPROPSHEETPAGE)lParam)->lParam;
    lpmd->cSel = 0;
    lpmd->dwFlags = 0;

    hwndCtl = GetDlgItem(hDlg, IDC_MODEMLV);

    // Use the "full line highlight" feature to highlight across all columns
    SendMessage(hwndCtl, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);
    
    // Get the modem icon image list
    if (GetModemImageList(&himl))
        {
        ListView_SetImageList(hwndCtl, himl, TRUE);
        }
    else
        {
        MsgBox(g_hinst,
               hDlg, 
               MAKEINTRESOURCE(IDS_OOM_OPENCPL), 
               MAKEINTRESOURCE(IDS_CAP_MODEM), 
               NULL,
               MB_OK | MB_ICONEXCLAMATION);
        PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
        }

    // Determine size of list view minus size of a possible scroll bar
    GetClientRect(hwndCtl, &r);
    cxList = r.right - GetSystemMetrics(SM_CXVSCROLL);

    // Insert the modem column.  The widths are calculated in ModemFillLB.
    lvcol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
    lvcol.fmt = LVCFMT_LEFT;
    lvcol.cx = MulDiv(cxList, 70, 100); // 70 percent
    lvcol.iSubItem = ICOL_MODEM;
    lvcol.pszText = SzFromIDS(g_hinst, IDS_MODEM, sz, sizeof(sz) / sizeof(TCHAR));
    ListView_InsertColumn(hwndCtl, ICOL_MODEM, &lvcol);

    // Insert the port column
    lvcol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
    lvcol.fmt = LVCFMT_LEFT;
    lvcol.cx = MulDiv(cxList, 30, 100); // 30 percent              
    lvcol.iSubItem = ICOL_PORT;
    lvcol.pszText = SzFromIDS(g_hinst, IDS_PORT, sz, sizeof(sz) / sizeof(TCHAR));
    ListView_InsertColumn(hwndCtl, ICOL_PORT, &lvcol);

    FillModemLB(hDlg, 0, ICOL_MODEM, &lpmd->hdi);

    // Set the column widths.  Try to fit both columns on the 
    // control without requiring horizontal scrolling.
    //ListView_SetColumnWidth(hwndCtl, ICOL_MODEM, LVSCW_AUTOSIZE_USEHEADER);
    //ListView_SetColumnWidth(hwndCtl, ICOL_PORT, LVSCW_AUTOSIZE_USEHEADER);

    // Now try to register for devicechange notifications.
    {
     DEV_BROADCAST_DEVICEINTERFACE  DevClass;

        TRACE_MSG(TF_GENERAL, "EMANP - registering for hardware notifications.");
        CopyMemory (&DevClass.dbcc_classguid,
                    &GUID_CLASS_MODEM,
                    sizeof(DevClass.dbcc_classguid));

        DevClass.dbcc_size = sizeof (DEV_BROADCAST_DEVICEINTERFACE);
        DevClass.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;

        lpmd->NotificationHandle = RegisterDeviceNotification (hDlg, &DevClass, DEVICE_NOTIFY_WINDOW_HANDLE);

        if (lpmd->NotificationHandle == NULL)
        {
            TRACE_MSG(TF_ERROR, "EMANP - Could not register dev not %d\n",GetLastError());
        }
    }

    return TRUE;
}


/*----------------------------------------------------------
Purpose: Copies properties of the currently selected modem
         into the local properties clipboard

Returns: --
Cond:    --
*/
void
PRIVATE
BuildTIC (
    IN LPREGDEVCAPS pDevCaps,
    IN PTIC         pTic)
{
 DWORD dwMode = pDevCaps->dwSpeakerMode;
 DWORD dwVolume = pDevCaps->dwSpeakerVolume;
 int i;
 int iTicCount = 0;
 static struct
 {
    DWORD dwVolBit;
    DWORD dwVolSetting;
 } rgvolumes[] = { 
        { MDMVOLFLAG_LOW,    MDMVOL_LOW},
        { MDMVOLFLAG_MEDIUM, MDMVOL_MEDIUM},
        { MDMVOLFLAG_HIGH,   MDMVOL_HIGH} };

    ZeroMemory (pTic, sizeof(TIC));
    // Does the modem support volume control?
    if (0 == dwVolume && IsFlagSet(dwMode, MDMSPKRFLAG_OFF) &&
        (IsFlagSet(dwMode, MDMSPKRFLAG_ON) || IsFlagSet(dwMode, MDMSPKRFLAG_DIAL)))
    {
        // Set up the volume tic table.
        iTicCount = 2;
        pTic->tics[0].dwVolume = 0;  // doesn't matter because Volume isn't supported
        pTic->tics[0].dwMode   = MDMSPKR_OFF;
        pTic->tics[1].dwVolume = 0;  // doesn't matter because Volume isn't supported
        pTic->tics[1].dwMode   = IsFlagSet(dwMode, MDMSPKRFLAG_DIAL) ? MDMSPKR_DIAL : MDMSPKR_ON;
    }
    else
    {
        DWORD dwOnMode = IsFlagSet(dwMode, MDMSPKRFLAG_DIAL) 
                             ? MDMSPKR_DIAL
                             : IsFlagSet(dwMode, MDMSPKRFLAG_ON)
                                   ? MDMSPKR_ON
                                   : 0;

        // MDMSPKR_OFF?
        if (IsFlagSet(dwMode, MDMSPKRFLAG_OFF))
        {
            for (i = 0; i < ARRAY_ELEMENTS(rgvolumes); i++)
            {
                if (IsFlagSet(dwVolume, rgvolumes[i].dwVolBit))
                {
                    pTic->tics[iTicCount].dwVolume = rgvolumes[i].dwVolSetting;
                    break;
                }
            }
            pTic->tics[iTicCount].dwMode   = MDMSPKR_OFF;
            iTicCount++;
        }

        // MDMVOL_xxx?
        for (i = 0; i < ARRAY_ELEMENTS(rgvolumes); i++)
        {
            if (IsFlagSet(dwVolume, rgvolumes[i].dwVolBit))
            {
                pTic->tics[iTicCount].dwVolume = rgvolumes[i].dwVolSetting;
                pTic->tics[iTicCount].dwMode   = dwOnMode;
                iTicCount++;
            }
        }
    }

    // Set up the control.
    if (iTicCount > 0)
    {
        pTic->ticVolumeMax = iTicCount - 1;
    }
}


/*----------------------------------------------------------
Purpose: Return the tic corresponding to bit flag value
Returns: tic index
Cond:    --
*/
int
PRIVATE
CplMapVolumeToTic (
    IN PTIC  pTic,
    IN DWORD dwVolume,
    IN DWORD dwMode)
{
 int   i;

    ASSERT(ARRAY_ELEMENTS(pTic->tics) > pTic->ticVolumeMax);
    for (i = 0; i <= pTic->ticVolumeMax; i++)
    {
        if (pTic->tics[i].dwVolume == dwVolume &&
            pTic->tics[i].dwMode   == dwMode)
        {
            return i;
        }
    }

    return 0;
}


/*----------------------------------------------------------
Purpose: Copies properties of the currently selected modem
         into the local properties clipboard

Returns: --
Cond:    --
*/
void
PRIVATE
CopyProperties (
    IN HWND     hDlg,
    IN HDEVINFO hdi)
{
 HWND hwndCtl = GetDlgItem(hDlg, IDC_MODEMLV);
 LV_ITEM lvi;
 int iSel;

    DBG_ENTER(CopyProperties);
    ASSERT (1 == ListView_GetSelectedCount (hwndCtl));

    g_PropertiesClipboard.dwIsDataValid = FALSE;

    iSel = ListView_GetNextItem(hwndCtl, -1, LVNI_SELECTED);
    if (-1 != iSel) 
    {
     COMMCONFIG *pcc;
     DWORD dwSize;
     PMODEMITEM pitem;
     HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

        // Get the selection
        lvi.mask = LVIF_PARAM;
        lvi.iItem = iSel;
        lvi.iSubItem = 0;
        ListView_GetItem(hwndCtl, &lvi);

        pitem = (PMODEMITEM)lvi.lParam;

        // The first call to GetDefaultCommConfig is just used to get
        // the size needed in dwSize; pcc is used as a bogus parameter,
        // because the function complains about a NULL pointer and doesn't
        // update dwSize; pcc is not used before it's initialized later
        // (by allocation)
        dwSize = sizeof (pcc);
        GetDefaultCommConfig(pitem->mpp.szFriendlyName, (LPCOMMCONFIG)&pcc, &dwSize);

        pcc = (COMMCONFIG *)ALLOCATE_MEMORY( (UINT)dwSize);
        if (pcc)
        {
            if (GetDefaultCommConfig(pitem->mpp.szFriendlyName, pcc, &dwSize))
            {
             HKEY hkeyDrv;

                hkeyDrv = SetupDiOpenDevRegKey (hdi, &pitem->devData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ);
                if (INVALID_HANDLE_VALUE != hkeyDrv)
                {
                 DWORD cbData;
                 REGDEVCAPS devcaps;

                    cbData = sizeof(devcaps);
                    if (ERROR_SUCCESS == RegQueryValueEx (hkeyDrv, REGSTR_VAL_PROPERTIES, NULL, NULL, (LPBYTE)&devcaps, &cbData))
                    {
                     LPMODEMSETTINGS pms = PmsFromPcc(pcc);
                     TIC Tic;

                        BuildTIC (&devcaps, &Tic);

                        g_PropertiesClipboard.dwCopiedOptions         = devcaps.dwModemOptions;
                        g_PropertiesClipboard.dwBaudRate              = pcc->dcb.BaudRate;
                        g_PropertiesClipboard.dwTic                   = CplMapVolumeToTic (&Tic,
                                                                                           pms->dwSpeakerVolume,
                                                                                           pms->dwSpeakerMode);
                        g_PropertiesClipboard.dwPreferredModemOptions = pms->dwPreferredModemOptions;


                        cbData = sizeof (g_PropertiesClipboard.szUserInit);
                        RegQueryValueEx (hkeyDrv, TEXT("UserInit"), NULL, NULL, (LPBYTE)g_PropertiesClipboard.szUserInit, &cbData);

                        cbData = sizeof (g_PropertiesClipboard.dwLogging);
                        RegQueryValueEx (hkeyDrv, TEXT("Logging"), NULL, NULL, (LPBYTE)&g_PropertiesClipboard.dwLogging, &cbData);

                        g_PropertiesClipboard.dwIsDataValid = TRUE;
                    }

                    RegCloseKey (hkeyDrv);
                }
            }

            FREE_MEMORY((HLOCAL)pcc);
        }

        SetCursor(hcur);
    }

    DBG_EXIT (CopyProperties);
}


/*----------------------------------------------------------
Purpose: Applies the properties on the clipboard to the
         currently selected modem(s)

Returns: --
Cond:    --
*/
void
PRIVATE
ApplyProperties (
    IN HWND     hDlg,
    IN HDEVINFO hdi)
{
 HWND hwndCtl = GetDlgItem(hDlg, IDC_MODEMLV);
 LV_ITEM lvi;
 int iSel, cSel;
 HCURSOR hcur;

    DBG_ENTER(ApplyProperties);

    ASSERT (TRUE == g_PropertiesClipboard.dwIsDataValid);

    EnableWindow (hDlg, FALSE);
    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    cSel = ListView_GetSelectedCount (hwndCtl);
    ASSERT (1 <= cSel);

    iSel = ListView_GetNextItem(hwndCtl, -1, LVNI_SELECTED);
    while (-1 != iSel) 
    {
     COMMCONFIG *pcc = NULL;
     DWORD dwSize;
     PMODEMITEM pitem;
     HKEY hkeyDrv = INVALID_HANDLE_VALUE;
     REGDEVCAPS devcaps;
     DWORD cbData;
     DWORD dwRet;
     LPMODEMSETTINGS pms;

        // Get the selection
        lvi.mask = LVIF_PARAM;
        lvi.iItem = iSel;
        lvi.iSubItem = 0;
        ListView_GetItem(hwndCtl, &lvi);

        pitem = (PMODEMITEM)lvi.lParam;

        hkeyDrv = SetupDiOpenDevRegKey (hdi, &pitem->devData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ | KEY_WRITE);
        if (INVALID_HANDLE_VALUE == hkeyDrv)
        {
            TRACE_MSG (TF_ERROR,
                       "Could not open the driver registry key for\n  %s\n  error: %#lx",
                       pitem->mpp.szFriendlyName, GetLastError ());
            goto _Loop;
        }

        cbData = sizeof(devcaps);
        dwRet = RegQueryValueEx (hkeyDrv, REGSTR_VAL_PROPERTIES, NULL, NULL, (LPBYTE)&devcaps, &cbData);
        if (ERROR_SUCCESS != dwRet)
        {
            TRACE_MSG (TF_ERROR,
                       "Could not get device capabilities for\n  %s\n  error: %#lx",
                       pitem->mpp.szFriendlyName, dwRet);
            goto _Loop;
        }

        // The first call to GetDefaultCommConfig is just used to get
        // the size needed in dwSize; pcc is used as a bogus parameter,
        // because the function complains about a NULL pointer and doesn't
        // update dwSize; pcc is not used before it's initialized later
        // (by allocation)
        dwSize = sizeof (pcc);
        GetDefaultCommConfig(pitem->mpp.szFriendlyName, (LPCOMMCONFIG)&pcc, &dwSize);

        pcc = (COMMCONFIG *)ALLOCATE_MEMORY( (UINT)dwSize);
        if (!pcc)
        {
            TRACE_MSG (TF_ERROR,
                       "Could not allocate COMMCONFIG memory for\n  %s",
                       pitem->mpp.szFriendlyName);
            goto _Loop;
        }
        if (!GetDefaultCommConfig(pitem->mpp.szFriendlyName, pcc, &dwSize))
        {
            TRACE_MSG (TF_ERROR,
                       "Could not get COMMCONFIG for\n  %s\n  error: %#lx",
                       pitem->mpp.szFriendlyName, GetLastError());
            goto _Loop;
        }

        pms = PmsFromPcc(pcc);
        pcc->dcb.BaudRate = g_PropertiesClipboard.dwBaudRate;
        if (pcc->dcb.BaudRate > devcaps.dwMaxDTERate)
        {
            pcc->dcb.BaudRate = devcaps.dwMaxDTERate;
        }

        {
         TIC Tic;
         int tic;

            BuildTIC (&devcaps, &Tic);
            tic = g_PropertiesClipboard.dwTic;
            if (tic > Tic.ticVolumeMax)
            {
                tic = Tic.ticVolumeMax;
            }
            pms->dwSpeakerVolume = Tic.tics[tic].dwVolume;
            pms->dwSpeakerMode = Tic.tics[tic].dwMode;
        }

        {
         DWORD dwOptions, dwOptionMask;
            // The options we'll be setting are the intersection between
            //  the options currently on the clipboard and the options
            //  supported by this device
            dwOptionMask = g_PropertiesClipboard.dwCopiedOptions & devcaps.dwModemOptions;
            // From the options on the clipboard, only the ones that are
            //  supported by the current device matter
            dwOptions = g_PropertiesClipboard.dwPreferredModemOptions & dwOptionMask;
            // Now, clear all the bits corresponding to the options we are setting
            pms->dwPreferredModemOptions &= ~dwOptionMask;
            // Now set the correct bits
            pms->dwPreferredModemOptions |= dwOptions;
        }

        RegSetValueEx (hkeyDrv, TEXT("UserInit"), 0, REG_SZ, (LPBYTE)g_PropertiesClipboard.szUserInit,
                       lstrlen (g_PropertiesClipboard.szUserInit)*sizeof(TCHAR)+sizeof(TCHAR));

        RegSetValueEx (hkeyDrv, TEXT("Logging"), 0, REG_BINARY, (LPBYTE)&g_PropertiesClipboard.dwLogging, sizeof (BYTE));
        if (0 != g_PropertiesClipboard.dwLogging)
        {
            TCHAR szPath[MAX_PATH];
            UINT uResult;
            DWORD Length;

            // Set the path of the modem log
            uResult = GetWindowsDirectory(szPath, SIZECHARS(szPath));
            if (uResult == 0)
            {
                lstrcpy (szPath, TEXT("\\ModemLog_"));
            } else
            {

                Length = sizeof(szPath) - (lstrlen(szPath) * sizeof(TCHAR));

                if ((DWORD)lstrlen(TEXT("\\ModemLog_")) < (Length / sizeof(TCHAR)))
                {
                    lstrcat (szPath, TEXT("\\ModemLog_"));
                } else
                {
                    lstrcpy (szPath, TEXT("\\ModemLog_"));
                }
            }

            Length = sizeof(szPath) - (lstrlen(szPath) * sizeof(TCHAR));

            if ((DWORD)(lstrlen(pitem->mpp.szFriendlyName) + 4) < (Length / sizeof(TCHAR)))
            {
                lstrcat (szPath, pitem->mpp.szFriendlyName);
                lstrcat (szPath,TEXT(".txt"));
            } else
            {
                lstrcpy (szPath,TEXT("\\ModemLog.txt"));
            }

            RegSetValueEx(hkeyDrv, c_szLoggingPath, 0, REG_SZ, 
                          (LPBYTE)szPath, CbFromCch(lstrlen(szPath)+1));
        }

        if (!SetDefaultCommConfig (pitem->mpp.szFriendlyName, pcc, dwSize))
        {
            TRACE_MSG (TF_ERROR,
                       "Could not get COMMCONFIG for\n  %s\n  error: %#lx",
                       pitem->mpp.szFriendlyName, GetLastError ());
        }

_Loop:
        if (NULL != pcc)
        {
            FREE_MEMORY((HLOCAL)pcc);
        }
        if (INVALID_HANDLE_VALUE != hkeyDrv)
        {
            RegCloseKey (hkeyDrv);
            hkeyDrv = INVALID_HANDLE_VALUE;
        }

        iSel = ListView_GetNextItem(hwndCtl, iSel, LVNI_SELECTED);
    }

    SetCursor(hcur);
    EnableWindow (hDlg, TRUE);

    DBG_EXIT (ApplyProperties);
}


void
PRIVATE
ViewLog(
    IN HWND     hDlg,
    IN HDEVINFO hdi
    )
{

    HWND hwndCtl = GetDlgItem(hDlg, IDC_MODEMLV);
    LV_ITEM lvi;
    int iSel, cSel;
    HCURSOR hcur;

    cSel = ListView_GetSelectedCount (hwndCtl);
    ASSERT (1 <= cSel);

    iSel = ListView_GetNextItem(hwndCtl, -1, LVNI_SELECTED);

    if (-1 != iSel) {

        DWORD dwSize;
        PMODEMITEM pitem;
        HKEY hkeyDrv = INVALID_HANDLE_VALUE;
        DWORD cbData;
        DWORD dwRet;

        // Get the selection
        lvi.mask = LVIF_PARAM;
        lvi.iItem = iSel;
        lvi.iSubItem = 0;
        ListView_GetItem(hwndCtl, &lvi);

        pitem = (PMODEMITEM)lvi.lParam;

        hkeyDrv = SetupDiOpenDevRegKey (hdi, &pitem->devData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ | KEY_WRITE);
        if (INVALID_HANDLE_VALUE == hkeyDrv)
        {
            TRACE_MSG (TF_ERROR,
                       "Could not open the driver registry key for\n  %s\n  error: %#lx",
                       pitem->mpp.szFriendlyName, GetLastError ());
            return;
        }

        {
            TCHAR    LogPath[MAX_PATH+2];
            DWORD    ValueType;
            DWORD    BufferLength;
            LONG     lResult;

            lstrcpy(LogPath,TEXT("notepad.exe "));

            BufferLength=sizeof(LogPath)-sizeof(TCHAR);

            lResult=RegQueryValueEx (hkeyDrv,
                                     c_szLoggingPath,
                                     0,
                                     &ValueType,
                                     (LPBYTE)(LogPath+lstrlen(LogPath)),
                                     &BufferLength);

            if (lResult == ERROR_SUCCESS) {

                STARTUPINFO          StartupInfo;
                PROCESS_INFORMATION  ProcessInfo;
                BOOL                 bResult;
                TCHAR                NotepadPath[MAX_PATH];

                ZeroMemory(&StartupInfo,sizeof(StartupInfo));

                StartupInfo.cb=sizeof(StartupInfo);

                bResult=CreateProcess (NULL, //NotepadPath,
                                       LogPath,
                                       NULL,
                                       NULL,
                                       FALSE,
                                       0,
                                       NULL,
                                       NULL,
                                       &StartupInfo,
                                       &ProcessInfo);

                if (bResult) {

                    CloseHandle(ProcessInfo.hThread);
                    CloseHandle(ProcessInfo.hProcess);
                }
            }
        }
        RegCloseKey(hkeyDrv);
    }
    return;
}


/*----------------------------------------------------------
Purpose: WM_COMMAND Handler
Returns: --
Cond:    --
*/
void 
PRIVATE 
ModemCpl_OnCommand(
    IN HWND hDlg,
    IN int  id,
    IN HWND hwndCtl,
    IN UINT uNotifyCode)
    {
    LPMODEMDLG lpmd = (LPMODEMDLG)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (id) 
        {
    case IDC_ADD:
        // Kick off the modem wizard.  
        DoWizard(hDlg);
        FillModemLB(hDlg, 0, ICOL_MODEM, &lpmd->hdi);
        break;
        
    case MIDM_REMOVE:
    case IDC_REMOVE:
        RemoveModem(hDlg, lpmd);
        break;

    case MIDM_PROPERTIES:
    case IDC_PROPERTIES:
        DoModemProperties(hDlg, lpmd->hdi);
        break;

    case MIDM_COPYPROPERTIES:
        CopyProperties (hDlg, lpmd->hdi);
        break;

    case MIDM_APPLYPROPERTIES:
        ApplyProperties (hDlg, lpmd->hdi);
        break;

    case MIDM_CLONE:
        CloneModem(hDlg, lpmd);
        break;

    case MIDM_VIEWLOG:
        ViewLog(hDlg, lpmd->hdi);
        break;



        }

    }


/*----------------------------------------------------------
Purpose: Comparison function for sorting columns

Returns: 
Cond:    --
*/
int
CALLBACK
ModemCpl_Compare(
    IN LPARAM lparam1,
    IN LPARAM lparam2,
    IN LPARAM lparamSort)
    {
    int iRet;
    PMODEMITEM pitem1 = (PMODEMITEM)lparam1;
    PMODEMITEM pitem2 = (PMODEMITEM)lparam2;
    DWORD      iCol = (DWORD)lparamSort;

    switch (iCol)
        {
    case ICOL_MODEM:
        iRet = lstrcmp(pitem1->mpp.szFriendlyName, pitem2->mpp.szFriendlyName);
        //iRet = my_lstrcmp_an(pitem1->mpp.szFriendlyName, pitem2->mpp.szFriendlyName);
        break;

    case ICOL_PORT:
        // iRet = lstrcmp(pitem1->mpp.szPort, pitem2->mpp.szPort);
        iRet = my_lstrcmp_an(pitem1->mpp.szPort, pitem2->mpp.szPort);
        break;
        }

	if (!g_bSortAscending) iRet = -iRet;

    return iRet;
    }


BOOL
DoesLogFileExist(
    IN HDEVINFO hdi,
    PMODEMITEM pitem
    )

{
    HKEY    hkeyDrv;
    BOOL    bResult=FALSE;

    hkeyDrv = SetupDiOpenDevRegKey (hdi, &pitem->devData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ);

    if (INVALID_HANDLE_VALUE == hkeyDrv) {

        TRACE_MSG (TF_ERROR,
                   "Could not open the driver registry key for\n  %s\n  error: %#lx",
                   pitem->mpp.szFriendlyName, GetLastError ());

        return FALSE;
    }

    {
        TCHAR    LogPath[MAX_PATH+2];
        DWORD    ValueType;
        DWORD    BufferLength;
        LONG     lResult;
        HANDLE   FileHandle;

        BufferLength=sizeof(LogPath);

        lResult=RegQueryValueEx (hkeyDrv,
                                 c_szLoggingPath,
                                 0,
                                 &ValueType,
                                 (LPBYTE)(LogPath),
                                 &BufferLength);

        if (lResult == ERROR_SUCCESS) {

            FileHandle=CreateFile(
                LogPath,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

            if (FileHandle != INVALID_HANDLE_VALUE) {

                CloseHandle(FileHandle);

                bResult=TRUE;
            }
        }
    }
    RegCloseKey(hkeyDrv);

    return bResult;
}


/*----------------------------------------------------------
Purpose: Show the context menu

Returns: --
Cond:    --
*/

#define ENABLE_COPY     0x1
#define ENABLE_APPLY    0x2
#define ENABLE_CLONE    0x4
#define ENABLE_VIEWLOG  0x8

void
PRIVATE
ModemCpl_DoContextMenu(
    IN HWND     hDlg,
    IN LPPOINT  ppt)
{
 HWND  hWndCtl;
 HMENU hmenu;
 DWORD dwFlags = ENABLE_COPY | ENABLE_APPLY | ENABLE_CLONE | ENABLE_VIEWLOG;
 LV_ITEM lvi;
 PMODEMITEM pitem;
 int iSel;

    hWndCtl = GetDlgItem (hDlg, IDC_MODEMLV);

    if (1 < ListView_GetSelectedCount (hWndCtl))
    {
        ClearFlag (dwFlags, ENABLE_COPY);
        ClearFlag (dwFlags, ENABLE_CLONE);
        ClearFlag (dwFlags, ENABLE_VIEWLOG);
    }
    if (FALSE == g_PropertiesClipboard.dwIsDataValid)
    {
        ClearFlag (dwFlags, ENABLE_APPLY);
    }

    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;

    iSel = ListView_GetNextItem(hWndCtl, -1, LVNI_SELECTED);
    while (-1 != iSel)
    {
        lvi.iItem = iSel;
        ListView_GetItem(hWndCtl, &lvi);
        pitem = (PMODEMITEM)lvi.lParam;
        if (IsFlagClear (pitem->dwFlags, MIF_LEGACY))
        {
            ClearFlag (dwFlags, ENABLE_CLONE);
        }
        if (IsFlagSet (pitem->dwFlags, MIF_PROBLEM) ||
            IsFlagSet (pitem->dwFlags, MIF_NOT_PRESENT))
        {
            break;
        }
        if (IsFlagSet(dwFlags,ENABLE_VIEWLOG)) {

            LPMODEMDLG lpmd = (LPMODEMDLG)GetWindowLongPtr(hDlg, DWLP_USER);

            if (!DoesLogFileExist(lpmd->hdi,pitem)) {
                //
                //  log file does not exist
                //
                ClearFlag (dwFlags, ENABLE_VIEWLOG);
            }
        }


        iSel = ListView_GetNextItem(hWndCtl, iSel, LVNI_SELECTED);
    }
    if (-1 != iSel)
    {
        ClearFlag (dwFlags, ENABLE_COPY);
        ClearFlag (dwFlags, ENABLE_APPLY);
        ClearFlag (dwFlags, ENABLE_CLONE);
    }

    hmenu = LoadMenu(g_hinst, MAKEINTRESOURCE(POPUP_CONTEXT));
    if (hmenu)
    {
        HMENU hmenuContext = GetSubMenu(hmenu, 0);
        if (IsFlagClear (dwFlags, ENABLE_COPY))
        {
            EnableMenuItem (hmenuContext, MIDM_COPYPROPERTIES, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
            EnableMenuItem (hmenuContext, MIDM_PROPERTIES, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
        }
        if (IsFlagClear (dwFlags, ENABLE_CLONE))
        {
            EnableMenuItem (hmenuContext, MIDM_CLONE, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
        }
        if (IsFlagClear (dwFlags, ENABLE_APPLY))
        {
            EnableMenuItem (hmenuContext, MIDM_APPLYPROPERTIES, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
        }

        if (IsFlagClear (dwFlags, ENABLE_VIEWLOG)) {

            EnableMenuItem (hmenuContext, MIDM_VIEWLOG, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
        }

        TrackPopupMenu(hmenuContext, TPM_LEFTALIGN | TPM_RIGHTBUTTON, 
                       ppt->x, ppt->y, 0, hDlg, NULL);

        DestroyMenu(hmenu);
    }
}
    

/*----------------------------------------------------------
Purpose: WM_NOTIFY handler

Returns: varies
Cond:    --
*/
LRESULT 
PRIVATE 
ModemCpl_OnNotify(
    IN HWND         hDlg,
    IN int          idFrom,
    IN NMHDR FAR *  lpnmhdr)
{
    LRESULT lRet = 0;
    LPMODEMDLG lpmd = (LPMODEMDLG)GetWindowLongPtr(hDlg, DWLP_USER);
    HWND hwndFocus;
    
    switch (lpnmhdr->code)
    {
        case PSN_SETACTIVE:
            break;

        case PSN_KILLACTIVE:
            // N.b. This message is not sent if user clicks Cancel!
            // N.b. This message is sent prior to PSN_APPLY
            //
            break;

        case PSN_APPLY:
            break;


        case NM_DBLCLK:

            if (IDC_MODEMLV == lpnmhdr->idFrom)
            {
                // Was an item clicked?
                HWND hwndCtl = lpnmhdr->hwndFrom;
                LV_HITTESTINFO ht;
                POINT pt;

                GetCursorPos(&pt);
                ht.pt = pt;

                ScreenToClient(hwndCtl, &ht.pt);
                ListView_HitTest(hwndCtl, &ht);

                if (   (ht.flags & LVHT_ONITEM)
                    && USER_IS_ADMIN()
                    && IsSelectedModemWorking(hwndCtl, ht.iItem))
                {
                    DoModemProperties(hDlg, lpmd->hdi);
                }
            }
            break;



        case NM_RCLICK:
            if (IDC_MODEMLV == lpnmhdr->idFrom)
            {
                // Was an item clicked?
                HWND hwndCtl = lpnmhdr->hwndFrom;
                LV_HITTESTINFO ht;
                POINT pt;

                GetCursorPos(&pt);
                ht.pt = pt;

                ScreenToClient(hwndCtl, &ht.pt);
                ListView_HitTest(hwndCtl, &ht);

                if (   (ht.flags & LVHT_ONITEM)
                    && USER_IS_ADMIN())
                {
                    ModemCpl_DoContextMenu(hDlg, &pt);
                }
            }
            break;

        case NM_RETURN:
            SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_PROPERTIES, BN_CLICKED), 
                        (LPARAM)GetDlgItem(hDlg, IDC_PROPERTIES));
            break;

        case LVN_KEYDOWN: 
        {
            NM_LISTVIEW FAR * lpnm_lv = (NM_LISTVIEW FAR *)lpnmhdr;

            switch (((LV_KEYDOWN FAR *)lpnm_lv)->wVKey)
            {
                case VK_DELETE:

                    if (USER_IS_ADMIN())
                    {
                        RemoveModem(hDlg, lpmd);
                    }
                    break;

                case VK_F10:
                    // Shift-F10 brings up the context menu

                    // Is the shift down?
                    if ( !(0x8000 & GetKeyState(VK_SHIFT)) )
                    {
                        // No; break
                        break;
                    }

                    // Yes; fall thru

                case VK_APPS:
                {         // Context menu
                    HWND hwndCtl = lpnmhdr->hwndFrom;
                    int iSel;

                    iSel = ListView_GetNextItem(hwndCtl, -1, LVNI_SELECTED);
                    if (-1 != iSel) 
                    {
                        RECT rc;
                        POINT pt;

                        ListView_GetItemRect(hwndCtl, iSel, &rc, LVIR_ICON);
                        pt.x = rc.left + ((rc.right - rc.left) / 2);
                        pt.y = rc.top + ((rc.bottom - rc.top) / 2);
                        ClientToScreen(hwndCtl, &pt);

                        ModemCpl_DoContextMenu(hDlg, &pt);
                    }

                    break;
                }
            }
            break;
        }

        case LVN_COLUMNCLICK:
        {
         NM_LISTVIEW FAR * lpnm_lv = (NM_LISTVIEW FAR *)lpnmhdr;

			if (g_CurrentSubItemToSort == lpnm_lv->iSubItem)
				g_bSortAscending = !g_bSortAscending;
			else
				g_CurrentSubItemToSort = lpnm_lv->iSubItem;

            ListView_SortItems (lpnmhdr->hwndFrom, ModemCpl_Compare, (LPARAM)g_CurrentSubItemToSort);

            break;
        }

        case LVN_ITEMCHANGED:
        {
         NM_LISTVIEW FAR * lpnm_lv = (NM_LISTVIEW FAR *)lpnmhdr;
         int cSel = ListView_GetSelectedCount (lpnm_lv->hdr.hwndFrom);

            if (cSel != lpmd->cSel)
            {
                if (IsFlagClear(lpmd->dwFlags, FLAG_MSG_POSTED))
                {
                    PostMessage (hDlg, WM_ENABLE_BUTTONS, 0, 0);
                    SetFlag (lpmd->dwFlags, FLAG_MSG_POSTED);
                }

                lpmd->cSel = cSel;
            }
            break;
        }

        case LVN_DELETEALLITEMS:
            hwndFocus = GetFocus();

            Button_Enable(GetDlgItem(hDlg, IDC_PROPERTIES), FALSE);
            Button_Enable(GetDlgItem(hDlg, IDC_REMOVE), FALSE);
            lpmd->cSel = 0;
            lpmd->dwFlags = 0;

            if ( !hwndFocus || !IsWindowEnabled(hwndFocus) )
            {
                SetFocus(GetDlgItem(hDlg, IDC_ADD));
                SendMessage(hDlg, DM_SETDEFID, IDC_ADD, 0);
            }
            break;

        default:
            break;
    }

    return lRet;
}


/*----------------------------------------------------------
Purpose: WM_DEVICECHANGE handler

Returns: --
Cond:    --
*/
BOOL ModemCpl_OnDeviceChange (HWND hDlg, UINT Event, DWORD dwData)
{
 BOOL bRet = TRUE;
 LPMODEMDLG lpmd = (LPMODEMDLG)GetWindowLongPtr(hDlg, DWLP_USER);

    DBG_ENTER_UL(ModemCpl_OnDeviceChange, Event);
    if (g_iCPLFlags & FLAG_PROCESS_DEVCHANGE)
    {
        switch (Event)
        {
            case DBT_DEVICEARRIVAL:
            case DBT_DEVICEREMOVECOMPLETE:
                FillModemLB (hDlg, 0, ICOL_MODEM, &lpmd->hdi);
                break;

            default:
                break;
        }
    }

    DBG_EXIT(ModemCpl_OnDeviceChange);
    return bRet;
}


/*----------------------------------------------------------
Purpose: WM_DESTROY handler

Returns: --
Cond:    --
*/
void
PRIVATE
ModemCpl_OnDestroy (IN HWND hDlg)
{
 LPMODEMDLG lpmd = (LPMODEMDLG)GetWindowLongPtr(hDlg, DWLP_USER);

    // Need to unregister device notifications
    if (NULL != lpmd->NotificationHandle)
    {
        UnregisterDeviceNotification (lpmd->NotificationHandle);
    }

    // Need to free the device info structs for each modem
    FreeModemListData((HWND)GetDlgItem(hDlg, IDC_MODEMLV));

    if (INVALID_HANDLE_VALUE != lpmd->hdi)
    {
        SetupDiDestroyDeviceInfoList (lpmd->hdi);
    }
}



void ModemCpl_OnEnableButtons (HWND hDlg)
{
 LPMODEMDLG lpmd = (LPMODEMDLG)GetWindowLongPtr(hDlg, DWLP_USER);

    if (USER_IS_ADMIN())
    {
     HWND hwndLV = GetDlgItem(hDlg, IDC_MODEMLV);
     HWND hwndProp = GetDlgItem(hDlg, IDC_PROPERTIES);
     HWND hwndDel = GetDlgItem(hDlg, IDC_REMOVE);
     int cSel = ListView_GetSelectedCount (hwndLV);
     BOOL bOldEnabled;
     BOOL bNewEnabled;

        lpmd->dwFlags &= ~(FLAG_DEL_ENABLED | FLAG_PROP_ENABLED);
        if (cSel > 0)
        {
            SetFlag (lpmd->dwFlags, FLAG_DEL_ENABLED);
        }

        if (1 == cSel)
        {
         LV_ITEM lvi;
         PMODEMITEM pitem;

            lvi.mask = LVIF_PARAM;
            lvi.iItem = ListView_GetNextItem(hwndLV, -1, LVNI_SELECTED);;
            lvi.iSubItem = 0;
            ListView_GetItem(hwndLV, &lvi);

            pitem = (PMODEMITEM)lvi.lParam;

            if (IsFlagClear (pitem->dwFlags, MIF_PROBLEM) &&
                IsFlagClear (pitem->dwFlags, MIF_NOT_PRESENT))
            {
                SetFlag (lpmd->dwFlags, FLAG_PROP_ENABLED);
            }
        }

        bOldEnabled = IsWindowEnabled (hwndProp)?1:0;
        bNewEnabled = (lpmd->dwFlags & FLAG_PROP_ENABLED)?1:0;
        if (bOldEnabled != bNewEnabled)
        {
            EnableWindow (hwndProp, bNewEnabled);
        }

        bOldEnabled = IsWindowEnabled (hwndDel)?1:0;
        bNewEnabled = (lpmd->dwFlags & FLAG_DEL_ENABLED)?1:0;
        if (bOldEnabled != bNewEnabled)
        {
            EnableWindow (hwndDel, bNewEnabled);
        }
    }

    lpmd->dwFlags = 0;
}



/*----------------------------------------------------------
Purpose: Dialog proc for main modem CPL dialog
Returns: varies
Cond:    --
*/
INT_PTR
CALLBACK
ModemCplDlgProc(
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam)
{
#pragma data_seg(DATASEG_READONLY)
    const static DWORD rgHelpIDs[] = {
        (UINT)IDC_STATIC,   IDH_MODEM_INSTALLED,
        IDC_CLASSICON,      IDH_MODEM_INSTALLED,
        IDC_MODEMLV,        IDH_MODEM_INSTALLED,
        IDC_ADD,            IDH_MODEM_ADD,
        IDC_REMOVE,         IDH_MODEM_REMOVE,
        IDC_PROPERTIES,     IDH_MODEM_PROPERTIES,
        IDC_DIALPROP,       IDH_MODEM_DIALING_PROPERTIES,
        IDC_LOC,            IDH_MODEM_DIALING_PROPERTIES,
        0, 0 };
#pragma data_seg()

    switch (message) 
    {
        HANDLE_MSG(hDlg, WM_INITDIALOG, ModemCpl_OnInitDialog);
        HANDLE_MSG(hDlg, WM_DESTROY, ModemCpl_OnDestroy);
        HANDLE_MSG(hDlg, WM_COMMAND, ModemCpl_OnCommand);
        HANDLE_MSG(hDlg, WM_NOTIFY, ModemCpl_OnNotify);
        HANDLE_MSG(hDlg, WM_DEVICECHANGE, ModemCpl_OnDeviceChange);

    case WM_ENABLE_BUTTONS:
        ModemCpl_OnEnableButtons (hDlg);
        break;

    case WM_HELP:
        WinHelp(((LPHELPINFO)lParam)->hItemHandle, c_szWinHelpFile, HELP_WM_HELP, (ULONG_PTR)(LPVOID)rgHelpIDs);
        break;

    case WM_CONTEXTMENU:
        // Don't bring up help context menu on list view control - it
        // already has a popup menu on the right mouse click.
        if (GetWindowLong((HWND)wParam, GWL_ID) != IDC_MODEMLV)
            WinHelp((HWND)wParam, c_szWinHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPVOID)rgHelpIDs);
        break;
    }
    
    return FALSE;
}


BOOL
RestartComputerDlg(
    IN HWND hwndOwner )

    /* Popup that asks the user to restart.  'HwndOwner' is the owning window.
    **
    ** Returns true if user selects "Yes", false otherwise.
    */
{
    int nStatus=FALSE;

    TRACE_MSG(TF_GENERAL, "RestartComputerDlg");

#if 0
    nStatus =
        (BOOL )DialogBoxParam(
            g_hinst,
            MAKEINTRESOURCE( DID_RC_Restart ),
            hwndOwner,
            RcDlgProc,
            (LPARAM )NULL );

    if (nStatus == -1)
        nStatus = FALSE;
#else // 0
        // Ask the user first
	if (IDYES == MsgBox(g_hinst, hwndOwner, 
						MAKEINTRESOURCE(IDS_ASK_REBOOTNOW),
						MAKEINTRESOURCE(IDS_CAP_RASCONFIG), 
						NULL, 
						MB_YESNO | MB_ICONEXCLAMATION))
    {
		nStatus = TRUE;
	}

#endif // 0

    return (BOOL )nStatus;
}

BOOL
RestartComputer()

    /* Called if user chooses to shut down the computer.
    **
    ** Return false if failure, true otherwise
    */
{
   HANDLE            hToken;              /* handle to process token */
   TOKEN_PRIVILEGES  tkp;                 /* ptr. to token structure */
   BOOL              fResult;             /* system shutdown flag */

    TRACE_MSG(TF_GENERAL, "RestartComputer");

   /* Enable the shutdown privilege */

   if (!OpenProcessToken( GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &hToken))
      return FALSE;

   /* Get the LUID for shutdown privilege. */

   LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);

   tkp.PrivilegeCount = 1;  /* one privilege to set    */
   tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

   /* Get shutdown privilege for this process. */

   AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES) NULL, 0);

   /* Cannot test the return value of AdjustTokenPrivileges. */

   if (GetLastError() != ERROR_SUCCESS)
      return FALSE;

   if( !ExitWindowsEx(EWX_REBOOT, 0))
      return FALSE;

   /* Disable shutdown privilege. */

   tkp.Privileges[0].Attributes = 0;
   AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES) NULL, 0);

   if (GetLastError() != ERROR_SUCCESS)
      return FALSE;

   return TRUE;
}

int my_atol(LPTSTR lptsz);

// Special-case alphanumeric stringcmp.
//
// The function returns for various combinations of input are give below.
// Note that it only does a numeric comparison for the tail end of the string.
// So, for example, it claims "2a" > "12". It also claims "a2 > a01". Big deal.
// The following data was actually generated by calling this function.
//
// fn("","")=0     fn("a","a")=0    fn("1","11")=-1     fn("a2","a12")=-990
// fn("","1")=-1   fn("1","1")=0    fn("11","1")=1      fn("a12","a2")=990
// fn("1","")=1    fn("a","1")=1    fn("1","12")=-1     fn("12a","2a")=-1
// fn("","a")=-1   fn("1","a")=-1   fn("12","1")=1      fn("2a","12a")=1
// fn("a","")=1    fn("a","b")=-1   fn("2","12")=-990   fn("a2","a01")=-879
// fn("b","a")=1   fn("12","2")=990 fn("101","12")=879
// fn("1","2")=-11 fn("2","1")=11
//
int my_lstrcmp_an(LPTSTR lptsz1, LPTSTR lptsz2)
{
	int i1, i2;

	// Skip common prefix
	while(*lptsz1 && *lptsz1==*lptsz2)
	{
		lptsz1++;
		lptsz2++;
	}
	i1 = my_atol(lptsz1);
	i2 = my_atol(lptsz2);

	if (i1==MAXDWORD || i2==MAXDWORD) return lstrcmp(lptsz1, lptsz2);
	else							  return i1-i2;
}

int my_atol(LPTSTR lptsz)
{
 TCHAR tchr = *lptsz++;
 int   iRet = 0;

	if (!tchr) goto bail;

	do
	{
        if (IsCharAlpha (tchr) ||
            !IsCharAlphaNumeric (tchr))
        {
            goto bail;
        }

		iRet*=10;
		iRet+=(int)tchr-(int)TEXT('0');
		tchr = *lptsz++;
	} while(tchr); 

	return iRet;

bail:
	return MAXDWORD;
}

BOOL IsSelectedModemWorking(
            HWND hwndLB,
            int iItem
        )
{
    LV_ITEM lvi;
    PMODEMITEM pitem;

    lvi.mask = LVIF_PARAM;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;
    ListView_GetItem(hwndLB, &lvi);

    pitem = (PMODEMITEM)lvi.lParam;

    return (pitem->dwFlags & (MIF_PROBLEM | MIF_NOT_PRESENT)) ? FALSE : TRUE;
}



INT_PTR CALLBACK DiagWaitModemDlgProc (
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam)
{
 static BOOL *pbCancel = NULL;

    switch (message)
    {
        case WM_INITDIALOG:
            pbCancel = (BOOL*)lParam;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
		    {
        	    case IDCANCEL:
				    *pbCancel = TRUE;
                    DestroyWindow (hDlg);
            	    break;
            }        
            break;

        default:
		    return FALSE;
            break;
    }    

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\modemui\cfggen.c ===
//---------------------------------------------------------------------------
//
// Copyrght (c) Microsoft Corporation 1993-1994
//
// File: gen.c
//
// This files contains the dialog code for the CPL General property page.
//
// History:
//  1-14-94 ScottH     Created
//
//---------------------------------------------------------------------------


/////////////////////////////////////////////////////  INCLUDES

#include "proj.h"         // common headers
#include "cfgui.h"


/////////////////////////////////////////////////////  CONTROLLING DEFINES

/////////////////////////////////////////////////////  TYPEDEFS

#define SUBCLASS_PARALLEL   0
#define SUBCLASS_SERIAL     1
#define SUBCLASS_MODEM      2

#define DEF_TIMEOUT                60      // 60 seconds
#define DEF_INACTIVITY_TIMEOUT     30      // 30 minutes
#define SECONDS_PER_MINUTE         60      // 60 seconds in a minute

#define MAX_NUM_VOLUME_TICS 4

#define SIG_CFGGEN    0x80ebb15f



// Flags for ConvertFlowCtl
#define CFC_DCBTOMS     1
#define CFC_MSTODCB     2
#define CFC_SW_CAPABLE  4
#define CFC_HW_CAPABLE  8

void FAR PASCAL ConvertFlowCtl(WIN32DCB FAR * pdcb, MODEMSETTINGS FAR * pms, UINT uFlags);

#define SAFE_DTE_SPEED 19200
static DWORD const FAR s_adwLegalBaudRates[] = { 300, 1200, 2400, 9600, 19200, 38400, 57600, 115200 };

typedef struct
{
    DWORD dwSig;            // Must be set to SIG_CFGGEN
    HWND hdlg;              // dialog handle

    // Call preferences ...
    HWND hwndDialTimerED;
    HWND hwndIdleTimerCH;
    HWND hwndIdleTimerED;
    HWND hwndManualDialCH;
    BOOL bManualDial;
    BOOL bSaveSpeakerVolume;

    // Data preferences...
    HWND hwndPort;
    HWND hwndErrCtl;
    HWND hwndCompress;
    HWND hwndFlowCtrl;
    BOOL bSupportsCompression;
    BOOL bSupportsForcedEC;
    BOOL bSupportsCellular;
    BOOL bSaveCompression;
    BOOL bSaveForcedEC;
    BOOL bSaveCellular;

    LPCFGMODEMINFO pcmi;        // modeminfo struct passed in to dialog

    int  iSelOriginal;


} CFGGEN, FAR * PCFGGEN;

void CfgGen_FillErrorControl(PCFGGEN this);
void CfgGen_FillCompression(PCFGGEN this);
void CfgGen_FillFlowControl(PCFGGEN this);
void PRIVATE CfgGen_SetTimeouts(PCFGGEN this);

void PRIVATE CfgGen_OnApply(
    PCFGGEN this
    );

void
PRIVATE
CfgGen_OnCommand(
    PCFGGEN this,
    IN int  id,
    IN HWND hwndCtl,
    IN UINT uNotifyCode
    );


/////////////////////////////////////////////////////  DEFINES

/////////////////////////////////////////////////////  MACROS

#define VALID_CFGGEN(_pcplgen)  ((_pcplgen)->dwSig == SIG_CFGGEN)

PCFGGEN CfgGen_GetPtr(HWND hwnd)
{
    PCFGGEN pCfgGen = (PCFGGEN)GetWindowLongPtr(hwnd, DWLP_USER);
    if (!pCfgGen || VALID_CFGGEN(pCfgGen))
    {
        return pCfgGen;
    }
    else
    {
        ASSERT(FALSE);
        return NULL;
    }
}

void CfgGen_SetPtr(HWND hwnd, PCFGGEN pCfgGen)
{
    if (pCfgGen && !VALID_CFGGEN(pCfgGen))
    {
        ASSERT(FALSE);
        pCfgGen = NULL;
    }

    SetWindowLongPtr(hwnd, DWLP_USER, (ULONG_PTR) pCfgGen);
}



/*----------------------------------------------------------
Purpose: Computes a "decent" initial baud rate.

Returns: a decent/legal baudrate (legal = settable)
Cond:    --
*/
DWORD
PRIVATE
ComputeDecentBaudRate(
    IN DWORD dwMaxDTERate,  // will always be legal
    IN DWORD dwMaxDCERate)  // will not always be legal
    {
    DWORD dwRetRate;
    int   i;
    static const ceBaudRates = ARRAYSIZE(s_adwLegalBaudRates);


    dwRetRate = 2 * dwMaxDCERate;

    if (dwRetRate <= s_adwLegalBaudRates[0] || dwRetRate > s_adwLegalBaudRates[ceBaudRates-1])
        {
        dwRetRate = dwMaxDTERate;
        }
    else
        {
        for (i = 1; i < ceBaudRates; i++)
            {
            if (dwRetRate > s_adwLegalBaudRates[i-1] && dwRetRate <= s_adwLegalBaudRates[i])
                {
                break;
                }
            }

        // cap off at dwMaxDTERate
        dwRetRate = s_adwLegalBaudRates[i] > dwMaxDTERate ? dwMaxDTERate : s_adwLegalBaudRates[i];

        // optimize up to SAFE_DTE_SPEED or dwMaxDTERate if possible
        if (dwRetRate < dwMaxDTERate && dwRetRate < SAFE_DTE_SPEED)
            {
            dwRetRate = min(dwMaxDTERate, SAFE_DTE_SPEED);
            }
        }

#ifndef PROFILE_MASSINSTALL
    TRACE_MSG(TF_GENERAL, "A.I. Initial Baud Rate: MaxDCE=%ld, MaxDTE=%ld, A.I. Rate=%ld",
              dwMaxDCERate, dwMaxDTERate, dwRetRate);
#endif
    return dwRetRate;
    }

/////////////////////////////////////////////////////  MODULE DATA


/*----------------------------------------------------------
Purpose: Set the speed controls
Returns: --
Cond:    --
*/
void PRIVATE CfgGen_SetSpeed(
    PCFGGEN this)
{
    WIN32DCB FAR * pdcb = &this->pcmi->w.dcb;
    // DWORD dwDTEMax = this->pcmi->dwMaximumPortSpeed;
    DWORD dwDTEMax;
    int n;
    int iMatch = -1;
    TCHAR sz[MAXMEDLEN];
    const BAUDS *pBaud = c_rgbauds;

    // Compute the DTE Max baud rate
    dwDTEMax = ComputeDecentBaudRate(this->pcmi->c.devcaps.dwMaxDTERate,
                                     this->pcmi->c.devcaps.dwMaxDCERate);

    // Fill the listbox
    SetWindowRedraw(this->hwndPort, FALSE);
    ComboBox_ResetContent(this->hwndPort);

    for (; pBaud->dwDTERate; pBaud++)
        {
        // Only fill up to the max DTE speed of the modem
        if (pBaud->dwDTERate <= dwDTEMax)
            {
            n = ComboBox_AddString (this->hwndPort,
                                    SzFromIDS(g_hinst, pBaud->ids, sz, SIZECHARS(sz)));
            ComboBox_SetItemData(this->hwndPort, n, pBaud->dwDTERate);

            // Keep our eyes peeled for important values
            if (pdcb->BaudRate == pBaud->dwDTERate)
                {
                iMatch = n;
                }
            }
        else
            break;
        }

    // Is the DCB baudrate >= the maximum possible DTE rate?
    if (pdcb->BaudRate >= dwDTEMax || -1 == iMatch)
        {
        // Yes; choose the highest possible (last) entry
        this->iSelOriginal = ComboBox_GetCount(this->hwndPort) - 1;
        }
    else
        {
        // No; choose the matched value
        ASSERT(-1 != iMatch);
        this->iSelOriginal = iMatch;
        }
    SetWindowRedraw (this->hwndPort, TRUE);
    ComboBox_SetCurSel (this->hwndPort, this->iSelOriginal);

#if 0   // We don't support this option anymore
    // Can this modem adjust speed?
    if (IsFlagClear(this->pcmi->c.devcaps.dwModemOptions, MDM_SPEED_ADJUST))
        {
        // No; disable the checkbox and check it
        Button_Enable(hwndCH, FALSE);
        Button_SetCheck(hwndCH, FALSE);
        }
    else
        {
        // Yes; enable the checkbox
        Button_Enable(hwndCH, TRUE);
        Button_SetCheck(hwndCH, IsFlagClear(this->pcmi->w.ms.dwPreferredModemOptions, MDM_SPEED_ADJUST));
        }
#endif
}


/*----------------------------------------------------------
Purpose: WM_INITDIALOG Handler
Returns: FALSE when we assign the control focus
Cond:    --
*/
BOOL PRIVATE CfgGen_OnInitDialog(
    PCFGGEN this,
    HWND hwndFocus,
    LPARAM lParam)              // expected to be PROPSHEETINFO
{
    LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
    HWND hdlg = this->hdlg;
    DWORD dwCapOptions =  0;
    BOOL fRet  = FALSE;

    ASSERT(VALID_CFGGEN(this));
    ASSERT((LPTSTR)lppsp->lParam);

    this->pcmi = (LPCFGMODEMINFO)lppsp->lParam;

    if (!VALIDATE_CMI(this->pcmi))
    {
        ASSERT(FALSE);
        goto end;
    }


    dwCapOptions =  this->pcmi->c.devcaps.dwModemOptions;

    // Save away the window handles
    //  Call preferences ...
    this->hwndDialTimerED = GetDlgItem(hdlg, IDC_ED_DIALTIMER);
    this->hwndIdleTimerCH = GetDlgItem(hdlg, IDC_CH_IDLETIMER);
    this->hwndIdleTimerED = GetDlgItem(hdlg, IDC_ED_IDLETIMER);
    this->hwndManualDialCH = GetDlgItem(hdlg, IDC_MANUAL_DIAL);
    // Data preferences...
    this->hwndPort     = GetDlgItem(hdlg, IDC_CB_SPEED);
    this->hwndErrCtl   = GetDlgItem(hdlg, IDC_CB_EC);
    this->hwndCompress = GetDlgItem(hdlg, IDC_CB_COMP);
    this->hwndFlowCtrl = GetDlgItem(hdlg, IDC_CB_FC);
    // Push-botton to launch "CPL" modem properties


    if (TRUE == g_dwIsCalledByCpl)
    {
        // If we're called from the CPL, disable a bunch of
        // stuff, that can be set directly form the CPL
        EnableWindow (this->hwndManualDialCH, FALSE);
        ShowWindow (this->hwndManualDialCH, SW_HIDE);
    }
    else
    {
        // ----------------- MANUAL DIAL  -----------------------
        // Don't enable manual dial unless the modem supports BLIND dialing
        // We need that capability to be able to do it.
        //
        if (dwCapOptions & MDM_BLIND_DIAL)
        {
            Button_SetCheck(
                     this->hwndManualDialCH,
                     (this->pcmi->w.fdwSettings & UMMANUAL_DIAL)!=0
                     );
        }
        else
        {
            Button_Enable(this->hwndManualDialCH, FALSE);
        }
    }

    // ----------------- PORT SPEED --------------------

    // Is this a parallel port?
    if (DT_PARALLEL_PORT == this->pcmi->c.dwDeviceType)
    {
        // Yes; hide the speed controls
        ShowWindow(this->hwndPort, SW_HIDE);
        EnableWindow(this->hwndPort, FALSE);
    }

    // -------------------- TIMEOUTS- ----------------------------

    Edit_LimitText(this->hwndDialTimerED, 3);
    Edit_LimitText(this->hwndIdleTimerED, 3);

    CfgGen_SetTimeouts(this);

    // ---------- ERROR CONTROL -----------
    CfgGen_FillErrorControl(this);

    // ---------- COMPRESSION -----------
    CfgGen_FillCompression(this);

    // ---------- FLOW CONTROL -----------
    CfgGen_FillFlowControl(this);

    fRet  = TRUE;

end:

    return fRet;   // default initial focus
}



/*----------------------------------------------------------
Purpose: PSN_KILLACTIVE handler
Returns: --
Cond:    --
*/
void PRIVATE CfgGen_OnSetActive(
    PCFGGEN this)
{
    // Set the speed listbox selection; find DCB rate in the listbox
    // (The speed can change in the Connection page thru the Port Settings
    // property dialog.)
    CfgGen_SetSpeed(this);
}


/*----------------------------------------------------------
Purpose: PSN_KILLACTIVE handler
Returns: --
Cond:    --
*/
void PRIVATE CfgGen_OnKillActive(
    PCFGGEN this)
{
 int iSel;

    // Save the settings back to the modem info struct so the Connection
    // page can invoke the Port Settings property dialog with the
    // correct settings.

    // Speed setting
    iSel = ComboBox_GetCurSel(this->hwndPort);
    this->pcmi->w.dcb.BaudRate = (DWORD)ComboBox_GetItemData(this->hwndPort, iSel);
}


/*----------------------------------------------------------
Purpose: WM_NOTIFY handler
Returns: varies
Cond:    --
*/
LRESULT PRIVATE CfgGen_OnNotify(
    PCFGGEN this,
    int idFrom,
    NMHDR FAR * lpnmhdr)
{
    LRESULT lRet = 0;

    switch (lpnmhdr->code)
        {
    case PSN_SETACTIVE:
        CfgGen_OnSetActive(this);
        break;

    case PSN_KILLACTIVE:
        // N.b. This message is not sent if user clicks Cancel!
        // N.b. This message is sent prior to PSN_APPLY
        CfgGen_OnKillActive(this);
        break;

    case PSN_APPLY:
        CfgGen_OnApply(this);
        break;

    default:
        break;
        }

    return lRet;
}


/*----------------------------------------------------------
Purpose: WM_DESTROY handler
Returns: --
Cond:    --
*/
void PRIVATE CfgGen_OnDestroy(
    PCFGGEN this)
{
}


/////////////////////////////////////////////////////  EXPORTED FUNCTIONS

static BOOL s_bCfgGenRecurse = FALSE;

LRESULT INLINE CfgGen_DefProc(
    HWND hDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    ENTER_X()
        {
        s_bCfgGenRecurse = TRUE;
        }
    LEAVE_X()

    return DefDlgProc(hDlg, msg, wParam, lParam);
}


/*----------------------------------------------------------
Purpose: Real dialog proc
Returns: varies
Cond:    --
*/
LRESULT CfgGen_DlgProc(
    PCFGGEN this,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (message)
        {
        HANDLE_MSG(this, WM_INITDIALOG, CfgGen_OnInitDialog);
        HANDLE_MSG(this, WM_NOTIFY, CfgGen_OnNotify);
        HANDLE_MSG(this, WM_DESTROY, CfgGen_OnDestroy);
        HANDLE_MSG(this, WM_COMMAND, CfgGen_OnCommand);

    case WM_HELP:
        WinHelp(((LPHELPINFO)lParam)->hItemHandle, c_szWinHelpFile, HELP_WM_HELP, (ULONG_PTR)(LPVOID)g_aHelpIDs_IDD_CFG_GENERAL);
        return 0;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, c_szWinHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPVOID)g_aHelpIDs_IDD_CFG_GENERAL);
        return 0;

    default:
        return CfgGen_DefProc(this->hdlg, message, wParam, lParam);
        }
}


/*----------------------------------------------------------
Purpose: Dialog Wrapper
Returns: varies
Cond:    --
*/
INT_PTR CALLBACK CfgGen_WrapperProc(
    HWND hDlg,          // std params
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PCFGGEN this;

    // Cool windowsx.h dialog technique.  For full explanation, see
    //  WINDOWSX.TXT.  This supports multiple-instancing of dialogs.
    //
    ENTER_X()
        {
        if (s_bCfgGenRecurse)
            {
            s_bCfgGenRecurse = FALSE;
            LEAVE_X()
            return FALSE;
            }
        }
    LEAVE_X()

    this = CfgGen_GetPtr(hDlg);
    if (this == NULL)
        {
        if (message == WM_INITDIALOG)
            {
            this = (PCFGGEN)ALLOCATE_MEMORY( sizeof(CFGGEN));
            if (!this)
                {
                MsgBox(g_hinst,
                       hDlg,
                       MAKEINTRESOURCE(IDS_OOM_GENERAL),
                       MAKEINTRESOURCE(IDS_CAP_GENERAL),
                       NULL,
                       MB_ERROR);
                EndDialog(hDlg, IDCANCEL);
                return (BOOL)CfgGen_DefProc(hDlg, message, wParam, lParam);
                }
            this->dwSig = SIG_CFGGEN;
            this->hdlg = hDlg;
            CfgGen_SetPtr(hDlg, this);
            }
        else
            {
            return (BOOL)CfgGen_DefProc(hDlg, message, wParam, lParam);
            }
        }

    if (message == WM_DESTROY)
        {
        CfgGen_DlgProc(this, message, wParam, lParam);
        this->dwSig = 0;
        FREE_MEMORY((HLOCAL)OFFSETOF(this));
        CfgGen_SetPtr(hDlg, NULL);
        return 0;
        }

    return SetDlgMsgResult(hDlg, message, CfgGen_DlgProc(this, message, wParam, lParam));
}

/*----------------------------------------------------------
Purpose: Set the timeout controls
Returns: --
Cond:    --
*/
void PRIVATE CfgGen_SetTimeouts(
    PCFGGEN this)
{
    int nVal;

    // A note on the timeouts:
    //
    // For the dial timeout, the valid range is [1-255].  If the dial
    // timeout checkbox is unchecked, we set the timeout value to 255.
    //
    // For the disconnect timeout, the valid range is [0-255].  If the
    // dial timeout checkbox is unchecked, we set the timeout value
    // to 0.

    // Is the dial timeout properties disabled?
    if (0 == this->pcmi->c.devcaps.dwCallSetupFailTimer)
        {
        // Yes; disable the box and edit
        Edit_Enable(this->hwndDialTimerED, FALSE);
        }
    else
        {
        // No; check the box and set the time value
        nVal = min(LOWORD(this->pcmi->w.ms.dwCallSetupFailTimer),
                   LOWORD(this->pcmi->c.devcaps.dwCallSetupFailTimer));
        Edit_SetValue(this->hwndDialTimerED, nVal);
        }

    // Is the disconnect timeout properties disabled?
    if (0 == this->pcmi->c.devcaps.dwInactivityTimeout)
        {
        // Yes; disable the box and edit
        Button_Enable(this->hwndIdleTimerCH, FALSE);
        Edit_Enable(this->hwndIdleTimerED, FALSE);
        }
    // No; Is the disconnect timeout set to 0?
    else if (0 == this->pcmi->w.ms.dwInactivityTimeout)
        {
        // Yes; leave box unchecked and disable edit
        Button_SetCheck(this->hwndIdleTimerCH, FALSE);

        Edit_SetValue(this->hwndIdleTimerED, DEF_INACTIVITY_TIMEOUT);
        Edit_Enable(this->hwndIdleTimerED, FALSE);
        }
    else
        {
        // No; check the box and set the time value
        Button_SetCheck(this->hwndIdleTimerCH, TRUE);

        nVal = min(this->pcmi->w.ms.dwInactivityTimeout,
                   this->pcmi->c.devcaps.dwInactivityTimeout);
        Edit_SetValue(this->hwndIdleTimerED, nVal/SECONDS_PER_MINUTE);
        }
}

#pragma data_seg(DATASEG_READONLY)

#define  ISDN(_pinfo)      MDM_GEN_EXTENDEDINFO(                \
                                            MDM_BEARERMODE_ISDN,\
                                            _pinfo              \
                                            )

#define  GSM(_pinfo)      MDM_GEN_EXTENDEDINFO(                \
                                            MDM_BEARERMODE_GSM,\
                                            _pinfo             \
                                            )


//
// This is the structure that is used to fill the data bits listbox
//
const LBMAP s_rgErrorControl[] = {

    { IDS_ERRORCONTROL_STANDARD,  IDS_ERRORCONTROL_STANDARD   },
    { IDS_ERRORCONTROL_DISABLED,  IDS_ERRORCONTROL_DISABLED   },
    { IDS_ERRORCONTROL_REQUIRED,  IDS_ERRORCONTROL_REQUIRED   },
    { IDS_ERRORCONTROL_CELLULAR,  IDS_ERRORCONTROL_CELLULAR },

    {ISDN(MDM_PROTOCOL_AUTO_1CH),           IDS_I_PROTOCOL_AUTO_1CH},
    {ISDN(MDM_PROTOCOL_AUTO_2CH),           IDS_I_PROTOCOL_AUTO_2CH},
    {ISDN(MDM_PROTOCOL_HDLCPPP_56K),        IDS_I_PROTOCOL_HDLC_PPP_56K},
    {ISDN(MDM_PROTOCOL_HDLCPPP_64K),        IDS_I_PROTOCOL_HDLC_PPP_64K},
    {ISDN(MDM_PROTOCOL_HDLCPPP_112K),       IDS_I_PROTOCOL_HDLC_PPP_112K},
    {ISDN(MDM_PROTOCOL_HDLCPPP_112K_PAP),   IDS_I_PROTOCOL_HDLC_PPP_112K_PAP},
    {ISDN(MDM_PROTOCOL_HDLCPPP_112K_CHAP),  IDS_I_PROTOCOL_HDLC_PPP_112K_CHAP},
    {ISDN(MDM_PROTOCOL_HDLCPPP_112K_MSCHAP),IDS_I_PROTOCOL_HDLC_PPP_112K_MSCHAP},
    {ISDN(MDM_PROTOCOL_HDLCPPP_128K),       IDS_I_PROTOCOL_HDLC_PPP_128K},
    {ISDN(MDM_PROTOCOL_HDLCPPP_128K_PAP),   IDS_I_PROTOCOL_HDLC_PPP_128K_PAP},
    {ISDN(MDM_PROTOCOL_HDLCPPP_128K_CHAP),  IDS_I_PROTOCOL_HDLC_PPP_128K_CHAP},
    {ISDN(MDM_PROTOCOL_HDLCPPP_128K_MSCHAP),IDS_I_PROTOCOL_HDLC_PPP_128K_MSCHAP},
    {ISDN(MDM_PROTOCOL_V120_64K),           IDS_I_PROTOCOL_V120_64K},
    {ISDN(MDM_PROTOCOL_V120_56K),           IDS_I_PROTOCOL_V120_56K},
    {ISDN(MDM_PROTOCOL_V120_112K),          IDS_I_PROTOCOL_V120_112K},
    {ISDN(MDM_PROTOCOL_V120_128K),          IDS_I_PROTOCOL_V120_128K},
    {ISDN(MDM_PROTOCOL_X75_64K),            IDS_I_PROTOCOL_X75_64K},
    {ISDN(MDM_PROTOCOL_X75_128K),           IDS_I_PROTOCOL_X75_128K},
    {ISDN(MDM_PROTOCOL_X75_T_70),           IDS_I_PROTOCOL_X75_T_70},
    {ISDN(MDM_PROTOCOL_X75_BTX),            IDS_I_PROTOCOL_X75_BTX},
    {ISDN(MDM_PROTOCOL_V110_1DOT2K),        IDS_I_PROTOCOL_V110_1DOT2K},
    {ISDN(MDM_PROTOCOL_V110_2DOT4K),        IDS_I_PROTOCOL_V110_2DOT4K},
    {ISDN(MDM_PROTOCOL_V110_4DOT8K),        IDS_I_PROTOCOL_V110_4DOT8K},
    {ISDN(MDM_PROTOCOL_V110_9DOT6K),        IDS_I_PROTOCOL_V110_9DOT6K},
    {ISDN(MDM_PROTOCOL_V110_12DOT0K),       IDS_I_PROTOCOL_V110_12DOT0K},
    {ISDN(MDM_PROTOCOL_V110_14DOT4K),       IDS_I_PROTOCOL_V110_14DOT4K},
    {ISDN(MDM_PROTOCOL_V110_19DOT2K),       IDS_I_PROTOCOL_V110_19DOT2K},
    {ISDN(MDM_PROTOCOL_V110_28DOT8K),       IDS_I_PROTOCOL_V110_28DOT8K},
    {ISDN(MDM_PROTOCOL_V110_38DOT4K),       IDS_I_PROTOCOL_V110_38DOT4K},
    {ISDN(MDM_PROTOCOL_V110_57DOT6K),       IDS_I_PROTOCOL_V110_57DOT6K},
    {ISDN(MDM_PROTOCOL_ANALOG_V34),         IDS_I_PROTOCOL_V34},
    {ISDN(MDM_PROTOCOL_PIAFS_INCOMING),     IDS_I_PROTOCOL_PIAFS_INCOMING},
    {ISDN(MDM_PROTOCOL_PIAFS_OUTGOING),     IDS_I_PROTOCOL_PIAFS_OUTGOING},

    //
    // Note: GSM doesn't have multi-link or auto ...
    //
    {GSM(MDM_PROTOCOL_HDLCPPP_56K),        IDS_G_PROTOCOL_HDLC_PPP_56K},
    {GSM(MDM_PROTOCOL_HDLCPPP_64K),        IDS_G_PROTOCOL_HDLC_PPP_64K},
    {GSM(MDM_PROTOCOL_V120_64K),           IDS_G_PROTOCOL_V120_64K},
    {GSM(MDM_PROTOCOL_V110_1DOT2K),        IDS_G_PROTOCOL_V110_1DOT2K},
    {GSM(MDM_PROTOCOL_V110_2DOT4K),        IDS_G_PROTOCOL_V110_2DOT4K},
    {GSM(MDM_PROTOCOL_V110_4DOT8K),        IDS_G_PROTOCOL_V110_4DOT8K},
    {GSM(MDM_PROTOCOL_V110_9DOT6K),        IDS_G_PROTOCOL_V110_9DOT6K},
    {GSM(MDM_PROTOCOL_V110_12DOT0K),       IDS_G_PROTOCOL_V110_12DOT0K},
    {GSM(MDM_PROTOCOL_V110_14DOT4K),       IDS_G_PROTOCOL_V110_14DOT4K},
    {GSM(MDM_PROTOCOL_V110_19DOT2K),       IDS_G_PROTOCOL_V110_19DOT2K},
    {GSM(MDM_PROTOCOL_V110_28DOT8K),       IDS_G_PROTOCOL_V110_28DOT8K},
    {GSM(MDM_PROTOCOL_V110_38DOT4K),       IDS_G_PROTOCOL_V110_38DOT4K},
    {GSM(MDM_PROTOCOL_V110_57DOT6K),       IDS_G_PROTOCOL_V110_57DOT6K},
    //
    // Following only available for GSM....
    //
    {GSM(MDM_PROTOCOL_ANALOG_RLP),         IDS_G_PROTOCOL_ANALOG_RLP},
    {GSM(MDM_PROTOCOL_ANALOG_NRLP),        IDS_G_PROTOCOL_ANALOG_NRLP},
    {GSM(MDM_PROTOCOL_GPRS),               IDS_G_PROTOCOL_GPRS},

    { 0,   0   }
    };

// This is the structure that is used to fill the parity listbox
static LBMAP s_rgCompression[] = {
    { IDS_COMPRESSION_ENABLED,  IDS_COMPRESSION_ENABLED  },
    { IDS_COMPRESSION_DISABLED,   IDS_COMPRESSION_DISABLED   },
    { 0,   0   }
    };

// This is the structure that is used to fill the stopbits listbox
static LBMAP s_rgFlowControl[] = {
    { IDS_FLOWCTL_XONXOFF,   IDS_FLOWCTL_XONXOFF   },
    { IDS_FLOWCTL_HARDWARE,   IDS_FLOWCTL_HARDWARE   },
    { IDS_FLOWCTL_NONE,   IDS_FLOWCTL_NONE   },
    { 0,   0   }
};


DWORD SelectFlowControlOption(
            DWORD dwValue,
            void *pvContext
            );

DWORD SelectCompressionOption(
            DWORD dwValue,
            void *pvContext
            );

DWORD SelectErrorControlOption(
            DWORD dwValue,
            void *pvContext
            );



DWORD SelectFlowControlOption(
            DWORD dwValue,
            void *pvContext
            )
{
    PCFGGEN this = (PCFGGEN) pvContext;
    DWORD dwRet = 0;
    BOOL fSelected = FALSE;
    BOOL fAvailable = FALSE;
    WIN32DCB FAR * pdcb = &this->pcmi->w.dcb;
    MODEMSETTINGS msT;
    DWORD dwOptions = 0;
    DWORD dwCapOptions =  this->pcmi->c.devcaps.dwModemOptions;
    ConvertFlowCtl(pdcb, &msT, CFC_DCBTOMS | CFC_HW_CAPABLE | CFC_SW_CAPABLE);

    dwOptions = msT.dwPreferredModemOptions;

    switch(dwValue)
    {
        case IDS_FLOWCTL_XONXOFF:
            if (dwCapOptions & MDM_FLOWCONTROL_SOFT)
            {
                fAvailable = TRUE;
                if (dwOptions & MDM_FLOWCONTROL_SOFT)
                {
                    fSelected = TRUE;
                }
            }
        break;

        case IDS_FLOWCTL_HARDWARE:
            if (dwCapOptions & MDM_FLOWCONTROL_HARD)
            {
                fAvailable = TRUE;
                if (dwOptions & MDM_FLOWCONTROL_HARD)
                {
                    fSelected = TRUE;
                }
            }
        break;

        case IDS_FLOWCTL_NONE:
            fAvailable = TRUE;
            if (!(dwOptions & dwCapOptions & (MDM_FLOWCONTROL_HARD | MDM_FLOWCONTROL_SOFT)))
            {
                fSelected = TRUE;
            }
        break;
    }

    if (fAvailable)
    {
        dwRet = fLBMAP_ADD_TO_LB;
        if (fSelected)
        {
            dwRet |= fLBMAP_SELECT;
        }
    }

    return dwRet;
}

DWORD SelectErrorControlOption(
            DWORD dwValue,
            void *pvContext
            )
{
    PCFGGEN this = (PCFGGEN) pvContext;
    DWORD dwCapOptions =  this->pcmi->c.devcaps.dwModemOptions;
    DWORD dwOptions = this->pcmi->w.ms.dwPreferredModemOptions;
    MODEM_PROTOCOL_CAPS  *pProtocolCaps = this->pcmi->c.pProtocolCaps;
    DWORD dwRet = 0;
    BOOL fSelected = FALSE;
    BOOL fAvailable = FALSE;
    DWORD dwBearerMode = MDM_GET_BEARERMODE(dwOptions);

    if (dwBearerMode != MDM_BEARERMODE_ANALOG)
    {
        //
        // Ignore stuff like error control and cellular if the bearermode
        // is not analog.
        //

        if (dwOptions & (  MDM_ERROR_CONTROL
                         | MDM_FORCED_EC
                         | MDM_CELLULAR ))
        {
            ASSERT(FALSE);

            dwOptions &= ~(   MDM_ERROR_CONTROL
                            | MDM_FORCED_EC
                            | MDM_CELLULAR );
        }
    }


    switch(dwValue)
    {

        case IDS_ERRORCONTROL_STANDARD:
            if (dwCapOptions & MDM_ERROR_CONTROL)
            {
                fAvailable = TRUE;

                // We make STANDARD the selected shoice iff MDM_ERROR_CONTROL
                // is selecteed but neither FORCED_EC nor CELLULAR is selected.

                if (    (dwOptions &  MDM_ERROR_CONTROL)
                    && !(dwOptions &  (MDM_FORCED_EC|MDM_CELLULAR)))
                {
                    fSelected = TRUE;
                }

				//
				// However, if bearermode is not analog, we don't select this...
				//
				if (dwBearerMode!=MDM_BEARERMODE_ANALOG)
				{
	                fSelected = FALSE;
					fAvailable = FALSE;
	            }

            }
        break;

        case IDS_ERRORCONTROL_REQUIRED:
            if (   (dwCapOptions & MDM_ERROR_CONTROL)
                && (dwCapOptions & MDM_FORCED_EC))
            {
                fAvailable = TRUE;

                // We make REQUIRED the selected shoice iff MDM_ERROR_CONTROL
                // and FORCED_EC is selecteed but CELLULAR is not.

                if (      (dwOptions &  MDM_ERROR_CONTROL)
                      &&  (dwOptions &  MDM_FORCED_EC)
                      && !(dwOptions &  MDM_CELLULAR) )
                {
                    fSelected = TRUE;
                }

				//
				// However, if bearermode is not analog, we don't select this...
				//
				if (dwBearerMode!=MDM_BEARERMODE_ANALOG)
				{
	                fSelected = FALSE;
					fAvailable = FALSE;
	            }

            }
        break;

        case IDS_ERRORCONTROL_CELLULAR:
            if (   (dwCapOptions & MDM_ERROR_CONTROL)
                && (dwCapOptions & MDM_CELLULAR))
            {
                fAvailable = TRUE;

                // We make CELLULAR the selected shoice iff MDM_ERROR_CONTROL
                // and CELLULAR is selecteed.
                // TODO: Note that we do not allow both CELLULAR and FORCED
                // as a user-selectable option.
                // This is deemed to be not an interesting case.
                //
                if (      (dwOptions &  MDM_ERROR_CONTROL)
                      &&  (dwOptions &  MDM_CELLULAR) )
                {
                    fSelected = TRUE;
                }
				
				//
				// However, if bearermode is not analog, we don't select this...
				//
				if (dwBearerMode!=MDM_BEARERMODE_ANALOG)
				{
	                fSelected = FALSE;
					fAvailable = FALSE;
	            }

            }
        break;


        case IDS_ERRORCONTROL_DISABLED:
            fAvailable = TRUE;

            // We make DISABLED the selected choice if either
            // MDM_ERROR_CONTROL is not supported, or
            // none of the error control options are selected..
            //
            if (   !(dwCapOptions & MDM_ERROR_CONTROL)
                || !(   dwOptions
                      & (MDM_ERROR_CONTROL|MDM_FORCED_EC|MDM_CELLULAR)))
            {
                fSelected = TRUE;
            }

            //
            // However, if bearermode is not analog, we don't select this...
            //
            if (dwBearerMode!=MDM_BEARERMODE_ANALOG)
            {
                fSelected = FALSE;
				fAvailable = FALSE;
            }
        break;

        default:

            //
            // Check if this value is an available protocol.
            // NOTE: "Protocol" here refers to "Extended Info", which
            // includes both protocol and bearermode information.
            //
            fAvailable = IsValidProtocol(pProtocolCaps, dwValue);

            if (fAvailable && dwBearerMode!=MDM_BEARERMODE_ANALOG)
            {
                DWORD dwSelProtocol = MDM_GET_EXTENDEDINFO(dwOptions);
                if (dwSelProtocol == dwValue)
                {
                    fSelected = TRUE;
                }
            }
        break;

    }

    if (fAvailable)
    {
        dwRet = fLBMAP_ADD_TO_LB;
        if (fSelected)
        {
            dwRet |= fLBMAP_SELECT;
        }
    }

    return dwRet;
}

DWORD SelectCompressionOption(
            DWORD dwValue,
            void *pvContext
            )
{
    PCFGGEN this = (PCFGGEN) pvContext;
    DWORD dwCapOptions =  this->pcmi->c.devcaps.dwModemOptions;
    DWORD dwOptions = this->pcmi->w.ms.dwPreferredModemOptions;
    DWORD dwRet = 0;
    BOOL fSelected = FALSE;
    BOOL fAvailable = FALSE;

    switch(dwValue)
    {
        case IDS_COMPRESSION_ENABLED:
            if (dwCapOptions & MDM_COMPRESSION)
            {
                fAvailable = TRUE;

                // We make ENABLED the selected shoice iff MDM_ERROR_CONTROL
                // and MDM_COMPRESSION are selected...

                if (    (dwOptions &  MDM_ERROR_CONTROL)
                    &&  (dwOptions &  MDM_COMPRESSION))
                {
                    fSelected = TRUE;
                }
            }
        break;

        case IDS_COMPRESSION_DISABLED:
            fAvailable = TRUE;

            // We make DISABLED the selected shoice iff MDM_ERROR_CONTROL
            // or MDM_COMPRESSION are not selected...

            if (   !(dwCapOptions & MDM_COMPRESSION)
                || !(dwOptions &  MDM_ERROR_CONTROL)
                || !(dwOptions &  MDM_COMPRESSION))
            {
                fSelected = TRUE;
            }
        break;
    }

    if (fAvailable)
    {
        dwRet = fLBMAP_ADD_TO_LB;
        if (fSelected)
        {
            dwRet |= fLBMAP_SELECT;
        }
    }

    return dwRet;
}

void CfgGen_FillErrorControl(PCFGGEN this)
{
    if ( (0 == (this->pcmi->c.devcaps.dwModemOptions &
               MDM_ERROR_CONTROL))
		&& (!this->pcmi->c.pProtocolCaps))
    {
            //
            // This modem doesn't support analog error control and
            // it does not have extended protocols (ISDN, GSM,...)
            // so we will disable the error control box.
            //
            ComboBox_Enable (this->hwndErrCtl, FALSE);
    }
    else
    {
        LBMapFill (this->hwndErrCtl,
                   s_rgErrorControl,
                   SelectErrorControlOption,
                   this);
    }
}


void CfgGen_FillCompression(PCFGGEN this)
{
    if (0 == (this->pcmi->c.devcaps.dwModemOptions &
              MDM_COMPRESSION))
    {
        ComboBox_Enable (this->hwndCompress, FALSE);
    }
    else
    {
        LBMapFill (this->hwndCompress,
                   s_rgCompression,
                   SelectCompressionOption,
                   this);
    }
}

void CfgGen_FillFlowControl(PCFGGEN this)
{
    if (0 == (this->pcmi->c.devcaps.dwModemOptions &
              (MDM_FLOWCONTROL_HARD | MDM_FLOWCONTROL_SOFT)))
    {
        ComboBox_Enable (this->hwndFlowCtrl, FALSE);
    }
    else
    {
        LBMapFill (this->hwndFlowCtrl,
                   s_rgFlowControl,
                   SelectFlowControlOption,
                   this);
    }
}


/*----------------------------------------------------------
Purpose: PSN_APPLY handler
Returns: --
Cond:    --
*/
void PRIVATE CfgGen_OnApply(
    PCFGGEN this)
{
    LPMODEMSETTINGS pms = &this->pcmi->w.ms;
    LPDWORD pdwPreferredOptions = &pms->dwPreferredModemOptions;
    WIN32DCB FAR * pdcb = &this->pcmi->w.dcb;
    TCHAR szBuf[LINE_LEN];
    BOOL bCheck;
    MODEMSETTINGS msT;
    int iSel = ComboBox_GetCurSel(this->hwndPort);
    DWORD baudSel = (DWORD)ComboBox_GetItemData(this->hwndPort, iSel);

    if (!VALIDATE_CMI(this->pcmi))
    {
        ASSERT(FALSE);
        goto end;
    }

    if (FALSE == g_dwIsCalledByCpl)
    {
        // ------------- MANUAL DIAL ------------------------
        if (Button_GetCheck(this->hwndManualDialCH))
        {
            this->pcmi->w.fdwSettings |= UMMANUAL_DIAL;
        }
        else
        {
            this->pcmi->w.fdwSettings &= ~UMMANUAL_DIAL;
        }
    }


    // ----------- PORT SPEED ---------------------
    // Has the user changed the speed?
    if (iSel != this->iSelOriginal)
    {
        this->pcmi->w.dcb.BaudRate = baudSel;      // yes
    }

    // -------------------- TIMEOUTS- ----------------------------
    // Set the dial timeout
    pms->dwCallSetupFailTimer = MAKELONG(Edit_GetValue(this->hwndDialTimerED), 0);

    // Set the idle timeout
    bCheck = Button_GetCheck(this->hwndIdleTimerCH);
    if (bCheck)
    {
        int nVal = Edit_GetValue(this->hwndIdleTimerED);
        pms->dwInactivityTimeout = MAKELONG(nVal*SECONDS_PER_MINUTE, 0);
    }
    else
    {
        pms->dwInactivityTimeout = 0;
    }

    // ------------ FLOW CONTROL ------------------
    {
        UINT uFlags=0;
        UINT uFCSel = (UINT)ComboBox_GetItemData(
                        this->hwndFlowCtrl,
                        ComboBox_GetCurSel(this->hwndFlowCtrl)
                        );

        msT.dwPreferredModemOptions = 0;
        switch(uFCSel)
        {
        case IDS_FLOWCTL_XONXOFF:
            SetFlag(msT.dwPreferredModemOptions, MDM_FLOWCONTROL_SOFT);
        break;

        case IDS_FLOWCTL_HARDWARE:
            SetFlag(msT.dwPreferredModemOptions, MDM_FLOWCONTROL_HARD);
        break;

        default:
        break;
        }

        // Always set the DCB according to the control settings.
        ConvertFlowCtl(pdcb, &msT, CFC_MSTODCB);

        // Set the modemsettings according to the DCB.
        if (IsFlagSet(this->pcmi->c.devcaps.dwModemOptions, MDM_FLOWCONTROL_HARD))
            {
            SetFlag(uFlags, CFC_HW_CAPABLE);
            }
        if (IsFlagSet(this->pcmi->c.devcaps.dwModemOptions, MDM_FLOWCONTROL_SOFT))
            {
            SetFlag(uFlags, CFC_SW_CAPABLE);
            }
        ConvertFlowCtl(pdcb, &this->pcmi->w.ms, CFC_DCBTOMS | uFlags);
    }

    // ------------ ERROR CONTROL ------------------
    if (
        (this->pcmi->c.devcaps.dwModemOptions & MDM_ERROR_CONTROL) ||
        (this->pcmi->c.pProtocolCaps)
       )
    {
        DWORD dwEC = 0;
        DWORD dwExtendedInformation=0;
        UINT uECSel = (UINT)ComboBox_GetItemData(
                        this->hwndErrCtl,
                        ComboBox_GetCurSel(this->hwndErrCtl)
                        );
        switch(uECSel)
        {
        case IDS_ERRORCONTROL_STANDARD:
            dwEC =  MDM_ERROR_CONTROL;
            break;

        default:

            // probably a non-analog protocol -- check...
            if (IsValidProtocol(this->pcmi->c.pProtocolCaps, uECSel))
            {
                //
                // It is, in which case uECSel contains the extended information
                // (bearermode and protocol info).
                //
                // Note that in in this case dwEC==0.
                //

                dwExtendedInformation = uECSel;
            }
            else
            {
                ASSERT(FALSE);
            }
            break;

        case IDS_ERRORCONTROL_DISABLED:
            break;

        case IDS_ERRORCONTROL_REQUIRED:
            dwEC = MDM_ERROR_CONTROL | MDM_FORCED_EC;
            break;

        case IDS_ERRORCONTROL_CELLULAR:
            dwEC = MDM_ERROR_CONTROL | MDM_CELLULAR;
            break;
        }

        //
        // Clear and set the error-control-related bits of dwPreferredOptions.
        // Note that in the case of non-analog protocols dwEC is 0 so these
        // bits are all set to 0.
        //
        *pdwPreferredOptions &=
                 ~(MDM_ERROR_CONTROL|MDM_CELLULAR|MDM_FORCED_EC);

        *pdwPreferredOptions |= dwEC;

        //
        // Note that dwExtendedInformation is either zero or
        // contains valid non-analog bearermode and protocol information.
        //
        MDM_SET_EXTENDEDINFO(*pdwPreferredOptions, dwExtendedInformation);
    }

    // ------------ COMPRESSION ------------------
    {
        UINT uCSel;

        if (0 == (this->pcmi->c.devcaps.dwModemOptions & MDM_COMPRESSION))
        {
            uCSel = (UINT)-1;
        }
        else
        {
            uCSel = (UINT)ComboBox_GetItemData(
                        this->hwndCompress,
                        ComboBox_GetCurSel(this->hwndCompress)
                        );
        }

        switch(uCSel)
        {
        case IDS_COMPRESSION_ENABLED:
            SetFlag(*pdwPreferredOptions, MDM_COMPRESSION);
            break;

        default:
            ASSERT(uCSel==(UINT)-1);
            // fallthrough ...

        case IDS_COMPRESSION_DISABLED:
            ClearFlag(*pdwPreferredOptions, MDM_COMPRESSION);
            break;
        }
    }

end:

    this->pcmi->fOK = TRUE;


}

void
PRIVATE
CfgGen_OnCommand(
    PCFGGEN this,
    IN int  id,
    IN HWND hwndCtl,
    IN UINT uNotifyCode
    )
{

    if (!VALIDATE_CMI(this->pcmi))
    {
        ASSERT(FALSE);
        goto end;
    }

    switch(id)
    {
        case IDC_CH_IDLETIMER:
        {
            if (BN_CLICKED == uNotifyCode)
            {
                EnableWindow (this->hwndIdleTimerED,
                              BST_CHECKED==(0x3 & Button_GetState(this->hwndIdleTimerCH))?TRUE:FALSE);
            }
            break;
        }

        case IDC_CB_SPEED:
            break;

        case IDC_CB_COMP:

            if (uNotifyCode == CBN_SELENDOK)
            {
                DWORD dwEC = 0;
                UINT uECSel = (UINT)ComboBox_GetItemData(
                                this->hwndErrCtl,
                                ComboBox_GetCurSel(this->hwndErrCtl)
                                );
                UINT uCompSel = (UINT)ComboBox_GetItemData(
                                this->hwndCompress,
                                ComboBox_GetCurSel(this->hwndCompress)
                                );
                if (   IDS_ERRORCONTROL_DISABLED == uECSel
                    && IDS_COMPRESSION_ENABLED == uCompSel)
                {
                    // This won't do -- error control to something reasonable...
                    // TODO: save away past selection of error control and
                    // restore it here..
                    ComboBox_SetCurSel(
                        this->hwndErrCtl,
                        0 // FOR IDS_ERRORCONTROL_STANDARD
                        );
                }
            }
            break;

        case IDC_CB_FC:
            break;

        default:
            break;

    }

end:
    return;
}


/*----------------------------------------------------------
Purpose: Sets the flow control related fields of one structure
         given the other structure.  The conversion direction
         is dictated by the uFlags parameter.

Returns: --
Cond:    --
*/
void PUBLIC ConvertFlowCtl(
    WIN32DCB FAR * pdcb,
    MODEMSETTINGS FAR * pms,
    UINT uFlags)            // One of CFC_ flags
    {
    LPDWORD pdw = &pms->dwPreferredModemOptions;

    if (IsFlagSet(uFlags, CFC_DCBTOMS))
        {
        // Convert from DCB values to MODEMSETTINGS values

        // Is this hardware flow control?
        if (FALSE == pdcb->fOutX &&
            FALSE == pdcb->fInX &&
            TRUE == pdcb->fOutxCtsFlow)
            {
            // Yes
            ClearFlag(*pdw, MDM_FLOWCONTROL_SOFT);

            if (IsFlagSet(uFlags, CFC_HW_CAPABLE))
                SetFlag(*pdw, MDM_FLOWCONTROL_HARD);
            else
                ClearFlag(*pdw, MDM_FLOWCONTROL_HARD);
            }

        // Is this software flow control?
        else if (TRUE == pdcb->fOutX &&
            TRUE == pdcb->fInX &&
            FALSE == pdcb->fOutxCtsFlow)
            {
            // Yes
            ClearFlag(*pdw, MDM_FLOWCONTROL_HARD);

            if (IsFlagSet(uFlags, CFC_SW_CAPABLE))
                SetFlag(*pdw, MDM_FLOWCONTROL_SOFT);
            else
                ClearFlag(*pdw, MDM_FLOWCONTROL_SOFT);
            }

        // Is the flow control disabled?
        else if (FALSE == pdcb->fOutX &&
            FALSE == pdcb->fInX &&
            FALSE == pdcb->fOutxCtsFlow)
            {
            // Yes
            ClearFlag(*pdw, MDM_FLOWCONTROL_HARD);
            ClearFlag(*pdw, MDM_FLOWCONTROL_SOFT);
            }
        else
            {
            ASSERT(0);      // Should never get here
            }
        }
    else if (IsFlagSet(uFlags, CFC_MSTODCB))
        {
        DWORD dw = *pdw;

        // Convert from MODEMSETTINGS values to DCB values

        // Is this hardware flow control?
        if (IsFlagSet(dw, MDM_FLOWCONTROL_HARD) &&
            IsFlagClear(dw, MDM_FLOWCONTROL_SOFT))
            {
            // Yes
            pdcb->fOutX = FALSE;
            pdcb->fInX = FALSE;
            pdcb->fOutxCtsFlow = TRUE;
            pdcb->fRtsControl = RTS_CONTROL_HANDSHAKE;
            }

        // Is this software flow control?
        else if (IsFlagClear(dw, MDM_FLOWCONTROL_HARD) &&
            IsFlagSet(dw, MDM_FLOWCONTROL_SOFT))
            {
            // Yes
            pdcb->fOutX = TRUE;
            pdcb->fInX = TRUE;
            pdcb->fOutxCtsFlow = FALSE;
            pdcb->fRtsControl = RTS_CONTROL_DISABLE;
            }

        // Is the flow control disabled?
        else if (IsFlagClear(dw, MDM_FLOWCONTROL_HARD) &&
            IsFlagClear(dw, MDM_FLOWCONTROL_SOFT))
            {
            // Yes
            pdcb->fOutX = FALSE;
            pdcb->fInX = FALSE;
            pdcb->fOutxCtsFlow = FALSE;
            pdcb->fRtsControl = RTS_CONTROL_DISABLE;
            }
        else
            {
            ASSERT(0);      // Should never get here
            }
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\modemui\cpladv.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: cpladv.c
//
// This files contains the dialog code for the Advanced Page
// of the modem CPL properties.
//
// History:
//  10/26/1997 JosephJ Created from the old advsett.c
//
//---------------------------------------------------------------------------


/////////////////////////////////////////////////////  INCLUDES

#include "proj.h"         // common headers
#include "cplui.h"         // common headers

/////////////////////////////////////////////////////  CONTROLLING DEFINES

/////////////////////////////////////////////////////  TYPEDEFS

#define SIG_CPLADV     0x398adb91

#define REGSTR_ADVANCED_SETTINGS  TEXT("AdvancedSettings")
#define REGSTR_COUNTRIES          TEXT("Countries")
#define REGSTR_COUNTRY_LIST       REGSTR_PATH_SETUP TEXT("\\Telephony\\Country List")
#define REGSTR_COUNTRY_NAME       TEXT("Name")

extern CONST CHAR *UnicodeBOM;

typedef void (*PADVANCEDSETTINGS)(HWND, HDEVINFO, PSP_DEVINFO_DATA);

typedef struct
{
    DWORD dwSig;            // Must be set to SIG_CPLADV
    HWND hdlg;              // dialog handle
    HWND hwndUserInitED;
    HWND hwndCountry;

    HINSTANCE hAdvSetDll;
    PADVANCEDSETTINGS pFnAdvSet;

    LPMODEMINFO pmi;        // modeminfo struct passed into dialog

} CPLADV, FAR * PCPLADV;

#define VALID_CPLADV(_pcplgen)  ((_pcplgen)->dwSig == SIG_CPLADV)

PCPLADV CplAdv_GetPtr(HWND hwnd)
{
    PCPLADV pCplAdv = (PCPLADV) GetWindowLongPtr(hwnd, DWLP_USER);
    if (!pCplAdv || VALID_CPLADV(pCplAdv))
    {
        return pCplAdv;
    }
    else
    {
        MYASSERT(FALSE);
        return NULL;
    }
}

void CplAdv_SetPtr(HWND hwnd, PCPLADV pCplAdv)
{
    if (pCplAdv && !VALID_CPLADV(pCplAdv))
    {
        MYASSERT(FALSE);
        pCplAdv = NULL;
    }

    SetWindowLongPtr(hwnd, DWLP_USER, (ULONG_PTR) pCplAdv);
}

void InitializeCountry (PCPLADV this);

BOOL ParseAdvancedSettings (LPTSTR, PCPLADV);

LRESULT PRIVATE CplAdv_OnNotify(
    PCPLADV this,
    int idFrom,
    NMHDR FAR * lpnmhdr);

void PRIVATE CplAdv_OnSetActive(
    PCPLADV this);

void PRIVATE CplAdv_OnKillActive(
    PCPLADV this);

INT_PTR CALLBACK CountryWaitDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

int PASCAL ReadModemResponse(HANDLE hPort, LPCSTR pszCommand, int cbLen, LPSTR pszResponse, HWND hDlg);
BOOL WINAPI TestBaudRate (HANDLE hPort, UINT uiBaudRate, DWORD dwRcvDelay, BOOL *lpfCancel);

//------------------------------------------------------------------------------
//  User Init String dialog code
//------------------------------------------------------------------------------

INT_PTR CALLBACK UserInitCallbackProc(
        HWND hDlg,
        UINT message,
        WPARAM wParam,
        LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:
            break;

        case WM_DESTROY:
            break;

        case WM_COMMAND:
            switch(GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                    if (Button_GetCheck(GetDlgItem(hDlg,IDC_INITCHECK)))
                    {
                        TRACE_MSG(TF_WARNING, "Button Checked");
                        EndDialog(hDlg,1);
                    } else
                    {
                        TRACE_MSG(TF_WARNING, "Button UnChecked");
                        EndDialog(hDlg,0);
                    }
                    return TRUE;
                    break;

                case IDCANCEL:
                    EndDialog(hDlg,0);
                    return TRUE;
                    break;

                default:
                    return TRUE;
            }
            break;

        default:
            // Didn't process a message
            return FALSE;
            break;
    }    

    return TRUE;


}

//------------------------------------------------------------------------------
//  Advanced Settings dialog code
//------------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: WM_INITDIALOG Handler
Returns: FALSE when we assign the control focus
Cond:    --
*/
BOOL PRIVATE CplAdv_OnInitDialog(
    PCPLADV this,
    HWND hwndFocus,
    LPARAM lParam)              // expected to be PROPSHEETINFO
{
 HWND hwnd = this->hdlg;
 LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
 HWND hWnd;
 TCHAR szAdvSettings[MAX_PATH];
 DWORD cbData;

    ASSERT((LPTSTR)lppsp->lParam);
    this->pmi = (LPMODEMINFO)lppsp->lParam;

    this->hwndUserInitED = GetDlgItem(hwnd, IDC_AM_EXTRA_ED);
    this->hwndCountry    = GetDlgItem (hwnd, IDC_CB_COUNTRY);

    InitializeCountry (this);

    Edit_LimitText(this->hwndUserInitED, USERINITLEN);
    Edit_SetText(this->hwndUserInitED, this->pmi->szUserInit);

    hWnd = GetDlgItem (hwnd, IDC_BN_PORTSETTINGS);
    cbData = sizeof(szAdvSettings);
    if (ERROR_SUCCESS ==
        RegQueryValueEx (this->pmi->pfd->hkeyDrv,
                         REGSTR_ADVANCED_SETTINGS,
                         NULL, NULL,
                         (PBYTE)szAdvSettings, &cbData) &&
        ParseAdvancedSettings (szAdvSettings, this))
    {
        EnableWindow (hWnd, TRUE);
        ShowWindow (hWnd, SW_SHOWNA);
    }
    else
    {
        this->pFnAdvSet = NULL;
        this->hAdvSetDll = NULL;
        EnableWindow (hWnd, FALSE);
        ShowWindow (hWnd, SW_HIDE);
    }

    return TRUE;   // let USER set the initial focus
}


/*----------------------------------------------------------
Purpose: PSN_APPLY handler
Returns: --
Cond:    --
*/

#define KEYBUFLEN 80
#define MODEM_QUERY_LEN 4096

HANDLE g_hWndWait;

void PRIVATE CplAdv_ApplyCountry(
    PCPLADV this)
{
    DWORD dwCurrentCountry;
    DWORD dwOldCountry;

    // Update the country setting in NVRAM.
    
    if (MAXDWORD != this->pmi->dwCurrentCountry)
    {
        DWORD dwBus = 0;
        TCHAR szPrefixedPort[MAX_BUF + sizeof(TEXT("\\\\.\\"))];
        HANDLE TapiHandle = NULL;
        HANDLE hPort;
        TCHAR pszTemp[KEYBUFLEN];
        TCHAR pszTemp2[(KEYBUFLEN * 3)];
        TCHAR pszTemp3[KEYBUFLEN];
        char szCommand[KEYBUFLEN];
        char szResponse[MODEM_QUERY_LEN];
        LPSTR pszResponse;
        TCHAR szLoggingPath[MAX_BUF];
        HANDLE hLog = INVALID_HANDLE_VALUE;
        DWORD dwBufferLength;
        HWND hWndWait;
        BOOL fCancel;
        BYTE CountryBuffer[2048];
        DWORD CountryBufferSize = 0;
        LONG lResult;
        DWORD Type;
        DWORD i;
        DWORD n;
        int result;
        DWORD dwRespCount = 0;

        // Get country from dialog box.

        dwCurrentCountry = (DWORD)ComboBox_GetItemData(this->hwndCountry, ComboBox_GetCurSel (this->hwndCountry));

        // Get old country just incase GCI fails.

        dwOldCountry = this->pmi->dwCurrentCountry;

        // There is no point updating the modem if the country has not changed.

        if (dwCurrentCountry != dwOldCountry)
        {

            // Get Bus Type.

            if (!CplDiGetBusType (this->pmi->pfd->hdi, &this->pmi->pfd->devData, &dwBus))
            {
                dwBus = BUS_TYPE_ROOT;
            }

            // Determine the portname and whether or not we communicate via TAPI.

            lstrcpy(szPrefixedPort, TEXT("\\\\.\\"));

            if (BUS_TYPE_ROOT == dwBus)
            {
                lstrcat(szPrefixedPort, this->pmi->szPortName);
            }
            else
            {
                lstrcat(szPrefixedPort, this->pmi->szFriendlyName);
                lstrcat(szPrefixedPort, TEXT("\\tsp"));
            }

            // Open port

            hPort = CreateFile(
                    szPrefixedPort,
                    GENERIC_WRITE | GENERIC_READ,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_OVERLAPPED,
                    NULL
                              );

            // If the port handle is invalid then try to open it through
            // TAPI. If TAPI fails then abort.

            if (hPort == INVALID_HANDLE_VALUE)
            {
                if ((GetLastError() == ERROR_ALREADY_EXISTS)
                        || (GetLastError() == ERROR_SHARING_VIOLATION)
                        || (GetLastError() == ERROR_ACCESS_DENIED))
                {
                    hPort=GetModemCommHandle(this->pmi->szFriendlyName,&TapiHandle);

                    if (hPort == NULL)
                    {

                        // Print error message

                        LoadString(g_hinst,IDS_OPEN_PORT,pszTemp2,sizeof(pszTemp2) / sizeof(TCHAR));
                        LoadString(g_hinst,IDS_ERROR,pszTemp3,sizeof(pszTemp3) / sizeof(TCHAR));
                        MessageBox(this->hdlg,pszTemp2,pszTemp3,MB_OK);

                        // Revert changes

                        dwCurrentCountry = dwOldCountry;

                        goto _Done;
                    }

                }
                else
                {

                    // Print error message

                    LoadString(g_hinst,IDS_NO_OPEN_PORT,pszTemp2,sizeof(pszTemp2) / sizeof(TCHAR));
                    LoadString(g_hinst,IDS_ERROR,pszTemp3,sizeof(pszTemp3) / sizeof(TCHAR));
                    MessageBox(this->hdlg,pszTemp2,pszTemp3,MB_OK);

                    // Revert changes

                    dwCurrentCountry = dwOldCountry;

                    goto _Done;
                }
            }

            // Opened the port

            // Display a please wait dialog box.

            g_hWndWait = CreateDialog(g_hinst, MAKEINTRESOURCE(IDD_COUNTRY_WAIT),this->hdlg,CountryWaitDlgProc);

            // Set DTR

            EscapeCommFunction(hPort,SETDTR);

                if (!TestBaudRate(hPort, this->pmi->pglobal->dwMaximumPortSpeedSetByUser, 2000, &fCancel))
                {
                    // Modem didn't respond, display and Bail
                    // Reset the modem and flush the ports after reading

                    // Flush the ports before closing.
                    PurgeComm(hPort, PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR| PURGE_RXCLEAR);
                    CloseHandle(hPort);

                    if (TapiHandle != NULL) 
                    {
                        FreeModemCommHandle(TapiHandle);
                    }

                    // Close dialog box

                    hWndWait = g_hWndWait;
                    g_hWndWait = NULL;
                    DestroyWindow (hWndWait);

                    // display message that modem didn't respond
                    LoadString(g_hinst,IDS_NO_MODEM_RESPONSE,pszTemp2,sizeof(pszTemp2) / sizeof(TCHAR));
                    MessageBox(this->hdlg,pszTemp2,NULL,MB_OK | MB_ICONEXCLAMATION);

                    // Revert changes

                    dwCurrentCountry = dwOldCountry;


                    goto _Done;
                }

            // Open the log file

            dwBufferLength = sizeof(szLoggingPath) / sizeof(TCHAR);

            if (ERROR_SUCCESS == RegQueryValueEx(this->pmi->pfd->hkeyDrv, //hKeyDrv, 
                        c_szLoggingPath,
                        NULL,
                        NULL,
                        (LPBYTE)szLoggingPath,
                        &dwBufferLength))
            {
                if (INVALID_HANDLE_VALUE != 
                        (hLog = CreateFile(szLoggingPath, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL)))
                {
                    DWORD dwBytesWritten = 0;

                    SetFilePointer(hLog, 0, NULL, FILE_BEGIN);
                    WriteFile(hLog,UnicodeBOM,sizeof(UnicodeBOM),&dwBytesWritten,NULL);

                    SetFilePointer(hLog, 0, NULL, FILE_END);
                    EnableWindow(GetDlgItem(this->hdlg, IDC_VIEWLOG), TRUE);
                }
                else
                {
                    TRACE_MSG(TF_WARNING, "Cannot open unimodem log '%s'", szLoggingPath);
                }
            }
            else
            {
                TRACE_MSG(TF_WARNING, "Cannot read LoggingPath from registry");
            }

            FillMemory(szResponse,MODEM_QUERY_LEN,0);

            // Create country command
          
            // Workaround so as to deal with Multiple country codes for
            // the former russia and yugoslavia.

            if ((dwCurrentCountry >= IDS_COUNTRY_RU2) &&
                    (dwCurrentCountry <= IDS_COUNTRY_RUE))
            {
                wsprintfA(szCommand,"at+gci=B8\r");
            } else if  ((dwCurrentCountry >= IDS_COUNTRY_YU2) &&
                    (dwCurrentCountry <= IDS_COUNTRY_YU6))
            {
                wsprintfA(szCommand,"at+gci=C5\r");
            } else
            {
                wsprintfA(szCommand,"at+gci=%.2x\r",dwCurrentCountry & 0xff);
            }
            
            TRACE_MSG(TF_GENERAL,"Modem command: %s",szCommand);

            // Send to modem and wait for response

            result = ReadModemResponse(hPort,szCommand,sizeof(szCommand),szResponse,this->hdlg);

            TRACE_MSG(TF_GENERAL,"Modem response: %s",szResponse);

            // Close dialog box

            hWndWait = g_hWndWait;
            g_hWndWait = NULL;
            DestroyWindow (hWndWait);
          
            // advance past leading CR & LF's.  This is because some
            // modems return <cr><lf><response string>

            dwRespCount = 0;
            pszResponse = szResponse;

            while((*pszResponse != '\0') && (dwRespCount != MODEM_QUERY_LEN))
            {
                if ((*pszResponse != '\r') && (*pszResponse != '\n'))
                {
                    break;
                }
                pszResponse++;
                dwRespCount++;
            }

            if (dwRespCount >= 2)
            {
                result = _strnicmp(pszResponse,"OK",2);
            } else
            {
                result = 1; // Lets induce an error here.
            }


            // If OK was received then tell user that the modem was
            // updated. Otherwise, print error message and revert change.
           
            if (result == 0)
            {

                LoadString(g_hinst,IDS_OK_COUNTRY,pszTemp2,sizeof(pszTemp2) / sizeof(TCHAR));
                LoadString(g_hinst,IDS_OK,pszTemp3,sizeof(pszTemp3) / sizeof(TCHAR));
                MessageBox(this->hdlg,pszTemp2,pszTemp3,MB_OK);


            } else
            {
                LoadString(g_hinst,IDS_ERR_COUNTRY,pszTemp2,sizeof(pszTemp2) / sizeof(TCHAR));
                LoadString(g_hinst,IDS_ERROR,pszTemp3,sizeof(pszTemp3) / sizeof(TCHAR));
                MessageBox(this->hdlg,pszTemp2,pszTemp3,MB_OK);

                // Revert changes

                dwCurrentCountry = dwOldCountry;

            }

_Done: 

            // Close the log file
            if (INVALID_HANDLE_VALUE != hLog)
            {
                CloseHandle(hLog);
            }

            PurgeComm(hPort, PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR| PURGE_RXCLEAR);
            CloseHandle(hPort);

            if (TapiHandle != NULL) 
            {
                FreeModemCommHandle(TapiHandle);
            }

            this->pmi->dwCurrentCountry = dwCurrentCountry;

            // Update combo box with current modem settings.
            //


            ZeroMemory(CountryBuffer, sizeof(CountryBuffer));

            lResult = RegQueryValueEx(this->pmi->pfd->hkeyDrv,
                    TEXT("CountryList"),
                    NULL,
                    &Type,
                    CountryBuffer,
                    &CountryBufferSize);

            for (i=0;i<CountryBufferSize;i++)
            {
                if (CountryBuffer[i] == dwCurrentCountry)
                {
                    ComboBox_SetCurSel(this->hwndCountry,i);
                }
            }

        }
    }
}

void PRIVATE CplAdv_OnApply(
    PCPLADV this)
{
    TCHAR szBuf[LINE_LEN];
    BOOL bCheck;
    TCHAR pszTemp[KEYBUFLEN*3];
    TCHAR pszTemp2[KEYBUFLEN*3];
    LONG lResult = 0;
    int iret = 0;

    // Get the user-defined init string
    Edit_GetText(this->hwndUserInitED, szBuf, ARRAYSIZE(szBuf));
    if (!IsSzEqual(szBuf, this->pmi->szUserInit))
    {
        DWORD dwNoMsg;
        DWORD dwNoMsgLen;
        DWORD dwRet;
        DWORD dwType;

        SetFlag(this->pmi->uFlags, MIF_USERINIT_CHANGED);
        lstrcpyn(
                this->pmi->szUserInit,
                szBuf,
                ARRAYSIZE(this->pmi->szUserInit));

        dwNoMsgLen = sizeof(DWORD);
        lResult = RegQueryValueEx(this->pmi->pfd->hkeyDrv,
                TEXT("DisableUserInitWarning"),
                NULL,
                &dwType,
                (LPBYTE)&dwNoMsg,
                &dwNoMsgLen);

        if (lResult != ERROR_SUCCESS)
        {
            dwNoMsg = 0;
        }

        if (lResult != REG_DWORD)
        {
            dwNoMsg = 0;
        }

        if ((lstrlen(szBuf) > MAX_INIT_STRING_LENGTH)
                && (!dwNoMsg))
        {
            // LoadString(g_hinst,IDS_ERR_LONGSTRING,pszTemp,sizeof(pszTemp));
            // LoadString(g_hinst,IDS_ERR_WARNING,pszTemp2,sizeof(pszTemp2));
            // MessageBox(this->hdlg,pszTemp,pszTemp2,MB_OK | MB_ICONWARNING);

            LRESULT lRet;
            DWORD dwUserinit;

            if(DialogBox(g_hinst, MAKEINTRESOURCE(IDD_USERINIT),
                    GetParent(this->hdlg), UserInitCallbackProc))
            {
                dwUserinit = 1;

                TRACE_MSG(TF_GENERAL,"Returned OK");
                TRACE_MSG(TF_GENERAL,"Update Registry");
                dwRet = RegSetValueEx(this->pmi->pfd->hkeyDrv,
                        TEXT("DisableUserInitWarning"),
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwUserinit,
                        sizeof(DWORD));

            }
        } else
        {
            SetFlag(this->pmi->uFlags, MIF_USERINIT_CHANGED);
            lstrcpyn(
                    this->pmi->szUserInit,
                    szBuf,
                    ARRAYSIZE(this->pmi->szUserInit)
                    );
        }
    }

    this->pmi->idRet = IDOK;
}

/*----------------------------------------------------------
Purpose: Dialog Call back function
Returns: --
Cond:    --
*/
INT_PTR CALLBACK CountryWaitDlgProc (
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam)
{
    switch (message)
    {
        case WM_DESTROY:
            g_hWndWait = NULL;
            break;
    
        case WM_COMMAND:
            break;

        default:
		    return FALSE;
            break;
    }    

    return TRUE;
}

/*----------------------------------------------------------
Purpose: WM_COMMAND Handler
Returns: --
Cond:    --
*/
void PRIVATE CplAdv_OnCommand(
    PCPLADV this,
    int id,
    HWND hwndCtl,
    UINT uNotifyCode)
{
    switch (id)
    {
        case IDC_BN_PORTSETTINGS:
        {
            if (NULL != this->hAdvSetDll &&
                NULL != this->pFnAdvSet)
            {
             HKEY hKeyParams;

                try
                {
                    this->pFnAdvSet (this->hdlg,
                                     this->pmi->pfd->hdi,
                                     &this->pmi->pfd->devData);
                }
                except (EXCEPTION_EXECUTE_HANDLER)
                {
                    TRACE_MSG(TF_ERROR, "Exception while calling the advanced settings function.");
                }

                // The port name may have changed, so update it.
                if (CR_SUCCESS ==
                    CM_Open_DevNode_Key (this->pmi->pfd->devData.DevInst,
                                         KEY_READ, 0, RegDisposition_OpenExisting,
                                         &hKeyParams, CM_REGISTRY_HARDWARE))
                {
                 TCHAR szPortName[MAX_PATH];
                 DWORD cbCount = sizeof (szPortName);
                 DWORD dwType;

                    if (ERROR_SUCCESS ==
                        RegQueryValueEx (hKeyParams, REGSTR_VAL_PORTNAME,
                                         NULL, &dwType, (LPBYTE)szPortName, &cbCount) &&
                        (dwType == REG_SZ) && 
                        0 != lstrcmpi (this->pmi->szPortName, szPortName))
                    {
                        // Port name has changed.
                        lstrcpy (this->pmi->szPortName, szPortName);
                        lstrcpy (this->pmi->pglobal->szPortName, szPortName);
                        RegSetValueEx (this->pmi->pfd->hkeyDrv,
                                       TEXT("AttachedTo"), 0, REG_SZ,
                                       (LPBYTE)szPortName,
                                       (lstrlen(szPortName)+1)*sizeof(TCHAR));

                        // Also, msports.dll changes the friendly name of the
                        // device, so change it back.
                        SetupDiSetDeviceRegistryProperty (this->pmi->pfd->hdi,
                                                          &this->pmi->pfd->devData,
                                                          SPDRP_FRIENDLYNAME,
                                                          (PBYTE)this->pmi->szFriendlyName,
                                                          (lstrlen(this->pmi->szFriendlyName)+1)*sizeof(TCHAR));
                    }
                }
            }
            break;
        }

        case IDC_BN_DEFAULTS:
        {
         PUMDEVCFG pUmDevCfg;
         DWORD dwMax, dwCount;

            // 1. Get the current maximum port speed from registry
            dwCount = sizeof(dwMax);
            if (ERROR_SUCCESS !=
                RegQueryValueEx (this->pmi->pfd->hkeyDrv,
                                 c_szMaximumPortSpeed,
                                 NULL,
                                 NULL,
                                 (LPBYTE)&dwMax,
                                 &dwCount))
            {
                dwMax = 0;
            }

            // 2. Set the maximum port speed to it's current value
            RegSetValueEx (this->pmi->pfd->hkeyDrv,
                           c_szMaximumPortSpeed,
                           0,
                           REG_DWORD,
                           (LPBYTE)&this->pmi->pglobal->dwMaximumPortSpeedSetByUser,
                           sizeof (DWORD));

            // 3. Call the configuration function
            pUmDevCfg = (PUMDEVCFG)ALLOCATE_MEMORY(sizeof(UMDEVCFG)-sizeof(COMMCONFIG)+CB_COMMCONFIGSIZE);
            if (pUmDevCfg)
            {
                pUmDevCfg->dfgHdr.dwSize     = sizeof(UMDEVCFG)-sizeof(COMMCONFIG)+CB_COMMCONFIGSIZE;
                pUmDevCfg->dfgHdr.dwVersion  = UMDEVCFG_VERSION;

                BltByte (&pUmDevCfg->commconfig, this->pmi->pcc, sizeof (COMMCONFIG));
                BltByte (&pUmDevCfg->commconfig.dcb, &this->pmi->dcb, sizeof (DCB));
                BltByte (&pUmDevCfg->commconfig.wcProviderData, &this->pmi->ms, CB_PROVIDERSIZE);

                if (NO_ERROR == UnimodemDevConfigDialog (this->pmi->szFriendlyName, this->hdlg,
                                    UMDEVCFGTYPE_COMM, 0, NULL, pUmDevCfg, NULL, 0))
                {
                    BltByte (&this->pmi->dcb, &pUmDevCfg->commconfig.dcb, sizeof (DCB));
                    BltByte (&this->pmi->ms, &pUmDevCfg->commconfig.wcProviderData, CB_PROVIDERSIZE);
                }

                FREE_MEMORY(pUmDevCfg);
            }

            // 4. If need be, restore the maximum port speed to what it was before
            if (0 != dwMax)
            {
                RegSetValueEx (this->pmi->pfd->hkeyDrv,
                               c_szMaximumPortSpeed,
                               0,
                               REG_DWORD,
                               (LPBYTE)&dwMax,
                               sizeof (DWORD));
            }
            break;
        }

        case IDOK:
            CplAdv_OnApply(this);
            EndDialog(this->hdlg, id);
            break;

        case IDCANCEL:
            EndDialog(this->hdlg, id);
            break;

        default:
            break;
    }
}


/*----------------------------------------------------------
Purpose: WM_DESTROY handler
Returns: --
Cond:    --
*/
void PRIVATE CplAdv_OnDestroy(
    PCPLADV this)
{
}


/////////////////////////////////////////////////////  EXPORTED FUNCTIONS

static BOOL s_bCplAdvRecurse = FALSE;

LRESULT INLINE CplAdv_DefProc(
    HWND hDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    ENTER_X()
        {
        s_bCplAdvRecurse = TRUE;
        }
    LEAVE_X()

    return DefDlgProc(hDlg, msg, wParam, lParam);
}


/*----------------------------------------------------------
Purpose: Real dialog proc
Returns: varies
Cond:    --
*/
LRESULT CplAdv_DlgProc(
    PCPLADV this,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (message)
        {
        HANDLE_MSG(this, WM_INITDIALOG, CplAdv_OnInitDialog);
        HANDLE_MSG(this, WM_COMMAND, CplAdv_OnCommand);
        HANDLE_MSG(this, WM_NOTIFY,  CplAdv_OnNotify);
        HANDLE_MSG(this, WM_DESTROY, CplAdv_OnDestroy);

    case WM_HELP:
        WinHelp(((LPHELPINFO)lParam)->hItemHandle, c_szWinHelpFile, HELP_WM_HELP, (ULONG_PTR)(LPVOID)g_aHelpIDs_IDD_ADV_MODEM);
        return 0;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, c_szWinHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPVOID)g_aHelpIDs_IDD_ADV_MODEM);
        return 0;

    default:
        return CplAdv_DefProc(this->hdlg, message, wParam, lParam);
        }
}


/*----------------------------------------------------------
Purpose: Dialog Wrapper
Returns: varies
Cond:    --
*/
INT_PTR CALLBACK CplAdv_WrapperProc(
    HWND hDlg,          // std params
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PCPLADV this;

    // Cool windowsx.h dialog technique.  For full explanation, see
    //  WINDOWSX.TXT.  This supports multiple-instancing of dialogs.
    //
    ENTER_X()
    {
        if (s_bCplAdvRecurse)
        {
            s_bCplAdvRecurse = FALSE;
            LEAVE_X()
            return FALSE;
        }
    }
    LEAVE_X()

    this = CplAdv_GetPtr(hDlg);
    if (this == NULL)
    {
        if (message == WM_INITDIALOG)
        {
            this = (PCPLADV)ALLOCATE_MEMORY( sizeof(CPLADV));
            if (!this)
            {
                MsgBox(g_hinst,
                       hDlg,
                       MAKEINTRESOURCE(IDS_OOM_SETTINGS),
                       MAKEINTRESOURCE(IDS_CAP_SETTINGS),
                       NULL,
                       MB_ERROR);
                EndDialog(hDlg, IDCANCEL);
                return (BOOL)CplAdv_DefProc(hDlg, message, wParam, lParam);
            }
            this->dwSig = SIG_CPLADV;
            this->hdlg = hDlg;
            CplAdv_SetPtr(hDlg, this);
        }
        else
        {
            return (BOOL)CplAdv_DefProc(hDlg, message, wParam, lParam);
        }
    }

    if (message == WM_DESTROY)
    {
        CplAdv_DlgProc(this, message, wParam, lParam);
        if (NULL != this->hAdvSetDll)
        {
            FreeLibrary (this->hAdvSetDll);
        }
        FREE_MEMORY((HLOCAL)OFFSETOF(this));
        CplAdv_SetPtr(hDlg, NULL);
        return 0;
    }

    return SetDlgMsgResult(
                hDlg,
                message,
                CplAdv_DlgProc(this, message, wParam, lParam)
                );
}


LRESULT PRIVATE CplAdv_OnNotify(
    PCPLADV this,
    int idFrom,
    NMHDR FAR * lpnmhdr)
{
    LRESULT lRet = 0;

    switch (lpnmhdr->code)
    {
    case PSN_SETACTIVE:
        CplAdv_OnSetActive(this);
        break;

    case PSN_KILLACTIVE:
        // N.b. This message is not sent if user clicks Cancel!
        // N.b. This message is sent prior to PSN_APPLY
        CplAdv_OnKillActive(this);
        break;

    case PSN_APPLY:
        CplAdv_OnApply(this);
        CplAdv_ApplyCountry(this);
        break;

    default:
        break;
    }

    return lRet;
}

void PRIVATE CplAdv_OnSetActive(
    PCPLADV this)
{
    // Init any display ....
}


/*----------------------------------------------------------
Purpose: PSN_KILLACTIVE handler
Returns: --
Cond:    --
*/
void PRIVATE CplAdv_OnKillActive(
    PCPLADV this)
{

    CplAdv_OnApply(this);
    // Save the settings back to the modem info struct so the Connection
    // page can invoke the Port Settings property dialog with the
    // correct settings.

}


BOOL ParseAdvancedSettings (LPTSTR szAdvSett, PCPLADV this)
{
 TCHAR *p = szAdvSett;
 BOOL   bRet = FALSE;

    this->hAdvSetDll = NULL;
    this->pFnAdvSet  = NULL;

    if (NULL != szAdvSett)
    {
        // Skip blanks
        while (TEXT(' ') == *p)
        {
            p++;
        }
        // Now, go to the first comma or blank
        for (; *p && *p != TEXT(',') && *p != TEXT(' '); p++);
        // if we're not at the end of the string, then
        // we just go the dll name, and the function name follows;
        if (*p)
        {
            *p = 0; // NULL-terminate the dll name;
            p++;    // go to the next symbol;
            // skip blanks
            while (TEXT(' ') == *p)
            {
                p++;
            }

            // Now, we have the DLL name and the function name;
            // first, let's try to load the dll name;
            this->hAdvSetDll = LoadLibrary (szAdvSett);
            if (NULL != this->hAdvSetDll)
            {
                // So we found the dll;
                // let's see if it contains the function.
#ifdef UNICODE
                // GetProcAddress only takes multi-byte strings
             char szFuncNameA[MAX_PATH];
                WideCharToMultiByte (CP_ACP, 0,
                                     p,
                                     -1,
                                     szFuncNameA,
                                     sizeof(szFuncNameA),
                                     NULL, NULL);
                this->pFnAdvSet = (PADVANCEDSETTINGS)GetProcAddress (this->hAdvSetDll, szFuncNameA);
#else
                this->pFnAdvSet = (PADVANCEDSETTINGS)GetProcAddress (this->hAdvSetDll, p);
#endif
                if (NULL != this->pFnAdvSet)
                {
                    bRet = TRUE;
                }
                else
                {
                    FreeLibrary (this->hAdvSetDll);
                    this->hAdvSetDll = NULL;
                }
            }
        }
    }

    return bRet;
}


#define MAX_COUNTRY_CODE   8
#define MAX_COUNTRY_NAME 256
#define MAX_CONTRY_VALUE  16

void InitializeCountry (PCPLADV this)
{
    TCHAR      szCountryName[MAX_COUNTRY_NAME];
    DWORD dwCountry;
    DWORD cbData, dwType, iIndex;
    HKEY  hKeyCountry;

    int   n,m;

    BYTE   CountryBuffer[2048];
    DWORD  CountryBufferSize;
    DWORD  Type;
    LONG   lResult;
    UINT   i;


    if (MAXDWORD == this->pmi->dwCurrentCountry) {

        goto _DisableCountrySelect;
    }

    //
    //  read in the list of countries supported by the modem
    //
    CountryBufferSize=sizeof(CountryBuffer);

    lResult=RegQueryValueEx(
        this->pmi->pfd->hkeyDrv,
        TEXT("CountryList"),
        NULL,
        &Type,
        CountryBuffer,
        &CountryBufferSize
        );

    if ((lResult != ERROR_SUCCESS) || (Type != REG_BINARY) || (CountryBufferSize < 2)) {

        goto _DisableCountrySelect;
    }

    for (i=0; i < CountryBufferSize; i++) {

        int StringLength;

        StringLength=LoadString (g_hinst, IDS_COUNTRY_00+CountryBuffer[i], szCountryName, sizeof(szCountryName)/sizeof(TCHAR));

        if (StringLength == 0) {
            //
            //  could not load a string
            //
            wsprintf(szCountryName,TEXT("Unknown country/region code (%d)"),CountryBuffer[i]);
        }

        n = ComboBox_AddString (this->hwndCountry, szCountryName);

        ComboBox_SetItemData(this->hwndCountry, n, CountryBuffer[i]);

        if (CountryBuffer[i] == this->pmi->dwCurrentCountry) {

            ComboBox_SetCurSel(this->hwndCountry, n);
        }

        if (CountryBuffer[i] == 0xb8)
        {
            /* Overload country codes so as to deal with the former 
             * USSR
             */
            for(m=0;m<=12;m++)
            {
                StringLength=LoadString (g_hinst, IDS_COUNTRY_RU2+m, szCountryName, sizeof(szCountryName)/sizeof(TCHAR));

                n = ComboBox_AddString (this->hwndCountry, szCountryName);

                ComboBox_SetItemData(this->hwndCountry, n, IDS_COUNTRY_RU2+m);
        
                if ((DWORD)(IDS_COUNTRY_RU2+m) == this->pmi->dwCurrentCountry) {

                    ComboBox_SetCurSel(this->hwndCountry, n);

                }
            }

        }

        if (CountryBuffer[i] == 0xc1)
        {
            /* Overload country codes so as to deal with the former 
             * Yugoslavia
             */
            for(m=0;m<=4;m++)
            {
                StringLength=LoadString (g_hinst, IDS_COUNTRY_YU2+m, szCountryName, sizeof(szCountryName)/sizeof(TCHAR));

                n = ComboBox_AddString (this->hwndCountry, szCountryName);

                ComboBox_SetItemData(this->hwndCountry, n, IDS_COUNTRY_YU2+m);

                if ((DWORD)(IDS_COUNTRY_YU2+m) == this->pmi->dwCurrentCountry) {

                    ComboBox_SetCurSel(this->hwndCountry, n);

                }

            }
        }


    }


    n = ComboBox_GetCount (this->hwndCountry);
    if (CB_ERR == n ||
        0 == n)
    {
        goto _DisableCountrySelect;
    }

    n = ComboBox_GetCurSel (this->hwndCountry);
    if (CB_ERR == n)
    {
        ComboBox_SetCurSel(this->hwndCountry, 0);
    }

    goto _Exit;

_DisableCountrySelect:
    this->pmi->dwCurrentCountry = MAXDWORD;
    ShowWindow (GetDlgItem (this->hdlg, IDC_AM_COUNTRY), SW_HIDE);
    ShowWindow (this->hwndCountry, SW_HIDE);

_Exit:

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\modemui\cpldiag.c ===
//-------------------------------------------------------------------
//  MDMMI.C
//  This file contains the routines for running the Modem Diagnostics
//  dialog box.
//
//  Created 9-19-97
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1993-1997
//  All rights reserved
//-------------------------------------------------------------------
#include "proj.h"     // common headers
#include "cplui.h"     // common headers

// These values are for diagnostics
#define NOT_DETECTING 0
#define DETECTING_NO_CANCEL 1
#define DETECTING_CANCEL 2

#define KEYBUFLEN         80
#define MODEM_QUERY_LEN 4096	 // Max length for modem return string
#define MAXLEN            256

#define ERROR_PORT_INACCESSIBLE     ERROR_UNKNOWN_PORT
#define ERROR_NO_MODEM              ERROR_SERIAL_NO_DEVICE

#define RCV_DELAY               2000
#define CHAR_DELAY              100

#define TF_DETECT           0x00010000

// Return values for the FindModem function
//
#define RESPONSE_USER_CANCEL    (-4)    // user requested cancel
#define RESPONSE_UNRECOG        (-3)    // got some chars, but didn't 
                                        //  understand them
#define RESPONSE_NONE           (-2)    // didn't get any chars
#define RESPONSE_FAILURE        (-1)    // internal error or port error
#define RESPONSE_OK             0       // matched with index of <cr><lf>OK<cr><lf>
#define RESPONSE_ERROR          1       // matched with index of <cr><lf>ERROR<cr><lf>

#define MAX_TEST_TRIES 1

#define MAX_SHORT_RESPONSE_LEN  30

#define CBR_HACK_115200         0xff00  // This is how we set 115,200 on 
                                        //  Win 3.1 because of a bug.

// Unicode start characters
CONST CHAR UnicodeBOM[] = { 0xff, 0xfe };

typedef struct tagDIAG
{
    HWND hdlg;              // dialog handle
    LPMODEMINFO pmi;        // modeminfo struct passed into dialog
} DIAG, *PDIAG;

const struct
{
	char szCommand[KEYBUFLEN];
	TCHAR szDisplay[KEYBUFLEN];
} g_rgATI[] =
{
        { "ATQ0V1E0\r",   TEXT("ATQ0V1E0")         },
        { "AT+GMM\r",   TEXT("AT+GMM")         },
        { "AT+FCLASS=?\r", TEXT("AT+FCLASS=?") },
        { "AT#CLS=?\r", TEXT("AT#CLS=?")       },
        { "AT+GCI?\r", TEXT("AT+GCI?")       },
        { "AT+GCI=?\r", TEXT("AT+GCI=?")       },
	{ "ATI1\r",	TEXT("ATI1")           },
	{ "ATI2\r",	TEXT("ATI2")           },
	{ "ATI3\r",	TEXT("ATI3")           },
	{ "ATI4\r",	TEXT("ATI4")           },
	{ "ATI5\r",	TEXT("ATI5")           },
	{ "ATI6\r",	TEXT("ATI6")           },
        { "ATI7\r",     TEXT("ATI7")           }

};

CONST UINT g_rguiBaud[] =
{
    CBR_300,
    CBR_1200,
    CBR_2400,
    CBR_9600,
    CBR_19200,
    CBR_38400,
	CBR_57600,
    CBR_115200
};

#define NUM_UIBAUD (sizeof(g_rguiBaud)/sizeof(g_rguiBaud[0]))


CONST DWORD BaudRateIds[] =
{
    IDS_CBR_300,
    IDS_CBR_1200,
    IDS_CBR_2400,
    IDS_CBR_9600,
    IDS_CBR_19_2,
    IDS_CBR_38_4,
    IDS_CBR_56_K,
    IDS_CBR_115K
};



char const *c_aszResponses[] = { "\r\nOK\r\n", "\r\nERROR\r\n" };
char const *c_aszNumericResponses[] = { "0\r", "4\r" };  

char const c_szNoEcho[] = "ATE0Q0V1\r";

TCHAR const FAR cszWinHelpFile4[] = TEXT("modem.hlp>proc4");

#define Diag_GetPtr(hwnd)           (PDIAG)GetWindowLongPtr(hwnd, DWLP_USER)
#define Diag_SetPtr(hwnd, lp)       (PDIAG)SetWindowLongPtr(hwnd, DWLP_USER, (ULONG_PTR)(lp))

#ifdef DEBUG
void HexDump( TCHAR *, LPCSTR lpBuf, DWORD cbLen);
#define	HEXDUMP(_a, _b, _c) HexDump(_a, _b, _c)
#else // !DEBUG
#define	HEXDUMP(_a, _b, _c) ((void) 0)
#endif


HWND g_hWndWait = NULL;
int g_DiagMode = NOT_DETECTING;				// used for processing cancel during the
                    								// detection routines

void PASCAL FillMoreInfoDialog(HWND hDlg, LPMODEMINFO pmi);
void PASCAL FillSWMoreInfoDialog(HWND hDlg, LPMODEMINFO pmi);
INT_PTR CALLBACK DiagWaitDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

void PASCAL CreateMoreInfoLVHeader(HWND hWnd, LPMODEMINFO pmi);
void NEAR PASCAL CreateSWInfoLVHeader(HWND hWnd);
int PASCAL ReadModemResponse(HANDLE hPort, LPCSTR pszCommand, int cbLen, LPSTR pszResponse, HWND hDlg);
void ParseATI (HWND hWnd, HANDLE hLog, LPSTR szResponse, LPTSTR szCommand, LV_ITEM FAR *lviItem);
UINT PASCAL CheckHighestBaudRate(HWND hWnd, HANDLE hPort);
BOOL WINAPI TestBaudRate (HANDLE hPort, UINT uiBaudRate, DWORD dwRcvDelay, BOOL *lpfCancel);
DWORD PASCAL SetPortBaudRate (HANDLE hPort, UINT BaudRate);
DWORD NEAR PASCAL CBR_To_Decimal(UINT uiCBR);
BOOL CancelDiag (void);
void
AddLVEntry(
    HWND hWnd,
    LPTSTR szField,
    LPTSTR szValue
    );

int FAR PASCAL mylstrncmp(LPCSTR pchSrc, LPCSTR pchDest, int count)
{
    for ( ; count && *pchSrc == *pchDest; pchSrc++, pchDest++, count--) {
        if (*pchSrc == '\0')
            return 0;
    }
    return count;
}

int FAR PASCAL mylstrncmpi(LPCSTR pchSrc, LPCSTR pchDest, int count)
{
    for ( ; count && toupper(*pchSrc) == toupper(*pchDest); pchSrc++, pchDest++, count--) {
        if (*pchSrc == '\0')
            return 0;
    }
    return count;
}


static BOOL s_bDiagRecurse = FALSE;

LRESULT INLINE Diag_DefProc (HWND hDlg,
                             UINT msg,
                             WPARAM wParam,
                             LPARAM lParam) 
{
    ENTER_X()
    {
        s_bDiagRecurse = TRUE;
    }
    LEAVE_X()

    return DefDlgProc(hDlg, msg, wParam, lParam); 
}


BOOL WINAPI
WinntIsWorkstation ();

BOOL PRIVATE Diag_OnInitDialog (PDIAG this,
                                HWND hwndFocus,
                                LPARAM lParam)              // expected to be PROPSHEETINFO 
{
 LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
 HWND hwnd = this->hdlg;
 TCHAR    LogPath[256];
 DWORD    ValueType;
 DWORD    BufferLength;
 LONG     lResult;
    
    ASSERT((LPTSTR)lppsp->lParam);

    this->pmi = (LPMODEMINFO)lppsp->lParam;

    if (WinntIsWorkstation ())
    {
        Button_SetText (GetDlgItem(this->hdlg, IDC_LOGGING),
                        SzFromIDS(g_hinst, IDS_LOGFILE, LogPath, SIZECHARS(LogPath)));
    }

    Button_SetCheck (GetDlgItem(this->hdlg, IDC_LOGGING), IsFlagSet(this->pmi->uFlags, MIF_ENABLE_LOGGING));

    BufferLength=sizeof(LogPath);

    lResult = RegQueryValueEx (this->pmi->pfd->hkeyDrv,
                               c_szLoggingPath,
                               0,
                               &ValueType,
                               (LPBYTE)LogPath,
                               &BufferLength);


    if ((lResult == ERROR_SUCCESS) && (ValueType == REG_SZ))
    {
     WIN32_FIND_DATA FindData;
     HANDLE hFindFile;
        hFindFile = FindFirstFile (LogPath, &FindData);
        if (INVALID_HANDLE_VALUE == hFindFile)
        {
            EnableWindow(GetDlgItem(this->hdlg, IDC_VIEWLOG), FALSE);
        }
        else
        {
            EnableWindow(GetDlgItem(this->hdlg, IDC_VIEWLOG), TRUE);
            FindClose (hFindFile);
        }
    }

    CreateSWInfoLVHeader(this->hdlg);
    FillSWMoreInfoDialog(this->hdlg, this->pmi);

    CreateMoreInfoLVHeader(this->hdlg, this->pmi);

    return TRUE;   // default initial focus
}



void PRIVATE Diag_OnCommand (PDIAG this,
                             int id,
                             HWND hwndCtl,
                             UINT uNotifyCode)
{
    switch (id)
    {
        case IDC_REFRESH:
        {
            FillMoreInfoDialog (this->hdlg, this->pmi);
            break;
        }
        case IDC_VIEWLOG:
        {
         TCHAR    LogPath[MAX_PATH+2];
         DWORD    ValueType;
         DWORD    BufferLength;
         LONG     lResult;

            lstrcpy(LogPath,TEXT("notepad.exe "));

            BufferLength=sizeof(LogPath)-sizeof(TCHAR)-(lstrlen(LogPath) * sizeof(TCHAR));

            lResult=RegQueryValueEx (this->pmi->pfd->hkeyDrv,
                                     c_szLoggingPath,
                                     0,
                                     &ValueType,
                                     (LPBYTE)(LogPath+lstrlen(LogPath)),
                                     &BufferLength);

            if (lResult == ERROR_SUCCESS)
            {
             STARTUPINFO          StartupInfo;
             PROCESS_INFORMATION  ProcessInfo;
             BOOL                 bResult;

                ZeroMemory(&StartupInfo,sizeof(StartupInfo));

                StartupInfo.cb=sizeof(StartupInfo);

                bResult=CreateProcess (NULL,
                                       LogPath,
                                       NULL,
                                       NULL,
                                       FALSE,
                                       0,
                                       NULL,
                                       NULL,
                                       &StartupInfo,
                                       &ProcessInfo);

                if (bResult)
                {
                    CloseHandle(ProcessInfo.hThread);
                    CloseHandle(ProcessInfo.hProcess);
                }
            }
        }
    }
}



/*----------------------------------------------------------
Purpose: WM_NOTIFY handler
Returns: varies
Cond:    --
*/
LRESULT PRIVATE Diag_OnNotify (PDIAG this,
                               int idFrom,
                               NMHDR FAR * lpnmhdr)
{
 LRESULT lRet = 0;
    
    switch (lpnmhdr->code)
    {
        case PSN_APPLY:
        {
         BOOL bCheck;
            // Get logging setting
            bCheck = Button_GetCheck(GetDlgItem(this->hdlg, IDC_LOGGING));
            if (bCheck != IsFlagSet(this->pmi->uFlags, MIF_ENABLE_LOGGING))
            {
                SetFlag(this->pmi->uFlags, MIF_LOGGING_CHANGED);
                if (bCheck)
                    SetFlag(this->pmi->uFlags, MIF_ENABLE_LOGGING);
                else
                    ClearFlag(this->pmi->uFlags, MIF_ENABLE_LOGGING);
            }

            this->pmi->idRet = IDOK;
            break;
        }

        case LVN_ITEMCHANGING:
            lRet = TRUE;
            break;

        default:
            break;
    }

    return lRet;
}



void PRIVATE Diag_OnDestroy (PDIAG this)
{
}


/*----------------------------------------------------------
Purpose: Real dialog proc
Returns: varies
Cond:    --
*/
LRESULT Diag_DlgProc(
    PDIAG this,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (message)
        {
        HANDLE_MSG(this, WM_INITDIALOG, Diag_OnInitDialog);
        HANDLE_MSG(this, WM_COMMAND, Diag_OnCommand);
        HANDLE_MSG(this, WM_DESTROY, Diag_OnDestroy);
        HANDLE_MSG(this, WM_NOTIFY, Diag_OnNotify);

    case WM_ACTIVATE:
        {
            if (NULL != g_hWndWait)
            {
                if (WA_ACTIVE == LOWORD(wParam) ||
                    WA_CLICKACTIVE == LOWORD(wParam))
                {
                    SetActiveWindow (g_hWndWait);
                }
            }

            break;
        }

    case WM_HELP:
        WinHelp(((LPHELPINFO)lParam)->hItemHandle, c_szWinHelpFile, HELP_WM_HELP, (ULONG_PTR)(LPVOID)g_aHelpIDs_IDD_DIAGNOSTICS);
        return 0;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, c_szWinHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPVOID)g_aHelpIDs_IDD_DIAGNOSTICS);
        return 0;

    default:
        return Diag_DefProc(this->hdlg, message, wParam, lParam);
        }

    return 0;
}



INT_PTR CALLBACK Diag_WrapperProc (HWND hDlg,
                                UINT message,
                                WPARAM wParam,
                                LPARAM lParam)
{
 PDIAG this;

    // Cool windowsx.h dialog technique.  For full explanation, see
    //  WINDOWSX.TXT.  This supports multiple-instancing of dialogs.
    //
    ENTER_X()
        {
        if (s_bDiagRecurse)
            {
            s_bDiagRecurse = FALSE;
            LEAVE_X()
            return FALSE;
            }
        }
    LEAVE_X()

    this = Diag_GetPtr(hDlg);
    if (this == NULL)
        {
        if (message == WM_INITDIALOG)
            {
            this = (PDIAG)ALLOCATE_MEMORY( sizeof(DIAG));
            if (!this)
                {
                MsgBox(g_hinst,
                       hDlg,
                       MAKEINTRESOURCE(IDS_OOM_SETTINGS), 
                       MAKEINTRESOURCE(IDS_CAP_SETTINGS),
                       NULL,
                       MB_ERROR);
                EndDialog(hDlg, IDCANCEL);
                return (BOOL)Diag_DefProc(hDlg, message, wParam, lParam);
                }
            this->hdlg = hDlg;
            Diag_SetPtr(hDlg, this);
            }
        else
            {
            return (BOOL)Diag_DefProc(hDlg, message, wParam, lParam);
            }
        }

    if (message == WM_DESTROY)
        {
        Diag_DlgProc(this, message, wParam, lParam);
        FREE_MEMORY((HLOCAL)OFFSETOF(this));
        Diag_SetPtr(hDlg, NULL);
        return 0;
        }

    return SetDlgMsgResult(hDlg, message, Diag_DlgProc(this, message, wParam, lParam));
}





//--BEGIN FUNCTION--(FillMoreInfoDialog)-----------------------------
// this routine first displays info gathered from the registry.  It then
// checks to see if IsModem is true, indicating that it should attempt
// to collect info directly from the modem.
void NEAR PASCAL FillMoreInfoDialog(HWND hDlg, LPMODEMINFO pmi)
{
 TCHAR szCommand[KEYBUFLEN];
 char szResponse[MODEM_QUERY_LEN];
 HANDLE hPort;
 int i;
 LV_ITEM lviItem;
 HWND hWndView = GetDlgItem(hDlg, IDC_MOREINFOLV);
 TCHAR pszTemp[KEYBUFLEN];
 TCHAR pszTemp2[(KEYBUFLEN * 3)];
 TCHAR pszTemp3[KEYBUFLEN];
 WORD wUart;
 TCHAR szPrefixedPort[MAX_BUF + sizeof(TEXT("\\\\.\\"))];
 HWND hWndWait;
 HANDLE   TapiHandle=NULL;
 DWORD dwBus;
 BOOL fCancel;
 TCHAR szLoggingPath[MAX_BUF];
 HANDLE hLog = INVALID_HANDLE_VALUE;
 DWORD dwBufferLength;
 DWORD dwLength;
 DWORD dwType;

	g_DiagMode = DETECTING_NO_CANCEL;   // Entering test mode

	// Fill in the List Window
	SetWindowRedraw(hWndView, FALSE);
	ListView_DeleteAllItems(hWndView);

	// create the column structure
	lviItem.mask = LVIF_TEXT;
    lviItem.iItem = 0x7FFF;
	lviItem.iSubItem = 0;
	
	lviItem.pszText = szCommand;
	
	// open the port and if successful, send commands
    if (!CplDiGetBusType (pmi->pfd->hdi, &pmi->pfd->devData, &dwBus))
    {
        dwBus = BUS_TYPE_ROOT;
    }

    lstrcpy(szPrefixedPort, TEXT("\\\\.\\"));

    dwLength = sizeof(szPrefixedPort) - (lstrlen(szPrefixedPort) * sizeof(TCHAR));

    if (BUS_TYPE_ROOT == dwBus)
    {
        if ((DWORD)lstrlen(pmi->szPortName) < (dwLength / sizeof(TCHAR)))
        {
            lstrcat(szPrefixedPort, pmi->szPortName);
        } else
        {
            goto _Done;
        }
    }
    else
    {
        if ((DWORD)(lstrlen(pmi->szFriendlyName) + lstrlen(TEXT("\\tsp"))) < (dwLength / sizeof(TCHAR)))
        {
            lstrcat(szPrefixedPort, pmi->szFriendlyName);
	    	lstrcat(szPrefixedPort, TEXT("\\tsp"));
        } else
        {
            goto _Done;
        }
    }

    if (DETECTING_CANCEL == g_DiagMode)
    {
        goto _Done;
    }

    TRACE_MSG(TF_GENERAL, "FillMoreInfoDialog: opening %s", szPrefixedPort);
    hPort = CreateFile(
        szPrefixedPort,
        GENERIC_WRITE | GENERIC_READ,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_OVERLAPPED,
        NULL
        );


    if (hPort == INVALID_HANDLE_VALUE)
    {
	    if ((GetLastError() == ERROR_ALREADY_EXISTS) ||
            (GetLastError() == ERROR_SHARING_VIOLATION) ||
            (GetLastError() == ERROR_ACCESS_DENIED))
        {
                //
                //  port is open, maybe by owning tapi app, try to make a passthrough call
                //
                hPort=GetModemCommHandle(pmi->szFriendlyName,&TapiHandle);

                if (hPort == NULL)
                {
                    //
                    //  could not get it from tapi
                    //
                    LoadString(g_hinst,IDS_OPEN_PORT,pszTemp2,sizeof(pszTemp2) / sizeof(TCHAR));
                    LoadString(g_hinst,IDS_OPENCOMM,pszTemp3,sizeof(pszTemp3) / sizeof(TCHAR));
                    MessageBox(hDlg,pszTemp2,pszTemp3,MB_OK);

                    goto _Done;
                }

        }
        else
        {
                //
                // can't open it for some other reason
                //
                LoadString(g_hinst,IDS_NO_OPEN_PORT,pszTemp2,sizeof(pszTemp2) / sizeof(TCHAR));
                LoadString(g_hinst,IDS_OPENCOMM,pszTemp3,sizeof(pszTemp3) / sizeof(TCHAR));
                MessageBox(hDlg,pszTemp2,pszTemp3,MB_OK);

                goto _Done;
        }
    }
    //
    //  opened the port
    //

    // Display a Wait Please Dialog box

    g_hWndWait = CreateDialog(g_hinst, MAKEINTRESOURCE(IDD_DIAG_WAIT), hDlg, DiagWaitDlgProc);

    if (g_hWndWait == NULL)
    {
        goto _CleanUp;
    }

    if (DETECTING_CANCEL == g_DiagMode) {

        goto _CleanUp;
    }

    EscapeCommFunction(hPort, SETDTR);

    if (!TestBaudRate(hPort, pmi->pglobal->dwMaximumPortSpeedSetByUser, 2000, &fCancel))
    {
        // Modem didn't respond, display and Bail
	    // Reset the modem and flush the ports after reading
        //
	    PurgeComm(hPort, PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR| PURGE_RXCLEAR);	// flush the ports before closing to avoid
	    CloseHandle(hPort);

            if (TapiHandle != NULL) {

                FreeModemCommHandle(TapiHandle);
            }

	    g_DiagMode = DETECTING_CANCEL;  		// So that we don't show an empty info dialog

            hWndWait = g_hWndWait;
            g_hWndWait = NULL;
            DestroyWindow (hWndWait);

	    // display message that modem didn't respond
	    LoadString(g_hinst,IDS_NO_MODEM_RESPONSE,pszTemp2,sizeof(pszTemp2) / sizeof(TCHAR));
	    MessageBox(hDlg,pszTemp2,NULL,MB_OK | MB_ICONEXCLAMATION);
	    return;
    }

    if (DETECTING_CANCEL == g_DiagMode) {

        goto _CleanUp;
    }

    // Open the log file
    dwBufferLength = sizeof(szLoggingPath);

    if (ERROR_SUCCESS == RegQueryValueEx(pmi->pfd->hkeyDrv, //hKeyDrv, 
                                             c_szLoggingPath,
                                             NULL,
                                             &dwType,
                                             (LPBYTE)szLoggingPath,
                                             &dwBufferLength) && (dwType == REG_SZ))
    {
        if (INVALID_HANDLE_VALUE != 
              (hLog = CreateFile(szLoggingPath, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL)))
        {
            DWORD dwBytesWritten = 0;

            SetFilePointer(hLog, 0, NULL, FILE_BEGIN);
            WriteFile(hLog,UnicodeBOM,sizeof(UnicodeBOM),&dwBytesWritten,NULL);

            SetFilePointer(hLog, 0, NULL, FILE_END);
            EnableWindow(GetDlgItem(hDlg, IDC_VIEWLOG), TRUE);
        }
        else
        {
            TRACE_MSG(TF_WARNING, "Cannot open unimodem log '%s'", szLoggingPath);
        }
    }
    else
    {
        TRACE_MSG(TF_WARNING, "Cannot read LoggingPath from registry");
    }

    FillMemory(szResponse,MODEM_QUERY_LEN,0);

	ReadModemResponse (hPort,
                       g_rgATI[2].szCommand,
                       sizeof(g_rgATI[2].szCommand),
                       szResponse,
                       hDlg);

	for(i = 0; i < ARRAYSIZE(g_rgATI); i++)
    {
        if (DETECTING_CANCEL == g_DiagMode)
        {
            goto _CleanUp;
        }
        FillMemory(szResponse,MODEM_QUERY_LEN,0);

		ReadModemResponse(
                        hPort,
                        g_rgATI[i].szCommand,
                        sizeof(g_rgATI[i].szCommand),
                        szResponse,
                        hDlg);

        //
		// This section parses the response, listing it on multiple lines
        //
        lstrcpy(szCommand, g_rgATI[i].szDisplay);

        // parse and display response string

		ParseATI (hWndView,
                  hLog,
                  szResponse,
                  szCommand,
                  &lviItem);
	}

    hWndWait = g_hWndWait;
    g_hWndWait = NULL;
    DestroyWindow (hWndWait);

    ListView_SetColumnWidth (hWndView, 0, LVSCW_AUTOSIZE_USEHEADER);
    ListView_SetColumnWidth (hWndView, 1, LVSCW_AUTOSIZE_USEHEADER);
	SetWindowRedraw(hWndView, TRUE);

    CheckHighestBaudRate(hDlg, hPort);

    // Reset the modem and flush the ports after reading



_CleanUp:

    // Close the log file
    if (INVALID_HANDLE_VALUE != hLog)
    {
        CloseHandle(hLog);
    }

    PurgeComm(hPort, PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR| PURGE_RXCLEAR);
    CloseHandle(hPort);

    if (TapiHandle != NULL) {

        FreeModemCommHandle(TapiHandle);
    }


_Done:

    if (DETECTING_NO_CANCEL == g_DiagMode) {

        g_DiagMode = NOT_DETECTING;  		// Through running detection routines
    }
}
//--END FUNCTION--(FillMoreInfoDialog)-------------------------------


//--BEGIN FUNCTION--(FillMoreInfoDialog)-----------------------------
// this routine first displays info gathered from the registry.  It then
// checks to see if IsModem is true, indicating that it should attempt
// to collect info directly from the modem.
void NEAR PASCAL FillSWMoreInfoDialog(HWND hDlg, LPMODEMINFO pmi)
{
 HWND hWndView = GetDlgItem(hDlg, IDC_MOREINFOV2);
 TCHAR *pszTemp;
 TCHAR szText[MAXLEN];
 DWORD dwBufSize = KEYBUFLEN*sizeof(TCHAR);

	// Fill in the List Window
	SetWindowRedraw(hWndView, FALSE);
	ListView_DeleteAllItems(hWndView);

    do
    {
	    pszTemp = ALLOCATE_MEMORY (dwBufSize);
        if (NULL == pszTemp)
        {
            break;
        }
  	    if (SetupDiGetDeviceRegistryProperty (pmi->pfd->hdi,
                                              &(pmi->pfd->devData),
                                              SPDRP_HARDWAREID,
                                              NULL,
                                              (LPBYTE)pszTemp,
                                              dwBufSize,
                                              &dwBufSize))
        {
	    LoadString(g_hinst,IDS_HARDWARE_ID,szText,sizeof(szText) / sizeof(TCHAR));
            AddLVEntry (hWndView, szText, pszTemp);
        }
        else if (ERROR_INSUFFICIENT_BUFFER == GetLastError ())
        {
            FREE_MEMORY (pszTemp);
            pszTemp = NULL;
        }
    } while (NULL == pszTemp);

    if (NULL != pszTemp)
    {
        FREE_MEMORY (pszTemp);
    }

    ListView_SetColumnWidth (hWndView, 0, LVSCW_AUTOSIZE_USEHEADER);
    ListView_SetColumnWidth (hWndView, 1, LVSCW_AUTOSIZE_USEHEADER);

    SetWindowRedraw(hWndView, TRUE);
}



//--BEGIN FUNCTION--(DiagWaitDlgProc)--------------------------------
INT_PTR CALLBACK DiagWaitDlgProc (
    HWND hDlg, 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam)
{
    switch (message)
    {
        case WM_DESTROY:
            g_hWndWait = NULL;
            break;
    
        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
		    {
        	    case IDCANCEL:
				    g_DiagMode = DETECTING_CANCEL;
                    g_hWndWait = NULL;
                    DestroyWindow (hDlg);
            	    break;
            }        
            break;

        default:
		    return FALSE;
            break;
    }    

    return TRUE;
}
//--END FUNCTION--(DiagWaitDlgProc)----------------------------------


DWORD WINAPI MyWriteComm (HANDLE hPort, LPCVOID lpBuf, DWORD cbLen)
{
    COMMTIMEOUTS cto;
    DWORD        cbLenRet;

    BOOL        bResult;
    LONG        lResult=ERROR_SUCCESS;
    OVERLAPPED  Overlapped;
    DWORD       BytesTransfered;


    HEXDUMP	(TEXT("Write"), lpBuf, cbLen);
    // Set comm timeout
    if (!GetCommTimeouts(hPort, &cto))
    {
      ZeroMemory(&cto, sizeof(cto));
    }

    // Allow a constant write timeout
    cto.WriteTotalTimeoutMultiplier = 0;
    cto.WriteTotalTimeoutConstant   = 1000; // 1 second
    SetCommTimeouts(hPort, &cto);

    // Synchronous write
//    WriteFile(hPort, lpBuf, cbLen, &cbLenRet, NULL);
//    return cbLenRet;

    ZeroMemory(&Overlapped, sizeof(Overlapped));

    Overlapped.hEvent=CreateEvent(
        NULL,
        TRUE,
        FALSE,
        NULL
        );

    if (Overlapped.hEvent == NULL) {

        return 0;
    }

    bResult=WriteFile(hPort, lpBuf, cbLen, &cbLenRet, &Overlapped);


    if (!bResult && GetLastError() != ERROR_IO_PENDING) {

        CloseHandle(Overlapped.hEvent);

        return 0;
    }

    bResult=GetOverlappedResult(
        hPort,
        &Overlapped,
        &BytesTransfered,
        TRUE
        );

    if (!bResult) {

        lResult=0;
    }

    CloseHandle(Overlapped.hEvent);

    return BytesTransfered;


}


LONG WINAPI
SyncReadFile(
    HANDLE    FileHandle,
    LPVOID    InputBuffer,
    DWORD     InputBufferLength,
    LPDWORD   BytesTransfered
    )


/*++

Routine Description:


Arguments:


Return Value:



--*/

{
    BOOL        bResult;
    LONG        lResult=ERROR_SUCCESS;
    OVERLAPPED  Overlapped;

    Overlapped.hEvent=CreateEvent(
        NULL,
        TRUE,
        FALSE,
        NULL
        );

    if (Overlapped.hEvent == NULL) {

        return GetLastError();
    }

    bResult=ReadFile(
        FileHandle,
        InputBuffer,
        InputBufferLength,
        NULL,
        &Overlapped
        );


    if (!bResult && GetLastError() != ERROR_IO_PENDING) {

        CloseHandle(Overlapped.hEvent);

        return GetLastError();
    }

    bResult=GetOverlappedResult(
        FileHandle,
        &Overlapped,
        BytesTransfered,
        TRUE
        );

    if (!bResult) {

        lResult=GetLastError();
    }

    CloseHandle(Overlapped.hEvent);

    return lResult;

}




// returns buffer full o' data and an int.
// if dwRcvDelay is NULL, default RCV_DELAY will be used, else
// dwRcvDelay (miliseconds) will be used
// *lpfCancel will be true if we are exiting because of a user requested cancel.
UINT PRIVATE ReadPort (
    HANDLE  hPort, 
    LPBYTE  lpvBuf, 
    UINT    uRead,
    DWORD   dwRcvDelay, 
    int FAR *lpiError, 
    BOOL FAR *lpfCancel)
{
    DWORD cb, cbLenRet;
    UINT uTotal = 0;
    DWORD tStart;
    DWORD dwDelay;
    COMSTAT comstat;
    COMMTIMEOUTS cto;
    DWORD   dwError;
    DWORD cbLeft;
#ifdef DEBUG
    DWORD dwZeroCount = 0;
#endif // DEBUG

    ASSERT(lpvBuf);
    ASSERT(uRead);
    ASSERT(lpiError);

    *lpiError = 0;
    *lpfCancel = FALSE;
    
    tStart = GetTickCount();
    dwDelay = dwRcvDelay ? dwRcvDelay : RCV_DELAY;
    
    // save space for terminator
    uRead--;
    cbLeft=uRead;


    // Set comm timeout
    if (!GetCommTimeouts(hPort, &cto))
    {
      ZeroMemory(&cto, sizeof(cto));
    };
    // Allow a constant write timeout
    cto.ReadIntervalTimeout        = 0;
    cto.ReadTotalTimeoutMultiplier = 0;
    cto.ReadTotalTimeoutConstant   = 25; 
    SetCommTimeouts(hPort, &cto);

    do
    {
        cb = 0;
        while(  cbLeft
                && (SyncReadFile(hPort, lpvBuf + uTotal + cb, 1, &cbLenRet)==ERROR_SUCCESS)
                && (cbLenRet))
        {
          ASSERT(cbLenRet==1);
          cb ++;
          cbLeft--;
        };

#ifdef DEBUG
        if (cb)
        {
            dwZeroCount = 0;
        }
        else
        {
            dwZeroCount++;
        }
#endif // DEBUG

        {
            MSG msg;

            while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                if (NULL == g_hWndWait || !IsDialogMessage (g_hWndWait, &msg))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }

        if (cb == 0)  // possible error?
        {
            dwError = 0;
            ClearCommError(hPort, &dwError, &comstat);
            *lpiError |= dwError;
#ifdef DEBUG
            if (dwError)
            {
              TRACE_MSG(TF_DETECT, "ReadComm returned %d, comstat: status = %hx, in = %u, out = %u",
                                  cb, dwError, comstat.cbInQue, comstat.cbOutQue);
            };
#endif // DEBUG
        }

        if (cb)
        {
            // successful read - add to total and reset delay
            uTotal += cb;

            if (uTotal >= uRead)
            {
                ASSERT(uTotal == uRead);
                break;
            }
            tStart = GetTickCount();
            dwDelay = CHAR_DELAY;
        }
        else
        {
            if (CancelDiag ())
            {
                TRACE_MSG(TF_DETECT, "User pressed cancel.");
                *lpfCancel = TRUE;
                break;
            }
        }

     // While read is successful && time since last read < delay allowed)       
    } while (cbLeft && (GetTickCount() - tStart) < dwDelay);
               
    *(lpvBuf+uTotal) = 0;
    
#ifndef PROFILE_MASSINSTALL
    TRACE_MSG(TF_DETECT, "ReadPort returning %d", uTotal);    
#endif
    return uTotal;
}


#define MAX_RESPONSE_BURST_SIZE 8192
#define MAX_NUM_RESPONSE_READ_TRIES 30 // digicom scout needs this much + some safety
#define MAX_NUM_MULTI_TRIES 3   // Maximum number of 'q's to be sent when we aren't getting any response

// Read in response.  Handle multi-pagers.  Return a null-terminated string.
// Also returns response code.
// If lpvBuf == NULL
//      cbRead indicates the max amount to read.  Bail if more than this.
// Else
//      cbRead indicates the size of lpvBuf
// This can not be a state driven (ie. char by char) read because we
// must look for responses from the end of a sequence of chars backwards.
// This is because "ATI2" on some modems will return 
// "<cr><lf>OK<cr><lf><cr><lf>OK<cr><lf>" and we only want to pay attention
// to the final OK.  Yee haw!
// Returns:  RESPONSE_xxx
int WINAPI ReadResponse (HANDLE hPort, 
                         LPBYTE lpvBuf, 
                         UINT cbRead, 
                         BOOL fMulti,
                         DWORD dwRcvDelay)
{
 int  iRet = RESPONSE_UNRECOG;
 LPBYTE pszBuffer;
 BOOL fDoCopy = TRUE;
 UINT uBufferLen, uResponseLen;
 UINT uReadTries = MAX_NUM_RESPONSE_READ_TRIES;
 UINT i;
 UINT uOutgoingBufferCount = 0;
 UINT uAllocSize = lpvBuf ? MAX_RESPONSE_BURST_SIZE : cbRead;
 UINT uTotalReads = 0;
 UINT uNumMultiTriesLeft = MAX_NUM_MULTI_TRIES;
 int  iError;
 BOOL fCancel;
 BOOL fHadACommError = FALSE;

    ASSERT(cbRead);

    // do we need to adjust cbRead?
    if (lpvBuf)
    {
        cbRead--;  // preserve room for terminator
    }

    // Allocate buffer
    if (!(pszBuffer = (LPBYTE)ALLOCATE_MEMORY(uAllocSize)))
    {
        TRACE_MSG(TF_ERROR, "couldn't allocate memory.\n");
        return RESPONSE_FAILURE;
    }

    while (uReadTries--)
    {
        // Read response into buffer
        uBufferLen = ReadPort (hPort, pszBuffer, uAllocSize, dwRcvDelay, &iError, &fCancel);

        // Did the user request a cancel?
        if (fCancel)
        {
            iRet = RESPONSE_USER_CANCEL;
            goto Exit;
        }

        // any errors?
        if (iError)
        {
            fHadACommError = TRUE;
#ifdef DEBUG
            if (iError & CE_RXOVER)   TRACE_MSG(TF_DETECT, "CE_RXOVER");
            if (iError & CE_OVERRUN)  TRACE_MSG(TF_DETECT, "CE_OVERRUN");
            if (iError & CE_RXPARITY) TRACE_MSG(TF_DETECT, "CE_RXPARITY");
            if (iError & CE_FRAME)    TRACE_MSG(TF_DETECT, "CE_FRAME");
            if (iError & CE_BREAK)    TRACE_MSG(TF_DETECT, "CE_BREAK");
            if (iError & CE_TXFULL)   TRACE_MSG(TF_DETECT, "CE_TXFULL");
            if (iError & CE_PTO)      TRACE_MSG(TF_DETECT, "CE_PTO");
            if (iError & CE_IOE)      TRACE_MSG(TF_DETECT, "CE_IOE");
            if (iError & CE_DNS)      TRACE_MSG(TF_DETECT, "CE_DNS");
            if (iError & CE_OOP)      TRACE_MSG(TF_DETECT, "CE_OOP");
            if (iError & CE_MODE)     TRACE_MSG(TF_DETECT, "CE_MODE");
#endif // DEBUG
        }

        // Did we not get any chars?
        if (uBufferLen)
        {
            uNumMultiTriesLeft = MAX_NUM_MULTI_TRIES; // reset num multi tries left, since we got some data
            uTotalReads += uBufferLen;
            HEXDUMP(TEXT("Read"), pszBuffer, uBufferLen);
            if (lpvBuf)
            {
                // fill outgoing buffer if there is room
                for (i = 0; i < uBufferLen; i++)
                {
                    if (0 == pszBuffer[i])
                    {
                        // Skip NULL characters
                        uTotalReads--;
                        continue;
                    }
                    if (uOutgoingBufferCount < cbRead)
                    {
                        lpvBuf[uOutgoingBufferCount++] = pszBuffer[i];
                    }
                    else
                    {
                        break;
                    }
                }
                // null terminate what we have so far
                lpvBuf[uOutgoingBufferCount] = 0;
            }
            else
            {
                if (uTotalReads >= cbRead)
                {
                    TRACE_MSG(TF_WARNING, "Bailing ReadResponse because we exceeded our maximum read allotment.");
                    goto Exit;
                }
            }

            // try to find a matching response (crude but quick)
            for (i = 0; i < ARRAYSIZE(c_aszResponses); i++)
            {
                // Verbose responses
                uResponseLen = lstrlenA(c_aszResponses[i]);

                // enough read to match this response?
                if (uBufferLen >= uResponseLen)
                {
                    if (!mylstrncmp(c_aszResponses[i], pszBuffer + uBufferLen - uResponseLen, uResponseLen))
                    {
                        iRet = i;
                        goto Exit;
                    }
                }

                // Numeric responses, for cases like when a MultiTech interprets AT%V to mean "go into numeric response mode"
                uResponseLen = lstrlenA(c_aszNumericResponses[i]);

                // enough read to match this response?
                if (uBufferLen >= uResponseLen)
                {
                    if (!mylstrncmp(c_aszNumericResponses[i], pszBuffer + uBufferLen - uResponseLen, uResponseLen))
                    {
                        DCB DCB;

                        TRACE_MSG(TF_WARNING, "went into numeric response mode inadvertantly.  Setting back to verbose.");

                        // Get current baud rate
                        if (GetCommState(hPort, &DCB) == 0) 
                        {
                            // Put modem back into Verbose response mode
                            if (!TestBaudRate (hPort, DCB.BaudRate, 0, &fCancel))
                            {
                                if (fCancel)
                                {
                                    iRet = RESPONSE_USER_CANCEL;
                                    goto Exit;
                                }
                                else
                                {
                                    TRACE_MSG(TF_ERROR, "couldn't recover contact with the modem.");
                                    // don't return error on failure, we have good info
                                }
                            }
                        }
                        else
                        {
                            TRACE_MSG(TF_ERROR, "GetCommState failed");
                            // don't return error on failure, we have good info
                        }

                        iRet = i;
                        goto Exit;
                    }
                }
            }
        }
        else
        {
            // have we received any chars at all (ie. from this or any previous reads)?
            if (uTotalReads)
            {
                if (fMulti && uNumMultiTriesLeft)
                {   // no match found, so assume it is a multi-pager, send a 'q'
                    // 'q' will catch those pagers that will think 'q' means quit.
                    // else, we will work with the pages that just need any ole' char.  
                    uNumMultiTriesLeft--;
                    TRACE_MSG(TF_DETECT, "sending a 'q' because of a multi-pager.");
                    if (MyWriteComm(hPort, "q", 1) != 1)
                    {
                        TRACE_MSG(TF_ERROR, "WriteComm failed");
                        iRet = RESPONSE_FAILURE;
                        goto Exit;
                    }
                    continue;
                }
                else
                {   // we got a response, but we didn't recognize it
                    ASSERT(iRet == RESPONSE_UNRECOG);   // check initial setting
                    goto Exit;
                }
            }
            else
            {   // we didn't get any kind of response
                iRet = RESPONSE_NONE;
                goto Exit;
            }
        }
    } // while

Exit:
    // Free local buffer
    FREE_MEMORY(pszBuffer);
    if (fHadACommError && RESPONSE_USER_CANCEL != iRet)
    {
        iRet = RESPONSE_FAILURE;
    }
    return iRet;
}



BOOL CancelDiag (void)
{
 BOOL bRet = FALSE;

    if (DETECTING_NO_CANCEL == g_DiagMode)
    {
     MSG msg;
        while (PeekMessage (&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (NULL == g_hWndWait || !IsDialogMessage (g_hWndWait, &msg))
            {
                TranslateMessage (&msg);
                DispatchMessage (&msg);
            }
        }

        bRet = (DETECTING_CANCEL == g_DiagMode);
    }

    return bRet;
}

// Switch to requested baud rate and try sending ATE0Q0V1 and return whether it works or not
// Try MAX_TEST_TRIES
// Returns: TRUE on SUCCESS
//          FALSE on failure (including user cancels)
BOOL 
WINAPI
TestBaudRate (
    IN  HANDLE hPort, 
    IN  UINT uiBaudRate, 
    IN  DWORD dwRcvDelay,
    OUT BOOL FAR *lpfCancel)
{
    DWORD cbLen;
    int   iTries = MAX_TEST_TRIES;

    DBG_ENTER(TestBaudRate);
    
    *lpfCancel = FALSE;

    while (iTries--)
    {
        if (CancelDiag ())
        {
            *lpfCancel = TRUE;
            break;
        }

        // try new baud rate
        if (SetPortBaudRate(hPort, uiBaudRate) == NO_ERROR) 
        {
            cbLen = lstrlenA(c_szNoEcho); // Send an ATE0Q0V1<cr>

            // clear the read queue, there shouldn't be anything there
            PurgeComm(hPort, PURGE_RXCLEAR);
            if (MyWriteComm(hPort, (LPBYTE)c_szNoEcho, cbLen) == cbLen) 
            {
                switch (ReadResponse (hPort, NULL, MAX_SHORT_RESPONSE_LEN, FALSE, dwRcvDelay))
                {
                case RESPONSE_OK:
		    DBG_EXIT(TestBaudRate);
                    return TRUE;

                case RESPONSE_USER_CANCEL:
                    *lpfCancel = TRUE;
                    break;
                }
            }                                                                
        }
    }
    DBG_EXIT(TestBaudRate);
    return FALSE;
}


#define SERIAL_CABLE_HD_ID  TEXT("PNPC031")

//--BEGIN FUNCTION--(CreateMoreInfoLVHeader)-------------------------
void NEAR PASCAL CreateMoreInfoLVHeader(HWND hWnd, LPMODEMINFO pmi)
{
 int index;
 LV_COLUMN lvC;
 TCHAR szText[KEYBUFLEN];
 HWND hWndList = GetDlgItem(hWnd, IDC_MOREINFOLV);

  	if (SetupDiGetDeviceRegistryProperty (pmi->pfd->hdi,
                                          &(pmi->pfd->devData),
                                          SPDRP_HARDWAREID,
                                          NULL,
                                          (LPBYTE)szText,
                                          sizeof(szText),
                                          NULL))
    {
        if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szText, -1, SERIAL_CABLE_HD_ID, -1) == 2)
        {
            EnableWindow (hWndList, FALSE);
            EnableWindow (GetDlgItem (hWnd, IDC_REFRESH), FALSE);
            return;
        }
    }

	lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvC.fmt = LVCFMT_LEFT;
	lvC.pszText = szText;

	LoadString(g_hinst,IDS_COMMAND,szText,sizeof(szText) / sizeof(TCHAR));
    lvC.iSubItem = index = 0;  lvC.cx = 50;
	ListView_InsertColumn(hWndList, index, &lvC);

	LoadString(g_hinst,IDS_RESPONSE,szText,sizeof(szText) / sizeof(TCHAR));
    lvC.iSubItem = index = 1;  

	ListView_InsertColumn(hWndList, index, &lvC);

    ListView_SetColumnWidth (hWndList, 0, LVSCW_AUTOSIZE_USEHEADER);
    ListView_SetColumnWidth (hWndList, 1, LVSCW_AUTOSIZE_USEHEADER);
}
//--END FUNCTION--(CreateMoreInfoLVHeader)---------------------------


void NEAR PASCAL CreateSWInfoLVHeader(HWND hWnd)
{
 int index;
 LV_COLUMN lvC;
 TCHAR szText[KEYBUFLEN];
 HWND hWndList = GetDlgItem(hWnd, IDC_MOREINFOV2);

	lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvC.fmt = LVCFMT_LEFT;
	lvC.pszText = szText;

    LoadString(g_hinst,IDS_FIELD,szText,sizeof(szText) / sizeof(TCHAR));
    lvC.iSubItem = index = 0;  lvC.cx = 50;
	ListView_InsertColumn(hWndList, index, &lvC);

    LoadString(g_hinst,IDS_VALUE,szText,sizeof(szText) / sizeof(TCHAR));
    lvC.iSubItem = index = 1;  
	ListView_InsertColumn(hWndList, index, &lvC);

    ListView_SetColumnWidth (hWndList, 0, LVSCW_AUTOSIZE_USEHEADER);
    ListView_SetColumnWidth (hWndList, 1, LVSCW_AUTOSIZE_USEHEADER);
}



//--BEGIN FUNCTION--(ReadModemResponse)------------------------------
// this routine uses ReadResponse from detect.c to get responses from
// the modem.

int WINAPI
ReadModemResponse(
    HANDLE hPort,
    LPCSTR pszCommand,
    int cbLen,
    LPSTR pszResponse,
    HWND hDlg
    )


{

    int PortError = 0;

    if (MyWriteComm(hPort, pszCommand, cbLen) == (DWORD)cbLen) {

        PortError = ReadResponse (hPort, pszResponse, MODEM_QUERY_LEN, TRUE, 10000);
    }

    return PortError;
}
//--END FUNCTION--(ReadModemResponse)--------------------------------


//--BEGIN FUNCTION--(ParseATI)---------------------------------------
// this function strips away extraneous information from the ATI
// responses retrieved from the modem.  It then displays the
// responses in the ListView
void
ParseATI(
    HWND hWnd,
    HANDLE hLog,
    LPSTR szResponse,
    LPTSTR szCommand,
    LV_ITEM FAR *lviItem)
{
 TCHAR  WideBuffer[MODEM_QUERY_LEN];
 LPTSTR Response;
 TCHAR	pszTemp[1024];
 TCHAR	pszTemp2[1024];
 TCHAR	wszLog[1024];
 char	szLog[1024];
 LPTSTR szTemp;
 int    item_no;
 BOOL   IsCommand  = FALSE;	// used to display 'OK' if no other response from ATI command
 BOOL   bFirstItem = TRUE;
 UNICODE_STRING UncBuffer;
 STRING AnsiString;

    FillMemory(WideBuffer,sizeof(WideBuffer),0);

    MultiByteToWideChar (CP_ACP, 0,
                         szResponse, lstrlenA(szResponse),
                         WideBuffer, sizeof(WideBuffer)/sizeof(TCHAR));

    Response = WideBuffer;
    szTemp   = pszTemp;

    Response[MODEM_QUERY_LEN-1] = TEXT('\0');

    while (*Response != TEXT('\0'))
    {
	    if ((*Response != TEXT('\r')) && (*Response != TEXT('\n')))
        {
	        *szTemp = *Response;
	        Response++;
            szTemp++;
	    }
        else
        {
            // got CR or LF
            // insure that we've actually processed some chars
	        if (szTemp != pszTemp)
            {
                //  got some chars
		        *szTemp = TEXT('\0');

                if ((lstrcmp(pszTemp,TEXT("OK")) != 0))
                {
                    // not OK
                    if (lstrcmp(pszTemp,TEXT("ERROR")) == 0)
                    {
                        //  got ERROR, but don't want to worry user
                        LoadString(g_hinst, IDS_ERROR_RESPONSE, pszTemp2, sizeof(pszTemp2) / sizeof(TCHAR));
                        item_no = ListView_InsertItem(hWnd, lviItem);
                        ListView_SetItemText(hWnd, item_no, 1, pszTemp2);

                        // Write to the log file
                        if (INVALID_HANDLE_VALUE != hLog)
                        {
                            DWORD dwWritten;

                            if (lstrlen(szCommand) <= (sizeof(wszLog) / sizeof(TCHAR)))
                            {
                                lstrcpy(wszLog, szCommand);
                            } else
                            {
                                lstrcpy(wszLog, TEXT(""));
                            }

                            if ((lstrlen(wszLog) + lstrlen(TEXT(" - ")) + lstrlen(pszTemp2) + lstrlen(TEXT("\r\n"))) <
                                  (sizeof(wszLog) / sizeof(TCHAR)))
                            {
                                lstrcat(wszLog, TEXT(" - "));
                                lstrcat(wszLog, pszTemp2);
                                lstrcat(wszLog, TEXT("\r\n"));
                            }

                            WideCharToMultiByte (CP_ACP, 0,
                                wszLog, -1,
                                szLog, sizeof(szLog),
                                NULL, NULL);

                            // WriteFile(hLog, szLog, lstrlenA(szLog), &dwWritten, NULL);
                            RtlInitAnsiString(&AnsiString,szLog);
                            RtlAnsiStringToUnicodeString(&UncBuffer,&AnsiString,TRUE);

                            WriteFile(hLog,
                                    UncBuffer.Buffer,
                                    UncBuffer.Length,
                                    &dwWritten,
                                    NULL);

                            RtlFreeUnicodeString(&UncBuffer);
                        }

                    }
                    else
                    {
                        //
                        //  not OK or ERROR
                        //
                        item_no = ListView_InsertItem(hWnd, lviItem);
                        ListView_SetItemText(hWnd, item_no, 1, pszTemp);

                        //
                        // Write to the log file
                        //
                        if (INVALID_HANDLE_VALUE != hLog)
                        {
                            DWORD dwWritten;

                            if (bFirstItem) {

                                lstrcpy(wszLog, szCommand);
                                lstrcat(wszLog, TEXT(" - "));

                            } else {
                                //
                                // just pad it
                                //
                                lstrcpy(wszLog, TEXT("       "));
                            }

                            if ((lstrlen(wszLog) + lstrlen(pszTemp) + lstrlen(TEXT("\r\n"))) <
                                  (sizeof(wszLog) / sizeof(TCHAR)))
                            {
                                lstrcat(wszLog, pszTemp);
                                lstrcat(wszLog, TEXT("\r\n"));
                            }

                            WideCharToMultiByte(
                                CP_ACP,
                                0,
                                wszLog,
                                -1,
                                szLog,
                                sizeof(szLog),
                                NULL,
                                NULL
                                );

                            RtlInitAnsiString(&AnsiString,szLog);
                            RtlAnsiStringToUnicodeString(&UncBuffer,&AnsiString,TRUE);

                            WriteFile(hLog,
                                    UncBuffer.Buffer,
                                    UncBuffer.Length,
                                    &dwWritten,
                                    NULL);

                            RtlFreeUnicodeString(&UncBuffer);
                            // WriteFile(hLog, szLog, lstrlenA(szLog), &dwWritten, NULL);
                        }

                        if (bFirstItem)
                        {
                            bFirstItem = FALSE;
                            lviItem->pszText[0] = 0;
                        }

                    }
                    IsCommand = TRUE;
                }

                szTemp = pszTemp;  //reset temp holder

                while ((*Response == TEXT('\r')) ||
                       (*Response == TEXT('\n')))
                {
                    //  skip any more CR's anf LF's
                    Response++;
                }

            }
            else
            {
                //
                //  there not any other characters in the buffer
                //
                if (*Response != TEXT('\0'))
                {
                    Response++;
                }
            }
        }
    }

    // break out of the for loop w/o processing the last string.
    // This keeps the final "OK" from showing up !!
    // If no command has been displayed, then display 'OK'
    //
    if (!IsCommand)
    {
    	LoadString(g_hinst, IDS_OK, pszTemp2, sizeof(pszTemp2) / sizeof(TCHAR));
    	item_no = ListView_InsertItem(hWnd, lviItem);
    	ListView_SetItemText(hWnd, item_no, 1, pszTemp2);

        // Write to the log file
        if (INVALID_HANDLE_VALUE != hLog)
        {
            DWORD dwWritten;

            lstrcpy(wszLog, szCommand);
            lstrcat(wszLog, TEXT(" - "));
            lstrcat(wszLog, pszTemp);
            lstrcat(wszLog, TEXT("\r\n"));

            WideCharToMultiByte (CP_ACP, 0,
                    wszLog, -1,
                    szLog, sizeof(szLog),
                    NULL, NULL);

            RtlInitAnsiString(&AnsiString,szLog);
            RtlAnsiStringToUnicodeString(&UncBuffer,&AnsiString,TRUE);

            WriteFile(hLog,
                    UncBuffer.Buffer,
                    UncBuffer.Length,
                    &dwWritten,
                    NULL);

            RtlFreeUnicodeString(&UncBuffer);

            // WriteFile(hLog, szLog, lstrlenA(szLog), &dwWritten, NULL);
        }
    }
}
//--END FUNCTION--(ParseATI)-----------------------------------------

void
AddLVEntry(
    HWND hWnd,
    LPTSTR szField,
    LPTSTR szValue
    )


{
	// create the column structure
    LV_ITEM lviItem;
    int item_no;
	lviItem.mask = LVIF_TEXT;
    lviItem.iItem = 0x7FFF;
	lviItem.iSubItem = 0;
	lviItem.pszText = szField;
	lviItem.cchTextMax = 32;
    item_no = ListView_InsertItem(hWnd, &lviItem);
    ListView_SetItemText(hWnd, item_no, 1, szValue);
}


//--BEGIN FUNCTION--(CheckHighestBaudRate)---------------------------
// This routine calls TestBaudRate to see what the
// highest communications speed with the port is.
UINT NEAR PASCAL CheckHighestBaudRate(HWND hWnd, HANDLE hPort)
{
    int x = (NUM_UIBAUD - 1);
    TCHAR szTemp[KEYBUFLEN];
    BOOL fCancel;

    while (x >= 0) {

	if (TestBaudRate (hPort, g_rguiBaud[x], 500, &fCancel))
    {
        LoadString(g_hinst,BaudRateIds[x],szTemp,sizeof(szTemp)/sizeof(TCHAR));

        EnableWindow(GetDlgItem(hWnd,IDC_ST_DIAG_RHS),TRUE);
	    SetDlgItemText(hWnd, IDC_DIAG_RHS, szTemp);

	    return g_rguiBaud[x];

	}

	x--;
    }

    EnableWindow(GetDlgItem(hWnd,IDC_ST_DIAG_RHS),TRUE);
    LoadString(g_hinst,IDS_CBR_0,szTemp,sizeof(szTemp)/sizeof(TCHAR));

    SetDlgItemText(hWnd, IDC_DIAG_RHS, szTemp);
    return 0;
}
//--END FUNCTION--(CheckHighestBaudRate)-----------------------------




#ifdef DEBUG
void HexDump(TCHAR *ptchHdr, LPCSTR lpBuf, DWORD cbLen)
{
    TCHAR *rgch = NULL;
	TCHAR *pc = NULL;
	TCHAR *pcMore = TEXT("");

    rgch = (TCHAR *)ALLOCATE_MEMORY(10000 * sizeof(TCHAR));

    pc = rgch;

	if ((rgch != NULL) && DisplayDebug(TF_DETECT))
    {
		pc += wsprintf(pc, TEXT("HEX DUMP(%s,%lu): ["), ptchHdr, cbLen);
		if (cbLen>1000) {pcMore = TEXT(", ..."); cbLen=1000;}

		for(;cbLen--; lpBuf++)
		{
			pc += wsprintf(pc, TEXT(" %02lx"), (unsigned long) *lpBuf);
			if (!((cbLen+1)%20))
			{
				pc += wsprintf(pc, TEXT("\r\n"));
			}
		}
		pc += wsprintf(pc, TEXT("]\r\n"));

		OutputDebugString(rgch);

        FREE_MEMORY(rgch);
	}


}
#endif // DEBUG



DWORD NEAR PASCAL SetPortBaudRate(HANDLE hPort, UINT BaudRate)
{
    DCB DCB;

    DBG_ENTER_UL(SetPortBaudRate, CBR_To_Decimal(BaudRate));

    // Get a Device Control Block with current port values

    if (!GetCommState(hPort, &DCB)) {
        TRACE_MSG(TF_ERROR, "GetCommState failed");
        DBG_EXIT(SetPortBaudRate);
        return ERROR_PORT_INACCESSIBLE;
    }

    DCB.BaudRate = BaudRate;
    DCB.ByteSize = 8;
    DCB.Parity = 0;
    DCB.StopBits = 0;
    DCB.fBinary = 1;
    DCB.fParity = 0;
    DCB.fDtrControl = DTR_CONTROL_ENABLE;
    DCB.fDsrSensitivity  = FALSE;
    DCB.fRtsControl = RTS_CONTROL_ENABLE;
    DCB.fOutxCtsFlow = FALSE;
    DCB.fOutxDsrFlow = FALSE;
    DCB.fOutX = FALSE;
    DCB.fInX =FALSE;


    if (!SetCommState(hPort, &DCB)) {
        TRACE_MSG(TF_ERROR, "SetCommState failed");
        DBG_EXIT(SetPortBaudRate);
        return ERROR_PORT_INACCESSIBLE;
    }
    TRACE_MSG(TF_DETECT, "SetBaud rate to %lu", BaudRate);

    if (!EscapeCommFunction(hPort, SETDTR)) {
        TRACE_MSG(TF_ERROR, "EscapeCommFunction failed");
        DBG_EXIT(SetPortBaudRate);
        return ERROR_PORT_INACCESSIBLE;
    }


    DBG_EXIT(SetPortBaudRate);
    return NO_ERROR;
}



// Convert CBR format speeds to decimal.  Returns 0 on error
DWORD NEAR PASCAL CBR_To_Decimal(UINT uiCBR)
{
    DWORD dwBaudRate;

    switch (uiCBR)
    {
    case CBR_300:
        dwBaudRate = 300L;
        break;
    case CBR_1200:
        dwBaudRate = 1200L;
        break;
    case CBR_2400:
        dwBaudRate = 2400L;
        break;
    case CBR_9600:
        dwBaudRate = 9600L;
        break;
    case CBR_19200:
        dwBaudRate = 19200L;
        break;
    case CBR_38400:
        dwBaudRate = 38400L;
        break;
    case CBR_56000:
        dwBaudRate = 57600L;
        break;
    case CBR_HACK_115200:
        dwBaudRate = 115200L;
        break;
//    case CBR_110:
//    case CBR_600:
//    case CBR_4800:
//    case CBR_14400:
//    case CBR_128000:
//    case CBR_256000:
    default:
        TRACE_MSG(TF_ERROR, "An unsupported CBR_x value was used.");
        dwBaudRate = 0;
        break;
    }
    return dwBaudRate;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\modemui\cplgen.c ===
//---------------------------------------------------------------------------
//
// Copyrght (c) Microsoft Corporation 1993-1994
//
// File: gen.c
//
// This files contains the dialog code for the CPL General property page.
//
// History:
//  1-14-94 ScottH     Created
//
//---------------------------------------------------------------------------


/////////////////////////////////////////////////////  INCLUDES

#include "proj.h"         // common headers
#include "cplui.h"         // common headers


/////////////////////////////////////////////////////  CONTROLLING DEFINES

/////////////////////////////////////////////////////  TYPEDEFS

#define SUBCLASS_PARALLEL   0
#define SUBCLASS_SERIAL     1
#define SUBCLASS_MODEM      2

#define MAX_NUM_VOLUME_TICS 4

#define SIG_CPLGEN   0x2baf341e


typedef struct tagCPLGEN
    {
    DWORD dwSig;            // Must be set to SIG_CPLGEN
    HWND hdlg;              // dialog handle
    HWND hwndPort;
    HWND hwndWait;

    LPMODEMINFO pmi;        // modeminfo struct passed in to dialog
    int  ticVolume;
    int  iSelOriginal;

    int  ticVolumeMax;
    struct {                // volume tic mapping info
        DWORD dwVolume;
        DWORD dwMode;
        } tics[MAX_NUM_VOLUME_TICS];
    
    } CPLGEN, FAR * PCPLGEN;

/////////////////////////////////////////////////////  DEFINES

/////////////////////////////////////////////////////  MACROS

#define VALID_CPLGEN(_pcplgen)  ((_pcplgen)->dwSig == SIG_CPLGEN)

PCPLGEN CplGen_GetPtr(HWND hwnd)
{
    PCPLGEN pCplGen = (PCPLGEN)GetWindowLongPtr(hwnd, DWLP_USER);
    if (!pCplGen || VALID_CPLGEN(pCplGen))
    {
        return pCplGen;
    }
    else
    {
        MYASSERT(FALSE);
        return NULL;
    }
}

void CplGen_SetPtr(HWND hwnd, PCPLGEN pCplGen)
{
    if (pCplGen && !VALID_CPLGEN(pCplGen))
    {
        MYASSERT(FALSE);
        pCplGen = NULL;
    }
   
    SetWindowLongPtr(hwnd, DWLP_USER, (ULONG_PTR) pCplGen);
}

/////////////////////////////////////////////////////  MODULE DATA

#pragma data_seg(DATASEG_READONLY)


// Map driver type values to icon resource IDs
struct 
    {
    BYTE    nDeviceType;    // DT_ value
    UINT    idi;            // icon resource ID
    UINT    ids;            // string resource ID
    } const c_rgmapdt[] = {
        { DT_NULL_MODEM,     IDI_NULL_MODEM,     IDS_NULL_MODEM },
        { DT_EXTERNAL_MODEM, IDI_EXTERNAL_MODEM, IDS_EXTERNAL_MODEM },
        { DT_INTERNAL_MODEM, IDI_INTERNAL_MODEM, IDS_INTERNAL_MODEM },
        { DT_PCMCIA_MODEM,   IDI_PCMCIA_MODEM,   IDS_PCMCIA_MODEM },
        { DT_PARALLEL_PORT,  IDI_NULL_MODEM,     IDS_PARALLEL_PORT },
        { DT_PARALLEL_MODEM, IDI_EXTERNAL_MODEM, IDS_PARALLEL_MODEM } };

#pragma data_seg()


/*----------------------------------------------------------
Purpose: Returns the appropriate icon ID given the device
         type.

Returns: icon resource ID in pidi
         string resource ID in pids
Cond:    --
*/
void PRIVATE GetTypeIDs(
    BYTE nDeviceType,
    LPUINT pidi,
    LPUINT pids)
    {
    int i;

    for (i = 0; i < ARRAY_ELEMENTS(c_rgmapdt); i++)
        {
        if (nDeviceType == c_rgmapdt[i].nDeviceType)
            {
            *pidi = c_rgmapdt[i].idi;
            *pids = c_rgmapdt[i].ids;
            return;
            }
        }
    ASSERT(0);      // We should never get here
    }


/*----------------------------------------------------------
Purpose: Returns FALSE if the given port is not compatible with
         the device type.

Returns: see above
Cond:    --
*/
BOOL 
PRIVATE 
IsCompatiblePort(
    IN  DWORD nSubclass,
    IN  BYTE nDeviceType)
    {
    BOOL bRet = TRUE;

    // Is the port subclass appropriate for this modem type?
    // (Don't list lpt ports when it is a serial modem.)
    switch (nSubclass)
        {
    case PORT_SUBCLASS_SERIAL:
        if (DT_PARALLEL_PORT == nDeviceType ||
            DT_PARALLEL_MODEM == nDeviceType)
            {
            bRet = FALSE;
            }
        break;

    case PORT_SUBCLASS_PARALLEL:
        if (DT_PARALLEL_PORT != nDeviceType &&
            DT_PARALLEL_MODEM != nDeviceType)
            {
            bRet = FALSE;
            }
        break;

    default:
        ASSERT(0);
        break;
        }

    return bRet;
    }



/*----------------------------------------------------------
Purpose: Return the tic corresponding to bit flag value
Returns: tic index
Cond:    --
*/
int PRIVATE MapVolumeToTic(
    PCPLGEN this)
    {
    DWORD dwVolume = this->pmi->ms.dwSpeakerVolume;
    DWORD dwMode = this->pmi->ms.dwSpeakerMode;
    int   i;

    ASSERT(ARRAY_ELEMENTS(this->tics) > this->ticVolumeMax);
    for (i = 0; i <= this->ticVolumeMax; i++)
        {
        if (this->tics[i].dwVolume == dwVolume &&
            this->tics[i].dwMode   == dwMode)
            {
            return i;
            }
        }

    return 0;
    }


/*----------------------------------------------------------
Purpose: Set the volume control
Returns: --
Cond:    --
*/
void PRIVATE CplGen_SetVolume(
    PCPLGEN this)
{
    HWND hwndVol = GetDlgItem(this->hdlg, IDC_VOLUME);
    DWORD dwMode = this->pmi->devcaps.dwSpeakerMode;
    DWORD dwVolume = this->pmi->devcaps.dwSpeakerVolume;
    TCHAR sz[MAXSHORTLEN];
    int i;
    int iTicCount;
    static struct
    {
        DWORD dwVolBit;
        DWORD dwVolSetting;
    } rgvolumes[] = { 
            { MDMVOLFLAG_LOW,    MDMVOL_LOW},
            { MDMVOLFLAG_MEDIUM, MDMVOL_MEDIUM},
            { MDMVOLFLAG_HIGH,   MDMVOL_HIGH} };

    // Does the modem support volume control?
    if (0 == dwVolume && IsFlagSet(dwMode, MDMSPKRFLAG_OFF) &&
        (IsFlagSet(dwMode, MDMSPKRFLAG_ON) || IsFlagSet(dwMode, MDMSPKRFLAG_DIAL)))
    {
        // Set up the volume tic table.
        iTicCount = 2;
        this->tics[0].dwVolume = 0;  // doesn't matter because Volume isn't supported
        this->tics[0].dwMode   = MDMSPKR_OFF;
        this->tics[1].dwVolume = 0;  // doesn't matter because Volume isn't supported
        this->tics[1].dwMode   = IsFlagSet(dwMode, MDMSPKRFLAG_DIAL) ? MDMSPKR_DIAL : MDMSPKR_ON;

        // No Loud.  So change it to On.
        Static_SetText(GetDlgItem(this->hdlg, IDC_LOUD), SzFromIDS(g_hinst, IDS_ON, sz, SIZECHARS(sz)));
    }
    else
    {
        DWORD dwOnMode = IsFlagSet(dwMode, MDMSPKRFLAG_DIAL) 
                             ? MDMSPKR_DIAL
                             : IsFlagSet(dwMode, MDMSPKRFLAG_ON)
                                   ? MDMSPKR_ON
                                   : 0;

        // Init tic count
        iTicCount = 0;

        // MDMSPKR_OFF?
        if (IsFlagSet(dwMode, MDMSPKRFLAG_OFF))
        {
            for (i = 0; i < ARRAY_ELEMENTS(rgvolumes); i++)
            {
                if (IsFlagSet(dwVolume, rgvolumes[i].dwVolBit))
                {
                    this->tics[iTicCount].dwVolume = rgvolumes[i].dwVolSetting;
                    break;
                }
            }
            this->tics[iTicCount].dwMode   = MDMSPKR_OFF;
            iTicCount++;
        }
        else
        {
            // No Off.  So change it to Soft.
            Static_SetText(GetDlgItem(this->hdlg, IDC_LBL_OFF), SzFromIDS(g_hinst, IDS_SOFT, sz, SIZECHARS(sz)));
        }

        // MDMVOL_xxx?
        for (i = 0; i < ARRAY_ELEMENTS(rgvolumes); i++)
        {
            if (IsFlagSet(dwVolume, rgvolumes[i].dwVolBit))
            {
                this->tics[iTicCount].dwVolume = rgvolumes[i].dwVolSetting;
                this->tics[iTicCount].dwMode   = dwOnMode;
                iTicCount++;
            }
        }
    }

    // Set up the control.
    if (iTicCount > 0)
    {
        this->ticVolumeMax = iTicCount - 1;

        // Set the range
        SendMessage(hwndVol, TBM_SETRANGE, TRUE, MAKELPARAM(0, this->ticVolumeMax));

        // Set the volume to the current setting
        this->ticVolume = MapVolumeToTic(this);
        SendMessage(hwndVol, TBM_SETPOS, TRUE, MAKELPARAM(this->ticVolume, 0));
    }
    else
    {
        // No; disable the control
        EnableWindow(GetDlgItem(this->hdlg, IDC_SPEAKER), FALSE);
        EnableWindow(hwndVol, FALSE);
        EnableWindow(GetDlgItem(this->hdlg, IDC_LBL_OFF), FALSE);
        EnableWindow(GetDlgItem(this->hdlg, IDC_LOUD), FALSE);
    }
}


/*----------------------------------------------------------
Purpose: Set the speed controls
Returns: --
Cond:    --
*/
void PRIVATE CplGen_SetSpeed(
    PCPLGEN this)
    {
    HWND hwndCB = GetDlgItem(this->hdlg, IDC_CB_SPEED);
    HWND hwndCH = GetDlgItem(this->hdlg, IDC_STRICTSPEED);
    WIN32DCB FAR * pdcb = &this->pmi->dcb;
    DWORD dwDTEMax = this->pmi->devcaps.dwMaxDTERate;

    int n;
    int iMatch = -1;
    TCHAR sz[MAXMEDLEN];
    const BAUDS *pBaud = c_rgbauds;


    // Fill the listbox
    SetWindowRedraw(hwndCB, FALSE);
    ComboBox_ResetContent(hwndCB);
    for (; pBaud->dwDTERate; pBaud++)
        {
        // Only fill up to the max DTE speed of the modem
        if (pBaud->dwDTERate <= dwDTEMax)
            {
            n = ComboBox_AddString(
                    hwndCB,
                    SzFromIDS(g_hinst, pBaud->ids, sz, SIZECHARS(sz))
                    );

            ComboBox_SetItemData(hwndCB, n, pBaud->dwDTERate);

            // Keep our eyes peeled for important values
            if (this->pmi->pglobal->dwMaximumPortSpeedSetByUser == pBaud->dwDTERate)
                {
                iMatch = n;
                }
            }
        else
            break;
        }

    // Is the DCB baudrate >= the maximum possible DTE rate?
    if (pdcb->BaudRate >= dwDTEMax || -1 == iMatch)
        {
        // Yes; choose the highest possible (last) entry
        this->iSelOriginal = ComboBox_GetCount(hwndCB) - 1;
        }
    else 
        {
        // No; choose the matched value
        ASSERT(-1 != iMatch);
        this->iSelOriginal = iMatch;
        }
    ComboBox_SetCurSel(hwndCB, this->iSelOriginal);
    SetWindowRedraw(hwndCB, TRUE);

    // Can this modem adjust speed?
    if (IsFlagClear(this->pmi->devcaps.dwModemOptions, MDM_SPEED_ADJUST))
        {
        // No; disable the checkbox and check it
        Button_Enable(hwndCH, FALSE);
        Button_SetCheck(hwndCH, FALSE);
        }
    else
        {
        // Yes; enable the checkbox
        Button_Enable(hwndCH, TRUE);
        Button_SetCheck(hwndCH, IsFlagClear(this->pmi->ms.dwPreferredModemOptions, MDM_SPEED_ADJUST));
        }
    }


/*----------------------------------------------------------
Purpose: WM_INITDIALOG Handler
Returns: FALSE when we assign the control focus
Cond:    --
*/
BOOL PRIVATE CplGen_OnInitDialog(
    PCPLGEN this,
    HWND hwndFocus,
    LPARAM lParam)              // expected to be PROPSHEETINFO 
    {
    LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
    HWND hdlg = this->hdlg;
    HWND hwndIcon;
    UINT idi;
    UINT ids;
    DWORD dwOptions;
    DWORD dwCapOptions;
    
    MYASSERT(VALID_CPLGEN(this));
    ASSERT((LPTSTR)lppsp->lParam);

    this->pmi = (LPMODEMINFO)lppsp->lParam;
    this->hwndWait = GetDlgItem(hdlg, IDC_WAITFORDIALTONE);
    dwOptions = this->pmi->ms.dwPreferredModemOptions;
    dwCapOptions = this->pmi->devcaps.dwModemOptions;

    Button_Enable(this->hwndWait, IsFlagSet(dwCapOptions, MDM_BLIND_DIAL));

    Button_SetCheck(this->hwndWait, IsFlagSet(dwCapOptions, MDM_BLIND_DIAL) && 
                                    IsFlagClear(dwOptions, MDM_BLIND_DIAL));

    this->hwndPort = GetDlgItem(hdlg, IDC_PORT_TEXT);
    //Edit_SetText(this->hwndPort, this->pmi->szPortName);

    CplGen_SetVolume(this);
    // Speed is set in CplGen_OnSetActive

    // Is this a parallel port?
    if (DT_PARALLEL_PORT == this->pmi->nDeviceType)
        {
        // Yes; hide the speed controls
        ShowWindow(GetDlgItem(hdlg, IDC_SPEED), SW_HIDE);
        EnableWindow(GetDlgItem(hdlg, IDC_SPEED), FALSE);

        ShowWindow(GetDlgItem(hdlg, IDC_CB_SPEED), SW_HIDE);
        EnableWindow(GetDlgItem(hdlg, IDC_CB_SPEED), FALSE);

        ShowWindow(GetDlgItem(hdlg, IDC_STRICTSPEED), SW_HIDE);
        EnableWindow(GetDlgItem(hdlg, IDC_STRICTSPEED), FALSE);
        }

    return TRUE;   // default initial focus
    }


/*----------------------------------------------------------
Purpose: WM_HSCROLL handler
Returns: --
Cond:    --
*/
void PRIVATE CplGen_OnHScroll(
    PCPLGEN this,
    HWND hwndCtl,
    UINT code,
    int pos)
    {
    // Handle for the volume control
    if (hwndCtl == GetDlgItem(this->hdlg, IDC_VOLUME))
        {
        int tic = this->ticVolume;

        switch (code)
            {
        case TB_LINEUP:
            tic--;
            break;

        case TB_LINEDOWN:
            tic++;
            break;

        case TB_PAGEUP:
            tic--;
            break;

        case TB_PAGEDOWN:
            tic++;
            break;

        case TB_THUMBPOSITION:
        case TB_THUMBTRACK:
            tic = pos;
            break;

        case TB_TOP:
            tic = 0;
            break;

        case TB_BOTTOM:
            tic = this->ticVolumeMax;
            break;

        case TB_ENDTRACK:
            return;
            }

        // Boundary check
        if (tic < 0)
            tic = 0;
        else if (tic > (this->ticVolumeMax))
            tic = this->ticVolumeMax;

        /*if (tic != this->ticVolume)
            {
            SendMessage(hwndCtl, TBM_SETPOS, TRUE, MAKELPARAM(tic, 0));
            }*/
        this->ticVolume = tic;
        }
    }


/*----------------------------------------------------------
Purpose: PSN_APPLY handler
Returns: --
Cond:    --
*/
void PRIVATE CplGen_OnApply(
    PCPLGEN this)
    {
    HWND hwndCB = GetDlgItem(this->hdlg, IDC_CB_SPEED);
    LPMODEMSETTINGS pms = &this->pmi->ms;
    int iSel;
    DWORD baudSel;


    // (The port name is saved in PSN_KILLACTIVE processing)

    // Determine new volume settings
    this->pmi->ms.dwSpeakerMode   = this->tics[this->ticVolume].dwMode;
    this->pmi->ms.dwSpeakerVolume = this->tics[this->ticVolume].dwVolume;

    // Determine new speed settings
    iSel = ComboBox_GetCurSel(hwndCB);
    baudSel = (DWORD)ComboBox_GetItemData(hwndCB, iSel);

    // Has the user changed the speed?
    if (iSel != this->iSelOriginal)
    {
        this->pmi->pglobal->dwMaximumPortSpeedSetByUser = baudSel;      // yes
    }

    if (Button_GetCheck(GetDlgItem(this->hdlg, IDC_WAITFORDIALTONE)))
        ClearFlag(pms->dwPreferredModemOptions, MDM_BLIND_DIAL);
    else
        SetFlag(pms->dwPreferredModemOptions, MDM_BLIND_DIAL);

    this->pmi->idRet = IDOK;
    }


/*----------------------------------------------------------
Purpose: PSN_KILLACTIVE handler
Returns: --
Cond:    --
*/
void PRIVATE CplGen_OnSetActive(
    PCPLGEN this)
    {
    Edit_SetText(this->hwndPort, this->pmi->szPortName);
    // Set the speed listbox selection; find DCB rate in the listbox
    // (The speed can change in the Connection page thru the Port Settings
    // property dialog.)
    CplGen_SetSpeed(this);
    }


/*----------------------------------------------------------
Purpose: PSN_KILLACTIVE handler
Returns: --
Cond:    --
*/
void PRIVATE CplGen_OnKillActive(
    PCPLGEN this)
{
    HWND hwndCB = GetDlgItem(this->hdlg, IDC_CB_SPEED);
    int iSel;

    // Save the settings back to the modem info struct so the Connection
    // page can invoke the Port Settings property dialog with the 
    // correct settings.

    // Speed setting
    iSel = ComboBox_GetCurSel(hwndCB);
    this->pmi->pglobal->dwMaximumPortSpeedSetByUser = (DWORD)ComboBox_GetItemData(hwndCB, iSel);
    if (this->pmi->dcb.BaudRate > this->pmi->pglobal->dwMaximumPortSpeedSetByUser)
    {
        this->pmi->dcb.BaudRate = this->pmi->pglobal->dwMaximumPortSpeedSetByUser;
    }
}


/*----------------------------------------------------------
Purpose: WM_NOTIFY handler
Returns: varies
Cond:    --
*/
LRESULT PRIVATE CplGen_OnNotify(
    PCPLGEN this,
    int idFrom,
    NMHDR FAR * lpnmhdr)
    {
    LRESULT lRet = 0;
    
    switch (lpnmhdr->code)
        {
    case PSN_SETACTIVE:
        CplGen_OnSetActive(this);
        break;

    case PSN_KILLACTIVE:
        // N.b. This message is not sent if user clicks Cancel!
        // N.b. This message is sent prior to PSN_APPLY
        CplGen_OnKillActive(this);
        break;

    case PSN_APPLY:
        CplGen_OnApply(this);
        break;

    default:
        break;
        }

    return lRet;
    }


/*----------------------------------------------------------
Purpose: WM_COMMAND Handler
Returns: --
Cond:    --
*/
void 
PRIVATE 
CplGen_OnCommand(
    IN PCPLGEN this,
    IN int  id,
    IN HWND hwndCtl,
    IN UINT uNotifyCode)
{
    switch (id) 
    {
        case IDC_CB_SPEED:
            if (CBN_SELCHANGE == uNotifyCode)
            {
             int iSel;
             DWORD baudSel;

                iSel = ComboBox_GetCurSel(hwndCtl);
                baudSel = (DWORD)ComboBox_GetItemData(hwndCtl, iSel);
                this->pmi->dcb.BaudRate = baudSel;
            }
            break;
    }
}


/*----------------------------------------------------------
Purpose: WM_DESTROY handler
Returns: --
Cond:    --
*/
void PRIVATE CplGen_OnDestroy(
    PCPLGEN this)
    {
    }


/*----------------------------------------------------------
Purpose: WM_COMMAND Handler
Returns: --
Cond:    --
*/



/////////////////////////////////////////////////////  EXPORTED FUNCTIONS

static BOOL s_bCplGenRecurse = FALSE;

LRESULT INLINE CplGen_DefProc(
    HWND hDlg, 
    UINT msg,
    WPARAM wParam,
    LPARAM lParam) 
    {
    ENTER_X()
        {
        s_bCplGenRecurse = TRUE;
        }
    LEAVE_X()

    return DefDlgProc(hDlg, msg, wParam, lParam); 
    }


/*----------------------------------------------------------
Purpose: Real dialog proc
Returns: varies
Cond:    --
*/
LRESULT CplGen_DlgProc(
    PCPLGEN this,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
    {
    switch (message)
        {
        HANDLE_MSG(this, WM_INITDIALOG, CplGen_OnInitDialog);
        HANDLE_MSG(this, WM_HSCROLL, CplGen_OnHScroll);
        HANDLE_MSG(this, WM_NOTIFY, CplGen_OnNotify);
        HANDLE_MSG(this, WM_DESTROY, CplGen_OnDestroy);
        HANDLE_MSG(this, WM_COMMAND, CplGen_OnCommand);

    case WM_HELP:
        WinHelp(((LPHELPINFO)lParam)->hItemHandle, c_szWinHelpFile, HELP_WM_HELP, (ULONG_PTR)(LPVOID)g_aHelpIDs_IDD_GENERAL);
        return 0;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, c_szWinHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPVOID)g_aHelpIDs_IDD_GENERAL);
        return 0;

    default:
        return CplGen_DefProc(this->hdlg, message, wParam, lParam);
        }
    }


/*----------------------------------------------------------
Purpose: Dialog Wrapper
Returns: varies
Cond:    --
*/
INT_PTR CALLBACK CplGen_WrapperProc(
    HWND hDlg,          // std params
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
    {
    PCPLGEN this;

    // Cool windowsx.h dialog technique.  For full explanation, see
    //  WINDOWSX.TXT.  This supports multiple-instancing of dialogs.
    //
    ENTER_X()
        {
        if (s_bCplGenRecurse)
            {
            s_bCplGenRecurse = FALSE;
            LEAVE_X()
            return FALSE;
            }
        }
    LEAVE_X()

    this = CplGen_GetPtr(hDlg);
    if (this == NULL)
        {
        if (message == WM_INITDIALOG)
            {
            this = (PCPLGEN)ALLOCATE_MEMORY( sizeof(CPLGEN));
            if (!this)
                {
                MsgBox(g_hinst,
                       hDlg, 
                       MAKEINTRESOURCE(IDS_OOM_GENERAL), 
                       MAKEINTRESOURCE(IDS_CAP_GENERAL),
                       NULL,
                       MB_ERROR);
                EndDialog(hDlg, IDCANCEL);
                return (BOOL)CplGen_DefProc(hDlg, message, wParam, lParam);
                }
            this->dwSig = SIG_CPLGEN;
            this->hdlg = hDlg;
            CplGen_SetPtr(hDlg, this);
            }
        else
            {
            return (BOOL)CplGen_DefProc(hDlg, message, wParam, lParam);
            }
        }

    if (message == WM_DESTROY)
        {
        CplGen_DlgProc(this, message, wParam, lParam);
        this->dwSig = 0;
        FREE_MEMORY((HLOCAL)OFFSETOF(this));
        CplGen_SetPtr(hDlg, NULL);
        return 0;
        }

    return SetDlgMsgResult(hDlg, message, CplGen_DlgProc(this, message, wParam, lParam));
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\modemui\cplisdn.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1998
//
// File: cplisdn.c
//
// This files contains the dialog code for the ISDN page
// of the modem properties.
//
// History:
//  1/23/1998 JosephJ Created
//
//---------------------------------------------------------------------------


/////////////////////////////////////////////////////  INCLUDES

#include "proj.h"         // common headers
#include "cplui.h"         // common headers

#define USPROP  fISDN_SWITCHPROP_US
#define MSNPROP fISDN_SWITCHPROP_MSN
#define EAZPROP fISDN_SWITCHPROP_EAZ
#define ONECH   fISDN_SWITCHPROP_1CH

/////////////////////////////////////////////////////  CONTROLLING DEFINES

/////////////////////////////////////////////////////  TYPEDEFS

#define SIG_CPLISDN 0xf6b2ea13

typedef struct
{
    DWORD dwSig;            // Must be set to SIG_CPLISDN
    HWND  hdlg;             // dialog handle
    HWND  hwndCB_ST;        // switch type
    HWND  hwndEB_Number1;   // 1st Number
    HWND  hwndEB_ID1;       // 1st ID
    HWND  hwndEB_Number2;   // 2nd Number
    HWND  hwndEB_ID2;       // 2nd ID

    LPMODEMINFO pmi;        // modeminfo struct passed into dialog

} CPLISDN, FAR * PCPLISDN;

#define VALID_CPLISDN(_pcplgen)  ((_pcplgen)->dwSig == SIG_CPLISDN)

ISDN_STATIC_CONFIG *
ConstructISDNStaticConfigFromDlg(
                        PCPLISDN this
                        );

// This is the structure that is used to fill the stopbits listbox
static LBMAP s_rgISDNSwitchType[] =
{
    { dwISDN_SWITCH_ATT1, IDS_ISDN_SWITCH_ATT1    },
    { dwISDN_SWITCH_ATT_PTMP, IDS_ISDN_SWITCH_ATT_PTMP    },
    { dwISDN_SWITCH_NI1, IDS_ISDN_SWITCH_NI1      },
    { dwISDN_SWITCH_DMS100, IDS_ISDN_SWITCH_DMS100},
    { dwISDN_SWITCH_INS64, IDS_ISDN_SWITCH_INS64  },
    { dwISDN_SWITCH_DSS1, IDS_ISDN_SWITCH_DSS1    },
    { dwISDN_SWITCH_1TR6, IDS_ISDN_SWITCH_1TR6    },
    { dwISDN_SWITCH_VN3, IDS_ISDN_SWITCH_VN3      },
    { dwISDN_SWITCH_BELGIUM1, IDS_ISDN_SWITCH_BELGIUM1},
    { dwISDN_SWITCH_AUS1, IDS_ISDN_SWITCH_AUS1    },
    { dwISDN_SWITCH_UNKNOWN, IDS_ISDN_SWITCH_UNKNOWN    },

    { 0,   0   }
};

DWORD SelectISDNSwitchType(
            DWORD dwValue,
            void *pvContext
            );

UINT GetNumEntries(
      IN  DWORD dwSwitchProps,
      IN  ISDN_STATIC_CAPS *pCaps,
      OUT BOOL *pfSetID
      );

void InitSpidEaz (PCPLISDN this);


PCPLISDN CplISDN_GetPtr(HWND hwnd)
{
    PCPLISDN pCplISDN = (PCPLISDN) GetWindowLongPtr(hwnd, DWLP_USER);
    if (!pCplISDN || VALID_CPLISDN(pCplISDN))
    {
        return pCplISDN;
    }
    else
    {
        MYASSERT(FALSE);
        return NULL;
    }
}

void CplISDN_SetPtr(HWND hwnd, PCPLISDN pCplISDN)
{
    if (pCplISDN && !VALID_CPLISDN(pCplISDN))
    {
        MYASSERT(FALSE);
        pCplISDN = NULL;
    }
   
    SetWindowLongPtr(hwnd, DWLP_USER, (ULONG_PTR) pCplISDN);
}


LRESULT PRIVATE CplISDN_OnNotify(
    PCPLISDN this,
    int idFrom,
    NMHDR FAR * lpnmhdr);

void PRIVATE CplISDN_OnSetActive(
    PCPLISDN this);

void PRIVATE CplISDN_OnKillActive(
    PCPLISDN this);
    



//------------------------------------------------------------------------------
//  Advanced Settings dialog code
//------------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: WM_INITDIALOG Handler
Returns: FALSE when we assign the control focus
Cond:    --
*/
BOOL PRIVATE CplISDN_OnInitDialog(
    PCPLISDN this,
    HWND hwndFocus,
    LPARAM lParam)              // expected to be PROPSHEETINFO 
{

    HWND hwnd = this->hdlg;
    LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
    ISDN_STATIC_CONFIG *pConfig = NULL;

    ASSERT((LPTSTR)lppsp->lParam);
    this->pmi = (LPMODEMINFO)lppsp->lParam;
    pConfig = this->pmi->pglobal->pIsdnStaticConfig;
        
    this->hwndCB_ST     = GetDlgItem(hwnd, IDC_CB_ISDN_ST);
    this->hwndEB_Number1 = GetDlgItem(hwnd, IDC_EB_ISDN_N1);
    this->hwndEB_ID1     = GetDlgItem(hwnd, IDC_EB_ISDN_ID1);
    this->hwndEB_Number2 = GetDlgItem(hwnd, IDC_EB_ISDN_N2);
    this->hwndEB_ID2     = GetDlgItem(hwnd, IDC_EB_ISDN_ID2);

    if (pConfig->dwNumEntries)
    {
        BOOL fSetID=FALSE;
        char *sz=NULL;

        Edit_LimitText(this->hwndEB_Number1, LINE_LEN-1);
        Edit_LimitText(this->hwndEB_ID1, LINE_LEN-1);
        Edit_LimitText(this->hwndEB_Number2, LINE_LEN-1);
        Edit_LimitText(this->hwndEB_ID2, LINE_LEN-1);
    
        if (pConfig->dwSwitchProperties & (USPROP|EAZPROP))
        {
            fSetID=TRUE;
        }

        if (pConfig->dwNumberListOffset)
        {
            // get the 1st number
            sz =  ISDN_NUMBERS_FROM_CONFIG(pConfig);
            //Edit_SetTextA(this->hwndEB_Number1, sz);
            SetWindowTextA(this->hwndEB_Number1, sz);

            if (pConfig->dwNumEntries>1)
            {
                // get the 2nd number
                sz += lstrlenA(sz)+1;
                // Edit_SetTextA(this->hwndEB_Number2, sz);
                SetWindowTextA(this->hwndEB_Number2, sz);
            }
            else
            {
                EnableWindow(this->hwndEB_Number2, FALSE);
            }
        }

        if (fSetID)
        {
            if (pConfig->dwIDListOffset)
            {
                // get the 1st number
                sz =  ISDN_IDS_FROM_CONFIG(pConfig);
                //Edit_SetTextA(this->hwndEB_ID1, sz);
                SetWindowTextA(this->hwndEB_ID1, sz);
    
                if (pConfig->dwNumEntries>1)
                {
                    // get the 2nd number
                    sz += lstrlenA(sz)+1;
                    //Edit_SetTextA(this->hwndEB_ID2, sz);
                    SetWindowTextA(this->hwndEB_ID2, sz);
                }
                else
                {
                    EnableWindow(this->hwndEB_ID2, FALSE);
                }
            }
        }
        else
        {
            EnableWindow(this->hwndEB_ID1, FALSE);
            EnableWindow(this->hwndEB_ID2, FALSE);
        }

    }

    // Fill switch type list box...
    LBMapFill(
            this->hwndCB_ST,
            s_rgISDNSwitchType,
            SelectISDNSwitchType,
            this
            );

    InitSpidEaz (this);

    return TRUE;   // let USER set the initial focus
}


/*----------------------------------------------------------
Purpose: PSN_APPLY handler
Returns: --
Cond:    --
*/
void PRIVATE CplISDN_OnApply(
    PCPLISDN this)
{
    BOOL fConfigChanged = FALSE;
    ISDN_STATIC_CONFIG * pConfig =  ConstructISDNStaticConfigFromDlg(this);

    if (pConfig)
    {
        ISDN_STATIC_CONFIG * pOldConfig = this->pmi->pglobal->pIsdnStaticConfig;
        if (pOldConfig)
        {
            if (   (pOldConfig->dwTotalSize != pConfig->dwTotalSize)
                || memcmp(pOldConfig, pConfig, pConfig->dwTotalSize))
            {
                // ISDN config has changed...
                fConfigChanged = TRUE;
            }

            // do a final validation of the configuration...

            FREE_MEMORY(pOldConfig);
            pOldConfig=NULL;
        }
        else
        {
            // hmm... old config didn't exist ?!
            fConfigChanged = TRUE;
        }

        if (fConfigChanged)
        {
            SetFlag(this->pmi->uFlags,  MIF_ISDN_CONFIG_CHANGED);
        }

        this->pmi->pglobal->pIsdnStaticConfig = pConfig;
    }

    this->pmi->idRet = IDOK;
}


/*----------------------------------------------------------
Purpose: WM_COMMAND Handler
Returns: --
Cond:    --
*/
void PRIVATE CplISDN_OnCommand(
    PCPLISDN this,
    int id,
    HWND hwndCtl,
    UINT uNotifyCode)
{
    switch (id)
    {
        case IDOK:
            CplISDN_OnApply(this);
            // Fall thru
            //   |   |
            //   v   v
        case IDCANCEL:
            EndDialog(this->hdlg, id);
            break;

        case  IDC_CB_ISDN_ST:

            if (uNotifyCode == CBN_SELENDOK)
            {
                InitSpidEaz (this);
            }
            break;

        default:
            break;
    }
}


/*----------------------------------------------------------
Purpose: WM_DESTROY handler
Returns: --
Cond:    --
*/
void PRIVATE CplISDN_OnDestroy(
    PCPLISDN this)
{
}


/////////////////////////////////////////////////////  EXPORTED FUNCTIONS

static BOOL s_bCplISDNRecurse = FALSE;

LRESULT INLINE CplISDN_DefProc(
    HWND hDlg, 
    UINT msg,
    WPARAM wParam,
    LPARAM lParam) 
{
    ENTER_X()
        {
        s_bCplISDNRecurse = TRUE;
        }
    LEAVE_X()

    return DefDlgProc(hDlg, msg, wParam, lParam); 
}


/*----------------------------------------------------------
Purpose: Real dialog proc
Returns: varies
Cond:    --
*/
LRESULT CplISDN_DlgProc(
    PCPLISDN this,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (message)
        {
        HANDLE_MSG(this, WM_INITDIALOG, CplISDN_OnInitDialog);
        HANDLE_MSG(this, WM_COMMAND, CplISDN_OnCommand);
        HANDLE_MSG(this, WM_NOTIFY,  CplISDN_OnNotify);
        HANDLE_MSG(this, WM_DESTROY, CplISDN_OnDestroy);

    case WM_HELP:
        WinHelp(((LPHELPINFO)lParam)->hItemHandle, c_szWinHelpFile, HELP_WM_HELP, (ULONG_PTR)(LPVOID)g_aHelpIDs_IDD_CPL_ISDN);
        return 0;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, c_szWinHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPVOID)g_aHelpIDs_IDD_CPL_ISDN);
        return 0;

    default:
        return CplISDN_DefProc(this->hdlg, message, wParam, lParam);
        }
}


/*----------------------------------------------------------
Purpose: Dialog Wrapper
Returns: varies
Cond:    --
*/
INT_PTR CALLBACK CplISDN_WrapperProc(
    HWND hDlg,          // std params
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PCPLISDN this;

    // Cool windowsx.h dialog technique.  For full explanation, see
    //  WINDOWSX.TXT.  This supports multiple-instancing of dialogs.
    //
    ENTER_X()
    {
        if (s_bCplISDNRecurse)
        {
            s_bCplISDNRecurse = FALSE;
            LEAVE_X()
            return FALSE;
        }
    }
    LEAVE_X()

    this = CplISDN_GetPtr(hDlg);
    if (this == NULL)
    {
        if (message == WM_INITDIALOG)
        {
            this = (PCPLISDN)ALLOCATE_MEMORY( sizeof(CPLISDN));
            if (!this)
            {
                MsgBox(g_hinst,
                       hDlg, 
                       MAKEINTRESOURCE(IDS_OOM_SETTINGS), 
                       MAKEINTRESOURCE(IDS_CAP_SETTINGS),
                       NULL,
                       MB_ERROR);
                EndDialog(hDlg, IDCANCEL);
                return (BOOL)CplISDN_DefProc(hDlg, message, wParam, lParam);
            }
            this->dwSig = SIG_CPLISDN;
            this->hdlg = hDlg;
            CplISDN_SetPtr(hDlg, this);
        }
        else
        {
            return (BOOL)CplISDN_DefProc(hDlg, message, wParam, lParam);
        }
    }

    if (message == WM_DESTROY)
    {
        CplISDN_DlgProc(this, message, wParam, lParam);
        FREE_MEMORY((HLOCAL)OFFSETOF(this));
        CplISDN_SetPtr(hDlg, NULL);
        return 0;
    }

    return SetDlgMsgResult(
                hDlg,
                message,
                CplISDN_DlgProc(this, message, wParam, lParam)
                );
}


LRESULT PRIVATE CplISDN_OnNotify(
    PCPLISDN this,
    int idFrom,
    NMHDR FAR * lpnmhdr)
{
    LRESULT lRet = 0;
    
    switch (lpnmhdr->code)
    {
    case PSN_SETACTIVE:
        CplISDN_OnSetActive(this);
        break;

    case PSN_KILLACTIVE:
        // N.b. This message is not sent if user clicks Cancel!
        // N.b. This message is sent prior to PSN_APPLY
        CplISDN_OnKillActive(this);
        break;

    case PSN_APPLY:
        CplISDN_OnApply(this);
        break;

    default:
        break;
    }

    return lRet;
}

void PRIVATE CplISDN_OnSetActive(
    PCPLISDN this)
{
    // Init any display ....
}


/*----------------------------------------------------------
Purpose: PSN_KILLACTIVE handler
Returns: --
Cond:    --
*/
void PRIVATE CplISDN_OnKillActive(
    PCPLISDN this)
{

    // CplISDN_OnApply(this);
    // Save the settings back to the modem info struct so the Connection
    // page can invoke the Port Settings property dialog with the 
    // correct settings.

}


DWORD SelectISDNSwitchType(
            DWORD dwValue,
            void *pvContext
            )
{
    PCPLISDN this = (PCPLISDN) pvContext;
    DWORD dwRet = 0;
    BOOL fSelected = FALSE;
    BOOL fAvailable = FALSE;
    ISDN_STATIC_CAPS *pCaps = this->pmi->pglobal->pIsdnStaticCaps;
    ISDN_STATIC_CONFIG *pConfig = this->pmi->pglobal->pIsdnStaticConfig;
    UINT u =  pCaps->dwNumSwitchTypes;
    DWORD *pdwType =  (DWORD*)(((BYTE*)pCaps)+pCaps->dwSwitchTypeOffset);
    DWORD dwSelectedType =  pConfig->dwSwitchType;

    // check to see if this switch type is available...
    while(u--)
    {
        if (*pdwType++==dwValue)
        {
            fAvailable = TRUE;
            if (dwSelectedType == dwValue)
            {
                fSelected=TRUE;
            }
            break;
        }
    }
    

    if (fAvailable)
    {
        dwRet = fLBMAP_ADD_TO_LB;
        if (fSelected)
        {
            dwRet |= fLBMAP_SELECT;
        }
    }

    return dwRet;
}


ISDN_STATIC_CONFIG *
ConstructISDNStaticConfigFromDlg(
                        PCPLISDN this
                        )
{
    DWORD dwSwitchType=0;
    DWORD dwSwitchProps=0;
    DWORD dwNumEntries=0;
    BOOL fSetID=FALSE;
    DWORD dwTotalSize = 0;
    char Number1[LINE_LEN];
    char Number2[LINE_LEN];
    char ID1[LINE_LEN];
    char ID2[LINE_LEN];
    UINT cbNumber1=0;
    UINT cbNumber2=0;
    UINT cbID1=0;
    UINT cbID2=0;

    ISDN_STATIC_CAPS *pCaps = this->pmi->pglobal->pIsdnStaticCaps;
    ISDN_STATIC_CONFIG *pConfig = NULL;

    if (!pCaps) goto end;

    dwSwitchType = (DWORD)ComboBox_GetItemData(
                            this->hwndCB_ST,
                            ComboBox_GetCurSel(this->hwndCB_ST)
                            );

    dwSwitchProps =  GetISDNSwitchTypeProps(dwSwitchType);

    dwNumEntries= GetNumEntries(
                          dwSwitchProps,
                          pCaps,
                          &fSetID
                          );


    cbNumber1 = 1+GetWindowTextA(this->hwndEB_Number1, Number1,sizeof(Number1));
    cbID1     = 1+GetWindowTextA(this->hwndEB_ID1, ID1, sizeof(ID1));

    if (dwNumEntries==2)
    {
        cbNumber2 = 1+GetWindowTextA(
                            this->hwndEB_Number2,
                            Number2,
                            sizeof(Number2)
                            );
        cbID2     = 1+GetWindowTextA(this->hwndEB_ID2, ID2, sizeof(ID2));
    }

    // Compute total size
    dwTotalSize = sizeof(*pConfig);
    dwTotalSize += 1+cbNumber1+cbNumber2; // for numbers.
    if (fSetID)
    {
        dwTotalSize += 1+cbID1+cbID2; // for IDs.
    }


    // Round up to multiple of DWORDs
    dwTotalSize += 3;
    dwTotalSize &= ~3;

    pConfig = ALLOCATE_MEMORY( dwTotalSize);

    if (pConfig == NULL) {

        goto end;
    }

    pConfig->dwSig       = dwSIG_ISDN_STATIC_CONFIGURATION;
    pConfig->dwTotalSize = dwTotalSize;
    pConfig->dwSwitchType = dwSwitchType;
    pConfig->dwSwitchProperties = dwSwitchProps;

    pConfig->dwNumEntries = dwNumEntries;
    pConfig->dwNumberListOffset = sizeof(*pConfig);

    // add the numbers
    if (cbNumber1 > 1)
    {
        BYTE *pb =  ISDN_NUMBERS_FROM_CONFIG(pConfig);
        CopyMemory(pb,Number1, cbNumber1);

        if (dwNumEntries>1)
        {
            pb+=cbNumber1;
            CopyMemory(pb,Number2, cbNumber2);
        }
    }

    // add the IDs, if required
    //
    if (fSetID)
    {
        BYTE *pb =  NULL;
        pConfig->dwIDListOffset = pConfig->dwNumberListOffset
                                  + 1+cbNumber1+cbNumber2;

        // note:following macro assumes dwIDLIstOffset is already set.
        pb =  ISDN_IDS_FROM_CONFIG(pConfig);
        CopyMemory(pb,ID1, cbID1);

        if (dwNumEntries>1)
        {
            pb+=cbID1;
            CopyMemory(pb,ID2, cbID2);
        }
    }

end:

    return pConfig;
}


UINT GetNumEntries(
      IN  DWORD dwSwitchProps,
      IN  ISDN_STATIC_CAPS *pCaps,
      OUT BOOL *pfSetID
      )
{
    DWORD dwNumEntries = 0;
    BOOL fSetID = FALSE;

    if (!pCaps || !pfSetID) goto end;

    if (dwSwitchProps & USPROP)
    {
        dwNumEntries = pCaps->dwNumChannels;
        fSetID=TRUE;
    }
    else if (dwSwitchProps & MSNPROP)
    {
        dwNumEntries = pCaps->dwNumMSNs;
    }
    else if (dwSwitchProps & EAZPROP)
    {
        dwNumEntries = pCaps->dwNumEAZ;
        fSetID=TRUE;
    }

    //
    // Some switches only support one number/channel
    //
    if (dwSwitchProps & ONECH)
    {
        if (dwNumEntries>1)
        {
            dwNumEntries=1;
        }
    }

    // TODO: Our UI can't currently deal with more than 2
    if (dwNumEntries>2)
    {
        dwNumEntries=2;
    }

    *pfSetID = fSetID;

end:

    return dwNumEntries;

}


void InitSpidEaz (PCPLISDN this)
{
    TCHAR szTempBuf[LINE_LEN];
    int MaxLen;
    ISDN_STATIC_CONFIG *pConfig =
                         this->pmi->pglobal->pIsdnStaticConfig;
    UINT uSwitchType = (UINT)ComboBox_GetItemData(
                            this->hwndCB_ST,
                            ComboBox_GetCurSel(this->hwndCB_ST)
                            );

    BOOL fSetID=FALSE, fSetNumber=TRUE;
    UINT uNumEntries= GetNumEntries(
                          GetISDNSwitchTypeProps(uSwitchType),
                          this->pmi->pglobal->pIsdnStaticCaps,
                          &fSetID
                          );

    //
    // Set/clear the ID (spid/eaz) and number fields
    //

    switch (uSwitchType)
    {
        case dwISDN_SWITCH_1TR6:
            fSetNumber=FALSE;
            MaxLen = 2;
            break;

        case dwISDN_SWITCH_DMS100:
        case dwISDN_SWITCH_ATT1:
        case dwISDN_SWITCH_ATT_PTMP:
        case dwISDN_SWITCH_NI1:
            MaxLen = 20;
            break;

        case dwISDN_SWITCH_DSS1:
            MaxLen = 16;
            break;

        default:
            MaxLen = LINE_LEN-1;
    }

    if (uNumEntries)
    {
        //
        // Enable the 1st Number field.
        //
        if (fSetNumber)
        {
            EnableWindow(this->hwndEB_Number1, TRUE);
        }
        else
        {
            EnableWindow(this->hwndEB_Number1, FALSE);
        }

        if (fSetID)
        {
            //
            // Enable the 1st ID field.
            //
            EnableWindow(this->hwndEB_ID1, TRUE);
            Edit_GetText(this->hwndEB_ID1, szTempBuf, sizeof(szTempBuf)/sizeof(TCHAR));
            if (lstrlen (szTempBuf) > MaxLen)
            {
                Edit_SetText(this->hwndEB_ID1, TEXT(""));
            }
            Edit_LimitText(this->hwndEB_ID1, MaxLen);
        }
        else
        {
            //
            // Zap the 1st ID field.
            //
            SetWindowText(this->hwndEB_ID1, TEXT(""));
            EnableWindow(this->hwndEB_ID1, FALSE);
        }
    }
    else // no entries...
    {
        //
        // Zap the 1st ID and number field.
        //
        SetWindowText(this->hwndEB_ID1, TEXT(""));
        EnableWindow(this->hwndEB_ID1, FALSE);
        SetWindowText(this->hwndEB_Number1, TEXT(""));
        EnableWindow(this->hwndEB_Number1, FALSE);
    }

    if (uNumEntries>=2)
    {
        //
        // Enable the 2nd Number field.
        //
        if (fSetNumber)
        {
            EnableWindow(this->hwndEB_Number2, TRUE);
        }
        else
        {
            EnableWindow(this->hwndEB_Number2, FALSE);
        }

        if (fSetID)
        {
            //
            // Enable the 2nd ID field.
            //
            EnableWindow(this->hwndEB_ID2, TRUE);
            Edit_GetText(this->hwndEB_ID2, szTempBuf, sizeof(szTempBuf)/sizeof(TCHAR));
            if (lstrlen (szTempBuf) > MaxLen)
            {
                Edit_SetText(this->hwndEB_ID2, TEXT(""));
            }
            Edit_LimitText(this->hwndEB_ID2, MaxLen);
        }
        else
        {
            //
            // Zap the 2nd ID field.
            //
            SetWindowText(this->hwndEB_ID2, TEXT(""));
            EnableWindow(this->hwndEB_ID2, FALSE);
        }
    }
    else // < 2 entries
    {
        //
        // Zap the 2nd ID and number field.
        //
        SetWindowText(this->hwndEB_ID2, TEXT(""));
        EnableWindow(this->hwndEB_ID2, FALSE);
        SetWindowText(this->hwndEB_Number2, TEXT(""));
        EnableWindow(this->hwndEB_Number2, FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\unimodem\src\modemui\dlgids.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define MIDM_FIRST                      0x0000
#define MIDM_CLONE                      0
#define MIDM_REMOVE                     1
#define MIDM_VIEWLOG                    2
#define IDC_BN_DEFAULTS                 3
#define MIDM_PROPERTIES                 3
#define MIDM_COPYPROPERTIES             4
#define MIDM_APPLYPROPERTIES            5
#define POPUP_CONTEXT                   100
#define IDD_ADV_MODEM                   102
#define IDB_PATTERNS                    103
#define IDC_PROPERTIES                  109
#define IDC_ADD                         110
#define IDC_REMOVE                      112
#define IDC_MODEMLV                     113
#define IDD_GENERAL                     117
#define IDD_RING                        119
#define IDD_CHEAPRING                   121
#define IDD_DIAGNOSTICS                 122
#define IDD_DIAG_WAIT                   123
#define IDD_CFG_GENERAL                 128
#define IDD_CFG_ADVANCED                129
#define IDD_CPL_ISDN                    130
#define IDD_COUNTRY_WAIT                131
#define IDD_USERINIT                    132
#define IDS_NULL_MODEM                  180
#define IDS_EXTERNAL_MODEM              181
#define IDS_INTERNAL_MODEM              182
#define IDS_PCMCIA_MODEM                183
#define IDS_PARALLEL_MODEM              184
#define IDS_PARALLEL_PORT               185
#define IDS_BAUD_110                    200
#define IDS_BAUD_1200                   201
#define IDS_BAUD_2400                   202
#define IDS_BAUD_4800                   203
#define IDS_BAUD_9600                   204
#define IDS_BAUD_19200                  206
#define IDS_BAUD_38400                  207
#define IDS_BAUD_115200                 210
#define IDS_BAUD_57600                  211
#define IDS_BAUD_300                    216
#define IDS_BAUD_230400                 220
#define IDS_BAUD_460800                 221
#define IDS_BAUD_921600                 222
#define IDS_BYTESIZE_4                  240
#define IDS_BYTESIZE_5                  241
#define IDS_BYTESIZE_6                  242
#define IDS_BYTESIZE_7                  243
#define IDS_BYTESIZE_8                  244
#define IDS_PARITY_EVEN                 250
#define IDS_PARITY_ODD                  251
#define IDS_PARITY_NONE                 252
#define IDS_PARITY_MARK                 253
#define IDS_PARITY_SPACE                254
#define IDS_STOPBITS_1                  255
#define IDS_STOPBITS_1_5                256
#define IDS_STOPBITS_2                  257
#define IDS_FLOWCTL_XONXOFF             260
#define IDS_FLOWCTL_HARDWARE            261
#define IDS_FLOWCTL_NONE                262
#define IDS_ON                          263
#define IDS_SOFT                        264
#define IDS_CCITT_V23                   265
#define IDS_CCITT_V21V22                266
#define IDS_BELL                        267
#define IDS_LOGFILE                     270
#define IDS_UNSPECIFIED                 300
#define IDS_DATA                        301
#define IDS_FAX                         302
#define IDS_VOICE                       303
#define IDS_AUTOMATIC                   304
#define IDS_OK_COUNTRY                  320
#define IDS_CAP_GENERAL                 340
#define IDS_CAP_SETTINGS                341
#define IDS_CAP_RING                    342
#define IDS_CAP_CALLFWD                 343
#define IDS_ERR_COUNTRY                 400
#define IDS_ERR_LONGSTRING              401
#define IDS_ERR_WARNING                 402
#define IDS_OOM_GENERAL                 460
#define IDS_OOM_SETTINGS                461
#define IDS_ERR_DUP_PATTERN             463
#define IDS_ERR_NEED_VALUE              464
#define IDS_ERRORCONTROL_STANDARD       465
#define IDS_ERRORCONTROL_REQUIRED       466
#define IDS_ERRORCONTROL_CELLULAR       467
#define IDS_ERRORCONTROL_DISABLED       468
#define IDS_COMPRESSION_ENABLED         469
#define IDS_COMPRESSION_DISABLED        470
#define IDS_I_PROTOCOL_AUTO_1CH         480
#define IDS_I_PROTOCOL_AUTO_2CH         481
#define IDS_I_PROTOCOL_HDLC_PPP_56K     482
#define IDS_I_PROTOCOL_HDLC_PPP_64K     483
#define IDS_I_PROTOCOL_HDLC_PPP_112K    484
#define IDS_I_PROTOCOL_HDLC_PPP_112K_PAP 485
#define IDS_I_PROTOCOL_HDLC_PPP_112K_CHAP 486
#define IDS_I_PROTOCOL_HDLC_PPP_112K_MSCHAP 487
#define IDS_I_PROTOCOL_HDLC_PPP_128K    488
#define IDS_I_PROTOCOL_HDLC_PPP_128K_PAP 489
#define IDS_I_PROTOCOL_HDLC_PPP_128K_CHAP 490
#define IDS_I_PROTOCOL_HDLC_PPP_128K_MSCHAP 491
#define IDS_I_PROTOCOL_V120_64K         500
#define IDS_I_PROTOCOL_V120_56K         501
#define IDS_I_PROTOCOL_V120_112K        502
#define IDS_I_PROTOCOL_V120_128K        503
#define IDS_I_PROTOCOL_X75_64K          504
#define IDS_I_PROTOCOL_X75_128K         505
#define IDS_I_PROTOCOL_X75_T_70         506
#define IDS_I_PROTOCOL_X75_BTX          507
#define IDS_I_PROTOCOL_V110_1DOT2K      508
#define IDS_I_PROTOCOL_V110_2DOT4K      509
#define IDS_I_PROTOCOL_V110_4DOT8K      510
#define IDS_I_PROTOCOL_V110_9DOT6K      511
#define IDS_I_PROTOCOL_V110_12DOT0K     512
#define IDS_I_PROTOCOL_V110_14DOT4K     513
#define IDS_I_PROTOCOL_V110_19DOT2K     514
#define IDS_I_PROTOCOL_V110_28DOT8K     515
#define IDS_I_PROTOCOL_V110_38DOT4K     516
#define IDS_I_PROTOCOL_V110_57DOT6K     517
#define IDS_I_PROTOCOL_V34              518
#define IDS_ISDN_SWITCH_ATT1            550
#define IDS_ISDN_SWITCH_ATT_PTMP        551
#define IDS_ISDN_SWITCH_NI1             552
#define IDS_ISDN_SWITCH_DMS100          553
#define IDS_ISDN_SWITCH_INS64           554
#define IDS_ISDN_SWITCH_DSS1            555
#define IDS_ISDN_SWITCH_1TR6            556
#define IDS_ISDN_SWITCH_VN3             557
#define IDS_ISDN_SWITCH_BELGIUM1        558
#define IDS_ISDN_SWITCH_AUS1            559
#define IDS_ISDN_SWITCH_UNKNOWN         560
#define IDS_ISDN_WARN1                  570
#define IDS_G_PROTOCOL_HDLC_PPP_56K     600
#define IDS_G_PROTOCOL_HDLC_PPP_64K     601
#define IDS_G_PROTOCOL_V120_64K         602
#define IDS_G_PROTOCOL_V110_1DOT2K      604
#define IDS_G_PROTOCOL_V110_2DOT4K      605
#define IDS_G_PROTOCOL_V110_4DOT8K      606
#define IDS_G_PROTOCOL_V110_9DOT6K      607
#define IDS_G_PROTOCOL_V110_12DOT0K     608
#define IDS_G_PROTOCOL_V110_14DOT4K     609
#define IDS_G_PROTOCOL_V110_19DOT2K     610
#define IDS_G_PROTOCOL_V110_28DOT8K     611
#define IDS_G_PROTOCOL_V110_38DOT4K     612
#define IDS_G_PROTOCOL_V110_57DOT6K     613
#define IDS_G_PROTOCOL_ANALOG_RLP       614
#define IDS_G_PROTOCOL_ANALOG_NRLP      615
#define IDS_G_PROTOCOL_GPRS             616
#define IDS_I_PROTOCOL_PIAFS_INCOMING   617
#define IDS_I_PROTOCOL_PIAFS_OUTGOING   618
#define IDS_TAPICURRENT                 700
#define IDI_NULL_MODEM                  700
#define IDI_EXTERNAL_MODEM              701
#define IDI_INTERNAL_MODEM              702
#define IDI_PCMCIA_MODEM                703
#define IDC_STRICTSPEED                 1000
#define IDC_TERMINAL_PRE                1000
#define IDC_LOUD                        1001
#define IDC_TERMINAL_POST               1001
#define IDC_MANUAL_DIAL                 1002
#define IDC_WAITFORDIALTONE             1003
#define IDC_TERMINALGRP                 1004
#define IDC_NAME                        1005
#define IDC_TERMINALGRP2                1005
#define IDC_WAIT_TEXT                   1007
#define IDC_WAIT_SEC                    1008
#define IDC_WAIT_SEC_ARRW               1009
#define IDC_WAIT_UNIT                   1010
#define IDC_ED_FRIENDLYNAME             1011
#define IDC_WAIT_TEXT2                  1011
#define IDC_AM_COUNTRY                  1012
#define IDC_CB_COUNTRY                  1013
#define IDC_AM_EXTRA                    1015
#define IDC_AM_EXTRA_ED                 1016
#define IDC_EB_ISDN_N                   1017
#define IDC_EB_ISDN_N1                  1017
#define IDC_AM_EXTRA3                   1018
#define IDC_LBL_PORT                    1018
#define IDC_EB_ISDN_N2                  1018
#define IDC_CB_PORT                     1020
#define IDC_LOGGING                     1020
#define IDC_ST_PORT                     1021
#define IDC_ED_PORT                     1022
#define IDC_LBL_DATABITS                1024
#define IDC_CB_DATABITS                 1025
#define IDC_DATABITS                    1025
#define IDC_LBL_PARITY                  1026
#define IDC_LBL_FC                      1027
#define IDC_CB_PARITY                   1028
#define IDC_PARITY                      1028
#define IDC_LBL_FC2                     1028
#define IDC_LBL_STOPBITS                1029
#define IDC_SPEAKER                     1029
#define IDC_CB_STOPBITS                 1030
#define IDC_STOPBITS                    1030
#define IDC_CB_FC                       1031
#define IDC_SPEED                       1031
#define IDC_LBL_EC                      1032
#define IDC_VOLUME                      1032
#define IDC_LBL_PS                      1034
#define IDC_LBL_COMP                    1035
#define IDC_CB_SPEED                    1036
#define IDC_CB_EC                       1037
#define IDC_CB_MOD                      1038
#define IDC_DRIVER                      1040
#define IDC_ED_DIALTIMER                1040
#define IDC_LBL_MOD                     1040
#define IDC_MOREINFOLV                  1041
#define IDC_SECONDS                     1041
#define IDC_CH_IDLETIMER                1042
#define IDC_MOREINFOV2                  1042
#define IDC_ED_IDLETIMER                1043
#define IDC_MINUTES                     1044
#define IDC_LBL_MOD2                    1045
#define IDC_LBL_OFF                     1045
#define IDC_ST_MODEM_GRP                1047
#define IDC_DIALPROP                    1050
#define IDC_LOC                         1051
#define IDC_CLASSICON                   1057
#define IDC_GE_ICON                     1059
#define IDC_CALL_PREF                   1060
#define IDC_FWD_CHECK                   1062
#define IDC_FWD_ACT                     1063
#define IDC_FWD_DEACT                   1064
#define IDC_DEACT                       1067
#define IDC_ACT                         1068
#define IDC_RING_GROUP                  1068
#define IDC_RING_CHECK                  1069
#define IDC_LBL_ADDR_PRI                1070
#define IDC_LBL_ADDR1                   1071
#define IDC_LBL_ADDR2                   1072
#define IDC_ADDR_PRI                    1073
#define IDC_ADDR1                       1074
#define IDC_ADDR2                       1075
#define IDC_LBL_ADDR3                   1076
#define IDC_ADDR3                       1077
#define IDC_LBL_PRI_CALLERS             1078
#define IDC_PRI_CALLERS                 1079
#define IDC_LBL_CALLBACK                1080
#define IDC_CALLBACK                    1081
#define IDC_TYPE_ADDR_PRI               1082
#define IDC_TYPE_ADDR1                  1083
#define IDC_TYPE_ADDR2                  1084
#define IDC_TYPE_ADDR3                  1085
#define IDC_TYPE_PRI_CALLERS            1086
#define IDC_TYPE_CALLBACK               1087
#define IDC_LBL_RING1                   1088
#define IDC_LBL_RING2                   1089
#define IDC_LBL_RING3                   1090
#define IDC_TYPE_RING1                  1091
#define IDC_TYPE_RING2                  1092
#define IDC_TYPE_RING3                  1093
#define IDC_VIEWLOG                     1094
#define IDC_PORT_TEXT                   1095
#define IDC_REFRESH                     1096
#define IDC_CB_COMP                     1099
#define IDC_BN_PORTSETTINGS             1100
#define IDC_CB_ISDN_ST                  1104
#define IDC_EB_ISDN_ID                  1107
#define IDC_EB_ISDN_ID1                 1107
#define IDC_EB_ISDN_ID2                 1108
#define IDC_INITCHECK                   1109
#define IDS_PORT                        2006
#define IDS_NOTPRESENT                  2007
#define IDS_NOTFUNCTIONAL               2008
#define IDS_NEEDSRESTART                2009
#define IDS_DEVSETUP_RESTART            2010
#define IDS_UNINSTALLED                 2011
#define IDS_UNKNOWNPORT                 2012
#define IDS_CAP_MODEMSETUP              3000
#define IDS_CPLNAME                     3018
#define IDS_CPLINFO                     3019
#define IDS_ERR_PROPERTIES              3053
#define IDS_CAP_MODEM                   3054
#define IDS_WRN_CONFIRMDELETE           3060
#define IDS_ERR_CANT_DEL_MODEM          3061
#define IDS_MODEM                       3062
#define IDS_OOM_OPENCPL                 3069
#define IDS_ERR_NOT_ADMIN               3073
#define IDS_ERR_NOMODEM_NOT_ADMIN       3074
#define IDS_ASK_REBOOTNOW               3076
#define IDS_CAP_RASCONFIG               3077
#define IDS_CBR_300                     3200
#define IDS_CBR_1200                    3201
#define IDS_CBR_2400                    3202
#define IDS_CBR_9600                    3203
#define IDS_CBR_19_2                    3204
#define IDS_CBR_38_4                    3205
#define IDS_CBR_56_K                    3206
#define IDS_CBR_0                       3207
#define IDS_COMMAND                     3212
#define IDS_RESPONSE                    3213
#define IDS_NO_OPEN_PORT                3214
#define IDS_OPEN_PORT                   3215
#define IDS_OPENCOMM                    3218
#define IDS_CBR_115K                    3221
#define IDS_UPDATING                    3222
#define IDS_ERROR                       3223
#define IDS_OK                          3233
#define IDS_NO_MODEM_RESPONSE           3236
#define IDS_ERROR_RESPONSE              3237
#define IDS_FIELD                       3238
#define IDS_VALUE                       3239
#define IDS_DEFAULT_PREF                3240
#define IDS_CONNECTION_PREF             3241
#define IDH_MODEM_INSTALLED             5000
#define IDH_MODEM_ADD                   5001
#define IDH_MODEM_REMOVE                5002
#define IDH_MODEM_PROPERTIES            5003
#define IDH_MODEM_DIALING_PROPERTIES    5004
#define IDI_MODEM                       5100
#define IDS_COUNTRY_00                  0x1800
#define IDS_COUNTRR_01                  0x1801
#define IDS_COUNTRY_02                  0x1802
#define IDS_COUNTRY_03                  0x1803
#define IDS_COUNTRY_04                  0x1804
#define IDS_COUNTRY_05                  0x1805
#define IDS_COUNTRY_06                  0x1806
#define IDS_COUNTRY_07                  0x1807
#defin