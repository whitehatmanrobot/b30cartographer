ILED(hr))
    {
        goto Cleanup;
    }

    if (pBreakTable)
    {
        hr = DYNCAST(CBreakTable, pBreakTable)->GetLayoutBreakTable()->GetBreak((void *)pElement, &pLayoutBreak);
        *ppLayoutBreak = DYNCAST(CLayoutBreak, pLayoutBreak);
    }

Cleanup:
    return (hr);
}

//----------------------------------------------------------------------------
//
//  Member: EnsureCleanToContext
//
//  Note:   Sends appropriate notifications to ensure that all dirty contexts in the
//          view chain prior to the one passed in will be measured.  If they
//          are all currently clean (not including the one passed in), return TRUE,
//          else return FALSE.
//----------------------------------------------------------------------------
BOOL
CViewChain::EnsureCleanToContext( CLayoutContext *pLContext )
{
    int              i               = 0;
    CBreakBase      *pBreakTable     = NULL;
    CLayoutContext  *pLC             = NULL;
    void            *pV              = NULL;
    BOOL             fCleanToContext = TRUE;

    Assert( HasLayoutOwner() );

    for (;;)
    {
        _bt.GetKeyByIndex( i, &pV );
        // TODO (112510, olego): Can't do a dynamic_cast from void *; 
        // think about changing the type of _pKey in CBreakTable
        pLC = (CLayoutContext *)pV;
        // GetKeyByIndex will return NULL when we reach the end of the array.
        // Stop processing once we've reached the context passed in.
        if ( !pLC || pLC->IsEqual( pLContext ))
            break;

        _bt.GetBreakByIndex( i, &pBreakTable );
        AssertSz( pBreakTable, "Must have a valid break if we found a key" );

        if ( pBreakTable->IsDirty() )
        {
            // If we found a dirty break, we must return false and
            // queue a request to get the break measured.
            fCleanToContext = FALSE;

            // remesuring layout rect that does not have content element yet 
            // has no sense...
            if (ElementContent())
            {
                pLC->GetLayoutOwner()->ElementOwner()->RemeasureElement();
            }
        }

        ++i;
    }

    return fCleanToContext;
}

//----------------------------------------------------------------------------
//
//  Member: MarkContextClean
//
//  Note:   Marks the breaktable for this context as clean
//----------------------------------------------------------------------------
HRESULT
CViewChain::MarkContextClean( CLayoutContext *pLContext )
{
    CBreakBase     *pBreakTable;
    HRESULT         hr = E_FAIL;

    hr = _bt.GetBreak((void *)pLContext, &pBreakTable);
    if ( SUCCEEDED(hr) )
    {
        Assert( pBreakTable );
        pBreakTable->SetDirty( FALSE );
    }

    return hr;
}

//----------------------------------------------------------------------------
//
//  Member: SetLayoutOwner
//
//----------------------------------------------------------------------------
void
CViewChain::SetLayoutOwner(CLayout *pLayoutOwner)
{ 
    if (!pLayoutOwner)
    {
        CLayoutContext  *pLayoutContext = NULL;
        CLayout         *pLayout        = NULL;
        void            *pV             = NULL;
        int              i;

        Assert(HasLayoutOwner());  // Someone needs to have a ref to us that we won't release in the loop below

        // NB: (greglett)
        // Other people may be removing the break we're looking at as we're looking at it.
        // If we iterate from 0 to size, then our indecies get messed up.
        // So, we iterate from size to 0.
        for (i=_bt.Size() - 1;i >= 0;i--)
        {            
            _bt.GetKeyByIndex( i, &pV );    

            if (!pV)
                break;

            // TODO (112510, olego): Can't do a dynamic_cast from void *; 
            // think about changing the type of _pKey in CBreakTable
            pLayoutContext = (CLayoutContext *)pV;
            pLayout  = pLayoutContext->GetLayoutOwner();
            Assert(pLayout);

            // Don't set the view chain on our owner - our owner is likely fiddling with us right now.
            if (pLayout != GetLayoutOwner())
            {
                // 
                // (bug # 104682) At this point container layout MUST be destroyed to ensure:
                // 1. Layout Context defined by container layout will be destroyed;
                // 2. Display node of this container layout will be deleted from the display tree. 
                // 
                CElement *pElement = pLayout->ElementOwner();

                //  Container Layout MUST be allowed to destroyed
                Assert(!pElement->_fLayoutAlwaysValid);

                if (pElement->HasLayoutPtr())
                {
                    WHEN_DBG(CLayout *pLayoutDbg =)
                    pElement->DelLayoutPtr();
                    Assert(pLayoutDbg == pLayout);

                    pLayout->Detach();
                    pLayout->Release();
                }
                else if (pElement->HasLayoutAry())
                {
                    pElement->DelLayoutAry(); // will take care of detaching/releasing its layouts
                }
            }
        }
    }

     _pLayoutOwner = pLayoutOwner;
}


//----------------------------------------------------------------------------
//
//  Member: ElementContent()
//
//  Note:   Returns the content element that this chain is measuring.
//          Obtained from the layout owner's slave ptr.
//----------------------------------------------------------------------------
CElement *
CViewChain::ElementContent()
{
    return ( HasLayoutOwner() ? _pLayoutOwner->ElementContent() : NULL );
}

//----------------------------------------------------------------------------
//
//  Member: YOffsetForContext()
//
//  Note:   Returns the starting Y for LayoutContext in stitched coordinate 
//          system
//----------------------------------------------------------------------------
long 
CViewChain::YOffsetForContext(CLayoutContext *pLayoutContext)
{
    Assert(pLayoutContext);

    CElement * pElementContent = ElementContent();
    long       yHeight = 0;
    int        i;
    
    Assert(pElementContent);

    for (i = 0; ; ++i)
    {
        CLayout * pL;
        void *    pV;

        _bt.GetKeyByIndex(i, &pV);
        if (pV == NULL)
        {
            //  the end of view chain is reached 
            //  given LayoutContext was not found so return 0
            yHeight = 0;
            break;
        }
        else if (pV == (void *)pLayoutContext)
        {
            // given LayoutContext is here - break
            break;
        }

        pL = pElementContent->GetUpdatedLayout((CLayoutContext *)pV);
        Assert(pL);

        yHeight += pL->GetHeight();
    }

    return (yHeight);
}

//----------------------------------------------------------------------------
//
//  Member: HeightForContext()
//
//  Note:   Returns height for LayoutContext 
//----------------------------------------------------------------------------
long 
CViewChain::HeightForContext(CLayoutContext *pLayoutContext)
{
    Assert(pLayoutContext);

    CElement * pElementContent;
    CLayout * pLayout;
    
    pElementContent = ElementContent();
    Assert(pElementContent);

    pLayout = pElementContent->GetUpdatedLayout(pLayoutContext);
    Assert(pLayout);

    return (pLayout->GetHeight());
}

//----------------------------------------------------------------------------
//
//  Member: LayoutContextFromPoint()
//
//  Note:   Returns the LayoutContext containing the point. If there is a break entry 
//          in display layer of break table returns the first empty context (if exist) 
//          Though fIgnoreChain (when is TRUE) force searching for chain. This is done 
//          to make rel disp nodes (that shares the same layout with parent) appear 
//          on the first page always. 
//----------------------------------------------------------------------------
CLayoutContext * 
CViewChain::LayoutContextFromPoint(CLayout *pLayout, CPoint *ppt, BOOL fIgnoreChain)
{
    Assert(pLayout && ppt);
    Assert(HasLayoutOwner());

    CElement *       pElementContent = ElementContent();
    CLayoutContext * pLayoutContext = NULL;
    long             yHeight = 0;
    void *           pV;
    int              i;
    
    Assert(pElementContent);

    //  find the layout context containing the point 
    for (i = 0; ; ++i)
    {
        CLayout * pL;

        _bt.GetKeyByIndex(i, &pV);
        if (pV == NULL)
        {
            //  the end of view chain is reached
            break;
        }

        pL = pElementContent->GetUpdatedLayout((CLayoutContext *)pV);
        Assert(pL);

        yHeight += pL->GetHeight();

        if (ppt->y < yHeight)
        {
            pLayoutContext = (CLayoutContext *)pV;
            break;
        }
    }

    if (    !fIgnoreChain 
        &&  pLayoutContext  )
    {
        //  check display layout of break table to find first empty context 
        CBreakBase *pBreakTable;
        CBreakBase *pLayoutBreak;

        for (i = _bt.GetIndex((void *)pLayoutContext), pLayoutContext = NULL; i < _bt.Size(); ++i)
        {
            if (FAILED(_bt.GetBreakByIndex(i, &pBreakTable)))
            {
                goto Cleanup;
            }

            if (pBreakTable)
            {
                DYNCAST(CBreakTable, pBreakTable)->GetDisplayBreakTable()->GetBreak((void *)pLayout, &pLayoutBreak);
                if (!pLayoutBreak) 
                {
                    //  there is no display break, so context is empty 
                    _bt.GetKeyByIndex(i, &pV);
                    pLayoutContext = (CLayoutContext *)pV;
                    break;
                }
            }
        }
    }

Cleanup:
    return (pLayoutContext);
}

//----------------------------------------------------------------------------
//
//  Member: SetDisplayBreak()
//----------------------------------------------------------------------------
HRESULT 
CViewChain::SetDisplayBreak(CLayoutContext *pLContext, 
                     CLayout *pLayout, CBreakBase *pBreak)
{
    HRESULT         hr = S_OK;
    CBreakBase      *pBreakTable;

    Assert( HasLayoutOwner() );
    Assert( pLayout );

    hr = _bt.GetBreak((void *)pLContext, &pBreakTable);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    if (pBreakTable)
    {
        hr = DYNCAST(CBreakTable, pBreakTable)->GetDisplayBreakTable()->SetBreak((void *)pLayout, pBreak);
    }

Cleanup:
    return (hr);
}

//----------------------------------------------------------------------------
//
//  Member: IsElementFirstBlock()
//
//  Note:   Returns TRUE if the element is starting in given layout context. 
//          SHOULD BE CALLED ONLY FOR ELEMENTS THAT CAN BE BROKEN !!!
//----------------------------------------------------------------------------
BOOL 
CViewChain::IsElementFirstBlock(CLayoutContext *pLayoutContext, CElement *pElement)
{
    AssertSz(pLayoutContext && pElement, "Illegal parameters !!!");
    Assert( HasLayoutOwner() );

    HRESULT       hr;
    CLayoutBreak *pLayoutBreak;

#if DBG==1
    {
        CLayoutBreak *pEndLayoutBreak;

        hr = GetLayoutBreak(pLayoutContext, pElement, &pEndLayoutBreak, 1);
        if (!FAILED(hr))
        {
            AssertSz(pEndLayoutBreak, "Function is called for NON broken element ?");
        }
    }
#endif

    hr = GetLayoutBreak(pLayoutContext, pElement, &pLayoutBreak, 0);
    if (FAILED(hr))
    {
        goto Error;
    }

    //  No break entry for this layout context means element is starting from here:
    return (!pLayoutBreak);

Error:
    //  By default return TRUE. (We won't skip drawing top border in this case.)
    return (TRUE);
}

//----------------------------------------------------------------------------
//
//  Member: IsElementLastBlock()
//
//  Note:   Returns TRUE if the element is ending in given layout context. 
//          SHOULD BE CALLED ONLY FOR ELEMENTS THAT CAN BE BROKEN !!!
//----------------------------------------------------------------------------
BOOL 
CViewChain::IsElementLastBlock(CLayoutContext *pLayoutContext, CElement *pElement)
{
    AssertSz(pLayoutContext && pElement, "Illegal parameters !!!");
    Assert( HasLayoutOwner() );

    HRESULT     hr;
    CBreakBase *pBreakTable;
    CBreakBase *pLayoutBreak = NULL;
    int         idx;

    idx = _bt.GetIndex((void *)pLayoutContext);

    //
    //  First check ending break...
    //
    hr = _bt.GetBreakByIndex(idx, &pBreakTable);
    if (FAILED(hr))
    {
        goto Error;
    }

    if (pBreakTable)
    {
        hr = DYNCAST(CBreakTable, pBreakTable)->GetLayoutBreakTable()->GetBreak((void *)pElement, &pLayoutBreak);
        AssertSz(FAILED(hr) || pLayoutBreak, "Function is called for NON broken element ?");
        if (FAILED(hr) || !pLayoutBreak)
        {
            goto Error;
        }

        if (DYNCAST(CLayoutBreak, pLayoutBreak)->LayoutBreakType() == LAYOUT_BREAKTYPE_LINKEDOVERFLOW)
        {
            //  Ending break is of overflow type so this is not the ending block
            return (FALSE);
        }
    }

    Assert(pLayoutBreak 
        && DYNCAST(CLayoutBreak, pLayoutBreak)->LayoutBreakType() == LAYOUT_BREAKTYPE_LAYOUTCOMPLETE);

    //
    //  Check if we have anything after... (We may if this is a table cell for example)
    //
    if ((idx + 1) >= _bt.Size())
    {
        //  The block is ending with layout complete and appeared inside last rect. This is the end...
        return (TRUE);
    }

    hr = _bt.GetBreakByIndex(idx + 1, &pBreakTable);
    if (FAILED(hr))
    {
        goto Error;
    }

    if (pBreakTable)
    {
        hr = DYNCAST(CBreakTable, pBreakTable)->GetLayoutBreakTable()->GetBreak((void *)pElement, &pLayoutBreak);
        if (FAILED(hr))
        {
            goto Error;
        }

        //  If we have something here the element doesn't finish yet.
        return (!pLayoutBreak);
    }

Error:
    //  By default return TRUE. (We won't skip drawing bottom border in this case.)
    return (TRUE);
}

//+-------------------------------------------------------------------------
//   A B S O L U T E   E L E M E N T S   H A N D L I N G 
//+-------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Member   : QueuePositionRequest()
//
//  Synopsis : Places request for position of absolute position object.
//
//  Arguments:  CLayout *  - layout owner of the request 
//              CElement * - element to be positioned
//              CPoint &   - point used for auto positioning 
//              BOOL       - if auto point is valid
//
//  Returns  :  S_OK          - success code
//              E_OUTOFMEMORY - not enough memory to allocate new element 
//                              in the queue.
//+-------------------------------------------------------------------------

HRESULT 
CViewChain::QueuePositionRequest(CLayout *pLayout, CElement *pElement, const CPoint &ptAuto, BOOL fAutoValid)
{
    // At the time a request is queued, the layout better be in a valid context.
    Assert(pLayout && pLayout->LayoutContext() && pLayout->LayoutContext()->IsValid());
    Assert(pElement && (pElement->IsAbsolute() || pElement->IsRelative()));

    HRESULT hr = S_OK;

    CRequest *pRequest = _aryRequest.Append();
    if (pRequest == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // FUTURE: Should addref or subaddref the element (and possibly the layout,
    // when we decide on a layout mem-management strategy).  Watch out for circular
    // references!  Shouldn't be an issue as long as the document is static, so we 
    // can probably get away with it for now.
    pRequest->_pLayoutOwner = pLayout;
    pRequest->_pElement     = pElement;
    pRequest->_ptAuto       = ptAuto;
    pRequest->_fAutoValid   = !!fAutoValid;

Cleanup:
    return (hr);
}

//+-------------------------------------------------------------------------
//
//  Member   : FlushRequests()
//
//  Synopsis : Flushes the queue of requests on a particular layout.
//
//  Arguments:  CLayout *  - layout owner of the request 
//
//  Returns  :  S_OK       - found and deleted requests for this layout
//              S_FALSE    - the layout didn't have any requests in the queue
//+-------------------------------------------------------------------------

HRESULT 
CViewChain::FlushRequests(CLayout *pLayout)
{
    Assert(pLayout && pLayout->LayoutContext());

    HRESULT hr = S_FALSE;

    // Deletion from the end simplifies index management
    int i = _aryRequest.Size() - 1;
    while ( i >= 0 )
    {
        if ( _aryRequest[i]._pLayoutOwner == pLayout )
        {
            _aryRequest.Delete( i );
            hr = S_OK;
        }
        --i;
    }

    return (hr);
}

//+-------------------------------------------------------------------------
//
//  Member   : HandlePositionRequests()
//
//  Synopsis : Processes the queue. Requests are pulled out in source order, 
//             which guarantees that parents will be processed before children 
//             in a case of nesting.
//
//+-------------------------------------------------------------------------
HRESULT 
CViewChain::HandlePositionRequests()
{
    int     idx;

    while ((idx = NextPositionRequestInSourceOrder()) >= 0)
    {
        Assert(idx < _aryRequest.Size());

        if (!HandlePositionRequest(&_aryRequest[idx]))
        {
            // cannot process yet (no page exists).

            // WARNING: This could probably be a "continue", because subsequent requests may
            // be handleable at this point.
            break;
        }

        //  delete this entry
        _aryRequest.Delete(idx);
    }

    return (S_OK);
}

//+-------------------------------------------------------------------------
//
//  Member : HandlePositionRequest()
//
//  Synopsis : Processes a single request
//
//+-------------------------------------------------------------------------
BOOL 
CViewChain::HandlePositionRequest(CRequest *pRequest)
{
    Assert(pRequest);
    Assert(pRequest->_pLayoutOwner);
    AssertSz(pRequest->_pLayoutOwner->HasLayoutContext(), "If we asked the viewchain to position us, we must have a context" );

    CLayout *pLayout = pRequest->_pLayoutOwner;

    if ( !pLayout->LayoutContext()->IsValid() )
    {
        // This request is pointless because the context it was made in is no longer valid.
        // Do nothing and return TRUE so the request will be deleted.
        return TRUE;
    }

    CCalcInfo CI(pLayout);

    // WARNING (KTam, OlegO): We should ensure that pRequest->_pElement
    // has a layout in this context; it's possible that it had a layout
    // but it was destroyed in UndoMeasure, in which case we will recreate
    // it here (bad) and end up with 2 positioned layouts for that element.

    return (pLayout->HandlePositionRequest(&CI, 
                                           pRequest->_pElement, 
                                           pRequest->_ptAuto, 
                                           pRequest->_fAutoValid));
}

//+-------------------------------------------------------------------------
//
//  Member : NextPositionRequestInSourceOrder()
//
//  Synopsis : Returns the first request in the queue (in source order) 
//
//+-------------------------------------------------------------------------
int 
CViewChain::NextPositionRequestInSourceOrder()
{
    int i, iRequest, cRequests;
    int si, siRequest;

    iRequest  = -1;
    cRequests = _aryRequest.Size();
    siRequest = INT_MAX;

    for (i = 0; cRequests; --cRequests, ++i)
    {
        CRequest *pRequest = &(_aryRequest[i]);

        Assert(pRequest && pRequest->_pElement);

        si = pRequest->_pElement->GetSourceIndex();
        if (si < siRequest)
        {
            siRequest = si;
            iRequest  = i;
        }
    }

    return iRequest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\eanchor.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eanchor.cxx
//
//  Contents:   Anchor element class
//
//  Classes:    CAnchorElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TXTELEMS_HXX_
#define X_TXTELEMS_HXX_
#include "txtelems.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include <treepos.hxx>
#endif

#ifndef X_HLINK_H_
#define X_HLINK_H_
#include "hlink.h"
#endif

#ifndef X_URLMON_H_
#define X_URLMON_H_
#include "urlmon.h"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif


#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_UNDO_HXX_
#define X_UNDO_HXX_
#include "undo.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "anchor.hdl"

MtDefine(CAnchorElement, Elements, "CAnchorElement")

ExternTag(tagMsoCommandTarget);

#ifdef WIN16
#define SetCursorStyle(x) ::SetCursor((HICON)x)
#endif

#ifndef NO_PROPERTY_PAGE
const CLSID * const CAnchorElement::s_apclsidPages[] =
{
    // Browse-time pages
    &CLSID_CAnchorBrowsePropertyPage,
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif // DBG==1    
    NULL
};
#endif // NO_PROPERTY_PAGE


const CElement::CLASSDESC CAnchorElement::s_classdesc =
{
    {
        &CLSID_HTMLAnchorElement,            // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                      // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                              // _pcpi
        0,                                   // _dwFlags
        &IID_IHTMLAnchorElement,             // _piidDispinterface
        &s_apHdlDescs,                       // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLAnchorElement,      // _pfnTearOff
    NULL                                     // _pAccelsRun
};


HRESULT
CAnchorElement::CreateElement(CHtmTag *pht, CDoc *pDoc, CElement **ppElement)
{
    HRESULT   hr = S_OK;

    Assert(pht->Is(ETAG_A));
    Assert(ppElement);
    *ppElement = new CAnchorElement(pDoc);

    if (!*ppElement)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CAnchorElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CAnchorElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLAnchorElement2, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

HRESULT
CAnchorElement::EnterTree()
{
    HRESULT hr = S_OK;
    TCHAR   cBuf[pdlUrlLen];
    TCHAR * pchNewUrl = cBuf;
    CDoc *  pDoc = Doc();

    Assert (IsInMarkup());

    if (GetMarkup()->_fMarkupServicesParsing && pDoc->_fPasteIE40Absolutify && !pDoc->_fNoFixupURLsOnPaste)
    {
        LPCTSTR szUrl = GetAAhref();

        if (szUrl && *szUrl)
        {
            Assert( !IsInPrimaryMarkup() );

            hr = THR(
                CMarkup::ExpandUrl(GetMarkup()->GetFrameOrPrimaryMarkup(), 
                    szUrl, ARRAY_SIZE(cBuf), pchNewUrl, this,
                    URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE,
                    LPTSTR( Doc()->_cstrPasteUrl)));

            if (hr)
                goto Cleanup;

            hr = THR(SetAAhref(pchNewUrl));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:

    RRETURN( hr );

}

void
CAnchorElement::Notify(CNotification *pNF)
{
    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_QUERYFOCUSSABLE:
        if (!IsEditable(TRUE))
        {
            CQueryFocus *   pQueryFocus     = (CQueryFocus *)pNF->DataAsPtr();
            CTreePos    *   ptp, *ptpEnd;

            if (!GetAAhref())
            {
                pQueryFocus->_fRetVal = FALSE;
                break;
            }
            // Check for server-side image map
            // If all that this contains is an IMG with isMap, don't take focus.
            // The image would take focus instead
            GetTreeExtent(&ptp, &ptpEnd);
            ptp = ptp->NextTreePos();
            if (    ptp != ptpEnd
                &&  ptp->IsBeginElementScope()
                &&  ptp->Branch()->Tag() == ETAG_IMG
                &&  DYNCAST(CImgElement, ptp->Branch()->Element())->GetAAisMap()
                &&  ptp->NextTreePos() == ptpEnd->PreviousTreePos())
            {
                pQueryFocus->_fRetVal = FALSE;
                break;
            }
        }
        // If the anchor is in edit mode and we don't have a layout,
        // then we don't want focus.
        else if (!GetUpdatedLayout())
        {
            CQueryFocus *   pQueryFocus     = (CQueryFocus *)pNF->DataAsPtr();
            pQueryFocus->_fRetVal = FALSE;
        }
        break;

    case NTYPE_ELEMENT_SETFOCUS:
        if (GetFirstBranch())
        {
            IGNORE_HR(SetStatusText());

            if (IsInMarkup())
            {
                SetActive(TRUE);
            }
        }
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        EnterTree();
        break;

    case NTYPE_BASE_URL_CHANGE: 
        _fBaseUrlChanged = TRUE;
        OnPropertyChange( DISPID_CAnchorElement_href, 
                            ((PROPERTYDESC *)&s_propdescCAnchorElementhref)->GetdwFlags(),
                            (PROPERTYDESC *)&s_propdescCAnchorElementhref);
        break;
    }
}

BOOL 
CAnchorElement::CanStealFormats(CTreeNode *pNodeVictim)
{
    BOOL fSteal;
    CAnchorElement *pAnchorOther = DYNCAST(CAnchorElement, pNodeVictim->Element());
    CAttrArray **ppAA1 = GetAttrArray();
    CAttrArray **ppAA2 = pAnchorOther->GetAttrArray();

    if (*ppAA1 != NULL && *ppAA2 != NULL)
    {
        DISPID dispid;
        if (!(*ppAA1)->Compare(*ppAA2, &dispid))
        {
            // If the 2 <A>'s are different only in their HREF and if both
            // have the same visited status, then we can steal formats.
            fSteal = dispid == s_propdescCAnchorElementhref.a.GetDispid()
                 && ( (GetAAhref()==NULL) == (pAnchorOther->GetAAhref()==NULL) );
        }
        else
        {
            // If they are the same hrefs (or no hrefs are present), then we can
            // steal the formats.
            fSteal = TRUE;
        }
    }
    else
    {
        fSteal = (*ppAA1 == NULL && *ppAA2 == NULL);
    }
    if (fSteal)
    {
        EnsureVisited();
        fSteal =    _fVisited == pAnchorOther->_fVisited
                 && _fHovered == pAnchorOther->_fHovered
                 && _fActive  == pAnchorOther->_fActive;
    }
    return fSteal;
}

HRESULT
CAnchorElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr;

    Assert(Tag() == ETAG_A);

    pCFI->PrepareCharFormat();

    if (GetAAhref())
    {
        pCFI->PrepareFancyFormat();

        switch (Doc()->_pOptionSettings->nAnchorUnderline)
        {
            case ANCHORUNDERLINE_NO:
                pCFI->_cf()._fUnderline = FALSE;
                pCFI->_ff()._fHasExplicitUnderline = FALSE;
                break;

            case ANCHORUNDERLINE_YES:
                pCFI->_cf()._fUnderline = TRUE;
                pCFI->_ff()._fHasExplicitUnderline = TRUE;
                break;

            case ANCHORUNDERLINE_HOVER:
                if (_fHovered)
                {
                    pCFI->_cf()._fUnderline = TRUE;
                    pCFI->_ff()._fHasExplicitUnderline = TRUE;
                }
                break;
        }

        pCFI->_cf()._ccvTextColor.SetValue(GetLinkColor(), FALSE);

        // (gschneid) If we have a link with a href attribute we always want to show
        // the hand for links. The following line prevents in this case (with attribute href)
        // that the cursor property is inherited from an enclosing element.
        pCFI->_cf()._bCursorIdx = styleCursorAuto;
    }

    pCFI->UnprepareForDebug();

    hr = THR(super::ApplyDefaultFormat(pCFI));

    RRETURN(hr);
}

void CAnchorElement::EnsureVisited()
{
    if (!_fVisitedValid)
    {
        _fVisited = Doc()->IsVisitedHyperlink(GetAAhref(), this);
        _fVisitedValid = TRUE;
    }
}


COLORREF CAnchorElement::GetLinkColor()
{
    CDoc *pDoc = Doc();

    CColorValue  color;

    EnsureVisited();
    if (!pDoc->_pOptionSettings->fAlwaysUseMyColors)
    {
        CBodyElement * pBody = NULL;

        if (GetFirstBranch())
        {
            CTreeNode * pNode;

            pNode = GetFirstBranch()->SearchBranchToRootForTag( ETAG_BODY );

            if (pNode)
                pBody = DYNCAST( CBodyElement, pNode->Element() );
        }

        if (pBody)
        {
            if (_fHovered && pDoc->_pOptionSettings->fUseHoverColor)
                ;//pBody->GetAAhLink();// When ScottI agrees with HLINK attribute on BODY ! :-)
            else if (_fActive)
                color = pBody->GetAAaLink();
            else if (_fVisited)
                color = pBody->GetAAvLink();
            else
                color = pBody->GetAAlink();
        }
    }

    if (_fHovered && pDoc->_pOptionSettings->fUseHoverColor)
    {
        return (color.IsDefined())
                ? color.GetColorRef()
                : pDoc->_pOptionSettings->crAnchorHovered();
    }
    else if (_fVisited)
    {
        return (color.IsDefined())
                ? color.GetColorRef()
                : pDoc->_pOptionSettings->crAnchorVisited();
    }
    else
    {
        return (color.IsDefined())
                ? color.GetColorRef()
                : pDoc->_pOptionSettings->crAnchor();
    }
}


HRESULT
CAnchorElement::UpdateAnchorFromHref()
{
    IHTMLEditingServices * pEd = NULL;

    IHTMLEditor *   phtmed;
    BOOL            fUpdateText;
    BSTR            bstrAnchorText = NULL;
    CMarkup *       pMarkup;
    OLECHAR *       pstrHref;
    HRESULT         hr = S_OK;
    MARKUP_CONTEXT_TYPE context;
    CDoc *          pDoc = Doc();    
    
    Assert( pDoc );

    CMarkupPointer  mpStart( pDoc );
    CMarkupPointer  mpEnd( pDoc );

    //
    // Get the text and href values
    //
    hr = THR( get_innerText( &bstrAnchorText ) );
    if (hr)
        goto Cleanup;

    pstrHref = (OLECHAR *)GetAAhref();
    if (! pstrHref)
        goto Cleanup;

    //
    // If anchor has text, and it's equal to the href already, we can bail
    //
    if ( bstrAnchorText && StrCmpIC( pstrHref, bstrAnchorText ) == 0 )
        goto Cleanup;

    pMarkup = GetMarkup();        
    
    if (! pMarkup )
        goto Cleanup;

    //
    // See what's inside the anchor
    //

    hr = THR( mpStart.MoveAdjacentToElement( this, ELEM_ADJ_AfterBegin ) );
    if (hr)
        goto Cleanup;

    hr = THR( mpEnd.MoveAdjacentToElement( this, ELEM_ADJ_BeforeEnd ) );
    if (hr)
        goto Cleanup;

    //
    // If there anything other than text in the anchor, it is best
    // not to update the anchor's text
    //
    fUpdateText = TRUE;
    while(! mpStart.IsEqualTo( &mpEnd ) )
    {           
        mpStart.Right( TRUE, &context, NULL, NULL, NULL, NULL );
        if ( context != CONTEXT_TYPE_Text )
        {
            fUpdateText = FALSE;
            break;
        }
    }

    if (! fUpdateText)
        goto Cleanup;

    //
    // Get a hold of yourself, now we have to call the autodetector to see
    // if the text and href are autodetectable and match the same pattern
    //
    hr = THR( mpStart.MoveAdjacentToElement( this, ELEM_ADJ_AfterBegin ) );
    if (hr)
        goto Cleanup;

    phtmed = pDoc->GetHTMLEditor();

    if (!phtmed)
        goto Cleanup;

    hr = THR(
        phtmed->QueryInterface(
            IID_IHTMLEditingServices, (void **) & pEd ) );

    if (hr)
        goto Cleanup;

    hr = THR( pEd->ShouldUpdateAnchorText( pstrHref, bstrAnchorText, &fUpdateText ) );
    if (hr)
        goto Cleanup;

    if ( fUpdateText )
    {
        hr = THR( pDoc->Remove( &mpStart, &mpEnd ) );
        if (hr)
            goto Cleanup;

        hr = THR( pDoc->InsertText( & mpStart, pstrHref, -1 ) );
        if (hr)
            goto Cleanup;
    }

Cleanup:
    if (bstrAnchorText)
        SysFreeString(bstrAnchorText);
    ReleaseInterface( pEd );
    return hr;
}


HRESULT
CAnchorElement::OnPropertyChange ( DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc )
{
    HRESULT hr = S_OK;
    //
    // If we are changing the HREF for the anchor, we may want to update the
    // text the anchor influences.
    //

    // Undoing of the modification of the tree will be handled by other objects in
    // the undo stack.  Mucking with the tree here will royally whack stuff.
    if (dispid == DISPID_CAnchorElement_href && TLS(nUndoState) == UNDO_BASESTATE)
    {
        // we must set this flag for NS compatibility (Carled)
        // if the change occured because of a base tag change, we don't treat
        // it as a direct OM modification
        _fOMSetHasOccurred = !_fBaseUrlChanged;
        _fBaseUrlChanged = FALSE;

        IGNORE_HR( UpdateAnchorFromHref() );
    }

    hr = THR( super::OnPropertyChange( dispid, dwFlags, ppropdesc ) );

    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  member OnCaptureMessage
//
// Synopsis : This fn will be called whenever the Anchor has captured the mouse
//      it is also resposible for intiating the dragdrop behavior of anchors,
//      including the firing of ondragstart
//
//----------------------------------------------------------------------------

HRESULT BUGCALL
CAnchorElement::OnCaptureMessage(CMessage *pMessage)
{
    HRESULT                     hr = S_FALSE;
    CLayout                  *  pLayout = GetFirstBranch()->GetUpdatedNearestLayout();
    TCHAR   cBuf[pdlUrlLen];
    TCHAR *                     pchExpandedUrl = cBuf;
    CStr                        strText;
    IUniformResourceLocator *   pURLToDrag = NULL;

    switch (pMessage->message)
    {
    case WM_LBUTTONUP:
        Assert(GetFirstBranch());
        pMessage->SetNodeClk(GetFirstBranch());
        // fall-through

    case WM_MBUTTONUP:
        hr = S_OK;
        // fall-through

    case WM_RBUTTONUP:
        // Release mouse capture
        TakeCapture(FALSE);
        //Doc()->SetMouseCapture(NULL, NULL);
        break;

    case WM_MOUSEMOVE:
    {
        // If the user moves the mouse outside the wobble zone,
        // show the no-entry , plus disallow a subsequent OnClick
        POINT ptCursor = { LOWORD(pMessage->lParam), HIWORD(pMessage->lParam) };
        CDoc *  pDoc = Doc();

        if ( _fCanClick && !PtInRect(&_rcWobbleZone, ptCursor))
        {
            _fCanClick = FALSE;
        }

        // initiate drag-drop
        if (!_fCanClick && !pDoc->_fIsDragDropSrc) // && !pDoc->_pElementOMCapture)
        {
            // fully resolve URL
            if (S_OK == THR(CMarkup::ExpandUrl(NULL, GetAAhref(), ARRAY_SIZE(cBuf), pchExpandedUrl, this)))
            {
                if (pMessage->pNodeHit &&
                        pMessage->pNodeHit->TagType() == ETAG_IMG &&
                        S_OK == THR(strText.Set(
                            DYNCAST(CImgElement,pMessage->pNodeHit->Element())
                                ->GetAAalt())) ||
                    S_OK == THR(GetPlainTextInScope(&strText)))
                {
                    if (S_OK == THR(CreateLinkDataObject(pchExpandedUrl,
                                            strText,
                                            &pURLToDrag)))
                    {
                        if (!DragElement(pLayout, pMessage->dwKeyState, pURLToDrag, -1))
                        {
                            // release the capture and let someone else handle the
                            // WM_MOUSEMOVE by leaving hr=S_FALSE
                            //pDoc->SetMouseCapture(NULL,NULL);
                            TakeCapture(FALSE);
                            break;
                        }
                    }
                }
            }
        }
        // Intentional drop through to WM_SETCURSOR - WM_SETCURSOR is NOT sent
        // while the Capture is set
    }

    case WM_SETCURSOR:
    {
        LPCTSTR idc;
        if(_fCanClick)
        {
            Assert(pLayout);
            idc = GetHyperlinkCursor();
        }
        else
        {
            idc = IDC_NO;
        }

        SetCursorStyle(idc);
        hr = S_OK;
    }
    break;
    }

    ReleaseInterface(pURLToDrag);

    RRETURN1 ( hr, S_FALSE );
}

//+------------------------------------------------------------------------
//
//  Member:     CAnchorElement::HandleMessage
//
//  Synopsis:   Perform any element specific mesage handling
//
//  Arguments:  pmsg    Ptr to incoming message
//
//-------------------------------------------------------------------------

HRESULT
CAnchorElement::HandleMessage(CMessage *pMessage)
{
    // Only the marquee is allowed to cheat and pass the wrong
    // context in.  This is only done so that message bubbling will
    // skip above the marquee.  However, for operations on the anchor itself,
    // we need to use a correct context and therefore use GetFirstBranch()

    CDoc *      pDoc = Doc();
    HRESULT     hr = S_FALSE;
    HRESULT     hr2;
    CLock       Lock(this);
    BOOL        fDesignMode = IsEditable(/*fCheckContainerOnly*/FALSE);
    CTreeNode * pNodeContextReal = GetFirstBranch();

    Assert(pNodeContextReal);

    CTreeNode::CLock NodeLock;
    hr2 = THR( NodeLock.Init(pNodeContextReal) );
    if( hr2 )
    {
        hr = hr2;
        goto Cleanup;
    }

    if (    fDesignMode

            // If htc is set to something other than HTC_NO or HTC_YES,
            // it tells me that the message is a mouse messaage and that
            // the mouse is over a scrollbar or some such uninteresting
            // region. I will let the base class take care of such a
            // message. Note that htc is left as HTC_NO for non-mouse
            // messages.
        ||  (pMessage->htc != HTC_YES && pMessage->htc != HTC_NO)

        || !GetAAhref())
    {
        goto Ignored;
    }

    // now deal with the rest of the messages
    switch ( pMessage -> message )
    {
    case WM_SETCURSOR:
        {
            TCHAR * pchUrl;

            hr = GetUrlComponent(NULL, URLCOMP_WHOLE, &pchUrl);
            if (hr == S_OK && pchUrl)
            {
                SetCursorStyle(GetHyperlinkCursor());
                MemFreeString(pchUrl);
                goto Cleanup;
            }
        }
        break;
    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
        // Capture the mouse to CAnchorElement::::OnCaptureMessage
        pDoc->SetMouseCapture(
                   MOUSECAPTURE_METHOD(CAnchorElement, OnCaptureMessage, oncapturemessage),
                   this,
                   TRUE,
                   TRUE);

        // Set the limits for a mouse move before showing
        // the no entry cursor
        _rcWobbleZone.left   = LOWORD(pMessage->lParam) - g_sizeDragMin.cx;
        _rcWobbleZone.right  = LOWORD(pMessage->lParam) + g_sizeDragMin.cx + 1;
        _rcWobbleZone.top    = HIWORD(pMessage->lParam) - g_sizeDragMin.cy;
        _rcWobbleZone.bottom = HIWORD(pMessage->lParam) + g_sizeDragMin.cy + 1;
        // Can click while mouse is inside wobble zone
        _fCanClick = GetAAhref() ? TRUE : FALSE;

        // Give immediate feedback
        if(_fCanClick)
        {
            SetCursorStyle(GetHyperlinkCursor());
        }

        // The message has been handled. Kill it.
        hr = S_OK;
        break;

    case WM_CONTEXTMENU:

        hr = THR(OnContextMenu(
                    (short) LOWORD(pMessage->lParam),
                    (short) HIWORD(pMessage->lParam),
                    (IsEditable(TRUE)) ? (CONTEXT_MENU_DEFAULT)
                                   : (CONTEXT_MENU_ANCHOR)));
        break;

    case WM_CHAR:
    case WM_SYSCHAR:
        switch (pMessage->wParam)
        {
        case VK_RETURN:

            // This is being called only if anchor element has a HREF.
            // i.e. because we donot support tabbing to (and hence the RETURN on)
            // anchor elements which do not have HREFs.
            Assert (GetAAhref() != NULL) ;

            pMessage->SetNodeClk(pNodeContextReal);
            hr = S_OK;
            break ;
        }
        break ;

    case WM_MOUSEWHEEL:
        if ((pMessage->dwKeyState & FSHIFT) && (((short) HIWORD(pMessage->wParam)) > 0))
        {
            // This is being called only if anchor element has a HREF, because
            // we donot navigate to anchor elements which do not have HREFs.
            //
            Assert(GetAAhref() != NULL);
            pMessage->SetNodeClk(pNodeContextReal);
            hr = S_OK;
        }
        break;

    case WM_MOUSEOVER:
        if (!_fHasMouseOverCancelled)
        {
            SetStatusText();
        }
        // fall through
    case WM_MOUSELEAVE:
        _fHovered = pMessage->message == WM_MOUSEOVER ? TRUE : FALSE;
        UpdateFormats(pNodeContextReal);
        break;
    }

Ignored:
    if (S_FALSE == hr)
    {
        hr = THR(super::HandleMessage(pMessage));
    }
Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CAnchorElement::UpdateFormats
//
//  Synopsis:   Clear format caches, recompute them and then do any
//              necessary invalidate or recalc.
//
//-------------------------------------------------------------------------

HRESULT
CAnchorElement::UpdateFormats(CTreeNode * pNodeContext)
{
    HRESULT hr = S_OK;
    LONG iCF = pNodeContext->_iCF;
    LONG iPF = pNodeContext->_iPF;
    LONG iFF = pNodeContext->_iFF;
    THREADSTATE * pts = GetThreadState();

    // Ensure that current formats are not going anywhere
    if (iCF >= 0) pts->_pCharFormatCache->AddRefData(iCF);
    if (iPF >= 0) pts->_pParaFormatCache->AddRefData(iPF);
    if (iFF >= 0) pts->_pFancyFormatCache->AddRefData(iFF);

    // Clear the format caches
    hr = THR(EnsureFormatCacheChange(ELEMCHNG_CLEARCACHES));
    if (hr)
        goto Cleanup;

    // Cause the formats to get recomputed
    pNodeContext->GetFancyFormat();

    // if format have not changed, no invalidation necessary
    if (    pNodeContext->_iCF >= 0
        &&  pNodeContext->_iCF == iCF
        &&  pNodeContext->_iPF == iPF
        &&  pNodeContext->_iFF == iFF)
        goto Cleanup;

    // And invalidate or recalc based on differences between the old and new formats
    if (    pNodeContext->_iCF == -1
        ||  pNodeContext->_iFF == -1
        ||  iCF == -1
        ||  iFF == -1
        ||  iPF != pNodeContext->_iPF
        ||  !GetCharFormatEx(pNodeContext->_iCF)->CompareForLayout(GetCharFormatEx(iCF))
        ||  !GetFancyFormatEx(pNodeContext->_iFF)->CompareForLayout(GetFancyFormatEx(iFF)))
    {
        // invalidate, because if the element gets/loses positioning, we need two different
        // rects redrawn (before & after)
        Invalidate();
        ResizeElement(NFLAGS_FORCE);
    }
    else
    {
        SmartInvalidate();
    }
    
Cleanup:
    // Release the old format caches
    if (iCF >= 0) pts->_pCharFormatCache->ReleaseData(iCF);
    if (iPF >= 0) pts->_pParaFormatCache->ReleaseData(iPF);
    if (iFF >= 0) pts->_pFancyFormatCache->ReleaseData(iFF);
    RRETURN(hr);
}

void
CAnchorElement::TSSmartInvalidate()
{
    Assert(g_fTerminalServer);
    CTreePos *ptp;
    CTreePos *ptpStop;
    CElement *pElement;
    BOOL fContainsOnlyImages = FALSE;
    
    GetTreeExtent(&ptp, &ptpStop);
    if (!ptp || !ptpStop)
        goto Cleanup;
    ptp = ptp->NextTreePos();

    while (   ptp != NULL
           && ptp != ptpStop
          )
    {
        // Text node with text: so contains something other than only images
        if (ptp->IsText() && ptp->Cch())
            goto Cleanup;

        if (ptp->IsBeginNode())
        {
            pElement = ptp->GetBranch()->Element();

            // Begining of a nested layout: so contains something other than only images
            if (   pElement->CurrentlyHasAnyLayout()
                && ptp->GetBranch()->Tag() != ETAG_IMG
               )
            {
                goto Cleanup;
            }
        }
        ptp = ptp->NextTreePos();
    }

    // OK, contains only images.
    fContainsOnlyImages = TRUE;

Cleanup:
    if (!fContainsOnlyImages)
    {
        Invalidate();
    }
}

HRESULT
CAnchorElement::DoClick(CMessage * pMessage, CTreeNode *pNodeContext,
                        BOOL fFromLabel,
                        EVENTINFO* pEvtInfo /*= NULL*/ ,
                        BOOL fFromClick /*= FALSE */)
{
    HRESULT         hr = S_OK;
    CFlowLayout   * pLayout;

    if(!pNodeContext)
        pNodeContext = GetFirstBranch();

    if(!pNodeContext)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    Assert(pNodeContext && pNodeContext->Element() == this);

    pLayout = pNodeContext->GetFlowLayout();
    if (pLayout )
    {
        hr = super::DoClick(pMessage, pNodeContext, fFromLabel, pEvtInfo, fFromClick );
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

HRESULT
CAnchorElement::ClickAction (CMessage *pmsg)
{
    HRESULT hr = super::ClickAction(pmsg);

    if (hr == S_OK && !_fVisited)
    {
        hr = THR(SetVisited());
        if (hr)
            goto Cleanup;
    }

Cleanup:
    // Do not want this to bubble, so..
    if (S_FALSE == hr)
        hr = S_OK;

    RRETURN(hr);
}

HRESULT
CAnchorElement::SetActive( BOOL fActive )
{
    HRESULT hr = S_OK;
    BOOL    fCurrentState = _fActive;

    // UpdateFormats needs this set inorder to properly pick up the new 
    // formats.
    _fActive = fActive;

    if ( fActive != fCurrentState)
    {
        hr = ExecPseudoClassEffect(_fVisited, fActive, _fVisited, fCurrentState);
    }

    return hr;
}

HRESULT
CAnchorElement::ExecPseudoClassEffect(BOOL fVisited, BOOL fActive,
                                      BOOL fOldVisited, BOOL fOldActive)
{
    HRESULT hr = S_OK;
   
    CStyleSheetArray * pSS = GetMarkup()->GetStyleSheetArray();
    BYTE                    ab[sizeof(CFormatInfo)];
    CFormatInfo *           pInfo = (CFormatInfo*)&ab;

    // First check the anchor itself for any styles that effect
    if(pSS)
    {
       pInfo->_pNodeContext = GetFirstBranch();
       if (pSS->TestForPseudoclassEffect(pInfo,
                                         fVisited, fActive,
                                         fOldVisited, fOldActive))
       {
           hr = UpdateFormats(pInfo->_pNodeContext);
       }
       else
       {
           CChildIterator  ci( this, NULL, CHILDITERATOR_DEEP );
           CTreeNode *     pNodeCurr;

           for( pNodeCurr = ci.NextChild();
                pNodeCurr;
                pNodeCurr = ci.NextChild() )
           {
               pInfo->_pNodeContext = pNodeCurr;
               if( pSS->TestForPseudoclassEffect(pInfo,
                                                 fVisited, fActive,
                                                 fOldVisited, fOldActive))
               {
                   // make sure we skip over the curr node's
                   // subtree
                   ci.ClearDeep();
               
                   // Resize/Invalidate the current element
                   hr = UpdateFormats(pInfo->_pNodeContext);
               }
               else
               {
                   ci.SetDeep();
               }
           }

           Invalidate();
       }
    }
    else
    {
        // Resize/Invalidate the current element
        hr = UpdateFormats(GetFirstBranch());
    }
    RRETURN(hr);
}

HRESULT
CAnchorElement::SetVisited()
{
    HRESULT hr = S_OK;

    if (!Doc()->IsOffline())
    {
        _fVisited = TRUE;
        _fVisitedValid = TRUE;

        // if we are not in the tree just leave.
        if (!GetFirstBranch())
            goto Cleanup;

        hr = ExecPseudoClassEffect(_fVisited, _fActive, FALSE, _fActive);
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
// Member: get_mimeType
//
//-----------------------------------------------------------------------------
extern TCHAR * GetFileTypeInfo(TCHAR * pszFileName);

STDMETHODIMP
CAnchorElement::get_mimeType(BSTR * pMimeType)
{
    HRESULT   hr   = S_OK;
    TCHAR   * pUrl = NULL;

    * pMimeType = NULL;

    hr = get_href(&pUrl);
    if (hr)
        goto Cleanup;

    if (pUrl && !UrlIsOpaque(pUrl))
    {
        TCHAR * pCh = _tcschr(pUrl, _T('?'));
        if (pCh)
            pCh = _T('\0');

        * pMimeType = GetFileTypeInfo(pUrl);
        SysFreeString(pUrl);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
// Member: get_protocolLong
//
//-----------------------------------------------------------------------------
extern TCHAR * ProtocolFriendlyName(TCHAR * szUrl);

STDMETHODIMP
CAnchorElement::get_protocolLong(BSTR * pProtocol)
{
    HRESULT   hr      = S_OK;
    TCHAR   * pUrl    = NULL;
    TCHAR   * pResult = NULL;

    * pProtocol = NULL;

    hr = get_href(&pUrl);
    if (hr)
        goto Cleanup;

    if (pUrl)
    {
        pResult = ProtocolFriendlyName(pUrl);
        if (pResult)
        {
            int z = (_tcsncmp(pResult, 4, _T("URL:"), -1) == 0) ? (4) : (0);
            * pProtocol = SysAllocString(pResult + z);
            SysFreeString(pResult);
        }
        SysFreeString(pUrl);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
// Member: get_nameProp
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CAnchorElement::get_nameProp(BSTR * pName)
{
    *pName = NULL;

    TCHAR   * pUrl  = NULL;
    TCHAR   * pszName = NULL;
    HRESULT hr;

    hr = get_href(&pUrl);
    if (hr)
        goto Cleanup;

    if (pUrl)
    {
        pszName = _tcsrchr(pUrl, _T('/'));
        if (!pszName)
            pszName = pUrl;
        else if (*(pszName + 1) == _T('\0'))
        {
            *(pszName) = _T('\0');
            pszName = _tcsrchr(pUrl, _T('/'));
            if (!pszName)
                pszName = pUrl;
            else
                pszName ++;
        }
        else
            pszName ++;

        * pName = SysAllocString(pszName);
        SysFreeString(pUrl);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------------------
//
//  Member:     CDoc::EnumContainedURLs
//
//  Synopsis:   returns 2 arrays (containing the URLs and the associated anchor
//              strings) for a given document
//
//  Arguments:  paryURLs     - array containing URL strings
//              paryStrings  - array containing anchor strings
//
//-----------------------------------------------------------------------------

HRESULT
CDoc::EnumContainedURLs(CURLAry * paryURLs, CURLAry * paryStrings)
{
    HRESULT         hr = S_OK;
    CElement        *pAnchorOrAreaElement;
    CAnchorElement  *pAnchorElem=NULL;
    CAreaElement    *pAreaElem=NULL;
    LPCTSTR         lpctstrAnchorOrAreaAAhref;
    BOOL            fAnchorElem;
    CStr            *pStrURL;
    CStr            *pStrText;
    LONG            i, c;
    CCollectionCache *pCollectionCache;

    if (!paryURLs || !paryStrings)
    {
       hr = E_POINTER;
       goto Cleanup;
    }

    hr = THR (PrimaryMarkup()->EnsureCollectionCache(CMarkup::LINKS_COLLECTION));
    if (hr)
    {
        goto Cleanup;
    }

    pCollectionCache = PrimaryMarkup()->CollectionCache();

    c = pCollectionCache->SizeAry(CMarkup::LINKS_COLLECTION);
    for (i = 0; i < c; i++)
    {
        hr = THR (pCollectionCache->GetIntoAry(CMarkup::LINKS_COLLECTION,
                        i,
                        &pAnchorOrAreaElement));
        if (hr != S_OK)
        {
            goto Cleanup;
        }

        fAnchorElem = pAnchorOrAreaElement->_etag == ETAG_A;
        Assert(fAnchorElem || pAnchorOrAreaElement->_etag == ETAG_AREA);

        pAnchorElem = fAnchorElem ? DYNCAST (CAnchorElement, pAnchorOrAreaElement) : NULL;
        pAreaElem  = !fAnchorElem ? DYNCAST (CAreaElement, pAnchorOrAreaElement) : NULL;

        lpctstrAnchorOrAreaAAhref = fAnchorElem ? pAnchorElem->GetAAhref() : pAreaElem->GetAAhref();
        if (lpctstrAnchorOrAreaAAhref)
        {
            CStr strTmp;
            TCHAR   cBuf[pdlUrlLen];
            TCHAR *pachAbsoluteUrl = cBuf;

            hr = paryURLs->AppendIndirect(NULL, &pStrURL);
            if (hr)
                goto Cleanup;

            hr = paryStrings->AppendIndirect(NULL, &pStrText);
            if (hr)
                goto Cleanup;

            hr = THR(CMarkup::ExpandUrl(NULL, 
                lpctstrAnchorOrAreaAAhref, ARRAY_SIZE(cBuf), pachAbsoluteUrl, pAnchorOrAreaElement));
            if (hr != S_OK || !pachAbsoluteUrl)
            {
                goto Cleanup;
            }

            hr = THR(pStrURL->Set(pachAbsoluteUrl));

            if (hr != S_OK)
            {
                goto Cleanup;
            }

            hr = pAnchorOrAreaElement->GetPlainTextInScope(&strTmp);
            if (hr != S_OK)
            {
                goto Cleanup;
            }

            hr = THR (pStrText->Set(strTmp));
            if (hr != S_OK)
            {
                goto Cleanup;
            }
        }
    }

Cleanup:
    RRETURN1 (hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CAnchorElement::ShowTooltip
//
//  Synopsis:   Displays the tooltip for the site.
//
//  Arguments:  [pt]    Mouse position in container window coordinates
//              msg     Message passed to tooltip for Processing
//
//--------------------------------------------------------------------------

ExternTag(tagFormatTooltips);

HRESULT
CAnchorElement::ShowTooltip(CMessage *pmsg, POINT pt)
{
    HRESULT     hr = S_FALSE;
    CDoc *      pDoc = Doc();
    TCHAR *     pchString;
    BOOL        fRTL = FALSE;

#if DBG == 1
    if (IsTagEnabled(tagFormatTooltips))
    {
        return super::ShowTooltip(pmsg, pt);
    }
#endif

    if (pDoc->State() < OS_INPLACE)
        goto Cleanup;

    pchString = (LPTSTR) GetAAtitle();

    if ( pchString)
    {
        RECT    rc;

        // Ignore spurious WM_ERASEBACKGROUNDs generated by tooltips
        CServer::CLock Lock(pDoc, SERVERLOCK_IGNOREERASEBKGND);

        hr = THR(GetElementRc(&rc,
                              GERC_ONALINE | GERC_CLIPPED,
                              &pt));
        if (hr)
            goto Cleanup;

        // COMPLEXSCRIPT - determine if element is right to left for tooltip style setting
        if(GetFirstBranch())
        {
            fRTL = GetFirstBranch()->GetCharFormat()->_fRTL;
        }          
        if (!pDoc->_pDocPopup)
        {
            FormsShowTooltip(
                    pchString,
                    pDoc->_pInPlace->_hwnd,
                    *pmsg,
                    &rc,
                    (DWORD_PTR) GetMarkup(),
                    (DWORD_PTR) this,
                    fRTL);
        }
        hr = S_OK;
    }

Cleanup:
    return hr;
}

#ifndef NO_DATABINDING
#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

class CDBindMethodsAnchor : public CDBindMethodsSimple
{
    typedef CDBindMethodsSimple super;

public:
    CDBindMethodsAnchor() : super(VT_BSTR, DBIND_ONEWAY) {}
    ~CDBindMethodsAnchor()  {}

    virtual HRESULT BoundValueToElement(CElement *pElem, LONG id,
                                        BOOL fHTML, LPVOID pvData) const;

};

static const CDBindMethodsAnchor DBindMethodsAnchor;

const CDBindMethods *
CAnchorElement::GetDBindMethods()
{

    return &DBindMethodsAnchor;
}

//+----------------------------------------------------------------------------
//
//  Function: BoundValueToElement, CDBindMethods
//
//  Synopsis: Transfer data into bound image.  Only called if DBindKind
//            allows databinding.
//
//  Arguments:
//            [id]      - ID of binding point.  For anchor, is always
//                        DISPID_CAnchorElement_href.
//            [pvData]  - pointer to data to transfer, in this case a bstr.
//
//-----------------------------------------------------------------------------
HRESULT
CDBindMethodsAnchor::BoundValueToElement(CElement *pElem,
                                         LONG,
                                         BOOL,
                                         LPVOID pvData) const
{
    RRETURN1(DYNCAST(CAnchorElement, pElem)->put_href(*(BSTR *)pvData), S_FALSE);
}
#endif // ndef NO_DATABINDING


// URL accessors - CHyperlink overrides

HRESULT
CAnchorElement::SetUrl(BSTR bstrUrl)
{
    return (s_propdescCAnchorElementhref.b.SetUrlProperty(bstrUrl,
                                this,
                                (CVoid *)(void *)GetAttrArray()));
}


LPCTSTR
CAnchorElement::GetUrl() const
{
    return GetAAhref();
}


LPCTSTR
CAnchorElement::GetTarget() const
{
    return GetAAtarget();
}


HRESULT
CAnchorElement::GetUrlTitle(CStr * pstr)
{
    HRESULT hr;
    LPCTSTR pchTitle = GetAAtitle();

    if (pchTitle && *pchTitle)
    {
        hr = THR(pstr->Set(pchTitle));
    }
    else
    {
        hr = THR(GetPlainTextInScope(pstr));
    }

    if (OK(hr) && GetMarkup()->_fVisualOrder) 
    {
        LPTSTR pStart = *pstr;
        LPTSTR pEnd = pStart + pstr->Length() - 1;

        while (pStart < pEnd)
        {
            const TCHAR ch = *pStart;
            *pStart++ = *pEnd;
            *pEnd-- = ch;
        }
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CAnchorElement::QueryStatus, public
//
//  Synopsis:   Implements QueryStatus for CAnchorElement
//
//  Notes:      Delegates to base class
//
//----------------------------------------------------------------------------

HRESULT
CAnchorElement::QueryStatus(
        GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    TraceTag((tagMsoCommandTarget, "CAnchorElement::QueryStatus"));

    Assert(cCmds == 1);
    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));

    HRESULT  hr   = S_OK;
    MSOCMD * pCmd = &rgCmds[0];

    Assert(!pCmd->cmdf);

    if (!hr && !pCmd->cmdf)
    {
        hr = THR_NOTRACE(super::QueryStatusHelper(pguidCmdGroup, cCmds, rgCmds, pcmdtext));
    }

    if (!hr && !pCmd->cmdf)
    {
        hr = THR_NOTRACE(CElement::QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext));
    }

    RRETURN_NOTRACE(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CAnchorElement::Exec, public
//
//  Synopsis:   Executes a command on the CAnchorElement
//
//  Notes:      Delegates to base class
//
//----------------------------------------------------------------------------

HRESULT
CAnchorElement::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    TraceTag((tagMsoCommandTarget, "CAnchorElement::Exec"));

    HRESULT hr = MSOCMDERR_E_NOTSUPPORTED;

    if (hr == MSOCMDERR_E_NOTSUPPORTED)
    {
        hr = THR_NOTRACE(super::ExecHelper(
                    pguidCmdGroup,
                    nCmdID,
                    nCmdexecopt,
                    pvarargIn,
                    pvarargOut));
    }

    if (hr == MSOCMDERR_E_NOTSUPPORTED)
    {
        hr = THR_NOTRACE(CElement::Exec(
                pguidCmdGroup,
                nCmdID,
                nCmdexecopt,
                pvarargIn,
                pvarargOut));
    }
    RRETURN_NOTRACE(hr);
}

HRESULT CAnchorElement::focus() { return super::focus(); };
HRESULT CAnchorElement::blur() { return super::blur(); };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\earea.cxx ===
//=-----------------------------------------------------------=
//
// File:        earea.cxx
//
// Contents:    Area element class
//
// Classes:     CAreaElement
//
//=-----------------------------------------------------------=


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MATH_H_
#define X_MATH_H_
#include "math.h"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"   // For AnchorPropertyPage
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_EMAP_HXX_
#define X_EMAP_HXX_
#include "emap.hxx"
#endif

#ifndef X_JSPROT_HXX_
#define X_JSPROT_HXX_
#include "jsprot.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_RECT_HXX_
#define X_RECT_HXX_
#include "rect.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#define _cxx_
#include "area.hdl"

MtDefine(CAreaElement, Elements, "CAreaElement")
MtDefine(CImgAreaStub, Elements, "CImgAreaStub")

ExternTag(tagMsoCommandTarget);

#ifndef NO_PROPERTY_PAGE
const CLSID * const CAreaElement::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
#endif // DBG==1    
    NULL
};
#endif // NO_PROPERTY_PAGE


const CElement::CLASSDESC CAreaElement::s_classdesc =
{
    {
    &CLSID_HTMLAreaElement,             // _pclsid
    0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
    s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
    s_acpi,                             // _pcpi
    ELEMENTDESC_NOLAYOUT,               // _dwFlags
    &IID_IHTMLAreaElement,              // _piidDispinterface
    &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLAreaElement,   // _pfnTearOff
    NULL                                // _pAccelsRun
};


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      Creation and Initialization
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

//=-----------------------------------------------------------------------=
//
// Function:    CreateElement
//
// Synopsis:    Creates an instance of the given element's class
//
// Arguments:   CHtmTag *pht - struct for tag creation info.
//              CElement *pElementParent - The parent of the element
//              CElement **ppElement - Return ptr to element in *ppElement.
//
//=-----------------------------------------------------------------------=
HRESULT
CAreaElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    HRESULT hr = S_OK;

    Assert(pht->Is(ETAG_AREA));
    Assert(ppElement);

    *ppElement = new CAreaElement(pDoc);

    if (!*ppElement)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
Cleanup:
    RRETURN(hr);
}

//=-----------------------------------------------------------------------=
//
// Function:    Init2()
//
// Synopsis:    Overridden to set netscape events (copied from
//              CAnchorElement::Init2()).
//
//=-----------------------------------------------------------------------=

HRESULT
CAreaElement::Init2(CInit2Context * pContext)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = Doc();

    Assert(pDoc);
    if (pDoc)
    {
        // Set default shape and parse the coords string if needed
        if (!_fShapeSet)
        {
            // No shape attribute is specified in the HTML
            _nShapeType = SHAPE_TYPE_RECT;
            _fShapeSet = TRUE;
            if (!_strCoords.IsNull())
            {
                hr = ParseCoords();
            }
        }

    }

    RRETURN(super::Init2(pContext));
}

//=-----------------------------------------------------------------------=
//
// Function:    GetcoordsHelper
//
// Synopsis:    Gets the coordinates attribute
//
// Arguments:   BSTR *bstrCOORDS - Pointer to BSTR for COORDS
//
//=-----------------------------------------------------------------------=
HRESULT
CAreaElement::GetcoordsHelper(CStr *pstrCOORDS)
{
    HRESULT hr = S_OK;
    TCHAR   achTemp[1024];
    int     c;
    int     nOffset;
    POINT  *ppt;
    BOOL    fFirst;

    Assert(pstrCOORDS);

    *achTemp = 0;
    switch(_nShapeType)
    {
    case SHAPE_TYPE_RECT:
        hr = THR(Format(0,
                &achTemp,
                ARRAY_SIZE(achTemp),
                _T("<0d>,<1d>,<2d>,<3d>"),
                (long)_coords.Rect.left,
                (long)_coords.Rect.top,
                (long)_coords.Rect.right,
                (long)_coords.Rect.bottom));
        if (hr)
            goto Cleanup;
        hr = THR(pstrCOORDS->Set(achTemp));
        break;

    case SHAPE_TYPE_CIRCLE:
        hr = THR(Format(0,
                &achTemp,
                ARRAY_SIZE(achTemp),
                _T("<0d>,<1d>,<2d>"),
                (long)_coords.Circle.lx,
                (long)_coords.Circle.ly,
                (long)_coords.Circle.lradius));
        if (hr)
            goto Cleanup;
        hr = THR(pstrCOORDS->Set(achTemp));
        break;

    case SHAPE_TYPE_POLY:
        hr = THR(pstrCOORDS->Set(_T("")));
        if (hr)
            goto Cleanup;
        fFirst = TRUE;
        for(c = _ptList.Size(), ppt = _ptList; c > 0; c--, ppt++)
        {
            if (fFirst)
            {
                fFirst = FALSE;
                nOffset = 0;
            }
            else
            {
                achTemp[0] = _T(',');
                nOffset = 1;
            }
            hr = THR(Format(0,
                    &(achTemp[nOffset]),
                    ARRAY_SIZE(achTemp)-nOffset,
                    _T("<0d>,<1d>"),
                    ppt->x,
                    ppt->y));
            if (hr)
                goto Cleanup;
            hr = THR(pstrCOORDS->Append(achTemp));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN ( hr );
}

//=-----------------------------------------------------------------------=
//
// Function:    SetcoordsHelper
//
// Synopsis:    Sets the coordinates attribute
//
// Arguments:   CStr pstrCOORDS - String containing COORDS
//
//=-----------------------------------------------------------------------=
HRESULT
CAreaElement::SetcoordsHelper(CStr *pstrCOORDS)
{
    if (!pstrCOORDS->Length())
        RRETURN(S_OK);

    // Copy the buffer for tokenizing
    _strCoords.Set(*pstrCOORDS);

    // Don;t parse this yet if we don't know the shape
    if (!_fShapeSet)
    {
        RRETURN(S_OK);
    }
    RRETURN(ParseCoords());
}

//=-----------------------------------------------------------------------=
//
// Function:    NextNumInDevicePixelsY
//
// Synopsis:    Return the next num in doc pixels instead of device
//
//=-----------------------------------------------------------------------=

HRESULT 
CAreaElement::NextNumInDevicePixelsY(LONG *plNum, TCHAR **ppch)
{
    HRESULT hr;

    hr = THR(NextNum(plNum, ppch));
    if (FAILED(hr)) 
        goto Cleanup;

    *plNum = g_uiDisplay.DeviceFromDocPixelsY(*plNum);

Cleanup:
    RRETURN(hr);
}

//=-----------------------------------------------------------------------=
//
// Function:    NextNumInDevicePixelsX
//
// Synopsis:    Return the next num in doc pixels instead of device
//
//=-----------------------------------------------------------------------=

HRESULT 
CAreaElement::NextNumInDevicePixelsX(LONG *plNum, TCHAR **ppch)
{
    HRESULT hr;

    hr = THR(NextNum(plNum, ppch));
    if (FAILED(hr)) 
        goto Cleanup;

    *plNum = g_uiDisplay.DeviceFromDocPixelsX(*plNum);

Cleanup:
    RRETURN(hr);
}

//=-----------------------------------------------------------------------=
//
// Function:    ParseCoords
//
// Synopsis:    Parses the input string and sets the coordinates attribute.
//
//=-----------------------------------------------------------------------=
HRESULT
CAreaElement::ParseCoords()
{
    POINT pt;
    TCHAR *pch;

    Assert(_fShapeSet);
    Assert(_strCoords.Length());

    //
    // Grab the first token.  If _tcstok returns NULL,
    // we want to keep processing, because this means they
    // gave us an empty coordinate string.  Right now,
    // missing values are set to 0.
    //

    pch = _tcstok(_strCoords, DELIMS);

    switch(_nShapeType)
    {
    case SHAPE_TYPE_RECT:
        NextNumInDevicePixelsX(&_coords.Rect.left, &pch);
        NextNumInDevicePixelsY(&_coords.Rect.top, &pch);
        NextNumInDevicePixelsX(&_coords.Rect.right, &pch);
        NextNumInDevicePixelsY(&_coords.Rect.bottom, &pch);

        UpdateRectangle();
        break;

    case SHAPE_TYPE_CIRCLE:
        NextNumInDevicePixelsX(&_coords.Circle.lx, &pch);
        NextNumInDevicePixelsY(&_coords.Circle.ly, &pch);
        NextNumInDevicePixelsX(&_coords.Circle.lradius, &pch);

        break;

    case SHAPE_TYPE_POLY:
        if(_ptList.Size())
        {
            _ptList.DeleteMultiple(0, _ptList.Size() - 1);
        }
        while(pch)
        {
            NextNumInDevicePixelsX(&pt.x, &pch);
            NextNumInDevicePixelsY(&pt.y, &pch);
           _ptList.AppendIndirect(&pt);
        }
        if (_ptList.Size())
        {
            // We don't store the same point as first and last
            if((_ptList[0].x == _ptList[_ptList.Size() - 1].x) &&
               (_ptList[0].y == _ptList[_ptList.Size() - 1].y))
            {
                _ptList.Delete(_ptList.Size() - 1);
            }
        }
        UpdatePolygon();
        break;
    }

    _strCoords.Free();
    RRETURN(S_OK);
}


//=-----------------------------------------------------------------------=
//
// Function:    GetshapeHelper
//
// Synopsis:    Gets the Shape attribute
//
// Arguments:   BSTR *bstrSHAPE - Pointer to BSTR for SHAPE
//
//=-----------------------------------------------------------------------=
HRESULT
CAreaElement::GetshapeHelper(CStr *pstrSHAPE)
{
    HRESULT hr = S_OK;
    Assert(pstrSHAPE);

    switch(_nShapeType)
    {
    case SHAPE_TYPE_RECT:
        hr = THR ( pstrSHAPE -> Set (_T("RECT")) );
        break;

    case SHAPE_TYPE_CIRCLE:
        hr = THR ( pstrSHAPE -> Set (_T("CIRCLE")) );
        break;

    case SHAPE_TYPE_POLY:
        hr = THR ( pstrSHAPE -> Set (_T("POLY")) );
        break;
    }


    RRETURN ( hr );
}


//=-----------------------------------------------------------------------=
//
// Function:    SetshapeHelper
//
// Synopsis:    Sets the shape attribute
//
// Arguments:   BSTR bstrSHAPE - BSTR containing SHAPE
//
//=-----------------------------------------------------------------------=
HRESULT
CAreaElement::SetshapeHelper(CStr *pstrSHAPE)
{
    HRESULT hr = S_OK;

    if (!*pstrSHAPE)
    {
        _nShapeType = SHAPE_TYPE_RECT;
    }
    else if (!StrCmpIC(*pstrSHAPE, _T("CIRC")) ||
         !StrCmpIC(*pstrSHAPE, _T("CIRCLE")))
    {
        _nShapeType = SHAPE_TYPE_CIRCLE;
    }
    else if (!StrCmpIC(*pstrSHAPE, _T("POLY")) ||
         !StrCmpIC(*pstrSHAPE, _T("POLYGON")))
    {
        _nShapeType = SHAPE_TYPE_POLY;
    }
    else
    {
        _nShapeType = SHAPE_TYPE_RECT;
    }

    // Parse the coords string if needed
    if (!_fShapeSet)
    {
        _fShapeSet = TRUE;
        if (!_strCoords.IsNull())
        {
            hr = ParseCoords();
        }
    }


    RRETURN(hr);
}



///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      End Creation and Initialization
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      Destructor
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

void CAreaElement::Passivate()
{
    if(_nShapeType == SHAPE_TYPE_POLY && _coords.Polygon.hPoly)
    {
        DeleteObject(_coords.Polygon.hPoly);
        _coords.Polygon.hPoly = NULL;
    }

    super::Passivate();
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      End Destructor
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      Drawing related Code
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////



//=-----------------------------------------------------------------------=
//
// Function:    Draw
//
// Synopsis:    Performs the drawing of the Area, given a DC
//
// Arguments:   CFormDrawInfo * pDI - draw info
//              CElement *      pImg- Associated image
//
//=-----------------------------------------------------------------------=

HRESULT
CAreaElement::Draw(CFormDrawInfo * pDI, CElement * pImg)
{
    CRect   rcFocus, rcImg;
    LONG    xOff, yOff;
    XHDC    hdc  = pDI->GetDC(TRUE);

    Assert(pImg);
    Assert(pImg->Doc());
    Assert(pImg->Doc()->_pInPlace);

    DYNCAST(CImgElement, pImg)->_pImage->GetRectImg(&rcImg);
    xOff = rcImg.left;
    yOff = rcImg.top;

    // Should not come here in browse mode
    Assert(pImg->IsEditable(TRUE));

    switch(_nShapeType)
    {
    case SHAPE_TYPE_RECT:
        rcFocus.left    = _coords.Rect.left     + xOff;
        rcFocus.top     = _coords.Rect.top      + yOff;
        rcFocus.right   = _coords.Rect.right    + xOff;
        rcFocus.bottom  = _coords.Rect.bottom   + yOff;
        Rectangle(hdc, rcFocus.left, rcFocus.top,
            rcFocus.right, rcFocus.bottom);
        break;

    case SHAPE_TYPE_CIRCLE:
        Ellipse(hdc,
            _coords.Circle.lx - _coords.Circle.lradius + xOff,
            _coords.Circle.ly - _coords.Circle.lradius + yOff,
            _coords.Circle.lx + _coords.Circle.lradius + xOff,
            _coords.Circle.ly + _coords.Circle.lradius + yOff);

        break;

    case SHAPE_TYPE_POLY:
        POINT *ppt;
        UINT c;

        // Do we have enough points to draw a polygon ?
        if (_ptList.Size() < 2)
            break;

        MoveToEx(hdc, _ptList[0].x + xOff, _ptList[0].y + yOff, (POINT *)NULL);
        for(c = _ptList.Size(), ppt = &(_ptList[1]);
            c > 1;                  // c > 1, because we MoveTo'd the first pt
            ppt++, c--)
        {
            LineTo(hdc, ppt->x + xOff, ppt->y + yOff);
        }
        //
        // If there are only 2 points in the polygon, we don't want to draw
        // the same line twice and end up with nothing!
        //

        if(_ptList.Size() != 2)
        {
            LineTo(hdc, _ptList[0].x + xOff, _ptList[0].y + yOff);

        }
        break;

    default:
        Assert(FALSE && "Invalid Shape");

        break;
    }

    return S_OK;
}

//=-----------------------------------------------------------------------=
//
// Function:    GetBoundingRect
//
// Synopsis:    Returns the bounding rectangle for the area.
//
//=-----------------------------------------------------------------------=
void
CAreaElement::GetBoundingRect(RECT *prc)
{
    int i;

    switch(_nShapeType)
    {
    case SHAPE_TYPE_RECT:
        *prc = _coords.Rect;
        break;
    case SHAPE_TYPE_CIRCLE:
        prc->left = _coords.Circle.lx - _coords.Circle.lradius;
        prc->top = _coords.Circle.ly - _coords.Circle.lradius;
        prc->right = _coords.Circle.lx + _coords.Circle.lradius;
        prc->bottom = _coords.Circle.ly + _coords.Circle.lradius;
        break;
    case SHAPE_TYPE_POLY:
        if (_ptList.Size() == 0)
            break;
        prc->left = prc->right = _ptList[0].x;
        prc->top = prc->bottom = _ptList[0].y;
        for (i = _ptList.Size() - 1; i > 0; i--)
        {
            if (_ptList[i].x < prc->left)
            {
                prc->left = _ptList[i].x;
            }
            else if (_ptList[i].x > prc->right)
            {
                prc->right = _ptList[i].x;
            }
            if (_ptList[i].y < prc->top)
            {
                prc->top = _ptList[i].y;
            }
            else if (_ptList[i].y > prc->bottom)
            {
                prc->bottom = _ptList[i].y;
            }
        }
        break;
    }
}


//=-----------------------------------------------------------------------=
//
// Function:    UpdatePolygon
//
// Synopsis:    Updates the internal polygon region.
//
// Notes:       Should only be called if the region is actually a
//              SHAPE_TYPE_POLY.
//
//=-----------------------------------------------------------------------=
HRESULT
CAreaElement::UpdatePolygon()
{
    HRGN hNew;

    Assert(_nShapeType == SHAPE_TYPE_POLY);

    hNew = CreatePolygonRgn(_ptList, _ptList.Size(), ALTERNATE);

    if(hNew == NULL)
    {
        return E_OUTOFMEMORY;
    }
    else
    {
        if (_coords.Polygon.hPoly)
            DeleteObject(_coords.Polygon.hPoly);
        _coords.Polygon.hPoly = hNew;

        return S_OK;
    }
}


//=-----------------------------------------------------------------------=
//
// Function:    UpdateRectangle
//
// Synopsis:    Updates the rectangle coordinates.
//
// Notes:       Should only be called if the region is actually a
//              SHAPE_TYPE_RECT.
//
//=-----------------------------------------------------------------------=
HRESULT
CAreaElement::UpdateRectangle()
{
    LONG ltemp;

    Assert(_nShapeType == SHAPE_TYPE_RECT);

    if(_coords.Rect.left > _coords.Rect.right)
    {
        ltemp = _coords.Rect.left;
        _coords.Rect.left = _coords.Rect.right;
        _coords.Rect.right = ltemp;
    }

    if(_coords.Rect.top > _coords.Rect.bottom)
    {
        ltemp = _coords.Rect.top;
        _coords.Rect.top = _coords.Rect.bottom;
        _coords.Rect.bottom = ltemp;
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      End Modification/Update Code
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// Helpers

HRESULT
CAreaElement::InsertIntoElemTree ( CMapElement * pMap, long lItemIndex )
{
    HRESULT    hr = S_OK;
    CTreeNode *pNodeAdjacentTo;
    Where      adjacencyHow;

    if (lItemIndex <= 0)
    {
        pNodeAdjacentTo = pMap->GetFirstBranch();
        adjacencyHow = AfterBegin;
    }
    else
    {
        CChildIterator ci(pMap);
        CTreeNode * pNode;
        LONG lIndex = 0;

        pNodeAdjacentTo = NULL;
        adjacencyHow = AfterEnd;

        while ((pNode = ci.NextChild()) != NULL)
        {
            if (pNode->Tag() == ETAG_AREA)
            {
                if (lItemIndex-1 == lIndex)
                {
                    if (ci.NextChild())
                    {
                        pNodeAdjacentTo = pNode;
                    }
                    break;
                }

                lIndex += 1;
            }
        }

        if (pNodeAdjacentTo == NULL)
        {
            pNodeAdjacentTo = pMap->GetFirstBranch();
            adjacencyHow = BeforeEnd;
        }
    }

    Assert(pNodeAdjacentTo);

    hr = THR( pNodeAdjacentTo->Element()->InsertAdjacent( adjacencyHow, this ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}

HRESULT
CAreaElement::RemoveFromElemTree()
{
    HRESULT hr;

    hr = THR( RemoveOuter() );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}


HRESULT
CAreaElement::focus()
{
    HRESULT hr = S_OK;
    CNotification   nf;
    CMarkup *       pMarkup = GetMarkup();

    // we could have been created and not added to the tree yet
    if (!pMarkup || !pMarkup->GetElementClient())
        goto Cleanup;

    nf.AreaFocus(pMarkup->GetElementClient(), this);
    pMarkup->Notify(&nf);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CAreaElement::blur()
{
    HRESULT         hr = S_OK;
    CImgElement *   pImg;
    long            lIndex;
    CDoc *          pDoc = Doc();
    
    Assert(pDoc);

    // don't blur if the img is not current, this area is not the _pArea
    // or the frame in which this object is, does not currently have the focus
    if (!pDoc->_pInPlace ||
        ::GetFocus() != pDoc->_pInPlace->_hwnd ||
        pDoc->_pElemCurrent->Tag() != ETAG_IMG)
        goto Cleanup;

    //
    // Search for this area in the current element's map.
    //

    pImg = DYNCAST(CImgElement, pDoc->_pElemCurrent);
    pImg->EnsureMap();
    if (!pImg->GetMap())
        goto Cleanup;

    if (!OK(pImg->GetMap()->SearchArea(this, &lIndex)))
        goto Cleanup;
    
    // make the body the current site. Become current handles all the event firing
    hr = THR(pImg->blur());

Cleanup:
    RRETURN(hr);
}

void
CAreaElement::Notify(CNotification *pNF)
{
    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_BASE_URL_CHANGE: 
        _fBaseUrlChanged = TRUE;
        OnPropertyChange( DISPID_CAreaElement_href, 
                          ((PROPERTYDESC *)&s_propdescCAreaElementhref)->GetdwFlags(),
                          (PROPERTYDESC *)&s_propdescCAreaElementhref);
        break;
    case NTYPE_ELEMENT_QUERYMNEMONICTARGET:
        *(FOCUS_ITEM *)pNF->DataAsPtr() = GetFocusItem();
        break;
    }
}


FOCUS_ITEM
CAreaElement::GetFocusItem()
{
    FOCUS_ITEM          fi;
    CElement *          pElem       = NULL;
    CImgElement *       pImg        = NULL;
    int                 i, c;
    CCollectionCache*   pCollectionCache;

    fi.pElement = NULL;
    fi.lSubDivision = 0;

    if (!IsInMarkup())
        goto Cleanup;

    // Search the document's collection for the first image that has this AREA as
    // a subdivision.
    if (S_OK != THR(GetMarkup()->EnsureCollectionCache(CMarkup::IMAGES_COLLECTION)))
        goto Cleanup;

    pCollectionCache = GetMarkup()->CollectionCache();

    // get size of collection
    c = pCollectionCache->SizeAry(CMarkup::IMAGES_COLLECTION);

    for (i = 0; i < c; i++)
    {
        if (S_OK != THR(pCollectionCache->GetIntoAry(CMarkup::IMAGES_COLLECTION, i, &pElem)))
            goto Cleanup;

        if (pElem->Tag() != ETAG_IMG)
            continue;

        pImg = DYNCAST(CImgElement, pElem);
        if (!pImg->EnsureAndGetMap())
            continue;

        if (OK(pImg->GetMap()->SearchArea(this, &fi.lSubDivision)))
        {
            fi.pElement = pImg;
            break;
        }
    }
Cleanup:
    return fi;
}


HRESULT
CAreaElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{

    switch (dispid)
    {
    case DISPID_CAreaElement_href:
        _fOMSetHasOccurred = !_fBaseUrlChanged;
        _fBaseUrlChanged = FALSE;
        break;

    case DISPID_CElement_tabIndex:
        {
            CNotification   nf;
            CMarkup *       pMarkup = GetMarkup();

            // we could have been created and not added to the tree yet
            if (!pMarkup || !pMarkup->GetElementClient())
                break;

            nf.AreaTabindexChange(pMarkup->GetElementClient(), this);
            pMarkup->Notify(&nf);
        }
        break;
    }
    
    return super::OnPropertyChange( dispid, dwFlags, ppropdesc );
}


// URL accessors - CHyperlink overrides

HRESULT
CAreaElement::SetUrl(BSTR bstrUrl)
{
    return (s_propdescCAreaElementhref.b.SetUrlProperty(bstrUrl,
                this,
                (CVoid *)(void *)GetAttrArray()));
}


LPCTSTR
CAreaElement::GetUrl() const
{
    return GetAAhref();
}


LPCTSTR
CAreaElement::GetTarget() const
{
    return GetAAtarget();
}


HRESULT
CAreaElement::GetUrlTitle(CStr *pstr)
{
    pstr->Set(GetAAalt());
    if (pstr->Length() == 0)
        pstr->Set(GetAAtitle());
    return S_OK;
}


HRESULT
CAreaElement::ClickAction (CMessage *pmsg)
{
    HRESULT hr = super::ClickAction(pmsg);

    // Do not want this to bubble, so..
    if (S_FALSE == hr)
        hr = S_OK;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\ebgsound.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       ebgsound.cxx
//
//  Contents:   CBGsound & related
//
//
//----------------------------------------------------------------------------

#include "headers.hxx"      // for the world

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"     // for cbitsctx
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"     // for celement
#endif

#ifndef X_EBGSOUND_HXX_
#define X_EBGSOUND_HXX_
#include "ebgsound.hxx"     // for cbgsound
#endif

#ifndef X_MMPLAY_HXX_
#define X_MMPLAY_HXX_
#include "mmplay.hxx"       // for ciemmplayer
#endif

#define _cxx_
#include "bgsound.hdl"      

MtDefine(CBGsound, Elements, "CBGsound")
extern BOOL IsScriptUrl(LPCTSTR pszURL);

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
const CBGsound::CLASSDESC CBGsound::s_classdesc =
{
    {
        &CLSID_HTMLBGsound,                 // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                               // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLBGsound,                  // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLBGsound
};

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
HRESULT CBGsound::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);

    *ppElement = new CBGsound(pDoc);

    return *ppElement ? S_OK : E_OUTOFMEMORY;
}


HRESULT
CBGsound::EnterTree()
{
    GWPostMethodCall(this, ONCALL_METHOD(CBGsound, OnSrcAvailable, onsrcavailable), 0, TRUE, "CBGsound::OnSrcAvailable");

    return S_OK;
}

void
CBGsound::OnSrcAvailable(DWORD_PTR dwContext)
{
    CDoc *pDoc = Doc();

    if (pDoc && (pDoc->State() >= OS_INPLACE))
        _fIsInPlace = TRUE;
    AddRef();
    THR(OnPropertyChange(DISPID_CBGsound_src, 
                         0, 
                         (PROPERTYDESC *)&s_propdescCBGsoundsrc));
    Release();
}


//+---------------------------------------------------------------------------
//
//  Member:     CBGSound::Init2
//
//  Synopsis:   Init override
//
//----------------------------------------------------------------------------

HRESULT 
CBGsound::Init2(CInit2Context * pContext)
{
    CDoc * pDoc = Doc();

    pDoc->_fBroadcastInteraction = TRUE;
    pDoc->_fBroadcastStop = TRUE;

    RRETURN(super::Init2(pContext));
}

//+---------------------------------------------------------------------------
//
//  Member:     CBGSound::Notify
//
//  Synopsis:   Handle notifications
//
//----------------------------------------------------------------------------

void
CBGsound::Notify(CNotification *pNF)
{
    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_DOC_STATE_CHANGE_1:
        if (!!_fIsInPlace != (Doc()->State() >= OS_INPLACE))
        {
            pNF->SetSecondChanceRequested();
        }
        break;

    case NTYPE_DOC_STATE_CHANGE_2:
        {
            CDoc * pDoc = Doc();

            Assert( !!_fIsInPlace != (pDoc->State() >= OS_INPLACE) );

            _fIsInPlace = pDoc->State() >= OS_INPLACE;

            SetAudio();

            if (_pBitsCtx && _fIsInPlace)
            {
                DWNLOADINFO dli;
                if( SUCCEEDED ( GetMarkup()->InitDownloadInfo(&dli) ) )
                {
                    _pBitsCtx->SetLoad(TRUE, &dli, FALSE);
                }
            }
        }
        break;

    case NTYPE_STOP_1:
    case NTYPE_MARKUP_UNLOAD_1:
        if (_pBitsCtx)
            _pBitsCtx->SetLoad(FALSE, NULL, FALSE);

        if (_pSoundObj)
            pNF->SetSecondChanceRequested();
        break;

    case NTYPE_STOP_2:
    case NTYPE_MARKUP_UNLOAD_2:
        if (_pSoundObj)
        {
            _pSoundObj->Stop();    // stop whatever we were playing
            _fStopped = TRUE;
        }
        break;

    case NTYPE_ENABLE_INTERACTION_1:
        pNF->SetSecondChanceRequested();
        break;

    case NTYPE_ENABLE_INTERACTION_2:
        SetAudio();
        break;

    case NTYPE_ACTIVE_MOVIE:
        {
            void * pv;

            pNF->Data(&pv);

            if (_pSoundObj && (pv == this))
                _pSoundObj->NotifyEvent();              
                // Let the sound object know something happened
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        if (_pSoundObj)
        {
            pNF->SetSecondChanceRequested();
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_2:
        {
            if(!_pSoundObj->Release())
                _pSoundObj = NULL;
        }
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        EnterTree();
        break;
        
    case NTYPE_BASE_URL_CHANGE:
        OnPropertyChange( DISPID_CBGsound_src, 
                          ((PROPERTYDESC *)&s_propdescCBGsoundsrc)->GetdwFlags(),
                          (PROPERTYDESC *)&s_propdescCBGsoundsrc);
        break;
    }
}


void
CBGsound::SetBitsCtx(CBitsCtx * pBitsCtx)
{
    if (_pBitsCtx)
    {
        if (_pSoundObj)
        {
            _pSoundObj->Stop();    // stop whatever we were playing
            ClearInterface(&_pSoundObj);
        }
        
        _pBitsCtx->SetProgSink(NULL); // detach download from document's load progress
        _pBitsCtx->Disconnect();
        _pBitsCtx->Release();
    }

    _pBitsCtx = pBitsCtx;

    if (pBitsCtx)
    {
        pBitsCtx->AddRef();

        _fStopped = FALSE;

        if (pBitsCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
            OnDwnChan(pBitsCtx);
        else
        {
            pBitsCtx->SetProgSink(CMarkup::GetProgSinkHelper(GetMarkup()));
            pBitsCtx->SetCallback(OnDwnChanCallback, this);
            pBitsCtx->SelectChanges(DWNCHG_COMPLETE, 0, TRUE);
        }
    }
}

//+------------------------------------------------------------------------
//
//  Method:     CBgsound::SetAudio
//
//-------------------------------------------------------------------------

void CBGsound::SetAudio()
{
    CDoc *  pDoc = Doc();

    if (!_pSoundObj)
        return;

    if (_fIsInPlace && pDoc->_fEnableInteraction && !_fStopped && !IsPrintMedia())
    {
        _pSoundObj->SetNotifyWindow(pDoc->GetHWND(), WM_ACTIVEMOVIE, (LONG_PTR)this);
        _pSoundObj->Play();
    }
    else
    {
        _pSoundObj->SetNotifyWindow(NULL, WM_ACTIVEMOVIE, (LONG_PTR)this);
        _pSoundObj->Stop();
    }
}

//+------------------------------------------------------------------------
//
//  Method:     CBGsound::OnDwnChan
//
//-------------------------------------------------------------------------

void CBGsound::OnDwnChan(CDwnChan * pDwnChan)
{
    ULONG ulState = _pBitsCtx->GetState();
    BOOL fDone = FALSE;
    TCHAR * pchFile = NULL;

    if (ulState & DWNLOAD_COMPLETE)
    {
        fDone = TRUE;

        BOOL fPendingRoot = FALSE;

        if (IsInMarkup())
            fPendingRoot = GetMarkup()->IsPendingRoot();

        // If security redirect occurred, we may need to blow away doc's lock icon
        Doc()->OnSubDownloadSecFlags(fPendingRoot, _pBitsCtx->GetUrl(), _pBitsCtx->GetSecFlags());

        // Ensure a sound object
        if(!_pSoundObj)
        {
            _pSoundObj = (CIEMediaPlayer *)new (CIEMediaPlayer);

            if(!_pSoundObj)
                goto Nosound;
        }


        _pSoundObj->AddRef();
        if((S_OK == _pBitsCtx->GetFile(&pchFile)) &&
           (S_OK == _pSoundObj->SetURL(pchFile)))       // Initialize & RenderFile
        {
            // Set the volume & balance values
            //

            // if the colume property is not initialized to something within range 
            // get the value from the soundobject and set it to that
            //
            if(GetAAvolume() > 0)   // range is -10000 to 0
            {
                VARIANT vtLong;

                vtLong.vt = VT_I4;
                vtLong.lVal = _pSoundObj->GetVolume();

                put_VariantHelper(vtLong, (PROPERTYDESC *)&s_propdescCBGsoundvolume);
            }
            else
                _pSoundObj->SetVolume(GetAAvolume());

            if(GetAAbalance() > 10000)   // range is -10000 to 10000
            {
                VARIANT vtLong;

                vtLong.vt = VT_I4;
                vtLong.lVal = _pSoundObj->GetBalance();

                put_VariantHelper(vtLong, (PROPERTYDESC *)&s_propdescCBGsoundbalance);
            }
            else
                _pSoundObj->SetBalance(GetAAbalance());

            _pSoundObj->SetLoopCount(GetAAloop());

            SetAudio();
        }
        _pSoundObj->Release();
    }
    else if (ulState & (DWNLOAD_STOPPED | DWNLOAD_ERROR))
    {
        fDone = TRUE;
    }

Nosound:
    if (fDone)
    {
        _pBitsCtx->SetProgSink(NULL); // detach download from document's load progress
    }

    MemFreeString(pchFile);
    
}

//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange
//
//  Note:       Called after a property has changed to notify derived classes
//              of the change.  All properties (except those managed by the
//              derived class) are consistent before this call.
//
//              Also, fires a property change notification to the site.
//
//-------------------------------------------------------------------------

HRESULT CBGsound::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;
    CDoc *pDoc = Doc();

    switch (dispid)
    {
        case DISPID_CBGsound_src:
        {
            // Should we even play the sound?
            if (pDoc->_dwLoadf & DLCTL_BGSOUNDS)
            {
                CBitsCtx *pBitsCtx = NULL;
                LPCTSTR szUrl = GetAAsrc();

                BOOL fPendingRoot = FALSE;

                if (IsInMarkup())
                    fPendingRoot = GetMarkup()->IsPendingRoot();

                if ( ! IsScriptUrl( szUrl ))
                {
                    hr = THR(pDoc->NewDwnCtx(DWNCTX_FILE, szUrl, this,
                                (CDwnCtx **)&pBitsCtx, fPendingRoot));

                    if (hr == S_OK)
                    {
                        SetBitsCtx(pBitsCtx);

                        if (pBitsCtx)
                            pBitsCtx->Release();
                    }
                }
            }
            break;
        }

        case DISPID_CBGsound_loop:
            if(_pSoundObj)
                _pSoundObj->SetLoopCount(GetAAloop());
            break;

        case DISPID_CBGsound_balance:
            if(_pSoundObj)
                _pSoundObj->SetBalance(GetAAbalance());
            break;
        
        case DISPID_CBGsound_volume:
            if(_pSoundObj)
                _pSoundObj->SetVolume(GetAAvolume());
            break;
    }

    if (OK(hr))
        hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));

    RRETURN(hr);
}

//--------------------------------------------------------------------------
//
//  Method:     CBGsound::Passivate
//
//  Synopsis:   Shutdown main object by releasing references to
//              other objects and generally cleaning up.  This
//              function is called when the main reference count
//              goes to zero.  The destructor is called when
//              the reference count for the main object and all
//              embedded sub-objects goes to zero.
//
//              Release any event connections held by the form.
//
//--------------------------------------------------------------------------

void CBGsound::Passivate(void)
{
    ClearInterface(&_pSoundObj);
    SetBitsCtx(NULL);
    super::Passivate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\eblock.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eblock.cxx
//
//  Contents:   Block element class
//
//  Classes:    CBlockElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#ifndef X_EBLOCK_HXX_
#define X_EBLOCK_HXX_
#include "eblock.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "block.hdl"

MtDefine(CBlockElement, Elements, "CBlockElement")

const CElement::CLASSDESC CBlockElement::s_classdesc =
{
    {
        &CLSID_HTMLBlockElement,            // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLBlockElement,             // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLBlockElement,      // _apfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CBlockElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert( pht->Is(ETAG_ADDRESS)  || pht->Is(ETAG_BLOCKQUOTE) ||
            pht->Is(ETAG_CENTER)   || pht->Is(ETAG_LISTING) ||
            pht->Is(ETAG_XMP)      || pht->Is(ETAG_PRE) ||
            pht->Is(ETAG_PLAINTEXT));

    Assert(ppElement);
    *ppElement = new CBlockElement(pht->GetTag(), pDoc);
    return *ppElement ? S_OK: E_OUTOFMEMORY;
}


//+------------------------------------------------------------------------
//
//  Member:     CBlockElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CBlockElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLBlockElement, NULL)
        QI_HTML_TEAROFF(this, IHTMLBlockElement2, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


HRESULT
CBlockElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr  = S_OK;
    CDoc *  pDoc = Doc();
    LONG lFontHeightTwips;

    if (pCFI->_ppf->_fTabStops)
    {
        pCFI->PrepareParaFormat();
        pCFI->_pf()._fTabStops = FALSE;
        pCFI->UnprepareForDebug();
    }

    //
    // Apply default indents and before/after space.
    // NOTE: Indents and before/after space are outside our box (== margins), 
    //       so they are relative to the parent's text flow.
    //
    BOOL fParentVertical = pCFI->_pNodeContext->IsParentVertical();

    switch(Tag())
    {
    case ETAG_ADDRESS:
        pCFI->PrepareCharFormat();
        pCFI->_cf()._fItalic = TRUE;
        pCFI->UnprepareForDebug();
        break;

    case ETAG_BLOCKQUOTE:
        {
            pCFI->PrepareParaFormat();
            pCFI->PrepareFancyFormat();

            pCFI->_pf()._cuvOffsetPoints.SetPoints( LIST_FIRST_REDUCTION_POINTS );
            pCFI->_pf()._cuvNonBulletIndentPoints.SetPoints(
                    pCFI->_pf()._cuvNonBulletIndentPoints.GetPoints() +
                    BLOCKQUOTE_INDENT_POINTS );

            ApplyDefaultVerticalSpace(fParentVertical, &pCFI->_ff());

            // Set the default indent values
            CUnitValue uv;
            uv.SetPoints(BLOCKQUOTE_INDENT_POINTS);
            if (fParentVertical)
            {
                if (pCFI->_ff().GetMargin(SIDE_TOP).IsNullOrEnum())
                    pCFI->_ff().SetMargin(SIDE_TOP, uv);
                if (pCFI->_ff().GetMargin(SIDE_BOTTOM).IsNullOrEnum())
                    pCFI->_ff().SetMargin(SIDE_BOTTOM, uv);
            }
            else
            {
                if (pCFI->_ff().GetMargin(SIDE_LEFT).IsNullOrEnum())
                    pCFI->_ff().SetMargin(SIDE_LEFT, uv);
                if (pCFI->_ff().GetMargin(SIDE_RIGHT).IsNullOrEnum())
                    pCFI->_ff().SetMargin(SIDE_RIGHT, uv);
            }
            pCFI->_ff()._fHasMargins = TRUE;

            pCFI->UnprepareForDebug();
        }
        break;

    case ETAG_CENTER:
        pCFI->_bBlockAlign     = (BYTE) htmlBlockAlignCenter;
        pCFI->_bCtrlBlockAlign = (BYTE) htmlBlockAlignCenter;
        break;

    case ETAG_LISTING:
        // NB (cthrash) Inside a listing, we drop the font size by 2.
        // We drop it by one here, and then set BUMPSIZEDOWN on
        // to drop another.
        pCFI->PrepareCharFormat();
        pCFI->_cf().ChangeHeightRelative( -1 );
        pCFI->UnprepareForDebug();
    case ETAG_XMP:
    case ETAG_PRE:
    case ETAG_PLAINTEXT:
        pCFI->PrepareParaFormat();
        pCFI->_pf()._fTabStops = TRUE;
        pCFI->_pf()._fHasPreLikeParent = TRUE;
        pCFI->UnprepareForDebug();

        pCFI->_fPre = TRUE;
        pCFI->_fInclEOLWhite = TRUE;
        pCFI->_fNoBreak = TRUE;

        pCFI->PrepareCharFormat();
        pCFI->_cf()._fBumpSizeDown = TRUE;
        pCFI->UnprepareForDebug();

        if (Tag() != ETAG_PLAINTEXT)
        {
            pCFI->PrepareFancyFormat();
            ApplyDefaultVerticalSpace(fParentVertical, &pCFI->_ff());
        }
        else
        {
            // Netscape puts a lot of space between PLAINTEXT and the preceeding lines.
            pCFI->PrepareFancyFormat();
            ApplyDefaultVerticalSpace(fParentVertical, &pCFI->_ff(), 26);
        }

        {
            pCFI->PrepareCharFormat();

            CMarkup * pMarkup = GetMarkup();
            CODEPAGESETTINGS * pCS = pMarkup->GetCodepageSettings();

            if (!pCS)
                pCS = pDoc->PrimaryMarkup()->GetCodepageSettings();

            // Thai does not have a fixed pitch font. Leave it as proportional
            if (pMarkup->GetCodePage() != CP_THAI)
            {
                pCFI->_cf()._bPitchAndFamily = FIXED_PITCH;
                pCFI->_cf().SetFaceNameAtom(pCS->latmFixedFontFace);
                if (pCFI->_cf().NeedAtFont())
                {
                    ApplyAtFontFace(&pCFI->_cf(), Doc(), GetMarkup());
                }
            }
            pCFI->_cf()._bCharSet = pCS->bCharSet;
            pCFI->_cf()._fNarrow = IsNarrowCharSet(pCFI->_cf()._bCharSet);

        }
        pCFI->UnprepareForDebug();
        break;

    case ETAG_P:
        pCFI->PrepareFancyFormat();
        ApplyDefaultBeforeSpace(fParentVertical, &pCFI->_ff());
        if (_fExplicitEndTag)
        {
            ApplyDefaultAfterSpace(fParentVertical, &pCFI->_ff());
        }
        pCFI->UnprepareForDebug();
        // Note that we inherit the after space from the parent.
        break;
    }

    // we need to call super AFTER the above code, because this is where in-linestyles get
    //  applied. by calling super first we overwrote explicitly set values (e.g. margin-top)
    hr = THR(super::ApplyDefaultFormat(pCFI));
    if(hr)
        goto Cleanup;

    // set up for potential EM, EN, ES converstions

    lFontHeightTwips = pCFI->_pcf->GetHeightInTwips(pDoc);
    if (lFontHeightTwips <= 0)
        lFontHeightTwips = 1;

    if (pCFI->_ppf->_lFontHeightTwips != lFontHeightTwips)
    {
        pCFI->PrepareParaFormat();
        pCFI->_pf()._lFontHeightTwips = lFontHeightTwips;
        pCFI->UnprepareForDebug();
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CBlockElement::Save
//
//  Synopsis:   Save the tag to the specified stream.
//
//-------------------------------------------------------------------------

HRESULT
CBlockElement::Save(CStreamWriteBuff * pStmWrBuff, BOOL fEnd)
{
    HRESULT hr;
    BOOL    fPreLikeElement = (   Tag() == ETAG_LISTING
                               || Tag() == ETAG_PLAINTEXT
                               || Tag() == ETAG_XMP
                               || Tag() == ETAG_PRE);

    if (!fEnd)
    {
        if (fPreLikeElement)
        {
            pStmWrBuff->BeginPre();

            if (Tag() != ETAG_PRE)
            {
                pStmWrBuff->ClearFlags(WBF_ENTITYREF);
            }
        }
    }

    hr = THR( super::Save(pStmWrBuff, fEnd) );
    if (hr)
        goto Cleanup;

    if (fPreLikeElement)
    {
        if (    fEnd 
            &&  (   !pStmWrBuff->GetElementContext() 
                 || GetFirstCp() >= pStmWrBuff->GetElementContext()->GetFirstCp() ) )
        {
            pStmWrBuff->EndPre();
            
            if (Tag() != ETAG_PRE)
            {
                pStmWrBuff->SetFlags(WBF_ENTITYREF);
            }

            if (pStmWrBuff->TestFlag(WBF_SAVE_PLAINTEXT) && !(pStmWrBuff->TestFlag(WBF_FORMATTED)))
            {
                pStmWrBuff->NewLine();
            }
        }
    }


Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\ebr.cxx ===
//+---------------------------------------------------------------------
//
//   File:      ebr.cxx
//
//  Contents:   BR element class
//
//  Classes:    CBRElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EBR_HXX_
#define X_EBR_HXX_
#include "ebr.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include <strbuf.hxx>
#endif

#define _cxx_
#include "br.hdl"

MtDefine(CBRElement, Elements, "CBRElement")

const CElement::CLASSDESC CBRElement::s_classdesc =
{
    {
        &CLSID_HTMLBRElement,               // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLBRElement,                // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLBRElement,         // _pfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CBRElement::CreateElement(
    CHtmTag *pht,
    CDoc *pDoc,
    CElement **ppElement)
{
    Assert(pht->Is(ETAG_BR));

    Assert(ppElement);
    *ppElement = new CBRElement(pDoc);
    return *ppElement ? S_OK: E_OUTOFMEMORY;
}


HRESULT
CBRElement::Save(
    CStreamWriteBuff * pStreamWrBuff,
    BOOL fEnd )
{
    HRESULT hr;

    hr = THR( super::Save(pStreamWrBuff, fEnd) );
    if (hr)
        goto Cleanup;

    if (fEnd && pStreamWrBuff->TestFlag(WBF_SAVE_PLAINTEXT))
    {
        hr = THR( pStreamWrBuff->NewLine() );
    }

Cleanup:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\edlist.cxx ===
//+---------------------------------------------------------------------
//
//   File:      edlist.cxx
//
//  Contents:   Ordered List Element class
//
//  Classes:    CDListElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EDLIST_HXX_
#define X_EDLIST_HXX_
#include "edlist.hxx"
#endif

#define _cxx_
#include "dlist.hdl"

const CElement::CLASSDESC CDListElement::s_classdesc =
{
    {
        &CLSID_HTMLDListElement,            // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLDListElement,             // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLDListElement,      // _pfnTearOff
    NULL                                    // _pAccelsRun
};


//+------------------------------------------------------------------------
//
//  Member:     CDListElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CDListElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if IID_HTML_TEAROFF(this, IHTMLDListElement, NULL)
    else
    {
        RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    (*(IUnknown **)ppv)->AddRef();
    return S_OK;
}


HRESULT CDListElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(pht->Is(ETAG_DL));
    Assert(ppElementResult);
    *ppElementResult = new CDListElement(pDoc);
    return *ppElementResult ? S_OK : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\edt.cxx ===
//+---------------------------------------------------------------------
//
//   File:      edd.cxx
//
//  Contents:   DT element class
//
//  Classes:    CDTElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EDT_HXX_
#define X_EDT_HXX_
#include "edt.hxx"
#endif

#ifndef X_ELIST_HXX_
#define X_ELIST_HXX_
#include "elist.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#define _cxx_
#include "dt.hdl"

MtDefine(CDTElement, Elements, "CDTElement")

const CElement::CLASSDESC CDTElement::s_classdesc =
{
    {
        &CLSID_HTMLDTElement,               // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLDTElement,                // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLDTElement,         // _apfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CDTElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_DT));

    Assert(ppElement);
    *ppElement = new CDTElement(pDoc);
    return *ppElement ? S_OK: E_OUTOFMEMORY;
}

HRESULT 
CDTElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr = S_OK;

    pCFI->PrepareParaFormat();
    pCFI->_pf()._cListing.SetType( CListing::DEFINITION );
    pCFI->UnprepareForDebug();

    pCFI->PrepareFancyFormat();
    pCFI->_ff()._cuvSpaceBefore.SetValue(0, CUnitValue::UNIT_POINT);
    pCFI->UnprepareForDebug();

    pCFI->PrepareFancyFormat();
    pCFI->_ff()._cuvSpaceAfter.SetValue(0, CUnitValue::UNIT_POINT);
    pCFI->UnprepareForDebug();

    hr = THR(super::ApplyDefaultFormat(pCFI));
    if(hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\efont.cxx ===
//+---------------------------------------------------------------------
//
//   File:      efont.cxx
//
//  Contents:   Font element class
//
//  Classes:    CFontElement, CBaseFontElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EFONT_HXX_
#define X_EFONT_HXX_
#include "efont.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#define _cxx_
#include "font.hdl"

#define _cxx_
#include "basefont.hdl"

MtDefine(CFontElement, Elements, "CFontElement")
MtDefine(CBaseFontElement, Elements, "CBaseFontElement")

const CElement::CLASSDESC CFontElement::s_classdesc =
{
    {
        &CLSID_HTMLFontElement,             // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLFontElement,              // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLFontElement,       //_apfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CFontElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_FONT));
    Assert(ppElement);
    *ppElement = new CFontElement(pDoc);
    return *ppElement ? S_OK: E_OUTOFMEMORY;
}



//+-------------------------------------------------------------------
//
//  Member:     Add Attributes
//
//  Synopsis:   For all unspecified attributes in 'this', the attributes
//              of pElement are merged in.  The caller is expected to
//              to delete the pElement after this operation.
//
//--------------------------------------------------------------------

HRESULT
CFontElement::CombineAttributes( CFontElement * pFont )
{
    HRESULT hr = S_OK;
    LPCTSTR pchFace;

    Assert( ETAG_FONT == pFont->Tag() );

    if (GetFontSize().IsNull())
    {
        hr = THR( SetAAsize(pFont->GetFontSize()) );
        if (hr)
            goto Cleanup;
    }

    if (!GetAAcolor().IsDefined())
    {
        hr = THR( SetAAcolor(pFont->GetAAcolor()) );
        if (hr)
            goto Cleanup;
    }

    pchFace = GetAAface();
    if ( !(pchFace && pchFace[0]) )
    {
        hr = THR( SetAAface(pFont->GetAAface()) );
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     RemoveAttributes
//
//  Synopsis:   Remove attributes specified in pFont for 'this.'
//              If all attributes were stripped, pfAttrBagEmpty
//              return true and the caller should free this object.
//
//--------------------------------------------------------------------

HRESULT
CFontElement::RemoveAttributes(
    CFontElement *pFont,
    BOOL * pfAttrBagEmpty )
{
    HRESULT hr=S_OK;
    BOOL fKeepThis = FALSE;
    
    Assert( ETAG_FONT == pFont->Tag() );

    if (!GetFontSize().IsNull())
    {
        if (!pFont->GetFontSize().IsNull())
        {
            CUnitValue cuv;
            cuv.SetNull();
            IGNORE_HR( SetAAsize(cuv) );
        }
        else
        {
            fKeepThis = TRUE;
        }
    }        

    if (GetAAcolor().IsDefined())
    {
        if (pFont->GetAAcolor().IsDefined())
        {
            IGNORE_HR( SetAAcolor(VALUE_UNDEF) );
        }
        else
        {
            fKeepThis = TRUE;
        }
    }

    LPCTSTR pchFace = GetAAface();
    if ( pchFace && pchFace[0] )
    {
        pchFace = pFont->GetAAface();
        if (pchFace && pchFace[0])
        {
            hr = THR( SetAAface(NULL) );
            if (hr)
                goto Cleanup;
        }
        else
        {
            fKeepThis = TRUE;
        }
    }

Cleanup:
    *pfAttrBagEmpty = !fKeepThis;

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//  Member:     CFontElement::ApplyDefaultFormat()
//
//  Synopsis:   Apply the default formats of the font element.
//-----------------------------------------------------------------------------
HRESULT
CFontElement::ApplyDefaultFormat(CFormatInfo * pCFI)
{
    HRESULT hr;

    // If this is an empty font tag, it should reset the font size
    if(!_pAA)
    {
        CUnitValue cuv;

        cuv.SetValue(0, CUnitValue::UNIT_RELATIVE);

        hr = THR(SetAAsize(cuv));
        if (hr)
            goto Cleanup;
    }

    hr = THR(super::ApplyDefaultFormat(pCFI));
Cleanup:
    RRETURN(hr);
}


//+-----------------------------------------------------
//
//  Member : CBaseFontElement::GetFontSize()
//
//  Synopsis : a wrapper function for the AttrArray access
//      method.
//
//+------------------------------------------------------
CUnitValue
CFontElement::GetFontSize( void )
{
    CUnitValue uvSize= GetAAsize();
    long lAASize = uvSize.GetUnitValue(); 

    //if it is valid
    lAASize = (lAASize<MIN_FONT_SIZE) ? MIN_FONT_SIZE : lAASize;
    lAASize = (lAASize>MAX_FONT_SIZE) ? MAX_FONT_SIZE : lAASize;

    uvSize.SetValue(lAASize, uvSize.GetUnitType());

    return uvSize;
}
//============================================================
//
//  CBaseFontElement Methods
//
//============================================================

const CElement::CLASSDESC CBaseFontElement::s_classdesc =
{
    {
        &CLSID_HTMLBaseFontElement,         // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLBaseFontElement,          // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLBaseFontElement,   // _ApfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CBaseFontElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_BASEFONT));
    Assert(ppElement);
    *ppElement = new CBaseFontElement(pDoc);
    return *ppElement ? S_OK: E_OUTOFMEMORY;
}

//+-----------------------------------------------------
//
//  Member : CBaseFontElement::GetFontSize()
//
//  Synopsis : a wrapper function for the AttrArray access
//      method.
//
//+------------------------------------------------------
long
CBaseFontElement::GetFontSize( void )
{
    long lAASize = GetAAsize(); 

    //if it is valid
    lAASize = (lAASize<MIN_BASEFONT) ? MIN_BASEFONT : lAASize;
    lAASize = (lAASize>MAX_BASEFONT) ? MAX_BASEFONT : lAASize;


    return lAASize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\edd.cxx ===
//+---------------------------------------------------------------------
//
//   File:      edd.cxx
//
//  Contents:   DD element class
//
//  Classes:    CDDElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EDD_HXX_
#define X_EDD_HXX_
#include "edd.hxx"
#endif

#ifndef X_ELIST_HXX_
#define X_ELIST_HXX_
#include "elist.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#define _cxx_
#include "dd.hdl"

MtDefine(CDDElement, Elements, "CDDElement")

const CElement::CLASSDESC CDDElement::s_classdesc =
{
    {
        &CLSID_HTMLDDElement,               // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLDDElement,                // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLDDElement,         // apfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CDDElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_DD));
    Assert(ppElement);
    *ppElement = new CDDElement(pDoc);
    return *ppElement ? S_OK: E_OUTOFMEMORY;
}

HRESULT
CDDElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr = S_OK;

    // Restart leveling. This means that nested DLs under this DD will
    // not indent anymore. This is all for Netscape compatibility.
    pCFI->PrepareParaFormat();
    pCFI->_pf()._cListing.SetLevel(0);
    pCFI->_pf()._cListing.SetType(CListing::DEFINITION);
    pCFI->UnprepareForDebug();

    pCFI->PrepareFancyFormat();
    pCFI->_ff()._cuvSpaceBefore.SetPoints(0);
    pCFI->_ff()._cuvSpaceAfter.SetPoints(0);
        pCFI->UnprepareForDebug();

    hr = THR(super::ApplyDefaultFormat(pCFI));
    if(hr)
        goto Cleanup;

    // If we're under a DL, we indent the whole paragraph, otherwise,
    // just the first line.
    if (pCFI->_pNodeContext->Ancestor(ETAG_DL))
    {
        pCFI->PrepareFancyFormat();

        BYTE    side;
        side = !pCFI->_ppf->HasRTL(TRUE) ? SIDE_LEFT : SIDE_RIGHT;
        side = !pCFI->_pff->FlipSides(pCFI->_pNodeContext->IsParentVertical(), pCFI->_pcf->_fWritingModeUsed) 
                ? side : (++side % SIDE_MAX);

        const CUnitValue &uvSideMargin = pCFI->_ff().GetMargin(side);

        if (    uvSideMargin.IsNullOrEnum()
            &&  (   !HasMarkupPtr() 
                ||  !GetMarkupPtr()->IsStrictCSS1Document() 
                ||  !pCFI->_ff().HasExplicitMargin(side) 
                ||  uvSideMargin.GetUnitType() != CUnitValue::UNIT_ENUM 
                ||  uvSideMargin.GetUnitValue() != styleAutoAuto    ) 
            )
        {
            CUnitValue uv;
            uv.SetPoints(LIST_INDENT_POINTS);
            pCFI->_ff().SetMargin(side, uv);
        }

        pCFI->_ff()._fHasMargins = TRUE;

        pCFI->UnprepareForDebug();
    }
    else
    {
        pCFI->PrepareParaFormat();
        pCFI->_pf()._fFirstLineIndentForDD = TRUE;
        pCFI->UnprepareForDebug();
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\eform.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eform.cxx
//
//  Contents:   Form element class, etc..
//
//  Classes:    CFormElement, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include <cguid.h>
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_BTNHLPER_HXX_
#define X_BTNHLPER_HXX_
#include "btnhlper.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_TEXTAREA_HXX_
#define X_TEXTAREA_HXX_
#include "textarea.hxx"
#endif

#ifndef X_INPUTBTN_HXX_
#define X_INPUTBTN_HXX_
#include "inputbtn.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_POSTDATA_HXX_
#define X_POSTDATA_HXX_
#include "postdata.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_INPUTLYT_HXX_
#define X_INPUTLYT_HXX_
#include "inputlyt.hxx"
#endif

#ifndef X_TAREALYT_HXX_
#define X_TAREALYT_HXX_
#include "tarealyt.hxx"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif


#if defined(_M_ALPHA)
#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif
#endif

#define _cxx_
#include "eform.hdl"

// Needs this for the IHTMLElementCollection interface
#define _hxx_
#include "collect.hdl"

DeclareTag(tagFormElement, "Form Element", "Form Element methods")
ExternTag(tagFormEncoding);

MtDefine(CFormElement, Elements, "CFormElement")
MtDefine(BldFormElementCol, PerfPigs, "Build CFormElement::FORM_ELEMENT_COLLECTION")
MtDefine(BldFormNamedImgCol, PerfPigs, "Build CFormElement::FORM_NAMED_IMG_COLLECTION")
MtDefine(BldFormSubmitCol, PerfPigs, "Build CFormElement::FORM_SUBMIT_COLLECTION")

#ifndef NO_PROPERTY_PAGE
const CLSID * const CFormElement::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif // DBG==1    
    NULL
};
#endif // NO_PROPERTY_PAGE


BEGIN_TEAROFF_TABLE(CFormElement, IProvideMultipleClassInfo)
    TEAROFF_METHOD(CFormElement, GetClassInfo, getclassinfo, (ITypeInfo ** ppTI))
    TEAROFF_METHOD(CFormElement, GetGUID, getguid, (DWORD dwGuidKind, GUID * pGUID))
    TEAROFF_METHOD(CFormElement, GetMultiTypeInfoCount, getmultitypeinfocount, (ULONG *pcti))
    TEAROFF_METHOD(CFormElement, GetInfoOfIndex, getinfoofindex, (
            ULONG iti,
            DWORD dwFlags,
            ITypeInfo** pptiCoClass,
            DWORD* pdwTIFlags,
            ULONG* pcdispidReserved,
            IID* piidPrimary,
            IID* piidSource))
END_TEAROFF_TABLE()


const CElement::CLASSDESC CFormElement::s_classdesc =
{
    {
        &CLSID_HTMLFormElement,             // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLFormElement,              // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLFormElement,       // _pfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CFormElement::CreateElement(CHtmTag *pht, CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_FORM));
    Assert(ppElement);
    *ppElement = new CFormElement(pDoc);
    return *ppElement ? S_OK: E_OUTOFMEMORY;
}


#if 0 // (JHarding): We need to be in a tree before adding ourselves to the
      // script collection, so this logic has moved to after we get our
      // enter tree notification
//+---------------------------------------------------------------------------
//
//  Member :    CFormElement::Init2
//
//  Synopsis:   Last chance to init.
//
//+---------------------------------------------------------------------------

HRESULT
CFormElement::Init2(CInit2Context * pContext)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = Doc();
    CScriptCollection * pScriptCollection;

    Assert (!_pTypeInfoElements);
    Assert (!_pTypeInfoCoClassElements);
    Assert (!_pTypeInfoImgs);
    Assert (!_pTypeInfoCoClassImgs);

    if (!pDoc || pContext->_pTargetMarkup->_fDesignMode)
        goto Cleanup;

    //
    // Add this form as a named item to the script engine.
    // This is to enable scriptlets for children of the form.  Also
    // to keep compatibility with IE.
    //
    pScriptCollection = pContext->_pTargetMarkup->GetScriptCollection();

    if (pScriptCollection)
    {
        hr = THR(pScriptCollection->AddNamedItem(this));
        if (hr)
            goto Cleanup;
    }

    hr = THR(super::Init2(pContext));

Cleanup:
    RRETURN(hr);
}
#endif // 0

//+---------------------------------------------------------------------------
//
//  Member :    CFormElement::Passivate
//
//  Synopsis:   1st stage destructor.
//
//+---------------------------------------------------------------------------

void
CFormElement::Passivate()
{
    ClearInterface(&_pTypeInfoElements);
    ClearInterface(&_pTypeInfoCoClassElements);
    ClearInterface(&_pTypeInfoImgs);
    ClearInterface(&_pTypeInfoCoClassImgs);

    // Free Radio groups
    while (_pRadioGrpName)
    {
        RADIOGRPNAME  *pRadioGroup = _pRadioGrpName->_pNext;

        SysFreeString((BSTR)_pRadioGrpName->lpstrName);
        delete _pRadioGrpName;
        _pRadioGrpName = pRadioGroup;
    }

    super::Passivate();
}


//+---------------------------------------------------------------------------
//
//  Member :    CFormElement::PrivateQueryInterface
//
//  Synopsis:   per IPrivateUnknown.
//
//+---------------------------------------------------------------------------

HRESULT
CFormElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF2(this, IProvideClassInfo, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF2(this, IProvideClassInfo2, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF(this, IHTMLSubmitData, NULL);
        QI_HTML_TEAROFF(this, IHTMLFormElement2, NULL);
        QI_TEAROFF(this, IHTMLFormElement3, NULL)

        default:
            RRETURN(super::PrivateQueryInterface(iid, ppv));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    (*(IUnknown **)ppv)->AddRef();

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     Getelements
//
//  Synopsis:   Return the form elements collection dispatch.  This is just
//              the "controls" in the form, not all elements.
//
//-------------------------------------------------------------------------

HRESULT
CFormElement::get_elements(IDispatch ** ppElemCol)
{
    TraceTag((tagFormElement, "Getelements"));

    HRESULT hr;

    if (!ppElemCol)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppElemCol = NULL;

    hr = THR_NOTRACE(QueryInterface(IID_IDispatch, (void**)
                ppElemCol));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     EnsureCollectionCache
//
//  Synopsis:   Create the form's collection cache if needed.
//
//-------------------------------------------------------------------------

HRESULT
CFormElement::EnsureCollectionCache()
{
    TraceTag((tagFormElement, "EnsureCollectionCache"));

    HRESULT         hr = S_OK;

    if (!_pCollectionCache)
    {
        _pCollectionCache = new CCollectionCache(
                this,
                GetWindowedMarkupContext(),
                ENSURE_METHOD(CFormElement, EnsureCollections, ensurecollections));
        if (!_pCollectionCache)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pCollectionCache->InitReservedCacheItems(FORM_NUM_COLLECTIONS,
            FORM_ELEMENT_COLLECTION /* Identitiy Collection Form == Form.elements */ ));
        if (hr)
            goto Error;

        //
        // To incorporate the VBScript engine dynamic type library, the form calls
        // BuildObjectTypeInfo to create a dynamic type info based on the FORM_ELEMENT_COLLECTION
        // starting at DISPID_COLLECTION_MIN
        //
        // We create two collections on the FORM element:-
        //
        // FORM_ELEMENT_COLLECTION is the "elements" collection used to resolve most names,
        // and serves as the identity collection
        //
        // FORM_NAMED_IMG_COLLECTION contains named IMGs scoped to the FORM. This mimics a Nav feature where named IMG's
        // appear in the name space of the FORM, but not as ordinals in the collection.
        //

        _pCollectionCache->SetDISPIDRange (
            FORM_ELEMENT_COLLECTION,
            DISPID_FORM_ELEMENT_GN_MIN,
            DISPID_FORM_ELEMENT_GN_MAX );

        // Turn off ordinal promotion on the named IMG collection, this stops us
        // resolving ordinals when we call GetIDsOfNamesEx in it.
        _pCollectionCache->DontPromoteOrdinals ( FORM_NAMED_IMG_COLLECTION );

        // Set the DISPID range for the second collection, so we can distinguish between the two
        // in Invoke

        _pCollectionCache->SetDISPIDRange (
            FORM_NAMED_IMG_COLLECTION,
            DISPID_FORM_NAMED_IMG_GN_MIN,
            DISPID_FORM_NAMED_IMG_GN_MAX );
    }

Cleanup:
    RRETURN(hr);

Error:
    delete _pCollectionCache;
    _pCollectionCache = NULL;
    goto Cleanup;
}


void
CFormElement::Notify(CNotification * pnf)
{
    // Do this before super::Notify
    switch( pnf->Type() )
    {
    case NTYPE_ELEMENT_ENTERTREE:
        FormEnterTree();
        break;
    }

    super::Notify(pnf);

    // Do these after super::Notify
    switch (pnf->Type())
    {
    case NTYPE_ELEMENT_EXITTREE_1:
        if (_pSubmitData)
            pnf->SetSecondChanceRequested();
        break;

    case NTYPE_ELEMENT_EXITTREE_2:
        delete _pSubmitData;
        _pSubmitData = NULL;
        break;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     EnsureCollections
//
//  Synopsis:   Refresh the form elements collection, if needed.
//
//-------------------------------------------------------------------------

HRESULT
CFormElement::EnsureCollections(long lIndex, long * plCollectionVersion)
{
    TraceTag((tagFormElement, "EnsureCollections Version:%d", *plCollectionVersion));

    CMarkup *   pMarkupPtr;
    long        lSize;
    long        l;
    HRESULT     hr;
    LPCTSTR     szFormName;
    BOOL fAddToNamedImages = FALSE, fAddToSubmit = FALSE,fAddToElements = FALSE ;
    CCollectionCache *pCollectionCache;

#ifdef PERFMETER
    static PERFMETERTAG s_mpColMtr[] = { Mt(BldFormElementCol), Mt(BldFormNamedImgCol), Mt(BldFormSubmitCol) };
#endif

    hr = THR(EnsureInMarkup());
    if (hr)
        goto Cleanup;

    pMarkupPtr = GetMarkupPtr();
    Assert(pMarkupPtr);

    // For
    // Makes sure the doc's collections are up-to-date.
    l = *plCollectionVersion;
    hr = THR(pMarkupPtr->EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    // Nothing to do so get out.
    if (*plCollectionVersion == pMarkupPtr->GetMarkupTreeVersion())
        return S_OK;

    MtAdd(s_mpColMtr[lIndex], +1, 0);

    if ( lIndex == FORM_NAMED_IMG_COLLECTION )
        fAddToNamedImages = TRUE;
    else if ( lIndex == FORM_SUBMIT_COLLECTION )
        fAddToSubmit = TRUE;
    else if ( lIndex == FORM_ELEMENT_COLLECTION )
        fAddToElements = TRUE;

    pCollectionCache = pMarkupPtr->CollectionCache();

    hr = THR(pCollectionCache->GetIntoAry(CMarkup::ELEMENT_COLLECTION, this, &l));
    if (hr)
        goto Cleanup;

    // Get the size of the doc's elements collection (0).
    lSize = pCollectionCache->SizeAry(CMarkup::ELEMENT_COLLECTION);

    // Reset the arrays before loading them.  This is the Member cache, not the Markup cache!
    _pCollectionCache->ResetAry(lIndex);

    szFormName = GetAAname();

    // Reload this collection.
    for (++l; l < lSize; ++l)
    {
        CElement * pElemCandidate;
        CTreeNode * pNodeCandidate;

        WHEN_DBG( pElemCandidate = NULL; )

        hr = THR(
            pCollectionCache->GetIntoAry( CMarkup::ELEMENT_COLLECTION, l, & pElemCandidate ) );

        if (hr)
            goto Error;

        Assert( pElemCandidate );
        pNodeCandidate = pElemCandidate->GetFirstBranch();
        Assert ( pNodeCandidate );

        //
        // Search for the element to ensure that it is within the form.  If not
        // then break out.
        //

        if (!pNodeCandidate->SearchBranchToRootForScope(this))
            break;              // Yes, so we're done.

        switch (pNodeCandidate->TagType())
        {
            //
            // If this ever changes, please change the
            // CDoc::AddToCollections list also
            //
        case ETAG_IMG:
            // Add named IMGs scoped by this
            if ( fAddToNamedImages )
            {
                hr = THR(_pCollectionCache->SetIntoAry( FORM_NAMED_IMG_COLLECTION,
                            pElemCandidate ));
                if (hr)
                    goto Error;
            }
            break;

        case ETAG_INPUT:
            // Ignore INPUT TYPE=IMAGE
            if (DYNCAST(CInput, pNodeCandidate->Element())->GetAAtype() == htmlInputImage)
            {
                if ( fAddToSubmit )
                {
                    hr = THR(_pCollectionCache->SetIntoAry( FORM_SUBMIT_COLLECTION,
                                pElemCandidate ));
                }
                break;
            }
            hr = S_OK;
            // otherwise intentional fall through

        case ETAG_FIELDSET :
        case ETAG_BUTTON:
        case ETAG_SELECT:
        case ETAG_TEXTAREA:
#ifdef  NEVER
        case ETAG_HTMLAREA:
#endif
        case ETAG_OBJECT:
        case ETAG_EMBED:
            if ( fAddToElements )
            {
                hr = THR(_pCollectionCache->SetIntoAry( FORM_ELEMENT_COLLECTION,
                            pElemCandidate ));
                if (hr)
                    goto Error;
            }
            if ( fAddToSubmit )
            {
                hr = THR(_pCollectionCache->SetIntoAry( FORM_SUBMIT_COLLECTION,
                            pElemCandidate ));
                if (hr)
                    goto Error;
            }
            break;
        default:
            if ( fAddToSubmit && pElemCandidate->HasPeerHolder())
            {
                HRESULT hrSubmit = S_OK;
                IElementBehaviorSubmit * pSubmit = NULL;

                hrSubmit = pElemCandidate->GetPeerHolder()->QueryPeerInterfaceMulti( 
                    IID_IElementBehaviorSubmit,
                    (void**)&pSubmit, 
                    FALSE );

                if (hrSubmit == S_OK)
                {
                    hr = THR(_pCollectionCache->SetIntoAry( FORM_SUBMIT_COLLECTION,
                            pElemCandidate ));
                }

                if (pSubmit)
                    pSubmit->Release();
            }
        }
    }

    *plCollectionVersion = pMarkupPtr->GetMarkupTreeVersion();

Cleanup:
    RRETURN(hr);

Error:
    _pCollectionCache->ResetAry(lIndex);
    goto Cleanup;
}


//+--------------------------------------------------------------
//
//  Member:     CFormElement::CallGetSubmitInfo
//
//  Synopsis:   Iterate thru elements, and call GetSubmitinfo on them.
//              this should construct the get/post data string in the
//              format: n=v[&n=v[...]]\0
//
//---------------------------------------------------------------
HRESULT
CFormElement::CallGetSubmitInfo( 
        CElement * pSubmitSite,
        CElement** ppInputImg,
        int      * pnMultiLines,
        int      * pnFieldsChanged,
        BOOL       fUseUtf8, /*= FALSE*/
        CODEPAGE   cp /*= NULL*/)
{
    HRESULT                     hr;
    ULONG                       i;
    BOOL                        fCanUseUTF8         = Utf8InAcceptCharset();
    ULONG                       cElements           = 0;
    BOOL                        fUseSubmitInterface = FALSE;
    IHTMLSubmitData *           pSubmitData         = NULL;

    TraceTag((tagFormEncoding, "CFormElement::CallGetSubmitInfo called. fUseUtf8: %d, cp %d", fUseUtf8, cp));

    // get size of collection
    cElements = _pCollectionCache->SizeAry(FORM_SUBMIT_COLLECTION);

    if (fUseUtf8)
    {
        Assert(!cp);
        _pSubmitData->_fUseUtf8 = TRUE;
        TraceTag((tagFormEncoding, "CPostData::_fUseUtf8 set to TRUE"));
    }

    if (cp)
    {
        Assert(!fUseUtf8);
        _pSubmitData->_fUseCustomCodePage = TRUE;
        TraceTag((tagFormEncoding, "CPostData::_fUseCustomCodePage set to TRUE"));
        _pSubmitData->_cpInit = cp;
        TraceTag((tagFormEncoding, "CPostData::_cpInit set to %d", cp));
    }   

    hr = THR( this->QueryInterface(IID_IHTMLSubmitData, (void **) &pSubmitData) );
    if (hr) 
        goto Cleanup;

    for (i = 0; i < cElements; i++)
    {
        CElement * pElement;
        const TCHAR *   pchName;
        IElementBehaviorSubmit *    pSubmit             = NULL;

        hr = THR(_pCollectionCache->GetIntoAry(FORM_SUBMIT_COLLECTION,
                        i,
                        &pElement ) );

        if (hr)
            goto Cleanup;

        // Per W3C, don't submit anything for diabled controls. This
        // is incompatible with Nav3/4, which do not support disabled
        // controls at all.
        if (!pElement->IsEnabled())
            continue;

        switch(pElement->Tag())
        {
        // Always skip non-input images
        // submit
        case    ETAG_IMG:
            continue;

        case ETAG_INPUT:
            switch (DYNCAST(CInput, pElement)->GetType())
            {
            case    htmlInputSubmit:
                    // (NS compatibility) If this is a 'submit' button and has
                    // no name (value=NULL), then don't send any submit info
                    // for this control. BUT if the control has a blank name
                    // (value=""), then do send. (ie. "...&=Submit")
                    pchName = pElement->GetAAsubmitname();
                    if ( ! pchName )
                        continue;
            case    htmlInputReset:
            case    htmlInputButton:
                if (!pSubmitSite || pSubmitSite != pElement)
                {
                    continue;
                }
                break;

            // For input images,
            // 1) do not send data if they did not initiate the submit
            // 2) send data in the end, if they did initiate the submit
            case    htmlInputImage:
                if (!pSubmitSite || pSubmitSite != pElement)
                    continue;
                if (i == cElements - 1)
                    break;
                Assert(!*ppInputImg);
                *ppInputImg = pElement;
                continue;
            }

            break;
        default:
            {
                if (pElement->HasPeerHolder())
                {
                    HRESULT hrSubmit = S_OK;
                    hrSubmit = pElement->GetPeerHolder()->QueryPeerInterfaceMulti(
                        IID_IElementBehaviorSubmit, 
                        (void **)&pSubmit, 
                        FALSE);

                    if (hrSubmit == S_OK)
                    {
                        fUseSubmitInterface = TRUE;
                    }
                }
            }
        }


        hr = THR(_pSubmitData->AppendItemSeparator());
        if ( hr )
        {
            if (pSubmit)
                pSubmit->Release();
            goto Cleanup;
        }

        if (!fUseSubmitInterface)
            hr = THR_NOTRACE(pElement->GetSubmitInfo(_pSubmitData));
        else
        {
            hr = pSubmit->GetSubmitInfo(pSubmitData);
            fUseSubmitInterface = FALSE;
        }
        hr = (hr == S_FALSE) ? S_OK : hr;
        if (hr)
        {
            if (pSubmit)
                pSubmit->Release();
            goto Cleanup;  // not OK, not E_NOTIMPL
        }

        //
        //  If the form can use utf-8 and we've found an element
        //  that does not use the default charset, break out of the
        //  loop and use utf-8 instead.
        //  NOTE (krisma) if these conditions are all true, 
        //  CallGetSubmitInfo will be called again by DoSubmit.
        //  See the note in that function.
        //
        if (_pSubmitData->_fCharsetNotDefault && fCanUseUTF8 && !fUseUtf8)
        {
            TraceTag((tagFormEncoding, "Bailing out of CallGetSubmitInfo. _pSubmitData->_fCharsetNotDefault: %d, fCanUseUTF8: %d, !fUseUtf8: %d", 
                _pSubmitData->_fCharsetNotDefault, fCanUseUTF8, !fUseUtf8));
            if (pSubmit)
                pSubmit->Release();
            goto Cleanup;
        }

        // Count the number of text fields, etc. This info is used to throw
        // the appropriate security alert
        switch(pElement->Tag())
        {
        case ETAG_INPUT:
            if (DYNCAST(CInput, pElement)->_fTextChanged)
            {
                (*pnFieldsChanged)++;
            }
            break;
#ifdef  NEVER
        case ETAG_HTMLAREA:
#endif
        case ETAG_TEXTAREA:
            if (DYNCAST(CRichtext, pElement)->_fTextChanged)
            {
                (*pnFieldsChanged)++;
                *pnMultiLines += DYNCAST(CRichtext,
                            pElement)->Layout()->LineCount() - 1;
            }
            break;
        }
        if (pSubmit)
            pSubmit->Release();
    }

Cleanup:
    if (pSubmitData)
        pSubmitData->Release();
    RRETURN(SetErrorInfo(hr));
}


//+--------------------------------------------------------------
//
//  Member:     CFormElement::submit
//
//  Synopsis:   Executes the submit method on the form
//              enumerates all contained sites
//              and calls the appropriated apis on the site
//              to get the submit infos
//              Then constructs the submit string and uses the
//              hyperlink apis to submit
//              This function is exclusively for use in scripts.
//              It does not fire onSubmit event. DoSubmit() must
//              be directly called for internal use.
//
//---------------------------------------------------------------
HRESULT
CFormElement::submit()
{
    RRETURN(DoSubmit(NULL, FALSE));
}

//+--------------------------------------------------------------
//
//  Member:     CFormElement::DoSubmit
//
//  Synopsis:   Executes the submit method on the form
//              enumerates all contained sites
//              and calls the appropriated apis on the site
//              to get the submit infos
//              Then constructs the submit string and uses the
//              hyperlink apis to submit
//
//---------------------------------------------------------------
HRESULT
CFormElement::DoSubmit(CElement *pSubmitSite, BOOL fFireEvent)
{
    HRESULT     hr              = S_OK;
    CDwnPost *  pDwnPost        = NULL;
    CDoc *      pDoc            = Doc();
    int         nMultiLines     = 0;
    int         nFieldsChanged  = 0;
    CElement *  pInputImg       = NULL;
    BOOL        fCanUseUTF8     = Utf8InAcceptCharset();
    BOOL        fUseUtf8        = FALSE;
    LPCTSTR     pchAction;
    CODEPAGE    cp              = NULL;
    CElement::CLock Lock(this);
    
    TraceTag((tagFormElement, "submit"));

    if (fFireEvent && !Fire_onsubmit())
        goto Cleanup;

    // got nuked in event handler?
    if (!IsConnectedToPrimaryMarkup())
        goto Cleanup;

    // We're starting a new submission, so we want to make sure the
    // CPostData is empty;
    if (_pSubmitData)
    {
        TraceTag((tagFormEncoding, "deleting _pSubmitData"));
        delete _pSubmitData;
        _pSubmitData = NULL;
    }
    EnsureSubmitData();
    
    pchAction = GetAAaction();

    // default action should navigate to top level page
    if (!(pchAction && pchAction[0]))
        pchAction = CMarkup::GetUrl(GetFrameOrPrimaryMarkup());

    // Collect and send submit data
    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->EnsureAry(FORM_SUBMIT_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR(CallGetSubmitInfo(
        pSubmitSite,
        &pInputImg,
        &nMultiLines,
        &nFieldsChanged));

    if (hr)
        goto Cleanup;

    // Should convert the submit data to UTF-8?
    // NOTE (krisma) If the following conditions are true,
    // we ended the previous CallGetSubitInfo early.
    // see the note in that function.
    if (_pSubmitData->_fCharsetNotDefault)
    {
        if (fCanUseUTF8)
        {
            fUseUtf8 = TRUE;
        }
        else if (!_pSubmitData->_fCodePageError && !GetMarkup()->HaveCodePageMetaTag())
        {
            hr = THR(mlang().CodePagesToCodePage(_pSubmitData->_dwCodePages, 0, &cp));
            if (S_OK != hr)
                goto Cleanup;
        }

        _pSubmitData->DeleteAllData();

        hr = THR(CallGetSubmitInfo(
            pSubmitSite,
            &pInputImg,
            &nMultiLines,
            &nFieldsChanged,
            fUseUtf8,
            cp));

        if (hr)
            goto Cleanup;
    }

    if (pInputImg)
    {
        _pSubmitData->AppendItemSeparator();
        hr = THR_NOTRACE(pInputImg->GetSubmitInfo(_pSubmitData));

        hr = (hr == S_FALSE) ? S_OK : hr;
        if (hr)
            goto Cleanup;  // not OK, not E_NOTIMPL
    }

    //  Finish up the SubmitData

    hr = THR(_pSubmitData->Finish());
    if ( hr )
        goto Cleanup;

    hr = THR(CDwnPost::Create(_pSubmitData, &pDwnPost));
    if (hr)
        goto Cleanup;

    TraceTag((tagFormEncoding, "Calling FollowHyperlink"));
    hr = THR(pDoc->FollowHyperlink(pchAction,       // Action
                                   GetAAtarget(),   // Target
                                   this,            // pElementContext
                                   pDwnPost,        // data to submit
                                   _fSendAsPost,    // POST or GET
                                   NULL,            // pchExtraHeaders
                                   FALSE,           // OpenInNewWindow
                                   NULL,            // pUnkFrame
                                   NULL,            // ppWindowOut
                                   0,               // dwBindOptions
                                   ERROR_INTERNET_POST_IS_NON_SECURE,  // dwSecurityCode
                                   FALSE,
                                   NULL,
                                   FALSE,
                                   CDoc::FHL_HYPERLINKCLICK | CDoc::FHL_SETDOCREFERER));

    if ( E_ABORT == hr )
    {
        hr = S_OK;
    }

Cleanup:
    if (_pSubmitData)
    {
        delete _pSubmitData;
        _pSubmitData = NULL;
    }
    ReleaseInterface(pDwnPost);
    RRETURN(SetErrorInfo(hr));
}


//+--------------------------------------------------------------
//
//  Member:     CFormElement::Utf8InAcceptCharset
//
//  Synopsis:   Searches through the accept-charset attribute
//              for the string "utf-8" (case insensitive)
//
//---------------------------------------------------------------
BOOL
CFormElement::Utf8InAcceptCharset()
{
    BOOL    fRetVal = FALSE;
    LPCTSTR pch = GetAAacceptCharset();

    TraceTag((tagFormEncoding, "GetAAacceptCharset returned %S", pch));

    while (pch && *pch)
    {
        if (_7csnipre(TEXT("utf-8"), 5, pch, -1))
        {
            fRetVal = TRUE;
            break;
        }
        pch++;
    }

    //
    // Let's make sure the next character is either a 
    // space, commma, or the end of the string
    //
    pch += 5;   //"utf-8" is 5 characters long
    if (fRetVal && *pch)
    {
        if (!_7csnipre(TEXT(" "), 1, pch, 1)
            && !_7csnipre(TEXT(","), 1, pch, 1))
            fRetVal=FALSE;
    }

    TraceTag((tagFormEncoding, "CFormElement::Utf8InAcceptCharset returning %d", fRetVal));
    return fRetVal;
}

//+--------------------------------------------------------------
//
//  Member:     CFormElement::reset
//
//  Synopsis:   Executes the reset method on the form
//              enumerates all contained sites
//              and calls the reset API on the site
//              This function is exclusively for use in scripts.
//              DoReset() must be directly called for internal
//              use.
//
//---------------------------------------------------------------
HRESULT
CFormElement::reset()
{
    RRETURN(DoReset(TRUE));
}

//+--------------------------------------------------------------
//
//  Member:     CFormElement::DoReset
//
//  Synopsis:   Executes the reset method on the form
//              enumerates all contained sites
//              and calls the reset API on the site
//
//---------------------------------------------------------------
HRESULT
CFormElement::DoReset(BOOL fFireEvent)
{
    TraceTag((tagFormElement, "reset"));

    HRESULT     hr = S_OK;
    long        c =0;

    if (fFireEvent && !Fire_onreset())
        goto Cleanup;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->EnsureAry(FORM_SUBMIT_COLLECTION));
    if (hr)
        goto Cleanup;

    // get size of collection
    c = _pCollectionCache->SizeAry(FORM_SUBMIT_COLLECTION);

    //
    // Iterate thru elements, and call DoReset on them.
    //
    while (c--)
    {
        CElement * pElem;

        hr = THR(_pCollectionCache->GetIntoAry(FORM_SUBMIT_COLLECTION,
                        c,
                        &pElem ) );

        if (!hr)
        {
            if (pElem->HasPeerHolder())
            {
                HRESULT                  hrReset = S_OK;
                IElementBehaviorSubmit * pSubmit = NULL;

                hrReset = pElem->GetPeerHolder()->QueryPeerInterfaceMulti(
                    IID_IElementBehaviorSubmit,
                    (void **)&pSubmit,
                    FALSE);
                
                if (!hrReset)
                    pSubmit->Reset();

                if (pSubmit)
                    pSubmit->Release();
            }
            else
                IGNORE_HR(pElem->DoReset());
        }
    }

    hr = S_OK;

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CFormElement::InvokeEx
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif

HRESULT
CFormElement::ContextThunk_InvokeEx (
    DISPID          dispidMember,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pdispparams,
    VARIANT *       pvarResult,
    EXCEPINFO *     pexcepinfo,
    IServiceProvider *pSrvProvider)
{
    IUnknown * pUnkContext;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    TraceTag((tagFormElement, "Invoke dispid=0x%x", dispidMember));

    HRESULT hr;
    RETCOLLECT_KIND collectionCreation;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = DISP_E_MEMBERNOTFOUND;

    // If the DISPID came from the typeinfo, adjust the DISPID into GetIdsOfNames range,
    // and record that the Invoke should only return a single item, not a collection

    if ( dispidMember >= DISPID_COLLECTION_TI_MIN &&
         dispidMember <= DISPID_COLLECTION_TI_MAX )
    {
        dispidMember = DISPID_COLLECTION_TI_TO_GN(dispidMember);

        collectionCreation = RETCOLLECT_FIRSTITEM;
    }
    else
    {
        collectionCreation = RETCOLLECT_ALL;
    }


    // Ensuring the 
    if ( _pCollectionCache->IsDISPIDInCollection ( FORM_ELEMENT_COLLECTION , dispidMember ) )
    {
        hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
        if (hr)
            goto Cleanup;
        hr = _pCollectionCache->Invoke(FORM_ELEMENT_COLLECTION,
                                      dispidMember,
                                      IID_NULL,
                                      lcid,
                                      wFlags,
                                      pdispparams,
                                      pvarResult,
                                      pexcepinfo,
                                      NULL,
                                      collectionCreation);
    }
    else 
    {

        if ( _pCollectionCache->IsDISPIDInCollection ( FORM_NAMED_IMG_COLLECTION , dispidMember ) )
        {
            hr = THR(_pCollectionCache->EnsureAry(FORM_NAMED_IMG_COLLECTION));
            if (hr)
                goto Cleanup;
            hr = _pCollectionCache->Invoke(FORM_NAMED_IMG_COLLECTION,
                                          dispidMember,
                                          IID_NULL,
                                          lcid,
                                          wFlags,
                                          pdispparams,
                                          pvarResult,
                                          pexcepinfo,
                                          NULL);
        }
    }

    // If above didn't work then try to get the property/expando.
    if (hr)
    {
        hr = THR_NOTRACE(super::ContextInvokeEx (dispidMember,
                                   lcid,
                                   wFlags,
                                   pdispparams,
                                   pvarResult,
                                   pexcepinfo,
                                   pSrvProvider,
                                   pUnkContext ? pUnkContext : (IUnknown*)this));
    }

Cleanup:
    RRETURN(hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif

HRESULT
CFormElement::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT     hr = DISP_E_UNKNOWNNAME;
    
    if(IsInMarkup())
    {
        // make sure the form element is inside the tree
        hr = THR(EnsureCollectionCache());
        if (hr)
            goto Cleanup;

        Assert (_pCollectionCache);


        hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
        if ( hr )
            goto Cleanup;

        // Try the FORM_ELEMENT_COLLECTION first
        hr = THR_NOTRACE(_pCollectionCache->GetDispID(FORM_ELEMENT_COLLECTION,
                                                      bstrName,
                                                      grfdex,
                                                      pid));

        // If not there try the FORM_NAMED_IMG_COLLECTION. Note that we've turned off
        // ordinal promotion on this collection.
        if ( hr == DISP_E_UNKNOWNNAME )
        {
            hr = THR(_pCollectionCache->EnsureAry(FORM_NAMED_IMG_COLLECTION));
            if ( hr )
                goto Cleanup;
            hr = THR_NOTRACE(_pCollectionCache->GetDispID(FORM_NAMED_IMG_COLLECTION,
                                                          bstrName,
                                                          grfdex,
                                                          pid));
        }
    }

    // The collectionCache GetDispID will return S_OK w/ DISPID_UNKNOWN
    // if the name isn't found, catastrophic errors are of course returned.
    if (hr || (!hr && *pid == DISPID_UNKNOWN))
    {
        // Don't allow vbscript fast event sinks to be hooked up.
        if (hr && (grfdex & fdexNameNoDynamicProperties))
        {
            *pid = DISPID_UNKNOWN;
            goto Cleanup;
        }

        hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pid));

        // Add the hack for the Jeremie test.  If the property we're looking
        // for is  enctype, return the dispid for encoding.
        if (hr == DISP_E_UNKNOWNNAME && !_tcscmp(bstrName, _T("enctype")))
        {
            BSTR    bstrTmp;

            hr = FormsAllocString(_T("encoding"), &bstrTmp);
            if (FAILED(hr))
                goto Cleanup;
            hr = THR_NOTRACE(super::GetDispID(bstrTmp, grfdex, pid));
            FormsFreeString(bstrTmp);
        }
    }

Cleanup:
    RRETURN(hr);
}


HRESULT
CFormElement::GetNextDispID(
                DWORD grfdex,
                DISPID id,
                DISPID *prgid)
{
    HRESULT     hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    if(IsInMarkup())
    {
        hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
        if (hr)
            goto Cleanup;
    }

    hr = DispatchGetNextDispIDCollection(this,
#ifndef WIN16
                                         (GetNextDispIDPROC)&super::GetNextDispID,
#else
                                         CBase::GetNextDispID,
#endif
                                         _pCollectionCache,
                                         FORM_ELEMENT_COLLECTION,
                                         grfdex,
                                         id,
                                         prgid);

Cleanup:
    RRETURN1(hr, S_FALSE);
}

HRESULT
CFormElement::GetMemberName(
                DISPID id,
                BSTR *pbstrName)
{
    HRESULT     hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = DispatchGetMemberNameCollection(this,
#ifndef WIN16
                                         (GetGetMemberNamePROC)super::GetMemberName,
#else
                                         CBase::GetMemberName,
#endif
                                         _pCollectionCache,
                                         FORM_ELEMENT_COLLECTION,
                                         id,
                                         pbstrName);

Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CFormElement::GetMultiTypeInfoCount
//
//  Synopsis:   per IProvideMultipleClassInfo
//
//---------------------------------------------------------------------------

HRESULT
CFormElement::GetMultiTypeInfoCount(ULONG *pc)
{
    TraceTag((tagFormElement, "GetMultiTypeInfoCount"));

    *pc = 3;
    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Member:     CFormElement::GetInfoOfIndex
//
//  Synopsis:   per IProvideMultipleClassInfo
//
//---------------------------------------------------------------------------

HRESULT
CFormElement::GetInfoOfIndex(
    ULONG       iTI,
    DWORD       dwFlags,
    ITypeInfo** ppTICoClass,
    DWORD*      pdwTIFlags,
    ULONG*      pcdispidReserved,
    IID*        piidPrimary,
    IID*        piidSource)
{
    TraceTag((tagFormElement, "GetInfoOfIndex"));

    HRESULT         hr = S_OK;
    long            lIndex;
    DISPID          dispidMin;
    DISPID          dispidMax;
    ITypeInfo **    ppTypeInfo = NULL;
    ITypeInfo **    ppTypeInfoCoClass = NULL;

    //
    // First try the main typeinfo
    //

    if (dwFlags & MULTICLASSINFO_GETTYPEINFO)
    {
        //
        // If the type-info to be created on the fly has not yet
        // happened then create them
        //

        if (1 == iTI)
        {
            lIndex = FORM_ELEMENT_COLLECTION;
            dispidMin = DISPID_FORM_ELEMENT_TI_MIN;
            dispidMax = DISPID_FORM_ELEMENT_TI_MAX;
            ppTypeInfo        = &_pTypeInfoElements;
            ppTypeInfoCoClass = &_pTypeInfoCoClassElements;
        }
        else if (2 == iTI)
        {
            lIndex = FORM_NAMED_IMG_COLLECTION;
            dispidMin = DISPID_FORM_NAMED_IMG_TI_MIN;
            dispidMax = DISPID_FORM_NAMED_IMG_TI_MAX;
            ppTypeInfo        = &_pTypeInfoImgs;
            ppTypeInfoCoClass = &_pTypeInfoCoClassImgs;
        }
        else
        {
            goto Dosuper;
        }

        hr = THR(EnsureCollectionCache());
        if (hr)
            goto Cleanup;

        hr = THR(_pCollectionCache->EnsureAry(lIndex));
        if (hr)
            goto Cleanup;

        Assert (ppTypeInfo && ppTypeInfoCoClass);

        if (!(*ppTypeInfo) || !(*ppTypeInfoCoClass))
        {
            hr = THR(Doc()->BuildObjectTypeInfo(
                _pCollectionCache,
                lIndex,
                dispidMin,
                dispidMax,
                ppTypeInfo,
                ppTypeInfoCoClass));
            if (hr)
                goto Cleanup;
        }

        *ppTICoClass = *ppTypeInfoCoClass;
        (*ppTICoClass)->AddRef();

        //
        // Clear out these values so that we can use the base impl.
        //

        dwFlags &= ~MULTICLASSINFO_GETTYPEINFO;
        iTI = 0;
        ppTICoClass = NULL;
    }

Dosuper:
    hr = THR(super::GetInfoOfIndex(
            iTI,
            dwFlags,
            ppTICoClass,
            pdwTIFlags,
            pcdispidReserved,
            piidPrimary,
            piidSource));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+--------------------------------------------------------------
//
//  Member:     CFormElement::FOnlyTextbox
//
//  Synopsis:   Called by an input textbox to determine whether
//              it should cause the form to be submitted upon
//              receiving a VK_ENTER.
//
//---------------------------------------------------------------

HRESULT
CFormElement::FOnlyTextbox(CInput * pTextbox, BOOL * pfOnly)
{
    HRESULT     hr = S_OK;
    long        i;
    CElement *  pElem;

    Assert(pTextbox);
    Assert(pTextbox->Tag() == ETAG_INPUT);
    Assert(pTextbox->GetType() != htmlInputButton);
    Assert(pTextbox->GetType() != htmlInputReset);
    Assert(pTextbox->GetType() != htmlInputSubmit);

    Assert(pfOnly);
    *pfOnly = TRUE;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    for (i = _pCollectionCache->SizeAry(FORM_ELEMENT_COLLECTION) - 1;
            i >= 0 && *pfOnly; i--)
    {
        hr = THR(_pCollectionCache->GetIntoAry(FORM_ELEMENT_COLLECTION,
                        i,
                        &pElem));
        if (hr)
            goto Cleanup;

        if (pElem != pTextbox && pElem->Tag() == ETAG_INPUT)
        {
            CInput * pInput = DYNCAST(CInput, pElem);

            switch (pInput->GetType())
            {
            case htmlInputText:
            case htmlInputPassword:
                *pfOnly = FALSE;  // found another textbox in this form
            }
        }
    }
Cleanup:
    RRETURN(hr);
}

//+--------------------------------------------------------------
//
//  Member:     CFormElement::FormTraverseGroup
//
//  Synopsis:   Called by (e.g.)a radioButton to its form, this function
//      takes the groupname and queries the Form's collection for the rest
//      of the group and calls the provided CLEARGROUP function on that
//      element. in this way ANY Form GRoup can be cleared (or have some
//      opetation done on all its members)
//
//---------------------------------------------------------------

HRESULT
CFormElement::FormTraverseGroup(
    LPCTSTR strGroupName,
    PFN_VISIT pfn,
    DWORD_PTR dw,
    BOOL fForward)
{
    HRESULT     hr;
    long        i, c;
    CElement *  pElem;
    LPCTSTR     lpName;

    _fInTraverseGroup = TRUE;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    // get size of collection
    c = _pCollectionCache->SizeAry(FORM_ELEMENT_COLLECTION);

    if (fForward)
        i = 0;
    else
        i = c - 1;

    // if nothing is in the collection, default answer is S_FALSE.
    hr = S_FALSE;

    while (c--)
    {
        hr = THR(_pCollectionCache->GetIntoAry(FORM_ELEMENT_COLLECTION,
                        i,
                        &pElem));
        if (fForward)
            i++;
        else
            i--;

        if (hr)
            goto Cleanup;

        lpName = pElem->GetAAname();

        hr = S_FALSE;                   // default answer again.

        // is this item in the target group?
        if ( lpName && FormsStringICmp(strGroupName, lpName) == 0 )
        {
            // Call the function and stop if it doesn't return S_FALSE.
#ifdef WIN16
            hr = THR( (*pfn)(pElem, dw) );
#else
            hr = THR( CALL_METHOD( pElem, pfn, (dw)) );
#endif
            if (hr != S_FALSE)
                break;
        }
    }

Cleanup:
    _fInTraverseGroup = FALSE;
    RRETURN1(hr, S_FALSE);
}

//+--------------------------------------------------------------
//
//  Member:     CFormElement::FindDefaultElem
//
//  Synopsis:   find the default/Cancel button
//
//---------------------------------------------------------------

CElement *
CFormElement::FindDefaultElem(BOOL fDefault, BOOL fCurrent /* FALSE */)
{
    HRESULT     hr      = S_FALSE;
    long        i       = 0;
    long        c       = 0;
    CElement  * pElem   = NULL;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    // get size of collection
    c = _pCollectionCache->SizeAry(FORM_ELEMENT_COLLECTION);

    while (c--)
    {
        hr = THR(_pCollectionCache->GetIntoAry(FORM_ELEMENT_COLLECTION,
                        i++,
                        &pElem));

        if (hr)
        {
            pElem = NULL;
            goto Cleanup;
        }

        Assert(pElem);
        if (pElem->_fExittreePending)
            continue;

        if (fCurrent)
        {
            if (pElem->_fDefault)
                goto Cleanup;
            continue;
        }

        if ( pElem->TestClassFlag(fDefault?
                ELEMENTDESC_DEFAULT : ELEMENTDESC_CANCEL)
            && pElem->IsVisible(TRUE)
            && pElem->IsEnabled()
            )
        {
                goto Cleanup;
        }
    }
    pElem = NULL;

Cleanup:
    return pElem;
}

//+--------------------------------------------------------------
//
//  Member:     CFormElement::ApplyDefaultFormat
//
//  Synopsis: Provide for special formatting for the form. So far
//            the only interesting thing here is that <FORM>s generate
//            extra vertical white space in Netscape, but not in IE.
//            We imitate Netscape.
//
//---------------------------------------------------------------

HRESULT
CFormElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT         hr = S_OK;

    hr = THR(super::ApplyDefaultFormat(pCFI));
    if(hr)
        goto Cleanup;

    //
    // Apply default before/after space.
    // NOTE: Before/after space are outside our box (== margins), 
    //       so they are relative to the parent's text flow.
    //
    {
        BOOL fParentVertical = pCFI->_pNodeContext->IsParentVertical();

        pCFI->PrepareFancyFormat();
        ApplyDefaultVerticalSpace(fParentVertical, &pCFI->_ff());
        pCFI->UnprepareForDebug();
    }

Cleanup:
    return (hr);
}

//+--------------------------------------------------------------
//
//  Member:     CFormElement::put_method
//
//  Synopsis: needed because of special get_method handling
//
//+--------------------------------------------------------------
STDMETHODIMP CFormElement::put_method(BSTR bstr)
{
    VARIANT v;
    v.vt = VT_BSTR;
    V_BSTR(&v) = bstr;
    RRETURN(SetErrorInfo(s_propdescCFormElementmethod.a.HandleEnumProperty(HANDLEPROP_SET |
                                                                 HANDLEPROP_AUTOMATION |
                                                                 (PROPTYPE_VARIANT << 16),
                                                                 &v,
                                                                 this,
                                                                 (CVoid *)(void *)(&_pAA))));
}
//+--------------------------------------------------------------
//
//  Member:     CFormElement::get_method
//
//  Synopsis: Through the OM when the value is notSet we return Get
//
//  N.B. this function assumes intimate knowledge of the htmlMethod enum.
//       and the possible values. if the number of enums changes, or the
//       indicies into the enum then this function will need attention
//+--------------------------------------------------------------
STDMETHODIMP CFormElement::get_method(BSTR * pbstr)
{
    HRESULT hr;

    if (!pbstr)
    {
        hr = E_POINTER;
        goto Cleanup;
    }



    if(GetAAmethod()!=htmlMethodPost)
    {
        // then return the "get" string
        hr = THR(FormsAllocString( s_enumdeschtmlMethod.aenumpairs[ htmlMethodGet ].pszName,
                                   pbstr));
    }
    else
    {
        // then return the "Post" string
        hr = THR(FormsAllocString( s_enumdeschtmlMethod.aenumpairs[ htmlMethodPost ].pszName,
                                   pbstr));
    }
    if (hr )
        goto Cleanup;


Cleanup:
    RRETURN(SetErrorInfo( hr));
}



//+------------------------------------------------------------------------
//
//  Member:     get_length
//
//  Synopsis:   collection object model, defers to Cache Helper
//
//-------------------------------------------------------------------------

HRESULT
CFormElement::get_length(long * plSize)
{
    HRESULT hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;


    hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->GetLength(FORM_ELEMENT_COLLECTION, plSize));

Cleanup:
    RRETURN(SetErrorInfo( hr));

}


//+------------------------------------------------------------------------
//
//  Member:     put_length
//
//  Synopsis:   collection object model, defers to Cache Helper
//
//-------------------------------------------------------------------------

HRESULT
CFormElement::put_length(long lSize)
{
    // supported only in area collection
    RRETURN(SetErrorInfo(E_NOTIMPL));
}


//+------------------------------------------------------------------------
//
//  Member:     item
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CFormElement::item(VARIANTARG var1, VARIANTARG var2, IDispatch** ppResult)
{
    HRESULT hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->Item(FORM_ELEMENT_COLLECTION,
                        var1,
                        var2,
                        ppResult));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+------------------------------------------------------------------------
//
//  Member:     namedItem
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CFormElement::namedItem(BSTR bstrName, IDispatch** ppResult)
{
    HRESULT hr;

    if (!bstrName || !*bstrName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    VARIANT var1, var2;

    var1.vt = VT_BSTR;
    var1.bstrVal = bstrName;
    var2.vt = VT_EMPTY;

    hr = THR(_pCollectionCache->Item(FORM_ELEMENT_COLLECTION,
                        var1,
                        var2,
                        ppResult));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+------------------------------------------------------------------------
//
//  Member:     tags
//
//  Synopsis:   collection object model, this always returns a collection
//              and is named based on the tag, and searched based on tagname
//
//-------------------------------------------------------------------------

HRESULT
CFormElement::tags(VARIANT var1, IDispatch ** ppdisp)
{
    HRESULT hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;


    hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->Tags(FORM_ELEMENT_COLLECTION, var1, ppdisp));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}


//+------------------------------------------------------------------------
//
//  Member:     urns
//
//  Synopsis:   collection object model, this always returns a collection
//              and is named based on the urn, and searched based on urn
//
//-------------------------------------------------------------------------

HRESULT
CFormElement::urns(VARIANT var1, IDispatch ** ppdisp)
{
    HRESULT hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;


    hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->Urns(FORM_ELEMENT_COLLECTION, var1, ppdisp));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+------------------------------------------------------------------------
//
//  Member:     Get_newEnum
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CFormElement::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    
    hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->GetNewEnum(FORM_ELEMENT_COLLECTION, ppEnum));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+------------------------------------------------------------------------
//
//  Member:     appendNameValuePair
//
//  Synopsis:   IHTMLSubmitData support
//
//-------------------------------------------------------------------------
HRESULT
CFormElement::appendNameValuePair(BSTR name, BSTR value)
{
    HRESULT hr = S_OK;

    hr = THR(EnsureSubmitData());
    if (hr)
        goto Cleanup;

    hr = THR(_pSubmitData->AppendNameValuePair(name, value, GetMarkup()));

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     appendNameFilePair
//
//  Synopsis:   IHTMLSubmitData support
//
//-------------------------------------------------------------------------
HRESULT
CFormElement::appendNameFilePair(BSTR name, BSTR filename)
{
    HRESULT hr = S_OK;

    hr = THR(EnsureSubmitData());
    if (hr)
        goto Cleanup;

    hr = THR(_pSubmitData->AppendNameFilePair(name, filename, GetMarkup()));

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     appendItemSeparator
//
//  Synopsis:   IHTMLSubmitData support
//
//-------------------------------------------------------------------------
HRESULT
CFormElement::appendItemSeparator()
{
    HRESULT hr = S_OK;

    hr = THR(EnsureSubmitData());
    if (hr)
        goto Cleanup;

    hr = THR(_pSubmitData->AppendItemSeparator());

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     EnsureSubmitData
//
//  Synopsis:   If _pSubmitData is null; create a new CPostData and 
//              initialize it.
//
//-------------------------------------------------------------------------
HRESULT
CFormElement::EnsureSubmitData()
{
    HRESULT     hr          = S_OK;
    BOOL        fSendAsPost;
    LPCTSTR     pchAction;
    CDoc *      pDoc        = Doc();

    if (_pSubmitData)
        goto Cleanup;

    _pSubmitData = new CPostData();
    if (!_pSubmitData)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    fSendAsPost = (GetAAmethod() == htmlMethodPost);

    pchAction = GetAAaction();
    if (!(pchAction && pchAction[0]))
        pchAction = pDoc->GetPrimaryUrl();

    //  Get the ENCTYPE attrib of the form. Set it into the SubmitData object
    _pSubmitData->_encType = GetAAencoding();

    // Netscape compatibility: if encType==text/plain then make it a POST
    if (_pSubmitData->_encType == htmlEncodingText && !fSendAsPost)
    {
        UINT    uProt = GetUrlScheme(pchAction);

        if (URL_SCHEME_HTTP == uProt ||
            URL_SCHEME_HTTPS == uProt)
        {
            fSendAsPost = TRUE;
        }
    }

    if (!fSendAsPost)
    {
        // GET only allows one possible encoding
        _pSubmitData->_encType = htmlEncodingURL;
    }

    hr = _pSubmitData->CreateHeader();
    if (hr)
        goto Error;

    _fSendAsPost = fSendAsPost;

Cleanup:
    RRETURN(hr);

Error:
    delete _pSubmitData;
    _pSubmitData = NULL;
    goto Cleanup;
}


//+----------------------------------------------------------------------------
//  
//  Method:     CFormElement::FormEnterTree
//  
//  Synopsis:   Does some work that's needed when the element enters the
//              tree, such as adding itself to the script collection.
//  
//  Returns:    HRESULT
//  
//  Arguments:
//  
//+----------------------------------------------------------------------------

HRESULT
CFormElement::FormEnterTree()
{
    HRESULT hr = S_OK;
    CMarkup * pMarkup = GetMarkupPtr();
    CScriptCollection * pScriptCollection;

    Assert (!_pTypeInfoElements);
    Assert (!_pTypeInfoCoClassElements);
    Assert (!_pTypeInfoImgs);
    Assert (!_pTypeInfoCoClassImgs);

    if (!pMarkup || pMarkup->_fDesignMode || pMarkup->_fMarkupServicesParsing)
        goto Cleanup;

    //
    // Add this form as a named item to the script engine.
    // This is to enable scriptlets for children of the form.  Also
    // to keep compatibility with IE.
    //
    pScriptCollection = pMarkup->GetScriptCollection();

    if (pScriptCollection)
    {
        hr = THR(pScriptCollection->AddNamedItem(this));
        if (hr)
            goto Cleanup;
    }
Cleanup:
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\elink.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       elink.cxx
//
//  Contents:   CLinkElement & related
//
//
//----------------------------------------------------------------------------

#include "headers.hxx"      // for the world

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"     // for CCssCtx
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"     // for CElement
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_ELINK_HXX_
#define X_ELINK_HXX_
#include "elink.hxx"        // for CLinkElement
#endif

#ifndef X_ESTYLE_HXX_
#define X_ESTYLE_HXX_
#include "estyle.hxx"       // for CStyleElement
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"      // for CTxtSite
#endif

#ifndef X_TYPES_H_
#define X_TYPES_H_
#include "types.h"          // for s_enumdeschtmlReadyState
#endif

#ifndef X_SCRPTLET_H_
#define X_SCRPTLET_H_
#include "scrptlet.h"       // for the scriptoid stuff
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_PRIVACY_HXX_
#define X_PRIVACY_HXX_
#include "privacy.hxx"
#endif

#if defined(_M_ALPHA)
#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif
#endif


#define _cxx_
#include "link.hdl"

MtDefine(CLinkElement, Elements, "CLinkElement")
MtDefine(CLinkElementOnDwnChan_pbBuffer, Locals, "CLinkElement::OnDwnChan pbBuffer")
MtDefine(CLinkElementOnDwnChan_pchSrc, Locals, "CLinkElement::OnDwnChan pchSrc")
MtDefine(CLinkElementHandleLinkedObjects, Elements, "CLinkElement::HandleLinkedObjects");

EXTERN_C const GUID CLSID_ScriptletConstructor;

ExternTag(tagStyleSheet)
ExternTag(tagSharedStyleSheet)
//+------------------------------------------------------------------------
//
//  Class: CLinkElement
//
//-------------------------------------------------------------------------

const CElement::CLASSDESC CLinkElement::s_classdesc =
{
    {
        &CLSID_HTMLLinkElement,             // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLLinkElement,              // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLLinkElement,       // _apfnTearOff
    NULL                                    // _pAccelsRun
};


CLinkElement::CLinkElement(CDoc *pDoc)
      : CElement(ETAG_LINK, pDoc)
{
    _pStyleSheet = NULL;
    _fIsInitialized = FALSE;
    _readyStateLink = READYSTATE_UNINITIALIZED;
}

HRESULT
CLinkElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);
    *ppElementResult = new CLinkElement(pDoc);
    return *ppElementResult ? S_OK : E_OUTOFMEMORY;
}


//+----------------------------------------------------------------------------
//
//  Member:     CLinkElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-----------------------------------------------------------------------------

HRESULT
CLinkElement::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_INHERITS2(this, IUnknown, IHTMLLinkElement)
        QI_HTML_TEAROFF(this, IHTMLElement2, NULL)
        QI_HTML_TEAROFF(this, IHTMLLinkElement, NULL)
        QI_HTML_TEAROFF(this, IHTMLLinkElement2, NULL)
        QI_HTML_TEAROFF(this, IHTMLLinkElement3, NULL)
        QI_TEAROFF_DISPEX(this, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     InvokeExReady
//
//  Synopsis  :this is only here to handle readyState queries, everything
//      else is passed on to the super
//
//+------------------------------------------------------------------------

#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif

STDMETHODIMP
CLinkElement::ContextThunk_InvokeExReady(DISPID dispid,
                            LCID lcid,
                            WORD wFlags,
                            DISPPARAMS *pdispparams,
                            VARIANT *pvarResult,
                            EXCEPINFO *pexcepinfo,
                            IServiceProvider *pSrvProvider)
{
    IUnknown * pUnkContext;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    HRESULT  hr = S_OK;

    hr = THR(ValidateInvoke(pdispparams, pvarResult, pexcepinfo, NULL));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(ReadyStateInvoke(dispid, wFlags, _readyStateFired, pvarResult));
    if (hr == S_FALSE)
    {
        hr = THR_NOTRACE(super::ContextInvokeEx(dispid,
                                         lcid,
                                         wFlags,
                                         pdispparams,
                                         pvarResult,
                                         pexcepinfo,
                                         pSrvProvider,
                                         pUnkContext ? pUnkContext : (IUnknown*)this));
    }

Cleanup:
    RRETURN(hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CLinkElement::Notify
//
//  Synopsis:   Receive notifications
//
//----------------------------------------------------------------------------

void
CLinkElement::Notify(CNotification *pNF)
{
    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_STOP_1:
    case NTYPE_MARKUP_UNLOAD_1:
        if ( _pCssCtx )
            _pCssCtx->SetLoad( FALSE, NULL, FALSE );  // stop the directly linked stylesheet
        if ( _pStyleSheet )
            _pStyleSheet->StopDownloads( FALSE );  // if the directly linked sheet already came down,
        break;

    case NTYPE_BASE_URL_CHANGE:
        OnPropertyChange( DISPID_CLinkElement_href, 
                          ((PROPERTYDESC *)&s_propdescCLinkElementhref)->GetdwFlags(),
                          (PROPERTYDESC *)&s_propdescCLinkElementhref);
        break;
        
    case NTYPE_ELEMENT_ENTERTREE:
        if(!_fIsInitialized)
        {
            HRESULT hr;
            // (Jharding): I'm changing this to a HandleLinkedObjects, which is 
            // all the OnPropertyChange was doing, less firing the notification
            hr = HandleLinkedObjects();
            if (!hr)
                _fIsInitialized = TRUE;
        }
        else
        {
            // Insert the existing SS into this Markup
            CMarkup * pMarkup = GetMarkup();
            CStyleSheetArray * pStyleSheets = NULL;

            if (pMarkup && _pStyleSheet)
            {
                // Check for the temporary holding SSA
                if (_pSSATemp && (_pSSATemp == _pStyleSheet->GetSSAContainer()))
                {
                    _pSSATemp->ReleaseStyleSheet( _pStyleSheet, FALSE );

                    // The Temp SSA's work is now done.
                    _pSSATemp->CBase::PrivateRelease();
                    _pSSATemp = NULL;
                }

                THR(pMarkup->EnsureStyleSheets());

                pStyleSheets = pMarkup->GetStyleSheetArray();

                THR(pStyleSheets->AddStyleSheet(_pStyleSheet));
                THR(EnsureStyleDownload());

                // When exiting the tree the style rules are disable. Reenable them if they were
                //     not also disabled on the element.
                if(!GetAAdisabled())
                    IGNORE_HR(_pStyleSheet->ChangeStatus(CS_ENABLERULES, FALSE, NULL) );

            }
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        {
            CMarkup * pMarkup = GetMarkup();

            if (_pStyleSheet)
            {
                CStyleSheetArray * pStyleSheets = NULL;

                if (pMarkup && !(pNF->DataAsDWORD() & EXITTREE_DESTROY))
                    pStyleSheets = pMarkup->GetStyleSheetArray();

                // Tell the top-level stylesheet collection to let go of it's reference
                // Do NOT force a re-render (might be fatal if everyone's passivating around us)
                if (pStyleSheets)
                    pStyleSheets->ReleaseStyleSheet( _pStyleSheet, FALSE );
            }

            // unblock script execution
            if (_dwScriptDownloadCookie && pMarkup)
            {
                _markupCookie = pMarkup;
                _markupCookie->AddRef();
                pNF->SetSecondChanceRequested();
            }
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_2:

        if (_dwScriptDownloadCookie)
        {
            Assert(_markupCookie);
            _markupCookie->UnblockScriptExecution(&_dwScriptDownloadCookie);
            _dwScriptDownloadCookie = NULL;
            _markupCookie->Release();
        }
        break;

    }
}


//+---------------------------------------------------------------------------
//
//  Method:     CLinkElement::SetCssCtx
//
//+---------------------------------------------------------------------------
void
CLinkElement::SetCssCtx(CCssCtx * pCssCtx)
{
    if (_pCssCtx)
    {        
        _pCssCtx->SetProgSink(NULL); // detach download from document's load progress
        _pCssCtx->Disconnect();
        _pCssCtx->Release();

        if (!pCssCtx && _dwStyleCookie)
        {
            Doc()->LeaveStylesheetDownload(&_dwStyleCookie);
        }
    }

    _pCssCtx = pCssCtx;

    if (pCssCtx)
    {
        pCssCtx->AddRef();

        TraceTag( (tagStyleSheet, "Link - SetCssCtx [%p]--  in state [%x]", _pCssCtx, _pCssCtx->GetState()) );
        if (pCssCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
        {
            OnDwnChan(pCssCtx);
        }
        else
        {
            pCssCtx->SetProgSink(CMarkup::GetProgSinkHelper(GetMarkup()));
            pCssCtx->SetCallback(OnDwnChanCallback, this);
            pCssCtx->SelectChanges(DWNCHG_HEADERS|DWNCHG_COMPLETE, 0, TRUE);
        }
    }
}

//+------------------------------------------------------------------------
//
//  Method:     CLinkElement::OnDwnChan
//
//-------------------------------------------------------------------------
void
CLinkElement::OnDwnChan(CDwnChan * pDwnChan)
{
    Assert( !_pStyleSheet || GetThreadState() == _pStyleSheet->_pts );

    ULONG       ulState;
    CDoc *      pDoc = Doc();
    CMarkup *   pMarkup = GetMarkup();
    char *      pbBuffer = NULL;
    TCHAR *     pchSrc = NULL;
    HRESULT     hrParsing = S_OK;
    BOOL        fDoHeaders;

    Assert(pDoc);

    Assert( _pCssCtx && "Link - OnDwnChan called while _pCssCtx == NULL, possibely legacy callbacks" );      
    ulState  = _pCssCtx->GetState();
    fDoHeaders = (BOOL)(ulState & DWNLOAD_HEADERS);
    if (!fDoHeaders)
    {
        fDoHeaders = (ulState & DWNLOAD_COMPLETE) && !(ulState & DWNLOAD_HEADERS);
    }
    
    if (fDoHeaders && _pStyleSheet)
    {
        BOOL fGotLastMod = FALSE;
        FILETIME ft = {0};
        
        ft = _pCssCtx->GetLastMod();
        if (ft.dwHighDateTime == 0 && ft.dwLowDateTime == 0)
        {
            extern BOOL GetUrlTime(FILETIME *pt, const TCHAR *pszAbsUrl, CElement *pElem);
            fGotLastMod = GetUrlTime(&ft, _pStyleSheet->GetAbsoluteHref(), _pStyleSheet->_pParentElement);
        }
        else
            fGotLastMod = TRUE;
        
        if (fGotLastMod)
        {
            _pStyleSheet->GetSSS()->_ft = ft;
        }
#if DBG==1            
        else
        {   
            TraceTag( (tagSharedStyleSheet, "Link - OnDwnChan cannot get FILETIME from CssCtx") );
        }
#endif             
        
        _pStyleSheet->GetSSS()->_dwBindf = _pCssCtx->GetBindf();
        _pStyleSheet->GetSSS()->_dwRefresh = _pCssCtx->GetRefresh();
    }

    // try attach late
    if ((ulState & (DWNLOAD_COMPLETE | DWNLOAD_HEADERS)) && _pStyleSheet)
    {
        CSharedStyleSheetsManager *pSSSM = _pStyleSheet->GetSSS()->_pManager;
        CSharedStyleSheet *pSSS = NULL;
        if (pSSSM && !_pStyleSheet->GetSSS()->_fComplete)     
        {
            // try find a completed one            
            if (!(_pStyleSheet->GetSSS()->_ft.dwHighDateTime == 0 && _pStyleSheet->GetSSS()->_ft.dwLowDateTime == 0)
                && (S_OK == THR(_pStyleSheet->AttachByLastMod(pSSSM, NULL, &pSSS, FALSE)) )
               )
            {
                //
                // Stop downloading
                //
                TraceTag( (tagSharedStyleSheet, "link - attached - stop downloading") );
                if (!(ulState & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED)))
                {
                    _pCssCtx->SetLoad( FALSE, NULL, FALSE );
                    ulState |= DWNLOAD_COMPLETE;
                }
                Assert( pSSS );
                IGNORE_HR(_pStyleSheet->AttachByLastMod(pSSSM, pSSS, NULL, TRUE));
                _pStyleSheet->_eParsingStatus = CSSPARSESTATUS_DONE;
            }
        }
        //
        // else simply fall through...
        // 
    }

    // do parsing if necessary
    if (ulState & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
    {
        // TODO: remove all the if (_pStyleSheet) statement below
        Assert( _pStyleSheet );
        if (_pStyleSheet)
        {
            if (_pStyleSheet->_fComplete)
            {
                TraceTag( (tagSharedStyleSheet, "link - OnDwnChan called while _pStyleSheet->_fComplete is TRUE - skipover" ) );
                Assert( FALSE && "reenter - link ondwnchan");
                goto Cleanup;
            }
            _pStyleSheet->_fComplete = TRUE;
        }
        
        SetReadyStateLink(READYSTATE_COMPLETE);
        pDoc->LeaveStylesheetDownload(&_dwStyleCookie);

        if (ulState & DWNLOAD_COMPLETE)
        {
            BOOL fPendingRoot = FALSE;

            if (IsInMarkup())
                fPendingRoot = GetMarkup()->IsPendingRoot();

            // If unsecure download, may need to remove lock icon on Doc
            Doc()->OnSubDownloadSecFlags(fPendingRoot, _pCssCtx->GetUrl(), _pCssCtx->GetSecFlags());
            
            if (_pStyleSheet)
            {
                if (_pStyleSheet->_eParsingStatus != CSSPARSESTATUS_DONE)
                {
                    hrParsing = THR(_pStyleSheet->DoParsing(_pCssCtx));
                }
                Assert( SUCCEEDED(hrParsing) );
                if (S_OK == hrParsing)
                {
                    // (this is not always stable moment)
                    IGNORE_HR( OnCssChange(/*fStable = */ FALSE, /* fRecomputePeers = */TRUE) );
                }
            }
            else
                TraceTag((tagError, "CLinkElement::OnChan bitsctx failed to get file!"));
        }
        else
        {
            _pStyleSheet->EnsureCopyOnWrite(/*fDetachOnly*/TRUE, /*fWaitForCompletion*/FALSE);
            TraceTag((tagError, "CLinkElement::OnChan bitsctx failed to complete! ulState [%x]", ulState));
        }

        if (S_FALSE != hrParsing)
        {
            TraceTag( (tagSharedStyleSheet, "Link - parsing status == DONE Notify markup and parent, unblock script execution") );
            if (_pStyleSheet)
            {
                _pStyleSheet->CheckImportStatus();
                if (_dwScriptDownloadCookie)
                {
                    Assert (pMarkup);
                    pMarkup->UnblockScriptExecution(&_dwScriptDownloadCookie);
                    _dwScriptDownloadCookie = NULL;
                }
            }

            _pCssCtx->SetProgSink(NULL); // detach download from document's load progress
            SetCssCtx( NULL );           // No reason to hold on to the data anymore
        }
        //
        // else we should wait for callback...
        //
    }
    else 
       WHEN_DBG( if (!(ulState & DWNLOAD_HEADERS)) Assert( "Unknown result returned from CStyleSheet's bitsCtx!" && FALSE ) );

Cleanup:
    delete pbBuffer;
    delete pchSrc;
    return;
}


//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange
//
//  Note:       Called after a property has changed to notify derived classes
//              of the change.  All properties (except those managed by the
//              derived class) are consistent before this call.
//
//              Also, fires a property change notification to the site.
//
//-------------------------------------------------------------------------

HRESULT
CLinkElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;

    switch (dispid)
    {
    case DISPID_CLinkElement_href:
    case DISPID_CLinkElement_rel:
    case DISPID_CLinkElement_type:
        hr = HandleLinkedObjects();
        break;

    case DISPID_CElement_disabled:
        // Passing ChangeStatus() 0 means disable rules
        if(_pStyleSheet)
        {
            hr = THR( _pStyleSheet->ChangeStatus( GetAAdisabled() ? 0 : CS_ENABLERULES, FALSE, NULL ) );
            {
                hr = THR( OnCssChange(/*fStable = */ TRUE, /* fRecomputePeers = */TRUE) );
                if (hr)
                    goto Cleanup;
            }
        }
        break;

    case DISPID_CLinkElement_media:
        {
            if(_pStyleSheet)
            {
                LPCTSTR pcszMedia;

                if ( NULL == ( pcszMedia = GetAAmedia() ) )
                    pcszMedia = _T("all");

                hr = THR( _pStyleSheet->SetMediaType( TranslateMediaTypeString( pcszMedia ), FALSE ) );
                if ( !( OK( hr ) ) )
                    goto Cleanup;

                hr = THR( OnCssChange(/*fStable = */ TRUE, /* fRecomputePeers = */TRUE) );
                if (hr)
                    goto Cleanup;
            }
        }
        break;
    }

    if (OK(hr))
        hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLinkElement::SetActivity
//
//  Synopsis:   Turns activity on or off depending on visibility and
//              in-place activation.
//
//----------------------------------------------------------------------------

void
CLinkElement::SetActivity()
{
}

//--------------------------------------------------------------------------
//
//  Method:     CLinkElement::Passivate
//
//  Synopsis:   Shutdown main object by releasing references to
//              other objects and generally cleaning up.  This
//              function is called when the main reference count
//              goes to zero.  The destructor is called when
//              the reference count for the main object and all
//              embedded sub-objects goes to zero.
//
//              Release any event connections held by the form.
//
//--------------------------------------------------------------------------

void
CLinkElement::Passivate(void)
{
    SetCssCtx(NULL);

    if (_pStyleSheet)
    {
        // Removed from StyleSheetArray in the ExitTree notification

        // Halt all stylesheet downloading.
        _pStyleSheet->StopDownloads( TRUE );

        // Let go of our reference
        _pStyleSheet->Release();
        _pStyleSheet = NULL;
    }

    if (_pSSATemp)
    {
        _pSSATemp->Release();
        _pSSATemp = NULL;
    }
  
    super::Passivate();
}

//--------------------------------------------------------------------------
//
//  Method:     CLinkElement::HandleLinkedObjects()
//
//  Helper called by OnPropertyChange.  Checks whether the attribute
//  values on the link tag require us to link to a stylesheet, and
//  does the appropriate stylesheet creation/release.
//
//--------------------------------------------------------------------------

HRESULT
CLinkElement::HandleLinkedObjects(void)
{
    HRESULT     hr = S_OK;
    CDoc *      pDoc = Doc();
    CMarkup *   pMarkup;
    LPCTSTR     szUrl = GetAAhref();
    LPCTSTR     pcszRel;
    LINKTYPE    linktype;
    CStyleSheetArray *pStyleSheets;
    CStyleSheetCtx  ctxSS;

    pMarkup = GetMarkup();

    Assert (pDoc);

    if (pMarkup)
    {
        pStyleSheets = pMarkup->GetStyleSheetArray();
    }
    else
    {
        pStyleSheets = _pSSATemp;
    }

    linktype = GetLinkType();

    if (LINKTYPE_STYLESHEET != linktype || !szUrl || !(*szUrl))
    {
        // If we get here, it means the attributes on the LINK do not qualify it as
        // a linked stylesheet.  We check if we have a current linked stylesheet, and
        // let it go, forcing a re-render.

        if (_pStyleSheet)
        {
            Assert(pStyleSheets);
            hr = THR(pStyleSheets->ReleaseStyleSheet(
                    _pStyleSheet,
                    TRUE));
            if (hr)
                goto Cleanup;

            _pStyleSheet->Release();
            _pStyleSheet = NULL;

            if (_pSSATemp)
            {
                Assert(!pMarkup);
                _pSSATemp->Release();
                _pSSATemp = NULL;
            }
        }

        if (LINKTYPE_P3PV1POLICYREF == linktype)
        {
            if (pMarkup && pDoc && szUrl && *szUrl)
            {
                TCHAR   cBuf[pdlUrlLen];
                hr = THR(CMarkup::ExpandUrl(pMarkup, szUrl, ARRAY_SIZE(cBuf), cBuf, this));
                THR(pDoc->AddToPrivacyList(CMarkup::GetUrl(pMarkup), cBuf, (DWORD)PRIVACY_URLHASPOLICYREFLINK));
            }
            goto Cleanup;
        }

        if(LINKTYPE_STYLESHEET != linktype)
            goto Cleanup; // done
        // Fall through for the empty href case, some pages need to have an empty stylesheet 
    }

    // If we get here, it means the attributes on the LINK qualify it as a linked stylesheet.
    SetReadyStateLink( READYSTATE_LOADING );

    ctxSS._pParentElement    = this;
    ctxSS._dwCtxFlag         = STYLESHEETCTX_SHAREABLE | STYLESHEETCTX_REUSE;
    ctxSS._szUrl             = szUrl;

    // If we're already ref'ing a stylesheet, then it means that the HREF changed (most likely)
    // or there was no TYPE property and now there is (unlikely, in which case the following work
    // is wasted).  We reload our current stylesheet object with the href.
    if ( _pStyleSheet )
    {
        // If we're in designMode and the don't downloadCSS flag is set on the doc
        // then don't initiate download.  Probably thicket saving.
        if (!(IsDesignMode() && pDoc->_fDontDownloadCSS))
        {
            hr = _pStyleSheet->LoadFromURL( &ctxSS, TRUE );
        }
    }
    // We aren't already ref'ing a stylesheet, so we need a new stylesheet object.
    else
    {
        long nSSInHead = -1;        // default to append

        if (pMarkup)
        {
            hr = pMarkup->EnsureStyleSheets();
            if ( hr )
                goto Cleanup;

            // Figure out where this <link> stylesheet lives (i.e. what should its index in the
            // stylesheet collection be?).  We only need to do this if we are turning an existing
            // link into a stylesheet link -- if this link is in the process of being constructed
            // then we're guaranteed the stylesheet belongs at the end.

            if ( _fIsInitialized )
            {
                Assert( pMarkup );
                CTreeNode *pNode;
                CLinkElement *pLink;
                CStyleElement *pStyle;

                Assert( pMarkup->GetHeadElement() );

                nSSInHead = 0;
            
                CChildIterator ci ( pMarkup->GetHeadElement() );

                while ( (pNode = ci.NextChild() ) != NULL )
                {
                    if ( pNode->Tag() == ETAG_LINK )
                    {
                        pLink = DYNCAST( CLinkElement, pNode->Element() );
                        if ( pLink == this )
                            break;
                        else if ( pLink->_pStyleSheet ) // faster than IsLinkedStyleSheet() and adequate here
                            ++nSSInHead;
                    }
                    else if ( pNode->Tag() == ETAG_STYLE )
                    {
                        pStyle = DYNCAST( CStyleElement, pNode->Element() );
                        if ( pStyle->_pStyleSheet ) // Not all STYLE elements create a SS.
                            ++nSSInHead;
                    }
                }
            }

            pStyleSheets = pMarkup->GetStyleSheetArray();
        }
        else
        {
            if (!_pSSATemp)
            {
                pStyleSheets = new CStyleSheetArray( NULL, NULL, 0 );
                if (!pStyleSheets || pStyleSheets->_fInvalid )
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
                _pSSATemp = pStyleSheets;
            }
            else
                pStyleSheets = _pSSATemp;

            nSSInHead = pStyleSheets->Size();
        }

        hr = pStyleSheets->CreateNewStyleSheet(&ctxSS, &_pStyleSheet, nSSInHead);
        if (!SUCCEEDED(hr))
            goto Cleanup;

        _pStyleSheet->AddRef(); // since the link elem is hanging onto the stylesheet ptr
                                // Note this results in a subref on us.
        if (hr == S_FALSE)
        {
            hr = S_OK;
            if ( szUrl && szUrl[0] )
            {
                hr = EnsureStyleDownload();
            }
            else
            {
                _pStyleSheet->GetSSS()->_fComplete = TRUE;
            }
        }
        else if (hr == S_OK)
        {
            Assert(_pStyleSheet);
            // (this is not always stable moment)
            IGNORE_HR( OnCssChange(/*fStable = */ FALSE, /* fRecomputePeers = */TRUE) );
            // _pStyleSheet might be freed by OnCssChange
            if(_pStyleSheet)
                _pStyleSheet->CheckImportStatus();
        }
    }

    pcszRel = GetAArel();
    if ( GetAAdisabled() || ( pcszRel && !StrCmpIC(_T("alternate stylesheet"), pcszRel ) ) )
    {
        hr = THR( _pStyleSheet->ChangeStatus( 0, FALSE, NULL ) );   // 0 means disable rules
    }

Cleanup:
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLinkElement::EnsureStyleDownload
//
//----------------------------------------------------------------------------

HRESULT
CLinkElement::EnsureStyleDownload()
{
    HRESULT     hr = S_OK;
    CDoc *      pDoc = Doc();
    CCssCtx *  pCssCtx = NULL;
    BOOL fPendingRoot = FALSE;

    if (IsInMarkup())
        fPendingRoot = GetMarkup()->IsPendingRoot();

    Assert( _pStyleSheet->GetSSS() );

    if (_pStyleSheet->_fComplete)
    {
        TraceTag( (tagStyleSheet, "Link [%p] - EnsureStyelDownload [%p]-- stylesheet is already completed", this, _pStyleSheet) );
        IGNORE_HR( OnCssChange(/*fStable = */ FALSE, /* fRecomputePeers = */TRUE) );
        goto Cleanup;
    }

    hr = THR(pDoc->NewDwnCtx(DWNCTX_CSS, _pStyleSheet->GetAbsoluteHref(),
                this, (CDwnCtx **)&pCssCtx, fPendingRoot));
    if(hr)
        goto Cleanup;

    pDoc->EnterStylesheetDownload(&_dwStyleCookie);

    if (IsInMarkup())
    {
        GetMarkup()->BlockScriptExecution(&_dwScriptDownloadCookie);
        Assert (_dwScriptDownloadCookie);
    }

    SetCssCtx(pCssCtx);                                   // Save the bits context

    if (pCssCtx)
        pCssCtx->Release();
    
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLinkElement::OnReadyStateChange
//
//----------------------------------------------------------------------------

void
CLinkElement::OnReadyStateChange()
{   // do not call super::OnReadyStateChange here - we handle firing the event ourselves
    SetReadyStateLink(_readyStateLink);
}

//+------------------------------------------------------------------------
//
//  Member:     CLinkElement::SetReadyStateLink
//
//  Synopsis:   Use this to set the ready state;
//              it fires OnReadyStateChange if needed.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CLinkElement::SetReadyStateLink(long readyStateLink)
{
    TraceTag( (tagStyleSheet, "[%p] set readystate [%x] - complete is %x", this, readyStateLink, READYSTATE_COMPLETE) );
    
    long readyState;
    
    _readyStateLink = readyStateLink;

    readyState = min ((long)_readyStateLink, super::GetReadyState());

    if ((long)_readyStateFired != readyState)
    {
        _readyStateFired = readyState;

        GWPostMethodCall(this,
            ONCALL_METHOD (CLinkElement, DeferredFireEvent, deferredfireevent),
            (DWORD_PTR) &s_propdescCElementonreadystatechange, FALSE, "CLinkElement::DeferredFireEvent");

        if (_readyStateLink == READYSTATE_COMPLETE)
        {
            GWPostMethodCall(this,
                ONCALL_METHOD (CLinkElement, DeferredFireEvent, deferredfireevent),
                (DWORD_PTR) &s_propdescCLinkElementonload, FALSE, "CLinkElement::DeferredFireEvent");
        }
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLinkElement:get_readyState
//
//+------------------------------------------------------------------------------

HRESULT
CLinkElement::get_readyState(BSTR * p)
{
    HRESULT hr = S_OK;

    if ( !p )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR( s_enumdeschtmlReadyState.StringFromEnum(_readyStateFired, p) );

Cleanup:
    RRETURN( SetErrorInfo(hr) );
}

HRESULT
CLinkElement::get_readyState(VARIANT * pVarRes)
{
    HRESULT hr = S_OK;

    if (!pVarRes)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = get_readyState(&V_BSTR(pVarRes));
    if (!hr)
        V_VT(pVarRes) = VT_BSTR;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CLinkElement::get_readyStateValue(long *plRetValue)
{
    HRESULT     hr = S_OK;

    if (!plRetValue)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *plRetValue = _readyStateFired;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------------------
//
//  Member:     CLinkElement:get_styleSheet
//
//+------------------------------------------------------------------------------

HRESULT
CLinkElement::get_styleSheet(IHTMLStyleSheet** ppHTMLStyleSheet)
{
    HRESULT hr = S_OK;

    if (!ppHTMLStyleSheet)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppHTMLStyleSheet = NULL;

    if ( _pStyleSheet )
    {
        hr = _pStyleSheet->QueryInterface(IID_IHTMLStyleSheet,
                                              (void**)ppHTMLStyleSheet);
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}



//+----------------------------------------------------------------------------
//
//  Member:     CLinkElement::GetLinkType
//
//  Tests the attributes of the LINK element to determine what type link this is
//
//+------------------------------------------------------------------------------

CLinkElement::LINKTYPE
CLinkElement::GetLinkType()
{
    LPCTSTR     pchHref = GetAAhref();
    LPCTSTR     pchRel = GetAArel();
    LPCTSTR     pchType = GetAAtype();
    CTreeNode * pNodeContext = GetFirstBranch();

    if (!pNodeContext || (!IsInMarkup() &&
        pNodeContext->Parent()->Tag() == ETAG_HEAD))
        return LINKTYPE_UNKNOWN;

    if (pchHref && pchRel)
    {
        if (0 == StrCmpIC(_T("stylesheet"), pchRel) ||          // if rel = "stylesheet"
            0 == StrCmpIC(_T("alternate stylesheet"), pchRel))  // or rel = "alternate stylesheet"
        {
            if (!pchType || 0 == StrCmpIC(_T("text/css"), pchType)) // if type = "text/css"
            {
                return LINKTYPE_STYLESHEET;                     // this is a stylesheet link
            }
        }

        if (0 == StrCmpIC(_T("P3Pv1"), pchRel))                 // if rel = "P3Pv1"
        {
            return LINKTYPE_P3PV1POLICYREF;
        }
    }

    return LINKTYPE_UNKNOWN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\elist.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eolist.cxx
//
//  Contents:   List Element class (OL, DL, UL, MENU, DIR
//
//  Classes:    CListElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ELIST_HXX_
#define X_ELIST_HXX_
#include "elist.hxx"
#endif

#ifndef X_EDLIST_HXX_
#define X_EDLIST_HXX_
#include "edlist.hxx"
#endif

#ifndef X_ELI_HXX_
#define X_ELI_HXX_
#include "eli.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "list.hdl"

MtDefine(CListElement, Elements, "CListElement")

const CElement::CLASSDESC CListElement::s_classdesc =
{
    {
        &CLSID_HTMLListElement,             // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLListElement,              // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnIHTMLListElement,         // apfnTearOff

    NULL                                    // _pAccelsRun
};

//+------------------------------------------------------------------------
//
//  Member:     CListElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CListElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLListElement2, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CListElement::ApplyDefaultFormat
//
//  Synopsis:   Applies default formatting properties for that element to
//              the char and para formats passed in
//
//  Arguments:  pCFI - Format Info needed for cascading
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CListElement::ApplyDefaultFormat (CFormatInfo *pCFI)
{
    HRESULT hr;
    BOOL fInList;
    WORD wLevel;

    // Don't inherit list-style-type property for list elements.
    // They have their own type defined.
    pCFI->PrepareParaFormat();
    pCFI->_pf().SetListStyleType(styleListStyleTypeNotSet);
    pCFI->UnprepareForDebug();

    // We need to do this first for list elements in order to determine if
    // this is an inside or outside bullet style.  We carefully check before
    // overriding margins or anything else, to see if the properties have already
    // been set by stylesheets, et al.
    hr = THR(super::ApplyDefaultFormat(pCFI));
    if(hr)
        goto Cleanup;

    fInList = pCFI->_ppf->_cListing.IsInList();
    wLevel  = (WORD)pCFI->_ppf->_cListing.GetLevel();

    pCFI->PrepareParaFormat();

    // NOTE (paulnel): we need direction added here because ApplyInnerOuterFormat
    // is not applied until later.
    pCFI->_pf()._fRTLInner = pCFI->_pcf->_fRTL;

    // Other tags interfere with level for DLs. This is necessary for Netscape
    // compatibility because <UL><LI><DL> only causes one level of indentation
    // instead of two. Basically, we reset the level for DLs whenever they're
    // the first nested tag under another type of nested list.
    if (ETAG_DL == Tag() && pCFI->_pf()._fResetDLLevel)
        wLevel = 0;

    // Note that we DO need to indent for DLs after the first one.
    if (ETAG_DL != Tag() || wLevel > 0)
    {
        // Don't inherit any numbering attributes.
        pCFI->_pf()._cListing.Reset();

        pCFI->PrepareFancyFormat();

        BYTE    side;
        side = !pCFI->_ppf->HasRTL(TRUE) ? SIDE_LEFT : SIDE_RIGHT;
        side = !pCFI->_pcf->HasVerticalLayoutFlow() ? side : (++side % SIDE_MAX);

        const CUnitValue &uvSideMargin = pCFI->_ff().GetMargin(side);

        if (    uvSideMargin.IsNullOrEnum()
            &&  (   !HasMarkupPtr() 
                ||  !GetMarkupPtr()->IsStrictCSS1Document() 
                ||  !pCFI->_ff().HasExplicitMargin(side) 
                ||  uvSideMargin.GetUnitType() != CUnitValue::UNIT_ENUM 
                ||  uvSideMargin.GetUnitValue() != styleAutoAuto    ) 
            )
        {
            CUnitValue uv;
            uv.SetPoints(LIST_INDENT_POINTS);
            pCFI->_ff().SetMargin(side, uv);
        }

        pCFI->_ff()._fHasMargins = TRUE;

        if (++wLevel < CListing::MAXLEVELS)
        {
            pCFI->_pf()._cListing.SetLevel(wLevel);
        }

        // Default index style.
        pCFI->_pf()._cListing.SetStyle(FilterHtmlListType(styleListStyleTypeNotSet, wLevel));
    }

    if (ETAG_DL == Tag())
    {
        // DLs have a level, but our normal mechanism above is short
        // circuited because we've combined it with indentation. This is 
        // done for Netscape compatibility.
        if (!wLevel)
        {
            // Paranoid assumption that the maximum allowable levels
            // might actually be zero.
            if (++wLevel < CListing::MAXLEVELS)
            {
                pCFI->_pf()._cListing.SetLevel(wLevel);
            }

            pCFI->_pf()._fResetDLLevel = FALSE;
        }

        // Check to see if the compact flag is set.  If so, set a bit in the para format.
        VARIANT_BOOL fCompact = FALSE;
        IGNORE_HR(this->get_PropertyHelper( &fCompact, (PROPERTYDESC *)&s_propdescCListElementcompact ) );
        pCFI->_pf()._fCompactDL = fCompact;
    }
    else
    {
        // all lists other than DL cause some indent by default. So, if there is
        // an li in the the list, then the bullet is drawn in the indent. For DL
        // there is no indent so do not set offset. This case is handled in
        // MeasureListIndent.
        if (pCFI->_pf()._bListPosition != styleListStylePositionInside)
            pCFI->_pf()._cuvOffsetPoints.SetPoints(LIST_FIRST_REDUCTION_POINTS);

        pCFI->_pf()._fResetDLLevel = TRUE;
    }

    pCFI->UnprepareForDebug();

    // Spacing is different within lists than without.
    ApplyListFormats(pCFI, fInList ? 0 : -1);

    pCFI->PrepareParaFormat();

    pCFI->_pf()._cListing.SetInList();

    // set up for potential EMs, ENs, and ES Conversions
    pCFI->_pf()._lFontHeightTwips = pCFI->_pcf->GetHeightInTwips(Doc());
    if (pCFI->_pf()._lFontHeightTwips <=0)
        pCFI->_pf()._lFontHeightTwips = 1;

    pCFI->UnprepareForDebug();

Cleanup:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:     FilterHtmlListType()
//
//  Returns:    Return the perferred htmlListType
//
//------------------------------------------------------------------------

styleListStyleType
CListElement::FilterHtmlListType(styleListStyleType type, WORD wLevel)
{
    return type;
}

//+-----------------------------------------------------------------------
//
//  Member:     Notify()
//
//  Returns:    Trap exit and enter tree's to invalidate the index caches
//
//------------------------------------------------------------------------
void
CListElement::Notify(CNotification *pNF)
{
    super::Notify(pNF);
    NOTIFYTYPE  ntype = pNF->Type();

    if (ntype == NTYPE_ELEMENT_EXITTREE_1)
    {
        if (!(pNF->DataAsDWORD() & EXITTREE_DESTROY))
        {
            CMarkup *pMarkup = GetMarkup();
            Assert (pMarkup);
            if (!pMarkup)
                goto Cleanup;
            
            CTreeNode *pListNode = pMarkup->FindMyListContainer(GetFirstBranch());
            if (pListNode)
            {
                CListElement *pListElement = DYNCAST(CListElement, pListNode->Element());

                // Invalidate my container so that it has 1 + max of my version and its
                // version. This way we are sure that all my containing LI's will
                // surely be invalid in my container.
                pListElement->_dwVersion = max(_dwVersion, pListElement->_dwVersion) + 1;
            }
        }
    }
    else if (ntype == NTYPE_ELEMENT_ENTERTREE)
    {
        CMarkup *pMarkup = GetMarkup();
        Assert (pMarkup);
        if (!pMarkup)
            goto Cleanup;
        
        CTreeNode *pListNode = pMarkup->FindMyListContainer(GetFirstBranch());
        if (pListNode)
        {
            CListElement *pListElement = DYNCAST(CListElement, pListNode->Element());

            // Update my version number to be the version number of the parent OL + 1
            // so that both, LI's inside me and inside my containing OL are invalidated.
            pListElement->UpdateVersion();
            _dwVersion = pListElement->_dwVersion;
        }
        else
        {
            // If we have _thrown_ an OL around existing LI's then we have to nuke
            // the version numbers of all such LI's since they are invalid now.
            CListItemIterator ci(this, NULL);
            CTreeNode *pNode;
            
            while ((pNode = ci.NextChild()) != NULL)
            {
                CLIElement *pLIElement = DYNCAST(CLIElement, pNode->Element());
                pLIElement->_ivIndex._dwVersion = 0;
            }

            // Finally nuke the OL's version number too!
            _dwVersion = 0;
        }
    }

Cleanup:
    return;
}


static ELEMENT_TAG g_etagChildrenNoRecurse[] = {ETAG_OL, ETAG_UL, ETAG_DL, ETAG_DIR, ETAG_MENU, ETAG_LI};
static ELEMENT_TAG g_etagInterestingChildren[] = {ETAG_LI};
    // Removed CHILDITERATOR_DEEP since USETAGS implies deep and giving both _USETAGS+_DEEP confuses
    // the iterator.
static const DWORD LI_ITERATE_FLAGS=(CHILDITERATOR_USETAGS); // Use the lists to stop recursion
CListItemIterator::CListItemIterator(CListElement *pElementContainer, CElement *pElementStart)
            :CChildIterator(pElementContainer,
                            pElementStart,
                            LI_ITERATE_FLAGS,
                            &g_etagChildrenNoRecurse[0],     // Do NOT recurse into these children
                            sizeof(g_etagChildrenNoRecurse) / sizeof(g_etagChildrenNoRecurse[0]),
                            &g_etagInterestingChildren[0],   // Return all of these kinds of children to me
                            sizeof(g_etagInterestingChildren) / sizeof(g_etagInterestingChildren[0])
                           )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\eli.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eli.cxx
//
//  Contents:   LI element class
//
//  Classes:    CLIElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ELI_HXX_
#define X_ELI_HXX_
#include "eli.hxx"
#endif

#ifndef X_ELIST_HXX_
#define X_ELIST_HXX_
#include "elist.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#ifndef X_NUMCONV_HXX_
#define X_NUMCONV_HXX_
#include "numconv.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#define _cxx_
#include "li.hdl"

MtDefine(CLIElement, Elements, "CLIElement")

EXTERN_C const ENUMDESC s_enumdescTYPE;

const CElement::CLASSDESC CLIElement::s_classdesc =
{
    {
        &CLSID_HTMLLIElement,               // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLLIElement,                // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLLIElement,         //_apfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CLIElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_LI));

    Assert(ppElement);
    *ppElement = new CLIElement(pDoc);
    return *ppElement ? S_OK: E_OUTOFMEMORY;
}

HRESULT
CLIElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT     hr = S_OK;
    CTreeNode * pNodeList = NULL;
    CTreeNode * pNodeContext = pCFI->_pNodeContext;
    CFlowLayout *pFL;
    
    Assert(pNodeContext && SameScope(this, pNodeContext));

    // Find the List element
    pFL = pNodeContext->Parent()->GetFlowLayout();
    if (pFL && pFL->GetContentMarkup())
    {
        pNodeList = pFL->GetContentMarkup()->SearchBranchForCriteria(
            pCFI->_pNodeContext->Parent(), IsBlockListElement, NULL);
    }

    // Setup default LI formats
    // Default bullet position is inside for naked LI's.
    pCFI->PrepareParaFormat();
    pCFI->_pf()._cListing.SetType((pNodeList && ETAG_OL == pNodeList->Tag())
                                  ? CListing::NUMBERING : CListing::BULLET);
    if (pNodeList)
    {
        CListElement * pListElem = DYNCAST(CListElement, pNodeList->Element());
        pCFI->_pf()._cListing.SetStyle(pListElem->FilterHtmlListType(pCFI->_ppf->GetListStyleType(), 
            ETAG_OL == pNodeList->Tag() ? 0 : (WORD)pCFI->_ppf->_cListing.GetLevel()));
    }
    if (!pCFI->_pf()._fExplicitListPosition)
    {
        // If list position hasn't been explicitly set, naked LIs and 
        // LIs inside DLs by default have bullet position inside.
        pCFI->_pf()._bListPosition = (pNodeList && pNodeList->Tag() != ETAG_DL)
                                   ? styleListStylePositionOutSide 
                                   : styleListStylePositionInside;
    }
    pCFI->UnprepareForDebug();

    // Apply formats
    hr = THR(super::ApplyDefaultFormat(pCFI));
    if(hr)
        goto Cleanup;

    // check for the VALUE attribute.
    if (GetAAvalue() > 0)
    {
        pCFI->PrepareParaFormat();
        pCFI->_pf()._cListing.SetValueValid();
        pCFI->_pf()._lNumberingStart = GetAAvalue();
        pCFI->UnprepareForDebug();
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CLIElement::Save
//
//  Synopsis:   Save the element to the stream
//
//-------------------------------------------------------------------------

HRESULT
CLIElement::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr;
    CElement *pElementParent = IsInMarkup() ? GetFirstBranch()->Parent()->Element() : NULL;
    CFlowLayout *pFL = GetFlowLayout();
    CElement *pElementFL = pFL ? pFL->ElementContent() : NULL;

    AssertSz( !( pStreamWrBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC) ||
                 pStreamWrBuff->TestFlag(WBF_NUMBER_LISTS) )
              || pElementParent, 
              "Parentless LIs can not be saved with these flags on!" );

    if (    pStreamWrBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC) 
        &&  pStreamWrBuff->TestFlag(WBF_SAVE_SELECTION)
        &&  pElementParent->Tag() == ETAG_OL
        &&  !fEnd
        &&  !IsDisplayNone() )
    {
        CListValue LV;
        GetValidValue(&LV, GetMarkupPtr(), GetFirstBranch(), 
            GetMarkupPtr()->FindMyListContainer(GetFirstBranch()), pElementFL);

        CAttrArray * pNewAA;
        CAttrArray * pOldAA = *GetAttrArray();
        if (pOldAA)
        {
            hr = pOldAA->Clone(&pNewAA);
            if (hr)
                goto Cleanup;
        }
        else
            pNewAA = new CAttrArray;

        if(!pNewAA)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        VARIANT value;
        value.vt = VT_I4;
        value.lVal = LV._lValue;
        CAttrArray::Set(&pNewAA, DISPID_CLIElement_value, &value);
        SetAttrArray(pNewAA);

        hr = super::Save(pStreamWrBuff, fEnd);

        SetAttrArray(pOldAA);
        delete pNewAA;
    }
    else
    {
        TCHAR ach[17];

        hr = super::Save(pStreamWrBuff, fEnd);
        if (hr)
            goto Cleanup;

        if (pStreamWrBuff->TestFlag(WBF_NUMBER_LISTS) && !fEnd)
        {
            CListValue LI;
            GetValidValue(&LI, GetMarkupPtr(), GetFirstBranch(), 
                GetMarkupPtr()->FindMyListContainer(GetFirstBranch()), pElementFL);

            if(pElementParent->Tag() == ETAG_OL)
            {
                NumberToNumeral(LI._lValue, ach);
            }
            else
            {
                NumberToAlphaLower(LI._lValue, ach);
            }

            hr = pStreamWrBuff->Write(ach);
            if (hr)
                goto Cleanup;

            hr = pStreamWrBuff->Write(_T(". "), 2);
           if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CLIElement::Notify
//
//  Synopsis:   Catches enter and exit tree notifications to update the
//              index caches.
//
//-------------------------------------------------------------------------
void
CLIElement::Notify(CNotification *pNF)
{
    super::Notify(pNF);
    switch (pNF->Type())
    {
        case NTYPE_ELEMENT_EXITTREE_1:
            if (pNF->DataAsDWORD() & EXITTREE_DESTROY)
                break;
            // Else, fall thru and do exactly the same stuff we would do on enter tree
        case NTYPE_ELEMENT_ENTERTREE:
        {
            CMarkup *pMarkup = GetMarkup();
            Assert(pMarkup);
            if (!pMarkup)
                goto Cleanup;

            CTreeNode *pListNode = pMarkup->FindMyListContainer(GetFirstBranch());
            if (pListNode)
            {
                DYNCAST(CListElement, pListNode->Element())->UpdateVersion();

                // For an LI coming in, we want to be sure that its version and
                // value are invalid. They may not be if this LI is being cut and
                // pasted from another part of the document. It may so happen that
                // the LI has the exact same version as the one we updated just
                // above,  then the LI will in most cases have a bad value.
                _ivIndex._dwVersion = 0;
                _ivIndex._lValue = 0;
            }
            break;
        }
    }
Cleanup:
    return;
}


//+------------------------------------------------------------------------
//
//  Member:     CLIElement::GetValidValue
//
//  Synopsis:   This is the main function which returns the list index value
//              for an LI. Its only called by the renderer.
//
//-------------------------------------------------------------------------
VOID
CLIElement::GetValidValue(CListValue   *pLV,                // [o]
                          CMarkup      *pMarkup,            // [i]
                          CTreeNode    *pLINode,            // [i]
                          CTreeNode    *pNodeListElement,   // [i]
                          CElement     *pElementFL)         // [i]
{
    CListing  Listing;
    BOOL      fInner;
    const     CParaFormat *pPF;
    CListElement *pListElement;
    
    Assert(pLV);
    Assert(pMarkup == GetMarkup());
    Assert(pLINode && pLINode->Element() == this);
    Assert(SameScope(pNodeListElement, pMarkup->FindMyListContainer(pLINode)));
    Assert(pElementFL);
    Assert(!IsDisplayNone());
    
    pListElement = pNodeListElement ? DYNCAST(CListElement, pNodeListElement->Element()) : NULL;

    fInner = SameScope(pLINode, pElementFL);
    pPF = pLINode->GetParaFormat();
    Listing = pPF->GetListing();
    Assert(Listing.HasAdornment());

    // Note(SujalP): LI's are naked if they are under anything but
    // OL and UL. (So an LI under a BODY, P, DL is considered naked)
    if (   !pListElement
        || pListElement->Tag() == ETAG_DL
       )
    {
        pLV->_lValue = Listing.IsValueValid()
                       ? pPF->GetNumberingStart()
                       : 1;
        pLV->_style = Listing.GetStyle();
    }

    // Valid index
    else if (IsIndexValid(pListElement))
    {
        pLV->_lValue = _ivIndex._lValue;
        pLV->_style  = Listing.GetStyle();
    }

    // Invalid index
    else
    {
        CTreeNode  *pNodeLastValid;
        CTreeNode  *pNode;

        // Find the previous valid LI with a valid index. If there was not valid LI
        // then the list container is by default valid so find that.
        LONG lValue = FindPreviousValidIndexedElement(pNodeListElement,
            pLINode,
            pElementFL,
            &pNodeLastValid);
        
        // We have to have a node, and it is either the container itself
        // or its a LI with a valid index.
        Assert(   pNodeLastValid
               && (   SameScope(pNodeLastValid, pListElement)
                   || DYNCAST(CLIElement, pNodeLastValid->Element())->IsIndexValid(pListElement)
                  )
              );

        CListItemIterator ci(pListElement,
                             SameScope(pNodeLastValid, pListElement) ? NULL : pNodeLastValid->Element());

        // Use the iterator to walk forward from the last li with a valid index to the
        // present LI, validating all the LI's along the way.
        while((pNode = ci.NextChild()) != NULL)
        {
            // Ignore an LI if it not displayed. Remember a display none LI will
            // never have a valid index
            if (pNode->IsDisplayNone())
            {
                Assert(!DYNCAST(CLIElement, pNode->Element())->IsIndexValid(pListElement));
                continue;
            }
            
            CLIElement *pLIElement = DYNCAST(CLIElement, pNode->Element());

            pPF         = pNode->GetParaFormat();
            fInner      = SameScope(pNode, pElementFL);
            Listing     = pPF->GetListing();

            if (Listing.IsValueValid())
            {
                lValue = pPF->GetNumberingStart();
            }
            
            // Validate all the list elements as we are walking forward
            pLIElement->_ivIndex._lValue    = lValue;
            pLIElement->_ivIndex._dwVersion = pListElement->_dwVersion;

            // If we have reached our LI then we stop any further validations.
            if (pLIElement == this)
            {
                pLV->_style  = Listing.GetStyle();
                pLV->_lValue = lValue;
                break;
            }

            // Increment the index to go to the next LI
            lValue++;
        }
    }
    
    if (pLV->_style == styleListStyleTypeNotSet)
        pLV->_style  = styleListStyleTypeDisc;
    return;
}


//+-----------------------------------------------------------------------
//
//  Member:     FindPreviousValidIndexedElement
//
//  Returns:    Finds the previous valid LI and returns the index to be
//              given to the current LI
//
//------------------------------------------------------------------------
LONG
CLIElement::FindPreviousValidIndexedElement(CTreeNode *pNodeListIndex,
                                            CTreeNode *pLINode,
                                            CElement  *pElementFL,
                                            CTreeNode **ppNodeLIPrevValid)
{
    Assert(pNodeListIndex);
    Assert(pLINode);
    Assert(ppNodeLIPrevValid);
    Assert(pElementFL);
    
    CTreeNode    *pNode;
    CLIElement   *pLIElement = NULL;
    LONG          lValue;
    CListElement *pListElement = DYNCAST(CListElement, pNodeListIndex->Element());

    CListItemIterator ci(pListElement, pLINode->Element());

    // Walk back till we find a LI with a valid index.
    while((pNode = ci.PreviousChild()) != NULL)
    {
        pLIElement = DYNCAST(CLIElement, pNode->Element());
        if (pLIElement->IsIndexValid(pListElement))
            break;
        pLIElement = NULL;
    }

    // If we came here with a NULL pLIElement, it means that we could not find
    // a LI with valid index and we have to return the OL.
    if (pLIElement)
    {
        lValue = pLIElement->_ivIndex._lValue + 1;
    }
    else
    {
        if (pNodeListIndex->Tag() == ETAG_OL)
        {
            const CParaFormat *pPF = pNodeListIndex->GetParaFormat();
            lValue = pPF->GetNumberingStart();
        }
        else
        {
            lValue = 1;
        }

        // If we have reached our container and its version is 0, then we have
        // have to validate the container's version number.
        if (pListElement->_dwVersion == 0)
            pListElement->_dwVersion = 1;
        
        pNode = pNodeListIndex;
    }

    *ppNodeLIPrevValid = pNode;
    return lValue;
}

//+-----------------------------------------------------------------------
//
//  Member:    IsIndexValid()
//
//  Note  :    Verifies if the index is a valid index.
//
//------------------------------------------------------------------------
BOOL
CLIElement::IsIndexValid(CListElement *pListElement)
{
    // NOTE: The following also tests for pListElement->_dwVersion==0 by default
    // and returns false in that case too.
    return    _ivIndex._dwVersion != 0
           && _ivIndex._dwVersion == pListElement->_dwVersion;
}

//+-----------------------------------------------------------------------
//
//  Member:     OnPropertyChange()
//
//  Note  :    Trap the change to start attribute to inval the index caches
//
//------------------------------------------------------------------------
HRESULT
CLIElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr;

    if (dispid == DISPID_CLIElement_value)
    {
        CTreeNode *pNode = GetMarkup()->FindMyListContainer(GetFirstBranch());
        if (pNode)
        {
            DYNCAST(CListElement, pNode->Element())->UpdateVersion();
        }
    }
    hr = THR( super::OnPropertyChange( dispid, dwFlags, ppropdesc ) );

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\eheader.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eheader.cxx
//
//  Contents:   Header Element class
//
//  Classes:    CHeaderElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EHEADER_HXX_
#define X_EHEADER_HXX_
#include "eheader.hxx"
#endif

#ifndef X_EFONT_HXX_
#define X_EFONT_HXX_
#include "efont.hxx"
#endif

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#define _cxx_
#include "header.hdl"


const CElement::CLASSDESC CHeaderElement::s_classdesc =
{
    {
        &CLSID_HTMLHeaderElement,           // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLHeaderElement,            // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLHeaderElement,     // _apfnTearOff
    NULL                                    // _pAccelsRun
};


HRESULT CHeaderElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert( pht->Is(ETAG_H1) || pht->Is(ETAG_H2) ||
            pht->Is(ETAG_H3) || pht->Is(ETAG_H4) ||
            pht->Is(ETAG_H5) || pht->Is(ETAG_H6));

    Assert(ppElementResult);
    *ppElementResult = new CHeaderElement(pht->GetTag(), pDoc);
    return *ppElementResult ? S_OK : E_OUTOFMEMORY;
}

//+------------------------------------------------------------------------
//
//  Member:     CHeaderElement::ApplyDefaultFormat
//
//  Synopsis:   Applies default formatting properties for that element to 
//              the char and para formats passed in
//
//  Arguments:  pCFI - Format Info needed for cascading
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
                                 
HRESULT                           
CHeaderElement::ApplyDefaultFormat (CFormatInfo *pCFI)
{
    if ( _nLevel >= 1 && _nLevel <= 6 )
    {
        //
        // Apply default before/after space.
        // NOTE: Before/after space are outside our box (== margins), 
        //       so they are relative to the parent's text flow.
        //
        BOOL fParentVertical = pCFI->_pNodeContext->IsParentVertical();

        pCFI->PrepareFancyFormat();
        ApplyDefaultVerticalSpace(fParentVertical, &pCFI->_ff());
        pCFI->UnprepareForDebug();

        pCFI->PrepareCharFormat();
        pCFI->_cf().SetHeightInTwips( ConvertHtmlSizeToTwips( 7-_nLevel ) );
        pCFI->_cf()._fBold = TRUE;
        pCFI->_cf()._wWeight = 700;
        pCFI->_cf()._fBumpSizeDown = FALSE; // Nav compat
        pCFI->UnprepareForDebug();
    }

    RRETURN(super::ApplyDefaultFormat(pCFI));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\elabel.cxx ===
//+---------------------------------------------------------------------
//
//   File:      elabel.cxx
//
//  Contents:   Label element class
//
//  Classes:    CLabelElement
//
//------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include <cguid.h>
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_INPUTTXT_H_
#define X_INPUTTXT_H_
#include "inputtxt.h"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_INPUTBTN_H_
#define X_INPUTBTN_H_
#include "inputbtn.h"
#endif

#ifndef X_INPUTBTN_HXX_
#define X_INPUTBTN_HXX_
#include "inputbtn.hxx"
#endif

#ifndef X_ELABEL_HXX_
#define X_ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include <treepos.hxx>
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_BTNHLPER_H_
#define X_BTNHLPER_H_
#include "btnhlper.hxx"
#endif

#define _cxx_
#include "label.hdl"

MtDefine(CLabelElement, Elements, "CLabelElement")

#ifndef NO_PROPERTY_PAGE
const CLSID * const CLabelElement::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
    // &CLSID_CCDLabelPropertyPage,
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif // DBG==1    
    NULL
};
#endif // NO_PROPERTY_PAGE


const CElement::CLASSDESC CLabelElement::s_classdesc =
{
    {
        &CLSID_HTMLLabelElement,            // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLLabelElement,             // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLLabelElement,      // _pfnTearOff
    NULL                                    // _pAccelsRun
};


HRESULT
CLabelElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_LABEL));
    Assert(ppElement);
    *ppElement = new CLabelElement(pDoc);
    return *ppElement ? S_OK : E_OUTOFMEMORY;
}

//+------------------------------------------------------------------------
//
//  Member:     CLabelElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CLabelElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_TEAROFF(this, IHTMLLabelElement2, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

#ifndef NO_DATABINDING
const CDBindMethods *
CLabelElement::GetDBindMethods()
{
    return &DBindMethodsTextRichRO;
}
#endif

HRESULT
CLabelElement::ClickAction(CMessage *pMessage)
{
    HRESULT     hr      = S_OK;
    FOCUS_ITEM  fi;
    
    fi = GetMnemonicTarget(pMessage ? pMessage->lSubDivision : 0);

    if (fi.pElement)
    {

        // Activate and click pElem. Use NULL instead of
        // pMessage, because the original message was intended for
        // the label and would not be appropriate for pElem.

        hr = THR(fi.pElement->BecomeCurrentAndActive(fi.lSubDivision, NULL, NULL, TRUE));
        if (hr)
            goto Cleanup;

        hr = THR(fi.pElement->ScrollIntoView());
        if (FAILED(hr))
            goto Cleanup;

        // TODO (MohanB) Click would not fire on the subdivision!
        hr = THR(fi.pElement->DoClick(NULL, fi.pElement->GetFirstBranch(), TRUE));
    }
Cleanup:
    // Do not want this to bubble, so..
    if (S_FALSE == hr)
        hr = S_OK;

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CLabelElement::HandleMessage
//
//  Synopsis:   Perform any element specific mesage handling
//
//  Arguments:  pmsg    Ptr to incoming message
//
//-------------------------------------------------------------------------

HRESULT
CLabelElement::HandleMessage(CMessage *pMessage)
{
    HRESULT     hr = S_FALSE;
    FOCUS_ITEM  fi;
    CInput     *pInput;
    CButton    *pButton;
    
    // If not in browse mode, then ignore message.
    if (IsEditable(TRUE))
        goto Ignored;

    switch (pMessage->message)
    {
    case WM_SETCURSOR:
#ifdef WIN16
        ::SetCursor(LoadCursor(NULL, IDC_ARROW));
#else
        SetCursorStyle(IDC_ARROW);
#endif
        hr = S_OK;
        break;
    case WM_MOUSEOVER:
    case WM_MOUSELEAVE:
        fi = GetMnemonicTarget(pMessage ? pMessage->lSubDivision : 0);
        if (fi.pElement && fi.pElement->Tag() == ETAG_INPUT)
        {
            pInput = DYNCAST(CInput, fi.pElement);
            if (pInput->IsOptionButton())
            {
                if (pMessage->message == WM_MOUSEOVER)
                {
                    pInput->_wBtnStatus = BTN_SETSTATUS(pInput->_wBtnStatus, FLAG_MOUSEOVER);
                }
                else // pMessage->message == WM_MOUSELEAVE
                {                 
                    pInput->_wBtnStatus = BTN_RESSTATUS(pInput->_wBtnStatus, FLAG_MOUSEOVER);                
                }
                
                pInput->CBtnHelper::Invalidate();
            }
        }
        else if (fi.pElement && fi.pElement->Tag() == ETAG_BUTTON)
        {
            pButton = DYNCAST(CButton, fi.pElement);
            if (pMessage->message == WM_MOUSEOVER)
            {
                pButton->_wBtnStatus = BTN_SETSTATUS(pButton->_wBtnStatus, FLAG_MOUSEOVER);
            }
            else // pMessage->message == WM_MOUSELEAVE
            {                 
                pButton->_wBtnStatus = BTN_RESSTATUS(pButton->_wBtnStatus, FLAG_MOUSEOVER);                
            }
            
            pButton->CBtnHelper::Invalidate();
            
        }
        hr = S_OK;
        break;
    }

Ignored:
    if (S_FALSE == hr)
    {
        hr = THR(super::HandleMessage(pMessage));
    }
    RRETURN1(hr, S_FALSE);
}

void
CLabelElement::Notify(CNotification *pNF)
{
    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_QUERYMNEMONICTARGET:
        {
            FOCUS_ITEM          fi;
            CElement *          pElem       = NULL;
            LPCTSTR             pszIdFor,
                                pszId;
            int                 c;
            CCollectionCache*   pCollectionCache;

            fi.pElement = NULL;
            fi.lSubDivision = 0;

            pszIdFor = GetAAhtmlFor();
            if (!pszIdFor || !pszIdFor[0])
                goto CleanupGetTarget;

            if (!IsInMarkup())
                goto CleanupGetTarget;

            // Search the document's collection for a site which has the same id
            // that is associated with this label.
            if (S_OK != THR(GetMarkup()->EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION)))
                goto CleanupGetTarget;

            pCollectionCache = GetMarkup()->CollectionCache();

            // get size of collection
            c = pCollectionCache->SizeAry(CMarkup::ELEMENT_COLLECTION);

            while (c--)
            {
                if (S_OK != THR(pCollectionCache->GetIntoAry(CMarkup::ELEMENT_COLLECTION, c, &pElem)))
                    goto CleanupGetTarget;

                pszId = pElem->GetAAid();

                // is this item in the target group?
                if (pszId && !FormsStringICmp(pszIdFor, pszId))
                {
                    break;
                }
            }
        CleanupGetTarget:
            if (pElem)
            {
                if (pElem->Tag() == ETAG_AREA)
                {
                    // Get the <IMG, lSubDivision> pair
                    fi = pElem->GetMnemonicTarget(0);
                }
                else
                {
                    fi.pElement = pElem;
                }
            }
            *(FOCUS_ITEM *)pNF->DataAsPtr() = fi;
        }
        break;
    default:
        super::Notify(pNF);
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\enoshow.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       eshow.cxx
//
//  Contents:   CNoShowElement
//
//  History:    15-Jul-1996     AnandRa     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ENOSHOW_HXX_
#define X_ENOSHOW_HXX_
#include "enoshow.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#define _cxx_
#include "noshow.hdl"

MtDefine(CNoShowElement, Elements, "CNoShowElement")
MtDefine(CShowElement, Elements, "CShowElement")

//+------------------------------------------------------------------------
//
//  Class:      CNoShowElement
//
//  Synopsis:   
//
//-------------------------------------------------------------------------

const CElement::CLASSDESC CNoShowElement::s_classdesc =
{
    {
        &CLSID_HTMLNoShowElement,           // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLNoShowElement,            // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnIHTMLNoShowElement,

    NULL                                    // _pAccelsRun
};


HRESULT
CNoShowElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);
    *ppElementResult = new CNoShowElement(pht->GetTag(), pDoc);

    return (*ppElementResult ? S_OK : E_OUTOFMEMORY);
}

//+---------------------------------------------------------------------------
//
//  Member:     CNoShowElement::Save
//
//  Synopsis:   called twice: for opening <NOFRAMES> and for </NOFRAMES>.
//
//----------------------------------------------------------------------------

HRESULT
CNoShowElement::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr;

    hr = THR(super::Save(pStreamWrBuff, fEnd));
    if (hr)
        goto Cleanup;

    if (!fEnd && !pStreamWrBuff->TestFlag(WBF_SAVE_PLAINTEXT))
    {
        DWORD dwOldFlags = pStreamWrBuff->ClearFlags(WBF_ENTITYREF);

        pStreamWrBuff->SetFlags(WBF_KEEP_BREAKS | WBF_NO_WRAP);

        if (_cstrContents.Length())
        {
            hr = THR(pStreamWrBuff->Write(_cstrContents));
            if (hr)
                goto Cleanup;
        }

        pStreamWrBuff->RestoreFlags(dwOldFlags);
    }

Cleanup:

    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\eolist.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eolist.cxx
//
//  Contents:   Ordered List Element class
//
//  Classes:    COListElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EOLIST_HXX_
#define X_EOLIST_HXX_
#include "eolist.hxx"
#endif

#define _cxx_
#include "olist.hdl"

EXTERN_C const ENUMDESC s_enumdescTYPE;

const CElement::CLASSDESC COListElement::s_classdesc =
{
    {
        &CLSID_HTMLOListElement,            // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLOListElement,             // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLOListElement,      // _apfnTearOff
    NULL                                    // _pAccelsRun
};


//+------------------------------------------------------------------------
//
//  Member:     COListElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
COListElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if IID_HTML_TEAROFF(this, IHTMLOListElement, NULL)
    else
    {
        RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    (*(IUnknown **)ppv)->AddRef();
    return S_OK;
}


HRESULT COListElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(pht->Is(ETAG_OL));
    Assert(ppElementResult);
    *ppElementResult = new COListElement(pDoc);
    return *ppElementResult ? S_OK : E_OUTOFMEMORY;
}

HRESULT
COListElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr;

    hr = super::ApplyDefaultFormat(pCFI);
    if (hr)
        goto Cleanup;

    pCFI->PrepareParaFormat();
    pCFI->_pf()._lNumberingStart = GetAAstart();
    pCFI->_pf()._cListing.SetStyle(FilterHtmlListType(pCFI->_ppf->GetListStyleType(), 0));
    pCFI->UnprepareForDebug();

Cleanup:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:     FilterHtmlListType()
//
//  Returns:    Return the perferred htmlListType for ordered lists.
//
//------------------------------------------------------------------------

styleListStyleType
COListElement::FilterHtmlListType(  styleListStyleType type, WORD wLevel )
{
    return ( styleListStyleTypeNotSet != type) ? type : styleListStyleTypeDecimal;
}


//+-----------------------------------------------------------------------
//
//  Member:     OnPropertyChange()
//
//  Note  :    Trap the change to start attribute to inval the index caches
//
//------------------------------------------------------------------------
HRESULT
COListElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr;

    if (dispid == DISPID_COListElement_start)
    {
        UpdateVersion();
    }
    hr = THR( super::OnPropertyChange( dispid, dwFlags, ppropdesc ) );

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\emap.cxx ===
//=-----------------------------------------------------------=
//
// File:        emap.cxx
//
// Contents:    Map element class
//
// Classes:     CMapElement
//              CAreasCollection
//
//=-----------------------------------------------------------=

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_EMAP_HXX_
#define X_EMAP_HXX_
#include "emap.hxx"
#endif

#ifndef X_CSIMUTIL_HXX_
#define X_CSIMUTIL_HXX_
#include "csimutil.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#define _cxx_
#include "map.hdl"

MtDefine(CMapElement, Elements, "CMapElement")
MtDefine(CAreasCollection, Tree, "CAreasCollection")
MtDefine(BldMapAreasCol, PerfPigs, "Build CMapElement::AREAS_COLLECTION")

const CElement::CLASSDESC CMapElement::s_classdesc =
{
    {
        &CLSID_HTMLMapElement,              // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLMapElement,               // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnIHTMLMapElement,          // _pfnTearOff

    NULL                                    // _pAccelsRun
};

CMapElement::CMapElement(CDoc *pDoc)
    : CElement(ETAG_MAP, pDoc)
{
#ifdef WIN16
    m_baseOffset = ((BYTE *) (void *) (CBase *)this) - ((BYTE *) this);
    m_ElementOffset = ((BYTE *) (void *) (CElement *)this) - ((BYTE *) this);
#endif
}

//=-----------------------------------------------------------------------=
//
// Function:    CreateElement
//
// Synopsis:    Creates an instance of the given element's class
//
// Arguments:   CHtmTag *pst - struct for creation info
//              CElement *pElementParent - Parent of new element
//              CElement **ppElement - Return ptr to element in *ppElement.
//
//=-----------------------------------------------------------------------=
HRESULT
CMapElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_MAP));
    Assert(ppElement);

    *ppElement = new CMapElement(pDoc);

    return *ppElement ? S_OK : E_OUTOFMEMORY;
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      Destructor, and pasivate
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

CMapElement::~CMapElement()
{
    delete _pCollectionCache;
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      Notification
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

void
CMapElement::Notify(CNotification *pNF)
{
    CMarkup * pMarkup;

    super::Notify(pNF);

    switch (pNF->Type())
    {
        case NTYPE_ELEMENT_ENTERTREE:
        {
            pMarkup = GetMarkup();
            Assert(pMarkup);
            _pMapNext = pMarkup->GetMapHead();
            pMarkup->SetMapHead(this);
            break;
        }

        case NTYPE_ELEMENT_EXITTREE_1:
        {
            CMapElement ** ppMap, *pMap;

            pMarkup = GetMarkup(); Assert(pMarkup);
            Assert( pMarkup->HasEditContext() && pMarkup->GetMapHead() );
            for ( ppMap = &( pMarkup->GetEditContext()->_pMapHead ); (pMap = *ppMap) != NULL; ppMap = &pMap->_pMapNext)
            {
                if (pMap == this)
                {
                    *ppMap = _pMapNext;
                    break;
                }
            }
            AssertSz(pMap == this, "Can't find CMapElement in CMarkupEditContext::_pMapHead list");
            break;
        }
    }
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      Containment Checking
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

//=-----------------------------------------------------------------------=
//
// Function:    GetAreaContaining
//
// Synopsis:    Gives the area in the map that contains the given point,
//                  if there is an area that contains it.  If the point
//                  is not contained within an area, it sets it to NULL.
//                  If an area is found, returns S_OK, if not, E_FAIL.
//
// Arguments:   POINT pt - The point for which to check containment.
//              CAreaElement **parea - Area (if any) containing the point
//                  is stored in *parea.
//
//=-----------------------------------------------------------------------=

HRESULT
CMapElement::GetAreaContaining(POINT pt, long *plIndex)
{
    CChildIterator ci(this, NULL, CHILDITERATOR_DEEP);
    CTreeNode * pNode;
    CAreaElement * pArea;
    LONG lIndex = 0;

    while ((pNode = ci.NextChild()) != NULL)
    {
        if (pNode->Tag() == ETAG_AREA)
        {
            pArea = DYNCAST(CAreaElement, pNode->Element());

            if (Contains(pt, pArea->_coords, pArea->_nShapeType))
            {
                *plIndex = lIndex;
                return S_OK;
            }

            lIndex += 1;
        }
    }

    *plIndex = -1;
    return S_OK;
}


//=-----------------------------------------------------------------------=
//
// Function:    GetAreaContaining
//
// Synopsis:    Gives the area in the map that contains the given point,
//                  if there is an area that contains it.  If the point
//                  is not contained within an area, it sets it to NULL.
//                  If an area is found, returns S_OK, if not, E_FAIL.
//
//=-----------------------------------------------------------------------=

HRESULT
CMapElement::GetAreaContaining(long lIndex, CAreaElement **ppArea)
{
    CChildIterator ci(this, NULL, CHILDITERATOR_DEEP);
    CTreeNode * pNode;

    *ppArea = NULL;
    while (lIndex >= 0 && (pNode = ci.NextChild()) != NULL)
    {
        if (pNode->Tag() == ETAG_AREA)
        {
            if (lIndex == 0)
            {
                *ppArea = DYNCAST(CAreaElement, pNode->Element());
                return S_OK;
            }

            lIndex -= 1;
        }
    }

    return E_FAIL;
}

LONG
CMapElement::GetAreaCount()
{
    CChildIterator ci(this, NULL, CHILDITERATOR_DEEP);
    CTreeNode * pNode;
    LONG lCount = 0;

    while ((pNode = ci.NextChild()) != NULL)
    {
        if (pNode->Tag() == ETAG_AREA)
        {
            lCount += 1;
        }
    }

    return lCount;
}

HRESULT
CMapElement::GetAreaTabs(long *pTabs, long c)
{
    CChildIterator ci(this, NULL, CHILDITERATOR_DEEP);
    CTreeNode * pNode;

    while ((pNode = ci.NextChild()) != NULL)
    {
        if (pNode->Tag() == ETAG_AREA)
        {
            if (c == 0)
            {
                AssertSz(0, "Requesting more tabs than there are AREA elements");
                return E_FAIL;
            }

            *pTabs++ = DYNCAST(CAreaElement, pNode->Element())->GetAAtabIndex();
            c -= 1;
        }
    }

    return S_OK;
}

//=-----------------------------------------------------------------------=
//
// Function:    CMapElement::SearchArea
//
// Synopsis:    Search for the given area, returning it's index
//
//=-----------------------------------------------------------------------=

HRESULT
CMapElement::SearchArea(CAreaElement *pAreaFind, long *plIndex)
{
    CChildIterator ci(this, NULL, CHILDITERATOR_DEEP);
    CTreeNode * pNode;
    CAreaElement * pArea;
    LONG lIndex = 0;

    while ((pNode = ci.NextChild()) != NULL)
    {
        if (pNode->Tag() == ETAG_AREA)
        {
            pArea = DYNCAST(CAreaElement, pNode->Element());

            if (pArea == pAreaFind)
            {
                *plIndex = lIndex;
                return S_OK;
            }
        }

        lIndex += 1;
    }

    *plIndex = 0;
    return E_FAIL;
}


//=-----------------------------------------------------------------------=
//
// Function:    GetBoundingRect
//
// Synopsis:    Returns the bounding rectangle for the map, computed as
//              union of the bounding rectangles of the <AREA>s in it.
//
//=-----------------------------------------------------------------------=
void
CMapElement::GetBoundingRect(RECT *prc)
{
    CChildIterator ci(this, NULL, CHILDITERATOR_DEEP);
    CTreeNode * pNode;
    RECT rcArea, rcTemp;

    SetRectEmpty(prc);

    while ((pNode = ci.NextChild()) != NULL)
    {
        if (pNode->Tag() == ETAG_AREA)
        {
            DYNCAST(CAreaElement, pNode->Element())->GetBoundingRect(&rcArea);
            CopyRect(&rcTemp, prc);
            UnionRect(prc, &rcTemp, &rcArea);
        }
    }
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      Drawing Related Code
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

//=------------------------------------------------------------------------=
//
// Function:    Draw
//
// Synopsis:    Refreshes all the areas on the map
//
// Arguments:   HDC hDC - The DC to draw into
//              RECT rc - The rectangle of the image site calling me
//
//=------------------------------------------------------------------------=
HRESULT
CMapElement::Draw(CFormDrawInfo * pDI, CElement * pImg)
{
    CChildIterator  ci(this, NULL, CHILDITERATOR_DEEP);
    CTreeNode *     pNode;
    HPEN            hpenOld;
    HBRUSH          hbrOld;
    int             nROPOld;
    XHDC            hdc = pDI->GetDC(TRUE);
    
    // Should come here only in edit mode
    Assert(pImg && pImg->IsEditable(TRUE));

    nROPOld = SetROP2(hdc, R2_XORPEN);
    hpenOld = (HPEN)SelectObject(hdc, GetStockObject(WHITE_PEN));
    hbrOld  = (HBRUSH)SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
    
    while ((pNode = ci.NextChild()) != NULL)
    {
        if (pNode->Tag() == ETAG_AREA)
        {
            DYNCAST(CAreaElement, pNode->Element())->Draw(pDI, pImg);
        }
    }

    SelectObject(hdc, hpenOld);
    SelectObject(hdc, hbrOld);
    SetROP2(hdc, nROPOld);

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      Area Collection Code
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
HRESULT
CMapElement::EnsureCollectionCache()
{
    HRESULT hr = S_OK;

    if ( ! _pCollectionCache )
    {
        _pCollectionCache =
            new CCollectionCache(
                this,
                GetWindowedMarkupContext(),
                ENSURE_METHOD(CMapElement, EnsureAreaCollection, ensureareacollection),
                CREATECOL_METHOD(CMapElement, CreateAreaCollection, createareacollection),
                NULL,
                ADDNEWOBJECT_METHOD(CMapElement, AddNewArea, addnewarea));

        if (!_pCollectionCache)
            goto MemoryError;

        hr = THR(_pCollectionCache->InitReservedCacheItems(1));
        if (hr)
            goto Cleanup;

    }

    hr = THR(_pCollectionCache->EnsureAry(AREA_ELEMENT_COLLECTION));

Cleanup:
    if (hr && _pCollectionCache)
    {
        delete _pCollectionCache;
        _pCollectionCache = NULL;
    }    
    RRETURN(SetErrorInfo(hr));

MemoryError:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

HRESULT BUGCALL
CMapElement::CreateAreaCollection(IDispatch ** ppIEC, long lIndex)
{
    HRESULT             hr = S_OK;
    CAreasCollection *  pobj;

    pobj = new CAreasCollection(_pCollectionCache, lIndex);
    if (!pobj)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pobj->QueryInterface(IID_IDispatch, (void **) ppIEC));
    pobj->Release();
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

HRESULT BUGCALL
CMapElement::EnsureAreaCollection(long lIndex, long * plCollectionVersion)
{
    CTreeNode *     pNode;
    HRESULT         hr = S_OK;
    CMarkup *       pMarkup = GetMarkup();

    *plCollectionVersion = NULL;

    // Nothing to do so get out.
    if (pMarkup && *plCollectionVersion == pMarkup->GetMarkupTreeVersion())
        return S_OK;

    MtAdd(Mt(BldMapAreasCol), +1, 0);

    // Reset this collection.
    _pCollectionCache->ResetAry(AREA_ELEMENT_COLLECTION);

    if(IsInMarkup())
    {
        CChildIterator  ci(this, NULL, CHILDITERATOR_DEEP);
        while ((pNode = ci.NextChild()) != NULL)
        {
            if (pNode->Tag() == ETAG_AREA)
            {
                hr = THR(_pCollectionCache->SetIntoAry(AREA_ELEMENT_COLLECTION, pNode->Element()));
                if (hr)
                    goto Error;
            }
        }
    }

    if (pMarkup)
        *plCollectionVersion = pMarkup->GetMarkupTreeVersion();

Cleanup:
    RRETURN(hr);

Error:
    _pCollectionCache->ResetAry(AREA_ELEMENT_COLLECTION);
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     AddAreaHelper
//
//  Synopsis:   Add area to collection
//
//-------------------------------------------------------------------------
HRESULT
CMapElement::AddAreaHelper(CAreaElement * pArea, long lItemIndex)
{
    HRESULT         hr;

    if (lItemIndex == -1)
        lItemIndex = GetAreaCount(); // append

    // insert the area into the element tree, with pMap as parent at the
    // position lItemIndex
    hr = THR(pArea->InsertIntoElemTree(this, lItemIndex));
    if (hr)
        goto Cleanup;
        
Cleanup:
    RRETURN (SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     RemoveAreaHelper
//
//  Synopsis:   remove the area at the given index 
//
//-------------------------------------------------------------------------

HRESULT
CMapElement::RemoveAreaHelper(long lItemIndex)
{
    HRESULT         hr;
    CAreaElement *  pArea;
    
    Assert (lItemIndex >= 0);
    
    hr = THR(GetAreaContaining(lItemIndex, &pArea));
    if (hr)
    {
        // Silently ignore out-of-bounds condition
        hr = S_OK;
        goto Cleanup;
    }

    // remove the area from the element tree
    hr = THR(pArea->RemoveFromElemTree());
    if (hr)
        goto Cleanup;
        
Cleanup:
    RRETURN (SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:     CMapElement::AddNewArea
//
// Supports adding area element to the areas collection via
// JScript array access e.g.
// areas [ 7 ] = new Area();
//----------------------------------------------------------------------------

HRESULT BUGCALL
CMapElement::AddNewArea(long lIndex, IDispatch *pObject, long index)
{
    HRESULT             hr = S_OK;
    CAreaElement *      pArea;
    IUnknown *          pUnk;
    long                lDummy;
    CElement *          pElement = NULL;
    long                lAreaCount;

    if (index < -1)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Make sure that pObject is an <AREA> element
    hr = THR(pObject->QueryInterface(IID_IHTMLAreaElement, (void**)&pUnk));
    ReleaseInterface(pUnk);
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    lAreaCount = GetAreaCount();

    if (index == -1)
        index = lAreaCount; // append

    // index is the ordinal position to add/replace
    // If it exists, replace the existing element.
    // If not extend the options array with default elements
    // up to index-1, then add the new element
    // Verify that pObject is an IOptionElement

    if (index < lAreaCount)
    {
        // remove the current element at 'index'
        hr = THR(RemoveAreaHelper(index));
        if (hr)
            goto Cleanup;

        lAreaCount -= 1;
    }
    else
    {
        CDoc *  pDoc = Doc();

        // pad with dummy elements till index - 1

        for (lDummy = index - lAreaCount; lDummy > 0; --lDummy)
        {
            hr = THR(pDoc->CreateElement(ETAG_AREA, &pElement));
            if (hr)
                goto Cleanup;

            pArea = DYNCAST(CAreaElement, pElement);
            // insert the dummy element
            hr = THR(AddAreaHelper(pArea, lDummy));
            if (hr)
                goto Cleanup;
                
            CElement::ClearPtr(&pElement);
           
            lAreaCount += 1;
        }
    }

    // insert the new element at 'index'
    Verify(S_OK == THR(pObject->QueryInterface(CLSID_CElement, (void **)&pArea)));

    // Bail out if the element is already in the tree - #25130
    if (pArea->IsInMarkup())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }


    hr = THR(AddAreaHelper(pArea, index));
    if (hr)
        goto Cleanup;

Cleanup:

    CElement::ClearPtr(&pElement);
        
    RRETURN(hr);
}


HRESULT
CMapElement::get_areas(IHTMLAreasCollection ** ppElemCol)
{
    HRESULT hr;

    if (!ppElemCol)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    hr = EnsureCollectionCache(); // Ensures AREAS
    if(hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->GetDisp(0, (IDispatch**)ppElemCol));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}



///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//          Class CAreasCollection method implementations
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------------
//
//  Member:     s_classdesc
//
//  Synopsis:   class descriptor
//
//-------------------------------------------------------------------------

const CBase::CLASSDESC CAreasCollection::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLAreasCollection,      // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

//+------------------------------------------------------------------------
//
//  Member:     ~CAreasCollection
//
//  Synopsis:   destructor
//
//-------------------------------------------------------------------------

CAreasCollection::~CAreasCollection()
{
    _pCollectionCache->ClearDisp(_lIndex);
}

//+------------------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:   vanilla implementation
//
//-------------------------------------------------------------------------

HRESULT
CAreasCollection::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IHTMLAreasCollection *)this, IUnknown)
        QI_INHERITS((IHTMLAreasCollection *)this, IDispatch)
        QI_INHERITS(this, IDispatchEx)
        QI_TEAROFF(this, IHTMLAreasCollection2, NULL)
        QI_TEAROFF(this, IHTMLAreasCollection3, NULL)

        default:
            if (iid == IID_IHTMLAreasCollection)
                *ppv = (IHTMLAreasCollection *)this;
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *) *ppv)->AddRef();

    return S_OK;
}



//+------------------------------------------------------------------------
//
//  Member:     get_length
//
//  Synopsis:   collection object model, defers to Cache Helper
//
//-------------------------------------------------------------------------

HRESULT
CAreasCollection::get_length(long * plSize)
{
    RRETURN(SetErrorInfo(_pCollectionCache->GetLength(_lIndex, plSize)));
}


//+-------------------------------------------------------------------------
//
//  Method:     CAreasCollection::putt_length
//
//  Synopsis:   Sets length (i.e. the number of entries). Truncates or
//              expands (by padding with dummy elements) the array as needed.
//
//--------------------------------------------------------------------------

HRESULT
CAreasCollection::put_length(long lLengthNew)
{
    HRESULT         hr = S_OK;
    long            l, lLengthOld;
    CAreaElement *  pArea;
    CMapElement *   pMap;
    CElement *      pElement = NULL;

    if (lLengthNew < 0)
    {
        hr =E_INVALIDARG;
        goto Cleanup;
    }

#ifdef WIN16
    // we store it as the original ptr and a DYNCAST just messes
    // things up so cast to void * and then back to what we want.
    pMap = (CMapElement *)(void *)_pCollectionCache->GetBase();
#else
    pMap = DYNCAST(CMapElement, _pCollectionCache->GetBase());
#endif
    if (!pMap)
    {
        hr = E_UNEXPECTED; 
        goto Cleanup;
    }

    lLengthOld = pMap->GetAreaCount();
    
    if (lLengthNew == lLengthOld)
        goto Cleanup;

    if (lLengthNew < lLengthOld)
    {
        // truncate the array
        for (l = lLengthOld-1; l >= lLengthNew; l--)
        {
            hr = THR(pMap->RemoveAreaHelper(l));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        CDoc *  pDoc = pMap->Doc();

        // pad the array
        for (l = lLengthOld; l < lLengthNew; l++)
        {
            hr = THR(pDoc->CreateElement(ETAG_AREA, &pElement));
            if (hr)
                goto Cleanup;

            pArea = DYNCAST(CAreaElement, pElement);
            // insert the dummy element
            hr = THR(pMap->AddAreaHelper(pArea, l));
            if (hr)
                goto Cleanup;

            CElement::ClearPtr(&pElement);
        }
    }
Cleanup:
    CElement::ClearPtr(&pElement);
    
    RRETURN(SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     item
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CAreasCollection::item(VARIANTARG var1, VARIANTARG var2, IDispatch** ppResult)
{
    RRETURN(SetErrorInfo(_pCollectionCache->Item(_lIndex, var1, var2, ppResult)));
}

//+------------------------------------------------------------------------
//
//  Member:     namedItem
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CAreasCollection::namedItem(BSTR bstrName, IDispatch** ppResult)
{
    HRESULT hr;

    if (!bstrName || !*bstrName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    VARIANT var1, var2;

    var1.vt = VT_BSTR;
    var1.bstrVal = bstrName;

    var2.vt = VT_EMPTY;

    hr = THR(_pCollectionCache->Item(_lIndex, var1, var2, ppResult));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+------------------------------------------------------------------------
//
//  Member:     tags
//
//  Synopsis:   collection object model, this always returns a collection
//              and is named based on the tag, and searched based on tagname
//
//-------------------------------------------------------------------------

HRESULT
CAreasCollection::tags(VARIANT var1, IDispatch ** ppdisp)
{
    RRETURN(SetErrorInfo(_pCollectionCache->Tags(_lIndex, var1, ppdisp)));
}


//+------------------------------------------------------------------------
//
//  Member:     urns
//
//  Synopsis:   collection object model, this always returns a collection
//              and is named based on the urn, and searched based on urn
//
//-------------------------------------------------------------------------

HRESULT
CAreasCollection::urns(VARIANT var1, IDispatch ** ppdisp)
{
    RRETURN(SetErrorInfo(_pCollectionCache->Urns(_lIndex, var1, ppdisp)));
}

//+------------------------------------------------------------------------
//
//  Member:     Get_newEnum
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CAreasCollection::get__newEnum(IUnknown ** ppEnum)
{
    RRETURN(SetErrorInfo(_pCollectionCache->GetNewEnum(_lIndex, ppEnum)));
}


//+------------------------------------------------------------------------
//
//  Member:     Add
//
//  Synopsis:   Add item to collection...
//
//-------------------------------------------------------------------------
HRESULT
CAreasCollection::add(IHTMLElement * pIElement, VARIANT varIndex)
{
    HRESULT         hr;
    CMapElement *   pMap;
    CAreaElement *  pArea;
    long            lItemIndex;
    IUnknown *      pUnk = NULL;

    if (!pIElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Make sure this is an AREA element
    hr = THR(pIElement->QueryInterface(IID_IHTMLAreaElement, (void**)&pUnk));
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(pUnk->QueryInterface(CLSID_CElement, (void**)&pArea));
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Bail out if the element is already in the tree - #25130
    if (pArea->IsInMarkup())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

#ifdef WIN16
    // we store it as the original ptr and a DYNCAST just messes
    // things up so cast to void * and then back to what we want.
    pMap = (CMapElement *)(void *)_pCollectionCache->GetBase();
#else
    pMap = DYNCAST(CMapElement, _pCollectionCache->GetBase());
#endif
    if (!pMap)
    {
        hr = E_UNEXPECTED; 
        goto Cleanup;
    }

    hr = THR(VARIANTARGToIndex(&varIndex, &lItemIndex));
    if (hr)
        goto Cleanup;
    
    if (lItemIndex < -1 || lItemIndex > pMap->GetAreaCount())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(pMap->AddAreaHelper(pArea, lItemIndex));
    if (hr)
        goto Cleanup;
        
Cleanup:
    ReleaseInterface(pUnk);
    RRETURN (SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     remove
//
//  Synopsis:   remove the item in the collection at the given index 
//
//-------------------------------------------------------------------------

HRESULT
CAreasCollection::remove(long lItemIndex)
{
    HRESULT         hr;
    CMapElement *   pMap; 

#ifdef WIN16
    // we store it as the original ptr and a DYNCAST just messes
    // things up so cast to void * and then back to what we want.
    pMap = (CMapElement *)(void *)_pCollectionCache->GetBase();
#else
    pMap = DYNCAST(CMapElement, _pCollectionCache->GetBase());
#endif
    if (!pMap)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if (lItemIndex < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(pMap->RemoveAreaHelper(lItemIndex));
        
Cleanup:
    RRETURN (SetErrorInfo(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\epara.cxx ===
//+---------------------------------------------------------------------
//
//   File:      epara.cxx
//
//  Contents:   Para element class
//
//  Classes:    CParaElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EPARA_HXX_
#define X_EPARA_HXX_
#include "epara.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#define _cxx_
#include "para.hdl"

const CElement::CLASSDESC CParaElement::s_classdesc =
{
    {
        &CLSID_HTMLParaElement,             // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLParaElement,              // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLParaElement,       // _apfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CParaElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_P));

    Assert(ppElement);
    *ppElement = new CParaElement(pDoc);
    return *ppElement ? S_OK: E_OUTOFMEMORY;
}

HRESULT
CParaElement::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr;

    hr = super::Save(pStreamWrBuff, fEnd);
    if (hr)
        goto Cleanup;
    
    if (fEnd && pStreamWrBuff->TestFlag(WBF_FORMATTED_PLAINTEXT))
    {
        // Double space in plaintext mode after <P> elements
        hr = pStreamWrBuff->NewLine();
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\estyle.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       estyle.cxx
//
//  Contents:   CStyleElement & related
//
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx" // for CStreamWriteBuf
#endif

#ifndef X_TYPES_H_
#define X_TYPES_H_
#include "types.h" // for s_enumdeschtmlReadyState
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_ESTYLE_HXX_
#define X_ESTYLE_HXX_
#include "estyle.hxx"
#endif

#ifndef X_ELINK_HXX_
#define X_ELINK_HXX_
#include "elink.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#if defined(_M_ALPHA)
#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif
#endif

#define _cxx_
#include "estyle.hdl"

MtDefine(CStyleElement, Elements, "CStyleElement")

const CElement::CLASSDESC CStyleElement::s_classdesc =
{
    {
        &CLSID_HTMLStyleElement,            // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLStyleElement,             // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLStyleElement,      // _apfnTearOff
    NULL                                    // _pAccelsRun
};


HRESULT CStyleElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);

    *ppElement = new CStyleElement(pDoc);
    return *ppElement ? S_OK : E_OUTOFMEMORY;
}

CStyleElement::CStyleElement(CDoc *pDoc)
    : CElement(ETAG_STYLE, pDoc)
{
    _pStyleSheet = NULL;
    _fDirty = FALSE;
    _fParseFinished = TRUE;
    _readyStateStyle = READYSTATE_UNINITIALIZED;
    _fExplicitEndTag = TRUE;
}

HRESULT
CStyleElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLElement2, NULL)
    }

    if (*ppv)
    {
        ((IUnknown *) *ppv)->AddRef();
        RRETURN(S_OK);
    }

    RRETURN(super::PrivateQueryInterface(iid, ppv));
}


void
CStyleElement::Notify(CNotification *pNF)
{
    // call super (important in all cases, including ENTERTREE)
    super::Notify(pNF);

    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_ENTERTREE:
        _fEnterTreeCalled = TRUE;
        if (_fParseFinished)
        {
            // setText can only be called when both this element is in the tree
            // and the parsectx::Finish() has been called.  The reason for this 
            // is that SetText needs to set up the absolute URL path, and any
            // base tags above it might not be in the tree yet either.

            // When a STYLE sheet moves between trees (as in paste or innerHTML etc)
            // I get an exit then an enter - in this case, I don't need to 
            // re-parse the text
            if ( !_pStyleSheet )
                IGNORE_HR(SetText(_cstrText));
            else
            {
                // Insert the existing SS into this Markup
                CMarkup * pMarkup = GetMarkup();
                CStyleSheetArray * pStyleSheets = NULL;

                if (pMarkup)
                {
                    CElement *pHeadElement;
                    int nSSInHead;

                    // Check for the temporary holding SSA
                    if (_pSSATemp && (_pSSATemp == _pStyleSheet->GetSSAContainer()))
                    {
                        _pSSATemp->ReleaseStyleSheet( _pStyleSheet, FALSE );

                        // The Temp SSA's work is now done.
                        _pSSATemp->Free();
                        _pSSATemp->CBase::PrivateRelease();
                        _pSSATemp = NULL;
                    }

                    THR(pMarkup->EnsureStyleSheets());

                    pStyleSheets = pMarkup->GetStyleSheetArray();
     
                    pHeadElement = pMarkup->GetHeadElement();
                    if (pHeadElement)
                    {
                        CChildIterator ci ( pHeadElement );
                        CTreeNode      * pNode;
                        CLinkElement   * pLink;
                        CStyleElement  * pStyle;

                        nSSInHead = 0;

                        while ( (pNode = ci.NextChild()) != NULL )
                        {
                            if ( pNode->Tag() == ETAG_LINK )
                            {
                                pLink = DYNCAST( CLinkElement, pNode->Element() );
                                if ( pLink->_pStyleSheet ) // faster than IsLinkedStyleSheet() and adequate here
                                    ++nSSInHead;
                            }
                            else if ( pNode->Tag() == ETAG_STYLE )
                            {
                                pStyle = DYNCAST( CStyleElement, pNode->Element() );
                                if ( pStyle == this)
                                {
                                    break;
                                }
                                if ( pStyle->_pStyleSheet ) // Not all STYLE elements create a SS.
                                    ++nSSInHead;
                            }
                        }
                    }
                    else
                    {
                        nSSInHead = -1;
                    }                    

                    THR(pStyleSheets->AddStyleSheet(_pStyleSheet, nSSInHead));
    
                    // When exiting the tree the style rules are disable. Reenable them if they were
                    //     not also disabled on the element.
                    if(!GetAAdisabled())
                        IGNORE_HR(_pStyleSheet->ChangeStatus(CS_ENABLERULES, FALSE, NULL) );

                    IGNORE_HR(OnCssChange(/*fStable = */ FALSE, /* fRecomputePeers = */FALSE));

                }
            }
        }
        break;
    case NTYPE_STOP_1:
    case NTYPE_MARKUP_UNLOAD_1:
        // if the directly linked sheet already came down,
        // this will stop any of its imports.
        if (_pStyleSheet)
            _pStyleSheet->StopDownloads(FALSE);  

        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        {
            if (_pStyleSheet)
            {
                CMarkup * pMarkup = GetMarkup();
                CStyleSheetArray * pStyleSheets = NULL;

                if (pMarkup && !(pNF->DataAsDWORD() & EXITTREE_DESTROY))
                    pStyleSheets = pMarkup->GetStyleSheetArray();

                // Tell the top-level stylesheet collection to let go of it's reference
                if (pStyleSheets)
                    pStyleSheets->ReleaseStyleSheet( _pStyleSheet, FALSE );

                _pStyleSheet->StopDownloads(TRUE);

                if ( !(pNF->DataAsDWORD() & EXITTREE_DESTROY) ) 
                    pMarkup->EnsureFormatCacheChange( ELEMCHNG_CLEARCACHES );
            }
            _fEnterTreeCalled = FALSE;
        }
    }
}


void
CStyleElement::Passivate (void)
{
    if (_pStyleSheet)
    {
        // Removed from StyleSheetArray in the ExitTree notification

        // Halt all stylesheet downloading.
        _pStyleSheet->StopDownloads( TRUE );

        // Let go of our reference
        _pStyleSheet->Release();    // this will subrel ourselves
        _pStyleSheet = NULL;
    }

    if (_pSSATemp)
    {
        _pSSATemp->Free();
        _pSSATemp->Release();
        _pSSATemp = NULL;
    }
   
    super::Passivate();
}


//+------------------------------------------------------------------------
//
//  Member:     InvokeExReady
//
//  Synopsis  :this is only here to handle readyState queries, everything
//      else is passed on to the super
//
//+------------------------------------------------------------------------

#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif

STDMETHODIMP
CStyleElement::ContextThunk_InvokeExReady(DISPID dispid,
                             LCID lcid,
                             WORD wFlags,
                             DISPPARAMS *pdispparams,
                             VARIANT *pvarResult,
                             EXCEPINFO *pexcepinfo,
                             IServiceProvider *pSrvProvider)
{
    IUnknown * pUnkContext;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    HRESULT  hr = S_OK;

    hr = THR(ValidateInvoke(pdispparams, pvarResult, pexcepinfo, NULL));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(ReadyStateInvoke(dispid, wFlags, _readyStateFired, pvarResult));
    if (hr == S_FALSE)
    {
        hr = THR_NOTRACE(super::ContextInvokeEx(dispid,
                                         lcid,
                                         wFlags,
                                         pdispparams,
                                         pvarResult,
                                         pexcepinfo,
                                         pSrvProvider,
                                         pUnkContext ? pUnkContext : (IUnknown*)this));
    }

Cleanup:
    RRETURN(hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif

//+---------------------------------------------------------------
//
//  Member : CStyleElement::Save
//
//  Synopsis    :   Standard Save routine
//
//+---------------------------------------------------------------
HRESULT
CStyleElement::Save(CStreamWriteBuff * pStreamWriteBuff, BOOL fEnd)
{
    HRESULT hr = S_OK;
    DWORD   dwOld;

    // No styles for plaintext mode
    if (pStreamWriteBuff->TestFlag(WBF_SAVE_PLAINTEXT))
        return S_OK;

    if (!fEnd)
    {
        hr = THR(pStreamWriteBuff->NewLine());
        if(hr)
            goto Cleanup;
    }

    //
    // Save tagname and attributes.
    //

    hr = THR(super::Save(pStreamWriteBuff, fEnd));
    if (hr)
        goto Cleanup;

    if (fEnd)
    {
        // New line after </STYLE>
        hr = THR(pStreamWriteBuff->NewLine());
        goto Cleanup;
    }

    //
    // Tell the write buffer to just write this string
    // literally, without checking for any entity references.
    //

    dwOld = pStreamWriteBuff->ClearFlags(WBF_ENTITYREF);

    //
    // Tell the stream to now not perform any fancy indenting
    // or such stuff.
    //

    pStreamWriteBuff->BeginPre();

    if ( _fDirty )
    {   // This stylesheet has been touched through the OM, we need to
        // use the internal data to get the contents to persist.
        _cstrText.Free();
        if ( _pStyleSheet )
        {
            hr = _pStyleSheet->GetString( &_cstrText );
            if (hr)
                goto Cleanup;
        }
    }
    hr = THR(pStreamWriteBuff->Write((LPTSTR)_cstrText));
    if (hr)
        goto Cleanup;

    if ( _fDirty )  // Don't leave our string around
        _cstrText.Free();

    pStreamWriteBuff->EndPre();
    pStreamWriteBuff->SetFlags(dwOld);

Cleanup:
    RRETURN(hr);
}

void CStyleElement::SetDirty( void )
{
    _cstrText.Free();
    _fDirty = TRUE;
}

//+---------------------------------------------------------------
//
//  Member:     CStyleElement::SetText
//
//  Synopsis:   Sets the text owned by the style
//
//  TODO: If this is called more than once per lifetime of a
//  style element, we need to fix the CreateNewStyleSheet call
//  so the old CStyleSheet is taken care of etc.  Right now the
//  assumption is that this is never called more than once
//  per lifetime of a style element.
//
//+---------------------------------------------------------------

HRESULT
CStyleElement::SetText(TCHAR *pch)
{
    CCSSParser *pcssp;
    HRESULT hr = S_OK;
    LPCTSTR szType;
    CDoc *  pDoc = Doc();
    CMarkup * pMarkup = GetMarkup();
    CStyleSheetArray *pSSA;
    CStyleSheetCtx  ctxSS;

    szType = GetAAtype();
    if ( szType && StrCmpIC( _T("text/css"), szType ) )
        goto Save_Contents;

    Assert( "Already have a stylesheet on this element!" && !_pStyleSheet );

    SetReadyStateStyle( READYSTATE_LOADING );

    if (pMarkup)
    {
        hr = pMarkup->EnsureStyleSheets();
        if (hr)
            goto Cleanup;

        pSSA = pMarkup->GetStyleSheetArray();
    }
    else
    {
        pSSA = new CStyleSheetArray( NULL, NULL, 0 );
        if (!pSSA || pSSA->_fInvalid )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _pSSATemp = pSSA;
    }

    ctxSS._pParentElement = this;
    hr = THR(pSSA->CreateNewStyleSheet(&ctxSS, &_pStyleSheet));
    if (!SUCCEEDED(hr))
        goto Cleanup;
    Assert(hr == S_FALSE);      // cannot be shared. has to download!
    hr = S_OK;
    
    _pStyleSheet->AddRef(); // since the style elem is hanging onto the stylesheet ptr
                            // Note this results in a subref on us.

    // Setting the disabled status BEFORE adding all the rules (Write()ing to the parser, below)
    // is more efficient, because we don't have to walk the rules list.
    if ( GetAAdisabled() )
    {
        hr = THR( _pStyleSheet->ChangeStatus( 0, FALSE, NULL ) );   // 0 means disable rules
        if (hr)
            goto Save_Contents;
    }

    if(pch && *pch)
    {
        pcssp = new CCSSParser(_pStyleSheet, NULL, IsInMarkup() && GetMarkupPtr()->IsXML(), 
                               IsInMarkup() && GetMarkup()->IsStrictCSS1Document());
        if (!pcssp)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pcssp->Open();
        pcssp->Write(pch, _tcslen(pch));
        pcssp->Close();
        delete pcssp;
        _pStyleSheet->GetSSS()->_fComplete = TRUE;

        // ArtakKa - I think we can remove the IsInMarkup() check and call EnsureFormatCacheChange
        //              whenever we have a pMarkup
        if (IsInPrimaryMarkup())
        {
            // (alexz) we don't need to do OnCssChangeStable here, and it is also unsafe to do so
            // (this is not a stable moment when we can go out to scripts and other external components) 
            IGNORE_HR(pDoc->ForceRelayout());
        }
        else if(pMarkup)
        {
            pMarkup->EnsureFormatCacheChange(ELEMCHNG_CLEARCACHES);
        }

        // _pStyleSheet might be freed by OnCssChange
        if(_pStyleSheet)
            _pStyleSheet->CheckImportStatus();
    }
    else
    {
        _pStyleSheet->GetSSS()->_fComplete = TRUE;
    }

Save_Contents:
    _cstrText.Set(pch);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStyleElement::OnReadyStateChange
//
//----------------------------------------------------------------------------

void
CStyleElement::OnReadyStateChange()
{   // do not call super::OnReadyStateChange here - we handle firing the event ourselves
    SetReadyStateStyle(_readyStateStyle);
}

//+------------------------------------------------------------------------
//
//  Member:     CStyleElement::SetReadyStateStyle
//
//  Synopsis:   Use this to set the ready state;
//              it fires OnReadyStateChange if needed.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CStyleElement::SetReadyStateStyle(long readyStateStyle)
{
    long readyState;

    _readyStateStyle = readyStateStyle;

    readyState = min ((long)_readyStateStyle, super::GetReadyState());

    if ((long)_readyStateFired != readyState)
    {
        _readyStateFired = readyState;

        GWPostMethodCall(this,
            ONCALL_METHOD (CStyleElement, DeferredFireEvent, deferredfireevent),
            (DWORD_PTR) &s_propdescCElementonreadystatechange, FALSE, "CStyleElement::DeferredFireEvent");

        if (_readyStateStyle == READYSTATE_COMPLETE)
        {
            GWPostMethodCall(this,
                ONCALL_METHOD (CStyleElement, DeferredFireEvent, deferredfireevent),
                (DWORD_PTR) &s_propdescCStyleElementonload, FALSE, "CStyleElement::DeferredFireEvent");
        }            
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CStyleElement:get_readyState
//
//+------------------------------------------------------------------------------

HRESULT
CStyleElement::get_readyState(BSTR * p)
{
    HRESULT hr = S_OK;

    if ( !p )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR( s_enumdeschtmlReadyState.StringFromEnum(_readyStateFired, p) );

Cleanup:
    RRETURN( SetErrorInfo(hr) );
}

HRESULT
CStyleElement::get_readyState(VARIANT * pVarRes)
{
    HRESULT hr = S_OK;

    if (!pVarRes)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = get_readyState(&V_BSTR(pVarRes));
    if (!hr)
        V_VT(pVarRes) = VT_BSTR;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     CStyleElement:get_styleSheet
//
//+------------------------------------------------------------------------------

HRESULT
CStyleElement::get_styleSheet(IHTMLStyleSheet** ppHTMLStyleSheet)
{
    HRESULT hr = S_OK;

    if (!ppHTMLStyleSheet)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppHTMLStyleSheet = NULL;

    // We may not have a stylesheet if we've been passivated
    if ( _pStyleSheet )
    {
        hr = _pStyleSheet->QueryInterface(IID_IHTMLStyleSheet,
                                              (void**)ppHTMLStyleSheet);
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange
//
//  Note:       Called after a property has changed to notify derived classes
//              of the change.  All properties (except those managed by the
//              derived class) are consistent before this call.
//
//              Also, fires a property change notification to the site.
//
//-------------------------------------------------------------------------

HRESULT
CStyleElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;

    switch (dispid)
    {
    case DISPID_CElement_disabled:
        // Passing ChangeStatus() 0 means disable rules
        if ( _pStyleSheet )
        {
            hr = THR( _pStyleSheet->ChangeStatus( GetAAdisabled() ? 0 : CS_ENABLERULES, FALSE, NULL ) );
            if ( !( OK( hr ) ) )
                goto Cleanup;

            hr = THR( OnCssChange(/*fStable = */ TRUE, /* fRecomputePeers = */TRUE) );
            if (hr)
                goto Cleanup;
        }
        break;

    case DISPID_CStyleElement_type:
        {
            LPCTSTR szType = GetAAtype();

            if ( szType && StrCmpIC( _T("text/css"), szType ) )
            {
                if ( _pStyleSheet )
                {
                    CMarkup * pMarkup = GetMarkup();
                    CStyleSheetArray * pStyleSheets = NULL;
                    
                    if (pMarkup)
                        pStyleSheets = pMarkup->GetStyleSheetArray();

                    // Halt all stylesheet downloading.
                    _pStyleSheet->StopDownloads( TRUE );

                    // Tell the top-level stylesheet collection to let go of it's reference
                    if (pStyleSheets)
                        pStyleSheets->ReleaseStyleSheet( _pStyleSheet, FALSE );

                    // Let go of our reference
                    _pStyleSheet->Release();    // this will subrel ourselves
                    _pStyleSheet = NULL;

                    // Rerender, since our SS is gone.
                    
                    hr = THR( OnCssChange(/*fStable = */ TRUE, /* fRecomputePeers = */TRUE) );
                    if (hr)
                        goto Cleanup;
                }

            }
            else
            {   // We're the right type - make sure we have a stylesheet attached.
                hr = EnsureStyleSheet();
            }
        }
        break;

    case DISPID_CStyleElement_media:
        if ( _pStyleSheet )
        {
            LPCTSTR pcszMedia;

            if ( NULL == ( pcszMedia = GetAAmedia() ) )
                pcszMedia = _T("all");

            hr = THR( _pStyleSheet->SetMediaType( TranslateMediaTypeString( pcszMedia ), FALSE ) );
            if ( !( OK( hr ) ) )
                goto Cleanup;

            hr = THR( OnCssChange(/*fStable = */ TRUE, /* fRecomputePeers = */TRUE) );
            if (hr)
                goto Cleanup;
        }
        break;
    }

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     CStyleElement:EnsureStyleSheet
//      Makes sure that we have a stylesheet built for this element.  This is
//  only called if we build a style element through a createElement call from
//  the OM, as opposed to a regular parsing pass (which will call SetText, which
//  will create our stylesheet in order automatically).
//      This particular CStyleElement should be living in the HEAD, or this function
//  may not work properly.  Note that from where this function is currently
//  called (the OM's createElement method), this is always true, so we'll throw
//  an assert if it's not true.
//
//+------------------------------------------------------------------------------
HRESULT
CStyleElement::EnsureStyleSheet( void )
{
    HRESULT hr = S_OK;

    if ( !_pStyleSheet )    // We aren't already ref'ing a stylesheet, so we need a new stylesheet object.
    {
        CMarkup *pMarkup = GetMarkup();
        CStyleSheetArray * pStyleSheets;

        if (pMarkup)
        {
            hr = pMarkup->EnsureStyleSheets();
            if ( hr )
                goto Cleanup;

            pStyleSheets = pMarkup->GetStyleSheetArray();
        }
        else
        {
            pStyleSheets = new CStyleSheetArray( NULL, NULL, 0 );
            if (!pStyleSheets || pStyleSheets->_fInvalid )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            // Track the StyleSheetArray in this element because we don't have a Markup
            _pSSATemp = pStyleSheets;
        }
        Assert(pStyleSheets);

        // Figure out where this <style> stylesheet lives (i.e. what should its index in the
        // stylesheet collection be?).

        long nSSInHead;
        CTreeNode *pNode;
        CLinkElement *pLink;
        CStyleElement *pStyle;
        CElement *pHeadElement = pMarkup ? pMarkup->GetHeadElement() : NULL;
        CStyleSheetCtx  ctxSS;

        nSSInHead = 0;
     
        if (pHeadElement)
        {
            CChildIterator ci ( pHeadElement );

            while ( (pNode = ci.NextChild()) != NULL )
            {
                if ( pNode->Tag() == ETAG_LINK )
                {
                    pLink = DYNCAST( CLinkElement, pNode->Element() );
                    if ( pLink->_pStyleSheet ) // faster than IsLinkedStyleSheet() and adequate here
                        ++nSSInHead;
                }
                else if ( pNode->Tag() == ETAG_STYLE )
                {
                    pStyle = DYNCAST( CStyleElement, pNode->Element() );
                    if ( pStyle == this )
                        break;
                    if ( pStyle->_pStyleSheet ) // Not all STYLE elements create a SS.
                        ++nSSInHead;
                }
            }
        }
        else
        {
            // Get the next available ID based on the size of the Style Sheet collection
            nSSInHead = pStyleSheets->Size();
        }

        ctxSS._pParentElement = this;
        hr = pStyleSheets->CreateNewStyleSheet( &ctxSS, &_pStyleSheet, nSSInHead );
        if ( !SUCCEEDED(hr) )
            goto Cleanup;
        Assert(hr = S_FALSE);   // need download...
        hr = S_OK;

        _pStyleSheet->AddRef(); // since the style elem is hanging onto the stylesheet ptr
                                // Note this results in a subref on us.
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CStyleElement::Clone
//
//  Synopsis:   Make a new one just like this one
//
//-------------------------------------------------------------------------

HRESULT
CStyleElement::Clone(CElement **ppElementClone, CDoc *pDoc)
{
    HRESULT hr;

    hr = THR(super::Clone(ppElementClone, pDoc));
    if (hr)
        goto Cleanup;

    if (_cstrText)
    {
        hr = THR(DYNCAST(CStyleElement, *ppElementClone)->SetText(_cstrText));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\ephrase.cxx ===
//+---------------------------------------------------------------------
//
//   File:      ephrase.cxx
//
//  Contents:   Phrase element class
//
//  Classes:    CPhraseElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EPHRASE_HXX_
#define X_EPHRASE_HXX_
#include "ephrase.hxx"
#endif

#ifndef X_EFONT_HXX_
#define X_EFONT_HXX_
#include "efont.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_E1D_HXX_
#define X_E1D_HXX_
#include "e1d.hxx"
#endif

#ifndef X_DISPDEFS_HXX_
#define X_DISPDEFS_HXX_
#include "dispdefs.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "phrase.hdl"

interface IHTMLControlElement;

extern "C" const IID IID_IControl;

MtDefine(CPhraseElement, Elements, "CPhraseElement")
MtDefine(CSpanElement, Elements, "CSpanElement")

const CElement::CLASSDESC CPhraseElement::s_classdesc =
{
    {
        &CLSID_HTMLPhraseElement,           // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLPhraseElement,            // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnIHTMLPhraseElement,       //  _apfnTearOff

    NULL                                    // _pAccelsRun
};

HRESULT
CPhraseElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    HRESULT    hr = S_OK;
    CElement * pElement;

    Assert(pht->Is(ETAG_B)        || pht->Is(ETAG_U)      ||
           pht->Is(ETAG_I)        || pht->Is(ETAG_STRONG) ||
           pht->Is(ETAG_BIG)      || pht->Is(ETAG_SMALL)  ||
           pht->Is(ETAG_BLINK)    || pht->Is(ETAG_TT)     ||
           pht->Is(ETAG_STRIKE)   || pht->Is(ETAG_VAR)    ||
           pht->Is(ETAG_SUP)      || pht->Is(ETAG_SUB)    ||
           pht->Is(ETAG_CITE)     || pht->Is(ETAG_CODE)   ||
           pht->Is(ETAG_KBD)      || pht->Is(ETAG_SAMP)   ||
           pht->Is(ETAG_DFN)      || pht->Is(ETAG_S)      ||
           pht->Is(ETAG_EM)       || pht->Is(ETAG_NOBR)   ||
           pht->Is(ETAG_ACRONYM)  || pht->Is(ETAG_Q)      ||
           pht->Is(ETAG_INS)      || pht->Is(ETAG_DEL)    ||
           pht->Is(ETAG_BDO)	  || pht->Is(ETAG_RUBY)   ||
           pht->Is(ETAG_RT)       || pht->Is(ETAG_RP));

    Assert(ppElement);
    pElement = new CPhraseElement(pht->GetTag(), pDoc);
    if (!pElement)
        goto MemoryError;

    *ppElement = pElement;

Cleanup:
    RRETURN(hr);

MemoryError:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     CPhraseElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CPhraseElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{   
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_TEAROFF(this, IHTMLPhraseElement, NULL)
        QI_HTML_TEAROFF(this, IHTMLPhraseElement2, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


HRESULT
CPhraseElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    pCFI->PrepareCharFormat();

    CCharFormat *pCF = &pCFI->_cf();
    LONG twips;

    switch(Tag())
    {
    case ETAG_I:
    case ETAG_CITE:
    case ETAG_DFN:
    case ETAG_EM:
    case ETAG_VAR:
        pCF->_fItalic = TRUE;
        break;

    case ETAG_U:
    case ETAG_INS:
        pCFI->PrepareFancyFormat();
        pCF->_fUnderline = TRUE;
        pCFI->_ff()._fHasExplicitUnderline = TRUE;
        break;

    case ETAG_SMALL:
    case ETAG_BIG:
        pCF->ChangeHeightRelative( (Tag() == ETAG_BIG) ? 1 : -1 );
        break;

    case ETAG_B:
    case ETAG_STRONG:
        pCF->_fBold = TRUE;
        pCF->_wWeight = 700;
        break;

    case ETAG_S:
    case ETAG_STRIKE:
    case ETAG_DEL:
        pCFI->PrepareFancyFormat();
        pCF->_fStrikeOut = TRUE;
        pCFI->_ff()._fHasExplicitLineThrough = TRUE;
        break;
        

    case ETAG_KBD:
    case ETAG_CODE:
    case ETAG_SAMP:
    case ETAG_TT:
        pCF->_fBumpSizeDown = TRUE;
        {
            CDoc *  pDoc = Doc();
            CMarkup * pMarkup = GetMarkup();
            CODEPAGESETTINGS * pCS = pMarkup->GetCodepageSettings();
            CODEPAGE cp = pMarkup->GetCodePage();

            if (!pCS)
                pCS = pDoc->PrimaryMarkup()->GetCodepageSettings();

            // Thai does not have a fixed pitch font. Leave it as proportional
            if(cp != CP_THAI)
            {
                pCF->_bPitchAndFamily = FIXED_PITCH;
                pCF->SetFaceNameAtom(pCS->latmFixedFontFace);
                if (pCF->NeedAtFont())
                {
                    ApplyAtFontFace(pCF, Doc(), GetMarkup());
                }
            }
            pCF->_bCharSet = pCS->bCharSet;
            pCF->_fNarrow = IsNarrowCharSet(pCS->bCharSet);
        }
        break;

    case ETAG_SUB:
        {
            pCF->_fSubscript = TRUE;
            pCF->_fSubSuperSized = TRUE;

            pCFI->PrepareFancyFormat();
            pCFI->_ff().SetVerticalAlign(styleVerticalAlignSub);
            pCFI->_ff().SetCSSVerticalAlign(TRUE);
            pCFI->_cf()._fNeedsVerticalAlign = TRUE;
        }
        break;

    case ETAG_SUP:
        {
            pCF->_fSuperscript = TRUE;
            pCF->_fSubSuperSized = TRUE;

            pCFI->PrepareFancyFormat();
            pCFI->_ff().SetVerticalAlign(styleVerticalAlignSuper);
            pCFI->_ff().SetCSSVerticalAlign(TRUE);
            pCFI->_cf()._fNeedsVerticalAlign = TRUE;
        }
        break;

    case ETAG_NOBR:
        pCFI->_fNoBreak = TRUE;
        break;

    case ETAG_RUBY:
        pCF->_fIsRuby = TRUE;
        break;

    case ETAG_RT:
        if(pCF->_fIsRuby) 
        {
            pCF->_fIsRubyText = TRUE;
            twips = pCF->GetHeightInTwips( Doc() );
            pCF->SetHeightInTwips( twips / 2 );
        }
        break;

    case ETAG_BDO:
        pCFI->_fBidiEmbed = TRUE;
        pCFI->_fBidiOverride = TRUE;
        break;

    case ETAG_RP:
        if(pCF->_fIsRuby) 
        {
            pCF->_fDisplayNone = TRUE;
            if( !pCF->_fIsRubyText )
            {
                pCF->_fIsRubyText = TRUE;
                twips = pCF->GetHeightInTwips( Doc() );
                pCF->SetHeightInTwips( twips / 2 );
            }
        }
        break;
    }
    
    pCFI->UnprepareForDebug();

    RRETURN(super::ApplyDefaultFormat(pCFI));
}

const CElement::CLASSDESC CSpanElement::s_classdesc =
{
    {
        &CLSID_HTMLSpanElement,             // _pclsid
        0,                                  // _idrBase
        s_apclsidPages,                     // _apClsidPages
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLSpanElement,              // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnIHTMLSpanElement,         // _apfnTearOff

    NULL                                    // _pAccelsRun
};

HRESULT
CSpanElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_SPAN));
    Assert(ppElement);
    *ppElement = new CSpanElement(ETAG_SPAN, pDoc);
    return *ppElement ? S_OK : E_OUTOFMEMORY;
}

#ifndef NO_DATABINDING
#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

const CDBindMethods *
CSpanElement::GetDBindMethods()
{
    return &DBindMethodsTextRichRO;
}


//+----------------------------------------------------------------------------
//
//  Member:     CSpanElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-----------------------------------------------------------------------------

HRESULT
CSpanElement::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    HRESULT hr;

    *ppv = NULL;

    // IE4 shipped the interface IHTMLControlElement with the same GUID as
    // IControl.  Unfortunately, IControl is a forms^3 interface, which is bad.
    // To resolve this problem Trident's GUID for IHTMLControlElement has
    // changed however, the old GUID remembered in the QI for CSite to return
    // IHTMLControlElement.  The only side affect is that using the old GUID
    // will not marshall the interface correctly only the new GUID has the
    // correct marshalling code.  So, the solution is that QI'ing for
    // IID_IControl or IID_IHTMLControlElement will return IHTMLControlElement.

    // For VB page designer we need to emulate IE4 behavior (fail the QI if not a site)
    if(iid == IID_IControl && Doc()->_fVB && !ShouldHaveLayout())
        RRETURN(E_NOINTERFACE);

    if (iid == IID_IHTMLControlElement || iid == IID_IControl)
    {

        hr = CreateTearOffThunk(this,
                                s_apfnpdIHTMLControlElement,
                                NULL,
                                ppv,
                                (void *)s_ppropdescsInVtblOrderIHTMLControlElement);
        if (hr)
            RRETURN(hr);
    }
    else
    {
        RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\eulist.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eulist.cxx
//
//  Contents:   Ordered List Element class
//
//  Classes:    CUListElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EULIST_HXX_
#define X_EULIST_HXX_
#include "eulist.hxx"
#endif

#define _cxx_
#include "ulist.hdl"

const CElement::CLASSDESC CUListElement::s_classdesc =
{
    {
        &CLSID_HTMLUListElement,            // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLUListElement,             // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLUListElement,      // _apfnTearOff
    NULL                                    // _pAccelsRun
};


//+------------------------------------------------------------------------
//
//  Member:     CUListElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CUListElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if IID_HTML_TEAROFF(this, IHTMLUListElement, NULL)
    else
    {
        RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    (*(IUnknown **)ppv)->AddRef();
    return S_OK;
}


HRESULT CUListElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(pht->Is(ETAG_UL) || pht->Is(ETAG_MENU) || pht->Is(ETAG_DIR));
    Assert(ppElementResult);
    *ppElementResult = new CUListElement(pht->GetTag(), pDoc);
    return *ppElementResult ? S_OK : E_OUTOFMEMORY;
}

HRESULT
CUListElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr;

    hr = super::ApplyDefaultFormat(pCFI);
    if (hr)
        goto Cleanup;

    pCFI->PrepareParaFormat();
    pCFI->_pf()._cListing.SetStyle(FilterHtmlListType(pCFI->_ppf->GetListStyleType(), 
                                   (WORD)pCFI->_pf()._cListing.GetLevel()));
    pCFI->UnprepareForDebug();

Cleanup:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:     FilterHtmlListType()
//
//  Returns:    Return the perferred htmlListType for unordered lists.
//
//------------------------------------------------------------------------

styleListStyleType
CUListElement::FilterHtmlListType(  styleListStyleType type, WORD wLevel )
{
    return ( styleListStyleTypeNotSet != type ? type :
            ((wLevel == 1) ? styleListStyleTypeDisc :
             (wLevel == 2) ? styleListStyleTypeCircle : styleListStyleTypeSquare) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\mmplay.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MMPLAY_HXX_
#define X_MMPLAY_HXX_
#include "mmplay.hxx"
#endif

#ifndef X_STRMIF_H_
#define X_STRMIF_H_
#include <strmif.h>
#endif

#ifndef X_CONTROL_H_
#define X_CONTROL_H_
#include <control.h>
#endif

#ifndef X_EVCODE_H_
#define X_EVCODE_H_
#include "evcode.h"
#endif

#ifndef X_UUIDS_H_
#define X_UUIDS_H_
#include <uuids.h>
#endif

#ifdef WIN16
#ifndef X_MMSYSTEM_H_
#define X_MMSYSTEM_H_
#include <mmsystem.h>
#endif

WORD MapFileToDeviceType(LPCTSTR);
#endif

#define DEFAULT_VIDEOWIDTH 32
#define DEFAULT_VIDEOHEIGHT 32

MtDefine(CIEMediaPlayer, Dwn, "CIEMediaPlayer")
MtDefine(CIEMediaPlayerUrl, CIEMediaPlayer, "CIEMediaPlayer::_pchUrl")

// ======================================================================
//
// ======================================================================
CIEMediaPlayer::CIEMediaPlayer()
{
    _ulRefs = 1;        // born with 1
    _fState = IEMM_Uninitialized;
#ifdef WIN16
    _wMCIDeviceID = -1;
#else
    _pGraph = NULL;
#endif
    _pchURL = NULL;
    _hwndOwner = NULL;
    _fHasAudio = FALSE;
    _fHasVideo = FALSE;

    _fDataDownloaded = FALSE;
    _fRestoreVolume = FALSE;
    _lLoopCount = 1;
    _lPlaysDone = 0;
    _lOriginalVol = 1000;       // init it out of range 
    _lOriginalBal = -100000;    // ditto

    _xWidth = DEFAULT_VIDEOWIDTH; 
    _yHeight = DEFAULT_VIDEOHEIGHT;
}


// ======================================================================
//
// ======================================================================
CIEMediaPlayer::~CIEMediaPlayer()
{
    if(_fRestoreVolume)
    {
        SetVolume(_lOriginalVol);
        SetBalance(_lOriginalBal);
        Stop();
    }

    DeleteContents();
}
#if !defined(WINCE) && !defined(NO_MEDIA_PLAYER)
// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::QueryInterface (REFIID riid, LPVOID * ppv)
{ 
    if (riid == IID_IUnknown)
    {
        *ppv = (IUnknown *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


// ======================================================================
//
// ======================================================================
void CIEMediaPlayer::DeleteContents( void )
{
#ifdef WIN16
    mciSendCommand(_wMCIDeviceID, MCI_CLOSE, 0, 0);
#else
    if (_pGraph) 
    {
        if (_hwndOwner)
        {
            HRESULT hr;
            IVideoWindow * pVW = NULL;
            hr = _pGraph->QueryInterface(IID_IVideoWindow, (void **) &pVW);
            if (OK(hr))
            {
                pVW->put_MessageDrain((OAHWND) NULL);
                pVW->Release();
                _hwndOwner = NULL;
            }
        }
        _pGraph->Release();
        _pGraph = NULL;
    }
#endif // ndef WIN16

    if(_pchURL)
    {
        MemFreeString(_pchURL);
        _pchURL = NULL;
    }

    _fState = IEMM_Uninitialized;
}

    
// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::Initialize(void) 
{
    HRESULT hr; // return code

#ifndef WIN16
    if(_pGraph)         // already initialized
    {
        _pGraph->Release(); // go away
        _pGraph = NULL;
    }


    hr = CoCreateInstance(CLSID_FilterGraph,    // get this documents graph object
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IGraphBuilder,
                          (void **) &_pGraph);

    if (FAILED(hr)) 
    {
        DeleteContents();
        return hr;
    }
#endif // ndef WIN16

    _fState = IEMM_Initialized;
    return S_OK;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetURL(const TCHAR  *pchURL)
{
    HRESULT hr = S_OK, hr2 = S_OK;
    IVideoWindow * pVW;

    if(!pchURL)
        return ERROR_INVALID_PARAMETER;

    MemReplaceString(Mt(CIEMediaPlayerUrl), pchURL, &_pchURL);
    
#ifdef WIN16
    mciSendCommand(_wMCIDeviceID, MCI_CLOSE, 0, 0);
#else
    if(_pGraph)
        Stop();     // We already have a graph built so call stop in case it's running
#endif // ndef WIN16

#if 1   // TODO: Davidna:     Do this until AMovie implements ReleaseAllFilters()
    hr = Initialize();       // This will release the Graph and CoCreateInstance() a new one.
#else
    hr = _pGraph->ReleaseAllFilters();       // Someday...
#endif

    if (FAILED(hr))
        goto Failed;

    _fDataDownloaded = TRUE;    // we we're passed in a valid URL

#ifdef WIN16
    MCI_OPEN_PARMS mciOpenParms;

    /*
     * Open the device by specifying the
     * device name and device element.
     * MCI will attempt to choose the
     * MIDI Mapper as the output port.
     */
    //mciOpenParms.lpstrDeviceType = (LPSTR)(LONG)MapFileToDeviceType(pchURL);
    mciOpenParms.lpstrElementName = _pchURL;
    if (hr = (HRESULT) mciSendCommand(NULL, MCI_OPEN,
            /*MCI_OPEN_TYPE |  */ MCI_OPEN_ELEMENT,
            (DWORD)(LPVOID) &mciOpenParms)) {
        
         /*
         * Failed to open device;
         * don't close it, just return error.
         */
        _fState = IEMM_Aborted;
        goto Failed;
    }
    else
    {
        _fState = IEMM_Stopped;
    }

    _wMCIDeviceID = mciOpenParms.wDeviceID;
#else
    // Build the graph.
    //
    // This won't return until the the file type is sniffed and the appropriate
    // graph is built
    //
    hr = _pGraph->RenderFile(_pchURL, NULL);
    if(SUCCEEDED(hr))
    {
        _fState = IEMM_Stopped;
    }
    else
    {
        _fState = IEMM_Aborted;
        goto Failed;
    }

    // Need to check to see if there's a Video renderer interface and
    // shut it off if it's there. Our default state is to show no window until
    // someone sets our window position
    //
    // For BGSound this allows video files to be used without having a video window
    //  pop up on us.
    // For DYNSRC a video window size will be set at which point we'll 
    //  turn the thing on again.
    
    hr = _pGraph->QueryInterface(IID_IVideoWindow, (void **) &pVW);
    if(OK(hr)) 
    {
        long lVisible;

        // if this fails then we have an audio only stream
        hr2 = pVW->get_Visible(&lVisible);  
        if(hr2 == S_OK)
        {
            SIZE size;
            GetSize(&size);             // this will get the size of the video source
                                        // and cache the results for later

            hr2 = pVW->put_AutoShow(0);  // turn off the auto show of the video window
            _fHasVideo = TRUE;
        }
        else
        {
            _xWidth = 0;
            _yHeight = 0;
        }
        pVW->Release();
    }

    _fUseSegments = FALSE;

    IMediaSeeking *pIMediaSeeking;
    hr = _pGraph->QueryInterface(IID_IMediaSeeking, (void **) &pIMediaSeeking);
    if( SUCCEEDED(hr))
    {
        // See if Segment seeking is supported (for Seamless looping)
        if (pIMediaSeeking)
        {
            DWORD dwCaps = AM_SEEKING_CanDoSegments;
            _fUseSegments =
                (S_OK == pIMediaSeeking->CheckCapabilities(&dwCaps));
        } 
        pIMediaSeeking->Release();
    }

    IBasicAudio *pIBa;
    long lOriginalVolume, lOriginalBalance;

    lOriginalVolume = lOriginalBalance = 0;

    hr = _pGraph->QueryInterface(IID_IBasicAudio, (void **) &pIBa);
    if( SUCCEEDED(hr))
    {
        hr2 = pIBa->get_Volume(&lOriginalVolume);
        if(hr2 == S_OK)
        {
            _fHasAudio = TRUE;
            pIBa->get_Balance(&lOriginalBalance);
        }
        pIBa->Release();
    }

    // save away the original volume so that we can restore it on our way out
    if(_fHasAudio && _lOriginalVol > 0)
    {
        _lOriginalBal = lOriginalBalance;
        _lOriginalVol = lOriginalVolume;
    }

#endif // ndef WIN16

Failed:
    return hr;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetVideoWindow(HWND hwnd)
{
    IVideoWindow * pVW = NULL;
    HRESULT        hr  = S_OK;

    if(!_fHasVideo)
        return S_FALSE;

#ifndef WIN16
    if(!_pGraph)
        return E_FAIL;

    if (hwnd)
    {
        _hwndOwner = hwnd;

        hr = _pGraph->QueryInterface(IID_IVideoWindow, (void **) &pVW);
        if (FAILED(hr))
            goto Cleanup;

        hr = pVW->put_Owner((OAHWND) hwnd);
        if (FAILED(hr))
            goto Cleanup;

        hr = pVW->put_MessageDrain((OAHWND) hwnd);
        if (FAILED(hr))
            goto Cleanup;

        hr = pVW->put_WindowStyle(WS_CHILDWINDOW);
        if (FAILED(hr))
            goto Cleanup;

        hr = pVW->put_BackgroundPalette(-1); // OATRUE
        if (FAILED(hr))
            goto Cleanup;
    }
#endif // ndef WIN16

Cleanup:
    if (pVW)
        pVW->Release();

    RRETURN(hr);
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetWindowPosition(RECT *prc)
{
    HRESULT hr;
    IVideoWindow * pVW = NULL;

    Assert(prc);

    if (!_fHasVideo)
        return S_FALSE;

#ifndef WIN16
    if (!_pGraph)
        return E_FAIL;

    hr = _pGraph->QueryInterface(IID_IVideoWindow, (void **) &pVW);
    if (FAILED(hr))
        goto Cleanup;

    hr = pVW->SetWindowPosition(prc->left,
                                prc->top,
                                prc->right - prc->left,
                                prc->bottom - prc->top);
#endif // ndef WIN16

Cleanup:
    if (pVW)
        pVW->Release();

    RRETURN(hr);

}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetVisible(BOOL fVisible)
{
    HRESULT hr;
    IVideoWindow * pVW = NULL;

    if(!_fHasVideo)
        return S_FALSE;

#ifndef WIN16
    if(!_pGraph)
        return E_FAIL;

    hr = _pGraph->QueryInterface(IID_IVideoWindow, (void **) &pVW);
    if (OK(hr))
    {
        if(fVisible)
            hr = pVW->put_Visible(-1);  // OATRUE
        else 
            hr = pVW->put_Visible(0);   // OAFALSE
    }

    if (pVW)
        pVW->Release();
#endif // ndef WIN16

    return hr;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::GetSize(SIZE *psize)
{
#ifdef WIN16
    psize->cx = psize->cy = 0;
    return S_OK;
#else
    long    lWidth = 0;
    long    lHeight = 0;
    HRESULT hr = S_OK;
    IBasicVideo * pBV = NULL;

    if(!_pGraph)
        return E_FAIL;

    if(_xWidth == DEFAULT_VIDEOWIDTH && _yHeight == DEFAULT_VIDEOHEIGHT)
    {
        hr = _pGraph->QueryInterface(IID_IBasicVideo, (void **) &pBV);

        if (OK(hr))
            hr = pBV->get_SourceWidth(&lWidth);

        if (OK(hr))
            hr = pBV->get_SourceHeight(&lHeight);
        
        if (OK(hr))
        {
            _xWidth = lWidth;
            _yHeight = lHeight;
        }
    }

    psize->cx = _xWidth;
    psize->cy = _yHeight;

    if (pBV)
        pBV->Release();

    return hr;
#endif
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetNotifyWindow(HWND hwnd, long lmsg, long lParam)
{
#ifdef WIN16
    return E_FAIL;
#else
    HRESULT hr = S_OK;
    IMediaEventEx *pMvEx = NULL;

    if(!_pGraph)
        return E_FAIL;

    hr = _pGraph->QueryInterface(IID_IMediaEventEx, (void **) &pMvEx);
    if (FAILED(hr))
        goto Failed;

    hr = pMvEx->SetNotifyWindow((OAHWND) hwnd, lmsg, lParam);
    
    pMvEx->Release();

Failed:
    return hr;
#endif
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetLoopCount(long uLoopCount)
{
    _lLoopCount = uLoopCount;
    _lPlaysDone = 0;
    return S_OK;
}

// ======================================================================
//
// ======================================================================
long CIEMediaPlayer::GetVolume(void)
{
#ifdef WIN16
    return E_FAIL;
#else
    HRESULT hr;
    IBasicAudio *pIBa;
    long lTheVolume=E_FAIL;

    if(_pGraph)
    {
        hr = _pGraph->QueryInterface(IID_IBasicAudio, (void **) &pIBa);
        if( SUCCEEDED(hr) && pIBa)
        {
            hr = pIBa->get_Volume(&lTheVolume);
            pIBa->Release();
        }
    }
    return lTheVolume;
#endif
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetVolume(long lVol)
{
#ifdef WIN16
    return E_FAIL;
#else
    HRESULT hr = S_OK;

    IBasicAudio *pIBa;

    if(lVol < -10000 && lVol > 0)
        return ERROR_INVALID_PARAMETER;

    if(!_pGraph)
        return E_FAIL;

    hr = _pGraph->QueryInterface(IID_IBasicAudio, (void **) &pIBa);
    if( SUCCEEDED(hr) && pIBa)
    {
        hr = pIBa->put_Volume(lVol);
        pIBa->Release();
    }
    _fRestoreVolume = TRUE;

    return hr;
#endif // ndef WIN16
}

// ======================================================================
//
// ======================================================================
long CIEMediaPlayer::GetBalance(void)
{
#ifdef WIN16
    return E_FAIL;
#else
    HRESULT hr;

    IBasicAudio *pIBa;
    long lTheBal=E_FAIL;

    if(_pGraph)
    {
        hr = _pGraph->QueryInterface(IID_IBasicAudio, (void **) &pIBa);
        if( SUCCEEDED(hr) && pIBa)
        {
            hr = pIBa->get_Balance(&lTheBal);
            pIBa->Release();
        }
    }

    return lTheBal;
#endif // ndef WIN16
}   
// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetBalance(long lBal)
{
#ifdef WIN16
    return E_FAIL;
#else
    HRESULT hr = S_OK;

    IBasicAudio *pIBa;

    if(lBal < -10000 && lBal > 10000)
        return ERROR_INVALID_PARAMETER;

    if(!_pGraph)
        return E_FAIL;

    hr = _pGraph->QueryInterface(IID_IBasicAudio, (void **) &pIBa);
    if( SUCCEEDED(hr) && pIBa)
    {
        hr = pIBa->put_Balance(lBal);
        pIBa->Release();
    }

    _fRestoreVolume = TRUE;

    return hr;
#endif // ndef WIN16
}

// ======================================================================
//
// ======================================================================
int CIEMediaPlayer::GetStatus(void)
{
    return _fState;
}


// ======================================================================
//
// CIEMediaPlayer commands
// ======================================================================
//
HRESULT CIEMediaPlayer::Play()
{
    HRESULT hr = S_OK;

    if (CanPlay())
    {
#ifdef WIN16
        MCI_PLAY_PARMS mciPlayParms = { 0,0,0};
        /*
        * Begin playback. The window procedure function
        * for the parent window is notified with an
        * MM_MCINOTIFY message when playback is complete.
        * The window procedure then closes the device.
        */
        if (hr = mciSendCommand(_wMCIDeviceID, MCI_PLAY,
            0, (DWORD)(LPVOID) &mciPlayParms)) {
            mciSendCommand(_wMCIDeviceID, MCI_CLOSE, 0, 0);
            return hr;
        }
#else
        IMediaControl *pMC = NULL;

        // Obtain the interface to our filter graph
        //
        hr = _pGraph->QueryInterface(IID_IMediaControl, (void **) &pMC);
        if (SUCCEEDED(hr) && pMC)
        {
            if (_fUseSegments)
            {
                // If we're using seamless looping, we need to 1st set seeking flags
                Seek(0);
            }

            // Ask the filter graph to play 
            hr = pMC->Run();

            if (SUCCEEDED(hr))
            {
                _fState = IEMM_Playing;
                if (_lLoopCount > 0)
                    _lPlaysDone++;
            }
            else
            {
                pMC->Stop();    // some filters in the graph may have started
                                // so we better stop them
            }
            pMC->Release();
        }
        else
            hr = S_FALSE;
#endif
    }

    RRETURN1(hr, S_FALSE);
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::Pause()
{
    HRESULT hr = S_OK;

    if( CanPause() )
    {
#ifdef WIN16
		// we are not too sophisticated, we just stop & start it.
		mciSendCommand(_wMCIDeviceID, MCI_CLOSE, 0, 0);
#else
        IMediaControl *pMC;
        // Obtain the interface to our filter graph
        hr = _pGraph->QueryInterface(IID_IMediaControl, (void **) &pMC);

        // Ask the filter graph to pause
        if( SUCCEEDED(hr ) )
            pMC->Pause();
        
        pMC->Release();

        _fState = IEMM_Paused;
#endif
    }
    else
        hr = S_FALSE;

    RRETURN1(hr, S_FALSE);
}

// ======================================================================
// 
//  Stop playback if it's active
//
// ======================================================================
HRESULT CIEMediaPlayer::Abort()
{
    // Must stop play first.
    //
    Stop();

    _fState = IEMM_Aborted;

    return S_OK;   // must not fail
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::Seek(ULONG uPosition)
{
#ifdef WIN16
    Assert(0);
    return S_FALSE;
#else
    HRESULT hr = S_OK;

    IMediaSeeking *pIMediaSeeking=NULL;
    if(_pGraph)
        hr = _pGraph->QueryInterface(IID_IMediaSeeking, (void **) &pIMediaSeeking);

    if( SUCCEEDED(hr) && pIMediaSeeking)
    {
        LONGLONG llStop;

        hr = pIMediaSeeking->GetPositions(NULL, &llStop);
        if (SUCCEEDED(hr) && (llStop > uPosition))
        {
            long lSegmentSeek = 0L;
            LONGLONG llPosition = (LONGLONG) uPosition;

            SetSegmentSeekFlags(&lSegmentSeek); // in case we're seamless looping
            hr = pIMediaSeeking->SetPositions( &llPosition
                                              , AM_SEEKING_AbsolutePositioning | lSegmentSeek
                                              , &llStop
                                              , AM_SEEKING_NoPositioning );
        }
        pIMediaSeeking->Release();
    }

    RRETURN1(hr, S_FALSE);
#endif // ndef WIN16
}

// ======================================================================
//
// ======================================================================
void CIEMediaPlayer::SetSegmentSeekFlags(LONG *plSegmentSeek)
{
#ifdef WIN16
    Assert(0);
#else
    if (plSegmentSeek)
    {
        *plSegmentSeek = 
            _fUseSegments && _lLoopCount != 1 ?
    	        ((_lLoopCount == -1) ||
	             (_lLoopCount > _lPlaysDone + 1) ? AM_SEEKING_NoFlush |
		        	  AM_SEEKING_Segment 
	            	: AM_SEEKING_NoFlush
                ) :  0L;
    }
#endif // ndef WIN16
}


// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::Stop()
{
    HRESULT hr = S_OK;

    if( CanStop() )
    {
#ifdef WIN16
        mciSendCommand(_wMCIDeviceID, MCI_CLOSE, 0, 0);
        Assert(0);
#else
        IMediaControl *pMC;

        // Obtain the interface to our filter graph
        hr = _pGraph->QueryInterface(IID_IMediaControl, (void **) &pMC);
        if( SUCCEEDED(hr) )
        {
            // Stop the filter graph
            hr = pMC->Stop();
            // Release the interface
            pMC->Release();

            // set the flags
            _fState = IEMM_Stopped;
        }
#endif
    }
    else
        hr = S_FALSE;

    RRETURN1(hr, S_FALSE);
}

//
// ======================================================================
//
// If the event handle is valid, ask the graph
// if anything has happened. eg the graph has stopped...
// ======================================================================
HRESULT CIEMediaPlayer::NotifyEvent(void) 
{
#ifdef WIN16
	Assert(0);
    return E_FAIL;
#else
    HRESULT hr = S_OK;
    long lEventCode;
    LONG_PTR lParam1, lParam2;
    IMediaEvent *pME = NULL;

    if(!_pGraph)
        return E_FAIL;

    hr = _pGraph->QueryInterface(IID_IMediaEvent, (void **) &pME); 
    if( FAILED(hr) )
        goto GN_Failed;

    hr = pME->GetEvent(&lEventCode, &lParam1, &lParam2, 0);
    if( FAILED(hr) )
        goto GN_Failed;

    if (lEventCode == EC_COMPLETE || lEventCode == EC_END_OF_SEGMENT)
    {
        // Do we need to loop?
        //
        if(_lLoopCount == -1 || _lLoopCount > _lPlaysDone )
        {
            Seek(0);        // we're still playing so seek back to the begining
                            // and we'll keep going
            if(_lLoopCount >0)
                _lPlaysDone++;
        }
        else    
        {
            // we're done stop the graph
            Stop();
            _fState = IEMM_Completed;
        }

    } else if ((lEventCode == EC_ERRORABORT) || (lEventCode == EC_USERABORT)      ) 
    {
        Stop();
    }

GN_Failed:
    if(pME) pME->Release();

    RRETURN1(hr, S_FALSE);
#endif
}

#else // !WINCE && !NO_MEDIA_PLAYER

// Just stub these methods out for GALAHAD / UNIX

// ======================================================================
//
// ======================================================================
void CIEMediaPlayer::DeleteContents( void )
{
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::QueryInterface (REFIID riid, LPVOID * ppv)
{ 
    *ppv = NULL;
    return E_NOINTERFACE;
}
    
// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::Initialize(void) 
{
    return E_FAIL;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetURL(const TCHAR  *pchURL)
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetVideoWindow(HWND hwnd)
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetWindowPosition(RECT *prc)
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetVisible(BOOL fVisible)
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::GetSize(SIZE *psize)
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetNotifyWindow(HWND hwnd, long lmsg, long lParam)
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetLoopCount(long uLoopCount)
{
    return E_FAIL;
}

// ======================================================================
//
// ======================================================================
long CIEMediaPlayer::GetVolume(void)
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetVolume(long lVol)
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
long CIEMediaPlayer::GetBalance(void)
{
	return E_FAIL;
}
// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetBalance(long lBal)
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
int CIEMediaPlayer::GetStatus(void)
{
    return _fState;
}


// ======================================================================
//
// CIEMediaPlayer commands
// ======================================================================
//
HRESULT CIEMediaPlayer::Play()
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::Pause()
{
	return E_FAIL;
}

// ======================================================================
// 
//  Stop playback if it's active
//
// ======================================================================
HRESULT CIEMediaPlayer::Abort()
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::Seek(ULONG uPosition)
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::Stop()
{
	return E_FAIL;
}

//
// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::NotifyEvent(void) 
{
	return E_FAIL;
}

#endif // WINCE && NO_MEDIA_PLAYER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\escript.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       escript.cxx
//
//  Contents:   CScriptElement, CScriptParser
//
//  History:    15-Jul-1996     AnandRa     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ESCRIPT_HXX_
#define X_ESCRIPT_HXX_
#include "escript.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_ACTIVSCP_H_
#define X_ACTIVSCP_H_
#include <activscp.h>
#endif

#ifndef X_SHOLDER_HXX_
#define X_SHOLDER_HXX_
#include "sholder.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_HTC_HXX_
#define X_HTC_HXX_
#include "htc.hxx"
#endif

#ifndef X_MARKUPCTX_HXX_
#define X_MARKUPCTX_HXX_
#include "markupctx.hxx"
#endif

#ifndef X_DEBUGGER_HXX_
#define X_DEBUGGER_HXX_
#include "debugger.hxx"
#endif

#ifndef X_DMEMBMGR_HXX_
#define X_DMEMBMGR_HXX_
#include <dmembmgr.hxx>       // for CDataMemberMgr
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include <intl.hxx>
#endif

#define _cxx_
#include "script.hdl"

extern BOOL IsSpecialUrl(LPCTSTR pszURL);
extern MIMEINFO *  GetMimeInfoFromData(void * pb, ULONG cb, const TCHAR *pchProposed, CStr * pcstrMimeType);

#ifndef NO_SCRIPT_DEBUGGER
extern interface IProcessDebugManager * g_pPDM;
extern interface IDebugApplication *g_pDebugApp;
#endif // ndef NO_SCRIPT_DEBUGGER

MtDefine(CScriptElement, Elements, "CScriptElement")
MtDefine(CScriptElement_pchSrcCode, CScriptElement, "CScriptElement::_pchSrcCode")
MtDefine(CScriptElementOnDwnChan_pbBuffer, Locals, "CScriptElement::OnDwnChan pbBuffer")
MtDefine(TokenizeEventDescription_ppchEventName, Utilities, "TokenizeEventDescription *ppchEventName")
MtDefine(TokenizeEventDescription_ppchFormalParams, Utilities, "TokenizeEventDescription *ppchFormalParams")

const CElement::CLASSDESC CScriptElement::s_classdesc =
{
    {
        &CLSID_HTMLScriptElement,       // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NOLAYOUT,           // _dwFlags
        &IID_IHTMLScriptElement,        // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLScriptElement, // _apfnTearOff
    NULL                                // _pAccelsRun
};

DeclareTag(tagHtmSrcTest, "Dwn", "! Test Unicode Source Access")

//+------------------------------------------------------------------------
//
//  Member:     CScriptElement::CreateElement
//
//  Synopsis:   standard element creator
//
//  Arguments:  pht             Info about the tag
//              pElementParent  The parent element of the script
//              ppElement       Ptr to returned element
//
//-------------------------------------------------------------------------

HRESULT 
CScriptElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    HRESULT         hr = S_OK;
    CScriptElement *pElement;

    Assert(ppElement);

    pElement = new CScriptElement(pht, pDoc);
    if (!pElement)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    *ppElement = pElement;
    pElement = NULL;
   
Cleanup:

    delete pElement;
    
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CScriptElement::CScriptElement
//
//-------------------------------------------------------------------------

CScriptElement::CScriptElement (CHtmTag *pht, CDoc *pDoc) 
     : CElement(pht->GetTag(), pDoc)
{
    _ulScriptOffset = pht->GetOffset();
    _ulScriptLine = pht->GetLine();

    _dwScriptCookie = NO_SOURCE_CONTEXT;

    Assert (!_fCodeConstructed);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptElement::PrivateQueryInterface, per IPrivateUnknown
//
//-------------------------------------------------------------------------

HRESULT
CScriptElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLElement2, NULL)
        QI_HTML_TEAROFF(this, IHTMLScriptElement2, NULL)

    default:
        if (iid == CLSID_HTMLScriptElement)
        {
            *ppv = this;    // weak ref
            return S_OK;
        }
    }

    if (*ppv)
    {
        ((IUnknown *) *ppv)->AddRef();
        RRETURN(S_OK);
    }

    RRETURN(super::PrivateQueryInterface(iid, ppv));
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptElement::Save
//
//  Synopsis:   standard element saver
//
//  Arguments:  pStreamWriteBuff    The stream to write into
//              fEnd                If this is the end tag
//
//-------------------------------------------------------------------------

HRESULT
CScriptElement::Save(CStreamWriteBuff * pStreamWriteBuff, BOOL fEnd)
{
    HRESULT hr = S_OK;

    // Do not write out the script when saving in plaintext mode, or when
    // writing for the rtf converter.
    if (!pStreamWriteBuff->TestFlag(WBF_SAVE_PLAINTEXT) &&
        !pStreamWriteBuff->TestFlag(WBF_FOR_RTF_CONV))
    {
        DWORD   dwOld;

        if (!fEnd)
        {
            //
            // New line for the <SCRIPT> tag
            //

            hr = THR(pStreamWriteBuff->NewLine());
            if(hr)
                goto Cleanup;
        }

        //
        // Save tagname and attributes.
        //

        hr = THR(super::Save(pStreamWriteBuff, fEnd));
        if (hr)
            goto Cleanup;

        if (fEnd)
        {
            //
            // New line after </SCRIPT>
            //

            hr = THR(pStreamWriteBuff->NewLine());
            goto Cleanup;
        }

        // Turn of entitizing within the script
        dwOld = pStreamWriteBuff->ClearFlags(WBF_ENTITYREF);
    
        // Turn off fancy indenting/formatting
        pStreamWriteBuff->BeginPre();

        hr = THR(pStreamWriteBuff->Write((LPTSTR)_cstrText));
        if (hr)
            goto Cleanup;
        
        pStreamWriteBuff->EndPre();
        pStreamWriteBuff->SetFlags(dwOld);
    }
    
Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CScriptElement::CommitCode
//
//  Synopsis:   Commits the code that it has into a script engine
//              holder.  This could potentially cause code to execute.
//
//-------------------------------------------------------------------------

HRESULT
CScriptElement::CommitCode(BOOL fCommitOutOfMarkup, CHtmlComponent *pComponent, CElement * pElementContext)
{
    const static TCHAR      achDelimiter[] = _T("</SCRIPT>");
    HRESULT                 hr = S_OK;
    CExcepInfo              ExcepInfo;
    CVariant                Var;
    CDoc  *                 pDoc = Doc();
    BSTR                    bstrFuncName = NULL;
    TCHAR *                 pchCleanSource = NULL;
    TCHAR *                 pchSource = NULL;
    LPTSTR                  pchNamespace;
    LPCTSTR                 pchScope = NULL;
    LPCTSTR                 pchLang;
    LPCTSTR                 pchEvent;
    LPCTSTR                 pchFor;
    LPCTSTR                 pchType;
    CMarkup *               pMarkup = GetMarkup();
    CMarkup *               pScriptCollectionMarkup;
    CScriptCollection *     pScriptCollection;
    CMarkupScriptContext *  pScriptContext;

    CDoc::CLock Lock(pDoc);

    Assert(!_fDeferredExecution);

    if (!pMarkup && !fCommitOutOfMarkup)
        goto Cleanup;

    if (!CMarkup::CanCommitScripts(fCommitOutOfMarkup ? NULL : pMarkup, this))
        goto Cleanup;

    // assert correctness of params setup
#if DBG == 1
    if (!fCommitOutOfMarkup)
    {
        // most typical case
        Assert (!pComponent && !pElementContext);
        Assert (pMarkup);
    }
    else
    {
        // script in lightweight HTCs
        Assert (pComponent && pElementContext);
        Assert (pMarkup);
    }

#endif

    pchLang = GetAAlanguage();
    pchEvent = GetAAevent();
    pchFor = GetAAhtmlFor();
    pchType = GetAAtype();
    
    SetReadyStateScript(READYSTATE_INTERACTIVE);
        
    if (!pchFor)
    {
        pchFor = DEFAULT_OM_SCOPE;
    }

    if (pComponent)
    {
        // lightweight htc
        pchNamespace = pComponent->GetNamespace();
    }
    else
    {
        hr = THR(pMarkup->EnsureScriptContext(&pScriptContext));
        if (hr)
            goto Cleanup;

        pchNamespace = pScriptContext->GetNamespace();
    }

    Assert(pchNamespace);

    pchScope = NameOrIDOfParentForm();

    pchSource = _fSrc ? _pchSrcCode : _cstrText;

#if DBG==1
    if (IsTagEnabled(tagHtmSrcTest))
    {
        TCHAR achSrc[512];
        ULONG cch;

        HRESULT hrT;

        hrT = pDoc->GetHtmSourceText(_ulScriptOffset, ARRAY_SIZE(achSrc) - 1,
                achSrc, &cch);

        if (hrT == S_OK)
        {
            cch = min(cch, (ULONG)_tcslen(STRVAL(pchSource)));
            achSrc[cch] = 0;

            TraceTag((tagHtmSrcTest, "Expect \"%.64ls\", (ln=%ld pos=%ld) \"%.64ls\"",
                pchSource, _ulScriptLine, _ulScriptOffset, achSrc));
        }
    }
#endif

#define MAX_SCRIPT_INCLUDES 0 // feature disabled - see CLIENT_SIDE_INCLUDES

#if MAX_SCRIPT_INCLUDES
    if (!pchEvent && pchLang && !StrCmpIC(pchLang, _T("include")) && pDoc->_cIncludes < MAX_SCRIPT_INCLUDES)
    {
        if (pchSource && pDoc->HtmCtx() && pMarkup->IsInInline() && (!_fSrc || _pBitsCtx && pDoc->AccessAllowed(_pBitsCtx->GetUrl())))
        {
            hr = THR(pDoc->HtmCtx()->Write(pchSource, FALSE));
        }

        pDoc->_cIncludes += 1;

        goto Cleanup;
    }
#endif

    if (!fCommitOutOfMarkup)
    {
        // most typical case

        pScriptCollectionMarkup = GetNearestMarkupForScriptCollection();
    }
    else
    {
        // lightweight HTCs case

        pScriptCollectionMarkup = pElementContext->GetNearestMarkupForScriptCollection();
    }

    Assert (pScriptCollectionMarkup);

    pScriptCollection = pScriptCollectionMarkup->GetScriptCollection();

    if (pScriptCollection)
    {
        // hold on to the script collection until the end of the cycle,
        pScriptCollection->AddRef();

        //
        // If the event attribute is set, then treat this as
        // a scriptlet.  Otherwise, just parse it in as script text as
        // long as we're not an event tag.
        //

        if (pchEvent)
        {
            hr = THR(pScriptCollection->AddScriptlet(
                    (LPTSTR)pchLang,                                    // pchLanguage
                    pMarkup,                                            // pScriptMarkup
                    (LPTSTR)pchType,                                    // pchType
                    (LPTSTR)pchSource,                                  // pchCode
                    (LPTSTR)(pchScope ? pchScope : DEFAULT_OM_SCOPE),   // pchItemName
                    (LPTSTR)pchFor,                                     // pchSubItemName
                    (LPTSTR)pchEvent,                                   // pchEventName
                    (LPTSTR)achDelimiter,                               // pchDelimiter
                    _fSrc ? 0 : _ulScriptOffset,                        // ulOffset
                    _fSrc ? 0 : _ulScriptLine,                          // ulStartingLine
                    NULL,                                               // pSourceObject
                    0,                                                  // dwFlags
                    &bstrFuncName,                                      // pbstrName
                    pComponent));                                       // instance of lightweight htc
            
        }
        else
        {
//$ WIN64: CScriptElement::CommitCode is passing a pointer through the ulSourceContextCookie parameter
//$ WIN64:   of the CScriptCollection::ParseScriptText method.

#ifndef NO_SCRIPT_DEBUGGER
            CBase *pBase = (!g_pPDM || !g_pDebugApp) ? pMarkup : (CBase *)this;          // pSourceObject
#else
            CBase *pBase = pMarkup;
#endif

            hr = THR(pScriptCollection->ParseScriptText(
                        (LPTSTR)pchLang,            // pchLanguage
                        pMarkup,                    // pScriptMarkup
                        (LPTSTR)pchType,            // pchType
                        (LPTSTR)pchSource,          // pchCode
                        (LPTSTR)pchNamespace,       // pchItemName
                        (LPTSTR)achDelimiter,       // pchDelimiter
                        _ulScriptOffset,            // ulOffset
                        _ulScriptLine,              // ulStartingLine
                        pBase,                      // pSourceObject
                        SCRIPTTEXT_ISVISIBLE | SCRIPTTEXT_HOSTMANAGESSOURCE, // dwFlags
                        &Var,                       // pvarResult
                        &ExcepInfo,                 // pExcepInfo
                        fCommitOutOfMarkup,         // For shared htc's        
                        pComponent));               // instance of lightweight htc
        }
        if (hr)
            hr = S_OK;

        // release the reference we added at the top of this if' s scope.
        pScriptCollection->Release();
    }

    SetReadyStateScript(READYSTATE_COMPLETE);

Cleanup:
    FormsFreeString(bstrFuncName);
    delete [] pchCleanSource;
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CScriptElement::EnsureScriptDownloadLeft
//
//-------------------------------------------------------------------------

HRESULT
CScriptElement::EnsureScriptDownloadLeft()
{
    HRESULT     hr = S_OK;

    if (_dwScriptDownloadCookie)
    {
        if (IsInMarkup())
            IGNORE_HR(GetMarkup()->UnblockScriptExecution(&_dwScriptDownloadCookie));
        _dwScriptDownloadCookie = NULL;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CScriptElement::EnsureSourceObjectRevoked
//
//-------------------------------------------------------------------------

HRESULT
CScriptElement::EnsureSourceObjectRevoked()
{
    HRESULT     hr = S_OK;
    CDoc *      pDoc = Doc();

    if (pDoc->_pScriptCookieTable && NO_SOURCE_CONTEXT != _dwScriptCookie)
    {
        IGNORE_HR(pDoc->_pScriptCookieTable->RevokeSourceObject(_dwScriptCookie, this));
        _dwScriptCookie = NO_SOURCE_CONTEXT;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:   CScriptElement::Passivate
//
//-------------------------------------------------------------------------

void
CScriptElement::Passivate()
{
    IGNORE_HR(EnsureSourceObjectRevoked());

    if (_pScriptDebugDocument)
    {
        _pScriptDebugDocument->Release();
    }

    if (_fSharedCode)
        _cstrText.SetPch(NULL);

    SetBitsCtx(NULL);
    if (!_fSharedCode)
        delete _pchSrcCode;
    delete _pchEventName;
    _pchEventName = NULL;
    ClearInterface (&_pDispCode);
    super::Passivate();
}

//+------------------------------------------------------------------------
//
//  Function:   helper for CScriptElement::CommitFunctionPointersCode
//
//-------------------------------------------------------------------------

HRESULT
TokenizeEventDescription (TCHAR * pchEvent, TCHAR ** ppchEventName, TCHAR ** ppchFormalParams)
{
    HRESULT     hr = S_OK;
    TCHAR *     pchStart;
    TCHAR *     pchEnd;
    long        l;

    Assert (ppchEventName);
    Assert (ppchFormalParams);
    
    delete [] *ppchEventName;
    *ppchEventName    = NULL;
    *ppchFormalParams = NULL;

    //
    // get event name
    //

    // skip leading spaces
    pchStart = pchEvent;
    while (_T(' ') == *pchStart)
        pchStart++;

    if (0 == *pchStart) // if no name specified
        goto Cleanup;

    // find the end of name
    pchEnd = pchStart;
    while (_T(' ') != *pchEnd && _T('(') != *pchEnd && *pchEnd)
        pchEnd++;

    // alloc and copy event name

    Assert (pchStart && pchEnd);

    l = PTR_DIFF(pchEnd, pchStart);

    *ppchEventName = new(Mt(TokenizeEventDescription_ppchEventName)) TCHAR [l + 1];
    if (!*ppchEventName)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _tcsncpy (*ppchEventName, pchStart, l);
    (*ppchEventName)[l] = 0;

    //
    // get formal params
    //

    pchStart = _tcschr (pchEnd, _T('('));
    if (!pchStart)
        goto Cleanup; // no open bracket so no params

    pchEnd = _tcschr (pchStart, _T(')'));
    if (!pchEnd)
        goto Cleanup; // invalid syntax - there was open bracket and no closing bracket

    // alloc and copy formal params

    Assert (pchStart && pchEnd);

    l = PTR_DIFF(pchEnd, pchStart) - 1;

    if (l)
    {
        *ppchFormalParams = new(Mt(TokenizeEventDescription_ppchFormalParams)) TCHAR [l + 1];
        if (!*ppchFormalParams)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        _tcsncpy (*ppchFormalParams, pchStart + 1, l);
        (*ppchFormalParams)[l] = 0;
    }

Cleanup:
    if (hr)
    {
        delete *ppchEventName;
        delete *ppchFormalParams;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptElement::CommitFunctionPointersCode
//
//-------------------------------------------------------------------------

HRESULT
CScriptElement::CommitFunctionPointersCode(CBase *pelTarget, BOOL fHookup)
{
    HRESULT                 hr = S_OK;
    TCHAR *                 pchEvent;
    TCHAR *                 pchFor;
    TCHAR *                 pchLanguage;
    TCHAR *                 pchType;
    int                     iObject;
    int                     cObjects;
    CBase *                 pObject;
    CElementAryCacheItem    cacheItem;
    CElement *              pElem;
    TCHAR *                 pchFormalParams = NULL;
    CBase *                 pNonElementPropHost = NULL;
    CBase **                ppBase = NULL;
    CScriptHolder *         pHolder;
    ITypeInfo *             pTIEvent = NULL;
    DISPID                  dispid = DISPID_UNKNOWN;
    COleSite *              pOleSite = NULL;
    CMarkup *               pMarkup = GetMarkup();
    TCHAR *                 pchSource = _fSrc ? _pchSrcCode : _cstrText;
    BOOL                    fAnyDeleted;
    CScriptCollection *     pScriptCollection;

    pchEvent = (TCHAR*) GetAAevent();
    pchFor   = (TCHAR*) GetAAhtmlFor();
    pchType  = (TCHAR*) GetAAtype();

    Assert(pMarkup);

    // if the script element is for/event type
    if (pchEvent && *pchEvent && pchFor && *pchFor && pchSource && *pchSource)
    {
        //
        // get objects specified in pchFor
        //

        pchLanguage = (TCHAR*)GetAAlanguage();
        pScriptCollection = pMarkup->GetScriptCollection();

        if (!pScriptCollection)
            goto Cleanup;

        hr = THR(pScriptCollection->GetHolderForLanguage(pchLanguage, pMarkup, pchType, NULL, &pHolder));
        if (hr)
            goto Cleanup;

        if (pelTarget)
        {
            if ((0 == FormsStringCmpCase(DYNCAST(CElement, pelTarget)->GetAAname(), pchFor, pHolder->_fCaseSensitive)) ||
                (0 == FormsStringCmpCase(DYNCAST(CElement, pelTarget)->GetAAid(), pchFor, pHolder->_fCaseSensitive)))
            {
                cObjects = 1;
                ppBase = &pelTarget;
            }
            else
                goto Cleanup;
        }
        else if (0 == FormsStringCmpCase(_T("document"), pchFor, pHolder->_fCaseSensitive))
        {
            hr = pMarkup->EnsureDocument();
            if (hr)
                goto Cleanup;

            pNonElementPropHost = pMarkup->Document();
            cObjects = 1;
            ppBase = &pNonElementPropHost;
        }
        else if (0 == FormsStringCmpCase(_T("window"), pchFor, pHolder->_fCaseSensitive))
        {
            if (!pMarkup->HasWindow())
            {
                hr = S_OK;
                goto Cleanup;
            }

            pNonElementPropHost = pMarkup->Window();
            cObjects = 1;
            ppBase = &pNonElementPropHost;            
        }
        else
        {
            hr = THR(pMarkup->EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION));
            if (hr)
                goto Cleanup;

            hr = THR_NOTRACE(pMarkup->CollectionCache()->BuildNamedArray(
                CMarkup::ELEMENT_COLLECTION,
                pchFor,
                FALSE,
                &cacheItem,
                0,  // iStartFrom
                pHolder->_fCaseSensitive));
            if (hr)
                goto Cleanup;

            cObjects = cacheItem.Length();
        }

        if (!cObjects)
            goto Cleanup;

        //
        // construct code
        //
        if (!_fCodeConstructed) 
        {
            //
            // get pchEventName and pchFormalParams from pchEvent
            //
            TCHAR *pchNamespace = NULL;

            hr = THR(TokenizeEventDescription((TCHAR*)pchEvent, &_pchEventName, &pchFormalParams));
            if (hr || !_pchEventName)
                goto Cleanup;

            if (!pMarkup->HasWindowPending())
            {
                CMarkupScriptContext *pScriptContext;
                hr = THR(pMarkup->EnsureScriptContext(&pScriptContext));
                if (!hr)
                    pchNamespace = pScriptContext->GetNamespace();
            }

            hr = THR_NOTRACE(pScriptCollection->ConstructCode(
                pchNamespace,       // pchScope
                pchSource,          // pchCode
                pchFormalParams,    // pchFormalParams
                pchLanguage,        // pchLanguage
                pMarkup,            // pMarkup
                pchType,            // pchType
                _ulScriptOffset,    // ulOffset
                _ulScriptLine,      // ulStartingLine
                pMarkup,            // pSourceObject
                0,                  // dwFlags
                &_pDispCode,        // ppDispCode result
                FALSE));            // fSingleLine

            if (hr)
            {                   // if the language does not support code construction
                                // or failed to construct because of syntax error
                hr = S_OK;
                goto Cleanup;
            }

            _fCodeConstructed = TRUE;
        }

        //
        // for each object set the property
        //
        for (iObject = 0; iObject < cObjects; iObject++)
        {
            if(ppBase)
            {
                pObject = ppBase[iObject];
                pElem = NULL;
            }
            else
            {
                pElem = cacheItem.GetAt(iObject);
                pObject = (CBase*)pElem;
            }

            hr = E_FAIL;

            //
            // Get the dispid to use for storing the function pointer.
            //

            //
            // If this object is an olesite, ask the control's event
            // typeinfo if it knows about the name.
            // We need to do this first in order to catch the event as
            // defined by the control rather than by us. (e.g. onclick)
            //
            if (pObject->BaseDesc()->_dwFlags & CElement::ELEMENTDESC_OLESITE)
            {
                pOleSite = DYNCAST(COleSite, pObject);

                pTIEvent = pOleSite->GetClassInfo()->_pTypeInfoEvents;
                if (pTIEvent)
                {
                    hr = THR_NOTRACE(pTIEvent->GetIDsOfNames(
                            &_pchEventName,
                            1,
                            &dispid));
                }
            }

            // if not an olesite or could not find dispid from object in olesite
            if (hr)
            {
                // Note: for special IE3 compatibility we allow case insensitive
                // matching for the EVENT OnLoad attribute.  This is because IE3
                // implemented it as onLoad, and we correctly implement it as
                // onload.  So that sites can use onLoad & work with IE3 until
                // it is gone for good this hack allows us to use onLoad with
                // any case whatsoever.  -TomSn
                hr = THR_NOTRACE(pObject->GetDispID(
                    _pchEventName,
                    (pHolder->_fCaseSensitive && _tcsicmp( _T("onload"), _pchEventName )) ?
                        fdexNameCaseSensitive : 0,
                    &dispid));

                // if could not get a standard event
                if (hr || IsExpandoDispid(dispid))
                {
                    if (!pNonElementPropHost)
                    {
                        CElement * pElement = DYNCAST(CElement, pObject);

                        if (pElement->HasPeerHolder())
                        {
                            hr = THR_NOTRACE(pElement->GetPeerHolder()->GetEventDispidMulti(
                                _pchEventName, &dispid));
                        }
                    }
                    else
                        hr = E_FAIL;

                    if (hr)
                    {
                        hr = S_OK;

                        if (pelTarget)      // this is important so that _fScriptCommitted does not get set
                            goto Cleanup;   // and we force the script element to be recommitted again later

                        continue;
                    }
                }
            }
            Assert(_pDispCode);
            hr = THR(pObject->SetCodeProperty(dispid, fHookup ? _pDispCode : NULL, &fAnyDeleted));
            if (hr)
                goto Cleanup;

            if (pElem && !fAnyDeleted && dispid == DISPID_EVPROP_ONLOAD)
            {
                IHTMLElement2  *pElem2 = NULL;
                long            lRetValue;

                hr = THR(pElem->QueryInterface(IID_IHTMLElement2, (void **)&pElem2));
                if (hr)
                    continue;

                IGNORE_HR(pElem2->get_readyStateValue(&lRetValue));

                ReleaseInterface(pElem2);
                
                if (lRetValue == READYSTATE_COMPLETE)
                {
                    // All onload propdesc's are same, so use any in the absence of one on CElement
                    pElem->FireEvent(&s_propdescCWindowonload);
                }
            }

            //
            // Ensure the private sink from oc's *after* setting the
            // code property so that if the oc immediately fires an
            // event, we can correctly refire into the script engine.
            //
            
            if (pOleSite && fHookup)
            {
                pOleSite->EnsurePrivateSink();
                pOleSite->SetEventsShouldFire();
            }

            // if we add a data event to an element, make sure the event can fire
            CDataMemberMgr::EnsureDataEventsFor(pObject, dispid);
        }
    }

    _fScriptCommitted = TRUE;

Cleanup:
    delete pchFormalParams;

    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CScriptElement::SetBitsCtx
//
//  Synopsis:   Attaches the script element to a bitsctx to download
//
//-------------------------------------------------------------------------

void CScriptElement::SetBitsCtx(CBitsCtx * pBitsCtx)
{
    CBitsCtx *  pBitsCtxOld = _pBitsCtx;
    
    if (pBitsCtxOld)
    {
        _pBitsCtx = NULL;
        pBitsCtxOld->SetProgSink(NULL); // detach download from document's load progress
        pBitsCtxOld->Disconnect();
        pBitsCtxOld->Release();
    }

    _pBitsCtx = pBitsCtx;

    if (pBitsCtx)
    {
        pBitsCtx->AddRef();

        if (pBitsCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
            OnDwnChan(pBitsCtx);
        else
        {
            pBitsCtx->SetProgSink(CMarkup::GetProgSinkHelper(GetMarkup()));
            pBitsCtx->SetCallback(OnDwnChanCallback, this);
            pBitsCtx->SelectChanges(DWNCHG_COMPLETE, 0, TRUE);
        }
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptElement::OnDwnChan
//
//  Synopsis:   Called by the bitsctx to notify of download progress
//
//-------------------------------------------------------------------------

void
CScriptElement::OnDwnChan(CDwnChan * pDwnChan)
{
    HRESULT         hr;
    CDoc *          pDoc = Doc();
    ULONG           ulState;
    char *          pbBuffer = NULL;
    IStream *       pStream = NULL;
    STATSTG         statstg;
    ULONG           cbLen;
    int             cchLen;
    BOOL            fEndCR;
    ULONG           cbRead;
    TCHAR *         pchEnd;
    TCHAR *         pchUrl;
    CMarkup *       pMarkup = GetMarkup();

    Assert(_fSrc);

    // Stress bug fix for # 28132.  CScriptElement seems to be getting destructed
    // half-way through this call.
    Assert(!(IsPassivating() || IsPassivated() || IsDestructing()));
    PrivateAddRef();

    ulState = _pBitsCtx->GetState();
    
    if (ulState & DWNLOAD_COMPLETE)
    {
        pchUrl = (LPTSTR) _pBitsCtx->GetRedirectedUrl();
        if (pchUrl == NULL)
            pchUrl = (LPTSTR) _pBitsCtx->GetUrl();

        BOOL fPendingRoot = FALSE;

        if (IsInMarkup())
            fPendingRoot = pMarkup->IsPendingRoot();

        // If unsecure download, may need to remove lock icon on Doc
        pDoc->OnSubDownloadSecFlags(fPendingRoot, pchUrl, _pBitsCtx->GetSecFlags());
    
        // if load completed OK, load file and convert to unicode
        hr = THR(_pBitsCtx->GetStream(&pStream));

        if (hr)
            goto Cleanup;

        hr = THR(pStream->Stat(&statstg, STATFLAG_NONAME));
        if (hr)
            goto Cleanup;

        cbLen = statstg.cbSize.LowPart;
        if (statstg.cbSize.HighPart || cbLen == 0xFFFFFFFF)
            goto Cleanup;

        pbBuffer = new(Mt(CScriptElementOnDwnChan_pbBuffer)) char[cbLen];
        if (!pbBuffer)
            goto Cleanup;

        hr = THR(pStream->Read(pbBuffer, cbLen, &cbRead));

        if (hr == S_FALSE)
            hr = S_OK;
        else if (hr || cbRead != cbLen)
            goto Cleanup;

        delete [] _pchSrcCode;

        if (cbLen)
        {
            // TODO/NB (cthrash) In IE4, we loaded linked script files by converting the source
            // to Unicode using CP_ACP.  This implied that how the script file was interpreted
            // depended on the system codepage of the UA, i.e. the author had no control over
            // how it was read into the browser.  This was bad.  So for IE5.1, we will load the
            // script file in the document's codepage, usually set in the form of a META tag.
            // This change will surely cause some incompatibilities, but hopefully not in cases
            // we care about.
            //
            // The quirk to this change which may not be immediately obvious to authors is that
            // immediately following a document.write, the document's codepage switches to Unicode
            // (cp1200).  This implies that subsequent linked script files would be loaded in
            // Unicode.  That would be a significant departure from IE4 (in IE4 you could not load
            // a Unicode-encoded script file under any circumstance.)   So the hack here is to load
            // the script file in the 'navigatable' codepage which is the same as the codepage in
            // all cases except Unicode.  The navigateable codepage for Unicode is UTF-8.  This is
            // clearly a hack, but at least all ASCII content is guaranteed to be loaded reliably,
            // and after all, that's the only kind of content you could predictably load in IE4
            // anyway.

//TODO (lmollico): fix this (CScriptElement::put_src in script2.htm)
            LPCTSTR szCharset = GetAAcharset();
            CODEPAGE cp = szCharset ? CodePageFromAlias(szCharset) : CP_UNDEFINED;

            if (cp == CP_UNDEFINED)
            {
                pMarkup = IsInMarkup() ? pMarkup : pDoc->PrimaryMarkup();
                cp = NavigatableCodePage(pMarkup->GetCodePage());
            }

            CToUnicodeConverter tuc(cp);
            HRESULT hr;

#ifdef PERFMETER
            tuc.SetMt(Mt(CScriptElement_pchSrcCode));
#endif

            hr = THR( tuc.Convert( pbBuffer, cbLen, &_pchSrcCode, &cchLen ) );
            if (hr)
                goto Cleanup;
        }
        else
        {
            // Commit code can't deal with NULL _pchSrcCode, so allocate a single-char buffer with NUL.

            _pchSrcCode = new(Mt(CScriptElement_pchSrcCode)) TCHAR[1];

            if (!_pchSrcCode)
                goto Cleanup;

            cchLen = 0;
        }

        fEndCR = FALSE;
        pchEnd = _pchSrcCode + cchLen;
        cchLen -= NormalizerChar(_pchSrcCode, &pchEnd);
        _pchSrcCode[cchLen] = _T('\0');
        
        // these variable are not set correctly in case of <script src = >
        _ulScriptOffset = 0;
        _ulScriptLine = 1;

        if (_pScriptDebugDocument)
        {
            _pScriptDebugDocument->Release();
        }
        {
            CScriptDebugDocument::CCreateInfo   createInfo(IsInMarkup() ? GetMarkup() : pDoc->PrimaryMarkup(), pchUrl, _pchSrcCode);

            hr = THR(CScriptDebugDocument::Create(&createInfo, &_pScriptDebugDocument));
            if (hr)
                goto Cleanup;
        }

        if ((!ParserWillExecute() || _fPastedOrInjected) && IsInMarkup())
        {
            if (!_fPastedOrInjected)
                Execute();
            _fPastedOrInjected = FALSE;
            CommitFunctionPointersCode();
        }
    }
    
Cleanup:
    // even if download failed, tell the cdoc that it's done
    if (ulState & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
    {
        SetReadyStateScript(READYSTATE_LOADED);

        IGNORE_HR(EnsureScriptDownloadLeft());
        
        // stress fix check - bug # 556759
        if (_pBitsCtx != NULL)
        {
            _pBitsCtx->SetProgSink(NULL); // detach download from document's load progress
            SetBitsCtx( NULL );           // No reason to hold on to the data anymore
        }
    }
    
    delete pbBuffer;
    ReleaseInterface(pStream);

    // PrivateRelease() to match the PrivateAddRef() at the beginning of the function.
    PrivateRelease();
}


//+------------------------------------------------------------------------
//
//  Member:     CScriptElement::Notify
//
//  Synopsis:   Handle the STOP message - stop downloading inline script
//
//-------------------------------------------------------------------------

void
CScriptElement::Notify(CNotification *pNF)
{
    HRESULT     hr = S_OK;
    TCHAR      *pchEvent;
    TCHAR      *pchFor;
    CDoc       *pDoc;
    
    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_STOP_1:
    case NTYPE_MARKUP_UNLOAD_1:
        if (_pBitsCtx)
            _pBitsCtx->SetLoad(FALSE, NULL, FALSE);
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        if(!_fFirstEnteredTree)
        {
            CMarkup *pMarkup = GetMarkup();
            pDoc = Doc();
            BOOL fRunScript;

            _fFirstEnteredTree = TRUE;

            // TODO (alexz) it is not safe to call SetReadyStateScript or ProcessUrlAction
            // from EnterTree. The first one may fire events, which will execute external code,
            // and the second one may push a message loop for a security message box. These
            // scenarios will lead to crashing bugs in the tree and parser code.
            // This code should be move to Execute phase

            SetReadyStateScript(READYSTATE_LOADING);

            if (IsSpecialUrl(CMarkup::GetUrl(pMarkup)))
            {
                DWORD dwPolicyTo;

                hr = THR(pMarkup->ProcessURLAction(URLACTION_SCRIPT_RUN, 
                                                    &fRunScript,
                                                    0, 
                                                    &dwPolicyTo, 
                                                    pMarkup->GetAAcreatorUrl()));
            }
            else
            {
                hr = THR(pMarkup->ProcessURLAction(URLACTION_SCRIPT_RUN, &fRunScript));
            }

            if (!hr && fRunScript)
            {
                // Do not download script if already done so in put_src
                if (!_fScriptDownloaded)
                {
                    hr = THR(DownLoadScript(TRUE));
                    if (hr)
                        break;
                }

                // commit script only when a newly created\removed script elem enters some tree
                // and it has no src or an already downloaded src as a result of a put_src
                if (!_fSrc || (_pchSrcCode && _fScriptDownloaded))
                {
                    // Commit only dynamically created script elems on behalf of parser.
                    if (!ParserWillExecute())
                    {
                        Execute();
                    }
                }

                pchEvent = (TCHAR *)GetAAevent();
                pchFor = (TCHAR *)GetAAhtmlFor();

                if (pchEvent && *pchEvent && pchFor && *pchFor)
                {
                    //
                    // Set bit on doc telling it to walk script collection.
                    //

                    if (!pMarkup->_fHasScriptForEvent) 
                        pMarkup->_fHasScriptForEvent = TRUE;

                    // commit script only when a newly created\removed script elem enters some tree
                    // and it has no src or an already downloaded src  as a result of a put_src
                    if ((!ParserWillExecute() || _fPastedOrInjected) && (!_fSrc || (_pchSrcCode && _fScriptDownloaded)))
                    {
                        Assert(!pMarkup->_fMarkupServicesParsing);
                        Assert(!_fPastedOrInjected || ParserWillExecute());
                        _fPastedOrInjected = FALSE;
                        CommitFunctionPointersCode();
                    }
        
                    if (pMarkup->_fMarkupServicesParsing)
                        _fPastedOrInjected = TRUE;
                }
            }
        }

        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        {
            // No longer under parser control, once removed from tree after being committed once.
            BOOL fMarkupDestroy = pNF->DataAsDWORD() & EXITTREE_DESTROY;

            // No longer under parser control, once removed from tree after being committed once
            if (_fScriptCommitted)
                SetParserWillExecute(FALSE);

            // unhook code on all objects associated with this (user created, not by parser)
            // script elem 
            if (!fMarkupDestroy)
            {
                if (!ParserWillExecute())
                {
                    pchEvent = (TCHAR *)GetAAevent();
                    // For now, don't allow inline script block to be reexecuted if it enters
                    // another markup later.
                    if (!pchEvent)
                        break;

                    CommitFunctionPointersCode(NULL, FALSE);
            
                    // Allow hook up when it enters some tree again.
                    _fScriptCommitted = FALSE;
                }

                // unblock script execution - stress fix check - bug # 556786
                CMarkup * pMarkup = GetMarkup();

                if (_dwScriptDownloadCookie && pMarkup)
                {
                    _markupCookie = pMarkup;
                    _markupCookie->AddRef();
                    pNF->SetSecondChanceRequested();
                }
            }
            else
            {
                SetBitsCtx(NULL);
                _fScriptCommitted = FALSE;
            }

            IGNORE_HR(EnsureSourceObjectRevoked());

            _fFirstEnteredTree = FALSE;
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_2:

        if (_dwScriptDownloadCookie)
        {
            Assert(_markupCookie);
            _markupCookie->UnblockScriptExecution(&_dwScriptDownloadCookie);
            _dwScriptDownloadCookie = NULL;
            _markupCookie->Release();
            _markupCookie = NULL;
        }
        break;
    }
}

HRESULT
CScriptElement::DownLoadScript(BOOL fShare)
{
    HRESULT         hr = S_OK;
    CDoc *          pDoc = Doc();
    const TCHAR *   pchUrl = GetAAsrc();
    CBitsCtx *      pBitsCtx = NULL;

    if (pchUrl && *pchUrl)
    {
        _fSrc = TRUE;

        CHtmlComponent *pComponent = NULL;
        CMarkup *pMarkup = GetMarkup();

        if (fShare && pMarkup && pMarkup->HasBehaviorContext())
        {
            pComponent = pMarkup->BehaviorContext()->_pHtmlComponent;
        }

        if (!pComponent || pComponent->_fFactoryComponent || !pComponent->_pConstructor->_pelFactoryScript)
        {
            BOOL fPendingRoot = FALSE;

            if (IsInMarkup())
                fPendingRoot = pMarkup->IsPendingRoot();

            hr = THR(pDoc->NewDwnCtx(DWNCTX_BITS, pchUrl, this,
                        (CDwnCtx **)&pBitsCtx, fPendingRoot, FALSE, PROGSINK_CLASS_CONTROL));
            if (hr)
                goto Cleanup;

            // IE5: don't block parser for script download if DEFER attribute is present
            // (we leave _dwScriptCookie NULL in this case)
        
            Assert(!_dwScriptDownloadCookie);
        
            if (VB_FALSE == GetAAdefer())
            {
                if (IsInMarkup())
                {
                    pMarkup->BlockScriptExecution(&_dwScriptDownloadCookie);
                    Assert(_dwScriptDownloadCookie);
                }
            }
        
            SetBitsCtx(pBitsCtx);
        }
        else
        {
            Assert(!pComponent->_fFactoryComponent);
            Assert(pComponent->_pConstructor->_pFactoryComponent->_fClonedScript);
            Assert(pComponent->_pConstructor->_pelFactoryScript);
            Assert(pComponent->_pConstructor->_pFactoryComponent->_pMarkup == pComponent->_pConstructor->_pelFactoryScript->GetMarkup());
            Assert(pComponent->_pConstructor->_pelFactoryScript->_pchSrcCode);
            _pchSrcCode = pComponent->_pConstructor->_pelFactoryScript->_pchSrcCode;
            _fSharedCode = TRUE;

            // these variable are not set correctly in case of <script src = >
            _ulScriptOffset = 0;
            _ulScriptLine = 1;

            if (_pScriptDebugDocument)
            {
                _pScriptDebugDocument->Release();
            }
            {
                CScriptDebugDocument::CCreateInfo   createInfo(IsInMarkup() ? pMarkup : pDoc->PrimaryMarkup(), (LPTSTR)pchUrl, _pchSrcCode);

                hr = THR(CScriptDebugDocument::Create(&createInfo, &_pScriptDebugDocument));
                if (hr)
                    goto Cleanup;
            }

            if ((!ParserWillExecute() || _fPastedOrInjected) && IsInMarkup())
            {
                if (!_fPastedOrInjected)
                    Execute();
                _fPastedOrInjected = FALSE;
                CommitFunctionPointersCode();
            }

            SetReadyStateScript(READYSTATE_LOADED);
        }
    }
    else
        _fSrc = FALSE;

Cleanup:
    if (pBitsCtx)
        pBitsCtx->Release();

    return hr;
}

HRESULT
CScriptElement::Execute()
{
    HRESULT         hr = S_OK;
    HRESULT         hr2;
    VARIANT_BOOL    vbDefer = GetAAdefer();
    CDoc *          pDoc = Doc();
    CMarkup *       pMarkup = GetMarkup();

    CDoc::CLock Lock(pDoc);

    if (!pMarkup)
        goto Cleanup;

    // if no defer attribute set, or we're not inside the parser, commit code now
    if (VB_FALSE == vbDefer || !ParserWillExecute())
    {
        //
        // Any script tags that don't have the defer attribute specified
        // are not sent to the script engine when pasting.  This is to
        // prevent document.write problems and more seriously exposing
        // the paste tree to object model before it's been spliced into
        // the main tree.
        //

        if (pMarkup->_fMarkupServicesParsing)
            return S_OK;

        if (_fSrc && pMarkup->IsInScriptExecution())
        {
            // commit after inline scripts are complete
            RRETURN(THR(pMarkup->EnqueueScriptToCommit(this)));
        }
        else
        {
            CWindow *pWindow = NULL;

            // execute should not be called on a script element that is not in a markup
            Assert (pMarkup);

            // Abort script execution in print mode
            // This scenario only appears to come up for HTCs
            if ( pMarkup->DontRunScripts() )
                goto Cleanup;

            // commit immediately
            hr = THR(pMarkup->EnterScriptExecution(&pWindow));
            if (hr)
                goto Cleanup;

            hr2 = THR(CommitCode());

            hr = THR(pMarkup->LeaveScriptExecution(pWindow));
            if (hr2)
                hr = hr2;

            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        // when parsing a script tag with the defer attribute, we want to
        // commit after all downloads are complete
        RRETURN(THR(pDoc->DeferScript(this)));
    }

    Assert(VB_FALSE != vbDefer || !pMarkup->_fMarkupServicesParsing);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CScriptElement::OnReadyStateChange
//
//----------------------------------------------------------------------------

void
CScriptElement::OnReadyStateChange()
{   // do not call super::OnReadyStateChange here - we handle firing the event ourselves
    SetReadyStateScript(_readyStateScript);
}

void
CScriptElement::FireOnReadyStateChange(DWORD_PTR dwContext)
{
    Fire_onreadystatechange();
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptElement::SetReadyStateScript
//
//  Synopsis:   Use this to set the ready state;
//              it fires OnReadyStateChange if needed.
//
//  Returns:    void
//
//-------------------------------------------------------------------------
void
CScriptElement::SetReadyStateScript(long readyStateScript)
{
    long readyState;

    _readyStateScript = readyStateScript;

    readyState = min ((long)_readyStateScript, super::GetReadyState());

    if ((long)_readyStateFired != readyState)
    {
        _readyStateFired = readyState;

        GWPostMethodCall(this, ONCALL_METHOD(CScriptElement, FireOnReadyStateChange, fireonreadystatechange), 0, FALSE, "CScriptElement::FireOnReadyStateChange");
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CScriptElement:get_readyState
//
//+------------------------------------------------------------------------------

HRESULT
CScriptElement::get_readyState(BSTR * p)
{
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr=THR(s_enumdeschtmlReadyState.StringFromEnum(_readyStateFired, p));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CScriptElement::get_readyState(VARIANT * pVarRes)
{
    HRESULT hr = S_OK;

    if (!pVarRes)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = get_readyState(&V_BSTR(pVarRes));
    if (!hr)
        V_VT(pVarRes) = VT_BSTR;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

STDMETHODIMP CScriptElement::put_src(BSTR v)
{
    HRESULT hr;
    BOOL fRunScript;
    CMarkup *pMU;

    hr = THR(put_StringHelper(v, (const PROPERTYDESC *)&s_propdescCScriptElementsrc));
    if (hr)
        goto Cleanup;

    pMU = GetMarkupPtr();
    if ( !pMU )
        pMU = Doc()->PrimaryMarkup();

    Assert( pMU );
    
    hr = THR(pMU->ProcessURLAction(URLACTION_SCRIPT_RUN, &fRunScript));
    if (hr)
        goto Cleanup;

    if (!fRunScript)
        goto Cleanup;
    
    _fCodeConstructed = FALSE;
    if (!_fSharedCode)
        delete [] _pchSrcCode;
    _pchSrcCode = NULL;


//    if (_fDownloadContent) // TODO(sramani)
    {
        // Make sure script will be committed\executed after download is finished.
        SetParserWillExecute(FALSE);

        hr = THR(DownLoadScript());
        if (hr)
            goto Cleanup;

        // flag that we have already downloaded script: in case script elem is
        // removed from some tree and inserted back in, or a newly created script
        // elem enters some tree, we don't want to download again on SN_ENTERTREE
        _fScriptDownloaded = _fSrc;
    }
//    else
//        _fScriptDownloaded = FALSE;

    // if the src is being removed, hook up again if the script elem
    // is in some tree and it has code.
    if (IsInMarkup() && !_fSrc && _cstrText)
    {
        hr = THR(Execute());
        if (hr)
            goto Cleanup;
        
        hr = THR(CommitFunctionPointersCode());
    }
    else
        _fSharedCode = FALSE;

Cleanup:
    return SetErrorInfo(hr);
}

STDMETHODIMP CScriptElement::put_htmlFor(BSTR v)
{
    // unhook current event sink for the old htmlFor
    if (IsInMarkup())
        CommitFunctionPointersCode(NULL, FALSE);

    // hook up this sink as the new one for <v>
    return SetPropertyHelper(v, (const PROPERTYDESC *)&s_propdescCScriptElementhtmlFor);
}

STDMETHODIMP CScriptElement::put_event(BSTR v)
{
    // TODO: don't allow inline script blocks to be converted to event handlers,
    // until namespace movement support is provided by script engine in IE6
    if (_fScriptCommitted && !GetAAevent())
        return SetErrorInfo(E_UNEXPECTED);

    // unhook event sink for all objects listening to current event.
    if (IsInMarkup())
        CommitFunctionPointersCode(NULL, FALSE);

    _fCodeConstructed = FALSE;
    return SetPropertyHelper(v, (const PROPERTYDESC *)&s_propdescCScriptElementevent);
}

STDMETHODIMP CScriptElement::put_text(BSTR v)
{
    _fCodeConstructed = FALSE;
    if (_fSharedCode)
    {
        _cstrText.SetPch(NULL);
        _fSharedCode = FALSE;
    }
    return SetPropertyHelper(v, (const PROPERTYDESC *)&s_propdescCScriptElementtext);
}

STDMETHODIMP CScriptElement::SetPropertyHelper(BSTR v, const PROPERTYDESC *pPropDesc)
{
    HRESULT hr;
    BOOL fRunScript;
    CMarkup *pMU;

    hr = THR(put_StringHelper(v, pPropDesc));
    if (hr)
        goto Cleanup;

    pMU = GetMarkupPtr();
    if ( !pMU )
        pMU = Doc()->PrimaryMarkup();

    Assert( pMU );
    
    hr = THR(pMU->ProcessURLAction(URLACTION_SCRIPT_RUN, &fRunScript));
    if (hr)
        goto Cleanup;

    if (!fRunScript)
        goto Cleanup;

    // Allow code to be committed\executed if not yet done, but script tag
    // is present on the page.
    SetParserWillExecute(FALSE);

    // if script elem in any tree, then commit its code now, else
    // do it when it enters some tree
    if (IsInMarkup())
    {
        hr = THR(Execute());
        if (hr)
            goto Cleanup;

        hr = THR(CommitFunctionPointersCode());
    }

Cleanup:
    return hr;
}

STDMETHODIMP CScriptElement::get_src(BSTR *p)
{
    HRESULT hr = get_PropertyHelper(p, (const PROPERTYDESC *)&s_propdescCScriptElementsrc);

    if (SUCCEEDED(hr) && (*p != NULL) && (_pBitsCtx != NULL) && (_pBitsCtx->GetRedirectedUrl() != NULL))
    {
        if (SysReAllocString(p, (OLECHAR*) _pBitsCtx->GetRedirectedUrl()))
            hr = S_OK;
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

STDMETHODIMP CScriptElement::get_htmlFor(BSTR *p)
{
    return get_PropertyHelper(p, (const PROPERTYDESC *)&s_propdescCScriptElementhtmlFor);
}

STDMETHODIMP CScriptElement::get_event(BSTR *p)
{
    return get_PropertyHelper(p, (const PROPERTYDESC *)&s_propdescCScriptElementevent);
}

STDMETHODIMP CScriptElement::get_text(BSTR *p)
{
    return get_PropertyHelper(p, (const PROPERTYDESC *)&s_propdescCScriptElementtext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\hyplnk.cxx ===
//=-----------------------------------------------------------=
//
// File:        earea.cxx
//
// Contents:    Area element class
//
// Classes:     CHyperlink
//
//=-----------------------------------------------------------=


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_MSRATING_HXX_
#define X_MSRATING_HXX_
#include "msrating.hxx" // AreRatingsEnabled()
#endif

MtDefine(CHyperlink, Elements, "CHyperlink")
MtDefine(CHyperlinkGetUrlComponent, Utilities, "CHyperlink::GetUrlComponent")


//+---------------------------------------------------------------------------
//
// Member: CHyperlink::SetStausText
//
//----------------------------------------------------------------------------

HRESULT
CHyperlink::SetStatusText()
{
    HRESULT     hr;
    CDoc *      pDoc    = Doc();
    TCHAR *     pchUrl  = NULL;

    hr = GetUrlComponent(NULL, URLCOMP_WHOLE, &pchUrl);
    if (!hr && pchUrl)
    {
        TCHAR *pchFriendlyUrl = GetFriendlyUrl(
                pchUrl,
                pDoc->GetPrimaryUrl(),
                pDoc->_pOptionSettings->fShowFriendlyUrl, TRUE);

        pDoc->SetStatusText(pchFriendlyUrl, STL_ROLLSTATUS, GetMarkup());

        MemFreeString(pchFriendlyUrl);
        MemFreeString(pchUrl);
    }
    return hr;

}

//+------------------------------------------------------------------------
//
//  Member:     CHyperlink::CopyLinkToClipboard
//
//  Synopsis:   Copies the asssociated link to clipboard, which can then be
//              pasted onto dersktop as a URL shortcut, etc. 
//
//-------------------------------------------------------------------------
HRESULT CHyperlink::CopyLinkToClipboard(const TCHAR * pchDesc/*=NULL*/)
{
    HRESULT                     hr              = S_OK;
    IDataObject *               pDO             = NULL;
    IUniformResourceLocator *   pURLToDrag      = NULL;
    TCHAR                       cBuf[pdlUrlLen];
    TCHAR *                     pchExpandedUrl  = cBuf;
    CStr                        strUrlTitle;
    CWindow *                   pWindow;

    // fully resolve URL
    hr = THR(CMarkup::ExpandUrl(NULL, GetUrl(), ARRAY_SIZE(cBuf), pchExpandedUrl, this));
    if (hr)
        goto Cleanup;

    if (!pchDesc && S_OK == GetUrlTitle(&strUrlTitle))
    {
        pchDesc = strUrlTitle;
    }

    hr = THR(CreateLinkDataObject(pchExpandedUrl, pchDesc, &pURLToDrag));
    if (hr)
        goto Cleanup;

    hr = THR(pURLToDrag->QueryInterface(IID_IDataObject, (void **)&pDO));
    if (hr)
        goto Cleanup;

    pWindow = GetCWindowPtr();
    
    if (pWindow)
    {
        hr = THR(pWindow->SetClipboard(pDO));
    }
    
Cleanup:
    ReleaseInterface(pURLToDrag);
    ReleaseInterface(pDO);
    RRETURN(hr);
}


//+-------------------------------------------------------------------
//
// Members:     URL componenet access helpers
//
// sysnopsis:  [Get/Set]UrlComponentHelper wraps InternetCrackURL
//              the fucntions below all call the helper with diffent
//              component requests:
//              Hash
//              Host
//              search
//              Hostname
//              pathname
//              port
//              protocol
//--------------------------------------------------------------------
#define URL_COMPONENT_FLAGS  (ICU_DECODE | URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE)

HRESULT
CHyperlink::get_host(BSTR *pstr)
{
    RRETURN(SetErrorInfo(GetUrlComponent(pstr, URLCOMP_HOST, 
                NULL, URL_COMPONENT_FLAGS)));
}

HRESULT
CHyperlink::put_host(BSTR str)
{
    RRETURN(SetErrorInfo(SetUrlComponent(str, URLCOMP_HOST)));
}

HRESULT
CHyperlink::get_hostname(BSTR *pstr)
{
    RRETURN(SetErrorInfo(GetUrlComponent(pstr, URLCOMP_HOSTNAME, 
                NULL, URL_COMPONENT_FLAGS)));
}

HRESULT
CHyperlink::put_hostname(BSTR str)
{
    RRETURN(SetErrorInfo(SetUrlComponent(str, URLCOMP_HOSTNAME)));
}

HRESULT
CHyperlink::get_pathname(BSTR *pstr)
{
    RRETURN(SetErrorInfo(GetUrlComponent(pstr, URLCOMP_PATHNAME, 
                NULL, URL_COMPONENT_FLAGS)));
}

HRESULT
CHyperlink::put_pathname(BSTR str)
{
    RRETURN(SetErrorInfo(SetUrlComponent(str, URLCOMP_PATHNAME)));
}

HRESULT
CHyperlink::get_port(BSTR *pstr)
{
    RRETURN(SetErrorInfo(GetUrlComponent(pstr, URLCOMP_PORT, 
                NULL, URL_COMPONENT_FLAGS)));
}

HRESULT
CHyperlink::put_port(BSTR str)
{
    RRETURN(SetErrorInfo(SetUrlComponent(str, URLCOMP_PORT)));
}

HRESULT
CHyperlink::get_protocol(BSTR *pstr)
{
     RRETURN(SetErrorInfo(GetUrlComponent(pstr, URLCOMP_PROTOCOL, 
                NULL, URL_COMPONENT_FLAGS)));
}

HRESULT
CHyperlink::put_protocol(BSTR str)
{
    RRETURN(SetErrorInfo(SetUrlComponent(str, URLCOMP_PROTOCOL)));
}

HRESULT
CHyperlink::get_search(BSTR *pstr)
{
    RRETURN(SetErrorInfo(GetUrlComponent(pstr, URLCOMP_SEARCH, 
                NULL, URL_COMPONENT_FLAGS)));
}

HRESULT
CHyperlink::put_search(BSTR str)
{
    RRETURN(SetErrorInfo(SetUrlComponent(str, URLCOMP_SEARCH)));
}

HRESULT
CHyperlink::get_hash(BSTR *pstr)
{
    RRETURN(SetErrorInfo(GetUrlComponent(pstr, URLCOMP_HASH, 
                NULL, URL_COMPONENT_FLAGS)));
}

HRESULT
CHyperlink::put_hash(BSTR str)
{
    RRETURN(SetErrorInfo(SetUrlComponent(str, URLCOMP_HASH)));
}

STDMETHODIMP
CHyperlink::get_href(BSTR * p)
{
    RRETURN(SetErrorInfo(GetUrlComponent(p, URLCOMP_WHOLE, 
                NULL, URL_COMPONENT_FLAGS)));
}

STDMETHODIMP
CHyperlink::put_href(BSTR v)
{
    RRETURN(SetErrorInfo(SetUrlComponent(v, URLCOMP_WHOLE)));
}

//+-----------------------------------------------------------
//
//  Member  : GetUrlComponenet
//
//  Synopsis    : return a componenet of the href
//              the OM calls to this always fill in a BSTR and 
//                   a NULL ppchurl and require no processing, 
//                   merely the componenet spliting
//              internal calls to this are the opposite and 
//                   are processed (expamded, encoded and then split)
//              this functin is written so that it returns one
//                   or the other of these, but not both. I always
//                   test just one of the pair for consistency.
//              if you make changes to get/set/shortcut make sure to 
//                  make the changes to their clones in CAnchorElemnt
//-----------------------------------------------------------

HRESULT
CHyperlink::GetUrlComponent(BSTR     * pstrComp, 
                  URLCOMP_ID ucid, 
                  TCHAR   ** ppchUrl,
                  DWORD      dwFlags)
{
    HRESULT  hr = S_OK;
    TCHAR  * pchTheHref = (TCHAR*)GetUrl();
    TCHAR   cBuf[pdlUrlLen];
    TCHAR  * pchNewUrl  = cBuf;

    // make sure we have at least one place to return a value
    Assert(!(pstrComp && ppchUrl));
    if (!pstrComp && !ppchUrl)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (ppchUrl)
        *ppchUrl = NULL;
    else
        *pstrComp = NULL;

    if (!pchTheHref)
        goto Cleanup;

    // get the expanded string 
    hr = THR(CMarkup::ExpandUrl(GetMarkup(), pchTheHref, ARRAY_SIZE(cBuf), pchNewUrl, this, dwFlags));

    // don't bail out if OM set has occured and OM is asking for the component.
    if (hr && (!_fOMSetHasOccurred || ppchUrl))
        goto Cleanup;

    // if asking for whole thing, just set return param
    if (ucid == URLCOMP_WHOLE)
    {
        if (ppchUrl)
        {
            MemAllocString(Mt(CHyperlinkGetUrlComponent), pchNewUrl, ppchUrl);
        }
        else
        {
            *pstrComp = (_fOMSetHasOccurred) ? SysAllocString(pchTheHref) :
                               SysAllocString(pchNewUrl);
            hr = (!*pstrComp) ? E_OUTOFMEMORY : S_OK;
        }
    }
    else
    {
        // we want a piece, so split it up.
        CStr cstrComponent; 
        // we need to use TheHref when a set has happened. but when hash/search
        //  is requested we NEED to crack the url properly, so we need to use
        //  pchNewUrl.
        BOOL fUseTheHref = _fOMSetHasOccurred && ((ucid != URLCOMP_HASH) && 
                              (ucid != URLCOMP_SEARCH));

        // bail out if we have to use expanded Url, but the Combine failes and we are
        // here because an OM set has already occured and an OM get is happening now.
        if (!fUseTheHref && hr)
            goto Cleanup;

        if (!pchNewUrl || pchNewUrl[0]==NULL || 
            (_fOMSetHasOccurred && (!pchTheHref || pchTheHref[0]==NULL)))
            goto Cleanup;

        hr = THR(GetUrlComponentHelper((fUseTheHref ? pchTheHref: pchNewUrl), 
                        &cstrComponent, 
                        dwFlags, 
                        ucid));
        if (hr == E_FAIL)
        {
            hr = S_OK;
            goto Cleanup;
        }


        if (ppchUrl)
        {
            if (cstrComponent)
            {
                hr = THR(MemAllocString(Mt(CHyperlinkGetUrlComponent),
                            cstrComponent, ppchUrl));
            }
            else
                *ppchUrl = NULL;
        }
        else
        {
            hr = THR(cstrComponent.AllocBSTR(pstrComp));
        }

    }

Cleanup:

    RRETURN (hr);
}

//+-----------------------------------------------------------
//
//  Member  : SetUrlComponenet
//
//  Synopsis    : field the various component setting requests
//
//-----------------------------------------------------------

HRESULT
CHyperlink::SetUrlComponent(const BSTR bstrComp, URLCOMP_ID ucid)
{
    HRESULT     hr=S_OK;
    TCHAR       achUrl[pdlUrlLen];
    TCHAR     * pchTheHref = NULL;

    // if set_href, just set it
    if (ucid == URLCOMP_WHOLE)
    {
        hr = THR(SetUrl(bstrComp));
    }
    else
    {
        // get the old url
        hr = THR(GetUrlComponent(NULL, URLCOMP_WHOLE, &pchTheHref, 
                     ICU_DECODE));
        if (hr || !pchTheHref)
            goto Cleanup;

        // expand it if necessary
        if ((ucid != URLCOMP_HASH) && (ucid != URLCOMP_SEARCH))
        {
            // and set the appropriate component
            hr = THR(SetUrlComponentHelper(pchTheHref,
                           achUrl,
                           ARRAY_SIZE(achUrl),
                           &bstrComp,
                           ucid));
        }
        else
        {
            hr = THR(ShortCutSetUrlHelper(pchTheHref,
                       achUrl,
                       ARRAY_SIZE(achUrl),
                       &bstrComp,
                       ucid));
        }
        if (hr)
            goto Cleanup;

        hr = THR(SetUrl((BSTR)achUrl));
    }
                        

Cleanup:
    if (pchTheHref)
        MemFreeString(pchTheHref);

    RRETURN(hr);
}

HRESULT CHyperlink::ClickAction(CMessage *pmsg)
{
    HRESULT         hr = S_OK;

    // Disable this feature, because this breaks compat. with IE$, where
    // Shift+Click causes the navigation to occur in a new browser window.
#ifdef NEVER
    // Shift+Click should do 'SaveAs'
    if (pmsg && pmsg->message == WM_LBUTTONUP && (pmsg->dwKeyState & FSHIFT))
    {
        MSOCMD cmd;

        cmd.cmdID = IDM_SAVETARGET;
        cmd.cmdf  = 0;

        hr = QueryStatusHelper((GUID *)&CGID_MSHTML, 1, &cmd, NULL, TRUE);
        if (hr == S_OK && cmd.cmdf != 0 && cmd.cmdf != MSOCMDSTATE_DISABLED)
        {
            hr = ExecHelper((GUID *)&CGID_MSHTML, cmd.cmdID, 0, NULL, NULL, FALSE);
        }

    }
    else
#endif
    {
        const TCHAR *   pchUrl = GetUrl();

        // This used to not hyperlink if the HREF was "".  For compatibility
        // with Navigator, we need to hyperlink even in that case.  The only
        // time we don't want to hyperlink is if the HREF is not supplied at all.

        if (pchUrl)
        {
            CDoc *  pDoc                = Doc();
            BOOL    fUseNewWindow       = (pmsg && pmsg->message != WM_MOUSEWHEEL)
                                            ? !!(pmsg->dwKeyState & MK_SHIFT)
                                            : FALSE;
            COmWindowProxy *pWindow = NULL;
            CWindow *pWindowParent;
            Assert(pDoc);

            while (pDoc->_fScriptletDoc)
            {
                Assert(pDoc->_pWindowPrimary);
                Assert(pDoc->_pWindowPrimary->Window());
                pWindowParent = pDoc->_pWindowPrimary->Window()->_pWindowParent;
                if (pWindowParent)
                {
                    pWindow = pWindowParent->Markup()->Window();
                    pDoc = pWindowParent->Doc();
                }
                else
                    break;
                    
                Assert(pDoc);
            }

            hr = THR(pDoc->FollowHyperlink(     /* formal arg name  */
                                pchUrl,         /* pchURL           */
                                GetTarget(),    /* pchTarget        */
                                this,           /* pElementContext  */
                                NULL,           /* pDwnPost         */
                                FALSE,          /* fSendAsPost      */
                                NULL,           /* pchExtraHeaders  */
                                FALSE        ,  /* fOpenInNewWindow */
                                pWindow,        /* pWindow          */
                                NULL,           /* ppWindowOut      */
                                0,              /* dwBindf          */
                                ERROR_SUCCESS,  /* dwSecurityCode   */
                                FALSE,          /* fReplace         */
                                NULL,           /* ppHTMLWindow2    */
                                fUseNewWindow,  /* fOpenInNewBrowser*/
                                CDoc::FHL_HYPERLINKCLICK | CDoc::FHL_SETDOCREFERER
                           ));
        }
    }
    RRETURN1(hr, S_FALSE);
}

//+--------------------------------------------------------------------------
//
//  Method :    CHyperlink::GetHyperlinkCursor
//
//  Synopsis :  Get cursor based on offline state and cache
//
//---------------------------------------------------------------------------

extern BOOL IsGlobalOffline();

LPTSTR
CHyperlink::GetHyperlinkCursor()
{
    if (!IsGlobalOffline())
        return MAKEINTRESOURCE(IDC_HYPERLINK);

    if (!_fAvailableOfflineValid)
    {
        _fAvailableOffline = Doc()->IsAvailableOffline(GetUrl(), this);
        _fAvailableOfflineValid = TRUE;
    }

    return _fAvailableOffline ? MAKEINTRESOURCE(IDC_HYPERLINK) : MAKEINTRESOURCE(IDC_HYPERLINK_OFFLINE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CHyperlink::QueryStatusHelper
//
//  Synopsis:   Implements QueryStatus for CHyperlink
//
//----------------------------------------------------------------------------

HRESULT
CHyperlink::QueryStatusHelper(
        GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    int idm;

    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));
    Assert(cCmds == 1);

    MSOCMD *        pCmd    = &rgCmds[0];
    HRESULT         hr      = S_OK;
    const TCHAR *   pchUrl  = GetUrl();

    Assert(!pCmd->cmdf);

    idm = CBase::IDMFromCmdID(pguidCmdGroup, pCmd->cmdID);
    switch (idm)
    {
    case IDM_FOLLOWLINKC:
    case IDM_FOLLOWLINKN:
    case IDM_PRINTTARGET:
    case IDM_SAVETARGET:

        // Plug a ratings security hole.
        if ((idm == IDM_PRINTTARGET || idm == IDM_SAVETARGET) &&
            S_OK == AreRatingsEnabled())
        {
            pCmd->cmdf = MSOCMDSTATE_DISABLED;
            break;
        }

        // Enable "Open->In Current Window"; enable "Open->In New Window"
        //  if protocol is not "mailto:"
        // Note: We don't need to call ExpandUrl() here
        if (pchUrl && (idm == IDM_FOLLOWLINKC ||
                        !_tcsnipre(_T("mailto:"), 7, pchUrl, -1)))
        {
            pCmd->cmdf = MSOCMDSTATE_UP;
        }
        break;
    case IDM_ADDFAVORITES:
    case IDM_COPYSHORTCUT:
        if (pchUrl)
        {
            pCmd->cmdf = MSOCMDSTATE_UP;
        }
        break;
    case IDM_CUT:
        // Enable if script wants to handle it, otherwise leave it to default
        if (!Fire_onbeforecut())
        {
            pCmd->cmdf = MSOCMDSTATE_UP;
        }
        break;
    case IDM_COPY:
        // Enable if script wants to handle it, otherwise leave it to default
        if (!Fire_onbeforecopy())
        {
            pCmd->cmdf = MSOCMDSTATE_UP;
        }
        break;
    case IDM_PASTE:
        // Enable if script wants to handle it, otherwise leave it to default
        if (!Fire_onbeforepaste())
        {
            pCmd->cmdf = MSOCMDSTATE_UP;
        }
        break;
    }

    RRETURN_NOTRACE(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHyperlink::ExecHelper
//
//  Synopsis:   Executes a command on the CHyperlink
//
//----------------------------------------------------------------------------

HRESULT
CHyperlink::ExecHelper(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));

    int             idm             = CBase::IDMFromCmdID(pguidCmdGroup, nCmdID);
    HRESULT         hr              = MSOCMDERR_E_NOTSUPPORTED;
    const TCHAR *   pchUrl          = GetUrl();
    TCHAR   cBuf[pdlUrlLen];
    TCHAR *         pchExpandedUrl  = cBuf;

    switch (idm)
    {
    case IDM_FOLLOWLINKC:
    case IDM_FOLLOWLINKN:
    case IDM_SAVETARGET:
    case IDM_PRINTTARGET:
    {
        if (pchUrl && !_tcsnipre(_T("mailto:"), 7, pchUrl, -1))
        {
            CDoc *  pDoc = Doc();

            if ((idm == IDM_PRINTTARGET) || (idm == IDM_SAVETARGET))
            {
                // Plug a ratings security hole.
                if (S_OK == AreRatingsEnabled())
                {
                    Assert(hr == MSOCMDERR_E_NOTSUPPORTED);
                    break;
                }

                hr = THR(CMarkup::ExpandUrl(NULL, pchUrl, ARRAY_SIZE(cBuf), pchExpandedUrl, this));

                if (hr == S_OK)
                {
                    if (idm == IDM_PRINTTARGET)
                    {
                        hr = pDoc->PrintHandler(Document(), NULL, pchExpandedUrl);
                    }
                    else    // IDM_SAVETARGET
                        hr = DoFileDownLoad(pchExpandedUrl);
                    if (hr == S_OK)
                    {
                        IGNORE_HR(SetVisited());
                    }

                }
            }
            else
            {
                hr = THR(pDoc->FollowHyperlink(
                            pchUrl,                 // pchURL
                            GetTarget(),            // pchTarget
                            this,                   // pElementContext
                            NULL,                   // pDwnPost
                            FALSE,                  // fSendAsPost
                            NULL,                   // pchExtraHeaders
                            FALSE,                  // fOpenInNewWindow
                            NULL,                   // pWindow
                            NULL,                   // ppWindowOut
                            0,                      // dwBindOptions
                            ERROR_SUCCESS,          // dwSecurityCode
                            FALSE,                  // fReplace
                            NULL,                   // ppHTMLWindow2
                            idm == IDM_FOLLOWLINKN, // fOpenInNewBrowser
                            CDoc::FHL_HYPERLINKCLICK | CDoc::FHL_SETDOCREFERER
                            )
                        );
            }
        }
        break;
    }

    case IDM_COPYSHORTCUT:
        if (pchUrl)
            hr = THR(CopyLinkToClipboard());
        break;

    case IDM_ADDFAVORITES:
        if (pchUrl)
        {
            CStr strUrlTitle;
            CDoc *  pDoc = Doc();

            hr = THR(CMarkup::ExpandUrl(NULL, pchUrl, ARRAY_SIZE(cBuf), pchExpandedUrl, this));
            if (hr)
                goto Cleanup;
            IGNORE_HR(GetUrlTitle(&strUrlTitle));
            hr = pDoc->AddToFavorites(pchExpandedUrl, strUrlTitle);
        }
        break;
    case IDM_CUT:
        if (!Fire_oncut())
            hr = S_OK;
        break;
    case IDM_COPY:
        if (!Fire_oncopy())
            hr = S_OK;
        break;
    case IDM_PASTE:
        if (!Fire_onpaste())
            hr = S_OK;
        break;
    }

Cleanup:
    RRETURN_NOTRACE(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscelem\generic.cxx ===
//+---------------------------------------------------------------------
//
//  File:       generic.cxx
//
//  Contents:   Extensible tags classes
//
//  Classes:    CGenericElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_GENERIC_HXX_
#define X_GENERIC_HXX_
#include "generic.hxx"
#endif

#ifndef X_HTC_HXX_
#define X_HTC_HXX_
#include "htc.hxx"
#endif

#ifndef X_XMLNS_HXX_
#define X_XMLNS_HXX_
#include "xmlns.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx" // for CStreamWriteBuf
#endif

#ifndef X_DMEMBMGR_HXX_
#define X_DMEMBMGR_HXX_
#include "dmembmgr.hxx"       // for CDataMemberMgr
#endif

#ifndef X_DBTASK_HXX_
#define X_DBTASK_HXX_
#include "dbtask.hxx"       // for CDataBindTask
#endif

#ifndef X_LRREG_HXX_
#define X_LRREG_HXX_
#include "lrreg.hxx"       // for CLayoutRectRegistry
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif // X_PEER_HXX_

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif // X_PEERXTAG_HXX_

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_PEERMGR_HXX_
#define X_PEERMGR_HXX_
#include "peermgr.hxx"
#endif

#define _cxx_
#include "generic.hdl"


#include "complus.h"

MtDefine(CGenericElement, Elements, "CGenericElement")

///////////////////////////////////////////////////////////////////////////
//
// misc
//
///////////////////////////////////////////////////////////////////////////

const CElement::CLASSDESC CGenericElement::s_classdesc =
{
    {
        &CLSID_HTMLGenericElement,          // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_XTAG
#ifdef V4FRAMEWORK
        | ELEMENTDESC_NOTIFYENDPARSE
#endif
        ,                                   // _dwFlags
        &IID_IHTMLGenericElement,           // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnIHTMLGenericElement,      //_apfnTearOff

    NULL                                    // _pAccelsRun
};

///////////////////////////////////////////////////////////////////////////
//
// CGenericElement methods
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Method:     CGenericElement::CreateElement
//
//-------------------------------------------------------------------------

HRESULT CGenericElement::CreateElement(
    CHtmTag *  pht,
    CDoc *      pDoc,
    CElement ** ppElement)
{
    HRESULT hr = S_OK;

    Assert(ppElement);

    *ppElement = new CGenericElement(pht, pDoc);
    if (!*ppElement)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

#ifdef V4FRAMEWORK
    hr = ((CGenericElement*)*ppElement)->CreateComPlusObjectLink();
    if ( hr )
        goto Cleanup;
#endif

Cleanup:
    return hr;;
}

//+------------------------------------------------------------------------
//
//  Method:     CGenericElement constructor
//
//-------------------------------------------------------------------------

CGenericElement::CGenericElement (CHtmTag * pht, CDoc * pDoc)
  : CElement(pht->GetTag(), pDoc)
{
    LPTSTR  pchColon;
    LPTSTR  pchStart;

    Assert(IsGenericTag(pht->GetTag()));
    Assert(pht->GetPch());

    if (pht->GetPch())
    {
        pchColon = StrChr(pht->GetPch(), _T(':'));
        if (pchColon)
        {
            pchStart = pht->GetPch();

            IGNORE_HR(_cstrNamespace.Set(pchStart, PTR_DIFF(pchColon, pchStart)));
            IGNORE_HR(_cstrTagName.Set(pchColon + 1));
        }
        else
        {
            IGNORE_HR(_cstrTagName.Set(pht->GetPch()));
        }
    }

#ifdef ATOMICGENERIC
    _fAttemptAtomicSave = pht->IsEmpty();
#endif // ATOMICGENERIC
}

#ifdef V4FRAMEWORK
void CGenericElement::Passivate()
{
    COMPLUSREF lVal;
    IExternalDocument *pFactory;
    HRESULT hr;

    pFactory = GetFrameworkDocAndElem(&lVal);
    if (!pFactory)
    {
        AssertSz(false, "~GenericElement() External Factory gone");
        goto Cleanup;
    }

    hr = THR(pFactory->ReleaseProxy((long)lVal));

Cleanup:
    super::Passivate();
}
#endif V4FRAMEWORK


#ifdef V4FRAMEWORK
HRESULT CGenericElement::PutComPlusReference ( COMPLUSREF lVal )
{
    return AddSimple(DISPID_INTERNAL_GENERICCOMPLUSREF, (DWORD)lVal, CAttrValue::AA_Internal);

}

HRESULT CGenericElement::GetComPlusReference ( COMPLUSREF *plVal )
{
    return GetSimpleAt (FindAAIndex (DISPID_INTERNAL_GENERICCOMPLUSREF, CAttrValue::AA_Internal), (DWORD *)plVal );
}
#endif V4FRAMEWORK

//+------------------------------------------------------------------------
//
//  Method:     CGenericElement::Init2
//
//-------------------------------------------------------------------------

HRESULT
CGenericElement::Init2(CInit2Context * pContext)
{
    HRESULT     hr;
    LPTSTR      pchNamespace;

    hr = THR(super::Init2(pContext));
    if (hr)
        goto Cleanup;

    if (pContext)
    {
        pchNamespace = (LPTSTR) Namespace();

        if (pchNamespace && pContext->_pTargetMarkup)
        {
            CXmlNamespaceTable *    pNamespaceTable = pContext->_pTargetMarkup->GetXmlNamespaceTable();
            LONG                    urnAtom;

            if (pNamespaceTable) // (we might not have pNamespaceTable if the namespace if "PUBLIC:")
            {
                hr = THR(pNamespaceTable->GetUrnAtom(pchNamespace, &urnAtom));
                if (hr)
                    goto Cleanup;

                if (-1 != urnAtom)
                {
                    hr = THR(PutUrnAtom(urnAtom));
                }
            }
        }
    }


Cleanup:
    RRETURN (hr);
}

#ifdef V4FRAMEWORK

class CExternalCOMPlusPeerHolder : public CPeerHolder
{
public:
    CExternalCOMPlusPeerHolder ( CElement *pElem ) : CPeerHolder (pElem){}
    HRESULT GetSize(LONG    lFlags,
                       SIZE    sizeNatural,
                       POINT * pPtTranslate,
                       POINT * pPtTopLeft,
                       SIZE  * psizeProposed);
};


HRESULT CExternalCOMPlusPeerHolder::GetSize(LONG    lFlags,
                   SIZE    sizeNatural,
                   POINT * pPtTranslate,
                   POINT * pPtTopLeft,
                   SIZE  * psizeProposed)
{
    IExternalDocument *pFactory = NULL;
    CGenericElement::COMPLUSREF cpRef;
    HRESULT hr;

    hr = ((CGenericElement*)_pElement)->GetComPlusReference ( &cpRef );
    if ( hr )
        goto Cleanup;

    pFactory = _pElement->Doc()->EnsureExternalFrameWork();
    if (!pFactory)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pFactory->GetSize ( (long)cpRef, lFlags,
        sizeNatural.cx, sizeNatural.cy,
        &pPtTranslate->x, &pPtTranslate->y,
        &pPtTopLeft->x, &pPtTopLeft->y,
        &psizeProposed->cx, &psizeProposed->cy ));
Cleanup:
    RRETURN(hr);
}

#endif V4FRAMEWORK


#ifdef V4FRAMEWORK
HRESULT CGenericElement::CreateComPlusObjectLink()
{
    HRESULT hr = S_OK;
    IExternalDocument *pFactory = NULL;
    COMPLUSREF lRef;
    BSTR bstrTagName;
    CPeerHolder *pH;

    // CoCreate the MSUI factory object
    pFactory = Doc()->EnsureExternalFrameWork();
    if (!pFactory)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(FormsAllocString( (TCHAR*)_cstrTagName,
        &bstrTagName ) );
    if (hr)
        goto Cleanup;


    // Hand out pointer to Element Site
    hr = pFactory->CreateElement ( bstrTagName, (long)this, &lRef );
    if (hr)
        goto Cleanup;

    //Store away the reference
    hr = PutComPlusReference ( lRef );
    if (hr)
        goto Cleanup;

    // Increment the count on the framework site, decremented when the external element is destroyed
    Doc()->_extfrmwrkSite.lExternalElems++;

    // Create call implicetly creates a strong ref on the newly created object

    // Artificialy AddRef ourselves - COMPlus object behaves as a strong ref
    AddRef();

    pH = new CExternalCOMPlusPeerHolder(this);
    pH->_pLayoutBag = new CPeerHolder::CLayoutBag();
    pH->_pLayoutBag->_lLayoutInfo = 0; // Gets set by CExternalFrameworkSite::SetLongRenderProperty ()
    SetPeerHolder(pH);

Cleanup:
    FormsFreeString(bstrTagName);
    return hr;
}
#endif V4FRAMEWORK

#ifdef V4FRAMEWORK
HRESULT CGenericElement::ChangeRefComPlusObject( BOOL fStrongNotWeak )
{
    IExternalDocument *pFactory = NULL;
    HRESULT hr;
    COMPLUSREF cpRef;

    hr = GetComPlusReference ( &cpRef );
    if ( hr )
        goto Cleanup;

    pFactory = Doc()->EnsureExternalFrameWork();
    if (!pFactory)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if ( fStrongNotWeak )
    {
        hr = pFactory ->StrongRefElement ( (long)cpRef );
    }
    else
    {
        hr = pFactory ->WeakRefElement ( (long)cpRef );
    }

Cleanup:
    return hr;
}
#endif V4FRAMEWORK


#ifdef V4FRAMEWORK
ULONG
CGenericElement::PrivateAddRef()
{
    CMarkup * pMarkup = NULL;
    BOOL fStrongRef = FALSE;

    if( _ulRefs == 2 && IsInMarkup() )
    {
        Assert( GetMarkupPtr() );
        pMarkup = GetMarkupPtr();
    }

    if ( _ulRefs == 1 )
        fStrongRef = TRUE;

    // Skip CElement deliberately
    ULONG ulRet = CBase::PrivateAddRef();

    if ( fStrongRef )
    {
        StrongRefComPlusObject();
    }

    if ( pMarkup )
    {
        pMarkup ->AddRef();
    }

    return ulRet;
}
#endif V4FRAMEWORK

#ifdef V4FRAMEWORK
void
CGenericElement::PrivateExitTree( CMarkup * pMarkupOld)
{
    BOOL fReleaseMarkup = _ulRefs > 2; // 1 from tree, 1 from COMPlus element
    BOOL fWeakRef = FALSE;

    Assert( ! IsInMarkup() );
    Assert( pMarkupOld );


    if (_ulRefs == 2)
    {
        // Only COM+ artificial AddRef() keeping object alive
        fWeakRef = TRUE;
    }

    // If we sent the EXITTREE_PASSIVATEPENDING bit then we
    // must also passivate right here.
    //AssertSz( !_fPassivatePending || _ulRefs == 2,
    //    "EXITTREE_PASSIVATEPENDING set and element did not passivate.  Talk to JBeda." );

    CBase::PrivateRelease();

    if ( fReleaseMarkup )
    {
        pMarkupOld->Release();
    }

    if ( fWeakRef )
    {
        // Takes off the strong ref on the COM+ object, COMPlus object will go away eventually when it's
        // external refs drop to Zero, then Finalize() on COM+ object will call back to us
        // to remove the artificial AddRef() applied in CreateComPlusObjectLink*(
        WeakRefComPlusObject();
    }

}
#endif V4FRAMEWORK

#ifdef V4FRAMEWORK
ULONG
CGenericElement::PrivateRelease()
{
    CMarkup * pMarkup = NULL;
    BOOL fWeakRef = FALSE;

    if(_ulRefs == 3 && IsInMarkup())
    {
        // Last External COM Classic Reference is being removed on element
        pMarkup = GetMarkupPtr();
    }

    if (_ulRefs == 2)
    {
        // Only COM+ artificial AddRef() keeping object alive
        fWeakRef = TRUE;
    }

    // Skip CElement deliberately
    ULONG ret =  CBase::PrivateRelease();

    if( pMarkup )
    {
        pMarkup->Release();
    }

    if ( fWeakRef )
    {
        // Takes off the strong ref on the COM+ object, COMPlus object will go away eventually when it's
        // external refs drop to Zero, then Finalize() on COM+ object will call back to us
        // to remove the artificial AddRef() applied in CreateComPlusObjectLink*(
        WeakRefComPlusObject();
    }
    return ret;
}
#endif V4FRAMEWORK

#ifdef V4FRAMEWORK


HRESULT
CGenericElement::InitAttrBag(CHtmTag *pht, CMarkup * pMarkup)
{
    // Tag the Tag Stream & hand it off to the element
    BSTR bstrPackedAttributeArray;
    HRESULT hr;
    IExternalDocument *pFactory;
    COMPLUSREF cpr;

    pFactory = GetFrameworkDocAndElem(&cpr);
    if (!pFactory)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pht->ToBSTR ( &bstrPackedAttributeArray );
    if ( hr )
        goto Cleanup;

    hr = pFactory->InitAttributes ( (long)cpr, bstrPackedAttributeArray );
    if ( hr )
        goto Cleanup;

Cleanup:
    FormsFreeString(bstrPackedAttributeArray);
    RRETURN(hr);
}

void CGenericElement::OnEnterTree(DWORD_PTR dwAsynch)
{
    IExternalDocument *pFactory;
    COMPLUSREF cpr;

    pFactory = GetFrameworkDocAndElem(&cpr);
    if (!pFactory)
        return;

    if ((BOOL)dwAsynch)
        IGNORE_HR(pFactory->OnEnterTreeAsynch((long)cpr));
    else
        IGNORE_HR(pFactory->OnEnterTree((long)cpr));
}

void CGenericElement::OnExitTree(DWORD_PTR dwAsynch)
{
    IExternalDocument *pFactory;
    COMPLUSREF cpr;

    pFactory = GetFrameworkDocAndElem(&cpr);
    if (!pFactory)
        return;

    if ((BOOL)dwAsynch)
        IGNORE_HR(pFactory->OnExitTreeAsynch((long)cpr));
    else
        IGNORE_HR(pFactory->OnExitTree((long)cpr));
}

#endif V4FRAMEWORK

//+------------------------------------------------------------------------
//
//  Method:     CGenericElement::Notify
//
//-------------------------------------------------------------------------

void
CGenericElement::Notify(CNotification *pnf)
{
    CMarkup *pMarkup;
    Assert(pnf);

    super::Notify(pnf);

    switch (pnf->Type())
    {
    case NTYPE_ELEMENT_ENTERTREE:

        pMarkup = GetMarkup();
        if (pMarkup->HasBehaviorContext() && Tag() == ETAG_GENERIC_BUILTIN)
        {
            CHtmlComponent *pComponent = pMarkup->BehaviorContext()->_pHtmlComponent;
            if (pComponent && !pComponent->Dirty())
            {
                if ((pMarkup->_LoadStatus >= LOADSTATUS_QUICK_DONE || pMarkup->GetWindowedMarkupContext()->GetWindowPending()->Window()->IsInScript()) &&
                    (TagNameToHtcBehaviorType(TagName()) & HTC_BEHAVIOR_PROPERTYORMETHODOREVENT))
                {
                    if (pComponent->_fFirstInstance)
                        pComponent->_pConstructor->_pFactoryComponent->_fDirty = TRUE;
                    else
                        pComponent->_fDirty = TRUE;
                }
                else if (GetName() &&
                         !pComponent->_fFactoryComponent &&
                         pComponent->_fFirstInstance &&
                         (TagNameToHtcBehaviorType(TagName()) & HTC_BEHAVIOR_PROPERTYORMETHOD))
                {
                    Assert(pComponent->_pConstructor);
                    Assert(pComponent->_pConstructor->_pFactoryComponent);
                    CHtmlComponent *pFactory = pComponent->_pConstructor->_pFactoryComponent;
                    Assert(pFactory);
                    Assert(StrCmpC(GetName(), GetExpandoString(this, _T("name"))) == 0);
                    // CONSIDER: any way to get the source index passed in at Enter Tree time?
                    pFactory->AddAtom(GetName(), LongToPtr(GetSourceIndex() + HTC_PROPMETHODNAMEINDEX_BASE));
                }
            }
        }

        // the <XML> tag can act as a data source for databinding.  Whenever such
        // a tag is added to the document, we should tell the databinding task
        // to try again.  Something might work now that didn't before.
        if (0 == FormsStringCmp(TagName(), _T("xml")))
        {
            pMarkup->GetDataBindTask()->SetWaiting();
        }
        // MULTI_LAYOUT
        // Semi-hack: when layout rect elements enter the tree, they need to participate
        // in hooking up to view chains.  This participation has 2 aspects:
        // 1) A layout rect may have an ID that matches a desired target ID (as
        // stored in the layout rect registry).  We need to see whether such a match
        // exists, and do the necessary hookup.
        // 2) A layout rect may have a nextRect attribute that identifies a target element
        // for overflowing content.  That target element may or may not currently be
        // in the tree; if it is, we can do the hookup here, otherwise we need to store
        // ourselves and and the target's ID in the layout rect registry so that if/when
        // an appropriate target enters the tree, the hookup can be done.
        // Why semi-hack?  We may want a better mechanism for this kind of
        // notification (ie, notifying an element when some other element
        // enters the tree), but this isn't really so bad.
        // Known limitations: consider the case where an existing viewchain
        // loses its head (ie the element w/ the contentSrc attr is removed).
        // The viewchain will remain, but will be ownerless.
        // If we then add a new layout rect w/ a contentSrc, and a nextRect
        // that hooks it up to the existing layout rects, we will not
        // behave correctly; what we'd like is to have 1 viewchain, but
        // instead we'll have 2 -- 1 that has just the head, and 1 that's
        // headless.  This is not a compelling scenario to enable for print
        // preview, but will be required if we expose view templates more
        // generally.
        else if ( IsLinkedContentElement() )
        {
            HRESULT   hr;
            CVariant  cvarNextRect;
            LPCTSTR   pszID = GetAAid();
            CElement *pSrcElem = NULL;

            Assert(pMarkup);

            // Do we have an ID?
            if ( pszID )
            {
                // yes, so find the element (if any) that's waiting for us.
                pSrcElem = pMarkup->GetLayoutRectRegistry()->GetElementWaitingForTarget( pszID );
            }

            // Is there an element waiting for a nextRect of our ID?
            if ( pSrcElem )
            {
                // yes, so hook us up.
                ConnectLinkedContentElems( pSrcElem, this );
                // src elem was subref'ed when its entry in the registry was
                // created
                pSrcElem->SubRelease();
                RemeasureElement(NFLAGS_FORCE);
            }

            // Do we have nextRect attribute?  If so we need to do some work.
            hr = GetLinkedContentAttr( _T("nextRect"), &cvarNextRect );
            if ( hr == S_OK )
            {
                // Found a valid nextRect attr
                CElement *pNextElem = GetNextLinkedContentElem();
                if ( pNextElem )
                {
                    // the element pointed to by the nextRect attr
                    // is in the tree, so we can hook it up now.
                    ConnectLinkedContentElems( this, pNextElem );
                    pNextElem->RemeasureElement(NFLAGS_FORCE);
                }
                else
                {
                    // can't find an element in the tree matching
                    // the ID specified by nextRect.  Add an entry
                    // to the layout rect registry so we can be
                    // notified when such an element enters.
                    pMarkup->GetLayoutRectRegistry()->AddEntry( this, (LPTSTR)V_BSTR(&cvarNextRect) );
                }
            }
        }

        //  When printing, we may have persisted the current state of a viewlinked markup.
        if (pMarkup->IsPrintMedia())
        {
            CVariant            cvarURL;
            CPeerMgr *          pPeerMgr;
            CDefaults *         pDefaults;
            CDocument *         pDocument   = pMarkup->Document();
            IHTMLDocument2  *   pIDoc       = NULL;

            if (    pDocument
                &&  PrimitiveGetExpando(_T("__IE_ViewLinkSrc"), &cvarURL) == S_OK
                &&  V_VT(&cvarURL) == VT_BSTR )
            {
                // We have persisted a viewlink.  Load it in...
                if  (   pDocument->createDocumentFromUrlInternal(V_BSTR(&cvarURL), _T("print"), &pIDoc, CDFU_DONTVERIFYPRINT) == S_OK
                     && pIDoc )
                {
                    // ...and viewlink it.
                    if (    CPeerMgr::EnsurePeerMgr(this, &pPeerMgr) == S_OK
                        &&  pPeerMgr->EnsureDefaults(&pDefaults) == S_OK     )
                    {
                        PrimitiveRemoveExpando(_T("__IE_ViewLinkSrc"));
                        pDefaults->put_viewLink(pIDoc);
                    }
                }
            }

            ReleaseInterface(pIDoc);
        }


#ifdef V4FRAMEWORK
        {
            OnEnterTree(FALSE);
            IGNORE_HR(GWPostMethodCall(this, ONCALL_METHOD(CGenericElement, OnEnterTree, onentertree), TRUE, FALSE, "CGenericElement::OnEnterTreeAynch"));
        }
#endif V4FRAMEWORK

        break;

    case NTYPE_DELAY_LOAD_HISTORY:
        {
            if (HasSlavePtr())
            {
                CElement *  pElemSlave = GetSlavePtr();

                if (pElemSlave)
                {
                    Assert(pElemSlave->IsInMarkup());
                    IGNORE_HR(pElemSlave->GetMarkup()->LoadSlaveMarkupHistory());
                }
            }
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        {
            pMarkup = GetMarkup();
            Assert(pMarkup);
            if (pMarkup->HasBehaviorContext() &&
                Tag() == ETAG_GENERIC_BUILTIN &&
                (TagNameToHtcBehaviorType(TagName()) & HTC_BEHAVIOR_PROPERTYORMETHODOREVENT))
            {
                CHtmlComponent *pComponent = pMarkup->BehaviorContext()->_pHtmlComponent;
                if (pComponent)
                    pComponent->_fDirty = TRUE;
            }

#ifdef V4FRAMEWORK
            OnExitTree(FALSE);
            IGNORE_HR(GWPostMethodCall(this, ONCALL_METHOD(CGenericElement, OnExitTree, onexittree), TRUE, FALSE, "CGenericElement::OnExitTreeAynch"));
#endif V4FRAMEWORK
        }
        break;

#ifdef V4FRAMEWORK
    case NTYPE_END_PARSE:
        {
            HRESULT hr;
            IExternalDocument *pFactory;
            COMPLUSREF cpr;
            BSTR bstrContents;

            pFactory = GetFrameworkDocAndElem(&cpr);
            if (!pFactory)
                break;

            if (_cstrContents)
            {
                hr = THR(FormsAllocString((TCHAR*)_cstrContents, &bstrContents));
                if (hr)
                   break;

                // set the literal content.
                IGNORE_HR(pFactory->SetLiteralContent((long)cpr, bstrContents));
                FormsFreeString(bstrContents);
            }

            IGNORE_HR(pFactory->OnContentReady((long)cpr));
        }

        break;
#endif V4FRAMEWORK

    default:
        break;
    }
}

//+------------------------------------------------------------------------
//
//  Method:     CGenericElement::Save
//
//-------------------------------------------------------------------------

HRESULT
CGenericElement::Save (CStreamWriteBuff * pStreamWriteBuff, BOOL fEnd)
{
    HRESULT     hr;
    DWORD       dwOldFlags;
    CMarkup *   pMarkup = GetMarkup();
    CDoc *      pDoc = Doc();
    BOOL        fSavedViewlink  = FALSE;
    BOOL        fExpando        = FALSE;
#ifdef ATOMICGENERIC
    BOOL        fAtomicSave = FALSE;

    // Determine if we should do an atomic save
    if( _fAttemptAtomicSave         &&
        !_cstrContents.Length() )
    {
        CTreePos * ptpBegin;
        CTreePos * ptpEnd;

        //
        // See if there is anything inside us besides pointer pos's
        //
        GetTreeExtent( &ptpBegin, &ptpEnd );
        while( ptpBegin->NextTreePos() != ptpEnd )
        {
            // TODO (JHarding): This won't see text frags.
            if( !ptpBegin->NextTreePos()->IsPointer() )
                break;

            ptpBegin = ptpBegin->NextTreePos();
        }

        fAtomicSave = ( ptpBegin->NextTreePos() == ptpEnd );
    }
#endif // ATOMICGENERIC

    //
    // For printing, persist out the current state of any viewlinked markup
    //
    if (    pDoc
        &&  pMarkup
        &&  pDoc->_fSaveTempfileForPrinting
        &&  !fEnd
        &&  HasSlavePtr())
    {
        CMarkup * pSlaveMarkup = GetSlavePtr()->GetMarkup();
        if( pSlaveMarkup ) // && pSlaveMarkup->GetReadyState() >= READYSTATE_LOADED )
        {
            TCHAR   achTempLocation[pdlUrlLen];

            _tcscpy(achTempLocation, _T("file://"));

            Assert(pdlUrlLen >= MAX_PATH + 7);

            // Obtain a temporary file name
            if (pDoc->GetTempFilename( _T("\0"), _T("htm"), ((TCHAR *)achTempLocation)+7 ) )
            {
                VARIANT varProp;

                // Save the submarkup
                hr = THR( pSlaveMarkup->Save(((TCHAR *)achTempLocation)+7, FALSE) );

                fExpando = pMarkup->_fExpando;
                pMarkup->_fExpando = TRUE;

                // Set an attribute so that we can relink the markup on the print side...
                // NOTE: If this expando ever becomes accessible to script (across the WriteTag call below, or whatever)
                //       we have a security hole.  See IE6 bug 15775 for effects.
                V_VT(&varProp)     = VT_BSTR;
                V_BSTR(&varProp)   = SysAllocString(achTempLocation);

                PrimitiveSetExpando(_T("__IE_ViewLinkSrc"), varProp);
                VariantClear(&varProp);

                fSavedViewlink = TRUE;
            }
        }
    }

    if (ETAG_GENERIC_LITERAL != Tag())
    {
#ifdef ATOMICGENERIC
        hr = THR( WriteTag(pStreamWriteBuff, fEnd, FALSE, fAtomicSave) );
#else
        hr = THR( super::Save(pStreamWriteBuff, fEnd) );
#endif
        if(hr)
            goto Cleanup;
    }
    else // if (ETAG_GENERIC_LITERAL == Tag())
    {
        Assert (ETAG_GENERIC_LITERAL == Tag());

        dwOldFlags = pStreamWriteBuff->ClearFlags(WBF_ENTITYREF);
        pStreamWriteBuff->SetFlags(WBF_SAVE_VERBATIM | WBF_NO_WRAP);

        pStreamWriteBuff->BeginPre();

#ifdef ATOMICGENERIC
        hr = THR( WriteTag(pStreamWriteBuff, fEnd, FALSE, fAtomicSave) );
#else
        hr = THR( super::Save(pStreamWriteBuff, fEnd) );
#endif // ATOMICGENERIC
        if(hr)
            goto Cleanup;

        if ( !fEnd &&
             !pStreamWriteBuff->TestFlag( WBF_SAVE_PLAINTEXT ) &&
             !pStreamWriteBuff->TestFlag( WBF_FOR_TREESYNC ) )
        {
#ifdef ATOMICGENERIC
            Assert( !fAtomicSave );
#endif // ATOMICGENERIC
            hr = THR(pStreamWriteBuff->Write(_cstrContents));
            if (hr)
                goto Cleanup;
        }
        pStreamWriteBuff->EndPre();

        pStreamWriteBuff->RestoreFlags(dwOldFlags);
    }

    // If we set the attribute to persist out, remove it here.
    if (fSavedViewlink)
    {
        WHEN_DBG(HRESULT hrDbg =)  PrimitiveRemoveExpando(_T("__IE_ViewLinkSrc"));
        Assert(!hrDbg);

        pMarkup->_fExpando = fExpando;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericElement::namedRecordset
//
//  Synopsis:   returns an ADO Recordset for the named data member.  Tunnels
//              into the hierarchy using the path, if given.
//
//  Arguments:  bstrDataMember  name of data member (NULL for default)
//              pvarHierarchy   BSTR path through hierarchy (optional)
//              pRecordSet      where to return the recordset.
//
//
//----------------------------------------------------------------------------

HRESULT
CGenericElement::namedRecordset(BSTR bstrDatamember,
                               VARIANT *pvarHierarchy,
                               IDispatch **ppRecordSet)
{
    HRESULT hr;
    CDataMemberMgr *pdmm;

#ifndef NO_DATABINDING
    EnsureDataMemberManager();
    pdmm = GetDataMemberManager();
    if (pdmm)
    {
        hr = pdmm->namedRecordset(bstrDatamember, pvarHierarchy, ppRecordSet);
        if (hr == S_FALSE)
            hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

#else
    *pRecordSet = NULL;
    hr = S_OK;
#endif NO_DATABINDING

    RRETURN (SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:     CGenericElement::getRecordSet
//
//  Synopsis:   returns an ADO Recordset pointer if this site is a data
//              source control
//
//  Arguments:  IDispatch **    pointer to a pointer to a record set.
//
//
//----------------------------------------------------------------------------

HRESULT
CGenericElement::get_recordset(IDispatch **ppRecordSet)
{
    return namedRecordset(NULL, NULL, ppRecordSet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscsite\ehr.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eli.cxx
//
//  Contents:   HR element class
//
//  Classes:    CHRElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EHR_HXX_
#define X_EHR_HXX_
#include "ehr.hxx"
#endif

#ifndef X_HRLYT_HXX_
#define X_HRLYT_HXX_
#include "hrlyt.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#define _cxx_
#include "hr.hdl"

MtDefine(CHRElement, Elements, "CHRElement")



const CElement::CLASSDESC CHRElement::s_classdesc =
{
    {
        &CLSID_HTMLHRElement,                // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                      // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                              // _pcpi
        ELEMENTDESC_NEVERSCROLL     |
        ELEMENTDESC_CARETINS_DL,             // _dwFlags
        &IID_IHTMLHRElement,                 // _piidDispinterface
        &s_apHdlDescs,                       // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLHRElement,          //_apfnTearOff
    NULL                                     // _pAccelsRun
};

HRESULT
CHRElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_HR));
    Assert(ppElement);

    *ppElement = new CHRElement(pDoc);

    RRETURN ( (*ppElement) ? S_OK : E_OUTOFMEMORY );
}

//+------------------------------------------------------------------------
//
//  Member:     CHRElement::Save
//
//  Synopsis:   Save the element to the stream
//
//-------------------------------------------------------------------------

HRESULT
CHRElement::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    DWORD   dwOldFlags;
    HRESULT hr = S_OK;

    dwOldFlags = pStreamWrBuff->ClearFlags(WBF_ENTITYREF);

    // Supress CRLF at start when saving (bug 66743) (jbeda)
    if (! pStreamWrBuff->TestFlag(WBF_NO_PRETTY_CRLF))
    {
        hr = pStreamWrBuff->NewLine();
        if (hr)
            goto Cleanup;
    }

    if(!fEnd)
    {
        if(pStreamWrBuff->TestFlag(WBF_SAVE_PLAINTEXT))
        {
            if (pStreamWrBuff->TestFlag(WBF_FORMATTED_PLAINTEXT))
            {
                hr = pStreamWrBuff->WriteRule();
                if(hr)
                    goto Cleanup;
            }
        }
        else
        {
            // do not write end tags for P, etc
            hr = WriteTag(pStreamWrBuff, fEnd);
            if(hr)
                goto Cleanup;
        }
    }

Cleanup:
    pStreamWrBuff->RestoreFlags(dwOldFlags);
    RRETURN(hr);
}

//
// NOTE marka - HandleMessage for HR has been removed. We used to bubble the message to it's
// parent in edit mode. We don't think we need this anymore ( or can't see why ).
//


HRESULT
CHRElement::ApplyDefaultFormat ( CFormatInfo * pCFI )
{
    HRESULT hr;

    // Override the inherited text color
    if (pCFI->_pcf->_ccvTextColor.IsDefined())
    {
        pCFI->PrepareCharFormat();
        pCFI->_cf()._ccvTextColor.Undefine();
        pCFI->UnprepareForDebug();
    }

    if (pCFI->_bBlockAlign == htmlBlockAlignNotSet)
    {
        pCFI->_bBlockAlign     = htmlBlockAlignCenter;
        pCFI->_bCtrlBlockAlign = htmlBlockAlignCenter;
    }

    hr = THR(super::ApplyDefaultFormat ( pCFI ));

    // Default to percent width (element's coordinate system).
    pCFI->PrepareFancyFormat();
    if (pCFI->_pcf->HasVerticalLayoutFlow())
    {
        pCFI->_ff().SetHeightPercent(pCFI->_ff().IsHeightPercent() | pCFI->_ff().GetHeight().IsNullOrEnum());
    }
    else
    {
        pCFI->_ff().SetWidthPercent(pCFI->_ff().IsWidthPercent() | pCFI->_ff().GetWidth().IsNullOrEnum());
    }
    pCFI->UnprepareForDebug();

    RRETURN(hr);
}



//+-------------------------------------------------------------------------
//
//  Method:     CHRElement::QueryStatus
//
//  Synopsis:   Called to discover if a given command is supported
//              and if it is, what's its state.  (disabled, up or down)
//
//--------------------------------------------------------------------------

HRESULT
CHRElement::QueryStatus(GUID * pguidCmdGroup,
                        ULONG cCmds,
                        MSOCMD rgCmds[],
                        MSOCMDTEXT * pcmdtext)
{
    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));
    Assert(cCmds == 1);

    MSOCMD   * pCmd = & rgCmds[0];
    ULONG      cmdID;
    HRESULT    hr;

    Assert(!pCmd->cmdf);

    cmdID = CBase::IDMFromCmdID( pguidCmdGroup, pCmd->cmdID );
    switch (cmdID)
    {
    case IDM_FORECOLOR:
        pCmd->cmdf = IsEditable(TRUE) ?
                (MSOCMDSTATE_UP) : (MSOCMDSTATE_DISABLED);
        hr = S_OK;
        break;

    default:
        hr = THR_NOTRACE(super::QueryStatus(pguidCmdGroup,
                                            1,
                                            pCmd,
                                            pcmdtext));
        break;
    }

    RRETURN_NOTRACE( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CHRElement::Exec
//
//  Synopsis:   execute the commands from QueryStatus
//
//--------------------------------------------------------------------------

HRESULT
CHRElement::Exec(GUID * pguidCmdGroup,
                 DWORD nCmdID,
                 DWORD nCmdexecopt,
                 VARIANTARG * pvarargIn,
                 VARIANTARG * pvarargOut)
{
    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));

    int      idm = CBase::IDMFromCmdID(pguidCmdGroup, nCmdID);
    HRESULT  hr  = MSOCMDERR_E_NOTSUPPORTED;

    switch (idm)
    {
    case IDM_FORECOLOR:
        if (pvarargOut)
        {
            // its a property get
            hr = THR(get_PropertyHelper(pvarargOut, (PROPERTYDESC *)&s_propdescCHRElementcolor));
            if (hr)
                goto Cleanup;

            if (VT_BSTR == V_VT(pvarargOut))
            {
                // we need to convert to I4 to return consistent with what
                // comes in from a set
                CColorValue cvColor;

                hr = THR(cvColor.FromString(V_BSTR(pvarargOut)));
                if (hr)
                    goto Cleanup;

                VariantClear(pvarargOut);
                V_I4(pvarargOut) = cvColor.GetRawValue();
                V_VT(pvarargOut) = VT_I4;
            }
        }
        else if (!pvarargIn)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        else
        {
#ifndef NO_EDIT
            CParentUndoUnit *pCPUU = OpenParentUnit(this, IDS_UNDOPROPCHANGE);
#endif // NO_EDIT

            // property set. we need to flip the colors, for OLE
            // compatability
            CColorValue cvValue;
            CVariant varColor;

            hr = THR(varColor.CoerceVariantArg(pvarargIn, VT_I4));
            if (hr)
                goto Cleanup;

            cvValue.SetFromRGB(V_I4(&varColor));

            V_I4(pvarargIn) = (DWORD)cvValue.GetRawValue();
            V_VT(pvarargIn) = VT_I4;

            //its a property put
            hr = THR(put_VariantHelper(*pvarargIn, (PROPERTYDESC *)&s_propdescCHRElementcolor));

#ifndef NO_EDIT
            CloseParentUnit(pCPUU, hr);
#endif // NO_EDIT
        }
        break;
    }

    if (hr == MSOCMDERR_E_NOTSUPPORTED)
    {
        hr = super::Exec(
                pguidCmdGroup,
                nCmdID,
                nCmdexecopt,
                pvarargIn,
                pvarargOut);
    }

Cleanup:
    RRETURN_NOTRACE(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscsite\e1d.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       e1d.cxx
//
//  Contents:   CFlowSite, C1DElement, CSpanSite, and related classes.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include <cguid.h>
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_DIV_HXX_
#define X_DIV_HXX_
#include "div.hxx"
#endif

#ifndef X_EPHRASE_HXX_
#define X_EPHRASE_HXX_
#include "ephrase.hxx"
#endif

#ifndef X_E1D_HXX_
#define X_E1D_HXX_
#include "e1d.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_FSlYT_HXX_
#define X_FSLYT_HXX_
#include "fslyt.hxx"
#endif

#ifndef X_DISPDEFS_HXX_
#define X_DISPDEFS_HXX_
#include "dispdefs.hxx"
#endif

#ifndef X_THEMEHLP_HXX_
#define X_THEMEHLP_HXX_
#include "themehlp.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "e1d.hdl"

#define _cxx_
#include "espan.hdl"

MtDefine(C1DElement, Elements, "C1DElement")
MtDefine(CSpanSite, Elements, "CSpanSite")
MtDefine(CLegendElement, Elements, "CLegendElement")
MtDefine(CFieldSetElement, Elements, "CFieldSetElement")

const CElement::CLASSDESC C1DElement::s_classdesc =
{
    {
        &CLSID_HTMLDivPosition,         // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_TEXTSITE,           // Allow 1D element to inherit parent styles
        &IID_IHTMLDivPosition,          // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLDivPosition,   // _apfnTearOff
    NULL                                // _pAccelsRun
};

#ifndef NO_PROPERTY_PAGE
const CLSID * const C1DElement::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif    
    NULL
};
#endif // NO_PROPERTY_PAGE

const CElement::CLASSDESC CSpanSite::s_classdesc =
{
    {
        &CLSID_HTMLSpanFlow,            // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_TEXTSITE,       // Allow SPAN element to inherit parent styles
        &IID_IHTMLSpanFlow,             // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLSpanFlow,      // _apfnTearOff
    NULL                                // _pAccelsRun
};

#ifndef NO_PROPERTY_PAGE
const CLSID * const CSpanSite::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif // DBG==1 
    NULL
};
#endif // NO_PROPERTY_PAGE


////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

CFlowSite::CFlowSite (ELEMENT_TAG etag, CDoc *pDoc)
  : CTxtSite(etag, pDoc)
{
}



#ifndef NO_DATABINDING
#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

//+----------------------------------------------------------------------------
//
//  Function: GetDBindMethods, IHTMLElement
//
//  Synopsis: Get pointer to implementation of databinding support.
//
//-----------------------------------------------------------------------------
const CDBindMethods *
CFlowSite::GetDBindMethods()
{
    Assert(Tag() == ETAG_SPAN || Tag() == ETAG_DIV);
    return &DBindMethodsTextRichRO;
}
#endif // ndef NO_DATABINDING

//+----------------------------------------------------------------------------
//
//  For:    CFieldSetElement
//
//
//
//+----------------------------------------------------------------------------

const CElement::CLASSDESC CFieldSetElement::s_classdesc =
{
    {
        &CLSID_HTMLFieldSetElement,     // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_TEXTSITE,       // Allow 1D element to inherit parent styles
        &IID_IHTMLFieldSetElement,      // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLFieldSetElement, // _apfnTearOff
    NULL                                // _pAccelsRun
};

//+---------------------------------------------------------------------------
//
//  Member:     CFieldSetElement::CreateElement
//
//  Synopsis:   Create a FieldSet
//
//+---------------------------------------------------------------------------

HRESULT
CFieldSetElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);

    *ppElement = new CFieldSetElement(pht->GetTag(), pDoc);

    RRETURN ( (*ppElement) ? S_OK : E_OUTOFMEMORY);
}

//+----------------------------------------------------------------------------
//
//  Member:     CFieldSetElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-----------------------------------------------------------------------------

HRESULT
CFieldSetElement::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    *ppv = NULL; 
    switch(iid.Data1)
    {
        QI_TEAROFF(this, IHTMLTextContainer, NULL)
        QI_TEAROFF(this, IHTMLFieldSetElement2, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFieldSetElement::GetBorderInfo
//
//  Synopsis:   provide BorderInfo
//              return FALSE when drawing, otherwise return TRUE
//
//----------------------------------------------------------------------------

DWORD
CFieldSetElement::GetBorderInfo(CDocInfo * pdci, CBorderInfo *pborderinfo, BOOL fAll, BOOL fAllPhysical FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    DWORD nBorders  = super::GetBorderInfo( pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);
    long  iBdrLeft  = pborderinfo->aiWidths[SIDE_LEFT];
    long  iBdrTop   = pborderinfo->aiWidths[SIDE_TOP];
    long  iBdrOff   = FIELDSET_CAPTION_OFFSET;

    CLegendLayout *     pLegendLayout;

    POINT   posLegend;
    SIZE    sizeLegend;
    SIZE    sizeFieldset;

    if (nBorders == DISPNODEBORDER_NONE)
        goto Cleanup;

    pLegendLayout = GetLegendLayout();
    if (!pLegendLayout)
        goto Cleanup;

    pLegendLayout->GetLegendInfo(&sizeLegend, &posLegend);
    GetUpdatedLayout()->GetSize(&sizeFieldset);

    if (pdci)
    {
        iBdrOff = pdci->DeviceFromDocPixelsY(FIELDSET_CAPTION_OFFSET);
    }

    // calc caption size and pos

    if (sizeLegend.cx > 0)
    {
        pborderinfo->sizeCaption.cx = posLegend.x - iBdrOff + iBdrLeft;
        pborderinfo->sizeCaption.cy = posLegend.x + sizeLegend.cx + iBdrOff + iBdrLeft;

        if (pborderinfo->sizeCaption.cx < 0)
            pborderinfo->sizeCaption.cx = 0;
        if (pborderinfo->sizeCaption.cy < 0)
            pborderinfo->sizeCaption.cy = 0;

        sizeFieldset.cx = sizeFieldset.cx - iBdrLeft * 2;

        if (pborderinfo->sizeCaption.cx > sizeFieldset.cx)
        {
            pborderinfo->sizeCaption.cx = sizeFieldset.cx;
        }
        if (pborderinfo->sizeCaption.cy > sizeFieldset.cx)
        {
            pborderinfo->sizeCaption.cy = sizeFieldset.cx;
        }
    }
    else
    {
        pborderinfo->sizeCaption.cx = 0;
        pborderinfo->sizeCaption.cy = 0;
    }


    // set offset
    if (sizeLegend.cy > 0)
    {
        pborderinfo->offsetCaption = posLegend.y + ((sizeLegend.cy - iBdrTop) >> 1);
        if (    pborderinfo->offsetCaption < 0 
           ||   pborderinfo->offsetCaption > sizeFieldset.cy)
        {
            pborderinfo->offsetCaption = 0;
        }
    }
    else
    {
        pborderinfo->offsetCaption = 0;
    }

    if (!_fDrawing)
    {
        pborderinfo->wEdges &= ~BF_TOP;
        pborderinfo->aiWidths[SIDE_TOP] = 0;
    }
    nBorders = DISPNODEBORDER_COMPLEX;

Cleanup:
    return nBorders;
}

CLegendLayout *
CFieldSetElement::GetLegendLayout()
{
    DWORD_PTR dw;
    CLayout * pLayout;
    CLayout * pLayoutThis = GetUpdatedLayout();
    CLegendLayout * pLegendLayout = NULL;

    Assert(pLayoutThis);

    // We can also enforce the fieldset legend to be the first element
    // in this case, we just need to return the first element in the site
    // array only if it is a legend
    for (pLayout = pLayoutThis->GetFirstLayout(&dw);
         pLayout;
         pLayout = pLayoutThis->GetNextLayout(&dw))
    {
        if (pLayout->Tag() == ETAG_LEGEND)
        {
            pLegendLayout = (CLegendLayout *)pLayout;
            break;
        }
    }
    pLayoutThis->ClearLayoutIterator(dw, FALSE);
    return pLegendLayout;
}

HRESULT
CFieldSetElement::ApplyDefaultFormat( CFormatInfo *pCFI )
{
    BYTE i;
    HRESULT hr;
    HTHEME hTheme = GetMarkup()->GetTheme(THEME_BUTTON);
    RECT            rcBg;
    CUnitValue      auv[SIDE_MAX];

    if (pCFI->_pcf->_bCursorIdx != styleCursorAuto)
    {
        //our intrinsics shouldn't inherit the cursor property. they have a 'default'
        pCFI->PrepareCharFormat();
        pCFI->_cf()._bCursorIdx = styleCursorAuto;
        pCFI->UnprepareForDebug();
    }

    pCFI->PrepareFancyFormat();

    CUnitValue uvBorder;
    uvBorder.SetValue(2, CUnitValue::UNIT_PIXELS);
    for (i = 0; i < SIDE_MAX; i++)
    {
        pCFI->_ff()._bd.SetBorderWidth(i, uvBorder);
        pCFI->_ff()._bd.SetBorderStyle(i, fmBorderStyleEtched);
    }

    pCFI->_ff()._bd._ccvBorderColorLight.SetSysColor(COLOR_3DLIGHT);
    pCFI->_ff()._bd._ccvBorderColorDark.SetSysColor(COLOR_3DDKSHADOW);
    pCFI->_ff()._bd._ccvBorderColorHilight.SetSysColor(COLOR_BTNHIGHLIGHT);
    pCFI->_ff()._bd._ccvBorderColorShadow.SetSysColor(COLOR_BTNSHADOW);

    pCFI->UnprepareForDebug();

    hr = THR(super::ApplyDefaultFormat(pCFI));
    if (hr)
        goto Cleanup;

    // Default to percent width (element's coordinate system).
    pCFI->PrepareFancyFormat();

    if (hTheme && !pCFI->_ff().IsThemeDisabled()) // the control is themed
    {
        // set theme defaults for properties not already set

        if (!THR(GetThemeBackgroundExtent(hTheme, NULL, BP_GROUPBOX, PBS_NORMAL, &g_Zero.rc, &rcBg)))
        {
            CUnitValue uv;

            if (!pCFI->_fPaddingLeftSet)
            {
                uv.SetValue( -rcBg.left, CUnitValue::UNIT_PIXELS);            
                pCFI->_ff().SetPadding(SIDE_LEFT, uv);
            }
            if (!pCFI->_fPaddingRightSet)
            {
                uv.SetValue( rcBg.right, CUnitValue::UNIT_PIXELS);            
                pCFI->_ff().SetPadding(SIDE_RIGHT, uv);
            }
            if (!pCFI->_fPaddingBottomSet)
            {
                uv.SetValue( rcBg.bottom, CUnitValue::UNIT_PIXELS);            
                pCFI->_ff().SetPadding(SIDE_BOTTOM, uv);
            }
        }           
    }

    if (pCFI->_pcf->HasVerticalLayoutFlow())
    {
        pCFI->_ff().SetHeightPercent(pCFI->_ff().IsHeightPercent() | pCFI->_ff().GetHeight().IsNullOrEnum());
    }
    else
    {
        pCFI->_ff().SetWidthPercent(pCFI->_ff().IsWidthPercent() | pCFI->_ff().GetWidth().IsNullOrEnum());
    }
    pCFI->UnprepareForDebug();

Cleanup:
    RRETURN(hr);
}

#ifndef NO_DATABINDING
const CDBindMethods *
CFieldSetElement::GetDBindMethods()
{
    // TODO: we probably want to support databniding to FieldSet's, but
    //  need to special-case any embedded Legend.
    return NULL;    // our superclass would do otherwise; suppress here
}
#endif // ndef NO_DATABINDING

const CElement::CLASSDESC CLegendElement::s_classdesc =
{
    {
        &CLSID_HTMLLegendElement,       // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_TEXTSITE,           // _dwFlags
        &IID_IHTMLLegendElement,        // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLLegendElement, // _pfnTearOff
    NULL                                // _pAccelsRun
};

HRESULT
CLegendElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);

    *ppElement = new CLegendElement(pht->GetTag(), pDoc);

    RRETURN ( (*ppElement) ? S_OK : E_OUTOFMEMORY);
}

//+------------------------------------------------------------------------
//
//  Member:     CLegendElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CLegendElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_TEAROFF(this, IHTMLLegendElement2, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

HRESULT CLegendElement::ApplyDefaultFormat ( CFormatInfo * pCFI )
{
    HTHEME hTheme = GetMarkup()->GetTheme(THEME_BUTTON);    
    HRESULT hr = S_OK;

    pCFI->_bBlockAlign     = htmlBlockAlignNotSet;
    pCFI->_bCtrlBlockAlign = htmlBlockAlignNotSet;

    hr = super::ApplyDefaultFormat ( pCFI );

    pCFI->PrepareCharFormat();
    pCFI->PrepareFancyFormat();

    if (hTheme && !pCFI->_ff().IsThemeDisabled()) // set theme defaults
    {
        LOGFONT lf;
        CUnitValue  uv;     
        COLORREF    cr;

        if (!pCFI->_fFontSet && !GetThemeFont(hTheme, NULL, BP_GROUPBOX, PBS_NORMAL, TMT_FONT, &lf))
        {
            long    twips;
                        
            if (!pCFI->_fFontWeightSet)
                pCFI->_cf()._wWeight = lf.lfWeight;

            if (!pCFI->_fFontHeightSet)
            {
                twips = MulDivQuick(lf.lfHeight,
                                    TWIPS_PER_INCH,
                                    g_sizePixelsPerInch.cy);

                if(twips < 0)
                    twips = - twips;

                pCFI->_cf().SetHeightInTwips( twips );
            }
        }        

        if (!pCFI->_fFontColorSet && !GetThemeColor(hTheme, BP_GROUPBOX, 0, TMT_TEXTCOLOR, &cr))
        {
            pCFI->_cf()._ccvTextColor.SetValue( cr, FALSE);
        }

        uv.SetValue( FIELDSET_CAPTION_OFFSET, CUnitValue::UNIT_PIXELS);

        if (!pCFI->_fPaddingLeftSet)
            pCFI->_ff().SetPadding(SIDE_LEFT, uv);
        
        if (!pCFI->_fPaddingRightSet)
            pCFI->_ff().SetPadding(SIDE_RIGHT, uv);        
    }

    pCFI->UnprepareForDebug();

    RRETURN(hr);
}


void
CLegendElement::Notify(CNotification *pNF)
{
    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_QUERYMNEMONICTARGET:
        {
            FOCUS_ITEM  fi;
            CElement *  pParent;

            fi.pElement = NULL;
            fi.lSubDivision = 0;
    
            // Legend itself is not focussable; activate the next element in the fieldset
            if (    NULL != (pParent = GetFirstBranch()->SearchBranchToRootForTag(ETAG_FIELDSET)->Element())
                &&  Doc()->FindNextTabOrder(DIRECTION_FORWARD, FALSE, NULL, this, 0, &fi.pElement, &fi.lSubDivision)
                &&  fi.pElement && fi.pElement->GetFirstBranch()->SearchBranchToRootForScope(pParent))
            {
                *(FOCUS_ITEM *)pNF->DataAsPtr() = fi;
            }
        }
        break;
    default:
        super::Notify(pNF);
        break;
    }
}

#ifndef NO_DATABINDING
#include "elemdb.hxx"

const CDBindMethods *
CLegendElement::GetDBindMethods()
{
    return &DBindMethodsTextRichRO;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\ole\bag16.cxx ===
//bag16.cxx
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_MIME64_HXX_
#define X_MIME64_HXX_
#include "mime64.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_PROPBAG_HXX_
#define X_PROPBAG_HXX_
#include "propbag.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include <binder.hxx>       // for cdatasourceprovider
#endif

#ifndef X_ADO_ADOID_H_
#define X_ADO_ADOID_H_
#include <ado/adoid.h>
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#include "object.hdl"

#pragma warning (disable: 4702)

#define      MAX_PROXY     1024  


static const char aJavaKey[] = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\JavaVM";
static const char aProxyKey[] = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings";


static const char* aProxyPropName[] = {"proxyhttp" , 
                                       "proxyssl", 
                                       "proxygopher",
                                       "proxyftp",
                                        NULL };

static const char* aProtocol[] = {"http", "https" , "gopher" , "ftp" , NULL};
static const char* aProtocolEq[] = {"http=", "https=" , "gopher=" , "ftp=" , "socks=", NULL};


char aClassPath[MAX_PATH];
char aDefaultOptions[MAX_PATH];
char aBaseUrl[MAX_PATH];
char aProxyString[MAX_PROXY];
char aProxyBuffer[MAX_PATH];


/*-----------------------------------------------------
** IsProxyEnabled
** 
** determine whether ProxyEnabled key in registry exists and if its value is nonzero
**-----------------------------------------------------
*/
BOOL IsProxyEnabled()
{
    DWORD dwData = 0;
    DWORD dwResult = 0;
    HKEY hKey = 0;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, &aProxyKey[0], 0 , NULL , &hKey))
    {   
        dwData = 4L;
        RegQueryValueEx(hKey,"ProxyEnable" ,NULL, NULL , (LPBYTE)&dwResult, &dwData); 
        RegCloseKey(hKey);
    } 
    
    return (dwResult != 0);
} 


/*------------------------------------------------------
** UseSameProxies
** 
** determine whether proxy settings string begins with a protocol name.  If not
** by convention the proxy string is assumed to be the proxy setting used for all protocols
**------------------------------------------------------
*/

BOOL UseSameProxies(LPSTR lpProxyString)
{   
    //if string begins with "socks" from the point of view of JavaVM, no proxies are enabled  
    if (strlen(lpProxyString) >= 5 && strnicmp(lpProxyString , "socks" , 5) == 0)
    {
        return FALSE;
    }
    
    char* lpProtocol;  
    int i;
    for (i = 0 , lpProtocol = (char*)aProtocolEq[0]; lpProtocol; i++ , lpProtocol = (char*)aProtocol[i])

    {
        if (strlen(lpProxyString) >= strlen(lpProtocol) &&  
            strnicmp(lpProxyString , lpProtocol, strlen(lpProtocol)) == 0) 
            return FALSE;
    }
    
    return TRUE;
}
            


   

/*
**----------------------------------------------
** GetProxyString   
**
** static helper to parse value of given proxy property from string in registry
**----------------------------------------------
*/

BOOL GetProxyString(LPSTR lpKey , LPSTR lpString, LPSTR lpRet, int iMaxChars)
{   
    if (!IsProxyEnabled()) 
    { 
        return FALSE;
    }
    
    if (!lpString || !lpString[0])
    {
        return FALSE;
    }
    
    if (UseSameProxies(lpString))
    {   
        //enough room in output buffer?
        if (iMaxChars < strlen(lpString) + strlen(lpKey) + 5)
        {
            return FALSE;
        }
        
        //change setting string of form "itgproxy:80" to one of form "http://itgproxy:80/"
        if (strstr(lpString, "://") == 0)
        {
            strcpy(lpRet,lpKey);
            strcat(lpRet,"://");
            strcat(lpRet,lpString);
        }
        else
        {
            strcpy(lpRet, lpString);
        }
        if (*(lpRet + strlen(lpRet) - 1) != '/')
        {
            strcat(lpRet,"/");
        }
        
        return TRUE;
    }    

    //copy data since strtok is destructive
    char* lpTemp = new char[strlen(lpString) + 1];
    strcpy(lpTemp , lpString);
    LPSTR lpNext = strtok(lpTemp , "=;" );
    while (lpNext)
    {
        if (strcmp(lpNext, lpKey) == 0)
        {
            LPSTR lpSetting = strtok(NULL , "=;");
            if (!lpSetting) 
            {    
                delete [] lpTemp;
                return FALSE;
            }

            if (iMaxChars < strlen(lpSetting) + strlen(lpKey) + 5) 
            {
                delete lpTemp;
                return FALSE;
            }
            
            //change setting string of form "itgproxy:80" to one of form "http://itgproxy:80/"
            if (strstr(lpSetting, "://") == 0)
            {
                strcpy(lpRet,lpKey);
                strcat(lpRet,"://");
                strcat(lpRet,lpSetting);
            }
            else
            {
                strcpy(lpRet, lpSetting);
            }
            if (*(lpRet + strlen(lpRet) - 1) != '/')
            {
                strcat(lpRet,"/");
            }

            delete [] lpTemp;
            return TRUE;
        }

        lpNext = strtok( NULL  , "=;");
    }

    //not found
    delete [] lpTemp;
    return FALSE;
    
}


HRESULT CObjectElement::SaveWin16AppletProps(IPropertyBag* pBag)
{
    HKEY hKey;
    HRESULT hr = S_OK;

    DWORD dwData;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, &aJavaKey[0], 0 , NULL , &hKey))
    {

        dwData = sizeof(aClassPath);
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, 
                                             "ClassPath" , 
                                             NULL, 
                                             NULL , 
                                             (LPBYTE)&aClassPath[0], &dwData))
        {
            goto FAILED;
        }

        dwData = sizeof(aDefaultOptions);
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, 
                        "DefaultOptions",
                        NULL,
                        NULL, 
                        (LPBYTE)&aDefaultOptions[0], 
                        &dwData))

    
        {
            strcpy(aDefaultOptions , "-mx600k -ss8k msjava16");
        }
        
        RegCloseKey(hKey);
        hKey = 0;
    }
    else
    {
        goto FAILED;
    }

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, &aProxyKey[0], 0 , NULL , &hKey))
    {
        dwData = sizeof(aProxyString);
        aProxyString[0] = '\0';
        RegQueryValueEx(hKey, "ProxyServer", NULL, NULL , (LPBYTE)&aProxyString[0], &dwData);
        RegCloseKey(hKey);
    }

    //drop data in propertybag
    VARIANT var;
    VariantInit(&var);
    if (pBag->Read("documentbase", &var, NULL) == E_INVALIDARG)
    {
        char* pBaseURL;  
        char pDocBaseURL[pdlUrlLen];
        char *pDocBaseSlash;
        DWORD dwDocBase;
        
        hr = _pDoc->GetBaseUrl(&pBaseURL, this); 
        if (hr)
            goto FAILED;
        
        dwDocBase = pdlUrlLen;
        if (!InternetCombineUrl(pBaseURL, "java", pDocBaseURL, &dwDocBase, 0))
            goto FAILED;
        char chSlash = strnicmp(pDocBaseURL, "file://", 7) ? '/' : '\\';
        if (!(pDocBaseSlash = strrchr(pDocBaseURL, chSlash)))
                goto FAILED;   

        if (_stricmp(pDocBaseSlash + 1, "java"))
            goto FAILED;
        *(pDocBaseSlash + 1) = '\0';  

        var.vt = VT_BSTR;
        var.bstrVal = SysAllocString(pDocBaseURL);  
        hr = pBag->Write("documentbase", &var);  
        VariantClear(&var);
        if (hr) goto FAILED;
    }
    
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(&aClassPath[0]);
    hr = pBag->Write("classpath", &var);
    VariantClear(&var);
    if (hr) goto FAILED;
   
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(&aDefaultOptions[0]);
    hr = pBag->Write("defaultoptions", &var); 
    VariantClear(&var);
    if (hr) goto FAILED;

    if (aProxyString[0])
    {
        for (int i = 0; aProtocol[i]; i++)
        {
            if (GetProxyString((LPSTR)aProtocol[i] , 
                               aProxyString, 
                               aProxyBuffer, 
                               sizeof(aProxyBuffer)))
            {
                var.vt = VT_BSTR; 
            
                var.bstrVal = SysAllocString(&aProxyBuffer[0]);
                hr = pBag->Write(aProxyPropName[i], &var);
                VariantClear(&var);
                if (hr) goto FAILED;
            
            }
        }

    }

    return S_OK;

FAILED:
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\ole\codeload.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       codeload.cxx
//
//  Contents:   Implementation of CCodeLoad class
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_CODELOAD_HXX_
#define X_CODELOAD_HXX_
#include "codeload.hxx"
#endif

#ifndef X_SAFETY_HXX_
#define X_SAFETY_HXX_
#include "safety.hxx"
#endif

#ifndef X_PROGSINK_HXX_
#define X_PROGSINK_HXX_
#include "progsink.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_SAFEOCX_H_
#define X_SAFEOCX_H_
#include <safeocx.h>
#endif

ExternTag(tagSecurityContext);

HRESULT CreateStreamOnFile(LPCTSTR lpstrFile, DWORD dwSTGM, LPSTREAM * ppstrm);

EXTERN_C CLSID CLSID_AppletOCX;

MtDefine(CCodeLoad, Dwn, "CCodeLoad")
MtDefine(OleCreateInfo, Dwn, "OLECREATEINFO")
MtDefine(CBindContextParam, Dwn, "CBindContextParam")

#define BINDCONTEXT_CMDID_BASEURL               0
#define BINDCONTEXT_CMDID_PROPBAG               1

///////////////////////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CCodeLoad::CCodeLoad
//
//  Synopsis:   ctor
//
//-------------------------------------------------------------------------

CCodeLoad::CCodeLoad()
{
    _info.clsid = GUID_NULL;
}


//+------------------------------------------------------------------------
//
//  Member:     CCodeLoad::Init
//
//  Synopsis:   Simple initializer for code download context
//
//-------------------------------------------------------------------------

HRESULT
CCodeLoad::Init(
    COleSite *pSiteOle,
    COleSite::OLECREATEINFO *pinfo)
{
    CLock   Lock(this);
    HRESULT hr = S_OK;
    CDoc *  pDoc = pSiteOle->Doc();

    Assert( pSiteOle );

    CMarkup * pMarkup = pSiteOle->GetMarkup();

    //
    // Initialize member data
    //

    _pSiteOle = pSiteOle;
    _pSiteOle->SubAddRef();

    if (pMarkup)
    {
        _pMarkupScriptBlock = pMarkup;
        _pMarkupScriptBlock->SubAddRef();

        pMarkup->BlockScriptExecution(&_dwScriptCookie);
    }

    _fGotData = TRUE;

    Assert(!pinfo->pDataObject);

    // Make a copy of pinfo locally.
    _info.clsid = pinfo->clsid;
    if (pinfo->pStream)
    {
        _info.pStream = pinfo->pStream;
        pinfo->pStream->AddRef();
    }
    if (pinfo->pStorage)
    {
        _info.pStorage = pinfo->pStorage;
        pinfo->pStorage->AddRef();
    }
    if (pinfo->pPropBag)
    {
        _info.pPropBag = pinfo->pPropBag;
        pinfo->pPropBag->AddRef();
    }
    if (pinfo->pStreamHistory)
    {
        _info.pStreamHistory = pinfo->pStreamHistory;
        pinfo->pStreamHistory->AddRef();
    }
    if (pinfo->pBindCtxHistory)
    {
        _info.pBindCtxHistory = pinfo->pBindCtxHistory;
        pinfo->pBindCtxHistory->AddRef();
    }
    if (pinfo->pShortCutInfo)
    {
        _info.pShortCutInfo = pinfo->pShortCutInfo;
        _info.pShortCutInfo->AddRef();
    }
    _info.dwMajorVer = pinfo->dwMajorVer;
    _info.dwMinorVer = pinfo->dwMinorVer;

    MemReplaceString(Mt(OleCreateInfo), pinfo->pchSourceUrl, &_info.pchSourceUrl);
    MemReplaceString(Mt(OleCreateInfo), pinfo->pchDataUrl, &_info.pchDataUrl);
    MemReplaceString(Mt(OleCreateInfo), pinfo->pchMimeType, &_info.pchMimeType);
    MemReplaceString(Mt(OleCreateInfo), pinfo->pchClassid, &_info.pchClassid);
    MemReplaceString(Mt(OleCreateInfo), pinfo->pchFileName, &_info.pchFileName);

    _pProgSink = CMarkup::GetProgSinkHelper(pMarkup);
    if (_pProgSink)
    {
        _pProgSink->AddRef();
        IGNORE_HR(_pProgSink->AddProgress( PROGSINK_CLASS_CONTROL, &_dwProgCookie ));
    }

    //
    // If we need to download data, create a bits context and get data
    //

    if (pinfo->pchDataUrl)
    {

        // We still download the data, even if from another domain.  But set
        // the flag so we can inject policy when we init the control.
        if (pMarkup)
            pSiteOle->_fDataSameDomain = pMarkup->AccessAllowed(pinfo->pchDataUrl);

        BOOL fPendingRoot = FALSE;

        if (pSiteOle->IsInMarkup())
            fPendingRoot = pSiteOle->GetMarkup()->IsPendingRoot();

        hr = THR(pDoc->NewDwnCtx(DWNCTX_FILE, pinfo->pchDataUrl,
                    pSiteOle, (CDwnCtx **)&_pBitsCtx, fPendingRoot));
        if (hr)
            goto Cleanup;

        if (_pBitsCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_ERROR))
        {
            OnDwnChan(_pBitsCtx);
        }
        else
        {
            _fGotData = FALSE;
            _pBitsCtx->SetProgSink(CMarkup::GetProgSinkHelper(pMarkup));
            _pBitsCtx->SetCallback(OnDwnChanCallback, this);
            _pBitsCtx->SelectChanges(DWNCHG_COMPLETE, 0, TRUE);
        }
    }

    if (pSiteOle->HasMarkupPtr())
        SetDwnDoc(pMarkup->GetDwnDoc());

    //
    // Start BTO.
    //

    hr = THR(BindToObject());
    if (!OK(hr))
        goto Cleanup;

Cleanup:
    RRETURN1(hr, MK_S_ASYNCHRONOUS);
}

//+------------------------------------------------------------------------
//
//  Method:     CCodeLoad::OnDwnChan
//
//-------------------------------------------------------------------------

void
CCodeLoad::OnDwnChan(CDwnChan * pDwnChan)
{
    CLock       Lock(this);
    ULONG       ulState = _pBitsCtx->GetState();
    HRESULT     hr;
    BOOL        fDone = FALSE;
    TCHAR *     pchExt;

    //
    // We better not have terminated yet
    //

    Assert(_pSiteOle);

    if (ulState & DWNLOAD_COMPLETE)
    {
        fDone = TRUE;

        BOOL fPendingRoot = FALSE;

        if (_pSiteOle->IsInMarkup())
            fPendingRoot = _pSiteOle->GetMarkup()->IsPendingRoot();

        // If unsecure download, may need to remove lock icon on Doc
        _pSiteOle->Doc()->OnSubDownloadSecFlags(fPendingRoot, _pBitsCtx->GetUrl(), _pBitsCtx->GetSecFlags());
        
        // Find last occurance of '.' in URL

        //
        // Due to a data sniffing bug, binary .stm files
        // are downloaded and given an extension of .htm.  We then
        // need to examine the URL to get the correct file extension
        //

        pchExt = _tcsrchr(_pBitsCtx->GetUrl(), _T('.'));
        if (pchExt &&
            (!StrCmpIC(pchExt, _T(".stm")) ||
             !StrCmpIC(pchExt, _T(".ods")) ||   // NCompass data files
             !StrCmpIC(pchExt, _T(".ica"))))    // Citrix Winframe data files
        {
            hr = THR(CreateStreamFromData());
            if (hr)
                goto Cleanup;

            goto Done;
        }

        _pBitsCtx->GetFile(&_info.pchFileName);
    }
    else if (ulState & (DWNLOAD_ERROR | DWNLOAD_STOPPED))
    {
        //
        // In error case, try to initNew
        //

        fDone = TRUE;
    }

Done:
    if (fDone)
    {
        _fGotData = TRUE;

        if (_punkObject)
        {
            //
            // Code download is already done, go ahead and create object.
            //

            hr = THR(_pSiteOle->CreateObjectNow(
                _iidObject,
                _punkObject,
                &_info));
        }

        if (_pBitsCtx)
        {
            _pBitsCtx->SetProgSink(NULL); // detach download from document's load progress
            _pBitsCtx->Disconnect();
            _pBitsCtx->Release();
            _pBitsCtx = NULL;
        }
    }

Cleanup:
    ;
}


//+------------------------------------------------------------------------
//
//  Member:     CCodeLoad::CreateStreamFromData
//
//  Synopsis:   Creates an OLE stream from a .stm data file.
//
//-------------------------------------------------------------------------

HRESULT
CCodeLoad::CreateStreamFromData()
{
    LARGE_INTEGER   dlibMove = {0,0};
    HRESULT         hr = E_FAIL;
    TCHAR *         pchFileName = NULL;
    CLSID           clsid;

    //
    // Retrieve clsid from stream and get control
    //

    hr = THR(_pBitsCtx->GetFile(&pchFileName));
    if (hr)
        goto Cleanup;

    hr = THR(CreateStreamOnFile(
            pchFileName,
            STGM_READ | STGM_SHARE_DENY_WRITE,
            &_info.pStream));
    if (hr)
        goto Cleanup;

    //
    // In this mode, we only know how to initialize the
    // object via a stream.
    //

    // seek to the begining of the stream
    hr = THR(_info.pStream->Seek(dlibMove, STREAM_SEEK_SET, NULL));
    if (hr)
        goto Cleanup;

    //
    // read the clsid from the first 16 bytes
    //

#ifdef BIG_ENDIAN
    Assert( 0 && "Fix big endian read of clsid" );
#endif

    hr = THR(_info.pStream->Read(&clsid, 16, NULL));
    if (hr)
        goto Cleanup;

    //
    // If we don't have a clsid yet, go ahead and set the clsid.
    //

    if (_info.clsid == g_Zero.guid)
    {
        _info.clsid = clsid;
    }

Cleanup:
    MemFreeString(pchFileName);
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CCodeLoad::Terminate
//
//  Synopsis:   1st stage destruction.
//
//-------------------------------------------------------------------------

void
CCodeLoad::Terminate()
{
    CLock Lock(this);

    Assert(_pSiteOle);

    if (_pMarkupScriptBlock)
    {
        IGNORE_HR(_pMarkupScriptBlock->UnblockScriptExecution(&_dwScriptCookie));

        _pMarkupScriptBlock->SubRelease();
        _pMarkupScriptBlock = NULL;
    }

    if (_pBitsCtx)
    {
        _pBitsCtx->Disconnect();
        _pBitsCtx->Release();
        _pBitsCtx = NULL;
    }

    _pSiteOle->AddRef();

    if (!_fGotObject)
    {
        // $$ktam: Another reason why Invalidate should be a CLayoutInfo virtual.
        // We can get away with it here because we aren't breaking ole sites.
        
        _pSiteOle->OnFailToCreate();

        // bug 102547
        Assert(!_pSiteOle->IsPassivated());

        CLayout * pLayout = _pSiteOle->GetUpdatedLayout(GUL_USEFIRSTLAYOUT);
        if (pLayout)
            pLayout->Invalidate(); // so olesite will redraw another placeholder

        if (_pbinding)
        {
            IGNORE_HR(_pbinding->Abort());
        }
    }

    if (_pbctx)
    {
        IGNORE_HR(RevokeBindStatusCallback(_pbctx, this));
        ClearInterface(&_pbctx);
    }

    _pSiteOle->OnControlReadyStateChanged(/* fForceComplete = */FALSE);

    _pSiteOle->SubRelease();
    _pSiteOle->Release();
    _pSiteOle = NULL;

    ClearInterface(&_punkObject);

    if( _dwProgCookie )
    {
        Assert( _pProgSink );
        _pProgSink->DelProgress( _dwProgCookie );
    }
    ClearInterface(&_pProgSink);
}


//+---------------------------------------------------------------------------
//
//  Member:     CCodeLoad::QueryInterface, IUnknown
//
//  Synopsis:   Per IUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP
CCodeLoad::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IWindowForBindingUI)
    {
        *ppv = (IWindowForBindingUI *)this;
        AddRef();
        return(S_OK);
    }

    return(super::QueryInterface(iid, ppv));
}


//+---------------------------------------------------------------------------
//
//  Member:     CCodeLoad::QueryService, IServiceProvider
//
//  Synopsis:   Per IServiceProvider
//
//----------------------------------------------------------------------------

STDMETHODIMP
CCodeLoad::QueryService(REFGUID rguidService, REFIID riid, void ** ppvObj)
{
    if (rguidService == IID_IWindowForBindingUI)
    {
        return QueryInterface(riid, ppvObj);
    }

    return super::QueryService(rguidService, riid, ppvObj);
}


//+---------------------------------------------------------------------------
//
//  Member:     CCodeLoad::GetWindow, IWindowForBindingUI
//
//  Synopsis:   Per IWindowForBindingUI
//
//----------------------------------------------------------------------------

STDMETHODIMP
CCodeLoad::GetWindow(REFGUID rguidReason, HWND *phwnd)
{
    HRESULT hr;

    if (!_pSiteOle)
    {
        *phwnd = 0;
        hr = E_FAIL;
    }
    else if (_pSiteOle->Doc() && _pSiteOle->Doc()->IsPrintDialogNoUI())
    {
        *phwnd = HWND_DESKTOP;
        hr = S_OK;
    }
    else if (_pSiteOle->Doc()->_dwLoadf & DLCTL_SILENT)
    {
        *phwnd = (HWND)INVALID_HANDLE_VALUE;
        hr = S_FALSE;
    }
    else
    {
        _pSiteOle->Doc()->GetWindowForBinding(phwnd);
        hr = S_OK;
    }

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCodeLoad::OnObjectAvailable, IBindStatusCallback
//
//  Synopsis:   Internet Component Download will call back
//              when object is ready.  Typically a class factory.
//
//----------------------------------------------------------------------------

HRESULT
CCodeLoad::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    HRESULT        hr = E_FAIL;
    IClassFactory *pCF = NULL;

    if (!_pSiteOle)
        goto Cleanup;

    _fGotObject = TRUE;

    if (!_fGotData)
    {
        //
        // Data download is occuring.  Wait until OnChan to create object.
        //

        ReplaceInterface (&_punkObject, punk);
        _iidObject = riid;
        hr = S_OK;
    }
    else
    {
        if (_fGetClassObject && OK(punk->QueryInterface(IID_IClassFactory, (void **)&pCF)))
        {
            hr = THR(_pSiteOle->CreateObjectNow(IID_IClassFactory, pCF, &_info));
        }
        else
        {
            hr = THR(_pSiteOle->CreateObjectNow(riid, punk, &_info));
        }
    }

Cleanup:
    ReleaseInterface(pCF);
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::GetBindInfo, per IBindStatusCallback
//
//-------------------------------------------------------------------------

HRESULT
CCodeLoad::GetBindInfo(DWORD * pdwBindf, BINDINFO * pbindinfo)
{
    HRESULT hr;

    hr = THR(super::GetBindInfo(pdwBindf, pbindinfo));
    if (S_OK == hr && _fGetClassObject)
    {
        *pdwBindf |= BINDF_GETCLASSOBJECT;
    }

    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CCodeLoad::OnProgress, IBindStatusCallback
//
//  Synopsis:   Feedback on code download.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CCodeLoad::OnProgress(ULONG ulPos, ULONG ulMax, ULONG ulCode,
    LPCWSTR pchText)
{
    LPCWSTR pszComponent = NULL;
    ULONG   ulSetProgressFlags;

    if (_pProgSink)
    {
        switch( ulCode )
        {
            case BINDSTATUS_DOWNLOADINGDATA:
            case BINDSTATUS_BEGINDOWNLOADCOMPONENTS:
            case BINDSTATUS_INSTALLINGCOMPONENTS:       
            ulSetProgressFlags = PROGSINK_SET_STATE | PROGSINK_SET_POS | PROGSINK_SET_IDS | PROGSINK_SET_MAX;
            if( pchText )
            {   // Find the component name in the passed in string:
                pszComponent = pchText + wcslen( pchText );
                while( pszComponent > pchText )
                {
                    if( pszComponent[-1] == _T('/') || pszComponent[-1] == _T('\\'))
                    {
                        break;
                    }
                    --pszComponent;
                }
                ulSetProgressFlags |= PROGSINK_SET_TEXT;
            }

            IGNORE_HR(_pProgSink->SetProgress(
              _dwProgCookie,
              ulSetProgressFlags,
              PROGSINK_STATE_LOADING,
              pszComponent,
              IDS_BINDSTATUS_INSTALLINGCOMPONENTS,
              ulPos,
              ulMax ));
            break;
        }
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCodeLoad::OnStartBinding, IBindStatusCallback
//
//  Synopsis:   Feedback on code download.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CCodeLoad::OnStartBinding(DWORD grfBSCOption, IBinding *pbinding)
{
    if (_pSiteOle)
    {
        ReplaceInterface(&_pbinding, pbinding);
    }
    else
    {
        IGNORE_HR(pbinding->Abort());
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCodeLoad::OnStopBinding, IBindStatusCallback
//
//  Synopsis:   Feedback on code download.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CCodeLoad::OnStopBinding(HRESULT hrBinding, LPCWSTR szErr)
{
    CLock   Lock(this);

    ClearInterface(&_pbinding);

        if (_pbctx)
        {
        IGNORE_HR(RevokeBindStatusCallback(_pbctx, this));
            ClearInterface(&_pbctx);
        }

    // if error (e.g., download was aborted or failed to find the object)
    if (hrBinding && _pSiteOle)
    {
        // If download failed due to trust violation, inform user.
        if (hrBinding == TRUST_E_FAIL)
        {
            //
            // Don't show dlg for TRUST_E_SUBJECT_NOT_TRUSTED because that
            // is only returned if user chooses no on authenticode dialog.
            // ie4 bug 38366.
            //
            NotifyHaveProtectedUserFromUnsafeContent(_pSiteOle->GetMarkup(), IDS_OCXDISABLED);
        }

        // in stress, _pSiteOle turns up NULL at this point (not sure why - dbau)
        if (_pSiteOle)
        {
            _pSiteOle->ReleaseCodeLoad();
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function    :   AddBindContextParam
//
//  Description :   Adds a CBindContextParam pointer to the bind context as a 
//                  parameter with the key name of BINDCONTEXT_PARAM if none is specified. 
//                  The class contains the base URL of the document and can
//                  contain additional parameters in the future.
//
//----------------------------------------------------------------------------
HRESULT
AddBindContextParam(IBindCtx *pbctx, CStr * pcstr, IPropertyBag * pPropBag, LPTSTR pstrKey /* NULL */)
{
    HRESULT             hr;
    CBindContextParam * pBindContextParam = NULL;

    pBindContextParam = new CBindContextParam();
    if (!pBindContextParam)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    TraceTag((tagSecurityContext, "AddBindContextParam - URL: %ws", (LPTSTR)(*pcstr)));

    hr = THR(pBindContextParam->Init(pcstr, pPropBag));
    if (hr)
        goto Cleanup;

    if (pstrKey)
        hr = THR(pbctx->RegisterObjectParam(pstrKey, pBindContextParam));
    else
        hr = THR(pbctx->RegisterObjectParam(KEY_BINDCONTEXTPARAM, pBindContextParam));

    if (hr)
        goto Cleanup;

Cleanup:
    if (pBindContextParam)
        pBindContextParam->Release();

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//  Function    :   GetBindContextParamHelper
//
//----------------------------------------------------------------------------
HRESULT
GetBindContextParam(IBindCtx * pBindCtx, CStr * pcstrSourceUrl)
{
    HRESULT             hr;
    IUnknown *          pUnk = NULL;
    IOleCommandTarget * pCommandTarget = NULL;
    CVariant            varUrl;
    DWORD               dwCmdId = BINDCONTEXT_CMDID_BASEURL;

    Assert(pBindCtx);
    Assert(pcstrSourceUrl);

    //
    // get the CBindContextParam object.
    //
    hr = THR(pBindCtx->GetObjectParam(KEY_BINDCONTEXTPARAM, &pUnk));
    if (hr)
        goto Cleanup;

    pBindCtx->RevokeObjectParam(KEY_BINDCONTEXTPARAM);

    hr = THR(pUnk->QueryInterface(IID_IOleCommandTarget, (void**) &pCommandTarget));
    if (hr)
        goto Cleanup;

//  We are hardcoding the cmdid now, however, if we have other commands in the future 
//      this function should be used with a switch statement and an additional param for the function. 
//  (FerhanE)

    hr = THR(pCommandTarget->Exec(
            &CGID_DownloadObjectBindContext,
            dwCmdId,
            0,
            NULL,
            &varUrl));
    if (hr)
        goto Cleanup;

    // Initialize the CStr with the BSTR 
    hr = THR(pcstrSourceUrl->SetBSTR(V_BSTR(&varUrl)));
    if (hr)
        goto Cleanup;

    TraceTag((tagSecurityContext, "GetBindContextParam - Bind context param URL: %ws", (LPTSTR)*pcstrSourceUrl));

Cleanup:
    ReleaseInterface(pUnk); 
    ReleaseInterface(pCommandTarget);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function    :   GetBindInfoParam
//  
//  Description :   
//
//----------------------------------------------------------------------------

#ifdef _WIN64
LWSTDAPI_(BOOL)     StrToInt64ExW(LPCWSTR pszString, DWORD dwFlags, LONGLONG * pllRet);
#endif

HRESULT
GetBindInfoParam( IInternetBindInfo * pIBindInfo, CStr * pcstrSourceUrl)
{
    HRESULT             hr;
    IBindCtx *          pBindCtx = NULL;
    TCHAR *             pchBindCtx = NULL;  // needed for delete 
    DWORD               dwElFetched = 0;
        
    Assert(pIBindInfo);
    Assert(pcstrSourceUrl);

    // get the bind context pointer as a string.
    hr = pIBindInfo->GetBindString(BINDSTRING_PTR_BIND_CONTEXT,
                                    &pchBindCtx, 
                                    0,
                                    &dwElFetched);
    if (hr)
        goto Cleanup;

    // convert the string to an actual pointer
#ifdef _WIN64
    StrToInt64ExW(pchBindCtx, 0, (LONGLONG *)&pBindCtx);
#else
    pBindCtx = (IBindCtx *) StrToInt(pchBindCtx);
#endif
    Assert(pBindCtx);

    hr = THR(GetBindContextParam( pBindCtx, pcstrSourceUrl)); 
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pBindCtx);

// The CoTaskMemFree can crash on WinCE with a NULL pointer(MSDN)(FerhanE)
#ifdef WINCE        
    if (pchBindCtx)                     
#endif
    CoTaskMemFree(pchBindCtx);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CCodeLoad::BindToObject
//
//  Synopsis:   Start binding to code.
//
//----------------------------------------------------------------------------

HRESULT
CCodeLoad::BindToObject()
{
    HRESULT                     hr;
    CLock                       Lock(this);
    BOOL                        fClearTask = TRUE;
    IClassFactory *             pCF = NULL;
    IMoniker *                  pMk = NULL;
    IUnknown *                  pUnkObject = NULL;
    TCHAR *                     pchUrl;
    COleSite::OLECREATEINFO *   pinfo = &_info;
    IBindStatusCallback *       pBSC;
    CDoc *                      pDoc = _pSiteOle->Doc();

    hr = THR(CreateAsyncBindCtxEx(NULL, 0, NULL, NULL, &_pbctx, 0));
    if (hr)
        goto Cleanup;

    pBSC = this;

#if DBG==1
    pBSC->AddRef();
    DbgTrackItf(IID_IBindStatusCallback, "codlod", TRUE, (void **)&pBSC);
#endif

    hr = THR(RegisterBindStatusCallback(_pbctx, pBSC, NULL, NULL));

#if DBG==1
    pBSC->Release();
#endif

    if (hr && hr != S_FALSE) // S_FALSE returned normally
        goto Cleanup;

    if (!IsEqualGUID(g_Zero.guid, pinfo->clsid) ||    // if clsid is not zero, or
        pinfo->pchMimeType)                           // there is MimeType
    {
        IActiveXSafetyProvider *    pSafetyProvider;

        hr = THR(_pSiteOle->Doc()->GetActiveXSafetyProvider(&pSafetyProvider));
        if (hr)
            goto Cleanup;

        if (pSafetyProvider) {
            //
            // An ActiveXSafetyProvider is installed.  Use it to
            // instantiate controls.
            //
            BOOL    fTreatAsUntrusted;

            hr = THR(_pSiteOle->GetMarkupPtr()->ProcessURLAction(URLACTION_ACTIVEX_TREATASUNTRUSTED,
                &fTreatAsUntrusted));
            if (hr)
                goto Cleanup;

            hr = pSafetyProvider->TreatControlAsUntrusted(fTreatAsUntrusted);
            if (hr)
                goto Cleanup;

            if (_pSiteOle->GetMarkupPtr()->IsPrintMedia() && pDoc->_pPrintSecurityMgr )
            {
                AssertSz(pDoc->IsPrintDialog(), "should never have a print security manager except in a printing dialog!");
                hr = pSafetyProvider->SetSecurityManager(pDoc->_pPrintSecurityMgr);
            }
            else
            {
                hr = pSafetyProvider->SetSecurityManager(pDoc->_pSecurityMgr);
            }
            if (hr)
                goto Cleanup;
            hr = pSafetyProvider->SetDocumentURLW(pDoc->GetPrimaryUrl());
            if (hr)
                goto Cleanup;
        }


        // CONSIDER: (alexz) (anandra) it would be good to have monikers support
        // urls like "clsid:......." - so that MkParseDisplayName would return
        // a moniker on clsid, and BindToObject on that moniker would instantiate
        // the object with the clsid. If that is implemented, then here we would
        // not call CoGetClassObjectFromURL but go instead to pchUrl codepath.

        if (!(pDoc->_dwLoadf & DLCTL_NO_DLACTIVEXCTLS))
        {
            //
            // main case - download of activex controls is allowed
            //

            // Need to ensure that the latest version of the Java VM is installed
            if (pinfo->clsid == CLSID_AppletOCX)
            {
                HWND            hwnd     = NULL;
                CDwnDoc       * pDwnDoc  = GetDwnDoc();
                CDoc          * pDoc     = NULL;
                uCLSSPEC        classpec;

                if (pDwnDoc)
                {
                    pDoc = pDwnDoc->GetCDoc();
                    if (pDoc)
                        hwnd = pDoc->GetHWND();
                }

                classpec.tyspec             = TYSPEC_CLSID;
                classpec.tagged_union.clsid = pinfo->clsid;

                hr = THR(FaultInIEFeatureHelper(hwnd, &classpec, NULL, 0));

                // We don't want to use an older version of the VM
                if (FAILED(hr))
                    goto Cleanup;
            }

            hr =  THR(CoGetClassObjectFromURL(
                        pinfo->clsid,
                        pinfo->pchSourceUrl,
                        pinfo->dwMajorVer,
                        pinfo->dwMinorVer,
                        pinfo->pchMimeType,
                        _pbctx,
                        CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER | CLSCTX_LOCAL_SERVER,
                        NULL,
                        IID_IClassFactory,
                        (void **)&pCF));
        }
        else
        {
            //
            // we are not allowed to download activex control so try to
            // instantiate from local machine (common scenario - in WebCheck)
            //

            if (pSafetyProvider) {
                hr = THR(pSafetyProvider->SafeGetClassObject(
                    pinfo->clsid,
                    CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER | CLSCTX_LOCAL_SERVER,
                    NULL,
                    IID_IClassFactory,
                    (IUnknown **)&pCF));
            } else {
                hr = THR(CoGetClassObject(
                    pinfo->clsid,
                    CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER | CLSCTX_LOCAL_SERVER,
                    NULL,
                    IID_IClassFactory,
                    (void **)&pCF));
            }
        }
    }
    else
    {
        ULONG   cchEaten;
        CStr cstrSpecialURL;
        TCHAR * pchCID;

        if (pinfo->pchClassid)
        {
            pchUrl = pinfo->pchClassid;
            _fGetClassObject = TRUE;
        }
        else
        {
            pchUrl = pinfo->pchDataUrl;
        }

        // since the UrlCompare also calls this, it is not a problem to call it here.
        // we need it to protect against cases where .HTA can be written as .ht%61
        hr = THR(UrlUnescape( pchUrl, NULL, NULL, URL_UNESCAPE_INPLACE));
        if (hr)
            goto Cleanup;

        // Binding to an HTA in this manner is a security hole.
        if (!pchUrl || !StrCmpI(PathFindExtension(pchUrl), _T(".HTA")))
            goto Cleanup;

        // we don't want to continue if the URL we have is the same
        // with the Urls of any of the parent documents.
        if (_pSiteOle->IsInMarkup())
        {                         
            if (_pSiteOle->GetMarkup()->IsUrlRecursive(pchUrl))
                goto Cleanup;
        }

        hr = E_FAIL;

        // do not allow code objects in OE mail
        if (_tcsnipre( _T("mhtml:"), 6, pchUrl,  -1))
        {
            pchCID = _tcschr(pchUrl, _T('!'));
            if (pchCID)
            {
                pchCID++;
                if (_tcsnipre( _T("cid:"), 4, pchCID,  -1))
                    goto Cleanup;
            }
        }

        //
        // First try MkParseDisplayName because MkParseDisplayNameEx
        // seems to have a bug in it where it doesn't forward to
        // MkParseDisplayName.  This is needed for TracySh's java:
        // moniker.  Look at ie4 bug 45662.  (anandra)
        //
        if (!_tcsnipre( _T("file:"), 5, pchUrl,  -1))
            hr = THR_NOTRACE(MkParseDisplayName(_pbctx, pchUrl, &cchEaten, &pMk));
        if (hr)
        {
            hr = THR(MkParseDisplayNameEx(_pbctx, pchUrl, &cchEaten, &pMk));
            if (hr)
                goto Cleanup;
        }

        TCHAR * pchBaseUrl;
        CStr    cstrBindCtxUrl;
            
        hr = THR(CMarkup::GetBaseUrl(NULL, &pchBaseUrl, _pSiteOle));
        hr = THR(cstrBindCtxUrl.Set(pchBaseUrl));
        if (hr) 
            goto Cleanup;

        hr = THR(AddBindContextParam(_pbctx, &cstrBindCtxUrl, _info.pPropBag));
        if (hr)
            goto Cleanup;


        hr = THR(pMk->BindToObject(
                _pbctx,
                NULL,
                IID_IUnknown,
                (void **)&pUnkObject));
        if (!OK(hr))
            goto Cleanup;
    }

    if (S_OK == hr)
    {
        //
        // the object is immediately available, signal OnObjectAvailable
        //

        if (pCF)
        {
            hr = THR(OnObjectAvailable(IID_IClassFactory, pCF));
        }
        else
        {
            Assert(pUnkObject);
            hr = THR(OnObjectAvailable(IID_IUnknown, pUnkObject));
        }
    }
    else if (MK_S_ASYNCHRONOUS == hr)
    {
        //
        // Block this task until OnObjectAvailable
        //

        fClearTask = FALSE;
    }
    else if (TRUST_E_FAIL == hr)
    {
            NotifyHaveProtectedUserFromUnsafeContent(_pSiteOle->GetMarkup(), IDS_OCXDISABLED);
    }


Cleanup:
    ReleaseInterface (pCF);
    ReleaseInterface (pMk);
    ReleaseInterface (pUnkObject);

    //
    // Clear up internal state in the case where the class
    // factory is already available.
    //

    if (fClearTask && _pbctx)
    {
        IGNORE_HR(RevokeBindStatusCallback(_pbctx, this));
    }

    RRETURN1(hr, MK_S_ASYNCHRONOUS);
}

///////////////////////////////////////////////////////////////////////////////////////////
//
// CBindContextParam methods
//
//

CBindContextParam::CBindContextParam()
{
    _ulRefs = 1;
    _pPropBag = NULL;
}

CBindContextParam::~CBindContextParam()
{
    if(_pPropBag)
        _pPropBag->Release();
}

HRESULT
CBindContextParam::QueryInterface(REFIID iid, void ** ppv)
{
    switch (iid.Data1)
    {
        QI_INHERITS(this, IUnknown)
        QI_INHERITS(this, IOleCommandTarget)

    default:
        *ppv = NULL;
        RRETURN (E_NOINTERFACE);
    }

    AddRef();
    return S_OK;
}

HRESULT
CBindContextParam::Init(CStr * pcstrData, IPropertyBag * pPropBag)
{
    Assert(pcstrData);
    
    ReplaceInterface(&_pPropBag, pPropBag);

    RRETURN(THR(_cstrBaseUrl.Set((LPTSTR)(*pcstrData))));
}

HRESULT
CBindContextParam::Exec(
    const GUID *    pguidCmdGroup,
    DWORD           nCmdID,
    DWORD           nCmdexecopt,
    VARIANT *       pvarIn,
    VARIANT *       pvarOut)
{
    HRESULT hr = S_OK;

    if (IsEqualGUID(*pguidCmdGroup, CGID_DownloadObjectBindContext))
    {
        if (!pvarOut)
        {
            hr = E_POINTER;
            goto Cleanup;
        }

        switch (nCmdID)
        {
        case BINDCONTEXT_CMDID_BASEURL:
            // *** external dependency: also called from shdocvw ***
            V_VT(pvarOut) = VT_BSTR;
            hr = THR(FormsAllocString(_cstrBaseUrl, &V_BSTR(pvarOut)));
            break;

        case BINDCONTEXT_CMDID_PROPBAG:
            if (_pPropBag)
            {
                V_VT(pvarOut) = VT_UNKNOWN;
                V_UNKNOWN(pvarOut) = _pPropBag;
                _pPropBag->AddRef();
                break;
            }

            // Fall thru

        default:
            hr = OLECMDERR_E_NOTSUPPORTED;
            break;
        }
    }
    else
    {
        hr = OLECMDERR_E_UNKNOWNGROUP;
    }

Cleanup:
    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\ole\clstab.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       clstab.cxx
//
//  Contents:   Class table for CDoc.
//
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_CLSTAB_HXX_
#define X_CLSTAB_HXX_
#include "clstab.hxx"
#endif

#ifndef X_TYPENAV_HXX_
#define X_TYPENAV_HXX_
#include <typenav.hxx>
#endif

#ifndef X_OBJEXT_H_
#define X_OBJEXT_H_
#include <objext.h>
#endif

MtDefine(CClassTable, CDoc, "CClassTable")
MtDefine(CClassTable_aryci_pv, CClassTable, "CClassTable::_aryci::_pv")

EXTERN_C const CLSID CLSID_IE4ShellFolderIcon = { 0xE5DF9D10, 0x3B52, 0x11D1, 0x83, 0xE8, 0x00, 0xA0, 0xC9, 0x0D, 0xC8, 0x49 };
EXTERN_C const CLSID CLSID_IE4ShellPieChart =   { 0x1D2B4F40, 0x1F10, 0x11D1, 0x9E, 0x88, 0x00, 0xC0, 0x4F, 0xDC, 0xAB, 0x92 };
EXTERN_C const CLSID CLSID_AppletOCX =          { 0x08B0e5c0, 0x4FCB, 0x11CF, 0xAA, 0xA5, 0x00, 0x40, 0x1C, 0x60, 0x85, 0x01 };
#if DBG == 1
EXTERN_C const CLSID CLSID_WebBrowser;
         const CLSID CLSID_IISForm =            { 0x812AE312, 0x8B8E, 0x11CF, 0x93, 0xC8, 0x00, 0xAA, 0x00, 0xC0, 0x8F, 0xDF };
         const CLSID CLSID_Forms3Optionbutton = { 0x8BD21D50, 0xEC42, 0x11CE, 0x9E, 0x0D, 0x00, 0xAA, 0x00, 0x60, 0x02, 0xF3 };
         const CLSID CLSID_Acrobat =            { 0xCA8A9780, 0x280D, 0x11CF, 0xA2, 0x4D, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00 };
         const CLSID CLSID_SurroundVideo =      { 0x928626A3, 0x6B98, 0x11CF, 0x90, 0xB4, 0x00, 0xAA, 0x00, 0xA4, 0x01, 0x1F };
         const CLSID CLSID_MSInvestor =         { 0xD2F97240, 0xC9F4, 0x11CF, 0xBF, 0xC4, 0x00, 0xA0, 0xC9, 0x0C, 0x2B, 0xDB };
         const CLSID CLSID_PowerPointAnimator = { 0xEFBD14F0, 0x6BFB, 0x11CF, 0x91, 0x77, 0x00, 0x80, 0x5F, 0x88, 0x13, 0xFF };
         const CLSID CLSID_MSInvestorNews =     { 0x025B1052, 0xCB0B, 0x11CF, 0xA0, 0x71, 0x00, 0xA0, 0xC9, 0xA0, 0x6E, 0x05 };
         const CLSID CLSID_MSTreeView =         { 0xB9D029D3, 0xCDE3, 0x11CF, 0x85, 0x5E, 0x00, 0xA0, 0xC9, 0x08, 0xFA, 0xF9 };
         const CLSID CLSID_ActiveMovie =        { 0x05589fa1, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a };
         const CLSID CLSID_MediaPlayer =        { 0x22D6F312, 0xB0F6, 0x11D0, 0x94, 0xAB, 0x00, 0x80, 0xC7, 0x4C, 0x7E, 0x95 };
         const CLSID CLSID_MCSITree =           { 0xB3F8F451, 0x788A, 0x11D0, 0x89, 0xD9, 0x00, 0xA0, 0xC9, 0x0C, 0x9B, 0x67 };
         const CLSID CLSID_IEMenu =             { 0x7823A620, 0x9DD9, 0x11CF, 0xA6, 0x62, 0x00, 0xaa, 0x00, 0xC0, 0x66, 0xD2 };
         const CLSID CLSID_CitrixWinframe =     { 0x238f6f83, 0xb8b4, 0x11cf, 0x87, 0x71, 0x00, 0xa0, 0x24, 0x54, 0x1e, 0xe3 };
         const CLSID CLSID_VivoViewer =         { 0x02466323, 0x75ed, 0x11cf, 0xa2, 0x67, 0x00, 0x20, 0xaf, 0x25, 0x46, 0xea };
         const CLSID CLSID_SheridanCommand =    { 0xAAD093B2, 0xF9CA, 0x11CF, 0x9C, 0x85, 0x00, 0x00, 0xC0, 0x93, 0x00, 0xC4 };
         const CLSID CLSID_VActive =            { 0x5A20858B, 0x000D, 0x11D0, 0x8C, 0x01, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00 };
         const CLSID CLSID_SaxCanvas =          { 0x1DF67C43, 0xAEAA, 0x11CF, 0xBA, 0x92, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00 };
         const CLSID CLSID_GregConsDieRoll =    { 0x46646B43, 0xEA16, 0x11CF, 0x87, 0x0C, 0x00, 0x20, 0x18, 0x01, 0xDD, 0xD6 };
         const CLSID CLSID_NCompassBillboard =  { 0x6059B947, 0xEC52, 0x11CF, 0xB5, 0x09, 0x00, 0xA0, 0x24, 0x48, 0x8F, 0x73 };
         const CLSID CLSID_NCompassLightboard = { 0xB2F87B84, 0x26A6, 0x11D0, 0xB5, 0x0A, 0x00, 0xA0, 0x24, 0x48, 0x8F, 0x73 };
         const CLSID CLSID_ProtoviewTreeView =  { 0xB283E214, 0x2CB3, 0x11D0, 0xAD, 0xA6, 0x00, 0x40, 0x05, 0x20, 0x79, 0x9C };
         const CLSID CLSID_ActiveEarthTime =    { 0x9590092D, 0x8811, 0x11CF, 0x80, 0x75, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00 };
         const CLSID CLSID_LeadControl =        { 0x00080000, 0xB1BA, 0x11CE, 0xAB, 0xC6, 0xF5, 0xB2, 0xE7, 0x9D, 0x9E, 0x3F };
         const CLSID CLSID_TextX =              { 0x5B84FC03, 0xE639, 0x11CF, 0xB8, 0xA0, 0x00, 0xA0, 0x24, 0x18, 0x6B, 0xF1 };
         const CLSID CLSID_Plugin =             { 0x06DD38D3, 0xD187, 0x11CF, 0xA8, 0x0D, 0x00, 0xC0, 0x4F, 0xD7, 0x4A, 0xD8 };
         const CLSID CLSID_GreetingsUpload =    { 0x03405265, 0xb4e2, 0x11d0, 0x8a, 0x77, 0x00, 0xaa, 0x00, 0xa4, 0xfb, 0xc5 };
         const CLSID CLSID_GreetingsDownload =  { 0x03405269, 0xb4e2, 0x11d0, 0x8a, 0x77, 0x00, 0xaa, 0x00, 0xa4, 0xfb, 0xc5 };
         const CLSID CLSID_COMCTLTree =         { 0x0713E8A2, 0x850A, 0x101B, 0xAF, 0xC0, 0x42, 0x10, 0x10, 0x2A, 0x8D, 0xA7 };
         const CLSID CLSID_COMCTLProg =         { 0x0713E8D2, 0x850A, 0x101B, 0xAF, 0xC0, 0x42, 0x10, 0x10, 0x2A, 0x8D, 0xA7 };
         const CLSID CLSID_COMCTLImageList =    { 0x58DA8D8F, 0x9D6A, 0x101B, 0xAF, 0xC0, 0x42, 0x10, 0x10, 0x2A, 0x8D, 0xA7 };
         const CLSID CLSID_COMCTLListview =     { 0x58DA8D8A, 0x9D6A, 0x101B, 0xAF, 0xC0, 0x42, 0x10, 0x10, 0x2A, 0x8D, 0xA7 };
         const CLSID CLSID_COMCTLSbar =         { 0x6B7E638F, 0x850A, 0x101B, 0xAF, 0xC0, 0x42, 0x10, 0x10, 0x2A, 0x8D, 0xA7 };
         const CLSID CLSID_MCSIMenu =           { 0x275E2FE0, 0x7486, 0x11D0, 0x89, 0xD6, 0x00, 0xA0, 0xC9, 0x0C, 0x9B, 0x67 };
         const CLSID CLSID_MSNVer =             { 0xA123D693, 0x256A, 0x11d0, 0x9D, 0xFE, 0x00, 0xC0, 0x4F, 0xD7, 0xBF, 0x41 };
         const CLSID CLSID_RichTextCtrl =       { 0x3B7C8860, 0xD78F, 0x101B, 0xB9, 0xB5, 0x04, 0x02, 0x1C, 0x00, 0x94, 0x02 };
         const CLSID CLSID_IETimer =            { 0x59CCB4A0, 0x727D, 0x11CF, 0xAC, 0x36, 0x00, 0xAA, 0x00, 0xA4, 0x7D, 0xD2 };
         const CLSID CLSID_SubScr =             { 0x78A9B22E, 0xE0F4, 0x11D0, 0xB5, 0xDA, 0x00, 0xC0, 0xF0, 0x0A, 0xD7, 0xF8 };
EXTERN_C const CLSID CLSID_Scriptlet;  //AE24FDAE-03C6-11D1-8B76-0080C744F389
         const CLSID CLSID_OldXsl =             { 0x2BD0D2F2, 0x52EC, 0x11D1, 0x8C, 0x69, 0x0E, 0x16, 0xBC, 0x00, 0x00, 0x00 };
         const CLSID CLSID_MMC =                { 0xD306C3B7, 0x2AD5, 0x11D1, 0x9E, 0x9A, 0x00, 0x80, 0x5F, 0x20, 0x00, 0x05 };
         const CLSID CLSID_RealAudio =          { 0xCFCDAA03, 0x8BE4, 0x11CF, 0xB8, 0x4B, 0x00, 0x20, 0xAF, 0xBB, 0xCC, 0xFA };
         const CLSID CLSID_WebCalc =            { 0x0002E510, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 };
         const CLSID CLSID_AnswerList =         { 0x8F2C1D40, 0xC3CD, 0x11D1, 0xA0, 0x8F, 0x00, 0x60, 0x97, 0xBD, 0x99, 0x70 };
         const CLSID CLSID_PreLoader =          { 0x16E349E0, 0x702C, 0x11CF, 0xA3, 0xA0, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0x20 };
         const CLSID CLSID_EyeDog =             { 0x06A7EC63, 0x4E21, 0x11D0, 0xA1, 0x12, 0x00, 0xA0, 0xC9, 0x05, 0x43, 0xAA };
         const CLSID CLSID_ImgAdmin =           { 0x009541A0, 0x3B81, 0x101C, 0x92, 0xF3, 0x04, 0x02, 0x24, 0x00, 0x9C, 0x02 };
         const CLSID CLSID_ImgThumb =           { 0xE1A6B8A0, 0x3603, 0x101C, 0xAC, 0x6E, 0x04, 0x02, 0x24, 0x00, 0x9C, 0x02 };
         const CLSID CLSID_HHOpen =             { 0x130D7743, 0x5F5A, 0x11D1, 0xB6, 0x76, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x33 };
         const CLSID CLSID_RegWiz =             { 0x50E5E3D1, 0xC07E, 0x11D0, 0xB9, 0xFD, 0x00, 0xA0, 0x24, 0x9F, 0x6B, 0x00 };
         const CLSID CLSID_SetupCtl =           { 0xF72A7B0E, 0x0DD8, 0x11D1, 0xBD, 0x6E, 0x00, 0xAA, 0x00, 0xB9, 0x2A, 0xF1 };
         const CLSID CLSID_ImgEdit =            { 0x6D940280, 0x9F11, 0x11CE, 0x83, 0xFD, 0x02, 0x60, 0x8C, 0x3E, 0xC0, 0x8A };
         const CLSID CLSID_ImgEdit2 =           { 0x6D940285, 0x9F11, 0x11CE, 0x83, 0xFD, 0x02, 0x60, 0x8C, 0x3E, 0xC0, 0x8A };
         const CLSID CLSID_ImgScan =            { 0x84926CA0, 0x2941, 0x101C, 0x81, 0x6F, 0x0E, 0x60, 0x13, 0x11, 0x4B, 0x7F };
         const CLSID CLSID_IELabel =            { 0x99B42120, 0x6EC7, 0x11CF, 0xA6, 0xC7, 0x00, 0xAA, 0x00, 0xA4, 0x7D, 0xD2 };
         const CLSID CLSID_HomePubRender =      { 0x96B9602E, 0xBD20, 0x11D2, 0xAC, 0x89, 0x00, 0xC0, 0x4F, 0x79, 0x89, 0xD6 };
         const CLSID CLSID_MGIPhotoSuiteBtn =   { 0x4FA211A0, 0xFD53, 0x11D2, 0xAC, 0xB6, 0x00, 0x80, 0xC8, 0x77, 0xD9, 0xB9 };
         const CLSID CLSID_MGIPhotoSuiteSlider ={ 0x105C7D20, 0xFE19, 0x11D2, 0xAC, 0xB6, 0x00, 0x80, 0xC8, 0x77, 0xD9, 0xB9 };
         const CLSID CLSID_MGIPrintShopSlider  ={ 0x7B9379D2, 0xE1E4, 0x11D0, 0x84, 0x44, 0x00, 0x40, 0x1C, 0x60, 0x75, 0xAA };
         const CLSID CLSID_RunLocExe =          { 0x73822330, 0xB759, 0x11D0, 0x9E, 0x3D, 0x00, 0xA0, 0xC9, 0x11, 0xC8, 0x19 };
         const CLSID CLSID_Launchit2 =          { 0xB75FEF72, 0x0C54, 0x11D2, 0xB1, 0x4E, 0x00, 0xC0, 0x4F, 0xB9, 0x35, 0x8B };
         const CLSID CLSID_MS_MSHTA =            {0x3050f4d8, 0x98b5, 0x11cf, {0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b}};
         const CLSID CLSID_ShavlikSec =         { 0x913C89C0, 0x492C, 0x11D4, 0x91, 0x1A, 0x00, 0x90, 0x27, 0x37, 0x06, 0x74 }; 
         const CLSID CLSID_TSActiveX1 =         { 0x1FB464C8, 0x09BB, 0x4017, 0xA2, 0xf5, 0xEB, 0x74, 0x2F, 0x04, 0x39, 0x2F }; 
         const CLSID CLSID_TSActiveX_WinXPGold= { 0x791FA017, 0x2DE3, 0x492E, 0xAC, 0xC5, 0x53, 0xC6, 0x7A, 0x2B, 0x94, 0xD0 }; 
         const CLSID CLSID_TSActiveX_Server   = { 0x931A8c29, 0x3EA9, 0x494D, 0x91, 0xE7, 0x22, 0xE9, 0xA9, 0x24, 0x76, 0x87 }; 
         const CLSID CLSID_Chat3              = { 0x81361155, 0xFAF9, 0x11D3, 0xB0, 0xD3, 0x00, 0xC0, 0x4F, 0x61, 0x2F, 0xF1 };
         const CLSID CLSID_Chat3HistoryCtl    = { 0x81361143, 0xFAF9, 0x11D3, 0xB0, 0xD3, 0x00, 0xC0, 0x4F, 0x61, 0x2F, 0xF1 };
         const CLSID CLSID_Chat3MemberCtl     = { 0x81361146, 0xFAF9, 0x11D3, 0xB0, 0xD3, 0x00, 0xC0, 0x4F, 0x61, 0x2F, 0xF1 };
         const CLSID CLSID_Chat3InputCtl      = { 0x81361149, 0xFAF9, 0x11D3, 0xB0, 0xD3, 0x00, 0xC0, 0x4F, 0x61, 0x2F, 0xF1 };
         const CLSID CLSID_Chat3Items         = { 0x8136114B, 0xFAF9, 0x11D3, 0xB0, 0xD3, 0x00, 0xC0, 0x4F, 0x61, 0x2F, 0xF1 };
         const CLSID CLSID_Chat3ChannelObject = { 0x8136114D, 0xFAF9, 0x11D3, 0xB0, 0xD3, 0x00, 0xC0, 0x4F, 0x61, 0x2F, 0xF1 };
         const CLSID CLSID_Chat3ChannelsCollection = { 0x8136114F, 0xFAF9, 0x11D3, 0xB0, 0xD3, 0x00, 0xC0, 0x4F, 0x61, 0x2F, 0xF1 };
         const CLSID CLSID_Chat3MsCCPr        = { 0x81361152, 0xFAF9, 0x11D3, 0xB0, 0xD3, 0x00, 0xC0, 0x4F, 0x61, 0x2F, 0xF1 };
         const CLSID CLSID_Chat4              = { 0xE87A6788, 0x1D0F, 0x4444, 0x88, 0x98, 0x1D, 0x25, 0x82, 0x9B, 0x67, 0x55 };
         const CLSID CLSID_Chat4_2            = { 0x9088E688, 0x063A, 0x4806, 0xA3, 0xDB, 0x65, 0x22, 0x71, 0x2F, 0xC0, 0x61 };
         const CLSID CLSID_Chat41             = { 0x29C13B62, 0xB9F7, 0x4CD3, 0x8C, 0xEF, 0x0A, 0x58, 0xA1, 0xA9, 0x94, 0x41 };
         const CLSID CLSID_MSFlUpl            = { 0x886E7BF0, 0xC867, 0x11CF, 0xB1, 0xAE, 0x00, 0xAA, 0x00, 0xA3, 0xF2, 0xC3 };
         const CLSID CLSID_LMReader1          = { 0x183C259A, 0x0480, 0x11d1, 0x87, 0xEA, 0x00, 0xC0, 0x4F, 0xC2, 0x9D, 0x46 };
         const CLSID CLSID_MSNInstallEnginer1 = { 0x1141B704, 0x053E, 0x11D0, 0x9D, 0xF0, 0x00, 0xC0, 0x4F, 0xD7, 0xBF, 0x41 };
         const CLSID CLSID_XENROLL            = { 0x43F8F289, 0x7A20, 0x11D0, 0x8F, 0x06, 0x00, 0xC0, 0x4F, 0xC2, 0x95, 0xE1 };
         const CLSID CLSID_SCRDENRL           = { 0x80CB7887, 0x20DE, 0x11D2, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xC2, 0x9D, 0x45 }; 
         const CLSID CLSID_DirectXFilesViewer = { 0x970C7E08, 0x05A7, 0x11D0, 0x89, 0xAA, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x29 };
         const CLSID CLSID_PluginOCX          = { 0x06DD38D3, 0xD187, 0x11CF, 0xA8, 0x0D, 0x00, 0xC0, 0x4F, 0xD7, 0x4A, 0xD8 };

    //
    // This table exists to double check the table in the registry.
    // It is incredibly easy for a typo to corrupt the copy of this table
    // that is stored in f3\rsrc\selfreg.inx and gets propagated to the registry.
    //
struct CompatibilityTableElementAssert
{
    const CLSID *pclsid;
    DWORD        dwCompatFlags;
    DWORD        dwMiscStatusFlags;
} s_aCompatibility[] = 
{
    // 
    // W A R N I N G - Review this list on a regular basis.
    //                 We might find that some of these controls
    //                 fix their problems.
    //
    // **  I M P O R T A N T  **
    //
    // To add to this compatibility table do the following steps:
    //
    // 1. Create a new COMPAT_* flag in clstab.hxx if needed.
    // 2. Implement the COMPAT_* flag check and associated special behavior in
    //    olesite.cxx or whereever.
    // 3. Add the clsid of the particular ActiveX control to the declarations
    //    above if not already there.
    // 4. Add a new entry to the table below for that clsid if not already there.
    //    ** VERY IMPORTANT:  Keep the table sorted in ascending clsid order.
    //    ** EVEN MORE IMPORTANT: Keeping the table sorted is no longer necessary.
    // 5. Add a corresponding clsid string and table entry to the [CompatTable.Reg]
    //    section of msthml\src\f3\rsrc\selfreg.inx.
    // 6. Increment the szOurVersion version number declaration below.
    // 7. Increment the "Version" reg entry value in the [CompatTable.Reg] section
    //    of selfreg.inx.
    //    ** if you fail to do this, your additions will not be installed
    //       into the registry, since ShouldWeRegisterCompatibilityTable()
    //       will think the table is unchanged.
    // 8. Build and do mshtmpad /local to put the new entry in the registry on your
    //    machine.
    // 9. When you check in warn everyone that they must do mshtmpad /local or they
    //    will get asserts.
    //

    { &CLSID_VivoViewer, COMPAT_SEND_SHOW, 0}, 
    { &CLSID_MSInvestorNews, COMPAT_NO_UIACTIVATE | COMPAT_NO_QUICKACTIVATE, 0 },
    { &CLSID_ActiveMovie, COMPAT_INPLACEACTIVATEEVENWHENINVISIBLE, 0 },
    { &CLSID_Plugin,    COMPAT_ALWAYS_INPLACEACTIVATE, 0 },
    { &CLSID_AppletOCX, COMPAT_INPLACEACTIVATEEVENWHENINVISIBLE, 0 },
    { &CLSID_SaxCanvas, COMPAT_ALWAYS_INPLACEACTIVATE | COMPAT_PROGSINK_UNTIL_ACTIVATED, 0 },
    { &CLSID_MediaPlayer, COMPAT_INPLACEACTIVATEEVENWHENINVISIBLE | COMPAT_NEEDSZEROBASEDDRAWRECT, 0 },
    { &CLSID_CitrixWinframe, COMPAT_USE_PROPBAG_AND_STREAM, 0 },
    { &CLSID_GregConsDieRoll, COMPAT_ALWAYS_INPLACEACTIVATE | COMPAT_DISABLEWINDOWLESS, 0 },
    { &CLSID_VActive, COMPAT_SEND_SHOW, 0 },
    { &CLSID_IEMenu, COMPAT_ALWAYS_INPLACEACTIVATE, 0 },
    { &CLSID_WebBrowser, COMPAT_AGGREGATE | COMPAT_ALWAYS_INPLACEACTIVATE, 0 },
    { &CLSID_Forms3Optionbutton, COMPAT_AGGREGATE, 0 },
    { &CLSID_SurroundVideo, COMPAT_NO_SETEXTENT, 0 },
    { &CLSID_MSTreeView, COMPAT_ALWAYS_INPLACEACTIVATE },
    { &CLSID_Acrobat, COMPAT_SEND_SHOW | COMPAT_PRINTPLUGINSITE, 0 },
    { &CLSID_MSInvestor, COMPAT_SEND_HIDE, 0 },
    { &CLSID_PowerPointAnimator, COMPAT_NO_SETEXTENT | COMPAT_NO_BINDF_OFFLINEOPERATION, 
        OLEMISC_INSIDEOUT | OLEMISC_ACTIVATEWHENVISIBLE },
    { &CLSID_SheridanCommand, COMPAT_DISABLEWINDOWLESS },
    { &CLSID_MCSITree, COMPAT_ALWAYS_INPLACEACTIVATE | COMPAT_PROGSINK_UNTIL_ACTIVATED, 0 },
    { &CLSID_NCompassBillboard,   COMPAT_SETWINDOWRGN, 0 },
    { &CLSID_NCompassLightboard,  COMPAT_SETWINDOWRGN, 0 },
    { &CLSID_ProtoviewTreeView,   COMPAT_SETWINDOWRGN, 0 },
    { &CLSID_ActiveEarthTime,     COMPAT_SETWINDOWRGN, 0 },
    { &CLSID_LeadControl,         COMPAT_SETWINDOWRGN, 0 },
    { &CLSID_TextX, COMPAT_DISABLEWINDOWLESS, 0 },
    { &CLSID_IISForm, COMPAT_NO_OBJECTSAFETY, 0 },
    { &CLSID_GreetingsUpload, COMPAT_ALWAYS_INPLACEACTIVATE, 0 },
    { &CLSID_GreetingsDownload, COMPAT_ALWAYS_INPLACEACTIVATE, 0 },
    { &CLSID_COMCTLTree, COMPAT_ALWAYS_INPLACEACTIVATE | COMPAT_PROGSINK_UNTIL_ACTIVATED, 0 },
    { &CLSID_COMCTLProg, COMPAT_ALWAYS_INPLACEACTIVATE | COMPAT_PROGSINK_UNTIL_ACTIVATED, 0 },
    { &CLSID_COMCTLImageList, COMPAT_ALWAYS_INPLACEACTIVATE | COMPAT_PROGSINK_UNTIL_ACTIVATED, 0 },
    { &CLSID_COMCTLListview, COMPAT_ALWAYS_INPLACEACTIVATE | COMPAT_PROGSINK_UNTIL_ACTIVATED, 0 },
    { &CLSID_COMCTLSbar, COMPAT_ALWAYS_INPLACEACTIVATE | COMPAT_PROGSINK_UNTIL_ACTIVATED, 0 },
    { &CLSID_MCSIMenu, COMPAT_ALWAYS_INPLACEACTIVATE, 0 },
    { &CLSID_MSNVer, COMPAT_ALWAYS_INPLACEACTIVATE, 0 },
    { &CLSID_RichTextCtrl, COMPAT_EVIL_DONT_LOAD, 0 },
    { &CLSID_IETimer, COMPAT_ALWAYS_INPLACEACTIVATE, 0 },
    { &CLSID_SubScr, COMPAT_EVIL_DONT_LOAD, 0 },
    { &CLSID_Scriptlet, COMPAT_ALWAYS_INPLACEACTIVATE, 0 },
    { &CLSID_OldXsl, COMPAT_EVIL_DONT_LOAD, 0 },
    { &CLSID_MMC, COMPAT_EVIL_DONT_LOAD, 0 },
    { &CLSID_RealAudio, COMPAT_INPLACEACTIVATEEVENWHENINVISIBLE, 0 },
    { &CLSID_WebCalc, COMPAT_ALWAYSDEFERSETWINDOWRGN, 0},
    { &CLSID_AnswerList, COMPAT_INPLACEACTIVATESYNCHRONOUSLY, 0 },
    { &CLSID_PreLoader, COMPAT_EVIL_DONT_LOAD, 0 },

    // Hack for IE5 #68793. These controls, used in IE4 shell webview, mess up tabbing once
    // they get focus. Make them unfocussable. The controls will be fixed in NT5 and given
    // new clsids.
    { &CLSID_IE4ShellFolderIcon, COMPAT_NEVERFOCUSSABLE, 0 },
    { &CLSID_IE4ShellPieChart, COMPAT_NEVERFOCUSSABLE, 0 },
    // End hack

    { &CLSID_EyeDog, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_ImgAdmin, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_ImgThumb, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_HHOpen, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_RegWiz, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_SetupCtl, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_ImgEdit, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_ImgEdit2, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_ImgScan, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_IELabel, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_HomePubRender, COMPAT_NEEDSZEROBASEDDRAWRECT, 0},
    { &CLSID_MGIPhotoSuiteBtn, COMPAT_HWNDPRIVATE, 0},
    { &CLSID_MGIPhotoSuiteSlider, COMPAT_HWNDPRIVATE, 0},
    { &CLSID_MGIPrintShopSlider, COMPAT_HWNDPRIVATE, 0},
    { &CLSID_RunLocExe, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_Launchit2, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_MS_MSHTA, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_ShavlikSec, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_TSActiveX1, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_TSActiveX_WinXPGold, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_TSActiveX_Server, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_Chat3, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_Chat3HistoryCtl, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_Chat3MemberCtl, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_Chat3InputCtl, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_Chat3Items, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_Chat3ChannelObject, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_Chat3ChannelsCollection, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_Chat3MsCCPr, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_Chat4, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_Chat4_2, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_Chat41, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_MSFlUpl, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_LMReader1, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_MSNInstallEnginer1, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_XENROLL, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_SCRDENRL, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_DirectXFilesViewer, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_PluginOCX, COMPAT_EVIL_DONT_LOAD, 0},
};
#endif

//
// This needs to stay in sync with the Version value in selfreg.inx!
// Note: this version number is also used for urlcomp.cxx
//

extern const TCHAR szOurVersion[];
const TCHAR szOurVersion[] = _T("6.11");

/*
Format of the registry entries
ROOT_LOCATION 
 =HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Explorer\ActiveX Compatibility

That root location key will have one value, "Version" = REG_SZ "5.00". 
This gives the version number of the compatability table. Initially the version 
numberwill be "0.0" allowing increments during development. At RTM it will be "5.00".

Under that will be keys with CLSID names with the same format as HKCR\CLSID.
Each of those CLSID subkeys may have two values.  Either or both values may be absent.
  {SOME-CLSID-VALUE-0000001}\ value name "Compatibility Flags" REG_DWORD 12345
  {SOME-CLSID-VALUE-0000001}\ value name "MiscStatus Flags"    REG_DWORD 12345

The Compat Flags value holds the COMPAT_* type flags.
The OleMiscFlags value holds our OLEMISC_* flags but uses a different name & structure
than in HKCR\CLSID. In that location they have MiscStatus\<version number>.
We don't track the version number of the control we instantiate, so we have
no <version number> subkey.

Self Registration
The compat table will be stored in f3\rsrc\selfreg.inx and written during normal
DLLInstall() operation.  It will be written
if the ROOT_LOCATION key does notexist or if the mshtml.dll 
compatibility table version number is > than thatin the registry. 
Such "reluctant" writing of the compatibility table will
allow users or others to add, modify, or delete entries in the compatibility
table and those changes will not be overwritten easily.
If mshtml.dll is writing the compatibility table to the registry due to a
compat table version number increase it will add entries but not remove
entries that may have been put there by someone else.
*/

static TCHAR szTableRootKey[] = 
   _T("Software\\Microsoft\\Internet Explorer\\ActiveX Compatibility");

static TCHAR szCompatFlags[] =      _T("Compatibility Flags");
static TCHAR szMiscStatusFlags[] =  _T("MiscStatus Flags");

CLASSINFO g_ciNull;

//+---------------------------------------------------------------------------
//
//  Function:   ShouldWeRegisterCompatibilityTable
//
//  Synopsis:   Determine whether would should write our compatibility table,
//              as recorded in selfreg.inx, to the registry.
//  
//              We do if the table is not in the registry at all, or if
//              our version of the table is more recent than that in the
//              registry.
//
//  Returns:    TRUE - yes, write the table please.
//
//----------------------------------------------------------------------------

BOOL 
ShouldWeRegisterCompatibilityTable()
{
    BOOL fOurRet = TRUE;
    LONG lRet;
    HKEY hkeyRoot = NULL;
    DWORD dwSize, dwType;
    TCHAR szVersion[10];

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTableRootKey, 0, KEY_READ, &hkeyRoot);
    if( lRet != ERROR_SUCCESS )
        return( TRUE );

    dwSize = sizeof( szVersion );
    lRet = RegQueryValueEx( hkeyRoot, _T("Version"), NULL, &dwType, 
      (LPBYTE)szVersion, &dwSize );
    if( lRet == ERROR_SUCCESS )
        fOurRet = (_tcscmp( szVersion, szOurVersion ) < 0);

    RegCloseKey( hkeyRoot );

    return( fOurRet );
}

#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   AssertCompatibilityTable
//
//  Synopsis:   Reads the compatibility table from the registry.
//              Confirms that it is identical to our internal compatibility
//              table.
//
//----------------------------------------------------------------------------

HRESULT
CompatFlagsFromClsid(REFCLSID clsid, LPDWORD pdwCompatFlags, LPDWORD pdwMiscStatusFlags);

void
AssertCompatibilityTable()
{
#ifndef WIN16           // we'll deal with ActiveX issue later
    LONG    lRet;       // Dual error code types and variables.
    HRESULT hr = S_OK;  // Notice the two exit paths below.

    HKEY  hkeyRoot = NULL;
    DWORD cKeys = 0, iKey = 0, cbClsid;
    DWORD dwOleMisc, dwSize, dwType;
    DWORD dwCompatFlags;
    CLSID clsid;
    TCHAR szClsid[40];
    TCHAR szVersion[10];
    int   iVersionNumberComparison;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTableRootKey, 0, KEY_READ, &hkeyRoot);
    if( lRet != ERROR_SUCCESS )
        goto Win32ErrorExit;

    // Check the version number:
    dwSize = sizeof( szVersion );
    lRet = RegQueryValueEx( hkeyRoot, _T("Version"), NULL, &dwType, 
      (LPBYTE)szVersion, &dwSize );
    if( lRet != ERROR_SUCCESS )
        goto Win32ErrorExit;

    iVersionNumberComparison = _tcscmp( szVersion, szOurVersion );

    // The version number should not be less than our internal one:
    Assert( szVersion >= 0 );

    // First count how many entries there are:
    lRet = RegQueryInfoKey( hkeyRoot, NULL, NULL, NULL, &cKeys,
        NULL, NULL, NULL, NULL, NULL, NULL, NULL );
    if( lRet != ERROR_SUCCESS )
        goto Win32ErrorExit;

    // If the version number is the same the count should be the
    // same:
    if( iVersionNumberComparison == 0 )
        Assert( cKeys == ARRAY_SIZE( s_aCompatibility ) );

    // Read each table entry:
    for( ; iKey < cKeys; iKey++ )
    {
        cbClsid = sizeof( szClsid );
        lRet = RegEnumKeyEx( hkeyRoot, iKey, szClsid, &cbClsid, NULL, NULL, NULL, NULL );
        if( lRet != ERROR_SUCCESS )
            goto Win32ErrorExit;

        // Get the clsid value from the string:
        szClsid[cbClsid] = _T('\0');
        hr = CLSIDFromString( szClsid, &clsid );
        if( FAILED(hr) )
            goto Exit;

        Assert( *s_aCompatibility[iKey].pclsid == clsid );

        hr = CompatFlagsFromClsid( clsid, &dwCompatFlags, &dwOleMisc );
        Assert( SUCCEEDED( hr ) );

        Assert( s_aCompatibility[iKey].dwCompatFlags == dwCompatFlags );
        Assert( s_aCompatibility[iKey].dwMiscStatusFlags == dwOleMisc );
    }

  Exit:
    if( hkeyRoot )
        RegCloseKey( hkeyRoot );

    Assert( SUCCEEDED( hr ) );
    return;

  Win32ErrorExit:  // convert WIN32 error code to HRESULT:
    hr = HRESULT_FROM_WIN32( lRet );
    goto Exit;
#endif    
}
#endif

EXTERN_C const IID IID_IRowset;
EXTERN_C const IID IID_OLEDBSimpleProvider;
EXTERN_C const IID IID_IRowCursor;
EXTERN_C const IID IID_DataSource;

DeclareTag(tagShowHideVerb, "OleSite", "DoVerb(SHOW/HIDE) before Inplace (de)activate.");


//+------------------------------------------------------------------------
//
//  Member:     CompatFlagsFromClsid
//
//  Synopsis:   Get compatibility flags for given clsid.
//
//-------------------------------------------------------------------------

HRESULT
CompatFlagsFromClsid(REFCLSID clsid, LPDWORD pdwCompatFlags, LPDWORD pdwMiscStatusFlags)
{
    LONG lRet;      // Dual error code types and variables.
    HRESULT hr;     // Notice the two exit paths below.

    HKEY hkeyRoot = NULL, hkeyClsid = NULL;
    DWORD dwSize, dwType;
    LPOLESTR pszClsid = NULL;
    union Yuck { 
        DWORD dw;
        TCHAR tch[10];
    } yuckValue;

    Assert( pdwCompatFlags != NULL );
    Assert( pdwMiscStatusFlags != NULL );

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTableRootKey, 0, KEY_READ, &hkeyRoot);
    if( lRet != ERROR_SUCCESS )
        goto Win32ErrorExit;

    hr = StringFromCLSID( clsid, &pszClsid );
    if( FAILED( hr ) )
        goto Exit;

    // Open the {####-####-####...} Clsid subkey:
    lRet = RegOpenKeyEx(hkeyRoot, pszClsid, 0, KEY_READ, &hkeyClsid);
    if( lRet != ERROR_SUCCESS )
    {
        hr = S_FALSE;  // if there is no entry in the table that is OK.
        goto Exit;
    }

    // Get the flags from the subkeys named values. Either value may
    // be missing from the registry, we'll just use 0 then.
    // The yuckValue mechanism is due to the fact that the .inf tools
    // sometimes put STRINGS rather than DWORDS in the registry on win95.
    *pdwCompatFlags = 0;    // default initial value in case we fail anywhere.
    dwSize = sizeof( yuckValue );
    lRet = RegQueryValueEx( hkeyClsid, szCompatFlags, NULL, &dwType, 
      (LPBYTE)&yuckValue, &dwSize );
    if( lRet == ERROR_SUCCESS )
    {
        if( dwType == REG_DWORD )
            *pdwCompatFlags = yuckValue.dw;
        else if( dwType == REG_SZ && dwSize > 2 )
            *pdwCompatFlags = _tcstol( yuckValue.tch+2, NULL, 16 );
    }
    
    *pdwMiscStatusFlags = 0; // default initial value in case we fail anywhere.
    dwSize = sizeof( yuckValue );
    lRet = RegQueryValueEx( hkeyClsid, szMiscStatusFlags, NULL, &dwType, 
      (LPBYTE)&yuckValue, &dwSize );
    if( lRet == ERROR_SUCCESS )
    {
        if( dwType == REG_DWORD )
            *pdwMiscStatusFlags = yuckValue.dw;   
        else if( dwType == REG_SZ && dwSize > 2)
            *pdwMiscStatusFlags = _tcstol( yuckValue.tch+2, NULL, 16 );
    }

  Exit:
    if( hkeyClsid )
        RegCloseKey( hkeyClsid );

    if( hkeyRoot )
        RegCloseKey( hkeyRoot );

    if( pszClsid )
        CoTaskMemFree( pszClsid );

    return( hr );

  Win32ErrorExit:  // convert WIN32 error code to HRESULT:
    hr = HRESULT_FROM_WIN32( lRet );
    goto Exit;
}


//+------------------------------------------------------------------------
//
//  Member:     CClassTable::Reset
//
//  Synopsis:   Releases the ITypeInfo interface pointes we have stored in the
//              _aryci array.
//
//-------------------------------------------------------------------------

void
CClassTable::Reset()
{
    int i = _aryci.Size();

    for( ; i > 0; --i )
    {
        ClearInterface( &_aryci[i-1]._pTypeInfoEvents );
    }

    _aryci.DeleteAll();

#if DBG == 1
    // Take out temporarily due to table order issues on WIN95.  -Tom
    //AssertCompatibilityTable();
#endif
}

//+------------------------------------------------------------------------
//
//  Member:     InitializeClassInfo
//
//  Synopsis:   Initializes a CLASSINFO structure
//
//  Arguments:  pci         CLASSINFO structure
//              clsid       The GUID identifier.
//
//  Returns:    void
//
//-------------------------------------------------------------------------

HRESULT
CLASSINFO::Init(REFCLSID rclsid, BOOL fInitCompatFlags)
{
    HRESULT hr = S_OK;

    // Initialize CLASSINFO members to defaul state

    // 0-fill for speed
    memset(this, 0, sizeof(CLASSINFO));
    
    clsid = rclsid;

    // Assume IDispatch for these two IIDs.  Note that if the object doesn't
    //  actually have a default interface or default event interface, subsequent
    //  code will simply fail when we try to QI or FindConnectionPoint for these
    //  IIDs, so we're no worse off than if we started with IID_NULL here.
    iidDefault = IID_IDispatch;
    iidDispEvent = IID_IDispatch;

    Assert(vtValueType == VT_EMPTY);
    Assert(vtBindType == VT_EMPTY);
    dispIDBind = DISPID_UNKNOWN;
    dispidIDataSource = DISPID_UNKNOWN;
    dispidRowset = DISPID_UNKNOWN;
    dispidCursor = DISPID_UNKNOWN;
    dispidSTD = DISPID_UNKNOWN;

    if (fInitCompatFlags)
    {
        hr = CompatFlagsFromClsid(rclsid, &dwCompatFlags, &dwMiscStatusFlags);
    }

    if (S_FALSE == hr)
        hr = S_OK;

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CClassTable::AssignWclsid
//
//  Synopsis:   Assign an integer id given a guid id.
//
//  Arguments:  pDoc       The hosting form.
//              clsid       The GUID identifier.
//              pwclsid     The integer identifier.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CClassTable::AssignWclsid(CDoc *pDoc, REFCLSID clsid, WORD *pwclsid)
{
    int                     wclsid = 0;
    CLASSINFO *             pci;
    HRESULT                 hr = S_OK;
    ILicensedClassManager * pLCM = NULL;
    IRequireClasses *       pRC = NULL;

    if (clsid == GUID_NULL)
        goto Cleanup;

    for (wclsid = 1, pci = _aryci; wclsid <= _aryci.Size(); wclsid++, pci++)
    {
        if (pci->clsid == clsid)
            goto Cleanup;
    }

    hr = THR(_aryci.EnsureSize(_aryci.Size() + 1));
    if (hr)
        goto Cleanup;

    pci = &_aryci[_aryci.Size()];

    hr = pci->Init(clsid, TRUE);
    if (hr)
        goto Cleanup;

    wclsid = _aryci.Size() + 1;

    _aryci.SetSize(_aryci.Size() + 1);

    // Notify the world that we have added a class.

    if (OK(THR_NOTRACE(pDoc->QueryService(
            SID_SLicensedClassManager,
            IID_ILicensedClassManager,
            (void **)&pLCM))))
    {
        if (OK(THR(pDoc->QueryInterface(IID_IRequireClasses, (void **)&pRC))))
        {
            IGNORE_HR(pLCM->OnChangeInRequiredClasses(pRC));
            pRC->Release();
        }
        pLCM->Release();
    }

 Cleanup:
    if (hr)
        wclsid = 0;

    *pwclsid = (WORD)wclsid;
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CClassTable::IsInterfaceProperty, static
//
//  Synopsis:   Determine if the given TypeDesc is for an interface-valued
//              property, and return the IID of that interface if it is.
//
//  Arguments:  pTI             TypeInfo which we found the given TypeDesc
//              pTypeDesc       type descriptor of a property
//              piid            Where to return the discovered IID
//              
//
//  Returns:    TRUE            if the TypeDesc is for an interface-valued
//                              property; fills in *piid.
//              FALSE           if the property is not interface-valued;
//                              leaves *piid unaffected.
//
//-------------------------------------------------------------------------

BOOL
CClassTable::IsInterfaceProperty (ITypeInfo *pTI, TYPEDESC *pTypeDesc, IID *piid)
{
    BOOL        fResult = FALSE;

    Assert(pTI);
    Assert(pTypeDesc);
    Assert(piid);

    // We are looking for a pointer to GUID'd user-defined type

    // first, make sure it's a pointer
    if (!pTypeDesc || pTypeDesc->vt != VT_PTR)
    {
        goto Cleanup;
    }

    // now examine the type of the object pointed to, make sure
    //  it's a user-defined type
    pTypeDesc = pTypeDesc->lptdesc;
    if (pTypeDesc && pTypeDesc->vt == VT_USERDEFINED)
    {
        // Yes, so it could be the interface-valued object.
        HREFTYPE    hreftype;
        ITypeInfo * pUserTI;

        // We have a property which has a undefined type.
        hreftype = pTypeDesc->hreftype;

        if (!pTI->GetRefTypeInfo(hreftype, &pUserTI))
        {
            TYPEATTR *pTypeAttr;

            if (!pUserTI->GetTypeAttr(&pTypeAttr))
            {
                *piid = pTypeAttr->guid;
                fResult = TRUE;

                pUserTI->ReleaseTypeAttr(pTypeAttr);
            }

            ReleaseInterface(pUserTI);
        }
    }

Cleanup:
    return fResult;
}


//+------------------------------------------------------------------------
//
//  Member:     GetDefaultBindInfoForGet, static helper
//
//  Synopsis:   save the info we need about the default bind property's
//              "get" method
//
//  Arguments:  pci             the class info structure
//              pfDesc          function description (from typelib)
//              pClassTable     the class table entry
//              cTINav          typeinfo navigator (for checking interface properties)
//
//  Returns:    none
//
//-------------------------------------------------------------------------
void
CClassTable::GetDefaultBindInfoForGet(CLASSINFO *pci, FUNCDESC *pfDesc,
                                        CTypeInfoNav& cTINav)
{
    IID iid;
    VARTYPE vtParamType;
    
    pci->uGetBindIndex = pfDesc->oVft;
    vtParamType = pfDesc->elemdescFunc.tdesc.vt;
    pci->dispIDBind = pfDesc->memid;

    // the type should agree with the put method (if we've seen it)
    Assert(pci->vtBindType == VT_EMPTY || (pci->vtBindType & VT_TYPEMASK) == vtParamType);
    pci->vtBindType = vtParamType | (pci->vtBindType & ~VT_TYPEMASK);

    // special check for complex data consumers
    if (IsInterfaceProperty(cTINav.getITypeInfo(),
                                &pfDesc->elemdescFunc.tdesc,
                                &iid))
    {
        if (IsEqualIID(iid, IID_DataSource) ||
            IsEqualIID(iid, IID_OLEDBSimpleProvider) ||
            IsEqualIID(iid, IID_IRowset))
        {
            pci->vtBindType = VT_UNKNOWN;
        }
    }
}


//+------------------------------------------------------------------------
//
//  Member:     GetDefaultBindInfoForPut, static helper
//
//  Synopsis:   save the info we need about the default bind property's
//              "put" method
//
//  Arguments:  pci             the class info structure
//              pfDesc          function description (from typelib)
//
//  Returns:    none
//
//-------------------------------------------------------------------------
void
CClassTable::GetDefaultBindInfoForPut(CLASSINFO *pci, FUNCDESC *pfDesc)
{
    VARTYPE vtParamType;
    BOOL fParamIsPointer;
    
    pci->uPutBindIndex = pfDesc->oVft;
    pci->fImmediateBind = !!(pfDesc->wFuncFlags & FUNCFLAG_FIMMEDIATEBIND);
    pci->dwFlagsBind = pfDesc->invkind;

    // get the type of the put method's parameter
    Assert(pfDesc->cParams == 1);
    vtParamType = pfDesc->lprgelemdescParam->tdesc.vt;
    fParamIsPointer = (vtParamType == VT_PTR);
    if (fParamIsPointer)
    {
        vtParamType = pfDesc->lprgelemdescParam->tdesc.lptdesc->vt | VT_BYREF;
    }

    // it should agree with the type of the get method (if we've seen it)
    Assert(pci->vtBindType == VT_EMPTY || 
            (pci->vtBindType & VT_TYPEMASK) == (vtParamType & VT_TYPEMASK));
    pci->vtBindType = vtParamType;
}


//+------------------------------------------------------------------------
//
//  Member:     CClassTable::GetDualInfo, static
//
//  Synopsis:   Save the
//
//  Arguments:  pTI             the class typeinfo.
//              pci             the class info structure, may change:
//                                  fDualInterface
//                                  fImmediateBind
//                                  dispIDBind
//                                  uGetBindIndex
//                                  uPutBindIndex
//                                  vtBindType
//
//  Returns:    none
//
//-------------------------------------------------------------------------
void
CClassTable::GetDualInfo(
        CTypeInfoNav & cTINav,
        FUNCDESC *pfDesc,
        CLASSINFO *pci)
{
    BOOL fValueProp = (pfDesc->memid == DISPID_VALUE);
    BOOL fDefaultBind = ( (pfDesc->wFuncFlags & 
                                (FUNCFLAG_FBINDABLE|FUNCFLAG_FDEFAULTBIND)) ==
                            (FUNCFLAG_FBINDABLE | FUNCFLAG_FDEFAULTBIND));
    
    switch (pfDesc->invkind)
    {
    case INVOKE_PROPERTYGET:
        // Save information about the defaultbind property
        if (fDefaultBind)
        {
            GetDefaultBindInfoForGet(pci, pfDesc, cTINav);
        }
        
        // Save information about the value property information (DISPID_VALUE)
        if (fValueProp)
        {
            pci->uGetValueIndex = pfDesc->oVft;
            pci->vtValueType = pfDesc->elemdescFunc.tdesc.vt;

            // if we haven't seen the defaultbind property, use the value property;
            // this will be overwritten if the defaultbind property shows up later.
            // The effect is to bind to the value property (if any) if no defaultbind
            // property is present.
            if (pci->dispIDBind == DISPID_UNKNOWN || pci->dispIDBind == DISPID_VALUE)
            {
                GetDefaultBindInfoForGet(pci, pfDesc, cTINav);
            }
        }
        break;

    case INVOKE_PROPERTYPUT:
    case INVOKE_PROPERTYPUTREF:
        // Save information about the defaultbind property
        if (fDefaultBind)
        {
            GetDefaultBindInfoForPut(pci, pfDesc);
        }
        
        // Save information about the value property information (DISPID_VALUE)
        if (fValueProp)
        {
            pci->uPutValueIndex = pfDesc->oVft;
            pci->dwFlagsValue = pfDesc->invkind;

            // if we haven't seen the defaultbind property, use the value property;
            // this will be overwritten if the defaultbind property shows up later.
            // The effect is to bind to the value property (if any) if no defaultbind
            // property is present.
            if (pci->dispIDBind == DISPID_UNKNOWN || pci->dispIDBind == DISPID_VALUE)
            {
                GetDefaultBindInfoForPut(pci, pfDesc);
            }
        }
        break;
    }
}



//+------------------------------------------------------------------------
//
//  Member:     CClassTable::FindTypelibInfo, static
//
//  Synopsis:   Look for the IRowset property and value property FuncFlags or
//              ValueFlags for this class, if they are found.
//
//  Arguments:  pTI             the class typeinfo.
//              pci             the class info structure, may change:
//                                  fImmediateBind
//                                  dispidRowset
//                                  dispIDBind
//                                  uGetBindIndex
//                                  uPutBindIndex
//                                  vtBindType
//                                  uSetRowset
//                                  dispidCursor
//                                  dispidSTD
//                                  uSetCursor
//                                  uGetSTD
//
//  Returns:    none
//
//-------------------------------------------------------------------------
void
CClassTable::FindTypelibInfo(ITypeInfo *pTI, CLASSINFO *pci)
{
    HRESULT         hr;
    CTypeInfoNav    cTINav;
    WORD            wVFFlags = 0;

    Assert(pTI);
    Assert(pci);

    // Look for the displaybind and bindable properties.
    hr = THR(cTINav.InitITypeInfo(pTI, 0));
    if (hr)
        goto Cleanup;

    // Keep looping through typeinfo until we find a property match.
    while (!cTINav.Next())
    {
        FUNCDESC    *pfDesc;

        pfDesc = cTINav.getFuncD();

        // Do we have a user defined type?
        if (pfDesc)
        {
            // Check for interesting interface-valued Get properties
            // with no paramter types.
            if (pfDesc->invkind == INVOKE_PROPERTYGET &&
                pfDesc->cParams == 0)
            {
                IID iid;

                // Check out the return type for a known interface.
                if (IsInterfaceProperty(pTI,
                                        &pfDesc->elemdescFunc.tdesc,
                                        &iid))
                {
                    if (IsEqualIID(iid, IID_DataSource))
                    {
                        pci->dispidIDataSource = pfDesc->memid;
                        pci->uGetIDataSource = pfDesc->oVft;
                    }
                    if (IsEqualIID(iid, IID_OLEDBSimpleProvider))
                    {
                        pci->dispidSTD = pfDesc->memid;
                        pci->uGetSTD = pfDesc->oVft;
                    }
                    if (IsEqualIID(iid, IID_IRowset))
                    {
                        pci->dispidRowset = pfDesc->memid;
                        pci->uGetRowset = pfDesc->oVft;
                    }
                }
            }

            // Check for interesting interface-valued put property.
            if (pfDesc->lprgelemdescParam &&
                (pfDesc->invkind == INVOKE_PROPERTYPUT ||
                 pfDesc->invkind == INVOKE_PROPERTYPUTREF))
            {
                IID iid;
                
                if (IsInterfaceProperty(pTI,
                                        &pfDesc->lprgelemdescParam->tdesc,
                                        &iid ) )
                {
                    if (IsEqualIID(iid, IID_DataSource))
                    {
                        pci->dispidIDataSource = pfDesc->memid;
                        pci->uSetIDataSource = pfDesc->oVft;
                        pci->dwFlagsDataSource = pfDesc->invkind;
                    }
                    if (IsEqualIID(iid, IID_IRowset))
                    {
                        pci->dispidRowset = pfDesc->memid;
                        pci->uSetRowset = pfDesc->oVft;
                        pci->dwFlagsRowset = pfDesc->invkind;
                    }
                    else if (IsEqualIID(iid, IID_IRowCursor))
                    {
                        pci->dispidCursor = pfDesc->memid;
                        pci->uSetCursor = pfDesc->oVft;
                    }
                }
            }

            if (cTINav.IsDualInterface())
            {
                GetDualInfo(cTINav, pfDesc, pci);
            }
        }
        else
        {
            VARDESC *pvDesc;

            pvDesc = cTINav.getVarD();
            if (pvDesc)
            {
                IID iid;
                
                wVFFlags = pvDesc->wVarFlags;

                // Check for the interface-valued properties
                if (IsInterfaceProperty(pTI, &pvDesc->elemdescVar.tdesc,
                                        &iid ) )
                {
                    if (IsEqualIID(iid, IID_DataSource))
                    {
                        pci->dispidIDataSource = pvDesc->memid;
                    }
                    else if (IsEqualIID(iid, IID_IRowset))
                    {
                        pci->dispidRowset = pvDesc->memid;
                    }
                    else if(IsEqualIID(iid, IID_OLEDBSimpleProvider))
                    {
                        pci->dispidSTD = pvDesc->memid;
                    }
                    else if(IsEqualIID(iid, IID_IRowCursor))
                    {
                        pci->dispidCursor = pvDesc->memid;
                    }
                }

                // Default bindable property?
                if (((wVFFlags&(FUNCFLAG_FBINDABLE|FUNCFLAG_FDEFAULTBIND)) ==
                     (FUNCFLAG_FBINDABLE | FUNCFLAG_FDEFAULTBIND)) ||
                    (pvDesc->memid == 0 && pci->dispIDBind == DISPID_UNKNOWN))
                {
                    pci->dispIDBind = pvDesc->memid;
                    pci->vtBindType = pvDesc->elemdescVar.tdesc.vt;
                    if (pvDesc->wVarFlags & VARFLAG_FIMMEDIATEBIND)
                    {
                        pci->fImmediateBind = TRUE;
                    }
                }
            }
        }
    }
    
    pci->fDualInterface = cTINav.IsDualInterface() &&
                            pci->uGetBindIndex!=0 && pci->uPutBindIndex!=0;

Cleanup:
    return;
}


//+------------------------------------------------------------------------
//
//  Member:     CClassTable::InitializeIIDsFromTIDefault, static
//
//  Synopsis:   Given the TypeInfo for the default interface of a class,
//              fill in whatever CLASSINFO members can be computed from it.
//              Helper function used no matter what mechanism is used to
//              obtain the TypeInfo.
//
//  Arguments:  pci         Fill in this CLASSINFO ..
//              pTIDefault  ... using this type info
//              ptaDefault  and the caller-fetched type attribute for
//                          this TypeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CClassTable::InitializeIIDsFromTIDefault(CLASSINFO *pci,
                                         ITypeInfo *pTIDefault,
                                         TYPEATTR *ptaDefault)
{
    HRESULT hr = S_OK;
    ITypeInfo * pTIDual= NULL;
    TYPEATTR *  ptaDual = NULL;
    HREFTYPE    hrt;

    
    //
    // Only handle dual interfaces.

    // Does the control class have an IRowset,Value and/or default
    // bindable property?
    FindTypelibInfo(pTIDefault, pci);

    pci->iidDefault = ptaDefault->guid;

    if (ptaDefault->wTypeFlags & TYPEFLAG_FDUAL)
    {
        hr = THR(pTIDefault->GetRefTypeOfImplType((UINT) -1, &hrt));
        if (hr)
            goto Cleanup;

        hr = THR(pTIDefault->GetRefTypeInfo(hrt, &pTIDual));
        if (hr)
            goto Cleanup;

        hr = THR(pTIDefault->GetTypeAttr(&ptaDual));
        if (hr)
            goto Cleanup;

        pci->cMethodsDefault = (int) (ptaDual->cbSizeVft / sizeof(void (*)()));
// TODO: (garybu) Should assert that tearoff table is large enough to thunk to this itf.
    }

Cleanup:
    if (ptaDual)
        pTIDual->ReleaseTypeAttr(ptaDual);
    ReleaseInterface(pTIDual);

    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CClassTable::InitializeIIDs, static
//
//  Synopsis:   Fetch the IIDs for a given CLASSINFO
//
//  Arguments:  pci     Fill in this CLASSINFO ..
//              pUnk    ... using type info from this object.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CClassTable::InitializeIIDs(CLASSINFO *pci, IUnknown *pUnk)
{
    HRESULT     hr = S_OK;
    int         i;
    ITypeInfo * pTIClass = NULL;
    TYPEATTR *  ptaClass = NULL;
    IProvideClassInfo *pPCI = NULL;
    IDispatch * pDispatch = NULL;

    Assert(!pci->fAllInitialized);
    
    // Should have been set when instantiated the control
    if (!pUnk)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Get the ITypeInfo, either via IProvideClassInfo, or IDispatch

    // TODO:
    // The IDispatch mechanism below won't discover any eventset. A solution\
    // would be to go to registry if we don't have IProvideClassInfo.
    //
    if (OK(THR_NOTRACE(pUnk->
               QueryInterface(IID_IProvideClassInfo,
                              (void **) &pPCI))))
    {
        hr = THR(pPCI->GetClassInfo(&pTIClass));
        if (hr)
            goto Cleanup;

        hr = THR(pTIClass->GetTypeAttr(&ptaClass));
        if (hr)
            goto Cleanup;

        if (ptaClass->typekind != TKIND_COCLASS)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        for (i = 0; i < ptaClass->cImplTypes; i++)
        {
            int         implTypeFlags;
            HREFTYPE    hrt;
            ITypeInfo * pTIDefault = NULL;
            TYPEATTR *  ptaDefault = NULL;

            hr = THR(pTIClass->GetImplTypeFlags(i, &implTypeFlags));
            if (hr)
                goto Cleanup;

            if (!(implTypeFlags & IMPLTYPEFLAG_FDEFAULT))
                continue;

            hr = THR(pTIClass->GetRefTypeOfImplType(i, &hrt));
            if (hr)
                goto Cleanup;

            hr = THR(pTIClass->GetRefTypeInfo(hrt, &pTIDefault));
            if (hr)
                goto Cleanup;

            hr = THR(pTIDefault->GetTypeAttr(&ptaDefault));
            if (hr)
                goto LoopCleanup;

            if (!(ptaDefault->typekind & TKIND_DISPATCH))
                goto LoopCleanup;

            if (implTypeFlags & IMPLTYPEFLAG_FSOURCE)
            {
                pci->_pTypeInfoEvents = pTIDefault;
                pTIDefault->AddRef();

                pci->iidDispEvent = ptaDefault->guid;

            }
            else
            {
                hr = THR(InitializeIIDsFromTIDefault(pci, pTIDefault, ptaDefault));
            }
LoopCleanup:
            if (ptaDefault)
                pTIDefault->ReleaseTypeAttr(ptaDefault);

            ReleaseInterface(pTIDefault);
            if (hr)
                goto Cleanup;
        }

    }
    else if (OK(THR_NOTRACE(pUnk->
               QueryInterface(IID_IDispatch,
                              (void **) &pDispatch))))
    {
        // we cheat a little on variable names here; we are using pTIClass
        //  and ptaClass, even though we have the TypeInfo for the Dispatch
        //  itself.  This lets us leverage the cleanup logic below
        hr = THR(pDispatch->GetTypeInfo(0, 0, &pTIClass));
        if (hr)
            goto Cleanup;
        hr = THR(pTIClass->GetTypeAttr(&ptaClass));
        if (hr)
            goto Cleanup;

        if (!(ptaClass->typekind & TKIND_DISPATCH))
        {
            goto Cleanup;
        }

        hr = THR(InitializeIIDsFromTIDefault(pci, pTIClass, ptaClass));
    }

Cleanup:
    if (ptaClass)
        pTIClass->ReleaseTypeAttr(ptaClass);

    ReleaseInterface(pTIClass);
    ReleaseInterface(pPCI);
    ReleaseInterface(pDispatch);

    if (hr != E_OUTOFMEMORY)
    {
        // we only try to initialize once, unless the problem was E_OUTOFMEMORY, which
        //  might get alleviated for subsequent attempts.
        pci->fAllInitialized = TRUE;
    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CClassTable::GetClassInfo
//
//  Synopsis:   Find pointer to class info given word class identifier.
//              Forces load of TypeInfo for class, if not already done.
//
//-------------------------------------------------------------------------

CLASSINFO *
CClassTable::GetClassInfo(int wclsid, IUnknown *pUnk, COleSite *pSite)
{
    CLASSINFO * pci;

    Assert(0 <= wclsid && wclsid <= _aryci.Size());

    if (wclsid == 0)
    {
        return(&g_ciNull);
    }

    pci = &_aryci[wclsid - 1];
    
    if (!pci->fAllInitialized) // Is it actually initialized?
    {
        // (sramani) java applets have same clsid but dufferent per instance typeinfo.
        // So we fetch the per instance classinfo and store it in that instance's olesite
        // instead of in the common class table entry. We make sure that it is only fetched
        // once per instance.
        Assert(pSite);
        if (pci->clsid == CLSID_AppletOCX)
        {
            if (!pSite->_pci)
            {
                pSite->_pci = new CLASSINFO;
                if (!pSite->_pci)
                    return(&g_ciNull);

                memcpy(pSite->_pci, pci, sizeof(CLASSINFO));
            }
 
            pci = pSite->_pci;
        }
        // No, so initialize it.  We trust InitializeIIDS to leave us
        //  us something sane on failure.
        if (!pci->fAllInitialized) // Is it actually initialized?
            IGNORE_HR(InitializeIIDs(pci, pUnk));
    }

    Assert(pci->clsid != CLSID_AppletOCX || (pSite->_pci && pSite->_pci->fAllInitialized));
    Assert(pci->clsid == CLSID_AppletOCX || !pSite->_pci);

#if DBG == 1
    if (IsTagEnabled(tagShowHideVerb))
        pci->dwCompatFlags |= (COMPAT_SEND_SHOW | COMPAT_SEND_HIDE);
#endif

    return pci;
}



//+------------------------------------------------------------------------
//
//  Member:     CClassTable::GetQuickClassInfo
//
//  Synopsis:   Find pointer to "quick" class info given word class
//              identifier.  Tries to avoid loading the TypInfo for
//              the class, but may need to, if the class doesn't
//              support IProvideClassInfo2.
//
//-------------------------------------------------------------------------

QUICKCLASSINFO *
CClassTable::GetQuickClassInfo(int wclsid, IUnknown *pUnk)
{
    Assert(0 <= wclsid && wclsid <= _aryci.Size());

    HRESULT             hr;
    CLASSINFO *         pci;
    IProvideClassInfo2 *pPCI2 = 0;

    if (wclsid == 0)
    {
        pci = &g_ciNull;
        goto Cleanup;
    }

    pci = &_aryci[wclsid - 1];

    // IE5 Bug 66813: Some controls, namely the TAPI control
    // QI us after we have already started shutting down. When
    // they QI us, we have already deleted everything in _aryci
    // in the Reset() method. This method is called with wclsid
    // set to 1. In that case, _aryci returns NULL for position 0,
    // since everything is already deleted. This check is to 
    // save ourselves from controls not doing what they are supposed to do.
    //
    if (!pci)
        goto Cleanup;

    //
    // If the Default Event has not yet been initialized and the entire
    // class info has also not been initialized, QI the pUnk for 
    // IProvideClassInfo2 and cache the info.
    //
    // HACKHACKHACK: All applets have the same clsid but will have 
    // different event iids.  To have event sinking on multiple applets
    // work, never depend on the cached event iid if we're the applet ocx.
    // ASSUMPTION: The VM implements IProvideClassInfo2.
    //
    
    if ((!pci->fAllInitialized && !pci->fiidDEInitialized) ||
        (pci->clsid == CLSID_AppletOCX))
    {
        if (OK(THR(pUnk->
                   QueryInterface(IID_IProvideClassInfo2,
                                  (void **) &pPCI2))))
        {
            hr = pPCI2->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID,
                                &pci->iidDispEvent);
            
            if (SUCCEEDED(hr))
            {
                pci->fiidDEInitialized = TRUE;
                goto Done;
            }
        }
        
        // If IProvideClassInfo2 is not supported, or the GetGUID
        // method failed, then we must try querying the TypeLibInfo..
        // except for applet OCs.

        if (!pci->fAllInitialized && !pci->fiidDEInitialized && pci->clsid != CLSID_AppletOCX)
        {
            hr = InitializeIIDs(pci, pUnk);
        }
    }

Done:
#if DBG == 1
    if (IsTagEnabled(tagShowHideVerb))
        pci->dwCompatFlags |= (COMPAT_SEND_SHOW | COMPAT_SEND_HIDE);
#endif
    ReleaseInterface(pPCI2);

Cleanup:
    return (QUICKCLASSINFO *) pci;
}



//+------------------------------------------------------------------------
//
//  Member:     CLASSINFO::ClearFDualInterface
//
//  Synopsis:   Change CLASSINFO marked as dual to a consistent state
//              reflecting that the class is IDispatch-only.  Meant
//              to be called if QI for the primary interface fails because
//              the primary interface isn't remoted across thread boundaries,
//              but a QI for IDispatch succeeds, because the system does
//              know how to remote IDispatch.
//
//-------------------------------------------------------------------------

void
CLASSINFO::ClearFDualInterface()
{
    // Mark control as NOT dual interface.
    fDualInterface = FALSE;

    // Set it so in later instances, we know to QI for IDispatch right
    // away, instead of trying the iidDefault marked in the Object's
    // typelib.
    iidDefault = IID_IDispatch;

    // This should really not be necessary, since people should check
    // dwFlags for CLSTABLE_DUALINTERFACE before jumping through the
    // VTable, but for now..
    uGetBindIndex = 0;
    uPutBindIndex = 0;
    uGetValueIndex = 0;
    uPutValueIndex = 0;
    uSetIDataSource = 0;
    uGetIDataSource = 0;
    uSetRowset = 0;
    uGetRowset = 0;
    uSetCursor = 0;
    uGetSTD = 0;
}

HRESULT
InitClassTable()
{
    RRETURN(g_ciNull.Init(GUID_NULL, FALSE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\miscsite\frameset.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       frameset.cxx
//
//  Contents:   Implementation of CFrameSetSite
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include "cguid.h"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_FRAMELYT_HXX_
#define X_FRAMELYT_HXX_
#include "framelyt.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_HTIFRAME_H_
#define X_HTIFRAME_H_
#include <htiframe.h>
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#define _cxx_
#include <frameset.hdl>

MtDefine(CFrameSetSite, Elements, "CFrameSetSite")
MtDefine(CFrameSetSite_aryFrames_pv, CFrameSetSite, "CFrameSetSite::_aryFrames::_pv")
MtDefine(CFrameSetSite_aryFormVisit_pv, CFrameSetSite, "CFrameSetSite::_aryFormVisit::_pv")
MtDefine(CNoFramesElement, Elements, "CNoFramesElement")
MtDefine(CFramesetChildIterator, Layout, "CFramesetChildIterator")

MtDefine(CFrameSetSite_aryRows_pv, CFrameSetSite, "CFrameSetSite::_aryRows::_pv")
MtDefine(CFrameSetSite_aryCols_pv, CFrameSetSite, "CFrameSetSite::_aryCols::_pv")

enum XorYLoop { XDirection = 0, YDirection = 1, Terminate = 2 };

#ifndef NO_PROPERTY_PAGE
const CLSID * const CFrameSetSite::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
#endif // DBG==1    
    NULL
};
#endif // NO_PROPERTY_PAGE

CElement::ACCELS CFrameSetSite::s_AccelsFrameSetSiteRun = CElement::ACCELS (&CElement::s_AccelsElementRun, IDR_ACCELS_FRAMESET_RUN);

const CElement::CLASSDESC CFrameSetSite::s_classdesc =
{
    {
        &CLSID_HTMLFrameSetSite,            // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _apiidConect
        ELEMENTDESC_BODY |                  // _dwFlags
        ELEMENTDESC_NOTIFYENDPARSE,
        &IID_IHTMLFrameSetElement,          // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLFrameSetElement,
    &s_AccelsFrameSetSiteRun                // _pAccelsRun
};

const CElement::CLASSDESC CNoFramesElement::s_classdesc = { 0 };

struct MYPROP
{
    PROPERTYDESC  pdesc;
    NUMPROPPARAMS numprop;
};

// Value the unitvalue is given if the string is empty
#define NOT_SET_DEFAULT  0

LPTSTR
FindRowColSeparator(LPTSTR pchStart, const TCHAR * pchSep)
{
    // IE50 Raid 3475
    // re-implement _tcstok to not skipping over leading separators
    //
    LPTSTR  pchNext;
    TCHAR * pchControl;

    for (pchNext = pchStart; * pchNext; pchNext ++)
    {
        for (pchControl = (TCHAR * ) pchSep;
             * pchControl && * pchNext != * pchControl;
             pchControl ++);
        if (* pchControl)
            break;
    }

    if (* pchNext)
    {
        * pchNext = _T('\0');
        return pchNext + 1;
    }
    else
        return NULL;
}


//+------------------------------------------------------------------------
//
//  Member:     CFrameSetSite::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CFrameSetSite::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if IID_TEAROFF(this, IHTMLFrameSetElement2, NULL)
    else
    {
        RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    (*(IUnknown **)ppv)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFrameSetSite::CreateElement, public
//
//  Synopsis:   Creates a CFrameSetSite
//
//----------------------------------------------------------------------------

HRESULT
CFrameSetSite::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert (ppElement);

    if (pht->Is(ETAG_FRAMESET))
    {
        *ppElement = new CFrameSetSite(pDoc);
    }
    else // ETAG_NOFRAMES
    {
        Assert(pht->Is(ETAG_NOFRAMES));

        *ppElement = new CNoFramesElement(pDoc);
    }

    RRETURN ((*ppElement) ? S_OK : E_OUTOFMEMORY);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFrameSetSite::CFrameSetSite, public
//
//  Synopsis:   CFrameSetSite ctor
//
//----------------------------------------------------------------------------

CFrameSetSite::CFrameSetSite ( CDoc * pDoc )
  : super(ETAG_FRAMESET, pDoc),
    _aryRows(Mt(CFrameSetSite_aryRows_pv)),
    _aryCols(Mt(CFrameSetSite_aryCols_pv)),
    _aryRowsResize(Mt(CFrameSetSite_aryRows_pv)),
    _aryColsResize(Mt(CFrameSetSite_aryCols_pv))
{
#ifdef WIN16
    m_baseOffset = ((BYTE *) (void *) (CBase *)this) - ((BYTE *) this);
    m_ElementOffset = ((BYTE *) (void *) (CElement *)this) - ((BYTE *) this);
#endif
    _pNFE = NULL;
};


//+---------------------------------------------------------------------------
//
//  Member:     CFrameSetSite::Init2, public
//
//  Synopsis:   Parse the ROWS and/or COLS attributes
//
//  Arguments:  (none)
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CFrameSetSite::Init2(CInit2Context * pContext)
{
    HRESULT   hr;
    CDoc *    pDoc = Doc();
    
    hr = THR(super::Init2(pContext));
    if (hr)
        goto Cleanup;
   
    pDoc->_fFrameBorderCacheValid = FALSE;

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CFrameSetSite::Notify
//
//--------------------------------------------------------------------------

void
CFrameSetSite::Notify(CNotification *pNF)
{
    super::Notify(pNF);

    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_ENTERTREE:
    {
        CMarkup * pMarkup = GetMarkup();

        pMarkup->_fFrameSet = TRUE;

        LPCTSTR    pStrFrameBorder = NULL;
        CElement * pParent         = GetFirstBranch()->Parent()->Element();

        //
        // Alert the view that the top client element may have changed
        //

        Doc()->OpenView();

        DoNetscapeMappings();

        pStrFrameBorder = GetAAframeBorder();

        if (pStrFrameBorder)
        {
            _fFrameBorder =  pStrFrameBorder[0] == _T('y')
                          || pStrFrameBorder[0] == _T('Y')
                          || pStrFrameBorder[0] == _T('1');
        }
        else if (pParent->Tag() == ETAG_FRAMESET)
        {
            _fFrameBorder = DYNCAST(CFrameSetSite, pParent)->_fFrameBorder;
        }
        else // top-level <frameset>, default is TRUE.
        {
            _fFrameBorder = TRUE;

            // If the HTML element has had it's formats calc'd, it has made scrolling decisions without us.
            // We want it to be aware of its client before making scrolling decisions.  Let it redecide.
            if (pMarkup->IsHtmlLayout())
            {
                CElement * pHTML = pMarkup->GetHtmlElement();
                if (pHTML)
                    pHTML->GetFirstBranch()->VoidFancyFormat();
            }
        }
        
        SetRowsCols();

        //
        // Notify the view of a new possible top element
        //

        SendNotification(NTYPE_VIEW_ATTACHELEMENT);

        if (pMarkup->HasWindowPending())
        {               
            pMarkup->OnLoadStatus(LOADSTATUS_INTERACTIVE);
        }

        break;
    }

    case NTYPE_ELEMENT_EXITTREE_1:
        //
        // Notify the view that the top element may have left
        //

        SendNotification(NTYPE_VIEW_DETACHELEMENT);
        break;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CFrameSetSite::ExpectedFrames
//
//  Synopsis:   Returns the number of frames expected (used during parsing)
//
//--------------------------------------------------------------------------

int
CFrameSetSite::ExpectedFrames()
{
    int iRows = _aryRows.Size();
    int iCols = _aryCols.Size();

    if (!iRows)
        iRows = 1;

    if (!iCols)
        iCols = 1;

    return (iRows * iCols);
}


//+-------------------------------------------------------------------------
//
// Member: CFrameSetSite::FrameSpacingAttribute
//
//  Synopsis:   walk up the tree looking for a framespacing attribute
//
//--------------------------------------------------------------------------
CUnitValue
CFrameSetSite::FrameSpacingAttribute()
{
    CUnitValue uv = GetAAframeSpacing();
    CTreeNode *pNode = GetFirstBranch();

    Assert( pNode );

    while ( uv.IsNull() )
    {
        pNode = pNode->Parent();
        if ( !pNode )
            break;

        if ( pNode->Tag() == ETAG_FRAMESET )
        {
            Assert( pNode->Element()->Tag() == ETAG_FRAMESET );
            uv = DYNCAST(CFrameSetSite, pNode->Element())->GetAAframeSpacing();
        }
    }

    return uv;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFrameSetSite::IsSeamlessEdit()
//
//  Synopsis:   tells us that Primary markup is in design mode
//              and we show no borders between frames (seamless join mode 
//              in VS terminology) - we want to show some resize handles 
//              in this mode anyway. (nothing shown in browse mode)
//--------------------------------------------------------------------------
BOOL 
CFrameSetSite::IsSeamlessEdit()
{
    CMarkup *pPrimaryMarkup = Doc()->PrimaryMarkup();
    CUnitValue uvFrameSpacing = FrameSpacingAttribute();

    //design_mode && border=0 && framespacing=0

    return (   pPrimaryMarkup
            && pPrimaryMarkup->IsEditable()
            && !_fFrameBorder
            && !uvFrameSpacing.IsNullOrEnum()
            && uvFrameSpacing.GetPixelValue() == 0
           );
}

//+-------------------------------------------------------------------------
//
//  Method:     CFrameSetSite::GetFrameSpacing()
//
//  Synopsis:   compute the amount of space between frames
//
//--------------------------------------------------------------------------

int
CFrameSetSite::GetFrameSpacing()
{
    CUnitValue uvFrameSpacing = FrameSpacingAttribute();

    if(!uvFrameSpacing.IsNullOrEnum())
    {
        int iRet = uvFrameSpacing.GetPixelValue();

        if(iRet == 0 && IsSeamlessEdit())
            return 2;
        else
            return iRet;
    }
    else
        return 2;

}

//+-------------------------------------------------------------------------
//
//  Method:     CFrameSetSite::DoNetscapeMappings()
//
//  Synopsis:   map netscapes frame attributes to ours
//
//--------------------------------------------------------------------------

void
CFrameSetSite::DoNetscapeMappings()
{
    BOOL fOldEventListener = FALSE;

    CUnitValue uv = FrameSpacingAttribute();
    if (uv.IsNull())
    {
        uv = BorderAttribute();
        if (!uv.IsNull())
        {
            // OK, so we have a border attribute and no
            // framespacing attribute.  Now we need to
            // map the values appropriately.

            int iPixelValueFrameSpacing = uv.GetPixelValue();
            VARIANT iFrameSpacing;
            iFrameSpacing.vt = VT_I2;
            iFrameSpacing.iVal = (SHORT)iPixelValueFrameSpacing;

            // Inhibit OnPropertyChange event firing because
            // this is an internal change for Netscape Compat
            fOldEventListener      = _fEventListenerPresent;
            _fEventListenerPresent = FALSE;

            switch(iPixelValueFrameSpacing)
            {
            case 0:
                iFrameSpacing.iVal = 0;
                put_StringHelper(_T("0"), (PROPERTYDESC *)&s_propdescCFrameSetSiteframeBorder);
                break;
            case 1:
            case 2:
                iFrameSpacing.iVal = _fFrameBorder ? 2 : 4;
                put_StringHelper(_T("0"), (PROPERTYDESC *)&s_propdescCFrameSetSiteframeBorder);
                break;
            case 3:
            case 4:
                iFrameSpacing.iVal = _fFrameBorder ? 1 : 4;
                put_StringHelper(_fFrameBorder ? _T("1") : _T("0"), (PROPERTYDESC *)&s_propdescCFrameSetSiteframeBorder);
                break;
            default:
                iFrameSpacing.iVal = (_fFrameBorder ? iPixelValueFrameSpacing-4
                                                   : iPixelValueFrameSpacing);
                break;
            }
            put_VariantHelper(iFrameSpacing, (PROPERTYDESC *)&s_propdescCFrameSetSiteframeSpacing);

            // Re-enable previous event firing settings
            _fEventListenerPresent = fOldEventListener;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CFrameSetSite::IsOverflowFrame
//
//  Synopsis : first we need to verify that our frameset is not an overflow of
//    a frameset above us.
//----------------------------------------------------------------------------

#ifdef _M_IA64
//$ WIN64: Why is there unreachable code in the retail build of this next function for IA64?
#pragma warning(disable:4702) /* unreachable code */
#endif

BOOL
CFrameSetSite::IsOverflowFrame(CElement *pel)
{

    if (CElement::IsOverflowFrame())
        return TRUE;
    else
    {
        int                 cexp = 0;
        int                 i = 0;
        CTreeNode *         pNode = NULL;
        static ELEMENT_TAG  atagStop = ETAG_FRAMESET;
        static ELEMENT_TAG  atagChild[2] = { ETAG_FRAMESET, ETAG_FRAME };
        CChildIterator  iter(
            this,
            NULL,
            CHILDITERATOR_USETAGS,
            &atagStop, 1,
            atagChild, ARRAY_SIZE(atagChild));

        cexp = ExpectedFrames();
    
        for (i = 0, pNode = iter.NextChild(); 
             (pNode && i < cexp); 
             pNode = iter.NextChild(), i++)
        {
            // seen request frame as expected
            if (pNode->Element() == pel)
                return FALSE;
        }

        // seen all expected frames already
        if (i >= cexp)
            return TRUE;

        // no more frames
        if (!pNode)
        {
            Assert(0);
        }
    }

    return FALSE;
}

#ifdef _M_IA64
#pragma warning(default:4702) /* unreachable code */
#endif

//+------------------------------------------------------------------
//
//  Member:     CFrameSetSite::GetFrameFlat
//
//  Synopsis:   gets frame # nIndex, where indexing goes flat through
//              nested framesets.
//              Returns:
//
//              nIndex          index of frame to get
//              pcFrames        number of frames passed by (including all frames
//                              in nested framesets)
//              ppFrame         frame with index nIndex if found
//
//              return value    TRUE            if frame with index nIndex found
//                              FALSE           otherwise
//
//-------------------------------------------------------------------

BOOL
CFrameSetSite::GetFrameFlat (LONG nIndex, LONG * pcFrames, CFrameElement ** ppFrame)
{
    CLayout         * pLayout;
    CFrameSetLayout * pLayoutThis = Layout();
    LONG              cFrames, cFramesSub;
    DWORD_PTR         dw;
    BOOL              fFound = FALSE;

    if (ppFrame)
        *ppFrame = NULL;

    cFrames = 0;

    for(pLayout = pLayoutThis->GetFirstLayout(&dw, FALSE);
        pLayout;
        pLayout = pLayoutThis->GetNextLayout(&dw, FALSE))
    {
        if (ETAG_FRAME == pLayout->Tag())
        {
            cFrames++;
            if (cFrames == nIndex+1)
            {
                fFound = TRUE;
                if (ppFrame)
                    *ppFrame = DYNCAST(CFrameElement, pLayout->ElementOwner());
                break;
            }
        }
        else if (ETAG_FRAMESET == pLayout->Tag())
        {
            fFound = DYNCAST(CFrameSetSite, pLayout->ElementOwner())->GetFrameFlat(nIndex - cFrames, &cFramesSub, ppFrame);
            cFrames += cFramesSub;
            if (fFound)
                break;
        }
    }

    pLayoutThis->ClearLayoutIterator(dw, FALSE);
    if (pcFrames)
        *pcFrames = cFrames;

    return fFound;
}

//+--------------------------------------------------------------
//
//  Member:     CFrameSetSite::GetFramesCount
//
//  Synopsis:   returns number of frames in this frameset,
//              including all nested frames
//
//---------------------------------------------------------------

HRESULT
CFrameSetSite::GetFramesCount (LONG * pcFrames)
{
    if (!pcFrames)
        RRETURN (E_POINTER);

    GetFrameFlat(-1, pcFrames, NULL);

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Function:   CFrameSetSite::BorderColorAttribute
//
//  Synopsis:   walk up the tree looking for a bordercolor attribute
//              if one isn't found, return NULL
//
//-------------------------------------------------------------------------
CColorValue
CFrameSetSite::BorderColorAttribute()
{
    CColorValue ccvBorderColor = GetAAborderColor();
    CTreeNode *pNode = GetFirstBranch();

    Assert( pNode );

    while ( ccvBorderColor.IsNull() )
    {
        pNode = pNode->Parent();
        if ( !pNode )
            break;

        if ( pNode->Tag() == ETAG_FRAMESET )
        {
            Assert( pNode->Element()->Tag() == ETAG_FRAMESET );
            ccvBorderColor = DYNCAST(CFrameSetSite, pNode->Element())->GetAAborderColor();
        }
    }

    return ccvBorderColor;
}


//+------------------------------------------------------------------------
//
//  Function:   CFrameSetSite::FrameBorderAttribute
//
//  Synopsis:   walk up the tree looking for a frameborder attribute
//              if one isn't found, return NULL
//
//-------------------------------------------------------------------------
void
CFrameSetSite::FrameBorderAttribute(BOOL fFrameBorder, BOOL fDefined)
{
    LPCTSTR pStrFrameBorder     = GetAAframeBorder();
    BOOL    fFrameBorderDefined = (pStrFrameBorder) ? (TRUE) : (fDefined);

    _fFrameBorder = (pStrFrameBorder)
                  ? (   pStrFrameBorder[0] == _T('y')
                     || pStrFrameBorder[0] == _T('Y')
                     || pStrFrameBorder[0] == _T('1'))
                  : (fFrameBorder);

    CFrameSetLayout * pLayoutThis = Layout( GUL_USEFIRSTLAYOUT );
    DWORD_PTR  dw;
    CLayout  * pLayout = pLayoutThis->GetFirstLayout(&dw, FALSE);
    BOOL       fFirst  = TRUE;
    BOOL       fFrameBorderThis = _fFrameBorder;
    BOOL       fFrameBorderChild;

    while (pLayout)
    {
        ELEMENT_TAG eTag = (ELEMENT_TAG) pLayout->ElementOwner()->_etag;

        switch (eTag)
        {
        case ETAG_FRAME:
            {
                CFrameSite * pFrame = DYNCAST(CFrameSite, pLayout->ElementOwner());
                pStrFrameBorder = pFrame->GetAAframeBorder();
                pFrame->_fFrameBorder = (pStrFrameBorder)
                                      ? (   pStrFrameBorder[0] == _T('y')
                                         || pStrFrameBorder[0] == _T('Y')
                                         || pStrFrameBorder[0] == _T('1'))
                                      : (_fFrameBorder);
                fFrameBorderChild = pFrame->_fFrameBorder;
            }
            break;

        case ETAG_FRAMESET:
            {
                CFrameSetSite * pFrameSet = DYNCAST(CFrameSetSite,
                                                    pLayout->ElementOwner());
                pFrameSet->FrameBorderAttribute(_fFrameBorder,
                                                fFrameBorderDefined);
                fFrameBorderChild = pFrameSet->_fFrameBorder;
            }
            break;

        default:
            fFrameBorderChild = fFrameBorderThis;
            break;
        }

        if (fFirst)
        {
            fFrameBorderThis = fFrameBorderChild;
            fFirst           = FALSE;
        }
        else if (fFrameBorderThis != fFrameBorderChild)
        {
            fFrameBorderThis = TRUE;
        }

        pLayout = pLayoutThis->GetNextLayout(&dw, FALSE);
    }

    pLayoutThis->ClearLayoutIterator(dw, FALSE);

    if (!fFrameBorderDefined)
    {
        _fFrameBorder = fFrameBorderThis;
    }
}

//+------------------------------------------------------------------------
//
//  Function:   CFrameSetSite::BorderAttribute
//
//  Synopsis:   walk up the tree looking for a border attribute
//              if one isn't found, return NULL
//
//-------------------------------------------------------------------------

CUnitValue
CFrameSetSite::BorderAttribute()
{
    CUnitValue uv = GetAAborder();
    CTreeNode *pNode = GetFirstBranch();

    Assert( pNode );

    while ( uv.IsNull() )
    {
        pNode = pNode->Parent();
        if ( !pNode )
            break;

        if ( pNode->Tag() == ETAG_FRAMESET )
        {
            Assert( pNode->Element()->Tag() == ETAG_FRAMESET );
            uv = DYNCAST(CFrameSetSite, pNode->Element())->GetAAborder();
        }
    }

    return uv;
}

//+------------------------------------------------------------------------
//
// Member:      CFrameSetSite::ApplyDefaultFormat, CSite
//
//-------------------------------------------------------------------------
HRESULT
CFrameSetSite::ApplyDefaultFormat(CFormatInfo * pCFI)
{
    CDoc *  pDoc = Doc();
    CMarkup * pMarkup = GetMarkup();

    if (!pMarkup->IsHtmlLayout())
    {
        pCFI->PrepareFancyFormat();

        pCFI->_ff().SetHeightPercent(TRUE);
        pCFI->_ff().SetWidthPercent(TRUE);
        if (    pMarkup->GetElementClient() == this
            &&  pMarkup->HasWindow()
            &&  (pMarkup->GetFrameOptions() & FRAMEOPTIONS_NO3DBORDER) == 0
            &&  (pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_NO3DBORDER) == 0 )
        {
            // set 3D border color attributes for top-level frameset
            //
            pCFI->_ff()._bd._ccvBorderColorLight.SetValue(
                    GetSysColorQuick(COLOR_3DLIGHT), FALSE);
            pCFI->_ff()._bd._ccvBorderColorShadow.SetValue(
                    GetSysColorQuick(COLOR_BTNSHADOW), FALSE);
            pCFI->_ff()._bd._ccvBorderColorHilight.SetValue(
                    GetSysColorQuick(COLOR_BTNHIGHLIGHT), FALSE);
            pCFI->_ff()._bd._ccvBorderColorDark.SetValue(
                    GetSysColorQuick(COLOR_3DDKSHADOW), FALSE);

        }
        pCFI->UnprepareForDebug();
    }

    return super::ApplyDefaultFormat(pCFI);
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSetSite::GetBorderInfo
//
//  Synopsis:   Generate the border information for a framesite
//
//-------------------------------------------------------------------------

DWORD
CFrameSetSite::GetBorderInfo(
    CDocInfo *      pdci,
    CBorderInfo *   pborderinfo,
    BOOL            fAll,
    BOOL            fAllPhysical
    FCCOMMA           FORMAT_CONTEXT FCPARAM)
{
    CDoc *  pDoc = Doc();
    if  (   !GetMarkup()->IsHtmlLayout()
         && (   GetMarkup() == Doc()->PrimaryMarkup()
             || (   IsInViewLinkBehavior(TRUE)
                 && !IsInViewLinkBehavior(FALSE) ))
         && (GetMarkup()->GetElementClient() == this)
         && ((GetMarkup()->GetFrameOptions() & FRAMEOPTIONS_NO3DBORDER) == 0)
         && ((pDoc->_dwFlagsHostInfo & (DOCHOSTUIFLAG_NO3DBORDER | DOCHOSTUIFLAG_NO3DOUTERBORDER)) == 0))
    {
        // set border style and border space for top-level frameset
        //
        pborderinfo->abStyles[SIDE_TOP]
                = pborderinfo->abStyles[SIDE_RIGHT]
                = pborderinfo->abStyles[SIDE_BOTTOM]
                = pborderinfo->abStyles[SIDE_LEFT]
                = fmBorderStyleSunken;
        pborderinfo->aiWidths[SIDE_TOP]
                = pborderinfo->aiWidths[SIDE_RIGHT]
                = pborderinfo->aiWidths[SIDE_BOTTOM]
                = pborderinfo->aiWidths[SIDE_LEFT]
                = 2;
        pborderinfo->wEdges = BF_RECT;
    }

    return super::GetBorderInfo(pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);
}

int CFrameSetSite::iPixelFrameHighlightWidth = 0;

int CFrameSetSite::iPixelFrameHighlightBuffer = 0;

//+---------------------------------------------------------------------------
//
//  Member:     CNoFramesElement::Save, public
//
//  Synopsis:   Saves all our embedded sites.
//
//  Arguments:  [pStreamWrBuff] -- Stream to write to
//              [fEnd]          -- TRUE if we're saving the end tag
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CNoFramesElement::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr;

    // No frameset for plaintext mode
    if (pStreamWrBuff->TestFlag(WBF_SAVE_PLAINTEXT))
        return S_OK;

    hr = super::Save(pStreamWrBuff, fEnd);
    if (hr)
        goto Cleanup;

    if (!fEnd)
    {
        DWORD dwOldFlags;

        hr = THR(pStreamWrBuff->NewLine());
        if (hr)
            goto Cleanup;
        hr = THR(pStreamWrBuff->NewLine());
        if (hr)
            goto Cleanup;

        dwOldFlags = pStreamWrBuff->ClearFlags(WBF_ENTITYREF);
        pStreamWrBuff->BeginPre();

        hr = THR(pStreamWrBuff->Write(_cstrNoFrames));
        if (hr)
            goto Cleanup;

        pStreamWrBuff->EndPre();
        pStreamWrBuff->RestoreFlags(dwOldFlags);

        hr = THR(pStreamWrBuff->NewLine());
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
// Member: OnPropertyChange
//
//-----------------------------------------------------------------------------
HRESULT
CFrameSetSite::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr;

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));
    if (hr)
        goto Cleanup;

    if (dispid == DISPID_CFrameSetSite_rows || dispid == DISPID_CFrameSetSite_cols)
    {
        SetRowsCols();
        Layout()->CancelManualResize(FALSE);
        Layout()->CancelManualResize(TRUE);
        ResizeElement();
    }

    if (dispid == DISPID_CFrameSetSite_frameBorder)
    {
        Doc()->_fFrameBorderCacheValid = FALSE;
    }

Cleanup:
    RRETURN(hr);
}

CBase *
CFrameSetSite::GetBaseObjectFor(DISPID dispID, CMarkup * pMarkup)
{
    // Messy.  We want to supply the window/markup if:
    // 1. We are backwards compatible and a BODY/FRAMESET (really should be *primary* BODY/FRAMESET).
    // 2. We are CSS1 strict, a BODY/FRAMESET (should be primary), and is not DISPID_EVPROP_ONSCROLL.
    // 3. We are CSS1 strict, an HTML element, and are DISPID_EVPROP_ONSCROLL
    // If we have to add other events to the list, we should make another static CMarkup fn.  (greglett)
    if (    !pMarkup
        &&  IsInMarkup() )
        pMarkup = GetMarkup();

    if (    CMarkup::IsTemporaryDISPID (dispID)
        &&  (   dispID != DISPID_EVPROP_ONSCROLL
            ||  !pMarkup                    
            ||  !pMarkup->IsHtmlLayout() ))
    {        
        if (!pMarkup)
            return NULL;
        else if (pMarkup->HasWindow())
            return pMarkup->Window();       // if we have a window use it 

        // if we have a pending window, we temporarily store these 
        // DISPIDs on the markup and move them onto the window when we switch
        else if (pMarkup->_fWindowPending)
            return pMarkup;
    }

    return this;
}


//+----------------------------------------------------------------------------
//
// Member: WaitForRecalc
//
//-----------------------------------------------------------------------------

void
CFrameSetSite::WaitForRecalc()
{
    CFrameSetLayout * pLayoutThis = Layout();
    CLayout *         pLayout;
    CFrameElement *   pFrameElement;
    DWORD_PTR         dw;

    for (pLayout = pLayoutThis->GetFirstLayout(&dw, FALSE);
         pLayout;
         pLayout = pLayoutThis->GetNextLayout(&dw, FALSE))
    {
        if (ETAG_FRAME == pLayout->Tag())
        {
            pFrameElement = DYNCAST(CFrameElement, pLayout->ElementOwner());

            if (pFrameElement->HasSlavePtr())
            {
                Doc()->WaitForRecalc(pFrameElement->GetSlavePtr()->GetMarkup());
            }
        }
        else if (ETAG_FRAMESET == pLayout->Tag())
        {
            DYNCAST(CFrameSetSite, pLayout->ElementOwner())->WaitForRecalc();
        }
    }

    pLayoutThis->ClearLayoutIterator(dw, FALSE);
}

void
CFrameSetSite::SetRowsCols()
{
    HRESULT                hr;
    CDataAry<CUnitValue> * paryValues;
    CDataAry<CUnitValue> * paryValuesResize;
    CUnitValue             uvValue;
    XorYLoop               dir;
    CStr                   cstr;
    LPCTSTR                pch;
    LPTSTR                 pchThis, pchNext;

    static const TCHAR * s_pszSep = _T(",;"); // Be liberal and allow semicolons
    static MYPROP  s_pdesc = {
                                      { NULL, NULL, 0, NOT_SET_DEFAULT },
                                      {
                                        {
                                           PP_UV_LENGTH_OR_PERCENT |
                                           PROPPARAM_TIMESRELATIVE, 0, 0
                                        },
                                        VT_EMPTY, 0, 0, 0
                                      }
                                    };

    // Clear rows/cols if they exist (IE6 15112)
    _aryCols.DeleteAll();
    _aryRows.DeleteAll();
    _aryColsResize.DeleteAll();
    _aryRowsResize.DeleteAll();
    if (CurrentlyHasAnyLayout())
        Layout()->SetDirtyFramePositions(TRUE);

    for (dir  = XDirection;
         dir != Terminate;
         dir  = ((dir==XDirection) ? YDirection : Terminate))
    {
        if (dir == XDirection)
        {
            pch = GetAAcols();
            paryValues = &_aryCols;
            paryValuesResize = &_aryColsResize;
        }
        else
        {
            pch = GetAArows();
            paryValues = &_aryRows;
            paryValuesResize = &_aryRowsResize;
        }

        if (!pch)
            continue;

        cstr.Set(pch); // Copy the string because _tcstok modifies it

        pchThis = cstr;

        while (pchThis && * pchThis)
        {
            pchNext = FindRowColSeparator(pchThis, s_pszSep);

            if (!(*pchThis))
            {
                // IE50 Raid 3475 - Treat empty string as "*"
                //
                hr = THR(uvValue.SetValue(100, CUnitValue::UNIT_TIMESRELATIVE));
            }
            else
            {
                // We are setting HTML-property and not CSS1 property.
                hr = THR(uvValue.FromString(pchThis, &s_pdesc.pdesc, 0)); 

                if (hr)
                {
                    uvValue.SetValue(0, CUnitValue::UNIT_PIXELS);
                }
                else if (uvValue.GetUnitValue() < 0)
                {
                    if (uvValue.GetUnitType() == CUnitValue::UNIT_PERCENT)
                    {
                        // treat negative percentage rows/cols values as "*"
                        //
                        hr = THR(uvValue.SetValue(100,
                                CUnitValue::UNIT_TIMESRELATIVE));
                    }
                    else
                    {
                        uvValue.SetValue(0, CUnitValue::UNIT_PIXELS);
                    }
                }
            }

            paryValues->AppendIndirect(&uvValue);
            paryValuesResize->AppendIndirect(&uvValue);
            pchThis = pchNext;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\ole\eobject.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eobject.cxx
//
//  Contents:   Object element class, etc..
//
//  Classes:    CObjectElement, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_MIME64_HXX_
#define X_MIME64_HXX_
#include "mime64.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_PROPBAG_HXX_
#define X_PROPBAG_HXX_
#include "propbag.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include "binder.hxx"       // for CDataSourceProvider
#endif

#ifndef X_DBTASK_HXX_
#define X_DBTASK_HXX_
#include "dbtask.hxx"       // for CDatabindTask
#endif

#ifndef X_DMEMBMGR_HXX_
#define X_DMEMBMGR_HXX_
#include "dmembmgr.hxx"       // for CDataMemberMgr
#endif

#ifndef X_POSTDATA_HXX_
#define X_POSTDATA_HXX_
#include "postdata.hxx"     // for cpostdata
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X_SAFETY_HXX_
#define X_SAFETY_HXX_
#include "safety.hxx"
#endif

#if defined(_M_ALPHA)
#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif
#endif

#define _cxx_
#include "object.hdl"

MtDefine(CParamElement, Elements, "CParamElement")
MtDefine(CObjectElement, Elements, "CObjectElement")
MtDefine(CObjectElement_aryParamBinding_pv, CObjectElement, "CObjectElement::_aryParamBinding::_pv")
MtDefine(CObjectElement_aryParams_pv, CObjectElement, "CObjectElement::_aryParams::_pv")
MtDefine(CObjectElementStreamFromInlineData_pMimeType, Locals, "CObjectElement::StreamFromInlineData pMimeType")
MtDefine(CObjectElementGetIDForParamBinding_strTemp, Locals, "CObjectElement::GetIDForParamBinding strTemp")
MtDefine(CObjectElementSaveToDataStream_pchData, Locals, "CObjectElement::SaveToDataStream pchData")
MtDefine(CObjectElementCreateObject_pchUrl, CObjectElement, "CObjectElement::CreateObject pchUrl")
MtDefine(CObjectElementRetrieveClassidAndData_pchUrl, CObjectElement, "CObjectElement::RetrieveClassidAndData pchUrl")

#define CLSID_PREFIX                _T("clsid:")
#define CLSID_PREFIX_LEN            (ARRAY_SIZE(CLSID_PREFIX)-1)

#define DATA_PREFIX                 _T("data:")
#define DATA_PREFIX_LEN             (ARRAY_SIZE(DATA_PREFIX)-1)

#define DATA_COMPLETE_PREFIX        _T("data:application/x-oleobject;base64,")
#define DATA_COMPLETE_PREFIX_LEN    (ARRAY_SIZE(DATA_COMPLETE_PREFIX)-1)

#define DATA_ENCODING               _T("base64")
#define DATA_ENCODING_LEN           (ARRAY_SIZE(DATA_ENCODING)-1)

#define DATA_MIMETYPE               _T("application/x-oleobject")
#define DATA_MIMETYPE_LEN           (ARRAY_SIZE(DATA_MIMETYPE)-1)

#define CODEBASE_VERSION            _T("version=")

#define CODEBASE_KEY_LEN            4

/// Externs 
EXTERN_C CLSID CLSID_AppletOCX;
extern BOOL IsSpecialUrl(LPCTSTR pchUrl);   // TRUE for javascript, vbscript, about protocols

// Apphack CLSIDs to instantiate in print/preview (IE6 15562)
const CLSID CLSID_Taltech_Barcode   = { 0xC917E12F, 0x9757, 0x11D2, 0x85, 0xDB, 0xF0, 0x18, 0x51, 0xC1, 0x00, 0x00 };   // Taltech barcode (demo & retail)
const CLSID CLSID_AOL_Calendar      = { 0x3AEE3932, 0x59BB, 0x11D3, 0xA8, 0xCC, 0x00, 0x50, 0x04, 0xA0, 0xF3, 0x23 };   // AOL calendar
const CLSID CLSID_CS_Calendar       = { 0xA552A602, 0x0A49, 0x11D4, 0x92, 0xCD, 0x00, 0x60, 0xB0, 0xFA, 0x8D, 0xAC };   // CS caldendar

// Apphack CLSIDs that require special handling in browser mode
const CLSID CLSID_MPIT_Menu         = { 0x22AA22B2, 0x2439, 0x11D3, 0xB9, 0x9C, 0x00, 0xC0, 0x4F, 0x68, 0x8B, 0xE3 };   // Popup menu
WHEN_DBG(CLSID CLSID_MPIT_MenuDBG = CLSID_MPIT_Menu);

#ifdef WIN16
const CLSID CLSID_CMSApplet16 = { 0x0D30EC48L, 0xDD33, 0x11D0, {0xA0, 0xFD, 0x00, 0x00, 0xF8, 0x75, 0x1B, 0x8D}};
// const CLSID CLSID_CMSApplet16 = { 0xfc144cc0, 0x2136, 0x11d0, {0x95, 0x38, 0x0, 0xaa, 0x0, 0x4b, 0x9c, 0x68}};
#endif

const CElement::CLASSDESC CParamElement::s_classdesc =
{
    {
        &CLSID_HTMLParamElement,            // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        NULL,                               // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLParamElement,             // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLParamElement,      // _pfnTearOff
    NULL                                    // _pAccelsRun
};

const CONNECTION_POINT_INFO CObjectElement::s_acpi[] =
{
    CPI_ENTRY(IID_IPropertyNotifySink, DISPID_A_PROPNOTIFYSINK)
    CPI_ENTRY(DIID_HTMLObjectElementEvents, DISPID_A_EVENTSINK)
    CPI_ENTRY(DIID_HTMLObjectElementEvents2, DISPID_A_EVENTSINK)
    CPI_ENTRY(IID_IDispatch, DISPID_A_EVENTSINK)
    CPI_ENTRY(IID_ITridentEventSink, DISPID_A_EVENTSINK)
    CPI_ENTRY(IID_NULL, DISPID_A_EVENTSINK) // This will be filled up at
                                        //   with ocx's primary event iid.
    CPI_ENTRY_NULL
};

const CElement::CLASSDESC CObjectElement::s_classdesc =
{
    {
        &CLSID_HTMLObjectElement,       // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NEVERSCROLL    |
        ELEMENTDESC_OLESITE        |    // _dwFlags
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NOANCESTORCLICK,
        &IID_IHTMLObjectElement,        // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLObjectElement, // _pfnTearOff
    NULL                                // _pAccelsRun
};

static void
GetVersionFromString(const TCHAR *pchBuf, DWORD *pdwMS, DWORD *pdwLS);

//+---------------------------------------------------------------------------
//
//  Function:   GetVersionFromString
//
//  Synopsis:   Converts version in text format (a,b,c,d) into two dwords
//              (a,b), (c,d).  The printed version number is of format a.b.d
//              (but, we don't care)
//
//  Notes:      Lifted from URLMON.DLL sources.
//
//----------------------------------------------------------------------------

void
GetVersionFromString(const TCHAR *pchBuf, DWORD *pdwMS, DWORD *pdwLS)
{
    const TCHAR *   pch = pchBuf;
    TCHAR           ch;
    USHORT          n = 0;
    USHORT          a = 0;
    USHORT          b = 0;
    USHORT          c = 0;
    USHORT          d = 0;
    enum HAVE { HAVE_NONE, HAVE_A, HAVE_B, HAVE_C, HAVE_D } have = HAVE_NONE;

    *pdwMS = 0;
    *pdwLS = 0;

    if (!pch)            // default to zero if none provided
        return;

    // TODO:  philco 5/6/96
    // Need to add code to handle trailing/leading/embedded spaces in the
    // version string.
    if (!StrCmpC(pch, _T("-1,-1,-1,-1")))
    {
        *pdwMS = 0xFFFFFFFF;
        *pdwLS = 0xFFFFFFFF;
        return;
    }

    for (ch = *pch++;;ch = *pch++)
    {
        if (ch == ',' || ch == '\0')
        {
            switch (have)
            {
            case HAVE_NONE:
                a = n;
                have = HAVE_A;
                break;

            case HAVE_A:
                b = n;
                have = HAVE_B;
                break;

            case HAVE_B:
                c = n;
                have = HAVE_C;
                break;

            case HAVE_C:
                d = n;
                have = HAVE_D;
                break;

            case HAVE_D:
                goto Error;
            }

            if (ch == '\0')
            {
                // all done convert a,b,c,d into two dwords of version

                *pdwMS = ((a << 16)|b);
                *pdwLS = ((c << 16)|d);
                return;
            }

            n = 0; // reset
        }
        else if (ch < '0' || ch > '9')
            goto Error;
        else
        {
            n = n*10 + (ch - '0');
        }
    } /* end forever */

Error:
    *pdwMS = *pdwLS = 0;
}

HRESULT CParamElement::CreateElement(CHtmTag *pht,
                                     CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);
    *ppElementResult = new CParamElement(pht->GetTag(), pDoc);
    return *ppElementResult ? S_OK : E_OUTOFMEMORY;
}

HRESULT 
CObjectElement::RemoveParam(CElement *pelOld)
{
    int idx;
    int c = _aryParams.Size();
    LPCTSTR pchName;
    HRESULT hr = S_OK;
    Assert(pelOld);
    Assert(pelOld->Tag() == ETAG_PARAM);
    CParamElement *pelParam = DYNCAST(CParamElement, pelOld);

    idx = pelParam->_idxParam;
    Assert(idx == _aryParams.Find(pelParam));
    Assert(idx != -1 && idx < c);
    Assert(_aryParams[idx] && _aryParams[idx] == pelParam);
    Assert(_aryParams[idx]->_pelObjParent == this);

    _aryParams.Delete(idx);

    for (int i = idx; i < c-1; i++)
    {
        Assert(_aryParams[i]->_idxParam == i+1);
        _aryParams[i]->_idxParam = i;
    }

    pelParam->_idxParam = -1;
    pelParam->Release();
    Assert(pelParam->GetObjectRefs());

    Assert(c-1 == _aryParams.Size());
    Assert(pelParam->_pelObjParent);

    pelParam->_pelObjParent = NULL;

    if (_pParamBag)
    {
        Assert(_pParamBag && c>0);
        Assert(c == _pParamBag->_aryProps.Size());

        pchName = pelParam->GetAAname();
        Assert(pchName && *pchName);

        for (idx = 0; idx < c; idx++)
        {
            if (0 == _tcsicmp(pchName, _pParamBag->_aryProps[idx]._cstrName))
            {
                _pParamBag->_aryProps[idx].Free();
                _pParamBag->_aryProps.Delete(idx);
                break;
            }
        }

        Assert(c-1 == _pParamBag->_aryProps.Size());
    }

    RRETURN(hr);
}

HRESULT 
CObjectElement::ReplaceParam(CElement *pelNew, CElement *pelOld)
{
    int idx;
    int c;
    LPCTSTR pchName;
    BOOL fAddParam = TRUE;
    HRESULT hr = E_INVALIDARG;
    CParamElement *pelParam;
    Assert(pelOld->Tag() == ETAG_PARAM);
    CParamElement *pelParamOld = DYNCAST(CParamElement, pelOld);

    if (pelNew->Tag() != ETAG_PARAM)
        goto Cleanup;

    // remove <PARAM> from exisiting <OBJECT> if present, first
    pelParam = DYNCAST(CParamElement, pelNew);
    if (pelParam->_pelObjParent)
    {
        Assert(!pelNew->IsInMarkup());
        Assert(pelParam->_idxParam != -1);
        hr = THR(pelParam->_pelObjParent->RemoveParam(pelParam));
        if (hr)
            goto Cleanup;
    }
    else if (pelNew->IsInMarkup())
    {
        Assert(Doc() == pelNew->Doc());
        hr = THR(Doc()->RemoveElement(pelNew, MUS_DOMOPERATION));
        if (hr)
            goto Cleanup;
    }

    c = _aryParams.Size();

    if (_pParamBag)
    {
        Assert(_pParamBag && c>0);
        Assert(c == _pParamBag->_aryProps.Size());

        pchName = pelParamOld->GetAAname();
        Assert(pchName && *pchName);

        for (idx = 0; idx < c; idx++)
        {
            if (0 == _tcsicmp(pchName, _pParamBag->_aryProps[idx]._cstrName))
            {
                _pParamBag->_aryProps[idx].Free();
                _pParamBag->_aryProps.Delete(idx);
                Assert(c-1 == _pParamBag->_aryProps.Size());
                break;
            }
        }

        Assert(idx < c);

        pchName = pelParam->GetAAname();
        if (pchName && *pchName)
        {
            LPCTSTR pchValue = pelParam->GetAAvalue();
            hr = THR(_pParamBag->AddProp((LPTSTR)pchName, _tcslen(pchName), (LPTSTR)pchValue, pchValue ? _tcslen(pchValue) : 0));
            if (hr)
                goto Cleanup;
        }

        fAddParam = (c == _pParamBag->_aryProps.Size());
    }

    Assert(pelParamOld);
    idx = pelParamOld->_idxParam;
    Assert(idx == _aryParams.Find(pelParamOld));
    Assert(idx != -1 && idx < c);
    Assert(_aryParams[idx] && _aryParams[idx] == pelOld);
    _aryParams[idx]->Release();
    Assert(pelParamOld->GetObjectRefs());
    Assert(_aryParams[idx]->_pelObjParent);
    Assert(_aryParams[idx]->_pelObjParent == this);
    Assert(_aryParams[idx]->_pelObjParent == pelParamOld->_pelObjParent);

    Assert(pelParam->_idxParam == -1);
    pelParamOld->_idxParam = -1;
    pelParamOld->_pelObjParent = NULL;

    if (fAddParam)
    {
        pelParam->AddRef();
        _aryParams[idx] = pelParam;
        pelParam->_idxParam = idx;
        Assert(c == _aryParams.Size());
        Assert(!pelParam->_pelObjParent);
        // the parent <OBJECT> will always outlive the child <PARAM>s, so no need to AddRef
        pelParam->_pelObjParent = this; 
    }
    else
    {
        Assert(!_pParamBag || (c-1 == _pParamBag->_aryProps.Size()));
        _aryParams.Delete(idx);
        Assert(c-1 == _aryParams.Size());

        for (int i = idx; i < c-1; i++)
        {
            Assert(_aryParams[i]->_idxParam == i+1);
            _aryParams[i]->_idxParam = i;
        }
    }

    hr= S_OK;

Cleanup:
    RRETURN(hr);
}

HRESULT 
CObjectElement::AddParam(CElement *pelNew, CElement *pelRef)
{
    LPCTSTR pchName;
    HRESULT hr = E_INVALIDARG;
    BOOL fAddParam = TRUE;
    int c;
    CParamElement *pelParam;

    if (pelNew->Tag() != ETAG_PARAM)
        goto Cleanup;

    // first, remove <PARAM> from exisiting <OBJECT> if present or other element if in markup
    pelParam = DYNCAST(CParamElement, pelNew);
    if (pelParam->_pelObjParent)
    {
        Assert(!pelNew->IsInMarkup());
        Assert(pelParam->_idxParam != -1);
        hr = THR(pelParam->_pelObjParent->RemoveParam(pelParam));
        if (hr)
            goto Cleanup;
    }
    else if (pelNew->IsInMarkup())
    {
        Assert(Doc() == pelNew->Doc());
        hr = THR(Doc()->RemoveElement(pelNew, MUS_DOMOPERATION));
        if (hr)
            goto Cleanup;
    }

    c = _aryParams.Size();
    Assert(c || !_pParamBag);

    if (!c && !_pParamBag)
    {
        hr = THR(EnsureParamBag());
        if (hr)
            goto Cleanup;
    }

    if (_pParamBag)
    {
        Assert(c == _pParamBag->_aryProps.Size());

        pchName = pelParam->GetAAname();
        if (pchName && *pchName)
        {
            LPCTSTR pchValue = pelParam->GetAAvalue();
            hr = THR(_pParamBag->AddProp((LPTSTR)pchName, _tcslen(pchName), (LPTSTR)pchValue, pchValue ? _tcslen(pchValue) : 0));
            if (hr)
                goto Cleanup;
        }

        fAddParam = (c+1 == _pParamBag->_aryProps.Size());
    }

    if (fAddParam)
    {
        pelParam->AddRef();
        Assert(pelParam->_idxParam == -1);
        if (pelRef)
        {
            CParamElement *pelParamRef = DYNCAST(CParamElement, pelRef);
            int idx = pelParamRef->_idxParam;
            Assert(idx == _aryParams.Find(pelParamRef));
            Assert(idx != -1 && idx < c);
            Assert(pelParamRef->_pelObjParent == this);
            Assert(_aryParams[idx] && _aryParams[idx] == pelParamRef);
            hr = THR(_aryParams.Insert(idx, pelParam));
            pelParam->_idxParam = idx;

            for (int i = idx+1; i <= c; i++)
            {
                Assert(_aryParams[i]->_idxParam == i-1);
                _aryParams[i]->_idxParam = i;
            }
        }
        else
        {
            hr = THR(_aryParams.Append(pelParam));
            pelParam->_idxParam = c;
        }

        if (hr)
            goto Cleanup;

        Assert(c+1 == _aryParams.Size());
        Assert(!pelParam->_pelObjParent);
        // the parent <OBJECT> will always outlive the child <PARAM>s, so no need to AddRef
        pelParam->_pelObjParent = this; 
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  element creator used by parser
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);

    *ppElementResult = new CObjectElement(pht->GetTag(), pDoc);

    RRETURN ( (*ppElementResult) ? S_OK : E_OUTOFMEMORY);
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement constructor
//
//----------------------------------------------------------------------------

CObjectElement::CObjectElement (ELEMENT_TAG etag, CDoc *pDoc)
  : super(etag, pDoc), _aryParamBinding(Mt(CObjectElement_aryParamBinding_pv)), 
                       _aryParams(Mt(CObjectElement_aryParams_pv))

{
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::Passivate, CBase
//
//----------------------------------------------------------------------------

void
CObjectElement::Passivate()
{
    long i;

#ifndef NO_DATABINDING
    //
    // There may be deferred calls pending to DeferredSaveData which
    // we need to clear
    //

    GWKillMethodCall(this, ONCALL_METHOD(CObjectElement, DeferredSaveData, deferredsavedata), 0);
#endif

    for ( i = _aryParamBinding.Size() ; i ; )
    {
        PARAMBINDING *pParamBinding = &_aryParamBinding[--i];

        MemFree(pParamBinding->_strParamName);
        MemFree(pParamBinding->_strDataSrc);
        MemFree(pParamBinding->_strDataFld);
        MemFree(pParamBinding->_strDataFormatAs);
    }
    _aryParamBinding.DeleteAll();

    for (i = _aryParams.Size() ; i ; )
    {
        CParamElement *pelParam = _aryParams[--i];
        Assert(pelParam && pelParam->Tag() == ETAG_PARAM);
        Assert(pelParam->_pelObjParent == this);
        pelParam->_pelObjParent = NULL;
        pelParam->Release();
    }
    _aryParams.DeleteAll();

    if (_pParamBag)
    {
        // This will only happen if the </OBJECT> end-tag is missing.
        TraceTag((tagError, "Missing </OBJECT> tag in HTML source!"));
        ReleaseParamBag();
    }

    super::Passivate();
}


//+----------------------------------------------------------------------------
//
//  Member:     CObjectElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-----------------------------------------------------------------------------

HRESULT
CObjectElement::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLElement2, NULL)
        QI_HTML_TEAROFF(this, IHTMLObjectElement, NULL)
        QI_INHERITS2(this, IUnknown, IHTMLObjectElement)
        QI_HTML_TEAROFF(this, IHTMLObjectElement2, NULL)
        QI_HTML_TEAROFF(this, IHTMLObjectElement3, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     InvokeExReady
//
//  Synopsis  :this is only here to handle readyState queries, everything
//      else is passed on to the super
//
//+------------------------------------------------------------------------

#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif

STDMETHODIMP
CObjectElement::ContextThunk_InvokeExReady(DISPID dispid,
                              LCID lcid,
                              WORD wFlags,
                              DISPPARAMS *pdispparams,
                              VARIANT *pvarResult,
                              EXCEPINFO *pexcepinfo,
                              IServiceProvider *pSrvProvider)
{
    IUnknown * pUnkContext;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    HRESULT  hr = S_OK;

    hr = THR(ValidateInvoke(pdispparams, pvarResult, pexcepinfo, NULL));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(ReadyStateInvoke(dispid, wFlags, _lReadyState, pvarResult));
    if (hr == S_FALSE)
    {
        hr = THR_NOTRACE(super::ContextInvokeEx(dispid,
                                         lcid,
                                         wFlags,
                                         pdispparams,
                                         pvarResult,
                                         pexcepinfo,
                                         pSrvProvider,
                                         pUnkContext ? pUnkContext : (IUnknown*)this));
    }

Cleanup:
    RRETURN(hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::StreamFromInlineData
//
//  Synopsis:   Retrieve DATA as a mime64 encoded string.
//
//  Notes:      Parses a data attribute of the form:
//
//              DATA="data:application/x-oleobject;base64,8dhfh8d4mvc983f"
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::StreamFromInlineData(TCHAR *pchData, IStream ** ppStm)
{
    if (!pchData || !ppStm)
        return E_INVALIDARG;

    HRESULT hr = E_FAIL;
    LPTSTR pData = pchData + DATA_PREFIX_LEN; // skip past data: URL specifier

    LPTSTR pComma = _tcsrchr(pData, _T(','));
    if (pComma == NULL)
        return E_INVALIDARG;    // Bad data attribute

    LPTSTR pSemiColon = _tcsrchr(pData, _T(';'));
    if (pSemiColon > pComma)
        pSemiColon = NULL;    // handles case where ';' appears in the encoded data.

    // Indicates the end of the mimetype designation.
    LPTSTR pMimeTerminator = pSemiColon ? pSemiColon : pComma;

    LPTSTR pMimeType = NULL;
    int mimelength = pMimeTerminator - pData + 1;  // leave room for the null terminator

    if (mimelength > 0)
    {
        pMimeType = (TCHAR *)MemAlloc(Mt(CObjectElementStreamFromInlineData_pMimeType),
            mimelength * sizeof(TCHAR));
        if (pMimeType)
        {
            // Since _tcsncpy doesn't terminate the string,
            // fill the memory with zeros.
            ::ZeroMemory(pMimeType, mimelength * sizeof(TCHAR));
            _tcsncpy(pMimeType, pData, (mimelength - 1));
        }
    }
    else
    {
        // Default to this mime type.
        MemAllocString(Mt(CObjectElementStreamFromInlineData_pMimeType),
            _T("text/plain;charset=US-ASCII"), &pMimeType);
    }

    if (pSemiColon)
    {
        pSemiColon = CharNext(pSemiColon);
        if ((_tcsnicmp( pSemiColon, DATA_ENCODING_LEN, DATA_ENCODING, DATA_ENCODING_LEN) == 0) && (_tcsncmp(pMimeType, DATA_MIMETYPE_LEN, DATA_MIMETYPE, DATA_MIMETYPE_LEN) == 0))
        {
            pComma = CharNext(pComma);
            hr = Mime64Decode(pComma, ppStm);
            goto Cleanup;
        }
    }

Cleanup:
    MemFree(pMimeType);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::SaveToDataStream
//
//  Synopsis:   Set the DATA attribute as a mime64 encoded string.
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::SaveToDataStream()
{
    HRESULT                 hr = S_OK;
    IPersistStreamInit *    pPSI = NULL;
    IStream *               pStm = NULL;
    STATSTG                 statstg;
    HGLOBAL                 hGlobal;
    LPVOID                  pv;
    TCHAR *                 pchData = NULL;

    hr = THR_NOTRACE(QueryControlInterface(IID_IPersistStreamInit, (void **)&pPSI));
    if (hr)
    {
        if (E_NOINTERFACE == hr) // eat up certain errors
            hr = S_OK;
        goto Cleanup;
    }

    hr = THR(CreateStreamOnHGlobal(NULL, TRUE, &pStm));
    if(hr)
        goto Cleanup;

    hr = THR(OleSaveToStream((IPersistStream*)pPSI, pStm));
    if (hr)
    {
        if (E_NOTIMPL == hr)
            hr = S_OK;  // bug 49053
        goto Cleanup;
    }

    hr = THR(pStm->Stat(&statstg, STATFLAG_NONAME));
    if (hr)
        goto Cleanup;

    if (statstg.cbSize.HighPart)
    {
        hr = E_FAIL; // way too long stream to save it
        goto Cleanup;
    }

    hr = THR(GetHGlobalFromStream(pStm, &hGlobal));
    if (hr)
        goto Cleanup;

    pv = GlobalLock(hGlobal);
    if (pv == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // we allocate this size under assumption that
    // mime64 encoding increases size if input not more than 2 times
    pchData = new(Mt(CObjectElementSaveToDataStream_pchData)) TCHAR [DATA_COMPLETE_PREFIX_LEN + 2 * statstg.cbSize.LowPart + 1];
    if (!pchData)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _tcscpy (pchData, DATA_COMPLETE_PREFIX);

    hr = THR(Mime64Encode((BYTE *)pv, statstg.cbSize.LowPart, pchData + DATA_COMPLETE_PREFIX_LEN));
    if (hr)
        goto Cleanup;

    GlobalUnlock(hGlobal);

    hr = THR(SetAAdata(pchData));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pPSI);
    ReleaseInterface(pStm);
    delete [] pchData;
    RRETURN(hr);
}

// (alexz) (anandra) (oliverse) (hollyba)
// because of a bug in JavaVM (as of Sep 3, 97), applets can crash when printed on
// FE Win95 systems. For stability reasons, instead of making the fix in JavaVM
// (which is not safe) we disable printing them on FE Win95 systems. In case if
// Java VM team makes a private or other drop of java VM with the problem fixed,
// registry key Software\\Microsoft\\Internet Explorer\\PrintAppletsOnFEWin95 can
// be put into the registry which will allow printing of applets on FE Win95.
// All other systems should not be affected by this fix.
//

BOOL PrintAppletsOnFEWin95()
{
    static TCHAR szTableRootKey[] =
        _T("Software\\Microsoft\\Internet Explorer\\PrintAppletsOnFEWin95");

    LONG    lRet;
    HKEY    hkeyRoot = NULL;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTableRootKey, 0, KEY_READ, &hkeyRoot);

    if (hkeyRoot)
        RegCloseKey (hkeyRoot);

    return (ERROR_SUCCESS == lRet) ? TRUE : FALSE;
}


//+------------------------------------------------------------------------
//
//  Member:     CObjectElement::CreateObject()
//
//  Synopsis:   Helper to instantiate control
//
//-------------------------------------------------------------------------

HRESULT
CObjectElement::CreateObject()
{
    HRESULT             hr = S_OK;
    OLECREATEINFO       info;
    TCHAR *             pchCodeBase = NULL;
    TCHAR *             pchVersion = NULL;
    TCHAR   cBuf[pdlUrlLen];
    TCHAR *             pchBaseUrl = cBuf;

    GWKillMethodCall((COleSite *)this, ONCALL_METHOD(COleSite, DeferredCreateObject, deferredcreateobject), 0);

    // if already created, do nothing
    if (_pUnkCtrl)
        goto Cleanup;

    //
    // This is where we create the object based on the html attributes
    // First try and get a clsid if possible.
    //

    hr = RetrieveClassidAndData(
             &info.clsid,
             &info.pStream,
             &info.pchDataUrl,
             &info.pchClassid);

    // We found a applet tag with a non Applet clsid OR 
    // an object tag with a code attribute and non-applet clsid, so prevent creation
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    //
    // Check if there is a snapshot. 
    // If there is, don't bother learning anything else about the object.
    //
    if (    _pParamBag
        &&  HasMarkupPtr()
        &&  GetMarkupPtr()->IsPrintMedia())
    {
        // AppHack (greglett)
        // Certain ActiveX controls want to draw during printing so that they can take
        // advantage of the higher resolution.
        if (    info.clsid == CLSID_Taltech_Barcode
            ||  info.clsid == CLSID_AOL_Calendar
            ||  info.clsid == CLSID_CS_Calendar         )       // Any more and we should iterate over a list!
            goto InstantiateHere;
        
        // See if there is a metafile provided
        VARIANT    var;
        var.vt = VT_BSTR;


        if (OK(_pParamBag->Read(L"_Snapshot_EMF", &var, NULL, 0)) &&
            var.vt == VT_BSTR && var.bstrVal)
        {
            // "_ZERO" means that the original didn't have layout, or had zero size.
            // We don't need it at all.
            if (0 !=_tcscmp(var.bstrVal, _T("_ZERO")))
            {
                // "_EB_FACTORY" means that this object doesn't have a metafile and 
                // MUST be instantiated. If not, then nothing will print/preview 
                // sicne we can't instantiate the element behavior
                if (0 ==_tcscmp(var.bstrVal, _T("_EB_FACTORY")))
                {
                    VariantClear(&var);
                    goto InstantiateHere;
                }

                // Open the metafile and hold on to it
                if (g_dwPlatformID == VER_PLATFORM_WIN32_NT)
                {
                    // Use Unicode file name
                    _hemfSnapshot = GetEnhMetaFile(var.bstrVal);
                }
                else
                {
                    // Use ANSI file name
                    char achFileNameA[MAX_PATH];
                    if (WideCharToMultiByte(CP_OEMCP, 0, var.bstrVal, -1, achFileNameA, MAX_PATH, NULL, NULL))
                    {
                        _hemfSnapshot = GetEnhMetaFileA(achFileNameA);
                    }
                }
            }
            // NOTE: whether we have succeeded with opening metafile or not, 
            //       DON'T proceed to loading the object. If there is metafile name in the stream,
            //       the object data is not usable.
            VariantClear(&var);

             // Supply a dummy object to pretend we've loaded it. It will fail all QIs and do nothing.
            _pUnkCtrl = (IUnknown *) new CDummyUnknown;
            _pUnkCtrl->AddRef();
            goto Cleanup;
        }
    } 
    
    // If we are in a print media markup, (getting here means we did NOT have a metafile)
    // and If we are a print template, don't instantiate the control.. 
    //    this is a major security issue, and a bigger UI problem.
    if (    !_fViewLinkedWebOC
        &&  IsPrintMedia()     )
    {
        // if we do not have a param bag, but are in a print media markup in a print template
        // still do not bring up the contrl
        // however, we do want to go to READYSTATE_COMPLETE so no one waits for us to download
        OnControlReadyStateChanged(TRUE);
        goto Cleanup;
    }


InstantiateHere:

    //
    // Bail out if not allowed to create control/applet/plugin
    //

    // [kusumav] - Moved this check from COleSite::CreateObjectNow
    // We may not have a clsid here but unless we pass in URLPOLICY_ACTIVEX_CHECK_LIST as a policy
    // to check when we call ProcessUrlAction, urlmon doesn't even look at this clsid. We only
    // check if controls are allowed to be created for the current zone.
    // A better fix may be to start the bind and wait for the clsid/mime notification but since 
    // urlmon posts progress notifications async-ly and due to the time gap to call Terminate
    // urlmon may already have created the server which we don't want. 
    if (!AllowCreate(info.clsid))
    {
        NotifyHaveProtectedUserFromUnsafeContent(GetMarkup(), IDS_OCXDISABLED);
        OnFailToCreate();
        OnControlReadyStateChanged();
        goto Cleanup;
    }

    // Check for zone elevation in case of the web browser object.
    CMarkup *pMarkup = HasMarkupPtr() ? GetMarkupPtr() : NULL;
    if (pMarkup && _pParamBag && (info.clsid == CLSID_WebBrowser || info.clsid == CLSID_WebBrowser_V1))
    {
        PROPNAMEVALUE *pprop = NULL;
        TCHAR cBuf[pdlUrlLen];
        BSTR bstrLoc = _T("location");

        pprop = _pParamBag->Find(bstrLoc);
        if (pprop)
        {
            hr = THR(CMarkup::ExpandUrl(NULL, V_BSTR(&pprop->_varValue), ARRAY_SIZE(cBuf), cBuf, this));
            if (!SUCCEEDED(hr) || !COmWindowProxy::CanNavigateToUrlWithLocalMachineCheck(pMarkup, NULL, cBuf))
            {
                OnFailToCreate();
                goto Cleanup;
            }
        }
    }

    //
    // Now initialize the mime type
    //

    if (info.clsid == CLSID_NULL && GetAAtype())
    {
        MemAllocString(Mt(OleCreateInfo),
            (TCHAR *)GetAAtype(), &info.pchMimeType);
    }

    //
    // Initialize the major and minor versions to a default of 0
    //

    info.dwMajorVer = info.dwMinorVer = (DWORD)0;

    //
    // Go about determining the source of the object/applet
    //

    info.pchSourceUrl = NULL;
    pchCodeBase = (TCHAR*) GetAAcodeBase();
    if (pchCodeBase)
    {
        // CODEBASE= values can take several forms:
        // 1. Full URL path:  CODEBASE=http://www.this.com/ctrls/foo.cab#version=...
        // 2. Relative URL:   CODEBASE=ctrls/foo.cab#version=...
        // 3. No URL:         CODEBASE=#version=...

        if (pchCodeBase[0] != _T('#') )
        {
            TCHAR   cBuf[pdlUrlLen];
            DWORD   dwZone;
            IInternetSecurityManager *pSecurityManager;

            // There is a part of a URL to expand & combine:
            hr = THR(CMarkup::ExpandUrl(NULL, pchCodeBase, ARRAY_SIZE(cBuf), cBuf, this));

            if (hr)
                goto Cleanup;

            // Reducing Attack Surface area, we will not allow special urls in the data attrib
            if (IsSpecialUrl(cBuf))
            {
                hr = E_ACCESSDENIED;
                goto Cleanup;
            }

            CMarkup *    pMarkup = HasMarkupPtr() ? GetMarkupPtr() : NULL;  //Moved from down a-thkesa.
            if (pMarkup)
            {
               pSecurityManager = GetMarkup()->GetSecurityManager();
               if (!pSecurityManager)
                  hr = E_ACCESSDENIED;
               else
               {
                  pSecurityManager->MapUrlToZone(cBuf, &dwZone, 0);

                  if (dwZone == URLZONE_LOCAL_MACHINE)
                  {
                      DWORD dwPageUrlZone;
                      pSecurityManager->MapUrlToZone(CMarkup::GetUrl(GetMarkup()), &dwPageUrlZone, 0);
                      if (dwPageUrlZone != URLZONE_LOCAL_MACHINE)
                         hr = E_ACCESSDENIED;
                  }
               }

               if (hr)
                 goto Cleanup;

               if (pMarkup->ValidateSecureUrl(pMarkup->IsPendingRoot(), cBuf, FALSE, FALSE))
                {
                    MemAllocString(Mt(CObjectElementCreateObject_pchUrl), cBuf, &info.pchSourceUrl);
                    if (info.pchSourceUrl == NULL)
                        goto Cleanup;

                    pchCodeBase = info.pchSourceUrl;

                    //
                    // Search the codebase for '#'.  This is the delimiter for the
                    // version.
                    //

                    // (ferhane/alanshi) 
                    // For Fusion usage, URLMON now needs the complete URL as the codebase string, 
                    // including the version information. So, we stopped terminating the codebase
                    // string at the '#' sign. The version string is still copied and used separately.

                    pchVersion = _tcschr(info.pchSourceUrl, _T('#'));

                    if (pchVersion)
                        pchVersion++;
                }
            }
        }
        else
        {   // There was only a version number:
            pchVersion = pchCodeBase+1;
        }

        if (pchVersion)
        {
            //
            // Continue searching for the "version="
            //

            if (_tcsnipre(
                    CODEBASE_VERSION, ARRAY_SIZE(CODEBASE_VERSION) - 1,
                    pchVersion, -1))
            {
                // Advance past the "version="
                pchVersion += ARRAY_SIZE(CODEBASE_VERSION) - 1;
                GetVersionFromString(pchVersion, &info.dwMajorVer, &info.dwMinorVer);
            }
        }
    }

    //
    // Finally in the case of the applet oc, specifically save
    // all attributes into the param bag so the applet oc can retrieve
    // everything.
    //
    if (info.clsid == CLSID_AppletOCX)
    {
        if (g_fFarEastWin9X && GetMarkupPtr()->IsPrintMedia())
        {
            if (!PrintAppletsOnFEWin95())
            {
                hr = E_FAIL;
                goto Cleanup;
            }
        }

        hr = THR(EnsureParamBag());
        if (hr)
            goto Cleanup;

        Assert(_pParamBag);

        //
        // Save attributes into param bag.
        //

        hr = THR(super::SaveAttributes(_pParamBag));
        if (hr)
            goto Cleanup;

        //
        // Set the codebase attribute to point to the full base url
        // The VM ocx needs this.
        //

        if (!pchCodeBase)
        {
            hr = THR(CMarkup::ExpandUrl(NULL, _T("."), ARRAY_SIZE(cBuf), pchBaseUrl, this));
            if (hr)
                goto Cleanup;

            // Reducing Attack Surface area, we will not allow special urls in the data attrib
            if (IsSpecialUrl(cBuf))
            {
                hr = E_ACCESSDENIED;
                goto Cleanup;
            }

            CMarkup *    pMarkup = HasMarkupPtr() ? GetMarkupPtr() : NULL;
            if (pMarkup)
            {
                if (!pMarkup->ValidateSecureUrl(pMarkup->IsPendingRoot(), pchBaseUrl, FALSE, FALSE))
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }
                hr = THR(_pParamBag->AddProp(_T("codeBase"), pchBaseUrl));
                if (hr)
                    goto Cleanup;
            }
        }
        else
        {
            // update the entry with the new string, 
            hr = THR(_pParamBag->FindAndSetProp(_T("codeBase"), pchCodeBase));
            if (hr)
                goto Cleanup;
        }
    }

    if (TLS(_pDataObjectForPaste))
    {
        info.pDataObject = TLS(_pDataObjectForPaste);
        (info.pDataObject)->AddRef();

        // Just to make the point that we have consumed this data obj.
        TLS(_pDataObjectForPaste) = NULL;
    }

    if (_pParamBag)
    {
        info.pPropBag = _pParamBag;
        _pParamBag->AddRef();
    }

    {
        //
        // (t-chrisr) hack so that webcheck can find out all the
        // information it needs to properly pull down java applets.
        //
        if (_pParamBag &&
            (OlesiteTag() == OSTAG_APPLET) &&
            (Doc()->_dwLoadf & DLCTL_NO_JAVA) &&
            Doc()->_pClientSite)
        {
            VARIANTARG  varargIn;
            VARIANTARG  varargOut;
            VariantInit(&varargIn);
            V_VT(&varargIn) = VT_UNKNOWN;
            varargIn.punkVal = (IPropertyBag2*)_pParamBag;

            //
            // if this fails, it should do no harm to us
            //
            IGNORE_HR(CTExec(Doc()->_pClientSite,
                            &CGID_JavaParambagCompatHack,
                            0,
                            MSOCMDEXECOPT_DONTPROMPTUSER,
                            &varargIn,
                            &varargOut));
        }
    }

    {
        // 
        // (olego) apphack fix for IE6 bug 25970. Set _fAppHack_MPIT_Menu flag 
        // so COleLayout can alter behaviour for this control...
        // 
        if (info.clsid == CLSID_MPIT_Menu)
        {
            _fAppHack_MPIT_Menu = TRUE;
        }
    }

    hr = THR(super::CreateObject(&info));


Cleanup:
    // If the control has been created, release the param bag.
    if (_pUnkCtrl)
        ReleaseParamBag();
        
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::RetrieveClassidAndData
//
//  Synopsis:   Helper for retrieving a CLSID from html attributes
//  
//  [kusumav - 03/2002] This function did not return a HRESULT previously and
//              we ignored all errors here. Still keeping the same behavior 
//              except for the invalid applets case since we don't want to 
//              create the element in these cases(See where hRes is being set)
//----------------------------------------------------------------------------

HRESULT
CObjectElement::RetrieveClassidAndData(
    CLSID *pclsid,
    IStream **ppStream,
    TCHAR **ppchData,
    TCHAR **ppchClassid)
{
    HRESULT     hr, hRes = S_OK;
    IBindCtx *  pBC = NULL;
    TCHAR *     pchData = (TCHAR *)GetAAdata();
    TCHAR *     pchClsid = (TCHAR *)GetAAclassid();

    //
    //  Rules for retrieval:
    //      -   If we have a data:, get the clsid from it.
    //      -   If we had a real clsid present as an attribute, use it.
    //      -   If the code attribute is present, default to the applet ocx.
    //      -   Try to infer the clsid from the codeType attribute.
    //      -   Failing that try to infer the clsid from the type attribute.
    //

    if (pchData)
    {
        if (!_tcsnipre(DATA_PREFIX, DATA_PREFIX_LEN, pchData, -1))
        {
            TCHAR   cBuf[pdlUrlLen];
            MemFreeString(*ppchData);
            hr = THR(CMarkup::ExpandUrl(NULL, pchData, ARRAY_SIZE(cBuf), cBuf, this));
            if (hr)
                goto Error;

            // Reducing Attack Surface area, we will not allow special urls in the data attrib
            if (IsSpecialUrl(cBuf))
            {
                hr = E_ACCESSDENIED;
                goto Error;
            }

            CMarkup *    pMarkup = HasMarkupPtr() ? GetMarkupPtr() : NULL;
            if (pMarkup)
            {
                if (pMarkup->ValidateSecureUrl(pMarkup->IsPendingRoot(), cBuf, FALSE, FALSE))
                {
                    MemAllocString(Mt(CObjectElementRetrieveClassidAndData_pchUrl), cBuf, ppchData);
                    if (ppchData == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                        goto Error;
                    }
                }
            }
        }
        else
        {
            HKEY hKey;
            DWORD dwData = 0, dwSize = sizeof(dwData);
            RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\ActiveX Compatibility"), 
                NULL, KEY_QUERY_VALUE, &hKey);
            RegQueryValueEx(hKey, TEXT("EnableInlineData"), NULL, NULL, (LPBYTE)&dwData, &dwSize);
            RegCloseKey(hKey);

            if (dwData)
            {
                LARGE_INTEGER   dlibMove = {0,0};

                // inline mime64-encoded data.  Parse and decode.
                hr = THR(StreamFromInlineData(pchData, ppStream));
                if (hr)
                    goto Error;

                // seek to the begining of the stream
                hr = THR((*ppStream)->Seek(dlibMove, STREAM_SEEK_SET, NULL));
                if (hr)
                    goto Error;

                //
                // read the clsid from the first 16 bytes
                //

    #ifdef BIG_ENDIAN
                Assert( 0 && "Fix big endian read of clsid" );
    #endif

                hr = THR((*ppStream)->Read(pclsid, 16, NULL));
                if (hr)
                    goto Error;

                goto Cleanup;
            }
        }
    }

    if (pchClsid && *pchClsid)
    {
        if (!OK(CLSIDFromHtmlString(pchClsid, pclsid)))
        {
            TCHAR   achBuf[pdlUrlLen];

            MemFreeString(*ppchClassid);
            hr = THR(CMarkup::ExpandUrl(NULL, pchClsid, ARRAY_SIZE(achBuf), achBuf, this));
            if (hr)
                goto Error;

            // Reducing Attack Surface area, we will not allow special urls in the data attrib
            if (IsSpecialUrl(achBuf))
            {
                hr = E_ACCESSDENIED;
                goto Error;
            }

            CMarkup *    pMarkup = HasMarkupPtr() ? GetMarkupPtr() : NULL;
            if (pMarkup)
            {
                if (pMarkup->ValidateSecureUrl(pMarkup->IsPendingRoot(), achBuf, FALSE, FALSE))
                {
                    MemAllocString(Mt(CObjectElementRetrieveClassidAndData_pchUrl), achBuf, ppchClassid);
                    if (ppchClassid == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                        goto Error;
                    }
                }
            }
        }
        // Is this an object tag with code attrib and a non applet clsid, if yes then don't create it
        if (((Tag() == ETAG_OBJECT) && (GetAAcode() && *GetAAcode())) || (Tag() == ETAG_APPLET))
        {
            if (*pclsid != CLSID_AppletOCX)
            {
                hRes = E_ACCESSDENIED;
                goto Error;
            }
        }
        goto Cleanup;
    }

    if ((Tag() == ETAG_APPLET) || GetAAcode())
    {
#ifndef WIN16
        *pclsid = CLSID_AppletOCX;
#else
                *pclsid = CLSID_CMSApplet16;
#endif
        goto Cleanup;
    }

    hr = THR(CreateAsyncBindCtxEx(NULL, 0, NULL, NULL, &pBC, 0));
    if (hr)
        goto Error;

    if (GetAAcodeType())
    {
        hr = THR_NOTRACE(GetClassFileOrMime(
                pBC,
                NULL,
                NULL,
                0,
                GetAAcodeType(),
                0,
                pclsid));
    }
    else if (GetAAtype())
    {
        hr = THR_NOTRACE(GetClassFileOrMime(
                pBC,
                NULL,
                NULL,
                0,
                GetAAtype(),
                0,
                pclsid));
    }
    else if (pchData)       // try the data URL to find a mime type
    {
        hr = THR_NOTRACE(GetClassFileOrMime(
                pBC,
                pchData,
                NULL,
                0,
                NULL,
                0,
                pclsid));

        // URLMON special cases CLSID_HTMLDocument to return the following
        // failure.  We don't want to lose the contents of *pchData in this case.
        if (hr == REGDB_E_CLASSNOTREG)
        {
            Assert(*pclsid == GUID_NULL);
            hr = S_OK;
        }
    }

    pBC->Release();

    if (hr)
        goto Error;

Cleanup:
    // Check for zone elevation.
    CMarkup *pMarkup = HasMarkupPtr() ? GetMarkupPtr() : NULL;
    if (pMarkup && pclsid && *pclsid == GUID_NULL && ppchData && *ppchData &&
        !COmWindowProxy::CanNavigateToUrlWithLocalMachineCheck(pMarkup, NULL, *ppchData))
    {
        // Note that when you get back to Cleanup from Error, *ppchData is NULL.
        // So there is no infinite loop here.
        goto Error;
    }
    RRETURN1(hRes, E_ACCESSDENIED);

Error:
    ClearInterface(ppStream);
    MemFreeString(*ppchData);
    *ppchData = NULL;
    *pclsid = GUID_NULL;
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::Save
//
//  Synopsis:   called twice: for opening <OBJECT> and for closing </OBJECT>.
//              Adds to parent's implementation saving parambag if necessary
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr = S_OK;
    TCHAR * pchData;
    BOOL    fSaveParams = FALSE;
    BOOL    fHadParamBag = !!(_pParamBag);

    if (pStreamWrBuff->TestFlag(WBF_NO_OBJECTS))
    {
        goto Cleanup;        
    }

    if (!fEnd && !pStreamWrBuff->TestFlag(WBF_SAVE_PLAINTEXT))
    {
        //
        // Saving open tag.
        //

        //
        // Many cases to consider here.
        // Case 1:  DATA attribute exists and it's not a data:
        //          Just save the attribute as is, and no saving params
        // Case 2:  DATA attribute exists and it is a data:
        //          Ask control to persist itself into stream and
        //          mime encode it.
        // Case 3:  Try IPersistPropertyBag::Save
        // Case 4:  Try IPersistStream::Save
        //

        pchData = (TCHAR *)GetAAdata();
        if (pchData)
        {
            if (_tcsnipre(DATA_PREFIX, DATA_PREFIX_LEN, pchData, -1))
            {
                // Case 2

                hr = THR(SaveToDataStream());
                // see commment 10 lines lower
                if (   hr 
                    && !Doc()->_fSaveTempfileForPrinting)
                    goto Cleanup;
            }
        }
        else
        {
            // Case 3

            if (_pParamBag)
            {
                fSaveParams = TRUE;
            }
            
            if (OK(ExchangeParamBag(FROMCONTROL)))
            {
                fSaveParams = TRUE;
            }
            else
            {
                // Case 4:

                hr = THR(SaveToDataStream());
                // if we are saving for printing we don't want to bail (104177)
                // because this will avoid saving the metafile, and nothing will
                // print.  
                if (   hr 
                    && !Doc()->_fSaveTempfileForPrinting)
                    goto Cleanup;
            }
        }
    }

    hr = THR(super::Save(pStreamWrBuff, fEnd));
    if (hr)
        goto Cleanup;

    if (!fEnd && !pStreamWrBuff->TestFlag(WBF_SAVE_PLAINTEXT))
    {
        // If we're saving for printing
        // TODO PRINT 112553: don't save anything other than snapshot 
        //                 if snapshot save is successful
        if (   Doc()->_fSaveTempfileForPrinting
            && _pUnkCtrl)
        {
            //
            // if we have a param bag then everything should save fine. However under
            // cases 1,2,4 above it is *possible* that we have no param bag at this point.
            // in this situation we simply want to create one and try to save the metafile.
            // Note, it is really important that we save the metafile. if this fails, then
            // the object will be instantiated in the print template and be UI activated, 
            // scrollable, poorly sized (due to high res measuring) and possibly have 
            // security warnings.  So pay attenting to the below Assert if you see it.
            //
            IGNORE_HR(EnsureParamBag());

            if (_pParamBag)
            {
                TCHAR   achTempFileName[MAX_PATH];
                
                if (S_OK == SaveMetaFileSnapshot(achTempFileName))
                {
                    THR(_pParamBag->AddProp(L"_Snapshot_EMF", achTempFileName));

                    fSaveParams = TRUE;
                }
                else
                {
                    // Well, we have failed to write out metafile snapshot, 
                    // but we are not going to do anything about it, except 
                    // we'll assert and investigate why that happens, just in case.
                    // The worst thing that can happen is we'll instantiate a new object 
                    // in print doc.
                    AssertSz(0, "Failed to save metafile shapshot");
                }
            }
        }

        // if open tag was just written
        hr = THR(SaveParamBindings(pStreamWrBuff));
        if (hr)
            goto Cleanup;

        if (fSaveParams && _pParamBag)
        {
            CPropertyBag *pParamBagFiltered = _pParamBag;

            if (!pStreamWrBuff->TestFlag(WBF_NO_DATABIND_ATTRS))
            {
                hr = THR(RemoveBoundParams(_pParamBag, fHadParamBag,
                                            &pParamBagFiltered));
            }
            
            hr = THR(pParamBagFiltered->Save(pStreamWrBuff));
            if (pParamBagFiltered != _pParamBag)
                pParamBagFiltered->Release();
            if (hr)
                goto Cleanup;
        }

        // save altHtml after PARAMs
        hr = THR(SaveAltHtml(pStreamWrBuff));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    // we release the param bag, if we created it now. 
    // We should not release it if we already had it when we were called.
    if ( !fHadParamBag )
        ReleaseParamBag();

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::RemoveBoundParams
//
//  Synopsis:   Helper routine, called by CObjectElement::Save.  This walks
//              through the param bag removing any params that also appear
//              in the param binding list, so that we don't persist them
//              twice.
//
//              To avoid allocations, we return the original bag
//              whenever possible - either because there were no changes
//              to make or because the caller said it was OK to change
//              the original list in place (by passing fPreserve = FALSE).
//              It's the caller's responsibility to release the new bag
//              if we did have to allocate a new one.
//
//  Arguments:  pParamBag           param bag (input)
//              fPreserve           true if we shouldn't change input bag
//              ppParamBagReturn    filtered param bag (output)
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::RemoveBoundParams(CPropertyBag *pParamBag,
                                    BOOL fPreserve,
                                    CPropertyBag **ppParamBagReturn)
{
    Assert(pParamBag && ppParamBagReturn);
    HRESULT hr = S_OK;
    int k;
    PROPNAMEVALUE *pProp;
    CPropertyBag *pParamBagNew;
    BOOL fNeedCopy = FALSE;

    // assume we can reuse the original bag
    *ppParamBagReturn = pParamBag;

    // if there are no param bindings, there's nothing to do
    if (_aryParamBinding.Size() == 0)
        goto Cleanup;

    // march through the input bag backwards, looking for duplicates
    for (k=pParamBag->_aryProps.Size()-1, pProp=&(pParamBag->_aryProps[k]);
         !fNeedCopy && k >= 0;
         --k, --pProp)
    {
        int j;
        PARAMBINDING *pParamBinding;

        for (j=_aryParamBinding.Size(), pParamBinding=&_aryParamBinding[0];
             j > 0;
             --j, ++pParamBinding)
        {
            if (!_tcsicmp(pProp->_cstrName, pParamBinding->_strParamName))
            {
                // there's a change to make.  Make it in place, if that's
                // allowed;  otherwise go do a full copy/filter.
                if (fPreserve)
                {
                    fNeedCopy = TRUE;
                }
                else
                {
                    pProp->Free();
                    pParamBag->_aryProps.Delete(k);
                }
                break;      // we've seen the dupe, no sense looking at the rest
            }
        }
    }

    // if we didn't need to allocate a new bag, we're done
    if (!fNeedCopy)
        goto Cleanup;

    // allocate a new param bag
    pParamBagNew = new CPropertyBag;
    if (pParamBagNew == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    // copy the properties that don't appear as param bindings
    for (k=pParamBag->_aryProps.Size(), pProp=&(pParamBag->_aryProps[0]);
         k > 0;
         --k, ++pProp)
    {
        int j;
        PARAMBINDING *pParamBinding;
        BOOL fCopy = TRUE;

        for (j=_aryParamBinding.Size(), pParamBinding=&_aryParamBinding[0];
             j > 0;
             --j, ++pParamBinding)
        {
            if (!_tcsicmp(pProp->_cstrName, pParamBinding->_strParamName))
            {
                fCopy = FALSE;
                break;      // we've seen the dupe, no sense looking at the rest
            }
        }

        // if the property wasn't a param binding, copy it to the new bag
        if (fCopy)
        {
            HRESULT hr1;
            PROPNAMEVALUE *pPropNew = pParamBagNew->_aryProps.Append();

            if (pPropNew == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            
            hr = pPropNew->_cstrName.Set(pProp->_cstrName);
            VariantInit(&pPropNew->_varValue);
            hr1 = VariantCopy(&pPropNew->_varValue, &pProp->_varValue);
            if (hr || hr1)
            {
                hr = hr ? hr : hr1;
                goto Cleanup;
            }
        }
    }

    // return the new param bag
    *ppParamBagReturn = pParamBagNew;

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::SaveParamBindings
//
//  Synopsis:   Helper routine, called by CObjectElement::Save, which persists
//              any bindings specified by attributes of PARAM tags.
//
//  Arguments:  pStreamWrBuff:  stream to write HTML to
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::SaveParamBindings(CStreamWriteBuff * pStreamWrBuff)
{
    HRESULT         hr = S_OK;
    int             cParamBindings = _aryParamBinding.Size();
    PARAMBINDING   *pParamBinding;
    DWORD           dwOldBuffFlags;

    if (pStreamWrBuff->TestFlag(WBF_NO_DATABIND_ATTRS))
        goto Cleanup;

    if (cParamBindings == 0)
        goto Cleanup;

    dwOldBuffFlags = pStreamWrBuff->ClearFlags(WBF_ENTITYREF);
    pStreamWrBuff->BeginIndent();

    for (pParamBinding = &_aryParamBinding[0]; cParamBindings--; pParamBinding++)
    {

        hr = pStreamWrBuff->NewLine();
        if (hr)
            break;

        hr = pStreamWrBuff->Write(
                pStreamWrBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC) && pStreamWrBuff->TestFlag(WBF_SAVE_FOR_XML)
                    ? _T("<HTML:PARAM NAME=") : _T("<PARAM NAME=")
                );
        if (hr)
            break;

        hr = pStreamWrBuff->WriteQuotedText( pParamBinding->_strParamName, TRUE );
        if( hr )
            break;

        if (pParamBinding->_strDataSrc)
        {
            hr = pStreamWrBuff->Write(_T(" DATASRC="));
            if( hr )
                break;

            hr = pStreamWrBuff->WriteQuotedText( pParamBinding->_strDataSrc, TRUE );
            if( hr )
                break;
        }

        if (pParamBinding->_strDataFld)
        {
            hr = pStreamWrBuff->Write(_T(" DATAFLD="));
            if( hr )
                break;

            hr = pStreamWrBuff->WriteQuotedText( pParamBinding->_strDataFld, TRUE );
            if( hr )
                break;
        }

        if (pParamBinding->_strDataFormatAs)
        {
            hr = pStreamWrBuff->Write(_T(" DATAFORMATAS="));
            if( hr )
                break;

            hr = pStreamWrBuff->WriteQuotedText( pParamBinding->_strDataFormatAs, TRUE );
            if( hr )
                break;
        }

        hr = pStreamWrBuff->Write(_T(">"));
        if( hr )
            break;
    }

    pStreamWrBuff->EndIndent();
    pStreamWrBuff->RestoreFlags(dwOldBuffFlags);

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::SaveAltHtml
//
//  Synopsis:   Helper routine, called by CObjectElement::Save, which saves
//              any "alternate" html originally inside the OBJECT tag
//
//  Arguments:  pStreamWrBuff:  stream to write HTML to
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::SaveAltHtml (CStreamWriteBuff *pStreamWrBuff)
{
    HRESULT         hr = S_OK;
    TCHAR         * pchAltHtml = (LPTSTR)GetAAaltHtml();
    DWORD           dwOldBuffFlags = pStreamWrBuff->ClearFlags(WBF_ENTITYREF);

    if (pchAltHtml)
    {
        hr = pStreamWrBuff->NewLine();
        if (hr)
            goto Cleanup;

        hr = pStreamWrBuff->Write(pchAltHtml);
    }

Cleanup:
    pStreamWrBuff->RestoreFlags(dwOldBuffFlags);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::Getobject
//
//  Synopsis:   implementation of pdl-abstract attribute
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::get_object(IDispatch **ppDisp)
{
    HRESULT hr = S_OK;

    if (!ppDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppDisp = NULL;

    if (!IsInMarkup())
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    CacheDispatch();
    if (!_pDisp)
        goto Cleanup;

    if (IsSafeToScript() && AccessAllowed(_pDisp))
    {
        CDoc *pDoc = NULL;
        if (SUCCEEDED(_pDisp->QueryInterface(CLSID_HTMLDocument, (void **)&pDoc)))
        {
            CDocument *pDocument = pDoc->_pWindowPrimary->Document();
            if (pDocument)
            {
                hr = pDocument->QueryInterface(IID_IDispatch, (void **)ppDisp);
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
        else
        {
            *ppDisp = _pDisp;
            _pDisp->AddRef();
        }
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::namedRecordset
//
//  Synopsis:   returns an ADO Recordset for the named data member.  Tunnels
//              into the hierarchy using the path, if given.
//
//  Arguments:  bstrDataMember  name of data member (NULL for default)
//              pvarHierarchy   BSTR path through hierarchy (optional)
//              pRecordSet      where to return the recordset.
//
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::namedRecordset(BSTR bstrDatamember,
                               VARIANT *pvarHierarchy,
                               IDispatch **pRecordSet)
{
    HRESULT hr;
    CDataMemberMgr *pdmm;

#ifndef NO_DATABINDING
    EnsureDataMemberManager();
    pdmm = GetDataMemberManager();
    if (pdmm)
    {
        hr = pdmm->namedRecordset(bstrDatamember, pvarHierarchy, pRecordSet);
        if (hr == S_FALSE)
            hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }
    
#else
    *pRecordSet = NULL;
    hr = S_OK;
#endif NO_DATABINDING

    RRETURN (SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::getRecordSet
//
//  Synopsis:   returns an ADO Recordset pointer if this site is a data
//              source control
//
//  Arguments:  IDispatch **    pointer to a pointer to a record set.
//
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::get_recordset(IDispatch **pRecordSet)
{
    HRESULT hr = S_OK;
    *pRecordSet = NULL;                 // Make sure to null on failure.
    CDataMemberMgr *pdmm;
    
#ifndef NO_DATABINDING
    EnsureDataMemberManager();
    pdmm = GetDataMemberManager();
    if (pdmm)
    {
        // normal case, return ADO recordset based on my provider
        hr = pdmm->namedRecordset(NULL, NULL, pRecordSet);
    }
    else
    {
        hr = S_FALSE;
    }
    
    // backward compatability with IE3 and ADC1.1.  If my control isn't a provider
    // (in the Trident sense), it may expose its own recordset property. Delegate.
    if (hr == S_FALSE)
    {
        DISPID dispid;
        VARIANT varRecordset;
        static OLECHAR * oszRecordset = _T("Recordset");

        hr = S_OK;
        if (!_pUnkCtrl)                 // Make sure site really has an object
            goto Cleanup;

        CacheDispatch();

        if ( !_pDisp )
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        // get dispid of control's recordset property
        hr = _pDisp->GetIDsOfNames(IID_NULL, &oszRecordset, 1,
                                    g_lcidUserDefault, &dispid);
        if (hr)
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        // get recordset property
        VariantInit(&varRecordset);
        hr = GetDispProp(_pDisp, dispid, g_lcidUserDefault, &varRecordset);
        if (hr)
            goto Cleanup;

        // return it to caller
        if (varRecordset.vt == VT_DISPATCH || varRecordset.vt == VT_UNKNOWN)
            *pRecordSet = varRecordset.pdispVal;
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
            VariantClear(&varRecordset);
            goto Cleanup;
        }
    }

Cleanup:
#endif // ndef NO_DATABINDING
    RRETURN (SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::setRecordSet
//
//  Synopsis:   returns an ADO Recordset pointer if this site is a data
//              source control
//
//  Arguments:  IDispatch **    pointer to a pointer to a record set.
//
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::put_recordset(IDispatch *pRecordSet)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND; // Trident does not support put_recordset

#ifndef NO_DATABINDING
    // backward compatability with IE3 and ADC1.1.  If my control isn't a provider
    // (in the Trident sense), it may expose its own recordset property. Delegate.
    if (!IsDataProvider())
    {
        DISPID dispid;
        VARIANT varRecordset;
        static OLECHAR * oszRecordset = _T("Recordset");

        CacheDispatch();

        if ( !_pDisp )
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        // get dispid of control's recordset property
        hr = _pDisp->GetIDsOfNames(IID_NULL, &oszRecordset, 1,
                                    g_lcidUserDefault, &dispid);
        if (hr)
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        // set recordset property
        VariantInit(&varRecordset);
        varRecordset.vt = VT_DISPATCH;
        varRecordset.pdispVal = pRecordSet;
        hr = SetDispProp(_pDisp, dispid, g_lcidUserDefault, &varRecordset);
    }

Cleanup:
#endif // ndef NO_DATABINDING
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::get_BaseHref
//
//  Synopsis:   Returns the base href for this object tag.
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::get_BaseHref(BSTR *pbstr)
{
        RRETURN( SetErrorInfo(GetBaseHref( pbstr )) );
}

#ifndef NO_DATABINDING
class CDBindMethodsObject : public CDBindMethods
{
    typedef CDBindMethods super;

public:
    CDBindMethodsObject()   {}
    ~CDBindMethodsObject()  {}

    virtual HRESULT BoundValueToElement(CElement *pElem, LONG id,
                                        BOOL fHTML, LPVOID pvData) const;

    virtual HRESULT BoundValueFromElement(CElement *pElem, LONG id,
                                         BOOL fHTML, LPVOID pvData) const;


protected:
    virtual DBIND_KIND DBindKindImpl(CElement *pElem,
                                     LONG id,
                                     DBINFO *pdbi) const;

    virtual BOOL    FDataSrcValidImpl(CElement *pElem) const { return TRUE; }
    virtual BOOL    FDataFldValidImpl(CElement *pElem) const { return TRUE; }
    virtual BOOL    IsReadyImpl(CElement *pElem) const;

    virtual HRESULT GetNextDBSpecCustom(CElement *pElem,
                                        LONG *pid,
                                        DBSPEC *pdbs) const;

};

static const CDBindMethodsObject DBindMethodsObject;

const CDBindMethods *
CObjectElement::GetDBindMethods()
{

    return &DBindMethodsObject;
}


//+----------------------------------------------------------------------------
//
//  Function: DBindKindImpl, CDBindMethods
//
//  Synopsis: Indicate whether or not <element, id> can be databound, and
//            optionally return additional info about binding -- an ID used
//            for transfer, and the desired data type to be used for transfer.
//
//  Arguments:
//            [id]    - binding being asked about; 0 mean defaulbind attribute,
//                      other refers to a param binding
//            [pdbi]  - pointer to struct to get data type and ID;
//                      may be NULL
//
//  Returns:  Binding status: one of
//              DBIND_NONE
//              DBIND_SINGLEVALUE
//              DBIND_ICURSOR
//              DBIND_IROWSET
//              DBIND_DLCURSOR
//
//-----------------------------------------------------------------------------

DBIND_KIND
CDBindMethodsObject::DBindKindImpl(CElement *pElem,
                                   LONG id,
                                   DBINFO *pdbi) const
{
    DBIND_KIND dbk = DBIND_NONE;

    CObjectElement *pObj = DYNCAST(CObjectElement, pElem);
    BOOL fReady = (pObj->_lReadyState >= READYSTATE_LOADED);
    CLASSINFO *pci;     // don't call GetClassInfo unless we have to

    // We use a private dbi, distinct from *pdbi.  Note that pdbi may be NULL;
    // if non-NULL, it has already been initialized.  
    DBINFO dbi;

    dbi._vt = VT_EMPTY;
    // If an Object/Applet can be bound, it will be bound READ/WRITE.
    dbi._dwTransfer = 0;    // no HTML, R/W; different than default *pdbi

    Assert(pObj->Tag() == ETAG_OBJECT
            || pObj->Tag() == ETAG_APPLET
            || pObj->Tag() == ETAG_EMBED );

    // avoid asking for CLASSINFO unless we really have a need --

    if (id != ID_DBIND_DEFAULT)
    {
        CObjectElement::PARAMBINDING *pParamBinding;

        Assert(id - (ID_DBIND_DEFAULT + 1) >= 0);
        Assert(id  - (ID_DBIND_DEFAULT + 1) < pObj->_aryParamBinding.Size());

        pParamBinding = &pObj->_aryParamBinding[id - (ID_DBIND_DEFAULT + 1)];
        pObj->EnsureParamType(pParamBinding);
        if (pParamBinding->_vt == VT_EMPTY)
            goto Cleanup;

        if (!FormsIsEmptyString(pParamBinding->_strDataFld))
        {
            dbk = DBIND_SINGLEVALUE;
            dbi._vt = CVarType(pParamBinding->_vt, pParamBinding->_vt != VT_VARIANT);
        }
        else if (pParamBinding->_vt == VT_UNKNOWN || pParamBinding->_vt == VT_DISPATCH)
        {
            dbk = DBIND_IDATASOURCE;
        }

        goto Cleanup;
    }

    pci = pObj->GetClassInfo();

    //Assert(pObj->GetAAdataFld() || pObj->GetAAdataSrc());

    if (!pObj->GetAAdataFld())  // set-binding requested
    {
// TODO: check that it's not a read-only property
        if (pci->dispIDBind == pci->dispidIDataSource &&
            pci->dispidIDataSource != DISPID_UNKNOWN)
        {
            dbk = DBIND_IDATASOURCE;
        }
        else if (pci->dispidCursor != DISPID_UNKNOWN)
        {
            dbk = DBIND_ICURSOR;
        }
        goto Cleanup;
    }

    if (pci->dispIDBind != DISPID_UNKNOWN)
    {
        VARTYPE vtBind = pci->vtBindType & VT_TYPEMASK;
        dbk = DBIND_SINGLEVALUE;
        dbi._vt = CVarType(vtBind, vtBind != VT_VARIANT && !pObj->IsVTableValid());
    }

Cleanup:
    // Don't bind to objects that aren't safe for scripting
    if (dbk != DBIND_NONE && fReady && !pObj->IsSafeToScript())
    {
        dbk = DBIND_NONE;
    }

    if (pdbi && dbk != DBIND_NONE)
    {
        *pdbi = dbi;
    }
    return dbk;
}


//+----------------------------------------------------------------------------
//
//  Function: IsReadyImpl, CDBindMethods
//
//  Synopsis: Indicate whether the element is ready to be bound.
//
//  Arguments:  pElem       pointer to object element being queried
//
//-----------------------------------------------------------------------------

BOOL
CDBindMethodsObject::IsReadyImpl(CElement *pElem) const
{
    CObjectElement *pObj = DYNCAST(CObjectElement, pElem);

    return (pObj->_lReadyState >= READYSTATE_LOADED);
}

//+----------------------------------------------------------------------------
//
//  Function: GetNextDBSpecCustom, CDBindMethods
//
//  Synopsis: Inspect whatever attributes and styles necessary to determine
//            what bindings are specified in addition to the one on the
//            element's tag itself.
//  Arguments:
//            [pElem] - element being asked bout
//            [pid]   - pointer to ID before the first to be considered
//            [pdbs]  - pointer to struct to get spec; can't be NULL
//
//  Returns:  S_OK:     We have a spec, *pid and *pdbs filled in
//            S_FALSE:  No more specs
//
//  Notes:    ID_DBIND_DEFAULT refers to the elements itself.  Successive
//            values refer to param bindings.
//
//-----------------------------------------------------------------------------

HRESULT
CDBindMethodsObject::GetNextDBSpecCustom(CElement *pElem,
                                         LONG *pid,
                                         DBSPEC *pdbs) const
{
    HRESULT hr = S_FALSE;
    CObjectElement *pObj = DYNCAST(CObjectElement, pElem);
    LONG size = pObj->_aryParamBinding.Size();
    LONG id = *pid;

    CObjectElement::PARAMBINDING *pParamBinding;
    LONG iParamBinding;

    id ++;  // the next id we will try
    iParamBinding = id - (ID_DBIND_DEFAULT + 1);

    if (iParamBinding < 0 || iParamBinding >= size)
    {
        goto Cleanup;
    }

    pParamBinding = &pObj->_aryParamBinding[iParamBinding];
    pdbs->_pStrDataSrc = pParamBinding->_strDataSrc;
    pdbs->_pStrDataFld = pParamBinding->_strDataFld;
    pdbs->_pStrDataFormatAs = pParamBinding->_strDataFormatAs;

    *pid = id;
    hr = S_OK;

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+----------------------------------------------------------------------------
//
//  Function: GetIDForParamBinding, CObjectElement
//
//  Synopsis: For a given PARAMBINDING specification, make sure that we have
//            a dispid to be used to either put or get a property value.
//            Helper for BoundValueToElement and BoundValueFromElement.
//
//  Arguments:
//            [pParamBinding]  - PARAMBINDING structure with property name,
//                               and may or may not have filled in DISPIDs
//                               for getting and putting property values.
//            [fPut]           - Does caller want to a put a value (as opposed
//                               to fetching one?)
//
//  Returns:  S_OK             - Desired DISPID has been set filled in with
//                               somethint other than DISPID_UNKNOWN in the
//                               PARAMBINDING.
//            E_*              - some erorr
//
//-----------------------------------------------------------------------------

HRESULT
CObjectElement::GetIDForParamBinding(PARAMBINDING *pParamBinding, BOOL fPut)
{
    HRESULT hr = S_OK;
    DISPID *pdispid = fPut ? &pParamBinding->_dispidPut
                           : &pParamBinding->_dispidGet;
    DISPID dispid;
    LPTSTR strName;

    if (*pdispid != DISPID_UNKNOWN)
    {
        goto Cleanup;
    }

    strName = pParamBinding->_strParamName;

    CacheDispatch();
    if (!_pDisp)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(_pDisp->GetIDsOfNames(IID_NULL,
                                   &strName,
                                   1,
                                   g_lcidUserDefault,
                                   &dispid ) );
    if (!hr)
    {
        pParamBinding->_dispidPut = pParamBinding->_dispidGet = dispid;
    }
    else
    {
        static const TCHAR PUT_PREFIX[] = _T("set");
        static const TCHAR GET_PREFIX[] = _T("get");
        LPCTSTR strPrefix = fPut ? PUT_PREFIX : GET_PREFIX;
        LPTSTR strTemp =  new(Mt(CObjectElementGetIDForParamBinding_strTemp)) TCHAR[_tcslen(strPrefix) + _tcslen(strName) + 1];

        if (strTemp == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _tcscpy(strTemp, strPrefix);
        _tcscat(strTemp, strName);

        hr = THR(_pDisp->GetIDsOfNames(IID_NULL,
                                       &strTemp,
                                       1,
                                       g_lcidUserDefault,
                                       &dispid ) );
        delete [] strTemp;
        if (!hr)
        {
            *pdispid = dispid;
            pParamBinding->_dwInvokeFlags = DISPATCH_METHOD;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function: BoundValueToElement, CDBindMethods
//
//  Synopsis: Transfer data into bound OBJECT.  Only called if DBindKind
//            previous returned TRUE.
//
//  Arguments:
//            [id]      - ID of binding point.  id 0 is the object's
//                        defaultbind property.  Other IDs are PARAM bindings.
//            [pvData]  - pointer to data to transfer, datatype specified
//                        by object's typeinfo
//
//-----------------------------------------------------------------------------

HRESULT
CDBindMethodsObject::BoundValueToElement(CElement *pElem,
                                         LONG id,
                                         BOOL,
                                         LPVOID pvData) const
{
    HRESULT                     hr = S_OK;
    DISPID                      dispid;
    DWORD                       dwInvokeFlags = DISPATCH_PROPERTYPUT;
    CObjectElement             *pObj = DYNCAST(CObjectElement, pElem);
    EXCEPINFO                   except;

    // if the object isn't ready yet, don't do anything and return S_OK.
    // This happens, for example, for applets in a repeated table.
    if (pObj->_lReadyState < READYSTATE_COMPLETE)
        goto Cleanup;

    pObj->CacheDispatch();
    if (!pObj->_pDisp)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (id == ID_DBIND_DEFAULT)
    {
        CLASSINFO      *pci = pObj->GetClassInfo();

        if (pObj->IsVTableValid())
        {
            hr = pObj->VTableDispatch(pObj->_pDisp,
                            pci->vtBindType,
                            COleSite::VTBL_PROPSET,
                            pvData,
                            pci->uPutBindIndex);
            goto Cleanup;
        }

        dispid = pci->dispIDBind;
        dwInvokeFlags = pci->dwFlagsBind;
    }
    else
    {
        CObjectElement::PARAMBINDING *pParamBinding;

        pParamBinding = &pObj->_aryParamBinding[id - (ID_DBIND_DEFAULT + 1)];
        hr = pObj->GetIDForParamBinding(pParamBinding, TRUE);
        if (hr)
            goto Cleanup;
        dispid = pParamBinding->_dispidPut;
        dwInvokeFlags = pParamBinding->_dwInvokeFlags;
    }

    InitEXCEPINFO(&except);
    hr = THR(SetDispProp(pObj->_pDisp,
                         dispid,
                         g_lcidUserDefault,
                         (VARIANT *) pvData,
                         &except,
                         dwInvokeFlags));
    FreeEXCEPINFO(&except);

Cleanup:
    return(hr);
}

//+----------------------------------------------------------------------------
//
//  Function: BoundValueFromElement, CDBindMethods
//
//  Synopsis: Transfer data from bound OBJECT.  Only called if DBindKind
//            previous returned TRUE.
//
//  Arguments:
//            [id]      - ID of binding point.  id 0 is the object's
//                        defaultbind property.  Other IDs are PARAM bindings.
//            [pvData]  - pointer to buffer for transfer, datatype specified
//                        by object's typeinfo
//
//-----------------------------------------------------------------------------

HRESULT
CDBindMethodsObject::BoundValueFromElement(CElement *pElem,
                                           LONG id,
                                           BOOL,
                                           LPVOID pvData) const
{
    HRESULT                     hr;
    DISPID                      dispid;
    DWORD                       dwInvokeFlags = DISPATCH_PROPERTYGET;
    CObjectElement             *pObj = DYNCAST(CObjectElement, pElem);
    EXCEPINFO                   except;

    pObj->CacheDispatch();
    if (!pObj->_pDisp)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (id == ID_DBIND_DEFAULT)
    {
        CLASSINFO      *pci = pObj->GetClassInfo();

        if (pObj->IsVTableValid())
        {
            hr = pObj->VTableDispatch(pObj->_pDisp,
                            pci->vtBindType,
                            COleSite::VTBL_PROPGET,
                            pvData,
                            pci->uGetBindIndex);
            goto Cleanup;
        }

        dispid = pci->dispIDBind;
        dwInvokeFlags = pci->dwFlagsBind;
    }
    else
    {
        CObjectElement::PARAMBINDING *pParamBinding;

        pParamBinding = &pObj->_aryParamBinding[id - (ID_DBIND_DEFAULT + 1)];
        hr = pObj->GetIDForParamBinding(pParamBinding, TRUE);
        if (hr)
            goto Cleanup;
        dispid = pParamBinding->_dispidGet;
        dwInvokeFlags = pParamBinding->_dwInvokeFlags;
    }

    InitEXCEPINFO(&except);
    hr = THR(GetDispProp(pObj->_pDisp,
                         dispid,
                         g_lcidUserDefault,
                         (VARIANT *) pvData,
                         &except,
                         dwInvokeFlags));
    FreeEXCEPINFO(&except);
    if (hr)
        goto Cleanup;

Cleanup:
    return(hr);
}


//+----------------------------------------------------------------------------
//
//  Function: EnsureParamType (private helper)
//
//  Synopsis: Determine the preferred type of a param binding
//
//  Arguments:
//            pParamBinding     binding whose type we want
//
//-----------------------------------------------------------------------------

void
CObjectElement::EnsureParamType(PARAMBINDING *pParamBinding)
{
    HRESULT     hr;
    DISPID      dispid;
    EXCEPINFO   except;
    VARIANT     var;
    CLASSINFO   *pci;

    if (pParamBinding->_vt != VT_EMPTY)     // we've already found the type
        goto Cleanup;

    if (_lReadyState < READYSTATE_LOADED)   // we're not ready to answer
        goto Cleanup;

    CacheDispatch();                        // need _pDisp to do anything
    if (!_pDisp)
        goto Cleanup;

    // get the dispid for the property
    hr = GetIDForParamBinding(pParamBinding, FALSE);
    if (hr)
        goto Cleanup;
    dispid = pParamBinding->_dispidGet;

    // Read the property from the control
    VariantInit(&var);
    InitEXCEPINFO(&except);
    hr = THR(GetDispProp(_pDisp,
                         dispid,
                         g_lcidUserDefault,
                         &var,
                         &except,
                         pParamBinding->_dwInvokeFlags));
    FreeEXCEPINFO(&except);
    if (hr)
        goto Cleanup;

    // remember its type
    switch (var.vt)
    {
    case VT_EMPTY:
    case VT_NULL:
        pParamBinding->_vt = VT_VARIANT;
        break;
    case VT_UNKNOWN:
    case VT_DISPATCH:
        // in this case, we need to get the typeinfo to see if the DataSource
        // property is put or putref
        pParamBinding->_vt = var.vt;
        pci = GetClassInfo();
        if (dispid == pci->dispidIDataSource)
        {
            pParamBinding->_dwInvokeFlags = pci->dwFlagsDataSource;
        }
        else if (dispid == pci->dispidRowset)
        {
            pParamBinding->_dwInvokeFlags = pci->dwFlagsRowset;
        }
        break;
    default:
        pParamBinding->_vt = var.vt;
        break;
    }
    VariantClear(&var);

Cleanup:
    return;
}

//+-------------------------------------------------------------------------
//
//  Method:     CObjectElement::DeferredSaveData
//
//  Synopsis:   If the Site was considered dirty, then save the data in a bound
//              element to what is it bound to (often, a database).
//              It is no longer dirty after flush.  Works on the default
//              binding only, not parameter bindings.
//
//  Arguments:  DWORD trickily encodes the bound id.  Because GWKillMethodCall
//              treats dw == 0 as a request to kill all calls no matter what
//              dw, we have to make sure that dw == 0 represents ID_DBIND_ALL.
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------

void
CObjectElement::DeferredSaveData(DWORD_PTR dw)
{
    // note use of super:: -- we don't need to call GWKillMethodCall, which
    //  CObjectElement::SaveDataIfChanged would do.

    // ID_DBIND_ALL adjusment is so that dw == 0 maps to id == ID_DBIND_ALL
    IGNORE_HR(super::SaveDataIfChanged((DWORD)dw + ID_DBIND_ALL, /* fLoud */ FALSE));
}


//+-------------------------------------------------------------------------
//
//  Method:     CObjectElement::SaveDataIfChanged, CSite
//
//  Synopsis:   Determine whether or not is appropate to save the value
//              in  a control to a datasource, and do so.  Fire any appropriate
//              events.
//
//  Returns:    S_OK: no work to do, or transfer successful
//
//--------------------------------------------------------------------------
HRESULT
CObjectElement::SaveDataIfChanged(LONG id, BOOL fLoud, BOOL fForceIsCurrent)
{
    // We kill any pending defered calls to ourselves, just in case we got here
    // other than from a defered call.
    // ID_DBIND_ALL adjustment is so that dw == 0 maps to id == ID_DBIND_ALL
    GWKillMethodCall(this, ONCALL_METHOD(CObjectElement, DeferredSaveData, deferredsavedata), (DWORD_PTR)(id - ID_DBIND_ALL));

    RRETURN1(super::SaveDataIfChanged(id, fLoud, fForceIsCurrent), S_FALSE);
}
#endif // ndef NO_DATABINDING

//+-------------------------------------------------------------------------
//
//  Method:     CObjectElement::OnControlRequestEdit, COleSite
//
//  Synopsis:   Give Site (or its derived class) a chance to act on a
//              control's OnRequestEdit notification,  and cancel any forwarding
//              which might normally take place through our XObject.
//
//  Arguments:  dispid of property who's value has changed
//
//  Returns:    HRESULT.  Any non-zero HRESULT, including S_FALSE, will
//              cancel OnRequestEdit forwarding.
//
//--------------------------------------------------------------------------

HRESULT
CObjectElement::OnControlRequestEdit(DISPID dispid)
{
    HRESULT             hr;
    DBMEMBERS          *pdbm;
    CLASSINFO          *pci;
    PARAMBINDING       *pParamBinding;
    int                 cParamBindings;

    hr = super::OnControlRequestEdit(dispid);
    if (hr)
    {
        goto Cleanup;
    }

    if (dispid == DISPID_UNKNOWN)
    {
        goto Cleanup;
    }

    if (_state < OS_LOADED)
    {
        // don't know if this check is necessary here, but it was necessary in
        // OnControlChanged.
        goto Cleanup;
    }

#ifndef NO_DATABINDING
    pdbm = GetDBMembers();
    if (!pdbm)
    {
        goto Cleanup;
    }

    cParamBindings = _aryParamBinding.Size();
    pParamBinding = &_aryParamBinding[cParamBindings];

    while (pParamBinding--, cParamBindings--)
    {
        if (pParamBinding->_dispidGet == dispid)
        {
            if (FAILED(pdbm->CheckSrcWritable(this,
                                 cParamBindings + (ID_DBIND_DEFAULT+1) ) ) )
            {
                hr = S_FALSE;
                goto Cleanup;
            }
        }
    }

    // we've considered the PARAM bindings; now consider the default
    //  binding.

    // Avoid accessing the ClassInfo unless we know that ID_DBIND_DEFAULT
    //  is bound.
    if (!pdbm->FBoundID(this, ID_DBIND_DEFAULT))
    {
        goto Cleanup;
    }

    // Now that we're sure we need it, get the ClassInfo
    pci = GetClassInfo();
    if (dispid != pci->dispIDBind)
    {
        goto Cleanup;
    }

    if (FAILED(pdbm->CheckSrcWritable(this, ID_DBIND_DEFAULT)))
    {
        hr = S_FALSE;
    }
#endif // ndef NO_DATABINDING

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CObjectElement::OnControlChanged, COleSite
//
//  Synopsis:   Give Site (or its derived class) a chance to act on a
//              control's OnChanged notification,  and cancel any forwarding
//              which might normally take place through our XObject.
//
//  Arguments:  dispid of property who's value has changed
//
//  Returns:    HRESULT.  Any non-zero HRESULT, including S_FALSE, will
//              cancel OnChanged forwarding.
//
//              We don't have code here to restore the dispid back to
//              the bound value, if the bound source isn't writable.
//              Probably should have a DeferedRestoreData.
//
//--------------------------------------------------------------------------

HRESULT
CObjectElement::OnControlChanged(DISPID dispid)
{
    HRESULT             hr          = S_OK;
    DBMEMBERS           *pdbm;
    CLASSINFO           *pci;
    CDoc *              pDoc = Doc();
    CDataMemberMgr *    pdmm = GetDataMemberManager();

    // handle changes in readystate
    Verify(!super::OnControlChanged(dispid));

    if (_state < OS_LOADED)
    {
        // (alexz) (anandra)
        // this is done specifically for Marquee control of IE 3.0,
        // which has DISPID_ScrollStyleX == DISPID_VALUE == 0 (which is a bug).
        // When loading from param bag, it fires OnPropertyChange (DISPID_ScrollStyleX),
        // which leads our code here as we think that was an OnValuePropertyChange; then it
        // causes save, which crashes that control because it's code happened to be
        // not robust for the case when somebody operates with it's properties while it is in
        // process of loading.
        goto Cleanup;
    }

#ifndef NO_DATABINDING
    // if the databinding interface changed, let the provider know
    if (pdmm)
    {
        if (dispid == pdmm->GetDatabindingDispid() || dispid == DISPID_UNKNOWN)
        {
            IGNORE_HR(pdmm->ChangeDataBindingInterface(NULL, TRUE));
        }
    }

    pdbm = GetDBMembers();
    if (!pdbm)
    {
        goto Cleanup;
    }

    if (this != pDoc->_pElemCurrent)
    {
        int           cParamBindings = _aryParamBinding.Size();
        PARAMBINDING *pParamBinding  = &_aryParamBinding[cParamBindings];

        while (pParamBinding--, cParamBindings--)
        {
            if ((dispid == DISPID_UNKNOWN || pParamBinding->_dispidGet == dispid)
                && pdbm->CompareWithSrc(this, cParamBindings + (ID_DBIND_DEFAULT+1)) )
            {
                // note two adjustments here
                //  ID_DBIND_DEFAULT+1 adjust array offset to binding id.
                //  -ID_DBIND_ALL adjusts binding id to required DWORD value
                //      (see DeferSaveData for details)
                GWPostMethodCall(this,
                                 ONCALL_METHOD(CObjectElement, DeferredSaveData, deferredsavedata),
                                 (DWORD_PTR) cParamBindings + (ID_DBIND_DEFAULT+1) - ID_DBIND_ALL,
                                 FALSE, "CObjectElement::DeferredSaveData");
            }
        }
    }

    // we only have to consider ClassInfo information if we have a binding
    //  on the tag itself
    if (!pdbm->FBoundID(this, ID_DBIND_DEFAULT))
    {
        goto Cleanup;
    }

    // Now that we're sure we need it, get the ClassInfo
    pci = GetClassInfo();

    if (dispid != DISPID_UNKNOWN && dispid != pci->dispIDBind)
    {
        goto Cleanup;
    }

    // for current control, we only transfer value now if IMMEDIATEBIND.
    if (this == pDoc->_pElemCurrent && !pci->FImmediateBind())
    {
        goto Cleanup;
    }


    // fetch that value
    if (!pdbm->CompareWithSrc(this, ID_DBIND_DEFAULT))
    {
        goto Cleanup;
    }

    // See DeferredSaveData for explanation of  "- ID_DBIND_ALL"
    GWPostMethodCall(this,
                     ONCALL_METHOD(CObjectElement, DeferredSaveData, deferredsavedata),
                     (DWORD_PTR) (ID_DBIND_DEFAULT - ID_DBIND_ALL), FALSE, "CObjectElement::DeferredSaveData");

#endif // ndef NO_DATABINDING
Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  Member:     OnFailToCreate
//
//  Synopsis:   Called when an OBJECT fails to instantiate correctly
//
//-------------------------------------------------------------------------

HRESULT
CObjectElement::OnFailToCreate()
{
    super::OnFailToCreate();

    if ( !IsEditable(/*fCheckContainerOnly*/FALSE) && !Doc()->IsShut() )
    {
        //
        // fire the onerror event to see if anyone wants to handle this case for us.
        // unless we get back FALSE, do the default processing which is to 
        // replace element with the altHTML.  
        //

        BOOL fRet = Fire_onerror();
        if (fRet)
        {
            TCHAR * pchAltHtml = (LPTSTR)GetAAaltHtml();
            if (pchAltHtml)
            {
                IGNORE_HR(Inject(
                        CElement::Outside, TRUE, pchAltHtml, _tcslen(pchAltHtml)));
            }
        }
    }

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     GetSumbitInfo
//
//  Synopsis:   Retrieve info for form sumbission and give it to the
//              CPostData.
//
//-------------------------------------------------------------------------

HRESULT
CObjectElement::GetSubmitInfo(CPostData *pSubmitData)
{
    HRESULT            hr = S_FALSE;
    const CCharFormat *pCF;
    CVariant           vt;
    LPCTSTR            lpstrName;


    // Make sure we've actually got a control.
    if(!_pDisp)
        goto Cleanup;

    // If it doesn't have a name, then it doesn't go in the string!
    lpstrName = GetAAname();
    if(!lpstrName)
        goto Cleanup;

    // Get the CharFormat for the LCID.
    pCF = GetFirstBranch()->GetCharFormat();
    if(!pCF)
        goto Cleanup;

    // Finally, get the default value.
    hr = THR(GetDispProp(_pDisp, DISPID_VALUE, pCF->_lcid, &vt));
    if(hr)
        goto Cleanup;

    hr = THR(vt.CoerceVariantArg(VT_BSTR));
    if(hr)
        goto Cleanup;

    hr = THR(pSubmitData->AppendNameValuePair(lpstrName, V_BSTR(&vt), GetMarkup()));

Cleanup:
    // If we got any kind of error, return S_FALSE
    // so that we're just skipped in the submit info.
    if(hr)
    {
        hr = S_FALSE;
    }
    RRETURN1(hr, S_FALSE);
}

STDMETHODIMP
CObjectElement::get_readyState(VARIANT *pVarResult)
{
    HRESULT     hr;

    if (!pVarResult)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = get_readyState(&V_I4(pVarResult));
    if (!hr)
        V_VT(pVarResult) = VT_I4;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

STDMETHODIMP
CObjectElement::get_readyState(long *pReadyState)
{
    HRESULT     hr = S_OK;

    if (!pReadyState)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pReadyState = _lReadyState;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

STDMETHODIMP CObjectElement::put_classid(BSTR v)
{
    HRESULT hr = CTL_E_SETNOTSUPPORTEDATRUNTIME;
    CVoid *pSubObj;
    if (_pUnkCtrl || GetAAclassid() || GetAAcodeType() || GetAAtype())
        goto Cleanup;

    RECALC_PUT_HELPER(s_propdescCObjectElementclassid.b.dispid)
    pSubObj = CVOID_CAST(GetAttrArray());
    hr = THR(s_propdescCObjectElementclassid.b.SetStringProperty(v, this, pSubObj));
    if (hr)
        goto Cleanup;

    hr = THR(CreateObject());

Cleanup:
    return SetErrorInfo(hr);
}

STDMETHODIMP CObjectElement::get_classid(BSTR *p)
{
    RECALC_GET_HELPER(s_propdescCObjectElementclassid.b.dispid)
    CVoid *pSubObj = CVOID_CAST(GetAttrArray());
    return SetErrorInfo(s_propdescCObjectElementclassid.b.GetStringProperty(p, this, pSubObj));
}

STDMETHODIMP CObjectElement::put_codeType(BSTR v)
{
    HRESULT hr = CTL_E_SETNOTSUPPORTEDATRUNTIME;
    CVoid *pSubObj;
    if (_pUnkCtrl || GetAAcodeType() || GetAAclassid() || GetAAtype())
        goto Cleanup;

    RECALC_PUT_HELPER(s_propdescCObjectElementcodeType.b.dispid)
    pSubObj = CVOID_CAST(GetAttrArray());
    hr = THR(s_propdescCObjectElementcodeType.b.SetStringProperty(v, this, pSubObj));
    if (hr)
        goto Cleanup;

    hr = THR(CreateObject());

Cleanup:
    return SetErrorInfo(hr);
}

STDMETHODIMP CObjectElement::get_codeType(BSTR *p)
{
    RECALC_GET_HELPER(s_propdescCObjectElementcodeType.b.dispid)
    CVoid *pSubObj = CVOID_CAST(GetAttrArray());
    return SetErrorInfo(s_propdescCObjectElementcodeType.b.GetStringProperty(p, this, pSubObj));
}

STDMETHODIMP CObjectElement::put_type(BSTR v)
{
    HRESULT hr = CTL_E_SETNOTSUPPORTEDATRUNTIME;
    CVoid *pSubObj;
    if (_pUnkCtrl || GetAAtype() || GetAAclassid() || GetAAcodeType())
        goto Cleanup;

    RECALC_PUT_HELPER(s_propdescCObjectElementtype.b.dispid)
    pSubObj = CVOID_CAST(GetAttrArray());
    hr = THR(s_propdescCObjectElementtype.b.SetStringProperty(v, this, pSubObj));
    if (hr)
        goto Cleanup;

    hr = THR(CreateObject());

Cleanup:
    return SetErrorInfo(hr);
}

STDMETHODIMP CObjectElement::get_type(BSTR *p)
{
    RECALC_GET_HELPER(s_propdescCObjectElementtype.b.dispid)
    CVoid *pSubObj = CVOID_CAST(GetAttrArray());
    return SetErrorInfo(s_propdescCObjectElementtype.b.GetStringProperty(p, this, pSubObj));
}

STDMETHODIMP CParamElement::get_name(BSTR *p)
{
    CVoid *pSubObj = CVOID_CAST(GetAttrArray());
    return SetErrorInfo(s_propdescCParamElementname.b.GetStringProperty(p, this, pSubObj));
}

STDMETHODIMP CParamElement::put_name(BSTR v)
{
    HRESULT hr = S_OK;
    CVoid *pSubObj = CVOID_CAST(GetAttrArray());

    if (_pelObjParent && _pelObjParent->_pParamBag)
    {
        if (v && *v)
        {
            LPCTSTR pchName;
            PROPNAMEVALUE *pprop = _pelObjParent->_pParamBag->Find(v);
            if (pprop)
                goto Cleanup;

            // Didn't find name, so change it in propbag too
            pchName = GetAAname();
            Assert(pchName && *pchName);
            pprop = _pelObjParent->_pParamBag->Find((LPTSTR)pchName);
            Assert(pprop);
            hr = THR(pprop->_cstrName.Set(v));
            if (hr)
                goto Cleanup;
        }
        else
            goto Cleanup;
    }

    hr = THR(s_propdescCParamElementname.b.SetStringProperty(v, this, pSubObj));
    if (hr)
        goto Cleanup;

Cleanup:
    return SetErrorInfo(hr);
}

STDMETHODIMP CParamElement::get_value(BSTR *p)
{
    CVoid *pSubObj = CVOID_CAST(GetAttrArray());
    return SetErrorInfo(s_propdescCParamElementvalue.b.GetStringProperty(p, this, pSubObj));
}

STDMETHODIMP CParamElement::put_value(BSTR v)
{
    HRESULT hr;
    CVoid *pSubObj = CVOID_CAST(GetAttrArray());
    
    if (_pelObjParent && _pelObjParent->_pParamBag)
    {
        VARIANT Var;
        if (v && *v)
        {
            V_VT(&Var) = VT_BSTR;
            V_BSTR(&Var) = v;
        }

        LPCTSTR pchName = GetAAname();
        Assert(pchName && *pchName);
        PROPNAMEVALUE *pprop = _pelObjParent->_pParamBag->Find((LPTSTR)pchName);
        Assert(pprop);
        VariantClear(&pprop->_varValue);
        hr = THR(VariantCopy(&pprop->_varValue, &Var));

        if (hr)
            goto Cleanup;
    }

    hr = THR(s_propdescCParamElementvalue.b.SetStringProperty(v, this, pSubObj));
    if (hr)
        goto Cleanup;

Cleanup:
    return SetErrorInfo(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\ole\iframe.cxx ===
//+---------------------------------------------------------------------
//
//   File:      frame.cxx
//
//  Contents:   frame tag implementation
//
//  Classes:    CFrameSite, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifdef WIN16
#ifndef X_EXDISP_H_
#define X_EXDISP_H_
#include <exdisp.h>
#endif
#endif

#define _cxx_
#include "iframe.hdl"

const CElement::CLASSDESC CIFrameElement::s_classdesc =
{
    {
        &CLSID_HTMLIFrame,              // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NEVERSCROLL    |
        ELEMENTDESC_FRAMESITE,          // _dwFlags
        &IID_IHTMLIFrameElement,        // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLIFrameElement, // _pfnTearOff
    NULL                                // _pAccelsRun
};

//+---------------------------------------------------------------------------
//
//  element creator used by parser
//
//----------------------------------------------------------------------------

HRESULT
CIFrameElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);

    *ppElementResult = new CIFrameElement(pDoc);

    RRETURN ( (*ppElementResult) ? S_OK : E_OUTOFMEMORY);
}

//+---------------------------------------------------------------------------
//
//  Member: CIFrameElement constructor
//
//----------------------------------------------------------------------------

CIFrameElement::CIFrameElement(CDoc *pDoc)
  : CFrameSite(ETAG_IFRAME, pDoc)
{
}


//+----------------------------------------------------------------------------
//
//  Member:     CIFrameElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-----------------------------------------------------------------------------

HRESULT
CIFrameElement::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *) this, IUnknown)
        QI_HTML_TEAROFF(this, IHTMLIFrameElement, NULL)
        QI_HTML_TEAROFF(this, IHTMLIFrameElement2, NULL)
        QI_TEAROFF_DISPEX(this, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}


//+----------------------------------------------------------------------------
//
// Member: CIFrameElement::ApplyDefaultFormat
//
//-----------------------------------------------------------------------------
HRESULT
CIFrameElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr = S_OK;

    //
    // in NF, IFrames now have a default size.
    //
    pCFI->PrepareFancyFormat();
    pCFI->_ff().SetWidth(CUnitValue(300, CUnitValue::UNIT_PIXELS));
    pCFI->_ff().SetHeight(CUnitValue(150, CUnitValue::UNIT_PIXELS));
    pCFI->_ff()._fRectangular = TRUE;
    pCFI->UnprepareForDebug();

    //
    // Add 'vspace' & 'hspace' to margins
    //
    long cxHSpace = GetAAhspace();
    long cyVSpace = GetAAvspace();

    if (cxHSpace)
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._fHasMargins = TRUE;

        CUnitValue uv(cxHSpace, CUnitValue::UNIT_PIXELS);
        if (pCFI->_ff().GetMargin(SIDE_LEFT).IsNullOrEnum())
            pCFI->_ff().SetMargin(SIDE_LEFT, uv);
        if (pCFI->_ff().GetMargin(SIDE_RIGHT).IsNullOrEnum())
            pCFI->_ff().SetMargin(SIDE_RIGHT, uv);

        pCFI->UnprepareForDebug();
    }
    if (cyVSpace)
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._fHasMargins = TRUE;

        CUnitValue uv(cyVSpace, CUnitValue::UNIT_PIXELS);
        if (pCFI->_ff().GetMargin(SIDE_TOP).IsNullOrEnum())
            pCFI->_ff().SetMargin(SIDE_TOP, uv);
        if (pCFI->_ff().GetMargin(SIDE_BOTTOM).IsNullOrEnum())
            pCFI->_ff().SetMargin(SIDE_BOTTOM, uv);

        pCFI->UnprepareForDebug();
    }

    hr = super::ApplyDefaultFormat(pCFI);

    // in NATIVE_FRAMES, IFrames need a default size but (bug 95406) it is 
    // possible that a user has set height:auto or width:auto.  In this 
    // case we want to use the default height (we do not size to content)
    // there are two ways to do this, 1> hack calcsizecore to detect an iframe with
    // auto settings, or 2> hack a reset for it here.  due to the possibility of 
    // regresions, I will hack here.

    pCFI->PrepareFancyFormat();
    if ( pCFI->_ff().GetWidth().GetRawValue() == CUnitValue::UNIT_ENUM) 
    {
        pCFI->_ff().SetWidth(CUnitValue(300, CUnitValue::UNIT_PIXELS));
    }
    if (pCFI->_ff().GetHeight().GetRawValue() == CUnitValue::UNIT_ENUM)
    {
        pCFI->_ff().SetHeight(CUnitValue(150, CUnitValue::UNIT_PIXELS));
    }

    pCFI->UnprepareForDebug();

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CIFrameElement::Save
//
//  Synopsis:   called twice: for opening <NOFRAMES> and for </NOFRAMES>.
//
//----------------------------------------------------------------------------

HRESULT
CIFrameElement::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr;

    hr = THR(super::Save(pStreamWrBuff, fEnd));
    if (hr)
        goto Cleanup;

    if (!fEnd && !pStreamWrBuff->TestFlag(WBF_SAVE_PLAINTEXT))
    {
        DWORD dwOldFlags = pStreamWrBuff->ClearFlags(WBF_ENTITYREF);

        pStreamWrBuff->SetFlags(WBF_KEEP_BREAKS | WBF_NO_WRAP);

        if (_cstrContents.Length())
        {
            hr = THR(pStreamWrBuff->Write(_cstrContents));
            if (hr)
                goto Cleanup;
        }

        pStreamWrBuff->RestoreFlags(dwOldFlags);
    }

Cleanup:

    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\ole\frame.cxx ===
//+---------------------------------------------------------------------
//
//   File:      frame.cxx
//
//  Contents:   frame tag implementation
//
//  Classes:    CFrameSite, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X_PUTIL_HXX_
#define X_PUTIL_HXX_
#include "putil.hxx"
#endif

#define _cxx_
#include "frame.hdl"

MtDefine(CFrameElement, Elements, "CFrameElement")
MtDefine(CIFrameElement, Elements, "CIFrameElement")

const CElement::CLASSDESC CFrameElement::s_classdesc =
{
    {
        &CLSID_HTMLFrameElement,        // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NEVERSCROLL    |
        ELEMENTDESC_FRAMESITE,          // _dwFlags
        &IID_IHTMLFrameElement,         // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLFrameElement,  // _pfnTearOff
    NULL                                // _pAccelsRun
};

//+---------------------------------------------------------------------------
//
//  element creator used by parser
//
//----------------------------------------------------------------------------

HRESULT
CFrameElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);

    *ppElementResult = new CFrameElement(pDoc);

    RRETURN ( (*ppElementResult) ? S_OK : E_OUTOFMEMORY);
}

//+---------------------------------------------------------------------------
//
//  Member: CFrameElement constructor
//
//----------------------------------------------------------------------------

CFrameElement::CFrameElement(CDoc *pDoc)
  : CFrameSite(ETAG_FRAME, pDoc)
{
}

//+----------------------------------------------------------------------------
//
// Member: CFrameElement::ApplyDefaultFormat
//
//-----------------------------------------------------------------------------
HRESULT
CFrameElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    pCFI->PrepareFancyFormat();
    pCFI->_ff()._fRectangular = TRUE;
    pCFI->UnprepareForDebug();
    RRETURN(super::ApplyDefaultFormat(pCFI));
}


//+----------------------------------------------------------------------------
//
// Member: CFrameElement:get_height
//
//-----------------------------------------------------------------------------
STDMETHODIMP CFrameElement::get_height(VARIANT * p)
{
    HRESULT hr = S_OK;

    if (p)
    {
        V_VT(p) = VT_I4;
        CLayout * pLayout = GetUpdatedLayout();

        //CFrameElement always has layout, but PREFIX doesn't believe it
        //and possibly some stress conditions could cause the problem indeed..
        V_I4(p) = ( pLayout ? g_uiDisplay.DocPixelsFromDeviceY(pLayout->GetHeight()) : 0 );
    }
    RRETURN(SetErrorInfo(hr));
}

STDMETHODIMP CFrameElement::put_height(VARIANT p)
{
    RRETURN(SetErrorInfo(CTL_E_METHODNOTAPPLICABLE));
}

//+----------------------------------------------------------------------------
//
// Member: CFrameElement:get_width
//
//-----------------------------------------------------------------------------
STDMETHODIMP CFrameElement::get_width(VARIANT * p)
{
    HRESULT hr = S_OK;

    if (p)
    {
        V_VT(p) = VT_I4;
        CLayout * pLayout = GetUpdatedLayout();

        //CFrameElement always has layout, but PREFIX doesn't believe it
        //and possibly some stress conditions could cause the problem indeed..
        V_I4(p) = ( pLayout ? g_uiDisplay.DocPixelsFromDeviceX(pLayout->GetWidth()) : 0 );
    }
    RRETURN(SetErrorInfo(hr));
}

STDMETHODIMP CFrameElement::put_width(VARIANT p)
{
    RRETURN(SetErrorInfo(CTL_E_METHODNOTAPPLICABLE));
}

//+----------------------------------------------------------------------------
//
// Member: CFrameElement:Notify
//
//-----------------------------------------------------------------------------
void
CFrameElement::Notify(CNotification *pNF)
{    
    switch (pNF->Type())
    {
    //  Notification creates collection of IPrints exclusively contained by frames.
    //  If this frame contains an IPrint instead of normal HTML, add the IPrint to the collection.
    //  NB: If we wanted to also collect IFrames (in addition to FRAMEs), we could just move this
    //      logic up to CFrameSite::Notify, and remove the FRAMESET check in CDoc::ExecHelper GETIPRINT.
    case NTYPE_COLLECT_IPRINT:
        CIPrintCollection *pIPC;

        pNF->Data((void**)&pIPC);
        if (pIPC)
        {        
            IPrint *pIPrint = NULL;
            if (!GetIPrintObject(&pIPrint))
            {
                pIPC->AddIPrint( pIPrint );
            }
            
            // Otherwise, rebroadcast in new markup if this is a submarkup with a nested frameset
            else
            {
                CMarkup  * pMarkup;
                CElement * pElement;

                pElement = GetSlavePtr();
                if (pElement)
                {
                    pMarkup = pElement->GetMarkup();
                    if (pMarkup)
                    {
                        pElement = pMarkup->GetElementClient();
                        Assert(pElement);
                        if (pElement)
                        {
                            // NB: (greglett) Since this notification only collects CFrameElements and not IFrames, we only need
                            // to fire the notification if we have a frameset.
                            if (pElement->Tag() == ETAG_FRAMESET)
                            {
                                CNotification nf;
                                Assert(pElement->GetFirstBranch());

                                // Collect all IPrint objects from frames that consist of only IPrint objects.
                                nf.Initialize(NTYPE_COLLECT_IPRINT, pElement, pElement->GetFirstBranch(), pIPC, 0);

                                pMarkup->Notify(&nf);
                            }
                        }
                    }
                }
            }

            ReleaseInterface(pIPrint);
        }
        break;
    }

    super::Notify(pNF);
}

//+----------------------------------------------------------------------------
//
//  Member:     CFrameElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-----------------------------------------------------------------------------

HRESULT
CFrameElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *) this, IUnknown)
        QI_HTML_TEAROFF(this, IHTMLFrameElement, NULL)
        QI_TEAROFF(this, IHTMLFrameElement2, NULL)
        QI_TEAROFF_DISPEX(this, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\ole\frmsite.cxx ===
//+---------------------------------------------------------------------
//
//   File:      frmsite.cxx
//
//  Contents:   frame site implementation
//
//  Classes:    CFrameSite, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_EXDISP_H_
#define X_EXDISP_H_
#include "exdisp.h"     // for IWebBrowser
#endif

#ifndef X_HTIFACE_H_
#define X_HTIFACE_H_
#include "htiface.h"    // for ITargetFrame, ITargetEmbedding
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include <shell.h>
#endif

#ifndef X_SHLOBJP_H_
#define X_SHLOBJP_H_
#include <shlobjp.h>
#endif

#ifndef X_SHLGUID_H_
#define X_SHLGUID_H_
#include <shlguid.h>
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_PERHIST_H_
#define X_PERHIST_H_
#include <perhist.h>
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_OLELYT_HXX_
#define X_OLELYT_HXX_
#include "olelyt.hxx"
#endif

#ifndef _X_WEBOCUTIL_H_
#define _X_WEBOCUTIL_H_
#include "webocutil.h"
#endif

#ifndef X_FRAMEWEBOC_HXX_
#define X_FRAMEWEBOC_HXX_
#include "frameweboc.hxx"
#endif

#ifndef X_FRAMELYT_HXX_
#define X_FRAMELYT_HXX_
#include "framelyt.hxx"
#endif

#define _cxx_
#include "frmsite.hdl"


////////////////////////////////////////////////////////////////////////////////////////

BOOL IsSpecialUrl(LPCTSTR pszUrl);
extern HRESULT GetCallerIDispatch(IServiceProvider *pSP, IDispatch ** ppID);
extern BOOL g_fInMshtmpad;

////////////////////////////////////////////////////////////////////////////////////////

#if 0
BOOL
CFrameSite::DoWeHandleThisIIDInOC(REFIID iid)
{
    return    IsEqualIID(iid, IID_IWebBrowser2)
           || IsEqualIID(iid, IID_IWebBrowser)
           || IsEqualIID(iid, IID_IWebBrowserApp)
           || IsEqualIID(iid, IID_IHlinkFrame)
           || IsEqualIID(iid, IID_ITargetFrame)
           || IsEqualIID(iid, IID_IServiceProvider)
           || IsEqualIID(iid, IID_IPersistHistory)
           || IsEqualIID(iid, IID_IPersist)
           || IsEqualIID(iid, IID_IOleCommandTarget)
           || IsEqualIID(iid, IID_IConnectionPointContainer);
}
#endif

//+------------------------------------------------------------------------
//
//  Member:     CFrameSite::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CFrameSite::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if IID_HTML_TEAROFF(this, IHTMLFrameBase, NULL)
    else
    if IID_HTML_TEAROFF(this, IHTMLFrameBase2, NULL)
    else
    if IID_HTML_TEAROFF(this, IHTMLFrameBase3, NULL)
    else
    if IID_HTML_TEAROFF(this, IHTMLElement2, NULL)
    else
    if IID_TEAROFF(this, IDispatchEx, NULL)
    else if (  _pWindow
            && _pWindow->Window()->_punkViewLinkedWebOC
            && IsEqualIID(iid, IID_ITargetFramePriv))
    {
        void * pvObject = NULL;

        hr = _pWindow->Window()->_punkViewLinkedWebOC->QueryInterface(iid, &pvObject);
        if (hr)
            RRETURN(hr);

        hr = THR(CreateTearOffThunk(
                 pvObject, 
                 *(void **)pvObject,
                 NULL,
                 ppv,
                 (IUnknown *)(IPrivateUnknown *)this,
                 *(void **)(IUnknown *)(IPrivateUnknown *)this,
                 QI_MASK,      // Call QI on object 2.
                 NULL));

         ((IUnknown *)pvObject)->Release();

         if (!*ppv)
         {
             return E_OUTOFMEMORY;
         }
    }
    else
    {
        hr = THR_NOTRACE(super::PrivateQueryInterface(iid, ppv));

        if (S_OK == hr)
        {
            RRETURN(hr);
        }
        else if (_pWindow)
        {
            void    * pvObject = NULL;
            CWindow * pWindow  = _pWindow->Window();

            //
            // For these cases, just delegate on down to the window
            // with our IUnknown.
            //
            if (!pWindow)
                return E_NOINTERFACE;

            hr = pWindow->EnsureFrameWebOC();
            if (hr)
                RRETURN(hr);

            hr = THR_NOTRACE(pWindow->_pFrameWebOC->QueryInterface(iid, &pvObject));
            if (hr)
                RRETURN(hr);

            hr = THR(CreateTearOffThunk(
                                        pvObject, 
                                        *(void **)pvObject,
                                        NULL,
                                        ppv,
                                        (IUnknown *)(IPrivateUnknown *)this,
                                        *(void **)(IUnknown *)(IPrivateUnknown *)this,
                                        QI_MASK,      // Call QI on object 2.
                                        NULL));

            ((IUnknown *)pvObject)->Release();
            if (!*ppv)
                RRETURN(E_OUTOFMEMORY);
        }
        else
            RRETURN(E_NOINTERFACE);
    }
    (*(IUnknown **)ppv)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     CFrameSite::Passivate
//
//  Synopsis:   1st stage dtor.
//
//---------------------------------------------------------------

void
CFrameSite::Passivate()
{
    Assert(Doc());

    if (_pWindow && _pWindow->_fFiredOnLoad &&
        !(Doc()->IsPassivating() || Doc()->IsPassivated()))
    {
        _pWindow->_fFiredOnLoad = FALSE;

        // This used to be done when the nested WebOC went down.(see bug# 101175)
        _pWindow->Fire_onunload();
    }

    if (_pWindow)
    {
        // Have to explictly shut down the child world.
        _pWindow->Markup()->TearDownMarkup();
        if( _pWindow->Window()->_pMarkupPending )
            _pWindow->Window()->ReleaseMarkupPending(_pWindow->Window()->_pMarkupPending);

        //
        //  Clear defunked AccEvents -- jharding
        //  These could hold onto our child window and keep it alive.
        //
        Doc()->_aryAccEvents.Flush();

        // Normally, the call to _pWindow->Fire_onunload() above will cause the MyPics object to be released.
        // However, if the Doc is passivating or passivated, the above call will be bypassed.  This call to 
        // DestroyMyPics will ensure that we release the MyPics object which holds a ref on the CDocument.
        _pWindow->DestroyMyPics();

        _pWindow->Release();
        _pWindow = NULL;
    }

    super::Passivate();
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSite::CreateObject()
//
//  Synopsis:   Helper to instantiate the contained document
//
//-------------------------------------------------------------------------

HRESULT
CFrameSite::CreateObject()
    {
    HRESULT             hr;
    CVariant            varApplication(VT_EMPTY);
    CVariant            varSecurity(VT_EMPTY);
    CMarkup           * pMarkup          = GetMarkup();
    CDoc              * pDoc             = Doc();
    INamedPropertyBag * pINPB            = NULL;
    BOOL                bRestoreFavorite = FALSE;
    COmWindowProxy    * pWindowProxy     = NULL;

    if (!pMarkup)
    {
        AssertSz(FALSE, "Should always have a markup.");
        hr = S_FALSE;
        goto Cleanup;
    }

    // See if there is an "Application" attribute on this element, and if there is,
    // set a flag that is checked from CDocument::SetClientSite.
    hr = getAttribute(_T("Application"), 0, &varApplication);

    if (SUCCEEDED(hr) && (V_VT(&varApplication) == VT_BSTR))
    {
        if (pMarkup->IsMarkupTrusted() && !StrCmpIC(V_BSTR(&varApplication), _T("Yes")))
            _fTrustedFrame = TRUE;
    }

    // See if there is a "Security" attribute on this element, if there is and it is
    // set to "Restricted", set a flag to be copied into proxy objects created for this 
    // window's access to other windows.
    hr = getAttribute(_T("Security"), 0, &varSecurity);

    if ( SUCCEEDED(hr) && (V_VT(&varSecurity) == VT_BSTR) && (V_BSTR(&varSecurity)))
    {
        _fRestrictedFrame = !StrCmpIC(V_BSTR(&varSecurity), _T("Restricted"));
    }

    // If we have the restricted zone set on the frame element or we have a parent window with 
    // restricted zone we are a restricted zone frame.
    pWindowProxy = GetWindowedMarkupContext()->GetWindowPending();
    if (pWindowProxy)
    {
        _fRestrictedFrame |= pWindowProxy->Window()->_fRestricted;
    }

    if (IsOverflowFrame() ||
        (pDoc->_dwLoadf & DLCTL_NO_FRAMEDOWNLOAD))
    {
        hr = S_OK;
        goto Cleanup;
    }

    //
    // $$anandra This needs to wire into the speculative dl that was begun.  
    //

    // if we are in the process of restoring a shortcut, then try to get the src
    // for this element.  If it is not there, do the normal load thing.  if it is
    // there, then set the src to that.

    // QFE: The BASEURL could be there, but stale.  This will happen if the top-level page has changed
    // to point the subframe to a different URL.
    // Provide a mechanism to compare and invalidate the persisted URL if this is the case.

    if (pDoc->_pShortcutUserData &&
        !pMarkup->MetaPersistEnabled(htmlPersistStateFavorite) )
    {
        hr = THR_NOTRACE(pDoc->_pShortcutUserData->
                        QueryInterface(IID_INamedPropertyBag,
                                      (void**) &pINPB));
        if (!hr)
        {
            PROPVARIANT  varBASEURL = {0};
            PROPVARIANT  varORIGURL = {0};
            BSTR         strName = GetPersistID();
            bRestoreFavorite = TRUE;

            // Check the shortcut for a BASEURL

            V_VT(&varBASEURL) = VT_BSTR;
            hr = THR_NOTRACE(pINPB->ReadPropertyNPB(strName, _T("BASEURL"), &varBASEURL));

            if (!hr && V_VT(&varBASEURL) == VT_BSTR)
            {
                // The shortcut has a BASEURL.  Now see if it has an ORIGURL (original URL)

                V_VT(&varORIGURL) = VT_BSTR;
                hr = THR_NOTRACE(pINPB->ReadPropertyNPB(strName, _T("ORIGURL"), &varORIGURL));

                if (!hr && V_VT(&varORIGURL) == VT_BSTR)
                {
                    // The shortcut has an ORIGURL.  Get the URL from the markup, and compare.

                    const TCHAR * pchUrl = GetAAsrc();

                    if (pchUrl && UrlCompare(pchUrl, V_BSTR(&varORIGURL), TRUE) != 0)
                    {
                        // They're different.  Invalidate the BASEURL by not setting the attribute.

                        bRestoreFavorite = FALSE;
                    }

                    SysFreeString(V_BSTR(&varORIGURL));
                    V_BSTR(&varORIGURL) = NULL;
                }
                
                // Restore the saved URL if either (1) there is no ORIGURL, or (2) there is an ORIGURL and it matches
                // the URL currently in the markup.

                if (bRestoreFavorite)
                {
                    // (jbeda) this will cause us to save the wrong ORIGURL if we
                    // repersist this favorite. BUG #87465
                    hr = THR(SetAAsrc(V_BSTR(&varBASEURL)));
                }

                SysFreeString(V_BSTR(&varBASEURL));
            }
            SysFreeString(strName);
            ReleaseInterface(pINPB);
        }

        hr = S_OK;
    }   

    _fDeferredCreate = FALSE;

    // HACK ALERT (jbeda)
    // If we are loading with PICS turned on we need to have something going on until we
    // know that this URL is okay.  For that reason, if we don't already have a window, we
    // first load up with about:blank and then navigate to the real URL that we want.
    if (!_pWindow && pDoc->_pClientSite && !(pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_NOPICS))
    {
        VARIANT varPics = {0};
        IGNORE_HR(CTExec(pDoc->_pClientSite, &CGID_ShellDocView, SHDVID_ISPICSENABLED, 
                         0, NULL, &varPics));
        if (V_VT(&varPics) == VT_BOOL && V_BOOL(&varPics) == VARIANT_TRUE)
        {
            CStr strUrlOrig;

            hr = strUrlOrig.Set(GetAAsrc());
            if (hr)
                goto Cleanup;

            hr = THR(SetAAsrc(_T("about:blank")));
            if (hr)
                goto Cleanup;

            OnPropertyChange_Src();
            SetFrameData();

            hr = THR(SetAAsrc(strUrlOrig));
            if (hr)
                goto Cleanup;

            // This is not the nav that you are looking for 
            // (with hand gesture -- get the reference?)
            if (_pWindow && _pWindow->Window())
            {
                _pWindow->Window()->_fNavigated = FALSE;
            }
        }
    }

    // JHarding: We were ignoring errors from here, but errors are
    // legitimately bad now.
    hr = THR(OnPropertyChange_Src());
    if( hr )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    SetFrameData();

    // Since we loaded from a favorite, we want to simulate
    // more than one load so that we will save out a favorite.
    if (bRestoreFavorite && _pWindow && _pWindow->Window())
        _pWindow->Window()->NoteNavEvent();

Cleanup:
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSite::Init2
//
//  Synopsis:   2nd phase of initialization
//
//-------------------------------------------------------------------------

HRESULT
CFrameSite::Init2(CInit2Context * pContext)
{
    HRESULT hr = THR(super::Init2(pContext));
    if (hr)
        goto Cleanup;

    Doc()->_fBroadcastStop = TRUE;

    if (Tag() == ETAG_IFRAME)
    {
        // frameBorder form <iframe> should be calculated here.
        //
        LPCTSTR    pStrFrameBorder = GetAAframeBorder();

        _fFrameBorder = !pStrFrameBorder
                      || pStrFrameBorder[0] == _T('y')
                      || pStrFrameBorder[0] == _T('Y')
                      || pStrFrameBorder[0] == _T('1');
        Doc()->_fFrameBorderCacheValid = TRUE;
    }
    else
    {
        Doc()->_fFrameBorderCacheValid = FALSE;
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFrameSite::IsClean
//
//  Synopsis:   Return S_OK if contained document is clean.
//
//----------------------------------------------------------------------------

HRESULT
CFrameSite::IsClean(void)
{
    HRESULT hr = S_FALSE;

    // ask the document inside if its dirty to answer the question
    IPersistFile * pPF;

    if (OK(THR(_pWindow->Document()->QueryInterface(IID_IPersistFile, (void **)&pPF))))
    {
        hr = THR(pPF->IsDirty());
        pPF->Release();
    }

    hr = (hr == S_FALSE) ? S_OK : S_FALSE;

    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSite::Notify
//
//  Synopsis:   Called to notify of a change
//
//-------------------------------------------------------------------------

void
CFrameSite::Notify(CNotification *pNF)
{
    
    switch (pNF->Type())
    {
    case NTYPE_BASE_URL_CHANGE:
        OnPropertyChange(DISPID_CFrameSite_src, 
                         ((PROPERTYDESC *) &s_propdescCFrameSitesrc)->GetdwFlags(),
                         (PROPERTYDESC *) &s_propdescCFrameSitesrc);
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        {                                 
            CElement *  pParent = GetFirstBranch()->Parent()->Element();

            GetMarkup()->_fHasFrames = TRUE;
            COmWindowProxy *pOmWindowParent = GetMarkup()->GetWindowPending();

            if (_pWindow && _pWindow->Window() && pOmWindowParent)
            {
                Assert(!_pWindow->Window()->_pWindowParent);                
           
                _pWindow->Window()->_pWindowParent = pOmWindowParent->Window();
                _pWindow->Window()->_pWindowParent->SubAddRef();

                // Attach a window that is disable modeless, when it
                // gets reenabled we will be reenabled one extra time.
                // We will underflow and never navigate again.
                Assert( !_pWindow->Window()->_ulDisableModeless );
            }                  

            if (_fDeferredCreate || 
                  ( (!pNF->DataAsDWORD()) && !_fHaveCalledOnPropertyChange_Src ) )
            {
                CreateObject();
            }

            //  If we have entered a FRAMESET, dirty its frame positions so that it will calc
            //  our positions and attach our display node.
            if (    pParent
                &&  pParent->Tag() == ETAG_FRAMESET
                &&  pParent->CurrentlyHasAnyLayout())
            {
                DYNCAST(CFrameSetSite, pParent)->Layout()->SetDirtyFramePositions(TRUE);
                pParent->ResizeElement();        
            }
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        pNF->SetSecondChanceRequested();
        break;

    case NTYPE_ELEMENT_EXITTREE_2:
        if (_pWindow && _pWindow->Window() && _pWindow->Window()->_pWindowParent)
        {
            _pWindow->Window()->_pWindowParent->SubRelease();
            _pWindow->Window()->_pWindowParent = NULL;

            // If we go away without reenable modeless on 
            // our parent markup, the parent will never
            // be able to navigate again.
            Assert( !_pWindow->Window()->_ulDisableModeless );
        }

        if(     !(pNF->DataAsDWORD() & EXITTREE_PASSIVATEPENDING) 
            &&  _pWindow 
            &&  _pWindow->Window() 
            &&  !_pWindow->Window()->_pMarkup->IsOrphanedMarkup() )
        {
            IGNORE_HR( _pWindow->Window()->_pMarkup->SetOrphanedMarkup( TRUE ) );
        }
        break;

        // CONSIDER: (jbeda) move this to CElement to handle general view-link case
    case NTYPE_FAVORITES_SAVE:
        // if persist is not turned on, do the 'default stuff' (if it is, the 
        //    special handling already happened in the call to super::
        if (!GetMarkup()->MetaPersistEnabled(htmlPersistStateFavorite))
        {
            BSTR                    bstrName;
            BSTR                    bstrTemp;
            FAVORITES_NOTIFY_INFO * psni;
            CMarkup*                pMarkupLink = NULL;
            
            pNF->Data((void **)&psni);

            if (_pWindow)
                pMarkupLink = _pWindow->Markup();

            if (!pMarkupLink)
                break;

            bstrName = GetPersistID(psni->bstrNameDomain);

            // fire on persist to give the event an oppurtunity to cancel
            // the default behavior.

            IGNORE_HR(PersistFavoritesData(psni->pINPB, bstrName));


            {
                CNotification   nf;
            
                // do the broadcast notify, but use the new name for nesting purposes
                bstrTemp = psni->bstrNameDomain;
                psni->bstrNameDomain = bstrName;

                nf.FavoritesSave(pMarkupLink->Root(), (void*)psni);
                pMarkupLink->Notify(&nf);

                psni->bstrNameDomain = bstrTemp;
            }

            SysFreeString(bstrName);
        }
        break;

    case NTYPE_GET_FRAME_ZONE:
        {
            VARIANT *   pvar;
            CMarkup*    pMarkupLink = NULL;
            HRESULT     hr;

            pNF->Data((void **)&pvar);

            if (_pWindow)
                pMarkupLink = _pWindow->Markup();

            if (!pMarkupLink)
                break;

            hr = THR(pMarkupLink->GetFrameZone(pvar));
            if (hr)
                break;
        }

        break;


    case NTYPE_BEFORE_UNLOAD:
        {
            BOOL *pfContinue;

            pNF->Data((void **)&pfContinue);
            if (*pfContinue && _pWindow)
            {
               *pfContinue = _pWindow->Fire_onbeforeunload();
            }
        }
        break;

    case NTYPE_ON_UNLOAD:
        {
            if (_pWindow && _pWindow->_fFiredOnLoad)
            {
                _pWindow->_fFiredOnLoad = FALSE;
                _pWindow->Fire_onunload();
            }
        }
        break;

    case NTYPE_ELEMENT_ENTERVIEW_1:
        {            
            if (_fDeferredCreate) 
            {               
                OnPropertyChange_Src();     
                SetFrameData();
            }
        }
        break;

    case NTYPE_UPDATE_DOC_DIRTY:
        if (S_FALSE == IsClean())
        {
            Doc()->_lDirtyVersion = MAXLONG;
            pNF->SetFlag(NFLAGS_SENDENDED);
        }
        break;
    }



    super::Notify(pNF);
}
//+--------------------------------------------------------------------------------
//
//  member : PersistFavoritesData   
//
//  Synopsis : this method is responsible for saveing the default frame information
//      into the shortcut file.  This include filtering for the meta tags/ xtag
//      specification of what values to store.
//
//      For the frame we want to save a number of different pieces of information
//      this includes:
//          frame name/id/unique identifier
//          frame URL
//          frame's body's scroll position
//          frame postition or size
//
//      TODO: add the filtering logic
//
//---------------------------------------------------------------------------------

HRESULT
CFrameSite::PersistFavoritesData(INamedPropertyBag * pINPB, BSTR bstrSection)
{
    HRESULT       hr = S_OK;
    PROPVARIANT   varValue;
    TCHAR         achTemp[pdlUrlLen];

    Assert (pINPB);

    // only do the save for this frame if it has actually navigated.
    if (_pWindow && _pWindow->Window() && _pWindow->Window()->_fNavigated)
    {
        hr = THR(GetCurrentFrameURL(achTemp, ARRAY_SIZE(achTemp) ));
        if (hr != S_OK)
        {
            hr = S_OK;
            goto Cleanup;
        }

        // First store off the url of the frame
        V_VT(&varValue) = VT_BSTR;
        V_BSTR(&varValue) = SysAllocString(achTemp);

        IGNORE_HR(pINPB->WritePropertyNPB(bstrSection,
                                          _T("BASEURL"),
                                          &varValue));
        SysFreeString(V_BSTR(&varValue));

        // Second, store off the original SRC URL
        const TCHAR * pchUrl = GetAAsrc();

        V_VT(&varValue) = VT_BSTR;
        V_BSTR(&varValue) = SysAllocString(pchUrl);

        IGNORE_HR(pINPB->WritePropertyNPB(bstrSection,
                                          _T("ORIGURL"),
                                          &varValue));
        SysFreeString(V_BSTR(&varValue));

    }

Cleanup:
    RRETURN( hr );
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSite::NoResize()
//
//  Note:       Called by CFrameSetSite to determine if the site is resizeable
//
//-------------------------------------------------------------------------

BOOL CFrameSite::NoResize()
{
    return GetAAnoResize() != 0 && !IsEditable(TRUE);
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSite::Opaque()
//
//  Note:       allowTransparency is a VARIANT_BOOL, default false
//              IsOpaque is designed to return the opposite of allowTransparency
//
//-------------------------------------------------------------------------

BOOL CFrameSite::IsOpaque()
{
    return GetAAallowTransparency() == VARIANT_FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSite::ApplyDefaultFormat()
//
//-------------------------------------------------------------------------

HRESULT CFrameSite::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr;

    hr = super::ApplyDefaultFormat(pCFI);
    if (FAILED(hr))
    {
        goto done;
    }

    if (IsOpaque())
    {
        pCFI->PrepareFancyFormat();
        
        pCFI->_ff()._ccvBackColor.SetSysColor(COLOR_WINDOW);
          
        Assert(pCFI->_ff()._ccvBackColor.IsDefined());
        
        pCFI->UnprepareForDebug();        
    }
    
done:
    RRETURN( hr );
}

//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange
//
//  Note:       Called after a property has changed to notify derived classes
//              of the change.  All properties (except those managed by the
//              derived class) are consistent before this call.
//
//              Also, fires a property change notification to the site.
//
//-------------------------------------------------------------------------

HRESULT
CFrameSite::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT   hr   = S_OK;
    CDoc    * pDoc = Doc();

    if (!pDoc)
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        return E_FAIL;
    }

    switch (dispid)
    {
    case DISPID_CFrameSite_src:
    {
        BOOL fSaveTempfileForPrinting = pDoc && pDoc->_fSaveTempfileForPrinting;

        // While we are saving frames or iframes out to tempfiles, we are rewiring
        // the src property of the (i)frame temporarily, but we don't want any
        // property change notifications to occur because they would alter the
        // document inside the browser.
        if (!fSaveTempfileForPrinting)
        {
            hr = THR(OnPropertyChange_Src());
            SetFrameData();
        }
        break;
    }

    case DISPID_CFrameSite_scrolling:
        hr = THR(OnPropertyChange_Scrolling());
        break;

    case DISPID_CFrameSite_noResize:
        hr = THR(OnPropertyChange_NoResize());
        break;

    case DISPID_CFrameSite_frameBorder:
        if (Tag() == ETAG_IFRAME)
        {
            LPCTSTR pStrFrameBorder = GetAAframeBorder();
            _fFrameBorder = !pStrFrameBorder
                          || pStrFrameBorder[0] == _T('y')
                          || pStrFrameBorder[0] == _T('Y')
                          || pStrFrameBorder[0] == _T('1');
        }
        else
        {
            // don't assume this, DOM can make a mess of the tree.
            if (GetMarkup()->GetElementClient()->Tag() == ETAG_FRAMESET)
            {
                pDoc->_fFrameBorderCacheValid = FALSE;
            }
        }
        break;
    }

    if (!hr)
    {
        hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));
    }

    RRETURN(hr);
}

HRESULT
CFrameSite::Init()
{
    HRESULT hr;

    hr = THR(super::Init());
    if (hr)
        goto Cleanup;

    _fLayoutAlwaysValid = TRUE;

    CreateLayout();

Cleanup:

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange_Src
//
//  Note:       Called after src property has changed
//
//-------------------------------------------------------------------------

HRESULT
CFrameSite::OnPropertyChange_Src(DWORD dwBindf, DWORD dwFlags, TCHAR * pchUrlContext)
{
    HRESULT       hr = S_OK;
    const TCHAR * pchUrl = GetAAsrc();
    TCHAR         cBuf[pdlUrlLen];
    TCHAR   *     pchExpandedUrl = cBuf;
    CDoc    *     pDoc = Doc();
    CMarkup *     pMarkup;
    CDwnDoc *     pDwnDoc;
    BSTR          bstrMedia   = NULL;
    IStream *     pStmHistory = NULL;
    BOOL          fLocalNavigation   = FALSE;
    BOOL          fProtocolNavigates = TRUE;
    BOOL          bAllowSpecialAboutBlank = FALSE;
    const TCHAR * pchContainerurl = NULL;
    const TCHAR * pchCreatorurl = NULL;
    DWORD         dwContext = 0;
    DWORD         dwPolicy = URLPOLICY_DISALLOW;
    DWORD         dwPUAFFlags = PUAF_DEFAULT;
    DWORD         dwZone = URLZONE_UNTRUSTED;
    CMarkup *     pWindowedMarkupContext = NULL;
    IInternetSecurityManager *pSecMgr = NULL;
    extern BOOL   g_fInAutoCad;

    // defer until we are connected to the primary markup
    if (!IsConnectedToPrimaryWindow())
    {   
        _fDeferredCreate = TRUE;
        goto Cleanup;
    }
    _fDeferredCreate = FALSE;
    
    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pMarkup = GetMarkup();          

    pDwnDoc = pMarkup->GetDwnDoc();

    if (pDwnDoc)
        dwBindf |= pDwnDoc->GetBindf();

    if (!pchUrl || !*pchUrl)
    {
        pchUrl = _T("about:blank");
    }

    if (!(dwFlags & CDoc::FHL_DONTEXPANDURL))
    {
        // Expand the URL and escape spaces.
        //
        CMarkup::ExpandUrl(pMarkup, pchUrl, ARRAY_SIZE(cBuf), pchExpandedUrl, this);
    }
    else
    {
        pchExpandedUrl = (TCHAR*)pchUrl;
    }

    // Block url recursion unless this came though window.location.href, etc (#106907)
    //
    if (   pMarkup
        && !(dwFlags & CDoc::FHL_SETURLCOMPONENT)
        && !(dwFlags & CDoc::FHL_FOLLOWHYPERLINKHELPER)
        && pMarkup->IsUrlRecursive(pchExpandedUrl))
    {
        TraceTag((tagWarning, "Found %ls recursively, not displaying", pchExpandedUrl));
        pchExpandedUrl = _T("about:blank");
    }

    // Do some security checks before allowing navigation to the frame.

    // Get the url of the markup.
    pWindowedMarkupContext = pMarkup->GetWindowedMarkupContext();
    pchContainerurl = pWindowedMarkupContext->Url();
    if (!pchContainerurl || IsSpecialUrl(pchContainerurl))
    {
        // If the markup is a special url, get the creator url.
        pchCreatorurl = pWindowedMarkupContext->GetAAcreatorUrl();
    }

    // Make a special case for about:blank, this allows for the design mode.
    if ((!pchCreatorurl || !_tcsicmp(pchCreatorurl, _T("about:blank"))) &&
        pchContainerurl && !_tcsicmp(pchContainerurl, _T("about:blank")))
    {
        bAllowSpecialAboutBlank = TRUE;
    }

    // If the container url is a special url, use the creator url.
    if (!pchContainerurl || IsSpecialUrl(pchContainerurl))
        pchContainerurl = pchCreatorurl;

    // Check if frames are allowed in the markup.
    if (!g_fInAutoCad && (Doc()->_dwLoadf & DLCTL_NOFRAMES))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }
    else if (_fTrustedFrame || bAllowSpecialAboutBlank)
    {
        // Do nothing for trusted frames.
        // Do nothing for the special case about:blank with no creator url.
    }
    else
    {
        // Get the security manager.
        pWindowedMarkupContext->Doc()->EnsureSecurityManager();
        pSecMgr = pWindowedMarkupContext->GetSecurityManager();

        if (!pchContainerurl || IsSpecialUrl(pchContainerurl))
        {
            // If the creator url is a special url, treat zone as restricted.
            dwPUAFFlags = PUAF_ENFORCERESTRICTED;
        }
        else if (pWindowedMarkupContext->HasWindowPending() &&
                 pWindowedMarkupContext->GetWindowPending()->Window()->_fRestricted)
        {
            // Honor the restricted bit on the window.
            dwPUAFFlags = PUAF_ENFORCERESTRICTED;
        }
        else if (!SUCCEEDED(hr = pSecMgr->MapUrlToZone(pchContainerurl, &dwZone, 0)) ||
                dwZone == URLZONE_UNTRUSTED)
        {
            // If MapUrlToZone fails, treat the url as restricted.
            dwPUAFFlags = PUAF_ENFORCERESTRICTED;
        }

        // We're overloading the Urlaction for launching programs and files in
        // frames to mean dis-allow frame navigation in Restricted zone.  Treat
        // URLPOLICY_QUERY as disallow for this purpose. RAID #569126.
        if (dwPUAFFlags == PUAF_ENFORCERESTRICTED)
        {
            hr = pSecMgr->ProcessUrlAction(pchContainerurl, URLACTION_SHELL_VERB,
                                           (BYTE*)&dwPolicy, sizeof(dwPolicy),
                                           (BYTE*)&dwContext, sizeof(dwContext),
                                           dwPUAFFlags | PUAF_NOUI, 0);

            if (!SUCCEEDED(hr) || GetUrlPolicyPermissions(dwPolicy) == URLPOLICY_DISALLOW)
            {
                hr = E_ACCESSDENIED;
                goto Cleanup;
            }
        }
    }

    // Do a local machine access check to see if navigation is allowed to the
    // specified Url in this frame.  No checks for the special case about:blank with
    // special creator url.  This allows design mode.
    if (!bAllowSpecialAboutBlank &&
        !COmWindowProxy::CanNavigateToUrlWithLocalMachineCheck(pMarkup, NULL, pchExpandedUrl))
    {
        pchExpandedUrl = _T("about:blank");
    }

    // FollowHyperlink is called in this function further down the line.  No further
    // local machine check is needed in FollowHyperLink since it'll repeat the same thing
    // we did above.
    dwFlags |= CDoc::FHL_NOLOCALMACHINECHECK;

    // If url is not secure but is on a secure page, we should query now
    // Note that even if we don't want to load the page, we do the navgiation anyway;
    // When loading the nested instance, we call ValidateSecureUrl again and fail the load.
    // This is so that the nested shdocvw has the correct URL in case of "refresh". (dbau)
    {
        SSL_SECURITY_STATE  sslSecurity;           // unsecure/mixed/secure
        SSL_PROMPT_STATE    sslPrompt;             // allow/query/deny
        BOOL                fPendingRoot = pMarkup->IsPendingRoot();
        
        pDoc->GetRootSslState(fPendingRoot, &sslSecurity, &sslPrompt);

        if (sslPrompt == SSL_PROMPT_QUERY && !IsSpecialUrl(pchExpandedUrl))
        {
            pMarkup->ValidateSecureUrl(fPendingRoot, pchExpandedUrl, FALSE, FALSE);
        }
    }
    
    dwFlags |= CDoc::FHL_IGNOREBASETARGET | 
               CDoc::FHL_SETDOCREFERER    |
               CDoc::FHL_FRAMENAVIGATION;

    if (!_pWindow)
    {
        dwFlags |= CDoc::FHL_FRAMECREATION;

        hr = THR(pMarkup->GetLoadHistoryStream((0xF000000 | GetSourceIndex()), HistoryCode(), &pStmHistory));

        // GetLoadHistoryStream can succeed
        // and return a NULL stream.
        //
        if (!hr && pStmHistory)
        {
            THR(pStmHistory->Seek(LI_ZERO.li, STREAM_SEEK_SET, NULL));
        }
    }
    
    hr = THR(pDoc->FollowHyperlink(pchExpandedUrl, 
                                   NULL, 
                                   this, 
                                   NULL, 
                                   FALSE,
                                   NULL,
                                   !_pWindow,
                                   _pWindow, 
                                   _pWindow ? NULL : &_pWindow,
                                   dwBindf,
                                   ERROR_SUCCESS,
                                   FALSE,
                                   NULL,
                                   FALSE,
                                   dwFlags,
                                   GetAAname(),
                                   pStmHistory,
                                   this,
                                   pchUrlContext,
                                   &fLocalNavigation,
                                   &fProtocolNavigates,
                                   NULL,
                                   pchContainerurl));

    //  If we don't have a _pWindow, the markup will not be trusted
    // (FerhanE)
    if (_pWindow)
    {
        if (!fProtocolNavigates)
        {
            // restore old src
            hr = S_FALSE;
        }
        else if (!fLocalNavigation)
        {
            hr = _pWindow->Window()->AttachOnloadEvent(pMarkup);
            if (hr)
                goto Cleanup;

            hr = THR(SetViewSlave(_pWindow->Markup()->Root()));
            if (hr)
                goto Cleanup;

            if( pMarkup->IsPrintMedia() )
            {
                bstrMedia = SysAllocString( _T("print") );

                Assert( _pWindow->Document() );

                IGNORE_HR( _pWindow->Document()->putMediaHelper( bstrMedia ) );
            }
            else if (pMarkup->IsPrintTemplate())
            {
                Assert( _pWindow->Document() && _pWindow->Document()->Markup() );

                CMarkup * pSlaveMarkup = _pWindow->Document()->Markup();
                if (!pSlaveMarkup->IsPrintTemplateExplicit())
                    pSlaveMarkup->SetPrintTemplate(TRUE);
            }

            // set the _fTrusted on the new window.
            if (pDoc->IsHostedInHTA() || pDoc->_fInTrustedHTMLDlg)
            {
                // the trust flag on the frame tag should be set &&
                // the trust flag on the containing markup should be set

                // BUBBUG(sramani) Don't need to check IsMarkupTrusted() anymore
                // as _fTrustedFrame implies it now. Infact there is no need to 
                // SetMarkupTrusted again here, as we already do so in DoNavigate
                // But I am leaving this here for now just to be on the safe side.
                BOOL fTrust = _fTrustedFrame && pMarkup->IsMarkupTrusted();

                _pWindow->Markup()->SetMarkupTrusted(fTrust);

                // For frames cases, the markup is created and the ensure window 
                // is called within the DoNavigate(). We have no knowledge of the 
                // _fTrustedFrame flag there, so we set the flag on the markup above.
                // Since the proxy flag _fTrustedDoc is also dependent on the markup's flag _fTrusted,
                // we have to make sure that we are updating that flag here.
                _pWindow->_fTrustedDoc = !!fTrust;
            }
                           
            pMarkup->_fHasFrames = TRUE;
        }
    }

    _fHaveCalledOnPropertyChange_Src = TRUE;
    
Cleanup:
    ReleaseInterface(pStmHistory);
    SysFreeString(bstrMedia);

    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange_Scrolling
//
//  Note:       Called after scrolling property has changed
//
//-------------------------------------------------------------------------

HRESULT
CFrameSite::OnPropertyChange_Scrolling()
{
    HRESULT hr = S_OK;

    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange_NoResize
//
//  Note:       Called after NoResize property has changed
//
//-------------------------------------------------------------------------

HRESULT
CFrameSite::OnPropertyChange_NoResize()
{
    HRESULT hr = S_OK;

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSite::GetIPrintObject
//
//  Note:       drills into WebBrowser control to get
//              the IPrint-supporter living there
//
//-------------------------------------------------------------------------
HRESULT
CFrameSite::GetIPrintObject(IPrint ** ppPrint)
{
    HRESULT     hr       = E_FAIL;
    IDispatch * pDispDoc = NULL;

    if (!ppPrint)
        RRETURN(E_POINTER);

    *ppPrint = NULL;

    if (!_pWindow)
        RRETURN(E_FAIL);

    if (!_pWindow->Window()->_punkViewLinkedWebOC)
        goto Cleanup;
    
    hr = GetWebOCDocument(_pWindow->Window()->_punkViewLinkedWebOC, &pDispDoc);
    if (hr)
        goto Cleanup;

    hr = pDispDoc->QueryInterface(IID_IPrint, (void **) ppPrint);

Cleanup:
    ReleaseInterface(pDispDoc);

    // Don't RRETURN because in most cases, we won't find an IPrint interface.
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSite::GetCurrentFrameURL
//
//  Note:       drills into WebBrowser control to get
//              the URL of the current html or external doc living there
//
//-------------------------------------------------------------------------

HRESULT
CFrameSite::GetCurrentFrameURL(TCHAR *pchUrl, DWORD cchUrl)
{
    CMarkup * pMarkupMaster = GetMarkup();
    CMarkup * pMarkupSlave = NULL;
    HRESULT hr = S_FALSE;
    DWORD cchTemp;
    const TCHAR * pchUrlBase = NULL;

    if (cchUrl)
        *pchUrl = _T('\0');

    if (_pWindow && _pWindow->Window())
        pMarkupSlave = _pWindow->Window()->_pMarkup;

    if (!pMarkupSlave)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    // Get the base URL
    if (pMarkupMaster->HasUrl())
        pchUrlBase = pMarkupMaster->Url();
    if (!pchUrlBase)
        pchUrlBase = _T("");

    hr = THR(CoInternetCombineUrl( pchUrlBase,
                                   pMarkupSlave->GetUrl( pMarkupSlave ),
                                   URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE,
                                   pchUrl, cchUrl, &cchTemp, 0));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN1 (hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSite::get_contentWindow
//
//-------------------------------------------------------------------------

HRESULT
CFrameSite::get_contentWindow(IHTMLWindow2 ** ppOut)
{
    HRESULT             hr;
    COmWindowProxy *    pWindow = NULL;
    CMarkup *           pMarkup = NULL;

    if (!ppOut)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    if (!_pWindow)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    *ppOut = NULL;

    // Secure the inner window of the framesite in the context of the 
    // window that contains the frame tag.

    pMarkup = GetMarkup();

    if (pMarkup)
    {
        // get the window that contains the page with the frame tag for this site.
        pWindow = pMarkup->Window();

        // In case framesite resides in an htc context, we need to get the window
        // that owns the page with the HTC.
        if (!pWindow)
        {
            pWindow = pMarkup->GetNearestMarkupForScriptCollection()->Window();
        }

        if (pWindow)
        {
            CVariant varIn(VT_DISPATCH);
            CVariant varOut(VT_DISPATCH);
            COmWindowProxy * pOmWindowProxy = NULL;

            if (_pWindow->Window()->_punkViewLinkedWebOC)
            {
                pOmWindowProxy = _pWindow->Window()->GetInnerWindow();
            }
            if (!pOmWindowProxy)
                pOmWindowProxy = _pWindow;

            V_DISPATCH(&varIn) = (IHTMLWindow2 *) pOmWindowProxy;
            pOmWindowProxy->AddRef();

            hr = pWindow->SecureObject(&varIn,
                                       &varOut,
                                       NULL,
                                       this);

            if (!hr && V_DISPATCH(&varOut))
            {
                *ppOut = ((IHTMLWindow2 *)V_DISPATCH(&varOut));
                (*ppOut)->AddRef();
            }

            goto Cleanup;
        }
    }
    
    hr = E_FAIL;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     CFrameSite::GetCWindow
//
//  Note:       Returns the CWindow of the doc living inside the framesite
//              THIS IS NOT A SECURE OBJECT AT ALL ! ! !
//
//-------------------------------------------------------------------------

HRESULT
CFrameSite::GetCWindow(IHTMLWindow2 ** ppOmWindow)
{
    *ppOmWindow = NULL;

    if (_pWindow)
    {
        IHTMLWindow2 * pWindow = _pWindow->_pWindow;

        Assert(_pWindow->_pWindow);

        if (_pWindow->Window()->_punkViewLinkedWebOC)
        {
            COmWindowProxy * pOmWindowProxy = _pWindow->Window()->GetInnerWindow();

            if (pOmWindowProxy)
                pWindow = pOmWindowProxy->_pWindow;
        }

        RRETURN(pWindow->QueryInterface(IID_IHTMLWindow2, (void **)ppOmWindow));
    }

    return E_FAIL;
}


//+----------------------------------------------------------------------------
//
// Member:    CFrameSite::VerifyReadyState
//
//-----------------------------------------------------------------------------
#if DBG==1

ExternTag(tagReadystateAssert);

void
CFrameSite::VerifyReadyState(LONG lReadyState)
{
    Assert(0);
}
#endif

void
CFrameSite::SetFrameData()
{
    // deferred until we are in the primary markup
    if (_fDeferredCreate)
        return;

    if (HasSlavePtr())
    {
        CMarkup *   pMarkup         = GetSlavePtr()->GetMarkup();
        DWORD       dwFlags         = pMarkup->GetFrameOptions();
        DWORD       dwFlagScroll    = (DWORD) GetAAscrolling();
        CDoc  *     pDoc            = Doc();
        CUnitValue  puvHeight       = GetAAmarginHeight();
        CUnitValue  puvWidth        = GetAAmarginWidth();
        long        iExtra          = CFrameSetSite::iPixelFrameHighlightWidth;
   
        // If GetAAscrolling() does not contain FRAMEOPTIONS_SCROLL_NO
        // default option contains FRAMEOPTIONS_SCROLL_AUTO,
        // In both cases, always contains FRAMEOPTIONS_NORESIZE
        //
        if (!pDoc->_fFrameBorderCacheValid && IsInMarkup())
        {
            CElement * pElemClient = GetMarkup()->GetElementClient();

            // don't assume since this could be an IFRAME or a frame as well
            if (pElemClient && pElemClient->Tag() == ETAG_FRAMESET)
            {
                DYNCAST(CFrameSetSite, pElemClient)->FrameBorderAttribute(TRUE, FALSE);
                pDoc->_fFrameBorderCacheValid = TRUE;
            }
        }

        if (dwFlagScroll & FRAMEOPTIONS_SCROLL_NO)
        {
            dwFlags |= FRAMEOPTIONS_NORESIZE
                    |  (_fFrameBorder ? 0 : FRAMEOPTIONS_NO3DBORDER)
                    |  dwFlagScroll;
        }
        else
        {
            dwFlags |= FRAMEOPTIONS_SCROLL_AUTO
                    |  FRAMEOPTIONS_NORESIZE
                    |  (_fFrameBorder ? 0 : FRAMEOPTIONS_NO3DBORDER)
                    |  dwFlagScroll;
        }

        pMarkup->SetFrameOptions(dwFlags);

        // if we have only one of (marginWidth, marginHeight) defined,
        // use 0 for the other. This is for Netscape compability.
        //

        _dwWidth  = (!puvWidth.IsNull())
                  ? max(iExtra, puvWidth.GetPixelValue())
                  : ((!puvHeight.IsNull()) ? 0 : -1);
        _dwHeight = (!puvHeight.IsNull())
                  ? max(iExtra, puvHeight.GetPixelValue())
                  : ((!puvWidth.IsNull()) ? 0 : -1);

        IGNORE_HR(_pWindow->put_name(const_cast<BSTR>(GetAAname())));
    }
}

#ifndef NO_DATABINDING
class CDBindMethodsFrame : public CDBindMethodsSimple
{
    typedef CDBindMethodsSimple super;

public:
    CDBindMethodsFrame() : super(VT_BSTR, DBIND_ONEWAY) {}
    ~CDBindMethodsFrame()   {}

    virtual HRESULT BoundValueToElement(CElement *pElem, LONG id,
                                        BOOL fHTML, LPVOID pvData) const;

};

static const CDBindMethodsFrame DBindMethodsFrame;

const CDBindMethods *
CFrameSite::GetDBindMethods()
{
    Assert(Tag() == ETAG_FRAME || Tag() == ETAG_IFRAME);
    return &DBindMethodsFrame;
}

//+----------------------------------------------------------------------------
//
//  Function: BoundValueToElement, CDBindMethods
//
//  Synopsis: Transfer data into bound image.  Only called if DBindKind
//            allows databinding.
//
//  Arguments:
//            [pvData]  - pointer to data to transfer, in this case a bstr.
//
//-----------------------------------------------------------------------------
HRESULT
CDBindMethodsFrame::BoundValueToElement(CElement *pElem,
                                        LONG,
                                        BOOL,
                                        LPVOID pvData) const
{
    RRETURN(DYNCAST(CFrameSite, pElem)->put_UrlHelper(*(BSTR *)pvData, (PROPERTYDESC *)&s_propdescCFrameSitesrc));
}
#endif // ndef NO_DATABINDING




HRESULT
CFrameSite::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    BOOL    fSaveToTempFile = FALSE;
    CDoc *  pDoc = Doc();
    BOOL    fSaveTempfileForPrinting = pDoc && pDoc->_fSaveTempfileForPrinting;
    TCHAR   achTempBuffer[pdlUrlLen];
    TCHAR   achTempLocation[pdlUrlLen];
    LPCTSTR pstrSrc = NULL;
    HRESULT hr;
    
    if (fSaveTempfileForPrinting && !fEnd)
    {
        if (_pWindow && _pWindow->Window()->_punkViewLinkedWebOC)
        {
            IDispatch   * pDispDoc      = NULL;
            CMarkup     * pMarkupSlave  = NULL;

            // (104758) (greglett)
            // XML documnents are a webOC'd subinstance of Trident.
            // We need to drill into them to persist their current state. 
            // Should XML ever cease to be a nested WebOC, we can do away with this.
            if (    (GetWebOCDocument(_pWindow->Window()->_punkViewLinkedWebOC, &pDispDoc) == S_OK)
                &&  (pDispDoc->QueryInterface(CLSID_CMarkup, (void **) &pMarkupSlave) == S_OK)               )
            {                        
                Assert(pMarkupSlave);
                pMarkupSlave->Doc()->SaveToTempFile(pMarkupSlave->Document(), achTempLocation, NULL);                
            }
            
            // We use the IPrint interface for an unrecognized/default webOC.
            // To work around an UrlMon / Word97 bug (43440) where the Word document disappears from the browse doc whenever someone
            // else binds to it we don't persist webOC objects; instead we persist a "Cannot be previewed" document and come back for
            // to get the IPrint when we print. (greglett)

            // For IFRAMEs, pretend that they're blank (52158)
            else if (Tag() == ETAG_IFRAME)
                _tcscpy(achTempLocation, _T("about:blank"));
            
            // For FRAMES, persist a cannot be previewed resource.
            else
                _tcscpy(achTempLocation, _T("res://SHDOCLC.DLL/printnof.htm"));
            
            ReleaseInterface(pDispDoc);
            hr = S_OK;
        }
        else
        {        
            CMarkup * pMarkup = _pWindow ? _pWindow->Markup() : NULL;

            if( pMarkup && pMarkup->GetReadyState() >= READYSTATE_LOADED )
            {
                Assert(ARRAY_SIZE(achTempLocation) > MAX_PATH + 7);

                _tcscpy(achTempLocation, _T("file://"));

                // Obtain a temporary file name
                if (!pDoc->GetTempFilename(_T("\0"), _T("htm"), ((TCHAR *)achTempLocation)+7 ))
                    goto DontCreateTempfile;

                hr = THR( pMarkup->Save(((TCHAR *)achTempLocation)+7, FALSE) );

            }
            else
            {
                hr = THR( GetCurrentFrameURL(achTempLocation, ARRAY_SIZE(achTempLocation) ));
            }

        }

        if (!hr)
        {
            // remember original src.
            pstrSrc = GetAAsrc();

            if ( pstrSrc )
            {
                _tcscpy(achTempBuffer, GetAAsrc());
                pstrSrc = achTempBuffer;
            }

            hr = THR( SetAAsrc(achTempLocation) );

            fSaveToTempFile = TRUE;
        }
    }

DontCreateTempfile:

    hr = THR( super::Save(pStreamWrBuff, fEnd) );

    if (fSaveToTempFile)
    {
        IGNORE_HR( SetAAsrc(pstrSrc) );
    }

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CFrameSite::Exec
//
//  Synopsis:   Called to execute a given command.  If the command is not
//              consumed, it may be routed to other objects on the routing
//              chain.
//
//--------------------------------------------------------------------------

HRESULT
CFrameSite::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    Assert(IsCmdGroupSupported(pguidCmdGroup));

    UINT    idm;
    CDoc *pDoc = Doc();
    HRESULT hr = OLECMDERR_E_NOTSUPPORTED;
    IServiceProvider *pSrvProvider = NULL;
    IDispatch *pCaller = NULL;
    IUnknown *  pUnk = NULL;
    CDocument *pInvokeContextDoc = NULL;

    //
    // default processing
    //

    idm = IDMFromCmdID(pguidCmdGroup, nCmdID);

    if (!pguidCmdGroup || IsEqualGUID(CGID_MSHTML, *pguidCmdGroup))
    {
        COmWindowProxy *pWindow;
        AAINDEX     aaindex;
        BOOL fClipboardAccessNotAllowed = FALSE;

        if (!_pWindow)
            goto Cleanup;

        Assert(GetMarkup());
        pWindow = GetMarkup()->Window();
        Assert(pWindow);
        Assert(pWindow->Window() == _pWindow->Window()->_pWindowParent);

        // Bug 27773: When we check to see if we're in script we can't just check IsInScript() on
        // the window.  Simple way is to walk up window parent chain to check IsInScript().  However
        // this does not work for TriEdit controls, so we need to get the caller from IServiceProvider,
        // which should be the calling window, and we can check IsInScript() on that.
        
        aaindex = FindAAIndex(DISPID_INTERNAL_INVOKECONTEXT, CAttrValue::AA_Internal);
        if (aaindex != AA_IDX_UNKNOWN)
        {
            hr = THR( GetUnknownObjectAt(aaindex, &pUnk) );
            if FAILED(hr)
                goto Cleanup;

            Assert(pUnk);
            if (pUnk)
            {
                hr = THR( pUnk->QueryInterface(IID_IServiceProvider, (void **)&pSrvProvider) );
                if (FAILED(hr))
                    goto Cleanup;
            }
            
            Assert(pSrvProvider);
            if (pSrvProvider)
            {
                hr = THR( GetCallerIDispatch(pSrvProvider, &pCaller) );
                if (FAILED(hr))
                {            
                    goto Cleanup;
                }
            }

            Assert(pCaller || g_fInMshtmpad);
            if (pCaller)
            {
                // We know from checks above that we are in script.  We'll call AccessAllowed
                // to do a final security check to see whether the pCaller (the script caller)
                // has access to the _pWindow.

                if (!_pWindow->AccessAllowed(pCaller))
                {
                    fClipboardAccessNotAllowed = TRUE;
                }
            }
        }
        else
        {
            // There may be cases where we aren't provided a service provider.  We'll take an extra step here to
            // check for cross domain access.  We'll take two steps here:
            //
            // 1. See if we were called through CDocument::InvokeEx.  Script engines, and other late bound callers,
            // will call us through Inovoke or InvokeEx with a null service provider.  We'll only perform the additional
            // check if this is the case so that we don't do this check for binary callers.  Possible badness here for
            // binary late bound callers that are not script engines.
            // 2. We cached the invoke context document on the element (us) and we'll compare the markup of this
            // context document with the markup of this frame.
            
            THREADSTATE *pts = GetThreadState();
            if (pts && pts->fCalledFromDocumentInvokeEx)
            {
                // Ok we were called through InvokeEx, let's check for cross domain access.
                
                aaindex = FindAAIndex(DISPID_INTERNAL_INVOKECONTEXTDOCUMENT, CAttrValue::AA_Internal);
                if (aaindex != AA_IDX_UNKNOWN)
                {
                    CMarkup *pThisMarkup = NULL;
                    CMarkup *pInvokeContextMarkup = NULL;
                    
                    if FAILED(GetPointerAt(aaindex, (void **)&pInvokeContextDoc))
                        goto Cleanup;

                    pThisMarkup = _pWindow->Markup();
                    pInvokeContextMarkup = pInvokeContextDoc->Markup();

                    if (pThisMarkup && pInvokeContextMarkup && !pThisMarkup->AccessAllowed(pInvokeContextMarkup))
                    {
                        fClipboardAccessNotAllowed = TRUE;
                    }
                }
            }
        }

        if (fClipboardAccessNotAllowed)
        {
            OPTIONSETTINGS *pos = pDoc->_pOptionSettings;
        
            if ((idm == IDM_PASTE || idm == IDM_CUT || idm == IDM_COPY) && (pos && pos->fAllowCutCopyPaste)) 
                goto AllowExec;

            hr = E_ACCESSDENIED;
            goto Cleanup;
        }

AllowExec:
        // If we are a site selected, then don't delegate the command to the iframe.  The
        // editor will handle it at a higher level

        if (IsSiteSelected())
        {
            hr = OLECMDERR_E_NOTSUPPORTED;
            goto Cleanup;
        }

        // If this assertion fails, that means CFrameSite can represent elements other than
        // ETAG_FRAME and ETAG_IFRAME.  Look in CDoc::ExecHelper for the case IDM_SAVEAS, see
        // what tags we're checking to defer Exec.  Based on that either change the assertion
        // or add the condition to the if statement that follows this assert.
        Assert(Tag() == ETAG_FRAME || Tag() == ETAG_IFRAME);

        // Bug fix for 21114 - CDoc::ExecHelper() returns control to its current element.
        // This condition check below prevents the ensuing infinite recursion if this
        // happens to be the current element for the CDoc.
        if (!(this == pDoc->_pElemCurrent && nCmdID == OLECMDID_SAVEAS))
        // Call Exec on the content document of this frame's window
        // (but don't honor CDoc::_pMenuObject, or we'd get into an infinite loop -- 91870)
        {
            CElement * pMenuObjectOld = pDoc->_pMenuObject;
            CDocument *pContextDoc = _pWindow->Document();
            BOOL      fAddContextToAA = FALSE;
            BOOL      fAddInvokeContextDocToAA = FALSE;

            pDoc->_pMenuObject = NULL;

            aaindex = pContextDoc->FindAAIndex(DISPID_INTERNAL_INVOKECONTEXT, CAttrValue::AA_Internal);
            fAddContextToAA = (aaindex == AA_IDX_UNKNOWN && pUnk);

            aaindex = pContextDoc->FindAAIndex(DISPID_INTERNAL_INVOKECONTEXTDOCUMENT, CAttrValue::AA_Internal);
            fAddInvokeContextDocToAA = (aaindex == AA_IDX_UNKNOWN && pInvokeContextDoc);

            if (fAddContextToAA)
            {
                pContextDoc->AddUnknownObject(
                    DISPID_INTERNAL_INVOKECONTEXT, pUnk, CAttrValue::AA_Internal);
            }

            if (fAddInvokeContextDocToAA)
            {
                pContextDoc->AddPointer(
                    DISPID_INTERNAL_INVOKECONTEXTDOCUMENT, pInvokeContextDoc, CAttrValue::AA_Internal);
            }
            
            hr = THR(pDoc->ExecHelper(pContextDoc, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));

            if (fAddContextToAA)
            {
                pContextDoc->FindAAIndexAndDelete(
                    DISPID_INTERNAL_INVOKECONTEXT, CAttrValue::AA_Internal);
            }

            if (fAddInvokeContextDocToAA)
            {
                pContextDoc->FindAAIndexAndDelete(
                    DISPID_INTERNAL_INVOKECONTEXTDOCUMENT, CAttrValue::AA_Internal);
            }
            
            pDoc->_pMenuObject = pMenuObjectOld;
        }
    }

    if (OLECMDERR_E_NOTSUPPORTED == hr)
        hr = THR(super::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));

Cleanup:
    ReleaseInterface(pSrvProvider);
    ReleaseInterface(pCaller);
    ReleaseInterface(pUnk);
    RRETURN_NOTRACE(hr);
}

HRESULT
CFrameSite::get_readyState(BSTR * p)
{
    if (_pWindow && _pWindow->Document())
        RRETURN(_pWindow->Document()->get_readyState(p));
    else
        RRETURN(SetErrorInfo(E_FAIL));
}

HRESULT
CFrameSite::get_readyState(VARIANT * pVarRes)
{
    HRESULT hr = S_OK;

    if (!pVarRes)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = get_readyState(&V_BSTR(pVarRes));
    if (!hr)
        V_VT(pVarRes) = VT_BSTR;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CFrameSite::GetDispID(BSTR bstrName, DWORD grfdex, DISPID * pid)
{
    HRESULT hr;

    hr = super::GetDispID(bstrName, grfdex, pid);

    Assert(hr || *pid < WEBOC_DISPIDBASE || *pid > WEBOC_DISPIDMAX);

    if (hr)
    {
        hr = GetWebOCDispID(bstrName, (grfdex & fdexNameCaseSensitive), pid);
    }

    RRETURN(hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif
HRESULT
CFrameSite::ContextThunk_InvokeEx (
    DISPID          dispidMember,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pdispparams,
    VARIANT *       pvarResult,
    EXCEPINFO *     pexcepinfo,
    IServiceProvider *pSrvProvider)
{
    HRESULT     hr;
    IUnknown *  pUnkContext;
    IDispatch *pCaller = NULL;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    hr = THR_NOTRACE(super::ContextInvokeEx(dispidMember,
                                            lcid,
                                            wFlags,
                                            pdispparams,
                                            pvarResult,
                                            pexcepinfo,
                                            pSrvProvider,
                                            pUnkContext ? pUnkContext : (IUnknown*)this));

    if (    hr
        &&  _pWindow
//        &&  dispidMember >= WEBOC_DISPIDBASE
//        &&  dispidMember <= WEBOC_DISPIDMAX
       )
    {
        hr = E_ACCESSDENIED;
        if (pSrvProvider)
        {
            if (FAILED(GetCallerIDispatch(pSrvProvider, &pCaller)))
            {            
                goto Cleanup;
            }
        }
        else
        {
            pCaller = GetWindowedMarkupContext() ? (IDispatch *)(IHTMLWindow2 *)GetWindowedMarkupContext()->Window() : NULL;
            if (pCaller)
            {
                pCaller->AddRef();
            }
        }

        if (pCaller && _pWindow->AccessAllowed(pCaller))
        {
            hr = _pWindow->Window()->EnsureFrameWebOC();
            if (hr)
                goto Cleanup;

            hr = InvokeWebOC(_pWindow->Window()->_pFrameWebOC, dispidMember, lcid,
                             wFlags, pdispparams, pvarResult, pexcepinfo, pSrvProvider);
        }
    }

Cleanup:
    ReleaseInterface(pCaller);
    RRETURN(hr);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif

BOOL
CFrameSite::IsSiteSelected()
{
    HRESULT         hr;
    BOOL            fIsSiteSelected = FALSE;
    ISegmentList    *pISegmentList = NULL;  
    IElementSegment *pIElementSegment = NULL;
    IHTMLElement    *pIElement = NULL;
    CElement        *pElement;
    ISegmentListIterator *pIter = NULL;
    ISegment        *pISegment = NULL;
    
    if (Doc()->GetSelectionType() != SELECTION_TYPE_Control)
        goto Cleanup;
    
    hr = THR(Doc()->GetCurrentSelectionSegmentList(&pISegmentList));
    if (hr)
        goto Cleanup;

    Assert(pISegmentList);


    hr = THR( pISegmentList->CreateIterator(&pIter) );
    if( hr )
        goto Cleanup;

    while( pIter->IsDone() == S_FALSE )
    {    
        hr = THR(pIter->Current(&pISegment) );
        if (hr)
            goto Cleanup;

        hr = THR(pISegment->QueryInterface(IID_IElementSegment, (void**)&pIElementSegment));
        if (hr)
            goto Cleanup;
            
        hr = THR(pIElementSegment->GetElement(&pIElement));
        if (hr)
            goto Cleanup;                

        if (!pIElement)
            goto Cleanup;
        
        hr = THR(pIElement->QueryInterface(CLSID_CElement, (void**)&pElement));
        if (hr)
            goto Cleanup;

        fIsSiteSelected = (pElement == this);
        if (fIsSiteSelected)
            goto Cleanup;

        ClearInterface(&pISegment);
        ClearInterface(&pIElementSegment);
        ClearInterface(&pIElement);

        hr = THR(pIter->Advance());
        if( hr )
            goto Cleanup;
    }


Cleanup:
    ReleaseInterface(pISegmentList);            
    ReleaseInterface(pIElementSegment);
    ReleaseInterface(pIElement);
    ReleaseInterface(pIter);
    ReleaseInterface(pISegment);

    return fIsSiteSelected;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\ole\olebindh.cxx ===
#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_PRGSNK_H_
#define X_PRGSNK_H_
#include <prgsnk.h>
#endif

ExternTag(tagOleSiteClient);

MtDefine(CProgressBindStatusCallback, Dwn, "CProgressBindStatusCallback")

//+---------------------------------------------------------------------------
//
//  Member:     CLock::CLock
//
//  Synopsis:   ctor/dtor
//
//----------------------------------------------------------------------------

CProgressBindStatusCallback::CLock::CLock(CProgressBindStatusCallback *pBSC)
{
    _pBSC = pBSC;
    _pBSC->AddRef();
}


CProgressBindStatusCallback::CLock::~CLock()
{
    _pBSC->Release();
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::CProgressBindStatusCallback
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CProgressBindStatusCallback::CProgressBindStatusCallback()
{
    _ulRefs = 1;
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::~CProgressBindStatusCallback
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CProgressBindStatusCallback::~CProgressBindStatusCallback()
{
    if (_dwProgCookie)
    {
        Assert( _pProgSink );
        _pProgSink->DelProgress(_dwProgCookie);
    }

    if (_pMarkup)
    {
        _pMarkup->SubRelease();
    }
    ReleaseInterface(_pProgSink);
    ReleaseInterface(_pBSCChain);
    ReleaseInterface(_pBCtx);
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::Init
//
//  Synopsis:   initializer
//
//----------------------------------------------------------------------------

HRESULT
CProgressBindStatusCallback::Init(
    CMarkup *               pMarkup, 
    DWORD                   dwCompatFlags,
    IBindStatusCallback *   pBSCChain,
    IBindCtx *              pBCtx)
{
    HRESULT hr = S_OK;

    Assert( pMarkup );
    if (!pMarkup->GetDwnDoc())
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    _pMarkup = pMarkup;
    _pMarkup->SubAddRef();
    
    _dwCompatFlags = dwCompatFlags;
    _dwBindf = pMarkup->GetDwnDoc()->GetBindf();
    
    ReplaceInterface(&_pBCtx, pBCtx);
    ReplaceInterface(&_pBSCChain, pBSCChain);
    
    _pProgSink = CMarkup::GetProgSinkHelper(pMarkup);
    if( _pProgSink )
    {
        _pProgSink->AddRef();
    
        //
        // If we failed to add this to the progress loader, it's ok to
        // continue loading.
        //
    
        IGNORE_HR(_pProgSink->AddProgress(PROGSINK_CLASS_OTHER, &_dwProgCookie));
    }

Cleanup:
    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::Terminate
//
//  Synopsis:   Kills the download.
//
//----------------------------------------------------------------------------

void
CProgressBindStatusCallback::Terminate()
{
    CLock   Lock(this);

    if (_pBinding)
    {
        _pBinding->Abort();
    }
    ClearInterface(&_pBinding);
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::QueryInterface
//
//  Synopsis:   per IUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgressBindStatusCallback::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;
    
    if (riid == IID_IUnknown || riid == IID_IBindStatusCallback)
    {
        *ppv = (IBindStatusCallback *)this;
    }
    else if (riid == IID_IServiceProvider)
    {
        *ppv = (IServiceProvider *)this;        
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    
    RRETURN(E_NOINTERFACE);
}


STDMETHODIMP
CProgressBindStatusCallback::QueryService(REFGUID guidService, REFIID iid, void ** ppv)
{
    HRESULT hr = E_NOINTERFACE;

    *ppv = NULL;
    IServiceProvider *pServiceProvider = NULL;

    // The CProgressBindStatusCallback doesn't have any interesting service to
    // offer here (yet), but our client might.
    if (_pBSCChain)
    {
        hr = _pBSCChain->QueryInterface(IID_IServiceProvider,
                                        (void **)&pServiceProvider);
        if (S_OK == hr)
        {
            hr = pServiceProvider->QueryService(guidService, iid, ppv);
        }
        ReleaseInterface(pServiceProvider);
    }

    if( FAILED( hr ) && _pMarkup)
    {
        CDocument * pDocument;

        // Try the CDocument and the CDoc.  
        // This is here specifically so that javascript:
        // URLs will work from plugins.  This also provides handy
        // connectivity that may be useful elsewhere.
        // Since CDocument delegates to CDoc if it does not handle the
        // guidService, we don't have to have additional logic here.

        hr = _pMarkup->EnsureDocument(&pDocument);
        if (hr)
            goto Cleanup;

        Assert(pDocument);

        hr = pDocument->QueryService(guidService, iid, ppv);
    }

Cleanup:
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::OnStartBinding
//
//  Synopsis:   per IBindStatusCallback
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgressBindStatusCallback::OnStartBinding(
    DWORD dwReserved, 
    IBinding *pBinding)
{
    ReplaceInterface(&_pBinding, pBinding);

    IGNORE_HR(pBinding->SetPriority(THREAD_PRIORITY_BELOW_NORMAL));

    RRETURN(_pBSCChain ? 
        THR(_pBSCChain->OnStartBinding(dwReserved, pBinding)) :
        S_OK);
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::GetPriority
//
//  Synopsis:   per IBindStatusCallback
//
//----------------------------------------------------------------------------

STDMETHODIMP        
CProgressBindStatusCallback::GetPriority(LONG *pnPriority)
{
    RRETURN(_pBSCChain ? 
        THR(_pBSCChain->GetPriority(pnPriority)) :
        S_OK);
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::OnLowResource
//
//  Synopsis:   per IBindStatusCallback
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgressBindStatusCallback::OnLowResource(DWORD dwReserved)
{
    RRETURN(_pBSCChain ? 
        THR(_pBSCChain->OnLowResource(dwReserved)) :
        S_OK);
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::OnProgress
//
//  Synopsis:   per IBindStatusCallback
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgressBindStatusCallback::OnProgress(
    ULONG   ulProgress,
    ULONG   ulProgressMax,
    ULONG   ulStatusCode,
    LPCWSTR szStatusText)
{
    HRESULT hr = S_OK;
    
    if ((ulStatusCode == BINDSTATUS_REDIRECTING) &&  
        (_dwCompatFlags & COMPAT_SECURITYCHECKONREDIRECT) &&
        _pMarkup && !_pMarkup->AccessAllowed(szStatusText))
    {
        static const IID IID_IAmTheTDC = {0x3050f6c2,0x98b5,0x11cf,{0xbb,0x82,0x00,0xaa,0x00,0xbd,0xce,0x0b}};
        IUnknown *pTDC;
        if (_pBSCChain && S_OK == _pBSCChain->QueryInterface(IID_IAmTheTDC, (void**)&pTDC))
        {
            // bug 85290 - TDC control handles its own cross-domain security,
            // so downloads on its behalf should not be aborted
            ReleaseInterface(pTDC);
        }
        else
        {
            if (_pBinding)
                _pBinding->Abort();
            _fAbort = TRUE;
        }
    }

    if (_dwProgCookie && ulStatusCode == BINDSTATUS_DOWNLOADINGDATA)
    {
        Assert( _pProgSink );
        hr = THR(_pProgSink->SetProgress( 
                _dwProgCookie, 
                PROGSINK_SET_STATE | PROGSINK_SET_POS | PROGSINK_SET_MAX | PROGSINK_SET_TEXT,
                PROGSINK_STATE_LOADING, 
                szStatusText,
                0,
                ulProgress, 
                ulProgressMax));
        if (hr)
            goto Cleanup;
    }

    if (_pBSCChain)
    {
        hr = THR(_pBSCChain->OnProgress(
                ulProgress, 
                ulProgressMax, 
                ulStatusCode, 
                szStatusText));
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::OnStopBinding
//
//  Synopsis:   per IBindStatusCallback
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgressBindStatusCallback::OnStopBinding(HRESULT hresult, LPCWSTR szError)
{
    HRESULT hr;
    
    CLock   Lock(this);

    ClearInterface(&_pBinding);
    if (_pMarkup && _pMarkup->Doc())
    {
        _pMarkup->Doc()->_aryChildDownloads.DeleteByValue(this);
    }
    
    hr = _pBSCChain ? 
        THR(_pBSCChain->OnStopBinding(hresult, szError)) :
        S_OK;
    if (hr)
        goto Cleanup;

    hr = THR(RevokeBindStatusCallback(_pBCtx, this));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::GetBindInfo
//
//  Synopsis:   per IBindStatusCallback
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgressBindStatusCallback::GetBindInfo(DWORD *grfBINDF, BINDINFO *pbindinfo)
{
    HRESULT     hr = S_OK;
    
    if (!pbindinfo)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // Prime the BINDF flags from our Doc's bind ctx flags.  This informs the 
    // object what BINDF we are using.
    *grfBINDF |= _dwBindf; 

    if (_pBSCChain)
    {
        hr = THR(_pBSCChain->GetBindInfo(grfBINDF,pbindinfo));
        if (hr)
            goto Cleanup;
            
        if (_dwCompatFlags & COMPAT_NO_BINDF_OFFLINEOPERATION)
        {
            //
            // The powerpoint animation viewer always passes in offline 
            // operation.  Obviously this will fail if the requested file
            // is not available in the cache.
            //
            
            *grfBINDF &= ~BINDF_OFFLINEOPERATION;
        }

        // Reapply our BINDF flags just in case they cleared any out.
        *grfBINDF |= _dwBindf; 
    
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::OnDataAvailable
//
//  Synopsis:   per IBindStatusCallback
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgressBindStatusCallback::OnDataAvailable(
    DWORD grfBSCF,
    DWORD dwSize,
    FORMATETC *pformatetc,
    STGMEDIUM *pstgmed)
{
    RRETURN1(_pBSCChain && !_fAbort ? 
        THR(_pBSCChain->OnDataAvailable(grfBSCF, dwSize, pformatetc, pstgmed)) :
        S_OK, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressBindStatusCallback::OnObjectAvailable
//
//  Synopsis:   per IBindStatusCallback
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgressBindStatusCallback::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    RRETURN(_pBSCChain ? 
        THR(_pBSCChain->OnObjectAvailable(riid, punk)) :
        S_OK);
}



//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::CreateMoniker, IBindHost
//
//  Synopsis:   Parses display name and returns a URL moniker
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::CreateMoniker(LPOLESTR szName, IBindCtx * pbc, IMoniker ** ppmk, DWORD dwReserved)
{
    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED|VALIDATE_DOC_ALIVE))
        RRETURN(E_UNEXPECTED);

    TCHAR       cBuf[pdlUrlLen];
    TCHAR *     pchUrl = cBuf;
    HRESULT     hr;

    hr = THR(CMarkup::ExpandUrl(
            MyOleSite()->IsInMarkup() ? MyOleSite()->GetMarkup()->GetFrameOrPrimaryMarkup() : NULL,
                szName, ARRAY_SIZE(cBuf), pchUrl, MyOleSite()));
    if (hr)
        goto Cleanup;

    TraceTag((tagOleSiteClient, 
        "COleSite::CClient::CreateMoniker SSN=0x%x url=%ls", 
        MyOleSite()->_ulSSN,
        pchUrl));

    hr = THR(CreateURLMoniker(NULL, pchUrl, ppmk));
    if (hr)
        goto Cleanup;
        
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   MonikerBind
//
//  Synopsis:   Helper routine contains the common code for BindToObject() and
//              BindToStorage().
//
//----------------------------------------------------------------------------

HRESULT
MonikerBind(
    CMarkup *               pMarkup,
    IMoniker *              pmk, 
    IBindCtx *              pbc,
    IBindStatusCallback *   pbsc, 
    REFIID                  riid, 
    void **                 ppv,
    BOOL                    fObject,
    DWORD                   dwCompatFlags)
{
    IBindCtx *                      pbcNew = NULL;
    CProgressBindStatusCallback *   pBSCWrap = NULL;
    HRESULT                         hr = S_OK;

    Assert( pMarkup );

    if (!pbc)
    {
        hr = THR(CreateAsyncBindCtxEx(NULL, 0, NULL, NULL, &pbcNew, 0));
        if (hr)
            goto Cleanup;

        pbc = pbcNew;
    }

    //
    // Create a wrapper bsc which will update our status bar appropriately.
    //
    
    pBSCWrap = new CProgressBindStatusCallback;
    if (!pBSCWrap)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pBSCWrap->Init(
            pMarkup, 
            dwCompatFlags,
            pbsc,
            pbc));
    if (hr)
        goto Cleanup;

    //
    // Register our wrapper bsc into the bind ctx.  This addrefs
    // the bscwrap.  
    //

    hr = THR(RegisterBindStatusCallback(pbc, pBSCWrap, NULL, NULL));
    if (!OK(hr))
        goto Cleanup;
    
    // Add pBSCWrap to the _aryChildDownloads.  If the bind
    // ends up happening synchronous, then it will be removed
    // further down the stack.
    IGNORE_HR(pMarkup->Doc()->_aryChildDownloads.Append(pBSCWrap));

    hr = fObject ? 
        THR(pmk->BindToObject(pbc, NULL, riid, ppv)) :
        THR(pmk->BindToStorage(pbc, NULL, riid, ppv));
    if (!OK(hr))
        goto Cleanup;
        
Cleanup:
    ReleaseInterface(pbcNew);

    if (hr != S_ASYNCHRONOUS)
    {
        pMarkup->Doc()->_aryChildDownloads.DeleteByValue(pBSCWrap);
    }
    
    if (pBSCWrap)
    {
        pBSCWrap->Release();
    }
    RRETURN1(hr, S_ASYNCHRONOUS);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::MonikerBindToStorage, IBindHost
//
//  Synopsis:   Calls BindToStorage on the moniker
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::MonikerBindToStorage(
    IMoniker * pmk, 
    IBindCtx * pbc,
    IBindStatusCallback * pbsc, 
    REFIID riid, 
    void ** ppvObj)
{
    INSTANTCLASSINFO * pici;
    
    TraceTag((tagOleSiteClient, "COleSite::CClient::MonikerBindToStorage SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(
            COleSite::VALIDATE_ATTACHED|COleSite::VALIDATE_DOC_ALIVE))
        RRETURN(E_UNEXPECTED);

    pici = MyOleSite()->GetInstantClassInfo();
    
    RRETURN1(MonikerBind(
        MyOleSite()->GetWindowedMarkupContext(), 
        pmk, 
        pbc, 
        pbsc, 
        riid, 
        ppvObj, 
        FALSE,
        pici ? pici->dwCompatFlags : 0), S_ASYNCHRONOUS);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::MonikerBindToObject, IBindHost
//
//  Synopsis:   Calls BindToObject on the moniker
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::MonikerBindToObject(
    IMoniker * pmk, 
    IBindCtx * pbc,
    IBindStatusCallback * pbsc, 
    REFIID riid, 
    void ** ppvObj)
{
    INSTANTCLASSINFO * pici;
    
    TraceTag((tagOleSiteClient, "COleSite::CClient::MonikerBindToObject SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(
            COleSite::VALIDATE_ATTACHED|COleSite::VALIDATE_DOC_ALIVE))
        RRETURN(E_UNEXPECTED);

    pici = MyOleSite()->GetInstantClassInfo();
    
    RRETURN1(MonikerBind(
        MyOleSite()->GetWindowedMarkupContext(), 
        pmk, 
        pbc, 
        pbsc, 
        riid, 
        ppvObj, 
        TRUE,
        pici ? pici->dwCompatFlags : 0), S_ASYNCHRONOUS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\ole\oleobj.cxx ===
//+------------------------------------------------------------------------
//
//  File:       oleobj.cxx
//
//  Contents:   COleSite::CObject implementation.
//
//
//	History:	
//				5-22-95		kfl		converted WCHAR to TCHAR
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

IMPLEMENT_FORMS_SUBOBJECT_IUNKNOWN(COleSite::CObject, COleSite, _Object)

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CObject::GetDispatch
//
//  Synopsis:   Fetch the IDispatch pointer of the embedded control.
//
//  Returns:    NULL if not available.
//
//----------------------------------------------------------------------------

IDispatch *
COleSite::CObject::GetDispatch()
{
    if (IsMyParentAlive())
    {
        return MyCOleSite()->_pDisp;
    }
    else
    {
        return NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CObject::QueryInterface, IUnknown
//
//  Synopsis:   As per IUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CObject::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IDispatch || iid == IID_IUnknown)
    {
        *ppv = (IDispatch *)this;
    }
    else
    {
        *ppv = 0;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CObject::GetTypeInfoCount, IDispatch
//
//  Synopsis:   As per IDispatch
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CObject::GetTypeInfoCount(UINT * pctinfo)
{
    IDispatch *pDisp = GetDispatch();

    RRETURN(!pDisp ? E_FAIL : pDisp->GetTypeInfoCount(pctinfo));
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CObject::GetIDsOfNames, IDispatch
//
//  Synopsis:   As per IDispatch
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CObject::GetIDsOfNames(
        REFIID          iid,
        LPTSTR *        rgszNames,
        UINT            cNames,
        LCID            lcid,
        DISPID FAR*     rgdispid)
{
    IDispatch *pDisp = GetDispatch();
    RRETURN(!pDisp ? E_FAIL : pDisp->GetIDsOfNames(
            iid,
            rgszNames,
            cNames,
            lcid,
            rgdispid));
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CObject::Invoke, IDispatch
//
//  Synopsis:   As per IDispatch
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CObject::Invoke(
        DISPID          dispidMember,
        REFIID          iid,
        LCID            lcid,
        WORD            wFlags,
        DISPPARAMS *    pdispparams,
        VARIANT *       pvarResult,
        EXCEPINFO *     pexcepinfo,
        UINT *          puArgErr)
{
    IDispatch *pDisp = GetDispatch();
    RRETURN(!pDisp ? E_FAIL : pDisp->Invoke(
            dispidMember,
            iid,
            lcid,
            wFlags,
            pdispparams,
            pvarResult,
            pexcepinfo,
            puArgErr));
}

STDMETHODIMP
COleSite::CObject::GetTypeInfo(
        UINT         itinfo,
        LCID         lcid,
        ITypeInfo ** pptinfo)
{
    IDispatch *pDisp = GetDispatch();
    RRETURN(!pDisp ? E_FAIL : pDisp->GetTypeInfo(
            itinfo,
            lcid,
            pptinfo));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\ole\olecpc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       olecpc.cxx
//
//  Contents:   Connection point container implementation for COleSite.
//
//  History:
//              5-22-95     KFL     stubbed MAC functions/macros ForwardToOutSink and
//                                  SINK_METHOD
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

extern "C" const IID IID_IDATASRCListener;
extern "C" const IID IID_IDatasrcChangeEvents;

//+---------------------------------------------------------------------------
//
//  Member:     COleSiteCPC::COleSiteCPC
//
//  Synopsis:   ctor.  Makes a local copy of the CONNECTION_POINT_INFO,
//              inserting the control's source event interfaces.
//
//  Arguments:  [pOleSite]    -- The site.
//              [pUnkPrivate] -- The private unknown of the control.
//
//----------------------------------------------------------------------------

COleSiteCPC::COleSiteCPC(COleSite *pOleSite, IUnknown *  pUnkPrivate)
        :
        super(pOleSite, NULL)
{
    const CBase::CLASSDESC *        pclassdesc;
    const CONNECTION_POINT_INFO *   pcpi;
    long                            i;

    pclassdesc = pOleSite->BaseDesc();
    
    for (i = 0, pcpi = pclassdesc->_pcpi; pcpi && pcpi->piid; i++, pcpi++)
    {
        _acpi[i].piid = pcpi->piid;
        _acpi[i].dispid = pcpi->dispid;
    }

    //
    // If this assert fires, then the classdescs for things derived from
    // COleSite are messed up. (anandra)
    //
    
    Assert(i == 6 || _acpi[CPI_OFFSET_OLESITECONTROL].piid == NULL);                     
    
    //
    // Assert that the last entry in the acpi array is IID_NULL
    //

    if (_acpi[CPI_OFFSET_OLESITECONTROL].piid)
    {
        Assert(IsEqualIID(IID_NULL, *(_acpi[CPI_OFFSET_OLESITECONTROL].piid)));
        _acpi[CPI_OFFSET_OLESITECONTROL].piid = pOleSite->GetpIIDDispEvent();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::EnsurePrivateSink
//
//  Synopsis:   Ensures that we are sinking events on the control's
//              primary event interface.
//
//----------------------------------------------------------------------------

// after COleSite::EnsureControlSink is executed, COleSiteEventSink OSES, which
// is allocated on stack, goes away. However, the sink is supposed to be alive as
// event will be firing in it, namely using it's vtable. The code below still works
// because the only thing used of OSES is it's vtable pointer, and the object does not
// have any state (data memebers) at all. Should COleSiteEventSink get any state, the code
// below should be changed such that OSES does not go away.

StartupAssert(sizeof(void *) == sizeof(COleSiteEventSink));

void
COleSite::EnsurePrivateSink()
{
    HRESULT             hr = S_OK;
    COleSiteEventSink   OSES;
    DWORD_PTR           dwSink;
    BOOL                fScriptEnabled = FALSE;
    
    // If the control isn't yet created, or if isn't in a markup, don't
    // connect the event sink yet.
	if (!_pUnkCtrl || !IsInMarkup())
		return;

    // If scripting is disabled, don't hook up the private event sink.
    hr = GetMarkupPtr()->ProcessURLAction(URLACTION_SCRIPT_RUN,&fScriptEnabled);

    if (FAILED(hr))
    {
        fScriptEnabled = FALSE;
    }

    if (!fScriptEnabled)
        return;

    SetEventsShouldFire();

    dwSink = *(DWORD_PTR *)&OSES;

    //
    // Assert that either we've not initialized the event sink yet
    // or if we have then the event sink vtable is the same as the old
    // event sink.
    //
    
    Assert(!_dwEventSinkIn || _dwEventSinkIn == dwSink);

    if (_dwEventSinkIn)
        return;
        
    _dwEventSinkIn |= dwSink;

    Assert(_pUnkCtrl);

    hr = THR(ConnectSink(
            _pUnkCtrl,
            *GetpIIDDispEvent(),
            (IUnknown *) &_dwEventSinkIn,
            &_dwEventSinkCookie));

    if (OK(hr))
    {
        _fPrimaryConnection = TRUE;
    }

    if (!OK(hr))
    {
        //
        // Failed with primary iid, try IDispatch.
        //

        hr = THR(ConnectSink(
                _pUnkCtrl,
                IID_IDispatch,
                (IUnknown *) &_dwEventSinkIn,
                &_dwEventSinkCookie));

        if (hr)
            _dwEventSinkIn = 0;
    }
}


//+------------------------------------------------------------------------
//
//  Connection point sinks implementations.
//
//-------------------------------------------------------------------------

IMPLEMENT_FORMS_SUBOBJECT_IUNKNOWN(COleSiteEventSink, COleSite, _dwEventSinkIn)

//+---------------------------------------------------------------------------
//
//  Member:     COleSiteEventSink::QueryInterface
//
//  Synopsis:   Per IUnknown.
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSiteEventSink::QueryInterface(REFIID iid, void ** ppv)
{
    IID* pIIDDispEvent;

    if (ppv)
        *ppv = NULL;

    if (MyCOleSite()->IllegalSiteCall(0))
        RRETURN(E_UNEXPECTED);

    if (!ppv)
        RRETURN(E_INVALIDARG);

    if (iid == IID_IUnknown  ||
        iid == IID_IDispatch)
    {
        *ppv = (IDispatch *) this;
    }
    else
    {
        pIIDDispEvent = MyCOleSite()->GetpIIDDispEvent();
        if (pIIDDispEvent && iid == *pIIDDispEvent)
        {
            *ppv = (IDispatch *) this;
        }
        else
        {
            *ppv = NULL;
            RRETURN_NOTRACE(E_NOINTERFACE);
        }
    }

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:     COleSiteEventSink::Invoke
//
//  Synopsis:   Forwards to the connection point.
//
//----------------------------------------------------------------------------
#if DBG==1
#pragma warning(disable:4189) // local variable initialized but not used 
#endif

STDMETHODIMP
COleSiteEventSink::Invoke(
        DISPID              dispidMember,
        REFIID              riid,
        LCID                lcid,
        WORD                wFlags,
        DISPPARAMS FAR*     pdispparams,
        VARIANT FAR*        pvarResult,
        EXCEPINFO FAR*      pexcepinfo,
        UINT FAR*           puArgErr)
{
    HRESULT         hr = S_OK;
    CMessage        Message(NULL, 0, 0, 0);
    POINT           pt;
    CTreeNode *     pNodeParent;
    ITypeInfo *     pTIEvent;

#if DBG==1
    COleSite *  pMyCOleSiteDbg = MyCOleSite();
#endif

    if (MyCOleSite()->IllegalSiteCall(0))
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if (!MyCOleSite()->IsSafeToScript())
        goto Cleanup;


    //
    // Refire event to any listening sinks out there.  Includes any hooked up
    // function pointers.
    //

    // Find the event name that corresponds to this event (used for fast event hookup).
    pTIEvent = MyCOleSite()->GetClassInfo()->_pTypeInfoEvents;

    IGNORE_HR(MyCOleSite()->InvokeEvent(
        dispidMember,
        dispidMember,
        NULL,
        pvarResult,
        pdispparams,
        pexcepinfo,
        puArgErr,
        pTIEvent));

    //
    // For the standard events, we will recalculate parameters to send
    // because arbitrary objects may use different coordinates than the
    // ones that we want.
    //

    switch (dispidMember)
    {
    case DISPID_CLICK:
    case DISPID_DBLCLICK:
        goto FireStdMessage;

    case DISPID_MOUSEMOVE:
        Message.message = WM_MOUSEMOVE;
        goto FireStdMessage;

    case DISPID_MOUSEDOWN:
        Message.message = 
            (Message.dwKeyState & MK_LBUTTON) ? WM_LBUTTONDOWN :
                (Message.dwKeyState & MK_RBUTTON) ? WM_RBUTTONDOWN : 
                    WM_MBUTTONDOWN;
        goto FireStdMessage;

    case DISPID_MOUSEUP:
        Message.message = 
            (Message.dwKeyState & MK_LBUTTON) ? WM_LBUTTONUP :
                (Message.dwKeyState & MK_RBUTTON) ? WM_RBUTTONUP : 
                    WM_MBUTTONUP;
        goto FireStdMessage;

FireStdMessage:
        hr = THR( Message.SetNodeHit( MyCOleSite()->GetFirstBranch() ) );
        if( hr )
            goto Cleanup;
        GetCursorPos(&pt);
        ScreenToClient(MyCOleSite()->Doc()->_pInPlace->_hwnd, &pt);
        Message.pt = pt;
        Message.wParam = Message.dwKeyState;
        Message.lParam = MAKELPARAM(Message.pt.x, Message.pt.y);

        //
        // Find the first element parent which can fire events
        //
        
        if (MyCOleSite()->GetFirstBranch())
        {
            pNodeParent = MyCOleSite()->GetFirstBranch()->Parent();
        
            if (pNodeParent)
            {
                if (DISPID_CLICK == dispidMember)
                {
                    IGNORE_HR(pNodeParent->Element()->Fire_onclick(pNodeParent));
                }
                else if (DISPID_DBLCLICK == dispidMember)
                {
                    IGNORE_HR(pNodeParent->Element()->Fire_ondblclick(pNodeParent));
                }
                else
                {
                    IGNORE_HR(pNodeParent->Element()->FireStdEventOnMessage(pNodeParent, &Message, pNodeParent));
                }
            }
        }
        break;
    }

Cleanup:
    RRETURN( hr );
}
#if DBG==1
#pragma warning(default:4189) // local variable initialized but not used 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\ole\oleclnt.cxx ===
//+---------------------------------------------------------------------------
//
//   File:      oleclnt.cxx
//
//  Contents:   True client site to embeddings.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include "binder.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_VBCURSOR_OCDB_H_
#define X_VBCURSOR_OCDB_H_
#include <vbcursor/ocdb.h>
#endif

#ifndef X_VBCURSOR_VBDSC_H_
#define X_VBCURSOR_VBDSC_H_
#include <vbcursor/vbdsc.h>
#endif

#ifndef X_VBCURSOR_OLEBIND_H_
#define X_VBCURSOR_OLEBIND_H_
#include <vbcursor/olebind.h>
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include <shell.h>
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_OLELYT_HXX_
#define X_OLELYT_HXX_
#include "olelyt.hxx"
#endif

#ifndef X_MSDATSRC_H_
#define X_MSDATSRC_H_
#include <msdatsrc.h>
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

PerfDbgExtern(tagDocPaint)
DeclareTagOther(tagOleSiteClientNoWindowless, "OleSite", "Disable windowless inplace activation")
DeclareTag(tagOleSiteClient, "OleSite", "OleSiteClient methods");
ExternTag(tagOleSiteRect);

// to make all QI_TEAROFFs directed to global function CreateTearOffThunk instead of attempt
// to use COleSite::CreateTearOffThunk inherited from CElement
#define CreateTearOffThunk ::CreateTearOffThunk

BEGIN_TEAROFF_TABLE_SUB_(COleSite, CClient, IOleInPlaceSiteWindowless)
    // IOleWindow
    TEAROFF_METHOD_SUB(COleSite, CClient, GetWindow, getwindow, (HWND *phwnd))
    TEAROFF_METHOD_SUB(COleSite, CClient, ContextSensitiveHelp, contextsensitivehelp, (BOOL fEnterMode))
    // IOleInPlaceSite
    TEAROFF_METHOD_SUB(COleSite, CClient, CanInPlaceActivate, caninplaceactivate, ())
    TEAROFF_METHOD_SUB(COleSite, CClient, OnInPlaceActivate, oninplaceactivate, ())
    TEAROFF_METHOD_SUB(COleSite, CClient, OnUIActivate, onuiactivate, ())
    TEAROFF_METHOD_SUB(COleSite, CClient, GetWindowContext, getwindowcontext, (IOleInPlaceFrame **ppFrame, IOleInPlaceUIWindow **ppDoc, LPOLERECT lprcPosRect, LPOLERECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo))
    TEAROFF_METHOD_SUB(COleSite, CClient, Scroll, scroll, (OLESIZE scrollExtant))
    TEAROFF_METHOD_SUB(COleSite, CClient, OnUIDeactivate, onuideactivate, (BOOL fUndoable))
    TEAROFF_METHOD_SUB(COleSite, CClient, OnInPlaceDeactivate, oninplacedeactivate, ())
    TEAROFF_METHOD_SUB(COleSite, CClient, DiscardUndoState, discardundostate, ())
    TEAROFF_METHOD_SUB(COleSite, CClient, DeactivateAndUndo, deactivateandundo, ())
    TEAROFF_METHOD_SUB(COleSite, CClient, OnPosRectChange, onposrectchange, (LPCOLERECT lprcPosRect))
    // IOleInPlaceSiteEx
    TEAROFF_METHOD_SUB(COleSite, CClient, OnInPlaceActivateEx, oninplaceactivateex, (BOOL *, DWORD))
    TEAROFF_METHOD_SUB(COleSite, CClient, OnInPlaceDeactivateEx, oninplacedeactivateex, (BOOL))
    TEAROFF_METHOD_SUB(COleSite, CClient, RequestUIActivate, requestuiactivate, ())
    // IOleInPlaceSiteWindowless
    TEAROFF_METHOD_SUB(COleSite, CClient, CanWindowlessActivate, canwindowlessactivate, ())
    TEAROFF_METHOD_SUB(COleSite, CClient, GetCapture, getcapture, ())
    TEAROFF_METHOD_SUB(COleSite, CClient, SetCapture, setcapture, (BOOL fCapture))
    TEAROFF_METHOD_SUB(COleSite, CClient, GetFocus, getfocus, ())
    TEAROFF_METHOD_SUB(COleSite, CClient, SetFocus, setfocus, (BOOL fFocus))
    TEAROFF_METHOD_SUB(COleSite, CClient, GetDC, getdc, (LPCRECT prc, DWORD grfFlags, HDC *phDC))
    TEAROFF_METHOD_SUB(COleSite, CClient, ReleaseDC, releasedc, (HDC hdc))
    TEAROFF_METHOD_SUB(COleSite, CClient, InvalidateRect, invalidaterect, (LPCRECT prc, BOOL fErase))
    TEAROFF_METHOD_SUB(COleSite, CClient, InvalidateRgn, invalidatergn, (HRGN hrgn, BOOL fErase))
    TEAROFF_METHOD_SUB(COleSite, CClient, ScrollRect, scrollrect, (int dx, int dy, LPCRECT prcScroll, LPCRECT prcClip))
    TEAROFF_METHOD_SUB(COleSite, CClient, AdjustRect, adjustrect, (LPRECT prc))
    TEAROFF_METHOD_SUB(COleSite, CClient, OnDefWindowMessage, ondefwindowmessage, (UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(COleSite, CClient, IOleControlSite)
    TEAROFF_METHOD_SUB(COleSite, CClient, OnControlInfoChanged, oncontrolinfochanged, ())
    TEAROFF_METHOD_SUB(COleSite, CClient, LockInPlaceActive, lockinplaceactive, (BOOL fLock))
    TEAROFF_METHOD_SUB(COleSite, CClient, GetExtendedControl, getextendedcontrol, (IDispatch ** ppDisp))
    TEAROFF_METHOD_SUB(COleSite, CClient, TransformCoords, transformcoords, (POINTL * lpptlHimetric, POINTF * lpptfContainer, DWORD flags))
    TEAROFF_METHOD_SUB(COleSite, CClient, TranslateAccelerator, translateaccelerator, (LPMSG lpMsg, DWORD grfModifiers))
    TEAROFF_METHOD_SUB(COleSite, CClient, OnFocus, onfocus, (BOOL fGotFocus))
    TEAROFF_METHOD_SUB(COleSite, CClient, ShowPropertyFrame, showpropertyframe, ())
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(COleSite, CClient, IDispatch)
    TEAROFF_METHOD_SUB(COleSite, CClient, GetTypeInfoCount, gettypeinfocount, (UINT * pctinfo))
    TEAROFF_METHOD_SUB(COleSite, CClient, GetTypeInfo, gettypeinfo, (UINT, ULONG, ITypeInfo**))
    TEAROFF_METHOD_SUB(COleSite, CClient, GetIDsOfNames, getidsofnames, (REFIID riid, LPTSTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid))
    TEAROFF_METHOD_SUB(COleSite, CClient, Invoke, invoke, (DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(COleSite, CClient, IOleCommandTarget)
    TEAROFF_METHOD_SUB(COleSite, CClient, QueryStatus, querystatus, (GUID *pguidCmdGroup, ULONG cCmds, MSOCMD rgCmds[], MSOCMDTEXT *pcmdText))
    TEAROFF_METHOD_SUB(COleSite, CClient, Exec, exec, (GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(COleSite, CClient, IServiceProvider)
    TEAROFF_METHOD_SUB(COleSite, CClient, QueryService, queryservice, (REFGUID guidService, REFIID iid, void ** ppv))
END_TEAROFF_TABLE()

#ifndef NO_DATABINDING
BEGIN_TEAROFF_TABLE_SUB_(COleSite, CClient, IBoundObjectSite)
    TEAROFF_METHOD_SUB(COleSite, CClient, GetCursor, getcursor, (DISPID dispid, ICursor **ppCursor, LPVOID FAR* ppcidOut))
END_TEAROFF_TABLE()
#endif // ndef NO_DATABINDING

BEGIN_TEAROFF_TABLE_SUB_(COleSite, CClient, IBindHost)
    TEAROFF_METHOD_SUB(COleSite, CClient, CreateMoniker, createmoniker,
        (LPOLESTR szName, IBindCtx * pbc, IMoniker ** ppmk, DWORD dwReserved))
    TEAROFF_METHOD_SUB(COleSite, CClient, MonikerBindToStorage, monikerbindtostorage,
        (IMoniker * pmk, IBindCtx * pbc, IBindStatusCallback * pbsc, REFIID riid, void ** ppvObj))
    TEAROFF_METHOD_SUB(COleSite, CClient, MonikerBindToObject, monikerbindtoobject,
        (IMoniker * pmk, IBindCtx * pbc, IBindStatusCallback * pbsc, REFIID riid, void ** ppvObj))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(COleSite, CClient, ISecureUrlHost)
    TEAROFF_METHOD_SUB(COleSite, CClient, ValidateSecureUrl, validatesecureurl,
        (BOOL* fAllow, OLECHAR* pchUrlInQuestion, DWORD dwFlags))
END_TEAROFF_TABLE()

EXTERN_C const IID IID_IHTMLDialog;

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::AddRef, IUnknown
//
//  Synopsis:   Private IUnknown implementation.
//
//----------------------------------------------------------------------------

ULONG
COleSite::CClient::AddRef()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::AddRef SSN=0x%x ulRefs=%ld", MyOleSite()->_ulSSN, ++_ulRefsLocal));

    return MyOleSite()->SubAddRef();
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::Release, IUnknown
//
//  Synopsis:   Private IUnknown implementation.
//
//----------------------------------------------------------------------------

ULONG
COleSite::CClient::Release()
{
    Assert(_ulRefsLocal > 0);
    TraceTag((tagOleSiteClient, "COleSite::CClient::Release SSN=0x%x ulRefs=%ld", MyOleSite()->_ulSSN, --_ulRefsLocal));

    return MyOleSite()->SubRelease();
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::QueryInterface, IUnknown
//
//  Synopsis:   Private IUnknown implementation.
//
//----------------------------------------------------------------------------

HRESULT
COleSite::CClient::QueryInterface(REFIID iid, void **ppv)
{
    if (ppv)
        *ppv = NULL;

    if (MyOleSite()->IllegalSiteCall(0))
        RRETURN(E_UNEXPECTED);

#if DBG==1
    char * pszTearoff = NULL, * pszInherit = NULL;
    if (iid == IID_IUnknown)                        pszInherit = "IUnknown";
    else if (iid == IID_IAdviseSinkEx)              pszInherit = "IAdviseSinkEx";
    else if (iid == IID_IAdviseSink)                pszInherit = "IAdviseSink";
    else if (iid == IID_IOleClientSite)             pszInherit = "IOleClientSite)";
    else if (iid == IID_IPropertyNotifySink)        pszInherit = "IPropertyNotifySink";
    else if (iid == IID_IDispatch)                  pszTearoff = "IDispatch";
    else if (iid == IID_IOleControlSite)            pszTearoff = "IOleControlSite";
    else if (iid == IID_IOleWindow)                 pszTearoff = "IOleWindow";
    else if (iid == IID_IOleInPlaceSite)            pszTearoff = "IOleInPlaceSite";
    else if (iid == IID_IOleInPlaceSiteWindowless)  pszTearoff = "IOleInPlaceSiteWindowless";
    else if (iid == IID_IOleInPlaceSiteEx)          pszTearoff = "IOleInPlaceSiteEx";
    else if (iid == IID_IOleCommandTarget)          pszTearoff = "IOleCommandTarget";
    else if (iid == IID_IServiceProvider)           pszTearoff = "IServiceProvider";
    else if (iid == IID_IBindHost)                  pszTearoff = "IBindHost";
    else if (iid == IID_IBoundObjectSite)           pszTearoff = "IBoundObjectSite";
    else if (iid == IID_ISecureUrlHost)             pszTearoff = "ISecureUrlHost";
    else                                            pszInherit = "(Unknown IID)";
    TraceTag((tagOleSiteClient, "COleSite::CClient::QueryInterface %s %s%s",
              pszTearoff ? "(Tearoff)" : "(Inherit)", pszTearoff ? pszTearoff : "",
              pszInherit ? pszInherit : ""));
#endif

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *) this, IUnknown)
#if 0 // IEUNIX
        QI_INHERITS2(this, IUnknown, IOleClientSite) // IEUNIX don't cast to IPrivateUnknown, because we don't implement that
#endif
        QI_INHERITS(this, IAdviseSinkEx)
        QI_INHERITS2(this, IAdviseSink, IAdviseSinkEx)
        QI_INHERITS2(this, IAdviseSink2, IAdviseSinkEx)
        QI_INHERITS(this, IOleClientSite)
#ifndef NO_DATABINDING
        QI_INHERITS(this, IPropertyNotifySink)
#endif // ndef NO_DATABINDING
        QI_TEAROFF(this, IDispatch, (IOleClientSite *)this)
        QI_TEAROFF(this, IOleControlSite, (IOleClientSite *)this)
        QI_TEAROFF2(this, IOleWindow, IOleInPlaceSiteWindowless, (IOleClientSite *)this)
        QI_TEAROFF2(this, IOleInPlaceSite, IOleInPlaceSiteWindowless, (IOleClientSite *)this)
        QI_TEAROFF(this, IOleInPlaceSiteWindowless, (IOleClientSite *)this)
        QI_TEAROFF2(this, IOleInPlaceSiteEx, IOleInPlaceSiteWindowless, (IOleClientSite *)this)
        QI_TEAROFF(this, IOleCommandTarget, (IOleClientSite *)this)
        QI_TEAROFF(this, IServiceProvider, (IOleClientSite *)this)
        QI_TEAROFF(this, IBindHost, (IOleClientSite*)this)
#ifndef NO_DATABINDING
        QI_TEAROFF(this, IBoundObjectSite, (IOleClientSite *)this)
#endif // ndef NO_DATABINDING
        QI_TEAROFF(this, ISecureUrlHost, (IOleClientSite *)this)
    }

    if (!*ppv)
    {
        // HACK for getting pWindowParent hooked up for scriptlets in native frames!
        if (IsEqualIID(iid, CLSID_HTMLWindow2))
        {
            if (MyOleSite()->HasMarkupPtr())
            {
                CMarkup * pMarkup = MyOleSite()->GetMarkup()->GetWindowedMarkupContext();

                Assert(pMarkup);

                COmWindowProxy *pOmWndProxy = pMarkup->Window();

                if (pOmWndProxy)
                {
                    *ppv = pOmWndProxy->Window();
                    return S_OK;
                }
            }
        }

        TraceTag((tagOleSiteClient, "COleSite::CClient::QueryInterface --> E_NOINTERFACE"));
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    (*(IUnknown **)ppv)->AddRef();

    TraceTag((tagOleSiteClient, "COleSite::CClient::QueryInterface --> %08lX", *ppv));

#if DBG==1
    if (pszTearoff)
    {
        MemSetName((*ppv, "COleSite::CClient::QI %s", pszTearoff));
    }
#endif

    DbgTrackItf(iid, "CClient", FALSE, ppv);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::SaveObject, IOleClientSite
//
//  Synopsis:   Object is asking us to save it
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::SaveObject()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::SaveObject SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED))
        RRETURN(E_UNEXPECTED);

    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::GetMoniker, IOleClientSite
//
//  Synopsis:   Answer the specified moniker
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::GetMoniker SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED))
        RRETURN(E_UNEXPECTED);

    HRESULT hr;

    switch (dwWhichMoniker)
    {
    case OLEWHICHMK_CONTAINER:
        {
            CMarkup * pMarkup = MyOleSite()->GetMarkup();

            if (    pMarkup
                &&  !pMarkup->IsPrimaryMarkup())
            {
                hr = THR(CreateURLMoniker(NULL, CMarkup::GetUrl(pMarkup), ppmk));
            }
            else
            {
                hr = THR_NOTRACE(Doc()->GetMoniker(dwAssign, OLEWHICHMK_OBJFULL, ppmk));
            }
        }

        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    RRETURN_NOTRACE(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::GetContainer, IOleClientSite
//
//  Synopsis:   Answer pointer to IOleContainer (if supported)
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::GetContainer(LPOLECONTAINER FAR* ppContainer)
{
    HRESULT hr;

    TraceTag((tagOleSiteClient, "COleSite::CClient::GetContainer SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED | VALIDATE_DOC_ALIVE))
        RRETURN(E_UNEXPECTED);

    if (MyOleSite()->IsInMarkup())
    {
        CMarkup * pMarkup = MyOleSite()->GetMarkup();

        if (pMarkup->HasWindow())
        {
            hr = THR(pMarkup->Document()->QueryInterface(IID_IOleContainer, (void **)ppContainer));
            goto Cleanup;
        }
    }
    hr = THR(Doc()->QueryInterface(IID_IOleContainer, (void **)ppContainer));
    DbgTrackItf(IID_IOleContainer, "GetContainer", TRUE, (void **)ppContainer);

Cleanup:
    RRETURN(hr);

}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::ShowObject, IOleClientSite
//
//  Synopsis:   Asks container to show itself (and object at this site)
//
//  Notes:  This method is called during the binding process to
//          a link source. The code was launched either:
//              a) with /Embedding, in which case it will
//                 be waiting to show itself and this or DoVerb(SHOW)
//                 will be the ocassion for doing so
//              b) without /Embedding, in which case it will have registered
//                 via CoRegisterClassObject and will already be
//                 visible: this method now means "bring the link
//                 source into view".
//
//          If this object is in turn embedded in another container,
//          it should (recursively) call this same method on it's
//          client site...
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::ShowObject()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::ShowObject SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED))
        RRETURN(E_UNEXPECTED);

#ifdef WISH_THAT_ACTIVEX_CTLS_WERENT_SO_STUPID
    //
    // The webbrowser oc as well as the marcwan (basectl) framework
    // call ShowObject while inplace-activating.  This makes no sense
    // for ocx's to do this at this juncture so bail out immediately.
    //
    // Also, bail out right now if the ocx is not inplace yet.  The ppt
    // viewer ocx extraordinaire calls ShowObject in the middle of
    // SetClientSite!  We don't have any code anyway for inside-out
    // inplace activation.
    //
    // IE3 didn't implement this method anyway, so there should be
    // no ill effects here. (anandra)
    //

    if (MyOleSite()->TestLock(COleSite::OLESITELOCK_INPLACEACTIVATE) ||
        MyOleSite()->State() < OS_INPLACE)
    {
        return S_OK;
    }

    //
    // If we're scrolling then we better not be in the middle of sizing
    // or positioning.  I.e. before we can scroll we need to know how big
    // and where we are!!
    //

    Assert(!MyOleSite()->TestLock(ELEMENTLOCK_SIZING) &&
           !MyOleSite()->TestLock(ELEMENTLOCK_POSITIONING));

    RRETURN(MyOleSite()->ScrollIntoView());
#else
    return S_OK;
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnShowWindow, IOleClientSite
//
//  Synopsis:   Informs container (us) about object Show/Hide events
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnShowWindow(BOOL fShow)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnShowWindow SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED))
        RRETURN(E_UNEXPECTED);

    OLE_SERVER_STATE stateNew = MyOleSite()->State();

    if (fShow)
    {
        stateNew = OS_OPEN;
    }
    else if (MyOleSite()->_state > OS_RUNNING)
    {
        stateNew = OS_RUNNING;
    }

    if (MyOleSite()->State() != stateNew)
    {
        MyOleSite()->_state = stateNew;
        MyOleSite()->GetUpdatedLayout()->Invalidate();
    }
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::RequestNewObjectLayout, IOleClientSite
//
//  Synopsis:
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::RequestNewObjectLayout( )
{
    HRESULT     hr;
    IOleObject *pOleObject = NULL;
    SIZEL       sizel;
    SIZE        size;
    CRect       rcBounds;
    CRect       rcClient;

// If we are in the midst of recalculating the size, ignore this call.
    if (MyOleSite()->CElement::TestLock(ELEMENTLOCK_RECALC))
        return S_OK;

    COleLayout * pLayout = DYNCAST(COleLayout, MyOleSite()->GetUpdatedLayout());
    Assert(pLayout);

    TraceTag((tagOleSiteClient, "COleSite::CClient::RequestNewObjectLayout SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED))
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //
    // Ask the object how big it wants to be and stuff the info into
    // the width/height attributes.
    //

    hr = THR_NOTRACE(MyOleSite()->QueryControlInterface(IID_IOleObject, (void **)&pOleObject));
    if (hr)
        goto Cleanup;

    //
    // Transition to the running state because GetExtent can fail
    // if not OS_RUNNING.
    //

    hr = THR(MyOleSite()->TransitionTo(OS_RUNNING));
    if (hr)
        goto Cleanup;

    hr = THR_OLE(pOleObject->GetExtent(DVASPECT_CONTENT, &sizel));
    if (hr)
        goto Cleanup;

    Doc()->GetView()->GetMeasuringDevice(mediaTypeNotSet)->DeviceFromHimetric(size, sizel);

    pLayout->GetRect(&rcBounds);
    pLayout->GetClientRect(&rcClient, COORDSYS_PARENT);

    rcBounds.right  = rcBounds.left + (rcBounds.Width()  - rcClient.Width())  + size.cx;
    rcBounds.bottom = rcBounds.top  + (rcBounds.Height() - rcClient.Height()) + size.cy;

    hr = THR(pLayout->Move(&rcBounds, SITEMOVE_RESIZEONLY));
    if (hr)
        goto Cleanup;

    MyOleSite()->ResizeElement();

Cleanup:
    ReleaseInterface(pOleObject);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::GetWindow, IOleWindow
//
//  Synopsis:   Answer containing window handle
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::GetWindow(HWND * phwnd)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::GetWindow SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED | VALIDATE_DOC_ALIVE))
        RRETURN(E_UNEXPECTED);

    RRETURN(Doc()->GetWindow(phwnd));
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::ContextSensitiveHelp, IOleWindow
//
//  Synopsis:   Notifies enter/exit CSH mode
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::ContextSensitiveHelp(BOOL fEnterMode)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::ContextSensitiveHelp SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED | VALIDATE_DOC_INPLACE))
        RRETURN(E_UNEXPECTED);

    RRETURN(Doc()->_pInPlace->_pInPlaceSite->ContextSensitiveHelp(fEnterMode));
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::CanInPlaceActivate, IOleInPlaceSite
//
//  Synopsis:   Answer wether or not object can IPActivate
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::CanInPlaceActivate()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::CanInPlaceActivate SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(0))
        RRETURN(E_UNEXPECTED);

    return S_OK;     // we always allow in-place activation
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnInPlaceActivate, IOleInPlaceSite
//
//  Synopsis:   Notifies container (us) of object activation
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnInPlaceActivate()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnInPlaceActivate SSN=0x%x", MyOleSite()->_ulSSN));

    RRETURN(THR_OLEO(OnInPlaceActivateEx(NULL, 0),MyOleSite()));
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnInPlaceActivateEx, IOleInPlaceSiteEx
//
//  Synopsis:   Notifies container (us) of object activation
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnInPlaceActivateEx(BOOL *pfNoRedraw, DWORD dwFlags)
{
    HRESULT hr;
    RECT    rcUpdate;
    RECT    rcSite;
    CDoc *  pDoc = Doc();

    TraceTag((tagOleSiteClient, "COleSite::CClient::OnInPlaceActivateEx SSN=0x%x", MyOleSite()->_ulSSN));

    //
    // Don't allow inplace activation if the site is not loaded yet
    // or if the doc is not at least inplace active.
    //

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED | VALIDATE_DOC_INPLACE ))
        RRETURN(E_UNEXPECTED);

    TraceTag((tagCDoc, "COleSite::CClient::OnInPlaceActivate %x", this));

    Assert(MyOleSite()->_pInPlaceObject == 0);

    // handle the above assert failing. If this site is already inplace, return S_OK.
    // This situation should never happen, but Adobe's Acrobat control does this.
    if (MyOleSite()->_pInPlaceObject != 0)
    {
        Assert(MyOleSite()->State() >= OS_INPLACE);
        return S_OK;
    }
        
    if (dwFlags & ACTIVATE_WINDOWLESS)
    {
        hr = THR_OLEO(MyOleSite()->QueryControlInterface(
                IID_IOleInPlaceObjectWindowless,
                (void **) &MyOleSite()->_pInPlaceObject),MyOleSite());
        if (hr)
            goto Cleanup;

        MyOleSite()->_fWindowlessInplace = TRUE;
        MyOleSite()->_fUseInPlaceObjectWindowless = TRUE;
    }
    else
    {
        hr = THR_OLEO(MyOleSite()->QueryControlInterface(
                IID_IOleInPlaceObject,
                (void **) &MyOleSite()->_pInPlaceObject),MyOleSite());
        if (hr)
            goto Cleanup;
    }

    MyOleSite()->_state = OS_INPLACE;

    // Adjust z-order of all HWNDs within the document and transparency of the associated display node (if any)

    if (!pDoc->_fInPlaceActivating && !MyOleSite()->_fWindowlessInplace)
    {
        HWND hwndPar = pDoc->_pInPlace->_hwnd;
        HWND hwndCtl = MyOleSite()->GetHwnd();
        CLayout *   pLayout   = MyOleSite()->GetUpdatedLayout(GUL_USEFIRSTLAYOUT);
        CDispNode * pDispNode = pLayout
                                    ? pLayout->GetElementDispNode()
                                    : NULL;

        if (hwndCtl)
        {
            if (GetParent(hwndCtl) == hwndPar)
            {
                pDoc->FixZOrder();
            }

            if (    pDispNode
                &&  pDispNode->IsOpaque()
                &&  ::GetWindowLong(hwndCtl, GWL_EXSTYLE) & WS_EX_TRANSPARENT)
            {
                MyOleSite()->ResizeElement();
            }
        }
    }

    if (pfNoRedraw)
    {
        // If the baseline state is OS_INPLACE then IVO::Draw() won't, so we
        // have to have them draw themselves during this activation process.
        *pfNoRedraw = (MyOleSite()->BaselineState(OS_INPLACE) != OS_INPLACE);

        // If the control is windowless, then the normal window invalidation
        // mechanism will take care of getting the bits on the screen correct.
        // If the control has a window, then we need to tell the object if
        // it needs to invalidate or not.

        if (!MyOleSite()->_fWindowlessInplace)
        {
            // If the form's update rect intersects the site, then
            // redraw is required.

            if (GetUpdateRect(pDoc->_pInPlace->_hwnd, &rcUpdate, FALSE))
            {
                CLayout * pLayout   = MyOleSite()->GetUpdatedLayout();

                if (pLayout)
                {
                    pLayout->GetRect(&rcSite, COORDSYS_GLOBAL);
                    if (IntersectRect(&rcSite, &rcSite, &rcUpdate))
                    {
                        *pfNoRedraw = FALSE;
                    }
                }
            }

            if (*pfNoRedraw)
            {
                *pfNoRedraw = !MyOleSite()->ActivationChangeRequiresRedraw();
            }
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnInPlaceDeactivateEx, IOleInPlaceSiteEx
//
//  Synopsis:   Notifies container (us) of object activation
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnInPlaceDeactivateEx(BOOL fNoRedraw)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnInPlaceDeactivateEx SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(0))
        RRETURN(E_UNEXPECTED);

    if (!fNoRedraw ||
        (!MyOleSite()->_fWindowlessInplace &&
            MyOleSite()->ActivationChangeRequiresRedraw()))
    {
        MyOleSite()->GetUpdatedLayout()->Invalidate();
    }

    RRETURN(THR(OnInPlaceDeactivate()));
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnInPlaceDeactivate, IOleInPlaceSite
//
//  Synopsis:   Notifies container (us) of object deactivation
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnInPlaceDeactivate()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnInPlaceDeactivate SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(0))
        RRETURN(E_UNEXPECTED);

    TraceTag((tagCDoc, "COleSite::CClient::OnInPlaceDeactivate %x", this));

    //
    // If this site is still UIACTIVE fire the OnUIDeactivate event for it.
    // This is protection against ill-behaved objects like WordArt 2.0 which
    // fire OnUIActivate but fail to send OnUIDeactivate if it encounters
    // trouble.  It does send OnInPlaceDeactivate, hence the catch here.
    //

    if (MyOleSite()->_state == OS_UIACTIVE)
    {
        OnUIDeactivate(FALSE);
    }
    
//    Assert(MyOleSite()->_pInPlaceObject); // (IE5 bug 65988) this is not a valid assert - the control can call OnInPlaceDeactivate any time it wants to, even in the middle of inplace activation)

    ClearInterface(&MyOleSite()->_pInPlaceObject);
    MyOleSite()->_fWindowlessInplace = FALSE;
    MyOleSite()->_fUseInPlaceObjectWindowless = FALSE;
    MyOleSite()->_state = OS_RUNNING;

    // Destroy private hwnd. Hack for PhotoSUite 3 (#94834)
    if (MyOleSite()->_hwndPrivate)
    {
#if DBG == 1
        INSTANTCLASSINFO * pici = MyOleSite()->GetInstantClassInfo();
        Assert(pici && (pici->dwCompatFlags & COMPAT_HWNDPRIVATE));
#endif
        Assert(IsWindow(MyOleSite()->_hwndPrivate));
        DestroyWindow(MyOleSite()->_hwndPrivate);
        MyOleSite()->_hwndPrivate = NULL;
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnUIActivate, IOleInPlaceSite
//
//  Synopsis:   Notifies container (us) of object UIactivation
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnUIActivate()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnUIActivate SSN=0x%x", MyOleSite()->_ulSSN));
    HRESULT     hr = S_OK;
    INSTANTCLASSINFO * pici = MyOleSite()->GetInstantClassInfo();

    //
    // Do not allow ui-activation if we're positioning the control.
    // The wonderful msn company news ocx does this when we
    // first inplace activate it.
    //

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED | VALIDATE_DOC_INPLACE) ||
        MyOleSite()->State() < OS_RUNNING ||
        (pici && (pici->dwCompatFlags & COMPAT_NO_UIACTIVATE)))
    {
        TraceTag((tagError, "Unexpected call to OnUIActivate!"));
        RRETURN(E_UNEXPECTED);
    }

    {
        CLock       Lock(MyOleSite(), OLESITELOCK_TRANSITION);

        hr = Doc()->SetUIActiveElement(MyOleSite());
        if (hr)
            RRETURN(hr);
    }

    MyOleSite()->_state = OS_UIACTIVE;

    if (!MyOleSite()->_fInBecomeCurrent)
    {
        // if, on the other hand, MyOleSite()->!_fInBecomeCurrent were TRUE,
        // we pretend that this is ui-active.  We will complete
        // the activation process in NTYPE_ELEMENT_SETFOCUS notification
        // once SetCurrentElem() succeeds. If, oin the other hand,
        // SetCurrentElem fails, we will reset the state in
        // NTYPE_ELEMENT_SETFOCUSFAILED notification.

        hr = MyOleSite()->BecomeCurrent(0);
        if (hr)
            hr = E_UNEXPECTED;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnUIDeactivate, IOleInPlaceSite
//
//  Synopsis:   Notifies container (us) of object UIdeactivation
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnUIDeactivate(BOOL fUndoable)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnUIDeactivate SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_INPLACE))
        RRETURN(E_UNEXPECTED);

    HRESULT     hr;
    CDoc *      pDoc = Doc();

    Assert (pDoc); // should be checked by IllegalSiteCall

    if (!pDoc->_pInPlace)  // if the doc has deactived already,
        return S_OK;       // nothing more to do

    Assert (pDoc->_pInPlace);

    // Mark ourselves as no longer UIActive:
    pDoc->_pInPlace->_fChildActive = FALSE;
    MyOleSite()->_state = OS_INPLACE;
    MyOleSite()->TakeCapture(FALSE);

    //
    // If we are the ui-active or current site, make sure
    // we clean up the doc's internal state variables.
    //

    if (pDoc->_pElemUIActive == MyOleSite() &&
        !pDoc->_pInPlace->_fChildActivating)
    {
        //
        // If the doc is not deactivating, just make this
        // site's parent current and active.
        //

        if (!pDoc->_pInPlace->_fDeactivating)
        {
            CElement * pElementPL = MyOleSite()->GetFirstBranch()
                                        ? MyOleSite()->GetUpdatedParentLayoutElement()
                                        : NULL;

            // The callee's expect this to no longer be so...
            pDoc->_pElemUIActive = NULL;

            if(pElementPL)
            {
                pElementPL->BecomeCurrentAndActive(0, NULL, NULL, TRUE);
            }
            else
            {
                IGNORE_HR(pDoc->PrimaryRoot()->BecomeCurrentAndActive());
            }
        }
        else
        {
            //
            // Otherwise the doc is deactivating, so just force
            // the rootsite to become current and active.
            // Don't use the BecomeUIActive method on the rootsite
            // because that could cause certain unpleasant side-effects
            //

            pDoc->_pElemUIActive = pDoc->_pElementDefault;

            IGNORE_HR(pDoc->PrimaryRoot()->BecomeCurrent(0));
        }
    }

    hr = S_OK;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::GetWindowContext, IOleInplaceSite
//
//  Synopsis:   Answer a description of the IP window context
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::GetWindowContext(
    IOleInPlaceFrame ** ppFrame,
    IOleInPlaceUIWindow ** ppDoc,
    LPOLERECT prcPosRect,
    LPOLERECT prcClipRect,
    OLEINPLACEFRAMEINFO * pFI)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::GetWindowContext SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_DOC_INPLACE))
        RRETURN(E_UNEXPECTED);

    HRESULT      hr;
    OLERECT      rcT;
    CDoc *       pDoc = Doc();
    COleLayout * pLayout;

    pLayout = DYNCAST(COleLayout, MyOleSite()->GetUpdatedLayout(GUL_USEFIRSTLAYOUT));

    if (MyOleSite()->_state < OS_LOADED)
    {
        Assert(0 && "Unexpected call to client site.");
        *ppFrame = NULL;
        *ppDoc = NULL;
        SetRectEmpty(prcPosRect);
        SetRectEmpty(prcClipRect);
        memset(pFI, 0, sizeof(OLEINPLACEFRAMEINFO));
        RRETURN(E_UNEXPECTED);
    }

    *ppFrame = NULL;
    *ppDoc = NULL;

    pFI->cb = sizeof(OLEINPLACEFRAMEINFO);
    hr = THR(pDoc->_pInPlace->_pInPlaceSite->GetWindowContext(
            ppFrame,
            ppDoc,
            &rcT,
            &rcT,
            pFI));
    if (hr)
        goto Cleanup;

    if (*ppFrame)
    {
        ReleaseInterface(*ppFrame);
        *ppFrame = &pDoc->_FakeInPlaceFrame;
        (*ppFrame)->AddRef();
        DbgTrackItf(IID_IOleInPlaceFrame, "FrmWnd", TRUE, (void **)ppFrame);
    }

    if (*ppDoc)
    {
        ReleaseInterface(*ppDoc);
        *ppDoc = &pDoc->_FakeDocUIWindow;
        (*ppDoc)->AddRef();
        DbgTrackItf(IID_IOleInPlaceUIWindow, "DocWnd", TRUE, (void **)ppDoc);
    }

    if (pLayout)
        pLayout->GetClientRect(prcPosRect, COORDSYS_GLOBAL);

#ifdef WIN16
    RECTL rcClipRectl;
    MyOleSite()->GetParentLayout()->GetVisibleClientRect(&rcClipRectl);
    CopyRect(prcClipRect, &rcClipRectl);
#else
    if (pLayout)
        pLayout->GetClippedClientRect((CRect*)prcClipRect, COORDSYS_GLOBAL);
#endif

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::Scroll, IOleInPlaceSite
//
//  Synopsis:   Object wants us to scroll by sizeScroll, which is in
//              pixels.
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::Scroll(OLESIZE sizeScroll)
{
#if 0
// TODO: Fix this! (brendand)
    int             i;
    POINT           ptBefore;
    POINT           ptAfter;
    SIZEL           sizelScroll;
    CTreeNode *     pNodeParent;
    int             cx;
    HRESULT         hr = S_OK;

    TraceTag((tagOleSiteClient, "COleSite::CClient::Scroll SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_INPLACE  | VALIDATE_DOC_INPLACE))
        RRETURN(E_UNEXPECTED);

    for (pNodeParent = MyOleSite()->GetParentLayoutNode();
            pNodeParent && (sizeScroll.cx || sizeScroll.cy);
            pNodeParent = pNodeParent->GetParentLayoutNode())
    {
        ptBefore.x = MyOleSite()->GetCurLayout()->_rc.left;
        ptBefore.y = MyOleSite()->GetCurLayout()->_rc.top;
        pNodeParent->Doc()->HimetricFromDevice(sizelScroll, sizeScroll);
        hr = THR(pNodeParent->GetCurLayout()->ScrollBy(
                                sizelScroll.cx,
                                sizelScroll.cy,
                                fmScrollActionControlRequest,
                                fmScrollActionControlRequest));
        if (hr)
            goto Cleanup;

        ptAfter.x = MyOleSite()->GetCurLayout()->_rc.left;
        ptAfter.y = MyOleSite()->GetCurLayout()->_rc.top;

        // Calculate the remaining amount to scroll using the positions
        // before and after scrolling. This calculation is tricky because we
        // want to handle the case where the parent site overshoots the scroll
        // amount. This might happen because a datadoc is aligning a row.

        for (i = 0; i < 2; i++)
        {
            cx = (&sizeScroll.cx)[i] + (&ptAfter.x)[i] - (&ptBefore.x)[i];
            if ((&sizeScroll.cx)[i] < 0)
            {
                if (cx > 0)
                    cx = 0;
            }
            else if ((&sizeScroll.cx)[i] > 0)
            {
                if (cx < 0)
                    cx = 0;
            }
            else
            {
                cx = 0;
            }
            (&sizeScroll.cx)[i] = cx;
        }
    }

    if (sizeScroll.cx || sizeScroll.cy)
        hr = THR(Doc()->_pInPlace->_pInPlaceSite->Scroll(sizeScroll));

Cleanup:
    RRETURN(hr);
#else
    RRETURN(S_OK);
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::DiscardUndoState, IOleInPlaceSite
//
//  Synopsis:   dump any saved undo state for this object
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::DiscardUndoState()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::DiscardUndoState SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_INPLACE))
        RRETURN(E_UNEXPECTED);

    // SITEBUG -- Undo
    // Doc()->SetUndoState(NULL);

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::DeactivateAndUndo, IOleInPlaceSite
//
//  Synopsis:   Object wants us to deactivate it and undo a prior action
//
//  Notes:      The object is asking us to back up, deactivating it
//              and undo (local to our state). We must call UIDeactivate
//              on the object.
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::DeactivateAndUndo()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::DeactivateAndUndo SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_INPLACE))
        RRETURN(E_UNEXPECTED);

    HRESULT     hr;
    CDoc *      pDoc = Doc();
    CDoc::CLock Lock(pDoc);

    // TODO:  Need to handle error result if error from SaveData call in
    //        TransitionToBaselineState.
    MyOleSite()->TransitionToBaselineState(OS_UIACTIVE);

    //
    // This will call Undo on the form's site if the first thing the user did
    // after the form was activated was activate something inside it.  This is
    // because the current undo object will be a CUndoActivate in that
    // situation.
    //

#ifdef NO_EDIT
    hr = S_OK;
#else
    hr = THR(pDoc->EditUndo());
#endif // NO_EDIT
    pDoc->ShowLastErrorInfo(hr);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnPosRectChange, IOleInPlaceSite
//
//  Synopsis:   object self-move/resize
//
//  Arguments:  prcPos  New Physical Rect
//
//  Notes:      We are being informed that the object wants a new position/size
//              in the document. We should try to be accomodating by laying
//              ourself out differently. This may of course be a recursive
//              process (if we are embedded). When we are done, the InPlace
//              object is notified of the result via SetObjectRects(). The
//              result may be that we have clipped some or all of the new
//              PosRect, or that the new PosRect is zoomed with respect
//              to the request -- in either case the object may choose
//              to deactivate and proceed with an open edit. Notice that
//              this means we may be deactivated if we choose to
//              recursively renegotiate with our InPlaceSite.
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnPosRectChange(LPCOLERECT prcPos)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnPosRectChange SSN=0x%x", MyOleSite()->_ulSSN));

    // If we are in the midst of recalculating the size, ignore this call.
    if (MyOleSite()->CElement::TestLock(CElement::ELEMENTLOCK_RECALC))
        return S_OK;

    if (MyOleSite()->IllegalSiteCall(VALIDATE_INPLACE))
        RRETURN(E_UNEXPECTED);

    // if we are in the midst of SetWindowPos or SetObjectRects, ignore this call
    if (Doc()->GetView()->IsChangingRectsFor(MyOleSite()->GetHwnd(), MyOleSite()->_pInPlaceObject))
        RRETURN(E_UNEXPECTED);

    // If we are currently rendering, we would like to still process this call, but at a later
    // time. So, we post a method call to ourselves.
    // The return value is an error since we can not process the call now. Since we will call
    // the SetObjectRects later when we process the posted message, the control is happy.
    if (MyOleSite()->IllegalSiteCall(VALIDATE_NOTRENDERING))
    {
        if (!_prcPending)
        {
            _prcPending = new CRect(*prcPos);

            if ( ! _prcPending )
            {
                RRETURN( E_OUTOFMEMORY );
            }
            
            TraceTag((
                tagOleSiteRect,
                "COleSite::Client::OnPosRectChange: SSN=%x rcPosIn=l=%ld t=%ld r=%ld b=%ld DSOR",
                MyOleSite()->_ulSSN,
                prcPos->left, prcPos->top, prcPos->right, prcPos->bottom));

            IGNORE_HR(GWPostMethodCall(this, 
                ONCALL_METHOD(COleSite::CClient, DeferredOnPosRectChange, deferredonposrectchange), 
                0, 
                TRUE, 
                "COleSite::CClient::DeferredOnPosRectChange"));
        }

        // we have to return here instead of going to the cleanup,
        // since cleanup frees the _prcPending and resets it.
        RRETURN(E_UNEXPECTED);
    }

    HRESULT hr  = S_OK;
    OLERECT rcPos;
    RECT    rcClip;

// TODO: Fix this (brendand)
    rcClip = g_Zero.rc;

    COleLayout * pLayout = DYNCAST(COleLayout, MyOleSite()->GetUpdatedLayout());
    
    //
    // If we are in the middle of COleSite::Move (_fSettingExtent == TRUE),
    // then we ignore the argument (prcPos) and tell the control to move
    // where COleSite::Move was told to move the control.  This protects
    // against calls to OnPosRectChange from the CDK's implementation of
    // IOleObject::SetExtent.
    //

    if (   pLayout 
        && MyOleSite()->TestLock(COleSite::OLESITELOCK_SETEXTENT))
    {
        SIZE    size;

        Doc()->DeviceFromHimetric(size, pLayout->_sizelLast);
        pLayout->GetClientRect(&rcPos, COORDSYS_GLOBAL);
        rcPos.right  = rcPos.left + size.cx;
        rcPos.bottom = rcPos.top + size.cy;

        TraceTag((
            tagOleSiteRect,
            "COleSite::Client::OnPosRectChange: SSN=%x rcPosIn=l=%ld t=%ld r=%ld b=%ld SOR=l=%ld t=%ld r=%ld b=%ld ",
            MyOleSite()->_ulSSN,
            prcPos->left, prcPos->top, prcPos->right, prcPos->bottom,
            rcPos.left, rcPos.top, rcPos.right, rcPos.bottom));

        {
            CView::CLockWndRects lock(Doc()->GetView(), NULL, MyOleSite()->_pInPlaceObject);
            hr = THR_OLEO(MyOleSite()->_pInPlaceObject->SetObjectRects(&rcPos, ENSUREOLERECT(&rcClip)),MyOleSite());
        }
        if (hr)
            goto Cleanup;
    }
    else
    {
        BOOL            fLayoutOnly = FALSE;
        BOOL            fStatic = TRUE;
        CRect           rcPosClient(0,0,0,0);

        if (pLayout)
            pLayout->GetClientRect(&rcPosClient, COORDSYS_GLOBAL);

        //
        // If the site is position is absolute or relative we will allow
        // changes to the location as well as size.  Otherwise only changes
        // to the size are allowed.
        //

        if (!MyOleSite()->IsPositionStatic())
        {
            fStatic = FALSE;
            rcPos = *prcPos;
        }
        else
        {
            rcPos = rcPosClient;
            rcPos.right = rcPos.left + prcPos->right - prcPos->left;
            rcPos.bottom = rcPos.top + prcPos->bottom - prcPos->top;
        }

        //
        // OPTIMIZATION:  If the new size is the same as the old size, only
        //   a relayout needs to be done.  Otherwise a full resizing
        //   a relayout is necessary.
        //
        if (    (rcPos.right - rcPos.left == rcPosClient.Width())
            &&  (rcPos.bottom - rcPos.top == rcPosClient.Height()))
        {
            fLayoutOnly = TRUE;
        }

        TraceTag((
            tagOleSiteRect,
            "COleSite::Client::OnPosRectChange: SSN=%x rcPosIn=l=%ld t=%ld r=%ld b=%ld SOR=l=%ld t=%ld r=%ld b=%ld ",
            MyOleSite()->_ulSSN,
            prcPos->left, prcPos->top, prcPos->right, prcPos->bottom,
            rcPos.left, rcPos.top, rcPos.right, rcPos.bottom));

        {
            CView::CLockWndRects lock(Doc()->GetView(), NULL, MyOleSite()->_pInPlaceObject);
            hr = THR_OLEO(MyOleSite()->_pInPlaceObject->SetObjectRects(
                &rcPos,
                ENSUREOLERECT(&rcClip)),
                MyOleSite());
        }
        if (hr)
            goto Cleanup;

        // convert the rc to parent content relative coordinates
        if (pLayout)
        {
            pLayout->TransformRect(&rcPos, COORDSYS_GLOBAL, COORDSYS_PARENT);

            hr = THR(pLayout->Move(&rcPos, SITEMOVE_NOFIREEVENT));
            if (hr)
                goto Cleanup;
        }

        TraceTag((
            tagOleSiteRect,
            "COleSite::Client::OnPosRectChange: SSN=%x \n\t rcPosIn=l=%ld t=%ld r=%ld b=%ld SOR=l=%ld t=%ld r=%ld b=%ld",
            MyOleSite()->_ulSSN,
            prcPos->left, prcPos->top, prcPos->right, prcPos->bottom,
            rcPos.left, rcPos.top, rcPos.right, rcPos.bottom));

        hr = THR(MyOleSite()->OnPropertyChange(
                DISPID_UNKNOWN,
                ELEMCHNG_CLEARCACHES));
        if (hr)
            goto Cleanup;

        MyOleSite()->ResizeElement();
    }

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnDataChange, IAdviseSink
//
//  Synopsis:   Data-changed event
//
//  Notes:      the memory pointed to by pStgmed is owned by the caller,
//              it must not be free's here (but can of course be copied).
//
//+---------------------------------------------------------------------------

void
COleSite::CClient::OnDataChange(FORMATETC FAR* pFormatetc, STGMEDIUM FAR* pStgmed)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnDataChange SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED))
        return;

    // Ignore calls from DataDoc instances.  Because they are
    // never saved, they can't be dirty.

    MyOleSite()->_fDirty = TRUE;
    Doc()->OnDataChange(FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnViewChange, IAdviseSink
//
//  Synopsis:   View-changed event
//
//+---------------------------------------------------------------------------

void
COleSite::CClient::OnViewChange(DWORD dwAspects, LONG lindex)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnViewChange SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED) || 
        MyOleSite()->IllegalSiteCall(VALIDATE_NOTRENDERING))
        return;

    if ((dwAspects & DVASPECT_CONTENT) && Doc()->_state >= OS_INPLACE)
    {
        if (MyOleSite()->_state < OS_INPLACE)
        {
            COleLayout * pLayout = DYNCAST(COleLayout, MyOleSite()->GetUpdatedLayout());
            if (pLayout)
            pLayout->Invalidate();
        }
    }

    // We only InvalidateColors is the object
    // doesn't know how to use SHDVID_ONCOLORSCHANGE
    //
    if (!MyOleSite()->_fCanDoShColorsChange)
            MyOleSite()->Doc()->InvalidateColors();

    Doc()->OnViewChange(dwAspects);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnRename, IAdviseSink
//
//  Synopsis:   Linking clients need to update source monikers.
//
//+---------------------------------------------------------------------------

void
COleSite::CClient::OnRename(LPMONIKER pmk)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnRenameSSN=0x%x", MyOleSite()->_ulSSN));
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnSave, IAdviseSink
//
//  Synopsis:   Object-saved event
//
//+---------------------------------------------------------------------------

void
COleSite::CClient::OnSave()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnSave SSN=0x%x", MyOleSite()->_ulSSN));
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnClose, IAdviseSink
//
//  Synopsis:   Object-closed event
//
//+---------------------------------------------------------------------------

void
COleSite::CClient::OnClose()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnClose SSN=0x%x", MyOleSite()->_ulSSN));
}


//+---------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnLinkSrcChange, IAdviseSink2
//
//  Synopsis:   Object-closed event
//
//---------------------------------------------------------------
void
COleSite::CClient::OnLinkSrcChange(IMoniker * pmk)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnLinkSrcChange SSN=0x%x", MyOleSite()->_ulSSN));
}


//+---------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnViewStatusChange, IAdviseSinkEx
//
//  Synopsis:   View Status flags has changed
//
//---------------------------------------------------------------
void
COleSite::CClient::OnViewStatusChange(DWORD dwViewStatus)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnViewStatusChange SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED))
        return;

    MyOleSite()->SetViewStatusFlags(dwViewStatus);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::CanWindowlessActivate, IOleInPlaceSiteWindowless
//
//  Synopsis:   object is asking if it can in-place activate without a window
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::CanWindowlessActivate()
{
    INSTANTCLASSINFO * pici;
    
    TraceTag((tagOleSiteClient, "COleSite::CClient::CanWindowlessActivate SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(0))
        RRETURN(E_UNEXPECTED);

#if DBG==1
    if (IsTagEnabled(tagOleSiteClientNoWindowless))
        return S_FALSE;
#endif
    pici = MyOleSite()->GetInstantClassInfo();

    if (!pici)
        return S_FALSE;
        
    return (pici->dwCompatFlags & COMPAT_DISABLEWINDOWLESS) ?
                    S_FALSE :
                    S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::GetCapture, IOleInPlaceSiteWindowless
//
//  Synopsis:   object wants to know if it still has mouse capture
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::GetCapture()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::GetCapture SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE | VALIDATE_DOC_INPLACE))
        RRETURN(E_UNEXPECTED);

    CDoc *  pDoc = Doc();

    return (pDoc->HasCapture(MyOleSite()) ? S_OK : S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::SetCapture, IOleInPlaceSiteWindowless
//
//  Synopsis:   object wants to capture the mouse, or release capture
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::SetCapture(BOOL fCapture)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::SetCapture SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        RRETURN(E_UNEXPECTED);

    MyOleSite()->TakeCapture(fCapture);
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::GetFocus, IOleInPlaceSiteWindowless
//
//  Synopsis:   object wants to know if it still has focus
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::GetFocus()
{
    CDoc * pDoc = Doc();

    TraceTag((tagOleSiteClient, "COleSite::CClient::GetFocus SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE | VALIDATE_DOC_INPLACE))
        RRETURN(E_UNEXPECTED);

    return (pDoc->_pElemCurrent == MyOleSite() &&
            ::GetFocus() == pDoc->_pInPlace->_hwnd) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::SetFocus, IOleInPlaceSiteWindowless
//
//  Synopsis:   Windowless control wants to grab the focus.
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::SetFocus(BOOL fFocus)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::SetFocus SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE | VALIDATE_DOC_INPLACE))
        RRETURN(E_UNEXPECTED);

    HRESULT hr = S_OK;
    CDoc *  pDoc = Doc();

    if (fFocus)
    {
        if (S_OK != MyOleSite()->BecomeCurrent(0))
        {
            RRETURN(E_FAIL);
        }

        if (::GetFocus() != pDoc->_pInPlace->_hwnd)
        {
            // This will cause WM_SETFOCUS to be sent to this site.
            ::SetFocus(pDoc->_pInPlace->_hwnd);
        }
        else
        {
            // Focus already on the form. Need to force message to control.

            LRESULT lResult;

            hr = THR_OLEO(((IOleInPlaceObjectWindowless *)MyOleSite()->_pInPlaceObject)->
                OnWindowMessage(
                    WM_SETFOCUS,
                    0,
                    0,
                    &lResult),MyOleSite());
        }
    }
    else if (pDoc->_pElemCurrent == MyOleSite() &&
             ::GetFocus() == pDoc->_pInPlace->_hwnd)
    {
        ::SetFocus(NULL);
    }

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnDefWindowMessage, IOleInPlaceSiteWindowless
//
//  Synopsis:   Implement default behavior for messages. Can be called by
//              object as an alternative to returning S_FALSE from
//              IOleInPlaceObjectWindowless::OnWindowMessage.
//
//  Arguments:  see OnWindowMessage
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnDefWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    TraceTag((tagOleSiteClient,
        "COleSite::CClient::OnDefWindowMessage SSN=0x%x msg=0x%x wParam=0x%x lParam=0x%x",
        MyOleSite()->_ulSSN,
        msg, wParam, lParam));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE | VALIDATE_DOC_INPLACE))
        RRETURN(E_UNEXPECTED);

    CMessage Message(NULL, msg, wParam, lParam);
    HRESULT hr;
    CDoc *  pDoc = Doc();

    hr = THR( Message.SetNodeHit( MyOleSite()->GetFirstBranch() ) );
    if( hr )
        goto Cleanup;

    // Tell the form that this message came from a control inside it.
    pDoc->_pInPlace->_fBubbleInsideOut = TRUE;
    hr = THR( MyOleSite()->CElement::HandleMessage( &Message ) );
    pDoc->_pInPlace->_fBubbleInsideOut = FALSE;
    // TODO (carled) plResult is not set by this routine. eventually we will want to
    // put in   *plResult = Message.lResult;
    // but for now...
    *plResult = hr;
Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   COleSite::CClient::GetDC, IOleInPlaceSiteWindowless
//
//  Synopsis:   Provides hDC for windowless object to paint itself.
//
//  Arguments:  [prc]     -- rect which object wants to draw in pixels
//              [dwFlags] -- flags to determine hDC returned by container
//              [phDC]    -- pointer to returned hDC
//
//  Returns:    HRESULT (S_OK if valid HDC, OLE_E_NESTEDPAINT if already painting)
//
//  Notes:      if [prc] is NULL, assume object wants to draw entire rect.
//
//              Following is the description of how we process depending on
//              various flags.
//
//                              no OFFSCREEN              OFFSCREEN
//
//              no PAINTBKGND   pre: exclude opaque       pre: nothing
//              (opaque)        areas in front
//
//                              post: paint transparent   post: paint all in
//                              areas in front            front
//
//
//              PAINTBKGND      pre: exclude opaque       pre: paint all
//              (transparent)   areas in front. paint     behind, also
//                              all sites behind, also    paint form.
//                              paint form.
//
//                              post: paint transparent   post: paint all
//                              areas in front            in front
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::GetDC(LPCRECT prc, DWORD dwFlags, HDC * phDC)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::GetDC SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        RRETURN(E_UNEXPECTED);

    CRect   rcClip;

    //  restrict paint area to the control's rectangle
    //
    COleLayout * pLayout = DYNCAST(COleLayout, MyOleSite()->GetUpdatedLayout());

    Assert(pLayout);

    pLayout->GetClippedRect(&rcClip, COORDSYS_GLOBAL);
    
    if (prc)
    {
        rcClip.IntersectRect(*prc);
    }
    
    if (!rcClip.IsEmpty())
    {
        // if the caller isn't going to use this DC for drawing, we can safely
        // return a DC
        if (dwFlags & OLEDC_NODRAW)
        {
            return pLayout->GetDC(&rcClip, dwFlags, phDC);
        }
        
        // just invalidate and fail, and we will draw the control later
        pLayout->Invalidate(rcClip, COORDSYS_GLOBAL);
    }
    
    return E_FAIL;
}


//+---------------------------------------------------------------------------
//
//  Function:   COleSite::CClient::ReleaseDC, IOleInPlaceSiteWindowless
//
//  Synopsis:   Signals end of paint for object
//
//  Arguments:  [hDC] -- hDC returned by object
//
//  Returns:    HRESULT (S_OK)
//
//  Notes:      See notes for GetDC
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::ReleaseDC(HDC hDC)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::ReleaseDC SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        RRETURN(E_UNEXPECTED);

    COleLayout * pLayout = DYNCAST(COleLayout, MyOleSite()->GetUpdatedLayout());
    Assert(pLayout);

    RRETURN(pLayout->ReleaseDC(hDC));
}


//+---------------------------------------------------------------------------
//
//  Function:   COleSite::CClient::InvalidateRect, IOleInPlaceSiteWindowless
//
//  Synopsis:   Invalidates a given rectangular area within object's rectangle
//
//  Arguments:  [prc]    -- rectangle to invalidate
//              [fErase] -- repaint the background?
//
//  Returns:    HRESULT (S_OK)
//
//  Notes:      [prc] is assumed to be in Window Pixel coordinates.
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::InvalidateRect(LPCRECT prc, BOOL fErase)
{
    COleSite *  pOleSite = MyOleSite();
    CLayout *   pLayout  = pOleSite->GetUpdatedLayout();

    if (!pLayout)
        return S_OK;

    TraceTag((tagOleSiteClient, "COleSite::CClient::InvalidateRect SSN=0x%x", MyOleSite()->_ulSSN));

    if (pOleSite->IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        RRETURN(E_UNEXPECTED);


    // make sure the doc flag for disabling tiled paint is set
    if (pOleSite->_fSurface)
    {
        pOleSite->Doc()->_fDisableTiledPaint = TRUE;
    }

    // prc is in global coordinates, so invalidate appropriately
    if (prc)
    {
        CRect   rc = *prc;

        pLayout->TransformRect(&rc, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT);
        pLayout->Invalidate(&rc);
    }
    else
        pLayout->Invalidate(prc);

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   COleSite::CClient::InvalidateRgn, IOleInPlaceSiteWindowless
//
//  Synopsis:   Invalidates a given region within object's rectangle
//
//  Arguments:  [hrgn]    -- region to invalidate
//              [fErase]  -- repaint the background?
//
//  Returns:    HRESULT (S_OK)
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::InvalidateRgn(HRGN hrgn, BOOL fErase)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::InvalidateRgn SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        RRETURN(E_UNEXPECTED);

    // make sure the doc flag for disabling tiled paint is set
    if (MyOleSite()->_fSurface)
    {
        MyOleSite()->Doc()->_fDisableTiledPaint = TRUE;
    }

// TODO: This region is in global coordinates and must be transformed to local before calling CLayout (brendand)
    MyOleSite()->GetUpdatedLayout()->Invalidate(hrgn);

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   COleSite::CClient::ScrollRect, IOleInPlaceSiteWindowless
//
//  Synopsis:   Scrolls the site window as requested
//
//  Arguments:  [dx]        --
//              [dy]        --
//              [prcScroll] --
//              [prcClip]   --
//
//  Returns:    HRESULT (S_OK)
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::ScrollRect(
    int dx, int dy, LPCRECT prcScroll, LPCRECT prcClip )
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::ScrollRect SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE | VALIDATE_DOC_INPLACE))
        RRETURN(E_UNEXPECTED);

    HRESULT         hr = S_OK;
#if 0
// TODO: Fix this! (brendand)
    RECT            rcParent;
    RECT            rcScroll;
    RECT            rcClip;
    RECT            rcSite;
    BOOL            fAboveMe;
    CDoc *          pDoc = Doc();

    Assert(pDoc->_pInPlace);

    // Get the visible site rect in device units

    rcSite = MyOleSite()->GetCurLayout()->_rc;
    MyOleSite()->GetParentLayout()->GetVisibleClientRect(&rcParent);
    IntersectRect(&rcSite, &rcSite, &rcParent);

    // If not scroll rect was passed in, then scroll the entire site

    rcScroll = prcScroll ? * prcScroll : rcSite;

    // If no clip rect was passed in, then set  it to the scroll rect

    rcClip = prcClip ? * prcClip : rcScroll;

    // Make sure rects are contained within the client site.  If either
    // does not intersect the site, then do nothing.

    if (!IntersectRect(&rcScroll, &rcScroll, &rcSite) ||
        !IntersectRect(&rcClip,   &rcClip,   &rcSite))
    {
        goto Cleanup;
    }

    // If this site has a transparent control, then just invalidate.

    if (!MyOleSite()->GetCurLayout()->_fOpaque)
        goto InvalidateClip;

    // Check to see if another site above us in the zorder intersects.
    // If so, then invalidate.

    fAboveMe = FALSE;
    if (pDoc->_pSiteRoot->GetCurLayout()->CheckLayoutIntersect(
                                     MyOleSite()->GetCurLayout(),
                                     &fAboveMe,
                                     SI_ABOVE))
        goto InvalidateClip;

    Assert(pDoc->_pInPlace->_hwnd);

    ::ScrollWindowEx(
        pDoc->_pInPlace->_hwnd,
        dx, dy, &rcScroll, &rcClip, 0, 0, SW_INVALIDATE);

Cleanup:
#endif

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   COleSite::CClient::AdjustRect, IOleInPlaceSiteWindowless
//
//  Synopsis:   Invalidates object's rectangle
//
//  Arguments:  [prc] -- return clipped rectangle here.
//
//  Returns:    HRESULT (S_OK)
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::AdjustRect(LPRECT prc)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::AdjustRect SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        RRETURN(E_UNEXPECTED);

#if 0
//    TODO : fix later, what is this doing ?
    CSite *         pSiteLoop;
    RECT            rcSiteOpaque;
    POINT           pt;

    if (!MyOleSite()->_fWindowlessInplace)
    {
        Assert(0 && "Unexpected call to client site.");
        RRETURN(E_UNEXPECTED);
    }

    Assert(prc);

    pt.x = prc->left;
    pt.y = prc->top;

    while ((pSiteLoop = iterBackToFront.Next()) != MyOleSite()) {};

    while ((pSiteLoop = iterBackToFront.Next()) != NULL)
    {
        if (pSiteLoop->HitTestRect(&(MyOleSite()->_rc)) == HTC_YES)
        {
            if (pSiteLoop->GetOpaqueRect(&rcSiteOpaque))
            {
                if (!IntersectRect(prc, prc, &rcSiteOpaque))
                {
                    prc->left = prc->right = pt.x;
                    prc->top = prc->bottom = pt.y;
                    return S_FALSE;
                }
            }
        }
        else
        {
            iterBackToFront.SkipChildren(pSiteLoop);
        }
    }
#endif
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnControlInfoChanged, IOleControlSite
//
//  Synopsis:   notification from the control of change
//
//  Returns:    S_OK iff sucessful, else error
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnControlInfoChanged()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnControlInfoChanged SSN=0x%x", MyOleSite()->_ulSSN));

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::LockInPlaceActive, IOleControlSite
//
//  Synopsis:   Increments or decrements an in-place active lock
//              count.  If non-zero, then the form will ensure that
//              this site is not deactivated.
//
//  Arguments:  [fLock] -- Increment if TRUE
//
//  Returns:    S_OK iff sucessful, else error
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::LockInPlaceActive(BOOL fLock)
{
    TraceTag((tagOleSiteClient,
        "COleSite::CClient::LockInPlaceActive SSN=0x%x fLock=%s",
        MyOleSite()->_ulSSN,
        fLock ? "TRUE" : "FALSE"));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_INPLACE))
        RRETURN(E_UNEXPECTED);

    HRESULT             hr;
    IOleControlSite *   pOCS;

    //  Part of the contract of locking the control in the in-place
    //    active state is that the form itself needs to remain
    //    in-place active.  We can't do this unless the form's
    //    site supports the LockInPlaceActive method

    hr = THR(Doc()->_pClientSite->QueryInterface(
            IID_IOleControlSite,
            (void **) &pOCS));
    if (hr)
        RRETURN(E_FAIL);

    hr = THR(pOCS->LockInPlaceActive(fLock));
    if (hr)
        goto Cleanup;

    if (fLock)
    {
        if (MyOleSite()->_cLockInPlaceActive == MAX_LOCK_INPLACEACTIVE)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        MyOleSite()->_cLockInPlaceActive++;
    }
    else
    {
        if (MyOleSite()->_cLockInPlaceActive == 0)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        MyOleSite()->_cLockInPlaceActive--;
    }

    //  Changing the lock count may change the proper state for
    //    this control; this call moves the control to the
    //    proper state.  Note that errors are ignored.

    IGNORE_HR(MyOleSite()->TransitionToCorrectState());

Cleanup:
    pOCS->Release();

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::GetExtendedControl, IOleControlSite
//
//  Synopsis:   Answer pointer to the XObject for this control
//
//  Arguments:  [ppUnk] -- where to return pointer
//
//  Returns:    S_OK iff sucessful, else error
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::GetExtendedControl(IDispatch **ppDisp)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::GetExtendedControl SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED))
        RRETURN(E_UNEXPECTED);

    RRETURN(THR_OLEO(MyOleSite()->QueryInterface(IID_IDispatch,(void **)ppDisp),MyOleSite()));
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::TransformCoords, IOleControlSite
//
//  Synopsis:   Answer pointer to the XObject for this control
//
//  Arguments:  [ppUnk] -- where to return pointer
//
//  Returns:    S_OK iff sucessful, else error
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::TransformCoords(POINTL *pptl, POINTF *pptf, DWORD dwFlags)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::TransformCoords SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED))
        RRETURN(E_UNEXPECTED);

     if (dwFlags & XFORMCOORDS_HIMETRICTOCONTAINER)
     {
         pptf->x = HPixFromHimetric(pptl->x);
         pptf->y = VPixFromHimetric(pptl->y);
     }
     else
     {
         pptl->x = HimetricFromHPix(pptf->x + 0.5);
         pptl->y = HimetricFromVPix(pptf->y + 0.5);
     }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::TranslateAccelerator, IOleControlSite
//
//  Synopsis:   Called by our embedded control if it doesn't process an
//              accelerator message.
//
//  Arguments:  [pmsg] -- Message to translate
//
//  Returns:    S_OK if handled, S_FALSE if not, error HRESULT on error.
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::TranslateAccelerator(LPMSG pmsg, DWORD grfModifiers)
{
    TraceTag((tagOleSiteClient,
        "COleSite::CClient::TranslateAccelerator SSN=0x%x message=0x%x",
        MyOleSite()->_ulSSN,
        pmsg->message));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED))
        RRETURN(E_UNEXPECTED);

    CMessage Message(pmsg);

    // Give host a chance to handle it first
    if (Doc()->HostTranslateAccelerator(pmsg) == S_OK)
        return S_OK;

    // We get many messages besides the keystroke messages here.  This is
    // expected and used by the other site types, but for ole sites we
    // need to ensure only keystroke messages are handled and propagated
    // here.  -Tom

    switch (pmsg->message)
    {
    case WM_KEYDOWN:
    case WM_KEYUP:
    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
        break;
    default:
        return S_FALSE;
    }

    //
    // Backspace is a navigation keystroke for us.  Block this out
    // for any ocx, as long as alt & ctrl aren't depressed either.
    //

    if (Message.wParam == VK_BACK &&
        !(Message.dwKeyState & (MK_CONTROL | MK_ALT)))
        return S_FALSE;

    CTreeNode * pNodeParentSite = MyOleSite()->GetUpdatedParentLayoutNode();

    if (!pNodeParentSite)
        return S_FALSE;

    RRETURN1(THR(pNodeParentSite->Doc()->PumpMessage(&Message, pNodeParentSite, TRUE)), S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::RequestUIActivate, IOleInPlaceSiteEx
//
//  Synopsis:   Notifies the container that the control intends to transition
//              to the UIActivate state
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::RequestUIActivate()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::RequestUIActivate SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED))
        RRETURN(E_UNEXPECTED);

    RRETURN1(MyOleSite()->IsFocussable(0) ? S_OK : S_FALSE, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnFocus, IOleControlSite
//
//  Synopsis:   Notifies the container that the control grabbed the focus.
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnFocus(BOOL)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnFocus SSN=0x%x", MyOleSite()->_ulSSN));

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::ShowPropertyFrame, IOleControlSite
//
//  Synopsis:   allows a container to hook the control's display of a
//              property frame.  Whenever the control wants to display
//              a property frame, it calls this method.  If this method
//              returns S_OK, then this site has displayed the property
//              frame, and the control should take no further action.
//              Otherwise, the control should proceed with displaying
//              its own property frame.
//
//  Returns:    S_OK or propagates error code.
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::ShowPropertyFrame()
{
#ifdef NO_PROPERTY_PAGE
    return S_OK;
#else
    TraceTag((tagOleSiteClient, "COleSite::CClient::ShowPropertyFrame SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED | VALIDATE_DOC_ALIVE))
        RRETURN(E_UNEXPECTED);


    HRESULT hr = E_FAIL;
    IOleControlSite * pCtrlSite = NULL;
    CDoc *  pDoc = Doc();

    //
    // Allow Trident host to handle this call
    //

    // First, give inplace object a chance to provide control site.
    if (pDoc->_pInPlace && pDoc->_pInPlace->_pInPlaceSite)
    {
        pDoc->_pInPlace->_pInPlaceSite->QueryInterface(IID_IOleControlSite, (void **) &pCtrlSite);
    }

    // if this fails, try the client site.
    if (!pCtrlSite && pDoc->_pClientSite)
    {
        pDoc->_pClientSite->QueryInterface(IID_IOleControlSite, (void **) &pCtrlSite);
    }

    if (pCtrlSite)
    {
        hr = pCtrlSite->ShowPropertyFrame();
        ReleaseInterface(pCtrlSite);
    }

    RRETURN(hr);
#endif // NO_PROPERTY_PAGE
}

//+------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::QueryStatus, IOleCommandTarget
//
//  Synopsis:   Delegates QS of commands upward
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

HRESULT
COleSite::CClient::QueryStatus(
                GUID * pguidCmdGroup,
                ULONG cCmds,
                MSOCMD rgCmds[],
                MSOCMDTEXT * pcmdtext)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::QueryStatus SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED | VALIDATE_DOC_SITE))
        RRETURN(OLECMDERR_E_UNKNOWNGROUP);

    HRESULT hr;

    hr = THR_NOTRACE(CTQueryStatus(
        Doc()->_pClientSite,
        pguidCmdGroup,
        cCmds,
        rgCmds,
        pcmdtext));

    if (hr == E_NOINTERFACE)
        hr = OLECMDERR_E_UNKNOWNGROUP;

    // Disable Office documents in frameset from showing/hiding toolbars.

    if (pguidCmdGroup == NULL)
    {
        for (UINT i = 0; i < cCmds; i++)
        {
            if (rgCmds[i].cmdID == OLECMDID_HIDETOOLBARS)
            {
                rgCmds[i].cmdf = 0;
            }
        }
    }

    RRETURN(hr);
}






//+------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::Exec, IOleCommandTarget
//
//  Synopsis:   Delegates Exec of commands upward
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

HRESULT
COleSite::CClient::Exec(
                GUID * pguidCmdGroup,
                DWORD nCmdID,
                DWORD nCmdexecopt,
                VARIANTARG * pvarargIn,
                VARIANTARG * pvarargOut)
{
    HRESULT hr;

    TraceTag((tagOleSiteClient, "COleSite::CClient::Exec SSN=0x%x", MyOleSite()->_ulSSN));

// New code to implement refresh for HTML OSP
    
    if ((pguidCmdGroup == NULL) && (nCmdID == OLECMDID_HTTPEQUIV))
    {
        extern BOOL ParseRefreshContent(LPCTSTR pchContent,
                                        UINT * puiDelay,
                                        LPTSTR pchUrlBuf,
                                        UINT cchUrlBuf);
        COleSite *pOleSite = MyOleSite();
        if (pOleSite->_iRefreshTime == 0)
        {
            LPCTSTR psz = pvarargIn->bstrVal;
            if (_tcsnipre(_T("refresh:"), 8, psz, -1))
            {
                UINT uiRefresh = 0;
                TCHAR ach[pdlUrlLen];
                psz += 8;

                if (ParseRefreshContent(psz, &uiRefresh, ach, ARRAY_SIZE(ach)))
                {
                    pOleSite->ClearRefresh();
                    pOleSite->_iRefreshTime = uiRefresh * 1000;
                    if (ach[0])
                        pOleSite->_pstrRefreshURL = SysAllocString(ach);
                }
            }
        }

        return S_OK;
    }

    if ((pguidCmdGroup == NULL) && (nCmdID == OLECMDID_HTTPEQUIV_DONE))
        return S_OK;

    if (IDMFromCmdID(pguidCmdGroup, nCmdID) == IDM_SHDV_ONCOLORSCHANGE)
    {
        MyOleSite()->Doc()->InvalidateColors();
        return S_OK;
    }

// End Refresh code

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED | VALIDATE_DOC_SITE))
        RRETURN(OLECMDERR_E_UNKNOWNGROUP);

    //  Doc aggregates the Enter/Leaving scripts of embeddings with its own
    //  and fires these execs on aggregate entry/leaving
    if (pguidCmdGroup && *pguidCmdGroup == CGID_ShellDocView)
    {
        Assert(MyOleSite()->GetWindowedMarkupContext());
        Assert(MyOleSite()->GetWindowedMarkupContext()->GetWindowPending());
        if (nCmdID == SHDVID_NODEACTIVATENOW)
        {
            RRETURN(THR(MyOleSite()->GetWindowedMarkupContext()->GetWindowPending()->Window()->EnterScript()));
        }
        else if (nCmdID == SHDVID_DEACTIVATEMENOW)
        {
            RRETURN(THR(MyOleSite()->GetWindowedMarkupContext()->GetWindowPending()->Window()->LeaveScript()));
        }
    }
    else if (pguidCmdGroup == NULL && nCmdID == OLECMDID_HIDETOOLBARS)
    {
        // Disable Office documents in frameset from showing/hiding toolbars.

        RRETURN(OLECMDERR_E_DISABLED);
    }

    if (pguidCmdGroup && IsEqualGUID(CGID_DocHostCmdPriv, *pguidCmdGroup))
    {
        return OLECMDERR_E_NOTSUPPORTED;
    }

    if (MyOleSite()->_fViewLinkedWebOC && pguidCmdGroup &&
        IsEqualGUID(CGID_Explorer, *pguidCmdGroup) &&
        nCmdID == SBCMDID_MIXEDZONE )
    {
        pvarargIn = NULL;
    }
   

    hr = THR_NOTRACE(CTExec(Doc()->_pClientSite,
                            pguidCmdGroup,
                            nCmdID,
                            nCmdexecopt,
                            pvarargIn,
                            pvarargOut));

    if (hr == E_NOINTERFACE)
    {
        hr = OLECMDERR_E_UNKNOWNGROUP;
    }

    RRETURN1(hr, S_FALSE);
}





//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::QueryService, IServiceProvider
//
//  Synopsis:   Return any requested services that the site supports,
//              otherwise delegate to the form.  The form will delegate to
//              its site.
//
//  Arguments:  [guidService] -- GUID of requested service
//              [iid]         -- Interface to return on requested service
//              [ppv]         -- Place to put requested service
//
//  Returns:    HRESULT (STDMETHOD)
//
//----------------------------------------------------------------------------

EXTERN_C const GUID CLSID_HTMLFrameBase;
EXTERN_C const GUID CLSID_HTMLIFrame;
EXTERN_C const GUID CLSID_HTMLObjectElement;

STDMETHODIMP
COleSite::CClient::QueryService(REFGUID guidService,
                                REFIID iid,
                                void ** ppv)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::QueryService SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED))
        RRETURN(E_NOINTERFACE);

    *ppv = NULL;

    OLESITE_TAG osTag = MyOleSite()->OlesiteTag();

    if (IsEqualGUID(guidService, CLSID_HTMLFrameBase))
    {
        if (MyOleSite()->_fViewLinkedWebOC)
        {
            // NOTE that we're not AddRef()'ing the return
            // value.  Callers beware!
            *ppv = MyOleSite();
            return S_OK;
        }
        else
            return E_NOINTERFACE;
    }
    else if (IsEqualGUID(guidService, CLSID_HTMLObjectElement))
    {
        // NOTE that we're not AddRef()'ing the return
        // value.  Callers beware!
        *ppv = MyOleSite();
        return S_OK;
    }
    else if (IsEqualGUID(guidService, SID_SBindHost))
    {
        RRETURN (THR(QueryInterface(iid, ppv)));
    }
    else if (osTag != OSTAG_FRAME &&
             osTag != OSTAG_IFRAME &&
             IsEqualGUID(guidService, CLSID_HTMLDocument))
    {
        //
        // (anandra) No bubbling of private QS's if not in a frame.
        //

        RRETURN(E_NOINTERFACE);
    }
    else if (IsEqualGUID(guidService, IID_IHTMLDialog))
    {
        // (alexz) (anandra) IID_IHTMLDialog is our private interface and it is used by document /
        // script window to find out if they are hosted in / aggregated by CHtmlDlg. No objects
        // hosted inside olesite can make QueryService for IID_IHTMLDialog except WebBrowser OC. WebBrowser OC
        // makes the QS in case if it contains Trident doc / window inside. In that case, however, we should
        // block the propagation of QS so that the doc / window will not get confused thinking that
        // they are hosted in / aggregated by html dlg.
        //
        // the way to get to this codepath: bring up an html dialog with <iframe> inside.

        RRETURN(E_NOINTERFACE);
    }
    else if (MyOleSite()->IsInMarkup())
    {
        // delegate the queryservice call to the document object.

        CDocument * pDocument = MyOleSite()->GetMarkup()->Document();
        
        if (pDocument)
        {
            RRETURN(pDocument->QueryService(guidService, iid, ppv));
        }
    }

    RRETURN(Doc()->QueryService(guidService, iid, ppv));
}

//+---------------------------------------------------------------------------
//
// Member:      COleSite::CClient::GetTypeInfoCount
//
// Synopsis:    Returns the number of typeinfos available on this object
//
// Arguments:   [pctinfo] - The number of typeinfos
//
//----------------------------------------------------------------------------

HRESULT
COleSite::CClient::GetTypeInfoCount(UINT FAR *pcTinfo)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::GetTypeInfoCount SSN=0x%x", MyOleSite()->_ulSSN));

    *pcTinfo = 0;
    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::GetIDsOfNames
//
// Synopsis:    Returns the ID of the given name
//
// Arguments:   [riid]      - Interface id to interpret names for
//              [rgszNames] - Array of names
//              [cNames]    - Number of names in [rgszNames]
//              [lcid]      - Locale ID to interpret names in
//              [rgdispid]  - Returned array of IDs
//
//----------------------------------------------------------------------------

HRESULT
COleSite::CClient::GetIDsOfNames(
        REFIID      riid,
        TCHAR **    rgszNames,
        UINT        cNames,
        LCID        lcid,
        DISPID *    rgdispid)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::GetIDsOfNames SSN=0x%x", MyOleSite()->_ulSSN));

    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::GetTypeInfo, IDispatch
//
//  Synopsis:   As per IDispatch
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** ppTI)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::GetTypeInfo SSN=0x%x", MyOleSite()->_ulSSN));

    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::Invoke, IDispatch
//
// Synopsis:    Provides access to properties and members of the control
//
// Arguments:   [dispidMember] - Member id to invoke
//              [riid]         - Interface ID being accessed
//              [wFlags]       - Flags describing context of call
//              [pdispparams]  - Structure containing arguments
//              [pvarResult]   - Place to put result
//              [pexcepinfo]   - Pointer to exception information struct
//              [puArgErr]     - Indicates which argument is incorrect
//
//----------------------------------------------------------------------------

HRESULT
COleSite::CClient::Invoke(DISPID dispidMember,
        REFIID riid,
        LCID lcid,
        WORD wFlags,
        DISPPARAMS FAR *pdispparams,
        VARIANT FAR *pvarResult,
        EXCEPINFO FAR *pexcepinfo,
        UINT FAR *puArgErr)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::Invoke SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED))
        RRETURN(E_UNEXPECTED);

    HRESULT hr = S_OK;

    if (puArgErr)
        *puArgErr = 0;

    if (pexcepinfo)
        memset(pexcepinfo, 0, sizeof(*pexcepinfo));

    if (!pdispparams)
        RRETURN(E_INVALIDARG);

    if (pvarResult != NULL)
        VariantInit(pvarResult);

    if (wFlags & DISPATCH_PROPERTYGET)
    {
        if (pvarResult == NULL)
            return E_INVALIDARG;

        hr = MyOleSite()->GetAmbientProp(dispidMember, pvarResult);
    }
    else if (wFlags & DISPATCH_PROPERTYPUT)
    {
        hr = DISP_E_MEMBERNOTFOUND;

        if (pdispparams->cArgs < 1)
            return E_INVALIDARG;
    }
    else
        hr = DISP_E_MEMBERNOTFOUND;

    return hr;
}

#ifndef NO_DATABINDING
//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::GetCursor (IBoundObjectSite)
//
//  Synopsis:   Called by Data consuming control to get its ICursor
//
//  Arguments:  dispid      dispid of data-bound property
//              ppCursor    where to put the cursor pointer
//                          may not be NULL
//              ppcidOut    If a simple-valued binding (not Cursor-valued,
//                          where to a return an ICursor DBCOLUMNID for
//                          which column boun to.
//
//  Returns:    S_OK        success
//              E_INVALIDARG
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::GetCursor(DISPID dispid,
        ICursor **ppCursor,
        LPVOID FAR* ppcidOut)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::GetCursor SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED))
        RRETURN(E_UNEXPECTED);

    HRESULT     hr = E_INVALIDARG;
    DISPID      dispidCursor = MyOleSite()->GetClassInfo()->dispidCursor;

    if (ppCursor == NULL)
        goto Cleanup;

    *ppCursor = NULL;

    // ppcidOut should only be NULL, otherwise error.
    if (ppcidOut != NULL)
    {
        *ppcidOut = NULL;
        goto Cleanup;
    }

    if (dispid == dispidCursor)
    {
        // we only support ICursor binding on the tag itself;
        //  any binding set on PARAMs uses IDataSource.
        DBMEMBERS *pdbm = MyOleSite()->GetDBMembers();
        CDataSourceBinder *pdsbBinder;

        if (!pdbm)
            goto Error;

        pdsbBinder = pdbm->GetBinder(ID_DBIND_DEFAULT);
        if (!pdsbBinder)
            goto Error;

        hr = pdsbBinder->GetICursor(ppCursor);
    }

Cleanup:
    RRETURN(hr);

Error:
    hr = E_FAIL;
    goto Cleanup;
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::::OnChanged
//
//  Synopsis:   Forwards to the connection point.
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnChanged(DISPID dispid)
{
    TraceTag((tagOleSiteClient,
        "COleSite::CClient::OnChanged SSN=0x%x dispid=0x%x",
        MyOleSite()->_ulSSN,
        dispid));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED))
        RRETURN(E_UNEXPECTED);

    HRESULT hr;

    hr = THR(MyOleSite()->OnControlChanged(dispid));
    if (hr == S_FALSE)
        hr = S_OK;
    else if (!hr)
        hr = THR(MyOleSite()->FireOnChanged(dispid));

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnRequestEdit
//
//  Synopsis:   Forwards to the connection point.
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnRequestEdit(DISPID dispid)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnRequestEdit SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED))
        RRETURN(E_UNEXPECTED);

    HRESULT hr;

    hr = THR(MyOleSite()->OnControlRequestEdit(dispid));
    if (!hr)
    {
        hr = THR(MyOleSite()->FireRequestEdit(dispid));
    }

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::ValidateSecureUrl
//
//  Synopsis:   Forwards to the connection point.
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::ValidateSecureUrl(BOOL* pfAllow, OLECHAR* pchUrlInQuestion, DWORD dwFlags)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::ValidateSecureUrl SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED))
        RRETURN(E_UNEXPECTED);

    HRESULT   hr;
    TCHAR     cBuf[pdlUrlLen];
    TCHAR   * pchNewUrl = cBuf;
    CDoc    * pDoc = MyOleSite()->Doc();
    BOOL      fPendingRoot = FALSE;
    CMarkup * pMarkup = NULL;

    hr = THR(CMarkup::ExpandUrl(
            NULL, pchUrlInQuestion, ARRAY_SIZE(cBuf), pchNewUrl, MyOleSite()));
    if (hr)
        goto Cleanup;

    if (MyOleSite()->IsInMarkup())
    {
        pMarkup = MyOleSite()->GetMarkup();
        fPendingRoot = pMarkup->IsPendingRoot();
    }
    else
    {
        pMarkup = pDoc->PrimaryMarkup();
    }

    Assert(pMarkup);

    *pfAllow = (pMarkup->ValidateSecureUrl(fPendingRoot, pchNewUrl,
        !!(SUHV_PROMPTBEFORENO & dwFlags),
        !!(SUHV_SILENTYES & dwFlags),
        !!(SUHV_UNSECURESOURCE & dwFlags)));

Cleanup:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//  Member:     COleSite::CClient::DeferredOnPosRectChange
//
//  Synopsis:   OnPostRectChange posts a call to itself through this method,
//              if we are in the rendering /view updating phase when OnPosRectChange
//              is called by the control site.
//              This member recalls the OnPosRectChange.
//----------------------------------------------------------------------------
void
COleSite::CClient::DeferredOnPosRectChange( DWORD_PTR dwContext )
{
    if (!_prcPending)
        return;

    THR(OnPosRectChange( _prcPending ));

    delete _prcPending;
    _prcPending = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\ole\olesitdb.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       olesitdb.cxx
//
//  Contents:   databinding functions for COleSite class
//
//  Classes:    COleSite
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include <binder.hxx>       // for cdatasourceprovider
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>     // for safetylevel in safety.hxx (via olesite.hxx)
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include <evntprm.hxx>      // for eventparam (needed by fire_ondata*)
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include <elemdb.hxx>       // for DBSPEC
#endif

#ifndef NO_DATABINDING
#ifndef X_VBCURSOR_VBDSC_H_
#define X_VBCURSOR_VBDSC_H_
#include <vbcursor/vbdsc.h> // for iid_ivbdsc
#endif

#ifndef X_SIMPDATA_H_
#define X_SIMPDATA_H_
#include <simpdata.h>
#endif

#ifndef X_MSDATSRC_H_
#define X_MSDATSRC_H_
#include <msdatsrc.h>
#endif

#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include <tearoff.hxx>
#endif

#endif // ndef NO_DATABINDING


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::GetInterfaceProperty (protected member)
//
//  Synopsis:   Get an interface-valued property of the control.
//
//----------------------------------------------------------------------------

HRESULT
COleSite::GetInterfaceProperty(UINT uGetOffset, DISPID dispid, REFIID riid,
                                IUnknown** ppunk)
{
    HRESULT hr;
    VARIANT var;

    // get the control's property
    VariantInit(&var);
    hr = GetProperty(uGetOffset, dispid, VT_UNKNOWN, &var);
    if (hr || (var.vt != VT_UNKNOWN && var.vt != VT_DISPATCH) || var.punkVal==0)
    {
        if (hr)
            VariantInit(&var);      // control might mess with var before failing
        goto Cleanup;
    }

    // get the desired interface
    hr = var.punkVal->QueryInterface(riid, (void**)ppunk);

Cleanup:
    VariantClear(&var);
    return hr;
}


#define VALID_VTABLE_OFFSET(off) ((off) && (off)!=~0UL)

//+-------------------------------------------------------------------------
// Function:    Get Property (protected helper)
//
// Synopsis:    fetch a property value
//
// Arguments:   uVTableOffsetGet    VTable offset for Get method (or "invalid")
//              dispidGet           dispid for property
//              vtType              type of property
//              pvar                variant into which value is placed
//
// Returns:     HRESULT

HRESULT
COleSite::GetProperty(UINT uVTableOffsetGet, DISPID dispidGet, VARTYPE vtType,
                        VARIANT* pVar)
{
    Assert(pVar);
    HRESULT hr;

    VariantInit(pVar);

    if (VALID_VTABLE_OFFSET(uVTableOffsetGet) && IsVTableValid())
    {   // use the VTable binding to read from the control.
        hr = VTableDispatch(_pDisp, vtType, VTBL_PROPGET,
                            (vtType == VT_VARIANT) ?
                                (void *) pVar :
                                (void *) &pVar->iVal,
                            uVTableOffsetGet);
        if (!hr && vtType != VT_VARIANT)
        {
            pVar->vt = vtType;
        }
    }
    
    else
    {   // use Invoke to read from the control
        EXCEPINFO   except;

        // If the dispatch isn't valid then we can't even begin to bind.
        CacheDispatch();
        if (!_pDisp)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        
        InitEXCEPINFO(&except);
        hr = THR(GetDispProp(_pDisp,
                             dispidGet,
                             g_lcidUserDefault,
                             pVar,
                             &except));
        FreeEXCEPINFO(&except);
    }

Cleanup:
    return hr;
}


//+-------------------------------------------------------------------------
// Function:    Set Property (public helper)
//
// Synopsis:    store a property value
//
// Arguments:   uVTableOffsetSet    VTable offset for Set method (or "invalid")
//              dispidSet           dispid for property
//              var                 variant into which value is placed
//
// Returns:     HRESULT

HRESULT
COleSite::SetProperty(UINT uVTableOffsetSet, DISPID dispidSet,
                     VARTYPE vtType, VARIANT *pVar)
{
    HRESULT hr;

    if (VALID_VTABLE_OFFSET(uVTableOffsetSet) && IsVTableValid())
    {   // use the VTable binding to write to the control.
        VARIANT     vCopy;
        VARIANT *   pVarPass = pVar;

        // Ensure the value in the variant (pVar) is the same type as the
        // property expects.
        if ((vtType != VT_VARIANT) && (vtType != pVarPass->vt))
        {
            vCopy.vt = VT_EMPTY;
            pVarPass = &vCopy;
            VariantChangeTypeEx(pVarPass, pVar, g_lcidUserDefault, 0, vtType);
        }

        // send the value to the control
        hr = VTableDispatch(_pDisp, vtType, VTBL_PROPSET,
                            (vtType == VT_VARIANT) ?
                                (void *) pVarPass :
                                (void *) &pVarPass->iVal,
                            uVTableOffsetSet);

         // free variant if we made a copy.
        if (pVarPass != pVar)
        {
            THR(VariantClear(pVarPass));
        }
    }
    
    else
    {   // use Invoke to read from the control
        EXCEPINFO   except;

        // If the dispatch isn't valid then we can't even begin to bind.
        CacheDispatch();
        if (!_pDisp)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        
        InitEXCEPINFO(&except);
        hr = THR(SetDispProp(_pDisp,
                             dispidSet,
                             g_lcidUserDefault,
                             pVar,
                             &except));
        FreeEXCEPINFO(&except);
    }

Cleanup:
    return hr;
}


//+------------------------------------------------------------------------
//
//  Member:     COleSite::IsVTableValid
//
//  Synopsis:   If the control offers a default (dual) interface, replace
//              my _pDisp with a pointer to the default interface.
//
//  Returns:    TRUE        _pDisp can be used for vtable-style interface
//              FALSE       _pDisp cannot be used for vtable, only for IDispatch
//
//  Note:       This function loads the control's typeinfo.  Don't call it unless
//              you really plan to use vtable offsets.
//
//-------------------------------------------------------------------------

BOOL
COleSite::IsVTableValid()
{
    HRESULT     hr;
    CLASSINFO * pci = GetClassInfo();
    IDispatch * pDisp;

    if (pci == NULL)
        goto Cleanup;
    
    if (!_fVTableCached && _pUnkCtrl)
    {
        hr = QueryControlInterface(pci->iidDefault, (void **)&pDisp );
        if (SUCCEEDED(hr))
        {
            ReplaceInterface(&_pDisp, pDisp);
            ReleaseInterface(pDisp);
            _fDispatchCached = TRUE;
        }
        else
        {
            // If we can't actually get the default interface, then we shouldn't
            // consider this control to be DUAL interface anymore.
            // This is probably because we're dealing with a control that's not
            // threadsafe.
            pci->ClearFDualInterface();
        }
    }

    _fVTableCached = TRUE;

Cleanup:
    return pci ? pci->FDualInterface() : FALSE;
}


//+---------------------------------------------------------------
//
//  Member:     VTableDispatch
//
//  Synopsis:   Set/Get the control property of the current object
//              via dual interface VTable binding.
//
//  Arguments:  propType        - the VT_nnn property type -- this had better
//                                be the correct proptype for this control
//                                property.
//              propDirection   - set the property or get the property
//              pData           - pointer to Data of a type that better match
//                                the propType argument
//                                assumed to have inspected CLASSINFO).
//              uVTblOffset     - v-table offset from pDispatch in bytes
//
//  Returns:    S_OK                    everything is fine
//              E_xxxx                  other errors from the property function
//                                      being called
//

typedef HRESULT (STDMETHODCALLTYPE *OLEVTblFunc)(IDispatch *, void*);

HRESULT
COleSite::VTableDispatch (IDispatch *pDisp,
                            VARTYPE propType,
                            VTBL_PROP propDirection,
                            void *pvData,
                            unsigned int uVTblOffset)
{
    OLEVTblFunc             pVTbl;
    HRESULT                 hr = E_FAIL;

    if (pDisp==NULL)
        goto Cleanup;

    Assert((propDirection == VTBL_PROPSET) || (propDirection == VTBL_PROPGET));
    Assert(VALID_VTABLE_OFFSET(uVTblOffset));
    Assert(pvData);
    if (!pvData)                         // in case we proceed past asssertion.
        goto Cleanup;

    pVTbl = *(OLEVTblFunc *)(((BYTE *)(*(DWORD_PTR *)pDisp)) + uVTblOffset);

    if (propDirection == VTBL_PROPSET)
    {
        AssertSz(!(propType & ~VT_TYPEMASK) ||
                    ((propType & VT_BYREF) && (VT_VARIANT == (propType & VT_TYPEMASK))),
                "Unsupported by-ref property put - base type isn't VARIANT");

        switch (propType & VT_TYPEMASK)
        {
            case VT_I2:
                hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, short)) pVTbl)
                    (pDisp, *(short*)pvData);
                break;
            case VT_I4:
                hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, long)) pVTbl)
                    (pDisp, *(long *)pvData);
                break;
            case VT_R4:
                hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, float)) pVTbl)
                    (pDisp, *(float *)pvData);
                break;
            case VT_R8:
                hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, double)) pVTbl)
                    (pDisp, *(double *)pvData);
                break;
            case VT_CY:
                hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, CY)) pVTbl)
                    (pDisp, *(CY *)pvData);
                break;
            case VT_DATE:
                hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, DATE)) pVTbl)
                    (pDisp, *(DATE *)pvData);
                break;
            case VT_BSTR:
                hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, BSTR)) pVTbl)
                    (pDisp, *(BSTR *)pvData);
                break;
            case VT_BOOL:
                hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, boolean)) pVTbl)
                    (pDisp, *(boolean *)pvData);
                break;
            case VT_VARIANT:
                if (propType & VT_BYREF)
                {
                    hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, VARIANT*)) pVTbl)
                        (pDisp, (VARIANT *)pvData);
                }
                else
                {
                    hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, VARIANT)) pVTbl)
                        (pDisp, *(VARIANT *)pvData);
                }
                break;
            case VT_UNKNOWN:
                hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, IUnknown*)) pVTbl)
                    (pDisp, *(IUnknown **)pvData);
                break;
            case VT_DISPATCH:
                hr = (* (HRESULT (STDMETHODCALLTYPE *)(IDispatch*, IDispatch*)) pVTbl)
                    (pDisp, *(IDispatch **)pvData);
                break;
            case VT_ERROR:
            case VT_EMPTY:
            case VT_NULL:
            default:
                Assert(!"Unsupported dual interface type.");
                hr = E_FAIL;
                break;
        }
    }
    else    // propDirection == VTBL_PROPGET
    {
        switch (propType & VT_TYPEMASK)
        {
        default:
            hr = (*pVTbl) (pDisp, pvData);
            break;
            
        // Following types not supported.
        case VT_ERROR:
        case VT_EMPTY:
        case VT_NULL:
            hr = E_FAIL;
            break;
        }
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\ole\olexobj.cxx ===
//+------------------------------------------------------------------------
//
//  File:       OLEXOBJ.CXX
//
//  Contents:   X-Object Implementation
//
//  Classes:    COleSite
//
//  Notes:      The Ole X object (attempts to) aggregate OLE controls and add
//              to them properties (and methods) specific to the container.
//
//              This XObject delegates the IDispatch implementation to the
//              control for properties and methods it doesn't know about.
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_TYPENAV_HXX_
#define X_TYPENAV_HXX_
#include <typenav.hxx>
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#if defined(_M_ALPHA)
#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif
#endif

HRESULT
InvokeDispatchWithNoThis (
    IDispatch *         pDisp,
    DISPID              dispidMember,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pdispparams,
    VARIANT *           pvarResult,
    EXCEPINFO *         pexcepinfo)
{
    HRESULT         hr;
    BOOL            fThis = FALSE;
    VARIANTARG *    rgOldVarg = NULL;
    DISPID     *    rgdispidOldNamedArgs = NULL;

    // Any invoke call from a script engine might have the named argument
    // DISPID_THIS.  If so then we'll not include this argument in the
    // list of parameters because oleaut doesn't know how to deal with this
    // argument.
    if (pdispparams->cNamedArgs && (pdispparams->rgdispidNamedArgs[0] == DISPID_THIS))
    {
        fThis = TRUE;
    
        pdispparams->cNamedArgs--;
        pdispparams->cArgs--;

        rgOldVarg = pdispparams->rgvarg;
        rgdispidOldNamedArgs = pdispparams->rgdispidNamedArgs;

        pdispparams->rgvarg++;
        pdispparams->rgdispidNamedArgs++;

        if (pdispparams->cNamedArgs == 0)
            pdispparams->rgdispidNamedArgs = NULL;

        if (pdispparams->cArgs == 0)
            pdispparams->rgvarg = NULL;
    }

    hr = THR_NOTRACE(pDisp->Invoke(
            dispidMember,
            IID_NULL,
            lcid,
            wFlags,
            pdispparams,
            pvarResult,
            pexcepinfo,
            NULL));


    // restore the named DISPID_THIS argument.
    if (fThis)
    {
        pdispparams->cNamedArgs++;
        pdispparams->cArgs++;

        pdispparams->rgvarg = rgOldVarg;
        pdispparams->rgdispidNamedArgs = rgdispidOldNamedArgs;
    }

    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}

//+---------------------------------------------------------------
//
//  Member:     COleSite::IE3XObjInvoke, IDispatch
//
// Synopsis:    supports IE3 xobj props by dispid
//
//---------------------------------------------------------------

HRESULT
COleSite::IE3XObjInvoke(
    DISPID       dispidMember,
    REFIID       riid,
    LCID         lcid,
    WORD         wFlags,
    DISPPARAMS * pdispparams,
    VARIANT *    pvarResult,
    EXCEPINFO *  pexcepinfo,
    UINT *       puArgErr)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;

    if (STDPROPID_IE3XOBJ_OBJECTALIGN == dispidMember)
    {
        htmlControlAlign    htmlAlign;
        CVariant            varAlign;

        if (wFlags & DISPATCH_PROPERTYGET)
        {
            if (!pvarResult)
            {
                hr = E_POINTER;
                goto Cleanup;
            }

            htmlAlign = GetAAalign();

            V_VT(pvarResult) = VT_I4;
            switch (htmlAlign)
            {
                case htmlControlAlignTop:       V_I4(pvarResult) = 1;   break;
                case htmlControlAlignBottom:    V_I4(pvarResult) = 2;   break;
                case htmlControlAlignLeft:      V_I4(pvarResult) = 3;   break;
                case htmlControlAlignRight:     V_I4(pvarResult) = 4;   break;
                default:                        V_I4(pvarResult) = 0;   break;
            }
        }
        else if (wFlags & DISPATCH_PROPERTYPUT)
        {
            if (!pdispparams || !pdispparams->rgvarg || 1 != pdispparams->cArgs)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            hr = THR(VariantChangeTypeSpecial(&varAlign, pdispparams->rgvarg, VT_I4));
            if (hr)
                goto Cleanup;

            if (V_I4(&varAlign) < 0 || 4 < V_I4(&varAlign))
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            Assert (VT_I4 == V_VT(&varAlign));

            switch (V_I4(&varAlign))
            {
                case 1:    htmlAlign = htmlControlAlignTop;    break;
                case 2:    htmlAlign = htmlControlAlignBottom; break;
                case 3:    htmlAlign = htmlControlAlignLeft;   break;
                case 4:    htmlAlign = htmlControlAlignRight;  break;
                default:   Assert (0); htmlAlign = htmlControlAlignBottom;  break;
            }

            hr = THR(SetAAalign(htmlAlign));
            if (hr)
                goto Cleanup;
        }
        else
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        hr = S_OK;
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------
//
//  Member:     COleSite::ContextThunk_InvokeEx, IDispatch
//
// Synopsis:    Provides access to properties and members of the control
//
// Arguments:   [dispidMember] - Member id to invoke
//              [riid]         - Interface ID being accessed
//              [wFlags]       - Flags describing context of call
//              [pdispparams]  - Structure containing arguments
//              [pvarResult]   - Place to put result
//              [pexcepinfo]   - Pointer to exception information struct
//              [puArgErr]     - Indicates which argument is incorrect
//
//---------------------------------------------------------------

#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif

HRESULT
COleSite::ContextThunk_InvokeEx(
        DISPID       dispidMember,
        LCID         lcid,
        WORD         wFlags,
        DISPPARAMS * pdispparams,
        VARIANT *    pvarResult,
        EXCEPINFO *  pexcepinfo,
        IServiceProvider *pSrvProvider)
{
    IUnknown * pUnkContext;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    return ContextInvokeEx(
            dispidMember,
            lcid,
            wFlags,
            pdispparams,
            pvarResult,
            pexcepinfo,
            pSrvProvider,
            pUnkContext ? pUnkContext : (IUnknown*)this);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif


//+---------------------------------------------------------------
//
//  Member:     COleSite::ContextInvokeEx
//
// Synopsis:    Provides access to properties and members of the control
//
// Arguments:   [dispidMember] - Member id to invoke
//              [riid]         - Interface ID being accessed
//              [wFlags]       - Flags describing context of call
//              [pdispparams]  - Structure containing arguments
//              [pvarResult]   - Place to put result
//              [pexcepinfo]   - Pointer to exception information struct
//              [puArgErr]     - Indicates which argument is incorrect
//              [pUnkContext]  - IUnknown to pass all calls to
//
//---------------------------------------------------------------

HRESULT
COleSite::ContextInvokeEx(
        DISPID       dispidMember,
        LCID         lcid,
        WORD         wFlags,
        DISPPARAMS * pdispparams,
        VARIANT *    pvarResult,
        EXCEPINFO *  pexcepinfo,
        IServiceProvider *pSrvProvider,
        IUnknown *   pUnkContext)
{
    HRESULT         hr = DISP_E_MEMBERNOTFOUND;
    IDispatchEx *   pDispEx = NULL;
    
    if (IllegalSiteCall(0))
        RRETURN(E_UNEXPECTED);

    CacheDispatch();

    hr = THR_NOTRACE(IE3XObjInvoke(
        dispidMember,
        IID_NULL,
        lcid,
        wFlags,
        pdispparams,
        pvarResult,
        pexcepinfo,
        NULL));
    if (DISP_E_MEMBERNOTFOUND != hr) // if S_OK or error other then DISP_E_MEMBERNOTFOUND
        goto Cleanup;

    // Don't pass on a property get for DISPID_VALUE to CBase. CBase will always
    // return a default [object] string.

    if (!((wFlags & DISPATCH_PROPERTYGET) && dispidMember == DISPID_VALUE))
    {
        // Invoke any HTML element properties OR expando
        hr = THR_NOTRACE(super::ContextInvokeEx(
                    dispidMember,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    pSrvProvider,
                    pUnkContext));
    }

    // If we're NOT an XObject DISPID AND we have a _pDisp AND it is safe to
    // delegate to the underlying object...
    if (hr == DISP_E_MEMBERNOTFOUND &&
        ((ULONG)dispidMember < DISPID_XOBJ_MIN || DISPID_XOBJ_MAX < (ULONG)dispidMember ) &&
        _pDisp &&
        IsSafeToScript())
    {
        if (!AccessAllowed(_pDisp))
        {
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }

        //
        // Try IDispatchEx2 first.
        //

        if (OK(THR_NOTRACE(QueryControlInterface(
                IID_IDispatchEx, 
                (void **)&pDispEx))))
        {
            hr = THR_NOTRACE(pDispEx->InvokeEx(
                    dispidMember,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    pSrvProvider));
        }
        else
        {
            hr = THR_NOTRACE(InvokeDispatchWithNoThis (
                _pDisp,
                dispidMember,
                lcid,
                wFlags,
                pdispparams,
                pvarResult,
                pexcepinfo));
        }

        if (SUCCEEDED(hr) && pvarResult)
        {
            CDoc *pDoc = NULL;
            IDispatch *pDispResult = V_VT(pvarResult) == VT_DISPATCH ? V_DISPATCH(pvarResult) : NULL;
            if (pDispResult && SUCCEEDED(pDispResult->QueryInterface(CLSID_HTMLDocument, (void **)&pDoc)))
            {
                IDispatch *pDisp = NULL;
                CDocument *pDocument = pDoc->_pWindowPrimary->Document();
                if (pDocument && SUCCEEDED(pDocument->QueryInterface(IID_IDispatch, (void **)&pDisp)))
                {
                    ReleaseInterface(pDispResult);
                    V_DISPATCH(pvarResult) = pDisp;
                }
            }
        }

#if 0
// Some activex controls like the IHammer controls will erroneously get an fp error
// w/o clearing the fp status codes.  This results in the script engines returning
// a fp error where none actually occured.  To bullet proof IE4 from from other
// errant apps like this we'll clear all exception flags prior to invoking an
// engine call.
#if (defined(_X86_))
#if DBG==1
__asm {
        fstsw	ax                  ;; Get error flags
        test	al,0DH              ;; See if any errors (Overflow, zero divide, invalid errs)
        jz      NoFPError           ;; No errors.
       }

    Assert(!"OleSite InvokeEx: Floating point status has errors.");
#endif  // DBG==1

    __asm { fnclex }                // Clear fp exception flags.
#endif // _X86_
#endif // 0
    }

#if 0
#if (defined(_X86_))
#if DBG==1
NoFPError:
#endif  // DBG==1
#endif // _X86_
#endif // 0

    // If we didn't find the default property on the OBJECT, retuin the
    // default object->string conversion
    if ( DISPID_NOT_FOUND(hr) && (wFlags & DISPATCH_PROPERTYGET) 
        && dispidMember == DISPID_VALUE && pvarResult &&
        pdispparams->cArgs == 0)
    {
        V_VT(pvarResult) = VT_BSTR;
        hr = THR(FormsAllocString ( _T("[object]"),&V_BSTR(pvarResult) ) );
    }

Cleanup:
    ReleaseInterface(pDispEx);
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}


//+-------------------------------------------------------------------------
//
//  Method:     COleSite::GetDispID, IDispatchEx
//
//  Synopsis:   First try GetDispID, then try expando version.
//
//--------------------------------------------------------------------------

HRESULT
COleSite::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT hr;
    INSTANTCLASSINFO * pici;

    if (IllegalSiteCall(0))
        RRETURN (E_UNEXPECTED);

    //
    // try to resolve the name using the element
    //

    hr = THR_NOTRACE(super::GetDispID(
        bstrName,
        grfdex & (~fdexNameEnsure),     // (don't allow it to create new expandos just yet)
        pid));

    if (S_OK == hr)
    {
        hr = THR(RemapActivexExpandoDispid(pid));
        goto Cleanup;
    }
    else if (DISP_E_MEMBERNOTFOUND != hr && DISP_E_UNKNOWNNAME != hr)   // if S_OK or error other than
    {                                                                   // DISP_E_MEMBERNOTFOUND or DISP_E_UNKNOWNNAME
        goto Cleanup;
    }

    //
    // try to resolve the name using dispatch interfaces the control exposes
    //

    CacheDispatch();
    if (_pDisp)
    {
        pici = GetInstantClassInfo();

        if (pici && pici->IsDispatchEx2())
        {
            // try to resolve the name using IDispatchEx

            IDispatchEx *   pDispEx = NULL;

            hr = THR(_pDisp->QueryInterface(IID_IDispatchEx, (void **)&pDispEx));

            if (S_OK == hr && pDispEx)
            {
                hr = THR_NOTRACE(pDispEx->GetDispID(bstrName, grfdex, pid));

                ReleaseInterface(pDispEx);
            }
	    }
        else
        {
            // try to resolve the name using IDispatch

            hr = THR_NOTRACE(_pDisp->GetIDsOfNames(IID_NULL, &bstrName, 1, 0, pid));
        }

        if (S_OK == hr && *pid != DISPID_UNKNOWN)     // don't check for DISP_E_MEMBERNOTFOUND or DISP_E_UNKNOWNNAME here - 
        {                   // the control might not follow conventions strictly enough
            goto Cleanup;   // done
        }
    }

    //
    // neither element nor control supports the name; so try to ensure expando
    //

    hr = THR_NOTRACE(GetExpandoDispID(bstrName, pid, grfdex));

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::RemapActivexExpandoDispid
//
//----------------------------------------------------------------------------

HRESULT
COleSite::RemapActivexExpandoDispid(DISPID * pid)
{
    HRESULT     hr = S_OK;

    if (IsExpandoDispid (*pid))
    {
        *pid = (*pid - DISPID_EXPANDO_BASE) + DISPID_ACTIVEX_EXPANDO_BASE;

        // Too many activeX expandos?
        if (*pid > DISPID_ACTIVEX_EXPANDO_MAX)
        {
            // Don't allow it.
            *pid = DISPID_UNKNOWN;
            hr = DISP_E_UNKNOWNNAME;
        }
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::GetNextDispID (IDispatchEx)
//
//  Synopsis:   Enumerates through all properties and html attributes.
//
//----------------------------------------------------------------------------

HRESULT
COleSite::GetNextDispID(
                DWORD grfdex,
                DISPID id,
                DISPID *prgid)
{
    HRESULT     hr;
    BSTR        bstr = NULL;

    CacheDispatch();

    hr = THR(GetInternalNextDispID(grfdex, id, prgid, &bstr, _pDisp));
    SysFreeString(bstr);
    RRETURN1(hr, S_FALSE);
}

HRESULT
COleSite::GetMemberName(DISPID id, BSTR *pbstrName)
{
    if (!pbstrName)
        return E_INVALIDARG;

    *pbstrName = NULL;
    
    if (super::GetMemberName(id, pbstrName))
    {
        CacheDispatch();
        if (_pDisp)
        {
            UINT            cNames = 0;
            ITypeInfo      *pTI = NULL;
            CTypeInfoNav    tin;
            INSTANTCLASSINFO * pici = GetInstantClassInfo();

            if (pici && pici->IsDispatchEx2())
            {
                IDispatchEx *pDispEx = NULL;

                HRESULT hr = THR(_pDisp->QueryInterface(IID_IDispatchEx, (void **)&pDispEx));
                if (S_OK == hr && pDispEx)
                {
                    hr = THR(pDispEx->GetMemberName(id, pbstrName));
                    ReleaseInterface(pDispEx);
                    goto Cleanup;
                }
            }

            if (tin.InitIDispatch(_pDisp, &pTI, 0))
                goto Cleanup;

            if (pTI->GetNames(id, pbstrName, 1, &cNames))
                goto Cleanup;
            
            Assert(cNames == 1);
        }
    }

Cleanup:
    return *pbstrName ? S_OK : DISP_E_MEMBERNOTFOUND;
}

HRESULT
COleSite::GetNameSpaceParent(IUnknown **ppunk)
{
    HRESULT     hr;

    if (!ppunk)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppunk = NULL;

    // TODO: (alexz) (terrylu) this needs to consider control's name space additionally
    // to implementation provided by super

    hr = THR(super::GetNameSpaceParent(ppunk));

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite:InterfaceSupportsErrorInfo, ISupportErrorInfo
//
//  Synopsis:   Return true if given interface supports error info.
//
//  Arguments:  iid the interface
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::InterfaceSupportsErrorInfo(REFIID iid)
{
    HRESULT             hr = S_FALSE;
    ISupportErrorInfo * psei;

    hr = THR(super::InterfaceSupportsErrorInfo(iid));
    if (S_OK == hr)
        goto Cleanup;

    // S_FALSE means that the interface is not supported by the x-object.
    // Try the aggregated control.

    if (OK(THR_NOTRACE(QueryControlInterface(
            IID_ISupportErrorInfo, (void**) &psei))))
    {
        hr = THR(psei->InterfaceSupportsErrorInfo(iid));
        ReleaseInterface(psei);
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}



//+---------------------------------------------------------------------------
//
//  Member:     COleSite::GetPages, ISpecifyPropertyPagse
//
//  Synopsis:   Return property pages supported
//
//  Arguments:  [pPages] -- return Pages here
//
//  Returns:    HRESULT
//
//  Notes:      Since the CSite aggregates the control, the set of pages
//              returned is obtained by appending the XObject property page to
//              the list of pages that the control says it supports.
//
//----------------------------------------------------------------------------

HRESULT
COleSite::GetPages(CAUUID * pPages)
{
#ifdef NO_PROPERTY_PAGE
    pPages->pElems = NULL;
    pPages->cElems = 0;
    return S_OK;
#else
    HRESULT hr;

    hr = THR(AddPages(
            _pUnkCtrl,
            BaseDesc()->_apclsidPages,
            pPages));
    RRETURN(hr);
#endif // NO_PROPERTY_PAGE
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite:GetClassInfo, IProvideMultipleClassInfo
//
//  Synopsis:   Returns the control's coclass typeinfo.
//
//  Arguments:  ppTI    Resulting typeinfo.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::GetClassInfo(ITypeInfo ** ppTI)
{
    RRETURN(THR(super::GetClassInfo(ppTI)));
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite:GetGUID, IProvideMultipleClassInfo
//
//  Synopsis:   Returns some type of requested guid
//
//  Arguments:  dwGuidKind      The type of guid requested
//              pGUID           Resultant
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::GetGUID(DWORD dwGuidKind, GUID *pGUID)
{
    RRETURN(THR(super::GetGUID(dwGuidKind, pGUID)));
}


//---------------------------------------------------------------------------
//
//  Member:     COleSite::GetMultiTypeInfoCount
//
//  Synopsis:   per IProvideMultipleClassInfo
//
//---------------------------------------------------------------------------


HRESULT
COleSite::GetMultiTypeInfoCount(ULONG *pc)
{
    RRETURN(GetAggMultiTypeInfoCount(pc, _pUnkCtrl));
}


//---------------------------------------------------------------------------
//
//  Member:     COleSite::GetInfoOfIndex
//
//  Synopsis:   per IProvideMultipleClassInfo
//
//---------------------------------------------------------------------------

HRESULT
COleSite::GetInfoOfIndex(
    ULONG       iTI,
    DWORD       dwFlags,
    ITypeInfo** ppTICoClass,
    DWORD*      pdwTIFlags,
    ULONG*      pcdispidReserved,
    IID*        piidPrimary,
    IID*        piidSource)
{
    RRETURN(GetAggInfoOfIndex(
        iTI,
        dwFlags,
        ppTICoClass,
        pdwTIFlags,
        pcdispidReserved,
        piidPrimary,
        piidSource,
        _pUnkCtrl));
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::GetBaseHref
//
//  Synopsis:   Returns the base href for this object tag.
//				Helper used by CPluginSite and CObjectElement.
//
//----------------------------------------------------------------------------

HRESULT
COleSite::GetBaseHref(BSTR *pbstr)
{
    HRESULT hr;
    TCHAR * pchUrl = NULL;

    *pbstr = NULL;
    
    hr = THR(CMarkup::GetBaseUrl(NULL, &pchUrl, this));
    if (hr)
        goto Cleanup;
        
    hr = THR(FormsAllocString(pchUrl, pbstr));
    if (hr)
        goto Cleanup;
        
Cleanup:
    RRETURN(hr);
}


//+--------------------------------------------------------------------------
//
//  Member:     COleSite::attachEvent
//
//  Synopsis:   Attach the event
//
//---------------------------------------------------------------------------

HRESULT 
COleSite::attachEvent(BSTR bstrEvent, IDispatch* pDisp, VARIANT_BOOL *pResult)
{
    DISPID      dispid;
    HRESULT     hr = S_OK;
    ITypeInfo * pTIEvent;

    if (!bstrEvent || !pDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    //
    // First see if the event coming in is an event on the ocx.
    // If so, use it's dispid.  Otherwise just use the base implementation
    //

    EnsurePrivateSink();
    pTIEvent = GetClassInfo()->_pTypeInfoEvents;
    if (pTIEvent)
    {
        hr = THR_NOTRACE(pTIEvent->GetIDsOfNames(
                &bstrEvent,
                1,
                &dispid));
        if (!hr)
        {
            hr = THR(AddDispatchObjectMultiple(
                    dispid,
                    pDisp,
                    CAttrValue::AA_AttachEvent,
                    CAttrValue::AA_Extra_OldEventStyle));
            goto Cleanup;
        }
    }
    
    hr = THR(super::attachEvent(bstrEvent, pDisp, pResult));

Cleanup:
    if (pResult)
    {
        *pResult = hr ? VARIANT_FALSE : VARIANT_TRUE;
    }

    RRETURN(SetErrorInfo(hr));
}
        

//+--------------------------------------------------------------------------
//
//  Member:     COleSite::detachEvent
//
//  Synopsis:   Detach the event
//
//---------------------------------------------------------------------------

HRESULT
COleSite::detachEvent(BSTR bstrEvent, IDispatch* pDisp)
{
    DISPID      dispid;
    HRESULT     hr = S_OK;
    ITypeInfo * pTIEvent;
    AAINDEX     aaidx = AA_IDX_UNKNOWN;
    IDispatch * pThisDisp = NULL;
    
    if (!bstrEvent || !pDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    //
    // First see if the event coming in is an event on the ocx.
    // If so, use it's dispid.  Otherwise just use the base implementation
    //

    pTIEvent = GetClassInfo()->_pTypeInfoEvents;
    if (pTIEvent)
    {
        hr = THR_NOTRACE(pTIEvent->GetIDsOfNames(
                &bstrEvent,
                1,
                &dispid));
        if (!hr)
        {
            // Find event that has this function pointer.
            for (;;)
            {
                aaidx = FindNextAAIndex(dispid, CAttrValue::AA_AttachEvent, aaidx);
                if (aaidx == AA_IDX_UNKNOWN)
                    break;

                ClearInterface(&pThisDisp);
                if (GetDispatchObjectAt(aaidx, &pThisDisp))
                    continue;

                if (IsSameObject(pDisp, pThisDisp))
                    break;
            };

            // Found item to delete?
            if (aaidx != AA_IDX_UNKNOWN)
            {
                DeleteAt(aaidx);
            }
            goto Cleanup;
        }
    }
    
    hr = THR(super::detachEvent(bstrEvent, pDisp));

Cleanup:
    ReleaseInterface(pThisDisp);
    RRETURN(SetErrorInfo(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\ole\pluginst.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       pluginst.cxx
//
//  Contents:   CPluginSite
//
//  Netscape plugin site code.  Works closely with plugin.ocx.
//
//  FYI:  A plugin is recorded in the HTML as:
//
//      <embed src="empty.vts" width=550 height=295 othername=otherval> 
//
//  Thus the plugin parameters are all recorded as tag attributes.  Contrast
//  this with an ActiveX imbedding which is stored as:
//     <OBJECT CLASSID = "clsid:01000000-840E-11CE-99BF-00AA0047D4FD">
//         <PARAM NAME="_Version" VALUE="65536">
//         <PARAM NAME="_ExtentX" VALUE="4445">
//         <PARAM NAME="_ExtentY" VALUE="3196">
//         <PARAM NAME="_StockProps" VALUE="13"></OBJECT>
//
//  Here is the IActiveXPlugin interface we use to communicate with plugin.ocx
//     interface IActiveXPlugin : IDispatch 
//     {
//        // Properties
//        // Methods
//        void Load([in]BSTR bstrUrl, [in]int bDeleteRegistry);
//        void AddParam([in]BSTR bstrName, [in]BSTR bstrValue);
//        void Show(void);
//        void Hide(void);
//        void Clear(void);
//        // get the Plugin's IDispatch, if any, otherwise return NULL
//        [propget] HRESULT dispatch([out, retval] IDispatch** retval);
//  
//     };
/*  Here is the plugin HTML spec from www.netscape.com:

Embedded plug-ins are loaded by Navigator when the user encounters an HTML page 
with an embedded object with a MIME type registered by a plug-in. When loaded, 
an embedded plug-in is displayed as part of the HTML document in a rectangular 
subpart of the page. This is similar to how a GIF or JPEG image is embedded, 
except that the plug-in can be live and respond to user events (such as mouse
 clicks). 

Plug-in objects are embedded in an HTML page by using the EMBED tag. The syntax
 of the EMBED tag is: 

<EMBED attributes> ... </EMBED>      [**** Tomsn note: the </EMBED> is often omitted]


Use the following attributes with the EMBED tag: 

HEIGHT="value" defines the horizontal location of the plug-in in the HTML page. 
    The unit of measurement is optionally defined by the UNITS attribute. 

HIDDEN="value" indicates whether the plug-in is visible on the page. 
    The value can be either true (the default) or false. A value of true 
    overrides the values of HEIGHT and WIDTH, making the plug-in zero-sized. 
    Always explicitly set HIDDEN=true to make an invisible plug-in (rather 
    than simply setting the HEIGHT and WIDTH to zero). 

PALETTE="value" indicates the mode of the plug-in's color palette. 
    The value can be either foreground or background (the default). 
    The palette mode is only relevant on the Windows platform. 

PLUGINSPAGE="URL" indicates the location of instructions on installing 
    the plug-in. The value URL is a standard uniform resource locator. 
    The URL is used by the assisted installation process if the plug-in 
    registered for the MIME type of this EMBED tag is not found. 

SRC="URL" optionally indicates the location of the plug-in data file.
    The value URL is a standard uniform resource locator. The MIME type of 
    the file (typically based on the file-name suffix) determines which 
    plug-in is loaded to handle this EMBED tag. Either the SRC attribute 
    or the TYPE attribute is required in an EMBED tag. 

TYPE="type" optionally indicates the MIME type of the EMBED tag, which 
    in turn determines which plug-in is loaded to handle this EMBED tag. 
    Either the SRC attribute or the TYPE attribute is required in an EMBED tag. 
    Use TYPE instead of SRC for plug-ins that require no data (for example, 
    a plug-in that draws an analog clock) or plug-ins that fetch all their 
    data dynamically. 

WIDTH="value " optionally defines the vertical location of the plug-in in 
    the HTML page. The unit of measurement is optionally defined by the 
    UNITS attribute. 

UNITS="value" defines the measurement unit used by the HEIGHT and WIDTH 
    attributes. The value can be either pixels (the default) or en 
    (half the point size). 

In addition to these standard attributes, plug-ins may optionally have private 
attributes to communicate specialized information between the HTML page and 
the plug-in code. Navigator ignores all non-standard attributes when parsing 
the HTML, but passes all attributes to the plug-in, allowing the plug-in to 
examine the attribute list for any private attributes that may modify its behavior. 

For example, a plug-in that displays video could have private attributes 
to determine whether the plug-in should automatically start playing the video, 
and whether the video should automatically loop on playback. Thus an example 
EMBED tag could be: 

<EMBED SRC="myavi.avi" WIDTH=320 HEIGHT=200 AUTOSTART=true LOOP=true>

Navigator would interpret the SRC tag to load the data file and determine the 
MIME type of the data, and the WIDTH and HEIGHT tags to size the area of the 
page handled by the plug-in to be 320 by 200 pixels. Navigator would simply 
ignore private attributes AUTOSTART and LOOP and pass them to the plug-in with 
the rest of the attributes. The plug-in could then scan its list of attributes 
to see if it should automatically start the video and loop it on playback. 
 */
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_PLUGINST_HXX_
#define X_PLUGINST_HXX_
#include "pluginst.hxx"
#endif

#ifndef X_PROPBAG_HXX_
#define X_PROPBAG_HXX_
#include "propbag.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X_INETREG_H_
#define X_INETREG_H_
#include "inetreg.h"    // for REGSTR_VAL_CODEDOWNLOAD & stuff
#endif

#ifndef X_PLUGIN_I_H_
#define X_PLUGIN_I_H_
#include "plugin_i.h"   // IActiveXPlugin interface definition.
#endif

#define _cxx_
#include "pluginst.hdl"

MtDefine(CPluginSite, Elements, "CPluginSite")
MtDefine(MapExtnToKnownControl, CPluginSite, "MapExtnToKnownControl (code base)")
MtDefine(CPluginSiteCreateObject, CPluginSite, "CPluginSite::CreateObject");

// These are the clsids for the actual plugin.ocx control:
const GUID CDECL IID_IActiveXPlugin =
{  0x06DD38D1L,0xD187,0x11CF,{ 0xA8,0x0D,0x00,0xC0,0x4F,0xD7,0x4A,0xD8}};

const GUID CDECL CLSID_ActiveXPlugin =
  { 0x06DD38D3L,0xD187,0x11CF, {0xA8,0x0D,0x00,0xC0,0x4F,0xD7,0x4A,0xD8}};

const CElement::CLASSDESC CPluginSite::s_classdesc =
{
    {
        &CLSID_HTMLEmbed,              // _pclsid
        0,                             // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                        // _pcpi
        ELEMENTDESC_NEVERSCROLL    |
        ELEMENTDESC_OLESITE,           // _dwFlags
        &IID_IHTMLEmbedElement,        // _piidDispinterface
        &s_apHdlDescs,                 // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLEmbedElement, // _pfnTearOff
    NULL                               // _pAccelsRun
};


HRESULT 
CPluginSite::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);

    *ppElement = new CPluginSite(pDoc);

    RRETURN ( (*ppElement) ? S_OK : E_OUTOFMEMORY);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPluginSite::get_BaseHref
//
//  Synopsis:   Returns the base href for this object tag.
//              Uses the helper provided by COleSite.
//              BTW, this is the only abstract property in pluginst.pdl,
//              therefore this is the only get/set routine in this src file.
//
//----------------------------------------------------------------------------

HRESULT
CPluginSite::get_BaseHref(BSTR *pbstr)
{
    RRETURN( SetErrorInfo(GetBaseHref( pbstr )) );
}


//+---------------------------------------------------------------------------
//
//  Member:     CPluginSite::CreateObject
//
//  Synopsis:   Called by our super when it comes time to actually create
//              the ActiveX Plugin control.
//
//              We gather the parameters from two places: 1) CUnknownPair
//              list which hase the <embed unknown1=this unknown2=that>
//              type pairs, and 2) _pAA attributes list is is accessed via
//              all our custom get_XXX() routines.  This list contains all the
//              known properties such as <embed width=4444 src=a_plugin.vts>.
//              These properties are available to vbscript code.
//
//              We transmit the properties to plugin.ocx via two routes: 1)
//              Load( pPropertyBag ).  This way the control gets all the known
//              properties up front at load time.  Eventially we may support
//              IPersistPropertyBag2 which will let the control find *all* properties,
//              known and unknown, at load time.  2) Call pActiveXPlugin->Load()
//              for every propety, know and unknown.
//
//              What this gives us is a uniform presentation of properties to 
//              plugin.ocx.  It can choose to use them at the Load( pPropertyBag ) time,
//              at the pActiveXPlugin->Load() time, or a mixture of the two.
//----------------------------------------------------------------------------

BOOL TryAsActiveXControl(CDoc *pDoc, LPCTSTR pszFile, LPTSTR pszClassId, 
 LPTSTR *ppszCodeBase, LPCTSTR szMimeTypeIn);

// This routine is exported by urlmon and should appear in a public header
// someday:
STDAPI FindMimeFromData(
                        LPBC pBC,                   // bind context - can be NULL
                        LPCWSTR pwzUrl,             // url - can be null 
                        LPVOID pBuffer,             // buffer with data to sniff - can be null (pwzUrl must be valid)
                        DWORD cbSize,               // size of buffer
                        LPCWSTR pwzMimeProposed,    // proposed mime if - can be null
                        DWORD dwMimeFlags,          // will be determined
                        LPWSTR *ppwzMimeOut,        // the suggested mime
                        DWORD dwReserved);          // must be 0

BOOL GetMimeTypeFromUrl(LPCTSTR url, TCHAR *mime);

HRESULT
CPluginSite::CreateObject()
{
    HRESULT             hr = E_FAIL;
    LPCTSTR             pszSrc = NULL;
    OLECREATEINFO       info;
    TCHAR               szClassId[2*CLSID_STRLEN];
    TCHAR               szMime[MAX_PATH];
    LPCTSTR             pszMime = NULL;
    LPTSTR              pszCodeBase = NULL;
    CMarkup *           pMarkup = GetMarkup();
    CDoc *              pDoc;

    if (pMarkup == NULL)
    {
        AssertSz(FALSE, "Should have a markup");
        RRETURN(hr);
    }
    pDoc = pMarkup->Doc();

    GWKillMethodCall((COleSite *)this, ONCALL_METHOD(COleSite, DeferredCreateObject, deferredcreateobject), 0);

    pDoc->AddRef();
    
    //
    // If user settings or other factors outside us prohibit
    // ActiveX controls and Plugins from running, then we
    // fail this create entirely:
    //

    if (!AllowCreate(CLSID_ActiveXPlugin))
        goto Cleanup;

    // See if this is printing and we've got a snapshot
    // TODO PRINT 112553: Can we share implementation with CObjectElement in COleSite ?
    if (pMarkup->IsPrintMedia())
    {
        DISPID dispid;
        LPTSTR pchEMF = NULL;
        
        if (S_OK == THR(GetExpandoDispID(_T("_Snapshot_EMF"), &dispid, 0))
            && (*GetAttrArray())->FindString(dispid, (LPCTSTR*)&pchEMF, CAttrValue::AA_Expando)
            && pchEMF)
        {
            // "_ZERO" means that the original didn't have layout, or had zero size.
            // We don't need it at all.
            if (0 !=_tcscmp(pchEMF, _T("_ZERO")))
            {
                // Open the metafile and hold on to it
                if (g_dwPlatformID == VER_PLATFORM_WIN32_NT)
                {
                    // Use Unicode file name
                    _hemfSnapshot = GetEnhMetaFile(pchEMF);
                }
                else
                {
                    // Use ANSI file name
                    char achFileNameA[MAX_PATH];
                    if (WideCharToMultiByte(CP_OEMCP, 0, pchEMF, -1, achFileNameA, MAX_PATH, NULL, NULL))
                    {
                        _hemfSnapshot = GetEnhMetaFileA(achFileNameA);
                    }
                }
            }
            
            // Supply a dummy object to pretend we've loaded it. It will fail all QIs and do nothing.
            _pUnkCtrl = (IUnknown *) new CDummyUnknown;
            _pUnkCtrl->AddRef();

            // we are done. we don't need to load anytning else, metafile is all we need.
            goto Cleanup;
        }
    }

    /////////////////////////////////////////////////////////////////////////////////////////////
    // winse 24131 a-naande 5-2-02
    // adapted from CMarkup::LoadFromInfo, when the plugin is being reloaded, it doesn't get named
    // which can mess up navigation in frames, so check if it should be named and then set the name
    BSTR bstrName = NULL;
    if (pDoc->_fViewLinkedInWebOC && pMarkup->IsPrimaryMarkup())
    {
        COmWindowProxy * pOmWindowProxy = pDoc->GetOuterWindow();

        if (pOmWindowProxy)
            IGNORE_HR(pOmWindowProxy->Window()->get_name(&bstrName));
    }

    if ((pMarkup->IsPrimaryMarkup() || (pMarkup->HasWindowPending() && pMarkup->GetWindowPending()->Markup()->IsPrimaryMarkup())) 
        && bstrName 
        && *bstrName)
    {
        hr = pDoc->_pWindowPrimary->put_name(bstrName);
    }

    if(bstrName)FormsFreeString(bstrName);
    // end 24131
    ///////////////////////////////////////////////////////////////////////////////////////////////

    // If this is a full-window embed, try to use the content type
    // reported to the binding via IMonikerProp for the plugin data file.
    if (pDoc->_fFullWindowEmbed)
    {
        pszMime = pDoc->_cstrPluginContentType;
        if (pszMime)
            SetAAtype(pszMime);
    }


    // If current document was obtained by POST action, the src attribute is
    // incorrect.  Use path to the cached data file instead.
    //
    // TODO:    What if the cached file is still being downloaded??  Can we
    //          still hand this to the plugin/control?  Or should we wait until
    //          the file is fully downloaded?  (philco)
    if (pDoc->_fFullWindowEmbed && pMarkup->GetDwnPost())
    {
        if(!pDoc->_fUseSrcURL)
            SetAAsrc(pDoc->_cstrPluginCacheFilename);
    }


    _fHidden = GetAAhidden();

    pszSrc = GetAAsrc();
    pszMime = GetAAtype();  // 'type' attribute is the mime type.

    if( !pszSrc && !pszMime )
        goto Cleanup;

    // Make sure we have at least an empty param bag allocated:
    hr = THR(EnsureParamBag());
    if (hr)
        goto Cleanup;

    Assert(_pParamBag);
    info.pPropBag = _pParamBag;
    info.pPropBag->AddRef();

#if 0
    // This URLMON call does not do a thorough enough job - it stops
    // just short of contacting the server to dertermine the mime type.
    // Thus we do the call just below this.
    FindMimeFromData( NULL, pszSrc, NULL, 0, NULL, 0, &pszMime, 0 );
#endif

    // Give the plugin the fully qualified URL of the plugin src file:
    if( pszSrc )
    {
        TCHAR   cBuf[pdlUrlLen];
        CMarkup::ExpandUrl(NULL, pszSrc, ARRAY_SIZE(cBuf), cBuf, this);

        if (!pMarkup->ValidateSecureUrl(pMarkup->IsPendingRoot(), cBuf, FALSE, FALSE))
        {
            // If unsecure, NULLify URL
            pszSrc = NULL;
            Assert(!_pszFullUrl);
        }
        else
        {
            MemAllocString(Mt(CPluginSiteCreateObject), cBuf, &_pszFullUrl);
            if (_pszFullUrl == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
    }

    // Track down the mime type.
    // If it is not given explicitly via an attribute of the <embed> tag, 
    // then query the server about what it thinks the mime type is.
    if( !pszMime && GetMimeTypeFromUrl(_pszFullUrl, szMime) )
    {
        // Some servers lie about the mime type and return "text/plain" to
        // confuse us.  Therefore we ignore such uninformative returns.
        if( StrCmpIC( szMime, _T("text/plain") ) && StrCmpIC( szMime, _T("text/html") ))
        {
            pszMime = szMime;
            hr = SetAAtype(pszMime);
            if( FAILED( hr ) )
                goto Cleanup;
        }
        else
        {
            // One last chance.  If this is a full-window embed, use the 
            // content type reported to the binding used for the plugin data file.
            if (pDoc->_fFullWindowEmbed)
            {
                pszMime = pDoc->_cstrPluginContentType;
                hr = SetAAtype(pszMime);
                if( FAILED( hr ) )
                    goto Cleanup;
            }
        }
    }


    // First decide if we should actually create an ActiveX control
    // to handle this data.  Notice pszCodeBase is an OUT param which
    // if allocated gets freed in the Cleanup.
    if( TryAsActiveXControl( pDoc, pszSrc, szClassId, &pszCodeBase, pszMime ) )
    {   //
        // Create ActiveX control directly code path....
        //
        hr = CLSIDFromHtmlString( szClassId, &info.clsid );
        if (FAILED(hr))
        {
            hr = THR(CLSIDFromString(szClassId, &info.clsid));
            if (FAILED(hr))
                goto Cleanup;
        }
        
        MemReplaceString(Mt(OleCreateInfo), pszCodeBase, &info.pchSourceUrl);

        // Set particular parameters based on what we know from other
        // places:
        if( pszCodeBase )
        {
            hr = SetAAcodeBase(pszCodeBase);
            if( FAILED( hr ) )
                goto Cleanup;
        }

        // Save them again so all that new stuff gets propagated to the
        // property bag:
        hr = THR(SaveAttributes(_pParamBag, FALSE));
        if (hr)
            goto Cleanup;
    
        // Right now super:: is COleSite.  If that ever changes you'd
        // better eyeball this whole routine closely.
        _fUsingActiveXControl = TRUE;
        hr = super::CreateObject( &info );
        // Be aware that that CreateObject() call is asynchronous and
        // COleSite will finish creating the object on the CreateObjectNow()
        // callback from CCodeLoad.
    }
    else if(Doc()->_pOptionSettings->fUsePlugin ) 
    {   //
        // Normal plugin.ocx plugin handling code path...
        //
        info.clsid = CLSID_ActiveXPlugin;
    
        // This saves all, known & unknown attributes into the property bag:
        hr = THR(SaveAttributes(_pParamBag, FALSE));
        if (hr)
            goto Cleanup;
    
        _fUsingActiveXControl = FALSE;
        hr = THR(super::CreateObject(&info));
        if (hr)
            goto Cleanup;
        // Be aware that that CreateObject() call is asynchronous and
        // WE will finish creating the object on the CreateObjectNow()
        // callback from CCodeLoad.
    }
    
Cleanup:
    pDoc->Release();
    MemFreeString(pszCodeBase);
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CPluginSite::PostLoad
//
//  Synopsis:   Called after the OLE site loads it's component in the normal
//              way.  Used to perform special actions after loading.
//
//---------------------------------------------------------------
HRESULT
CPluginSite::PostLoad()
{
    IActiveXPlugin *    pIActiveXPlugin = NULL;
    HRESULT             hr = S_OK;

    if( !_fUsingActiveXControl ) 
    {
        hr = QueryControlInterface(IID_IActiveXPlugin, (LPVOID*)&pIActiveXPlugin);
        if (hr)
            goto Cleanup;

        // _pszFullUrl may be NULL & that's OK.
        pIActiveXPlugin->Load( _pszFullUrl, FALSE );
    }

  Cleanup:
    ReleaseInterface(pIActiveXPlugin);
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CPluginSite::Passivate
//
//  Synopsis:   Called when main CSite reference count (_ulRefs) drops
//              to zero. Do not call this method directly.  Use
//              IUnknown::Release instead.
//
//---------------------------------------------------------------

void
CPluginSite::Passivate()
{
    MemFree( _pszFullUrl );
    _pszFullUrl = NULL;

    ReleaseParamBag();

    super::Passivate();
}


//+---------------------------------------------------------------------------
//
//  Member:     CPluginSite::Save
//
//  Synopsis:   Call PLUGIN.OCX to save its parambag, and look for special printing keyword
//              IE5/60771
//
//----------------------------------------------------------------------------

HRESULT
CPluginSite::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr = S_OK;
    DISPID  expandoDISPID = DISPID_UNKNOWN;

    
    if (!fEnd && pStreamWrBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC))
    {
        CDoc * pDoc = Doc();

        // Only create expando if no other print jobs are pending, so we don't have to
        // freeze the document for too long.
        if (!pDoc || !pDoc->_fSaveTempfileForPrinting || pDoc->PrintJobsPending())
            goto Cleanup;

        // Save metafile snapshot for printing 
        BOOL fSnapshotSucceeded = FALSE;
        if (_pUnkCtrl)
        {
            TCHAR   achTempFileName[MAX_PATH];
            
            if (S_OK == SaveMetaFileSnapshot(achTempFileName))
            {
                // Create an expando
                hr = THR_NOTRACE(AddExpando(L"_Snapshot_EMF", &expandoDISPID));
                if (hr)
                    goto Cleanup;

                expandoDISPID = expandoDISPID - DISPID_EXPANDO_BASE +
                    DISPID_ACTIVEX_EXPANDO_BASE;

                hr = THR(AddString(
                        expandoDISPID,
                        achTempFileName,
                        CAttrValue::AA_Expando));
                if (hr)
                    goto Cleanup;

                AssertSz(TRUE, "Plugin: metafile snapshot succeeded!");
                fSnapshotSucceeded = TRUE;
            }
            else
            {
                // Snapshot failed. We may need to marshall a pointer if it doesn't work
                AssertSz(0, "Failed to save metafile shapshot");
            }
        }

#if 0   // TODO PRINT 112553: There is still code in plugin.ocx (in Controls project) that supports
        //                    IE5-style marshalled pointers. That code should be cleaned up too.
        //                    Use this to guide you to the obsolete code in control.cpp (or search for "alexmog" there).
        
        // If snapshot was not successful, marshal pUnknown
        if (!fSnapshotSucceeded && 
            OK(ExchangeParamBag(FROMCONTROL)))
        {
            // If we have a marshaled punk, add an expando for it.
            //
            VARIANT   var;
            PROPBAG2  propbag;
            TCHAR     szBuf[16];

            memset(&propbag, 0, sizeof(PROPBAG2));
            propbag.vt = VT_I4;
            propbag.pstrName = L"_Marshaled_pUnk";

            // Look for a parameter named "_Marshaled_pUnk"
            //
            VariantInit(&var);
            if (OK(_pParamBag->Read(1, &propbag, NULL, &var, &hr)) && OK(hr))
            {
                // I think we need it to be a string?
                //
                if (var.vt == VT_I4)
                {
                    wsprintf(szBuf, L"%d", var.ulVal);
                    VariantClear(&var);

                    // Create an expando

                    hr = THR_NOTRACE(AddExpando(L"_Marshaled_pUnk", &expandoDISPID));
                    if (hr)
                        goto Cleanup;

                    expandoDISPID = expandoDISPID - DISPID_EXPANDO_BASE +
                        DISPID_ACTIVEX_EXPANDO_BASE;

                    hr = THR(AddString(
                            expandoDISPID,
                            szBuf,
                            CAttrValue::AA_Expando));
                    if (hr)
                        goto Cleanup;

                    // Let DoPrint know we now rely on the original document to stick around.
                    pDoc->_fPrintedDocSavedPlugins = TRUE;
                }
            }
        }
#endif
    }

Cleanup:
        hr = THR(super::Save(pStreamWrBuff, fEnd));

    // If we added an expando to save the punk, remove it now.
    if (expandoDISPID != DISPID_UNKNOWN)
        FindAAIndexAndDelete(expandoDISPID, CAttrValue::AA_Expando);
    
    ReleaseParamBag();
    RRETURN1(hr, S_FALSE);
}


//=================================================================
//===== THIS HELPER CODE STOLEN FROM IE3.0 PLUGIN.OCX FILE DIALOGS.CPP
//=================================================================

//////////////////////////////////////////////////////////////////////////
//
//    GetMimeTypeFromUrl                                         [PUBLIC]
//
//  Ideally we would not have synchronous calls like this into wininet
// on the GUI thread.  They should be made asynchronous and use a callback
// to return the data when available.  The callback support in wininet, 
// however, makes cross thread calls to the callback function.  We can not
// use that.  The asynchronous support in urlmon.dll, which does the correct
// same-thread callback behavior, does not have an interface for just querying
// the mime type.  You must download the data and you then get the mime type
// as a side effect.  We don't want to download the data at this time.
//
// To work around the possibility of freezing the GUI thread while waiting for
// a response from the internet server, we set the timeout to be a relatively
// low 10 seconds.  
//
BOOL GetMimeTypeFromUrl(LPCTSTR url, TCHAR *mime)
{
   BOOL        bRet = FALSE;
#ifdef WIN16
   // BUGWIN16
   TraceTag((tagError, "GetMimeTypeFromUrl - pluginst.cxx, need to plugin ours !!"));
#else
   HINTERNET   hInternet=NULL;                 // opened connection
   HINTERNET   hRequest=NULL;                  // opened request
   DWORD       dwSize  = MAX_PATH;        // size of buffer returned
   DWORD       dwTimeout = 10000;   // 10 seconds.

   Assert( mime );

   if (NULL == url)
      goto Cleanup;

   if (NULL == (hInternet = InternetOpen(_T("contype"), INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0)))
      goto Cleanup;

   InternetSetOption( hInternet, INTERNET_OPTION_CONNECT_TIMEOUT, (LPVOID)&dwTimeout, sizeof(dwTimeout) );
   InternetSetOption( hInternet, INTERNET_OPTION_DATA_RECEIVE_TIMEOUT, (LPVOID)&dwTimeout, sizeof(dwTimeout) );
   InternetSetOption( hInternet, INTERNET_OPTION_SEND_TIMEOUT, (LPVOID)&dwTimeout, sizeof(dwTimeout) );
   InternetSetOption( hInternet, INTERNET_OPTION_RECEIVE_TIMEOUT, (LPVOID)&dwTimeout, sizeof(dwTimeout) );

   if (NULL == (hRequest  = InternetOpenUrl(hInternet, url, _T("Accept: */*"), (ULONG)-1, 0, 0)))
      goto Cleanup;

   if (!HttpQueryInfo(hRequest, HTTP_QUERY_CONTENT_TYPE, mime, &dwSize, NULL))
      goto Cleanup;

   if (dwSize > 0)
      bRet = TRUE;

  Cleanup:
   if( hRequest )
      InternetCloseHandle(hRequest);
   if( hInternet )
      InternetCloseHandle(hInternet);

#endif
   return (bRet);
}

//=================================================================
//===== THIS DIALOG CODE STOLEN FROM IE3.0 SOURCE FILES DLG_PLUG.*
//=================================================================

typedef struct {
    LPCTSTR  szExt;
    LPCTSTR  szMIMEtype;
} DLGPLUGDATA, *LPDLGPLUGDATA;

INT_PTR CALLBACK OCXOrPluginDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            LPDLGPLUGDATA lpPlug;
            lpPlug = (LPDLGPLUGDATA) lParam;

            // turn checkbox on
            CheckDlgButton(hDlg, IDC_PLUGIN_UPGRADE_CHECK, TRUE);

            // set dialog text for MIME and Extention
            SetDlgItemText(hDlg, IDC_PLUGIN_UPGRADE_MIME_TYPE, 
                lpPlug->szMIMEtype);
            SetDlgItemText(hDlg, IDC_PLUGIN_UPGRADE_EXTENSION, 
                lpPlug->szExt);
        }
        return FALSE;

    case WM_DESTROY:
        return TRUE;
/*
    case WM_HELP:            // F1
        ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
        HELP_WM_HELP, (DWORD)(LPSTR)mapIDCsToIDHs);
        break;

    case WM_CONTEXTMENU:        // right mouse click
        ResWinHelp( (HWND) wParam, IDS_HELPFILE,
        HELP_CONTEXTMENU, (DWORD)(LPSTR)mapIDCsToIDHs);
        break;
*/
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {

            case IDYES:
                if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                {
                    EndDialog(hDlg, IDYES);
                    return TRUE;
                }
                break;

            case IDCANCEL:
                if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                {
                    EndDialog(hDlg, IDCANCEL);
                    return TRUE;
                }
                break;

            case IDNO:
                if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                {
                    if (IsDlgButtonChecked(hDlg, IDC_PLUGIN_UPGRADE_CHECK))
                        EndDialog(hDlg, IDCANCEL );
                    else
                        EndDialog(hDlg, IDNO);
                    return TRUE;
                }
                break;
        }

    }

    return FALSE;
}

//=================================================================
//===== THIS CODE STOLEN FROM IE3.0 SOURCE FILE HTML.C
//=================================================================

const static TCHAR * szKNOWNCONTROLS = 
    _T("Software\\Microsoft\\Internet Explorer\\EmbedExtnToClsidMappings\\");

const static TCHAR * szKNOWNCONTROLSOVER = 
    _T("Software\\Microsoft\\Internet Explorer\\EmbedExtnToClsidMappingOverride\\");
    
// MapExtnToKnownControl
// Looks up a registry mapping for Extn to Clsid + CODEBASE (if available)
// Returns: 
//  TRUE: if found a clsid for extn
//  FALSE: not found or any error
BOOL MapExtnToKnownControl(TCHAR *fileExt, TCHAR *szClassId, TCHAR **ppszCodeBase)
{
    DWORD Size = MAX_PATH;
    DWORD dwType =0;
    LONG lResult = ERROR_SUCCESS;

    const static TCHAR * szCODEBASE = _T("CODEBASE");

    TCHAR szKey[pdlUrlLen];
    TCHAR szCodeBase[pdlUrlLen];
    HKEY hKeyExt = 0;

    BOOL fRet = FALSE;

    wcscpy(szKey, szKNOWNCONTROLS);
    wcsncat(szKey, fileExt, sizeof(szKey)/sizeof(TCHAR) - lstrlen(szKNOWNCONTROLS));    
    
    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, 
                        KEY_READ, &hKeyExt);

    if (lResult == ERROR_SUCCESS) {

        Size = MAX_PATH;
        lResult = RegQueryValueEx(hKeyExt, NULL, NULL, &dwType, 
                            (LPBYTE)szClassId, &Size);

        if (lResult == ERROR_SUCCESS) {

            fRet = TRUE;

            Size = pdlUrlLen;
            lResult = RegQueryValueEx(hKeyExt, szCODEBASE, NULL, &dwType, 
                                (LPBYTE)szCodeBase, &Size);

            if (lResult == ERROR_SUCCESS) {
                HRESULT hr = MemAllocString( Mt(MapExtnToKnownControl), szCodeBase, ppszCodeBase );
                if( hr )
                    fRet = FALSE;
            }
        }

        if (hKeyExt)
        {
            RegCloseKey(hKeyExt);
            hKeyExt = NULL; 
        }            
    }

    //
    // Also check for Override key path...
    //
    if ( ! fRet )
    {
        wcscpy(szKey, szKNOWNCONTROLSOVER);     
        wcsncat(szKey, fileExt, sizeof(szKey)/sizeof(TCHAR) - lstrlen(szKNOWNCONTROLSOVER));
        
        Assert( ! hKeyExt ); 
        
        lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, 
                            KEY_READ, &hKeyExt);

        if (lResult == ERROR_SUCCESS) {

            Size = MAX_PATH;
            lResult = RegQueryValueEx(hKeyExt, NULL, NULL, &dwType, 
                                (LPBYTE)szClassId, &Size);

            if (lResult == ERROR_SUCCESS) {

                fRet = TRUE;

                Size = pdlUrlLen;
                lResult = RegQueryValueEx(hKeyExt, szCODEBASE, NULL, &dwType, 
                                    (LPBYTE)szCodeBase, &Size);

                if (lResult == ERROR_SUCCESS) {
                    HRESULT hr = MemAllocString( Mt(MapExtnToKnownControl), szCodeBase, ppszCodeBase );
                    if( hr )
                        fRet = FALSE;
                }
            }

            if (hKeyExt)
                RegCloseKey(hKeyExt);
        }
    }
    
    return fRet;
}

BOOL UserPrefersControlOverPlugin(CDoc *pDoc, TCHAR const *szName, TCHAR *fileExt)
{

    BOOL fRet;
    TCHAR szKey[MAX_PATH];
    int Choice;
    DLGPLUGDATA   Plug;
    HWND hwndParent;

    Plug.szExt = fileExt;
    Plug.szMIMEtype = szName;

    {
        CDoEnableModeless   dem(pDoc, NULL);
        
        hwndParent = dem._hwnd;
        Choice = DialogBoxParam(GetResourceHInst(),
                              MAKEINTRESOURCE(IDD_PLUGIN_UPGRADE),
                              hwndParent,
                              &OCXOrPluginDlgProc,
                              (LPARAM)&Plug);
    }
    
    switch (Choice) {

    case IDYES:
        fRet = TRUE;
        break;
        
    case IDNO:

        // never ask again for this data type/extn
        // remove the entry from the known controls list in the registry
        wcscpy(szKey, szKNOWNCONTROLS);
        wcscat(szKey, fileExt);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szKey);
        
    case IDCANCEL:
    default:

        fRet = FALSE;
        break;
    }

    return fRet;
}

#ifndef WIN16
#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"  // for string conversions.
#endif
#endif // !WIN16

//
// FindPlugin - delegates this call to the plugin OCX
//
BOOL FindPlugin(TCHAR *szFileExt, TCHAR *szName, TCHAR const *szMime)
{
   typedef (WINAPI *PFN_FINDPLUGIN)(char *ext, char *name, char *mime);
   PFN_FINDPLUGIN pfnFindPlugin;
   BOOL fRet = FALSE;

   HMODULE hLib = LoadLibraryEx(_T("plugin.ocx"), NULL, 0);
   if (hLib == NULL)
   {
       goto Exit;
   }

    // Wowza - I wish there was a FindPluginW() available....
   pfnFindPlugin = (PFN_FINDPLUGIN)GetProcAddress(hLib, "FindPluginA");
   if (pfnFindPlugin == NULL)
   {
       goto Exit;
   }

   //BUGWIN16: shortcut, CStrIn is not defined for several reasons.
   // we need to fix that before enabling this.
#ifndef WIN16
   {
        CStrIn strinFileExt(szFileExt), strinName(szName), strinMime(szMime);
        fRet = pfnFindPlugin(strinFileExt, strinName, strinMime);
   }
#endif // !WIN16
Exit:
   if (hLib)
      FreeLibrary(hLib);

   return fRet;
}

//
// Checks the registry to see if we should prefer a plugin over a certain
// control for a certain file extension. This was put in because some ActiveX
// controls do not fully support rendering the file extensions they claim.
//
// For example ActiveMovie doesn't support QuickTime VR .mov files.
//
BOOL PreferPluginOverControl(TCHAR *szFileExt, TCHAR *szClassId)
{
    HKEY hk;
    TCHAR szKeyName[MAX_PATH];
    TCHAR *pszRealClassId;

    //
    // The real classid name begins at szClassId + strlen("clsid:")
    //
    Assert(szClassId && wcslen(szClassId) > 6);
    pszRealClassId = szClassId + 6;

    // notice tricky braces '}' below due to bizarre look of the
    // pszRealClsid we get:
    Format( 0, szKeyName, MAX_PATH, _T("CLSID\\{<0s>\\EnablePlugin\\<1s>"), pszRealClassId, szFileExt);
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szKeyName, 0, KEY_READ, &hk) ==
        ERROR_SUCCESS)
    {
        RegCloseKey(hk); // Close the key immediately, just test for existance
        
        //
        // Now we know we have a control that doesn't handle this file extension
        // fully. So we make the expensive call to find out if there is a 
        // plugin that can handle this file extension. The sad assumption is 
        // that any plugins will handle this file type better than this control
        //
        if (FindPlugin(szFileExt, NULL, NULL))
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL PreferControlOverPlugin(CDoc *pDoc, TCHAR *fileExt, TCHAR const *pszMime)
{
    TCHAR name[MAX_PATH];
    HKEY hkey = NULL;
    TCHAR szDoCodeDownload[10]; // should only be "yes" or "no"
    DWORD cb;
    BOOL fRet = TRUE;

    name[0] = _T('\0');  // start out fresh and clean.

    if (!FindPlugin(fileExt, name, pszMime))
    {
        goto Exit;
    }

    // check to see if the user has set codedown load to "no"
    if (RegOpenKeyEx(HKEY_CURRENT_USER, TSZWININETPATH, (DWORD) NULL,
            KEY_ALL_ACCESS, &hkey) == ERROR_SUCCESS)
    {
        cb = sizeof(szDoCodeDownload);
        if (RegQueryValueEx(hkey, REGSTR_VAL_CODEDOWNLOAD, NULL,
                NULL, (LPBYTE)szDoCodeDownload, &cb) == ERROR_SUCCESS)
        {
            goto SkipDefault;
        }
    }

    // something went wrong... use default
    wcscpy(szDoCodeDownload, REGSTR_VAL_CODEDOWNLOAD_DEF);

SkipDefault:
    
    if (hkey)
        RegCloseKey(hkey);

    // if "no" codedownload... don't ask the question
    if (!_tcsicmp(szDoCodeDownload, TEXT("no")))
    {
        fRet = FALSE;
        goto Exit;  // return FALSE
    }

    // there is a plugin for this extn/mime on the system
    // we have to pop up a courtesy dialog to the user to check if they 
    // want to use the plugin or download the control

    fRet = UserPrefersControlOverPlugin(pDoc, pszMime, fileExt);

Exit:
    return fRet;
}


// TryAsActiveXControl
//
// try to locate an activeX control 
// if absent, check for known control extension to clsid mapping
// if absent or present and user wanted to use a plugin anyway
// fall to the plugin. Otherwise we go to the 
// object code with the clsid/codebase form the registry
#define REGKEY_DISABLEACTIVEX \
 _T("Software\\Microsoft\\Internet Explorer\\Plugins\\DisableActiveXControls")

int GetFileExtension(LPCTSTR szFilename, TCHAR **szExtension);
BOOL IsActiveXControl(LPCTSTR szFile, TCHAR *szClassId, TCHAR *fileExt, LPCTSTR szMimeTypeIn);

BOOL TryAsActiveXControl(CDoc *pDoc, LPCTSTR pszFile, LPTSTR pszClassId, 
 LPTSTR *ppszCodeBase, LPCTSTR szMimeTypeIn)
{
    TCHAR    *fileExt = NULL;    // file extension
    BOOL    fRet     = FALSE;    // return value
    HKEY    hKey     = NULL;     // reg key
    LONG    cbData     = 0;      // bytes to read
    TCHAR   szKey[MAX_PATH];
    HRESULT    hr;               // return code

    // Determine if searching for activex controls has been disabled...
    hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_DISABLEACTIVEX, 0, KEY_READ, &hKey);
    if (ERROR_SUCCESS == hr)
    {
       cbData = MAX_PATH;
       RegQueryValue(hKey, NULL, szKey, &cbData);
       RegCloseKey(hKey);
       if (StrCmpIC(szKey, _T("true")) == 0)
          return (FALSE);
    }

    // Need to parse the szFile to get the extension.
    // If this fails we carry on since we can also use the mimetype below.
    if( pszFile )
        GetFileExtension(pszFile, &fileExt);

    if (fileExt && _tcslen(fileExt) > 50)
    {
        //Qfe8503:If we have a szMimeTypeIn, then continue to search 
        // for ActiveX control by MimeType otherwise exit.    
        if ( ! szMimeTypeIn )
        {
            fRet = FALSE;
            goto exit;
        }
    }
    
    fRet = IsActiveXControl(pszFile, pszClassId,fileExt,szMimeTypeIn);

    // If we have no file extension then the processing below is not
    // applicable and we return the fRet just obtained.
    if (!fileExt)
        goto exit;

    //
    // If there is an ActiveXControl that we might want to use for this EMBED
    // tag, we check if there is a plugin that can handle this file extension
    // and if we prefer this plugin over this control. If so return FALSE;
    //
    if (fRet)
    {
        if(PreferPluginOverControl(fileExt, pszClassId))
        {
            fRet = FALSE; // set return value to FALSE so will use the PLUGIN
        }
        else
        {
            ;    // Do nothing as fRet is already TRUE so will use the CONTROL
        }

        //
        // Return result in fRet as we know we have a control or plugin to use.
        //
        goto exit;
    }

    // check for a Known control availabe

    fRet = MapExtnToKnownControl(fileExt, pszClassId, ppszCodeBase);

    if (!fRet)
        goto exit;    // if not found then use the plugin if any

    //
    // nolonger ask for courtesy dialog
    //
#if 0 
    // check for a plugin, and if found then
    // put up a courtesy dialog before proceeding
    fRet = PreferControlOverPlugin(pDoc, fileExt, szMimeTypeIn);
#endif

exit:
    if (fileExt)
        FormsFreeString(fileExt);

    return fRet;
}

//////////////////////////////////////////////////////////////////////////
//
//    ClsidFromMime  - Look up a mime type in the registry and find the
//                     activeX control's clsid.
//
//         szMimeType  - IN points at obj mime type, MAY BE NULL.
//         szClassId   - [RETURN] String pointing to the class id.
//   ----------->BEWARE: string contains a leading '{' char as is found
//                       in the registry.  Caller must get rid of it.
//                       We do null out the trailing '}' char. 
//
//       HRESULT        - [RETURN] If we mapped to control.
//
//    Looks up mimetype->clsid

HRESULT ClsidFromMime( TCHAR *szClassId, LPCTSTR szMimeType)
{
    HKEY     hKeyProgId  = NULL;  // registry key for prog id
    LONG     cbData;              // buffer size
    HRESULT  hr;                  // last return from Reg*** function
    DWORD    dwRet;
    TCHAR    pszRegKey[MAX_PATH];   // class id for the object

    Assert( szMimeType );

    hr = Format(0,pszRegKey,MAX_PATH,_T("MIME\\Database\\Content Type\\<0s>"), szMimeType); 
    if (FAILED(hr))
        goto CleanupHR;

    // Open the registry entry for the prog id
    dwRet = RegOpenKeyEx(HKEY_CLASSES_ROOT, pszRegKey, 0, KEY_READ, &hKeyProgId);
    if (ERROR_SUCCESS != dwRet )
        goto Cleanup;

    cbData = MAX_PATH;
    dwRet = RegQueryValueEx(hKeyProgId, _T("CLSID"), NULL, NULL, (LPBYTE)szClassId, (DWORD*)&cbData);

    // Get rid of the trailing '}'
    if ( ERROR_SUCCESS == dwRet && cbData >= 2 )
        szClassId[cbData - 2] = _T('\0');

  Cleanup:
    hr = HRESULT_FROM_WIN32( dwRet );

  CleanupHR:
    if (hKeyProgId != NULL)
        RegCloseKey(hKeyProgId);

    return( hr );
}
 
//////////////////////////////////////////////////////////////////////////
//
//    IsActiveXControl - only used by EMBED tag.
//
//       szFile      - The file to check to determine if we have a control. MAY BE NULL.
//       szClassId   - [RETURN] String pointing to the class id.
//       fileExt     - IN points at extn in szFile MAY BE NULL.
//       szMimeTypeIn- IN points at obj mime type, MAY BE NULL.
//
//       BOOL        - [RETURN] If we mapped to control.
//
//    Given a source URL or file to look at, we will search to determine
//    if the object is an ActiveX Control.
//
//    Looks up file extension->mimetype->clsid then if that fails
//                  extension->progid->clsid then if that fails
//                  mimetype->clsid
//    We give priority to the file extension mime type mapping over the
//    passed in mime type since this is closer to the original IE3
//    behavior which only used the file extension.
//
BOOL IsActiveXControl(LPCTSTR szFile, TCHAR *szClassId, TCHAR *fileExt, LPCTSTR szMimeTypeIn)
{
   HKEY     hKeyFileExt = NULL;  // opened registry key
   HKEY     hKeyProgId  = NULL;  // registry key for prog id
   HKEY     hKeyClassId = NULL;  // registry key for class id
   LONG     cbData;              // buffer size
   HRESULT  hr;                  // last return from Reg*** function
   HKEY     hKeyControl = NULL;  // registry key for control under clsid
   TCHAR    pszControl[MAX_PATH];   // path to control key
   TCHAR    pszMimeTypeOrProgId[MAX_PATH];  // prog id for the object
   TCHAR    pszClassId[MAX_PATH];   // class id for the object

    *pszMimeTypeOrProgId = _T('\0');

    if (fileExt)
    {
        // Try to open the key HKEY_CLASSES_ROOT\fileExt. to get mime type.
        //    Example HKEY_CLASSES_ROOT\.xls
        hr = RegOpenKeyEx(HKEY_CLASSES_ROOT, fileExt, 0, KEY_READ, &hKeyFileExt);
        if (ERROR_SUCCESS == hr)
        {
            cbData     = MAX_PATH;

            // We found the file extension in the registry... now, we
            // want to get the mime type, if present
            hr = RegQueryValueEx(hKeyFileExt, _T("Content Type"), NULL, NULL, (LPBYTE)pszMimeTypeOrProgId, (DWORD*)&cbData);
            if (ERROR_SUCCESS == hr)
            {
                hr = ClsidFromMime( pszClassId, pszMimeTypeOrProgId );
                if( !hr ) 
                    goto GotCLSID;
            }
        }
    }

    //
    // just fall thru and try the ext->progid->clsid lookup
    //
    cbData = MAX_PATH;   
    // now, try the progid for the object.
    hr = RegQueryValue(hKeyFileExt, NULL, pszMimeTypeOrProgId, &cbData);
    if (ERROR_SUCCESS != hr || cbData <= 0)
        goto TryMime;
   
    // Now that we have the prog id, let's go and get the CLSID.
    pszMimeTypeOrProgId[cbData-1] = _T('\0'); // append the NULL character to our string

    // Open the registry entry for the prog id
    hr = RegOpenKeyEx(HKEY_CLASSES_ROOT, pszMimeTypeOrProgId, 0, KEY_READ, &hKeyProgId);
    if (ERROR_SUCCESS != hr)
        goto TryMime;

    // Check to see if the object has a CLSID key.
    hr = RegOpenKeyEx(hKeyProgId, _T("CLSID"), 0, KEY_READ, &hKeyClassId);
    if (ERROR_SUCCESS != hr)
        goto TryMime;

    cbData = MAX_PATH;
    hr = RegQueryValue(hKeyClassId, NULL, pszClassId, &cbData);
    if (ERROR_SUCCESS != hr || cbData <= 0)
        goto TryMime;

    // In the object tag, the class id can not have the { }. So, we will remove the
    // brackets when we return the value of the class id.
    Format(0, pszControl, MAX_PATH, _T("CLSID\\<0s>\\Control"), pszClassId);
    hr = RegOpenKeyEx(HKEY_CLASSES_ROOT, pszControl, 0, KEY_READ, &hKeyControl);
    if (ERROR_SUCCESS == hr)
    {
        // The classid does refer to a control.  Get rid of the { } brackets in
        // the classid string:
        if( cbData >= 2 )
            pszClassId[cbData-2] = _T('\0');     // add the null to the end of the string where the }
    }
    else
    {
  TryMime:  
        // Try the passed in mime type directly.
        // if we don't have a mime type, then don't try to execute
        // the GotCLSID piece below, since pszClassId never gets set
        if (!szMimeTypeIn)
            goto Cleanup;   // hr is already an error code, so we'll return FALSE.

        hr = ClsidFromMime( pszClassId, szMimeTypeIn );
        if( hr ) 
            goto Cleanup;
    }

  GotCLSID:
    wcscpy(szClassId, _T("clsid:"));    // need to preface with "clsid:"
    wcscat(szClassId, pszClassId+1);  // copy the value to our out param
 
  Cleanup:
    // Close all open reg keys
    if (hKeyFileExt != NULL)
        RegCloseKey(hKeyFileExt);

    if (hKeyProgId != NULL)
        RegCloseKey(hKeyProgId);

    if (hKeyClassId != NULL)
        RegCloseKey(hKeyClassId);

    if (hKeyControl != NULL)
        RegCloseKey(hKeyControl);

    if (hr == ERROR_SUCCESS)
        return (TRUE);
    else
        return (FALSE);
}

//////////////////////////////////////////////////////////////////////////
//
//    GetFileExtension
//
//       szFilename     - [in] string containing the file name
//       szExtension    - [out] the file extension found
//                        WARNING - caller must free memory for szExtension
//
//       int            - [return] the number of characters in file extension
//
//    This function will return the file extension (including the .). And it 
//    will return the number of characters in the file extension.
//
int GetFileExtension(LPCTSTR szFilename, TCHAR **szExtension)
{
   int  count   = 0;          // number of characters in extension
   LPCTSTR szTemp = NULL;       // temp pointer to filename string
   LPCTSTR szEnd = NULL;

   Assert(szFilename);
   Assert(szExtension);

   if (szFilename == NULL || szExtension == NULL)
      return (count);

   // move temp pointer to end
   szTemp = szFilename + wcslen(szFilename);
   szEnd = szTemp;

   while (szTemp != szFilename)
   {
      // This function is essentially duplicated in at least
      // two other components.  The search behavior here is different
      // (RTL as opposed to the typical LTR), but I'm not going
      // to clean this up in a hotfix.
      // Consequently, when a query or bookmark char is found,
      // update it as our new end point for the extension string.
      if ((*szTemp == _T('?')) || (*szTemp == _T('#')))
      {
          szEnd = szTemp;
      }

      // when we have a period, we found the extension
      else if (*szTemp == _T('.'))
      {
        HRESULT hr = FormsAllocStringLen( szTemp, szEnd-szTemp, szExtension );
        if( FAILED( hr ) )
            count = 0;
        return (count);
      }
      --szTemp;
      ++count;
   }
   return (0);
}

//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange
//
//  Note:       Called after a property has changed to notify derived classes
//              of the change.  All properties (except those managed by the
//              derived class) are consistent before this call.
//
//              Also, fires a property change notification to the site.
//
//-------------------------------------------------------------------------

HRESULT
CPluginSite::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr;

    switch (dispid)
    {
        case DISPID_CPluginSite_hidden:
        {
            _fHidden = GetAAhidden();
            break;
        }
    }

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\ole\olesite.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       olesite.cxx
//
//  Contents:   Implementation of COleSite class
//
//  Classes:    COleSite
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include <cguid.h>
#endif

#ifndef X_SIMPDATA_H_
#define X_SIMPDATA_H_
#include <simpdata.h>
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include <binder.hxx>       // for cdatasourceprovider
#endif

#ifndef X_VBCURSOR_VBDSC_H_
#define X_VBCURSOR_VBDSC_H_
#include <vbcursor/vbdsc.h> // for iid_ivbdsc
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_DBTASK_HXX_
#define X_DBTASK_HXX_
#include "dbtask.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_CODELOAD_HXX_
#define X_CODELOAD_HXX_
#include "codeload.hxx"
#endif

#ifndef X_OLEACC_H_
#define X_OLEACC_H_
#include "oleacc.h"
#endif

#ifndef X_OCIDL_H_
#define X_OCIDL_H_
#include <ocidl.h>
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx" // for drawplaceholder
#endif

#ifndef X_PROPBAG_HXX_
#define X_PROPBAG_HXX_
#include "propbag.hxx"
#endif

#ifndef X_VBCURSOR_OCDB_H_
#define X_VBCURSOR_OCDB_H_
#include "vbcursor/ocdb.h"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_TYPENAV_HXX_
#define X_TYPENAV_HXX_
#include "typenav.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_PLUGINST_HXX_
#define X_PLUGINST_HXX_
#include "pluginst.hxx"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include <shell.h>
#endif

#ifndef X_COMCAT_H_
#define X_COMCAT_H_
#include "comcat.h"
#endif

#ifndef X_OBJSAFE_H_
#define X_OBJSAFE_H_
#include "objsafe.h"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_IDISPIDS_H_
#define X_IDISPIDS_H_
#include "idispids.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"                     // for quickmimegetcsetinfo
#endif

#ifndef X_OLELYT_HXX_
#define X_OLELYT_HXX_
#include "olelyt.hxx"
#endif

#ifndef X_ACTIVSCP_H_
#define X_ACTIVSCP_H_
#include <activscp.h>
#endif

#ifndef X_PERHIST_H_
#define X_PERHIST_H_
#include <perhist.h>
#endif

#ifndef X_OBJEXT_H_
#define X_OBJEXT_H_
#include <objext.h>
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_SAFETY_HXX_
#define X_SAFETY_HXX_
#include "safety.hxx"
#endif

#ifndef X_DBTASK_HXX_
#define X_DBTASK_HXX_
#include <dbtask.hxx>       // for CDatabindTask
#endif

#ifndef X_DMEMBMGR_HXX_
#define X_DMEMBMGR_HXX_
#include <dmembmgr.hxx>       // for CDataMemberMgr
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_DISPDEFS_HXX_
#define X_DISPDEFS_HXX_
#include "dispdefs.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_PLUGIN_I_H_
#define X_PLUGIN_I_H_
#include "plugin_i.h"   // IActiveXPlugin interface definition.
#endif

#define _cxx_
#include "olesite.hdl"

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#include "shpriv.h"
#include "winspool.h"

MtDefine(COleSiteCLock, Locals, "COleSite::CLock")

#define IDM_BORDERSTYLEFIXED 1000       
#define IDM_BORDERSTYLENO    1001



BEGIN_TEAROFF_TABLE(COleSite, IProvideMultipleClassInfo)
    TEAROFF_METHOD(COleSite, GetClassInfo, getclassinfo, (ITypeInfo ** ppTI))
    TEAROFF_METHOD(COleSite, GetGUID, getguid, (DWORD dwGuidKind, GUID * pGUID))
    TEAROFF_METHOD(COleSite, GetMultiTypeInfoCount, getmultitypeinfocount, (ULONG *pcti))
    TEAROFF_METHOD(COleSite, GetInfoOfIndex, getinfoofindex, (
            ULONG iti,
            DWORD dwFlags,
            ITypeInfo** pptiCoClass,
            DWORD* pdwTIFlags,
            ULONG* pcdispidReserved,
            IID* piidPrimary,
            IID* piidSource))
END_TEAROFF_TABLE()

DeclareTag(tagIgnoreAWV, "OleSite", "Ignore ActiveWhenVisible bit on controls");
DeclareTag(tagOleSiteRect, "OleSite", "Olesite position trace");
DeclareTag(tagOleSiteAssert, "OleSite", "Former compat list assert; wmp problem");

BEGIN_TEAROFF_TABLE_(COleSite, IServiceProvider)
        TEAROFF_METHOD(COleSite, QueryService, queryservice, (REFGUID guidService, REFIID riid, void **ppvObject))
END_TEAROFF_TABLE()

extern TCHAR g_szPropertiesVerb[];
extern HRESULT CreateStreamOnFile(
        LPCTSTR lpstrFile,
        DWORD dwSTGM,
        LPSTREAM * ppstrm);

extern BOOL OLECMDIDFromIDM(int idm, ULONG *pulCmdID);
extern HRESULT GetCategoryManager(ICatInformation **ppCat);


#ifndef NO_PROPERTY_PAGE
const CLSID * const COleSite::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
#endif // DBG==1    
    NULL
};
#endif // NO_PROPERTY_PAGE

EXTERN_C CLSID CLSID_AppletOCX;
EXTERN_C const IID IID_IActiveDesigner;
EXTERN_C const CLSID CLSID_Scriptlet;
EXTERN_C const IID IID_IVB5Control = { 0xFCFB3D26, 0xA0FA, 0x1068, 0xA7, 0x38, 0x08, 0x00, 0x2B, 0x33, 0x71, 0xB5 };
EXTERN_C const IID IID_IVB6Control = { 0xe93ad7c1, 0xc347, 0x11d1, 0xa3, 0xe2, 0x00, 0xa0, 0xc9, 0x0a, 0xea, 0x82 };

//
// misc helper functions
//

HRESULT
CLSIDFromHtmlString(TCHAR *pchClsid, CLSID *pclsid)
{
    const TCHAR achClsidPrefix [] = _T("clsid:");
    HRESULT     hr = S_OK;
    TCHAR       achClsid[CLSID_STRLEN + 1];

    // if begins with "clsid:" prefix
    if (pchClsid &&
        _tcsnipre(achClsidPrefix, ARRAY_SIZE(achClsidPrefix)-1, pchClsid, -1))
    {
        achClsid[0] = _T('{');
        _tcsncpy(
            achClsid + 1,
            pchClsid + ARRAY_SIZE(achClsidPrefix) - 1,
            CLSID_STRLEN - 2);
        achClsid[CLSID_STRLEN - 1] = _T('}');
        achClsid[CLSID_STRLEN] = 0;

        hr = THR(CLSIDFromString(achClsid, pclsid));
    }
    else
    {
        hr = E_FAIL;
    }

    RRETURN (hr);
}


//+---------------------------------------------------------------
//
//  Member:     OLECREATEINFO::~OLECREATEINFO
//
//  Synopsis:   dtor
//
//---------------------------------------------------------------

COleSite::OLECREATEINFO::~OLECREATEINFO()
{
    MemFreeString(pchSourceUrl);
    MemFreeString(pchDataUrl);
    MemFreeString(pchMimeType);
    MemFreeString(pchClassid);
    MemFreeString(pchFileName);
    ReleaseInterface(pStream);
    ReleaseInterface(pStorage);
    ReleaseInterface(pPropBag);
    ReleaseInterface(pDataObject);
    ReleaseInterface(pStreamHistory);
    ReleaseInterface(pBindCtxHistory);
    ReleaseInterface(pShortCutInfo);
}


//+---------------------------------------------------------------
//
//  Member:     COleSite::COleSite, protected
//
//  Synopsis:   used internally by the static Create methods to
//              initialize site object to a default state
//
//  Arguments:  [pUnkOuter] --  Controlling unknown for this site
//              [pParent]   --  Site that's our parent
//
//  Notes:      can not fail
//
//---------------------------------------------------------------

COleSite::COleSite(ELEMENT_TAG etag, CDoc *pDoc)
    : super(etag, pDoc)
{
    TraceTag((tagCDoc, "constructing COleSite"));
#ifdef WIN16
    m_baseOffset = ((BYTE *) (void *) (CBase *)this) - ((BYTE *) this);
    m_ElementOffset = ((BYTE *) (void *) (CElement *)this) - ((BYTE *) this);
#endif
    _pAtomTable = NULL;
    _wclsid = 0;
    _fDataSameDomain = TRUE;

#if DBG == 1
    _Client._pMyOleSite = this;
#endif
}


//+------------------------------------------------------------------------
//
//  Member:     COleSite::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
COleSite::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr = S_OK;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_TEAROFF(this,  IProvideMultipleClassInfo, NULL)
        QI_TEAROFF2(this, IProvideClassInfo, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF2(this, IProvideClassInfo2, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF((CBase *)this, IOleCommandTarget, NULL)
        QI_TEAROFF_DISPEX(this,  NULL)
        QI_TEAROFF(this, IServiceProvider, NULL)
        QI_CASE(IConnectionPointContainer)
        {
            if (_pUnkCtrl)
            {
                COleSiteCPC *   pOleCPC;

                pOleCPC = new COleSiteCPC(this, _pUnkCtrl);
                if (!pOleCPC)
                    RRETURN(E_OUTOFMEMORY);

                (*(IConnectionPointContainer **)ppv) = pOleCPC;

                //
                // Since we just created an ole cpc, it's time to start
                // sinking events from the ocx.
                //

                EnsurePrivateSink();
            }
            break;
        }

        default:
            hr = THR_NOTRACE(super::PrivateQueryInterface(iid, ppv));
            if (OK(hr))
                return S_OK;

            if (_pUnkCtrl)
            {
                void * pvObject;

                if (_fXAggregate)
                {
                    RRETURN(_pUnkCtrl->QueryInterface(iid, ppv));
                }

                hr = THR_NOTRACE(QueryControlInterface(iid, &pvObject));
                if (OK(hr))
                {
                    hr = THR(CreateTearOffThunk(
                            pvObject,
                            *(void **)pvObject,
                            NULL,
                            ppv,
                            (IUnknown *)this,
                            *(void **)(IUnknown *)this,
                            1,      // Call QI on object 2.
                            NULL));
                    ((IUnknown *)pvObject)->Release();
                }
            }
            break;
    }

    if (*ppv)
    {
        ((IUnknown *) *ppv)->AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}

//+----------------------------------------------------------------------------
//
//  Method : COleSite :: QueryService
//
//  Synopsis : IServiceProvider methoid Implementaion.
//          first QI for IServiceProvider on the control, and pass the QS to that.
//          if it fails, then pass the QS to our super's implementation
//
//-----------------------------------------------------------------------------

HRESULT
COleSite::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    HRESULT hr = E_POINTER;

    if (!ppvObject)
        goto Cleanup;

    if (_pUnkCtrl)
    {
        IServiceProvider * pISP = NULL;

        hr = THR_NOTRACE(_pUnkCtrl->QueryInterface(IID_IServiceProvider,
                                                   (void**)&pISP));
        if (hr)
            goto TryElement;

        hr = THR_NOTRACE(pISP->QueryService(guidService, riid, ppvObject));
        ReleaseInterface(pISP);
        if (hr)
            goto TryElement;

        goto Cleanup;
    }


TryElement:
    hr = THR_NOTRACE(super::QueryService(guidService,riid, ppvObject));

Cleanup:
    RRETURN1( hr, E_NOINTERFACE);
}


//+------------------------------------------------------------------------
//
//  Member:     COleSite::QueryControlInterface
//
//  Synopsis:   Query the control for an interface.
//              The purpose of this function is to reduce code size.
//
//  Arguments:  iid     Interface to query for
//              ppv     Returned interface
//
//-------------------------------------------------------------------------

HRESULT
COleSite::QueryControlInterface(REFIID iid, void **ppv)
{
    if (_pUnkCtrl)
        return _pUnkCtrl->QueryInterface(iid, ppv);
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

#ifdef WIN16
#pragma code_seg( "OLESITE_2_TEXT" )
#endif // WIN16

//+------------------------------------------------------------------------
//
//  Member:     COleSite::InvalidCall
//
//  Synopsis:   Return TRUE if call to client site is illegal.
//
//-------------------------------------------------------------------------

BOOL
COleSite::IllegalSiteCall(DWORD dwFlags)
{
    CDoc *  pDoc = Doc();

    //
    // Step 1: Check to see if object is alive and call is on correct thread.
    //

    if (GetRefs() == 0)
        return TRUE;

    Assert(pDoc);  // Should be set if _pUnkOuter != NULL.

    if (pDoc->_dwTID != GetCurrentThreadId())
    {
        TraceTag((tagError, "ActiveX control called MSHTML across apartment thread boundary (not an MSHTML bug)"));
        return TRUE;
    }

    //
    // Step 2:  Check state of COleSite.
    //

    switch (dwFlags & 0xFF)
    {
    case VALIDATE_WINDOWLESSINPLACE:
        if (!_fWindowlessInplace)
        {
            TraceTag((tagError, "Illegal call to windowless interface by ActiveX control (not an MSHTML bug)"));
            return TRUE;
        }
        break;

    case VALIDATE_INPLACE:
        if (State() < OS_INPLACE)
            return TRUE;
        break;

    case VALIDATE_LOADED:
        if (State() < OS_LOADED || !IsInMarkup())
            return TRUE;
        break;

    case VALIDATE_ATTACHED:
        if (!IsInMarkup())
            return TRUE;
        break;

    case VALIDATE_NOTRENDERING:
        {
            CLayout * pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

            if (pLayout && (   pLayout->GetView()->IsInState(CView::VS_INRENDER)
                            || !!(pLayout->GetView()->GetState() & CView::VS_INLAYOUT)
                           )
                )
                return TRUE;
        }
    }

    //
    // Step 3: Check state of document.
    //

    switch (dwFlags & (0xFF << 8))
    {
    case VALIDATE_DOC_INPLACE:
        if (pDoc->State() < OS_INPLACE)
            return TRUE;
        break;

    case VALIDATE_DOC_SITE:
        if (!pDoc->_pUnkOuter || !pDoc->_pClientSite)
            return TRUE;
        break;

    case VALIDATE_DOC_ALIVE:
        if (!pDoc->_pUnkOuter)
            return TRUE;
        break;
    }

    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CObjectElement::Init2
//
//  Synopsis:   2nd phase of initialization
//
//-------------------------------------------------------------------------

HRESULT
COleSite::Init2(CInit2Context * pContext)
{
    CDoc *  pDoc = Doc();
    ELEMENT_TAG etag = Tag();

    pDoc->_fHasOleSite = TRUE;
    pDoc->_fBroadcastInteraction = TRUE;
    pDoc->_fBroadcastStop = TRUE;

    // should we post a createobject call?

    if ((etag == ETAG_EMBED) || (pContext->_dwFlags & INIT2FLAG_EXECUTE))
    {
        IGNORE_HR(GWPostMethodCall(this, 
                                    ONCALL_METHOD(COleSite, DeferredCreateObject, deferredcreateobject), 0, FALSE, 
                                    "COleSite::DeferredCreateObject"));
    }

    // TODO: load any <OBJECT>-specific state (must match saved data in :Notify)

    RRETURN(super::Init2(pContext));
}


//+------------------------------------------------------------------------
//
//  Member:     Notify
//
//  Synopsis:   Handle notification
//
//-------------------------------------------------------------------------

void
COleSite::Notify(CNotification *pnf)
{
    HRESULT hr = S_OK;
    INSTANTCLASSINFO * pici;

    Assert(pnf);

    super::Notify(pnf);

    switch (pnf->Type())
    {
    case NTYPE_ELEMENT_QUERYFOCUSSABLE:
        pici = GetInstantClassInfo();
        
        ((CQueryFocus *)pnf->DataAsPtr())->_fRetVal =
                            _fObjAvailable
                        &&  !_fActsLikeLabel

                            // Hack for #68793
                        &&  pici && !(pici->dwCompatFlags & COMPAT_NEVERFOCUSSABLE);
        break;

    case NTYPE_ELEMENT_QUERYMNEMONICTARGET:
        if (_fActsLikeLabel)
        {
            FOCUS_ITEM fi;

            fi.pElement = NULL;
            fi.lSubDivision = 0;

            if (S_OK == Doc()->FindNextTabOrder(DIRECTION_FORWARD, FALSE, NULL, this, 0, &fi.pElement, &fi.lSubDivision))
            {
                *(FOCUS_ITEM*)pnf->DataAsPtr() = fi;
            }
        }
        break;

    case NTYPE_ELEMENT_SETTINGFOCUS:
        {
            OLE_SERVER_STATE    baseState;
            CDoc *              pDoc = Doc();
            CSetFocus *         pSetFocus = (CSetFocus *)pnf->DataAsPtr();

            _fInBecomeCurrent = TRUE;

            if (pDoc->_fDontUIActivateOleSite && (pDoc->State() < OS_UIACTIVE))
            {
                // if the call is coming from DeferSetCurrency, and the document
                // is not UI activated, do not UI activate the olesite, since that
                // would cause the document to be UI activated prematurely.
                baseState = OS_INPLACE;
            }
            else
            {
                // If the call is not coming from the DeferSetCurrency, or the document
                // is already UI activated, then UI activate the olesite.
                baseState = OS_UIACTIVE;
            }

            pSetFocus->_hr = THR(TransitionTo(baseState, pSetFocus->_pMessage));

            if (S_OK == pSetFocus->_hr && _state != (unsigned)baseState)
            {
                pSetFocus->_hr = S_FALSE;                
            }
            else if (E_NOTIMPL == pSetFocus->_hr)
            {
                Assert(_state != (unsigned)baseState);
                pSetFocus->_hr = S_FALSE;                
            }
            _fInBecomeCurrent = FALSE;
        }
        break;

    case NTYPE_ELEMENT_SETFOCUSFAILED:
        IGNORE_HR(TransitionToBaselineState(Doc()->State()));
        break;

    case NTYPE_ELEMENT_SETFOCUS:
        {
            CDoc * pDoc = Doc();

            //
            // If this flag is set, then we did not UI activate the olesite
            // and left it inplace activated. So, we can not tell the document
            // that it has an active element.
            if (!pDoc->_fDontUIActivateOleSite)
            {
                Assert(OS_UIACTIVE == _state);

                // Update our state
                pDoc->_pInPlace->_fChildActive = TRUE;

                //  The user might open-edit something in the embedding,
                //  so pass along the host names.
                IGNORE_HR(SetHostNames());
            }
        }
        break;

    case NTYPE_UPDATE_DOC_DIRTY:
        if (S_FALSE == IsClean())
        {
            Doc()->_lDirtyVersion = MAXLONG;
            pnf->SetFlag(NFLAGS_SENDENDED);
        }
        break;

    case NTYPE_RELEASE_EXTERNAL_OBJECTS:
        ReleaseObject();
        break;

    case NTYPE_FREEZE_EVENTS:
        //
        // This code is needed to compensate for a problem with 
        // the Alpha version of the VM.
        //
        if (OlesiteTag() != OSTAG_APPLET)
        {
            IOleControl * pControl = NULL;

            if (OK(THR_OLE(QueryControlInterface(
                    IID_IOleControl,
                    (void **) &pControl))))
            {
                BOOL    fFreeze;
                pnf->Data(&fFreeze);

                THR_OLE(pControl->FreezeEvents(fFreeze));
                pControl->Release();
            }
        }
        break;

    case NTYPE_AMBIENT_PROP_CHANGE:
        {
            DISPID          dispid;
            IOleControl *   pControl;

            pnf->Data(&dispid);
            if (OK(QueryControlInterface(IID_IOleControl, (void **)&pControl)))
            {
                IGNORE_HR(pControl->OnAmbientPropertyChange(dispid));
                pControl->Release();
            }
        }
        break;

    case NTYPE_UPDATE_VIEW_CACHE:
        {
            IOleObject *pObj;

            if (OK(QueryControlInterface(IID_IOleObject, (void **)&pObj)))
            {
                IGNORE_HR(pObj->Update());
                pObj->Release();
            }
        }
        break;

    case NTYPE_UPDATE_DOC_UPTODATE:
        {
            IOleObject *pObj;

            if (OK(QueryControlInterface(IID_IOleObject, (void **)&pObj)))
            {
                if (S_FALSE == THR_OLE(pObj->IsUpToDate()))
                {
                    pnf->SetFlag(NFLAGS_SENDENDED);
                    Doc()->_fIsUpToDate = FALSE;
                }
                pObj->Release();
            }
        }
        break;

    case NTYPE_DOC_STATE_CHANGE_1:
    case NTYPE_DOC_STATE_CHANGE_2:
        {
            DWORD   dw;
            CDoc *  pDoc = Doc();
            BOOL    fDown = FALSE;
            
            pnf->Data(&dw);

            // Our parent form is broadcasting a state change, transition
            // ourself correspondingly if the Doc's state is falling.

            if (pDoc->State() < (OLE_SERVER_STATE)dw)
            {
                fDown = TRUE;
            }
            
            pici = GetInstantClassInfo();
            
            if (pici && fDown ||  
                (pDoc->State() >= OS_INPLACE && 
                 (pici->dwCompatFlags & COMPAT_ALWAYS_INPLACEACTIVATE)))
            {
                if (pnf->IsSecondChance())
                {
                    //
                    // If it's a down transition and the state is already at the max,
                    // nothing more to do.
                    //
                    
                    if (fDown && State() <= pDoc->State())
                        break;
                        
                    IGNORE_HR(TransitionToBaselineState(pDoc->State()));
                }
                else
                    pnf->SetSecondChanceRequested();
            }
        }
        break;

    case NTYPE_STOP_1:
    case NTYPE_MARKUP_UNLOAD_1:

        if(_fClipViaHwndOnly && _pInPlaceObject)
        {
            HWND hwnd;

            // For some VB controls we need to hook the window messages to remove a
            //  user message that is causing window clip problems (IE6 bug 13321).
            // Here we are removing the hooks
        
            _pInPlaceObject->GetWindow(&hwnd);
            CView *     pView     = Doc()->GetView();

            Assert(pView && hwnd);

            // Check if the control window has hooks attached and detach them
            if(pView != NULL && hwnd != NULL && GetProp(hwnd, VBCTRLHOOK_PROPNAME))
            {
                pView->RemoveVBControlClipHook(hwnd);
            }
        }
        pnf->SetSecondChanceRequested();
        break;

    case NTYPE_STOP_2:
    case NTYPE_MARKUP_UNLOAD_2:
        ClearRefresh();

        ReleaseCodeLoad();

        if (_fViewLinkedWebOC && pnf->Type() == NTYPE_MARKUP_UNLOAD_2)
        {
            CVariant cvarDisplayErrorPage(VT_BOOL);

            V_BOOL(&cvarDisplayErrorPage) = VARIANT_FALSE;

            OnCommand(NULL, OLECMDID_STOP, 0, &cvarDisplayErrorPage);
        }
        else
        {
            OnCommand(NULL, OLECMDID_STOP);
        }

        break;

    case NTYPE_ENABLE_INTERACTION_1:
        pnf->SetSecondChanceRequested();
        break;

    case NTYPE_ENABLE_INTERACTION_2:
        {
            VARIANT varargIn;

            varargIn.vt = VT_I4;
            varargIn.lVal = Doc()->_fEnableInteraction;
            OnCommand(NULL, OLECMDID_ENABLE_INTERACTION, 0, &varargIn);
        }
        break;

    case NTYPE_BEFORE_UNLOAD:
        {
            BOOL *pfContinue;

            pnf->Data((void **)&pfContinue);
            if (*pfContinue)
            {
                VARIANT varOut = {0};
                OnCommand (NULL, OLECMDID_ONUNLOAD, 0,
                        NULL, &varOut);
                if (varOut.vt == VT_BOOL && varOut.boolVal == FALSE)
                    *pfContinue = FALSE;
            }
        }
        break;

    case NTYPE_BEFORE_REFRESH:
        {
            VARIANTARG varargIn;
            varargIn.vt = VT_I4;
            pnf->Data(&varargIn.lVal);
            OnCommand (NULL, OLECMDID_PREREFRESH, MSOCMDEXECOPT_DONTPROMPTUSER,
                    &varargIn, NULL);
        }
        break;

    case NTYPE_COMMAND:
        {
            COnCommandExecParams* pParm;

            pnf->Data((void **)&pParm);
            Assert(pParm);
            hr = THR(OnCommand(pParm->pguidCmdGroup, pParm->nCmdID,
                               pParm->nCmdexecopt, pParm->pvarargIn,
                               pParm->pvarargOut));
        }
        break;

    case NTYPE_SAVE_HISTORY_1:
        pnf->SetSecondChanceRequested();
        break;

    case NTYPE_SAVE_HISTORY_2:
        {
            IStream *           pStream = NULL;
            CHistorySaveCtx *   phsc = NULL;

            pnf->Data((void **)&phsc);
            hr = THR(phsc->BeginSaveStream(GetSourceIndex(), HistoryCode(), &pStream));
            if (hr)
                goto CleanupHistory;

            hr = THR(SaveHistoryStream(pStream));
            if (hr)
                goto CleanupHistory;

            hr = THR(phsc->EndSaveStream());
            if (hr)
                goto CleanupHistory;

        CleanupHistory:
            ReleaseInterface(pStream);
        }
        break;

    case NTYPE_END_PARSE:
#ifndef NO_DATABINDING
        if (    (OlesiteTag() == OSTAG_ACTIVEX || OlesiteTag() == OSTAG_APPLET)
            &&  HasMarkupPtr())
        {
            AssertSz( !GetMarkupPtr()->_fDataBindingEnabled, "Databinding enabled in NTYPE_END_PARSE, talk to jharding" );
            DYNCAST(CObjectElement, this)->AttachDataBindings();
            Assert( HasMarkupPtr() );
            if (HasMarkupPtr())
                GetMarkup()->GetDataBindTask()->SetWaiting();
        }
#endif // ndef NO_DATABINDING
        break;

    case NTYPE_ELEMENT_EXITVIEW_1:
        if (State() > OS_RUNNING)
        {
            pnf->SetSecondChanceRequested();
        }
        break;
    case NTYPE_ELEMENT_EXITTREE_1:
        pnf->SetData( pnf->DataAsDWORD() | EXITTREE_DELAYRELEASENEEDED );
        if (State() > OS_RUNNING)
        {
            pnf->SetSecondChanceRequested();
        }
        UnregisterForRelease();
        break;

    case NTYPE_ELEMENT_EXITVIEW_2:
    case NTYPE_ELEMENT_EXITTREE_2:
        // If it is inplace-active or greater, transition to the running state.
        // The object shouldn't display after it leaves the tree.
        if (State() > OS_RUNNING)
           TransitionTo(OS_RUNNING);

        if (_fViewLinkedWebOC)
        {
            CMarkup * pMarkup = GetMarkup();

            if (pMarkup && pMarkup->HasWindow())
            {
                CWindow * pWindow = pMarkup->Window()->Window();
                
                if (!pWindow->_pMarkupPending)
                    pMarkup->Window()->Window()->ReleaseViewLinkedWebOC();
            }
        }
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        EnterTree();
        break;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     COleSite::OnCommand
//
//  Note:       propagates a given notification down to doc living in the
//              WB control
//
//-------------------------------------------------------------------------

HRESULT
COleSite::OnCommand(const GUID * pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                    VARIANTARG * pvarargIn, VARIANTARG * pvarargOut)
{
    HRESULT                 hr;
    IOleCommandTarget *     pCmdTarget = NULL;

    hr = THR_NOTRACE(QueryControlInterface(
            IID_IOleCommandTarget,
            (void**)&pCmdTarget));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pCmdTarget->Exec(
            pguidCmdGroup,
            nCmdID,
            nCmdexecopt,
            pvarargIn,
            pvarargOut));

Cleanup:
    ReleaseInterface(pCmdTarget);

    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::SetMiscStatusFlags
//
//  Synopsis:   Set members from ole misc status flags
//
//  Arguments:  dwMiscStats     the flags
//
//----------------------------------------------------------------------------

void
COleSite::SetMiscStatusFlags(DWORD dwMiscStatus)
{
    INSTANTCLASSINFO * pici = GetInstantClassInfo();
    
    //  We may have to add in some flags from our compatability class table
    // since some controls' record their flags wrong and IE3 did not fully
    // enforce the meaning of missing flags such as INSIDEOUT.
    if (pici)
        dwMiscStatus |= pici->dwMiscStatusFlags;

    //  If a control acts like a label, we default it's TabStop
    //    property to FALSE, rather than the normal TRUE default

    if (dwMiscStatus & OLEMISC_ACTSLIKELABEL)
    {
        _fActsLikeLabel = TRUE;
    }

    if (dwMiscStatus & OLEMISC_ACTSLIKEBUTTON)
        _fActsLikeButton = TRUE;

    if (dwMiscStatus & OLEMISC_NOUIACTIVATE)
        _fNoUIActivate = TRUE;

    if (dwMiscStatus & OLEMISC_INSIDEOUT)
        _fInsideOut = TRUE;

    if (dwMiscStatus & OLEMISC_INVISIBLEATRUNTIME)
        _fInvisibleAtRuntime = TRUE;

    if (dwMiscStatus & OLEMISC_ALWAYSRUN)
        _fAlwaysRun = TRUE;

    // A control is activate when visible if
    //      the flag is set AND
    //      the ignore flag is not set AND
    //      the control is not iconic and invisible at runtime.
    //
    // The last part of this check is required because some controls
    // marked as activiate when visible and invisible at runtime do
    // not correctly handle being active. In the case of the VB4 common
    // dialog control, it will not paint its window correctly.

    if ((dwMiscStatus &
            (OLEMISC_ACTIVATEWHENVISIBLE|OLEMISC_IGNOREACTIVATEWHENVISIBLE)) ==
                OLEMISC_ACTIVATEWHENVISIBLE &&
        (dwMiscStatus &
            (OLEMISC_ONLYICONIC|OLEMISC_INVISIBLEATRUNTIME)) !=
                (OLEMISC_ONLYICONIC|OLEMISC_INVISIBLEATRUNTIME))
    {
#if DBG == 1
        if (!IsTagEnabled(tagIgnoreAWV))
#endif
        _fActivateWhenVisible = TRUE;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::SetViewStatusFlags
//
//  Synopsis:   Set members from view object status flags
//
//  Arguments:  dwViewStatus     the flags
//
//----------------------------------------------------------------------------

void
COleSite::SetViewStatusFlags(DWORD dwViewStatus)
{
    SetSurfaceFlags(dwViewStatus & VIEWSTATUS_SURFACE, dwViewStatus & VIEWSTATUS_3DSURFACE);

    _fDVAspectOpaque = !!(dwViewStatus & VIEWSTATUS_DVASPECTOPAQUE);
    _fDVAspectTransparent = !!(dwViewStatus & VIEWSTATUS_DVASPECTTRANSPARENT);

    // send a REmeaseure notification, which on the layout will PostLayoutRequest
    // this will cause a ensureDispNode to be called, and that in turn will
    // set the opacity flag
    RemeasureElement();
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::ConnectControl1
//
//  Synopsis:   Establish connection between control and client site
//              and set status bits.  Call this function before calling
//              IPersist*::InitNew or IPersist*::Load.
//
//  Arguments:  pdwInitFlags  In/out argument. Taken from the
//                            FSI_ enumeration.  Pass result to ConnectControl.
//
//  Returns:    HRESULT
//----------------------------------------------------------------------------

HRESULT
COleSite::ConnectControl1(DWORD *pdwInitFlags)
{
    HRESULT         hr = S_OK;
    DWORD           dwMiscStatus;
    QACONTROL       qacontrol;
    QACONTAINER     qacontainer;
    IQuickActivate *pQA = NULL;
    IOleObject *    pOleObject = NULL;
    CDoc *          pDoc = Doc();
    INSTANTCLASSINFO * pici;

    // Make sure we have an undo manager to hand to our embeddings.  If we
    // haven't gotten our undo manager by now, then our container better not
    // be providing one.  If they are providing one they have to support
    // SETCLIENTSITEFIRST, which means we would have gotten it before loading.

#ifndef NO_EDIT
    if (pDoc->UndoManager() == &g_DummyUndoMgr)
    {
        hr = THR(pDoc->CreateUndoManager());
        if (hr)
            goto Cleanup;
    }
#endif // NO_EDIT

    //
    // Only use QuickActivate if the following conditions are met:
    //
    //  1)  The COMPAT_NO_QUICKACTIVATE flag is not set.
    //  2)  _pUnkCtrl is not an ole proxy (i.e. it is apartment modelled)
    //      There's an OLE bug in the marshalling for IQuickActivate which
    //      causes E_UNEXPECTED to be returned on win95 and nt versions
    //      < SP3.  (anandra)
    //  3)  _pUnkCtrl supports the QI for IQuickActivate.
    //
    pici = GetInstantClassInfo();

    // If pici is NULL, don't try to quick activate the control.
    // We don't try to quick activate it because if pici is NULL,
    // SetOC96 won't be called and the control will never be drawn.
    //
    if (pici && !(pici->dwCompatFlags & COMPAT_NO_QUICKACTIVATE) &&
        !IsOleProxy() &&
        OK(THR_NOTRACE(QueryControlInterface(
            IID_IQuickActivate, (void **)&pQA))))
    {
        *pdwInitFlags |= FSI_QUICKACTIVATE|FSI_CLIENTSITESET;

        memset(&qacontrol, 0, sizeof(qacontrol));
        qacontrol.cbSize = sizeof(qacontrol);

        memset(&qacontainer, 0, sizeof(qacontainer));
        qacontainer.cbSize = sizeof(qacontainer);
        qacontainer.pAdviseSink = &_Client;
        qacontainer.pClientSite = &_Client;
        qacontainer.pPropertyNotifySink = &_Client;

#if DBG==1
        qacontainer.pAdviseSink->AddRef();
        DbgTrackItf(IID_IAdviseSink, "CClient", FALSE, (void **)&qacontainer.pAdviseSink);

        qacontainer.pClientSite->AddRef();
        DbgTrackItf(IID_IOleClientSite, "CClient", FALSE, (void **)&qacontainer.pClientSite);

        qacontainer.pPropertyNotifySink->AddRef();
        DbgTrackItf(IID_IPropertyNotifySink, "PNS", FALSE, (void **)&qacontainer.pPropertyNotifySink);
#endif

        VARIANT v;
        VariantInit(&v);

        // Ambient foregound color
        IGNORE_HR(GetAmbientProp(DISPID_AMBIENT_FORECOLOR, &v));
        Assert(VT_I4 == V_VT(&v));
        qacontainer.colorFore = V_I4(&v);

        // Ambient backgound color
        IGNORE_HR(GetAmbientProp(DISPID_AMBIENT_BACKCOLOR, &v));
        Assert(VT_I4 == V_VT(&v));
        qacontainer.colorBack = V_I4(&v);

        // Ambient locale
        IGNORE_HR(GetAmbientProp(DISPID_AMBIENT_LOCALEID, &v));
        Assert(VT_I4 == V_VT(&v));
        qacontainer.lcid = V_I4(&v);

        // Ambient Font...
        hr = THR(GetAmbientProp(DISPID_AMBIENT_FONT, &v));
        if (OK(hr) && V_DISPATCH(&v))
        {
            // Since the ambient font property is an LPFONTDISP, we need
            // to ask for IFont.
            LPDISPATCH pFontDisp = V_DISPATCH(&v);
            pFontDisp->QueryInterface(IID_IFont, (void **) &qacontainer.pFont);
            VariantClear(&v);   // will release the LPFONTDISP interface
        }

#ifndef NO_EDIT
        qacontainer.pUndoMgr = (pDoc->_pUndoMgr != &g_DummyUndoMgr) ?
                                       pDoc->_pUndoMgr : NULL;
#endif // NO_EDIT

        //
        // The quick-activate of event sink is disabled below because
        // the olesite event sink does not know how to correctly
        // return from events when there is not an event sink
        // hooked up to the control.
        //
        // qacontainer.pUnkEventSink     = pUnkEventSink;

        //
        // Initialize all current mode behaviors.
        //
        qacontainer.dwAmbientFlags =
                QACONTAINER_MESSAGEREFLECT |
                QACONTAINER_SUPPORTSMNEMONICS;

        if (IsDesignMode())
        {
            qacontainer.dwAmbientFlags |=
                    QACONTAINER_SHOWHATCHING |
                    QACONTAINER_SHOWGRABHANDLES;
        }
        else
        {
            qacontainer.dwAmbientFlags |= QACONTAINER_USERMODE;
        }

        if (_fDefault)
        {
            //  Note that the _fActsLikeButton flag is not set until
            //    we call SetMiscStatusFlags below

            if (!CheckDisplayAsDefault(pDoc->_pElemCurrent))
            {
                qacontainer.dwAmbientFlags |= QACONTAINER_DISPLAYASDEFAULT;
            }
        }

        hr = THR_OLE(pQA->QuickActivate(&qacontainer, &qacontrol));
#if DBG==1
        qacontainer.pAdviseSink->Release();
        qacontainer.pClientSite->Release();
        qacontainer.pPropertyNotifySink->Release();
#endif
        ReleaseInterface(qacontainer.pFont);
        if (hr)
            goto Cleanup;

        SetMiscStatusFlags(qacontrol.dwMiscStatus);
        SetViewStatusFlags(qacontrol.dwViewStatus);
        *pdwInitFlags |= FSI_PNSCONNECTED;

        pici->SetOC96(TRUE);
    }
    else if (OK(THR_OLE(QueryControlInterface(
                IID_IOleObject, (void **)&pOleObject))))
    {
        hr = THR_OLE(pOleObject->GetMiscStatus(
                DVASPECT_CONTENT,
                &dwMiscStatus));
        if (hr)
        {
            dwMiscStatus = 0;  // this is how IE3 behaves.
            hr = S_OK;         // this happens with the Interactive Music Control, 11/18/96
        }

        SetMiscStatusFlags(dwMiscStatus);
        if (dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST)
        {
            *pdwInitFlags |= FSI_CLIENTSITESET;
            hr = THR_OLE(SetClientSite(&_Client));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    ReleaseInterface(pOleObject);
    ReleaseInterface(pQA);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::ConnectControl2
//
//  Synopsis:   Establish connection between control and client site
//              and get extent.  Call this function after calling
//              IPersist*::InitNew or IPersist*::Load.
//
//  Arguments:  dwInitFlags     Some combination of:
//
//                  FSI_NONE            No special behavior.
//                  FSI_QUICKACTIVATE   ConnectControl1 used IQuickActivate.
//                  FSI_CLIENTSITESET   ConnectControl1 set the client site.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
COleSite::ConnectControl2(DWORD *pdwInitFlags)
{
    HRESULT             hr = S_OK;
    DWORD               dwViewStatus;
    IActiveScript *     pScript = NULL;
    CNotification       nf;
    CDoc *              pDoc = Doc();
    CMarkup *           pMarkup;
    ICatInformation *   pCatInfo = NULL;
    CScriptCollection * pScriptCollection;

    _state = OS_LOADED;

    // Cache a pointer to the object's IViewObject implementation

    if (OK(THR_NOTRACE(QueryControlInterface(IID_IViewObjectEx,
            (void **)&_pVO))))
    {
        _fUseViewObjectEx = TRUE;
    }
    else
    {
        THR_OLE(QueryControlInterface(IID_IViewObject, (void **) &_pVO));
    }

    // Set the client site if not already set.

    if (!(*pdwInitFlags & FSI_CLIENTSITESET))
    {
        *pdwInitFlags |= FSI_CLIENTSITESET;
        hr = THR_OLE(SetClientSite(&_Client));
        if (hr)
            goto Cleanup;
    }

    if (!(*pdwInitFlags & FSI_QUICKACTIVATE))
    {
        // Setup stuff handled by quick activate.

        if (_pVO)
        {
#if DBG==1
            IAdviseSink *pAdviseSink = &_Client;
            pAdviseSink->AddRef();
            DbgTrackItf(IID_IAdviseSink, "CClient", FALSE, (void **)&pAdviseSink);
#endif
            IGNORE_HR(_pVO->SetAdvise(DVASPECT_CONTENT, 0, &_Client));
#if DBG==1
            pAdviseSink->Release();
#endif
        }

        // Parse view status flags.

        if (_fUseViewObjectEx)
        {
            hr = THR_OLE(((IViewObjectEx*)_pVO)->GetViewStatus(&dwViewStatus));
            if (hr)
                goto Cleanup;

            SetViewStatusFlags(dwViewStatus);
        }

        //
        // Some down-level controls don't like to be UI-activated
        // in design mode. Therefore, if the control does not support
        // IQuickActivate we assume it's down-level and prevent transitioning
        // it to UI-active state except through its verb menu (if it provides it).
        // If it does not support IOleControl then it's not a control and
        // we don't set the _fNoUIActivateInDesign flag.
        // (LyleC)
        //
        // Note that it _is_ possible to get into this codepath (with
        // FSI_QUICKACTIVATE not set) but still have the control support
        // IQuickActivate.
        //

        // TODO: Remove the OSTAG_APPLET check below when the Java VM supports IQuickActivate.
        if (IsDesignMode() && OlesiteTag() != OSTAG_APPLET)
        {
            HRESULT             hr2;
            IQuickActivate *    pQA    = NULL;
            IOleControl *       pCtrl  = NULL;

            hr2 = THR_NOTRACE(QueryControlInterface(IID_IQuickActivate,
                                                  (LPVOID*)&pQA));
            if (hr2)
                pQA = NULL;

            hr2 = THR_NOTRACE(QueryControlInterface(IID_IOleControl,
                                                  (LPVOID*)&pCtrl));
            if (hr2)
                pCtrl = NULL;

            if (!pQA && pCtrl)
            {
                _fNoUIActivateInDesign  = TRUE;
            }

            ReleaseInterface (pQA);
            ReleaseInterface (pCtrl);

        }

        // Don't require the component to support IConnectionPointContainer or
        // a connection point for IPropertyNotifySink.  Since all errors are clamped
        // to E_FAIL anyway, ignore the return value  (philco).

        IPropertyNotifySink *pPNS = &_Client;

#if DBG==1
        pPNS->AddRef();
        DbgTrackItf(IID_IPropertyNotifySink, "cclient", FALSE, (void **)&pPNS);
#endif

        if (OK(THR(ConnectSink(
                _pUnkCtrl,
                IID_IPropertyNotifySink,
                pPNS,
                &_dwPropertyNotifyCookie))))
        {
            *pdwInitFlags |= FSI_PNSCONNECTED;
        }

#if DBG==1
        pPNS->Release();
#endif
    }

    //
    // Set _fNoUIActivateInDesign flag for Design Time Controls,
    // Java Applets or other OLE Controls based on host preferences
    //   
  
    if ( IsDesignMode() &&
        (pDoc->_fNoActivateNormalOleControls ||
         pDoc->_fNoActivateDesignTimeControls ||
         pDoc->_fNoActivateJavaApplets))
    {
        HRESULT           hr2;
        IUnknown *        pAD = NULL;
        BOOL              fDesignTimeControl = FALSE;
        BOOL              fJavaApplet = (OlesiteTag() == OSTAG_APPLET);

        hr2 = THR_NOTRACE(QueryControlInterface(IID_IActiveDesigner,
                                          (LPVOID*)&pAD));
        if (S_OK == hr2)
            fDesignTimeControl = TRUE;

        ReleaseInterface (pAD);

        if (pDoc->_fNoActivateDesignTimeControls && fDesignTimeControl)
            _fNoUIActivateInDesign = TRUE;

        if (pDoc->_fNoActivateJavaApplets && fJavaApplet)
            _fNoUIActivateInDesign = TRUE;

        if (pDoc->_fNoActivateNormalOleControls && !fDesignTimeControl && !fJavaApplet)
            _fNoUIActivateInDesign = TRUE;
    }

    //
    // If _fNoUIActivateInDesign is set, then override this if they support 
    // CATID_DesignTimeUIActivatableControl. Note that anything with an appropriate
    // CATID will be UI active even if the HOST tells us not to do so.
    //

    if (_fNoUIActivateInDesign)
    {
        //
        // Get the category manager
        //
        
        hr = THR(GetCategoryManager(&pCatInfo));
        if (hr)
            goto Cleanup;

        //
        // Check if control supports CATID_DesignTimeUIActivatableControl
        //
        CATID rgcatid[1];
        rgcatid[0] = CATID_DesignTimeUIActivatableControl;

        CLSID * pCLSID = GetpCLSID();
        
        if (pCLSID)
        {
            _fNoUIActivateInDesign = 
                (pCatInfo->IsClassOfCategories(*pCLSID, 1, rgcatid, 0, NULL) != S_OK);        
        }
        else
        {
            _fNoUIActivateInDesign = TRUE;
        }
    }    

    //
    // Query for the scripting interfaces.  If available then add
    // a holder for them.
    //

    QueryControlInterface(IID_IActiveScript, (void **)&pScript);

    if (pScript)
    {
        pMarkup = GetWindowedMarkupContext();
        Assert(pMarkup);
        
        pScriptCollection = pMarkup->GetScriptCollection();
        if (pScriptCollection)
        {
            hr = THR(pScriptCollection->AddHolderForObject(pScript, GetpCLSID()));

            if (hr)
                goto Cleanup;
        }
    }

    //
    // If we just created the license manager and no license manager
    // currently exists, cache pointer to license manager.
    //
    {
        pMarkup = GetWindowedMarkupContext();
        CWindow* pWindow = pMarkup ? pMarkup->GetWindowedMarkupContextWindow() : NULL;
        
        if ( pWindow &&
             ! pWindow->_pLicenseMgr )
        {
            QueryControlInterface(IID_ILocalRegistry,(void**)& pWindow->_pLicenseMgr );
        }
    }
    
    //
    // Check for support for the new palette notification
    //

    if ((Tag() == ETAG_FRAME || Tag() == ETAG_IFRAME) &&
        SUCCEEDED(OnCommand(&CGID_ShellDocView, SHDVID_CANDOCOLORSCHANGE)))
    {
        _fCanDoShColorsChange = TRUE;
    }

    //
    // Freeze events if the doc's freeze count is > 0
    //

    if (pDoc->_cFreeze)
    {
        //
        // Will be unfrozen when doc's freezecount drops to zero.
        //

        nf.FreezeEvents(this, (void *)TRUE);
        Notify(&nf);
    }
    
    //
    // Freeze events again if the doc is not fully loaded
    //
    if (GetWindowedMarkupContext()->LoadStatus() < LOADSTATUS_DONE)
    {
        //
        // Will be unfrozen when the doc is fully loaded.
        //
        nf.FreezeEvents(this, (void *)TRUE);
        Notify(&nf);
    }

    nf.EnableInteraction1(this);
    Notify(&nf);

    if (nf.IsSecondChanceRequested())
    {
        nf.EnableInteraction2(this);
        Notify(&nf);
    }

Cleanup:
    ReleaseInterface(pScript);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::AssignWclsidFromControl
//
//  Synopsis:   Assign _wclsid using IPersist* interface on control.
//
//  Arguments:  None
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
COleSite::AssignWclsidFromControl()
{
    HRESULT     hr;
    IPersist *  pPers = NULL;
    CLSID       clsid;
    CDoc *      pDoc = Doc();

    hr = THR_OLE(QueryControlInterface(IID_IPersist, (void **) &pPers));
    if (hr)
        goto Cleanup;

    hr = THR_OLE(pPers->GetClassID(&clsid));
    if (hr)
        goto Cleanup;

    hr = THR(pDoc->_clsTab.AssignWclsid(pDoc, clsid, &_wclsid));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pPers);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::InitNewObject
//
//  Synopsis:   Initializes embedded object from scratch.
//              Assumes _wclsid is initialized.
//
//  Arguments:  None
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
COleSite::InitNewObject()
{
    HRESULT                 hr;
    IPersistStreamInit *    pPStm = NULL;
    IPersistPropertyBag *   pPPBag = NULL;
    IPersistPropertyBag2 *  pPPBag2 = NULL;
    IPersistStorage         *pStorage = NULL;

    if (!QueryControlInterface (IID_IPersistPropertyBag2, (void**)&pPPBag2))
    {
        hr = THR_OLE(pPPBag2->InitNew());
        if (hr)
            goto Cleanup;
    }
    else if (!QueryControlInterface(IID_IPersistPropertyBag,(void**)&pPPBag))
    {
        hr = THR_OLE(pPPBag->InitNew());
        if (hr)
            goto Cleanup;
    }
    else
    {   // control does not support IPersistPropertyBag

        hr = THR_OLE(QueryControlInterface(
                IID_IPersistStreamInit,
                (void **) &pPStm));

        if (!hr)
        {
            hr = THR_OLE(pPStm->InitNew());
            if (hr)
                goto Cleanup;
        }
        else
        {

            hr = THR_OLE(QueryControlInterface(
                IID_IPersistStorage,
                (void **) &pStorage ));

            if (!hr)
            {
                // we do not support controls who require storage....
                hr = E_FAIL;
                goto Cleanup;
            }
            // The control does not support IPersist
            hr = S_OK; // we allow such controls
        }
    }

Cleanup:
    ReleaseInterface(pPPBag);
    ReleaseInterface(pPPBag2);
    ReleaseInterface(pPStm);
    ReleaseInterface(pStorage);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::LoadObject, public
//
//  Synopsis:   Loads our embedded object from a stream.
//
//  Arguments:  [pStm] -- Stream to load from
//
//  Returns:    HRESULT
//
//  Notes:      S_FALSE is returned to indicate the object cannot be
//              safely initialized on this interface.
//
//----------------------------------------------------------------------------

HRESULT
COleSite::LoadObject(IStream * pStm)
{
    HRESULT                 hr      = S_FALSE;
    IPersistStreamInit *    pPStm   = NULL;

    hr = THR_OLE(QuerySafeLoadInterface(IID_IPersistStreamInit, (void **) &pPStm));
    if (OK(hr) && pPStm)
    {
        hr = THR_OLE(pPStm->Load(pStm));
        goto Cleanup;
    }
    else
    {
        hr = THR_OLE(QuerySafeLoadInterface(IID_IPersistStream, (void **) &pPStm));
        if (OK(hr) && pPStm)
        {
            hr = THR_OLE(pPStm->Load(pStm));
            goto Cleanup;
        }
    }

Cleanup:
    ReleaseInterface(pPStm);
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::LoadObject, public
//
//  Synopsis:   Loads our embedded object from a storage
//
//  Arguments:  [pStg] -- Storage to load from.
//
//  Returns:    HRESULT
//
//  Notes:      S_FALSE is returned to indicate the object cannot be
//              safely initialized on this interface.
//----------------------------------------------------------------------------

HRESULT
COleSite::LoadObject(IStorage * pStg)
{
    HRESULT             hr          = S_FALSE;
    IPersistStorage *   pPStg       = NULL;

    hr = THR_OLE(QuerySafeLoadInterface(IID_IPersistStorage, (void **) &pPStg));
    if (OK(hr) && pPStg)
    {
        hr = THR_OLE(pPStg->Load(pStg));
        goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pPStg);
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::LoadObject, public
//
//  Synopsis:   Initializes embedded object from a PropertyBag
//
//  Notes:      S_FALSE is returned to indicate the object cannot be
//              safely initialized on this interface.
//----------------------------------------------------------------------------

HRESULT
COleSite::LoadObject(IPropertyBag * pPropBag)
{
    HRESULT                 hr = S_FALSE;
    IPersistPropertyBag *   pPPBag = NULL;
    IPersistPropertyBag2 *  pPPBag2 = NULL;
    IPropertyBag2 *         pPBag2 = NULL;

    //
    // Ensure the VB standard _ExtentX and _ExtentY properties are
    // available.  Some controls like SurroundVideoCtrl Object
    // choke if those properties are not available.
    //
    if (IsInMarkup())
    {
        {   const static TCHAR tchExtentX[] = _T("_ExtentX");
            CVariant Var( VT_EMPTY );
            if( pPropBag->Read( tchExtentX, &Var, NULL ) == E_INVALIDARG)
            {
                // Property does not exist:
                CUnitValue  uvWidth      = GetFirstBranch()->GetCascadedwidth();
                if( !uvWidth.IsNull() )
                {
                    Var.vt = VT_I4;
                    Var.lVal = HimetricFromHPix(uvWidth.GetPixelValue());
                    // We do not concern ourselves with failures here
                    // since this whole operation is just a convenience
                    // for some controls and not strictly neccessary.
                    pPropBag->Write( tchExtentX, &Var );
                }
            }
        }
        {   const static TCHAR tchExtentY[] = _T("_ExtentY");
            CVariant Var( VT_EMPTY );
            if( pPropBag->Read( tchExtentY, &Var, NULL ) == E_INVALIDARG)
            {
                // Property does not exist:
                CUnitValue  uvHeight     = GetFirstBranch()->GetCascadedheight();
                if( !uvHeight.IsNull() )
                {
                    Var.vt = VT_I4;
                    Var.lVal = HimetricFromVPix(uvHeight.GetPixelValue());
                    // We do not concern ourselves with failures here
                    // since this whole operation is just a convenience
                    // for some controls and not strictly neccessary.
                    pPropBag->Write( tchExtentY, &Var );
                }
            }
        }
    }


    //
    // First try IPersistPropertyBag2.
    //

    hr = THR_NOTRACE(QuerySafeLoadInterface(IID_IPersistPropertyBag2, (void **) &pPPBag2));
    if (OK(hr) && pPPBag2)
    {
        Verify(OK(pPropBag->QueryInterface(IID_IPropertyBag2, (void **)&pPBag2)));
        hr = THR_OLE(pPPBag2->Load(pPBag2, NULL));
        if (hr)
            goto Cleanup;
    }
    else
    {
        //
        // Then IPersistPropertyBag
        //

        hr = THR_OLE(QuerySafeLoadInterface(IID_IPersistPropertyBag, (void **) &pPPBag));
        if (OK(hr) && pPPBag)
        {
            hr = THR_OLE(pPPBag->Load(pPropBag, NULL));
            goto Cleanup;
        }
    }

Cleanup:
    ReleaseInterface(pPPBag);
    ReleaseInterface(pPBag2);
    ReleaseInterface(pPPBag2);
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::LoadObject, public
//
//  Synopsis:   Loads our embedded object from a file name
//
//  Arguments:  [pchFileName] -- Filename to load from.
//
//  Returns:    HRESULT
//
//  Notes:      S_FALSE is returned to indicate the object cannot be
//              safely initialized on this interface.
//
//----------------------------------------------------------------------------

HRESULT
COleSite::LoadObject(TCHAR *pchDataUrl, TCHAR *pchFileName)
{
    HRESULT             hr = S_OK;
    IPersistFile *      pPF = NULL;
    IPersistMoniker *   pPMk = NULL;
    IStream *           pStm = NULL;
    IStorage *          pStg = NULL;
    IBindCtx *          pBCtx = NULL;
    IMoniker *          pMk = NULL;

    //
    // First try IPersistMoniker if we have a data url
    //

    if (pchDataUrl)
    {
        hr = THR_OLE(QuerySafeLoadInterface(IID_IPersistMoniker, (void **)&pPMk));
        if (OK(hr) && pPMk)
        {
            hr = THR(CreateAsyncBindCtxEx(NULL, 0, NULL, NULL, &pBCtx, 0));
            if (hr)
                goto Cleanup;

            hr = THR(CreateURLMoniker(NULL, pchDataUrl, &pMk));
            if (hr)
                goto Cleanup;

            hr = THR(pPMk->Load(FALSE, pMk, pBCtx, 0));
            goto Cleanup;
        }
    }

    if (!pchFileName || hr == S_FALSE)
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }

    hr = THR_OLE(QuerySafeLoadInterface(IID_IPersistFile, (void **) &pPF));
    if (OK(hr) && pPF)
    {
        hr = THR(pPF->Load(pchFileName, 0));
        if (hr)
            goto Cleanup;
    }
#ifndef WIN16
    else if (hr == S_FALSE)
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }
    else
    {
        //
        // Try the stream approach on this file
        //

        hr = THR(CreateStreamOnFile(
                pchFileName,
                STGM_READ | STGM_SHARE_DENY_WRITE,
                &pStm));
        if (hr)
            goto Cleanup;

        hr = THR_OLE(LoadObject(pStm));
        if (!hr)
            goto Cleanup;

        //
        // Finally try to create a storage on the file
        //

        ClearInterface(&pStm);
        hr = THR(StgOpenStorage(
          pchFileName,
          NULL,
          STGM_READ | STGM_DIRECT | STGM_SHARE_DENY_WRITE,
          NULL,
          0,
          &pStg));
        if (hr)
            goto Cleanup;

        hr = THR_OLE(LoadObject(pStg));
        if (hr)
            goto Cleanup;
    }
#endif //ndef WIN16

Cleanup:
    ReleaseInterface(pPMk);
    ReleaseInterface(pBCtx);
    ReleaseInterface(pPF);
    ReleaseInterface(pMk);
    ReleaseInterface(pStm);
    ReleaseInterface(pStg);
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::LoadHistoryStream, public
//
//  Synopsis:   Loads our embedded object from a history stream
//
//  Arguments:  [pStream] - the history stream to load from
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
COleSite::LoadHistoryStream(IStream *pStream, IBindCtx *pbc)
{
    CDataStream ds(pStream);

    HRESULT             hr = S_FALSE;
    HRESULT             hr2;
    IPersistHistory *   pPH = NULL;
    IStream *           pStm = NULL;

    hr = THR_NOTRACE(QuerySafeLoadInterface(IID_IPersistHistory, (void **) &pPH));
    if (OK(hr) && pPH)
    {
        hr = THR(ds.LoadDword((DWORD*)&hr2));
        if (hr)
            goto Cleanup;

        hr = THR(ds.LoadSubstream(&pStm));
        if (hr)
            goto Cleanup;

        if (!hr2)
            hr2 = THR_OLE(pPH->LoadHistory(pStm, pbc));

        if (hr2)
            hr = hr2;
    }

Cleanup:
    ReleaseInterface(pPH);
    ReleaseInterface(pStm);
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::SaveHistoryStream, public
//
//  Synopsis:   Saves our embedded object to a history stream
//
//  Arguments:  [pStream] - the history stream to save to
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
COleSite::SaveHistoryStream(IStream *pStream)
{
    CDataStream ds;
    IStream *pSubstream = NULL;
    IPersistHistory *pPH = NULL;
    DWORD dwPosition;
    HRESULT hr = S_OK;
    HRESULT hr2 = S_OK;

    if (OK(QueryControlInterface(IID_IPersistHistory, (void **)&pPH)))
    {
        ds.Init(pStream);

        hr = THR(ds.SaveDataLater(&dwPosition, sizeof(hr2)));
        if (hr)
            goto Cleanup;

        hr = THR(ds.BeginSaveSubstream(&pSubstream));
        if (hr)
            goto Cleanup;

        hr2 = THR_OLE(pPH->SaveHistory(pSubstream));

        hr = THR(ds.EndSaveSubstream());
        if (hr)
            goto Cleanup;

        hr = THR(ds.SaveDataNow(dwPosition, &hr2, sizeof(hr2)));
        if (hr)
            goto Cleanup;
    }

Cleanup:

    ReleaseInterface(pSubstream);
    ReleaseInterface(pPH);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CreateObject
//
//  Synopsis:   selects a way to instantiate object or launch download;
//              actual instantiation always happens in CreateObjectNow
//              called from this function or in the end of download
//
//  Arguments:  pinfo       Creation info
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

#define REGACTIVEXCOMPATIBILITY _T("Software\\Microsoft\\Internet Explorer\\ActiveX Compatibility\\")

HRESULT  
COleSite::CheckForAlternateGUID(LPTSTR *pclsid)
{

    CDoc * pDoc = Doc();

    for(int i = 0; i< 10; i++)
    {
        TCHAR  szKey[MAX_PATH] = REGACTIVEXCOMPATIBILITY;
        CLSID  clsid;
        INSTANTCLASSINFO * pici = NULL;
        lstrcat(szKey, *pclsid);

        DWORD dwType, dwSize = 40 * sizeof(TCHAR);

        if(ERROR_SUCCESS != SHRegGetUSValue(szKey, _T("AlternateCLSID"),
                                         &dwType, (LPVOID)*pclsid, &dwSize,
                                         TRUE, NULL, 0)
          || FAILED(CLSIDFromString(*pclsid, &clsid)))                                         
                            
        {
            return E_ACCESSDENIED;
        }


        if (FAILED(pDoc->_clsTab.AssignWclsid(pDoc, clsid, &_wclsid)))
        {
            return E_ACCESSDENIED;
        }

        pici = GetInstantClassInfo();

        if (pici && (pici->dwCompatFlags & COMPAT_EVIL_DONT_LOAD))
        {
            continue;
        }

        return S_OK;

    }

    return E_ACCESSDENIED;
}


HRESULT
COleSite::CreateObject(OLECREATEINFO *pinfo)
{
    HRESULT         hr = S_OK;
    CMarkup *       pMarkup = GetMarkup();
    CDoc *          pDoc = Doc();
    INSTANTCLASSINFO * pici;

    Assert(!_pUnkCtrl);

    // 
    //  During the creation of a control, we may make sycnhronous calls
    //  to that component. There are some cases, where the component pushes 
    //  a message loop, and the browser window is closed in that time frame.
    //  If that ever happens, we risk not having a document at the end of this
    //  function.
    //  We addref here and release at the end of this function to guarantee.
    //  Bug#IE573270 (ferhane)
    //
    Assert(pDoc);
    pDoc->AddRef();


    // init2 is called at the begin tag parse time, since this element is not
    // in the tree yet, we can't call GetLoadHistoryStream().  This is safe to
    // do here since _pStreamHistory isn't used until CreateObjectNow() (below) and 
    // in CFrameSite::CreatObject (which doesn't call super); plugins can now leverage
    // this (bug in previous logic)
    if (!_pStreamHistory && pMarkup)
    {
        THR(pMarkup->GetLoadHistoryStream(GetSourceIndex(), HistoryCode(), &_pStreamHistory));
    }

    if (_pStreamHistory)
    {
        Assert(!pinfo->pStreamHistory);

        pinfo->pStreamHistory = _pStreamHistory;
        _pStreamHistory->AddRef();
    }

    hr = THR(pDoc->_clsTab.AssignWclsid(pDoc, pinfo->clsid, &_wclsid));
    if (hr)
        goto Error;

    pici = GetInstantClassInfo();
    
    if (pici && (pici->dwCompatFlags & COMPAT_EVIL_DONT_LOAD))
    {
        //
        // The registry says that this control is not allowed to run at all
        // in IE4.
        //
        hr = E_ACCESSDENIED;

        TCHAR  pstrClsid[40];
        LPTSTR lpsz = pstrClsid;

        if(!StringFromGUID2( pinfo->clsid, pstrClsid, ARRAY_SIZE(pstrClsid) ))
        {
            goto Error;
        }

        if(FAILED(CheckForAlternateGUID(&lpsz)))
        {
            hr = E_ACCESSDENIED;
            goto Error;
        }

          
        if(FAILED(CLSIDFromString(pstrClsid, &pinfo->clsid)))                                                                                 
        {
            goto Error;
        }

        hr = S_OK;
    }

    //
    // If we have a data object, instantiate immediately without
    // code loader.
    //

    if (pinfo->pDataObject)
    {
        hr = THR(CreateObjectNow(IID_IDataObject, pinfo->pDataObject, pinfo));
        if (hr)
            goto Cleanup;
    }
    else
    {
        //
        // If we have any attributes whatsoever with which code-download
        // can do its thang, start the codeloader.  Otherwise, just fail
        // immediately.
        //

#ifndef WIN16
        if (!IsEqualGUID(pinfo->clsid, g_Zero.guid) ||
            !FormsIsEmptyString(pinfo->pchMimeType) ||
            !FormsIsEmptyString(pinfo->pchClassid) ||
            !FormsIsEmptyString(pinfo->pchDataUrl))
        {
            //
            // instantiate immediately through CCodeLoadCtx or launch download
            //

            _pCodeLoad = new CCodeLoad;
            if (!_pCodeLoad)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            }

            hr = THR(_pCodeLoad->Init(this, pinfo));
            if (S_OK != hr && MK_S_ASYNCHRONOUS != hr)
                goto Error;

            hr = S_OK;
        }
        else
#endif // ndef WIN16
        {
            // this will be a very empty olesite
            Assert (!_pUnkCtrl);
            _state = OS_LOADED;
            OnFailToCreate();
            hr = S_OK;
        }
    }

Cleanup:
    ClearInterface(&_pStreamHistory);

    if (hr && _dwProgCookie)
    {
        //
        // If there was some failure and a progress cookie still exists
        // delete progress sink
        //
        IGNORE_HR(CMarkup::GetProgSinkHelper(GetFrameOrPrimaryMarkup())->DelProgress(_dwProgCookie));
        _dwProgCookie = 0;
    }

    pDoc->Release();

    RRETURN(hr);

Error:
    ReleaseCodeLoad();
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::AllowCreate
//
//  Synopsis:   Returns whether it's ok to create this object after checking
//              permissions on doc, etc.
//
//----------------------------------------------------------------------------

BOOL
COleSite::AllowCreate(REFCLSID clsid)
{
    DWORD   dwAction = 0;
    HRESULT hr;
    BOOL    fAllowed = TRUE;

    if (_fViewLinkedWebOC)
        return TRUE;

    if (OlesiteTag() == OSTAG_APPLET)
    {
        dwAction = URLACTION_JAVA_PERMISSIONS;
    }
    else if (OlesiteTag() == OSTAG_ACTIVEX || Tag() == ETAG_EMBED)
    {
        dwAction = URLACTION_ACTIVEX_RUN;
    }

    if (dwAction)
    {
        // KTam): We may not be in a markup yet (e.g.
        // if we were created via createElement -- script.js does this)
        // What then?  Default to primary markup.
        CMarkup *pMU = GetMarkupPtr();
        if ( !pMU )
            pMU = Doc()->PrimaryMarkup();

        Assert( pMU );

        hr = THR(pMU->ProcessURLAction(
                dwAction,
                &fAllowed,
                0,
                NULL,
                NULL,
                (BYTE *)&clsid,
                sizeof(CLSID)));

        if (hr || !fAllowed)
        {
            //
            // The control was not allowed to create itself.  Treat page
            // as if control doesn't exist.  This creates no layout
            // space for this site.
            //
            _fInvisibleAtRuntime = TRUE;
        }

    }


       return fAllowed;

}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CreateObjectNow
//
//  Synopsis:   Creates, connects and initializes embedded object from
//              a class factory.
//
//  Arguments:  pCF     The class factory (can be null if intializing from an
//                      IDataObject)
//              pinfo   OLE initialization info
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
COleSite::CreateObjectNow(
    REFIID          riidObject,
    IUnknown *      punkObject,
    OLECREATEINFO * pinfo)
{
    HRESULT hr = S_OK;
    DWORD   dwFlags = 0;
    BOOL    fNoLoad = FALSE;
    CDoc *  pDoc = Doc();
    INSTANTCLASSINFO * pici;
    CMarkup * pMarkupContext = NULL;

    Assert(!_dwProgCookie);
    //
    // instantiate object
    //

    if (IsEqualGUID(IID_IDataObject, riidObject))
    {
        hr = THR(InstantiateObjectFromDataObject((IDataObject *)punkObject));
        if (hr)
        {
            goto Error;
        }
    }
    else if (IsEqualGUID(IID_IClassFactory, riidObject))
    {
        hr = THR(InstantiateObjectFromCF((IClassFactory*)punkObject, pinfo));
        if (hr)
            goto Error;
    }
    else
    {
        //
        // No need to perform IPersist*::Load because that has already
        // happened as a result of the BindToObject.
        //

        fNoLoad = TRUE;
        _pUnkCtrl = punkObject;
        _pUnkCtrl->AddRef();
    }

    if (!_pUnkCtrl)
        goto Error;

#if DBG==1
    _clsid = pinfo->clsid;
#endif

    // Register for release object notifications from the Doc.
    RegisterForRelease();

    //
    // If we think the clsid is GUID_NULL, try and get a real wclsid from
    // the control.
    //

    if (pinfo->clsid == g_Zero.clsid)
    {
        IGNORE_HR(AssignWclsidFromControl());
    }

    //
    // Turn off events for the duration of creation
    //

    {
        CNotification   nf;

        nf.FreezeEvents(this, (void *)TRUE);
        Notify(&nf);
    }

    //
    // First stage control creation.
    //

    hr = THR(ConnectControl1(&dwFlags));
    if (hr)
        goto Error;

    //
    // Load/InitNew the control
    //

    if (!fNoLoad)
    {
        if (!pinfo->pStreamHistory ||
            !OK(THR(LoadHistoryStream(
                pinfo->pStreamHistory,
                pinfo->pBindCtxHistory))))
        {
            if (pinfo->pStream)
            {
                hr = THR(LoadObject(pinfo->pStream));

                pici = GetInstantClassInfo();
                
                if (pici && (pici->dwCompatFlags & COMPAT_USE_PROPBAG_AND_STREAM) &&
                    pinfo->pPropBag)
                {
                    //
                    // If this is one of those nasty controls that want both
                    // IPersistPropertyBag::Load and IPersistStreamInit::Load,
                    // honor them.
                    //

                    hr = THR(LoadObject(pinfo->pPropBag));
                }
            }
            else if (pinfo->pPropBag)
            {
                hr = THR(LoadObject(pinfo->pPropBag));
            }
            else if (pinfo->pStorage)
            {
                hr = THR(LoadObject(pinfo->pStorage));
            }
            else if (pinfo->pchDataUrl || pinfo->pchFileName)
            {
                hr = THR(LoadObject(pinfo->pchDataUrl, pinfo->pchFileName));
            }
            else
            {
                hr = THR(InitNewObject());
            }
        }

        //
        // S_FALSE is used in this context to indicate that initialization
        // failed because of a safety problem.  In this case, we use InitNew
        // to initialize to a default state - ignoring any potentially unsafe
        // persistent data.
        if (hr == S_FALSE || hr == E_NOINTERFACE)
        {
            hr = THR(InitNewObject());
            if (hr)
                goto Error;
        }
    }

    if (pinfo->clsid == CLSID_ActiveXPlugin)
    {
        CMarkup *    pMarkup = GetMarkup();
        if (pMarkup)
        {
            IActiveXPlugin *    pIActiveXPlugin = NULL;
            CMarkup *    pMarkup = GetMarkup();
            CDoc *              pDoc;
            LPTSTR  pszFullUrl = NULL;
            TCHAR   cBuf[pdlUrlLen];

            pDoc = pMarkup->Doc();

            VARIANT  vSrc;
            VariantInit(&vSrc);        

            hr = pinfo->pPropBag->Read(TEXT("src"), &vSrc, NULL);
            if(!hr)
            {
                pszFullUrl = V_BSTR(&vSrc);
            }


            if (pDoc->_fFullWindowEmbed && pMarkup->GetDwnPost())
            {
                pszFullUrl = pDoc->_cstrPluginCacheFilename;
            }

            if(pszFullUrl)
            {
                CMarkup::ExpandUrl(NULL, pszFullUrl, ARRAY_SIZE(cBuf), cBuf, this);

                if (!pMarkup->ValidateSecureUrl(pMarkup->IsPendingRoot(), cBuf, FALSE, FALSE))
                {
                    // If unsecure, NULLify URL
                    pszFullUrl = NULL;
                }
                else
                {
                    pszFullUrl = cBuf;
                }
            }

            hr = QueryControlInterface(IID_IActiveXPlugin, (LPVOID*)&pIActiveXPlugin);
            if (hr)
                goto Cleanup;
            pIActiveXPlugin->Load( pszFullUrl, FALSE );
            ReleaseInterface(pIActiveXPlugin);
        }
    }
    else
    {    
        // Give derived classes a chance to perform special processing after the object has
        // been loaded in the normal way...
        PostLoad();
    }
    
    //
    // Second stage control creation
    //

    hr = THR(ConnectControl2(&dwFlags));
    if (hr)
        goto Error;

    //
    // Finally transition control to the loaded state.
    //

    hr = THR(TransitionTo(OS_LOADED));
    if (hr)
        goto Error;

    //
    // Set bit informing world that the control is downloaded and
    // ready.
    //

    _fObjAvailable = TRUE;

    OnControlReadyStateChanged(!(dwFlags & FSI_PNSCONNECTED));

    //
    // For certain controls we must add a Progsink until they inplace
    // activate so that the OnLoad() script event won't fire until the
    // control is ready for scripting
    //
    pici = GetInstantClassInfo();
    
    if (pici && (pici->dwCompatFlags & COMPAT_PROGSINK_UNTIL_ACTIVATED))
    {
        Assert( _dwProgCookie == 0 );  // these controls had better not support readystate.

        // FerhanE : We may be executing this call, in which case we will not have a progsink.
        //           We call GetFrameOrPrimarymarkup since it will return us a markup 
        //           that can have a progsink. ( inthis case hopefully the parser contextmarkup)
        //
        pMarkupContext = GetFrameOrPrimaryMarkup();

        IGNORE_HR(CMarkup::GetProgSinkHelper(pMarkupContext)->AddProgress(
            PROGSINK_CLASS_OTHER,
            &_dwProgCookie));
    }

Cleanup:

    //
    // Now that we've actually created the object, its size could have changed.
    // Also, the way a object initially gets put in its baseline state
    // (inplace active or whatever) is via a SetPos().  Thus we must ensure
    // the size is updated and SetPos() is called sending a ResizeElement notification.
    // If this olesite is being parented to the rootsite directly, there's
    // no need to call RequestResize because this ocx will never be drawn.
    //

    if (    GetFirstBranch()
        &&  GetUpdatedParentLayoutNode()
        &&  GetFirstBranch()->GetCascadeddisplay() != styleDisplayNone)
    {
        ResizeElement();
        pici = GetInstantClassInfo();
        
        if (pici && (pDoc->State() >= OS_INPLACE)
            && ((pici->dwCompatFlags & COMPAT_ALWAYS_INPLACEACTIVATE) || 
                (pici->dwCompatFlags & COMPAT_INPLACEACTIVATEEVENWHENINVISIBLE) ))
        {
            IGNORE_HR(TransitionToBaselineState(pDoc->State()));
        }
    }
    else
    {
        TransitionToBaselineState(pDoc->State());
    }


    //
    // Turn events back on
    //

    {
        CNotification   nf;

        nf.FreezeEvents(this, (void *)FALSE);
        Notify(&nf);
    }

    //
    // If an error occurred make for darn sure that any progsink
    // we created is deleted.
    //
    if (hr && _dwProgCookie)
    {
        Assert(pMarkupContext);
        IGNORE_HR(CMarkup::GetProgSinkHelper(pMarkupContext)->DelProgress(_dwProgCookie));
        _dwProgCookie = 0;
    }

    ReleaseCodeLoad();
 
    RRETURN(hr);

Error:
    //
    // this codepath completely aborts creation process
    //

    // Revoke client site (if set)
    if (dwFlags & FSI_CLIENTSITESET)
    {
        SetClientSite(NULL);
    }
    ClearInterface(&_pUnkCtrl);

    _state = OS_LOADED;
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::InstantitateObjectFromCF, public
//
//  Synopsis:   Creates a control using a license manager or class factory.
//
//  Arguments:  [pCF] -- Class Factory to use if license manager not available.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
COleSite::InstantiateObjectFromCF(
    IClassFactory * pCF,
    OLECREATEINFO * pinfo)
{
    HRESULT             hr;
    DWORD               dwCompatFlags;
    CDoc *              pDoc = Doc();
    IClassFactoryEx *   pCFEx = NULL;
    INSTANTCLASSINFO *  pici;
    CMarkup*            pMarkup = NULL;
    CWindow*            pWindow = NULL;
    
    hr = THR(pDoc->_clsTab.AssignWclsid(pDoc, pinfo->clsid, &_wclsid));
    if (hr)
        goto Cleanup;
        
    pici = GetInstantClassInfo();
    
    dwCompatFlags = pici ? pici->dwCompatFlags : 0;

    // Create the control.  If a license manager exists, use it.
    // Otherwise use provided class factory.
    //
    pMarkup = GetWindowedMarkupContext();
    pWindow = pMarkup ? pMarkup->GetWindowedMarkupContextWindow() : NULL;
    
    if ( pWindow &&
         pWindow->_pLicenseMgr )         
    {
        hr = THR_OLE(pWindow->_pLicenseMgr->CreateInstance(
                pinfo->clsid,
                (dwCompatFlags & COMPAT_AGGREGATE) ?
                        PunkInner() : NULL,
                IID_IUnknown,
                CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
                (void **)&_pUnkCtrl));
    }
    else
    {
        //
        // Try IClassFactory3 first
        //

        if (OK(pCF->QueryInterface(IID_IClassFactoryEx, (void **)&pCFEx)))
        {
            hr = THR(pCFEx->CreateInstanceWithContext(
                (IOleClientSite *)&_Client, 
                (dwCompatFlags & COMPAT_AGGREGATE) ?
                    PunkInner() : NULL,
                IID_IUnknown, 
                (void **)&_pUnkCtrl));
        }
        else
        {
            hr = THR_OLE(pCF->CreateInstance(
                    (dwCompatFlags & COMPAT_AGGREGATE) ?
                            PunkInner() : NULL,
                    IID_IUnknown,
                    (void **)&_pUnkCtrl));
        }
    }
    if (hr)
        goto Cleanup;

    if (ETAG_OBJECT == Tag())
    {
        CDoc * pDoc2;
        CObjectElement * pOE;
        LPCTSTR pchType;
        pOE = DYNCAST(CObjectElement, this);
        Assert(_pUnkCtrl);
        HRESULT hr2 = _pUnkCtrl->QueryInterface(CLSID_HTMLDocument, (void**)&pDoc2);
        if (!hr2)
        {
            pchType = pOE->GetAAtype();
            if (CompareString((LCID)NULL, NORM_IGNORECASE, _T("image/"), 6, pchType, 6))
            {
                pDoc2->_fInImageObject = 1;
            }
        }
    }

    if (dwCompatFlags & COMPAT_AGGREGATE)
    {
#if DBG == 1
    //
    // Debug mode check to verify that when we aggregate controls
    // we really get the private unknown of the control.  Even though
    // we're really selective about what we aggregate there have been
    // cases of certain unnamed controls which don't aggregate correctly.
    //

        IUnknown *  pUnk = NULL;

        hr = THR_OLE(QueryControlInterface(IID_IUnknown, (void **)&pUnk));
        if (OK(hr))
        {
            Assert(pUnk == _pUnkCtrl && "Control did not aggregate correctly");
            ReleaseInterface(pUnk);
        }
#endif
        _fXAggregate = TRUE;
    }

    MemSetName((this, "%s _pUnkCtrl=%08x", MemGetName(this), _pUnkCtrl));

    DbgTrackItf(GUID_NULL,
            "pUnkCtrl",
            TRUE,
            (void **)&_pUnkCtrl);

Cleanup:
    ReleaseInterface(pCFEx);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::SaveFormatSupported
//
//  Synopsis:   Returns TRUE if the embedded control supports a save format
//              we can use.
//
//  Returns:    BOOL
//
//----------------------------------------------------------------------------

BOOL
COleSite::SaveFormatSupported()
{
    HRESULT                hr;
    IPersistPropertyBag *  pPropBag = NULL;
    IPersistPropertyBag2 * pPropBag2 = NULL;
    IPersistStreamInit *   pStm = NULL;

    hr = THR_OLE(QueryControlInterface(IID_IPersistPropertyBag,
                                       (void **)&pPropBag));
    if (!hr)
        goto Cleanup;

    hr = THR_OLE(QueryControlInterface(IID_IPersistPropertyBag2,
                                       (void **)&pPropBag2));
    if (!hr)
        goto Cleanup;

    hr = THR_OLE(QueryControlInterface(IID_IPersistStreamInit,
                                       (void **)&pStm));

    if (!hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pPropBag);
    ReleaseInterface(pPropBag2);
    ReleaseInterface(pStm);

    return hr == S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::InstantitateObjectFromDataObject, public
//
//  Synopsis:   Creates a control from a data object.
//
//  Arguments:  [pDataObject] -- Data object to load from.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
COleSite::InstantiateObjectFromDataObject(IDataObject * pDataObject)
{
    HRESULT     hr = E_FAIL;
#ifndef WIN16
    static FORMATETC s_formatetcContent =
    {
        0,                  //CLIPFORMAT
        NULL,               //DVTARGETDEVICE FAR*
        DVASPECT_CONTENT,   //dwAspect
        -1,                 //lindex
        TYMED_NULL          //tymed
    };


    IStorage *  pStg = NULL;

    hr = THR(StgCreateDocfile(
                NULL,
                STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_DELETEONRELEASE,
                0, &pStg));

    if (hr)
        goto Cleanup;


    hr = THR_OLE(OleCreateFromData(pDataObject, IID_IOleObject, OLERENDER_DRAW,
                                   &s_formatetcContent,
                                   NULL,
                                   pStg,
                                   (void **)&_pUnkCtrl));

    if (hr)
        goto Cleanup;

    if (!SaveFormatSupported())
    {
        // If we can not persist the object, it is misleading to instantiate
        // it from the data.
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(AssignWclsidFromControl());
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pStg);
#endif // ndef WIN16

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     COleSite::RegisterForRelease
//
//  Synopsis:   Adds this element to the Doc array to recieve notifications when
//              it should release the contained OLE object
//
//  Returns:    void
//
//-------------------------------------------------------------------------
void
COleSite::RegisterForRelease()
{
    CMarkup * pMarkup = GetMarkup();

    if (!_fRegisteredForRelease && pMarkup)
    {
        pMarkup->RequestReleaseNotify(this);
        _fRegisteredForRelease = TRUE;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     COleSite::UnregisterForRelease
//
//  Synopsis:   Removes this element from the Doc array to recieve notifications when
//              it should release the contained OLE object
//
//  Returns:    void
//
//-------------------------------------------------------------------------
void
COleSite::UnregisterForRelease()
{
    CMarkup * pMarkup = GetMarkup();

    if (_fRegisteredForRelease && pMarkup)
    {
        pMarkup->RevokeRequestReleaseNotify(this);
        _fRegisteredForRelease = FALSE;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     COleSite::SetHostNames
//
//  Synopsis:   Passes along to this control the host name object
//              provided to the form.  Since the form is always
//              embedded, it is never the original source of the
//              names.  It can only pass along the strings passed
//              to its IOleObject::SetHostNames method.
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

HRESULT
COleSite::SetHostNames( )
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = Doc();

    if (!_fSetHostNames && ((LPTSTR)pDoc->_cstrCntrApp != NULL))
    {
        IOleObject * pObj;

        // Note: it's legal for the container object name to be NULL.

        hr = THR_OLE(QueryControlInterface(IID_IOleObject, (LPVOID*)&pObj));
        if (!hr)
        {
            hr = THR_OLE(pObj->SetHostNames(
                    pDoc->_cstrCntrApp,
                    pDoc->_cstrCntrObj));

            ReleaseInterface(pObj);
        }

        _fSetHostNames = TRUE;
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     COleSite::SetClientSite
//
//  Synopsis:   Sets the client site to whatever pointer is passed.  Supports
//                both IOleObject::SetClientSite and IObjectWithSite::SetSite
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

HRESULT
COleSite::SetClientSite(IOleClientSite *pClientSite)
{
    IOleObject *pOleObject = NULL;
    IObjectWithSite *pObjSite = NULL;

#if DBG==1
    if (pClientSite)
    {
        pClientSite->AddRef();
        DbgTrackItf(IID_IOleClientSite, "CClient", FALSE, (void **)&pClientSite);
    }
#endif

    HRESULT hr = QueryControlInterface(IID_IOleObject, (void **)&pOleObject);

    if (OK(hr) && pOleObject)
    {
        hr = pOleObject->SetClientSite(pClientSite);
        ReleaseInterface(pOleObject);
    }
    else
    {
        hr = QueryControlInterface(IID_IObjectWithSite, (void **)&pObjSite);

        if (OK(hr) && pObjSite)
        {
            hr = pObjSite->SetSite(pClientSite);
            ReleaseInterface(pObjSite);
        }
        else
        {
            hr = S_OK;
        }
    }

    // We need the ViewLinkedWebOC flag of the WebOC set before it is initialized.

    if (_fViewLinkedWebOC)
    {
        IBrowserService* pBrowserSvc      = NULL;
        IWebBrowser2*    pWebBrowserFrame = NULL;

        IInitViewLinkedWebOC* pInitViewLinkedWebOC = NULL;


        HRESULT hr3 = E_FAIL;

        hr3 = IUnknown_QueryService(_pUnkCtrl,
                                    SID_SShellBrowser,
                                    IID_IBrowserService,
                                    (void**)&pBrowserSvc);
        if (SUCCEEDED(hr3))
        {
            hr3 = pBrowserSvc->QueryInterface(IID_IInitViewLinkedWebOC, 
                                              (void**)&pInitViewLinkedWebOC);
            if (SUCCEEDED(hr3))
            {              
                BOOL fIsAlreadyViewLinked;

                pInitViewLinkedWebOC->IsViewLinkedWebOC(&fIsAlreadyViewLinked);

                if (!fIsAlreadyViewLinked)
                {
                    CMarkup * pMarkup = GetMarkup();
                    Assert(pMarkup);

                    COmWindowProxy * pProxy = pMarkup->GetWindowPending();
                    Assert(pProxy);

                    CWindow * pWindow = pProxy->Window();
                    Assert(pWindow);

                    hr3 = pWindow->QueryService(SID_SWebBrowserApp,
                                                IID_IWebBrowser2,
                                                (void**)&pWebBrowserFrame);
                    if (SUCCEEDED(hr3))
                    {
                        pInitViewLinkedWebOC->SetViewLinkedWebOC(TRUE);
                        pInitViewLinkedWebOC->SetViewLinkedWebOCFrame(pWebBrowserFrame);

                        if (pWindow->_cstrName)
                        {
                            BSTR bstrFrameName = SysAllocString(pWindow->_cstrName);

                            pInitViewLinkedWebOC->SetFrameName(bstrFrameName);

                            SysFreeString(bstrFrameName);
                        }

                        ReleaseInterface(pWebBrowserFrame);
                    }

                    ReleaseInterface(pInitViewLinkedWebOC);
                }
            }
            
            ReleaseInterface(pBrowserSvc);
        }
    }

#if DBG==1
    if (pClientSite)
    {
        pClientSite->Release();
    }
#endif

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     COleSite::TransitionTo, public
//
//  Synopsis:   Manage internal state transitions.
//
//  Arguments:  [state] -- the target state
//
//  Returns:    NOERROR iff sucessful
//
//  Notes:      This method manages "push" requests to
//              get us into a desired state. There are
//              a number of important "pull" requests that
//              change our state without going through here:
//              for example, OnUIDeactivate
//
//              IPD = IOleInPlaceObject::InPlaceDeactivate
//              UID = IOleInPlaceObject::UIDeactivate
//              + means that the state transition is incomplete
//
//   (from)
//           | PASSIVE | LOADED | RUNNING | INPLACE  | UIACTIVE | OPEN
//------------------------------------------------------------------------
//           |         |        |         |          |          |
// PASSIVE   | Illegal |  SHN   |   Err   |    Err   |   Err    |  Err
//           |         |        |         |          |          |
//------------------------------------------------------------------------
//           |         |        |         |          |          |
// LOADED    | Illegal |  NOP   | OleRun  |  DoVerb  |  DoVerb  |  DoVerb
//           |         |        |         |          |          |
//------------------------------------------------------------------------
//           |         |        |         |          |          |
// RUNNING   | Illegal | Close  |   NOP   |  DoVerb  |  DoVerb  |  DoVerb
//           |         |        |         |          |          |
//------------------------------------------------------------------------
//           |         |        |         |          |          |
// INPLACE   | Illegal |  IPD+  |   IPD   |   NOP    |  DoVerb  |   IPD+
//           |         |        |         |          |          |
//------------------------------------------------------------------------
//           |         |        |         |          |          |
// UIACTIVE  | Illegal |  IPD+  |   IPD   |   UID    |   NOP    |   IPD+
//           |         |        |         |          |          |
//------------------------------------------------------------------------
//           |         |        |         |          |          |
// OPEN      | Illegal | DoVerb+| DoVerb  |  DoVerb+ |  DoVerb+ |   NOP
//           |         |        |         |          |          |
//------------------------------------------------------------------------

HRESULT
COleSite::TransitionTo(OLE_SERVER_STATE state, LPMSG pMsg)
{
    HRESULT         hr;
    HWND            hWndCntr;
    IOleObject *    pObj;
    CDoc *          pDoc = Doc();
    INSTANTCLASSINFO * pici;

    // If we are not in a tree anymore and someone is trying to increase our
    // state, do not allow. If we allocate the olelayout with the line below,
    // we will end up leaking it since we are out of the tree.
    if (_fObjectReleased && ((OLE_SERVER_STATE)_state) < state)
    {
        return E_FAIL;
    }

    COleLayout * pLayout = DYNCAST(COleLayout, GetUpdatedLayout(GUL_USEFIRSTLAYOUT));

    Assert(state >= OS_LOADED && state <= OS_OPEN);
    Assert(_state <= OS_OPEN);

    //
    // It's ok to try to transition a site to >= OS_INPLACE even
    // if it's _fSizeThis or _fPositionThis is true because it just
    // means that it will be sized and SetObjectRects at sometime later.
    //      Assert(state < OS_INPLACE || _fPositionThis);
    //

    Assert(_cLockInPlaceActive == 0 ||
           (state == OS_INPLACE || state == OS_UIACTIVE));
    Assert(!(state == OS_UIACTIVE && _fNoUIActivate));

    //  Early exit if we're already in the requested state.
    if (state == State())
        return S_OK;

    //
    // If the object is not yet available, bail out now.
    // We could get into this situation if the safety confirmation
    // dialog is up for initializing a control
    //

    if (!_fObjAvailable)
        return S_OK;

    //
    // If the transition lock is on, bail out right now.  This means
    // we're in the middle of an ocx requested state change and some
    // document change is causing a transitionTo.
    //

    if (TestLock(OLESITELOCK_TRANSITION))
        return S_OK;

    //  Get state required by multiple state transitions

    hr = THR_NOTRACE(QueryControlInterface(IID_IOleObject, (LPVOID*)&pObj));
    if (!OK(hr))
    {
        if (E_NOINTERFACE == hr)
            hr = S_OK;
        RRETURN(hr);
    }

    hWndCntr = (pDoc->_pInPlace) ? pDoc->_pInPlace->_hwnd : NULL;

    //  Loop until we're in the correct state or an error occurs

    while (state != State() && OK(hr))
    {
        switch(_state)
        {

#if DBG == 1
        //
        //  We don't use the TransitionTo method to get out of
        //  the OS_PASSIVE state.  Use the various IPersist*::Load
        //  methods instead.
        //

        case OS_PASSIVE:
            Assert(0 && "Transitioning a passive olesite");
            hr = E_FAIL;
            break;
#endif
        case OS_LOADED:
            switch (state)
            {
            case OS_RUNNING:
                hr = THR_OLE(OleRun(pObj));
                if (!hr)
                    _state = OS_RUNNING;

                break;

            // in the rest of the cases we can go direct (recall that DoVerb
            // will automatically run!)

            case OS_INPLACE:
                if (_fInsideOut)
                {
                    if (!_hemfSnapshot)
                    {
                        hr = THR(InPlaceActivate(pObj, hWndCntr, pMsg));
                    }
                }
                if (_state != OS_INPLACE && OK(hr))
                {
                    hr = E_NOTIMPL;
                }
                break;

            case OS_UIACTIVE:
                if (!NoUIActivate())
                {
                    CRect   rc;

                    pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

                    hr = THR_OLE(pObj->DoVerb(
                            OLEIVERB_UIACTIVATE,
                            pMsg,
                            &_Client,
                            0,
                            hWndCntr,
                            ENSUREOLERECT(&rc)));
                }
                if (_state != OS_UIACTIVE && OK(hr))
                {
                    hr = E_NOTIMPL;
                }
                break;

            case OS_OPEN:
                hr = THR(SetHostNames());
                if (!hr && !NoUIActivate())
                {
                    CRect   rc;

                    pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

                    hr = THR_OLE(pObj->DoVerb(
                            OLEIVERB_OPEN,
                            pMsg,
                            &_Client,
                            0,
                            hWndCntr,
                            ENSUREOLERECT(&rc)));
                    if (_state != OS_OPEN && OK(hr))
                    {
                        hr = E_NOTIMPL;
                    }
                }
                break;
            }
            break;

        case OS_RUNNING:
            switch(state)
            {
            case OS_LOADED:

                //  NOTE it is legal to close an object merely
                //    by letting go of all pointers to it; however,
                //    in practice we've encountered objects which
                //    do not cope with this usage.  So, we explicitly
                //    close everything.  (garybu, chrisz)

                hr = THR_OLE(pObj->Close(OLECLOSE_NOSAVE));
                switch (hr)
                {
                case S_OK:
                case E_NOTIMPL: // MS License Manager returns E_NOTIMPL
                case RPC_E_DISCONNECTED:
                    _state = OS_LOADED;
                    hr = S_OK;
                    break;
                }
                break;

            case OS_INPLACE:
            case OS_UIACTIVE:
                if (_fInsideOut)
                {   
                    // Hide local object when a print delegate is available.
                    // The local object can participate in measurement, but all drawing
                    // is done by print delegate via IViewObject::Draw
                    if (!_hemfSnapshot) // TODO PRINT 112553: do we still need this?
                    {
                        hr = THR(InPlaceActivate(pObj, hWndCntr, pMsg));
                    }
                }
                if (_state != OS_INPLACE && OK(hr))
                {
                    hr = E_NOTIMPL;
                }
                break;

            case OS_OPEN:
                hr = THR(SetHostNames());
                if (!hr && !NoUIActivate())
                {
                    CRect   rc;

                    pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

                    hr = THR_OLE(pObj->DoVerb(
                            OLEIVERB_OPEN,
                            pMsg,
                            &_Client,
                            0,
                            hWndCntr,
                            ENSUREOLERECT(&rc)));
                    if (_state != OS_OPEN && OK(hr))
                    {
                        hr = E_NOTIMPL;
                    }
                }
                break;
            }
            break;

        case OS_INPLACE:
            switch(state)
            {
            case OS_UIACTIVE:
                if (!NoUIActivate() && pLayout)
                {
                    CRect   rc;

                    pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

                    hr = THR_OLE(pObj->DoVerb(
                            OLEIVERB_UIACTIVATE,
                            pMsg,
                            &_Client,
                            0,
                            hWndCntr,
                            ENSUREOLERECT(&rc)));
                }
                if (_state != OS_UIACTIVE && OK(hr))
                {
                    hr = E_NOTIMPL;
                }
                break;

            default:
                if (_cLockInPlaceActive)
                {
                    hr = E_FAIL;
                }
                else
                {   // Some controls count on being hidden before deactivating:
                    pici = GetInstantClassInfo();
                    
                    if (pici && (pici->dwCompatFlags & COMPAT_SEND_HIDE))
                    {
                        CRect   rc;

                        pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

                        hr = THR_OLE(pObj->DoVerb(
                                OLEIVERB_HIDE,
                                pMsg,
                                &_Client,
                                0,
                                hWndCntr,
                                ENSUREOLERECT(&rc)));
                    }
                    // That OLEIVERB_HIDE above may have put us in a different
                    // state....
                    if( _state >= OS_INPLACE && NULL != _pInPlaceObject )
                    {
                        if(_fClipViaHwndOnly)
                        {
                            // For some VB controls we need to hook the window messages to remove a
                            //  user message that is causing window clip problems (IE6 bug 13321).
                            // Here we are removing the hooks
                            CView *     pView     = Doc()->GetView();
                            HWND        hwndControl;
                            _pInPlaceObject->GetWindow(&hwndControl);

                            Assert(pView);

                            // Check if the control window has hooks attached and detach them
                            if(pView != NULL && hwndControl != NULL && GetProp(hwndControl, VBCTRLHOOK_PROPNAME))
                            {
                                pView->RemoveVBControlClipHook(hwndControl);
                            }
                        }

                        // The following pulls us to OS_RUNNING
                        hr = THR_OLE(_pInPlaceObject->InPlaceDeactivate());
                    }
                }

                // if everything went well then our state should already be
                // in the running state.  Otherwise, something went wrong
                if (_state != OS_RUNNING && !hr)
                {
                    hr = E_FAIL;
                }
                break;
            }
            break;

        case OS_UIACTIVE:
            switch(state)
            {
            case OS_INPLACE:
                Assert(_fInsideOut);

                if (_pInPlaceObject)
                    hr = THR_OLE(_pInPlaceObject->UIDeactivate());
                else 
                    hr = E_UNEXPECTED;

                if (_state != OS_INPLACE && !hr)
                {
                    hr = E_FAIL;
                }
                break;

            default:
                // Some controls count on being hidden before deactivating:
                pici = GetInstantClassInfo();
                
                if (pici && (pici->dwCompatFlags & COMPAT_SEND_HIDE))
                {
                    CRect   rc;

                    pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

                    hr = THR_OLE(pObj->DoVerb(
                            OLEIVERB_HIDE,
                            pMsg,
                            &_Client,
                            0,
                            hWndCntr,
                            ENSUREOLERECT(&rc)));
                }

                // That OLEIVERB_HIDE above may have put us in a different
                // state....
                if( _state >= OS_INPLACE && NULL != _pInPlaceObject )
                {
                    if(_fClipViaHwndOnly)
                    {
                        // For some VB controls we need to hook the window messages to remove a
                        //  user message that is causing window clip problems (IE6 bug 13321).
                        // Here we are removing the hooks
                        CView *     pView     = Doc()->GetView();
                        HWND        hwndControl;
                        _pInPlaceObject->GetWindow(&hwndControl);

                        Assert(pView);

                        // Check if the control window has hooks attached and detach them
                        if(pView != NULL && hwndControl != NULL && GetProp(hwndControl, VBCTRLHOOK_PROPNAME))
                        {
                            pView->RemoveVBControlClipHook(hwndControl);
                        }
                    }
                    hr = THR_OLE(_pInPlaceObject->InPlaceDeactivate());
                }
                if (_state != OS_RUNNING && !hr)
                {
                    hr = E_FAIL;
                }
                break;
            }
            break;

        case OS_OPEN:
            {
                CRect   rc;

                pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

                hr = THR_OLE(pObj->DoVerb(
                        OLEIVERB_HIDE,
                        pMsg,
                        &_Client,
                        0,
                        hWndCntr,
                        ENSUREOLERECT(&rc)));
            }
            if (!hr)
            {
                pLayout->Invalidate();
                _state = OS_RUNNING;
                ::SetFocus(hWndCntr);
            }
            break;
        }
    }

    ReleaseInterface(pObj);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     COleSite::TransitionToBaselineState
//
//  Synopsis:   Transitions this object to its proper baseline state,
//              given a maximum state allowed to the object
//
//  Arguments:  [osMax]     --  Maximum state allowed
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
COleSite::TransitionToBaselineState(OLE_SERVER_STATE osMax)
{
    HRESULT hr;

    osMax = BaselineState(osMax);

    if (State() != osMax)
    {
        // prevent WM_ERASEBKGND flash
        CServer::CLock Lock(Doc(), SERVERLOCK_IGNOREERASEBKGND);
        hr = THR(TransitionTo(osMax));
    }
    else
    {
        hr = S_OK;
    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     COleSite::TransitionToCorrectState
//
//  Synopsis:   In some circumstances, the object's baseline state may
//              change.  This method transitions the object to its new
//              baseline state, unless the object is currently the UI
//              Active object, in which case it is unaffected.
//
//  Arguments:  [osMax]     --  Maximum state allowed
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
COleSite::TransitionToCorrectState()
{
    HRESULT hr;

    if (_state == OS_UIACTIVE)
    {
        hr = S_OK;
    }
    else
    {
        hr = THR(TransitionToBaselineState(Doc()->State()));
    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     COleSite::InPlaceActivate
//
//  Synopsis:   Helper to encapsulate the inplace activation process
//
//  Arguments:  [pOleObject]    --  Ptr to the IOleObject
//              [hwnd]          --  Hwnd of the container
//              [pMsg]          --  Message to send while inplace activating
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
COleSite::InPlaceActivate(IOleObject *pOleObject, HWND hwnd, LPMSG pMsg)
{
    CDoc *      pDoc            = Doc();

    AssertSz(!_hemfSnapshot, "InPlaceActivate must not be called on a snapshot");

    CRect   rc;
    HRESULT hr;
    CLock   Lock(this, OLESITELOCK_INPLACEACTIVATE);

    COleLayout * pLayout = DYNCAST(COleLayout, GetUpdatedLayout(GUL_USEFIRSTLAYOUT));
    INSTANTCLASSINFO * pici = GetInstantClassInfo();

    if (pici && pLayout && (pici->dwCompatFlags & COMPAT_SEND_SHOW))
    {
        pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

        hr = THR_OLE(pOleObject->DoVerb(
                OLEIVERB_SHOW,
                pMsg,
                &_Client,
                0,
                hwnd,
                ENSUREOLERECT(&rc)));

        // Some buggy controls return S_FALSE instead of S_OK when they succeed.  This is
        // normally caused by returning the value of a boolean function which succeeds.  Treat
        // this scode as S_OK.  -- philco
        
        hr = (hr == S_FALSE) ? S_OK : hr;
            
        if (hr)
            goto Cleanup;
    }

    if (pLayout)
        pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

    // Set up _hwndPrivate during inplace--activation.
    // Hack for PhotoSuite3 (#94834)
    Assert(!_hwndPrivate);

    if (pici && (pici->dwCompatFlags & COMPAT_HWNDPRIVATE))
    {
        pDoc->_pElemOleSiteActivating = this;
    }
    hr = THR_OLE(pOleObject->DoVerb(
            OLEIVERB_INPLACEACTIVATE,
            pMsg,
            &_Client,
            0,
            hwnd,
            ENSUREOLERECT(&rc)));

    if (pDoc->_pElemOleSiteActivating)
    {
        pDoc->_pElemOleSiteActivating = NULL;
        Assert(pici && (pici->dwCompatFlags & COMPAT_HWNDPRIVATE));
        Assert(GetHwnd() == NULL);
    }

    // Some buggy controls return S_FALSE instead of S_OK when they succeed.  This is
    // normally caused by returning the value of a boolean function which succeeds.  Treat
    // this scode as S_OK.  -- philco
    
    hr = (hr == S_FALSE) ? S_OK : hr;
            
    if (hr)
        goto Cleanup;
        
    pici = GetInstantClassInfo();
    
    if (pici && _dwProgCookie &&
        (pici->dwCompatFlags & COMPAT_PROGSINK_UNTIL_ACTIVATED))
    {
        CMarkup::GetProgSinkHelper(GetFrameOrPrimaryMarkup())->DelProgress(_dwProgCookie);
        _dwProgCookie = 0;
    }

    //
    // After inplace-activation also send down a SetObjectRects.  It
    // should not be necessary to do this, but unfortunately the marcwan
    // basectl framework has a bug where it does not clip correctly
    // if it's only inplace-activated without a subsequent SetObjectRects.
    // The bug is that the basectl framework does not go through its
    // SetWindowRgn code if it's only inplace-activated.  A SetObjectRects
    // after inplace-activation forces it down that code path. (anandra)
    //

    if (State() >= OS_INPLACE && _pInPlaceObject)
    {
        CView *     pView     = Doc()->GetView();
        CDispNode * pDispNode = (pView->IsActive() && pLayout)
                                    ? pLayout->GetElementDispNode()
                                    : NULL;

        if (pDispNode)
        {
            //  (bug #108313) this should prevent display tree from closing during 
            //  call HandleViewChange later in this block. 
            CView::CEnsureDisplayTree edt(pView);

            // make sure our deferred calls get processed later
            pView->OpenView();

            // set opacity on display node
            // (donmarsh) - being pessimistic here, because it's only a
            // small perf hit if the window is opaque and the display node is
            // transparent.  On the other hand, it is a rendering
            // bug if the window is transparent and the display node is opaque.
            pDispNode->SetOpaque(FALSE);
            
            DWORD       grfFlags = pDispNode->IsInView()
                                        ? VCF_INVIEW | VCF_INVIEWCHANGED | VCF_POSITIONCHANGED
                                        : VCF_INVIEWCHANGED | VCF_POSITIONCHANGED;
            CRect       rc;
            CRect       rcClip;

            pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);
            pLayout->GetClippedClientRect(&rcClip, COORDSYS_GLOBAL);

            pLayout->HandleViewChange(grfFlags, &rc, &rcClip, pDispNode);
        }
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::GetHwnd, CSite
//
//  Synopsis:   Return control's window, if any
//
//----------------------------------------------------------------------------

HWND
COleSite::GetHwnd()
{
    HWND hwnd = NULL;
    HWND hwndParent;
    CDoc *  pDoc = Doc();

    if (!_fObjAvailable || !_pInPlaceObject || !pDoc->_pInPlace)
        return NULL;

    // pretend there is no window if a delegate is supposed to draw
    // NOTE: we are assuming here that if a delegate exists, the local
    //       object should not be involved in drawing under any circumstances
    if (_hemfSnapshot)
        return NULL;

    _pInPlaceObject->GetWindow(&hwnd);
    if (!hwnd)
        return NULL;

    // the first time we notice that the control has an HWND (even a bogus one),
    // mark its display node for ViewChange.  This ensures that the HWND
    // participates in the "obscuring element" feature.
    // Don't do this if the controls's hwnd isn't a descendant of the main
    // window (IE6 13819).
    if (!_fHasHwnd && IsChild(pDoc->_pInPlace->_hwnd, hwnd))
    {
        _fHasHwnd = TRUE;

        // now that we know the control has an HWND, decide how to clip it.
        // Some controls behave better if we never set a clip rect in SetObjectRects,
        // but instead rely on SetWindowRgn to clip the window.
        IUnknown *punk1 = NULL;
        IUnknown *punk2 = NULL;

        if (S_OK == QueryControlInterface(IID_IVB5Control, (void**)&punk1) ||
            S_OK == QueryControlInterface(IID_IVB6Control, (void**)&punk2) )
        {
            _fClipViaHwndOnly = TRUE;

            ReleaseInterface(punk1);
            ReleaseInterface(punk2);
        }

        CView *     pView     = Doc()->GetView();
        CLayout *   pLayout   = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);
        CDispNode * pDispNode = (pView->IsActive() && pLayout)
                                    ? pLayout->GetElementDispNode()
                                    : NULL;

        if (_fClipViaHwndOnly)
        {
            // We need to set a getmeesage hook, because the vb controls are sending
            // themselves a WM_USER+3202 (0x1082) message after which the reset their
            // window clip. This interferes with the way we clip them (IE6 bug 13321)
            if(!GetProp(hwnd, VBCTRLHOOK_PROPNAME))
            {
                pView->CreateVBControlClipHook(hwnd);
            }
        }

        // ask for ViewChange
        if (pDispNode)
        {
            CView::CEnsureDisplayTree edt(pView);
            pDispNode->RequestViewChange();
        }
    }

    hwndParent = ::GetParent(hwnd);
    if (hwndParent == pDoc->_pInPlace->_hwnd)
        return hwnd;

    // The object is being tricky and has inserted some windows
    // between the form and the window it returns from
    // IOleInPlaceActiveObject::GetWindow.  Find out what the
    // window handle that is a direct descendant of us is.

    if (!IsChild(pDoc->_pInPlace->_hwnd, hwnd))
    {
        TraceTag((tagError, "Window handle returned from object not a child of the Form!"));
        return hwnd;
    }

    while (hwndParent != pDoc->_pInPlace->_hwnd)
    {
        hwnd = hwndParent;
        hwndParent = ::GetParent(hwnd);
    }

    return hwnd;
}

//+---------------------------------------------------------------
//
//  Member:     COleSite::Passivate
//
//  Synopsis:   Called when main CSite reference count (_ulRefs) drops
//              to zero. Do not call this method directly.  Use
//              IUnknown::Release instead.
//
//---------------------------------------------------------------

void
COleSite::Passivate()
{
#if defined(UNIX) && defined(ux10)
//  IEUNIX:  Ensure that the this object is not deleted before the
//  end of the function. (ReleaseObject results in deletion of this.

    CLock  lock(this);
#endif
    ReleaseObject();

    Assert(_cLockInPlaceActive == 0);
    Assert(!_pInPlaceObject);

    if (_pAtomTable)
    {
        _pAtomTable->Free();
        delete _pAtomTable;
        _pAtomTable = NULL;
    }

    if (_pci)
    {
        ReleaseInterface(_pci->_pTypeInfoEvents);
        delete _pci;
    }

    // Release control's private unknown.
    ClearInterface(&_pUnkCtrl);

    ClearInterface(&_pStreamHistory);
    if (_hemfSnapshot)
    {
        DeleteEnhMetaFile(_hemfSnapshot);
        _hemfSnapshot = NULL;
    }

    ClearRefresh();
    super::Passivate();
}

void
COleSite::ClearRefresh()
{
    FormsKillTimer(this, REFRESH_TIMER_ID);
    FormsFreeString(_pstrRefreshURL);
    _pstrRefreshURL = NULL;
}

//+---------------------------------------------------------------
//
//  Member:     COleSite::EnterTree
//
//  Synopsis:   Notification that this object is entering the tree.
//
//---------------------------------------------------------------
void
COleSite::EnterTree()
{
    // Since we are entering the tree, this object should transition
    // to the correct state.
    if (_fObjAvailable)
        IGNORE_HR(TransitionToBaselineState(Doc()->State()));

#ifndef NO_DATABINDING
    GetMarkup()->GetDataBindTask()->SetWaiting();
#endif // ndef NO_DATABINDING

}

//+---------------------------------------------------------------
//
//  Member:     COleSite::ReleaseObject
//
//  Synopsis:   Disconnect from the form.
//
//---------------------------------------------------------------

void
COleSite::ReleaseObject()
{

    // Ensure this object stays alive until the function returns.
    CLock lock(this);

    // if the underlying OLE object is already released, simply return.
    if (_fObjectReleased)
        return;

    _fObjectReleased = TRUE;

#ifndef NO_DATABINDING
    DetachDataBindings();
#endif // ndef NO_DATABINDING

    //         Temporary hack for controls built with MFC 4.0 (VC 3.0).
    //         COleControl::~COleControl does not release our advise
    //         sink, so we force COleControl to release it explicitly
    //         here.  We check for IViewObjectEx to avoid hurting the
    //         performance of our own controls.
    if (_pVO && !_fUseViewObjectEx)
    {
        IGNORE_HR(_pVO->SetAdvise(DVASPECT_CONTENT, 0, NULL));
    }

    // If we are still holding onto the param bag, release it now.
    ReleaseParamBag();

    // Break reference count loop when control is aggregated
    // by releasing cached object pointers.

    ClearInterface(&_pDisp);
    ClearInterface(&_pVO);
    _fUseViewObjectEx = FALSE;

    // Since site's are generic non-ole things, we have to explicitly
    // ensure that we're at most in the loaded state.
    if (_state > OS_LOADED)
    {
        IGNORE_HR(TransitionTo(OS_LOADED));
    }

    Assert(_state <= OS_LOADED && "Object did not shutdown correctly.");

    // The above transitions the site from states above OS_LOADED
    // to OS_LOADED.  If all went well, the site should now be in either
    // the OS_LOADED or OS_PASSIVE state.  No matter what happened,
    // we now assume the site is in the OS_PASSIVE state.  This assumption
    // simplifies checks for unexpected calls in the client interfaces.

    _state = OS_PASSIVE;
    _fWindowlessInplace = FALSE;
    _fUseInPlaceObjectWindowless = FALSE;

    ReleaseCodeLoad();

    if (_dwProgCookie)
    {

        CMarkup *pMarkupContext = GetFrameOrPrimaryMarkup();
#if DBG==1
        if (!(!pMarkupContext || CMarkup::GetProgSinkHelper(pMarkupContext) || _lReadyState < READYSTATE_LOADED))
        {
            TraceTag((tagOleSiteAssert, "Possible update of a control we have in the compat list."));
        }        
#endif

        if (CMarkup::GetProgSinkHelper(pMarkupContext))
            IGNORE_HR(CMarkup::GetProgSinkHelper(pMarkupContext)->DelProgress(_dwProgCookie));

        _dwProgCookie = 0;
    }

    // Revoke the client site.
    SetClientSite(NULL);

    // Disconnect property notify sink.  Shouldn't need to do this,
    // but MSN controls will leak if we do not.

    if (_dwPropertyNotifyCookie)
    {
        DisconnectSink(_pUnkCtrl, IID_IPropertyNotifySink, &_dwPropertyNotifyCookie);
    }

    if (_dwEventSinkCookie)
    {
        DisconnectSink(_pUnkCtrl, 
            _fPrimaryConnection ? *GetpIIDDispEvent() : IID_IDispatch, 
            &_dwEventSinkCookie);
    }

    if (_fViewLinkedWebOC)
    {
        CMarkup * pMarkup = GetMarkup();

        if (pMarkup && pMarkup->HasWindow())
        {
            CWindow * pWindow = pMarkup->Window()->Window();
            
            if (pWindow && 
                ((!pWindow->_fDelegatedSwitchMarkup) || pMarkup->Doc()->_fActiveDesktop))
                pWindow->ReleaseViewLinkedWebOC();
        }
    }

    UnregisterForRelease();
}

HRESULT
COleSite::GetColors(CColorInfo *pCI)
{
    HRESULT hr;

    if (_pVO)
        hr = pCI->AddColors(_pVO);
    else
        hr = S_FALSE;

    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method:     COleSite::YieldCurrency
//
//  Synopsis:   Relinquish currency
//
//  Arguments:  pSiteNew    New site that wants currency
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------

HRESULT
COleSite::YieldCurrency(CElement * pElemNew)
{
    HRESULT hr;
    CDoc *  pDoc = Doc();

    hr = THR(super::YieldCurrency(pElemNew));
    if (hr)
        goto Cleanup;

    // IE5 #62775. The control needs to yield UI. Remaining ui-active while not having
    // focus/currency is bad.
    if (_state >= OS_UIACTIVE)
    {
        // First, reset _pElemUIActive, in order to prevent the call to BecomeCurrentAndActive
        // on the parent in COleSite::CClient::OnUIDeactivate()
        pDoc->_pElemUIActive = NULL;

        YieldUI(pDoc->PrimaryRoot());
    }

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     COleSite::YieldUI
//
//  Synopsis:   Relinquish UI
//
//  Arguments:  pSiteNew    New site that wants UI
//
//--------------------------------------------------------------------------

void
COleSite::YieldUI(CElement *pElemNew)
{
    Assert(OS_UIACTIVE == _state);
    IGNORE_HR(TransitionToBaselineState(OS_INPLACE));
}


//+-------------------------------------------------------------------------
//
//  Method:     COleSite::BecomeUIActive
//
//  Synopsis:   Force ui activity on the site.
//
//  Notes:      This is the method that external objects should call
//              to force sites to become ui active.
//
//--------------------------------------------------------------------------

HRESULT
COleSite::BecomeUIActive()
{
    // Nothing to do here.  Controls are responsible for getting
    // into the UI active state if that's what they want.
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::ActivationChangeRequiresRedraw
//
//  Synopsis:   Determine if change in activation requires redraw.
//
//----------------------------------------------------------------------------

BOOL
COleSite::ActivationChangeRequiresRedraw()
{
#if 0
    // TODO: Fix this! (brendand)

    BOOL fAbove = FALSE;

    Assert(!_fWindowlessInplace);

    // If the site's window will be positioned above some other site
    // with a window, or if the site will pop above a windowless site,
    // then redraw is required.

    return Doc()->_pSiteRoot->GetCurLayout()->CheckLayoutIntersect(
                            GetCurLayout(),
                            &fAbove,
                            SI_ABOVE | SI_BELOW | SI_BELOWWINDOWED);
#else
    return FALSE;
#endif
}


//+------------------------------------------------------------------------
//
//  Member:     COleSite::BaselineState
//
//  Synopsis:   Returns the OLE state this object should be in, barring
//              other special circumstances, and subject to a "maximum"
//              state the object is allowed
//
//  Parameters: [osMax]     --  Maximum state allowed to the object;
//                              usually determined by the state of the
//                              enclosing form
//
//  Returns:    OLE_SERVER_STATE
//
//-------------------------------------------------------------------------

OLE_SERVER_STATE
COleSite::BaselineState(OLE_SERVER_STATE osMax)
{
    OLE_SERVER_STATE    os;
    INSTANTCLASSINFO *  pici = GetInstantClassInfo();
    
#if DBG == 1
    Assert(!g_Zero.ab[0]);
#endif

    // If we're locked in the inplace-active state, that's our baseline.
    //

    if (_cLockInPlaceActive > 0)
    {
        os = OS_INPLACE;
    }
    else if (pici && !IsDesignMode()
             && (   pici->dwCompatFlags & COMPAT_ALWAYS_INPLACEACTIVATE
                 || pici->dwCompatFlags & COMPAT_INPLACEACTIVATEEVENWHENINVISIBLE
                 || (_fActivateWhenVisible && (IsVisible(TRUE)))))
    {
        //
        // The baseline is inplace if the following conditions are met:
        //  1)  the doc is in browse mode           AND
        //  2)  the ocx is visible                  AND
        //  3)  we're an activate-when-visible ocx  OR
        //  4)  it's one which requires inplace
        //      activation *all* the time.

        //  The visibility check is defined as the ocx's visible property
        //  should be set to true (hidden is not set) and the site is
        //  in the doc's current view rect.  However, if all these conditions
        //  are met except for the view rect one, we look at the current state.
        //  If this is > INPLACE, then we stay right here.
        //

        os = OS_INPLACE;
    }
    else if (_fAlwaysRun || _state >= OS_RUNNING || 
            (GetMarkup() && GetMarkup()->SearchBranchForTagInStory(GetFirstBranch(), ETAG_HEAD)))
    {
        //
        // Otherwise if this control is marked to be always running
        // or if we're already greater than running, the base-line
        // is running.
        //

        os = OS_RUNNING;
    }
    else
    {
        //
        // Otherwise, the baseline is just plain old OS_LOADED.
        //

        os = OS_LOADED;
    }

    if (os > osMax)
        os = osMax;

    return os;
}

//+------------------------------------------------------------------------
//
//  Member:     COleSite::CacheDispatch
//
//  Synopsis:   Fill in our pointer to the control's IDispatch, if it
//              has one.
//
//-------------------------------------------------------------------------

void
COleSite::CacheDispatch()
{
    if (_fDispatchCached || !_pUnkCtrl)
        return;

    INSTANTCLASSINFO * picti = GetInstantClassInfo();

    // if we havne' determined if the control is IDispatchEx yet, then
    // call this.
    if (picti && !picti->HasIDex2BeenCalled())
    {
        IDispatchEx * pDispEx2 = NULL;

        THR_NOTRACE(QueryControlInterface(IID_IDispatchEx,
                                               (void **)&pDispEx2));
        picti->SetIsDispatchEx2( !!pDispEx2 );
        ReleaseInterface(pDispEx2);
    }

    IGNORE_HR(QueryControlInterface(IID_IDispatch, (void **)&_pDisp ));

    _fDispatchCached = TRUE;
}

HRESULT
COleSite::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr = super::Save ( pStreamWrBuff, fEnd );
    if ( !hr )
    {
        _fDirty = FALSE;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::IsClean, COleSite
//
//  Synopsis:   Return S_OK if contained object is clean.
//
//----------------------------------------------------------------------------

HRESULT
COleSite::IsClean(void)
{
    HRESULT hr = S_FALSE;

    // If we are an HTML control site don't use the control's dirty state
    // because we are setting properties in it from HTML

    if (_fDirty)
        return S_FALSE;

    IPersistStreamInit * pPSI;

    if (OK(THR_OLE(QueryControlInterface(IID_IPersistStreamInit, (void **)&pPSI))))
    {
        hr = THR_OLE(pPSI->IsDirty());
        pPSI->Release();
    }

    hr = (hr == S_FALSE) ? S_OK : S_FALSE;

    RRETURN1(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  Member:     COleSite::GetReadyState
//
//  Synopsis:   Returns the readystate of the object.  If not supported
//              an error is returned
//
//  Arguments:  plReadyState    Resultant readystate
//
//  Returns:    S_OK if control supports ReadyState natively.
//              S_FALSE if control doesn't support ReadyState.
//
//-------------------------------------------------------------------------

HRESULT
COleSite::GetReadyState(long *plReadyState)
{
    HRESULT     hr = S_OK;
    CVariant    Var;

    CacheDispatch();
    if (!_pDisp)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR_NOTRACE(GetDispProp(
            _pDisp,
            DISPID_READYSTATE,
            g_lcidUserDefault,
            &Var,
            NULL));
    if (hr)
        goto Cleanup;

    //
    // Look for either VT_I4 or VT_I2
    //

    if (V_VT(&Var) == VT_I4)
    {
        *plReadyState = V_I4(&Var);
    }
    else if (V_VT(&Var) == VT_I2)
    {
        *plReadyState = V_I2(&Var);
    }
    else
    {
        hr = E_FAIL;
    }

#if DBG==1
    if (hr == S_OK)
    {
        VerifyReadyState(*plReadyState);
    }
#endif

Cleanup:

    // If the control doesn't support the readystate property, that's ok.
    // Just return S_FALSE to indicate that.
    if (DISP_E_MEMBERNOTFOUND == hr)
        hr = S_FALSE;

    RRETURN1_NOTRACE(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  Member:     COleSite::GetBoolPropertyOnObject
//
//  Synopsis:   Returns TRUE if the property is not a member of the control or
//              if the property exists it's value is TRUE.  Returns FALSE only
//              if the property exists and it's value is FALSE.
//
//  Arguments:  dispid -- dispatch ID of property to read.
//
//  Returns:    BOOL
//
//-------------------------------------------------------------------------

BOOL
COleSite::GetBoolPropertyOnObject(DISPID dispid)
{
    HRESULT hr;
    BOOL    fBoolean = TRUE;            // Any failure with the one exception
                                        // will return TRUE (see below).

    CacheDispatch();

    // Does the object support IDispatch?
    if (_pDisp)
    {
        // Yes, try to get the property?
        CVariant var;

        hr = THR_NOTRACE(GetDispProp(_pDisp,
                                     dispid,
                                     LOCALE_SYSTEM_DEFAULT,
                                     &var));
        if (!hr)
        {
            if (var.vt == VT_BOOL)
                fBoolean = var.boolVal;
            else
                hr = DISP_E_MEMBERNOTFOUND;
        }

        // Did we get a problem accessing the property?
        if (hr && !DISPID_NOT_FOUND(hr))
        {
            // some other error: the DISPID_ENABLED property will disable the
            // control 

            // Yes, and it wasn't because the property wasn't there so set it to
            // false.
            TraceTag((tagWarning, "COleSite::GetBoolPropertyOnObject -- %l "
                                     "via Dispatch returns %hr", dispid, hr));

            fBoolean = FALSE;
        }
    }

    return fBoolean;
}


//+---------------------------------------------------------------------------
//
//  Member:     HandleMessage
//
//  Synopsis:   Handle messages bubbling when the passed site is non null
//
//  Arguments:  [pMessage]  -- message
//              [pChild]    -- pointer to child when bubbling allowed
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT BUGCALL
COleSite::HandleMessage(CMessage * pMessage)
{
    HRESULT         hr      = S_FALSE;
    IOleControl *   pCtrl   = NULL;
    LRESULT         lr;
    CDoc *          pDoc = Doc();
    BOOL fBranchTaken = FALSE;
    BOOL fEditable = IsEditable(/*fCheckContainerOnly*/FALSE);

    if ( !_fObjAvailable )
    {
        RRETURN1(hr, S_FALSE);
    }
    
    // Note: WM_SETCURSOR and WM_CONTEXTMENU messages can arrive
    // here after bubbling up from a windowed control in another
    // thread.  We are careful about calling the control methods
    // in this scenario because OLE does not allow it.

#if !defined(WINCE) && !defined(_MAC)
    if (pMessage->message != WM_ERASEBKGND &&
        pMessage->message != WM_SETCURSOR &&
        InSendMessage())
    {
        //
        // If the message is not erasebkgnd or setcursor and
        // we're in the middle of some ole thread synchronization
        // then re-post this message so that the control thread
        // is no longer waiting on us.  Add other messages here on
        // a case-by-case basis.
        //

        PostMessage(
            pDoc->_pInPlace->_hwnd,
            pMessage->message,
            pMessage->wParam,
            pMessage->lParam);
        hr = S_OK;  // To signify that we handled the message.
        goto Cleanup;
    }
#endif // GAL_VERSION

    // Check for special internal messages first.

    if (pMessage->message == WM_MOUSELEAVE)
    {
        fBranchTaken = TRUE;
        if (_fWindowlessInplace)
        {
            hr = THR_OLE(((IOleInPlaceObjectWindowless *)_pInPlaceObject)->
                OnWindowMessage(
                    pMessage->message,
                    pMessage->wParam,
                    pMessage->lParam,
                    &lr));
        }

        if (_fDeactivateOnMouseExit)
        {
            IGNORE_HR(TransitionToCorrectState());
        }
    }

    if (!fBranchTaken )        
    {
        if (_fWindowlessInplace)
        {
            //
            // Otherwise, if the control we're holding is windowless
            // inplace, let it handle the message.
            //
#ifdef _MAC
            pMessage->lParam = MAKELPARAM(pMessage->ptContent.x, pMessage->ptContent.y);
#endif
            hr = THR_OLE(((IOleInPlaceObjectWindowless *)_pInPlaceObject)->
                    OnWindowMessage(
                        pMessage->message,
                        pMessage->wParam,
                        pMessage->lParam,
                        &lr));

        }
        else if (pMessage->message == WM_CONTEXTMENU)
        {
            //
            // Show context menu on behalf of the control.
            // A number of control don't handle themselves context
            // menus upon reception of WM_CONTEXTMENU, but do it
            // instead upon reception of WM_RBUTTONUP. To compensate,
            // in browse mode, eat up the context menu message and never
            // show a context menu on behalf of the ocx. (anandra)
            //

            //
            // Certain OLE Sites can "eat" WM_RBUTTONUP messages.
            // We hence pass the WM_CONTEXTMENU to mshtmled where we can set 
            // state saying we got an RBUTTONUP
            if (fEditable)
            {
                hr = THR(OnContextMenu(
                        (short) LOWORD(pMessage->lParam),
                        (short) HIWORD(pMessage->lParam),
                        CONTEXT_MENU_CONTROL));
            }
            else
            {
                hr = S_OK;
            }
        }
        else if (_state < OS_INPLACE)
        {
            // Otherwise, the form is in run-mode and the control is inactive
            // Pass messages to inactive control as appropriate.
            switch (pMessage->message)
            {
                //
                // marka - we used to always go UI Active on Mouse Down.
                // we now want to go UI Active on Mouse UP in design mode
                // this allows single click dragging of site selected controls 
                // ( because control wont go UI Active on Mouse Down ).
                //
            case WM_LBUTTONDOWN:
            case WM_RBUTTONDOWN:
            case WM_MBUTTONDOWN:
                if ( ! fEditable )
                {
                    hr = THR(OnInactiveMouseButtonMessage(pMessage, &lr));
                }
                break;

                //
                // Always go UI Active on double click
                //
            case WM_LBUTTONDBLCLK:  
                if ( ! fEditable )
                {
                    hr = THR(OnInactiveMouseButtonMessage(pMessage, &lr));                                    
                }                
                else
                {
                    //
                    // At design time - the decision to go Active is up tot hte tracker
                    //
                    hr = S_FALSE;
                }
                break;

            case WM_SETCURSOR:
                if ( ! fEditable && ! IsMasterParentEditable() )
                {
                    hr = THR(OnInactiveMouseButtonMessage(pMessage, &lr));
                }
                else 
                {
                    hr = super::HandleMessage(pMessage);
                    if (hr == S_FALSE)
                    {
                       SetCursorStyle(IDC_SIZEALL);
                    }
                }
                hr = S_OK;
                break;
                
            case WM_MOUSEMOVE:
                if ( ! fEditable )
                {
                    hr = THR(OnInactiveMousePtrMessage(pMessage, GetFirstBranch(), &lr));
                }
                else
                {
                    hr = S_FALSE;
                }                    
                break;

#ifndef NO_MENU
            case WM_INITMENUPOPUP:
                hr = THR(OnInitMenuPopup(
                        (HMENU) pMessage->wParam,
                        (int) LOWORD(pMessage->lParam),
                        (BOOL) HIWORD(pMessage->lParam)));
                break;
#endif // NO_MENU

            default:
                hr = THR(super::HandleMessage(pMessage));
                break;
            }
        }
        else if (!((pMessage->dwKeyState & FALT) &&
                (pMessage->message == WM_KEYDOWN ||
                pMessage->message == WM_SYSKEYDOWN ||
                pMessage->message == WM_CHAR ||
                pMessage->message == WM_SYSCHAR) &&
                pMessage->wParam != VK_MENU))
        {
            //
            // Handle WM_SETCURSOR & WM_ERASEBKGND right here due to
            // the ole synchronization problem with multiple threads, where
            // the ctrl thread is waiting on processing of these messages.
            //

            if (pMessage->message == WM_ERASEBKGND ||
                pMessage->message == WM_SETCURSOR)
            {
                hr = S_FALSE;
            }
            else
            {
                // Otherwise, if the message is not an accelerator, as signified
                // by the alt key not being held down, pass it to default processing.
                hr = super::HandleMessage(pMessage);
                // No bubbling up to parent here.
                goto Cleanup;
            }
        }
        else
        {
            hr = THR(super::HandleMessage(pMessage));
            goto Cleanup;
        }
    }

Cleanup:
    ReleaseInterface(pCtrl);
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::OnMnemonic, public
//
//  Synopsis:   Indicates that our mnemonic has been pressed by the user.
//
//  Arguments:  [pMsg] -- Message corresponding to our mnemonic
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
COleSite::OnMnemonic(LPMSG lpmsg)
{
    HRESULT         hr      = S_FALSE;
    IOleControl *   pCtrl   = NULL;

    if (!THR_OLE(QueryControlInterface(IID_IOleControl, (void **) &pCtrl)))
    {
        hr = THR_OLE(pCtrl->OnMnemonic(lpmsg));
        pCtrl->Release();
    }

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::OnMenuEvent, public
//
//  Synopsis:   Handles context menu items for this site.
//
//  Arguments:  [id]   -- Menu item ID
//              [code] -- Menu code
//
//  Returns:    TRUE if the message is handled.  FALSE if we want the form
//              to provide default behavior for that menu item.
//
//----------------------------------------------------------------------------

BOOL
COleSite::OnMenuEvent(int id, UINT code)
{

    if (IsDesignMode())
    {
        //
        //  Embedded object verbs on the context menu.  All other context menu
        //  items are handled by the form.
        //

        if (id >= IDM_OBJECTVERBLIST0 && id <= IDM_OBJECTVERBLISTLAST)
        {
            DoEmbedVerbs(id - IDM_OBJECTVERBLIST0);
            return TRUE;
        }

    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Method:     COleSite::OnControlChanged
//
//  Synopsis:   Give Site (or its derived class) a chance to act on a
//              control's OnChanged notification,  and cancel any forwarding
//              which might normally take place through our XObject.
//
//  Arguments:  dispid of property who's value has changed
//
//  Returns:    HRESULT.  Any non-zero HRESULT, including S_FALSE, will
//              cancel OnChanged forwarding.
//
//--------------------------------------------------------------------------

HRESULT
COleSite::OnControlChanged(DISPID dispid)
{
    HRESULT             hr          = S_OK;

    if (dispid != DISPID_READYSTATE)
        _fDirty = TRUE;

    // handle changes in readystate
    if (dispid == DISPID_READYSTATE || dispid == DISPID_UNKNOWN)
    {
        OnControlReadyStateChanged();
    }

    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method:     COleSite::OnControlReadyStateChanged
//
//  Synopsis:   Handle readystate change notifications from control
//
//--------------------------------------------------------------------------

void
COleSite::OnControlReadyStateChanged(BOOL fForceComplete)
{
    long    lReadyState;
    long    lReadyStateOrig = _lReadyState;
    HRESULT hr;
    BOOL    fNativeSupport = FALSE;

    fNativeSupport = (THR_NOTRACE(GetReadyState(&lReadyState)) == S_OK);

    if (fForceComplete || (!fNativeSupport))
    {
        // If we have trouble getting the readystate, assume it's complete.
        lReadyState = READYSTATE_COMPLETE;
    }

    if (lReadyState == READYSTATE_COMPLETE)
    {
        if (_iRefreshTime > 0)
        {
            FormsSetTimer(this,
                          ONTICK_METHOD(COleSite, RefreshCallback, refreshcallback),
                          REFRESH_TIMER_ID,
                          _iRefreshTime);
            _iRefreshTime = 0; // in case we become READYSTATE_COMPLETE again
        }
    }

    TraceTagEx((tagOLEWatch,
        TAG_NONAME,
        "COleSite::OnControlReadyStateChange SSN=0x%x, _lreadystate=0x%x lreadystate=0x%x",
        _ulSSN,
        _lReadyState,
        lReadyState));

    // change by cfranks 8 May 1997:
    // We now allow controls that are in the complete state to transition
    // as far back as loaded, but not further back. (Example: data source
    // controls can have a new query run against them, in which case they
    // might go COMPLETE -> LOADED -> INTERACTIVE -> COMPLETE again.)
    if (_lReadyState == READYSTATE_COMPLETE && lReadyState < READYSTATE_LOADED)
    {
        return;                         // not further back than LOADED
    }

    if (_lReadyState != lReadyState ||
        _lReadyState == READYSTATE_UNINITIALIZED)
    {
        IProgSink * pProgSink = CMarkup::GetProgSinkHelper(GetFrameOrPrimaryMarkup());

        if (pProgSink)
        {
            if (lReadyState < READYSTATE_LOADED)
            {
                if (_dwProgCookie == 0)
                {
                    // Until we're in the loaded state, we need to add progress on
                    // the PROSINK_CLASS_CONTROL class.

                    IGNORE_HR(pProgSink->AddProgress(GetProgSinkClass(),
                        &_dwProgCookie));
                }
            }
            else if (lReadyState < READYSTATE_COMPLETE)
            {
                if (_lReadyState < READYSTATE_LOADED)
                {
                    DWORD dwProgCookie = _dwProgCookie;
                    _dwProgCookie = 0;

                    // Until we're in the complete state, we need to add progress
                    // on the PROGSINK_CLASS_OTHER class.

                    hr = THR(pProgSink->AddProgress(GetProgSinkClassOther(),
                            &_dwProgCookie));

                    if (hr)
                    {
                        _dwProgCookie = dwProgCookie;
                        goto Cleanup;
                    }

                    if (dwProgCookie)
                    {
                        pProgSink->DelProgress(dwProgCookie);
                    }
                }
            }
            else if (_dwProgCookie)
            {
                // We're all done.  Remove the progress from the document.

                pProgSink->DelProgress(_dwProgCookie);
                _dwProgCookie = 0;
            }
        }

        _lReadyState = lReadyState;

#ifndef NO_DATABINDING
        if (    lReadyStateOrig < READYSTATE_LOADED
            &&  lReadyState >= READYSTATE_LOADED
            &&  Tag() != ETAG_IFRAME   &&  Tag() != ETAG_FRAME
            &&  !_fFailedToCreate)
        {
            // the control/applet can now respond to more questions;
            // try doing more databinding
            AttachDataBindings();
        }
#endif // ndef NO_DATABINDING

        if (    Tag() == ETAG_FRAME
            &&  _lReadyState >= LOADSTATUS_INTERACTIVE
            &&  GetMarkup()->LoadStatus() < LOADSTATUS_INTERACTIVE)
        {
            GetMarkup()->OnLoadStatus(LOADSTATUS_INTERACTIVE);
        }
    }

Cleanup:
    // If ready state has changed, fire the READYSTATECHANGE event on behalf
    // of the control (but only if it doesn't fire the event itself).
    if (_lReadyState != lReadyStateOrig)
    {
        if (_lReadyState == READYSTATE_COMPLETE)
            hr = THR(Doc()->CommitScripts(GetMarkup(), this));

        if (!fNativeSupport)
        {
            OLESITE_TAG ostag = OlesiteTag();

            if (ostag == OSTAG_ACTIVEX || ostag == OSTAG_APPLET)
            {
                DYNCAST(CObjectElement, this)->Fire_onreadystatechange();
            }
        }
    }
}

//+------------------------------------------------------------------------
//
//  Function:   LooksLikePropertiesVerb
//
//  Synopsis:   Return true if the given string is likely to be the
//              properties verb.
//
//              We are forced to use this disgusting hack because we don't
//              know of a more reliable mechanism to determine if an object
//              has a properites verb.
//
//  Arguments:  pstrVerb    String to examine
//
//
//-------------------------------------------------------------------------
BOOL
LooksLikePropertiesVerb(TCHAR *pstrVerb)
{
    TCHAR achPropertiesVerb[FORMS_MAXVERBNAMLEN + 1];
    TCHAR *pch1 = pstrVerb;
    TCHAR *pch2 = achPropertiesVerb;
    TCHAR s_achNoise[] = _T("&.");

    if (!pch1)
    {
        return FALSE;
    }

    LoadString(GetResourceHInst(),
               IDS_PROPVERB,
               achPropertiesVerb,
               ARRAY_SIZE(achPropertiesVerb));

    for (;;)
    {
        // Skip over noise characters

        while (*pch1 && _tcschr(s_achNoise, *pch1))
            pch1 += 1;

        while (*pch2 && _tcschr(s_achNoise, *pch2))
            pch2 += 1;

        // CONSIDER: do comparison in lowercase.

        if (*pch1 != *pch2)
            return FALSE;

        if (*pch1 == 0)
            return TRUE;

        Assert(*pch1 != 0 && *pch2 != 0);

        pch1 += 1;
        pch2 += 1;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::DoEmbedVerbs, public
//
//  Synopsis:   Invokes a verb on an embedding when the user selects it from
//              the context menu.
//
//  Arguments:  [usVerbIndex] -- 0-based index of the verb as returned from
//                               the enumerator.
//
//----------------------------------------------------------------------------

void
COleSite::DoEmbedVerbs(USHORT usVerbIndex)
{
    USHORT        i          = 0;
    long          lVerb      = 0;
    IOleObject *  pObj       = NULL;
    IEnumOLEVERB *pEnumVerb  = NULL;
    HRESULT       hr;
    OLEVERB       verb;
    CRect         rc;

    // We should never have been able to get here if the number of selected
    // sites wasn't one.
    //
    COleLayout * pLayout = DYNCAST(COleLayout, GetUpdatedLayout(GUL_USEFIRSTLAYOUT));
    Assert(pLayout);

    Assert(Doc()->GetSelectionType() == SELECTION_TYPE_Control );

    hr = THR_OLE(QueryControlInterface(IID_IOleObject, (LPVOID*)&pObj));
    if (hr)
        goto Cleanup;

    hr = THR_OLE(pObj->EnumVerbs(&pEnumVerb));
    if (hr)
        goto Cleanup;

    // Get the verb number (lVerb)

    while(pEnumVerb->Next(1, &verb, NULL) == S_OK)
    {
        CoTaskMemFree(verb.lpszVerbName);
        if ((verb.grfAttribs & OLEVERBATTRIB_ONCONTAINERMENU) &&
                verb.lVerb != OLEIVERB_PROPERTIES &&
                !LooksLikePropertiesVerb(verb.lpszVerbName))
        {
            if (i == usVerbIndex)
            {
                lVerb = verb.lVerb;
                break;
            }
            i++;
        }
    }

    Assert(i == usVerbIndex);

     // Set the host names just in case it's opening.
    IGNORE_HR(SetHostNames());

    Assert(Doc()->_pInPlace);

    pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

    IGNORE_HR(pObj->DoVerb(lVerb,
                           NULL,
                           &_Client,
                           0,
                           Doc()->_pInPlace->_hwnd,
                           ENSUREOLERECT(&rc)));

Cleanup:
    ReleaseInterface(pObj);
    ReleaseInterface(pEnumVerb);
    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::GetControlInfo, public
//
//  Synopsis:   Returns a filled in CONTROLINFO struct for this object.
//
//  Arguments:  [pci] -- Struct to fill in.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
COleSite::GetControlInfo(CONTROLINFO *pci)
{
    IOleControl *   pCtrl;
    HRESULT         hr;

    // Can't just do a memset because of pci->cb

    pci->hAccel = NULL;
    pci->cAccel = 0;
    pci->dwFlags = 0;

    hr = THR_OLE(QueryControlInterface(IID_IOleControl, (void **) &pCtrl));
    if (!hr)
    {
        hr = THR_OLE(pCtrl->GetControlInfo(pci));

        pCtrl->Release();

        if (pci->dwFlags & CTRLINFO_EATS_RETURN)
            _fEatsReturn = TRUE;
        else
            _fEatsReturn = FALSE;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::OnInactiveMousePtrMessage
//
//  Synopsis:   Handle WM_SETCURSOR, WM_MOUSEMOVE on inactive control.
//
//----------------------------------------------------------------------------
HRESULT
COleSite::OnInactiveMousePtrMessage(CMessage *pMessage, CTreeNode * pNodeContext, LRESULT *plResult)
{
    HRESULT             hr;
    IPointerInactive *  pPI = NULL;
    DWORD               dwPolicy;
    RECT                rc;
    POINT               pt;

    COleLayout * pLayout = DYNCAST(COleLayout, GetUpdatedLayout(GUL_USEFIRSTLAYOUT));
    Assert(pLayout);
    Assert( ! IsEditable(/*fCheckContainerOnly*/FALSE) );
    
    if (THR_NOTRACE(QueryControlInterface(
                IID_IPointerInactive, (void **) &pPI)))
    {
        hr = THR(super::HandleMessage(pMessage));
        goto Cleanup;
    }

    hr = THR(pPI->GetActivationPolicy(&dwPolicy));
    if (hr)
        goto Cleanup;

    if (dwPolicy & POINTERINACTIVE_DEACTIVATEONLEAVE)
    {
        _fDeactivateOnMouseExit = TRUE;
    }

    if (dwPolicy & POINTERINACTIVE_ACTIVATEONENTRY)
    {
        hr = THR(TransitionTo(OS_INPLACE, NULL));
        if (hr)
            goto Cleanup;
    }

    // If the control became windowless inplace in TransitionTo, then
    // pass the message along to the control. Otherwise, use
    // IPointerInactive.
    if ( _fWindowlessInplace )
    {

        hr = THR(((IOleInPlaceObjectWindowless *)_pInPlaceObject)->
                OnWindowMessage(
                        pMessage->message,
                        pMessage->wParam,
                        pMessage->lParam,
                        plResult));
    }
    else
    {
        if (pMessage->message == WM_MOUSEMOVE)
        {
            CRect   rc;

            pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

            hr = THR_NOTRACE(pPI->OnInactiveMouseMove(
                                        &rc,
                                        MAKEPOINTS(pMessage->lParam).x,
                                        MAKEPOINTS(pMessage->lParam).y,
                                        pMessage->wParam));
        }
        else
        {
            GetCursorPos(&pt);
            ScreenToClient(Doc()->_pInPlace->_hwnd, &pt);

            // See if the control wants to set the cursor
            hr = THR(pPI->OnInactiveSetCursor(
                &rc,
                pt.x,
                pt.y,
                HIWORD(pMessage->lParam),
                FALSE));

            //
            //(ferhane) The spec says that we can only receive an S_FALSE, but ATL 
            // returns E_NOTIMPL for the default case. We are accomodating the vast 
            // number of NT ATL controls here.
            //
            if ( (hr == S_FALSE) || (hr == E_NOTIMPL) )
            {
                CTreeNode * pNodeParent = pNodeContext->GetUpdatedParentLayoutNode();
                Assert(pNodeParent);

                // Control did not set the cursor, give the container a chance
                // Call HandleMessage directly because we do not want bubbling here.
                hr = THR(pNodeParent->Element()->HandleMessage(pMessage));

                // The container did not set the cursor
                // Force the control to do it
                if (*plResult == FALSE)
                {
                    hr = THR(pPI->OnInactiveSetCursor(
                        &rc,
                        pt.x,
                        pt.y,
                        HIWORD(pMessage->lParam),
                        TRUE));
                    if (hr == S_FALSE)
                    {
                        hr = S_OK;
                    }
                }
            }
        }
    }

Cleanup:
    ReleaseInterface(pPI);
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::OnInactiveButtonMessage
//
//  Synopsis:   Handle WM_xBUTTONDOWN, WM_LBUTTONDBLCLK on inactive control.
//
//----------------------------------------------------------------------------

HRESULT
COleSite::OnInactiveMouseButtonMessage(CMessage *pMessage, LRESULT *plResult)
{
    HRESULT      hr = S_OK;
    int          iVerb;
    MSG          msg;
    UINT         message;
    IOleObject * pObj = NULL;
    CRect        rc;
    INSTANTCLASSINFO * pici;

    COleLayout * pLayout = DYNCAST(COleLayout, GetUpdatedLayout(GUL_USEFIRSTLAYOUT));
    Assert(pLayout);
    Assert( ! IsEditable(/*fCheckContainerOnly*/FALSE) );

    if (OK(THR_OLE(QueryControlInterface(IID_IOleObject, (void  **)&pObj))))
    {
        CDoc *  pDoc = Doc();

        message = pMessage->message;
        if (pMessage->message == WM_LBUTTONDBLCLK)
        {
            // Use 0 == default verb for double click.
            iVerb = 0;

            // Make double click look like single click.
            message = WM_LBUTTONDOWN;

            // Set the host names in case control opens in default verb.
            IGNORE_HR(SetHostNames());
        }
        else
        {
            //
            // Temp fix for IE5 bug 45562.  (anandra) Too risky to make this change
            // in full right now, should do this post beta2. BUG 48041 has been
            // raided about this.  
            //

            if (IsDesignMode() &&
                (pDoc->_fNoActivateNormalOleControls ||
                 pDoc->_fNoActivateDesignTimeControls ||
                 pDoc->_fNoActivateJavaApplets))
            {
                // Only vid sets these bits so we should only come here for them.
                hr = S_OK;
                if (!NoUIActivate())
                {
                    hr = THR(TransitionTo(OS_UIACTIVE, pMessage));
                }
                goto Cleanup;
            }

            pici = GetInstantClassInfo();
            
            // inplace activate in all cases, except:
            // in design mode, controls which do not do menu merge
            iVerb = (IsDesignMode() && pici &&
                     !(OLEMISC_WANTSTOMENUMERGE & pici->dwMiscStatusFlags)) ?
                        OLEIVERB_UIACTIVATE :
                        OLEIVERB_INPLACEACTIVATE;
        }

        msg = *(MSG *)pMessage;
        msg.message = message;

        pLayout->GetClientRect(&rc, COORDSYS_GLOBAL);

        hr = THR_OLE(pObj->DoVerb(
                iVerb,
                &msg,
                &_Client,
                0,
                pDoc->_pInPlace->_hwnd,
                ENSUREOLERECT(&rc)));

        if (!hr && _state < OS_RUNNING)
        {
            _state = OS_RUNNING;
        }
    }

Cleanup:
    ReleaseInterface(pObj);
    RRETURN(hr);
}


#ifndef NO_MENU
//+------------------------------------------------------------------------
//
//  Member:     COleSite::InitMenuPopup
//
//  Synopsis:   Handles WM_CONTEXTMENU message after default handling occurs.
//
//-------------------------------------------------------------------------

HRESULT
COleSite::OnInitMenuPopup(HMENU hmenu, int item, BOOL fSystemMenu)
{
    IOleObject *    pObj = NULL;
    IEnumOLEVERB *  pEnumVerb = NULL;
    OLEVERB         verb;
    HRESULT         hr;
    UINT            i;
    ULONG           cFetched;
    CDoc *          pDoc = Doc();

    hr = super::OnInitMenuPopup(hmenu, item, fSystemMenu);
    if (hr)
        goto Cleanup;

    // Clean up the verbs on the context menu from last time

    if (pDoc->_usNumVerbs)
    {
        for (i=0; i < pDoc->_usNumVerbs; i++)
        {
            DeleteMenu(hmenu, IDM_OBJECTVERBLIST0+i, MF_BYCOMMAND);
        }

        pDoc->_usNumVerbs = 0;
    }

    //
    // If we're the only site selected, then add the verbs of the embedding
    // to the context menu.
    //

    if (pDoc->GetSelectionType() == SELECTION_TYPE_Control )
    {
        hr = THR_OLE(QueryControlInterface(IID_IOleObject, (LPVOID*)&pObj));
        if (hr)
            goto Cleanup;

        hr = THR_OLE(pObj->EnumVerbs(&pEnumVerb));
        if (hr)
            goto Cleanup;

        while (pEnumVerb->Next(1, &verb, &cFetched) == S_OK)
        {
            if (verb.grfAttribs & OLEVERBATTRIB_ONCONTAINERMENU)
            {
                // If it is the properties verb or it looks like the
                // properties verb, then add a menu item for our own
                // properites command.  This insures that our own
                // properties command will always be available, but
                // has the potential for hiding an object verb that just
                // happens to look like the property verb.

                if (verb.lVerb == OLEIVERB_PROPERTIES ||
                        LooksLikePropertiesVerb(verb.lpszVerbName))
                {
#ifdef NEVER
                    fHasPropertiesVerb = TRUE;
                    AppendMenu(hmenu,
                           MF_STRING | MF_ENABLED,
                           IDM_PROPERTIES,
                           verb.lpszVerbName);
#endif
                }
                else
                {
                    AppendMenu(hmenu,
                               MF_STRING | verb.fuFlags,
                               IDM_OBJECTVERBLIST0+pDoc->_usNumVerbs,
                               verb.lpszVerbName);

                    pDoc->_usNumVerbs += 1;

                    if (pDoc->_usNumVerbs > (IDM_OBJECTVERBLISTLAST - IDM_OBJECTVERBLIST0 + 1))
                        break;
                }
            }

            CoTaskMemFree(verb.lpszVerbName);
        }
    }

#ifdef NEVER
    // Add a properties verb if object didn't have one or it's multi-select.

    if (!fHasPropertiesVerb)
    {
       AppendMenu(hMenu,
               MF_STRING | MF_ENABLED,
               IDM_PROPERTIES,
               g_szPropertiesVerb);
    }
#endif // NEVER

Cleanup:
    ReleaseInterface(pObj);
    ReleaseInterface(pEnumVerb);

    RRETURN(hr);
}
#endif // NO_MENU


//+-------------------------------------------------------------------------
//
//  Method:     COleSite::ReleaseCodeLoad
//
//  Synopsis:   Calculate the size of the object
//
//--------------------------------------------------------------------------

void
COleSite::ReleaseCodeLoad()
{
#ifndef WIN16
    if (_pCodeLoad)
    {
        CCodeLoad * pCodeLoad = _pCodeLoad;
        _pCodeLoad = NULL;
        pCodeLoad->Terminate();
        pCodeLoad->Release();
    }
#endif
}


//+-------------------------------------------------------------------------
//
//  Method:     COleSite::GetNaturalExtent
//
//  Synopsis:   Get the extent of the site.
//
//--------------------------------------------------------------------------

HRESULT
COleSite::GetNaturalExtent(DWORD dwMode, SIZEL *psizel)
{
    HRESULT hr;

    if (!_fUseViewObjectEx)
        return E_FAIL;

    DVEXTENTINFO extinfo;

    memset(&extinfo, 0, sizeof(extinfo));
    extinfo.cb = sizeof(DVEXTENTINFO);
    extinfo.sizelProposed = *psizel;
    extinfo.dwExtentMode = dwMode;

    hr = THR_OLE(((IViewObjectEx *)_pVO)->GetNaturalExtent(
            DVASPECT_CONTENT,
            -1,
            NULL,
            TLS(hdcDesktop),
            &extinfo,
            psizel));

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   COleSite::SizeToFit
//
//  Synopsis:   Do sizetoFit on.
//
//----------------------------------------------------------------------------

HRESULT
COleSite::SizeToFit()
{
    IOleObject *pObject = NULL;
    RECT        rc;
    HRESULT     hr = S_OK;
    SIZEL       sizel = { 0, 0 };

    COleLayout * pLayout = DYNCAST(COleLayout, GetUpdatedLayout(GUL_USEFIRSTLAYOUT));
    Assert(pLayout);

    if (!_fUseViewObjectEx)
        goto Cleanup;

    DVEXTENTINFO extinfo;
    memset(&extinfo, 0, sizeof(extinfo));
    extinfo.cb = sizeof(extinfo);
    extinfo.dwExtentMode = DVEXTENT_CONTENT;
    extinfo.sizelProposed = sizel;

    hr = THR_OLE(((IViewObjectEx *)_pVO)->GetNaturalExtent(
            DVASPECT_CONTENT,
            -1,
            NULL,
            NULL,
            &extinfo,
            &sizel));
    if (hr)
        goto Cleanup;

    hr = THR_OLE(QueryControlInterface(IID_IOleObject, (void **)&pObject));
    if (hr)
        goto Cleanup;

    // Control must be at least running to set the extent.

    if (_state < OS_RUNNING)
    {
        IGNORE_HR(TransitionTo(OS_RUNNING));
    }

    // The CDK implementation of IOleObject::SetExtent calls
    // IOleInplaceSite::OnPosRectChange with the old position
    // of the control.  We note that we are setting the extent
    // in order to give OnPosRectChange a reasonable answer.

    pLayout->_sizelLast = sizel;

    {
        CLock   Lock(this, OLESITELOCK_SETEXTENT);

        hr = THR_OLE(pObject->SetExtent(DVASPECT_CONTENT, &sizel));
    }

    pLayout->GetPosition((CPoint *)&rc);
    rc.right    = -1;
    rc.bottom   = -1;

    hr = THR(pLayout->Move(&rc, 0));

Cleanup:
    ReleaseInterface(pObject);

    // Ignore errors if the object does not want to resize.
    return S_OK;
}

//+-------------------------------------------------------------------
//
// Member :   COleSite::QueryStatus
//
// Synopsis :
//
//--------------------------------------------------------------------

HRESULT COleSite::QueryStatus(
        GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    Assert(IsCmdGroupSupported(pguidCmdGroup));
    Assert(cCmds == 1);

    MSOCMD * pCmd = NULL;
    HRESULT hr = S_OK;
    UINT        uPropName;
    VARTYPE     vt = VT_EMPTY;
    int         c;
    int         idm;
    GUID *      pguidControl;
    ULONG       ulCmdID;

    #if 0
            if (InSendMessage())
            {
                ReplyMessage(0);
            }
    #endif

    for (pCmd = rgCmds, c = cCmds; --c >= 0; pCmd++)
    {
        Assert(!pCmd->cmdf);

        // Disable Office documents in frameset from showing/hiding toolbars.
        if (pguidCmdGroup == NULL && pCmd->cmdID == OLECMDID_HIDETOOLBARS)
        {
            pCmd->cmdID = MSOCMDSTATE_DISABLED;
            continue;
        }

        idm = IDMFromCmdID(pguidCmdGroup, pCmd->cmdID);

        uPropName = 0;

        switch (idm)
        {
        case IDM_OBJECTVERBLIST0:
            pCmd->cmdf = MSOCMDSTATE_UP;
            break;

        case IDM_FONTNAME:
            uPropName = IDS_DISPID_FONTNAME;
            vt = VT_BSTR;
            break;

        case IDM_FONTSIZE:
            uPropName = IDS_DISPID_FONTSIZE;
            vt = VT_CY;
            break;

        case IDM_SUPERSCRIPT:
            uPropName = IDS_DISPID_FONTSUPERSCRIPT;
            vt = VT_BOOL;
            break;

        case IDM_SUBSCRIPT:
            uPropName = IDS_DISPID_FONTSUBSCRIPT;
            vt = VT_BOOL;
            break;

        case IDM_BOLD:
            uPropName = IDS_DISPID_FONTBOLD;
            vt = VT_BOOL;
            break;

        case IDM_ITALIC:
            uPropName = IDS_DISPID_FONTITAL;
            vt = VT_BOOL;
            break;

        case IDM_UNDERLINE:
            uPropName = IDS_DISPID_FONTUNDER;
            vt = VT_BOOL;
            break;

        case IDM_BACKCOLOR:
            uPropName = IDS_DISPID_BACKCOLOR;
            vt = VT_I4;
            break;

        case IDM_FORECOLOR:
            {
            // TODO: (jenlc) this is just a transition code, will be 
            // changed later for QueryStatus/Exec architecture rework.
            //
            CVariant varargOut;
            DISPID     dispidProp;
            HRESULT    hr;

            dispidProp = DISPID_A_COLOR;
            vt         = VT_I4;
            V_VT(&varargOut) = VT_I4;
            hr = THR_NOTRACE(ExecSetGetKnownProp(NULL, &varargOut, dispidProp, vt));
            pCmd->cmdf = (hr) ? (MSOCMDSTATE_DISABLED) : (MSOCMDSTATE_UP);
            break;
            }

        case IDM_BORDERCOLOR:
            uPropName = IDS_DISPID_BORDERCOLOR;
            vt = VT_I4;
            break;

        case IDM_BORDERSTYLEFIXED:
        case IDM_BORDERSTYLENO:
            uPropName = IDS_DISPID_BORDERSTYLE;
            vt = VT_I4;
            break;

        case IDM_JUSTIFYLEFT:
        case IDM_JUSTIFYCENTER:
        case IDM_JUSTIFYRIGHT:
        case IDM_JUSTIFYGENERAL:
        case IDM_JUSTIFYFULL:
            uPropName = IDS_DISPID_TEXTALIGN;
            vt = VT_I4;
            break;

        case IDM_FLAT:
        case IDM_RAISED:
        case IDM_SUNKEN:
            uPropName = IDS_DISPID_SPECIALEFFECT;
            vt = VT_I4;
            break;

        default:
            //
            // Do a reverse lookup to try and match into the standard cmd set.
            //

            if (OLECMDIDFromIDM(idm, &ulCmdID))
            {
                pguidControl = NULL;
                pCmd->cmdID = ulCmdID;
            }
            else
            {
                pguidControl = pguidCmdGroup;
            }

            if (!pguidControl ||
                (IsEqualGUID(CGID_MSHTML, *pguidControl) &&
                    (Tag() == ETAG_FRAME || Tag() == ETAG_IFRAME)))
            {
                // Only call control if not locked and the command guid
                // is the standard one.  (Forms3 specific commands are
                // never passed down.)
                //

// WINCEREVIEW - cut call to InSendMessage
#ifndef WINCE
                if (_pUnkCtrl && ! this->TestLock(OLESITELOCK_QUERYSTATUS) && !InSendMessage())
                {
                    CLock   Lock(this, OLESITELOCK_QUERYSTATUS);
                    
                    hr = THR_OLE(CTQueryStatus(
                            _pUnkCtrl,
                            pguidControl,
                            1,
                            pCmd,
                            pcmdtext));
                }
                else
#endif // WINCE
                {
                    pCmd->cmdf = MSOCMDSTATE_DISABLED;
                }
                continue;
           }

        }

        if(uPropName)
        {
            Assert(vt != VT_EMPTY);
            hr = THR_NOTRACE(QueryStatusProperty(pCmd, uPropName, vt));
        }

        if ((hr == S_OK || hr == OLECMDERR_E_NOTSUPPORTED) && !pCmd->cmdf)
        {
            hr = THR_NOTRACE(super::QueryStatus(pguidCmdGroup, 1, pCmd, pcmdtext));
        }

    }

    RRETURN_NOTRACE(hr);
}

//+-------------------------------------------------------------------
//
// Member :   COleSite::Exec
//
// Synopsis :
//
//--------------------------------------------------------------------

HRESULT
COleSite::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));

    HRESULT         hr = OLECMDERR_E_NOTSUPPORTED;
    UINT            uPropName;
    VARTYPE         vt = VT_EMPTY;
    DWORD           dwValue;
    int             idm;
    DISPID          dispidProp;
    CParentUndoUnit *pCPUU = NULL;
    GUID *          pguidControl;
    ULONG           ulCmdID;

    // Disable Office documents in frameset from showing/hiding toolbars.
    if (pguidCmdGroup == NULL && nCmdID == OLECMDID_HIDETOOLBARS)
    {
        RRETURN(OLECMDERR_E_DISABLED);
    }

    idm = IDMFromCmdID(pguidCmdGroup, nCmdID);

    // If the idm represents an undoable property change, open
    // a parent undo unit.

#ifndef NO_EDIT
    if (idm != IDM_UNDO && idm != IDM_REDO)
    {
        pCPUU = OpenParentUnit(this, IDS_UNDOPROPCHANGE);
    }
#endif // NO_EDIT
    switch (idm)
    {

    case IDM_SIZETOFIT:
        hr = THR(SizeToFit());
        break;

    case IDM_OBJECTVERBLIST0:
        break;

    case IDM_FONTNAME:
        uPropName = IDS_DISPID_FONTNAME;
        vt = VT_BSTR;
        goto ExecSetGetProperty;

    case IDM_FONTSIZE:
        {
            CVariant varTemp;
            CY      cy;

             V_VT(&varTemp) = VT_CY;
            // Need to do convert from long (twips) to CURRENCY for font size
            if (pvarargIn)
            {
                cy.Lo = V_I4(pvarargIn)/20 * 10000;
                cy.Hi = 0;
                V_CY(&varTemp) = cy;
            }

            hr = THR_NOTRACE(ExecSetGetProperty(
                    pvarargIn ? &varTemp: NULL,
                    pvarargOut ? &varTemp : NULL ,
                    IDS_DISPID_FONTSIZE,
                    VT_CY));

            if (!hr && pvarargOut)
            {
                V_VT(pvarargOut) = VT_I4;
                cy = V_CY(&varTemp);
                V_I4(pvarargOut) = cy.Lo /10000*20;
            }
            goto Cleanup;
        }

    case IDM_SUPERSCRIPT:
        uPropName = IDS_DISPID_FONTSUPERSCRIPT;
        goto ExecToggleCmd;

    case IDM_SUBSCRIPT:
        uPropName = IDS_DISPID_FONTSUBSCRIPT;
        goto ExecToggleCmd;

    case IDM_BOLD:
        uPropName = IDS_DISPID_FONTBOLD;
        goto ExecToggleCmd;

    case IDM_ITALIC:
        uPropName = IDS_DISPID_FONTITAL;
        goto ExecToggleCmd;

    case IDM_UNDERLINE:
        uPropName = IDS_DISPID_FONTUNDER;
        goto ExecToggleCmd;

    case IDM_BACKCOLOR:
        uPropName = IDS_DISPID_BACKCOLOR;
        vt = VT_I4;
        goto ExecSetGetProperty;

    case IDM_FORECOLOR:
        dispidProp = DISPID_A_COLOR;
        // for this color we need to swap
        if (pvarargIn)
        {
            CColorValue cvValue;
            CVariant varColor;

            hr = THR(varColor.CoerceVariantArg(pvarargIn, VT_I4));
            if (hr)
                goto Cleanup;

            cvValue.SetFromRGB(V_I4(&varColor));

            V_I4(pvarargIn) = (DWORD)cvValue.GetRawValue();
            V_VT(pvarargIn) = VT_I4;
        }
        vt = VT_I4;
        goto ExecKnownDispidProperty;

    case IDM_BORDERCOLOR:
        uPropName = IDS_DISPID_BORDERCOLOR;
        vt = VT_I4;
        goto ExecSetGetProperty;

    case IDM_BORDERSTYLEFIXED:
        uPropName = IDS_DISPID_BORDERSTYLE;
        dwValue = fmBorderStyleSingle;
        goto ExecSetPropertyCmd;

    case IDM_BORDERSTYLENO:
        uPropName = IDS_DISPID_BORDERSTYLE;
        dwValue = fmBorderStyleNone;
        goto ExecSetPropertyCmd;

    case IDM_RAISED:
        uPropName = IDS_DISPID_SPECIALEFFECT;
        dwValue = fmBorderStyleRaised;
        goto ExecSetPropertyCmd;

    case IDM_SUNKEN:
        uPropName = IDS_DISPID_SPECIALEFFECT;
        dwValue = fmBorderStyleSunken;
        goto ExecSetPropertyCmd;

    case IDM_GETPUNKCONTROL:
        if (pvarargOut)
        {
            V_VT(pvarargOut) = VT_UNKNOWN;
            pvarargOut->punkVal = _pUnkCtrl;
            hr = S_OK;
        }
        goto Cleanup;

    default:
        //
        // Do a reverse lookup to try and match into the standard cmd set.
        //

        if (OLECMDIDFromIDM(idm, &ulCmdID))
        {
            pguidControl = NULL;
        }
        else
        {
            pguidControl = pguidCmdGroup;
            ulCmdID = nCmdID;
        }


        if (_pUnkCtrl && 
            (!pguidCmdGroup ||
                (IsEqualGUID(CGID_MSHTML, *pguidCmdGroup) &&
                    (Tag() == ETAG_FRAME || Tag() == ETAG_IFRAME))))
        {
            OPTIONSETTINGS *pos = Doc()->_pOptionSettings;
            
            if (_pDisp &&
                (idm == IDM_IMAGE || 
                 ((idm == IDM_PASTE || idm == IDM_CUT || idm == IDM_COPY) &&
                  (!pos || !pos->fAllowCutCopyPaste))) && 
                !AccessAllowed(_pDisp))
            {
                hr = E_ACCESSDENIED;
                goto Cleanup;
            }

            hr = THR_OLE(CTExec(
                    _pUnkCtrl,
                    pguidControl,
                    ulCmdID,
                    nCmdexecopt,
                    pvarargIn,
                    pvarargOut));
        }
        break;
    }

    // When user cancel saveas, Excel returns OLECMDERR_E_NOTSUPPORTED
    if (idm == IDM_SAVEAS && hr == OLECMDERR_E_NOTSUPPORTED)
    {
        hr = S_OK;
    }

    // Some controls return DISP_E_MEMBERNOTFOUND even though they should return OLECMDERR_E_NOTSUPPORTED
    // instead.  This safety valve catches those cases:    -Tom
    if( DISPID_NOT_FOUND(hr) || hr == E_NOINTERFACE ||
            hr == OLE_E_NOCONNECTION || hr == OLECMDERR_E_UNKNOWNGROUP)
    {
        hr = OLECMDERR_E_NOTSUPPORTED;
    }

    if (OLECMDERR_E_NOTSUPPORTED == hr)
        hr = THR_NOTRACE(super::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn,
                pvarargOut));
    goto Cleanup;

ExecKnownDispidProperty:
    Assert(vt != VT_EMPTY);
    hr = THR_NOTRACE(ExecSetGetKnownProp(pvarargIn,pvarargOut,dispidProp, vt));
    goto Cleanup;

ExecSetGetProperty:
    Assert(vt != VT_EMPTY);
    hr = THR_NOTRACE(ExecSetGetProperty(pvarargIn,pvarargOut,uPropName,vt));
    goto Cleanup;

ExecToggleCmd:
    hr = THR_NOTRACE(ExecToggleCmd(uPropName));
    goto Cleanup;

ExecSetPropertyCmd:
    hr = THR_NOTRACE(ExecSetPropertyCmd(uPropName, dwValue));
    goto Cleanup;

Cleanup:
#ifndef NO_EDIT
    CloseParentUnit(pCPUU, hr);
#endif // NO_EDIT
    RRETURN_NOTRACE(hr);
}





BOOL
COleSite::CheckDisplayAsDefault(CElement * pElem)
{
     return (pElem && pElem->TestClassFlag(ELEMENTDESC_OLESITE) &&
      (DYNCAST(COleSite, pElem)->_fActsLikeButton ||
       DYNCAST(COleSite, pElem)->_fEatsReturn));
}
//+---------------------------------------------------------------------------
//
//  Member:     COleSite::EnsureParamBag()
//
//  Synopsis:   creates param bag if not yet
//
//----------------------------------------------------------------------------

HRESULT
COleSite::EnsureParamBag()
{
    if (!_pParamBag)
    {
        _pParamBag = new CPropertyBag();
        if (!_pParamBag)
            RRETURN (E_OUTOFMEMORY);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::ReleaseParamBag()
//
//  Synopsis:   releases param bag if not yet; sets _pParamBag to NULL
//
//----------------------------------------------------------------------------

HRESULT
COleSite::ReleaseParamBag()
{
    if (_pParamBag)
    {
        _pParamBag->Release();
        _pParamBag = NULL;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::ExchangeParamBag()
//
//  Synopsis:   exchanges properties between control and param bag using
//              IPersistProperyBag interface
//
//  Parameters  dir:    if (dir == UPLOADPARAMBAG)
//                          uploads parameters from param bag of CObjectElement
//                          to control maintained in this site
//                      else if (dir == DOWNLOADPARAMBAG)
//                          downloads parameters to param bag of CObjectElement
//                          from control maintained in this site
//
//
//----------------------------------------------------------------------------

HRESULT
COleSite::ExchangeParamBag(ExchangeParamBagDir dir)
{
    HRESULT                 hr = S_OK;
    IPersistPropertyBag *   pPPBag = NULL;
    IPersistPropertyBag2 *  pPPBag2 = NULL;

    if (QueryControlInterface(IID_IPersistPropertyBag2, (void **)&pPPBag2))
    {
        hr = QueryControlInterface(IID_IPersistPropertyBag, (void**)&pPPBag);
        if (hr)
            goto Cleanup;
    }

    Assert(pPPBag || pPPBag2);

    switch (dir)
    {
    case TOCONTROL:
        Assert(_pParamBag);
        hr = (pPPBag2) ?
                THR_OLE(pPPBag2->Load(_pParamBag, NULL)) :
                THR_OLE(pPPBag->Load(_pParamBag, NULL));
        break;

    case FROMCONTROL:
        hr = EnsureParamBag();
        if (hr)
            goto Cleanup;

        hr = (pPPBag2) ?
                THR_OLE(pPPBag2->Save(_pParamBag, TRUE, TRUE)) :
                THR_OLE(pPPBag->Save(_pParamBag, TRUE, TRUE));
        break;

    default:
        Assert (0 && "invalid argument");
    }

Cleanup:
    ReleaseInterface(pPPBag);
    ReleaseInterface(pPPBag2);
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::IsOleProxy
//
//  Returns:    BOOL      True if _pUnkCtrl is actually an OLE proxy.
//
//  Notes:      It performs this check by QI'ing for IClientSecurity.
//              Typically only ole proxies implement this interface.  An
//              arbitrary ocx has no use for it.
//
//----------------------------------------------------------------------------

BOOL
COleSite::IsOleProxy()
{
    IClientSecurity *   pCL;
    BOOL                fRet = FALSE;

#ifndef WIN16       //BUGWIN16 deal with this when do code download
    if (OK(QueryControlInterface(IID_IClientSecurity, (void **)&pCL)))
    {
        ReleaseInterface(pCL);
        // Only proxy objects should support this interface.
        fRet = TRUE;
    }
#endif

    return fRet;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::QuerySafeLoadInterface
//
//  Returns:    HRESULT     E_NOINTERFACE if not verifiably safe to initialize via
//                          the requested interface.  Otherwise, the result
//                          returned from QueryInterface.
//
//  Notes:      Queries for the interface, then determines safety of initialization
//              via that interface.  If not verifiable safe, clears the interface
//              and returns E_NOINTERFACE even if the control implements it.
//
//----------------------------------------------------------------------------

HRESULT
COleSite::QuerySafeLoadInterface(REFIID riid, void ** ppOut)
{
    HRESULT hr = THR_NOTRACE(QueryControlInterface(riid, ppOut));

    if (OK(hr) && *ppOut)
    {
        if (!IsSafeToInitialize(riid))
        {
            ClearInterface((IUnknown **)ppOut);
            hr = S_FALSE;
            goto Cleanup;
        }
        else
        {
            //  Loading data into a control on a print doc is always safe since the
            //  data was saved by this control and wouldn't have been loaded originally
            //  unless it was safe to do so.
            if (Doc()->IsPrintDialogNoUI())
            {
                goto Cleanup;
            }    
            else if ( riid == IID_IPersistMoniker ||
                      riid == IID_IPersistStream ||
                      riid == IID_IPersistFile ||
                      riid == IID_IPersistStreamInit)
            {
                //  For certain interfaces, deny access to x-domain data if the user
                //  has not explicitly allowed it.

                CLSID * pCLSID = GetpCLSID();

                if (!pCLSID || (!_fDataSameDomain && !IsEqualCLSID(CLSID_Scriptlet, *pCLSID)))
                {
                    BOOL fAllowXDomain = FALSE;

                    THR(GetMarkupPtr()->ProcessURLAction(
                        URLACTION_CROSS_DOMAIN_DATA,
                        &fAllowXDomain));

                    // if user has chosen not to allow x-domain data access, honor that.
                    if (!fAllowXDomain)
                    {
                        ClearInterface((IUnknown **)ppOut);
                        hr = S_FALSE;
                        goto Cleanup;
                    }
                }
            }
        }
    }

Cleanup:
    return hr;
}


HRESULT
COleSite::GetAmbientProp(DISPID dispid, VARIANT *pvarResult)
{
    Assert(pvarResult);

    HRESULT hr = S_OK;
    BOOL    fBoolValue;

    switch (dispid)
    {
        case DISPID_AMBIENT_BACKCOLOR:
            {
                OLE_COLOR backColor = (OLE_COLOR)(GetInheritedBackgroundColor() & 0x00ffffff);
                V_VT(pvarResult) = VT_I4;
                V_I4(pvarResult) = backColor;
            }
            break;

        case DISPID_AMBIENT_FORECOLOR:
            {
                CColorValue ccvTextColor;
                OLE_COLOR foreColor;

                if (GetFirstBranch())
                    ccvTextColor = GetFirstBranch()->GetCascadedcolor();

                if (ccvTextColor.IsDefined())
                {
                    // If ForeColor is available from character formatting info...
                    foreColor = ccvTextColor.GetOleColor();
                }
                else
                {
                    // otherwise get ForeColor from document settings.
                    foreColor = Doc()->_pOptionSettings->colorText;
                }

                V_VT(pvarResult) = VT_I4;
                V_I4(pvarResult) = foreColor;
            }
            break;

        case DISPID_AMBIENT_FONT:
            {
                const CCharFormat *pCF = GetFirstBranch() ? GetFirstBranch()->GetCharFormat() : NULL;
                LPDISPATCH pFontDisp = NULL;

                if (pCF)
                {
                    FONTDESC fontDesc;

                    CStr sFaceName;
                    sFaceName.Set(pCF->GetFaceName());

                    fontDesc.cbSizeofstruct = sizeof (FONTDESC);
                    fontDesc.lpstrName = sFaceName;
                    fontDesc.cySize.Hi = 0;
                    fontDesc.cySize.Lo = MulDivQuick(pCF->GetHeightInTwips(Doc()), 10000, TWIPS_PER_POINT);
                    fontDesc.sWeight = pCF->_wWeight;
                    fontDesc.sCharset = pCF->_bCharSet;
                    fontDesc.fItalic = pCF->_fItalic;
                    fontDesc.fUnderline = pCF->_fUnderline;
                    fontDesc.fStrikethrough = pCF->_fStrikeOut;
                    hr = THR(OleCreateFontIndirect(&fontDesc, IID_IFontDisp, (void **)&pFontDisp));
                }

                V_VT(pvarResult) = VT_DISPATCH;
                if (OK(hr) && pFontDisp)
                    V_DISPATCH(pvarResult) = pFontDisp;  // Consumer must Release...
                else
                    V_DISPATCH(pvarResult) = NULL;
            }
            break;

        case DISPID_AMBIENT_DISPLAYNAME:
            V_VT(pvarResult) = VT_BSTR;
            hr = THR(FormsAllocString(GetIdentifier(), &V_BSTR(pvarResult)));
            break;

        case DISPID_AMBIENT_UIDEAD:
            fBoolValue = FALSE;
            goto StoreBool;

        case DISPID_AMBIENT_USERMODE:
            fBoolValue = !IsDesignMode();
            goto StoreBool;

        case DISPID_AMBIENT_SHOWGRABHANDLES:
        case DISPID_AMBIENT_SHOWHATCHING:
            fBoolValue = FALSE; // Never allow clients to show hatching
            goto StoreBool;

        case DISPID_AMBIENT_LOCALEID:
            {
                V_VT(pvarResult) = VT_I4;
                const CCharFormat *pCF = GetFirstBranch() ? GetFirstBranch()->GetCharFormat() : NULL;
                if (pCF)
                {
                    V_I4(pvarResult) = pCF->_lcid;
                }
                else
                {
                    V_I4(pvarResult) = g_lcidUserDefault;
                }
            }
            break;

#ifndef WIN16
            // michaelw - temporary fix until ambient palette is implemented by CDoc
        case DISPID_AMBIENT_PALETTE:
            V_VT(pvarResult) = VT_HANDLE;
            V_I4(pvarResult) = HandleToLong(Doc()->GetPalette());
            break;
#endif //!WIN16

        case DISPID_AMBIENT_MESSAGEREFLECT:
        case DISPID_AMBIENT_SUPPORTSMNEMONICS:
            fBoolValue = TRUE;
            goto StoreBool;

        case DISPID_AMBIENT_DISPLAYASDEFAULT:
            {
                CElement * pElemCurrent = Doc()->_pElemCurrent;

                if (pElemCurrent == this)
                {
                    fBoolValue = TRUE;
                }
                else if (_fDefault &&
                        !CheckDisplayAsDefault(pElemCurrent))
                {
                    fBoolValue = TRUE;
                }
                else
                {
                    fBoolValue = FALSE;
                }
            }
            goto StoreBool;

        case DISPID_AMBIENT_OFFLINEIFNOTCONNECTED :
            fBoolValue = ((Doc()->_dwLoadf & DLCTL_OFFLINEIFNOTCONNECTED) ? TRUE : FALSE);
            goto StoreBool;

        case DISPID_AMBIENT_SILENT :
            fBoolValue = ((Doc()->_dwLoadf & DLCTL_SILENT) ? TRUE : FALSE);
            goto StoreBool;

        case DISPID_AMBIENT_USERAGENT:
            V_VT(pvarResult) = VT_BSTR;
            hr = THR(FormsAllocString(Doc()->_bstrUserAgent, &V_BSTR(pvarResult)));
            break;

        case DISPID_AMBIENT_DLCONTROL:
            V_VT(pvarResult) = VT_I4;
            V_I4(pvarResult) = Doc()->_dwLoadf;
            break;

        case DISPID_AMBIENT_RIGHTTOLEFT:
        {
            fBoolValue = FALSE;
            if (IsInMarkup())
            {
                if (GetMarkup()->Document())
                {
                    hr = THR(GetMarkup()->Document()->GetDocDirection(&fBoolValue));
                }
            }
            fBoolValue = ENSURE_BOOL(fBoolValue);
            goto StoreBool;

StoreBool:
            V_VT(pvarResult) = VT_BOOL;
            V_BOOL(pvarResult) = (VARIANT_BOOL)-fBoolValue;
            break;
        }
        case DISPID_AMBIENT_CODEPAGE:
            V_VT(pvarResult) = VT_UI4;
            V_UI4(pvarResult) = GetMarkup()->GetCodePage();
            break;

        case DISPID_AMBIENT_CHARSET:
            {
                TCHAR tszCharset[MAX_MIMECSET_NAME] = {0};
                V_VT(pvarResult) = VT_BSTR;
                IGNORE_HR(GetMlangStringFromCodePage(GetMarkup()->GetCodePage(), tszCharset,
                                                     ARRAY_SIZE(tszCharset)));
                hr = THR(FormsAllocString(tszCharset, &V_BSTR(pvarResult)));
            }
            break;

        default:
            hr = THR_NOTRACE(Doc()->GetAmbientVariant(dispid, pvarResult));
            break;

    }   // switch

    RRETURN_NOTRACE(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::OlesiteTag
//
//  Synopsis:   Return type of thingy that's really running in this site
//
//----------------------------------------------------------------------------

COleSite::OLESITE_TAG
COleSite::OlesiteTag()
{
    OLESITE_TAG ostag;
    INSTANTCLASSINFO * pici;

    // TODO: For now just look at my tag.  Replace this with a more sophisticated
    // test that drills down to the thing that's really running.
    switch (Tag())
    {
    case ETAG_OBJECT:
    case ETAG_APPLET:
        pici = GetInstantClassInfo();

        if (!pici)
        {
            ostag = OSTAG_UNKNOWN;
        }
        else if ((Tag() == ETAG_APPLET && IsEqualGUID((REFGUID)pici->clsid, (REFGUID)g_Zero.guid)) || 
                  IsEqualGUID((REFGUID)pici->clsid, (REFGUID)CLSID_AppletOCX))
        {
           ostag = OSTAG_APPLET;
        }
        else
        {
           ostag = OSTAG_ACTIVEX;
        }
        break;

    case ETAG_EMBED:
        ostag = OSTAG_PLUGIN;
        break;

    case ETAG_FRAME:
        ostag = OSTAG_FRAME;
        break;

    case ETAG_IFRAME:
        ostag = OSTAG_IFRAME;
        break;

    default:
        AssertSz(0, "Unknown tag");
        ostag = OSTAG_UNKNOWN;
        break;
    }

    return ostag;
}

//+------------------------------------------------------------------------
//
//  Member:     COleSite::RefreshCallback(UINT uTimerID)
//
//  Synopsis:   refresh our control which can only be a CDoc by
//              potentially bashing it's _cstrUrl
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT BUGCALL
COleSite::RefreshCallback(UINT uTimerID)
{
    HRESULT hr = S_OK;
    FormsKillTimer(this, REFRESH_TIMER_ID);
    DWORD dwRefreshFlags = OLECMDIDF_REFRESH_NO_CACHE;

    CDoc *pDoc = (CDoc*)(void*)_pUnkCtrl;
    Assert( (*(void**)pDoc) == *(void**)Doc()); // This *should* always be a CDoc.
    if (_pstrRefreshURL)
    {
        dwRefreshFlags |= OLECMDIDF_REFRESH_CLEARUSERINPUT;
        hr = THR(pDoc->SetPrimaryUrl(_pstrRefreshURL));
        // _pstrRefreshURL must be NULL before we ExecRefresh
        // since the ExecRefresh may free the string
        FormsFreeString(_pstrRefreshURL);
        _pstrRefreshURL = NULL;
        if (hr)
            goto Cleanup;
        
    }
    GetMarkup()->Window()->ExecRefresh(dwRefreshFlags);

Cleanup:
    return hr;
}

HRESULT COleSite::OnFailToCreate()
{
    _fFailedToCreate = TRUE;
    _fNoUIActivateInDesign = TRUE;
    return S_OK;
}

void
COleSite::DeferredCreateObject( DWORD_PTR dwContext )
{
    ELEMENT_TAG etag = Tag();

    if ((etag == ETAG_APPLET) || (etag == ETAG_OBJECT))
    {
        IGNORE_HR((DYNCAST(CObjectElement, this))->CreateObject());
    }
    else if (etag == ETAG_EMBED)
    {
        IGNORE_HR((DYNCAST(CPluginSite, this))->CreateObject());
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::SaveMetaFileSnapshot
//
//  Synopsis:   Helper routine, called by CObjectElement::Save, which saves
//              a metafile image of the element
//
//  Arguments:  pchTempFileName - returns the name of temporary used for save
//
//----------------------------------------------------------------------------
HRESULT COleSite::SaveMetaFileSnapshot(TCHAR *pchTempFileName)
{
    HRESULT hr = E_FAIL;
    CLayout * pLayout;
    CSize size;

    // Get layout. If there is no layout, or if the size is zero, 
    // return fake file name to suppress object instantiation in print doc.
    // NOTE: at this point, we don't care which layout we get - 
    //       we hope the size is same everywhere.
    pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);
    if (NULL == pLayout || (pLayout->GetContentSize(&size), size.IsZero()))
    {
        // if this olesite is being used as a class factory for elemente 
        // behaviors we need to do something special.  This object actually
        // needs to be instantiated in the print template document, as a 
        // precondition, we can't put "ZERO" into the filename, and we 
        // do need a sentinal to say "hey I need to be instantiated.
        if (!_fElementBehaviorFactory)
        {
            _tcscpy(pchTempFileName, _T("_ZERO"));
        }
        else
        {
            _tcscpy(pchTempFileName, _T("_EB_FACTORY"));
        }

        hr = S_OK;
        goto Cleanup;
    }

    // Get temp file name    
    if (!Doc()->GetTempFilename(_T("\0"), _T("emf"), pchTempFileName))
    {
        goto Cleanup;
    }
    
    // Draw to metafile
    hr = SaveMetaFileSnapshotCore(pLayout, size, pchTempFileName);

Cleanup:
    if (hr != S_OK)
        *pchTempFileName = 0;
        
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Routine:    IsMoney2000
//
//  Synopsis:   Detect whether client object is implemented by
//              MSMoney2000. Considered "yes" if it have property
//              "hwndMoney" and have not "ie55compatible" property.
//              The last one is supposed to be added to MSMoney2001
//              and next msmoney versions.
//
//----------------------------------------------------------------------------
static bool IsMoney2000(IViewObject* pVO)
{
    if (!g_fInMoney98 || !pVO)
        return false;

    IDispatch* pDispatch;
    HRESULT hr = pVO->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    if (FAILED(hr))
        return false;

    DISPID rgDispId[2];
           rgDispId[0] =
           rgDispId[1] = DISPID_UNKNOWN;
    static OLECHAR* propNames[2] =
    {
        _T("hwndMoney"),
        _T("ie55compatible")
    };

    hr = pDispatch->GetIDsOfNames(IID_NULL,
                                  propNames, 2,
                                  g_lcidUserDefault, rgDispId);

    pDispatch->Release();

    return (hr == DISP_E_UNKNOWNNAME || SUCCEEDED(hr))
        && rgDispId[0] != DISPID_UNKNOWN
        && rgDispId[1] == DISPID_UNKNOWN;
}

//+---------------------------------------------------------------------------
//
//  Routine:    CreatePrinterIC
//
//  Synopsis:   Create information context for printer device,
//              using our best guess as a printer device.  This is, in descending order:
//              1. the last printer used to print from this app (_hDevNames)
//              2. the system default printer
//              Note that we may not actually use this printer in the final draw, which
//              can cause issues with things like colour depth...
//
//  Return:     HDC or 0 on any error
//
//  Note:       this hack reproduces old-style mshtml behavior that
//              required for already shipped applications like Money2000
//
//----------------------------------------------------------------------------
static HDC CreatePrinterIC(CDoc *pDoc)
{
    HDC hDC = NULL;

    // We have stored the DEVNAMES of the last our successful print.
    // Best guess: the user probably will print to the same device this time.
    if (pDoc && pDoc->_hDevNames)
    {
        DEVNAMES * pDevNames = (DEVNAMES *)::GlobalLock(pDoc->_hDevNames);           
        if (pDevNames)
        {
            hDC = CreateIC((TCHAR *)pDevNames + pDevNames->wDriverOffset,
                           (TCHAR *)pDevNames + pDevNames->wDeviceOffset,
                           NULL,
                           NULL);

            ::GlobalUnlock(pDoc->_hDevNames);
        }
    }

    // 2. If an IC is still needed, check for a system default printer
    if (!hDC)
    {
        // A better way to do this on NT5+ is to use ::GetDefaultPrinter.
        PRINTDLG printdlg;

        ::ZeroMemory(&printdlg, sizeof(PRINTDLG));
        printdlg.lStructSize    = sizeof(PRINTDLG);
        printdlg.hwndOwner      = pDoc->GetHWND();       
        printdlg.Flags          |= PD_RETURNDEFAULT | PD_RETURNIC;

        if (PrintDlg(&printdlg))
        {
            hDC = printdlg.hDC;
            if (printdlg.hDevMode)
                ::GlobalFree(printdlg.hDevMode);
            if (printdlg.hDevNames)
                ::GlobalFree(printdlg.hDevNames);
        }
    }
    
    return hDC;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::SaveMetaFileSnapshotCore
//
//  Synopsis:   Helper routine, called by CObjectElement::Save, which saves
//              a metafile image of the element
//
//  Arguments:  pLayout - current layout
//              sizeCurrent - logical size of layout (not apparent)
//              pchTempFileName - the name of temporary used for save
//
//  Return:     S_OK on success
//              S_FALSE on no API failures, but unusable metafile
//              E_FAIL on other failures.
//
//----------------------------------------------------------------------------
//
// this is the list of controls that have been identified as CLAIMING to support IVO, but in actually do
// NOTHING when called to draw. They all have HWNDS, so we can apphack them.  Bad control. Bad.
//
EXTERN_C const GUID CLSID_MS_PROJ_GRID_CTRL    = {0xBE194B4A, 0x6063, 0x11D1, {0xBE, 0x5C, 0x00, 0xC0, 0x4F, 0xB9, 0x07, 0x59}};
EXTERN_C const GUID CLSID_MS_SYSTEMINFORMATION = {0x273380e8, 0x1438, 0x4b2c, {0x95, 0xb0, 0x71, 0x32, 0x84, 0xfb, 0xc3, 0x02}};
EXTERN_C const GUID CLSID_PRINTSHOP_PHOTO_BTN  = {0xADB880A6, 0xD8FF, 0x11CF, {0x93, 0x77, 0x00, 0xAA, 0x00, 0x3B, 0x7A, 0x11}};
EXTERN_C const GUID CLSID_HTMLHELP  = {0x41B23C28, 0x488E, 0x4E5C, {0xAC, 0xE2, 0xBB, 0x0B, 0xBA, 0xBE, 0x99, 0xE8}};


HRESULT COleSite::SaveMetaFileSnapshotCore(CLayout *pLayout, 
                                           CSize sizeCurrent, 
                                           TCHAR const *pchTempFileName)
{
    HENHMETAFILE    hemf = NULL;
    HRESULT         hr = S_OK;
    HDC             hdcEmf = NULL;
    CSize           sizeCurrentHM;

    
    // Use display as target device.
    //
    // NOTE: we really should be using some kind of universal standard device, with 
    //       resolution set to our hi-res units, but I don't know if we can cook up
    //       an information context for it without having a driver.
    //       More issues to consider for choice of target device:
    //       * From metafile point of ciew, screen pixels are not always square. 
    //         My screen has 4x4.27 ratio (although it doesn't look like that to me) 
    //         and that affects subsequent metafile rendering unless we make adjustments
    //       * printer pixels are usually square. Hovever, if a bitmap is output for 
    //         printer resolution, it may get huge, without becoming higher quality (alexmog 10/13/99)
    //
    // NOTE: we can't hook up the IC without a driver, and we need to do this in
    //      order to avoid driver problems when they try to dither a bitmap drawn to screen colordepth
    //      to their grayscale or limited colors.  This has been a source of regular complaints during
    //      ie 5.5 (carled 03/01/00)
    //

    // NOTE: MSMoney2000 refuses to draw if hicTargetDev corresponds to display-type device.
    //       They use to compare GetDeviceCaps(*, TECHNOLOGY) with DT_RASDISPLAY value.
    //       We consider this incorrect, but unfortunately money is shipped already so we need
    //       to provide compatibility. Following patch can be removed if we'll dare to develop
    //       drivers for all platforms (mikhaill  4/29/00).

    HDC hicTargetDev = 0;

    if (IsMoney2000(_pVO))
        hicTargetDev = CreatePrinterIC(Doc());

    if (hicTargetDev == 0)
        hicTargetDev = CreateIC(_T("DISPLAY"), NULL, NULL, NULL);

    // NOTE: if you want to initialize hicTargetDev for default printer, refer
    //       to source history of this file.

    // Use default measuring device (unless we use a specific target DC)
    CDocInfo const *pdciTarget = Doc()->GetView()->GetMeasuringDevice(mediaTypeNotSet);

    // We need to find object size to initialize metafile bounds properly
    // The size we are getting from layout may have been calculated for a different resolution.
    // Use layout's media to convert to himetric
    {
        mediaType mediaLayout = pLayout->LayoutContext() ? pLayout->LayoutContext()->GetMedia() : mediaTypeNotSet;
        CDocInfo const *pdciLayout = Doc()->GetView()->GetMeasuringDevice(mediaLayout);

        // Calculate size in himetric
        pdciLayout->HimetricFromDevice(sizeCurrentHM, sizeCurrent);

        // Convert layout size to target size if devices are different
        pdciLayout->TargetFromDevice(sizeCurrent, *pdciTarget->GetUnitInfo());
    }
            
    // This rectangle will determine the element's size when we print
    CRect rcMetafileBounds(sizeCurrentHM);

    //
    // create metafile
    //
    if (g_dwPlatformID == VER_PLATFORM_WIN32_NT)
    {
        // Use Unicode for file name
        hdcEmf = CreateEnhMetaFile(hicTargetDev,                    // hdcRef
                                   pchTempFileName,                 // lpFilename
                                   &rcMetafileBounds,               // lpRect
                                   _T("MSHTML\0OLE object image\0\0"));  // lpDescription
    }
    else
    {
        // Use ANSI for file name
        char achTempFileA[MAX_PATH];
        if (WideCharToMultiByte(CP_OEMCP, 0, pchTempFileName, -1, achTempFileA, MAX_PATH, NULL, NULL))
        {
            hdcEmf = CreateEnhMetaFileA(hicTargetDev,                // hdcRef
                                    achTempFileA,                    // lpFilename
                                    &rcMetafileBounds,               // lpRect
                                    "MSHTML\0OLE object image\0\0"); // lpDescription
        }
    }

    if (hdcEmf != NULL)
    {
        INSTANTCLASSINFO *  pici;

        // For controls that use the fUseBMP hack
        HDC                 hdcBmp  = NULL;
        HBITMAP             hbmp    = NULL;
        HDC                 hdcToUse = NULL;

        pici = GetInstantClassInfo();

        //
        // this test is for known controls that say they support IVO, but do nothing on the 
        // IVO::Draw call. for these we can only print them by using the sendMessage codepath
        //
        BOOL fNoIVODraw =   (   pici 
                             && (   IsEqualGUID((REFGUID)pici->clsid,
                                                (REFGUID)CLSID_MS_PROJ_GRID_CTRL)
                                 || IsEqualGUID((REFGUID)pici->clsid, 
                                                (REFGUID)CLSID_MS_SYSTEMINFORMATION)
                                 || IsEqualGUID((REFGUID)pici->clsid, 
                                                (REFGUID)CLSID_PRINTSHOP_PHOTO_BTN)
                                 || IsEqualGUID((REFGUID)pici->clsid, 
                                                (REFGUID)CLSID_HTMLHELP)
                             ));
        //
        // This test is for controls that can't (for whatever reason) use a metafile.
        // We render them to a memory DC (with bitmap enabled), and just bitblt over the contents.
        // Yes, this should cause dithering weirdness depending on the color depth of the DISPLAY driver & printers.
        // This includes:
        // (1)  Applets under Win9x with FE characters crash when rendering to a metafile due to JVM/GDI bugs.
        //      We can't tell if an applet has such characters, so we use the heuristic to identify risk applets:
        //      (a) Applet is not on an AsciiLatin codepage
        //      (b) We are running on an FE build of Win9x.
        //      In these cases we trade font fidelity/size for safety.
        //        
        BOOL fUseBMP    =   (   !g_fUnicodePlatform   
                             && OlesiteTag() == OSTAG_APPLET
                             && (   GetMarkup()->GetCodePage() != 1252
                                 ||  g_fFarEastWin9X
                            ));
                                             
        //
        // Initialize non-inplace draw info
        //
        CDispClipTransform cliptransform;
        cliptransform.SetToIdentity();

        // Render directly to the metafile DC in most cases
        hdcToUse = hdcEmf;
        if (fUseBMP)
        {
            // Create a screen-compatible DC for rendering
            hdcBmp = CreateCompatibleDC(hicTargetDev);
            if (hdcBmp)
            {
                // QUINMARK: Need non-memory DC for colors!
                hbmp =  CreateCompatibleBitmap(hicTargetDev, sizeCurrent.cx, sizeCurrent.cy);
                if (hbmp)
                {
                    // Render the metafile into the bitmap    
                    SelectObject(hdcBmp, hbmp);     
            
                    // Render to the bitmap DC, then bitblt the bitmap to the metafile DC.
                    hdcToUse = hdcBmp;
                }
                else
                {
                    DeleteDC(hdcBmp);
                }
            }
        }

        CDispSurface        *pSurface;
        pSurface = new CDispSurface(hdcToUse);
        if(pSurface)
        {
            //
            // Initialize surface. 
            // note: we don't need to clip anything here. 
            //       if we did, we would have to initialize clip rectangle.
            //
            pSurface->PrepareClientSurface(&cliptransform);
            pSurface->SetNeverClip(TRUE); 
    
            CFormDrawInfo DI;
            DI.Init(this, pSurface);
            DI._pSurface = pSurface;
            DI._fIsMetafile = TRUE;     // Do we want this on for fUseBMP?  It does a SetViewportOrg in the Draw...
            DI._fInplacePaint = FALSE;

            DI.CDocScaleInfo::Copy(*pdciTarget);
            DI._hic = XHDC(hicTargetDev, NULL);

            //
            // rectangle in DI should be exactly the bounding rectangle of layout,
            // but positioned at (0,0).
            //
            DI._rc = CRect(sizeCurrent);

            //
            // We don't need to set rcWBounds.
            // Note: I know at least one applet that resets itself if asked to draw with WBounds -- alexmog
            //
            DI._prcWBounds = NULL;

            //
            // Do the actual draw
            // 
            if (_pUnkCtrl && _pVO && !fNoIVODraw)
            {
                //
                // we have an IVO ptr and this control is not in the
                // apphack list of badly implemented IVO::Draw's
                //
                pLayout->Draw(&DI);
            }
            else if ( GetHwnd())
            {
                // We have an HWND but do not support IVO, (or an apphack control)
                // inorder to save we need to do special work.
                SaveMetaFileWithoutIVO( &DI );
            }

            // If we're hacking around a problem by rendering to a BMP, then bitblting to the metafile,
            // now is the time to finish up with the BitBlt.
            if (fUseBMP)
            {
                BitBlt(hdcEmf, 0, 0, sizeCurrent.cx, sizeCurrent.cy,    // dest DC & Rect
                       hdcBmp, 0, 0,                                    // source DC
                       SRCCOPY);                                        // raster mode

                if (hbmp)
                    DeleteObject(hbmp);
                if (hdcBmp)
                    DeleteDC(hdcBmp);        
            }

            //
            // close metafile - this also deallocates hdcEmf
            //
            hemf = CloseEnhMetaFile(hdcEmf);

        }
        delete pSurface;
    }


    if (hicTargetDev)
        DeleteDC(hicTargetDev);

    if (hemf)
    {
        // metafile is ready to use. Release memory, we only need the file.
        DeleteEnhMetaFile(hemf);

        // If it is not a success, proceed to deleting the file.
        if (hr == S_OK)
            return hr;
    }
    else
        hr = E_FAIL;
    
    // We have failed. Delete temp file.
    if (*pchTempFileName)
        DeleteFile(pchTempFileName);

    return hr;
}       


//+----------------------------------------------------------------
//
//  Member : SaveMetaFileWithoutIVO
//
//  Synopsis : Windowed controls that do not implement IViewObject
//      still need to be printed.  Since we cannot simply call
//      Layout()->Draw, we need to be a little more clever here
//      and call SendMessage(WM_PAINT)
//
//  Warning - we still cannot protect a control from being badly authored.
//      the wparam of WM_PAINT is the DC to paint to, if the control 
//      doesn't honor this, they won't print (grid control from office 97 e.g.)
//
//+----------------------------------------------------------------
MtDefine(CDataAry_aryHWND, Locals, "aryHWND")

BOOL CALLBACK enumchildWindowProc ( HWND hwndChild, LPARAM lparam )
{
    CDataAry<HWND>  * paryWindows = (CDataAry<HWND> *)lparam;
    HWND            * pwnd        = paryWindows->Append();

    if (!pwnd)
        return FALSE;  // out of memory

    *pwnd = hwndChild;

    return TRUE;
}

void
COleSite::SaveMetaFileWithoutIVO( CFormDrawInfo *pDI )
{
    Assert(pDI);

    XHDC      hdc    = pDI->GetGlobalDC(!GetMarkupPtr()->IsPrintMedia());
    HDC       rawHDC = hdc.GetOleDC();            // CAUTION: getting raw DC. We must be 
                                                  //          careful with what we do to it.
    POINT     ptViewportOrigin  = g_Zero.pt;
    POINT     ptBrushOriginSave = g_Zero.pt;
    BOOL      fBrushOrgChanged  = GetViewportOrgEx(hdc, &ptViewportOrigin);

    AssertSz(pDI->_fIsMetafile, "Warning! Fx is only safe for Metafile drawing");
    Assert(!pDI->_prcWBounds);
    AssertSz(GetHwnd(), "No window for the control");


    //
    // Prepare the DC to be drawn into. and Save DC - who knows what the control 
    //        will do to the DC?
    //---------------------------------------------------------------------------
    int nSavedDC = ::SaveDC(rawHDC);
    Assert(nSavedDC);

    // Set the brush Origin
    if (fBrushOrgChanged)
    {
        POINT   ptNewBrushOrigin;

        ptNewBrushOrigin.x = (ptViewportOrigin.x + pDI->_rc.left) % 8;
        if( ptNewBrushOrigin.x < 0 )
            ptNewBrushOrigin.x += 8;

        ptNewBrushOrigin.y = (ptViewportOrigin.y + pDI->_rc.top) % 8;
        if( ptNewBrushOrigin.x < 0 )
            ptNewBrushOrigin.y += 8;

        fBrushOrgChanged = SetBrushOrgEx(hdc,
                                         ptNewBrushOrigin.x,
                                         ptNewBrushOrigin.y,
                                         &ptBrushOriginSave );
    }

    // Set the origin of the ViewPort
    ::SetViewportOrgEx(hdc, 0, 0, NULL);


    //
    // Transform the bounds so that we have a rect to draw into:
    //-------------------------------------------------------------------
    // Note - we might need to do more work here, see COleLayout::Draw.
    //      - pDI->_rc is the size in target device coordinates.

    if (   hdc.HasTransform()
        && !pDI->_rc.IsEmpty())
    {
        CRect rcBounds = pDI->_rc;

        // Note: for rotation, ie5.5 only rotates in 90 degree increments
        AssertSz(hdc.transform().GetAngle() % 900 == 0, "Non-trivial rotation in COleSite::SaveMetaFileWithoutIVO");
    
        hdc.transform().Transform(&rcBounds);

        pDI->_rc = rcBounds;
    }


    //
    // Send the paint message to the window:
    //         The lparam of WM_PAINT is not defined. However Office's GridControl
    //         expects it to be the rectangle to draw into.
    //-----------------------------------------------------------------------------

    {
        WPARAM  wParam      = (WPARAM)rawHDC;
        HWND    hwndControl = GetHwnd();
        int     i;
        CDataAry<HWND> aryWindows(Mt(CDataAry_aryHWND));
        HWND  * pwnd        = aryWindows.Append();

        if (!pwnd)
            goto Cleanup;   // out of memory

        *pwnd = hwndControl;

        // this call recursively visits all descendant windows and lets them 
        // add themselves to the array
        ::EnumChildWindows(hwndControl, enumchildWindowProc, (LPARAM)&aryWindows);

        // because we are not drawing in z-order we are getting different results
        // depending on how we process this array.
        for(i =0; i < aryWindows.Size(); i++)
        {
            CRect   rectTemp    = g_Zero.rc;
            LPARAM  lParam      = (LPARAM)&rectTemp;

            // get that child window's rect. some controls from ie5.0 era look for this
            // in the LPARAM eventhough the lparam is undefined for these messages.
            ::GetWindowRect(aryWindows[i], &rectTemp);

            if (::SendMessage(aryWindows[i], WM_PAINT, wParam, lParam))
            {
                // the paint was not handled, so try to get it to invalidate and draw
                if (::RedrawWindow(aryWindows[i], NULL, NULL, RDW_ALLCHILDREN | RDW_INVALIDATE ))
                    ::SendMessage(aryWindows[i], WM_PAINT, wParam, lParam);
            }
        }
    }

Cleanup:
    // Restore DC (this restores viewport and brush origins)
    Verify(::RestoreDC(rawHDC, nSavedDC));
}


HRESULT
COleSite::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr     = S_OK;
    IOleControl *    pControl;

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));
    if(hr)
        goto Cleanup;

    // In theory, we only want to let the ole controller know about this property change
    // if it's an ambient property. However, there are two problems.
    // 1) There is no DISPID_AMBIENT_{FIRST,LAST}, so there's no generic way of telling
    //    whether or not the dispid is for an ambient property.
    // 2) For legacy reasons, we need to fire this with DISPID_UNKNOWN every time. The 
    //    OnAmbientPropertyChange used to be called in COleLayout::OnFormatsChange, which
    //    was in turn called from CMarkup::ClearRunCaches. There is a function on 
    //    CControlledFormatter which is called from CControlledFormatter::Init which 
    //    determines whether or not the caches need to be cleared. CControlledFormatter::Init
    //    is always called from CElement::OnPropertyChange, and the function that tells it whether
    //    or not to recompute formats currently always returns TRUE. 
    //
    //    In other words, this was being called with DISPID_UNKNOWN on every property change, and so
    //    we do that here to maintain compat.

    if (OK(QueryControlInterface(IID_IOleControl, (void **)&pControl)))
    {
        IGNORE_HR(pControl->OnAmbientPropertyChange(DISPID_UNKNOWN));
        pControl->Release();
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\ole\scrpctrl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1997 - 1998.
//
//  File:       scrpctrl.cxx
//
//  History:    19-Jan-1998     sramani     Created
//
//  Contents:   CScriptControl implementation
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SCRPTLET_HXX_
#define X_SCRPTLET_HXX_
#include "scrptlet.hxx"
#endif

#ifndef X_SCRPCTRL_HXX_
#define X_SCRPCTRL_HXX_
#include "scrpctrl.hxx"
#endif

#ifndef X_DOCUMENT_H_
#define X_DOCUMENT_H_
#include <document.h>
#endif

#ifndef X_SCRSBOBJ_HXX_
#define X_SCRSBOBJ_HXX_
#include "scrsbobj.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

MtDefine(CScriptControl, Scriptlet, "CScriptControl")

const CBase::CLASSDESC CScriptControl::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IWBScriptControl,          // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

HRESULT
CScriptControl::PrivateQueryInterface(REFIID iid, LPVOID * ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
    default:
        if (IsEqualIID(iid, IID_IWBScriptControl))
            *ppv = (IWBScriptControl *)this;
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IWBScriptControl

STDMETHODIMP
CScriptControl::raiseEvent(BSTR name, VARIANT eventData)
{
    HRESULT hr;
    IHTMLEventObj *pEventObj = NULL;
    BYTE byParamTypes[3] = {VT_BSTR, VT_VARIANT, 0};
    CDoc * pDoc = _pScriptlet->_pDoc;
    EVENTPARAM param(pDoc, NULL, pDoc->_pWindowPrimary->Markup(), TRUE);

    param.SetType(_T("scriptletevent"));

    // Get the eventObject.
    Assert(pDoc->_pparam);
    CEventObj::Create(&pEventObj, pDoc, NULL, pDoc->_pWindowPrimary->Markup());

    hr = THR(_pScriptlet->FireEventV(1, DISPID_UNKNOWN, pEventObj, NULL, byParamTypes, name, eventData));
    
    ReleaseInterface(pEventObj);
    
    RRETURN(hr);
}

const struct
{
    LPOLESTR    pstrEventName;
    DISPID      dispidEvent;
} mppstreventinfo [] =
{
    { _T("click"),      DISPID_HTMLDOCUMENTEVENTS_ONCLICK },
    { _T("dblclick"),   DISPID_HTMLDOCUMENTEVENTS_ONDBLCLICK },
    { _T("keydown"),    DISPID_HTMLDOCUMENTEVENTS_ONKEYDOWN },
    { _T("keypress"),   DISPID_HTMLDOCUMENTEVENTS_ONKEYPRESS },
    { _T("keyup"),      DISPID_HTMLDOCUMENTEVENTS_ONKEYUP },
    { _T("mousedown"),  DISPID_HTMLDOCUMENTEVENTS_ONMOUSEDOWN },
    { _T("mousemove"),  DISPID_HTMLDOCUMENTEVENTS_ONMOUSEMOVE },
    { _T("mouseup"),    DISPID_HTMLDOCUMENTEVENTS_ONMOUSEUP }
};                   

STDMETHODIMP
CScriptControl::bubbleEvent()
{
    int              i;
    DISPID           dispidEvent;
    BSTR             bstrType;
    IHTMLWindow2    *pHW = NULL;
    IHTMLEventObj   *pEO = NULL;
    CDoc *           pDoc = _pScriptlet->_pDoc;

    // Look at the Window object to see whether it has an event posted.

    pHW = pDoc->_pWindowPrimary;
    pHW->AddRef();
    if (pHW->get_event(&pEO))
        goto Cleanup;
    if (!pEO)
        goto Cleanup;
 
    // They did. Find the flavour of the event and do the appropriate thing:

    if (pEO->get_type(&bstrType))
        goto Cleanup;

    dispidEvent = DISPID_UNKNOWN;
    for (i = 0; i < ARRAY_SIZE(mppstreventinfo); ++i)
    {
        if (!_tcscmp(mppstreventinfo[i].pstrEventName, bstrType))
        {
            dispidEvent = mppstreventinfo[i].dispidEvent;
            break;
        }
    }
    if (dispidEvent == DISPID_UNKNOWN)
        goto Cleanup;

    _pScriptlet->FireEvent(pDoc, NULL, pDoc->_pWindowPrimary->Markup(), dispidEvent, DISPID_UNKNOWN);

Cleanup:
    ReleaseInterface(pHW);
    ReleaseInterface(pEO);
    return S_OK;
}

STDMETHODIMP
CScriptControl::setContextMenu(VARIANT var)
{
    return _pScriptlet->_ScriptletSubObjects.SetContextMenu(var);
}


STDMETHODIMP
CScriptControl::get_selectableContent(VARIANT_BOOL * vbSelectable)
{
    *vbSelectable = _pScriptlet->_vbSelectable;
    return S_OK;
}

STDMETHODIMP
CScriptControl::put_selectableContent(VARIANT_BOOL vbSelectable)
{
    _pScriptlet->_vbSelectable = vbSelectable ? VARIANT_TRUE : VARIANT_FALSE;
    return _pScriptlet->_pDoc->OnAmbientPropertyChange(DISPID_UNKNOWN);
}

STDMETHODIMP
CScriptControl::get_frozen(VARIANT_BOOL * pvbFrozen)
{
    HRESULT hr = S_OK;
    if (!pvbFrozen)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pvbFrozen = _pScriptlet->_cFreezes > 0 ? VARIANT_TRUE : VARIANT_FALSE;

Cleanup:
    return hr;
}

STDMETHODIMP
CScriptControl::get_scrollbar(VARIANT_BOOL * pvbShow)
{
    return _pScriptlet->get_Scrollbar(pvbShow);
}

STDMETHODIMP
CScriptControl::put_scrollbar(VARIANT_BOOL vbShow)
{
    return _pScriptlet->put_Scrollbar(vbShow);
}

STDMETHODIMP
CScriptControl::get_version(BSTR * pbstr)
{
    return (FormsAllocString(_T("5.0 Win32"), pbstr));
}

STDMETHODIMP
CScriptControl::get_visibility(VARIANT_BOOL *pvbVisibility)
{
    if (!pvbVisibility)
        return E_POINTER;
    
    *pvbVisibility = _pScriptlet->_fIsVisible ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}


STDMETHODIMP
CScriptControl::get_onvisibilitychange(VARIANT *pvar)
{
    if (!pvar)
        return E_POINTER;
        
    return VariantCopy(pvar, &_pScriptlet->_varOnVisChange);
}


STDMETHODIMP
CScriptControl::put_onvisibilitychange(VARIANT var)
{
    return VariantCopy(&_pScriptlet->_varOnVisChange, &var);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\ole\scrptlet.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1997 - 1998.
//
//  File:       scriptlet.cxx
//
//  History:    19-Jan-1998     sramani     Created
//
//  Contents:   CScriptlet implementation
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include <mshtmdid.h>
#endif

#ifndef X_SCRPTLET_HXX_
#define X_SCRPTLET_HXX_
#include "scrptlet.hxx"
#endif

#ifndef X_SCRPCTRL_HXX_
#define X_SCRPCTRL_HXX_
#include "scrpctrl.hxx"
#endif

#ifndef X_SCRSBOBJ_HXX_
#define X_SCRSBOBJ_HXX_
#include "scrsbobj.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_EVENTOBJ_H_
#define X_EVENTOBJ_H_
#include "eventobj.h"
#endif

#ifndef X_OBJSAFE_H_
#define X_OBJSAFE_H_
#include "objsafe.h"
#endif

extern class CBaseLockCF g_cfDoc;

#define _cxx_
#include "scrptlet.hdl"

MtDefine(Scriptlet, Mem, "Scriptlet")
MtDefine(CScriptlet, Scriptlet, "CScriptlet")
MtDefine(CScriptlet_aryDR_pv, CScriptlet, "CScriptlet::_aryDR::_pv")
MtDefine(CSortedAtomTable, Scriptlet, "CSortedAtomTable")
MtDefine(CSortedAtomTable_pv, CSortedAtomTable, "CSortedAtomTable::_pv")
MtDefine(CSortedAtomTable_aryIndex_pv, CSortedAtomTable, "CSortedAtomTable::_aryIndex::_pv")

BEGIN_TEAROFF_TABLE(CScriptlet, IOleObject)
    TEAROFF_METHOD(CScriptlet, SetClientSite, setclientsite, (LPOLECLIENTSITE pClientSite))
    TEAROFF_METHOD(CScriptlet, GetClientSite, getclientsite, (LPOLECLIENTSITE FAR* ppClientSite))
    TEAROFF_METHOD(CScriptlet, SetHostNames, sethostnames, (LPCTSTR szContainerApp, LPCTSTR szContainerObj))
    TEAROFF_METHOD(CScriptlet, Close, close, (DWORD dwSaveOption))
    TEAROFF_METHOD(CScriptlet, SetMoniker, setmoniker, (DWORD dwWhichMoniker, LPMONIKER pmk))
    TEAROFF_METHOD(CScriptlet, GetMoniker, getmoniker, (DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk))
    TEAROFF_METHOD(CScriptlet, InitFromData, initfromdata, (LPDATAOBJECT pDataObject, BOOL fCreation, DWORD dwReserved))
    TEAROFF_METHOD(CScriptlet, GetClipboardData, getclipboarddata, (DWORD dwReserved, LPDATAOBJECT * ppDataObject))
    TEAROFF_METHOD(CScriptlet, DoVerb, doverb, (LONG iVerb, LPMSG lpmsg, LPOLECLIENTSITE pActiveSite, LONG lindex, HWND hwndParent, LPCOLERECT lprcPosRect))
    TEAROFF_METHOD(CScriptlet, EnumVerbs, enumverbs, (LPENUMOLEVERB FAR* ppenumOleVerb))
    TEAROFF_METHOD(CScriptlet, Update, update, ())
    TEAROFF_METHOD(CScriptlet, IsUpToDate, isuptodate, ())
    TEAROFF_METHOD(CScriptlet, GetUserClassID, getuserclassid, (CLSID FAR* pClsid))
    TEAROFF_METHOD(CScriptlet, GetUserType, getusertype, (DWORD dwFormOfType, LPTSTR FAR* pszUserType))
    TEAROFF_METHOD(CScriptlet, SetExtent, setextent, (DWORD dwDrawAspect, LPSIZEL lpsizel))
    TEAROFF_METHOD(CScriptlet, GetExtent, getextent, (DWORD dwDrawAspect, LPSIZEL lpsizel))
    TEAROFF_METHOD(CScriptlet, Advise, advise, (IAdviseSink FAR* pAdvSink, DWORD FAR* pdwConnection))
    TEAROFF_METHOD(CScriptlet, Unadvise, unadvise, (DWORD dwConnection))
    TEAROFF_METHOD(CScriptlet, EnumAdvise, enumadvise, (LPENUMSTATDATA FAR* ppenumAdvise))
    TEAROFF_METHOD(CScriptlet, GetMiscStatus, getmiscstatus, (DWORD dwAspect, DWORD FAR* pdwStatus))
    TEAROFF_METHOD(CScriptlet, SetColorScheme, setcolorscheme, (LPLOGPALETTE lpLogpal))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CScriptlet, IOleControl)
    TEAROFF_METHOD(CScriptlet, GetControlInfo, getcontrolinfo, (CONTROLINFO * pCI))
    TEAROFF_METHOD(CScriptlet, OnMnemonic, onmnemonic, (LPMSG pMsg))
    TEAROFF_METHOD(CScriptlet, OnAmbientPropertyChange, onambientpropertychange, (DISPID dispid))
    TEAROFF_METHOD(CScriptlet, FreezeEvents, freezeevents, (BOOL fFreeze))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CScriptlet, IOleInPlaceObject)
    TEAROFF_METHOD(CScriptlet, GetWindow, getwindow, (HWND*))
    TEAROFF_METHOD(CScriptlet, ContextSensitiveHelp, contextsensitivehelp, (BOOL fEnterMode))
    TEAROFF_METHOD(CScriptlet, InPlaceDeactivate, inplacedeactivate, ())
    TEAROFF_METHOD(CScriptlet, UIDeactivate, uideactivate, ())
    TEAROFF_METHOD(CScriptlet, SetObjectRects, setobjectrects, (LPCRECT prcPos, LPCRECT prcClip))
    TEAROFF_METHOD(CScriptlet, ReactivateAndUndo, reactivateandundo, ())
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CScriptlet, IPersistPropertyBag)
    TEAROFF_METHOD(CScriptlet, GetClassID, getclassid, (LPCLSID lpClassID))
    TEAROFF_METHOD(CScriptlet, InitNew, initnew, ())
    TEAROFF_METHOD(CScriptlet, Load, LOAD, (LPPROPERTYBAG pBag, LPERRORLOG pErrLog))
    TEAROFF_METHOD(CScriptlet, Save, SAVE, (LPPROPERTYBAG pBag, BOOL fClearDirty, BOOL fSaveAllProperties))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CScriptlet, IPersistStreamInit)
    TEAROFF_METHOD(CScriptlet, GetClassID, getclassid, (LPCLSID lpClassID))
    TEAROFF_METHOD(CScriptlet, IsDirty, isdirty, ())
    TEAROFF_METHOD(CScriptlet, Load, LOAD, (LPSTREAM pStm))
    TEAROFF_METHOD(CScriptlet, Save, SAVE, (LPSTREAM pStm, BOOL fClearDirty))
    TEAROFF_METHOD(CScriptlet, GetSizeMax, GETSIZEMAX, (ULARGE_INTEGER FAR * pcbSize))
    TEAROFF_METHOD(CScriptlet, InitNew, initnew, ())
END_TEAROFF_TABLE()

/////////////////////////////////////////////////////////////////////////////
// CScriptlet

const CONNECTION_POINT_INFO CScriptlet::s_acpi[] =
{
    CPI_ENTRY(IID_IPropertyNotifySink, DISPID_A_PROPNOTIFYSINK)
    CPI_ENTRY(DIID_DWebBridgeEvents, DISPID_A_EVENTSINK)
    CPI_ENTRY(IID_IDispatch, DISPID_A_EVENTSINK)
    CPI_ENTRY(IID_ITridentEventSink, DISPID_A_EVENTSINK)
    CPI_ENTRY_NULL
};

const CBase::CLASSDESC CScriptlet::s_classdesc =
{
    &CLSID_Scriptlet,               // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    s_acpi,                         // _pcpi
    0,                              // _dwFlags
    &IID_IWebBridge,                // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

//+------------------------------------------------------------------------
//
//  Member:     CreateScriptlet
//
//  Synopsis:   Creates a new scriptlet doc instance.
//
//  Arguments:  pUnkOuter   Outer unknown
//
//-------------------------------------------------------------------------

CBase * STDMETHODCALLTYPE
CreateScriptlet(IUnknown *pUnkOuter)
{
    CBase *pBase;
    pBase = new CScriptlet(pUnkOuter);
    return(pBase);
}

CScriptlet::CScriptlet(IUnknown *pUnkOuter)
    : _aryDR(Mt(CScriptlet_aryDR_pv))
{
    _pUnkOuter  = pUnkOuter ? pUnkOuter : PunkInner();
    VariantInit(&_varOnVisChange);
    _dispidCur = DISPID_VECTOR_BASE;
}

CScriptlet::~CScriptlet()
{
    _cstrUrl.Free();
    VariantClear(&_varOnVisChange);
    _aryDR.DeleteAll();
    _aryDispid.Free();
}

void CScriptlet::Passivate()
{
    ReleaseInterface(_pScriptCtrl);
    ReleaseInterface(_pDescription);

    super::Passivate();

    // (sramani) Trident will rel its propnotify sink when its attr array is destroyed in the destructor thus
    // subrel'ing us, causing the scriptlet to be destroyed.
    // This will also rel the doc host handler associated with this scriptlet!
    ReleaseInterface(_pTrident); 
}

HRESULT
CScriptlet::Init()
{
    HRESULT hr;

    // Create And Aggregate Trident
    hr = THR(g_cfDoc.CreateInstance(_pUnkOuter, IID_IUnknown, (void**)&_pTrident));
    if (hr)
        goto Cleanup;

    hr = _pTrident->QueryInterface(CLSID_HTMLDocument, (void **)&_pDoc);
    if (hr)
        goto Cleanup;

    _pDoc->_fScriptletDoc = TRUE;

    hr = E_OUTOFMEMORY;

    _pScriptCtrl = new CScriptControl(this);
    if (!_pScriptCtrl)
        goto Cleanup;

    // (sramani) The doc holds a ref on to the doc host handler at SetDocHostUI time. This causes a subaddref on us,
    // the corresponding subrelease happening when the doc is destroyed. 
    _pDoc->SetUIHandler((IDocHostUIHandler *)&_ScriptletSubObjects);
    
    hr = ConnectSink(_pTrident, IID_IPropertyNotifySink, (IPropertyNotifySink *)&_ScriptletSubObjects, NULL);
    if (hr)
        goto Cleanup;
    // (sramani) Note:Trident now holds a subAddref on the scriptlet. This will be released when Trident destroys its attr
    // array on the passivate call of the scriptlet.

Cleanup:
    if (hr)
    {
        _pDoc->SetUIHandler(NULL);
        ReleaseInterface(_pScriptCtrl);
        ReleaseInterface(_pTrident);
    }
    return hr;
}

// IOleObject

HRESULT CScriptlet::SetClientSite(IOleClientSite *pClientSite)
{ 
    // (sramani) No need to addref this as the COleSite's clientsite will always outlive the 
    // scriptlet that it contains. This is so because the outer doc's olesite will hold on to the scriptlet.
    _pOCS = pClientSite;

    if (pClientSite)
    {
        CWindow *pWindow;
        HRESULT hr;

        hr = pClientSite->QueryInterface(CLSID_HTMLWindow2, (void **)&pWindow);
        if (!hr)
        {
            Assert(_pDoc->_pWindowPrimary);
            Assert(_pDoc->_pWindowPrimary->Window());
            Assert(!_pDoc->_pWindowPrimary->Window()->_pWindowParent);
            _pDoc->_pWindowPrimary->Window()->_pWindowParent = pWindow;
            _pDoc->_pWindowPrimary->Window()->_pWindowParent->SubAddRef();
        }
    }

    return _pDoc->SetClientSite(pClientSite);
}

HRESULT CScriptlet::DoVerb(LONG iVerb, LPMSG lpmsg, IOleClientSite* pActiveSite, LONG lindex, HWND hwndParent, LPCRECT lprcPosRect)
{
    BOOL fExtentSet = FALSE;

    // (sramani) Need to SetExtent as some container's like VB don't do so b4 inplace activating us.
    if (!_fExtentSet && (iVerb == OLEIVERB_INPLACEACTIVATE))
    {
        SIZEL sizel;
        GetExtent(DVASPECT_CONTENT, &sizel);
        fExtentSet = TRUE;
    }

    HRESULT hr = _pDoc->DoVerb(iVerb, lpmsg, pActiveSite, lindex, hwndParent, lprcPosRect);
    
    if (iVerb == OLEIVERB_INPLACEACTIVATE)
    {
        SIZEL sizeHiMetric;

        // NOTE(sramani): This will break VB as this is the only time this will be
        // called with an lprcPosRect, but we don't care, at least you will have the 
        // default size.
        if (!fExtentSet)
        {
            _sizePixExtent.cx = lprcPosRect->right - lprcPosRect->left;
            _sizePixExtent.cy = lprcPosRect->bottom - lprcPosRect->top;
            _fValidCx = _fValidCy = TRUE;
        }

        sizeHiMetric.cx = HimetricFromHPix(_sizePixExtent.cx);
        sizeHiMetric.cy = HimetricFromVPix(_sizePixExtent.cy);
        hr = SetExtent(DVASPECT_CONTENT, &sizeHiMetric);
        OnVisibilityChange();
    }
    return hr;
}

HRESULT CScriptlet::GetUserClassID(CLSID *pClsid)
{
    *pClsid = *BaseDesc()->_pclsid;
    return S_OK;
}

HRESULT CScriptlet::GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType)
{
    return OleRegGetUserType(*BaseDesc()->_pclsid, dwFormOfType, pszUserType);
}

HRESULT CScriptlet::SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    HRESULT     hr;
    IHTMLStyle *pStyle = NULL;

    _sizePixExtent.cx = HPixFromHimetric(psizel->cx);
    _sizePixExtent.cy = VPixFromHimetric(psizel->cy);
    _fValidCx = _fValidCy = TRUE;
    _fExtentSet = TRUE;

    hr = _pDoc->SetExtent(dwDrawAspect, psizel);
    if (hr)
	    goto Cleanup;

    hr = GetStyleProperty(&pStyle);
    if (hr)
        goto Cleanup;

    if (pStyle)
    {
        pStyle->put_pixelWidth(_sizePixExtent.cx);
        pStyle->put_pixelHeight(_sizePixExtent.cy);
    }

Cleanup:
    ReleaseInterface(pStyle);
    return hr;
}

HRESULT CScriptlet::GetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    if (!_fValidCx)
    {
        _sizePixExtent.cx = WEBBRIDGE_DEFAULT_WIDTH;
        _fValidCx = TRUE;
    }

    if (!_fValidCy)
    {
        _sizePixExtent.cy = WEBBRIDGE_DEFAULT_HEIGHT;
        _fValidCy = TRUE;
    }

    psizel->cx = HimetricFromHPix(_sizePixExtent.cx);
    psizel->cy = HimetricFromVPix(_sizePixExtent.cy);

    // (sramani) Need to SetExtent as some container's like VB don't do so b4 inplace activating us.
    if (!_fExtentSet)
    {
        _fExtentSet = TRUE;
        _pDoc->SetExtent(DVASPECT_CONTENT, psizel);
    }

    return S_OK;
}

// IOleControl

HRESULT CScriptlet::FreezeEvents(BOOL fFreeze)
{
    if (fFreeze)
        ++_cFreezes;
    else
        --_cFreezes;

    Assert(_cFreezes >= 0);
    if (!_cFreezes && _fDelayOnReadyStateFiring)
    {
        FireEvent(_pDoc, NULL, _pDoc->_pWindowPrimary->Markup(), DISPID_READYSTATECHANGE, DISPID_UNKNOWN, _T("readystatechange"));
        _fDelayOnReadyStateFiring = FALSE;
    }

    return _pDoc->FreezeEvents(fFreeze);
}

// IOleInPlaceObject

HRESULT CScriptlet::InPlaceDeactivate()
{
    HRESULT hr;
    hr = _pDoc->InPlaceDeactivate();
    OnVisibilityChange();
    return hr;
}

HRESULT CScriptlet::SetObjectRects(LPCOLERECT prcPos, LPCOLERECT prcClip)
{
    HRESULT hr;
    hr = _pDoc->SetObjectRects(prcPos, prcClip);
    OnVisibilityChange();
    return hr;
}

// Scriptlet helpers

HRESULT
CScriptlet::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, _pUnkOuter)
        QI_TEAROFF(this, IWebBridge, _pUnkOuter)
        QI_TEAROFF(this, IOleObject, _pUnkOuter)
        QI_TEAROFF(this, IOleControl, _pUnkOuter)
        QI_TEAROFF(this, IOleInPlaceObject, _pUnkOuter)
        QI_TEAROFF(this, IPersistStreamInit, _pUnkOuter)
        QI_TEAROFF(this, IPersistPropertyBag, _pUnkOuter)
        QI_TEAROFF((CBase *)this, IProvideMultipleClassInfo, _pUnkOuter)
        QI_TEAROFF2((CBase *)this, IProvideClassInfo, IProvideMultipleClassInfo, _pUnkOuter)
        QI_TEAROFF2((CBase *)this, IProvideClassInfo2, IProvideMultipleClassInfo, _pUnkOuter)
        QI_CASE(IConnectionPointContainer)
        {
            *((IConnectionPointContainer **)ppv) =
                    new CConnectionPointContainer(this, NULL);

            if (!*ppv)
                RRETURN(E_OUTOFMEMORY);
            break;
        }

        QI_FALLTHRU(IPersistMoniker, IHTMLDocument)
        QI_FALLTHRU(IViewObject, IHTMLDocument)
        QI_FALLTHRU(IViewObjectEx, IHTMLDocument)
        QI_FALLTHRU(IViewObject2, IHTMLDocument)
        QI_FALLTHRU(IOleInPlaceActiveObject, IHTMLDocument)
        QI_FALLTHRU(IOleInPlaceObjectWindowless, IHTMLDocument)
        QI_FALLTHRU(IOleWindow, IHTMLDocument)
        QI_FALLTHRU(IQuickActivate, IHTMLDocument)
        QI_FALLTHRU(IOleCommandTarget, IHTMLDocument)
        QI_FALLTHRU(IObjectSafety, IHTMLDocument)
        QI_FALLTHRU(IOleContainer, IHTMLDocument)
        QI_FALLTHRU(IDataObject, IHTMLDocument)
        QI_CASE(IHTMLDocument)
            // (sramani): This is equivalent to calling _pTrident->QI, but faster!
            RRETURN(_pDoc->PrivateQueryInterface(iid, ppv));

    default:
        return E_NOINTERFACE;
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}

// IDispatchEx over-rides

STDMETHODIMP 
CScriptlet::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT                 hr;
    long                    lIndex;
    DispidRecord            dr;
    BSTR                    bstrCopy = NULL;
    CStr                    cstrName;

    // Check to see if the Names are implemented directly by the Scriptlet. If so, intercept them
    // immediately.

    hr = CBase::GetInternalDispID(bstrName, pid, grfdex);
    if (!hr)
        goto Cleanup;

    // Assume failure.
    *pid = DISPID_UNKNOWN;
    hr = DISP_E_UNKNOWNNAME;

    if (_pDoc->PrimaryMarkup()->GetReadyState() < READYSTATE_COMPLETE || !bstrName)
        goto Cleanup;

    if (!StrCmpNIC(_T("get_"), bstrName, 4) ||
        !StrCmpNIC(_T("put_"), bstrName, 4) ||
        !StrCmpNIC(_T("event_"), bstrName, 6))    // NOTE (sramani) : why shud this last check be there?
        goto Cleanup;

    // See if we've found this particular name before. 
    if (_aryDispid.Find(bstrName, pid, !!(grfdex & fdexNameCaseSensitive)))
    {
        *pid += DISPID_VECTOR_BASE;
        hr = S_OK;
        goto Cleanup;
    }

    // If these are NULL, there is no public_description object,
    // so we need to look for public_ prefixes.
    if (!_pDescription)
    {
        hr = cstrName.Set(_T("public_get_"));
        if (hr)
            goto Cleanup;
        hr = cstrName.Append(bstrName);
        if (hr)
            goto Cleanup;
        hr = cstrName.AllocBSTR(&bstrCopy);
        if (hr)
            goto Cleanup;

        hr = _pDoc->_pWindowPrimary->GetDispID(bstrCopy, grfdex & ~fdexNameEnsure, &dr.dispid_get);
        if (hr)
            dr.dispid_get = DISPID_UNKNOWN;

        bstrCopy[7] = _T('p');
        bstrCopy[8] = _T('u');
        hr = _pDoc->_pWindowPrimary->GetDispID(bstrCopy, grfdex & ~fdexNameEnsure, &dr.dispid_put);
        if (hr)
            dr.dispid_put = DISPID_UNKNOWN;

        // If neither a get or put method exists for this name, look for a bare name

        if (dr.dispid_get == DISPID_UNKNOWN &&
            dr.dispid_put == DISPID_UNKNOWN)
        {
            hr = cstrName.Set(_T("public_"));
            if (hr)
                goto Cleanup;
            hr = cstrName.Append(bstrName);
            if (hr)
                goto Cleanup;
            FormsFreeString(bstrCopy);
            hr = cstrName.AllocBSTR(&bstrCopy);
            if (hr)
                goto Cleanup;

            hr = _pDoc->_pWindowPrimary->GetDispID(bstrCopy, grfdex & ~fdexNameEnsure, &dr.dispidBare);
            if (hr)
                goto Cleanup;
        }
        else
            dr.dispidBare = DISPID_UNKNOWN;
    }
    else
    {
        hr = cstrName.Set(_T("get_"));
        if (hr)
            goto Cleanup;
        hr = cstrName.Append(bstrName);
        if (hr)
            goto Cleanup;
        hr = cstrName.AllocBSTR(&bstrCopy);
        if (hr)
            goto Cleanup;

        Assert(_pDescription);
        hr = _pDescription->GetIDsOfNames(IID_NULL, &bstrCopy, 1, LOCALE_USER_DEFAULT, &dr.dispid_get);
        if (hr)
            dr.dispid_get = DISPID_UNKNOWN;

        bstrCopy[0] = _T('p');
        bstrCopy[1] = _T('u');

        hr = _pDescription->GetIDsOfNames(IID_NULL, &bstrCopy, 1, LOCALE_USER_DEFAULT, &dr.dispid_put);
        if (hr)
            dr.dispid_put = DISPID_UNKNOWN;

        // If neither a get or put method exists for this name, look for a bare name

        if (dr.dispid_get == DISPID_UNKNOWN &&
            dr.dispid_put == DISPID_UNKNOWN)
        {
            hr = _pDescription->GetIDsOfNames(IID_NULL, &bstrName, 1, LOCALE_USER_DEFAULT, &dr.dispidBare);
            if (hr)
                goto Cleanup;
        }
        else
            dr.dispidBare = DISPID_UNKNOWN;
    }

    // Otherwise, we got a keeper! 
    hr = _aryDR.AppendIndirect(&dr);
    if (hr)
        goto Cleanup;

    hr = _aryDispid.Insert(bstrName, *pid, &lIndex);
    if (hr)
    {
        _aryDR.Delete(_aryDR.Size() - 1);
        goto Cleanup;
    }

    Assert(lIndex == _aryDR.Size() - 1);

    _dispidCur = lIndex + DISPID_VECTOR_BASE + 1;
    Assert(_dispidCur < 0x7FFFFFF);
    *pid = lIndex + DISPID_VECTOR_BASE;

Cleanup:
    cstrName.Free();
    FormsFreeString(bstrCopy);
    return hr;
}

STDMETHODIMP
CScriptlet::InvokeEx(DISPID dispid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, IServiceProvider *pSrvProvider)
{
    HRESULT         hr;
    DispidRecord *  pDR;
    DISPPARAMS      dispparams;

    // (sramani) CScriptlet's own DISPIDs have first priority.

    if ((0 <= dispid && dispid < DISPID_VECTOR_BASE) ||
        dispid == DISPID_ABOUTBOX ||
        dispid == DISPID_IHTMLWINDOW2_EVENT)
    {
        return CBase::InvokeEx(dispid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, pSrvProvider);
    }

    if (PassThruDISPID(dispid))
        return _pDoc->_pWindowPrimary->Document()->InvokeEx(dispid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, pSrvProvider);

    if (dispid < 0)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    if (dispid < _dispidCur)
    {
        pDR = _aryDR + (dispid - DISPID_VECTOR_BASE);

        // Check how they want to call this thing.

        if (wFlags & DISPATCH_PROPERTYGET)
        {
            // try function property get 
            Assert((wFlags & (DISPATCH_PROPERTYPUT|DISPATCH_PROPERTYPUTREF)) == 0);
            dispid = pDR->dispid_get;
            if (dispid == DISPID_UNKNOWN)
                dispid = pDR->dispidBare;               // could be member property get
            else
                wFlags = DISPATCH_METHOD;               // calling a get_XXX method.
        }
        else if (wFlags & (DISPATCH_PROPERTYPUT|DISPATCH_PROPERTYPUTREF))
        {
            // try function property put 
            dispid = pDR->dispid_put;
            if (dispid == DISPID_UNKNOWN)
                dispid = pDR->dispidBare;               // could be member property put
            else
            {
                wFlags = DISPATCH_METHOD;               // calling a put_XXX method.
                // (sramani) Nuke the named parameters!. This is reqd. as the original call
                // came in as a propput and the script engine passes a named param for it. but
                // the actual invoke is really a method call. The script engine will fail the
                // invoke if we dont do this as it will be unable to find a named param for
                // public_put_foo, as it thinks it really belongs to foo (which is how it was
                // called from script)
                dispparams = *pdispparams;
                dispparams.cNamedArgs = 0;
                pdispparams = &dispparams;
            }
        }
        else
        {
            // try method call
            dispid = pDR->dispidBare;
        }

        if (dispid == DISPID_UNKNOWN)
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }
         
        if (_pDescription)
        {
            hr = _pDescription->Invoke(dispid,  IID_NULL,  lcid,  wFlags,  pdispparams,  pvarResult,  pexcepinfo,  NULL);
        }
        else
        {
            hr = _pDoc->_pWindowPrimary->InvokeEx(dispid,  lcid,  wFlags,  pdispparams,  pvarResult,  pexcepinfo,  pSrvProvider);
        }
    }
    else
        hr = DISP_E_MEMBERNOTFOUND;

Cleanup:
    return hr;
}

BOOL
CScriptlet::PassThruDISPID(DISPID dispid)
{
    switch (dispid)
    {
        case    DISPID_SECURITYDOMAIN:
        case    DISPID_SECURITYCTX:
        case    DISPID_READYSTATE:
            return TRUE;

        default:
            return FALSE;
    }
}

BOOL
CScriptlet::InDesignMode()
{
    HRESULT    hr;
    VARIANT    var;
    IDispatch *pDispOCS = NULL;

    if (!_pOCS)
        return FALSE;

    hr = _pOCS->QueryInterface(IID_IDispatch, (void **)&pDispOCS);
    if (hr)
        return FALSE;

    hr = Property_get(pDispOCS, DISPID_AMBIENT_USERMODE, &var);

    ReleaseInterface(pDispOCS);
    return (hr == S_OK && var.vt == VT_BOOL && var.boolVal == VARIANT_FALSE);
}


// IWebBridge properties and methods //////////////////////////////////

STDMETHODIMP CScriptlet::get_URL(BSTR * pVal)
{
    return FormsAllocString(_pDoc->GetPrimaryUrl(), pVal);
}

STDMETHODIMP CScriptlet::put_URL(BSTR newVal)
{
    HRESULT hr;

    // We only expose this as a write property at design time.
    if (!InDesignMode() || _fHardWiredURL)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    _fRequiresSave = 1;
    hr = LoadScriptletURL(newVal);

Cleanup:
    return hr;
}

STDMETHODIMP
CScriptlet::get_Scrollbar(VARIANT_BOOL *pfShow)
{
    *pfShow = _vbScrollbar;
    return S_OK;
}

STDMETHODIMP
CScriptlet::put_Scrollbar(VARIANT_BOOL fShow)
{
    _vbScrollbar = fShow ? VARIANT_TRUE : VARIANT_FALSE;
    return _pDoc->OnAmbientPropertyChange(DISPID_UNKNOWN);
}

STDMETHODIMP
CScriptlet::get_embed(VARIANT_BOOL * pfEmbedded)
{
    // 'embed' is a design-time only property.
    if (!InDesignMode())
        return DISP_E_MEMBERNOTFOUND;

    *pfEmbedded = _vbEmbedded;
    return S_OK;
}

STDMETHODIMP
CScriptlet::put_embed(VARIANT_BOOL fEmbed)
{
    if (!InDesignMode())
        return DISP_E_MEMBERNOTFOUND;

    _vbEmbedded = fEmbed ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

STDMETHODIMP
CScriptlet::get_readyState(long * pReadyState)
{
    *pReadyState = _pDoc->PrimaryMarkup()->GetReadyState();
    return S_OK;
}

STDMETHODIMP
CScriptlet::get_event(IDispatch **ppEvent)
{
    HRESULT          hr = S_OK;
    IHTMLWindow2    *pHW = NULL;
    IHTMLEventObj   *pEO = NULL;

    *ppEvent = NULL;

    pHW = _pDoc->_pWindowPrimary;
    pHW->AddRef();
    if (hr)
        goto Cleanup;

    hr = pHW->get_event(&pEO);
    if (hr)
        goto Cleanup;

    if (pEO)
    {
        *ppEvent = pEO;
        (*ppEvent)->AddRef();
    }

Cleanup:
    ReleaseInterface(pHW);
    ReleaseInterface(pEO);
    return hr;
}

STDMETHODIMP
CScriptlet::AboutBox()
{
    HRESULT hr;
    HWND    hwnd;
    RECT    rcPos;
    RECT    rcClip;
    OLEINPLACEFRAMEINFO oipfi;
    IOleInPlaceSite *pOIPS = NULL;
    IOleInPlaceFrame *pFrame = NULL;
    IOleInPlaceUIWindow *pDoc = NULL;

    // We only expose this as a method at design time.
    if (!InDesignMode())
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    hr = _pOCS->QueryInterface(IID_IOleInPlaceSite, (void **) &pOIPS);
    if (hr)
        goto Cleanup;

    hr = pOIPS->GetWindowContext(&pFrame, &pDoc, &rcPos, &rcClip, &oipfi);
    if (hr)
        goto Cleanup;

    hr = pFrame->GetWindow(&hwnd);
    if (hr)
        goto Cleanup;
    
    pFrame->EnableModeless(FALSE);
    MessageBoxA(hwnd, "Copyright (C) 1997 Microsoft\r\nhttp://www.microsoft.com", "Scriptlet Component", MB_OK);
    pFrame->EnableModeless(TRUE);

Cleanup:
    ReleaseInterface(pOIPS);
    ReleaseInterface(pFrame);
    ReleaseInterface(pDoc);
    return hr;
}

HRESULT CScriptlet::LoadScriptletURL(TCHAR *pchUrl)
{
    CStr cstrBlank;
    CWindow *pCWindow = NULL;

    if (_fHardWiredURL && !pchUrl)
        pchUrl = _cstrUrl;
        
    if (!pchUrl || !_pOCS)
        return E_POINTER;

    if (!*pchUrl || UnescapeAndTruncateUrl(pchUrl) != S_OK)
    {
        cstrBlank.Set(_T("about:blank"));
        pchUrl = cstrBlank;
    }

    // Do a local machine access check.  Can't do much if there is no window
    // parent.  For IE, there should always be one.
    pCWindow = _pDoc->_pWindowPrimary->Window()->_pWindowParent;
    if (pCWindow)
    {
        if (!COmWindowProxy::CanNavigateToUrlWithLocalMachineCheck(pCWindow->Markup(), NULL, pchUrl))
        {
            cstrBlank.Set(_T("about:blank"));
            pchUrl = cstrBlank;
        }
    }
    else
    {
        // The site doesn't have a window.
        Assert(_pOCS->QueryInterface(CLSID_HTMLWindow2, (void **)&pCWindow));
    }

    HRESULT hr;
    IMoniker           *pMoniker = NULL;
    IServiceProvider   *pSP = NULL;
    IBindHost          *pBH = NULL;

    // Try getting the IBindHost service first.

    hr = _pOCS->QueryInterface(IID_IServiceProvider, (void **)&pSP);
    if (!hr)
    {
        hr = pSP->QueryService(SID_IBindHost, IID_IBindHost, (void **)&pBH);
        if (!hr)
        {
            hr = pBH->CreateMoniker(pchUrl, NULL, &pMoniker, 0);
        }
    }

    // If we failed to create the moniker that way, make  an absolute moniker.

    if (!pMoniker)
    {
        hr = CreateURLMoniker(NULL, pchUrl, &pMoniker);
    }

    if (!hr)
    {
        hr = _pDoc->Load(FALSE, pMoniker, NULL, 0);
    }

    ReleaseInterface(pMoniker);
    ReleaseInterface(pBH);
    ReleaseInterface(pSP);
    return hr;
}

HRESULT CScriptlet::GetStyleProperty(IHTMLStyle **ppHTMLStyle)
{
    HRESULT                 hr;
    VARIANT                 varArg1;
    VARIANT                 varArg2;
    IHTMLElementCollection *pHEC = NULL;
    IHTMLElementCollection *pHEC2 = NULL;
    IDispatch              *pDispHtmlElement = NULL;
    IDispatch              *pDispCollection = NULL;

    *ppHTMLStyle = NULL;
    
    {
        hr = _pDoc->_pWindowPrimary->Document()->get_all(&pHEC);
        if (hr)
            goto Cleanup;

        varArg1.vt = VT_BSTR;
        hr = FormsAllocString(_T("HTML"), &varArg1.bstrVal);
        if (hr)
            goto Cleanup;

        hr = pHEC->tags(varArg1, &pDispCollection);
        if (hr)
            goto Cleanup;

        hr = pDispCollection->QueryInterface(IID_IHTMLElementCollection, (void **)&pHEC2);
        if (hr)
            goto Cleanup;

        VariantClear(&varArg1);
        varArg1.vt = VT_I4;
        varArg1.lVal = 0;
        varArg2.vt = VT_ERROR;
        hr = pHEC2->item(varArg1, varArg2, &pDispHtmlElement);
        if (hr)
            goto Cleanup;

        if (pDispHtmlElement)
        {
            hr = pDispHtmlElement->QueryInterface(IID_IHTMLElement, (void **)&_pHTMLElement);
            if (hr)
                goto Cleanup;
        }
        else
            goto Cleanup;
    }

    Assert(_pHTMLElement);
    hr = _pHTMLElement->get_style(ppHTMLStyle);

    ClearInterface(&_pHTMLElement);

Cleanup:
    ReleaseInterface(pHEC);
    ReleaseInterface(pHEC2);
    ReleaseInterface(pDispHtmlElement);
    ReleaseInterface(pDispCollection);
    return hr;
}

HRESULT CScriptlet::Resize()
{
    HRESULT                 hr = E_FAIL;
    RECT                    rcPos;
    RECT                    rcClip;
    OLEINPLACEFRAMEINFO     oipfi;
    IOleInPlaceSite        *pOIPS = NULL;
    IOleInPlaceFrame       *pOIPF = NULL;
    IOleInPlaceUIWindow    *pOIPUIW = NULL;

    if (!_pOCS)
        goto Cleanup;

    if (_pDoc->State() >= OS_INPLACE)
    {
        hr = _pOCS->QueryInterface(IID_IOleInPlaceSite, (void **)&pOIPS);
        if (hr)
            goto Cleanup;

        hr = pOIPS->GetWindowContext(&pOIPF, &pOIPUIW, &rcPos, &rcClip, &oipfi);
        if (hr)
            goto Cleanup;

        rcPos.right = rcPos.left + _sizePixExtent.cx;
        rcPos.bottom = rcPos.top + _sizePixExtent.cy;

        hr = pOIPS->OnPosRectChange(&rcPos);
    }
    else
        hr = _pOCS->RequestNewObjectLayout();

Cleanup:
    ReleaseInterface(pOIPS);
    ReleaseInterface(pOIPF);
    ReleaseInterface(pOIPUIW);
    return hr;
}

void CScriptlet::OnReadyStateChange()
{
    HRESULT hr;
    BSTR bstrName = NULL;
    IHTMLStyle *pStyle = NULL;

    if (_pDoc->PrimaryMarkup()->GetReadyState() == READYSTATE_COMPLETE)
    {
        // Discover if script name space contains the "public_description" object.
        DISPID dispidED;
        VARIANT v;

        if (THR(FormsAllocString(EXTERNAL_DESCRIPTION, &bstrName)))
            goto Cleanup;

        hr = THR(_pDoc->_pWindowPrimary->GetDispID(bstrName, fdexFromGetIdsOfNames, &dispidED));
        if (!hr)
        {
            Assert(dispidED != DISPID_UNKNOWN);
            DISPPARAMS dispparams = { NULL, NULL, 0, 0 };

            hr = _pDoc->_pWindowPrimary->InvokeEx(dispidED, LOCALE_USER_DEFAULT,
                              DISPATCH_METHOD|DISPATCH_PROPERTYGET, &dispparams, &v, NULL, NULL);
            if (!hr && v.vt == VT_DISPATCH)
            {
                _pDescription = v.pdispVal;
            }
        }
    }
    else if (_pDoc->PrimaryMarkup()->GetReadyState() == READYSTATE_INTERACTIVE)
    {
        // Need to recache the HTML element if doc gets blown away;
        ClearInterface(&_pHTMLElement);
        if (_fValidCx || _fValidCy)
        {
            hr = THR(GetStyleProperty(&pStyle));
            if (hr)
                goto Cleanup;
            if (!pStyle)
                goto Cleanup;
            if (_fValidCx)
                pStyle->put_pixelWidth(_sizePixExtent.cx);
            if (_fValidCy)
                pStyle->put_pixelHeight(_sizePixExtent.cy);
        }
    }

Cleanup:
    ReleaseInterface(pStyle);
    FormsFreeString(bstrName);

    // Fire the event on the ole site (<OBJECT>) and whoever else might be listening, if the
    // container is ready to handle events
    if (!_cFreezes)
        FireEvent(_pDoc, NULL, _pDoc->_pWindowPrimary->Markup(), DISPID_READYSTATECHANGE, DISPID_UNKNOWN, _T("readystatechange"));
    else
        _fDelayOnReadyStateFiring = TRUE;

    return;
}

void CScriptlet::SetWidth(DISPID dispid)
{
    long cpixels;
    IHTMLStyle *pStyle = NULL;

    if (GetStyleProperty(&pStyle))
        goto Cleanup;
    if (!pStyle)
        goto Cleanup;
    if (!pStyle->get_pixelWidth(&cpixels))
    {
        if (!_fValidCx || cpixels != _sizePixExtent.cx)
        {
            // HACK to avoid infinite scale factor error, if current size is 0
            if (_fValidCx && !_sizePixExtent.cx)
            {
                SIZEL sizel;
                if (!_sizePixExtent.cy)
                    _sizePixExtent.cy = 1;
                sizel.cx = HimetricFromHPix(cpixels);
                sizel.cy = HimetricFromVPix(_sizePixExtent.cy);
                _pDoc->SetExtent(DVASPECT_CONTENT, &sizel);
            }

            _sizePixExtent.cx = cpixels;
            _fValidCx = TRUE;
            Resize();
        }

        FireOnChanged(dispid);
    }

Cleanup:
    ReleaseInterface(pStyle);
    return;
}

void CScriptlet::SetHeight(DISPID dispid)
{
    long cpixels;
    IHTMLStyle *pStyle = NULL;
    
    if (GetStyleProperty(&pStyle))
        goto Cleanup;
    if (!pStyle)
        goto Cleanup;
    if (!pStyle->get_pixelHeight(&cpixels))
    {
        if (!_fValidCy || cpixels != _sizePixExtent.cy)
        {
            // HACK to avoid infinite scale factor error, if current size is 0
            if (_fValidCy && !_sizePixExtent.cy)
            {
                SIZEL sizel;
                if (!_sizePixExtent.cx)
                    _sizePixExtent.cx = 1;
                sizel.cx = HimetricFromHPix(_sizePixExtent.cx);
                sizel.cy = HimetricFromVPix(cpixels);
                _pDoc->SetExtent(DVASPECT_CONTENT, &sizel);
            }

            _sizePixExtent.cy = cpixels;
            _fValidCy = TRUE;
            Resize();
        }

        FireOnChanged(dispid);
    }

Cleanup:
    ReleaseInterface(pStyle);
    return;
}

void CScriptlet::OnVisibilityChange()
{
    RECT                    rcPos;
    RECT                    rcClip;
    OLEINPLACEFRAMEINFO     oipfi;
    IOleInPlaceSite        *pOIPS = NULL;
    IOleInPlaceFrame       *pOIPF = NULL;
    IOleInPlaceUIWindow    *pOIPUIW = NULL;
    IDispatchEx            *pDispEx = NULL;
    BOOL                    fNewVisible = _fIsVisible;
    HRESULT                 hr;
    
    if (_pDoc->State() < OS_INPLACE)
    {
        fNewVisible = FALSE;
        // NOTE: (anandra) Not quite correct.  Will do the right thing
        // in design mode in trident/vb because it's not inplace-active
        // but not quite correct because it might be visible. IE4 bug 59988.
    }
    else if (_pOCS)
    {
        hr = _pOCS->QueryInterface(
                IID_IOleInPlaceSite, 
                (void **) &pOIPS);
        if (hr)
            goto Cleanup;
            
        hr = pOIPS->GetWindowContext(
                &pOIPF,
                &pOIPUIW,
                &rcPos,
                &rcClip,
                &oipfi);
        if (hr)
            goto Cleanup;

        fNewVisible = IntersectRect(&rcPos, &rcPos, &rcClip) != 0;
    }

Cleanup:
    if ((unsigned)fNewVisible != _fIsVisible)
    {
        _fIsVisible = (unsigned)fNewVisible;
        
        if (V_VT(&_varOnVisChange) == VT_DISPATCH)
        {
            DISPPARAMS  dp = { 0 };

            if (SUCCEEDED(V_DISPATCH(&_varOnVisChange)->QueryInterface(
                    IID_IDispatchEx, (void **)&pDispEx)))
            {
                hr = pDispEx->InvokeEx(
                        DISPID_VALUE,
                        LOCALE_USER_DEFAULT,
                        DISPATCH_METHOD,
                        &dp,
                        NULL,
                        NULL,
                        NULL);
            }
            else
            {
                hr = V_DISPATCH(&_varOnVisChange)->Invoke(
                    DISPID_VALUE, 
                    IID_NULL,  
                    LOCALE_USER_DEFAULT,
                    DISPATCH_METHOD,  
                    &dp,  
                    NULL,  
                    NULL,  
                    NULL);
            }
        }
    }

    ReleaseInterface(pOIPS);
    ReleaseInterface(pOIPF);
    ReleaseInterface(pOIPUIW);
    ReleaseInterface(pDispEx);
}

HRESULT
Property_get(IDispatch * pDisp, DISPID dispid, VARIANT * pvar)
{
    DISPPARAMS dispparams = { NULL, NULL, 0, 0 };

    return pDisp->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD|DISPATCH_PROPERTYGET,
                         &dispparams, pvar, NULL, NULL);
}

// IPersistPropertyBag

STDMETHODIMP CScriptlet::GetClassID(CLSID *pClassID)
{
    *pClassID = *BaseDesc()->_pclsid;
    return S_OK;
}

STDMETHODIMP CScriptlet::InitNew()
{
    HRESULT hr; 

    if (_fHardWiredURL)
    {
        hr = LoadScriptletURL();
    }
    else
    {
        hr = _pDoc->InitNew();
    }
    
    return hr;
}

STDMETHODIMP CScriptlet::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    HRESULT hr;
    VARIANT var;
    TCHAR *pchUrl = NULL;
    
    VariantInit(&var);
    hr = THR(pPropBag->Read(_T("Scrollbar"), &var, pErrorLog));
    if (!hr && !VariantChangeType(&var, &var, 0, VT_BOOL))
        _vbScrollbar = var.boolVal;
    VariantClear(&var);

    if (!_fHardWiredURL)
    {
        hr = THR(pPropBag->Read(_T("URL"), &var, pErrorLog));
        if (hr == E_INVALIDARG)
        {
            // No URL property was saved in the property bag. We force the update
            // of the scrollbar and go home.

            hr = THR(_pDoc->InitNew());
            if (hr)
                goto Cleanup;

            _pDoc->OnAmbientPropertyChange(DISPID_UNKNOWN);
            hr = S_OK;
            goto Cleanup;
        }

        if (hr)
            goto Cleanup;

        hr = THR(VariantChangeType(&var, &var, 0, VT_BSTR));
        if (hr)
            goto Cleanup;

        pchUrl = var.bstrVal;
    }

    // Force Trident to update its UI
    _pDoc->OnAmbientPropertyChange(DISPID_UNKNOWN);

    hr = THR(LoadScriptletURL(pchUrl));

Cleanup:
    VariantClear(&var);
    RRETURN(hr);  
}

STDMETHODIMP CScriptlet::Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT hr;
    VARIANT var;

    var.vt = VT_BOOL;
    var.boolVal = _vbScrollbar;
    hr = pPropBag->Write(_T("Scrollbar"), &var);
    if (hr)
        goto Cleanup;

    if (!_fHardWiredURL)
    {
        var.vt = VT_BSTR;
        hr = THR(FormsAllocString(_pDoc->GetPrimaryUrl(), &var.bstrVal));
        if (hr)
            goto Cleanup;

        hr = THR(pPropBag->Write(_T("URL"), &var));
        if (hr)
            goto Cleanup;
    }

    if (fClearDirty)
        _fRequiresSave = 0;

Cleanup:
    VariantClear(&var);
    RRETURN(hr); 
}

// IPersistStreamInit

STDMETHODIMP CScriptlet::IsDirty(void)
{
    if (_fRequiresSave)
        return S_OK;
    else
        return _pDoc->IsDirty();
}

STDMETHODIMP CScriptlet::Load(LPSTREAM pStm)
{
    HRESULT hr;
    CStr cstrUrl;

    hr = THR(pStm->Read(&_vbScrollbar, sizeof(_vbScrollbar), NULL));
    if (hr)
        goto Cleanup;

    if (!_fHardWiredURL)
    {
        hr = THR(cstrUrl.Load(pStm));
        if (hr)
            goto Cleanup;
    }

    _pDoc->OnAmbientPropertyChange(DISPID_UNKNOWN);
    hr = THR(LoadScriptletURL(cstrUrl));

Cleanup:
    RRETURN(hr);
}

STDMETHODIMP CScriptlet::Save(LPSTREAM pStm, BOOL fClearDirty)
{
    HRESULT hr;

    if (fClearDirty)
        _fRequiresSave = 0;

    hr = THR(pStm->Write(&_vbScrollbar, sizeof(_vbScrollbar), NULL));
    if (hr)
        goto Cleanup;

    if (!_fHardWiredURL)
    {
        CStr cstrUrl;
        
        hr = cstrUrl.Set(_pDoc->GetPrimaryUrl());
        if (hr)
            goto Cleanup;

        hr = cstrUrl.Save(pStm);
    }

Cleanup:
    RRETURN(hr);
}

BOOL CSortedAtomTable::Find(LPCTSTR pch, LONG *plIndex, BOOL fCaseSensitive)
{
    int r;
    long iLow  = 0;
    long iMid  = 0;
    long iHigh = Size() - 1;
    STRINGCOMPAREFN pfnCompareString = fCaseSensitive ? StrCmpC : StrCmpIC;
    long lIndex;
    TCHAR *pchCur;

    // Binary search for atom name
    while (iHigh >= iLow)
    {
        iMid = (iHigh + iLow) >> 1;
        lIndex = (long)_aryIndex[iMid];
        pchCur = (LPTSTR)(*(CStr *)Deref(sizeof(CStr), lIndex));
        r = pfnCompareString(pch, pchCur);
        if (r < 0)
        {
            iHigh = iMid - 1;
        }
        else if (r > 0)
        {
            iLow = iMid + 1;
        }
        else
        {
            *plIndex = lIndex;
            return TRUE;
        }
    }

    *plIndex = iHigh + 1;
    return FALSE;
}

HRESULT
CSortedAtomTable::Insert(LPCTSTR pch, LONG lInsertAt, LONG *plIndex)
{
    HRESULT hr = S_OK;
    WORD    wIndex;
    long    lIndex;
    CStr    cstrCopy;
    CStr   *pcstr;

    // Not found, so add atom(name) to end of array, so that the lIndex given out
    // is always the same (this could be a dispid that needs to be the same.
    hr = THR(AppendIndirect(&cstrCopy));
    if (hr)
        goto Cleanup;

    lIndex = Size() - 1;
    pcstr = (CStr *)Deref(sizeof(CStr), lIndex);
    hr = THR(pcstr->Set(pch));
    if (hr)
    {
        Delete(lIndex);
        goto Cleanup;
    }

    wIndex = (WORD)lIndex;

    // Insert the index of the new atom so that the sort order is maintained.
    hr = _aryIndex.InsertIndirect(lInsertAt, &wIndex);
    if (hr)
    {
        Delete(lIndex);
        goto Cleanup;
    }

    if (plIndex)
        *plIndex = lIndex;

Cleanup:
    RRETURN(hr);
}

void
CSortedAtomTable::Free()
{
    CStr *pcstr;
    long  i;
    
    for (i = 0; i < Size(); i++)
    {
        pcstr = (CStr *)Deref(sizeof(CStr), i);
        pcstr->Free();
    }

    _aryIndex.DeleteAll();
    DeleteAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\ole\safety.cxx ===
//+------------------------------------------------------------------------
//
//  File:       SAFETY.CXX
//
//  Contents:   Test safety options for embedded objects.
//
//  Notes:      Contains functions to determine safety of scripting and
//              initialization operations for embedded objects.
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COMCAT_H_
#define X_COMCAT_H_
#include "comcat.h"
#endif

#ifndef X_OBJSAFE_H_
#define X_OBJSAFE_H_
#include "objsafe.h"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_SAFETY_HXX_
#define X_SAFETY_HXX_
#include "safety.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_CLSTAB_HXX_
#define X_CLSTAB_HXX_
#include "clstab.hxx"
#endif

DeclareTag(tagObjectSafety, "OleSite", "Object safety information");

EXTERN_C const CLSID CLSID_AppletOCX;
HRESULT GetSIDOfDispatch(IDispatch *pDisp, BYTE *pbSID, DWORD *pcbSID, BOOL *pfDomainExist = NULL);
HRESULT GetCategoryManager(ICatInformation **ppCat);


//+-------------------------------------------------------------------------
//
//  Function:   DeinitCategoryInfo
//
//  Synopsis:   Clear out the thread local cached component category mgr.
//
//--------------------------------------------------------------------------

void 
DeinitCategoryInfo(THREADSTATE *pts)
{
    Assert(pts);
    ClearInterface(&pts->pCatInfo);
}


//+-------------------------------------------------------------------------
//
//  Function:   GetCategoryManager
//
//  Synopsis:   Retrieve thread local cached component category mgr.
//              or create a new one and put it in there if not. 
//
//--------------------------------------------------------------------------

HRESULT
GetCategoryManager(ICatInformation **ppCat)
{
    HRESULT hr = S_OK;

    Assert(GetThreadState());
    
    if (!TLS(pCatInfo))
    {
        ICatInformation *   pCatInfo = NULL;
        
        hr = THR(CoCreateInstance(
                CLSID_StdComponentCategoriesMgr, 
                NULL, 
                CLSCTX_INPROC_SERVER, 
                IID_ICatInformation, 
                (void **) &pCatInfo));
        if (hr) // couldn't get the category manager--
            goto Cleanup;

        Assert(pCatInfo);
        TLS(pCatInfo) = pCatInfo;   // Take over the ref of pCatInfo
    }

    *ppCat = TLS(pCatInfo);

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     COleSite::AccessAllowed
//
// Synopsis:    Return TRUE if it's ok to access the object model
//              of the dispatch passed in.
//
//---------------------------------------------------------------

BOOL
COleSite::AccessAllowed(IDispatch *pDisp)
{
    BOOL            fAllowed = FALSE;
    BOOL            fDomainChanged = FALSE;
    BYTE            abSID[MAX_SIZE_SECURITY_ID];
    DWORD           cbSID = ARRAY_SIZE(abSID);
    
    if (OK(THR_NOTRACE(GetSIDOfDispatch(pDisp, abSID, &cbSID, &fDomainChanged))))
    {
        COmWindowProxy *    pProxy;

        pProxy = GetWindowedMarkupContext()->Window();

        fAllowed = cbSID == pProxy->_cbSID &&
                    !memcmp(abSID, pProxy->_pbSID, cbSID) && fDomainChanged == (BOOL)pProxy->_fDomainChanged;
    }
    else
    {
        //[kusumav]When this function is called by COleSite, if the control doesn't not support DISPID_SECURITYCTX 
        //we will allow access since the control is not placing any access restrictions. But in the case where 
        //the object supports this DISPID_SECURITYCTX but some call after this fails here (eg: object returned 
        //a value that could not be converted into a SID blob or we could not generate a blob bcos of memory failure,
        //we need to communicate back so that we don't allow access to the control by default. We do this by
        //setting the size to Zero, since all callers pass in the correct buffer size (MAX_SIZE_SECURITY_ID) initially
        fAllowed = (cbSID != 0);
    }
    
    return fAllowed;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::IsSafeToScript, COleSite::IsSafeToInitialize, 
//
//  Returns:    BOOL      TRUE if operation is safe, otherwise FALSE.
//
//----------------------------------------------------------------------------

BOOL
COleSite::IsSafeToScript()
{
    BOOL    fSafe = FALSE;    

    INSTANTCLASSINFO * pici;
    
    if (_fKnowSafeToScript)
    {
        fSafe = !!_fSafeToScript;
    }
    else
    {
        HRESULT hr;

        _fKnowSafeToScript = TRUE;
        // (KTam): We may not be in a markup yet (e.g.
        // if we were created via createElement -- script.js does this)
        // What then?  Default to primary markup.
        CMarkup *pMU = GetMarkupPtr();
        if ( !pMU )
            pMU = Doc()->PrimaryMarkup();

        Assert( pMU );

        if (OlesiteTag() == OSTAG_APPLET)
        {
            //
            // If we're an applet, determine if we're even allowed
            // to script to them.
            //
            hr = THR(pMU->ProcessURLAction(
                    URLACTION_SCRIPT_JAVA_USE,
                    &fSafe));
            //
            // We don't want to prompt about activex controls so go to Cleanup directly
            // If we had failed we would return unsafe anyway
            //
            _fSafeToScript = !!fSafe;
            goto Cleanup;
        }

        hr = THR(pMU->ProcessURLAction(
                URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY, 
                &fSafe));
        if (hr)
            goto Cleanup;

        if (fSafe)
        {
            _fSafeToScript = !!fSafe;
            goto Cleanup;
        }
        
        else
        {
            pici = GetInstantClassInfo();

            if (pici)
            {
                if (_fViewLinkedWebOC)
                    fSafe = TRUE;
                else
                    fSafe = IsSafeTo(
                                SAFETY_SCRIPT, 
                                IID_IDispatch, 
                                pici->clsid, 
                                _pUnkCtrl, 
                                pMU);
            }
            else
            {
                fSafe = FALSE;
            }
        }

        _fSafeToScript = !!fSafe;

        if (!fSafe)
        {
            NotifyHaveProtectedUserFromUnsafeContent(GetMarkup(), IDS_PROTECTEDFROMUNSAFEOCX);
        }
    }
    
Cleanup:
    return fSafe;
}    


BOOL
COleSite::IsSafeToInitialize(REFIID riid)
{
    BOOL    fSafe;
    HRESULT hr;
    CDoc *  pDoc = Doc();
    INSTANTCLASSINFO * pici;

#ifdef NO_SECURITY
    return TRUE;
#else

    // (KTam): We may not be in a markup yet (e.g.
    // if we were created via createElement -- script.js does this)
    // What then?  Default to primary markup.
    CMarkup *pMU = GetMarkupPtr();
    if ( !pMU )
        pMU = pDoc->PrimaryMarkup();

    Assert( pMU );
    
    hr = THR(pMU->ProcessURLAction(
            URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY, 
            &fSafe));
    if (hr)
        goto Cleanup;

    if (!fSafe)
    {
        pici = GetInstantClassInfo();

        if (pici)
        {
            fSafe = IsSafeTo(
                        SAFETY_INIT, 
                        riid, 
                        pici->clsid, 
                        _pUnkCtrl, 
                        pMU);
        }
    }

    if (!fSafe)
    {
        NotifyHaveProtectedUserFromUnsafeContent(GetMarkup(), IDS_PROTECTEDFROMOCXINIT);
    }
    
Cleanup:
    return fSafe;

#endif // NO_SECURITY
}


//+---------------------------------------------------------------------------
//
//  Synopsis:   Brings up the unsafe content protection dialog.
//
//----------------------------------------------------------------------------

void 
NotifyHaveProtectedUserFromUnsafeContent(CMarkup *pMarkup, UINT uResId)
{
    if (pMarkup)
    {
        CDoc * pDoc = pMarkup->Doc();

        if (!pMarkup->_fSafetyInformed && 
            !(pDoc->_dwLoadf & DLCTL_SILENT) &&
            pDoc->_pInPlace &&
            pDoc->_pInPlace->_hwnd)
        {
            CDoc::CLock Lock(pDoc);

            pMarkup->_fSafetyInformed = TRUE;
            IGNORE_HR(pDoc->ShowMessage(NULL, MB_OK | MB_ICONWARNING, 0, uResId));
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Synopsis:   Verifies safety for a particular action (on a particular 
//              interface).
//
//  Arguments:  sOperation:     The operation being validated for safety.
//              riid:           The interface this operation will use.
//
//  Returns:    BOOL            TRUE if operation is safe, otherwise FALSE.
//
//----------------------------------------------------------------------------

BOOL 
IsSafeTo(
    SAFETYOPERATION sOperation, 
    REFIID          riid, 
    CLSID           clsid, 
    IUnknown *      pUnk, 
    CMarkup *       pMarkup)       // if NULL, we don't confirm with user
{
    BOOL    fSafe = FALSE;
    HRESULT hr = E_FAIL;
    DWORD   dwCompat = 0;
    DWORD   dwMisc;
    CATID   catid = GUID_NULL;  // category of safety
    DWORD   dwXSetMask = 0; // options to set
    DWORD   dwXOptions = 0; // options to make safe for
                            // (either INTERFACESAFE_FOR_UNTRUSTED_CALLER or
                            // INTERFACESAFE_FOR_UNTRUSTED_DATA)

#if defined(WINCE) || defined(UNIX)
	// Temp overide any security on CE 
	return TRUE;
#else

    IObjectSafety *     posafe = NULL;
    ICatInformation *   pCatInfo = NULL;

    // Only these three operations are handled here. That's why we
    // can get away with not initializing catid.
    AssertSz(sOperation==SAFETY_INIT ||
             sOperation==SAFETY_SCRIPT ||
             sOperation==SAFETY_SCRIPTENGINE, "Illegal operation param to IsSafeTo.");

    switch (sOperation)
    {
    case SAFETY_INIT:
        catid = CATID_SafeForInitializing;
        dwXSetMask = INTERFACESAFE_FOR_UNTRUSTED_DATA;
        dwXOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
        break;

    case SAFETY_SCRIPT:
        catid = CATID_SafeForScripting;
        dwXSetMask = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
        dwXOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
        break;
        
    case SAFETY_SCRIPTENGINE:
        catid = GUID_NULL;  // Registry check is not sufficient for script engines
        dwXOptions = dwXSetMask =   INTERFACESAFE_FOR_UNTRUSTED_DATA
                                  | INTERFACE_USES_DISPEX 
                                  | INTERFACE_USES_SECURITY_MANAGER;
    }

    // 
    // Check compat flags first.  If no object safety is allowed, go 
    // straight to confirm because we don't believe what this control
    // says about it's safety.  Effectively the control is lying to us,
    // or implemented IObjectSafety incorrectly.
    //

    hr = THR(CompatFlagsFromClsid(clsid, &dwCompat, &dwMisc));
    if (!OK(hr))
        goto Cleanup;

    if (dwCompat & COMPAT_EVIL_DONT_LOAD)
    {
        Assert (!fSafe);
        goto Cleanup;
    }
        
    if (dwCompat & COMPAT_NO_OBJECTSAFETY)
        goto Confirm;
        
    hr = pUnk->QueryInterface(IID_IObjectSafety, (void **) &posafe);

    // If IObjectSafety is supported, ask the object to make itself safe
    if (posafe)
    {
        //
        // If we're trying to make it safe to script, ask object
        // if it knows about dispex2 & sec mgr.  If not, then bail out
        // if it's a script engine, continue otherwise.
        //

        if (sOperation == SAFETY_SCRIPTENGINE)
        {
            DWORD   dwMask = 0;
            DWORD   dwEnabled;
            
            hr = THR(posafe->GetInterfaceSafetyOptions(
                    riid,
                    &dwMask,
                    &dwEnabled));
            if (hr || !(dwMask & INTERFACE_USES_DISPEX))
                goto Cleanup;
        }

        //
        // If we're going for safe for scripting, try making the object
        // safe on IDispatchEx first, then drop to IDispatch.
        //

        hr = E_FAIL;
        if (sOperation == SAFETY_SCRIPT)
        {
            DWORD dwMask = 0;
            DWORD dwEnabled;

            // use security manager for controls if supported
            hr = THR(posafe->GetInterfaceSafetyOptions(
                    IID_IDispatchEx,
                    &dwMask,
                    &dwEnabled));

            if(OK(hr) && (dwMask & INTERFACE_USES_SECURITY_MANAGER)) {
                hr = THR(posafe->
                    SetInterfaceSafetyOptions(IID_IDispatchEx, 
                            dwXSetMask | INTERFACE_USES_SECURITY_MANAGER, 
                            dwXOptions | INTERFACE_USES_SECURITY_MANAGER));
            } 
            else
            {
                hr = THR(posafe->
                    SetInterfaceSafetyOptions(IID_IDispatchEx, dwXSetMask, dwXOptions));
            }
        }
        if (!OK(hr))
        {
            hr = THR(posafe->
                    SetInterfaceSafetyOptions(riid, dwXSetMask, dwXOptions));
        }
        
        if (!OK(hr))
        {
            // Give user an opportunity to override.
            goto Confirm;
        }

        // Don't check registry if object supports IObjectSafety.
        goto EnsureSafeForScripting;
    }

    // otherwise looking in the registry to see if the object
    // belongs to the appropriate component category

    hr = THR(GetCategoryManager(&pCatInfo));
    if (hr)
        goto Cleanup;
        
    CATID rgcatid[1];
    rgcatid[0] = catid;

    // Ask if the object belongs to the specified category
    hr = THR(pCatInfo->IsClassOfCategories(clsid, 1, rgcatid, 0, NULL));
    if (hr)
        goto Confirm;

    // Object is safe on this interface!

EnsureSafeForScripting:

    //
    // Though object appears to be safe, we still need to
    // see if scripting to objects is allowed at all.
    //

    if (sOperation == SAFETY_SCRIPT && pMarkup)
    {
        hr = pMarkup->ProcessURLAction(URLACTION_SCRIPT_SAFE_ACTIVEX,&fSafe);

        if (FAILED(hr))
        {
            fSafe = FALSE;
        }
    }
    else
    {
        fSafe = TRUE;
    }

    goto Cleanup;

Cleanup:
#if DBG==1
    if (!fSafe)
        TraceTag((tagObjectSafety, "Safety check failed!!"));
#endif

    ReleaseInterface(posafe);
    return fSafe;

Confirm:
    if (pMarkup)
    {
        hr = pMarkup->ProcessURLAction(URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY,&fSafe);

        if (FAILED(hr))
        {
            fSafe = FALSE;
        }
    }

    goto Cleanup;

#endif // WINCE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\print\putil.cxx ===
//+--------------------------------------------------------------------------
//
//  File:       print.cxx
//
//  Contents:   Print/PageSetup dialog helpers
//
//---------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_PUTIL_HXX
#define X_PUTIL_HXX
#include "putil.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_MSRATING_HXX_
#define X_MSRATING_HXX_
#include "msrating.hxx" // areratingsenabled()
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_ELINK_HXX_
#define X_ELINK_HXX_
#include "elink.hxx"    // GetAlternatePrintDoc()
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_HTC_HXX_
#define X_HTC_HXX_
#include "htc.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include <intl.hxx>
#endif

#ifndef X_HTMLDLG_HXX
#define X_HTMLDLG_HXX
#include "htmldlg.hxx"
#endif

DeclareTag(tagPrintBackground, "Print", "Print background")
DeclareTag(tagPrintKeepTempfiles, "Print", "Don't delete temporary files")
MtDefine(GetNextToken_ppchOut, Printing, "GetNextToken *ppchOut")
MtDefine(CIPrintCollection, Printing, "CIPrintCollection")
MtDefine(CIPrintCollection_aryIPrint_pv, CIPrintCollection, "CIPrintCollection::_aryIPrint::_pv")

static int GetNextToken(const TCHAR *pchIn, TCHAR **ppchOut);
static HRESULT ReadURLFromFile(TCHAR *pchFileName, TCHAR **ppchURL);

// helpers for the string manipulation stuff in PrintHTML

static const TCHAR g_achURLDelimiter[] = TEXT("");
static const TCHAR g_achURLPrefix[]    = TEXT("url:");
static const UINT  g_uiURLPrefixLen    = sizeof(g_achURLPrefix) - 1;

BOOL g_fFoundOutIfATMIsInstalled;
BOOL g_fATMIsInstalled;
extern BOOL g_fInHtmlHelp;

#define _cxx_
#include "print.hdl"

static const DRIVERPRINTMODE s_aPrintDriverPrintModes[] =
{ { _T("WinFax")               , PRINTMODE_NO_TRANSPARENCY },
  { _T("OLFAXDRV")             , PRINTMODE_NO_TRANSPARENCY },
  { _T("NEC  SuperScript 860") , PRINTMODE_NO_TRANSPARENCY },
  { _T("NEC  SuperScript 1260"), PRINTMODE_NO_TRANSPARENCY }
};


// the following must match the order of PrintEnum
const TCHAR *s_aachPrintType[] =
{
    _T("PageSetup"),        // PRINTTYPE_PAGESETUP
    _T("Preview"),          // PRINTTYPE_PREVIEW
    _T("Prompt"),           // PRINTTYPE_PRINT
    _T("NoPrompt"),         // PRINTTYPE_NOPROMPT
};

//
// NOTE(SujalP + OliverSe): This code is safe in a multithreaded environment because in the
// worst case multiple threads will end up calling GetPrivateProfileStringA, but they will
// all drive the same information -- either it is installed or not.
//
static void
FindIfATMIsInstalled()
{
    if (!g_fFoundOutIfATMIsInstalled)
    {
        if (!g_fUnicodePlatform)
        {
            char szReturned[2];
            GetPrivateProfileStringA("Boot",
                                     "atm.system.drv",
                                     "*",
                                     szReturned,
                                     sizeof(szReturned),
                                     "system.ini"
                                    );
            g_fATMIsInstalled = szReturned[0] != '*';
        }
        else
        {
            g_fATMIsInstalled = FALSE;
        }
        g_fFoundOutIfATMIsInstalled = TRUE;
    }
}


BOOL
IsATMInstalled()
{
    FindIfATMIsInstalled();
    return g_fATMIsInstalled;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::PaintBackground
//
//  Synopsis:   Returns whether printing of backgrounds is on or off.
//
//----------------------------------------------------------------------------
BOOL CMarkup::PaintBackground()
{
    return (
#if DBG == 1
                IsTagEnabled(tagPrintBackground) ||             // Lets us force printing of backgrounds
#endif // DBG == 1
                Doc()->_pOptionSettings->fPrintBackground       // Should we always print backgrounds?
        ||      !IsPrintMedia() );                              // Are we printing?
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::DontRunScripts
//
//  Synopsis:   Returns FALSE for CDoc's and TRUE for CPrintDoc's that were
//              are marked not to run scripts because they were saved out to
//              tempfiles.
//
//----------------------------------------------------------------------------
BOOL CMarkup::DontRunScripts()
{
    // The general rule is to disallow scripts in print media.
    // 10/20/2000 (greglett)  ...And there are now no exceptions.
    return IsPrintMedia();
}


//+---------------------------------------------------------------------
//
//   Helper : CopyPrintHandles
//
//   Synopsis :
//
//   NOTE (greglett)  Most Win9x *W() API's that use the DEVMODE structure
//   use a DEVMODEA.  Under Win9x, we'll assume a DEVMODEA.  The plumbing
//   in NT is correct, so expect a DEVMODEW.
//
//   Parameters:    [in]  HGLOBAL hSrcDevNames
//                  [in]  HGLOBAL hSrcDevMode
//                  [out] HGLOBAL *phDstDevNames
//                  [out] HGLOBAL *phDstDevMode
//
//+---------------------------------------------------------------------
HRESULT CopyPrintHandles(HGLOBAL hSrcDevNames, HGLOBAL hSrcDevMode, HGLOBAL *phDstDevNames, HGLOBAL *phDstDevMode)
{
    HRESULT     hr      = S_OK;
    DEVNAMES  * pDNSrc  = NULL;
    DEVNAMES  * pDNDst  = NULL;
    void      * pDMSrc  = NULL;
    void      * pDMDst  = NULL;
    WORD        nSize;

    Assert(phDstDevNames);
    Assert(phDstDevMode);
    *phDstDevNames = NULL;
    *phDstDevMode  = NULL;

    if (!hSrcDevNames || !hSrcDevMode)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pDNSrc = (DEVNAMES *)::GlobalLock(hSrcDevNames);
    pDMSrc = ::GlobalLock(hSrcDevMode);

    if (!pDMSrc || !pDNSrc)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Net structure size is: BaseSize + (DriverStrLen + DeviceStrLen + OutputStrLen) * sizeof(TCHAR)
    // String offsets are in TCHARs, not bytes.
    nSize = sizeof(DEVNAMES)
          + ( _tcslen( ((TCHAR *)pDNSrc) + pDNSrc->wDriverOffset)
            + _tcslen( ((TCHAR *)pDNSrc) + pDNSrc->wDeviceOffset)
            + _tcslen( ((TCHAR *)pDNSrc) + pDNSrc->wOutputOffset)
            + 3 ) * sizeof(TCHAR);

    *phDstDevNames = ::GlobalAlloc(GHND, nSize);
    if (!*phDstDevNames)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pDNDst = (DEVNAMES *)::GlobalLock(*phDstDevNames);
    if (!pDNDst)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    ::CopyMemory(pDNDst, pDNSrc, nSize);
    ::GlobalUnlock(*phDstDevNames);


    if (g_fUnicodePlatform)
        nSize = ((DEVMODEW *)pDMSrc)->dmSize + ((DEVMODEW *)pDMSrc)->dmDriverExtra;
    else
        nSize = ((DEVMODEA *)pDMSrc)->dmSize + ((DEVMODEA *)pDMSrc)->dmDriverExtra;

    // Global alloc some new space for our copy
    *phDstDevMode = ::GlobalAlloc(GHND, nSize);
    if (!*phDstDevMode)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pDMDst = ::GlobalLock(*phDstDevMode);
    if (!pDMDst)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    ::CopyMemory(pDMDst, pDMSrc, nSize);
    ::GlobalUnlock(*phDstDevMode);

Cleanup:
    if (pDNSrc)
        ::GlobalUnlock(hSrcDevNames);
    if (pDMSrc)
        ::GlobalUnlock(hSrcDevMode);

    if (hr != S_OK)
    {
        // Abandon ship!  Free any objects we may have allocated.
        if (*phDstDevNames)
        {
            ::GlobalFree(*phDstDevNames);
            *phDstDevNames = NULL;
        }
        if (*phDstDevMode)
        {
            ::GlobalFree(*phDstDevMode);
            *phDstDevMode = NULL;
        }
    }

    return hr;
}

HRESULT
CDocExtra::ReplacePrintHandles(HGLOBAL hDN, HGLOBAL hDM)
{
    HRESULT hr;
    HGLOBAL hDNOut = NULL;
    HGLOBAL hDMOut = NULL;

    // We have been passed a DEVNAMES/DEVMODE pair.
    // Copy it into our own
    hr = CopyPrintHandles(hDN, hDM, &hDNOut, &hDMOut);
    if (hr == S_OK)
    {
        // Print handles successfully copied.  Overwrite input arguments.
        if (_hDevNames)
            ::GlobalFree(_hDevNames);
        if (_hDevMode)
            ::GlobalFree(_hDevMode);

        _hDevNames = hDNOut;
        _hDevMode  = hDMOut;
    }

    return hr;
}

//+---------------------------------------------------------------------
//
//   Helper : ProcessHeaderFooterArray, Static
//
//   Synopsis : helper method for PrintHandler, this is essentially copied
//      from the Old CDoc::DoPrint code, and is responsible for parsing out
//      the contents of the SafeArray varArg that came into IDM_PRINT.  IN
//      template printing, we pull these out into another bundle of parameters
//      (based on expandos on the eventObject) and this is passed as the
//      varargin do the DHUI handler.  The DHUI handler then pulls them off
//      the eventObject and builds another safearray of a lot of things to be
//      used in the template. whew. lots of copies of copies.
//
//      Read print parameters
//      1. header string
//      2. footer string
//      3. Outlook Express header document IStream *
//      4. alternate URL string (used for MHTML in OE)
//      5. dwFlags to be ORed in
//      6. print template string
//      7. DEVNAMES (always W)
//      8. DEVMODE (DEVMODEA on Win9x, DEVMODEW on NT)
//
//----------------------------------------------------------------------
HRESULT ParseHeaderFooterArray(SAFEARRAY * psaHeaderFooter,
                               BSTR      * pbstrHeader,
                               BSTR      * pbstrFooter,
                               IStream  ** ppStream,
                               BSTR      * pbstrAlternate,
                               DWORD     * pdwFlags,
                               BSTR      * pbstrTemplate,
                               CDoc      * pDoc)
{
    HRESULT hr = S_OK;
    long    lArg;
    VARIANT var;

    // check parameters
    if (   !psaHeaderFooter
        || SafeArrayGetDim(psaHeaderFooter) != 1
        || psaHeaderFooter->rgsabound[0].cElements < 2
        || psaHeaderFooter->rgsabound[0].cElements == 7     // DEVNAMES and DEVMODE are a pair
        || psaHeaderFooter->rgsabound[0].cElements > 8)
    {
        return E_INVALIDARG;
    }

    Assert(pbstrHeader);
    Assert(pbstrFooter);
    Assert(ppStream);
    Assert(pbstrAlternate);
    Assert(pdwFlags);
    Assert(pbstrTemplate);
    Assert(pDoc);

    // initialize helper variables
    VariantInit(&var);

    // Obtain the header and footer
    for (lArg = 0; lArg < 2; ++lArg)
    {
        hr = SafeArrayGetElement(psaHeaderFooter, &lArg, &var);
        if (hr == S_OK)
        {
            hr = VariantChangeType(&var, &var, NULL, VT_BSTR);
            if (hr == S_OK && V_BSTR(&var))
            {
                if (lArg == 0)
                {
                    // transfer ownership
                    *pbstrHeader = V_BSTR(&var);
                }
                else
                {
                    // transfer ownership
                    *pbstrFooter = V_BSTR(&var);
                }

            }
        }

        VariantInit(&var);  //don't clear
    }

    // Obtain OE Header stream.
    if (psaHeaderFooter->rgsabound[0].cElements > 2)
    {
        lArg = 2;

        hr = SafeArrayGetElement(psaHeaderFooter, &lArg, &var);
        if (   hr == S_OK
            && V_VT(&var) == VT_UNKNOWN
            && V_UNKNOWN(&var))
        {
            // transfer Ownership
            *ppStream = (IStream *)V_UNKNOWN(&var);
        }

        VariantInit(&var);  // don't clear
    }

    // Obtain OE MHTML Url.
    if (psaHeaderFooter->rgsabound[0].cElements > 3)
    {
        lArg = 3;

        hr = SafeArrayGetElement(psaHeaderFooter, &lArg, &var);
        if (   hr == S_OK
            && V_VT(&var) == VT_BSTR
            && V_BSTR(&var)
            && SysStringLen(V_BSTR(&var)))
        {
            *pbstrAlternate = V_BSTR(&var);
        }

        VariantInit(&var); // don't clear
    }

    // Obtain dwFlags and OR them in.
    if (psaHeaderFooter->rgsabound[0].cElements > 4)
    {
        lArg = 4;

        hr = SafeArrayGetElement(psaHeaderFooter, &lArg, &var);
        if (   hr == S_OK
            && V_VT(&var) == VT_I4
            && V_I4(&var) != 0)
        {
            *pdwFlags |= ((DWORD) V_I4(&var));
        }

        VariantInit(&var); // don't clear
    }

    // Obtain print template string
    if (psaHeaderFooter->rgsabound[0].cElements > 5)
    {
        lArg = 5;

        hr = SafeArrayGetElement(psaHeaderFooter, &lArg, &var);
        if (   hr == S_OK
            && V_VT(&var) == VT_BSTR
            && V_BSTR(&var)
            && SysStringLen(V_BSTR(&var)))
        {
            *pbstrTemplate = V_BSTR(&var);
        }

        VariantInit(&var); // don't clear
    }

    // Hosts may pass us a DEVNAMES, DEVMODE pair with which to seed the template.
    if (psaHeaderFooter->rgsabound[0].cElements > 7)
    {
        HGLOBAL hDN = NULL;
        HGLOBAL hDM = NULL;

        lArg = 6;
        hr = SafeArrayGetElement(psaHeaderFooter, &lArg, &var);
        if (    hr != S_OK
            &&  V_VT(&var) == VT_PTR
            &&  V_BYREF(&var) )
        {
            hDN = V_BYREF(&var);
        }
        VariantInit(&var);

        lArg++;

        hr = SafeArrayGetElement(psaHeaderFooter, &lArg, &var);
        if (    hr != S_OK
            &&  V_VT(&var) == VT_PTR
            &&  V_BYREF(&var) )
        {
            hDM = V_BYREF(&var);
        }
        VariantInit(&var);

        pDoc->ReplacePrintHandles(hDN,hDM);
    }

    return hr;
}



//--------------------------------------------------------------------
// FirePrintEvents
//
// This function recursively walks the frames collection of the target markup,
// and fires the OnBefore/OnAfterPrint events and sets/removes expandos important
// to the print template.  These expandos are then persisted to the temp file
// and used by the print template.
//
// Expandos set:
//      __IE_DisplayURL     The "real" (as opposed to the temp file's) URL
//      __IE_ActiveFrame    Set documents with the current element in a subframe -
//                          this is the index into the frames collection of the active
//--------------------------------------------------------------------
BOOL
FirePrintEvents(CMarkup * pMarkup, CElement * pElementCurrent, BOOL fBeforePrint)
{
    BOOL        fActiveFrame    = FALSE;
    BOOL        fExpando = pMarkup->_fExpando;
    CVariant    cvarProp;
    CElement   *pHtmlElem;
    COmWindowProxy *pWindow = pMarkup->Window();

    if (!pMarkup)
        goto Cleanup;

    // Fire our OnBeforePrint, if we are in an before print.
    if (pWindow && fBeforePrint)
        pWindow->Fire_onbeforeprint();

    pMarkup->_fExpando = TRUE;

    pHtmlElem = pMarkup->GetHtmlElement();

    {
        long cFrames;

        // Walk our frames collection, recalling this on children.
        pMarkup->EnsureCollectionCache(CMarkup::FRAMES_COLLECTION);
        cFrames = pMarkup->CollectionCache()->SizeAry(CMarkup::FRAMES_COLLECTION);

        if (cFrames > 0)
        {
            CElement *pFrame;
            long i;

            for (i=0; i<cFrames; i++)
            {
                pMarkup->CollectionCache()->GetIntoAry(CMarkup::FRAMES_COLLECTION, i, &pFrame);

                if (    pFrame
                    &&  pFrame->HasSlavePtr()   )
                {
                    if (FirePrintEvents(pFrame->GetSlavePtr()->GetMarkup(), pElementCurrent, fBeforePrint))
                    {
                        fActiveFrame = TRUE;
                        if (pHtmlElem)
                        {
                            if (fBeforePrint)
                            {
                                V_VT(&cvarProp) = VT_INT;
                                V_INT(&cvarProp) = i;
                                pHtmlElem->PrimitiveSetExpando(_T("__IE_ActiveFrame"), cvarProp);
                            }
                            else
                            {
                                V_VT(&cvarProp) = VT_BOOL;
                                pHtmlElem->PrimitiveRemoveExpando(_T("__IE_ActiveFrame"));
                            }
                            cvarProp.Clear();
                        }
                    }
                }
            }
        }
    }

    pMarkup->_fExpando = fExpando;

    // AppHack (greglett) (108234)
    // HtmlHelp does something in the onafterprint event which results in a ProgressChange.
    // They then use this ProgressChange to do something that may result in a print.
    // Thus, multiple print dialogs appear until they crash.
    // This hack delays the onafterprint event for HtmlHelp until the template is closing.
    // If we rearchitect to remove this plumbing problem (events fired always, immediately),
    // then we should remove this hack.
    if (pWindow && !(fBeforePrint || g_fInHtmlHelp))
        pWindow->Fire_onafterprint();

    if ( !fActiveFrame &&  pElementCurrent )
        fActiveFrame = (pMarkup == pElementCurrent->GetMarkup());

Cleanup:
    return fActiveFrame;
}

//--------------------------------------------------------------------
//
//  Member : SaveToTempFile
//
//  Synopsis : Helper function, this is used both by CDoc::DoPrint
//      and by execCommand::IDM_PRINTPREVIEW
//      As a save, this function always sets _fSaveTempfileForPrinting
//      to true.
//
//--------------------------------------------------------------------
HRESULT
CDoc::SaveToTempFile(CDocument *pContextDoc,    // IN
                     LPTSTR pchTempFile,        // OUT
                     LPTSTR pchSelTempFile,     // OUT
                     DWORD dwFlags)
{
    HRESULT   hr = S_OK;
    CMarkup  *pMarkup = pContextDoc->Markup();

    Assert(pMarkup);

    BOOL      fSelection = pchSelTempFile && HasTextSelection();
    CODEPAGE  codepage = pMarkup->GetCodePage();

    Assert(pchTempFile);
    Assert(!HasTextSelection() || pchSelTempFile);

#if DBG == 1 
    // (gschneid) This hack has been moved out to fromkrnl.cxx it is needed globally now.
    // Let it here to Assert that we have the same behavior as before.
    //
    // AppHack (greglett) (108234)
    // HtmlHelp does something in the onafterprint event which results in a ProgressChange.
    // They then use this ProgressChange to do something that may result in a print.
    // Thus, multiple print dialogs appear until they crash.
    // This hack delays the onafterprint event for HtmlHelp until the template is closing.
    // If we rearchitect to remove this plumbing problem (events fired always, immediately),
    // then we should remove this hack.
    if (_pInPlace)
    {
        BOOL fInHtmlHelp = FALSE;
        TCHAR   acClass[10];
        HWND    hwnd;

        for (hwnd = _pInPlace->_hwnd;
             hwnd && !fInHtmlHelp;
             hwnd = GetParent(hwnd))
        {
            if (GetClassName(hwnd, acClass, 10) > 0)
            {
                fInHtmlHelp = (_tcsncmp(acClass, 9, _T("HH Parent"), 9) == 0);
            }
        }
    	// (gschneid) Assert here instead of setting g_fInHtmlHelp
        Assert(fInHtmlHelp == g_fInHtmlHelp);
    }
#endif // Debug

    if (!GetTempFilename(_T("\0"), _T("htm"), pchTempFile))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (fSelection)
    {
        if (!GetTempFilename(_T("\0"), _T("htm"), pchSelTempFile))
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    // HACK (cthrash) We must ensure that our encoding roundtrips -- the
    // only known codepage for which this isn't guaranteed is ISO-2022-JP.
    // In this codepage, half-width katakana will be converted to full-
    // width katakana, which can lead to potentially disasterous results.
    // Swap in a more desirable codepage if we have ISO-2022-JP.
    if (codepage == CP_ISO_2022_JP)
    {
        IGNORE_HR(pMarkup->SetCodePage(CP_ISO_2022_JP_ESC1));
    }

    // HACK (cthrash/sumitc) we can't identify UTF-7 pages as such, and so
    // we can't load them in correctly.  So (for bug 46925), we save UTF-7
    // as Unicode instead.
    if (codepage == CP_UTF_7)
    {
        IGNORE_HR(pMarkup->SetCodePage(CP_UCS_2));
    }

    AssertSz(!_fSaveTempfileForPrinting, "No nested printing allowed!");
    _fSaveTempfileForPrinting = TRUE;

	_fPrintEvent = TRUE;
    FirePrintEvents(pMarkup, _pElemCurrent, TRUE);
    _fPrintEvent = FALSE;

    if (fSelection)
    {
        hr = SaveSelection(pchSelTempFile);
    }

    // Save the whole doc to the temporary file
    hr = pMarkup->Save(pchTempFile, FALSE);

/*
    if (   !(dwFlags & PRINT_WAITFORCOMPLETION)
        && pDocToPrint->_fPrintedDocSavedPlugins)
        pDocToPrint->_fPrintedDocSavedPlugins = FALSE;
*/
    _fPrintEvent = TRUE;
    FirePrintEvents(pMarkup, _pElemCurrent, FALSE);
    _fPrintEvent = FALSE;

    _fSaveTempfileForPrinting = FALSE;

    IGNORE_HR(pMarkup->SetCodePage(codepage));

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetPlugInSiteForPrinting
//
//  Synopsis:   Returns COleSite which is an Adobe Acrobat plugin control for printing.
//              Only used for printing Acrobat controls which only print when inplace-active.
//
//  Returns:    S_OK    - Adobe plugin exists.  IDispatch returned.
//              S_FALSE - No Adobe plugin exists
//              (anything else) - Another call failed, returning this code.
//
//----------------------------------------------------------------------------
HRESULT
CDoc::GetPlugInSiteForPrinting(CDocument *pContextDoc, IDispatch ** ppDispatch)
{
    HRESULT         hr              = S_FALSE;
    DWORD_PTR       dwEnumCookie    = 0;
    INSTANTCLASSINFO * pici;
    COleSite *      pPlugInSite     = NULL;
    CLayout  *      pLayoutClient   = NULL;
    CLayout *       pChildLayout    = NULL;
    CElement *      pElementClient  = pContextDoc->Markup()->GetElementClient();

    if (ppDispatch)
        *ppDispatch = NULL;

    // No plugin site unless the doc's rootsite's clientsite is a
    // body element.
    if (!pElementClient || ETAG_BODY != pElementClient->Tag())
        goto Cleanup;

    pLayoutClient = pElementClient->GetUpdatedLayout();

    // Get the first child site.
    pChildLayout = pLayoutClient->GetFirstLayout(&dwEnumCookie);
    if (!pChildLayout || ETAG_EMBED != pChildLayout->Tag())
        goto Cleanup;

    // We have a plugin site.
    pPlugInSite = DYNCAST(COleSite, pChildLayout->ElementOwner());

    // Insist on the plugin site being the only site.
    pChildLayout = pLayoutClient->GetNextLayout(&dwEnumCookie);
    if (pChildLayout)
        goto Cleanup;

    pici = pPlugInSite->GetInstantClassInfo();

    if (!pici || !(pici->dwCompatFlags & COMPAT_PRINTPLUGINSITE))
        goto Cleanup;

    // Do we print this as a plugin?
    // Make sure we have the IDispatch pointer
    if (!pPlugInSite->_pDisp)
        goto Cleanup;

    if (ppDispatch)
    {
        *ppDispatch = pPlugInSite->_pDisp;
        (*ppDispatch)->AddRef();                //  Should we AddRef?  Not needed, now...
    }

    hr = S_OK;

Cleanup:
    if (pLayoutClient)
        pLayoutClient->ClearLayoutIterator(dwEnumCookie, FALSE);

    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------
//
//  Member:    CDoc::GetAlternatePrintDoc
//
//  Arguments: pstrUrl (out): pointer to Url of active frame
//                            needs to be at least pdlUrlLen
//                            characters long.
//             cchUrl (in):   length of url array passed in.
//
//  Synopsis : Returns S_OK and the Url of alternate print doc if it exists.
//             Otherwise returns S_FALSE.
//
//-----------------------------------------------------------------

HRESULT CDoc::GetAlternatePrintDoc(CDocument *pContextDoc, TCHAR *pchUrl, DWORD cchUrl)
{
    CTreeNode *     pNode;
    CLinkElement *  pLink;
    HRESULT         hr = S_FALSE;
    CMarkup *       pMarkup = pContextDoc->Markup();

    if (!pchUrl || cchUrl >= pdlUrlLen)
        return E_POINTER;

    if (!pMarkup->GetHeadElement())
        return S_FALSE;

    CChildIterator ci (pMarkup->GetHeadElement());

    while ( (pNode = ci.NextChild()) != NULL )
    {
        if ( pNode->Tag() == ETAG_LINK )
        {
            LPCTSTR pstrRel = NULL, pstrMedia = NULL, pstrUrl = NULL;

            // Found a link element.  Examine it.
            pLink = DYNCAST(CLinkElement, pNode->Element());

            pstrRel = pLink->GetAArel();

            if (!pstrRel || _tcsicmp(pstrRel, _T("alternate")))
                continue;

            pstrMedia = pLink->GetAAmedia();

            if (!pstrMedia || _tcsicmp(pstrMedia, _T("print")))
                continue;

            // We found a REL=alternate MEDIA=print candidate.  Lets
            // get the url.

            pstrUrl = pLink->GetAAhref();

            if (pstrUrl && (_tcslen(pstrUrl) > 0))
            {
                TCHAR achUrl[pdlUrlLen];
                DWORD cchDummy;

                // Obtain absolute Url.
                if (FAILED(CoInternetCombineUrl(pMarkup->GetUrl(pMarkup),
                                pstrUrl,
                                URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE,
                                achUrl,
                                ARRAY_SIZE(achUrl),
                                &cchDummy,
                                0))
                  || (_tcslen(achUrl) == 0))
                {
                    // Skip problematic Urls.
                    continue;
                }

                _tcsncpy(pchUrl, achUrl, cchUrl);
                hr = S_OK;
                break;
            }
        }
    }

    RRETURN1(hr, S_FALSE);
}

#ifndef WIN16
//+---------------------------------------------------------------------------
//
//  Member:     ReadURLFromFile
//
//  Synopsis:   helper to read the URL out of a shortcut file
//
//  Returns:
//
//----------------------------------------------------------------------------
HRESULT ReadURLFromFile(TCHAR *pchFileName, TCHAR **ppchURL)
{
    HRESULT  hr = E_FAIL;
    IPersistFile *pPF = 0;
    IUniformResourceLocator * pUR = 0;
    TCHAR *pchNew = 0;

    if (!*ppchURL)
    {
        goto Cleanup;
    }

    hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
                           IID_IPersistFile, (void **)&pPF);
    if (hr)
        goto Cleanup;

    hr = pPF->Load(pchFileName,0);
    if (hr)
        goto Cleanup;

    hr = pPF->QueryInterface(IID_IUniformResourceLocator, (void**)&pUR);
    if (hr)
        goto Cleanup;

    hr = pUR->GetURL(&pchNew);
    if (!hr)
    {
        // If pre-allocated buffer is too small, re-alloc it.
        size_t  ilen  =  _tcslen(pchNew);
        if  (_tcslen(*ppchURL)  <  ilen)
        {
            delete  *ppchURL;
            *ppchURL  =  new  TCHAR[ilen  +  1];
        }
        _tcscpy(*ppchURL, pchNew);
    }

Cleanup:
    ReleaseInterface(pPF);
    ReleaseInterface(pUR);
    //delete pchNew;
    CoTaskMemFree(pchNew);
    RRETURN(hr);
}
#endif // ndef WIN16



//+----------------------------------------------------------------------
//
//  Function:   GetNextToken
//
//  Purpose:    get a "..." token from a command line
//                  allocates the outstring
//
//  Returns:    index in stringnothing
//
//-----------------------------------------------------------------------
int GetNextToken(const TCHAR *pchIn, TCHAR **ppchOut)
{
    int i = 0, j = 0, len ;

    *ppchOut = 0 ;

    if (!pchIn)
    {
        return 0;
    }

    while ( pchIn[i] && pchIn[i] != '"' )
        i++ ;

    if ( !pchIn[i] )
        return 0 ;

    j=i+1 ;
    while ( pchIn[j] && pchIn[j] != '"' )
        j++ ;

    if ( j > i + 1 )
    {
        len = j - i - 1 ;
        *ppchOut = (TCHAR*) new(Mt(GetNextToken_ppchOut)) TCHAR[(len+1)];
        if ( !(*ppchOut) )
            return 0 ;

        _tcsncpy(*ppchOut,&pchIn[i+1],len);
        (*ppchOut)[len] = '\0' ;
    }
    else
        return 0 ;

    return j ;
}

//+----------------------------------------------------------------------
//
//  Function:   ParseCMDLine
//
//  Purpose:    takes a string, checks if there is printer driver info in
//              the string, returns URL, DEVNAMES, DEVMODE, and HDC as needed
//
//  Arguments:  pchIn [IN]          -The command line string to be parsed.
//                                   Format: '"<URL>" "<Printer>" "<Driver>" "<Port"'
//              ppchURL [OUT]       - The URL found.
//              ppchPrinter [OUT]   - The Device Names (printer name)
//              ppchDriver [OUT]    - The device mode (dirver)
//              ppchPort[OUT]       - The port of the device
//
// parses a string of the form:
//      "<URL>" "<PRINTER>" "<DRIVER>" "<PORT>"
//
//-----------------------------------------------------------------------
HRESULT
ParseCMDLine(const TCHAR *pchIn,
             TCHAR ** ppchURL,
             TCHAR ** ppchPrinter,
             TCHAR ** ppchDriver,
             TCHAR ** ppchPort)
{
    HRESULT hr = S_OK;
    int     index;

    Assert(pchIn);
    Assert(ppchURL);
    Assert(ppchDriver);
    Assert(ppchPort);

    *ppchURL      = NULL;
    *ppchPrinter  = NULL;
    *ppchDriver   = NULL;
    *ppchPort     = NULL;

    index = GetNextToken(pchIn, ppchURL);

    if (index == 0)
    {
        // this was not a cmd line string, get out
        hr =  E_INVALIDARG;
        goto Cleanup;
    }

    // so we should have a filename now, but it maybe
    // an URL file, so get the data out if that is the case
    if (_tcsistr(*ppchURL, TEXT(".url")))
    {
        // we need to get the string out of the file....
        hr = ReadURLFromFile(*ppchURL, ppchURL);
        if (hr)
            goto Cleanup;
    }


    // now that we have a URL sift for the other values...
    if (pchIn[++index])
    {
        // wait...there is more
        index += GetNextToken(&pchIn[index], ppchPrinter);

        if (pchIn[++index])
        {
            // wait...there is more
            index += GetNextToken(&pchIn[index], ppchDriver);

            if (pchIn[++index])
            {
                // wait...there is more
                index += GetNextToken(&pchIn[index], ppchPort);
            }
        }
    }

Cleanup:
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Helper : SetPrintCommandParameters
//
//  Synopsis : this function will take a set of paramters and bundles them into
//      the event object so that it may be passed up to the DHUI handler.  This
//      information is necessary for the DHUI handler to bring up the correct
//      template, with the correct content document, and with the correct
//      Headers and footers and initial print device.
//
//          Expando Name                                 Mapped from Parameter
//     --------------------------------------------------------------------------
//     {TEXT("__IE_TemplateUrl"),         VT_BSTR},             pstrTemplate
//     {TEXT("__IE_ParentHWND"),          VT_UINT},             parentHWND
//     {TEXT("__IE_HeaderString"),        VT_BSTR},             bstrHeader
//     {TEXT("__IE_FooterString"),        VT_BSTR},             bstrFooter
//     {TEXT("__IE_OutlookHeader"),       VT_UNKNOWN},          pStream
//     {TEXT("__IE_BaseLineScale"),       VT_INT},              iFontScale
//     {TEXT("__IE_uPrintFlags"),         VT_UINT},             uFlags
//     {TEXT("__IE_ContentDocumentUrl"),  VT_BSTR},             pstrUrlToPrint
//     {TEXT("__IE_PrinterCMD_Printer"),  VT_BSTR},             pstrPrinter
//     {TEXT("__IE_PrinterCMD_Device"),   VT_BSTR},             pstrDriver
//     {TEXT("__IE_PrinterCMD_Port"),     VT_BSTR},             pstrPort
//     {TEXT("__IE_ContentSelectionUrl"), VT_BSTR},             pstrSelectionUrl
//     {TEXT("__IE_BrowseDocument"),      VT_UNKNOWN},          pBrowseDoc
//     {TEXT("__IE_TemporaryFiles"),      VT_ARRAY/VT_EMPTY},   pvarFileArray
//     {TEXT("__IE_PrinterCMD_DevNames"), VT_I8},               hDevNames
//     {TEXT("__IE_PrinterCMD_DevMode"),  VT_I8},               hDevMode
//     {TEXT("__IE_PrintType"),           VT_BSTR},             pt
//
//  Comments on __IEDevNames/Mode: This is a windows global handle (HGLOBAL), which is
//  safe to pass cross-thread.  If we pass it as a VT_*PTR RPC will refuse to marshall.
//  VT_HANDLEs are currently always 32 bits.  The only easy option this leaves us with
//  is to pass it as a VT_I8 to fake out RPC.
//
//  As other paremeters, the HTML element of each print doc has the following attributes
//  set in FirePrintEvents.
//      __IE_DisplayURL     Original (non tempfile) URL.
//      __IE_ActiveFrame    Index into the frames collection of the active FRAME/IFRAME (if one exists).
//
//      __IE_ViewLinkSrc
//
//----------------------------------------------------------------------------

IUnknown *
SetPrintCommandParameters (HWND      parentHWND,
                           LPTSTR    pstrTemplate,
                           LPTSTR    pstrUrlToPrint,
                           LPTSTR    pstrSelectionUrl,
                           UINT      uFlags,
                           INT       iFontScale,
                           BSTR      bstrHeader,
                           BSTR      bstrFooter,
                           LPSTREAM  pStream,
                           IUnknown* pBrowseDoc,
                           VARIANT * pvarFileArray,
                           HGLOBAL   hDevNames,
                           HGLOBAL   hDevMode,
                           LPTSTR    pstrPrinter,
                           LPTSTR    pstrDriver,
                           LPTSTR    pstrPort,
                           PRINTTYPE pt)
{
    HRESULT          hr = S_OK;
    CVariant         cvarTemp;
    IHTMLEventObj  * pEventObj    = NULL;
    IHTMLEventObj2 * pEvObj2      = NULL;

    // Let's assert some input constraints:
    // (1) We should never have both a printer/driver/port and a DEVMODE/DEVNAMES specified.
    //     They specify the same thing, and we have not specified an order of priority.
    // (2) Of printer/driver/port, printer is crucial.  Ensure it is there if any are.
    // (3) DEVMODE and DEVNAMES must come in a pair.
    // (4) The TempFileArray must either be a safearray of BSTRs, or an empty variant.
    Assert(     !(pstrPrinter || pstrDriver || pstrPort)
            ||  !(hDevNames || hDevMode));
    Assert(pstrPrinter || !(pstrDriver || pstrPort));
    Assert((hDevNames && hDevMode) || !(hDevNames || hDevMode));
    Assert(     pvarFileArray
            &&  (   V_VT(pvarFileArray) == (VT_ARRAY | VT_BSTR)
                ||  V_VT(pvarFileArray) == VT_EMPTY ));

    uFlags &= PRINT_FLAGSTOPASS;        // Mask out all but flags to pass on the OLECMDID_PRINT or _PRINTPREVIEW

    // Create the event object as a holder for the parameters to pass
    //---------------------------------
    hr = CEventObj::Create(&pEventObj, NULL, NULL, NULL, FALSE, NULL, NULL);
    if (hr)
        goto Cleanup;

    hr = pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**)&pEvObj2);
    if (hr)
        goto Cleanup;


    // Set the template URL
    //---------------------------------
    if (pstrTemplate)
    {
        V_VT(&cvarTemp) = VT_BSTR;
        V_BSTR(&cvarTemp) = SysAllocString(pstrTemplate);
    }
    else
    {
        cvarTemp.Clear();
    }
    pEvObj2->setAttribute(_T("__IE_TemplateUrl"), cvarTemp, 0);
    cvarTemp.Clear();


    // Set the Parent HWND
    //---------------------------------
    V_VT(&cvarTemp) = VT_UINT;
    V_UINT(&cvarTemp) = HandleToUlong(parentHWND);
    pEvObj2->setAttribute(_T("__IE_ParentHWND"), cvarTemp, 0);
    cvarTemp.Clear();


    // set the Header string
    //---------------------------------
    V_VT(&cvarTemp) = VT_BSTR;
    V_BSTR(&cvarTemp) = bstrHeader;
    pEvObj2->setAttribute(_T("__IE_HeaderString"), cvarTemp, 0);
    cvarTemp.ZeroVariant();  //don't release the string


    // set the FooterString
    //---------------------------------
    V_VT(&cvarTemp) = VT_BSTR;
    V_BSTR(&cvarTemp) = bstrFooter;
    pEvObj2->setAttribute(_T("__IE_FooterString"), cvarTemp, 0);
    cvarTemp.ZeroVariant();  //don't release the string


    // Set the Outlook header thingy
    //---------------------------------
    V_VT(&cvarTemp) = VT_UNKNOWN;
    V_UNKNOWN(&cvarTemp) = pStream;
    if (pStream) pStream->AddRef();
    pEvObj2->setAttribute(_T("__IE_OutlookHeader"), cvarTemp, 0);
    cvarTemp.Clear();


    // set the Base line scale factor
    //---------------------------------
    V_VT(&cvarTemp) = VT_INT;
    V_INT(&cvarTemp) = iFontScale;
    pEvObj2->setAttribute(_T("__IE_BaseLineScale"), cvarTemp, 0);
    cvarTemp.Clear();


    // set the PrintFlags
    //---------------------------------
    V_VT(&cvarTemp) = VT_UINT;
    V_UINT(&cvarTemp) = uFlags;
    pEvObj2->setAttribute(_T("__IE_uPrintFlags"), cvarTemp, 0);
    cvarTemp.Clear();

    // set the ContentDocumentURL (this is likely the temp file that the browse
    //  document was saved into
    //---------------------------------
    V_VT(&cvarTemp) = VT_BSTR;
    V_BSTR(&cvarTemp) = SysAllocString(pstrUrlToPrint);
    pEvObj2->setAttribute(_T("__IE_ContentDocumentUrl"), cvarTemp, 0);
    cvarTemp.Clear();

    // set the SelectionURL (of it was specified)
    // (this is the temp file into which the browse selection may have been saved)
    //---------------------------------
    V_VT(&cvarTemp) = VT_BSTR;
    V_BSTR(&cvarTemp) = SysAllocString(pstrSelectionUrl);
    pEvObj2->setAttribute(_T("__IE_ContentSelectionUrl"), cvarTemp, 0);
    cvarTemp.Clear();

    // set the Printer Name
    //--------------------------------------------
    V_VT(&cvarTemp) = VT_BSTR;
    V_BSTR(&cvarTemp) = SysAllocString(pstrPrinter);
    pEvObj2->setAttribute(_T("__IE_PrinterCMD_Printer"), cvarTemp, 0);
    cvarTemp.Clear();


    // set the Driver
    //--------------------------------------------
    V_VT(&cvarTemp) = VT_BSTR;
    V_BSTR(&cvarTemp) = SysAllocString(pstrDriver);
    pEvObj2->setAttribute(_T("__IE_PrinterCMD_Device"), cvarTemp, 0);
    cvarTemp.Clear();


    // set the Printer Port
    //--------------------------------------------
    V_VT(&cvarTemp) = VT_BSTR;
    V_BSTR(&cvarTemp) = SysAllocString(pstrPort);
    pEvObj2->setAttribute(_T("__IE_PrinterCMD_Port"), cvarTemp, 0);
    cvarTemp.Clear();

    // Set a reference back to ourselves, if we have the document in memory
    //---------------------------------
    V_VT(&cvarTemp) = VT_UNKNOWN;
    V_UNKNOWN(&cvarTemp) = pBrowseDoc;
    if (pBrowseDoc) pBrowseDoc->AddRef();
    pEvObj2->setAttribute(_T("__IE_BrowseDocument"), cvarTemp, 0);
    cvarTemp.Clear();

    // Set a reference to temp file list
    //---------------------------------
    pEvObj2->setAttribute(_T("__IE_TemporaryFiles"), *pvarFileArray, 0);

    // Set references to DEVMODE/DEVNAMES, if they have been passed
    //---------------------------------
    if (hDevNames && hDevMode)
    {
        HGLOBAL hDNOut;
        HGLOBAL hDMOut;

        if (CopyPrintHandles(hDevNames, hDevMode, &hDNOut, &hDMOut) == S_OK)
        {
            V_VT(&cvarTemp) = VT_HANDLE;
            V_BYREF(&cvarTemp) = hDNOut;
            pEvObj2->setAttribute(_T("__IE_PrinterCMD_DevNames"), cvarTemp, 0);

            V_VT(&cvarTemp) = VT_HANDLE;
            V_BYREF(&cvarTemp) = hDMOut;
            pEvObj2->setAttribute(_T("__IE_PrinterCMD_DevMode"), cvarTemp, 0);

            VariantInit(&cvarTemp);
        }
    }

    // set the PrintTemplate target type
    //--------------------------------------------
    V_VT(&cvarTemp) = VT_BSTR;
    V_BSTR(&cvarTemp) = ::SysAllocString(s_aachPrintType[pt]);
    pEvObj2->setAttribute(_T("__IE_PrintType"), cvarTemp, 0);
    cvarTemp.Clear();

Cleanup:
    ReleaseInterface(pEventObj);
    return pEvObj2;
}



//+---------------------------------------------------------------------------
//
//  Member:     PrintMSHTML, public
//
//  Synopsis:   Prints the passed in URL
//              called as a helper from the Shell
//
//  Returns:    like WinMain
//
//----------------------------------------------------------------------------
STDAPI_(int) PrintHTML(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpURLToPrint, int nNotUsed)
{
    HRESULT             hr = E_FAIL;
    CVariant            cvarArgIn;
    IDocHostUIHandler * pDHUIHandler = NULL;
    IOleCommandTarget * pDHUICommand = NULL;
    CVariant            cvarEmpty;
    TCHAR             * pchURL       = NULL;
    TCHAR             * pchPrinter   = NULL;
    TCHAR             * pchDriver    = NULL;
    TCHAR             * pchPort      = NULL;

    // (greglett) 01/13/2000
    // We are not loading the document and saving it to a temp file.  This causes several difference from the
    // print/print preview codepath:
    //  (1) Objects won't print.  We save them to a metafile and scale them; without the browse doc, we don't have the metafile.
    //  (2) Expressions will not persist out their current value.  Shortly, they won't execute at all in the print doc.
    //  (3) WebOC documents will be directly loaded in framesets; print/print preview will load a resource URL claiming they can't be printed.
    // This could be fixed by loading the doc, saving it to tempfile, and reloading in the template, but this would more than double the time
    // required for printing.
    // (greglett) 01/13/2000
    // We are seeing a memory leak (and crash in MSHTMDBG) calling this function with debug DLLs.
    // This leak occurs due to the dialog brought up in printing, and will occur if absolutely nothing else is done.
    // This leak does not occur if PrintHTML is called from IDM_PRINT, or some other codepath than as an API.
    // Carl and I conjecture that this leak is an unreal report produced by the way we're loaded; this could be fixed by doing the
    // above fix.

    //
    // we can ignore all the stuff that is passed in beside the lpURLToPrint...
    // which can be either
    //  : a URL file spec of the form "<URL>"
    //  : or a string containing "<URL>" "<PRINTER>" "<DRIVER>" "<PORT>"
    //
    CoInitialize(NULL);

    if (!lpURLToPrint)
        goto Cleanup;

    // Open scope for thread state manager, cets.
    {
        TCHAR               achBuff[pdlUrlLen];
        CEnsureThreadState  cets;

        if (FAILED(cets._hr))
        {
            goto Cleanup;
        }

        // dll initialization of globals
        hr = InitDocClass();
        if (hr)
            goto Cleanup;

        // If ratings are enabled, refuse to print anything we don't already know about.
        if (S_OK == AreRatingsEnabled())
        {
            // If the ratings people ever convince us to bring up some UI, this is the
            // place.  That UI can potentially also provide the option to continue as normal
            // after typing in a password.
            hr = E_FAIL;
            goto Cleanup;
        }

        //
        // The way that we do this is:
        // ---------------------------
        //  1. Create a DHUIHandler (we use the default from shdocvw since we
        //          have no host in this call.
        //  2. Parse the command line to get the URL to print, printer/port/driver.
        //  3. The DHUI handler will to the document creation, url download, and
        //          issue the print commands.
        //
        hr = THR(CoCreateInstance(CLSID_DocHostUIHandler,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IDocHostUIHandler,
                                  (void**)&pDHUIHandler));
        if (hr)
            goto Cleanup;

        hr = pDHUIHandler->QueryInterface(IID_IOleCommandTarget,
                                          (void **) &pDHUICommand);
        if (hr)
            goto Cleanup;


        //
        // prepare the arg parameters for the delegation call
        //

        memset(achBuff, 0, pdlUrlLen*sizeof(TCHAR));

        if (MultiByteToWideChar(CP_ACP, 0, (const char*)lpURLToPrint, -1,achBuff, pdlUrlLen-1))
        {
            hr = ParseCMDLine(achBuff, &pchURL, &pchPrinter, &pchDriver, &pchPort);
            if (FAILED(hr))
                goto Cleanup;


            V_VT(&cvarArgIn)      = VT_UNKNOWN;
            V_UNKNOWN(&cvarArgIn) = SetPrintCommandParameters(
                                        NULL,
                                        NULL,
                                        pchURL,
                                        NULL,
                                        PRINT_WAITFORCOMPLETION,
                                        0, NULL, NULL, NULL, NULL,
                                        &cvarEmpty, NULL, NULL,
                                        pchPrinter, pchDriver, pchPort,
                                        PRINTTYPE_PRINT);
            //
            // ...and finally make the delegation call
            //
            hr = pDHUICommand->Exec(&CGID_DocHostCommandHandler,
                               OLECMDID_PRINT,
                               0,
                               &cvarArgIn,
                               NULL);
        }
    }

Cleanup:
    ReleaseInterface(pDHUIHandler);
    ReleaseInterface(pDHUICommand);

    if (pchURL)
        delete []pchURL;
    if (pchPrinter)
        delete []pchPrinter;
    if (pchPort)
        delete []pchPort;
    if (pchDriver)
        delete []pchDriver;

    CoUninitialize();

    return (hr==S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::PrintHandler
//
//  Synopsis:   Prints the document.  In Template Printing, the only real work
//      that Trident needs to do is to set up the eventObject Parameters and then
//      delegate the print call to the host.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CDoc::PrintHandler( CDocument   * pContextDoc,
                    const TCHAR * pchTemplate,
                    const TCHAR * pchAlternateUrl,
                    DWORD         dwFlags,               // == PRINT_DEFAULT
                    SAFEARRAY   * psaHeaderFooter,       // == NULL
                    DWORD         nCmdexecopt,           // == 0
                    VARIANTARG  * pvarargIn,             // == NULL
                    VARIANTARG  * pvarargOut,            // == NULL
                    BOOL          fPreview)              // == FALSE
{
    Assert(pContextDoc);
    HRESULT       hr = S_OK;
    BOOL          fSelection = FALSE;
    LPTSTR        pchUrlDocToPrint = NULL;          // The content Document to flow & print
    TCHAR         achTempFileName[MAX_PATH];        // Buffer for saving tempfile
    TCHAR         achSelTempFileName[MAX_PATH];
    BSTR          bstrHeader = NULL,
                  bstrFooter = NULL,
                  bstrAlt2 = NULL,
                  bstrTemplate = NULL;
    IStream     * pStream = NULL;
    CDoc        * pDocument = NULL;
    CVariant      cvarIn;
    CVariant      cvarTempFileList;
    CVariant      cvarDevNames;                     // VT_PTR - aiming at a DEVNAMES handle
    CVariant      cvarDevMode;                      // VT_PTR - aiming at a DEVMODE handle

    // If we have a HostUICommandHandler, and the caller did NOT request no-UI, pass it up to the host
    // If we don't have a _pHostUICommandHandler, then hr will remain OLECMDERR_E_NOTSUPPORTED
    //
    // The pvarargIn is only provided from the CDoc::Exec code path so that back compat delegation
    // works properly. All other code paths, leave that blank, so that we can do our "default"
    // processing
    //------------------------------------------------------------------------------------------
    if (   _pHostUICommandHandler
        && !(nCmdexecopt & OLECMDEXECOPT_DONTPROMPTUSER)
        && !_fOutlook98)
    {
        hr = THR_NOTRACE(_pHostUICommandHandler->Exec(&CGID_DocHostCommandHandler,
                                              (fPreview ? OLECMDID_PRINTPREVIEW : OLECMDID_PRINT),
                                              nCmdexecopt,
                                              pvarargIn,
                                              pvarargOut));

        if (   hr != OLECMDERR_E_NOTSUPPORTED
            && hr != OLECMDERR_E_UNKNOWNGROUP
            && hr != E_NOTIMPL)
            goto Cleanup;  // Handled
    }

    // there are some special case printing scenarios that need to be handled directly
    //--------------------------------------------------------------------------------

    // If the print document is in memory, ask for an alternate print document.
    // But We never print alternate documents if ratings are enabled to avoid
    // ratings security holes.
    if (   !pchAlternateUrl
        && S_OK == GetAlternatePrintDoc(pContextDoc, achTempFileName, MAX_PATH)
        && (_tcslen(achTempFileName) > 0))
    {
        // assign pchAlternateUrl so that we can avoid work later, and so that
        // achTempFileName doesn't get overridden.
        pchAlternateUrl  = achTempFileName;
    }

    // But, If ratings are enabled, refuse to print anything we don't already know about.
    if (   pchAlternateUrl
        && (S_OK == AreRatingsEnabled()))
    {
        // If the ratings people ever convince us to bring up some UI, this is the
        // place.  That UI can potentially also provide the option to continue as normal
        // after typing in a password.

        hr = E_FAIL;
        goto Cleanup;
    }

    // Is this an Adobe Acrobat plugin site?
    // NB: We don't do the right thing right now if we have an alternate print doc that aims at an Acrobat page. (greglett)
    //     I don't believe that we will ever care enough to fix this.
    {
        IDispatch * pDisp = NULL;
        if (GetPlugInSiteForPrinting(pContextDoc, &pDisp) == S_OK)
        {
            if (fPreview)
            {
                hr = E_FAIL;
            }
            else
            {
                static OLECHAR * oszPrint = _T("Print");
                unsigned int    nParam = 0;
                DISPID          dispidPrint = 0;
                DISPPARAMS      DispParams;
                VARIANT         varReturn;
                EXCEPINFO       excepinfo;

                // Find out what the "Print" method's dispid is.  Should be 2 for Adobe Acrobat.
                hr = THR(pDisp->GetIDsOfNames(IID_NULL, &oszPrint, 1, g_lcidUserDefault, &dispidPrint));
                if (hr)
                    goto Cleanup;

                // Invoke the print method.  For Adobe this should return immediately after
                // posting a window message to the out-of-proc server.
                VariantInit(&varReturn);
                DispParams.cNamedArgs         = 0;
                DispParams.rgdispidNamedArgs  = NULL;
                DispParams.cArgs = 0;


                hr = THR(pDisp->Invoke(dispidPrint,
                                            IID_NULL,
                                            g_lcidUserDefault,
                                            DISPATCH_METHOD,
                                            &DispParams,
                                            &varReturn,
                                            &excepinfo,
                                            &nParam));

                VariantClear(&varReturn);
            }

            // Whether we're printing (and just printed the Adobe site) or previewing (and can't
            // preview the document) we have nothing left to do.  Head for the door.
            ReleaseInterface(pDisp);
            goto Cleanup;
        }
    }

    if (psaHeaderFooter)
    {
        hr = ParseHeaderFooterArray(psaHeaderFooter,
                               &bstrHeader,
                               &bstrFooter,
                               &pStream,
                               &bstrAlt2,
                               &dwFlags,
                               &bstrTemplate,
                               this);
        if (hr)
            goto Cleanup;

        if (!pchAlternateUrl)
             pchAlternateUrl = bstrAlt2;

        // Hosts can pass either a pchTemplate BSTR or a SAFEARRAY with their Exec request.
        // If we are examining the contents of a valid SAFEARRAY, the pchTemplate must not
        // have been passed, and will therefore be NULL.
        Assert (!pchTemplate);
        pchTemplate = bstrTemplate;
    }

    //
    // We need to handle this print operation since our host didn't do it for us
    //  and this isn't a special scenario.  What we need to do is accumulate all
    //  the data that needs to be bundled into the parameter object.
    //---------------------------------------------------------------------------
    if (!pchAlternateUrl)
    {

#if DBG==1
        // Use debug tag to keep temp files from destruction
        SetTempFileTracking(!IsTagEnabled(tagPrintKeepTempfiles));
#else
        SetTempFileTracking(TRUE);
#endif // DBG == 1

        fSelection = HasTextSelection();
        SaveToTempFile(pContextDoc, achTempFileName, (fSelection) ? achSelTempFileName : NULL);

        TransferTempFileList(&cvarTempFileList);
        SetTempFileTracking(FALSE);

        pchUrlDocToPrint = achTempFileName;

        pDocument = this;
    }
    else
    {
        pchUrlDocToPrint = (LPTSTR)pchAlternateUrl;
    }

    //
    // take all the data that we have just accumulated and create a parameter
    // object to pass to the delegation call
    //-----------------------------------------------------------------------
    V_VT(&cvarIn)      = VT_UNKNOWN;
    V_UNKNOWN(&cvarIn) = SetPrintCommandParameters(
                                GetHWND(),              // parentHWND
                                (LPTSTR)pchTemplate,    // Template
                                pchUrlDocToPrint,       // URL to Print
                                (fSelection) ? achSelTempFileName : NULL,
                                dwFlags,                // PRINT flags
                                _sBaselineFont,
                                bstrHeader,             // header string
                                bstrFooter,             // footer string
                                pStream,                // OE document stream
                                pContextDoc ? (IUnknown *)pContextDoc : (IUnknown *)this,
                                &cvarTempFileList,
                                _hDevNames,
                                _hDevMode,
                                NULL, NULL, NULL,
                                (fPreview) ? PRINTTYPE_PREVIEW : (dwFlags & PRINT_DONTBOTHERUSER) ? PRINTTYPE_PRINTNOUI : PRINTTYPE_PRINT );

    // If we have a HostUICommandHandler, and the caller did NOT request no-UI, pass it up to the host
    // for the second time, this time using the PrintParameter IHTMLEventObject that template printing
    // normally uses.  If we don't have a _pHostUICommandHandler, then hr will remain
    // OLECMDERR_E_NOTSUPPORTED
    //------------------------------------------------------------------------------------------
    if (   _pHostUICommandHandler
        && !(nCmdexecopt & OLECMDEXECOPT_DONTPROMPTUSER)
        && !_fOutlook98)
    {
        hr = THR_NOTRACE(_pHostUICommandHandler->Exec(&CGID_DocHostCommandHandler,
                                              (fPreview ? OLECMDID_PRINTPREVIEW2 : OLECMDID_PRINT2),
                                              0,
                                              &cvarIn,
                                              NULL));

        if (   hr != OLECMDERR_E_NOTSUPPORTED
            && hr != OLECMDERR_E_UNKNOWNGROUP
            && hr != E_NOTIMPL)
            goto Cleanup;  // Handled
    }

    //
    // delegate the print call to our backup handler
    //-----------------------------------------------
    EnsureBackupUIHandler();
    if (_pBackupHostUIHandler)
    {
        IOleCommandTarget * pBackupHostUICommandHandler;

        hr = _pBackupHostUIHandler->QueryInterface(IID_IOleCommandTarget,
                                                   (void **) &pBackupHostUICommandHandler);
        if (hr)
            goto Cleanup;

        // we are setting up a print job for the spooler, increment this count.
        _cSpoolingPrintJobs++;

        hr = pBackupHostUICommandHandler->Exec(
                    &CGID_DocHostCommandHandler,
                    (fPreview  ? OLECMDID_PRINTPREVIEW : OLECMDID_PRINT),
                    0,
                    &cvarIn,
                    NULL);
        if (hr)
        {
            // there was an error, remove this job from the count
            // if there was no error, then this will be decremented when
            // the olecmdid_pagestatus (-1) comes through
            _cSpoolingPrintJobs--;
        }

        ReleaseInterface(pBackupHostUICommandHandler);
    }

Cleanup:

    SysFreeString(bstrHeader);
    SysFreeString(bstrFooter);
    SysFreeString(bstrAlt2);
    SysFreeString(bstrTemplate);
    ReleaseInterface(pStream);
    RRETURN(hr);
}

struct SExpandoInfo
{
    TCHAR * name;
#if DBG==1
    VARTYPE type;
#endif
};

#define PRINTINGDLG_STRUCT   0
#define PRINTINGDLG_HANDLE   1
#define PAGESETUP_TRANSFERTO 4
#define PRINT_TRANSFERTO     14

static const SExpandoInfo s_aPagesetupExpandos[] =
{
    {OLESTR("pagesetupStruct"), WHEN_DBG(VT_PTR)   },
    {OLESTR("hPageSetup"),      WHEN_DBG(VT_HANDLE)},
    {OLESTR("pagesetupHeader"), WHEN_DBG(VT_BSTR)  },
    {OLESTR("pagesetupFooter"), WHEN_DBG(VT_BSTR)  }
};
static const SExpandoInfo s_aPrintExpandos[] =
{
    {OLESTR("printStruct"),                     WHEN_DBG(VT_PTR)   },
    {OLESTR("hPrint"),                          WHEN_DBG(VT_HANDLE)},
    {OLESTR("printfRootDocumentHasFrameset"),   WHEN_DBG(VT_BOOL)  },
    {OLESTR("printfAreRatingsEnabled"),         WHEN_DBG(VT_BOOL)  },
    {OLESTR("printfActiveFrame"),               WHEN_DBG(VT_BOOL)  },
    {OLESTR("printfLinked"),                    WHEN_DBG(VT_BOOL)  },
    {OLESTR("printfSelection"),                 WHEN_DBG(VT_BOOL)  },
    {OLESTR("printfAsShown"),                   WHEN_DBG(VT_BOOL)  },
    {OLESTR("printfShortcutTable"),             WHEN_DBG(VT_BOOL)  },
    {OLESTR("printiFontScaling"),               WHEN_DBG(VT_INT)   },
    {OLESTR("printpBodyActiveTarget"),          WHEN_DBG(VT_UNKNOWN)  },
    {OLESTR("printToFileOk"),                   WHEN_DBG(VT_BOOL)  },
    {OLESTR("printToFileName"),                 WHEN_DBG(VT_BSTR)  },
    {OLESTR("printfActiveFrameEnabled"),        WHEN_DBG(VT_BOOL)  }
};

HRESULT CDoc::DelegateShowPrintingDialog(VARIANT *pvarargIn, BOOL fPrint)
{
    HRESULT         hr              = OLECMDERR_E_NOTSUPPORTED;
    IHTMLEventObj2  * pEvent        = NULL;
    IHTMLEventObj   * pLocalEvent1  = NULL;
    IHTMLEventObj2  * pLocalEvent2  = NULL;
    void            * pPSD          = NULL;
    VARIANT         varHandle;
    VariantInit(&varHandle);

    // pvarargIn should be an IUnknown* to an event object
    if (    _pHostUICommandHandler
        &&  !_fOutlook98            // (41577)
        &&  pvarargIn
        &&  V_VT(pvarargIn) == VT_UNKNOWN
        &&  V_UNKNOWN(pvarargIn) )
    {
        const int           cExpandos   = (fPrint) ? PRINT_TRANSFERTO : PAGESETUP_TRANSFERTO;
        const SExpandoInfo *aExpandos   = (fPrint) ? s_aPrintExpandos : s_aPagesetupExpandos;
        BSTR    bstrAttribute   = NULL;
        int     i;
        VARIANT var;
        VariantInit(&var);

        // Check if we need to do ugly magic marshalling stuff.
        // We need to if RPC won't let us pass the PAGESETUPDLG structure.
        hr = V_UNKNOWN(pvarargIn)->QueryInterface(IID_IHTMLEventObj2, (void**)&pEvent);
        if (hr)
            goto Cleanup;
        Assert(pEvent);

        // We can't use a VT_PTR cross threads due to RPC.
        // CTemplatePrinter has passed us a GHND with a struct to use in this case.
        // Check for the printing handle expando.  If it doesn't exist, assume this is a call from 
        // a host/control trying to show the dialog.  (Example: ScriptX 5.5).
        // We can't use a VT_PTR cross threads due to RPC.
        // CTemplatePrinter has passed us a GHND with a struct to use in this case.
        bstrAttribute = ::SysAllocString(aExpandos[PRINTINGDLG_HANDLE].name);
        if (!bstrAttribute)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        hr = pEvent->getAttribute(bstrAttribute,0,&varHandle);
        ::SysFreeString(bstrAttribute);

        if (    hr 
            ||  V_VT(&varHandle) != VT_HANDLE
            ||  !V_BYREF(&varHandle) )
        {

            // This is not a dialog call coming in from CTemplatePrinter.
            // We aren't responsible for the event object created by external folks.
            // Just directly delegate the call.
            hr = _pHostUICommandHandler->Exec(
                &CGID_DocHostCommandHandler,
                (fPrint) ? OLECMDID_SHOWPRINT : OLECMDID_SHOWPAGESETUP,
                0,
                pvarargIn,
                NULL);

            goto Cleanup;
        }

        // Create a local event object to hold the expandoes.
        hr = THR(CEventObj::Create(&pLocalEvent1, this, NULL, NULL));
        if (hr)
            goto Cleanup;
        Assert(pLocalEvent1);

        hr = pLocalEvent1->QueryInterface(IID_IHTMLEventObj2, (void**)&pLocalEvent2);
        if (hr)
            goto Cleanup;
        Assert(pLocalEvent2);

        // Transfer each of the (non pointer) expandoes to the local event object
        for (i=PRINTINGDLG_HANDLE+1; i < cExpandos; i++)
        {
            // Cross thread calls to this often require sys alloc'd BSTRs (TCHARs won't cut it),
            // so we do our allocation thing.
            bstrAttribute = ::SysAllocString(aExpandos[i].name);
            if (!bstrAttribute)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            pEvent->getAttribute(bstrAttribute,0,&var);
            pLocalEvent2->setAttribute(bstrAttribute,var,0);

            Check(V_VT(&var) == aExpandos[i].type);
            VariantClear(&var);
            ::SysFreeString(bstrAttribute);
        }

        // Lock the handle and pass it on as the structure pointer.
        pPSD = ::GlobalLock(V_BYREF(&varHandle));
        V_VT(&var) = VT_PTR;
        V_BYREF(&var) = pPSD;
        pLocalEvent2->setAttribute(aExpandos[PRINTINGDLG_STRUCT].name,var,0);

        // Put the event parameter in the variant
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = pLocalEvent2;

        // Delegate the call
        hr = _pHostUICommandHandler->Exec(
                &CGID_DocHostCommandHandler,
                (fPrint) ? OLECMDID_SHOWPRINT : OLECMDID_SHOWPAGESETUP,
                0,
                &var,
                NULL);
        VariantInit(&var);      // Don't clear - no extra reference

        // Transfer back the info
        for (i=PRINTINGDLG_HANDLE+1; i < cExpandos; i++)
        {
            // Cross thread calls to this often require sys alloc'd BSTRs (TCHARs won't cut it),
            // so we do our allocation thing.
            bstrAttribute = ::SysAllocString(aExpandos[i].name);
            if (!bstrAttribute)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            pLocalEvent2->getAttribute(bstrAttribute,0,&var);
            pEvent->setAttribute(bstrAttribute,var,0);

            ::SysFreeString(bstrAttribute);
            VariantClear(&var);
        }
    }

Cleanup:
    if (pPSD)
        ::GlobalUnlock(V_BYREF(&varHandle));
    ReleaseInterface(pEvent);
    ReleaseInterface(pLocalEvent1);
    ReleaseInterface(pLocalEvent2);
    VariantClear(&varHandle);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     SetDocumentPrinter
//
//  Synopsis:   This API is essentially a cynical hack for naughty printers.
//              CTemplatePrinter calls this whenever instantiating a new printer.
//
//              We check the printer, and if there are any known issues with it, we go into
//              the relevant compatibility mode.  For most printers, we will remain in
//              the default WYSIWYG, purely virtual device mode.
//
//              This function could be expanded in V4 to set the DC for measuring to get any
//              necessary printer font metrics.
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
extern BOOL g_fPrintToGenericTextOnly;  // HACK for Generic/Text Only printer.

HRESULT
CElement::SetDocumentPrinter(BSTR bstrPrinterName, HDC hDC)
{    
    HRESULT hr = S_OK;
    BOOL fRelayoutRequired     = FALSE;

    if (!bstrPrinterName || !hDC)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }        

    if (!_tcsicmp(bstrPrinterName, _T("Generic / Text Only")))
    {
        fRelayoutRequired = !g_fPrintToGenericTextOnly;       
        g_fPrintToGenericTextOnly = TRUE;
    }
    else
    {
        fRelayoutRequired = g_fPrintToGenericTextOnly;
        g_fPrintToGenericTextOnly = FALSE;
    }
   
    TLS(fPrintWithNoTransparency) = FALSE;
    for (int cDriverCount = ARRAY_SIZE(s_aPrintDriverPrintModes) - 1 ; cDriverCount >= 0 ; cDriverCount--)
    {
        if (!_tcscmp(s_aPrintDriverPrintModes[cDriverCount].achDriverName,bstrPrinterName))
        {
            TLS(fPrintWithNoTransparency) = !!(s_aPrintDriverPrintModes[cDriverCount].dwPrintMode & PRINTMODE_NO_TRANSPARENCY);
            break;
        }
    }


#ifdef TOO_DANGEROUS_FOR_V3
    BOOL fUsePrinterFonts      = FALSE;
    BOOL fUsePrinterResolution = FALSE;

    // TODO (greglett) (3/27/2000)
    // The generic/text only printer does not support any TrueType fonts.  It always instantiates 60 wide monospace bitmap characters.
    // This causes *major* problems in our current architecture.  The solution is to instantiate fonts on the printer's DC, and measure
    // to the printer's resolution (other printers may follow).
    // This solution turns out to be too invasive for V3, but some provision for this will have to be made in the next version.
    // I've removed most of the other code I wrote to accomplish this in the font cache/Ccs (it would clutter the source considerably)
    
    // This printer has extremely nonstandard font support.  It may not support TrueType fonts, or whatever.
    if (fUsePrinterFonts)
    {
        // Essentially, this just means "update the printer DC".
        // It could either be null, and set for special printers, or initialized to hdcDesktop and overset for special printers.
        // The latter would be slighly better for perf - one fewer potential if in the DocInfo/Font code.
        // It should prolly be on the view instead of the TLS.
        if (TLS(hdcPrint) != hDC)
        {
            TLS(hdcPrint) = hDC;        // Change this to CreateCompatibleDC - can't store a handle that can be released by the client
            fRelayoutRequired = TRUE;
        }
    }
    // Go back to screen fonts
    else if (TLS(hdcPrint))
    {
        TLS(hdcPrint) = NULL;
        fRelayoutRequired = TRUE;
    }

    // Use the printer's resolution for measurement
    if (fUsePrinterResolution)
    {
        SIZE szInch;
        szInch.cx = GetDeviceCaps(hDC, LOGPIXELSX);
        szInch.cy = GetDeviceCaps(hDC, LOGPIXELSY);
        fRelayoutRequired |= pDoc->GetView()->SetPrinterResolution(szInch);        
    }
    // Use the virtual WYSIWYG printer
    else
    {
        fRelayoutRequired |= pDoc->GetView()->SetPrinterResolution(g_uiVirtual.GetResolution());
    }
#endif

    //  (PERF) (greglett)
    //         We really only need to relayout anything in the layoutContext of a media=print DeviceRect.
    //         This is *not* the same thing as all print media markups - media=print on the DeviceRect essentially just
    //         means "measure anything inside this as if it were going to the printer."
    //         Could we use a notification?
    if (fRelayoutRequired)
    {
        fc().ClearFontCache();      // HACK!  We manually patch the fast width cache for these fonts.
        Doc()->ForceRelayout();
    }

Cleanup:
    RRETURN(hr);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CIPrintCollection
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC CIPrintCollection::s_classdesc =
{
    &CLSID_HTMLDocument,             // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLIPrintCollection,     // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

//+----------------------------------------------------------------
//
//  member : DTOR
//
//+----------------------------------------------------------------

CIPrintCollection::~CIPrintCollection()
{
    long    i;

    for (i = _aryIPrint.Size()-1; i >= 0; i--)
    {
        ReleaseInterface(_aryIPrint[i]);
    }

    _aryIPrint.DeleteAll();
}


//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
CIPrintCollection::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IDispatch)
        QI_TEAROFF(this, IObjectIdentity, NULL)
    default:
        if (iid == IID_IHTMLIPrintCollection)
        {
           *ppv = (IHTMLIPrintCollection *) this;
        }
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Member  : AddName
//
//  Sysnopsis : Helper function that takes a font name from the font
//      callback and adds it to the cdataary.
//
//----------------------------------------------------------------
HRESULT
CIPrintCollection::AddIPrint(IPrint *pIPrint)
{
    HRESULT hr          = S_OK;

    hr = THR(_aryIPrint.AppendIndirect(&pIPrint, NULL));
    if (hr)
        goto Cleanup;

    pIPrint->AddRef();

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member  : length
//
//  Sysnopsis :
//
//----------------------------------------------------------------
HRESULT
CIPrintCollection::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLength = _aryIPrint.Size();

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//+---------------------------------------------------------------
//
//  Member  : item
//
//  Sysnopsis :
//
//----------------------------------------------------------------

HRESULT
CIPrintCollection::item(long lIndex, IUnknown ** ppIPrint)
{
    HRESULT   hr   = S_OK;

    if (!ppIPrint)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    (*ppIPrint) = NULL;

    if (lIndex < 0 || lIndex >= _aryIPrint.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    (*ppIPrint) = _aryIPrint[lIndex];
    (*ppIPrint)->AddRef();

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+---------------------------------------------------------------
//
//  Member  : _newEnum
//
//  Sysnopsis :
//
//----------------------------------------------------------------

HRESULT
CIPrintCollection::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr = S_OK;

    if (!ppEnum)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEnum = NULL;

    hr = THR(_aryIPrint.EnumVARIANT(VT_UNKNOWN,
                                      (IEnumVARIANT**)ppEnum,
                                       FALSE,
                                       FALSE));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\ole\scrsbobj.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1997 - 1998.
//
//  File:       scrsbobj.cxx
//
//  History:    19-Jan-1998     sramani     Created
//
//  Contents:   CScriptletSubObjects: CScriptlet subobject implementation for 
//              IDocHostUIHandler and IPropertyNotifySink Support
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SCRSBOBJ_HXX_
#define X_SCRSBOBJ_HXX_
#include "scrsbobj.hxx"
#endif

#ifndef X_SCRPTLET_HXX_
#define X_SCRPTLET_HXX_
#include "scrptlet.hxx"
#endif

#ifndef X_SCRPCTRL_HXX_
#define X_SCRPCTRL_HXX_
#include "scrpctrl.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

MtDefine(CScriptletSubObjects, Scriptlet, "CScriptletSubObjects")
MtDefine(CScriptletSubObjects_aryDispid_pv, CScriptletSubObjects, "CScriptletSubObjects::_aryDispid::_pv")
MtDefine(CScriptletSubObjectsSetContextMenu_aryDispid_pv, Locals, "CScriptletSubObjects::SetContextMenu aryDispid::_pv")

enum { MENUID_OFFSET = 1 };

IMPLEMENT_SUBOBJECT_IUNKNOWN(CScriptletSubObjects, CScriptlet, Scriptlet, _ScriptletSubObjects)

CScriptletSubObjects::~CScriptletSubObjects()
{
    if (_hmenuCtx)
        DestroyMenu(_hmenuCtx);
    
    _aryDispid.DeleteAll();
}

// IUnknown methods

STDMETHODIMP CScriptletSubObjects::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if (riid==IID_IUnknown || riid==IID_IDocHostUIHandler)
    {
        *ppv = (IDocHostUIHandler *)this;
        AddRef();
        return S_OK;
    }
    else if (riid==IID_IPropertyNotifySink)
    {
        *ppv = (IPropertyNotifySink *)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

// IDocHostUIHandler interface ////////////////////////////////////

STDMETHODIMP
CScriptletSubObjects::ShowContextMenu(DWORD dwID, POINT * ppt, IUnknown *, IDispatch *)
{
    HWND            hwnd = NULL;
    MSG             msg;
    DISPPARAMS      dispparams = { NULL, 0, NULL, 0 };

    // If we have no ctx menu, we're out of a job!

    if (!_hmenuCtx)
        goto Cleanup;

    // Create a small window to show what we've got. 

    hwnd = CreateWindowA(
                "STATIC",
                "",
                WS_POPUP,
                CW_USEDEFAULT, CW_USEDEFAULT,
                CW_USEDEFAULT, CW_USEDEFAULT,
                NULL,
                NULL,
                g_hInstCore,
                NULL);
    if (hwnd == NULL)
        goto Cleanup;

    // Show the context menu, funneling its command into the queue of hwnd.

    if (TrackPopupMenu(
            _hmenuCtx, TPM_LEFTALIGN, 
            ppt->x,
            ppt->y,
            0,
            hwnd,
            NULL) == 0)
    {
        goto Cleanup;
    }

    // The WM_COMMAND is in the message queue for the HWND. Get it.

    if (PeekMessage(&msg, hwnd, WM_COMMAND, WM_COMMAND, PM_REMOVE) == 0)
        goto Cleanup;

    // We have a dispid, now call the script object with it.

    Scriptlet()->_pDoc->_pWindowPrimary->InvokeEx(
                _aryDispid[LOWORD(msg.wParam) - MENUID_OFFSET],
                LOCALE_USER_DEFAULT,
                DISPATCH_METHOD,
                &dispparams, 
                NULL, NULL, NULL);
Cleanup:
    if (hwnd)
        DestroyWindow(hwnd);

    return S_OK;
}

STDMETHODIMP
CScriptletSubObjects::GetHostInfo(DOCHOSTUIINFO * pDHUI)
{
    pDHUI->cbSize = sizeof(*pDHUI);
    pDHUI->dwFlags =
            DOCHOSTUIFLAG_NO3DBORDER | 
            DOCHOSTUIFLAG_DISABLE_HELP_MENU;
    if (!Scriptlet()->_vbSelectable)
        pDHUI->dwFlags |= DOCHOSTUIFLAG_DIALOG;
    if (!Scriptlet()->_vbScrollbar) 
        pDHUI->dwFlags |= DOCHOSTUIFLAG_SCROLL_NO;
    pDHUI->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;

    return S_OK;
}

STDMETHODIMP
CScriptletSubObjects::ShowUI(DWORD dwID, IOleInPlaceActiveObject *, IOleCommandTarget *, IOleInPlaceFrame *, IOleInPlaceUIWindow *)
{
    // We have no UI to show, Trident will do that for itself.
    return S_FALSE;
}

STDMETHODIMP
CScriptletSubObjects::HideUI()
{
    return S_OK;
}

STDMETHODIMP
CScriptletSubObjects::UpdateUI()
{
    return S_OK;
}

STDMETHODIMP
CScriptletSubObjects::EnableModeless(BOOL fEnable)
{
    return S_FALSE;
}

STDMETHODIMP
CScriptletSubObjects::OnDocWindowActivate(BOOL fActive)
{
    return S_FALSE;
}

STDMETHODIMP
CScriptletSubObjects::OnFrameWindowActivate(BOOL fActive)
{
    return S_FALSE;
}

STDMETHODIMP
CScriptletSubObjects::ResizeBorder(LPCRECT, IOleInPlaceUIWindow *, BOOL fFrameWindow)
{
    return S_FALSE;
}

STDMETHODIMP
CScriptletSubObjects::TranslateAccelerator(MSG * pmsg,const GUID * pguidCmdGroup, DWORD nCmdID)
{
    // disable F5 as a refresh tool.

    if (pmsg->message == WM_KEYDOWN || pmsg->message == WM_KEYUP)
    {
        if (pmsg->wParam == VK_F5)
            return S_OK;
    }

    return S_FALSE;
}

STDMETHODIMP
CScriptletSubObjects::GetOptionKeyPath(LPOLESTR * pchKey,  DWORD dwReserved)
{
    // User preferences are the same as those of Default Trident
    return S_FALSE;
}

STDMETHODIMP
CScriptletSubObjects::GetDropTarget(IDropTarget *, IDropTarget ** )
{
    // We don't interfere with Trident's drag/drop stuff.
    return S_FALSE;
}

/*
 *  IDocHostUIHandler::GetExternal
 *
 *  The IDispatch asked for will be used to resolve any references to 
 *  window.external from script. In our case, we want the object
 *  to be the CScriptControl.
 */

STDMETHODIMP
CScriptletSubObjects::GetExternal(IDispatch ** ppDisp)
{
    Assert(Scriptlet()->_pScriptCtrl);

    *ppDisp = Scriptlet()->_pScriptCtrl;
    (*ppDisp)->AddRef();

    return S_OK;
}

STDMETHODIMP
CScriptletSubObjects::TranslateUrl(DWORD dwTranslate, OLECHAR *, OLECHAR ** )
{
    return S_FALSE;
}

STDMETHODIMP
CScriptletSubObjects::FilterDataObject(IDataObject *, IDataObject ** )
{
    return S_FALSE;
}


// IPropertyNotifySink

STDMETHODIMP CScriptletSubObjects::OnRequestEdit(DISPID dispid)
{
    if (dispid < 0)     // no Trident properties make it out.
        return S_OK;

    return Scriptlet()->FireRequestEdit(dispid);
}

STDMETHODIMP CScriptletSubObjects::OnChanged(DISPID dispid)
{
    switch (dispid)
    {
    case DISPID_READYSTATE:
        Scriptlet()->FireOnChanged(DISPID_READYSTATE);
        Scriptlet()->OnReadyStateChange();
        break;

    case STDPROPID_XOBJ_WIDTH:
        Scriptlet()->SetWidth(dispid);
        break;

    case STDPROPID_XOBJ_HEIGHT:
        Scriptlet()->SetHeight(dispid);
        break;

    default:
        if (dispid >= 0)     // no Trident properties make it out.
            Scriptlet()->FireOnChanged(dispid);
        break;
    }

    return S_OK;
}

// CScriptletSubObjects helper methods /////////////////////////////////////////

HRESULT
CScriptletSubObjects::SetContextMenu(VARIANT varArray)
{
    HRESULT                  hr;
    int                      i;
    DISPID                   dispid;
    char                     achCaption[256];
    HMENU                    hmenu = NULL;
    VARIANT                  varCaption;
    VARIANT                  varFunction;
    CDataAry<DISPID>         aryDispid(Mt(CScriptletSubObjectsSetContextMenu_aryDispid_pv));
    HRESULT                (*pfnGetItem)(const VARIANT & varArray, long i, VARIANT * pvar);

    VariantInit(&varCaption);
    VariantInit(&varFunction);

    // Determine the way to unpack the array.
    
    hmenu = CreatePopupMenu();
    if (!hmenu)
        goto Cleanup;

    switch (varArray.vt)
    {
    case VT_VARIANT | VT_ARRAY | VT_BYREF:
        // Access the data in a safearray (thank *you*, VBScript!)
        pfnGetItem = CScriptletSubObjects::GetVBScriptItem;
        break;
    case VT_DISPATCH:
        pfnGetItem = CScriptletSubObjects::GetJavaScriptItem;
        break;
    default:
        // Can't safely handle your data, mister.
        hr = E_FAIL;
        goto Cleanup;
    }

    // Unpack the array and store items in the menu and dynarray

    for (i = 0; ; i += 2)
    {
        hr = pfnGetItem(varArray, i, &varCaption);
        if (hr)
            break;
        hr = VariantChangeType(&varCaption, &varCaption, 0, VT_BSTR);
        if (hr)
            break;
        if (varCaption.bstrVal && varCaption.bstrVal[0])
        {
            WideCharToMultiByte(CP_ACP, 0, 
                                varCaption.bstrVal, -1, 
                                achCaption, sizeof(achCaption), 
                                NULL, NULL);

            hr = pfnGetItem(varArray, i+1, &varFunction);
            if (hr)
                break;
            hr = VariantChangeType(&varFunction, &varFunction, 0, VT_BSTR);
            if (hr)
                break;
            
            hr = Scriptlet()->_pDoc->_pWindowPrimary->GetDispID(varFunction.bstrVal, fdexFromGetIdsOfNames, &dispid);
            if (hr)
                break;
        }
        else
        {
            achCaption[0] = '\0';
            dispid = DISPID_UNKNOWN;
        }

        // The menu ID's are going to be 1+the offset into the arydispid array.
        // A menu ID of 0 is hard to distinguish from Windows error codes.

        Assert(aryDispid.Size() == i/2);

        hr = aryDispid.AppendIndirect(&dispid);
        if (hr)
            break;

        if (!AppendMenuA(
                hmenu,
                (achCaption[0]) ? MF_STRING : MF_SEPARATOR,
                i/2 + MENUID_OFFSET, 
                achCaption))
            break;

        VariantClear(&varCaption);
        VariantClear(&varFunction);
    }

    if (i == 0)
        goto Cleanup;

    hr = _aryDispid.EnsureSize(aryDispid.Size());
    if (hr)
        goto Cleanup;

    // All went well! Now destroy the old context menu and keep 
    // the new one.

    if (_hmenuCtx)
        DestroyMenu(_hmenuCtx);

    _hmenuCtx = hmenu;
    hmenu = NULL;

    memcpy((char *)(DISPID *)_aryDispid,
           (char *)(DISPID *)aryDispid,
           aryDispid.Size() * sizeof(DISPID));

    _aryDispid.SetSize(aryDispid.Size());

Cleanup:
    if (hmenu)
        DestroyMenu(hmenu);

    return S_OK;
}

HRESULT
CScriptletSubObjects::GetJavaScriptItem(const VARIANT & varArray, long i, VARIANT * pvar)
{
    HRESULT hr;
    DISPID  dispid;
    TCHAR   ach[30];

    // JScript returns a dispatch object with items named "0", "1", ....

    hr = Format(0, ach, ARRAY_SIZE(ach), _T("<0d>"), i);
    if (hr)
        goto Cleanup;

    hr = IdFromName(varArray.pdispVal, ach, &dispid);
    if (hr)
        goto Cleanup;
    
    hr = Property_get(varArray.pdispVal, dispid, pvar);

Cleanup:
    return hr;
}

HRESULT
CScriptletSubObjects::GetVBScriptItem(const VARIANT & varArray, long i, VARIANT * pvar)
{
    long cElements;

    // Convert to closest even number.
    cElements = ((*varArray.pparray)->rgsabound[0].cElements) & ~1;
    if (i >= cElements)
        return DISP_E_BADINDEX;
    return SafeArrayGetElement(*varArray.pparray, &i, pvar);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\style\atblocks.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1997
//
//  File:       AtBlocks.cxx
//
//  Contents:   Support for Cascading Style Sheets "atblocks" - e.g., "@page" and "@media" definitions.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FONTFACE_HXX_
#define X_FONTFACE_HXX_
#include "fontface.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_TOKENZ_HXX_
#define X_TOKENZ_HXX_
#include "tokenz.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_PAGESCOL_HXX_
#define X_PAGESCOL_HXX_
#include "pagescol.hxx"
#endif

#ifndef X_ATBLOCKS_HXX_
#define X_ATBLOCKS_HXX_
#include "atblocks.hxx"
#endif

#ifndef X_CBUFSTR_HXX_
#define X_CBUFSTR_HXX_
#include "cbufstr.hxx"
#endif

MtDefine(CAtPage, StyleSheets, "CAtPage")
MtDefine(CAtMedia, StyleSheets, "CAtMedia")
MtDefine(CAtFontFace, StyleSheets, "CAtFontFace")
MtDefine(CAtNamespace, StyleSheets, "CAtNamespace")
MtDefine(CAtUnknown, StyleSheets, "CAtUnknown")
MtDefine(CAtUnknownInfo, StyleSheets, "CAtUnknownInfo")

DeclareTag(tagCSSAtBlocks, "Stylesheets", "Dump '@' blocks")



EMediaType CSSMediaTypeFromName (LPCTSTR szMediaName)
{
    if(!szMediaName || !(*szMediaName))
        return MEDIA_NotSet;

    for(int i = 0; i < ARRAY_SIZE(cssMediaTypeTable); i++)
    {
        if(_tcsiequal(szMediaName, cssMediaTypeTable[i]._szName))
            return cssMediaTypeTable[i]._mediaType;
    }

    return MEDIA_Unknown;
}


//+----------------------------------------------------------------------------
//
//  Class:  CAtPage
//
//-----------------------------------------------------------------------------

CAtPage::CAtPage (CCSSParser *pParser, Tokenizer &tok)
                : CAtBlockHandler(pParser)
{
    Assert(pParser && pParser->GetStyleSheet());

    CStyleSheet *pStyleSheet = pParser->GetStyleSheet();

    // NOTE (KTam): Compat issue -- we are no longer preserving the content
    // between '@page' and the first '{'.  Does anyone care? (I haven't seen
    // an Office doc that actually uses page selectors).

    // Beginning of a page rule:
    //  PAGE_SYM S* IDENT? [':' IDENT]? S* '{'

    // Parse up to the { (or EOF).  We start by looking for a page selector,
    // switching to look for a pseudoclass if we see a ':'.
    BOOL fLookForSelector = TRUE;
    CStr cstrSelector, cstrPseudoClass;

    Tokenizer::TOKEN_TYPE tt = tok.NextToken();

    while (tt != Tokenizer::TT_EOF && tt != Tokenizer::TT_LCurly)
    {
        if (tok.IsIdentifier(tt))
        {
            if ( fLookForSelector )
                cstrSelector.Set( tok.GetStartToken(), tok.GetTokenLength() );
            else
                cstrPseudoClass.Set( tok.GetStartToken(), tok.GetTokenLength() );
        }
        else if ( tt == Tokenizer::TT_Colon )
        {
            fLookForSelector = FALSE;
        }

        tt = tok.NextToken();
    }

    // Create the "pages" array if we don't already have one.
    if ( !pStyleSheet->_pPageRules )
    {
        pStyleSheet->_pPageRules = new CStyleSheetPageArray( pStyleSheet );
        // The stylesheet owns the ref on the page array that it will release when it passivates.
        // The page array holds a subref back on the stylesheet.
    }

    // Create the page rule object corresponding to this @block.
    if ( pStyleSheet->_pPageRules )
    {
        HRESULT hr =  CStyleSheetPage::Create(&_pPage, pStyleSheet, cstrSelector, cstrPseudoClass );
        // Each page in the array holds a subref back on the stylesheet.
        if (!hr)
        {
            pStyleSheet->_pPageRules->Append(_pPage);  // array refs page if append is successful.
        }
        // We'll hang onto our ref on the page until we go out of scope (dtor).
    }
}

CAtPage::~CAtPage ()
{
    if ( _pPage )
        _pPage->Release();  // corresponds to ref given by "new" when _pPage was created (ctor).
}

HRESULT CAtPage::SetProperty (LPCTSTR pszName, LPCTSTR pszValue, BOOL fImportant)
{
    HRESULT hr = S_FALSE;

#if DBG==1
    if (IsTagEnabled(tagCSSAtBlocks))
    {
        CStr cstr;
        cstr.Set( _T("AtPage::SetProperty( \"") );
        cstr.Append( pszName );
        cstr.Append( _T("\", \"") );
        cstr.Append( pszValue );
        cstr.Append( fImportant ? _T("\" ) (important)\r\n") : _T("\" )\r\n") );
        OutputDebugString( cstr );
    }
#endif
    if ( _pPage )
    {
        DISPID      dispid;
        VARIANT     varNew;
        CBase      *pBase;

        // Create an expando
        pBase = _pPage;

        Assert(pBase);

        hr = pBase->GetExpandoDispID((LPTSTR)pszName, &dispid, fdexNameCaseSensitive|fdexNameEnsure);
        if (hr)
            goto Cleanup;

        // Use the byref member of the union because it's a PVOID and
        // there's no member corresponding to VT_LPWSTR.
        varNew.vt = VT_LPWSTR;
        varNew.byref = (LPTSTR)pszValue;

        hr = THR(CAttrArray::Set(_pPage->GetAA(), dispid, &varNew, NULL, CAttrValue::AA_Expando));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    return hr;
}

HRESULT CAtPage::EndStyleRule (CStyleRule *pRule)
{
#if DBG==1
    if (IsTagEnabled(tagCSSAtBlocks))
    {
        OutputDebugStringA("AtPage::EndStyleRule()\r\n");
    }
#endif
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Class:  CAtMedia
//
//-----------------------------------------------------------------------------

CAtMedia::CAtMedia (CCSSParser *pParser, Tokenizer &tok, CStyleSheet *pStyleSheet)
                : CAtBlockHandler(pParser)
{
    Assert(pParser);
 
    _ePrevMediaType = _ePrevAtMediaType = MEDIA_NotSet;

    _pStyleSheet = pStyleSheet;

    _dwFlags = ATBLOCKFLAGS_MULTIPLERULES;
    if (pStyleSheet)
    {
        LPTSTR pszName;

        tok.StartSequence();

        // Get the propertyValue
        Tokenizer::TOKEN_TYPE tt = tok.NextToken();

        while (tt != Tokenizer::TT_EOF && tt != Tokenizer::TT_LCurly)
        {
            tt = tok.NextToken();
        }

        tok.StopSequence(&pszName);

        EMediaType eMediaType = (EMediaType)TranslateMediaTypeString(pszName);
        if(eMediaType != MEDIA_NotSet)
        {
            _ePrevMediaType   = pStyleSheet->GetMediaTypeValue();
            _ePrevAtMediaType = pStyleSheet->GetLastAtMediaTypeValue();
            pStyleSheet->SetMediaTypeValue((EMediaType)(eMediaType & _ePrevMediaType));
            // Save the last media type for serializaton purposed
            if(_ePrevAtMediaType != MEDIA_NotSet)
            {
                eMediaType = (EMediaType)(eMediaType & _ePrevAtMediaType);
                if(eMediaType == MEDIA_NotSet)
                    eMediaType = MEDIA_Unknown;
            }
            pStyleSheet->SetLastAtMediaTypeValue(eMediaType);
        }
    }

}

CAtMedia::~CAtMedia ()
{
    if(_pStyleSheet)
    {
        // Restore the saved previous at block media types
         _pStyleSheet->SetMediaTypeValue(_ePrevMediaType);
         // Restore the previous applied media type value (& ed value)
         _pStyleSheet->SetLastAtMediaTypeValue(_ePrevAtMediaType);
    }
}

HRESULT CAtMedia::SetProperty (LPCTSTR pszName, LPCTSTR pszValue, BOOL fImportant)
{
#if DBG==1
    if (IsTagEnabled(tagCSSAtBlocks))
    {
        CStr cstr;
        cstr.Set( _T("AtMedia::SetProperty( \"") );
        cstr.Append( pszName );
        cstr.Append( _T("\", \"") );
        cstr.Append( pszValue );
        cstr.Append( fImportant ? _T("\" ) (important)\r\n") : _T("\" )\r\n") );
        OutputDebugString( cstr );
    }
#endif
    return S_OK;
}

HRESULT CAtMedia::EndStyleRule (CStyleRule *pRule)
{
#if DBG==1
    if (IsTagEnabled(tagCSSAtBlocks))
    {
        OutputDebugStringA("AtMedia::EndStyleRule()\n");
    }
#endif
    
    return S_OK;
}



//+----------------------------------------------------------------------------
//
//  Class:  CAtFontFace
//
//-----------------------------------------------------------------------------

CAtFontFace::CAtFontFace (CCSSParser *pParser, Tokenizer &tok)
                : CAtBlockHandler(pParser)
{
    LPTSTR pszName;
    Assert(pParser && pParser->GetStyleSheet());
    
    tok.StartSequence();

    // Get the propertyValue
    Tokenizer::TOKEN_TYPE tt = tok.NextToken();

    while (tt != Tokenizer::TT_EOF && tt != Tokenizer::TT_LCurly)
    {
        tt = tok.NextToken();
    }

    tok.StopSequence(&pszName);
    
    HRESULT hr = CFontFace::Create(&_pFontFace,pParser->GetStyleSheet(), pszName);
    if (!hr)
        pParser->GetStyleSheet()->AppendFontFace(_pFontFace);
}


CAtFontFace::~CAtFontFace ()
{
}

HRESULT CAtFontFace::SetProperty (LPCTSTR pszName, LPCTSTR pszValue, BOOL fImportant)
{
    IGNORE_HR(_pFontFace->SetProperty(pszName, pszValue));

    // S_FALSE means no further processing is needed

    return S_FALSE;
}

HRESULT CAtFontFace::EndStyleRule (CStyleRule *pRule)
{
    HRESULT hr = _pFontFace->StartDownload();

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Class:  CAtUnknown
//
//-----------------------------------------------------------------------------

CAtUnknown::CAtUnknown (CCSSParser *pParser, Tokenizer &tok, CStyleSheet *pStyleSheet, LPTSTR pchAlt) 
                : CAtBlockHandler(pParser)
{
    Assert(pParser);
 
    _pStyleSheet = pStyleSheet;

    _dwFlags = ATBLOCKFLAGS_MULTIPLERULES;

    _pBlockInfo = new CAtUnknownInfo;

    if(_pBlockInfo)
    {
        if (pchAlt)
        {
            _pBlockInfo->_cstrUnknownBlockName.Set(_T("import"));
            _pBlockInfo->_cstrUnknownBlockSelector.Set(pchAlt);
        }
        else
        {
            _pBlockInfo->_cstrUnknownBlockName.Set(tok.GetStartToken(), tok.GetTokenLength());

            tok.StartSequence();

            // Get the propertyValue
            Tokenizer::TOKEN_TYPE tt = tok.NextToken();

            while (tt != Tokenizer::TT_EOF && tt != Tokenizer::TT_Semi && tt != Tokenizer::TT_LCurly)
            {
                tt = tok.NextToken();
            }

            tok.StopSequence();
    
            _pBlockInfo->_cstrUnknownBlockSelector.Set(tok.GetStartToken(), tok.GetTokenLength());
        }
    }
}


CAtUnknown::~CAtUnknown ()
{    
    delete _pBlockInfo;
}


HRESULT CAtUnknown::SetProperty (LPCTSTR pszName, LPCTSTR pszValue, BOOL fImportant)
{
#if DBG==1
    if (IsTagEnabled(tagCSSAtBlocks))
    {
        CStr cstr;
        cstr.Set( _T("AtUnknown::SetProperty( \"") );
        cstr.Append( pszName );
        cstr.Append( _T("\", \"") );
        cstr.Append( pszValue );
        cstr.Append( fImportant ? _T("\" ) (important)\r\n") : _T("\" )\r\n") );
        OutputDebugString( cstr );
    }
#endif
    return S_OK;
}


HRESULT CAtUnknown::EndStyleRule (CStyleRule *pRule)
{
#if DBG==1
    if (IsTagEnabled(tagCSSAtBlocks))
    {
        OutputDebugStringA("CAtUnknown::EndStyleRule()\n");
    }
#endif

    
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\style\curstyle.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1997
//
//  File:       curstyle.cxx
//
//  Contents:   Support for CElement::CurrentStyle property
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_INTSHCUT_H_
#define X_INTSHCUT_H_
#include "intshcut.h"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include "csite.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_SCROLLBAR_HXX_
#define X_SCROLLBAR_HXX_
#include "scrollbar.hxx"
#endif

#ifndef X_CURSTYLE_HXX_
#define X_CURSTYLE_HXX_
#include "curstyle.hxx"
#endif

#ifndef X_CBUFSTR_HXX_
#define X_CBUFSTR_HXX_
#include "cbufstr.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_PEERFACT_HXX_
#define X_PEERFACT_HXX_
#include "peerfact.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_MISCPROT_H_
#define X_MISCPROT_H_
#include "miscprot.h"
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include "mshtmdid.h"
#endif

#ifndef X_CUSTCUR_HXX_
#define X_CUSTCUR_HXX_
#include "custcur.hxx"
#endif

#define _cxx_
#include "curstyle.hdl"

MtDefine(CCurrentStyle, StyleSheets, "CCurrentStyle")

#define GetUnitValueWithEnumDef(p, Uv, pDesc, enumname, nDefEnumValue) \
    GetUnitValueHelper(p, Uv, pDesc, &s_enumdesc##enumname, nDefEnumValue)
#define GetUnitValueWithEnum(p, Uv, pDesc, enumname) \
    GetUnitValueHelper(p, Uv, pDesc, &s_enumdesc##enumname)

#define NULLPTRCHECK(ptr, err)  if (!ptr) \
    {   \
        hr = err; \
        goto Cleanup;   \
    }

extern CCustomCursor* 
GetCustomCursorForNode(CTreeNode* pStartNode);
extern HRESULT 
UnMungeCustomUrl( CStr* pcstrUrlOrig, CStr* pcstrResult );

//
// marka temporary fix for SupeHot 33205. We may have deleted the elemnet
// after we get the current style the first time.
// becuase of a ref-counting problem - we can't now replace the node
// talk to jbeda and rgardner about replacing this.
//
#define NODE_IN_TREE_CHECK() CTreeNode* pNodeToUse = _pNode; \
    if( ! _pNode->IsInMarkup() ) \
    { \
        pNodeToUse = _pNode->Element()->GetFirstBranch(); \
        NULLPTRCHECK(pNodeToUse, E_POINTER) \
    }

BEGIN_TEAROFF_TABLE(CCurrentStyle, IRecalcProperty)
    TEAROFF_METHOD(CCurrentStyle, GetCanonicalProperty, getcanonicalproperty, (DISPID dispid, IUnknown **ppUnk, DISPID *pdispid))
END_TEAROFF_TABLE()


//+------------------------------------------------------------------------
//
//  Member:     CCurrentStyle::CCurrentStyle
//
//-------------------------------------------------------------------------
CCurrentStyle::CCurrentStyle()
{
    WHEN_DBG(_dwCookie=eCookie;)
}

HRESULT
CCurrentStyle::Init(CTreeNode *pNode)
{
    HRESULT hr;

    Assert ( pNode );

    WHEN_DBG( _fInited = TRUE; );

    _pNode = pNode;
    hr = THR( _pNode->NodeAddRef() );
    if( hr )
    {
        _pNode = NULL;
    }

    RRETURN( hr );
}

//+------------------------------------------------------------------------
//
//  Member:     CCurrentStyle::Passivate
//
//-------------------------------------------------------------------------
void
CCurrentStyle::Passivate()
{
    AssertSz( _fInited, "Must call Init first!" );
    super::Passivate();

    if( _pNode )
    {
        // Remove myself from the node's lookaside
        if( _pNode->HasCurrentStyle() && this == _pNode->GetCurrentStyle() )
        {
            Verify( this == _pNode->DelCurrentStyle() );
        }

        _pNode->NodeRelease();
    }
}

//+------------------------------------------------------------------------
//
//  Member:     ClassDesc
//
//-------------------------------------------------------------------------
const CCurrentStyle::CLASSDESC CCurrentStyle::s_classdesc =
{
    &CLSID_HTMLCurrentStyle,       // _pclsid
    0,                             // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                          // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                          // _pcpi
    0,                             // _dwFlags
    &IID_IHTMLCurrentStyle,        // _piidDispinterface
    &s_apHdlDescs,                 // _apHdlDesc
};



//+------------------------------------------------------------------------
//
//  Member:     CCurrentStyle::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CCurrentStyle::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    AssertSz(eCookie==_dwCookie, "NOT A CCurrentSTYLE");
    AssertSz( _fInited, "Must call Init first!" );

    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS((IPrivateUnknown *)this, IUnknown)
    QI_TEAROFF_DISPEX(this, NULL)
    QI_TEAROFF((CBase *)this, IPerPropertyBrowsing, NULL)
    QI_TEAROFF((CBase *)this, IRecalcProperty, NULL)
    QI_TEAROFF(this, IHTMLCurrentStyle, NULL)
    QI_TEAROFF(this, IHTMLCurrentStyle2, NULL)
    QI_TEAROFF(this, IHTMLCurrentStyle3, NULL)
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}


//+----------------------------------------------------------------
//
//  member : get_position
//
//  Synopsis : IHTMLCurrentStyle property. returns the position enum
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_position( BSTR *pbstr )
{
    HRESULT         hr;
    stylePosition   stPos;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)

    stPos = pNodeToUse->GetCascadedposition();
    if(stPos == stylePositionNotSet)
        stPos = stylePositionstatic;

   // get the positioning, and then its string
    hr = THR(STRINGFROMENUM(stylePosition, stPos, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_styleFloat
//
//  Synopsis : IHTMLCurrentStyle property. returns the styleDloatenum
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_styleFloat( BSTR *pbstr )
{
    HRESULT         hr;
    styleStyleFloat stFloat;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)

    stFloat = pNodeToUse->GetCascadedfloat();

    if(stFloat == styleStyleFloatNotSet)
        stFloat = styleStyleFloatNone;

    hr = THR(STRINGFROMENUM(styleStyleFloat, stFloat, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_color
//
//  Synopsis : IHTMLCurrentStyle property. returns the current color
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_color(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()

    hr = THR(GetColorHelper(p, pNodeToUse->GetCascadedcolor()));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_backgroundColor
//
//  Synopsis : IHTMLCurrentStyle property. returns the current backgroundColor
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_backgroundColor(VARIANT * p)
{
    HRESULT      hr;
    CColorValue  colVal;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)
    TCHAR        szBuffer[pdlColor];


    V_VT(p) = VT_EMPTY;
    colVal = pNodeToUse->GetCascadedbackgroundColor();
    if (!colVal.IsDefined())
    {
        hr = THR(colVal.SetValue(0, FALSE, CColorValue::TYPE_TRANSPARENT));
        if (hr)
            goto Cleanup;
    }
    
    hr = THR(colVal.FormatBuffer(szBuffer, ARRAY_SIZE(szBuffer), NULL));
    if(hr)
        goto Cleanup;

    V_VT(p) = VT_BSTR;
    hr = THR(FormsAllocString(szBuffer, &(V_BSTR(p))));
    if (hr)
        goto Cleanup;
        
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_fontFamily
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_fontFamily(BSTR * p)
{
    HRESULT         hr;
    LPCTSTR         pchName;
    VARIANT         varValue;
    CElement *      pElement;

    NODE_IN_TREE_CHECK()
    pElement = pNodeToUse->SafeElement();

    NULLPTRCHECK(p, E_POINTER)
    NULLPTRCHECK(pElement, E_FAIL)

    hr = THR(pElement->ComputeExtraFormat(DISPID_A_FONTFACE, 
                ComputeFormatsType_GetInheritedValue, pNodeToUse, &varValue));
    if(hr)
        goto Cleanup;

    if(((CVariant *)&varValue)->IsEmpty())
    {
        // Return the rendered values

        // Try to get the font name
        pchName = pNodeToUse->GetCascadedfontFaceName();
        if(!pchName  || !(*pchName))
        {
            // Get the generic family name
            pchName = pNodeToUse->GetCascadedfontFamilyName();
            if(!pchName  || !(*pchName))
            {
                *p = NULL;
                hr = S_OK;
                goto Cleanup;
            }
        }
    }
    else
    {
        Assert(V_VT(&varValue) == VT_BSTR || V_VT(&varValue) == VT_LPWSTR);
        pchName = V_BSTR(&varValue);
    }

    hr = THR(FormsAllocString(pchName, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_fontStyle
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_fontStyle(BSTR * p)
{
    HRESULT         hr;
    styleFontStyle  sty;
    VARIANT         varValue;
    CElement *      pElement;
    NODE_IN_TREE_CHECK()
    pElement = pNodeToUse->SafeElement();

    NULLPTRCHECK(pElement, E_FAIL)
    NULLPTRCHECK(p, E_POINTER)

    hr = THR(pElement->ComputeExtraFormat(DISPID_A_FONTSTYLE, 
                ComputeFormatsType_GetInheritedValue, pNodeToUse, &varValue));
    if(hr)
        goto Cleanup;

    if( !((CVariant *)&varValue)->IsEmpty() )
        sty = (styleFontStyle) V_I4(&varValue);
    else
        sty = (pNodeToUse->GetCascadedfontItalic()) ? styleFontStyleItalic : styleFontStyleNormal;

    Assert((pNodeToUse->GetCascadedfontItalic() &&  (sty == styleFontStyleOblique || sty == styleFontStyleItalic) )
            || (!pNodeToUse->GetCascadedfontItalic() && sty != styleFontStyleOblique && sty != styleFontStyleItalic) );

    hr = THR(STRINGFROMENUM(styleFontStyle, sty, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_fontVariant
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_fontVariant(BSTR * p)
{
    HRESULT           hr;
    styleFontVariant  sty;
    VARIANT           varValue;
    CElement *        pElement;
    NODE_IN_TREE_CHECK()
    pElement = pNodeToUse->SafeElement();

    NULLPTRCHECK(pElement, E_FAIL)
    NULLPTRCHECK(p, E_POINTER)

    hr = THR(pElement->ComputeExtraFormat(DISPID_A_FONTVARIANT,
                ComputeFormatsType_GetInheritedValue, pNodeToUse, &varValue));
    if(hr)
        goto Cleanup;

    sty = (((CVariant *)&varValue)->IsEmpty())
                        ? styleFontVariantNormal
                        : (styleFontVariant) V_I4(&varValue);

    hr = THR(STRINGFROMENUM(styleFontVariant, sty, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_fontWeight
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_fontWeight(VARIANT * p)
{
    HRESULT      hr = S_OK;
    WORD         wWeight;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    wWeight = pNodeToUse->GetCascadedfontWeight();
    V_VT(p) = VT_I4;
    V_I4(p) = wWeight;

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_fontSize
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_fontSize(VARIANT * p)
{
    HRESULT      hr = S_OK;
    LONG         lSize;
    CVariant     varValue;
    CElement   * pElement;
    CUnitValue * pVal;
    CUnitValue   cuv;
    NODE_IN_TREE_CHECK()
    pElement = pNodeToUse->SafeElement();

    NULLPTRCHECK(pElement, E_FAIL)
    NULLPTRCHECK(p, E_POINTER)

    // Full font size information is not stored in CF so we need to walk
    //  the element tree and apply the formats
    hr = THR(pElement->ComputeExtraFormat(DISPID_A_FONTSIZE,
                ComputeFormatsType_GetInheritedValue, pNodeToUse, &varValue));
    if(hr)
        goto Cleanup;

    if(varValue.IsEmpty())
    {
        CDoc *pDoc = pNodeToUse->Doc();

        Assert(pDoc);

        lSize = pNodeToUse->GetCharFormat()->GetHeightInTwips(pDoc);

        lSize = MulDivQuick(lSize, 1000, TWIPS_PER_POINT);
        cuv.SetValue(lSize, CUnitValue::UNIT_POINT);

        pVal = &cuv;
    }
   else
    {
        pVal = (CUnitValue*) (void*) &V_I4(&varValue);
    }

   hr = THR(GetUnitValueWithEnum(p, *pVal,
                        &(s_propdescCCurrentStylefontSize.a), styleFontSize));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_layoutGridChar
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_layoutGridChar(VARIANT * p)
{
    HRESULT      hr = S_OK;
    CUnitValue   cuv;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(p, E_POINTER)

    cuv = pNodeToUse->GetCascadedlayoutGridChar();
    hr = THR(GetUnitValueWithEnumDef(p, cuv, 
                                     &(s_propdescCCurrentStylelayoutGridChar.a), styleLayoutGridChar,
                                     styleLayoutGridCharNone));
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_layoutGridLine
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_layoutGridLine(VARIANT * p)
{
    HRESULT      hr = S_OK;
    CUnitValue   cuv;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(p, E_POINTER)

    cuv = pNodeToUse->GetCascadedlayoutGridLine();
    hr = THR(GetUnitValueWithEnumDef(p, cuv, 
                                     &(s_propdescCCurrentStylelayoutGridLine.a), styleLayoutGridLine,
                                     styleLayoutGridLineNone));
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_layoutGridMode
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_layoutGridMode(BSTR * pbstr)
{
    HRESULT         hr;
    styleLayoutGridMode  sty;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(pbstr, E_POINTER)

    sty = pNodeToUse->GetCascadedlayoutGridMode();
        
    hr = THR(STRINGFROMENUM(styleLayoutGridMode, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));

}


//+----------------------------------------------------------------
//
//  member : get_layoutGridType
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_layoutGridType(BSTR * pbstr)
{
    HRESULT         hr;
    styleLayoutGridType  sty;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(pbstr, E_POINTER)

    sty = pNodeToUse->GetCascadedlayoutGridType();
        
    hr = THR(STRINGFROMENUM(styleLayoutGridType, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));

}


//+----------------------------------------------------------------
//
//  member : get_layoutFlow
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_layoutFlow(BSTR * pbstr)
{
    HRESULT         hr;
    styleLayoutFlow  sty;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(pbstr, E_POINTER)

    sty = pNodeToUse->GetCascadedlayoutFlow();
        
    hr = THR(STRINGFROMENUM(styleLayoutFlow, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));

}


//+----------------------------------------------------------------
//
//  member : get_writingMode
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_writingMode(BSTR * pbstr)
{
    HRESULT         hr;
    styleLayoutFlow  styLF;
    styleWritingMode styWM;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(pbstr, E_POINTER)

    styLF = pNodeToUse->GetCascadedlayoutFlow();
    switch(styLF)
    {
    case styleLayoutFlowHorizontal:             styWM = styleWritingModeLrtb; break;
    case styleLayoutFlowVerticalIdeographic:    styWM = styleWritingModeTbrl; break;
    case styleLayoutFlowNotSet:
    default:                                    styWM = styleWritingModeNotSet; break;
    }
        
    hr = THR(STRINGFROMENUM(styleWritingMode, styWM, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

HRESULT
CCurrentStyle::get_hasLayout(VARIANT_BOOL *pfhasLayout)
{
    HRESULT hr = S_OK;
    CElement *pElement;

    NULLPTRCHECK(pfhasLayout, E_POINTER)
    Assert(_pNode && _pNode->Element());

    pElement = _pNode->Element();
    if (pElement->HasMasterPtr())
        pElement = pElement->GetMasterPtr();

    *pfhasLayout = (pElement->ShouldHaveLayout()) ? VB_TRUE : VB_FALSE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CCurrentStyle::get_isBlock(VARIANT_BOOL *pfBlock)
{
    HRESULT hr;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pfBlock, E_POINTER)

    *pfBlock = pNodeToUse->Element()->IsBlockElement() ? VB_TRUE : VB_FALSE; 

    hr = S_OK;

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_zoom
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------
HRESULT
CCurrentStyle::get_zoom(VARIANT * p)
{
    HRESULT    hr = S_OK;
    float      flZoom = 0;
    CUnitValue cuvTemp(0, CUnitValue::UNIT_ENUM);

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    flZoom = pNodeToUse->GetFancyFormat(FCPARAM)->_flZoomFactor;

    if (flZoom !=0)
    {
        flZoom *= CUnitValue::TypeNames[CUnitValue::UNIT_PERCENT].wScaleMult;
        cuvTemp.SetPercent(flZoom);
    }


    hr = THR(GetUnitValueWithEnumDef(p, 
                    cuvTemp,
                    &(s_propdescCCurrentStylezoom.a), styleNormal,
                    styleNormalNormal));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------
//
//  member : get_textUnderlinePosition
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textUnderlinePosition(BSTR * pbstr)
{
    HRESULT         hr;
    styleTextUnderlinePosition  sty;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(pbstr, E_POINTER)

    sty = pNodeToUse->GetCascadedtextUnderlinePosition();
        
    hr = THR(STRINGFROMENUM(styleTextUnderlinePosition, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));

}

//+----------------------------------------------------------------
//
//  member : get_textOverflow
//
//  Synopsis : IHTMLCurrentStyle3 property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textOverflow(BSTR * pbstr)
{
    HRESULT hr;
    styleTextOverflow sty;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(pbstr, E_POINTER)

    sty = pNodeToUse->GetCascadedtextOverflow();
        
    hr = THR(STRINGFROMENUM(styleTextOverflow, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));

}

//+----------------------------------------------------------------
//
//  member : get_whiteSpace
//
//  Synopsis : IHTMLCurrentStyle3 property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_whiteSpace(BSTR * pbstr)
{
    HRESULT hr;
    styleWhiteSpace sty = styleWhiteSpaceNormal;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)

    if (pNodeToUse->GetParaFormat()->_fPreInner)
        sty = styleWhiteSpacePre;
    else if (pNodeToUse->GetCharFormat()->_fNoBreak)
        sty = styleWhiteSpaceNowrap;

    hr = THR(STRINGFROMENUM(styleWhiteSpace, sty, pbstr));
        
Cleanup:
    RRETURN(SetErrorInfo( hr ));

}


//+----------------------------------------------------------------
//
//  member : get_backgroundImage
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_backgroundImage(BSTR * p)
{
    HRESULT      hr;
    long         lCookie;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    lCookie = pNodeToUse->GetCascadedbackgroundImageCookie();

    if(lCookie != 0)
    {
        hr = THR(GetImageNameFromCookie(lCookie, p));
    }
    else
    {
        hr = THR(FormsAllocString(_T("none"), p));
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_backgroundPositionX
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_backgroundPositionX(VARIANT * p)
{
    HRESULT         hr;
    VARIANT         varValue;
    CUnitValue      uvBkgnd;
    CElement *      pElement;
    NODE_IN_TREE_CHECK()
    pElement = pNodeToUse->SafeElement();

    NULLPTRCHECK(pElement, E_FAIL)
    NULLPTRCHECK(p, E_POINTER)

    // Information is modified before being stored in CF/PF/FF so we need to walk
    //  the element tree and apply the formats in a special mode to get the original value
    hr = THR(pElement->ComputeExtraFormat(DISPID_A_BACKGROUNDPOSX,
                ComputeFormatsType_GetValue, pNodeToUse, &varValue));
    if(hr)
        goto Cleanup;

    if(((CVariant *)&varValue)->IsEmpty())
        uvBkgnd.SetRawValue(MAKEUNITVALUE(0, UNIT_PERCENT));
    else
        uvBkgnd = *(CUnitValue *)&V_I4(&varValue);

    hr = GetUnitValueWithEnum(p, uvBkgnd,
        &(s_propdescCCurrentStylebackgroundPositionX.a), styleBackgroundPositionX);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------
//
//  member : get_backgroundPositionY
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_backgroundPositionY(VARIANT * p)
{
    HRESULT         hr;
    VARIANT         varValue;
    CUnitValue      uvBkgnd;
    CElement *      pElement;
    NODE_IN_TREE_CHECK()
    pElement = pNodeToUse->SafeElement();

    NULLPTRCHECK(pElement, E_FAIL)
    NULLPTRCHECK(p, E_POINTER)

    // Information is modified before being stored in CF/PF/FF so we need to walk
    //  the element tree and apply the formats in a special mode to get the original value
    hr = THR(pElement->ComputeExtraFormat(DISPID_A_BACKGROUNDPOSY,
                ComputeFormatsType_GetValue, pNodeToUse, &varValue));
    if(hr)
        goto Cleanup;

    if(((CVariant *)&varValue)->IsEmpty())
        uvBkgnd.SetRawValue(MAKEUNITVALUE(0, UNIT_PERCENT));
    else
        uvBkgnd = *(CUnitValue *)&V_I4(&varValue);

    hr = GetUnitValueWithEnum(p, uvBkgnd,
        &(s_propdescCCurrentStylebackgroundPositionY.a), styleBackgroundPositionY);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------
//
//  member : get_backgroundRepeat
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_backgroundRepeat(BSTR * p)
{
    HRESULT                 hr;
    BOOL                    fRepeatX, fRepeatY;
    styleBackgroundRepeat   eBr;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    fRepeatX = pNodeToUse->GetCascadedbackgroundRepeatX();
    fRepeatY = pNodeToUse->GetCascadedbackgroundRepeatY();

    if(fRepeatX)
        if(fRepeatY)
            eBr = styleBackgroundRepeatRepeat;
        else
            eBr = styleBackgroundRepeatRepeatX;
    else
        if(fRepeatY)
            eBr = styleBackgroundRepeatRepeatY;
        else
            eBr = styleBackgroundRepeatNoRepeat;

    // Convert to string
    hr = THR(STRINGFROMENUM( styleBackgroundRepeat, eBr, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_borderLeftColor
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderLeftColor(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CColorValue cv = pNodeToUse->GetCascadedborderLeftColor();
        if(!cv.IsDefined())
            cv = pNodeToUse->GetCascadedcolor();

        hr = THR(GetColorHelper(p, cv));
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+----------------------------------------------------------------
//
//  member : get_borderTopColor
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderTopColor(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetColorHelper(p, pNodeToUse->GetCascadedborderTopColor()));
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_borderRightColor
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderRightColor(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetColorHelper(p, pNodeToUse->GetCascadedborderRightColor()));
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_borderBottomColor
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderBottomColor(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    
    hr = THR(GetColorHelper(p, pNodeToUse->GetCascadedborderBottomColor()));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+----------------------------------------------------------------
//
//  member : get_borderTopStyle
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderTopStyle(BSTR * p)
{
    HRESULT             hr;
    styleBorderStyle    bdrStyle;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    bdrStyle = GetBorderStyle(SIDE_TOP);

    hr = THR(STRINGFROMENUM(styleBorderStyle, bdrStyle, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_borderRightStyle
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderRightStyle(BSTR * p)
{
    HRESULT             hr;
    styleBorderStyle    bdrStyle;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    bdrStyle = GetBorderStyle(SIDE_RIGHT);

    hr = THR(STRINGFROMENUM(styleBorderStyle, bdrStyle, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_borderBottomStyle
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderBottomStyle(BSTR * p)
{
    HRESULT             hr;
    styleBorderStyle    bdrStyle;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    bdrStyle = GetBorderStyle(SIDE_BOTTOM);

    hr = THR(STRINGFROMENUM(styleBorderStyle, bdrStyle, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_borderLeftStyle
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderLeftStyle(BSTR * p)
{
    HRESULT             hr;
    styleBorderStyle    bdrStyle;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    bdrStyle = GetBorderStyle(SIDE_LEFT);

    hr = THR(STRINGFROMENUM(styleBorderStyle, bdrStyle, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_borderTopWidth
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderTopWidth(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvWidth = pNodeToUse->GetCascadedborderTopWidth();

        hr = THR(GetUnitValueWithEnumDef(p, uvWidth,
                            &(s_propdescCCurrentStyleborderTopWidth.a),
                            styleBorderWidth, styleBorderWidthMedium));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_borderRightWidth
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderRightWidth(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvWidth = pNodeToUse->GetCascadedborderRightWidth();

        hr = THR(GetUnitValueWithEnumDef(p, uvWidth,
                            &(s_propdescCCurrentStyleborderRightWidth.a),
                            styleBorderWidth, styleBorderWidthMedium));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_borderBottomWidth
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderBottomWidth(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvWidth = pNodeToUse->GetCascadedborderBottomWidth();

        hr = THR(GetUnitValueWithEnumDef(p, uvWidth,
            &(s_propdescCCurrentStyleborderBottomWidth.a),
                            styleBorderWidth, styleBorderWidthMedium));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_borderLeftWidth
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderLeftWidth(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvWidth = pNodeToUse->GetCascadedborderLeftWidth();

        hr = THR(GetUnitValueWithEnumDef(p, uvWidth,
                        &(s_propdescCCurrentStyleborderLeftWidth.a),
                            styleBorderWidth, styleBorderWidthMedium));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_left
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_left(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnumDef(p, pNodeToUse->GetCascadedleft(),
        &(s_propdescCCurrentStyleleft.a), styleAuto, styleAutoAuto));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_right
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_right(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnumDef(p, pNodeToUse->GetCascadedright(), 
                &(s_propdescCCurrentStyleright.a), styleAuto, styleAutoAuto));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_top
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_top(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnumDef(p, pNodeToUse->GetCascadedtop(),
        &(s_propdescCCurrentStyletop.a), styleAuto, styleAutoAuto));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_bottom
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_bottom(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnumDef(p, pNodeToUse->GetCascadedbottom(), 
         &(s_propdescCCurrentStylebottom.a), styleAuto, styleAutoAuto));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_width
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_width(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnumDef(p, pNodeToUse->GetCascadedwidth(),
        &(s_propdescCCurrentStylewidth.a), styleAuto, styleAutoAuto));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_height
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_height(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnumDef(p, pNodeToUse->GetCascadedheight(),
        &(s_propdescCCurrentStyleheight.a), styleAuto, styleAutoAuto));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_minHeight
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_minHeight(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnumDef(p, pNodeToUse->GetCascadedminHeight(),
        &(s_propdescCCurrentStyleminHeight.a), styleAuto, styleAutoAuto));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_paddingLeft
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_paddingLeft(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvPad = pNodeToUse->GetCascadedpaddingLeft();

        if(uvPad.IsNull())
            uvPad.SetRawValue(MAKEUNITVALUE(0, UNIT_PIXELS));

        hr = THR(GetUnitValueHelper(p, uvPad,
                        &(s_propdescCCurrentStylepaddingLeft.a)));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_paddingTop
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_paddingTop(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvPad = pNodeToUse->GetCascadedpaddingTop();

        if(uvPad.IsNull())
            uvPad.SetRawValue(MAKEUNITVALUE(0, UNIT_PIXELS));

        hr = THR(GetUnitValueHelper(p, uvPad,
                        &(s_propdescCCurrentStylepaddingTop.a)));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_paddingRight
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_paddingRight(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvPad = pNodeToUse->GetCascadedpaddingRight();

        if(uvPad.IsNull())
            uvPad.SetRawValue(MAKEUNITVALUE(0, UNIT_PIXELS));

        hr = THR(GetUnitValueHelper(p, uvPad,
                        &(s_propdescCCurrentStylepaddingRight.a)));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_paddingBottom
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_paddingBottom(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvPad = pNodeToUse->GetCascadedpaddingBottom();

        if(uvPad.IsNull())
            uvPad.SetRawValue(MAKEUNITVALUE(0, UNIT_PIXELS));

        hr = THR(GetUnitValueHelper(p, uvPad,
                        &(s_propdescCCurrentStylepaddingBottom.a)));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_textAlign
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textAlign(BSTR * p)
{
    HRESULT         hr;
    htmlBlockAlign  align;
    styleDir        dir;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(p, E_POINTER)

    align = pNodeToUse->GetCascadedblockAlign();
    dir   = pNodeToUse->GetCascadedBlockDirection();

    // The default value is left align if LTR and right align if RTL
    if(align == htmlBlockAlignNotSet)
    {
        if(dir == styleDirLeftToRight)
           align = htmlBlockAlignLeft;
        else
           align = htmlBlockAlignRight;
    }

    hr = THR(STRINGFROMENUM(htmlBlockAlign, align, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_textAlignLast
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textAlignLast(BSTR * p)
{
    HRESULT         hr;
    styleTextAlignLast alignLast;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(p, E_POINTER)

    alignLast = pNodeToUse->GetCascadedtextAlignLast();

    // The default value is left align if LTR and right align if RTL
    if(alignLast == styleTextAlignLastNotSet)
    {
        alignLast = styleTextAlignLastAuto;
    }

    hr = THR(STRINGFROMENUM(styleTextAlignLast, alignLast, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_textDecoration
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textDecoration(BSTR * p)
{
    HRESULT         hr;
    textDecoration  td;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    if(pNodeToUse->GetCascadedunderline())
        td = textDecorationUnderline;
    else if(pNodeToUse->GetCascadedoverline())
        td = textDecorationOverline;
    else if(pNodeToUse->GetCascadedstrikeOut())
        td = textDecorationLineThrough;
    else
        td = textDecorationNone;

    hr = THR(STRINGFROMENUM(textDecoration, td, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_accelerator
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_accelerator(BSTR * p)
{
    HRESULT         hr;
    styleAccelerator sa;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    sa = pNodeToUse->GetCascadedaccelerator();

    hr = THR(STRINGFROMENUM(styleAccelerator, sa, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_display
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_display(BSTR * p)
{
    HRESULT      hr;
    styleDisplay sd;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    sd = pNodeToUse->GetCascadeddisplay();
    if(sd == styleDisplayNotSet)
    {
        Assert(pNodeToUse->_iFF != -1);
        sd = pNodeToUse->_fBlockNess ? styleDisplayBlock : styleDisplayInline;
    }

    hr = THR(STRINGFROMENUM(styleDisplay, sd, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_visibility
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_visibility(BSTR * p)
{
    HRESULT         hr;
    styleVisibility sv;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    sv = (styleVisibility)pNodeToUse->GetFancyFormat()->_bVisibility;
    if (sv == styleVisibilityNotSet)
        sv = styleVisibilityInherit;

    hr = THR(STRINGFROMENUM(styleVisibility, sv, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_zIndex
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_zIndex(VARIANT * p)
{
    HRESULT      hr = S_OK;
    long         lVal;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    lVal = pNodeToUse->GetCascadedzIndex();
    V_I4(p) = lVal;
    V_VT(p) = VT_I4;

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_letterSpacing
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_letterSpacing(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnumDef(p, pNodeToUse->GetCascadedletterSpacing(),
                    &(s_propdescCCurrentStyleletterSpacing.a), styleNormal,
                    styleNormalNormal));
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_wordSpacing
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_wordSpacing(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnumDef(p, pNodeToUse->GetCascadedwordSpacing(),
                    &(s_propdescCCurrentStylewordSpacing.a), styleNormal,
                    styleNormalNormal));
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_lineHeight
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_lineHeight(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue valHeight = pNodeToUse->GetCascadedlineHeight();
        hr = THR(GetUnitValueWithEnumDef(p, valHeight,
                    &(s_propdescCCurrentStylelineHeight.a), styleNormal,
                    styleNormalNormal));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_textIndent
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textIndent(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvIndent = pNodeToUse->GetCascadedtextIndent();

        if(uvIndent.IsNull())
            uvIndent.SetRawValue(MAKEUNITVALUE(0, UNIT_POINT));

        hr = THR(GetUnitValueHelper(p, uvIndent,
                        &(s_propdescCCurrentStyletextIndent.a)));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_verticalAlign
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_verticalAlign(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvVA = pNodeToUse->GetCascadedverticalAlign();
        hr = THR(GetUnitValueWithEnum(p, uvVA, &(s_propdescCCurrentStyleverticalAlign.a), styleVerticalAlign));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_backgroundAttachment
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_backgroundAttachment(BSTR * p)
{
    HRESULT                     hr;
    styleBackgroundAttachment   eBA;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    eBA = (pNodeToUse->GetCascadedbackgroundAttachmentFixed()) ?
            styleBackgroundAttachmentFixed : styleBackgroundAttachmentScroll;

    // Convert to string
    hr = THR(STRINGFROMENUM(styleBackgroundAttachment, eBA, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
 //  member : get_marginTop
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_marginTop(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvMargin = pNodeToUse->GetCascadedmarginTop();

        hr = THR(GetUnitValueWithEnumDef(p, uvMargin,
            &(s_propdescCCurrentStylemarginTop.a), styleAuto, styleAutoAuto));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_marginRight
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_marginRight(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvMargin = pNodeToUse->GetCascadedmarginRight();

        hr = THR(GetUnitValueWithEnumDef(p, uvMargin,
            &(s_propdescCCurrentStylemarginRight.a), styleAuto, styleAutoAuto));
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_marginBottom
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_marginBottom(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvMargin = pNodeToUse->GetCascadedmarginBottom();

        hr = THR(GetUnitValueWithEnumDef(p, uvMargin,
            &(s_propdescCCurrentStylemarginBottom.a), styleAuto, styleAutoAuto));
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_marginLeft
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_marginLeft(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvMargin = pNodeToUse->GetCascadedmarginLeft();

        hr = THR(GetUnitValueWithEnumDef(p, uvMargin,
            &(s_propdescCCurrentStylemarginLeft.a), styleAuto, styleAutoAuto));
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_clear
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_clear(BSTR * p)
{
    HRESULT       hr;
    BOOL          fClearLeft, fClearRight;
    htmlClear     eClr;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    fClearLeft = pNodeToUse->GetCascadedclearLeft();
    fClearRight = pNodeToUse->GetCascadedclearRight();

    if(fClearLeft)
        if(fClearRight)
            eClr = htmlClearBoth;
        else
            eClr = htmlClearLeft;
    else
        if(fClearRight)
            eClr = htmlClearRight;
        else
            eClr = htmlClearNone;

    // Convert to string
    hr = THR(STRINGFROMENUM(htmlClear, eClr, p));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_listStyleType
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_listStyleType(BSTR * pbstr)
{
    HRESULT             hr;
    styleListStyleType  slt;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)


    slt = pNodeToUse->GetCascadedlistStyleType();

    if (slt == styleListStyleTypeNotSet)
       slt = styleListStyleTypeDisc;

    hr = THR(STRINGFROMENUM(styleListStyleType, slt, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_listStylePosition
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_listStylePosition(BSTR * pbstr)
{
    HRESULT hr;
    styleListStylePosition slsp;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)


    slsp = pNodeToUse->GetCascadedlistStylePosition();
    if(slsp == styleListStylePositionNotSet)
        slsp = styleListStylePositionOutSide;

    hr = THR(STRINGFROMENUM(styleListStylePosition, slsp, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_listStyleImage
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_listStyleImage(BSTR * p)
{
    HRESULT      hr;
    long         lCookie;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)

    lCookie = pNodeToUse->GetCascadedlistImageCookie();

    if(lCookie == 0)
    {
        hr = THR(FormsAllocString(_T("none"), p));
    }
    else
    {
        hr = THR(GetImageNameFromCookie(lCookie, p));
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_clipTop
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_clipTop(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnum(p, pNodeToUse->GetCascadedclipTop(),
                    &(s_propdescCCurrentStyleclipTop.a), styleAuto));
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_clipRight
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_clipRight(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnum(p, pNodeToUse->GetCascadedclipRight(),
                    &(s_propdescCCurrentStyleclipRight.a), styleAuto));
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_clipBottom
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_clipBottom(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = THR(GetUnitValueWithEnum(p, pNodeToUse->GetCascadedclipBottom(),
                    &(s_propdescCCurrentStyleclipBottom.a), styleAuto));
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_clipLeft
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_clipLeft(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    hr = (GetUnitValueWithEnum(p, pNodeToUse->GetCascadedclipLeft(),
                    &(s_propdescCCurrentStyleclipLeft.a), styleAuto));
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_clipLeft
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_overflow(BSTR * pbstr)
{
    HRESULT         hr;
    styleOverflow   stO;
    CElement *pElement;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)

    pElement = pNodeToUse->Element();
    Assert(pElement);
    if (pElement->HasMasterPtr())
    {
        pElement = pElement->GetMasterPtr();
        Assert(pElement);
        pNodeToUse = pElement->GetFirstBranch();
        Assert(pNodeToUse);
    }

    stO = pNodeToUse->GetCascadedoverflow();

    if(stO == styleOverflowNotSet)
    {
        CDispNode *pDispNode = NULL;
        CFlowLayout *pLayout = pNodeToUse->HasFlowLayout();
        if (pLayout)
            pDispNode = pLayout->GetElementDispNode();
    
        stO = (pLayout && pDispNode && pDispNode->IsScroller()) ? styleOverflowScroll : styleOverflowVisible;
    }

    hr = THR(STRINGFROMENUM(styleOverflow, stO, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_pageBreakBefore
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_pageBreakBefore(BSTR * pbstr)
{
    HRESULT         hr;
    stylePageBreak  stpb;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)


    stpb = pNodeToUse->GetCascadedpageBreakBefore();

    // When not set the default value is auto
    if(stpb == stylePageBreakNotSet)
        stpb = stylePageBreakAuto;

    hr = THR(STRINGFROMENUM(stylePageBreak, stpb, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_pageBreakAfter
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_pageBreakAfter(BSTR * pbstr)
{
    HRESULT hr;
    stylePageBreak  stpb;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)


    stpb = pNodeToUse->GetCascadedpageBreakAfter();

    // When not set the default value is auto
    if(stpb == stylePageBreakNotSet)
        stpb = stylePageBreakAuto;

    hr = THR(STRINGFROMENUM(stylePageBreak, stpb, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_cursor
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_cursor(BSTR * pbstr)
{
    HRESULT hr = S_OK  ;
    styleCursor scCursor;
    
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)

    scCursor = pNodeToUse->GetCascadedcursor();
    if ( scCursor == styleCursorcustom )
    {
        CCustomCursor* pCustom = GetCustomCursorForNode(pNodeToUse);
        Assert( pCustom );
        if ( pCustom )
        {
            CStr currentUrl, cstrResult;
            BOOL fContainsPeriod = FALSE;
            pCustom->GetCurrentUrl( & currentUrl );
            TCHAR* pch = (LPTSTR) currentUrl;
            size_t nLen = pch ? _tcslen(pch) : 0 ;

            while (nLen--)
            {
                if (0==_tcsnicmp(pch, 1, _T("."), 1))
                {
                    fContainsPeriod = TRUE;
                    break;
                }
                pch++;
            }

            if ( fContainsPeriod )
            {
                hr = THR( UnMungeCustomUrl( & currentUrl, & cstrResult ));
                if ( hr )
                    goto Cleanup;

                hr = THR( cstrResult.AllocBSTR( pbstr ));                
            }
            else
            {
                hr = THR( currentUrl.AllocBSTR( pbstr ));                
            }
        }
       
    }
    else
    {
        hr = THR(STRINGFROMENUM(styleCursor, scCursor , pbstr));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_tableLayout
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_tableLayout(BSTR * pbstr)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)


    hr = THR(STRINGFROMENUM(styleTableLayout, pNodeToUse->GetCascadedtableLayoutEnum(), pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_borderCollapse
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_borderCollapse (BSTR * pbstr)
{
    HRESULT hr;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)

    hr = THR(STRINGFROMENUM(styleBorderCollapse, pNodeToUse->GetCascadedborderCollapseEnum(), pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_blockDirection
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_blockDirection(BSTR * pbstr)
{
    HRESULT hr;
    
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)

    
    hr = THR(STRINGFROMENUM(styleDir, pNodeToUse->GetCascadedBlockDirection(), pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_direction
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_direction(BSTR * pbstr)
{
    HRESULT hr;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)


    hr = THR(STRINGFROMENUM(styleDir, pNodeToUse->GetCascadeddirection(), pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_unicodeBidi
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_unicodeBidi(BSTR * pbstr)
{
    HRESULT hr;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)

    hr = THR(STRINGFROMENUM(styleBidi,pNodeToUse->GetCascadedunicodeBidi(), pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_imeMode
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_imeMode(BSTR * pbstr)
{
    HRESULT         hr;
    styleImeMode    sty;

    NULLPTRCHECK(pbstr, E_POINTER)

    hr = THR(ComputeLongExtraFormat(DISPID_A_IMEMODE, 
            ComputeFormatsType_GetInheritedValue, 
            (long)styleImeModeNotSet, (long *)&sty));
    if(hr)
        goto Cleanup;
    hr = THR(STRINGFROMENUM(styleImeMode, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));

}


//+----------------------------------------------------------------
//
//  member : get_rubyAlign
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_rubyAlign(BSTR * pbstr)
{
    HRESULT         hr;
    styleRubyAlign  sty;

    NULLPTRCHECK(pbstr, E_POINTER)

    hr = THR(ComputeLongExtraFormat(DISPID_A_RUBYALIGN, 
            ComputeFormatsType_GetInheritedValue, 
            (long)styleRubyAlignAuto, (long *)&sty));
    if(hr)
        goto Cleanup;
    hr = THR(STRINGFROMENUM(styleRubyAlign, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));

}


//+----------------------------------------------------------------
//
//  member : get_rubyPosition
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_rubyPosition(BSTR * pbstr)
{
    HRESULT         hr;
    styleRubyPosition  sty;

    NULLPTRCHECK(pbstr, E_POINTER)

    hr = THR(ComputeLongExtraFormat(DISPID_A_RUBYPOSITION, 
            ComputeFormatsType_GetInheritedValue, 
            (long)styleRubyPositionAbove, (long *)&sty));
    if(hr)
        goto Cleanup;
    hr = THR(STRINGFROMENUM(styleRubyPosition, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_rubyOverhang
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_rubyOverhang(BSTR * pbstr)
{
    HRESULT            hr;
    styleRubyOverhang  sty;

    NULLPTRCHECK(pbstr, E_POINTER)

    hr = THR(ComputeLongExtraFormat(DISPID_A_RUBYOVERHANG, 
            ComputeFormatsType_GetInheritedValue, 
            (long)styleRubyOverhangAuto, (long *)&sty));
    if(hr)
        goto Cleanup;
    hr = THR(STRINGFROMENUM(styleRubyOverhang, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_textAutospace
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textAutospace(BSTR * pbstr)
{
    HRESULT hr = S_OK;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(pbstr, E_POINTER)
    hr = WriteTextAutospaceFromLongToBSTR(pNodeToUse->GetCascadedtextAutospace(), pbstr, TRUE);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_wordBreak
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_wordBreak(BSTR * pbstr)
{
    HRESULT hr;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)

    hr = THR(STRINGFROMENUM(styleWordBreak, pNodeToUse->GetCascadedwordBreak(), pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_wordWrap
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_wordWrap(BSTR * pbstr)
{
    HRESULT hr;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)

    hr = THR(STRINGFROMENUM(styleWordWrap, pNodeToUse->GetCascadedwordWrap(), pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_lineBreak
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_lineBreak(BSTR * pbstr)
{
    HRESULT            hr;
    styleLineBreak     sty;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(pbstr, E_POINTER)

    sty = pNodeToUse->GetCascadedlineBreak();
    hr = THR(STRINGFROMENUM(styleLineBreak, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_textJustify
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textJustify(BSTR * pbstr)
{
    HRESULT          hr;
    styleTextJustify just;
    htmlBlockAlign   align;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER);

    align = pNodeToUse->GetCascadedblockAlign();

    if (align == htmlBlockAlignJustify)
    {
        just = pNodeToUse->GetCascadedtextJustify();
        if(just == styleTextJustifyNotSet)
            just = styleTextJustifyAuto;
    }
    else
    {
        just = styleTextJustifyAuto;
    }
            
    hr = THR(STRINGFROMENUM(styleTextJustify, just, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+----------------------------------------------------------------
//
//  member : get_textJustifyTrim
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textJustifyTrim(BSTR * pbstr)
{
    HRESULT              hr;
    styleTextJustifyTrim trim;
    htmlBlockAlign       align;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER)

    align = pNodeToUse->GetCascadedblockAlign();

    if (align == htmlBlockAlignJustify)
    {
        trim = pNodeToUse->GetCascadedtextJustifyTrim();
    }
    else
    {
        trim = styleTextJustifyTrimNotSet;
    }
    
    hr = THR(STRINGFROMENUM(styleTextJustifyTrim, trim, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+----------------------------------------------------------------
//
//  member : get_textKashida
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textKashida(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvKashida = pNodeToUse->GetCascadedtextKashida();

        if(uvKashida.IsNull())
            uvKashida.SetRawValue(MAKEUNITVALUE(0, UNIT_POINT));

        hr = THR(GetUnitValueHelper(p, uvKashida,
                        &(s_propdescCCurrentStyletextKashida.a)));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+----------------------------------------------------------------
//
//  member : get_textKashidaSpace
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textKashidaSpace(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CUnitValue uvKashidaSpace = pNodeToUse->GetCascadedtextKashidaSpace();

        if(uvKashidaSpace.IsNull())
            uvKashidaSpace.SetRawValue(MAKEUNITVALUE(0, UNIT_POINT));

        hr = THR(GetUnitValueHelper(p, uvKashidaSpace,
                        &(s_propdescCCurrentStyletextKashidaSpace.a)));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+----------------------------------------------------------------
//
//  member   : get_borderColor
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT 
CCurrentStyle::get_borderColor(BSTR * p)
{
    HRESULT             hr;
    CVariant            varTop, varRight, varBottom, varLeft;

    NULLPTRCHECK(p, E_POINTER)
    *p = NULL;

    hr = THR(get_borderTopColor(&varTop));
    if(hr)
        goto Cleanup;

    hr = THR(get_borderRightColor(&varRight));
    if(hr)
        goto Cleanup;

    hr = THR(get_borderBottomColor(&varBottom));
    if(hr)
        goto Cleanup;

    hr = THR(get_borderLeftColor(&varLeft));
    if(hr)
        goto Cleanup;

    hr = THR(GetCompositBSTR(&varTop, &varRight, &varBottom, &varLeft, p));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------
//
//  member   : get_borderWidth
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT 
CCurrentStyle::get_borderWidth(BSTR * p)
{
    HRESULT             hr;
    CVariant            varTop, varRight, varBottom, varLeft;

    NULLPTRCHECK(p, E_POINTER)
    *p = NULL;

    hr = THR(get_borderTopWidth(&varTop));
    if(hr)
        goto Cleanup;

    hr = THR(get_borderRightWidth(&varRight));
    if(hr)
        goto Cleanup;

    hr = THR(get_borderBottomWidth(&varBottom));
    if(hr)
        goto Cleanup;

    hr = THR(get_borderLeftWidth(&varLeft));
    if(hr)
        goto Cleanup;

    hr = THR(GetCompositBSTR(&varTop, &varRight, &varBottom, &varLeft, p));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------
//
//  member : get_padding
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT 
CCurrentStyle::get_padding(BSTR * p)
{
    HRESULT             hr;
    CVariant            varTop, varRight, varBottom, varLeft;

    NULLPTRCHECK(p, E_POINTER)
    *p = NULL;

    hr = THR(get_paddingTop(&varTop));
    if(hr)
        goto Cleanup;

    hr = THR(get_paddingRight(&varRight));
    if(hr)
        goto Cleanup;

    hr = THR(get_paddingBottom(&varBottom));
    if(hr)
        goto Cleanup;

    hr = THR(get_paddingLeft(&varLeft));
    if(hr)
        goto Cleanup;

    hr = THR(GetCompositBSTR(&varTop, &varRight, &varBottom, &varLeft, p));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------
//
//  member : get_padding
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT 
CCurrentStyle::get_margin(BSTR * p)
{
    HRESULT             hr;
    CVariant            varTop, varRight, varBottom, varLeft;

    NULLPTRCHECK(p, E_POINTER)
    *p = NULL;

    hr = THR(get_marginTop(&varTop));
    if(hr)
        goto Cleanup;

    hr = THR(get_marginRight(&varRight));
    if(hr)
        goto Cleanup;

    hr = THR(get_marginBottom(&varBottom));
    if(hr)
        goto Cleanup;

    hr = THR(get_marginLeft(&varLeft));
    if(hr)
        goto Cleanup;

    hr = THR(GetCompositBSTR(&varTop, &varRight, &varBottom, &varLeft, p));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------
//
//  member   : get_borderStyle
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT 
CCurrentStyle::get_borderStyle(BSTR * p)
{
    HRESULT             hr;
    styleBorderStyle    bdrStyle;
    LPCTSTR             strTop, strRight, strBottom, strLeft;

    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(p, E_POINTER)
    *p = NULL;
    
    bdrStyle = GetBorderStyle(SIDE_TOP);
    strTop = STRINGPTRFROMENUM(styleBorderStyle, bdrStyle);
    if(!strTop)
        goto Error;

    bdrStyle = GetBorderStyle(SIDE_RIGHT);
    strRight = STRINGPTRFROMENUM(styleBorderStyle, bdrStyle);
    if(!strRight)
        goto Error;

    bdrStyle = GetBorderStyle(SIDE_BOTTOM);
    strBottom = STRINGPTRFROMENUM(styleBorderStyle, bdrStyle);
    if(!strBottom)
        goto Error;

    bdrStyle = GetBorderStyle(SIDE_LEFT);
    strLeft = STRINGPTRFROMENUM(styleBorderStyle, bdrStyle);
    if(!strLeft)
        goto Error;

    hr = THR(GetCompositBSTR(strTop, strRight, strBottom, strLeft, p));

Cleanup:
    RRETURN(SetErrorInfo(hr));

Error:
    hr = E_INVALIDARG;
    goto Cleanup;
}


//+----------------------------------------------------------------
//
//  member : get_overflowX
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_overflowX(BSTR * pbstr)
{
    HRESULT            hr;
    styleOverflow      sty;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(pbstr, E_POINTER)

    sty = pNodeToUse->GetCascadedoverflowX();
    if(sty == styleOverflowNotSet)
        sty = styleOverflowVisible;
    hr = THR(STRINGFROMENUM(styleOverflow, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+----------------------------------------------------------------
//
//  member : get_overflowY
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_overflowY(BSTR * pbstr)
{
    HRESULT            hr;
    styleOverflow      sty;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(pbstr, E_POINTER)

    sty = pNodeToUse->GetCascadedoverflowY();
    if(sty == styleOverflowNotSet)
        sty = styleOverflowVisible;
    hr = THR(STRINGFROMENUM(styleOverflow, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+----------------------------------------------------------------
//
//  member : get_textTransform
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_textTransform(BSTR * pbstr)
{
    HRESULT            hr;
    styleTextTransform sty;
    NODE_IN_TREE_CHECK()

    NULLPTRCHECK(pbstr, E_POINTER)

    sty = pNodeToUse->GetCascadedtextTransform();
    if(sty == styleTextTransformNotSet)
        sty = styleTextTransformNone;
    hr = THR(STRINGFROMENUM(styleTextTransform, sty, pbstr));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_scrollbarTrackColor
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_scrollbarTrackColor(VARIANT * p)
{
    HRESULT hr = S_OK;
    NODE_IN_TREE_CHECK()
    {
        CColorValue cv = pNodeToUse->GetScrollbarTrackColor();

        if(cv.IsDefined())
        {
            hr = THR(GetColorHelper(p, cv));
        }
        else
        {
            // We return empty string if it is not set (the default is generated and dithered)
            V_VT(p) = VT_BSTR;
            V_BSTR(p) = NULL;
        }

    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_scrollbarBaseColor
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------
HRESULT
CCurrentStyle::get_scrollbarBaseColor(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CColorValue cv = pNodeToUse->GetScrollbarBaseColor();
        if(!cv.IsDefined())
        {
            CScrollbarThreeDColors  colors(pNodeToUse);
            if(colors.IsBaseColorSet())
                cv.SetValue(colors.GetBaseColor(), FALSE);
        }

        hr = THR(GetColorHelper(p, cv));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+----------------------------------------------------------------
//
//  member : get_scrollbarFaceColor
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------
HRESULT
CCurrentStyle::get_scrollbarFaceColor(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CColorValue cv = pNodeToUse->GetScrollbarFaceColor();
        if(!cv.IsDefined())
        {
            CScrollbarThreeDColors  colors(pNodeToUse);
            cv.SetValue(colors.BtnFace(), FALSE);
        }

        hr = THR(GetColorHelper(p, cv));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_scrollbar3dLightColor
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------
HRESULT
CCurrentStyle::get_scrollbar3dLightColor(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CColorValue cv = pNodeToUse->GetScrollbar3dLightColor();
        if(!cv.IsDefined())
        {
            CScrollbarThreeDColors  colors(pNodeToUse);
            cv.SetValue(colors.BtnLight(), FALSE);
        }

        hr = THR(GetColorHelper(p, cv));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_scrollbarShadowColor
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------
HRESULT
CCurrentStyle::get_scrollbarShadowColor(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CColorValue cv = pNodeToUse->GetScrollbarShadowColor();
        if(!cv.IsDefined())
        {
            CScrollbarThreeDColors  colors(pNodeToUse);
            cv.SetValue(colors.BtnShadow(), FALSE);
        }

        hr = THR(GetColorHelper(p, cv));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : get_scrollbarHighlightColor
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------
HRESULT
CCurrentStyle::get_scrollbarHighlightColor(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CColorValue cv = pNodeToUse->GetScrollbarHighlightColor();
        if(!cv.IsDefined())
        {
            CScrollbarThreeDColors  colors(pNodeToUse);
            cv.SetValue(colors.BtnHighLight(), FALSE);
        }

        hr = THR(GetColorHelper(p, cv));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_scrollbarDarkShadowColor
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------
HRESULT
CCurrentStyle::get_scrollbarDarkShadowColor(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CColorValue cv = pNodeToUse->GetScrollbarDarkShadowColor();
        if(!cv.IsDefined())
        {
            CScrollbarThreeDColors  colors(pNodeToUse);
            cv.SetValue(colors.BtnDkShadow(), FALSE);
        }

        hr = THR(GetColorHelper(p, cv));
    }
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_scrollbarArrowColor
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------
HRESULT
CCurrentStyle::get_scrollbarArrowColor(VARIANT * p)
{
    HRESULT hr;
    NODE_IN_TREE_CHECK()
    {
        CColorValue cv = pNodeToUse->GetScrollbarArrowColor();
        if(!cv.IsDefined())
        {
            CScrollbarThreeDColors  colors(pNodeToUse);
            cv.SetValue(colors.BtnArrowColor(), FALSE);
        }

        hr = THR(GetColorHelper(p, cv));
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------
//
//  member : get_filter
//
//  Synopsis : IHTMLCurrentStyle2 property
//
//+----------------------------------------------------------------
HRESULT
CCurrentStyle::get_filter(BSTR * pBStr)
{
    HRESULT hr;
    LPCTSTR szFiltStr;

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pBStr, E_POINTER)
    szFiltStr = pNodeToUse->GetFancyFormat(FCPARAM)->_pszFilters;
    hr = THR(FormsAllocString(szFiltStr, pBStr));
    
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------
//
//  member : GetCompositBSTR
//
//  Synopsis : Returns the string that represents the value of a 
//               border property
//              Here are the rules:
//
//            If there is only one value, it applies to all sides. 
//            If there are two values, the top and bottom are set to the 
//              first value and the right and left are set to the second. 
//            If there are three values, the top is set to the first value, 
//              the left and right are set to the second, and the bottom is 
//              set to the third. 
//            If there are four values, they apply to the top, right, bottom,
//               and left, respectively. 
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::GetCompositBSTR(LPCTSTR szTop, LPCTSTR szRight, 
                               LPCTSTR szBottom, LPCTSTR szLeft, BSTR *pbstrRet)
{
    CBufferedStr    strRet; 
    BOOL            fWriteRightLeft = FALSE, fWriteBottom = FALSE, fWriteLeft = FALSE;

    Assert(pbstrRet);
    Assert(szTop && szRight && szBottom && szLeft);
    AssertSz( _fInited, "Must call Init first!" );

    *pbstrRet = NULL;

    strRet.QuickAppend(szTop);    // We always have the top string
    if ( _tcsicmp( szRight, szLeft ) )
    {   // Right and left don't match - write out everything.
        fWriteRightLeft = TRUE;
        fWriteBottom = TRUE;
        fWriteLeft = TRUE;
    }
    else
    {
        if ( _tcsicmp( szTop, szBottom ) )
        {
            fWriteBottom = TRUE;     // Top and bottom don't match
            fWriteRightLeft = TRUE;
        }
        else if ( _tcsicmp( szTop, szRight ) )
            fWriteRightLeft = TRUE;
    }

    if ( fWriteRightLeft )
    {
        strRet.QuickAppend(_T(" "));
        strRet.QuickAppend(szRight);    // Write out the right string (may be left also)
    }
    if ( fWriteBottom )
    {
        strRet.QuickAppend(_T(" "));
        strRet.QuickAppend(szBottom);    // Write out the bottom string
    }
    if ( fWriteLeft )
    {
        strRet.QuickAppend(_T(" "));
        strRet.QuickAppend(szLeft);    // Write out the left string
    }

    RRETURN(FormsAllocString(strRet, pbstrRet));
}


//+----------------------------------------------------------------
//
//  member : GetCompositBSTR
//
//  Synopsis : Returns the string that represents the value of a 
//               border property.
//
//              Here are the rules:
//
//            If there is only one value, it applies to all sides. 
//            If there are two values, the top and bottom are set to the 
//              first value and the right and left are set to the second. 
//            If there are three values, the top is set to the first value, 
//              the left and right are set to the second, and the bottom is 
//              set to the third. 
//            If there are four values, they apply to the top, right, bottom,
//               and left, respectively. 
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::GetCompositBSTR(CVariant *pvarTop, CVariant *pvarRight, 
                               CVariant *pvarBottom, CVariant *pvarLeft, BSTR *bstrStr)
{
    HRESULT     hr;

    AssertSz( _fInited, "Must call Init first!" );

    hr = THR(pvarTop->CoerceVariantArg(VT_BSTR));
    if(hr)
        goto Cleanup;

    hr = THR(pvarRight->CoerceVariantArg(VT_BSTR));
    if(hr)
        goto Cleanup;

    hr = THR(pvarBottom->CoerceVariantArg(VT_BSTR));
    if(hr)
        goto Cleanup;

    hr = THR(pvarLeft->CoerceVariantArg(VT_BSTR));
    if(hr)
        goto Cleanup;
    
    hr = THR(GetCompositBSTR(V_BSTR(pvarTop), V_BSTR(pvarRight), 
        V_BSTR(pvarBottom), V_BSTR(pvarLeft), bstrStr));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------
//
//  member : ComputeLongExtraFormat
//
//  Synopsis : Looks up the variant value of a format attribute
//             and returns it as a long
//              if eCmpType is ComputeFormatsType_GetValue  only this element is searched
//              if eCmpType is ComputeFormatsType_GetInheritedValue this element
//                         and its ancestors are searched, till we meet a table cell
//              if eCmpType is ComputeFormatsType_GetInheritedIntoTableValue this element
//                         and its all ancestors are searched
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::ComputeLongExtraFormat(DISPID dispID,                // IN
                                      COMPUTEFORMATSTYPE eCmpType,  // IN
                                      long defaultVal,              // IN
                                      long *plReturn)               // OUT
{
    HRESULT         hr;
    VARIANT         varValue;
    CElement *      pElement;
    NODE_IN_TREE_CHECK()
    pElement = pNodeToUse->SafeElement();

    AssertSz( _fInited, "Must call Init first!" );

    NULLPTRCHECK(pElement, E_FAIL)

    hr = THR(pElement->ComputeExtraFormat(dispID, eCmpType, pNodeToUse, &varValue));
    if(hr)
        goto Cleanup;

    *plReturn = (((CVariant *)&varValue)->IsEmpty())
                                             ? defaultVal
                                             : V_I4(&varValue);

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------
//
//  member : get_behavior
//
//  Synopsis : IHTMLCurrentStyle property
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::get_behavior(BSTR * pbstr)
{
    HRESULT hr = S_OK;
    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(pbstr, E_POINTER);


    *pbstr = NULL;
/*
    if(_pNode->Element())
    {
        // (alexz) this is wrong because there are multiple behaviors on the element
        // also, the logic itself should be in peer.cxx, not here
        CPeerHolder * pPeerPtr = _pNode->Element()->GetPeerHolderPtr();
        if(pPeerPtr)
        {
            CPeerFactoryUrl * pFactoryURL = pPeerPtr->_pPeerFactoryUrl;
            if(pFactoryURL)
            {
                FormsAllocString(pFactoryURL->_cstrUrl, pbstr);
            }

        }
    }
*/
Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//*********************************************************************
// CCurrentStyle::GetDispID, IDispatch
//    Is used to do sepecial processing for the expandos. CurrentStyle
//      expandos are not stored in object's attr array
//
//*********************************************************************

STDMETHODIMP
CCurrentStyle::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT         hr;

    AssertSz( _fInited, "Must call Init first!" );

    // We do not allow adding expandos on currentStyle
    grfdex = grfdex & (~fdexNameEnsure);

    // Now let CBase to search for the dispid
    hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pid));

    if(hr == DISP_E_UNKNOWNNAME)
    {
        CAttrArray          * pAA;

        // Not found, search cached propagated expandos of the node
        pAA = GetCachedExpandoAA();
        if(pAA)
        {
            hr = GetExpandoDispID(bstrName, pid, grfdex, pAA);
            if (hr == S_FALSE)
            {
                Assert(*pid == DISPID_UNKNOWN);
                hr = S_OK;
            }
        }
    }

    RRETURN1(hr, DISP_E_UNKNOWNNAME);
}


//*********************************************************************
// CCurrentStyle::GetDispID, InvokeEx
//    Is used to do sepecial processing for the expandos. CurrentStyle
//      expandos are not stored in object's attr array
//
//*********************************************************************

HRESULT
CCurrentStyle::InvokeEx(DISPID dispid, LCID lcid, WORD wFlags,  DISPPARAMS *pdispparams,
               VARIANT *pvarResult, EXCEPINFO *pexcepinfo, IServiceProvider *pSrvProvider)
{
    HRESULT hr = S_OK;

    AssertSz( _fInited, "Must call Init first!" );

    if (!pvarResult)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Fail if it is a property put
    if( wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF) )
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    if (IsExpandoDISPID(dispid))
    {
        CAttrArray          * pAA;

        if(!(wFlags & DISPATCH_PROPERTYGET))
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        // Not found, search cached propagated expandos of the node
        pAA = GetCachedExpandoAA();

        if(!pAA)
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        const CAttrValue * pAV = pAA->Find(dispid, CAttrValue::AA_Expando);

        if(pAV != NULL)
            hr = pAV->GetIntoVariant(pvarResult);
        else
            V_VT(pvarResult) = VT_NULL;
    }
    else
    {
        hr = THR(super::InvokeEx(dispid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, pSrvProvider));
    }


Cleanup:
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}


//+----------------------------------------------------------------
//
//  member : GetColorHelper
//
//  Synopsis : helper function used by functions gettting from
//                  CColorValue
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::GetColorHelper(VARIANT * p, const CColorValue &cvCol)
{
    HRESULT      hr = S_OK;
    TCHAR        szBuffer[pdlColor];

    NODE_IN_TREE_CHECK()
    NULLPTRCHECK(p, E_POINTER)
    AssertSz( _fInited, "Must call Init first!" );

    V_VT(p) = VT_BSTR;
    V_BSTR(p) = NULL;

    if(cvCol.IsDefined())
    {
        hr = THR(cvCol.FormatBuffer(szBuffer, ARRAY_SIZE(szBuffer), NULL));
        if(hr)
            goto Cleanup;
        hr = THR(FormsAllocString(szBuffer, &(V_BSTR(p))));
    }
    else
    {
        CColorValue cvColDef = pNodeToUse->GetCascadedcolor();

        if(cvColDef.IsDefined())
        {
            hr = THR(cvColDef.FormatBuffer(szBuffer, ARRAY_SIZE(szBuffer), NULL));
            if(hr)
                goto Cleanup;
            hr = THR(FormsAllocString(szBuffer, &(V_BSTR(p))));
        }
    }


Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------
//
//  member : GetUnitValueHelper
//
//  Synopsis : helper function used by functions gettting from
//                  CUnitValue
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::GetUnitValueHelper(
    VARIANT *p,
    CUnitValue uvVal,
    const PROPERTYDESC *pDesc,
    const ENUMDESC *pEnDesc /* = NULL */,
    const int nDefEnumValue /* = 0 */)
{
    HRESULT      hr = S_OK;

    NULLPTRCHECK(p, E_POINTER)
    AssertSz( _fInited, "Must call Init first!" );

    V_VT(p) = VT_EMPTY;

    if(pEnDesc && uvVal.IsNull())
        uvVal.SetRawValue(MAKEUNITVALUE(nDefEnumValue, UNIT_ENUM));

    if(uvVal.GetUnitType() == CUnitValue::UNIT_ENUM)
    {
        if(pEnDesc == NULL)
        {
            Assert(0 && "Unexpeted Unit value of enum type");
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR(pEnDesc->StringFromEnum(uvVal.GetUnitValue(), &(V_BSTR(p))));
    }
    else
    {
        TCHAR        szBuffer[pdlLength];

        // We aways want the unit values to be appended, so we pass in true
        hr = THR(uvVal.FormatBuffer(szBuffer, ARRAY_SIZE(szBuffer), pDesc, TRUE)) ;
        if(hr)
            goto Cleanup;
        hr = THR(FormsAllocString(szBuffer, &(V_BSTR(p))));
    }
    if(hr)
        goto Cleanup;
    V_VT(p) = VT_BSTR;

Cleanup:
    RRETURN(hr);
}



//+----------------------------------------------------------------
//
//  member : GetImageNameFromCookie
//
//  Synopsis : helper function that allocates and return the url corresponging
//               to given cookie enclosion the url in url("...")
//
//+----------------------------------------------------------------

HRESULT
CCurrentStyle::GetImageNameFromCookie(long lCookie, BSTR *p)
{
    HRESULT hr = S_OK;
    NODE_IN_TREE_CHECK()
    AssertSz( _fInited, "Must call Init first!" );

    if(lCookie)
    {
        CImgCtx *pCtx = pNodeToUse->Doc()->GetUrlImgCtx(lCookie);
        if (!pCtx)
        {
            *p = NULL;
        }
        else
        {
            CBufferedStr szBufSt;
            szBufSt.Set(_T("url(\""));
            szBufSt.QuickAppend(pCtx->GetUrl());
            szBufSt.QuickAppend(_T("\")"));
            hr = THR(FormsAllocString(szBufSt, p));
        }
    }
    else
    {
        *p = NULL;
    }

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------
//
//  member : GetBorderStyle
//
//  Synopsis : Helper function
//
//+----------------------------------------------------------------

styleBorderStyle
CCurrentStyle::GetBorderStyle(int nBorder)
{
    CDocInfo            di;
    CBorderInfo         bi;
    HRESULT             hr;

    NODE_IN_TREE_CHECK()
    AssertSz( _fInited, "Must call Init first!" );

    {
        CElement* pElement = pNodeToUse->Element();
        di = pElement->Doc()->_dciRender;
        pElement->GetBorderInfo(&di, &bi, FALSE, FALSE);
    }
    return ConvertFmToCSSBorderStyle(bi.abStyles[nBorder]);
Cleanup:    
    // It should never come here because calles should have called NODE_IN_TREE_CHECK()
    AssertSz(0, "Caller should have called NODE_IN_TREE_CHECK()");
    return styleBorderStyleNone;
}



//+----------------------------------------------------------------
//
//  member : GetCachedExpandoAA
//
//  Synopsis : Returns the attribute array that contains the expandos
//               propagated from the style.
//+----------------------------------------------------------------

CAttrArray *
CCurrentStyle::GetCachedExpandoAA()
{
    HRESULT hr;
    CAttrArray          * pAA = NULL;
    const CFancyFormat  * pFF;

    NODE_IN_TREE_CHECK()
    AssertSz( _fInited, "Must call Init first!" );

    if(pNodeToUse->_iFF == -1)
    {
         // This makes sure ComputeFormat is called and style expandos are propagated
        pNodeToUse->GetFancyFormatIndex();
        Assert(pNodeToUse->_iFF != -1);
    }

    pFF = GetFancyFormatEx(pNodeToUse->_iFF);
    if(pFF->_iExpandos != -1)
        pAA = GetExpandosAttrArrayFromCacheEx(pFF->_iExpandos);

Cleanup:
    return pAA;
}

//+----------------------------------------------------------------------------
//
//  Function:   CCurrentStyle::GetCanonicalProperty
//
//  Synopsis:   Returns the canonical pUnk/dispid pair for a particular dispid
//              Used by the recalc engine to catch aliased properties.
//
//  Parameters: ppUnk will contain the canonical object
//              pdispid will contain the canonical dispid
//
//  Returns:    S_OK if successful
//              S_FALSE if property has no alias
//
//-----------------------------------------------------------------------------

HRESULT
CCurrentStyle::GetCanonicalProperty(DISPID dispid, IUnknown **ppUnk, DISPID *pdispid)
{
    HRESULT hr;

    NODE_IN_TREE_CHECK()
    AssertSz( _fInited, "Must call Init first!" );

    switch (dispid)
    {
    case DISPID_IHTMLSTYLE_LEFT:
        *pdispid = DISPID_IHTMLELEMENT_OFFSETLEFT;
        hr = THR(pNodeToUse->Element()->PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        break;
    case DISPID_IHTMLSTYLE_TOP:
        *pdispid = DISPID_IHTMLELEMENT_OFFSETTOP;
        hr = THR(pNodeToUse->Element()->PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        break;

    case DISPID_IHTMLSTYLE_WIDTH:
        *pdispid = DISPID_IHTMLELEMENT_OFFSETWIDTH;
        hr = THR(pNodeToUse->Element()->PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        break;

    case DISPID_IHTMLSTYLE_HEIGHT:
        *pdispid = DISPID_IHTMLELEMENT_OFFSETHEIGHT;
        hr = THR(pNodeToUse->Element()->PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        break;
    default:
        *ppUnk = 0;
        *pdispid = 0;
        hr = S_FALSE;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\style\fontface.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1997
//
//  File:       FontFace.cxx
//
//  Contents:   Support for Cascading Style Sheets "@font-face"
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FONTFACE_HXX_
#define X_FONTFACE_HXX_
#include "fontface.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_T2EMBAPI_H_
#define X_T2EMBAPI_H_
#include "t2embapi.h"
#endif

#ifndef X_T2EMWRAP_HXX_
#define X_T2EMWRAP_HXX_
#include "t2emwrap.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_ASSOC_HXX_
#define X_ASSOC_HXX_
#include "assoc.hxx"
#endif

#define _cxx_
#include "fontface.hdl"

MtDefine(CFontFace, StyleSheets, "CFontFace")
MtDefine(CFontFaceName, StyleSheets, "CFontFace::_pszFaceName")
MtDefine(CFontFaceRefStr, StyleSheets, "CFontFace::InstallFont (temp)")
extern BOOL IsScriptUrl(LPCTSTR pszURL);
extern BOOL IsSpecialUrl(LPCTSTR pszURL);

const CFontFace::CLASSDESC CFontFace::s_classdesc =
{
    {
        &CLSID_HTMLStyleFontFace,            // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        NULL,                                // _apClsidPages
#endif // NO_PROPERTY_PAGE
        NULL,                                // _pcpi
        0,                                   // _dwFlags
        &IID_IHTMLStyleFontFace,             // _piidDispinterface
        &s_apHdlDescs                        // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLStyleFontFace                 // _apfnTearOff
};


HRESULT  
CFontFace::Create(CFontFace **ppFontFace, CStyleSheet *pParentStyleSheet, LPCTSTR pcszFaceName)
{
    HRESULT    hr = S_OK;

    Assert(ppFontFace);
    Assert(pParentStyleSheet);

    *ppFontFace = new CFontFace(pParentStyleSheet, NULL);
    if (!*ppFontFace)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // no need to addRef here
    hr = CAtFontBlock::Create(&((*ppFontFace)->_pAtFont), pcszFaceName);
    
Cleanup:
    RRETURN(hr);
}



HRESULT 
CFontFace::Create(CFontFace **ppFontFace, CStyleSheet *pParentStyleSheet, CAtFontBlock *pAtBlock)
{
    HRESULT    hr = S_OK;

    Assert(ppFontFace);
    Assert(pParentStyleSheet);
    Assert(pAtBlock);

    *ppFontFace = new CFontFace(pParentStyleSheet, pAtBlock);
    if (!*ppFontFace)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
Cleanup:
    RRETURN(hr);
}



CFontFace::CFontFace(
    CStyleSheet *pParentStyleSheet,
    CAtFontBlock *pAtFont
    )
    : 
    _pParentStyleSheet( pParentStyleSheet ),
    _pAtFont(pAtFont)
{
    _pszInstalledName[0] = 0;
    _hEmbeddedFont = NULL;
    _fFontLoadSucceeded = FALSE;
    _fFontDownloadInterrupted = FALSE;
    _fFontDownloadStarted = FALSE;
    _pBitsCtx = NULL;
    _pAA = NULL;
    _dwStyleCookie = 0;
    if (_pAtFont)
    {
        _pAtFont->AddRef();
    }
}


CFontFace::~CFontFace()
{
#ifndef NO_FONT_DOWNLOAD
    GWKillMethodCall(this, ONCALL_METHOD(CFontFace, FaultInT2, faultinusp), 0);
    if ( _hEmbeddedFont )
    {
        ULONG ulStatus;

        if ( E_NONE != T2DeleteEmbeddedFont( _hEmbeddedFont, 0, &ulStatus ) )
        {
            Assert( "Couldn't unload downloaded font!" );
        }
    }

    SetBitsCtx(NULL);
#endif
    if (_pAtFont)
    {
        _pAtFont->Release();
    }
}



HRESULT CFontFace::SetProperty( const TCHAR *pcszPropName, const TCHAR *pcszValue )
{
    HRESULT hr = S_OK;

    if ( !_tcslen( pcszPropName ) )
        return S_FALSE;

    const PROPERTYDESC * found = FindPropDescForName ( pcszPropName );

    if ( !StrCmpIC( pcszPropName, _T( "font-family" ) ) )
    {
        if ( _pAtFont->_pszFaceName )
          MemFree( _pAtFont->_pszFaceName ); //free
        _pAtFont->_pszFaceName = (TCHAR *)MemAlloc(Mt(CFontFaceName), (_tcslen( pcszValue ) + 1)*sizeof(TCHAR) );
        if ( _pAtFont->_pszFaceName )
        {
            _tcscpy( _pAtFont->_pszFaceName, pcszValue );
            TCHAR *pszFace = _pAtFont->_pszFaceName;
            while ( *pszFace && ( *pszFace != _T(',') ) )
                pszFace++;
            if ( *pszFace == _T(',') )
            {
                *pszFace-- = _T('\0');
                while ( ( pszFace >= _pAtFont->_pszFaceName ) && _istspace( *pszFace ) )
                    *pszFace-- = _T('\0');
            }
        }
        goto Cleanup;
    }

    if ( found && ( found->pfnHandleProperty ) )
    {
        // Try and parse attribute
#ifdef WIN16
        hr = THR ( (found->pfnHandleProperty)((PROPERTYDESC *)found,
            HANDLEPROP_SETHTML,
            (CVoid *)pcszValue, NULL, (CVoid *)GetAA() ) );
#else
        hr = THR ( CALL_METHOD( found, found->pfnHandleProperty, (
            HANDLEPROP_SETHTML, /*NOTE: This opcode may be incorrect when we expose these through the OM. */
            (CVoid *)pcszValue, NULL, (CVoid *)GetAA() ) ));
#endif
        if (!hr)
        {
            // got a match
            goto Cleanup;
        }
    }

    // TODO: Need to handle expandos - either here, or (more preferably) in a generic fashion in the CAtBlockHandler code.

Cleanup:
    RRETURN1(hr, S_FALSE);
}

#ifdef NO_FONT_DOWNLOAD
HRESULT CFontFace::StartDownload( void )
{
    return S_OK;
}

#else // NO_FONT_DOWNLOAD

static inline void FillClassSpec(uCLSSPEC *pclasspec)
{
    pclasspec->tyspec = TYSPEC_FILENAME;
    pclasspec->tagged_union.pFileName = _T("{630b1da0-b465-11d1-9948-00c04f98bbc9}");
}

HRESULT CFontFace::StartDownload( void )
{
    CDoc *pDoc = _pParentStyleSheet->GetElement()->Doc();
    QUERYCONTEXT qcNotUsed;
    uCLSSPEC classpec;
    LPCTSTR  pcszURL = NULL;
    HRESULT hr = E_FAIL;
    extern DYNPROC g_dynprocT2EmbedLoadFont;

    Assert(!_fFontDownloadStarted);
    _fFontDownloadStarted = TRUE;
    //
    // Do we have a source URL from which to download?
    //
    if ( !(*GetAA()) || !(*GetAA())->FindString ( DISPID_A_FONTFACESRC, &pcszURL ) )
        goto Cleanup;   // No SRC!
    
    //
    // First check if t2embed has already on the system.  Note that the user
    // may have independently loaded t2embed.dll, in which case we just use
    // that version.  Otherwise we would require a cabinet containing other
    // features the user may not need.
    //

    hr = THR_NOTRACE(LoadProcedure(&g_dynprocT2EmbedLoadFont));
    if (FAILED(hr))
    {
        FillClassSpec(&classpec);
        hr = THR(FaultInIEFeatureHelper(pDoc->GetHWND(), &classpec, &qcNotUsed, FIEF_FLAG_PEEK) );
    }
    
    //
    // If it has already been downloaded, then ask t2 to bring in the font.
    //
    if (hr == S_OK)
    {
        hr = THR(StartFontDownload());
    }
    else if (hr == HRESULT_FROM_WIN32(ERROR_PRODUCT_UNINSTALLED))
    {
        hr = GWPostMethodCall(this, ONCALL_METHOD(CFontFace, FaultInT2, faultinusp), 0, FALSE, "CFontFace::FaultInT2");
    }
    else
        hr = S_FALSE;

Cleanup:    
    RRETURN2(hr, S_FALSE, E_FAIL);
    }

void CFontFace::FaultInT2(DWORD_PTR dwContext)
{
    CDoc *pDoc = _pParentStyleSheet->GetElement()->Doc();
    uCLSSPEC classpec;
    HRESULT hr = S_OK;
    ULONG   cDie;
    
    FillClassSpec(&classpec);

    _fFontDownloadInterrupted = FALSE;
    cDie = pDoc->_cDie;
    pDoc->SubAddRef();
    PrivateAddRef();
    
    hr = THR(FaultInIEFeatureHelper(pDoc->GetHWND(), &classpec, NULL, 0));

    //
    // Irrespective of what Fault* returns we have to restart rendering! However
    // if the document cycled thru a UnloadContents then we are not interested
    // either enabling rendering or in starting font download.
    //
    if (cDie == pDoc->_cDie)
    {
        //
        // If the style element was blown away (say thru OM timer event) while
        // we were downloading (only the element was blown away -- the doc was
        // left intact and hence was not caught in the check for cDie)
        // then do not do anything since its pointless!
        //
        if (!_fFontDownloadInterrupted)
        {
            //
            // If we successfully downloaded the t2 dll, then we should proceed with
            // the download of the font.
            //
            if (S_OK == hr)
            {
                hr = StartFontDownload();
            }
        }
    }
    
    // And yes, don't leak anything :-)
    PrivateRelease();
    pDoc->SubRelease();
}

HRESULT CFontFace::StartFontDownload( void )
{
    CBitsCtx   *pBitsCtx = NULL;
    HRESULT     hr = E_FAIL;
    LPCTSTR     pcszURL = NULL;
    CElement   *pElement = _pParentStyleSheet->GetElement();
    BOOL        fAllow;
    TCHAR      *pchFontSrcURL = NULL;
    CMarkup    *pMarkup = pElement->GetMarkup();
    CDoc       *pDoc = pMarkup->Doc();

    if (!(*GetAA()) || !(*GetAA())->FindString ( DISPID_A_FONTFACESRC, &pcszURL ) )
        goto Cleanup;
    
    _fFontLoadSucceeded = FALSE;

    hr = THR(pMarkup->ProcessURLAction(
            URLACTION_HTML_FONT_DOWNLOAD,
            &fAllow));
    if (hr)
        RRETURN(hr);

    if (!fAllow)
        RRETURN(E_ACCESSDENIED);

    if (_pParentStyleSheet->GetAbsoluteHref())
    {
        hr = ExpandUrlWithBaseUrl(_pParentStyleSheet->GetAbsoluteHref(),
                                  pcszURL,
                                  &pchFontSrcURL);
        if (hr)
            goto Cleanup;
    }

    if ( ! IsScriptUrl( _pParentStyleSheet->GetAbsoluteHref() ? pchFontSrcURL : pcszURL ))
    {
        // Kick off the download of the imported sheet
        hr = THR(pDoc->NewDwnCtx(DWNCTX_FILE,
                    _pParentStyleSheet->GetAbsoluteHref() ? pchFontSrcURL : pcszURL,
                    pElement,
                    (CDwnCtx **)&pBitsCtx,
                    pMarkup->IsPendingRoot()));
        if ( hr == S_OK )
        {
            // For rendering purposes, having an @imported sheet pending is just like having
            // a linked sheet pending.
            pDoc->EnterStylesheetDownload(&_dwStyleCookie);
            
            // Give ownership of bitsctx to the newly created (empty) stylesheet, since it's
            // the one that will need to be filled in by the @import'ed sheet.
            SetBitsCtx( pBitsCtx );
        }
    }
    
    if (pBitsCtx)
        pBitsCtx->Release();

Cleanup:
    if (pchFontSrcURL)
        MemFreeString(pchFontSrcURL);
    return hr;
}

//*********************************************************************
//  CFontFace::SetBitsCtx()
//  Sets ownership and callback information for a BitsCtx.  A FontFace
//  will have a non-NULL BitsCtx if it's being downloaded.
//*********************************************************************
void CFontFace::SetBitsCtx( CBitsCtx * pBitsCtx )
{
    CElement *pElement = _pParentStyleSheet->GetElement();

    if (_pBitsCtx)
        _pBitsCtx->Release();

    _pBitsCtx = pBitsCtx;

    if (pBitsCtx)
    {
        pBitsCtx->AddRef();

        // If the bits are here then just call OnDwnChan.
        // This will start handling the font (e.g., installing it).

        if (pBitsCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
            OnDwnChan(pBitsCtx);
        else
        {
            pBitsCtx->SetProgSink(CMarkup::GetProgSinkHelper(pElement->GetMarkup()));
            pBitsCtx->SetCallback(OnDwnChanCallback, this);
            pBitsCtx->SelectChanges(DWNCHG_COMPLETE, 0, TRUE);
        }
    }
}

//*********************************************************************
//  CFontFace::OnChan()
//  Callback used by BitsCtx once it's downloaded our font file.
//*********************************************************************
void CFontFace::OnDwnChan(CDwnChan * pDwnChan)
{
    ULONG ulState = _pBitsCtx->GetState();
    CMarkup *pMarkup = _pParentStyleSheet->GetElement()->GetMarkup();
    CDoc *pDoc;
    
    Assert(pMarkup);
    pDoc = pMarkup->Doc();

    if (ulState & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
    {
        pDoc->LeaveStylesheetDownload(&_dwStyleCookie);
        _pBitsCtx->SetProgSink(NULL); // detach download from document's load progress
    }

    if (ulState & DWNLOAD_COMPLETE)
    {
        LPTSTR szFile = NULL;
        if ( S_OK == _pBitsCtx->GetFile(&szFile) )
        {
            // If unsecure download, may need to remove lock icon on Doc
            pDoc->OnSubDownloadSecFlags(pMarkup->IsPendingRoot(), _pBitsCtx->GetUrl(), _pBitsCtx->GetSecFlags());
            
            Assert( szFile );       // GetFile should always yield a valid string if it rets S_OK

            if ( S_OK == InstallFont( szFile ) )
            {
                // (this is not always a stable moment)
                IGNORE_HR( pMarkup->OnCssChange( /*fStable = */ FALSE, /* fRecomputePeers = */FALSE) );
            }
            else
                pDoc->Invalidate(); // So we'll update the screen.
            MemFreeString( szFile );
        }
    }
    else
    {
        pDoc->Invalidate(); // So we'll update the screen.
        TraceTag((tagError, "CFontFace::OnChan bitsctx failed to complete!"));
    }
}

unsigned long __cdecl FontReadCallback( void *pvFile, void *pvData, const unsigned long ulBytes )
{
    HFILE hFile = (HFILE)(DWORD_PTR)pvFile;
    return ( _lread( hFile, pvData, ulBytes ) );
}

//*********************************************************************
//  CFontFace::InstallFont()
//      Method used to load up the font embedding DLL and attempt to
//  install the font.
//*********************************************************************
HRESULT CFontFace::InstallFont( LPCTSTR pcszPathname )
{
    HRESULT hr = S_FALSE;
    HANDLE hFile = CreateFile( pcszPathname, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    hr = S_FALSE;   // Still haven't loaded the font.
    if ( hFile != INVALID_HANDLE_VALUE)
    {
        TTLOADINFO ttli;
        CMarkup *pMarkup = _pParentStyleSheet->GetElement()->GetMarkupPtr();
        
        LPCTSTR pcszDocUrl = CMarkup::GetUrl(pMarkup);
        if (IsSpecialUrl(pcszDocUrl))
        {
            LPCTSTR pchCreatorUrl = pMarkup->GetAAcreatorUrl();
            if (pchCreatorUrl)
            {
                pcszDocUrl = pchCreatorUrl;
            }
        }

        CookupInstalledName(pMarkup);

        ttli.usStructSize = sizeof(TTLOADINFO);

        hr = THR(MemAllocString(Mt(CFontFaceRefStr), pcszDocUrl, &ttli.pusRefStr ) );
        if ( hr == S_OK )
        {
            hr = S_FALSE;   // Still haven't finished.
            ttli.usRefStrSize = _tcslen( pcszDocUrl ) + 1;
            ULONG ulPrivStatus, ulStatus;
            char acMacName[ LF_FACESIZE * 2 + 1 ];

            WideCharToMultiByte( CP_ACP, 0, _pszInstalledName, -1, acMacName, LF_FACESIZE*2, NULL, NULL );

            switch ( T2LoadEmbeddedFont( &_hEmbeddedFont, TTLOAD_PRIVATE, &ulPrivStatus, LICENSE_DEFAULT, &ulStatus,
                                                        FontReadCallback, (void *)hFile, _pszInstalledName,
                                                        acMacName, &ttli ) )
            {
            case E_FONTNAMEALREADYEXISTS:   // We must have already downloaded this font for this document.
            case E_FONTALREADYEXISTS:       // (bug # 95655)
                _hEmbeddedFont = NULL;
                // Intentional fall-through
            case E_NONE:
                // Whoo-hoo!  The font has been loaded!
                _fFontLoadSucceeded = TRUE;
                hr = S_OK;
            }
            MemFreeString( ttli.pusRefStr );
        }
        CloseHandle( hFile );
    }
    RRETURN1( hr, S_FALSE );
}

//+----------------------------------------------------------------------------
//
//  Function:   CFontFace::CookupInstalledName
//
//  Synopsis:   Populate CFontFace::_pszInstalledName
//
//  Note:       Emperically we have determined that AddFontResource will fail
//              if the internal name is too long.  For these systems, we'll use
//              the old IE4-style internal name, which will fail if we have a
//              non-ASCII Unicode value.  Most fonts have an ASCII external
//              name, so this isn't usually a problem.
//
//-----------------------------------------------------------------------------

#define SIZEOF_COLOR 7 // syntax for <c>: #rrggbb

void
CFontFace::CookupInstalledName( void * p )
{
    TCHAR szTmpPtr[ 20 ];   // We use the document ptr as a hash on the installed name, so
                            // font-faces can be named the same across pages without conflict.
                            // We also use the current process ID to avoid naming conflicts
                            // across processes - although this is highly improbably, it is
                            // possible.

    if (g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS && g_dwPlatformVersion == 0x00040000)
    {
        const size_t cch = LF_FACESIZE - SIZEOF_COLOR - SIZEOF_COLOR - 1;
        _tcsncpy( _pszInstalledName, _pAtFont->_pszFaceName, cch );
        _pszInstalledName[ cch ] = _T('\0');

        // Add the document pointer.

        Format( 0, szTmpPtr, 19, _T("<0c>"), p );
        _tcscat( _pszInstalledName, szTmpPtr );
    }
    else
    {
        DWORD dwFontNameHash;

        //
        // Embedded fonts are saved under a generated name which is a hash of a bunch of things.
        // First, there is a hash of the original font-name itself.  Then there is 
        // the location of the pDoc object (in Hex), and then the process Id.  The latter
        // two are added to prevent different pages from sharing fonts, as this would be a security
        // flaw.  The font name is hashed so that if two fonts differ only at the end, we still
        // register them under different names.
        //

        // NOTE (paulpark) Eventually, this code will break since we are relying on a hash.
        // If two (different) font-names hash to the same value, this will break, and we will 
        // display something in an incorrect font.

        dwFontNameHash = HashString( _pAtFont->_pszFaceName, _tcslen(_pAtFont->_pszFaceName), 0 );
        Format( 0, szTmpPtr, 19, _T("<0x>"), dwFontNameHash );
        _tcscpy( _pszInstalledName, szTmpPtr );

        // Run it twice to get a (sort-of) 64 bit hash.

        dwFontNameHash = HashString( _pAtFont->_pszFaceName, _tcslen(_pAtFont->_pszFaceName), dwFontNameHash );
        Format( 0, szTmpPtr, 19, _T("<0x>"), dwFontNameHash );
        _tcscat( _pszInstalledName, szTmpPtr );
        // Add the document pointer.

        Format( 0, szTmpPtr, 19, _T("<0x>"), p );
        _tcscat( _pszInstalledName, szTmpPtr );
    }

    // Add the process ID just to be safe.

    Format( 0, szTmpPtr, 19, _T("<0c>"), GetCurrentProcessId() );
    _tcscat(_pszInstalledName, szTmpPtr );

    // Make sure we don't overflow static buffer
    AssertSz(_tcsclen(_pszInstalledName) < LF_FACESIZE, "String length > LF_FACESIZE");
    _pszInstalledName[LF_FACESIZE - 1] = 0;
}


void
CFontFace::StopDownloads()
{
    GWKillMethodCall(this, ONCALL_METHOD(CFontFace, FaultInT2, faultinusp), 0);
    _fFontDownloadInterrupted = TRUE;
}

#endif // !NO_FONT_DOWNLOAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\style\pagescol.cxx ===
//=================================================================
//
//   File:      pagescol.cxx
//
//  Contents:   CStyleSheetPageArray class
//
//  Classes:    CStyleSheetPageArray
//
//=================================================================

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_COLLBASE_HXX_
#define X_COLLBASE_HXX_
#include "collbase.hxx"
#endif

#ifndef X_PAGESCOL_HXX_
#define X_PAGESCOL_HXX_
#include "pagescol.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "pagescol.hdl"

MtDefine(CStyleSheetPage, StyleSheets, "CStyleSheetPage");
MtDefine(CStyleSheetPageArray, StyleSheets, "CStyleSheetPageArray");
MtDefine(CStyleSheetPageArray_aPages_pv, CStyleSheetPageArray, "CStyleSheetPageArray::_aPages::_pv");

// Refcounting structure for page rules:
// The SS holds a ref on the page array, which holds a subref on the SS.
// The page array holds a ref on each page it contains.
// Each page holds a subref on the SS.
// Destruction is led by the SS calling Free() (usually in Passivate or
// the changing of cssText).  SS releases the array, and all internal Trident
// refs/subrefs should go away.

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CStyleSheetPageArray
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------
const CBase::CLASSDESC CStyleSheetPageArray::s_classdesc =
{
    &CLSID_HTMLStyleSheetPagesCollection,   // _pclsid
    0,                                      // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                                   // _pcpi
    0,                                      // _dwFlags
    &IID_IHTMLStyleSheetPagesCollection,    // _piidDispinterface
    &s_apHdlDescs                           // _apHdlDesc
};

//+----------------------------------------------------------------
//
//  Member : CTOR/DTOR
//
//+----------------------------------------------------------------
CStyleSheetPageArray::CStyleSheetPageArray( CStyleSheet *pStyleSheet ) : _pStyleSheet(pStyleSheet)
{
    Assert( _pStyleSheet );
    _pStyleSheet->SubAddRef();
}

CStyleSheetPageArray::~CStyleSheetPageArray()
{
    Assert( _pStyleSheet );
    _pStyleSheet->SubRelease();

    int i;
    int len = _aPages.Size();

    for (i=0; i < len ; ++i)
    {
        _aPages[i]->Release();
    }
}

//+---------------------------------------------------------------
//
//  Member  : CStyleSheetPageArray::PrivateQueryInterface
//
//----------------------------------------------------------------
HRESULT
CStyleSheetPageArray::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        default:
        {
            const CLASSDESC *pclassdesc = BaseDesc();

            if (pclassdesc &&
                pclassdesc->_piidDispinterface &&
                (iid == *pclassdesc->_piidDispinterface))
            {
                HRESULT hr = THR(CreateTearOffThunk(this, s_apfnIHTMLStyleSheetPagesCollection, NULL, ppv));
                if (hr)
                    RRETURN(hr);
            }
        }
    }

    if (*ppv)
    {
        (*(IUnknown**)ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Member  : CStyleSheetPageArray::Append
//
//----------------------------------------------------------------

HRESULT
CStyleSheetPageArray::Append(CStyleSheetPage * pPage, BOOL fAddToContainer)
{
    HRESULT hr = S_OK;

    if ( !pPage )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = _aPages.Append( pPage );

    if ( SUCCEEDED(hr) )
    {
        pPage->AddRef();
    }

    if (fAddToContainer && _pStyleSheet)
    {
        hr = THR(_pStyleSheet->AppendPage(pPage));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = E_FAIL;
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//+---------------------------------------------------------------
//
//  Member  : CStyleSheetPageArray::length
//
//----------------------------------------------------------------

HRESULT
CStyleSheetPageArray::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLength = _aPages.Size();

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//+---------------------------------------------------------------
//
//  Member  : CStyleSheetPageArray::item
//
//----------------------------------------------------------------

HRESULT
CStyleSheetPageArray::item(long lIndex, IHTMLStyleSheetPage **ppSSPage)
{
    HRESULT         hr;
    VARIANT         varDispatch;

    if (!ppSSPage)
    {
        RRETURN(E_POINTER);
    }

    hr = THR(GetItem(lIndex, &varDispatch));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&varDispatch) == VT_DISPATCH);
    *ppSSPage = (IHTMLStyleSheetPage *) V_DISPATCH(&varDispatch);

Cleanup:
    RRETURN(hr);
}

HRESULT 
CStyleSheetPageArray::GetItem (long lIndex, VARIANT *pvar)
{
    HRESULT hr = S_OK;
    IHTMLStyleSheetPage *pIPage = NULL;

    // pvar is NULL if we're validating lIndex
    if ( pvar )    
    {
        V_VT(pvar) = VT_DISPATCH;
        V_DISPATCH(pvar) = NULL;
    }

    if ( lIndex < 0 || lIndex >= _aPages.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ( pvar )
    {
        hr = _aPages[ lIndex ]->QueryInterface( IID_IHTMLStyleSheetPage, (void**)&pIPage );
        if (hr)
            goto Cleanup;

        Assert( pIPage );

        V_DISPATCH(pvar) = pIPage;
    }

Cleanup:
    RRETURN(hr);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CStyleSheetPage
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

const CBase::CLASSDESC CStyleSheetPage::s_classdesc =
{
    0,                          // _pclsid
    0,                          // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                       // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                       // _pcpi
    0,                          // _dwFlags
    &IID_IHTMLStyleSheetPage,   // _piidDispinterface
    &s_apHdlDescs,              // _apHdlDesc
};

//+----------------------------------------------------------------
//
//  Member : CTOR/DTOR
//
//+----------------------------------------------------------------
CStyleSheetPage::CStyleSheetPage(CStyleSheet *pStyleSheet, CAtPageBlock *pAtPage)
{
    Assert(pStyleSheet);
    _pStyleSheet = pStyleSheet;
    _pStyleSheet->SubAddRef();

    Assert(pAtPage);
    _pAtPage = pAtPage;
    _pAtPage->AddRef();
    
    _fInvalid  = FALSE;
}



CStyleSheetPage::CStyleSheetPage( CStyleSheet *pStyleSheet, const CStr & rcstrSelector, const CStr & rcstrPseudoClass )
    : _pStyleSheet( pStyleSheet )
{
    Assert( pStyleSheet );

    HRESULT hr;
    
    _fInvalid  = FALSE;

    if(_pStyleSheet)
        _pStyleSheet->SubAddRef();

    hr = CAtPageBlock::Create(&_pAtPage);
    if (hr)
    {
        _fInvalid = TRUE;
    }
    else
    {
        _pAtPage->_cstrSelectorText.Set(rcstrSelector);
        _pAtPage->_cstrPseudoClassText.Set(rcstrPseudoClass);
    }

    _pAA = NULL;
}



CStyleSheetPage::~CStyleSheetPage()
{
    if ( _pAA )
        delete( _pAA );
    _pAA = NULL;

    if(_pStyleSheet)
    {
        _pStyleSheet->SubRelease();
        _pStyleSheet = NULL;
    }

    if (_pAtPage)
    {
        _pAtPage->Release();
        _pAtPage = NULL;
    }
}


HRESULT  
CStyleSheetPage::Create(CStyleSheetPage **ppSSP, CStyleSheet *pStyleSheet, const CStr &rcstrSelector, const CStr &rcstrPseudoClass)
{
    HRESULT hr = S_OK;

    Assert(ppSSP && pStyleSheet);
    
    if (!ppSSP || !pStyleSheet)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppSSP = new CStyleSheetPage(pStyleSheet, rcstrSelector, rcstrPseudoClass);
    if (!(*ppSSP) || (*ppSSP)->_fInvalid)
    {
        hr = E_OUTOFMEMORY;
    }

Cleanup:
    RRETURN(hr);
}



//+----------------------------------------------------------------
//
//  Member : PrivateQueryInterface
//
//+----------------------------------------------------------------
STDMETHODIMP
CStyleSheetPage::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IUnknown ||
        iid == IID_IDispatch ||
        iid == IID_IHTMLStyleSheetPage)
    {
        *ppv = (IHTMLStyleSheetPage *)this;
    }
    else if (iid == IID_IDispatchEx)
    {
        *ppv = (IDispatchEx *)this;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

HRESULT
CStyleSheetPage::get_selector(BSTR *pBSTR)
{
    HRESULT hr = E_FAIL;

    if (!pBSTR)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pBSTR = NULL;

    if (_pAtPage)
    {
        hr = _pAtPage->_cstrSelectorText.AllocBSTR( pBSTR );
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

HRESULT
CStyleSheetPage::get_pseudoClass(BSTR *pBSTR)
{
    HRESULT hr = E_FAIL;

    if (!pBSTR)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pBSTR = NULL;

    if (_pAtPage)
    {
        hr = _pAtPage->_cstrPseudoClassText.AllocBSTR(pBSTR);
    }
    
Cleanup:
    RRETURN( SetErrorInfo( hr ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\style\rendstyl.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "Qi_impl.h"
#endif

#ifndef X_RENDSTYL_HXX_
#define X_RENDSTYL_HXX_
#include "rendstyl.hxx"
#endif


MtDefine(CRenderStyle, StyleSheets, "CRenderStyle")

#define _cxx_
#include "rendstyl.hdl"

const CRenderStyle::CLASSDESC CRenderStyle::s_classdesc =
{
    {
        &CLSID_HTMLRenderStyle,              // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        NULL,                                // _apClsidPages
#endif // NO_PROPERTY_PAGE
        NULL,                                // _pcpi
        0,                                   // _dwFlags
        &IID_IHTMLRenderStyle,               // _piidDispinterface
        &s_apHdlDescs,                       // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLRenderStyle,          // _apfnTearOff
};


CRenderStyle::CRenderStyle(CDoc *pDoc)
{
    _pDoc = pDoc;
    _fSendNotification = TRUE;
}

void CRenderStyle::Passivate()
{
    super::Passivate();
}

HRESULT
CRenderStyle::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr=S_OK;

    *ppv = NULL;


    if( CLSID_HTMLRenderStyle == iid ) 
    {
       *ppv = this;
       return S_OK;
    }
    
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_HTML_TEAROFF(this, IHTMLRenderStyle, NULL)
    }

    if (*ppv)
        (*(IUnknown **)ppv)->AddRef();
    else
        hr = E_NOINTERFACE;

    RRETURN(hr);
}

HRESULT
CRenderStyle::OnPropertyChange ( DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    CNotification       nf;
    CTreePos* ptpFirst;
    CTreePos* ptpEnd;

    Assert( !ppropdesc || ppropdesc->GetDispid() == dispid );
    //Assert( !ppropdesc || ppropdesc->GetdwFlags() == dwFlags );

    if (!_fSendNotification)
        return S_OK;

    AddRef();

    CMarkup* pMarkup = _pDoc->PrimaryMarkup();
    
    if (pMarkup && pMarkup->GetElementClient())
    {
        pMarkup->GetElementClient()->GetTreeExtent( & ptpFirst, & ptpEnd );    
        nf.MarkupRenderStyle( ptpFirst->GetCp(), ptpEnd->GetCp() - ptpFirst->GetCp() , (IHTMLRenderStyle*) this );
        pMarkup->Notify(&nf);
    }

    Release();

    return S_OK;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\style\custcur.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-12000
//
//  File:       CustCursor.cxx
//
//  Contents:   Support for custom CSS cursors
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"     // for cbitsctx
#endif

#ifndef X_CUSTCUR_HXX_
#define X_CUSTCUR_HXX_
#include "custcur.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif


#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_CDBASE_HXX_
#define X_CDBASE_HXX_
#include "cdbase.hxx"
#endif

extern LPCTSTR GetCursorForStyle( BYTE iIndex );
extern BOOL IsSpecialUrl(LPCTSTR pszURL);

MtDefine(CCustomCursor, StyleSheets, "CCustomCursor")

CCustomCursor::CCustomCursor(  )
{

}

HRESULT
CCustomCursor::Init(const CStr &cstr, CElement* pElement )
{
    _pElement  = pElement;
    _cstrUrl.Set( cstr );
    _cstrCurUrl.Set( cstr );
    return S_OK;
}

HRESULT
CCustomCursor::StartDownload()
{
    HRESULT hr;

    Assert( ! _pBitsCtx );
    
    if ( IsCompositeUrl( ))
    {
        _fCompositeUrl = TRUE;
        _iLastComma = -1 ;
        
        Verify( GetNextUrl( & _cstrCurUrl ));
        hr = THR( BeginDownload( &_cstrCurUrl ));
        
    }
    else
        hr = THR( BeginDownload( & _cstrUrl ));


    RRETURN( hr );
}

CCustomCursor::CCustomCursor(const CCustomCursor &PCC)
{ 
    _pElement = PCC._pElement;
    _hCursor = PCC._hCursor;           // Handle to Custom Cursor
    _pBitsCtx = PCC._pBitsCtx;
    if ( _pBitsCtx )
    {
        _pBitsCtx->AddRef();
    }
    _cstrUrl.Set( PCC._cstrUrl );
    _cstrCurUrl.Set( PCC._cstrCurUrl );
    _fCompositeUrl = PCC._fCompositeUrl;
    _iLastComma = PCC._iLastComma;
    
}

//==================================================
//
//  Get the next Url to be processed.
//  Return true - if there are more, false otherwise
//
//==================================================

BOOL
CCustomCursor::GetNextUrl(CStr* pCStr)
{
    TCHAR achUrl[4096];
    UINT i,j = 0;
    TCHAR* pstr;
    TCHAR  strComma[] = _T(",");
    TCHAR* pchNew;
    int    oldComma = _iLastComma;
    
    Assert( _fCompositeUrl );

    if ( (UINT)_iLastComma == _cstrUrl.Length() )
        return FALSE;
        
    // 
    // Scan the string looking for ","
    //
    pstr = _cstrUrl;
    pstr = & ( pstr[_iLastComma+1] ) ;
    
    for( i = _iLastComma+1. ; 
         i< _cstrUrl.Length(); 
         i++, pstr++,j++ )
    {
        achUrl[j] = (*pstr);
        if( 0==_tcsnicmp(pstr, 1, strComma, 1 ))
        {
            _iLastComma = i;
            break;
        }                        
    }
    achUrl[j]= '\0';

        
    //
    // Strip the url('...')
    //
    TCHAR* pchOld = achUrl;    
    while ( _istspace( *pchOld ) )
        pchOld++;    
    int nLenIn = ValidStyleUrl( pchOld );    
    if ( nLenIn > 0 )
    {
        StripUrl( pchOld, nLenIn, & pchNew );
    }
    else
        pchNew = pchOld;
        
    pCStr->Set( pchNew );

    //
    // This is the last available url. Update _lastComma so we know...
    //
    if ( oldComma == _iLastComma )
    {
        _iLastComma = _cstrUrl.Length();
    }

    return TRUE;
}

//=============================================================
//
//  StripUrl
//      Remove url('...') from a string
//
//
//=============================================================
VOID
CCustomCursor::StripUrl( TCHAR* pch, int nLenIn , TCHAR** pchNew )
{
    TCHAR *psz = pch+4;
    TCHAR *quote = NULL;
    TCHAR *pszEnd;
    TCHAR terminator;

    Assert( ValidStyleUrl( pch) > 0 );

    while ( _istspace( *psz ) )
        psz++;
    if ( *psz == _T('\'') || *psz == _T('"') )
    {
        quote = psz++;
    }
    nLenIn--;   // Skip back over the ')' character - we know there is one, because ValidStyleUrl passed this string.
    pszEnd = pch + nLenIn - 1;
    while ( _istspace( *pszEnd ) && ( pszEnd > psz ) )
        pszEnd--;
    if ( quote && ( *pszEnd == *quote ) )
        pszEnd--;
    terminator = *(pszEnd+1);
    *(pszEnd+1) = _T('\0');

    *pchNew = psz;    
 }                           

BOOL 
IsCompositeUrl(CStr *pcstr, int startAt /*=0*/)
{
    BOOL fComplex = FALSE;
    UINT i;
    TCHAR* pstr;
    TCHAR  strComma[] = _T(",");

    // 
    // Scan the string looking for ","
    //

    for( pstr = *pcstr, i = startAt ; 
         i< pcstr->Length(); 
         i++,pstr++ )
    {
        if( 0==_tcsnicmp(pstr, 1, strComma, 1 ))
        {
            fComplex = TRUE;
            break;
        }                        
    }

    return fComplex;    

}

//------------------------------------------
//
// Is this a "composite" url ? Composite urls contain many urls
//
// eg. style="cursor:url('mything.cur'), url('custom.cur'), hand";
//
//-------------------------------------------

BOOL
CCustomCursor::IsCompositeUrl()
{
    return ::IsCompositeUrl( & _cstrUrl, _iLastComma+1 );       
}


BOOL 
CCustomCursor::IsCustomUrl( CStr* pCStr )
{
    return  ValidStyleUrl((TCHAR*) pCStr) > 0 ;
}

CCustomCursor::~CCustomCursor()
{    
    if ( _pBitsCtx )
    {
        _pBitsCtx->Release();
        _pBitsCtx = NULL;
    }
}

WORD
CCustomCursor::ComputeCrc() const
{
    DWORD dwCrc=0, z;

    for (z=0;z<sizeof(CCustomCursor)/sizeof(DWORD);z++)
    {
        dwCrc ^= ((DWORD*) this)[z];
    }
    return (LOWORD(dwCrc) ^ HIWORD(dwCrc));
}

//-------------------------------------------------------------
//
// CCustomCursor::BeginDownload
// 
// Begin the Cursor download. Set the _pBitsCtx
//
//-------------------------------------------------------------

HRESULT
CCustomCursor::BeginDownload(CStr* pCStr )
{
    HRESULT hr = E_FAIL;
    CBitsCtx   *pBitsCtx = NULL;
    CMarkup    *pMarkup = _pElement->GetMarkup();
    CDoc       *pDoc = pMarkup->Doc();



    //
    // Kick off the download of the cursor file 
    //

    if ( ! IsSpecialUrl( (LPCTSTR) *pCStr ))
    {        
        hr = THR(pDoc->NewDwnCtx( DWNCTX_FILE,
                    * pCStr  ,
                    _pElement,
                    (CDwnCtx **)&pBitsCtx,
                    pMarkup->IsPendingRoot()));
                    
        if ( hr == S_OK )
        {        
            SetBitsCtx( pBitsCtx);
        }

        if (pBitsCtx)
            pBitsCtx->Release();
    }
    
    RRETURN ( hr );

}

//-------------------------------------------------------------
//
// CCustomCursor::GetCursor
// 
// Return the _hCursor. Should be null if we haven't finished downloading.
//
//-------------------------------------------------------------

HCURSOR
CCustomCursor::GetCursor()
{
    return _hCursor;
}

void 
CCustomCursor::SetBitsCtx( CBitsCtx * pBitsCtx)
{
    if (_pBitsCtx)
        _pBitsCtx->Release();

    _pBitsCtx = pBitsCtx;

    if (pBitsCtx)
    {
        pBitsCtx->AddRef();

        // If the bits are here then just call OnDwnChan.
        // This will start handling the font (e.g., installing it).

        if (pBitsCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
            OnDwnChan(pBitsCtx);
        else
        {
            pBitsCtx->SetProgSink(CMarkup::GetProgSinkHelper( _pElement->GetMarkup()));
            pBitsCtx->SetCallback(OnDwnChanCallback, this);
            pBitsCtx->SelectChanges(DWNCHG_COMPLETE, 0, TRUE);
        }
    }
}


//*********************************************************************
//  CCustomCursor::OnChan()
//  Callback used by BitsCtx once it's downloaded our cursor file.
//*********************************************************************
void 
CCustomCursor::OnDwnChan(CDwnChan * pDwnChan)
{
    ULONG ulState = _pBitsCtx->GetState();
    CMarkup *pMarkup = _pElement->GetMarkup();
    CDoc *pDoc;
    BOOL fError = FALSE;
    
    Assert(pMarkup);
    pDoc = pMarkup->Doc();

    if (ulState & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
    {
        _pBitsCtx->SetProgSink(NULL); // detach download from document's load progress
    }

    if (ulState & DWNLOAD_COMPLETE)
    {
        LPTSTR szFile = NULL;
        if ( S_OK == _pBitsCtx->GetFile(&szFile) )
        {
            HANDLE hCur = LoadImage(NULL,
                                 szFile,
                                 IMAGE_CURSOR,
                                 0,
                                 0,
                                 LR_DEFAULTSIZE | LR_LOADFROMFILE ); 
            if ( hCur )
            {
                _hCursor = (HCURSOR) hCur;
            }
            else
            {            
                fError = TRUE;
            }
            MemFreeString( szFile );
        }
        
    }
    else
    {
        fError = ( ulState & DWNLOAD_ERROR ) ;
    }

    if ( fError && _fCompositeUrl )
    {       
        HandleNextUrl();
    }

}


VOID
CCustomCursor::HandleNextUrl()
{
    long lNewValue = 0 ;
    HRESULT hr;
    

    if ( GetNextUrl( & _cstrCurUrl ))
    {
        //
        // Need to see if this is a 'custom' url or not
        // by seeing if it matches a known property
        //            
        
        hr = LookupEnumString( & ( s_propdescCStylecursor.b) , _cstrCurUrl, & lNewValue );
        if ( hr )
        {
            BeginDownload( &_cstrCurUrl );
        }
        else
        {
            LPCTSTR idc = NULL;
        
            idc = GetCursorForStyle((BYTE)lNewValue);

            _hCursor = LoadCursorA(
                                    ((DWORD_PTR)idc >= (DWORD_PTR)IDC_ARROW) ? NULL : g_hInstCore,
                                    (char *)idc);
        
        }
    }
}

VOID    
CCustomCursor::GetCurrentUrl(CStr* pcstr) 
{
    Assert( pcstr );
    pcstr->Set( _cstrCurUrl );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\style\rulescol.cxx ===
//=================================================================
//
//   File:      rulescol.cxx
//
//  Contents:   CStyleSheetRuleArray class
//
//  Classes:    CStyleSheetRuleArray
//
//=================================================================

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_COLLBASE_HXX_
#define X_COLLBASE_HXX_
#include "collbase.hxx"
#endif

#ifndef X_RULESCOL_HXX_
#define X_RULESCOL_HXX_
#include "rulescol.hxx"
#endif

#ifndef X_RULESTYL_HXX_
#define X_RULESTYL_HXX_
#include "rulestyl.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "rulescol.hdl"

MtDefine(CStyleSheetRule, StyleSheets, "CStyleSheetRule")
MtDefine(CStyleSheetRuleArray, StyleSheets, "CStyleSheetRuleArray")


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CStyleSheetRuleArray
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------
const CBase::CLASSDESC CStyleSheetRuleArray::s_classdesc =
{
    &CLSID_HTMLStyleSheetRulesCollection,   // _pclsid
    0,                                      // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                                   // _pcpi
    0,                                      // _dwFlags
    &IID_IHTMLStyleSheetRulesCollection,    // _piidDispinterface
    &s_apHdlDescs                           // _apHdlDesc
};

//+----------------------------------------------------------------
//
//  member : CTOR
//
//+----------------------------------------------------------------
CStyleSheetRuleArray::CStyleSheetRuleArray( CStyleSheet *pStyleSheet ) : _pStyleSheet(pStyleSheet)
{
}

//+----------------------------------------------------------------
//
//  member : StyleSheetRelease()
//      This method calls Release(), but it is called from the parent
//  stylesheet during its destruction - so we need to make sure to
//  clear our pointer to the parent stylesheet at the same time.
//
//+----------------------------------------------------------------
int CStyleSheetRuleArray::StyleSheetRelease()
{
    Assert( _pStyleSheet );
    _pStyleSheet = NULL;
    return Release();
}

//+---------------------------------------------------------------
//
//  Member  : CStyleSheetRuleArray::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------
HRESULT
CStyleSheetRuleArray::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
        default:
        {
            const CLASSDESC *pclassdesc = BaseDesc();

            if (pclassdesc &&
                pclassdesc->_piidDispinterface &&
                (iid == *pclassdesc->_piidDispinterface))
            {
                HRESULT hr = THR(CreateTearOffThunk(this, s_apfnIHTMLStyleSheetRulesCollection, NULL, ppv));
                if (hr)
                    RRETURN(hr);
            }
        }
    }

    if (*ppv)
    {
        (*(IUnknown**)ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------
//
//  Member  : CStyleSheetRuleArray::length
//
//  Sysnopsis : IHTMLFiltersCollection interface method
//
//----------------------------------------------------------------

HRESULT
CStyleSheetRuleArray::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (_pStyleSheet ) 
        *pLength = _pStyleSheet->GetNumRules();
    else
        *pLength = 0;

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//+---------------------------------------------------------------
//
//  Member  : CStyleSheetRuleArray::item
//
//  Sysnopsis : IHTMLStyleSheetRulesCollection interface method
//
//----------------------------------------------------------------

HRESULT
CStyleSheetRuleArray::item(long lIndex, IHTMLStyleSheetRule **ppSSRule)
{
    HRESULT         hr;
    VARIANT         varDispatch;

    if (!ppSSRule)
    {
        RRETURN(E_POINTER);
    }

    hr = THR(GetItem(lIndex, &varDispatch));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&varDispatch) == VT_DISPATCH);
    *ppSSRule = (IHTMLStyleSheetRule *) V_DISPATCH(&varDispatch);

Cleanup:
    RRETURN(hr);
}

HRESULT 
CStyleSheetRuleArray::GetItem (long lIndex, VARIANT *pvar)
{
    HRESULT hr = S_OK;

    // ppSSRule is NULL if we're validating lIndex 
    if ( pvar )    
        V_DISPATCH(pvar) = NULL;

    if ( !_pStyleSheet )
    {
        hr = OLECMDERR_E_NOTSUPPORTED;
        goto Cleanup;
    }

    if ( lIndex < 0 || (unsigned int)lIndex >= _pStyleSheet->GetNumRules())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ( pvar )
    {
        hr = _pStyleSheet->OMGetOMRule( lIndex, (IHTMLStyleSheetRule**) &V_DISPATCH(pvar) );
        if (hr)
            goto Cleanup;

        V_VT(pvar) = VT_DISPATCH;
    }

Cleanup:
    RRETURN(hr);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CStyleSheetRule
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+----------------------------------------------------------------
//
//  member : ClassDesc Structure
//
//-----------------------------------------------------------------

const CBase::CLASSDESC CStyleSheetRule::s_classdesc =
{
    NULL,                                // _pclsid
    0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                                // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                                // _pcpi
    0,                                   // _dwFlags
    &IID_IHTMLStyleSheetRule,            // _piidDispinterface
    &s_apHdlDescs,                       // _apHdlDesc
};


//+----------------------------------------------------------------
//
//  member : CTOR
//
//-----------------------------------------------------------------

CStyleSheetRule::CStyleSheetRule( CStyleSheet *pStyleSheet, DWORD dwSID, ELEMENT_TAG eTag ) :
    _pStyleSheet(pStyleSheet),
    _dwID(dwSID),
    _eTag(eTag),
    _pStyle(NULL)
{
    //
    // The sid is local to pStyleSheet -- it should not contain sheet info.
    //
    Assert( 0 == ((CStyleID)dwSID).GetSheet() );
}

//+----------------------------------------------------------------
//
//  member : DTOR
//
//-----------------------------------------------------------------

CStyleSheetRule::~CStyleSheetRule()
{
    if ( _pStyle )
    {
        _pStyle->ClearRule();
        _pStyle->PrivateRelease();
    }
}

//+----------------------------------------------------------------
//
//  member : StyleSheetRelease()
//      This method calls Release(), but it is called from the parent
//  stylesheet during its destruction - so we need to make sure to
//  clear our pointer to the parent stylesheet at the same time.
//
//+----------------------------------------------------------------
int CStyleSheetRule::StyleSheetRelease()
{
    Assert( _pStyleSheet );
    _pStyleSheet = NULL;
    return Release();
}

CStyleRule *CStyleSheetRule::GetRule()
{   // Can't be inlined because of undefined CStyleSheetArray class.
    if ( _pStyleSheet )
    {
        CStyleID sid(_dwID);
        return _pStyleSheet->OMGetRule( _eTag, sid );
    }
    return NULL;
}

//+---------------------------------------------------------------------
//
//  Class:      CStyleSheetRule::PrivateQueryInterface
//
//------------------------------------------------------------------------
HRESULT
CStyleSheetRule::PrivateQueryInterface( REFIID iid, LPVOID *ppv )
{
    HRESULT hr = S_OK;

    if ( !ppv )
        return E_INVALIDARG;

    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS((IPrivateUnknown *)this, IUnknown)
    QI_TEAROFF_DISPEX(this, NULL)

    default:
        if (iid == IID_IHTMLStyleSheetRule)
        {
            hr = THR(CreateTearOffThunk(this, s_apfnIHTMLStyleSheetRule, NULL, ppv));
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }

    if ( *ppv )
        ((IUnknown *)*ppv)->AddRef();

    RRETURN(hr);
}

//*********************************************************************
//  CStyleSheetRule::selectorText
//      IHTMLStyleSheetRule interface method
//*********************************************************************
HRESULT
CStyleSheetRule::get_selectorText(BSTR *pBSTR)
{
    HRESULT hr = OLECMDERR_E_NOTSUPPORTED;

    if (!pBSTR)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pBSTR = NULL;

    if ( _pStyleSheet )
    {
        CStyleID sid( _dwID );

        CStyleRule *pRule = GetRule();
        Assert( pRule );
        CStyleSelector *pSelector = pRule->GetSelector();
        if ( pSelector )
        {
            CStr cstrSelector;
            pSelector->GetString( &cstrSelector );
            cstrSelector.TrimTrailingWhitespace();
            hr = cstrSelector.AllocBSTR( pBSTR );
        }
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

HRESULT
CStyleSheetRule::put_selectorText(BSTR bstr)
{
    HRESULT hr = E_NOTIMPL;

//Cleanup:
    RRETURN1( SetErrorInfo( hr ), E_NOTIMPL);
}

HRESULT CStyleSheetRule::get_style( IHTMLRuleStyle **ppStyle )
{
    HRESULT hr = S_OK;

    if ( !ppStyle )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    *ppStyle = NULL;

    if ( !_pStyle )
    {
        _pStyle = new CRuleStyle( this );
        if ( !_pStyle )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = _pStyle->QueryInterface( IID_IHTMLRuleStyle, (void**)ppStyle);

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

HRESULT CStyleSheetRule::get_readOnly( VARIANT_BOOL * pvbReadOnly )
{
    Assert( pvbReadOnly );
    
    RRETURN( SetErrorInfo( _pStyleSheet->get_readOnly( pvbReadOnly ) ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\style\sheetcol.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       sheetcol.cxx
//
//  Contents:   Support for collections of Cascading Style Sheets.. including:
//
//              CStyleSheetArray
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"  // For CAnchorElement decl, for pseudoclasses
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_FONTFACE_HXX_
#define X_FONTFACE_HXX_
#include "fontface.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "sheetcol.hdl"

DeclareTag(tagStyleSheetApply,                    "Style Sheet Apply", "trace Style Sheet application")
ExternTag(tagStyleSheet)

//*********************************************************************
//      CStyleSheetArray
//*********************************************************************
const CStyleSheetArray::CLASSDESC CStyleSheetArray::s_classdesc =
{
    {
        &CLSID_HTMLStyleSheetsCollection,    // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        NULL,                                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
        NULL,                                   // _pcpi
        0,                                   // _dwFlags
        &IID_IHTMLStyleSheetsCollection,     // _piidDispinterface
        &s_apHdlDescs                        // _apHdlDesc
    },
    (void *)s_apfnIHTMLStyleSheetsCollection         // _apfnTearOff
};

//*********************************************************************
//      CStyleSheetArray::CStyleSheetArray()
//  When you create a CStyleSheetArray, the owner element specified will
//  have a subref added.  In the case of the top-level stylesheets collection,
//  the owner is the CDoc.  In the case of imports collections, the owner is
//  a CStyleSheet.
//*********************************************************************
CStyleSheetArray::CStyleSheetArray(
    CBase * const pOwner,             // CBase obj that controls our lifetime/does our ref-counting.
    CStyleSheetArray * pRootSSA,      // NULL if we are the RootSSA
    CStyleSheetID const sidParentSheet)    // ID of our owner's SS (non-zero for CSSA storing imported SS only)
    :
    _pOwner(pOwner),
    _fInvalid(FALSE),
    _aStyleSheets()
{
    WHEN_DBG( _fFreed = FALSE );

    // If we are constructed w/ a NULL manager, then we manage our own storage
    _pRootSSA = pRootSSA ? pRootSSA : this;

    WHEN_DBG( _nValidLevels = 0 );

    if (!ChangeID(sidParentSheet))
    {
        _fInvalid = TRUE;
    }

    // Add-ref ourselves before returning from constructor.  This will actually subref our owner.
    AddRef();

}


BOOL
CStyleSheetArray::ChangeID(CStyleSheetID const sidParentSheet)
{
    unsigned int parentLevel;
    CStyleSheet **pSS;
    int  i;
    CStyleSheetID    sidSheet;

    _sidForOurSheets = sidParentSheet;
    _sidForOurSheets.SetRule(0);  // Clear rule information

    parentLevel = sidParentSheet.FindNestingLevel();
    // We are one level deeper than our parents.
    _Level = parentLevel + 1;
    Assert( "Invalid level computed for stylesheet array! (informational only)" && _Level > 0 && _Level < 5 );
    if ( _Level > MAX_IMPORT_NESTING )
    {
        _Level = MAX_IMPORT_NESTING;
        return FALSE;
    }

    // We want _sidForOurSheets to be the ID that should be assigned to stylesheets built by this array.
    // If we're being built to hold imported stylesheets (_Level > 1), patch the ID by lowering previous
    // level by 1.
    if ( _Level > 1 )
    {
        unsigned long parentLevelValue = sidParentSheet.GetLevel( parentLevel );
        Assert( "Nested stylesheets must have non-zero parent level value!" && parentLevelValue );
        _sidForOurSheets.SetLevel( parentLevel, parentLevelValue-1 );
    }

    sidSheet = _sidForOurSheets;
    for (i = 0, pSS = _aStyleSheets;  i < _aStyleSheets.Size(); i++, pSS++)
    {
        sidSheet.SetLevel(_Level, i+1);
        if (! (*pSS)->ChangeID(sidSheet))
            return FALSE;
    }
    
    return TRUE;
}

//*********************************************************************
//      CStyleSheetArray::~CStyleSheetArray()
//  Recall we don't maintain our own ref-count; this means our memory
//  doesn't go away until our owner's memory is going away.  In order
//  to do this, the owner has to call ->CBase::PrivateRelease() on us.
//  (see the CDoc destructor for example).
//  This works because: a) we start with an internal ref-count of 1,
//  which is keeping us alive, b) that internal ref-count is never
//  exposed to changes (all AddRef/Release calls are delegated out).
//  So in effect the internal ref-count of 1 is held by the owner.
//*********************************************************************
CStyleSheetArray::~CStyleSheetArray()
{
    Assert( "Must call Free() before destructor!" && _fFreed );
}

#if DBG==1
CStyleSheetArray::CCheckValid::CCheckValid( CStyleSheetArray *pSSA ) 
{ 
    Assert(pSSA);
    _pSSA = pSSA->RootManager(); 
    if (_pSSA->_nValidLevels == 0)
    {
        Assert( _pSSA->DbgIsValidImpl() );
    }
    _pSSA->_nValidLevels++; 
}

CStyleSheetArray::CCheckValid::~CCheckValid() 
{ 
    if (--(_pSSA->_nValidLevels) == 0) 
        Assert( _pSSA->DbgIsValidImpl() ); 
}

BOOL 
CStyleSheetArray::DbgIsValidImpl()
{
    //
    // For every style sheet, check the stylesheet is valid
    //
    {
        CStyleSheet * pSS;
        int nSS, iSS;
        for (iSS = 0, nSS = _aStyleSheets.Size(); iSS < nSS; iSS++)
        {
            pSS = _aStyleSheets[iSS];
            if (!pSS->DbgIsValid())
                return FALSE;
                
            // Recursivly call for import SSA
            if (    pSS->_pImportedStyleSheets 
                && !pSS->_pImportedStyleSheets->DbgIsValidImpl())
                return FALSE;
        }
    }

    return TRUE;
}



VOID CStyleSheetArray::Dump()
{
    if (!InitDumpFile())
        return;
    
    Dump(FALSE);

    CloseDumpFile( );
}



VOID CStyleSheetArray::Dump(BOOL fRecursive)
{
    int z;
    int nSheets;

    if (!fRecursive)
    {
        fRecursive = TRUE;
    }
    
    if (RootManager() != this)
    {
        WriteChar(g_f, ' ', 8 * _Level);
    }
    WriteHelp(g_f, _T("<0d>[StyleSheetArray]-0x<1x>\r\n"), _Level, _sidForOurSheets);
    
    for (z=0, nSheets = _aStyleSheets.Size(); z<nSheets; ++z)
    {
        CStyleSheet *pSS = _aStyleSheets[z];
        WriteChar(g_f, ' ', 8 * _Level);
        WriteHelp(g_f, _T("sheet <0d>:"), z);
        pSS->Dump(fRecursive);
        WriteHelp(g_f, _T("\r\n"));
    }
}


#endif

//*********************************************************************
//      CStyleSheetArray::PrivateQueryInterface()
//*********************************************************************
HRESULT
CStyleSheetArray::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
        default:
        {
            const CLASSDESC *pclassdesc = ElementDesc();

            if (pclassdesc &&
                pclassdesc->_apfnTearOff &&
                pclassdesc->_classdescBase._piidDispinterface &&
                (iid == *pclassdesc->_classdescBase._piidDispinterface))
            {
                HRESULT hr = THR(CreateTearOffThunk(this, (void *)(pclassdesc->_apfnTearOff), NULL, ppv));
                if (hr)
                    RRETURN(hr);
            }
        }
    }

    if (*ppv)
    {
        (*(IUnknown**)ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//*********************************************************************
// CStyleSheetArray::Invoke, IDispatch
// Provides access to properties and members of the object
//
// Arguments:   [dispidMember] - Member id to invoke
//              [riid]         - Interface ID being accessed
//              [wFlags]       - Flags describing context of call
//              [pdispparams]  - Structure containing arguments
//              [pvarResult]   - Place to put result
//              [pexcepinfo]   - Pointer to exception information struct
//              [puArgErr]     - Indicates which argument is incorrect
//
// We override this to support ordinal and named member access to the
// elements of the collection.
//*********************************************************************

STDMETHODIMP
CStyleSheetArray::InvokeEx( DISPID       dispidMember,
                        LCID         lcid,
                        WORD         wFlags,
                        DISPPARAMS * pdispparams,
                        VARIANT *    pvarResult,
                        EXCEPINFO *  pexcepinfo,
                        IServiceProvider *pSrvProvider)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    LPCTSTR pszName;
    long lIdx;

    // Is the dispid an ordinal index? (array access)
    if ( IsOrdinalSSDispID( dispidMember) )
    {
        if ( wFlags & DISPATCH_PROPERTYPUT )
        {
            // Stylesheets collection is readonly.
            // Inside OLE says return DISP_E_MEMBERNOTFOUND.
            goto Cleanup;
        }
        else if ( wFlags & DISPATCH_PROPERTYGET )
        {
            if (pvarResult)
            {
                lIdx = dispidMember - DISPID_STYLESHEETSCOLLECTION_ORDINAL_BASE;
                // item() will bounds check for us.
                hr = item( lIdx, (IHTMLStyleSheet **) &(pvarResult->pdispVal));
                if (hr)
                {
                    Assert( pvarResult->pdispVal == NULL );
                    pvarResult->vt = VT_NULL;
                }
                else
                {
                    Assert( pvarResult->pdispVal );
                    pvarResult->vt = VT_DISPATCH;
                }

            }
        }
    }
    else if ( IsNamedSSDispID( dispidMember) )
    {
        if ( wFlags & DISPATCH_PROPERTYPUT )
        {
            // Stylesheets collection is readonly.
            // Inside OLE says return DISP_E_MEMBERNOTFOUND.
            goto Cleanup;
        }
        else if ( wFlags & DISPATCH_PROPERTYGET )
        {
            if (pvarResult)
            {
                hr = GetAtomTable()->
                        GetNameFromAtom( dispidMember - DISPID_STYLESHEETSCOLLECTION_NAMED_BASE,
                                         &pszName );
                if (hr)
                {
                    pvarResult->pdispVal = NULL;
                    pvarResult->vt = VT_NULL;
                    goto Cleanup;
                }

                lIdx = FindSSByHTMLID( pszName, TRUE );
                // lIdx will be -1 if SS not found, in which case item will return an error.
                hr = item( lIdx, (IHTMLStyleSheet **) &(pvarResult->pdispVal));
                if (hr)
                {
                    Assert( pvarResult->pdispVal == NULL );
                    pvarResult->vt = VT_NULL;
                }
                else
                {
                    Assert( pvarResult->pdispVal );
                    pvarResult->vt = VT_DISPATCH;
                }
            }
        }
    }
    else
    {
        // CBase knows how to handle expando
        hr = THR_NOTRACE(super::InvokeEx( dispidMember,
                                        lcid,
                                        wFlags,
                                        pdispparams,
                                        pvarResult,
                                        pexcepinfo,
                                        pSrvProvider));
    }

Cleanup:
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}

//*********************************************************************
//  CStyleSheetArray::GetDispID, IDispatchEx
//  Overridden to output a particular dispid range for ordinal access,
//  and another range for named member access.  Ordinal access dispids
//  range from DISPID_STYLESHEETSCOLLECTION_ORDINAL_BASE to
//  DISPID_STYLESHEETSCOLLECTION_ORDINAL_MAX.  Named access dispids
//  range from DISPID_STYLESHEETSCOLLECTION_NAMED_BASE to
//  DISPID_STYLESHEETSCOLLECTION_NAMED_MAX.
//********************************************************************

STDMETHODIMP
CStyleSheetArray::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT           hr = E_FAIL;
    long              lIdx = 0;
    long              lAtom = 0;
    DISPID            dispid = 0;

    Assert( bstrName && pid );

    // Could be an ordinal access
    hr = ttol_with_error(bstrName, &lIdx);
    if ( !hr )
    {
        dispid = DISPID_STYLESHEETSCOLLECTION_ORDINAL_BASE + lIdx;
        *pid = (dispid > DISPID_STYLESHEETSCOLLECTION_ORDINAL_MAX) ?
                        DISPID_UNKNOWN : dispid;
        hr = S_OK;
        goto Cleanup;
    }

    // Not ordinal access; could be named (via id) access if we're the top-level collection
    if ( _Level == 1 )
    {
        lIdx = FindSSByHTMLID( bstrName, (grfdex & fdexNameCaseSensitive) ? TRUE : FALSE );
        if ( lIdx != -1 )   // -1 means not found
        {
            // Found a matching ID!

            // Since we found the element in the elements collection,
            // update atom table.  This will just retrieve the atom if
            // the string is already in the table.
            Assert( bstrName );
            hr = GetAtomTable()->AddNameToAtomTable(bstrName, &lAtom);
            if ( hr )
                goto Cleanup;
            // lAtom is the index into the atom table.  Offset this by
            // base.
            lAtom += DISPID_STYLESHEETSCOLLECTION_NAMED_BASE;
            *pid = lAtom;
            if (lAtom > DISPID_STYLESHEETSCOLLECTION_NAMED_MAX)
            {
                hr = DISP_E_UNKNOWNNAME;
            }
            goto Cleanup;
        }
    }

    // Otherwise delegate to CBase impl for expando support etc.
    hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pid));

Cleanup:
    RRETURN(THR_NOTRACE( hr ));
}

//*********************************************************************
//  CStyleSheetArray::GetNextDispID, IDispatchEx
//  Supports enumerating our collection indices in addition to the
//  collection's own properties.  Semantically this implementation is
//  known to be incorrect; prgbstr and prgid should match (both should
//  be the next dispid).  This is due to the current implementation in
//  the element collections code (collect.cxx); when that gets fixed,
//  this should be looked at again.  In particular, the way we begin
//  to enumerate indices is wonky; we should be using the start enum
//  DISPID value.
//*********************************************************************
STDMETHODIMP
CStyleSheetArray::GetNextDispID(DWORD grfdex,
                                DISPID id,
                                DISPID *prgid)
{
    HRESULT hr = S_OK;
    Assert( prgid );

    // Are we in the middle of enumerating our indices?
    if ( !IsOrdinalSSDispID(id) )
    {
        // No, so delegate to CBase for normal properties
        hr = super::GetNextDispID( grfdex, id, prgid );
        if (hr)
        {
            // normal properties are done, so let's start enumerating indices
            // if we aren't empty.  Return string for index 0,
            // and DISPID for index 1.
            if (_aStyleSheets.Size())
            {
                *prgid = DISPID_STYLESHEETSCOLLECTION_ORDINAL_BASE;
                hr = S_OK;
            }
        }
    }
    else
    {
        // Yes we're enumerating indices, so return string of current DISPID, and DISPID for next index,
        // or DISPID_UNKNOWN if we're out of bounds.
        if ( !IsOrdinalSSDispID(id+1) || (((long)(id+1-DISPID_STYLESHEETSCOLLECTION_ORDINAL_BASE)) >= _aStyleSheets.Size()) )
        {
            *prgid = DISPID_UNKNOWN;
            hr = S_FALSE;
            goto Cleanup;
        }

        ++id;
        *prgid = id;
    }

Cleanup:
    RRETURN1(THR_NOTRACE( hr ), S_FALSE);
}

STDMETHODIMP
CStyleSheetArray::GetMemberName(DISPID id, BSTR *pbstrName)
{
    TCHAR   ach[20];

    if (!pbstrName)
        return E_INVALIDARG;

    *pbstrName = NULL;

    // Are we in the middle of enumerating our indices?
    if ( !IsOrdinalSSDispID(id) )
    {
        // No, so delegate to CBase for normal properties
        super::GetMemberName(id, pbstrName);
    }
    else
    {
        // Yes we're enumerating indices, so return string of current DISPID, and DISPID for next index,
        // or DISPID_UNKNOWN if we're out of bounds.
        if ( !IsOrdinalSSDispID(id) || (((long)(id-DISPID_STYLESHEETSCOLLECTION_ORDINAL_BASE)) >= _aStyleSheets.Size()) )
            goto Cleanup;

        if (Format(0, ach, ARRAY_SIZE(ach), _T("<0d>"), (long)id-DISPID_STYLESHEETSCOLLECTION_ORDINAL_BASE))
            goto Cleanup;

        FormsAllocString(ach, pbstrName);
    }

Cleanup:
    return *pbstrName ? S_OK : DISP_E_MEMBERNOTFOUND;
}

// Helpers for determining whether dispids fall into particular ranges.
BOOL CStyleSheetArray::IsOrdinalSSDispID( DISPID dispidMember )
{
    return ((dispidMember >= DISPID_STYLESHEETSCOLLECTION_ORDINAL_BASE) &&
           (dispidMember <= DISPID_STYLESHEETSCOLLECTION_ORDINAL_MAX));
}

BOOL CStyleSheetArray::IsNamedSSDispID( DISPID dispidMember )
{
    return ((dispidMember >= DISPID_STYLESHEETSCOLLECTION_NAMED_BASE) &&
           (dispidMember <= DISPID_STYLESHEETSCOLLECTION_NAMED_MAX));
}


//*********************************************************************
//      CStyleSheetArray::Free()
//              Release all stylesheets we're holding, and clear our storage.
//  After this has been called, we are an empty array.  If we were
//      responsible for holding onto rules, they too have been emptied.
//*********************************************************************
void CStyleSheetArray::Free( void )
{
    // Forget all the CStyleSheets we're storing
    CStyleSheet **ppSheet;
    int z;
    int nSheets = _aStyleSheets.Size();
    for (ppSheet = (CStyleSheet **) _aStyleSheets, z=0; z<nSheets; ++z, ++ppSheet)
    {
         // We need to make sure that when imports stay alive after the collection
         // holding them dies, they don't point to their original parent (all sorts
         // of badness would occur because we wouldn't be able to tell that the
         // import is effectively out of the collection, since the parent chain would
         // be intact).
         (*ppSheet)->DisconnectFromParentSS();
         if ( (*ppSheet)->GetRootContainer() == this )
             (*ppSheet)->_pSSAContainer = NULL;

         (*ppSheet)->Release();
    }
    _aStyleSheets.DeleteAll();

    _cstrUserStylesheet.Free();
    WHEN_DBG( _fFreed = TRUE );
}

//*********************************************************************
//  CStyleSheetArray::CreateNewStyleSheet()
//      This method creates a new CStyleSheet object and adds it to the
//  array (at the end).  The newly created stylesheet has an ref count of 1
//  and has +1 subrefs on the parent element, which are considered to be
//  held by the stylesheet array.  If the caller decides to keep a pointer
//  to the newly created stylesheet (e.g. when a STYLE or LINK element
//  creates a new stylesheet and tracks it), it must call CreateNewStyleSheet
//  to get the pointer and then make sure to AddRef it.
//
//  S_OK    :  no need to download
//  S_FALSE :  need to download
//
//*********************************************************************
HRESULT CStyleSheetArray::CreateNewStyleSheet( CStyleSheetCtx *pCtx, CStyleSheet **ppStyleSheet,
                                               long lPos /*=-1*/, long *plNewPos /*=NULL*/)
{
    // lPos == -1 indicates append.
    HRESULT hr = S_OK;
    HRESULT hrReturn = hr;

    if (!ppStyleSheet)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppStyleSheet = NULL;

    if ( lPos == _aStyleSheets.Size() )
        lPos = -1;

    if ( plNewPos )
        *plNewPos = -1;     // -1 means failed to create

    // If our level is full, then just don't create the requested stylesheet.
    if ( _aStyleSheets.Size() >= MAX_SHEETS_PER_LEVEL )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Create the stylesheet
    hr =CStyleSheet::Create(pCtx, ppStyleSheet, this);
    if (!SUCCEEDED(hr))
        goto Cleanup;
    hrReturn = hr;

    hr = AddStyleSheet(*ppStyleSheet, lPos, plNewPos);

    if (!hr)
        (*ppStyleSheet)->Release();       // Remove the extra one the Add put on to keep the count correct
Cleanup:
    if ( !SUCCEEDED(hr) )   // need to propagate the error code back
    {
        if (ppStyleSheet && *ppStyleSheet)
        {
            delete *ppStyleSheet;
            *ppStyleSheet = NULL;
        }
        hrReturn = hr;
    }
    RRETURN1(hrReturn, S_FALSE);
}


//*********************************************************************
//  CStyleSheetArray::AddStyleSheet()
//  This method tells the array to add the stylesheet to the array, like
//  CreateStyleSheet, but with an existing StyleSheet
//*********************************************************************
HRESULT CStyleSheetArray::AddStyleSheet( CStyleSheet * pStyleSheet, long lPos /* = -1 */, long *plNewPos /* = NULL */ )
{
    WHEN_DBG( CStyleSheetArray::CCheckValid checkValid(this) );
#if DBG == 1
    if (IsTagEnabled(tagStyleSheet))
    {
        WHEN_DBG( Dump(FALSE) );
    }
#endif
    
    // lPos == -1 indicates append.
    HRESULT hr = S_OK;
    CStyleSheetID id = _sidForOurSheets;      // id for new sheet
    long lValue;

    Assert ( pStyleSheet );
    Assert ( lPos >= -1 && lPos <= _aStyleSheets.Size() );

    if ( lPos == _aStyleSheets.Size() )
        lPos = -1;

    if ( plNewPos )
        *plNewPos = -1;     // -1 means failed to create

    // If our level is full, then just don't create the requested stylesheet.
    if ( _aStyleSheets.Size() >= MAX_SHEETS_PER_LEVEL )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Set value for current level of new sheet
    lValue = ((lPos == -1) ? _aStyleSheets.Size() : lPos) + 1;
    id.SetLevel( _Level, lValue );

    // Change the StyleSheet container (is a no-op when just created), including import sheets
    pStyleSheet->ChangeContainer(_pRootSSA);

    // Update all the rules for this StyleSheet with the new ID
    pStyleSheet->ChangeID(id);

    if (lPos == -1) // Append..
    {
        hr = _aStyleSheets.AppendIndirect( &pStyleSheet );
        // Return the index of the newly appended sheet
        if ( plNewPos )
            *plNewPos = _aStyleSheets.Size()-1;
    }
    else            // ..or insert
    {
        hr = _aStyleSheets.InsertIndirect( lPos, &pStyleSheet );
        if ( hr )
            goto Cleanup;

        // Return the index of the newly inserted sheet
        if ( plNewPos )
            *plNewPos = lPos;

        // Patch ids of sheets that got shifted up by the insertion.
        // Start patching at +1 from the insertion position.
        for ( ++lPos; lPos < _aStyleSheets.Size() ; ++lPos )
        {
            _aStyleSheets[lPos]->PatchID( _Level, lPos+1, FALSE  );
        }
    }

    pStyleSheet->AddRef();          // Reference for the Add or the Create

Cleanup:
    RRETURN( hr );
}

//*********************************************************************
//  CStyleSheetArray::ReleaseStyleSheet()
//  This method tells the array to release its reference to a stylesheet,
//  After this, as far as the array is concerned, the stylesheet does not
//  exist -- it no longer has a pointer to it, all other stylesheets have
//  their ids patched, and the rules of the released stylesheet are marked
//  as gone from the tree and have ids of 0.
//*********************************************************************
HRESULT CStyleSheetArray::ReleaseStyleSheet( CStyleSheet * pStyleSheet, BOOL fForceRender )
{
    HRESULT hr = E_FAIL;

    WHEN_DBG( CStyleSheetArray::CCheckValid checkValid(this) );

    Assert( pStyleSheet );
    Assert( pStyleSheet->_sidSheet.FindNestingLevel() == _Level );

    long idx = _aStyleSheets.FindIndirect( &pStyleSheet );
    if (idx == -1) // idx == -1 if not found; e.g. an elem releasing its SS which has already been removed from SSC via OM.
        return hr;

    _aStyleSheets.Delete(idx);  // no return value

    Assert( pStyleSheet->_sidSheet.GetLevel( _Level ) == (unsigned long)(idx+1) );

    // Make sure the appropriate rules get marked to reflect the fact this stylesheet is out of the
    // collection (a.k.a out of the tree).
    hr = pStyleSheet->ChangeStatus( CS_DETACHRULES, fForceRender, NULL );

    // Patch ids of remaining stylesheets (each SS that came after us has its level value reduced by 1)
    // Start patching at the idx where we just deleted (everyone was shifted down).
    while (idx < _aStyleSheets.Size())
    {
        _aStyleSheets[idx]->PatchID( _Level, idx+1, FALSE );
        ++idx;
    }

    // Release that ref that used to be held by this collection/array
    pStyleSheet->Release();

    return hr;
}


CStyleSheet *
CStyleSheetArray::FindStyleSheetForSID(CStyleSheetRuleID sidTarget)
{
    unsigned long uLevel;
    unsigned long uWhichLevel;
    unsigned long uSheetTarget = sidTarget.GetSheet();

    CDataAry<CStyleSheet*> *pArray = &_aStyleSheets;
    CStyleSheet *pSheet;

    // For each level in the incoming SID
    for ( uLevel = 1 ;
        uLevel <= MAX_IMPORT_NESTING && pArray ;
        uLevel++ )
    {
        uWhichLevel = sidTarget.GetLevel(uLevel);

        Assert(uWhichLevel <= (unsigned long)pArray->Size());

        // Either we exactly match one in the current array at our index for this level
        if ( uWhichLevel && ((*pArray)[uWhichLevel-1])->_sidSheet.GetSheet() == uSheetTarget )
            return (*pArray)[uWhichLevel-1];
        // Or we need to dig into the imports array
        pSheet = (*pArray)[uWhichLevel];
        if ( !pSheet->_pImportedStyleSheets )
            break;
        pArray = &(pSheet->_pImportedStyleSheets->_aStyleSheets);
    }
    return NULL;
}



void
CachedStyleSheet::PrepareForCache (CStyleSheetRuleID sidSR, CStyleRule *pRule)
{
    _pRule = pRule;
    _sidSR = sidSR;
}

LPTSTR
CachedStyleSheet::GetBaseURL(void)
{
    unsigned int    uSIdx;

    if (_pRule && _sidSR)
    {
        uSIdx = _sidSR.GetSheet();
        if (!(_pCachedSS && _uCachedSheet == uSIdx))
        {
            _pCachedSS = _pssa->GetSheet(_sidSR);
            _uCachedSheet = uSIdx;
        }
        return _pCachedSS->GetAbsoluteHref();
    }
    else
    {
       return NULL;
    }

}

MtDefine(CRules_ary, CStyleSheetArray, "CRules_ary")


BOOL CStyleSheetArray::OnlySimpleRulesApplied(CFormatInfo *pCFI)
{
    BOOL fSimple = TRUE;
    CStyleRule *pRule;
    CProbableRules *ppr;

    Assert(!pCFI->_ProbRules.IsItValid(this));
    if (S_OK != THR(BuildListOfProbableRules(pCFI->_pNodeContext, &pCFI->_ProbRules)))
    {
        fSimple = FALSE;
        goto Cleanup;
    }

    ppr = &pCFI->_ProbRules;
    Assert(ppr->IsItValid(this));
    if (ppr->_cRules.Size())
    {
        for (LONG i = 0; i < ppr->_cRules.Size(); i++)
        {
            pRule = ppr->_cRules[i]._pRule;
            Assert(pRule);
            if (pRule->GetSelector()->_pParent)
                fSimple = FALSE;
        }
    }

    if (ppr->_cWRules.Size())
    {
        for (LONG i = 0; i < ppr->_cWRules.Size(); i++)
        {
            pRule = ppr->_cWRules[i]._pRule;
            Assert(pRule);
            if (pRule->GetSelector()->_pParent)
                fSimple = FALSE;
        }
    }
    
Cleanup:
    return fSimple;
}

HRESULT
CStyleSheetArray::BuildListOfProbableRules(
                    CTreeNode *pNode, CProbableRules *ppr, 
                    CClassIDStr *pclsStrLink,       // computed class string/hash value
                    CClassIDStr *pidStr,        // computed id string/has value
                    BOOL  fRecursiveCall        // FALSE for ext. callers
                    )
{
    HRESULT hr = S_OK;
    CStyleSheet * pSS;
    int nSS, iSS;

    LPCTSTR pszClass;
    LPCTSTR pszID;
    INT nClassIdLen = 0;
    BOOL fRootCall = FALSE;

    CClassIDStr  clsStrOnStack;
    CClassIDStr  idStrOnStack;
    
    if (!fRecursiveCall)
    {
        Assert(pclsStrLink == NULL);
        Assert(pidStr == NULL);
        
        CElement *pElement = pNode->Element();
        if (!pclsStrLink)
        {
            HRESULT hrClass = pElement->GetStringAt(
                                pElement->FindAAIndex(DISPID_CElement_className, CAttrValue::AA_Attribute), 
                                &pszClass);
            if (!hrClass && pszClass && *pszClass)
            {
                CDataListEnumerator pClassIdNames(pszClass); 
                if (pClassIdNames.GetNext(&pszClass, &nClassIdLen))
                {
                    CClassIDStr  **pNext= &pclsStrLink;
                    //
                    // if we only have one class name, which probably will
                    // be most common, then we don't allocate memory on heap
                    //
                    pclsStrLink         = &clsStrOnStack;

                    (*pNext)->_dwHashKey   = HashStringCiDetectW(pszClass, nClassIdLen, 0);
                    (*pNext)->_dwHashKey   = FormalizeHashKey( (*pNext)->_dwHashKey << 2 );
                    (*pNext)->_eType       = eClass;
                    (*pNext)->_strClassID  = pszClass;
                    (*pNext)->_nClassIDLen = nClassIdLen;
                    (*pNext)->_pNext       = NULL;

                    // If we have to allocate memory, do it
                    while (pClassIdNames.GetNext(&pszClass, &nClassIdLen))
                    {
                        Assert(pNext);
                        pNext = &((*pNext)->_pNext);
                        *pNext = new CClassIDStr();
                        if (!(*pNext))
                        {
                            hr = E_OUTOFMEMORY;
                            goto Cleanup;
                        }
                        
                        (*pNext)->_dwHashKey   = HashStringCiDetectW(pszClass, nClassIdLen, 0);
                        (*pNext)->_dwHashKey   = FormalizeHashKey( (*pNext)->_dwHashKey << 2 );
                        (*pNext)->_eType       = eClass;
                        (*pNext)->_strClassID  = pszClass;
                        (*pNext)->_nClassIDLen = nClassIdLen;
                        (*pNext)->_pNext       = NULL;
                    }
                 }
            }
        }

        if (!pidStr)
        {
            HRESULT hrID = pElement->GetStringAt(
                                pElement->FindAAIndex(DISPID_CElement_id, CAttrValue::AA_Attribute),
                                &pszID);
            if (!hrID && pszID && &pszID)
            {
                idStrOnStack._dwHashKey = FormalizeHashKey( HashStringCiDetectW(pszID, _tcslen(pszID), 0) << 2 );
                idStrOnStack._eType       = eID;
                idStrOnStack._strClassID  = pszID;
                idStrOnStack._nClassIDLen = _tcslen(pszID);
                idStrOnStack._pNext       = NULL;
                pidStr = &idStrOnStack;
            }
        }

        fRootCall = TRUE;
        fRecursiveCall = TRUE;
    }


    if (fRootCall) 
        ppr->Init();

    //
    // Now do a depth first traverse
    //
    for (iSS = 0, nSS = _aStyleSheets.Size(); iSS < nSS; iSS++)
    {
        pSS = _aStyleSheets[iSS];
        Assert(pSS);
        hr = THR(pSS->AppendListOfProbableRules(pNode, ppr, pclsStrLink, pidStr, fRecursiveCall));
        if (hr)
            goto Cleanup;
    }
    
    if (fRootCall) 
    {
        ppr->Validate(this);

        if (pclsStrLink && (pclsStrLink == &clsStrOnStack))
        {
            // we are the one who allocated memory
            // skip the first one since it is one stack
            pclsStrLink = pclsStrLink->_pNext;
            while (pclsStrLink)
            {
                CClassIDStr  *pN = pclsStrLink->_pNext;
                delete pclsStrLink;
                pclsStrLink = pN;
            }
        }
    }

    
Cleanup:    
    RRETURN(hr);
}

//*********************************************************************
//  CStyleSheetArray::Apply()
//      This method applies (in cascade order) all style rules in the
//  collection of all sheets in this Array that apply to this element
//  context to the formats passed in pStyleInfo.
//*********************************************************************

#ifdef CSSSHARE_NOPRESORT
//  ascending order according to specificity
int RTCCONV CompareRules(const void * pvElem1, const void * pvElem2)
{
    CProbableRuleEntry *pvRE1 = (CProbableRuleEntry *)pvElem1;
    CProbableRuleEntry *pvRE2 = (CProbableRuleEntry *)pvElem2;

    Assert(pvRE1->_pRule && pvRE1->_pRule->IsMemValid() && "CompareRules called on non-CProbableRuleEntry item" );
    Assert(pvRE2->_pRule && pvRE2->_pRule->IsMemValid() && "CompareRules called on non-CProbableRuleEntry item" );

    DWORD   dwSP1 = pvRE1->_pRule->GetSpecificity();
    DWORD   dwSP2 = pvRE2->_pRule->GetSpecificity();

    if (dwSP1 == dwSP2)
    {
        if (pvRE1->_sidSheetRule > pvRE2->_sidSheetRule)
        {
            return 1;
        }
        else
        {  
            return -1;
        }
        // never return 0
    }
    else if (dwSP1 > dwSP2)
        return 1;
    else 
        return -1;
}
#endif



HRESULT CStyleSheetArray::Apply( CStyleInfo *pStyleInfo,
        ApplyPassType passType,
        EMediaType eMediaType,
        BOOL *pfContainsImportant /*=NULL*/ )
{
    HRESULT hr = S_OK;

    // Cache for class & ID on this element and potentially its parents (if they get walked)
    CStyleClassIDCache CIDCache;

#if DBG == 1
    if (IsTagEnabled(tagStyleSheetApply))
    {
        WHEN_DBG( Dump() );
    }
#endif

    WHEN_DBG( CTreeNode *pNode = pStyleInfo->_pNodeContext );

    // used to walk through ppTRules
    CStyleRule  *pTagRule = NULL;
    CStyleSheetRuleID sidTagRule = 0;
    int nTagRules;
    int iLastTagRule = -1;


    // used to walk through ppWcRules
    CStyleRule *pWildcardRule = NULL;
    CStyleSheetRuleID  sidWildRule = 0;
    int nWildcardRules;
    int iLastWCRule = -1;

    CStyleRule *pRule = NULL;

    // If we _know_ there's no class/id on this elem, don't bother w/ wildcard rules
    CachedStyleSheet cachedSS(this);
    CFormatInfo *pCFI;
    EPseudoElement epeTag = pelemNone;
    EPseudoElement epeWildcard = pelemNone;

    int iWCNum = 0;
    int iTagNum = 0;
    BOOL fTagApplied = TRUE;
    BOOL fWildcardApplied = TRUE;

    CRules *pcRules;
    CRules *pcWRules;
    CProbableRules ProbRules;
    
    if (!pStyleInfo->_ProbRules.IsItValid(this))
    {
        // Its not valid or its valid for a different style sheet. In any case
        // lets build the new list in a different place since if its actuall
        // built, then we want it to remain built since it will be used by
        // that style sheet at a later time.
        BuildListOfProbableRules(pStyleInfo->_pNodeContext, &ProbRules);
        pcRules  = &ProbRules._cRules;
        pcWRules = &ProbRules._cWRules;
    }
    else
    {
        // Valid for this style sheet, so just use the one in the style info
        pcRules  = &pStyleInfo->_ProbRules._cRules;
        pcWRules = &pStyleInfo->_ProbRules._cWRules;
    }

    nTagRules = pcRules->Size();
    nWildcardRules = pcWRules->Size();

#ifdef CSSSHARE_NOPRESORT
    // Sort by specificity, then by source order (i.e. rule ID).  
    if (nTagRules > 1)
        qsort(*pcRules, nTagRules, sizeof(CProbableRuleEntry), CompareRules);

    if (nWildcardRules > 1)
        qsort(*pcWRules, nWildcardRules, sizeof(CProbableRuleEntry), CompareRules);
#endif


#if DBG == 1
    if (IsTagEnabled(tagStyleSheetApply))
    {
        // Dump the rules list
        int n;
        for (n = 0; n < nTagRules; n++)
        {
            CProbableRuleEntry *pRE = (CProbableRuleEntry *)pcRules->Deref(sizeof(CProbableRuleEntry),n);
            Assert (pRE && pRE->_pRule);
            TraceTag((tagStyleSheetApply, "- [%2d]: ", n));
            pRE->_pRule->DumpRuleString(this);
        }

        for (n = 0; n < nWildcardRules; n++)
        {
            CProbableRuleEntry *pRE = (CProbableRuleEntry *)pcWRules->Deref(sizeof(CProbableRuleEntry),n);
            Assert (pRE->_pRule);
            TraceTag((tagStyleSheetApply, "- [%2d]: ", n));
            pRE->_pRule->DumpRuleString(this);
        }
        
    }
#endif

    pCFI = (passType == APPLY_Behavior) ? NULL : (CFormatInfo*)pStyleInfo;

    if (pCFI)
        pCFI->SetMatchedBy(pelemNone);

    while (nTagRules || nWildcardRules)
    {

        if (fTagApplied)
        {
            fTagApplied = FALSE;

            while ((iLastTagRule == iTagNum) && nTagRules)
            {
                ++iTagNum;
                --nTagRules;
            }

            if (nTagRules)
            {
                iLastTagRule = iTagNum;
                pTagRule = pcRules->Item(iTagNum)._pRule;
                sidTagRule = pcRules->Item(iTagNum)._sidSheetRule;
                pRule = pTagRule;
            }

            // Walk back from end of the rules lists, looking for a rule that needs to be applied.
            while (nTagRules &&
                    (!pRule->GetSelector() ||
                     !pRule->MediaTypeMatches(eMediaType) ||
                     !pRule->GetSelector()->Match(pStyleInfo, passType, &CIDCache)
                    )
                  )
            {
                TraceTag((tagStyleSheetApply, "Check Tag Rule %08lX", pRule->GetRuleID()));
                --nTagRules;
                ++iTagNum;
                while ((iLastTagRule == iTagNum) && nTagRules)
                {
                    ++iTagNum;
                    --nTagRules;
                }
                if (nTagRules)
                {
                    iLastTagRule = iTagNum;
                    pTagRule = pcRules->Item(iTagNum)._pRule;
                    sidTagRule = pcRules->Item(iTagNum)._sidSheetRule;
                    pRule = pTagRule;
                }
            }
            epeTag = pCFI ? pCFI->GetMatchedBy() : pelemNone;
        }

        if (fWildcardApplied)
        {
            fWildcardApplied = FALSE;
            while ((iLastWCRule == iWCNum) && nWildcardRules)
            {
                ++iWCNum;
                --nWildcardRules;
            }

            if (nWildcardRules)
            {
                iLastWCRule = iWCNum;
                pWildcardRule = pcWRules->Item(iWCNum)._pRule;
                sidWildRule   = pcWRules->Item(iWCNum)._sidSheetRule;
                pRule = pWildcardRule;
            }

            // Make sure this rule should be applied.
            // If the rule has a parent/pseudoclass/pseudoelement, we need to call Match
            // to make sure the rule applies.
            // Otherwise, the rule will apply since it is a wildcard (bare class/id) rule.
            while (nWildcardRules && 
                    (!pRule->GetSelector() || 
                     !pRule->MediaTypeMatches(eMediaType) ||
                     ((pRule->GetSelector()->_pParent ||
                       (pRule->GetSelector()->_ePseudoclass != pclassNone) ||
                       (pRule->GetSelector()->_ePseudoElement != pelemNone))
                      && !pRule->GetSelector()->Match(pStyleInfo, passType, &CIDCache))
                    )
                  )
            {
                TraceTag((tagStyleSheetApply, "Check Wildcard Rule %08lX", pRule->GetRuleID()));
                --nWildcardRules;
                ++iWCNum;
                while ((iLastWCRule == iWCNum) && nWildcardRules)
                {
                    ++iWCNum;
                    --nWildcardRules;
                }
                if (nWildcardRules)
                {
                    iLastWCRule = iWCNum;
                    pWildcardRule = pcWRules->Item(iWCNum)._pRule;
                    sidWildRule   = pcWRules->Item(iWCNum)._sidSheetRule;
                    pRule = pWildcardRule;
                }
            }
            epeWildcard = pCFI ? pCFI->GetMatchedBy() : pelemNone;
        }
        
        // When we get here, nTagRules and nWildcardRules index to rules that need to be applied.
        if (nTagRules)
        {
            if (nWildcardRules)
            {
                // If we get here, then we have a wildcard rule AND a tag rule that need to be applied.
                // NOTE: This '>=' should eventually take source order into account.
                if ( pTagRule->GetSpecificity() >= pWildcardRule->GetSpecificity() )
                {
                    // If the specificity of the tag rule is greater or equal, apply the wildcard rule here,
                    // then we'll overwrite it by applying the tag rule later.
                    if ( pWildcardRule->GetStyleAA() )
                    {
                        cachedSS.PrepareForCache( sidWildRule, pWildcardRule);

                        TraceTag((tagStyleSheetApply, "Applying Wildcard Rule: %08lX to etag: %ls  id: %ls", 
                            (DWORD)pWildcardRule->GetRuleID(), pNode->_pElement->TagName(), STRVAL(pNode->_pElement->GetAAid())));

                        if (pCFI)
                            pCFI->SetMatchedBy(epeWildcard);
                        
                        hr = THR( ApplyAttrArrayValues (
                            pStyleInfo,
                            pWildcardRule->GetRefStyleAA(),
                            &cachedSS,
                            passType,
                            pfContainsImportant ) );

                        if ( hr != S_OK )
                            break;
                    }
                    fWildcardApplied = TRUE;
                    --nWildcardRules;
                    ++iWCNum;
                }
                else
                {
                    if ( pTagRule->GetStyleAA() )
                    {
                        cachedSS.PrepareForCache( sidTagRule ,pTagRule);
                                        
                        TraceTag((tagStyleSheetApply, "Applying Tag Rule: %08lX to etag: %ls  id: %ls", 
                            (DWORD)pTagRule->GetRuleID(), pNode->_pElement->TagName(), STRVAL(pNode->_pElement->GetAAid())));

                        if (pCFI)
                            pCFI->SetMatchedBy(epeTag);
                        
                        hr = THR( ApplyAttrArrayValues (
                            pStyleInfo,
                            pTagRule->GetRefStyleAA(),
                            &cachedSS,
                            passType,
                            pfContainsImportant ) );

                        if ( hr != S_OK )
                            break;
                    }
                    fTagApplied = TRUE;
                    --nTagRules;
                    ++iTagNum;
                }
            }
            else
            {
                if ( pTagRule->GetStyleAA() )
                {
                    cachedSS.PrepareForCache( sidTagRule, pTagRule);
                                        
                    TraceTag((tagStyleSheetApply, "Applying Tag Rule: %08lX to etag: %ls  id: %ls", 
                        (DWORD)pTagRule->GetRuleID(), pNode->_pElement->TagName(), STRVAL(pNode->_pElement->GetAAid())));

                    if (pCFI)
                        pCFI->SetMatchedBy(epeTag);
                    
                    hr = THR( ApplyAttrArrayValues (
                        pStyleInfo,
                        pTagRule->GetRefStyleAA(),
                        &cachedSS,
                        passType,
                        pfContainsImportant ) );

                    if ( hr != S_OK )
                        break;
                }
                fTagApplied = TRUE;
                --nTagRules;
                ++iTagNum;
            }
        }
        else if ( nWildcardRules )
        {
            if ( pWildcardRule->GetStyleAA() )
            {
                cachedSS.PrepareForCache( sidWildRule, pWildcardRule);
                                
                TraceTag((tagStyleSheetApply, "Applying Wildcard Rule: %08lX to etag: %ls  id: %ls", 
                    (DWORD) pWildcardRule->GetRuleID(), pNode->_pElement->TagName(), STRVAL(pNode->_pElement->GetAAid())));

                if (pCFI)
                    pCFI->SetMatchedBy(epeWildcard);
                
                hr = THR( ApplyAttrArrayValues (
                    pStyleInfo,
                    pWildcardRule->GetRefStyleAA(),
                    &cachedSS,
                    passType,
                    pfContainsImportant ) );

                if ( hr != S_OK )
                    break;
            }
            fWildcardApplied = TRUE;
            --nWildcardRules;
            ++iWCNum;
        }
    }   // End of while(nTagRules || nWildcardRules) loop

    if (pCFI)
       pCFI->SetMatchedBy(pelemNone);
    
    pStyleInfo->_ProbRules.Invalidate(this);

    RRETURN( hr );
}

//*********************************************************************
//      CStyleSheetArray::TestForPseudoclassEffect()
//              This method checks all the style rules in this collection of
//  style sheets to see if a change in pseudoclass will change any
//  properties.
//*********************************************************************
BOOL CStyleSheetArray::TestForPseudoclassEffect(
    CStyleInfo *pStyleInfo,
    BOOL fVisited,
    BOOL fActive,
    BOOL fOldVisited,
    BOOL fOldActive )
{
    AssertSz( pStyleInfo, "NULL styleinfo!" );
    AssertSz( pStyleInfo->_pNodeContext, "NULL node context!" );
    CElement *pElem = pStyleInfo->_pNodeContext->Element();
    AssertSz( pElem, "NULL element!" );

    int z;
    int nSheets;
    
    CDoc *pDoc = pElem->Doc();
    AssertSz( pDoc, "No Document attached to this Site!" );

    if ( pDoc->_pOptionSettings && !pDoc->_pOptionSettings->fUseStylesheets )
        return FALSE;   // Stylesheets are turned off.


    for (z=0, nSheets = _aStyleSheets.Size(); z<nSheets; ++z)
    {
        CStyleSheet *pSS = _aStyleSheets[z];

        if (pSS->TestForPseudoclassEffect(pStyleInfo, fVisited,  fActive, fOldVisited, fOldActive ))
            return TRUE;
    }

    return FALSE;
}



//*********************************************************************
//      CStyleSheetArray::Get()
//  Acts like the array operator.
//*********************************************************************
CStyleSheet * CStyleSheetArray::Get( long lIndex )
{
    if (lIndex < 0 || lIndex >= _aStyleSheets.Size())
    {
        return NULL;
    }

    return _aStyleSheets[ lIndex ];
}


//*********************************************************************
//  CStyleSheetArray::length
//      IHTMLStyleSheetsCollection interface method
//*********************************************************************

HRESULT
CStyleSheetArray::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLength = _aStyleSheets.Size();

Cleanup:
    RRETURN( SetErrorInfo( hr ));

}

//*********************************************************************
//  CStyleSheetArray::item
//      IHTMLStyleSheetsCollection interface method.  This overload is
//  not exposed via the PDL; it's purely internal.  Automation clients
//  like VBScript will access the overload that takes variants.
//*********************************************************************

HRESULT
CStyleSheetArray::item(long lIndex, IHTMLStyleSheet** ppHTMLStyleSheet)
{
    HRESULT   hr;

    if (!ppHTMLStyleSheet)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppHTMLStyleSheet = NULL;

    // Just exit if access is out of bounds.
    if (lIndex < 0 || lIndex >= _aStyleSheets.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = _aStyleSheets[lIndex]->QueryInterface(IID_IHTMLStyleSheet, (void**)ppHTMLStyleSheet);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

HRESULT
CStyleSheetArray::item(VARIANTARG *pvarArg1, VARIANTARG * pvarRes)
{
    HRESULT             hr = S_OK;
    long                lIndex;
    IHTMLStyleSheet     *pHTMLStyleSheet;
    CVariant            cvarArg;

    if (!pvarRes)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // Clear return value
    VariantInit (pvarRes);

    if (VT_EMPTY == V_VT(pvarArg1))
    {
        Assert("Don't know how to deal with this right now!" && FALSE);
        goto Cleanup;
    }

    // first attempt ordinal access...
    hr = THR(cvarArg.CoerceVariantArg(pvarArg1, VT_I4));
    if (hr==S_OK)
    {
        lIndex = V_I4(&cvarArg);

        // Just exit if access is out of bounds.
        if (lIndex < 0 || lIndex >= _aStyleSheets.Size())
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        hr = _aStyleSheets[lIndex]->QueryInterface(IID_IHTMLStyleSheet, (void **)&pHTMLStyleSheet);
        if (hr)
            goto Cleanup;
    }
    else
    {
        // not a number so try a name
        hr = THR_NOTRACE(cvarArg.CoerceVariantArg(pvarArg1, VT_BSTR));
        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        else
        {
            // its a string, so handle named access
            if ( _Level != 1 )
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            lIndex = FindSSByHTMLID( (LPTSTR)V_BSTR(pvarArg1), FALSE ); // not case sensitive for VBScript
            if ( lIndex == -1 )
            {
                hr = DISP_E_MEMBERNOTFOUND;
                goto Cleanup;
            }

            hr = _aStyleSheets[lIndex]->QueryInterface(IID_IHTMLStyleSheet, (void **)&pHTMLStyleSheet);
            if (hr)
                goto Cleanup;

        }
    }

    V_VT(pvarRes) = VT_DISPATCH;
    V_DISPATCH(pvarRes) = pHTMLStyleSheet;

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheetArray::_newEnum
//      IHTMLStyleSheetsCollection interface method
//*********************************************************************

HRESULT
CStyleSheetArray::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr = S_OK;

    if (!ppEnum)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEnum = NULL;

    hr = THR(_aStyleSheets.EnumVARIANT(VT_DISPATCH,
                                      (IEnumVARIANT**)ppEnum,
                                      FALSE,
                                      FALSE));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheetArray::FindSSByHTMLID
//  Searches the array for a stylesheet whose parent element has
//  the specified HTML ID.  Returns index if found, -1 if not found.
//*********************************************************************

long
CStyleSheetArray::FindSSByHTMLID( LPCTSTR pszID, BOOL fCaseSensitive )
{
    HRESULT   hr;
    CElement *pElem;
    BSTR      bstrID;
    long      lIdx;

    for ( lIdx = 0 ; lIdx < _aStyleSheets.Size() ; ++lIdx )
    {
        pElem = (_aStyleSheets[lIdx])->GetParentElement();
        Assert( "Must always have parent element!" && pElem );
        // TODO perf: more efficient way to get id?
        hr = pElem->get_PropertyHelper( &bstrID, (PROPERTYDESC *)&s_propdescCElementid );
        if ( hr )
            return -1; 

        if (bstrID)
        {
            if ( !(fCaseSensitive ? _tcscmp( pszID, bstrID ) : _tcsicmp( pszID, bstrID )) )
            {
                FormsFreeString(bstrID);
                return lIdx;
            }
            FormsFreeString(bstrID);
        }
    }
    return -1;
}



//+----------------------------------------------------------------------------
//
//  Function:   __ApplyFontFace_MatchDownloadedFont, static
//
//  Synopsis:   If the supplied face name maps to a successfully 
//              downloaded (embedded) font, fill in the appropriate 
//              pCF members and return TRUE. Otherwise, leave pCF untouched 
//              and return FALSE.
//
//-----------------------------------------------------------------------------
BOOL
CStyleSheetArray::__ApplyFontFace_MatchDownloadedFont(TCHAR * szFaceName, 
                                    CCharFormat * pCF, 
                                    CMarkup * pMarkup)
{
   Assert(_tcsclen(szFaceName) < LF_FACESIZE);

   CStyleSheet **ppSheet;
   int z;
   int nSheets = _aStyleSheets.Size();
   for (ppSheet = (CStyleSheet **) _aStyleSheets, z=0; z<nSheets; ++z, ++ppSheet)
   {
        int n = (*ppSheet)->GetNumDownloadedFontFaces();
        CFontFace **ppFace = (*ppSheet)->GetDownloadedFontFaces();

        for( ; n > 0; --n, ppFace++)
        {
            if (((*ppFace)->IsInstalled()) && (_tcsicmp(szFaceName, (*ppFace)->GetFriendlyName()) == 0))
            {
                pCF->SetFaceName((*ppFace)->GetInstalledName());
                pCF->_bPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
                pCF->_bCharSet = DEFAULT_CHARSET;
                pCF->_fDownloadedFont = TRUE;
                return TRUE;
            }
        }

        if ((*ppSheet)->_pImportedStyleSheets)
        {
            if ((*ppSheet)->_pImportedStyleSheets->__ApplyFontFace_MatchDownloadedFont(szFaceName, pCF, pMarkup))
                return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\style\rulestyl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       rulestyl.cxx
//
//  Contents:   Support for Cascading Style Sheets Object Model - style object
//              that hangs off a Rule.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_RULESTYL_HXX_
#define X_RULESTYL_HXX_
#include "rulestyl.hxx"
#endif

#ifndef X_COLLBASE_HXX_
#define X_COLLBASE_HXX_
#include "collbase.hxx"
#endif

#ifndef X_RULESCOL_HXX_
#define X_RULESCOL_HXX_
#include "rulescol.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include "mshtmdid.h"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

MtDefine(CRuleStyle, StyleSheets, "CRuleStyle")

//+---------------------------------------------------------------------------
//
// CRuleStyle
//
//----------------------------------------------------------------------------


//+------------------------------------------------------------------------
//
//  Member:     CRuleStyle::CRuleStyle
//
//-------------------------------------------------------------------------
CRuleStyle::CRuleStyle( CStyleSheetRule *pRule ) :
    CStyle(NULL, 0, STYLE_REFCOUNTED), _pRule(pRule)
{
    CStyleRule *pSSRule;

    if ( _pRule && NULL != (pSSRule = _pRule->GetRule() ) )
    {
        _pAA = pSSRule->GetStyleAA();
    }
    else
        _pAA = NULL;
    // CStyle::~CStyle will clean the _pAA up for us (that is, set it to
    // NULL so that CBase::~CBase will not destroy it, since it doesn't
    // belong to us.  Look at CStyle::Passivate() for more info.
}

void CRuleStyle::Passivate()
{
    if ( !_pRule )
        delete _pAA;    // We don't have a rule, this must just be junk floating around.
    _pAA = NULL;
    super::Passivate();
}

ULONG CRuleStyle::PrivateAddRef ( void )
{
    return CBase::PrivateAddRef();
}

ULONG CRuleStyle::PrivateRelease( void )
{
    return CBase::PrivateRelease();
}

const CRuleStyle::CLASSDESC CRuleStyle::s_classdesc =
{
    {
        &CLSID_HTMLRuleStyle,                // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        NULL,                                // _apClsidPages
#endif // NO_PROPERTY_PAGE
        NULL,                                // _pcpi
        0,                                   // _dwFlags
        &IID_IHTMLRuleStyle,                 // _piidDispinterface
        &s_apHdlDescs,                       // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLRuleStyle,                    // _apfnTearOff
};

//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange
//
//  Note:       Called after a property has changed to notify derived classes
//              of the change.  All properties (except those managed by the
//              derived class) are consistent before this call.
//
//-------------------------------------------------------------------------
HRESULT CRuleStyle::OnPropertyChange( DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc )
{
    HRESULT hr = S_OK;
    
    if (TestFlag(STYLE_MASKPROPERTYCHANGES))
        goto Cleanup;

    if (_pRule && _pRule->GetStyleSheet())
    {
        CMarkup *pMarkup = _pRule->GetStyleSheet()->GetMarkup();
        if (pMarkup)
        {
            CDoc *pDoc = pMarkup->Doc();
            Assert( pDoc );

            if(dispid == DISPID_A_POSITION)
            {
                if(!pDoc->_fRegionCollection)
                {
                    DWORD dwVal;
                    CAttrArray * pAA = *GetAttrArray();  Assert(pAA);
                    BOOL fFound = pAA->FindSimple(DISPID_A_POSITION, &dwVal);

                    if(fFound && ((stylePosition)dwVal == stylePositionrelative || 
                        (stylePosition)dwVal == stylePositionabsolute))
                    {
                        pDoc->_fRegionCollection = TRUE;
                    }
                }
            }

            hr = THR( pMarkup->OnCssChange(/*fStable = */ TRUE, /* fRecomputePeers = */ (DISPID_A_BEHAVIOR == dispid) ) );

            goto Cleanup; // done
        }
    }
    
    hr = E_FAIL;
    goto Cleanup;

Cleanup:

    RRETURN( hr );
}

//+------------------------------------------------------------------------
//
//  Member:     CRuleStyle::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------
HRESULT
CRuleStyle::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr=S_OK;

    // All interfaces derived from IDispatch must be handled
    // using the ElementDesc()->_apfnTearOff tearoff interface.
    // This allows classes such as COleSite to override the
    // implementation of IDispatch methods.

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_HTML_TEAROFF(this, IHTMLRuleStyle2, NULL)
        QI_HTML_TEAROFF(this, IHTMLRuleStyle3, NULL)
        QI_HTML_TEAROFF(this, IHTMLRuleStyle4, NULL)

    default:
        {
            const CLASSDESC *pclassdesc = (CLASSDESC *) BaseDesc();
            if (pclassdesc &&
                pclassdesc->_apfnTearOff &&
                pclassdesc->_classdescBase._piidDispinterface &&
                (iid == *pclassdesc->_classdescBase._piidDispinterface || DispNonDualDIID(iid)) 
                && _pRule)
            {
                hr = THR(CreateTearOffThunk(this, pclassdesc->_apfnTearOff, NULL, ppv, 
                                                (void *)(CRuleStyle::s_ppropdescsInVtblOrderIHTMLRuleStyle)));
            }
        }
    }
    if (!hr)
    {
        if (*ppv)
            (*(IUnknown **)ppv)->AddRef();
        else
            hr = E_NOINTERFACE;
    }
    RRETURN(hr);
}

CAttrArray **CRuleStyle::GetAttrArray ( void ) const
{
    CStyleRule *pRule;

    if ( _pRule && NULL != (pRule = _pRule->GetRule() ) )
        return pRule->GetRefStyleAA();
    else
        return (CAttrArray **)&_pAA;    // In case we're disconnected, we still need to
                                        // support GetAA.  This is a junk-heap AA - it will
                                        // exist only to satisfy this requirement, and get
                                        // thrown away when we destruct.
}

CAtomTable *CRuleStyle::GetAtomTable ( BOOL *pfExpando )
{
    if ( _pRule && _pRule->GetStyleSheet() )
    {
        CStyleSheet *pSS = _pRule->GetStyleSheet();
        CDoc *pDoc = pSS->GetDocument();

        if (pfExpando)
        {
            Assert(pSS->GetMarkup());
            CMarkup *pMarkupContext = pSS->GetMarkup()->GetWindowedMarkupContext();
            Assert(pMarkupContext);
            *pfExpando = pMarkupContext->_fExpando;
        }

        Assert(pDoc);
        return &(pDoc->_AtomTable);
    }
    return NULL;
};


// We use this to make sure that if an AA is creatid during CBase::GetDispID 
// it goes to the right place (CRuleStyle does not own an AttrArray)
HRESULT
CRuleStyle::GetDispID(BSTR bstrName, DWORD grfdex,  DISPID *pid)
{
    HRESULT         hr;
    BOOL            fNoAA;
    CStyleRule    * pSSRule = NULL;

    if(!_pAA && _pRule && NULL != (pSSRule = _pRule->GetRule()))
    {
        if(pSSRule->GetStyleAA())
            _pAA = pSSRule->GetStyleAA();
    }

    fNoAA = (_pAA == NULL);

    hr = THR_NOTRACE(CBase::GetDispID(bstrName, grfdex, pid));

    if(fNoAA && _pAA)
    {
        // The AA was created by CBase::InvokeEx, make sure we save it in the owner
        if(pSSRule)
        {
            Assert(pSSRule->GetStyleAA() == NULL);
            pSSRule->SetStyleAA(_pAA);
        }
        else
        {
            delete _pAA;
            _pAA = NULL;
        }
    }

    RRETURN1(hr, DISP_E_UNKNOWNNAME);
}



//*********************************************************************
// CRuleStyle::Invoke, IDispatch
// Provides access to properties and members of the object. We use it
//      to invalidate the caches when a expando is changed on the style
//      so that it is propagated down to the elements it affects
//
// Arguments:   [dispidMember] - Member id to invoke
//              [riid]         - Interface ID being accessed
//              [wFlags]       - Flags describing context of call
//              [pdispparams]  - Structure containing arguments
//              [pvarResult]   - Place to put result
//              [pexcepinfo]   - Pointer to exception information struct
//              [puArgErr]     - Indicates which argument is incorrect
//
//*********************************************************************

STDMETHODIMP
CRuleStyle::InvokeEx( DISPID       dispidMember,
                        LCID         lcid,
                        WORD         wFlags,
                        DISPPARAMS * pdispparams,
                        VARIANT *    pvarResult,
                        EXCEPINFO *  pexcepinfo,
                        IServiceProvider *pSrvProvider)
{
    HRESULT         hr = DISP_E_MEMBERNOTFOUND;
    BOOL            fNoAA;
    CStyleRule    * pSSRule = NULL;

    if(!_pAA && _pRule && NULL != (pSSRule = _pRule->GetRule()))
    {
        if(pSSRule->GetStyleAA())
            _pAA = pSSRule->GetStyleAA();
    }

    fNoAA = (_pAA == NULL);

    // Jump directly to CBase. super:: will try to invalidate a branch
    hr = THR_NOTRACE(CBase::InvokeEx( dispidMember,
                                    lcid,
                                    wFlags,
                                    pdispparams,
                                    pvarResult,
                                    pexcepinfo,
                                    pSrvProvider));

    if(fNoAA && _pAA)
    {
        // The AA was created by CBase::InvokeEx, make sure we save it in the owner
        if(pSSRule)
        {
            Assert(pSSRule->GetStyleAA() == NULL);
            pSSRule->SetStyleAA(_pAA);
        }
        else
        {
            delete _pAA;
            _pAA = NULL;
        }
    }

    if(hr)
        goto Cleanup;
    

    if( (_pRule && IsExpandoDISPID(dispidMember) && (wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))) || 
        (dispidMember == DISPID_IHTMLSTYLE_REMOVEATTRIBUTE && (wFlags & DISPATCH_METHOD)) )
    {
        // Invalidate the whole document, a global style has changed
        _pRule->GetStyleSheet()->GetMarkup()->EnsureFormatCacheChange(ELEMCHNG_CLEARCACHES);
    }


Cleanup:
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}

// All putters/getters must not have a pointer into the element attrArray is it could move.
// Use the below macros to guarantee we're pointing to a local variable which is pointing to the
// style sheet attrArray and not pointing to the attrValue on the element attrArray which can
// move if the elements attrArray has attrValues added to or deleted from.
#define GETATTR_ARRAY   \
    CAttrArray *pTempStyleAA = *GetAttrArray();

#define USEATTR_ARRAY   \
    &pTempStyleAA
    

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP
CRuleStyle::put_StyleComponent(BSTR v)
{
    GET_THUNK_PROPDESC
    return put_StyleComponentHelper(v, pPropDesc, GetAttrArray());
}

STDMETHODIMP
CRuleStyle::put_Url(BSTR v)
{
    GET_THUNK_PROPDESC
    return put_UrlHelper(v, pPropDesc, GetAttrArray());
}

STDMETHODIMP
CRuleStyle::put_String(BSTR v)
{
    GET_THUNK_PROPDESC
    return put_StringHelper(v, pPropDesc, GetAttrArray());
}

STDMETHODIMP
CRuleStyle::put_Long(long v)
{
    GET_THUNK_PROPDESC
    return put_LongHelper(v, pPropDesc, GetAttrArray());
}


STDMETHODIMP
CRuleStyle::put_Bool(VARIANT_BOOL v)
{
    GET_THUNK_PROPDESC
    return put_BoolHelper(v, pPropDesc, GetAttrArray());
}

STDMETHODIMP
CRuleStyle::put_Variant(VARIANT v)
{
    GET_THUNK_PROPDESC
    return put_VariantHelper(v, pPropDesc, GetAttrArray());
}

STDMETHODIMP
CRuleStyle::put_DataEvent(VARIANT v)
{
    GET_THUNK_PROPDESC
    return put_DataEventHelper(v, pPropDesc, GetAttrArray());
}

STDMETHODIMP
CRuleStyle::get_Url(BSTR *p)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY
    if (!pTempStyleAA)
    {
        *p = NULL;
        return S_OK;
    }
    else
        return get_UrlHelper(p, pPropDesc, USEATTR_ARRAY);
}

STDMETHODIMP
CRuleStyle::get_StyleComponent(BSTR *p)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY
    if (!pTempStyleAA)
    {
        *p = NULL;
        return S_OK;
    }
    else
        return get_StyleComponentHelper(p, pPropDesc, USEATTR_ARRAY);
}

STDMETHODIMP
CRuleStyle::get_Property(void *p)
{
    GET_THUNK_PROPDESC
    GETATTR_ARRAY
    if (!pTempStyleAA)
    {
        return S_OK;
    }
    else
        return get_PropertyHelper(p, pPropDesc, USEATTR_ARRAY);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

#ifndef NO_EDIT
IOleUndoManager * 
CRuleStyle::UndoManager(void) 
{ 
    return _pRule->UndoManager(); 
}

BOOL 
CRuleStyle::QueryCreateUndo(BOOL fRequiresParent, BOOL fDirtyChange /* = FALSE */, BOOL * pfTreeSync /* = NULL */)
{
    if( pfTreeSync )
        *pfTreeSync = FALSE;

    return _pRule->QueryCreateUndo( fRequiresParent, fDirtyChange, NULL );
}

#endif // NO_EDIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\style\ssheets.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       ssheets.cxx
//
//  Contents:   Support for shared style sheets
//
//
//  History:    zhenbinx    created 08/18/2000
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_CBUFSTR_HXX_
#define X_CBUFSTR_HXX_
#include "cbufstr.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_TOKENZ_HXX_
#define X_TOKENZ_HXX_
#include "tokenz.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_COLLBASE_HXX_
#define X_COLLBASE_HXX_
#include "collbase.hxx"
#endif

#ifndef X_PAGESCOL_HXX_
#define X_PAGESCOL_HXX_
#include "pagescol.hxx"
#endif

#ifndef X_RULESCOL_HXX_
#define X_RULESCOL_HXX_
#include "rulescol.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_HTMTAGS_HXX_
#define X_HTMTAGS_HXX_
#include "htmtags.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_FONTFACE_HXX_
#define X_FONTFACE_HXX_
#include "fontface.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_ATBLOCKS_HXX_
#define X_ATBLOCKS_HXX_
#include "atblocks.hxx"
#endif


MtDefine(CSharedStyleSheet, Mem, "CSharedStyleSheet");
MtDefine(CSharedStyleSheet_apRulesList_pv, CSharedStyleSheet, "CSharedStyleSheet_apRulesList_pv");
MtDefine(CSharedStyleSheet_apImportedStyleSheets_pv, CSharedStyleSheet, "CSharedStyleSheet_apImportedStyleSheets_pv");
MtDefine(CSharedStyleSheet_apPageBlocks_pv, CSharedStyleSheet, "CSharedStyleSheet_apPageBlocks_pv");
MtDefine(CSharedStyleSheet_apFontBlocks_pv, CSharedStyleSheet, "CSharedStyleSheet_apFontBlocks_pv");
MtDefine(CStyleSheetArray, CSharedStyleSheet, "CStyleSheetArray")
MtDefine(CStyleSheetArray_aStyleSheets_pv, CSharedStyleSheet, "CStyleSheetArray::_aStyleSheets::_pv")
MtDefine(CStyleRule, CSharedStyleSheet, "CStyleRule")
MtDefine(CStyleRuleArray, CSharedStyleSheet, "CStyleRuleArray")
MtDefine(CStyleRuleArray_pv, CSharedStyleSheet, "CStyleRuleArray::_pv")
MtDefine(CAtPageBlock, CSharedStyleSheet, "CAtPageBlock");
MtDefine(CAtFontBlock, CSharedStyleSheet, "CAtFontBlock");
MtDefine(CSharedStyleSheet_apSheetsList_pv, CSharedStyleSheet, "CSharedStyleSheet::_apSheetsList");

MtDefine(CSharedStyleSheetsManager, Mem, "CSharedStyleSheetManager");
MtDefine(CSharedStyleSheetsManager_apSheets_pv, CSharedStyleSheetsManager, "CSharedStyleSheetsManager_apSheets_pv");



DeclareTag(tagSharedStyleSheet, "Style Sheet Shared", "trace Shared Style Sheet operations")

//---------------------------------------------------------------------
//  Class Declaration:  CSharedStyleSelect
//      This class implements a parsed style sheet - it managers the rules
//      and is shared among different markup so that re-parse is not
//      necessary if the same CSS is ref-ed in different markups.
//---------------------------------------------------------------------

//*********************************************************************
//      CSharedStyleSheet::Create
//  Factory Method
//*********************************************************************
HRESULT
CSharedStyleSheet::Create(CSharedStyleSheet **ppSSS)
{
    HRESULT hr = S_OK;

    if (!ppSSS)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppSSS = new CSharedStyleSheet();
    if (!*ppSSS)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    if (hr && (*ppSSS) && (*ppSSS)->_fInvalid)
    {
        delete (*ppSSS);
        (*ppSSS) = NULL;
    }
    RRETURN(hr);
}


//*********************************************************************
//      CSharedStyleSheet::CSharedStyleSheet()
//  The shared style sheet contains only the rules
//*********************************************************************
CSharedStyleSheet::CSharedStyleSheet()
    :
    _pManager(NULL),
    _pRulesArrays(NULL),
    _fInvalid(FALSE),
    _fComplete(FALSE),
    _fParsing(FALSE),
    _fModified(FALSE),
    _fExpando(FALSE),
    _achAbsoluteHref(NULL),
    _cp(CP_UNDEFINED),
    _fXMLGeneric(FALSE),
    _dwBindf(0),
    _dwRefresh(0),
    _ulRefs(1)
{
    WHEN_DBG( _fPassivated = FALSE );
    WHEN_DBG( _lReserveCount = 0 );

    _eMediaType = MEDIA_All;
    _eLastAtMediaType = MEDIA_NotSet;

    memset(&_ft, 0, sizeof(FILETIME));

    _pRulesArrays = new CStyleRuleArray[ETAG_LAST];
    if (!_pRulesArrays)
    {
        _fInvalid = TRUE;
        goto Cleanup;
    }

    _htClassSelectors.SetCallBack(this, CompareIt);
    _htIdSelectors.SetCallBack(this, CompareIt);


Cleanup:
    if (_fInvalid)
    {
        if (_pRulesArrays)
        {
            delete [] _pRulesArrays;
            _pRulesArrays = NULL;
        }
    }
}


CSharedStyleSheet::~CSharedStyleSheet()
{
    Assert( "Must call Free() before destructor!" && _fPassivated );
}


STDMETHODIMP_(ULONG)
CSharedStyleSheet::PrivateAddRef()
{
    return (ULONG)InterlockedIncrement((LONG *)&_ulRefs);
}



STDMETHODIMP_(ULONG)
CSharedStyleSheet::PrivateRelease()
{
    if ((ULONG)InterlockedDecrement((LONG *)&_ulRefs) == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        Passivate();
        delete this;
        return 0;
    }
    return _ulRefs;
}



//*********************************************************************
//      CSharedStyleSheet::Passivate
//  Disconnect this from anything elese. Free all the resources we are holding onto.
//  This object is about to die...
//*********************************************************************
void
CSharedStyleSheet::Passivate()
{
    Assert( _ulRefs == ULREF_IN_DESTRUCTOR );

    // free all resources
    ReInit();

    // notify the manager that this is gone
    if (_pManager)
    {
        _pManager->RemoveSharedStyleSheet(this);
        _pManager = NULL;
    }

    // no sheets should be holding on to this now..
     _apSheetsList.DeleteAll();

    if (_pRulesArrays)
    {
        delete [] _pRulesArrays;    // Arrays should be empty; we're just releasing mem here
        _pRulesArrays = NULL;
    }

    WHEN_DBG( _fPassivated = TRUE );
}



//*********************************************************************
//      CSharedStyleSheet::ReInit()
//  Free all the resources we are holding onto -- re-init this to its pristine state.
//*********************************************************************
void
CSharedStyleSheet::ReInit()
{
    // release all rules and internal indexes
    ReleaseRules();

    if (_achAbsoluteHref)
    {
        MemFreeString(_achAbsoluteHref);
        _achAbsoluteHref = NULL;
    }

    _fComplete = FALSE;
    _fParsing   = FALSE;
    _fModified   = FALSE;
    _cp        = CP_UNDEFINED;
    _fXMLGeneric = FALSE;
    _fExpando   = FALSE;
}





//*********************************************************************
//      CSharedStyleSheet::ReleaseRules
//  Release all rules we are holding onto.
//*********************************************************************
HRESULT
CSharedStyleSheet::ReleaseRules(void)
{
    //
    // DONOT call ReleaseRules on imported shared style sheets!
    // Pretend that we don't know imported shared style sheets since
    // our containing style sheets knows about its imported style
    // sheet, so they will release the imported shared style sheets
    // correctly.
    //
    //
    int z;

    _fComplete = FALSE;
    _fParsing  = FALSE;

    int idx = _apRulesList.Size();
    while ( idx )
    {
        _apRulesList[ idx-1]->Free();
        delete _apRulesList[ idx - 1];
        idx--;
    }
    _apRulesList.DeleteAll();

    // Free all @pages
    idx = _apPageBlocks.Size();
    while (idx)
    {
        _apPageBlocks[idx-1]->Release();
        idx--;
    }
    _apPageBlocks.DeleteAll();


    // Forget all the @font we're storing
    idx =  _apFontBlocks.Size();
    while (idx)
    {
        _apFontBlocks[idx - 1]->Release();
        idx--;
    }
    _apFontBlocks.DeleteAll();


    if (_pRulesArrays)
    {
        for ( z=0 ; z < ETAG_LAST ; ++z )
            _pRulesArrays[z].Free( );
    }

    {
        UINT iIndex;
        CStyleRuleArray * pary;
        for (pary = (CStyleRuleArray *)_htClassSelectors.GetFirstEntry(&iIndex);
             pary;
             pary = (CStyleRuleArray *)_htClassSelectors.GetNextEntry(&iIndex))
        {
            pary->Free();
            delete pary;
        }
        _htClassSelectors.ReInit();
        for (pary = (CStyleRuleArray *)_htIdSelectors.GetFirstEntry(&iIndex);
             pary;
             pary = (CStyleRuleArray *)_htIdSelectors.GetNextEntry(&iIndex))
        {
            pary->Free();
            delete pary;
        }
        _htIdSelectors.ReInit();
    }

    {
        // remove imported style sheets
        CImportedStyleSheetEntry    *pRE;
        int n;
        for (pRE = _apImportedStyleSheets, n = _apImportedStyleSheets.Size();
             n > 0;
             n--, pRE++
             )
        {
            pRE->_cstrImportHref.Free();
        }
        _apImportedStyleSheets.DeleteAll();
    }

    return S_OK;
}



//*********************************************************************
//      CSharedStyleSheet::Clone()
//  Make a new one just like this one...
//*********************************************************************
HRESULT
CSharedStyleSheet::Clone(CSharedStyleSheet **ppSSS, BOOL fNoContent)
{
    HRESULT hr = S_OK;
    int n;
    CSharedStyleSheet *pClone = NULL;

    Assert( DbgIsValid() );
    Assert( ppSSS );

    hr = CSharedStyleSheet::Create(ppSSS);
    if (hr)
        goto Cleanup;
    pClone = (*ppSSS);
    Assert( pClone );

    // clone settings
    if (_achAbsoluteHref)
    {
        MemAllocString( Mt(CSharedStyleSheet), _achAbsoluteHref, &(pClone->_achAbsoluteHref) );
        if ( !pClone->_achAbsoluteHref )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    pClone->_eMediaType       = _eMediaType;
    pClone->_eLastAtMediaType = _eLastAtMediaType;
    pClone->_fInvalid         = _fInvalid;
    pClone->_fComplete        = _fComplete;
    pClone->_fModified        = _fModified;
    pClone->_fExpando         = _fExpando;
    pClone->_cp               = _cp;
    pClone->_fXMLGeneric      = _fXMLGeneric;
    pClone->_pManager         = _pManager;
    pClone->_fIsStrictCSS1    = _fIsStrictCSS1;

    if (fNoContent)     // we are done...
    {
        TraceTag( (tagSharedStyleSheet, "Clone - fNoContent - simply return") );
        goto Cleanup;
    }

    // clone rules
    CStyleRule  **pRules;
    CStyleRule  *pCloneRule;
    for (n = 0, pRules = _apRulesList;
         n < _apRulesList.Size();
         n++, pRules++)
    {
        hr = (*pRules)->Clone(&pCloneRule);
        if (hr)
            goto Cleanup;
        pClone->_apRulesList.Append(pCloneRule);
    }

    // clone imports
    CImportedStyleSheetEntry    *pRE;
    for (pRE = _apImportedStyleSheets, n = 0;
         n < _apImportedStyleSheets.Size();
         n++, pRE++
         )
    {
        CImportedStyleSheetEntry *pNE;
        pClone->_apImportedStyleSheets.AppendIndirect(NULL, &pNE);

        pNE->_cstrImportHref.Set( pRE->_cstrImportHref );
    }

    // clone @font
    CAtFontBlock **ppAtFont;
    for (n=0, ppAtFont = _apFontBlocks;
         n < _apFontBlocks.Size();
         n++, ppAtFont++
         )
    {
        CAtFontBlock *pAtFont;
        hr = (*ppAtFont)->Clone(&pAtFont);
        if (hr)
            goto Cleanup;

        pClone->_apFontBlocks.Append(pAtFont);
    }

    // clone @page
    CAtPageBlock **ppAtPage;
    for (n = 0, ppAtPage = _apPageBlocks;
         n < _apPageBlocks.Size();
         n++, ppAtPage++
         )
    {
        CAtPageBlock *pAtPage;
        hr = (*ppAtPage)->Clone(&pAtPage);
        if (hr)
            goto Cleanup;

        pClone->_apPageBlocks.Append(pAtPage);
    }

    // clone indexes
    if (_pRulesArrays)
    {
        TraceTag( (tagSharedStyleSheet, "Clone  indexes rule-array") );
        int z;
        for ( z=0 ; z < ETAG_LAST ; ++z )
        {
            CStyleRuleArray *pTagRules = &(_pRulesArrays[z]);
            Assert(pTagRules);
            CStyleRuleArray * pCloneRA = &(pClone->_pRulesArrays[z]);
            Assert( pCloneRA);
            for (n = 0; n < pTagRules->Size(); n++)
            {
                CStyleRule  *pRule = *((CStyleRule **)pTagRules->Deref(sizeof(CStyleRule *), n));
                Assert( pRule );
                CStyleRuleID sidRule = pRule->GetRuleID();
                Assert( sidRule >= 1);
                Verify( S_OK == THR(pCloneRA->InsertStyleRule( pClone->_apRulesList[sidRule - 1], TRUE, NULL)) );
                TraceTag( (tagSharedStyleSheet, "Clone  indexes rule-array [%2d] with rule [%d]", z, n) );
            }
        }
    }

    //
    // clone hash table this way is slow
    //
    UINT iIndex;
    CStyleRuleArray * pary;
    CHtPvPv     *pVV;

    TraceTag( (tagSharedStyleSheet, "Clone  indexes class hash table") );
    pVV = &(pClone->_htClassSelectors);
    hr = _htClassSelectors.CloneMemSetting( &pVV, FALSE /* fCreateNew */);
    if (hr)
        goto Cleanup;

    for (pary = (CStyleRuleArray *)_htClassSelectors.GetFirstEntry(&iIndex);
         pary;
         pary = (CStyleRuleArray *)_htClassSelectors.GetNextEntry(&iIndex))
    {
        // set the entry
        CStyleRuleArray   *pCloneRuleAry = new CStyleRuleArray();
        if (!pCloneRuleAry)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        void *pdwKey = _htClassSelectors.GetKey(iIndex);    // no need to clone key since it is just a hash value
        pClone->_htClassSelectors.Set(iIndex, pdwKey, pCloneRuleAry);

        // set the entry array
        int nRules = pary->Size();
        int iRule;
        CStyleRuleID sidRule;

        TraceTag( (tagSharedStyleSheet, "Clone  indexes class hash table - [%p] has [%d] rules", pCloneRuleAry, nRules) );
        for (iRule=0 ; iRule < nRules ; ++iRule)            // for all rules in this array
        {
            sidRule = pary->Item(iRule)->GetRuleID();
            pCloneRuleAry->Append( pClone->_apRulesList[sidRule - 1] );
        }
    }

    //
    TraceTag( (tagSharedStyleSheet, "Clone  indexes id hash table") );
    pVV =  &(pClone->_htIdSelectors);
    hr = _htIdSelectors.CloneMemSetting( &pVV, FALSE /*fCreateNew */);
    if (hr)
        goto Cleanup;

    for (pary = (CStyleRuleArray *)_htIdSelectors.GetFirstEntry(&iIndex);
         pary;
         pary = (CStyleRuleArray *)_htIdSelectors.GetNextEntry(&iIndex))
    {
        // set the entry
        CStyleRuleArray   *pCloneRuleAry = new CStyleRuleArray();
        if (!pCloneRuleAry)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        void *pdwKey = _htIdSelectors.GetKey(iIndex);    // no need to clone key since it is just a hash value
        pClone->_htIdSelectors.Set(iIndex, pdwKey, pCloneRuleAry);

        int nRules = pary->Size();
        int iRule;
        CStyleRuleID sidRule;

        TraceTag( (tagSharedStyleSheet, "Clone  indexes id hash table - [%p] has [%d] rules", pCloneRuleAry, nRules) );
        for (iRule=0 ; iRule < nRules ; ++iRule)            // for all rules in this array
        {
            sidRule = pary->Item(iRule)->GetRuleID();
            pCloneRuleAry->Append( pClone->_apRulesList[sidRule - 1] );
        }
    }

    Assert( DbgIsValid() );
    Assert( pClone->DbgIsValid() );
Cleanup:
    if (hr && pClone)
    {
        pClone->Release();    // this will cause destruction in case of any failures
        (*ppSSS) = NULL;
        Assert(FALSE && "CSharedStyleSheet::Clone Failed");
    }
    RRETURN(hr);
}



//*********************************************************************
//      CSharedStyleSheet::Notify()
//  Notify the style sheets that share this one that certain events
//  happens such as done parsing
//*********************************************************************
HRESULT
CSharedStyleSheet::Notify(DWORD dwNotification)
{
    HRESULT  hr = S_OK;
    CStyleSheet **ppSS;
    int n;
    for (n = _apSheetsList.Size(), ppSS = _apSheetsList;
         n > 0;
         n--, ppSS++
         )
     {
        //
        // TODO: Make this async -- otherwise we would be deadlocked in multithread case
        //
        // GWPostMethodCallEx(_pts, this, ONCALL_METHOD(CDwnChan, OnMethodCall, onmethodcall), 0, FALSE, GetOnMethodCallName());
        //
        if ( (*ppSS)->_eParsingStatus == CSSPARSESTATUS_PARSING)
        {
            hr = THR((*ppSS)->Notify(dwNotification));
            if (hr)
                goto Cleanup;
        }
     }

Cleanup:
    RRETURN(hr);
}


//*********************************************************************
//      CSharedStyleSheet::SwitchParserAway()
// error during parsing. try to switch to a different parser
//*********************************************************************
HRESULT
CSharedStyleSheet::SwitchParserAway(CStyleSheet *pSheet)
{
    RRETURN(E_NOTIMPL);
}



//*********************************************************************
//      CSharedStyleSheet::CompareIt()
//  Used in CHtPvPv by _htIdSelectors and _htClassSelectors
//*********************************************************************
BOOL
CSharedStyleSheet::CompareIt(const void *pObject, const void *pvKeyPassedIn, const void *pvVal2)
{
    CStyleRuleArray *   pary;
    CClassIDStr *       strProbe;
    CStyleRule *        pRule;
    CStyleSelector *    pSelector;

    strProbe = (CClassIDStr *)pvKeyPassedIn;
    pary = (CStyleRuleArray *)pvVal2;

    Assert( pary && pary->Size() );

    pRule = *((CStyleRule **)pary->Deref(sizeof(CStyleRule *), 0));
    pSelector = pRule->GetSelector();

    // The following code uses case sensitive comparison iff we are in strict css mode.
    if (strProbe->_eType == eClass)
    {
        if (pSelector->_fIsStrictCSS1)
            return !_tcsncmp(pSelector->_cstrClass, pSelector->_cstrClass.Length(), strProbe->_strClassID, strProbe->_nClassIDLen);
        else
            return !_tcsnicmp(pSelector->_cstrClass, pSelector->_cstrClass.Length(), strProbe->_strClassID, strProbe->_nClassIDLen);
    }
    else
    {
        if (pSelector->_fIsStrictCSS1)
            return !_tcsncmp(pSelector->_cstrID, pSelector->_cstrID.Length(), strProbe->_strClassID, strProbe->_nClassIDLen);
        else
            return !_tcsnicmp(pSelector->_cstrID, pSelector->_cstrID.Length(), strProbe->_strClassID, strProbe->_nClassIDLen);
    }
}







 CStyleRule *CSharedStyleSheet::GetRule(CStyleRuleID sidRule)
{
    Assert ( "rule id contains sheet id" && (sidRule.GetSheet() == 0) );
    if (sidRule.GetRule() <= 0 || sidRule.GetRule() > (unsigned int)(_apRulesList.Size()))
        return NULL;
    return _apRulesList[sidRule.GetRule() - 1];
}


//*********************************************************************
//  CSharedStyleSheet::ChangeRulesStatus()
// Change Media type
//*********************************************************************
HRESULT
CSharedStyleSheet::ChangeRulesStatus(DWORD dwAction, BOOL *pfChanged)
{
    Assert( MEDIATYPE(dwAction) && "ChangeRulesStatus should only be called for media types");

    if (MEDIATYPE(dwAction))
    {
        if (*pfChanged)
        {
            if (_eMediaType != (EMediaType)MEDIATYPE(dwAction))
            {
                *pfChanged = TRUE;
            }
        }
        _eMediaType = (EMediaType)MEDIATYPE(dwAction);

        // change rules
        CStyleRule **pRules;
        int n;
        for (n = _apRulesList.Size(), pRules = _apRulesList;
             n > 0;
             n--, pRules++)
        {
            // Need to patch media type.
            (*pRules)->SetMediaType(dwAction);
        }
    }

    return S_OK;
}


//*********************************************************************
//  CSharedStyleSheet::AddStyleRule()
//      This method adds a new rule to the correct CStyleRuleArray in
//  the hash table (hashed by element (tag) number) (The CStyleRuleArrays
//  are stored in the containing CStyleSheetArray).  This method is
//  responsible for splitting apart selector groups and storing them
//  as separate rules.  May also handle important! by creating new rules.
//
//  We also maintain a list in source order of the rules inserted by
//  this stylesheet -- the list has the rule ID (rule info only, no
//  import nesting info) and etag (no pointers)
//
//  NOTE:  If there are any problems, the CStyleRule will auto-destruct.
//*********************************************************************
HRESULT
CSharedStyleSheet::AddStyleRule(CStyleRule *pRule, BOOL fDefeatPrevious /*=TRUE*/, long lIdx /*=-1*/)
{
    WHEN_DBG(Assert(DbgIsValid()));

    HRESULT     hr  = S_OK;
    CStyleSelector  *pNextSelector;

    do
    {
        CStyleRule *pSiblingRule = NULL;

        pNextSelector = pRule->GetSelector()->_pSibling;
        pRule->GetSelector()->_pSibling = NULL;

        if ( _apRulesList.Size() >= MAX_RULES_PER_SHEET )
        {
            hr = E_INVALIDARG;
            break;
        }

        pRule->SetMediaType(pRule->GetMediaType() | _eMediaType );
        pRule->SetLastAtMediaTypeBits( _eLastAtMediaType  );

        if ( ( lIdx < 0 ) || ( lIdx >= _apRulesList.Size() ) )   // Add at the end
        {
            lIdx = _apRulesList.Size();
            pRule->GetRuleID().SetRule( lIdx + 1 );
        }
        else
        {
            CStyleRule      **pRE;
            int  i, nRules;

            pRule->GetRuleID().SetRule( lIdx + 1 );

            for ( pRE = (CStyleRule **)_apRulesList + lIdx, i = lIdx, nRules = _apRulesList.Size();
                  i < nRules; i++, pRE++ )
            {
                (*pRE)->GetRuleID().SetRule( (*pRE)->GetRuleID().GetRule() + 1 );
            }

        }

        // _Track_ the rule in our internal list.  This list lets us enumerate in
        // source order the rules that we've added.  It makes a copy of the rule
        // entry, so it's OK for re to be on the stack.
        if ( ( lIdx < 0 ) || ( lIdx >= _apRulesList.Size() ) )   // Add at the end
            _apRulesList.Append( pRule );
        else
            _apRulesList.Insert( lIdx, pRule );


        // Call back to CStyleSheet so that it has a chance to update OM
        if (!_pManager)
        {
            // only update OM if it is not shared and completed
            // there is no point to update OM since there would be
            // no OM event comes in during parsing.
            Assert( _apSheetsList.Size() == 1 );    // must be a private copy
            int i;
            for (i = 0; i < _apSheetsList.Size(); i++)
            {
                hr = THR(_apSheetsList[i]->OnNewStyleRuleAdded(pRule));
                if (hr)
                    goto Cleanup;
            }
        }

        // index this rule
        hr = THR(IndexStyleRule(pRule, ruleInsert, fDefeatPrevious));
        if (hr)
            goto Cleanup;



        if ( pNextSelector )
        {
            pSiblingRule = new CStyleRule( pNextSelector );
            if ( !pSiblingRule )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            // Copy the recognized style properties from the original rule's attr array
            pSiblingRule->SetStyleAA(NULL);
            if ( pRule->GetStyleAA())
            {
                CAttrArray  *paa;
                hr = pRule->GetStyleAA()->Clone( &paa );
                if ( hr != S_OK )
                    break;
                pSiblingRule->SetStyleAA(paa);
            }

            // Copy any unknown properties
            //hr = pRule->_uplUnknowns.Duplicate( pSiblingRule->_uplUnknowns );
            //if ( hr != S_OK )
            //  break;
        }

        if ( pNextSelector )
            pRule = pSiblingRule;

    } while ( pNextSelector );

Cleanup:
    WHEN_DBG(Assert(DbgIsValid()));
    RRETURN( hr );

}




//*********************************************************************
//      CSharedStyleSheet::RemoveStyleRule(long lIdx)
//
//*********************************************************************
HRESULT
CSharedStyleSheet::RemoveStyleRule(CStyleRuleID sidRule)
{
    WHEN_DBG( Assert(DbgIsValid()) );

    HRESULT  hr = S_OK;
    CStyleRule **pRE;
    int i;
    CStyleRule *pRule;
    unsigned long lRule = sidRule.GetRule();

    if (lRule <= 0 || lRule > (unsigned long)_apRulesList.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Call back to CStyleSheet so that it has a chance to update OM
    if (!_pManager)
    {
        Assert( _apSheetsList.Size() == 1 );    // must be a private copy
        for (i = 0; i < _apSheetsList.Size(); i++)
        {
            hr = THR(_apSheetsList[i]->OnStyleRuleRemoved(sidRule));
            if (hr)
                goto Cleanup;
        }
    }

    // re-index
    hr = THR(IndexStyleRule(_apRulesList[lRule - 1], ruleRemove, FALSE));
    if (hr)
        goto Cleanup;

    // Shift Down all the IDs
    for (pRE = (CStyleRule **)_apRulesList+lRule, i=lRule;
         i < _apRulesList.Size();
         i++, pRE++
         )
    {
        Assert( (*pRE)->GetRuleID().GetRule() > 0);
        (*pRE)->GetRuleID().SetRule( (*pRE)->GetRuleID().GetRule() - 1);
    }

    // release all the resources we are holding on to...
    pRule = _apRulesList[lRule-1];
    Assert(pRule);
    pRule->Free();
    delete pRule;
    // remove it from the collection
    _apRulesList.Delete(lRule - 1);

Cleanup:
    WHEN_DBG(Assert(DbgIsValid()));
    RRETURN(hr);
}


//*********************************************************************
//      CSharedStyleSheet::IndexStyleRule()
//  Index Style Rules. Should only be called by CSharedStyleSheet::AddStyleRule().  Since rules
//  are actually stored by CSSS's, this exposes that ability.
//*********************************************************************
HRESULT
CSharedStyleSheet::IndexStyleRule(CStyleRule *pRule, ERulesShiftAction eAction, BOOL fDefeatPrevious)
{
    HRESULT hr = S_OK;

    int iIndex;
    BOOL  fInserted     = FALSE;
    BOOL  fRemoved      = FALSE;
    BOOL  *pfProcessed  = (eAction == ruleInsert? &fInserted : &fRemoved);

    if (pRule->GetSelector()->_cstrID.Length())
    {
        CClassIDStr cmpKey;
        DWORD dwHash, dwKey;
        CStyleRuleArray *pHashRules;
        BOOL    fFound;

        dwHash = HashStringCiDetectW(pRule->GetSelector()->_cstrID, pRule->GetSelector()->_cstrID.Length(), 0);
        dwKey = dwHash << 2;
        dwKey = FormalizeHashKey(dwKey);

        cmpKey._eType = eID;
        cmpKey._strClassID = pRule->GetSelector()->_cstrID;
        cmpKey._nClassIDLen = pRule->GetSelector()->_cstrID.Length();

        fFound = !_htIdSelectors.LookupSlow(ULongToPtr(dwKey), (void *)&cmpKey, (void **)&pHashRules);

        switch (eAction)
        {
        case ruleInsert:
            if (!fFound)
            {
                // Create New
                pHashRules = new CStyleRuleArray;

                if (!pHashRules)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

#if DBG==1
                hr = _htIdSelectors.Insert(ULongToPtr(dwKey),  (void *)pHashRules, (void *)&cmpKey);
#else
                hr = _htIdSelectors.Insert(ULongToPtr(dwKey),  (void *)pHashRules);
#endif
                if (hr)
                {
                    // could not insert in hash table, but created new above, so get rid of it
                    Assert(pHashRules);
                    delete pHashRules;
                    goto Cleanup;
                }
            }

            hr = pHashRules->Append(pRule);
            if (hr)
                goto Cleanup;

            //
            // We don't want both class Hash and ID Hash
            // if the rule have both Class and ID
            //
            fInserted = TRUE;
            break;


       case ruleRemove:
            if (fFound)
            {
                if (pHashRules->Size() == 1)
                {
                    if (pHashRules != _htIdSelectors.Remove(ULongToPtr(dwKey), (void *)&cmpKey))
                    {
                        Assert(FALSE);
                    }
                    pHashRules->Free();
                    delete pHashRules;
                }
                else
                {
                    pHashRules->RemoveStyleRule(pRule, NULL);
                }
                fRemoved = TRUE;
            }

            break;
       }// end-switch
    } // end id hash table


    if (!(*pfProcessed) && pRule->GetSelector()->_cstrClass.Length())
    {
        CClassIDStr cmpKey;
        DWORD dwHash, dwKey;
        CStyleRuleArray *pHashRules;
        BOOL        fFound;

        dwHash = pRule->GetSelector()->_dwStrClassHash;
        dwKey = dwHash << 2;
        dwKey = FormalizeHashKey(dwKey);

        cmpKey._eType = eClass;
        cmpKey._strClassID = pRule->GetSelector()->_cstrClass;
        cmpKey._nClassIDLen = pRule->GetSelector()->_cstrClass.Length();

        fFound = !_htClassSelectors.LookupSlow(ULongToPtr(dwKey), (void *)&cmpKey, (void **)&pHashRules);

        switch (eAction)
        {
        case ruleInsert:
            if (!fFound)
            {
                // Create New
                pHashRules = new CStyleRuleArray;

                if (!pHashRules)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
#if DBG==1
                hr = _htClassSelectors.Insert(ULongToPtr(dwKey),  (void *)pHashRules, (void *)&cmpKey);
#else
                hr = _htClassSelectors.Insert(ULongToPtr(dwKey),  (void *)pHashRules);
#endif
                if (hr)
                {
                    // could not insert in hash table, but created new above, so get rid of it
                    Assert(pHashRules);
                    delete pHashRules;
                    goto Cleanup;
                }
            }

            hr = pHashRules->Append(pRule);
            if (hr)
                goto Cleanup;
            fInserted = TRUE;
            break;


        case ruleRemove:
            if (fFound)
            {
                if (pHashRules->Size() == 1)
                {
                    if (pHashRules != _htClassSelectors.Remove(ULongToPtr(dwKey), (void *)&cmpKey))
                    {
                        Assert(FALSE);
                    }
                    pHashRules->Free();
                    delete pHashRules;
                }
                else
                {
                    pHashRules->RemoveStyleRule(pRule, NULL);
                }
                fRemoved = TRUE;
            }
            break;
        } // end switch
    }// end class hash table


    if (!(*pfProcessed))
    {
        Assert( "Must have index array allocated to add index!" && _pRulesArrays );

        CStyleRuleArray * pRA = &(_pRulesArrays[ pRule->GetElementTag() ]);
        if (eAction == ruleInsert)
            hr = pRA->InsertStyleRule( pRule, fDefeatPrevious, &iIndex );
        else
            hr = pRA->RemoveStyleRule(pRule, &iIndex);
        if (hr)
            goto Cleanup;
        WHEN_DBG( (*pfProcessed) = TRUE );
    }

Cleanup:
    Assert( (*pfProcessed) );
    RRETURN(hr);
}




// ascending order
WHEN_NOT_DBG(inline)
HRESULT InsertProbableRule(CRules &cwRules, CStyleRule *pRule, CStyleSheetID sidSheet)
{
    HRESULT     hr = S_OK;

#ifndef CSSSHARE_NOPRESORT
    CStyleSheetRuleID   sidSheetRuleID;
    DWORD               sp;

    Assert(pRule);
    sidSheetRuleID  = sidSheet;
    sidSheetRuleID.SetRule(pRule->GetRuleID());
    sp = pRule->GetSpecificity();

    int lBound  = 0;
    int uBound  = cwRules.Size();
    int nMedian = 0;

    while (lBound < uBound)
    {
        nMedian = (lBound + uBound) >> 1;
        CProbableRuleEntry *pElem  = ((CProbableRuleEntry *)cwRules) + nMedian;
        DWORD spElem = pElem->_pRule->GetSpecificity();

        if (spElem == sp)
        {
            if (pElem->_sidSheetRule < sidSheetRuleID)
            {
                lBound  = nMedian + 1;
                nMedian++;
            }
            else if (pElem->_sidSheetRule > sidSheetRuleID)
            {
                uBound   = nMedian;
            }
            else
            {
                // we found the same rule simply return
                goto Cleanup;
            }
        }
        else  if (spElem > sp)
        {
            uBound  = nMedian;
        }
        else    // spElem < sp
        {
            lBound  = nMedian + 1;
            nMedian++;
        }
    }

    Assert( nMedian >= 0);
    hr = cwRules.InsertIndirect(nMedian, NULL);
    if (!hr)
    {
        cwRules[nMedian]._pRule = pRule;
        cwRules[nMedian]._sidSheetRule = sidSheetRuleID;
    }

#else

    CProbableRuleEntry  *pElem;
    cwRules.AppendIndirect(NULL, &pElem);
    pElem->_pRule = pRule;
    pElem->_sidSheetRule = sidSheet;
    pElem->_sidSheetRule.SetRule( pRule->GetRuleID() );
#endif

Cleanup:
    return hr;
}


//*********************************************************************
//      CSharedStyleSheet::AppendListOfProbableRules()
//              This method checks all the style rules in this style sheet
//  to build a list of applicable rules to a given element
//*********************************************************************
HRESULT
CSharedStyleSheet::AppendListOfProbableRules(
        CStyleSheetID sidSheet,
        CTreeNode *pNode,
        CProbableRules *ppr,
        CClassIDStr *pclsStrLink,
        CClassIDStr *pidStr,
        BOOL fRecursiveCall
        )
{
    Assert(pNode);
    Assert(ppr);

    HRESULT  hr = S_OK;
    CStyleRule   *pRule;
    CElement *pElement = pNode->Element();
    // Save the pointer for later use
    CClassIDStr *pclsStrLink2 = pclsStrLink;

    while (pclsStrLink)
    {
        CStyleRuleArray *pHashRules;
        CStyleRule      *pRule;

        if (!_htClassSelectors.LookupSlow(ULongToPtr(pclsStrLink->_dwHashKey), (void *)(pclsStrLink),(void **)&pHashRules))
        {
            for (int i = 0; i < pHashRules->Size(); ++i)
            {
                pRule = *((CStyleRule **)pHashRules->Deref(sizeof(CStyleRule *), i));
                if (!pRule->GetSelector()->_fSelectorErr)
                {
                    if (pRule->GetElementTag() == pElement->TagType())
                    {
                        // If the Rule found has both a class and an ID,
                        // then make sure the element has that class and ID
                        // as well, or this rule should not apply.
                        if (!pRule->GetSelector()->_cstrID.Length() ||
                                (pidStr &&
                                    (pRule->GetSelector()->_fIsStrictCSS1 ?
                                         _tcsequal(pRule->GetSelector()->_cstrID, pidStr->_strClassID)
                                         : _tcsiequal(pRule->GetSelector()->_cstrID, pidStr->_strClassID)
                                    )
                                )
                           )
                        {
                            InsertProbableRule(ppr->_cRules, pRule, sidSheet);
                        }
                    }
                    else if (pRule->GetElementTag() == ETAG_UNKNOWN)
                    {
                        // Look at the comment above.
                        if (!pRule->GetSelector()->_cstrID.Length() ||
                                (pidStr &&
                                    (pRule->GetSelector()->_fIsStrictCSS1 ?
                                         _tcsequal(pRule->GetSelector()->_cstrID, pidStr->_strClassID)
                                         : _tcsiequal(pRule->GetSelector()->_cstrID, pidStr->_strClassID)
                                    )
                                )
                           )
                        {
                            InsertProbableRule(ppr->_cWRules, pRule, sidSheet);
                        }
                    }
                }
            }
        }
        pclsStrLink = pclsStrLink->_pNext;
    }

    if (pidStr)
    {
        CStyleRuleArray *pHashRules;
        CStyleRule      *pRule;
        CStyleSelector  *pSelector;

        if (!_htIdSelectors.LookupSlow(ULongToPtr(pidStr->_dwHashKey), (void *)pidStr, (void **)&pHashRules))
        {
            for (int i = 0; i < pHashRules->Size(); ++i)
            {
                pRule = *((CStyleRule **)pHashRules->Deref(sizeof(CStyleRule *), i));
                pSelector = pRule->GetSelector();
                if (!pSelector->_fSelectorErr)
                {
                    // fNeedToBeApplied determines if the current rule needs to be applied to the element. There are two cases:
                    // (1) The rule does _not_ have a class selector. In this case it must be applied because it matches
                    // the id attribute of the element (otherwise we wouldn't be here).
                    // (2) The rule has a class selector. Then it is applied if and only if the class selector is a member
                    // of the class attribute set of the element.
                    BOOL fNeedToBeApplied = FALSE;
                    if (pSelector->_cstrClass.Length())
                    { // This rule has a class selector, check that it is in the class attribute of the element
                        for ( ; pclsStrLink2;  pclsStrLink2 = pclsStrLink2->_pNext)
                        {
                            if (pSelector->_fIsStrictCSS1 ?
                                    !_tcsncmp(pSelector->_cstrClass,
                                              pSelector->_cstrClass.Length(),
                                              pclsStrLink2->_strClassID,
                                              pclsStrLink2->_nClassIDLen)
                                    : !_tcsnicmp(pSelector->_cstrClass,
                                                 pSelector->_cstrClass.Length(),
                                                 pclsStrLink2->_strClassID,
                                                 pclsStrLink2->_nClassIDLen)
                               )
                            {
                                fNeedToBeApplied = TRUE;
                                // Finding one class selector is enough ("OR")
                                break;
                            }
                        }
                    }
                    else
                    { // This rule does not have a class selector, so apply it
                        fNeedToBeApplied = TRUE;
                    }

                    if (fNeedToBeApplied)
                    {
                        if (pRule->GetElementTag() == pElement->TagType())
                        {
                            InsertProbableRule(ppr->_cRules, pRule, sidSheet);
                        }
                        else if (pRule->GetElementTag() == ETAG_UNKNOWN)
                        {
                            InsertProbableRule(ppr->_cWRules, pRule, sidSheet);
                        }
                    }
                }
            }
        }
    }

    {
        ELEMENT_TAG etag = pElement->TagType();
        CStyleRuleArray *pTagRules = &_pRulesArrays[etag];

        if (pTagRules)
        {
            for (int i = 0; i < pTagRules->Size(); ++i)
            {
                pRule = *((CStyleRule **)pTagRules->Deref(sizeof(CStyleRule *), i));
                Assert(!pRule->GetSelector()->_cstrClass.Length() && !pRule->GetSelector()->_cstrID.Length());
                InsertProbableRule(ppr->_cRules, pRule, sidSheet);
            }
        }
    }

    // Look at wildcard rules
    {
        CStyleRuleArray *pWCRules = &_pRulesArrays[ETAG_UNKNOWN];

        if (pWCRules)
        {
            for (int i = 0; i < pWCRules->Size(); ++i)
            {
                pRule = *((CStyleRule **)pWCRules->Deref(sizeof(CStyleRule *), i));
                Assert(!pRule->GetSelector()->_cstrClass.Length() && !pRule->GetSelector()->_cstrID.Length());
                InsertProbableRule(ppr->_cWRules, pRule, sidSheet);
           }
        }
    }

    RRETURN(hr);
}


BOOL
CSharedStyleSheet::TestForPseudoclassEffect(
    CStyleInfo *pStyleInfo,
    BOOL fVisited,
    BOOL fActive,
    BOOL fOldVisited,
    BOOL fOldActive )
{
    AssertSz( pStyleInfo, "NULL styleinfo!" );
    AssertSz( pStyleInfo->_pNodeContext, "NULL node context!" );
    CElement *pElem = pStyleInfo->_pNodeContext->Element();
    AssertSz( pElem, "NULL element!" );

   // Begin walking rules..

    // Cache for class and ID of this element and potentially its parents
    CStyleClassIDCache CIDCache;
    EPseudoclass eOldClass = pclassLink;
    EPseudoclass eNewClass = pclassLink;

    // Set up the pseudoclass types
    if ( fActive )
        eNewClass = pclassActive;
    else if ( fVisited )
        eNewClass = pclassVisited;

    if ( fOldActive )
        eOldClass = pclassActive;
    else if ( fOldVisited )
        eOldClass = pclassVisited;

    {
        CStyleRule **pSR;
        int z;
        for ( z = 0, pSR = _apRulesList;
              z < _apRulesList.Size();
              z++, pSR++
              )
        {
            if ( (*pSR)->GetElementTag() == pElem->Tag() || (*pSR)->GetElementTag() == ETAG_UNKNOWN)
            {
                if ( (*pSR)->GetSelector()->Match( pStyleInfo, APPLY_All, &CIDCache, &eNewClass )^
                     (*pSR)->GetSelector()->Match( pStyleInfo, APPLY_All, &CIDCache, &eOldClass ) )
                    return TRUE;
            }
        }
    }

    return FALSE;
}


//*********************************************************************
//      CSharedStyleSheet::GetString()
//              Serialization
//*********************************************************************
HRESULT CSharedStyleSheet::GetString( CBase *pBase, CStr *pResult )
{

    {
        // Handle @import
        CImportedStyleSheetEntry    *pRE;
        int n;
        for (pRE = _apImportedStyleSheets, n = _apImportedStyleSheets.Size();
             n > 0;
             n--, pRE++
             )
        {
            pResult->Append( _T("@import url( ") );
            pResult->Append( pRE->_cstrImportHref );
            pResult->Append( _T(" );\r\n") );
        }
    }

    {
        // Handle @font
        int nFonts = _apFontBlocks.Size();
        CAtFontBlock    *pAtFont;
        for(int i=0; i < nFonts; i++ )
        {
            LPCTSTR pcszURL = NULL;

            pAtFont = _apFontBlocks[i];
            Assert(pAtFont && pAtFont->_pAA);
            pAtFont->_pAA->FindString ( DISPID_A_FONTFACESRC, &pcszURL );
            pResult->Append( _T("@font-face {\r\n\tfont-family: ") );
            pResult->Append( pAtFont->_pszFaceName );
            if ( pcszURL )
            {
                pResult->Append( _T(";\r\n\tsrc:url(") );
                pResult->Append( pcszURL );
                pResult->Append( _T(")") );
            }
            pResult->Append( _T(";\r\n}\r\n") );
        }
    }


    // Handle @page rules
    {
        HRESULT hr = S_OK;
        CAttrArray *pAA = NULL;
        const CAttrValue *pAV = NULL;
        int iLen;
        int idx;
        LPCTSTR lpPropName = NULL;
        LPCTSTR lpPropValue = NULL;
        BSTR bstrTemp = NULL;
        long nPageRules = _apPageBlocks.Size();
        CAtPageBlock *pPage = NULL;

        for (int i=0 ; i < nPageRules ; ++i )
        {
            pPage = _apPageBlocks[i];
            pAA = pPage->_pAA;

            pResult->Append( _T("@page ") );
            pResult->Append( pPage->_cstrSelectorText );
            if ( pPage->_cstrPseudoClassText.Length() )
            {
                pResult->Append( _T(":") );
                pResult->Append( pPage->_cstrPseudoClassText );
            }
            pResult->Append( _T(" {") );

            // Dump expandos
            // NB (JHarding): For an empty rule, ie
            // @page {}
            // pPage->_pAA is NULL.
            if( pAA )
            {
                pAV = (CAttrValue *)(*pAA);
                iLen = pAA->Size();
                for ( idx=0; idx < iLen; idx++ )
                {
                    if ((pAV->AAType() == CAttrValue::AA_Expando))
                    {
                        hr = pBase->GetExpandoName( pAV->GetDISPID(), &lpPropName );
                        if (hr)
                            continue;

                        if ( pAV->GetIntoString( &bstrTemp, &lpPropValue ) )
                            continue;   // Can't convert to string

                        pResult->Append( lpPropName );
                        pResult->Append( _T(": ") );
                        pResult->Append( lpPropValue );
                        if ( bstrTemp )
                        {
                            SysFreeString ( bstrTemp );
                            bstrTemp = NULL;
                        }
                        pResult->Append( _T("; ") );
                    }
                    pAV++;
                }
            }
            pResult->Append( _T("}\r\n") );
        }
    }


    {
        // Handle rules
        CStyleRule *pRule;
        CStyleRule **pRE;
        int i, nRules;


        DWORD           dwPrevMedia = (DWORD)MEDIA_NotSet;
        DWORD           dwCurMedia;
        CBufferedStr    strMediaString;

        // Handle rules.
        for ( pRE = _apRulesList, i = 0, nRules = _apRulesList.Size();
              i < nRules; i++, pRE++ )
        {
            pRule = (*pRE);
            if ( pRule )
            {
                // Write the media type string if it has changed from previous rule
                dwCurMedia = pRule->GetLastAtMediaTypeBits();
                if(dwCurMedia != MEDIA_NotSet)
                {
                    if(dwCurMedia != dwPrevMedia)
                    {
                        // Media type has changed, close the previous if needed and open a new one
                        if(dwPrevMedia != MEDIA_NotSet)
                            pResult->Append( _T("\r\n}\r\n") );

                        pResult->Append( _T("\r\n@media ") );
                        pRule->GetMediaString(dwCurMedia, &strMediaString);
                        pResult->Append(strMediaString);
                        pResult->Append( _T("    \r\n{\r\n") );
                    }
                }
                else
                {
                    // Close the old one if it is there
                    if(dwPrevMedia != MEDIA_NotSet)
                        pResult->Append( _T("    }\r\n") );
                }

                // Save the new namespace as the current one
                dwPrevMedia = dwCurMedia;

                // Now append the rest of the rule
                pRule->GetString( pBase, pResult );
            }
        }

        // If we have not closed the last namespace, close it
        if(dwPrevMedia != MEDIA_NotSet)
            pResult->Append( _T("\r\n}\r\n") );
    }

    return S_OK;
}



//*********************************************************************
//      CSharedStyleSheet::AppendFontFace()
// Note: Add a CAtPageBlock into our collection
//*********************************************************************
HRESULT
CSharedStyleSheet::AppendFontFace(CAtFontBlock *pAtFont)
{
    Assert(pAtFont);
    _apFontBlocks.Append(pAtFont);
    pAtFont->AddRef();
    return S_OK;
}





//*********************************************************************
//      CSharedStyleSheet::AppendPage()
// Note: Add a CAtPageBlock into our collection
//*********************************************************************
HRESULT
CSharedStyleSheet::AppendPage(CAtPageBlock *pAtPage)
{
    Assert(pAtPage);
    _apPageBlocks.Append(pAtPage);
    pAtPage->AddRef();
    return S_OK;
}



//*********************************************************************
//      CSharedStyleSheet::DbgIsValid()
//  Debug functions
//*********************************************************************
#if DBG==1
BOOL
CSharedStyleSheet::DbgIsValid()
{
    // check to make sure all the rules are valid
    if(IsTagEnabled(tagSharedStyleSheet))
    {
        CStyleRule **pSR;
        int z;
        for ( z = 0, pSR = _apRulesList;
              z < _apRulesList.Size();
              z++, pSR++
              )
        {
            // valid _sidRule is relative id -- no sheetid contained
            if ( (*pSR)->GetRuleID().GetSheet() != 0)
            {
                TraceTag( (tagSharedStyleSheet, "CSharedStyleSheet: invalid due to sheetid in rule [%d]", z) );
                goto Error;
            }

            // valid rules are positioned correctly
            if ( (*pSR)->GetRuleID().GetRule() != (unsigned int)(z+1) )
            {
                TraceTag( (tagSharedStyleSheet,  "CSharedStyleSheet: invalid due to vaild rule [%d] in wrong position [%d]", (*pSR)->GetRuleID().GetRule(), z) );
                goto Error;
            }

            // any rule should only be referenced once and only once
            // in the indexed rule array and the hash tables
            if ( !ExistsOnceInRulesArrays( (*pSR) ) )
            {
                TraceTag( (tagSharedStyleSheet, "CSharedStyleSheet: invalid due to !exist once and only once in indexes") );
                goto Error;
            }
        }
    }

    // Now, for every rule in the indexed array , make sure it shows up in
    // the style sheet once and only once
    if(IsTagEnabled(tagSharedStyleSheet))
    {
        for (int iRA=0 ; iRA < ETAG_LAST ; ++iRA)
        {
            CStyleRuleArray *pRA = &(_pRulesArrays[iRA]);
            int nRules = pRA->Size();
            int iRule;
            CStyleRule * pR;

            for (iRule=0 ; iRule < nRules ; ++iRule)            // for all rules in this array
            {
                pR = pRA->Item(iRule);

                if (OccurancesInStyleSheet(pR) != 1)
                {
                    TraceTag( (tagSharedStyleSheet, "CSharedStyleSheet: invalid due to index rules occurance in rule array != 1") );
                    goto Error;
                }

            }
        }

        //
        // Check validity of the hash tables
        //
        UINT iIndex;
        CStyleRuleArray * pary;
        for (pary = (CStyleRuleArray *)_htClassSelectors.GetFirstEntry(&iIndex);
             pary;
             pary = (CStyleRuleArray *)_htClassSelectors.GetNextEntry(&iIndex))
        {
            int nRules = pary->Size();
            int iRule;
            CStyleRule * pR;

            for (iRule=0 ; iRule < nRules ; ++iRule)            // for all rules in this array
            {
                pR = pary->Item(iRule);

                if (OccurancesInStyleSheet(pR) != 1)
                {
                    TraceTag( (tagSharedStyleSheet, "CSharedStyleSheet: invalid due to index rules occurance in rule array != 1") );
                    goto Error;
                }
            }
        }

        for (pary = (CStyleRuleArray *)_htIdSelectors.GetFirstEntry(&iIndex);
             pary;
             pary = (CStyleRuleArray *)_htIdSelectors.GetNextEntry(&iIndex))
        {
            int nRules = pary->Size();
            int iRule;
            CStyleRule * pR;

            for (iRule=0 ; iRule < nRules ; ++iRule)            // for all rules in this array
            {
                pR = pary->Item(iRule);

                if (OccurancesInStyleSheet(pR) != 1)
                {
                    TraceTag( (tagSharedStyleSheet, "CSharedStyleSheet: invalid due to index rules occurance in rule array != 1") );
                    goto Error;
                }

            }
        }
    }

    return TRUE;
Error:
    Assert( FALSE && "CSharedStyleSheet - DbgIsValid FALSE!");
    return FALSE;
}


BOOL
CSharedStyleSheet::ExistsOnceInRulesArrays( CStyleRule * pRule )
{
    BOOL fFound = FALSE;

    int iRA;
    for (iRA=0 ; iRA < ETAG_LAST ; ++iRA)
    {
        CStyleRuleArray *pRA = &(_pRulesArrays[iRA]);
        int nRules = pRA->Size();
        int iRule;
        CStyleRule * pRuleCompare;

        for (iRule=0 ; iRule < nRules ; ++iRule)            // for all rules in this array
        {
            pRuleCompare = pRA->Item(iRule);

            if (pRuleCompare == pRule)
            {
                if (fFound)
                    return FALSE; // multiple times
                fFound = TRUE;
            }
        }
    }

    // see if this also exist in hash tables
    {
        UINT iIndex;
        CStyleRuleArray * pary;
        for (pary = (CStyleRuleArray *)_htClassSelectors.GetFirstEntry(&iIndex);
             pary;
             pary = (CStyleRuleArray *)_htClassSelectors.GetNextEntry(&iIndex))
        {
            int nRules = pary->Size();
            int iRule;
            CStyleRule * pR;

            for (iRule=0 ; iRule < nRules ; ++iRule)            // for all rules in this array
            {
                pR = pary->Item(iRule);

                if (pR == pRule)
                {
                    if (fFound)
                        return FALSE;   // multiple times
                    fFound = TRUE;
                }
            }
        }

        for (pary = (CStyleRuleArray *)_htIdSelectors.GetFirstEntry(&iIndex);
             pary;
             pary = (CStyleRuleArray *)_htIdSelectors.GetNextEntry(&iIndex))
        {
            int nRules = pary->Size();
            int iRule;
            CStyleRule * pR;

            for (iRule=0 ; iRule < nRules ; ++iRule)            // for all rules in this array
            {
                pR = pary->Item(iRule);

                if (pR == pRule)
                {
                    if (fFound)
                        return FALSE;   // multiple times
                    fFound = TRUE;
                }

            }
        }
    }

    return fFound;
}


int
CSharedStyleSheet::OccurancesInStyleSheet( CStyleRule * pRule )
{
    int nFound = 0;
    int iSSR, nSSR;
    CStyleRule * pRuleCompare;
    for (iSSR = 0, nSSR = _apRulesList.Size(); iSSR < nSSR; iSSR++)
    {
        pRuleCompare = _apRulesList[iSSR];

        if (pRuleCompare == pRule)
        {
            nFound++;
        }

    }

    return nFound;
}


VOID
CSharedStyleSheet::Dump(CStyleSheet *pStyleSheet)
{
    Assert(pStyleSheet);
    unsigned long lLevel = pStyleSheet->_sidSheet.FindNestingLevel();
    // check to make sure all the rules are valid
    {
        CStyleRule **pSR;
        int z;
        for ( z = 0, pSR = _apRulesList;
              z < _apRulesList.Size();
              z++, pSR++
              )
        {
            CStr cstr;

            (*pSR)->GetString(pStyleSheet, &cstr);
            WriteChar(g_f, ' ', lLevel * 8 + 2);
            WriteHelp(g_f, _T("(<0d>)<1s>\r\n "), (*pSR)->GetRuleID().GetRule(),cstr);
        }
    }



}
#endif


//---------------------------------------------------------------------
//  Class Declaration:  CAtPageBlock
//      This class implements a parsed page block - it managers all
//  the properties in an @page block
//---------------------------------------------------------------------

//*********************************************************************
//      CAtPageBlock::CAtPageBlock()
// Note: _pAA is created by CStyleSheetPage
//
//*********************************************************************
CAtPageBlock::CAtPageBlock()
    :
    _cstrSelectorText(),
    _cstrPseudoClassText(),
    _pAA(NULL),
    _ulRefs(1)
{

}


CAtPageBlock::~CAtPageBlock()
{
    // free should have been called
    Assert(_pAA == NULL);
}


void CAtPageBlock::Free(void)
{
    if (_pAA)
    {
        delete _pAA;
        _pAA = NULL;
    }
}


HRESULT
CAtPageBlock::Clone(CAtPageBlock **ppAtPage)
{
    HRESULT  hr = S_OK;

    hr = Create(ppAtPage);
    if (hr)
        goto Cleanup;

    if (_pAA)
    {
        hr = _pAA->Clone( &(*ppAtPage)->_pAA );
        if (hr)
            goto Cleanup;
    }

    (*ppAtPage)->_cstrSelectorText.Set(_cstrSelectorText);
    (*ppAtPage)->_cstrPseudoClassText.Set(_cstrPseudoClassText);

Cleanup:
    RRETURN(hr);
}


HRESULT
CAtPageBlock::Create(CAtPageBlock **ppAtPgBlk)
{
    HRESULT  hr = S_OK;

    Assert( ppAtPgBlk );
    *ppAtPgBlk = new CAtPageBlock();
    if (!*ppAtPgBlk)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    (*ppAtPgBlk)->_pAA = new CAttrArray;
    if (!(*ppAtPgBlk)->_pAA)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    if (hr)
    {
        if (*ppAtPgBlk)
        {
            (*ppAtPgBlk)->Free();
            delete *ppAtPgBlk;
            *ppAtPgBlk = NULL;
        }
    }
    return hr;
}




//---------------------------------------------------------------------
//  Class Declaration:  CAtFontBlock
//      This class implements a parsed/downloaded font block -
//---------------------------------------------------------------------

//*********************************************************************
//      CAtFontBlock::CAtFontBlock()
// Note: _pAA is created by CStyleSheetPage
//
//*********************************************************************
CAtFontBlock::CAtFontBlock()
    :
    _pszFaceName(NULL),
    _pAA(NULL),
    _ulRefs(1)
{
}


CAtFontBlock::~CAtFontBlock()
{
    // free should have been called
    Assert(_pAA == NULL);
    Assert(_pszFaceName == NULL);
}


void CAtFontBlock::Free(void)
{
    if (_pAA)
    {
        delete _pAA;
        _pAA = NULL;
    }

    if ( _pszFaceName )
      MemFree( _pszFaceName ); //free
    _pszFaceName = NULL;
}



HRESULT
CAtFontBlock::Clone(CAtFontBlock **ppAtFont)
{
    //
    // TODO: this only works if CAtFontBlock is
    // read only. Needs further consideration!
    //
    this->AddRef();
    *ppAtFont = this;

    return S_OK;
}


HRESULT
CAtFontBlock::Create(CAtFontBlock **ppAtFontBlock, LPCTSTR pcszFaceName)
{
    HRESULT  hr = S_OK;

    Assert( ppAtFontBlock );
    *ppAtFontBlock = new CAtFontBlock();

    if (!*ppAtFontBlock)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    (*ppAtFontBlock)->_pAA = new CAttrArray;
    if (!(*ppAtFontBlock)->_pAA)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if ( pcszFaceName )
    {

        hr = THR( MemAllocString(Mt(CAtFontBlock), pcszFaceName, &((*ppAtFontBlock)->_pszFaceName)) );
    }

Cleanup:
    if (hr)
    {
        if (*ppAtFontBlock)
        {
            (*ppAtFontBlock)->Free();
            delete *ppAtFontBlock;
            *ppAtFontBlock = NULL;
        }
    }
    RRETURN(hr);
}



//---------------------------------------------------------------------
//  Class Declaration:  CSharedStyleSheetsManager
//      This class managers all the shared style sheets
//---------------------------------------------------------------------
//*********************************************************************
//      CSharedStyleSheetsManager::CSharedStyleSheetsManager
//
//*********************************************************************
CSharedStyleSheetsManager::CSharedStyleSheetsManager(CDoc *pDoc)
{
#ifdef CSSS_MT
    memset(&_cs, 0, sizeof(CRITICAL_SECTION));
#endif
    _pDoc = pDoc;
}


HRESULT
CSharedStyleSheetsManager::Create(CSharedStyleSheetsManager **ppSSSM, CDoc *pDoc)
{
    HRESULT hr = S_OK;
    Assert(ppSSSM);
    (*ppSSSM) = new CSharedStyleSheetsManager(pDoc);
    if (!(*ppSSSM))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

#ifdef CSSS_MT
    hr = THR(HrInitializeCriticalSection( &((*ppSSSM)->_cs) ));
#endif

Cleanup:
    RRETURN(hr);
}


CSharedStyleSheetsManager::~CSharedStyleSheetsManager()
{
#ifdef CSSS_MT
    DeleteCriticalSection(&_cs);
#endif

    //
    // If someone holds a reference to the style sheet after
    // the DOC is gone, we have to disconnect it with 
    // this manager. 
    //
    CSharedStyleSheet **pAry;
    int n;
    for (n = _apSheets.Size(), pAry = _apSheets;
         n > 0;
         n--, pAry++
        )
    {
        Assert( (*pAry) 
                && !(*pAry)->_fInvalid 
                && !(*pAry)->_fModified 
                );
        (*pAry)->_pManager = NULL;
        TraceTag( (tagWarning, "SharedStyleSheetsManager goes away while its shared style sheets are still alive [%p]",(*pAry)) );
    }
}




#ifdef CSSS_MT
HRESULT
CSharedStyleSheetsManager::Enter()
{
    HRESULT  hr = S_OK;

    __try
    {
        TraceTag( (tagSharedStyleSheet, "[%p] -- try enter CS by tid [0x%x]", this, GetCurrentThreadId()) );
        ::EnterCriticalSection(&_cs);
        TraceTag( (tagSharedStyleSheet, "[%p] -- entered CS by tid [0x%x]", this, GetCurrentThreadId()) );

    } __except(GetExceptionCode() == STATUS_INVALID_HANDLE)
    {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}



HRESULT
CSharedStyleSheetsManager::Leave()
{
    TraceTag( (tagSharedStyleSheet, "CSharedStyleSheetsManager [%p] -- leavingr CS by tid [0x%x]", this, GetCurrentThreadId()) );
    LeaveCriticalSection(&_cs);
    return S_OK;
}
#endif



#if  DBG == 1
BOOL
CSharedStyleSheetsManager::DbgIsValid()
{
    CSharedStyleSheet **pAry;
    int n;
    for (n = _apSheets.Size(), pAry = _apSheets;
         n > 0;
         n--, pAry++
        )
    {

        Assert( (*pAry)
                && !(*pAry)->_fInvalid
                && !(*pAry)->_fModified
                );
        {
            int z;
            int nFound = 0;
            for (z = 0; z < _apSheets.Size(); z++)
            {
                if (_apSheets[z] == (*pAry))
                    nFound++;
            }
            if (nFound != 1)
            {
                Assert( FALSE &&  "CSharedStyleSheetsManager : more than one copy of [%p] exist in shared array!");
                return FALSE;
            }
        }
    }

    return TRUE;
}


VOID
CSharedStyleSheetsManager::Dump()
{
    if (!InitDumpFile( TRUE ))
        return;

    CSharedStyleSheet **pAry;
    int n;
    for (n = 0, pAry = _apSheets;
         n < _apSheets.Size();
         n++, pAry++
        )
    {
        CStr        strRule;
        CHAR        szBuffer[1024];
        WideCharToMultiByte(CP_ACP, 0, (*pAry)->_achAbsoluteHref, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
        TraceTag( (tagSharedStyleSheet, "[%2d]-%s", n, szBuffer) );

        WriteHelp(g_f, _T("<0d>-<1s>\r\n"), n, (*pAry)->_achAbsoluteHref);
    }

    CloseDumpFile();
}

#endif


//*********************************************************************
//      CSharedStyleSheetsManager::AddSharedStyleSheet
//
//*********************************************************************
HRESULT
CSharedStyleSheetsManager::AddSharedStyleSheet(CSharedStyleSheet *pSSS)
{
#ifdef CSSS_MT
    CLock _lock(this);
#endif

    HRESULT  hr = S_OK;

    Assert( DbgIsValid() );

    if (_apSheets.Find(pSSS) > 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(_apSheets.Append(pSSS));
    if (!hr)
    {
        pSSS->_pManager = this;
    }

Cleanup:
    RRETURN(hr);
}


//*********************************************************************
//      CSharedStyleSheetsManager::RemoveSharedStyleSheet
//
//*********************************************************************
HRESULT
CSharedStyleSheetsManager::RemoveSharedStyleSheet(CSharedStyleSheet *pSSS)
{
#ifdef CSSS_MT
    CLock _lock(this);
#endif

    Assert( DbgIsValid() );
    Assert( pSSS );
    pSSS->_pManager = NULL;

    if (_apSheets.DeleteByValue(pSSS))
        return S_OK;

    return E_FAIL;
}

//*********************************************************************
//  CSharedStyleSheetsManager::FindSharedStyleSheet
//
// Find one shared style sheet other than the passed in one that can be reused
//
// S_OK:    Find a match -- everything is okay
// S_FALSE: Cannot find a match
//
//*********************************************************************
HRESULT
CSharedStyleSheetsManager::FindSharedStyleSheet(CSharedStyleSheet **ppSSS, CSharedStyleSheetCtx *pCtx)
{
#ifdef CSSS_MT
    CLock _lock(this);
#endif

    Assert( DbgIsValid() );
    Assert( pCtx && pCtx->_szAbsUrl && pCtx->_pParentElement);
    Assert( ppSSS );

    HRESULT hr = S_FALSE;

    *ppSSS = NULL;

#if DBG == 1
    if (IsTagEnabled(tagSharedStyleSheet))
    {
        Dump();
    }
    {
        CStr        strRule;
        CHAR        szBuffer[1024];
        if (pCtx->_szAbsUrl)
        {
            WideCharToMultiByte(CP_ACP, 0, pCtx->_szAbsUrl, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
        }
        else
        {
            szBuffer[0] = '\0';
        }
        TraceTag( (tagSharedStyleSheet, " Try [%s]", szBuffer) );
    }

#endif


    //
    // simply find the first one that matches
    //
    CSharedStyleSheet **pAry;
    int n;

    if ( !(pCtx->_dwFlags & SSS_IGNORESECUREURLVALIDATION) )
    {
        BOOL        fPendingRoot = FALSE;
        CMarkup *   pMarkup = NULL;

        if (pCtx->_pParentElement->IsInMarkup())
        {
            pMarkup = pCtx->_pParentElement->GetMarkup();
            fPendingRoot = pMarkup->IsPendingRoot();
        }
        else
        {
            pMarkup = _pDoc->PrimaryMarkup();
        }

        Assert(pMarkup);

        if (!pMarkup->ValidateSecureUrl(fPendingRoot, pCtx->_szAbsUrl, FALSE, TRUE))
        {
            TraceTag( (tagSharedStyleSheet, "ValidateSecureUrl returned FALSE") );
            goto Cleanup;
        }
    }

    for (n = 0, pAry = _apSheets;
         n <  _apSheets.Size();
         n++, pAry++
        )
    {
        if ( (*pAry)
            && ( !(*pAry)->_fModified )
            && ( (*pAry)->_achAbsoluteHref && pCtx->_szAbsUrl && _tcsequal((*pAry)->_achAbsoluteHref, pCtx->_szAbsUrl)  )
            && ( (*pAry)->_eMediaType == (EMediaType)MEDIATYPE(pCtx->_dwMedia) )
            && ( (!!(*pAry)->_fExpando) == !!pCtx->_fExpando  )
            && ( (!!(*pAry)->_fXMLGeneric) == !!pCtx->_fXMLGeneric  )
            && ( !!(*pAry)->_fIsStrictCSS1 == !!pCtx->_fIsStrictCSS1 )
            && ( ((*pAry)->_cp) == pCtx->_cp )
           )
        {
            BOOL  fFound = TRUE;

            if (!(pCtx->_dwFlags & SSS_IGNORECOMPLETION) )
            {
                if ( !(*pAry)->_fComplete )
                {
                    TraceTag( (tagSharedStyleSheet, "Not matching - not completed!") );
                    continue;
                }
            }

            if (!(pCtx->_dwFlags & SSS_IGNOREREFRESH))
            {
                if ( (*pAry)->_dwRefresh != pCtx->_dwRefresh )
                {
                    TraceTag( (tagSharedStyleSheet, "Not matching _dwRefresh [%x] - pCtx->_dwRefresh [%x]", (*pAry)->_dwRefresh, pCtx->_dwRefresh) );
                    continue;
                }
            }


            if (!(pCtx->_dwFlags & SSS_IGNOREBINDF))
            {
                if ( ((*pAry)->_dwBindf & BINDF_OFFLINEOPERATION) != (pCtx->_dwBindf & BINDF_OFFLINEOPERATION) )
                {
                    TraceTag( (tagSharedStyleSheet, "Not matching _dwBindf [%x] - pCtx->_dwBindf [%x]", (*pAry)->_dwBindf, pCtx->_dwBindf) );
                    continue;
                }
            }

            if ( !(pCtx->_dwFlags & SSS_IGNORELASTMOD) )
            {
                fFound = FALSE;
                if (pCtx->_pft)
                {
                    // this is the match - check to see if it expires...
                    TraceTag( (tagSharedStyleSheet, "timestamp [%d] - FT [%x] [%x]", n, (*pAry)->_ft.dwHighDateTime, (*pAry)->_ft.dwLowDateTime) );
                    TraceTag( (tagSharedStyleSheet, "timestamp target - FT [%x] [%x]", pCtx->_pft->dwHighDateTime, pCtx->_pft->dwLowDateTime) );
                    if (memcmp(&((*pAry)->_ft), &g_Zero, sizeof(FILETIME)) != 0)   // not empty
                    {
                        Assert(pCtx->_pft);
                        if (memcmp(&((*pAry)->_ft), pCtx->_pft, sizeof(FILETIME)) == 0)
                        {
                            Assert( (*pAry) != pCtx->_pSSInDbg );
                            TraceTag( (tagSharedStyleSheet, "Found by matching timestamp!") );

                            fFound = TRUE;
                        }
                    }
                    else
                        TraceTag( (tagSharedStyleSheet, "Warning: Found SS with empty timestamp!") );
                }
            }

            if (fFound)
            {
                *ppSSS = (*pAry);
                WHEN_DBG( InterlockedIncrement( &((*ppSSS)->_lReserveCount) ) );
                (*ppSSS)->AddRef();
                hr  =  S_OK;
                TraceTag( (tagSharedStyleSheet, "Found a good SharedStyleSheet at [%d]", n) );
                goto Cleanup;
            }
        }
    }

    TraceTag( (tagSharedStyleSheet, "Cannot find a matching shared style sheet") );
Cleanup:
    RRETURN1(hr, S_FALSE);
}


//*********************************************************************
//      CSharedStyleSheetsManager::GetUrlTime()
//*********************************************************************
extern HRESULT  CoInternetParseUrl(LPCWSTR pwzUrl, PARSEACTION ParseAction, DWORD dwFlags, LPWSTR pszResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved);
extern BOOL GetFileLastModTime(TCHAR * pchFile, FILETIME * pftLastMod);

BOOL
GetUrlTime(FILETIME *pt, const TCHAR *pszAbsUrl, CElement *pElem)
{
    BOOL  fRet = FALSE;
    Assert( pszAbsUrl );
    {
        // only works for file://
        TCHAR achPath[MAX_PATH];
        DWORD cchPath;

        HRESULT hr = THR(CoInternetParseUrl(pszAbsUrl, PARSE_PATH_FROM_URL, 0,
                    achPath, ARRAY_SIZE(achPath), &cchPath, 0));

        if (hr == S_OK)
        {
            fRet = GetFileLastModTime(achPath, pt);
        }
    }

#if 0
    if (!fRet)
    {
        extern BOOL GetUrlLastModTime(TCHAR * pchUrl, UINT uScheme, DWORD dwBindf, FILETIME * pftLastMod);
       // this does not work well for APPs
        {
            DWORD    dwBindf = 0;
            UINT     uScheme;
            if (pElem && pElem->IsInMarkup())
            {
                CDwnDoc *pDwnDoc = pElem->GetMarkup()->GetWindowedMarkupContext()->GetDwnDoc();
                if (pDwnDoc)
                {
                    dwBindf = pDwnDoc->GetBindf();
                }
            }

            uScheme = GetUrlScheme(pszAbsUrl);
            fRet = GetUrlLastModTime(const_cast<TCHAR *>(pszAbsUrl), uScheme, dwBindf, pt);
        }
    }
#endif

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\style\t2embapi.h ===
/***************************************************************************
 * Module: T2EMBAPI.H
 *
 * Copyright (c) Microsoft Corp., 1996, 1997
 *
 * Author: Paul Linnerud (paulli)
 * Date:   May 1996
 *
 * Mods:
 *
 * Header file for the TrueType embedding services dll (T2EMBED.DLL)
 *
 **************************************************************************/

#ifndef I_T2EMBAPI_H_
#define I_T2EMBAPI_H_
#pragma INCMSG("--- Beg 't2embapi.h'")

#if !defined(_T2API_LIB_)
#define T2API __declspec(dllimport)
#else
#define T2API __declspec(dllexport)
#endif

// Charset flags for ulCharSet field of TTEmbedFont
#if !defined(CHARSET_UNICODE)
#define CHARSET_UNICODE                    1
#define CHARSET_DEFAULT                    1
#define CHARSET_SYMBOL                     2
#endif

// Status returned by TTLoadEmbeddedFont
#if !defined(EMBED_PREVIEWPRINT)
#define EMBED_PREVIEWPRINT                 1
#define EMBED_EDITABLE                     2
#define EMBED_INSTALLABLE                  3
#define EMBED_NOEMBEDDING                  4
#endif

// Use restriction flags
#if !defined(LICENSE_INSTALLABLE)
#define LICENSE_INSTALLABLE             0x0000
#define LICENSE_DEFAULT                 0x0000
#define LICENSE_NOEMBEDDING             0x0002
#define LICENSE_PREVIEWPRINT            0x0004
#define LICENSE_EDITABLE                0x0008
#endif

// Options given to TTEmbedFont in uFlags parameter
#if !defined(TTEMBED_RAW)
#define TTEMBED_RAW							0x00000000
#define TTEMBED_SUBSET						0x00000001
#define TTEMBED_TTCOMPRESSED				0x00000004
#define TTEMBED_FAILIFVARIATIONSIMULATED	0x00000010
#define TTEMBED_XORENCRYPTDATA				0x10000000 // internal
#endif

// Bits returned through pulStatus for TTEmbedFont
#if !defined(TTEMBED_VARIATIONSIMULATED)
#define TTEMBED_VARIATIONSIMULATED		0x00000001					
#endif

// Flag options for TTLoadEmbeddedFont 
#if !defined(TTLOAD_PRIVATE)
#define TTLOAD_PRIVATE                  0x00000001 
#endif

// Bits returned through pulStatus for TTLoadEmbeddedFont 
#if !defined(TTLOAD_FONT_SUBSETTED)
#define TTLOAD_FONT_SUBSETTED		0x00000001
#define TTLOAD_FONT_IN_SYSSTARTUP	0x00000002
#endif

// Flag options for TTDeleteEmbeddedFont
#if !defined(TTDELETE_DONTREMOVEFONT)
#define TTDELETE_DONTREMOVEFONT		0x00000001	
#endif

// Error codes
#if !defined(E_NONE)
#define E_NONE                      0x0000L
#endif

// Top level error codes
#if !defined(E_CHARCODECOUNTINVALID)
#define E_CHARCODECOUNTINVALID      0x0002L
#define E_CHARCODESETINVALID        0x0003L
#define E_DEVICETRUETYPEFONT        0x0004L
#define E_HDCINVALID                0x0006L
#define E_NOFREEMEMORY              0x0007L
#define E_FONTREFERENCEINVALID      0x0008L
#define E_NOTATRUETYPEFONT          0x000AL
#define E_ERRORACCESSINGFONTDATA    0x000CL
#define E_ERRORACCESSINGFACENAME    0x000DL
#define E_ERRORUNICODECONVERSION    0x0011L
#define E_ERRORCONVERTINGCHARS      0x0012L
#define E_EXCEPTION					0x0013L
#define E_RESERVEDPARAMNOTNULL		0x0014L	
#define E_CHARSETINVALID			0x0015L
#define E_WIN32S_NOTSUPPORTED		0x0016L
#endif

// Indep level error codes 
#if !defined(E_ERRORCOMPRESSINGFONTDATA)
#define E_ERRORCOMPRESSINGFONTDATA    0x0100L
#define E_FONTDATAINVALID             0x0102L
#define E_NAMECHANGEFAILED            0x0103L
#define E_FONTNOTEMBEDDABLE           0x0104L
#define E_PRIVSINVALID                0x0105L
#define E_SUBSETTINGFAILED            0x0106L
#define E_READFROMSTREAMFAILED        0x0107L
#define E_SAVETOSTREAMFAILED          0x0108L
#define E_NOOS2                       0x0109L
#define E_T2NOFREEMEMORY              0x010AL
#define E_ERRORREADINGFONTDATA        0x010BL
#define E_FLAGSINVALID                0x010CL
#define E_ERRORCREATINGFONTFILE       0x010DL
#define E_FONTALREADYEXISTS           0x010EL
#define E_FONTNAMEALREADYEXISTS       0x010FL
#define E_FONTINSTALLFAILED           0x0110L
#define E_ERRORDECOMPRESSINGFONTDATA  0x0111L
#define E_ERRORACCESSINGEXCLUDELIST   0x0112L
#define E_FACENAMEINVALID			  0x0113L
#define E_STREAMINVALID               0x0114L
#define E_STATUSINVALID				  0x0115L
#define E_PRIVSTATUSINVALID			  0x0116L
#define E_PERMISSIONSINVALID		  0x0117L
#define E_PBENABLEDINVALID			  0x0118L
#define E_SUBSETTINGEXCEPTION		  0x0119L
#define E_SUBSTRING_TEST_FAIL		  0x011AL
#define E_FONTVARIATIONSIMULATED	  0x011BL
#endif

// Bottom level error codes
#if !defined(E_ADDFONTFAILED)
#define E_ADDFONTFAILED             0x0200L
#define E_COULDNTCREATETEMPFILE     0x0201L
#define E_FONTFILECREATEFAILED      0x0203L
#define E_WINDOWSAPI                0x0204L
#define E_FONTFILENOTFOUND          0x0205L
#define E_RESOURCEFILECREATEFAILED  0x0206L
#define E_ERROREXPANDINGFONTDATA    0x0207L
#define E_ERRORGETTINGDC            0x0208L
#define E_EXCEPTIONINDECOMPRESSION	0x0209L
#define E_EXCEPTIONINCOMPRESSION	0x020AL
#endif

#ifdef __cplusplus
extern "C" {
#endif

// 1st argument - Stream identifier (file handle or other) (dwStream) */
// 2nd argument - Address of buffer with data to read or write */
// 3rd argument - Number of bytes to read or write */
typedef unsigned long( __cdecl *READEMBEDPROC ) ( void*, void*, const unsigned long );
typedef unsigned long( __cdecl *WRITEEMBEDPROC ) ( void*, const void*, const unsigned long );

#if !defined(_TTLOADINFO_DEFINED)
typedef struct
{
	unsigned short usStructSize;	// size in bytes of structure client should set to sizeof(TTLOADINFO)
	unsigned short usRefStrSize;	// size in wide characters of pusRefStr including NULL terminator
	LPTSTR  pusRefStr;		// reference or actual string. 
}TTLOADINFO;
#define _TTLOADINFO_DEFINED
#endif

#if !defined(_TTEMBEDINFO_DEFINED)
typedef struct
{
	unsigned short usStructSize;	// size in bytes of structure client should set to sizeof(TTEMBEDINFO)
	unsigned short usRootStrSize;   // size in wide chars of pusSubStr including NULL terminator(s)
	LPTSTR  pusRootStr;		// substring(s) of strings given at load time. can have multiple strings separated
									//  by a NULL terminator. 
}TTEMBEDINFO;
#define _TTEMBEDINFO_DEFINED
#endif

/* Font Embedding APIs ----------------------------------------------------*/

T2API LONG WINAPI TTEmbedFont
(
	HDC       hDC,                    // device-context handle
	ULONG     ulFlags,                // flags specifying the request
	ULONG     ulCharSet,              // flags specifying char set
	ULONG*    pulPrivStatus,          // upon completion contains embedding priv of font
	ULONG*    pulStatus,              // on completion may contain status flags for request
	WRITEEMBEDPROC lpfnWriteToStream, // callback function for doc/disk writes
	LPVOID    lpvWriteStream,         // the output stream tokin
	USHORT*   pusCharCodeSet,         // address of buffer containing optional
									  // character codes for subsetting
	USHORT    usCharCodeCount,        // number of characters in the
									  // lpvCharCodeSet buffer
	USHORT    usLanguage,             // specifies the language in the name table to keep
									  //  set to 0 to keep all
	TTEMBEDINFO* pTTEmbedInfo         // optional security
);


T2API LONG WINAPI TTLoadEmbeddedFont
(
	HANDLE*   phFontReference,			// on completion, contains handle to identify embedded font installed
										// on system
	ULONG	  ulFlags,					// flags specifying the request 
	ULONG*    pulPrivStatus,			// on completion, contains the embedding status
	ULONG     ulPrivs,					// allows for the reduction of licensing privileges
	ULONG*    pulStatus,				// on completion, may contain status flags for request 
	READEMBEDPROC lpfnReadFromStream,	// callback function for doc/disk reads
	LPVOID    lpvReadStream,			// the input stream tokin
	LPWSTR    szWinFamilyName,			// the new 16 bit windows family name can be NULL
	LPSTR	  szMacFamilyName,			// the new 8 bit mac family name can be NULL
	TTLOADINFO* pTTLoadInfo				// optional security
);

T2API LONG WINAPI TTDeleteEmbeddedFont
(
	HANDLE    hFontReference,	// Reference to font value provided by load functions										
	ULONG	  ulFlags,
	ULONG*    pulStatus
);

T2API LONG WINAPI TTGetEmbeddingType
(                                                                       
	HDC         hDC,                   // device context handle
	ULONG*      pulEmbedType           // upon completion, contains the
									   // embedding status
);

T2API LONG WINAPI TTCharToUnicode
(	
	HDC			hDC,				// device context handle
	UCHAR*		pucCharCodes,		// array of 8 bit character codes to convert
	ULONG		ulCharCodeSize,		// size of 8 bit character code array
	USHORT*     pusShortCodes,		// buffer to recieve Unicode code points
	ULONG		ulShortCodeSize,	// size in wide characters of 16 bit character code array
	ULONG		ulFlags				// Control flags
);


/* Font Enabling APIs -----------------------------------------------------*/

T2API LONG WINAPI TTIsEmbeddingEnabled
(                                                                       
	HDC                     hDC,            // device context handle                                                                
	BOOL*           pbEnabled       // upon completion will indicate if enabled
);                                                              

T2API LONG WINAPI TTIsEmbeddingEnabledForFacename
(                                                                       
	LPSTR           lpszFacename,   // facename
	BOOL*           pbEnabled       // upon completion will indicate if enabled
);

T2API LONG WINAPI TTEnableEmbeddingForFacename
(                                   // If fEnable != 0, it removes the indicated
	LPSTR           lpszFacename,   // typeface name from the "embedding
	BOOL            bEnable         // exclusion list".  Else, it enters the
);                                  // indicated typeface name in the "embedding
									// exclusion list". 

#ifdef __cplusplus
}
#endif

#pragma INCMSG("--- End 't2embapi.h'")
#else
#pragma INCMSG("*** Dup 't2embapi.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\style\t2emwrap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1997
//
//  File:       T2EmWrap.cxx
//
//  Contents:   Wrapper functions for the OpenType Embedding DLL (t2embed.dll).
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_T2EMBAPI_H_
#define X_T2EMBAPI_H_
#include "t2embapi.h"
#endif

#ifndef X_T2EMWRAP_HXX_
#define X_T2EMWRAP_HXX_
#include "t2emwrap.hxx"
#endif


DYNLIB g_dynlibT2Embed = { NULL, NULL, "T2EMBED.DLL" };
DYNPROC g_dynprocT2EmbedLoadFont =
    { NULL, &g_dynlibT2Embed, "TTLoadEmbeddedFont" };
DYNPROC g_dynprocT2EmbedDeleteFont =
    { NULL, &g_dynlibT2Embed, "TTDeleteEmbeddedFont" };

// refcount

ULONG g_cT2EmbedFonts = 0;

void LockT2Embed()
{
    LOCK_GLOBALS;
    g_cT2EmbedFonts++;
}

void FreeT2Embed()
{
    LOCK_GLOBALS;
    g_cT2EmbedFonts--;
    if (g_cT2EmbedFonts == 0)
    {
        FreeDynlib(&g_dynlibT2Embed);
    }
}

LONG WINAPI T2LoadEmbeddedFont( HANDLE *phFontReference, ULONG ulFlags, ULONG *pulPrivStatus,
        ULONG ulPrivs, ULONG *pulStatus, READEMBEDPROC lpfnReadFromStream, LPVOID lpvReadStream,
        LPWSTR szWinFamilyName, LPSTR szMacFamilyName, TTLOADINFO *pTTLoadInfo )
{
    LONG lRet = E_EXCEPTION;
    
    LockT2Embed();
    if ( THR( LoadProcedure( &g_dynprocT2EmbedLoadFont ) ) == S_OK )
    {
        LOADEMBFONTFN lpfnTTLoadEmbeddedFont = (LOADEMBFONTFN)g_dynprocT2EmbedLoadFont.pfn;

        lRet = (lpfnTTLoadEmbeddedFont)( phFontReference, ulFlags, pulPrivStatus, ulPrivs, pulStatus,
                                                    lpfnReadFromStream, lpvReadStream, szWinFamilyName,
                                                    szMacFamilyName, pTTLoadInfo );
    }
    FreeT2Embed();
    return lRet;
}

LONG WINAPI T2DeleteEmbeddedFont ( HANDLE hFontReference, ULONG ulFlags, ULONG *pulStatus )
{
    LONG lRet = E_EXCEPTION;
    
    LockT2Embed();
    if ( THR( LoadProcedure( &g_dynprocT2EmbedDeleteFont ) ) == S_OK )
    {
        DELEMBFONTFN lpfnTTDeleteEmbeddedFont = (DELEMBFONTFN)g_dynprocT2EmbedDeleteFont.pfn;
        lRet = (lpfnTTDeleteEmbeddedFont)( hFontReference, ulFlags, pulStatus );
    }
    FreeT2Embed();
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\style\sheets.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       sheets.cxx
//
//  Contents:   Support for Cascading Style Sheets.. including:
//
//              CStyleSelector
//              CStyleRule
//              CStyleSheet
//              CStyleID
//              CSharedStyleSheet
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_CBUFSTR_HXX_
#define X_CBUFSTR_HXX_
#include "cbufstr.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_TOKENZ_HXX_
#define X_TOKENZ_HXX_
#include "tokenz.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif


#ifndef X_COLLBASE_HXX_
#define X_COLLBASE_HXX_
#include "collbase.hxx"
#endif

#ifndef X_PAGESCOL_HXX_
#define X_PAGESCOL_HXX_
#include "pagescol.hxx"
#endif

#ifndef X_RULESCOL_HXX_
#define X_RULESCOL_HXX_
#include "rulescol.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_HTMTAGS_HXX_
#define X_HTMTAGS_HXX_
#include "htmtags.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"  // For CAnchorElement decl, for pseudoclasses
#endif

#ifndef X_ELINK_HXX_
#define X_ELINK_HXX_
#include "elink.hxx"    // for CLinkElement
#endif

#ifndef X_ESTYLE_HXX_
#define X_ESTYLE_HXX_
#include "estyle.hxx"   // for CStyleElement
#endif

#ifndef X_FONTFACE_HXX_
#define X_FONTFACE_HXX_
#include "fontface.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_ATBLOCKS_HXX_
#define X_ATBLOCKS_HXX_
#include "atblocks.hxx"
#endif



// NOTE: Right now we do a certain amount of dyncasting of _pParentElement to
// either CLinkElement or CStyleElement.  Consider developing an ABC (CStyleSheetElement?)
// that exposes the stylesheet support for elements (e.g. _pStyleSheet, SetReadyState() etc)?
// Might be more trouble than it's worth..

#define _cxx_
#include "sheet.hdl"

MtDefine(StyleSheets, Mem, "StyleSheets")
MtDefine(CStyleSheet, StyleSheets, "CStyleSheet")
MtDefine(CStyleSheet_apFontFaces_pv, CStyleSheet, "CStyleSheet::_apFontFace_pv");
MtDefine(CStyleSheet_apOMRules_pv, CStyleSheet, "CStyleSheet::_apOMRules_pv")
MtDefine(CStyleSheet_CreateNewStyleSheet, StyleSheets, "CStyleSheet::CreateNewStyleSheet");
MtDefine(CNamespace, CStyleSheet, "CStyleSheet::_pDefaultNamespace")
MtDefine(CStyleSelector, StyleSheets, "CStyleSelector")
MtDefine(CStyleClassIDCache, StyleSheets, "CStyleClassIDCache")
MtDefine(CachedStyleSheet, StyleSheets, "CachedStyleSheet")
MtDefine(CStyleSheetAddImportedStyleSheet_pszParsedURL, Locals, "CStyleSheet::AddImportedStyleSheet pszParsedURL")
MtDefine(CClassCache_ary, StyleSheets, "CClassCache_ary")
MtDefine(CCache_ary, StyleSheets, "CCache_ary")
MtDefine(CClassIDStr, StyleSheets, "CClassIDStr")




DeclareTag(tagStyleSheet,                    "Style Sheet", "trace Style Sheet operations")
ExternTag(tagSharedStyleSheet)
extern BOOL GetUrlTime(FILETIME *pt, const TCHAR *pszAbsUrl, CElement *pElem);


#if  DBG == 1
void DumpHref(TCHAR *pszHref)
{
    if (IsTagEnabled(tagStyleSheet))
    {
        CStr        strRule;
        CHAR       szBuffer[2000];

        WideCharToMultiByte(CP_ACP, 0, pszHref, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
        TraceTag( (tagStyleSheet, "Href == [%s]", szBuffer) );
    }
}
#endif                



//*********************************************************************
//  CStyleClassIDCache::~CStyleClassIDCache()
//*********************************************************************
CStyleClassIDCache::~CStyleClassIDCache()
{
    CCacheEntry * pEntry = _aCacheEntry;
    int i = _aCacheEntry.Size();

    for ( ; i > 0 ; i--, pEntry++ )
    {
        pEntry->~CCacheEntry();
    }
}

//*********************************************************************
//  CStyleClassIDCache::EnsureSlot(int slot)
//      Makes sure that this slot is initialized and ready to use
//*********************************************************************
HRESULT CStyleClassIDCache::EnsureSlot(int slot)
{
    HRESULT hr = S_OK;
    int     nOrigSize = _aCacheEntry.Size();
    int     i;
    CCacheEntry * pAryStart;

    Assert(slot >= 0);

    if (slot < nOrigSize)
        goto Cleanup;

    pAryStart = _aCacheEntry;
    
    hr = _aCacheEntry.Grow(slot+1);
    if (hr)
        goto Cleanup;

    if (pAryStart != _aCacheEntry)
    {
        pAryStart = _aCacheEntry;

        for( i = 0; i < nOrigSize; i++, pAryStart++ )
        {
            pAryStart->_aryClass.ReinitAfterPossibleRealloc();
        }
    }
    else
    {
        pAryStart = &(_aCacheEntry[nOrigSize]);
    }

    Assert( pAryStart == &(_aCacheEntry[nOrigSize]));

    for( i = nOrigSize; i <= slot; i++, pAryStart++ )
    {
        // use placement new
        new(pAryStart) CCacheEntry;
    }

Cleanup:
    RRETURN(hr);
}

//*********************************************************************
//  CStyleClassIDCache::PutClass(LPCTSTR pszClass, int slot)
//      Parses and stores the class in the cache.
//*********************************************************************

HRESULT CStyleClassIDCache::PutClass(LPCTSTR pszClass, int slot)
{
    HRESULT hr = S_OK;
    LPCTSTR pszThisClass = NULL; // keep compiler happy
    INT nThisLength = 0; // keep compiler happy
    CClassCache * pClass;
    CDataListEnumerator classNames(pszClass);

    Assert(slot >= 0);
    
    hr = EnsureSlot(slot);
    if (hr)
        goto Cleanup;

    _aCacheEntry[slot]._pszClass = pszClass;

    // Allow for comma, seperated ClassName
    while (classNames.GetNext(&pszThisClass, &nThisLength))
    {
        // NOTE: This should always be non zero but check was in old code...
        Assert(nThisLength); 

        hr = _aCacheEntry[slot]._aryClass.AppendIndirect(NULL, &pClass);
        if (hr)
            goto Cleanup;

        pClass->_pszClass = pszThisClass;
        pClass->_cchClass = nThisLength;
        pClass->_dwHash = HashStringCiDetectW(pszThisClass, nThisLength, 0);
    }

Cleanup:
    RRETURN(hr);
}

//*********************************************************************
//  CStyleClassIDCache::PutNoClass(int slot)
//      Puts an empty entry to denote cache spot is taken.
//*********************************************************************

HRESULT CStyleClassIDCache::PutNoClass(int slot)
{
    HRESULT hr;
    Assert(slot >= 0); 
    
    hr = THR(EnsureSlot(slot));
    if (hr)
        goto Cleanup;

    _aCacheEntry[slot]._pszClass = NULL;

Cleanup:
    RRETURN(hr);
}


//*********************************************************************
//  CStyleClassIDCache::PutID(int slot)
//      Stores the ID in the Cache
//*********************************************************************

void CStyleClassIDCache::PutID(LPCTSTR pszID, int slot)
{
    Assert(slot >= 0); 
    
    if (S_OK != EnsureSlot(slot))
        return;
    
    _aCacheEntry[slot]._pszID = pszID; 
}

//---------------------------------------------------------------------
//  Class Declaration:  CStyleSelector
//      This class implements a representation of a stylesheet selector -
//  that is, a particular tag/attribute situation to match a style rule.
//---------------------------------------------------------------------

//*********************************************************************
//  CStyleSelector::CStyleSelector()
//      The constructor for the CStyleSelector class initializes all
//  member variables.
//*********************************************************************

CStyleSelector::CStyleSelector (Tokenizer &tok, CStyleSelector *pParent, BOOL fIsStrictCSS1, BOOL fXMLGeneric)
{
    _fSelectorErr = FALSE;
    _ulRefs = 0;    // this is to fool the code that does not know that selector does refcounting
    _pParent = pParent;
    _pSibling = NULL;
    _eElementType = ETAG_UNKNOWN;
    _ePseudoclass = pclassNone;
    _ePseudoElement = pelemNone;

    _dwStrClassHash = 0;
    _fIsStrictCSS1 = !!fIsStrictCSS1;

    Init(tok, fXMLGeneric);
}

CStyleSelector::CStyleSelector ()
{
    _ulRefs = 0;
    _pParent = NULL;
    _pSibling = NULL;
    _ePseudoclass = pclassNone;
    _ePseudoElement = pelemNone;
    _eElementType = ETAG_NULL;

    _dwStrClassHash = 0;
}

//*********************************************************************
//  CStyleSelector::~CStyleSelector()
//*********************************************************************
CStyleSelector::~CStyleSelector( void )
{
    delete _pParent;
    delete _pSibling;
}

//*********************************************************************
//  CStyleSelector::Init()
//      This method parses a string selector and initializes all internal
//  member data variables.
//*********************************************************************

HRESULT CStyleSelector::Init (Tokenizer &tok, BOOL fXMLGeneric)
{
    HRESULT                 hr = S_OK;
    TCHAR                  *szIdent;
    ULONG                   cSzIdent;   
    Tokenizer::TOKEN_TYPE   tt;

/*
    selector
      : simple_selector
    simple_selector
      : [[scope:\]? element_name]? [ HASH | class | pseudo ]* S*
    class
      : '.' IDENT
    element_name
      : IDENT | '*'
    pseudo
      : ':' [ IDENT | FUNCTION S* IDENT S* ')' ]
    HASH
      : '#' IDENT
*/

    // First we parse the first part of a selector. E.g. in TABLE DIV #id we are parsing TABLE.

    tt = tok.TokenType();

    Assert(!_fSelectorErr);
    if (tok.IsIdentifier(tt))
    {
        if (fXMLGeneric)
        {
            _eElementType = ETAG_NULL;

            if (tok.CurrentChar() == CHAR_ESCAPE)
            {
                if (tok.IsKeyword(_T("HTML")))
                {
                    if (tok.NextToken() == Tokenizer::TT_EscColon)
                    {
                        // from the html namespace
                        // just skip past the HTML\: and continue the normal HTML parse
                        fXMLGeneric = FALSE;
                        tt = tok.NextToken();
                        if (tt == Tokenizer::TT_Asterisk)
                        {
                            if(_Nmsp.IsEmpty())
                                _eElementType = ETAG_UNKNOWN;      // Wildcard
                            else
                                _eElementType = ETAG_GENERIC;
              
                            _cstrTagName.Set (_T("*"), 1);
                            goto ParseRemaining;  // Done, fetch next token in selector
                        }
                        else if (!tok.IsIdentifier(tt))
                        {
                            // Error, discard this token and continue with rest in this selector
                            hr = S_FALSE;
                            goto ParseRemaining;
                        }
                    }
                    else
                    {
                        // Error, discard this token and continue with rest in this selector
                        hr = S_FALSE;
                        goto ParseRemaining;
                    }
                }
            }
        }

        szIdent = tok.GetStartToken();
        cSzIdent = tok.GetTokenLength();

        if (!fXMLGeneric)
            _eElementType = EtagFromName(szIdent, cSzIdent);      

        if (_eElementType == ETAG_NULL || !_Nmsp.IsEmpty() || tok.CurrentChar() == CHAR_ESCAPE)
        {
            _eElementType = ETAG_GENERIC;
            if(tok.CurrentChar() == CHAR_ESCAPE)
            {
                if (tok.NextToken() == Tokenizer::TT_EscColon)
                {
                    // The selector has scope\:name syntax
                    _Nmsp.SetShortName(szIdent, cSzIdent);
                    
                    tt = tok.NextToken();

                    if (tok.IsIdentifier(tt))
                    {
                        szIdent = tok.GetStartToken();
                        cSzIdent = tok.GetTokenLength();

                        _cstrTagName.Set(szIdent, cSzIdent);
                    }
                    else if (tt == Tokenizer::TT_Asterisk)
                    {
                        if(_Nmsp.IsEmpty())
                            _eElementType = ETAG_UNKNOWN;      // Wildcard
                        else
                            _eElementType = ETAG_GENERIC;
              
                        _cstrTagName.Set (_T("*"), 1);
                    }
                    else
                        hr = S_FALSE;
                }
                else
                    hr = S_FALSE;
            }
            else
            {
                _cstrTagName.Set(szIdent, cSzIdent);
            }
        }
    }
    else if (tt == Tokenizer::TT_Asterisk)
    {
        if(_Nmsp.IsEmpty())
            _eElementType = ETAG_UNKNOWN;      // Wildcard
        else
            _eElementType = ETAG_GENERIC;

        _cstrTagName.Set (_T("*"), 1);
    }
    else
        hr = S_FALSE;

// Now we parse the rest of the selector. E.g in TABLE DIV #id the DIV #id part.

ParseRemaining:

    tt = tok.TokenType();

    while (tt != Tokenizer::TT_EOF)
    {
        if (hr == S_OK)
        {
            // if no whitespace then next token is part of same selector, else bale out.
            if (isspace(tok.PrevChar()))
            {
                tt = tok.NextToken();
                break;
            }
            else
                tt = tok.NextToken();

            // Pseudo elements are only allowed at the beginning of a selector. If we are in standard compliant mode this
            // sets the flag that the rule is invalid in standard compliant mode.
            if ((_ePseudoElement!=pelemNone) && _fIsStrictCSS1) 
                _fSelectorErr = TRUE;    
        }
        else
            hr = S_OK;

        if (tt == Tokenizer::TT_Hash)
        {
            tt = tok.NextToken();

            if (tok.IsIdentifier(tt))
            {
                szIdent = tok.GetStartToken();
                cSzIdent = tok.GetTokenLength();
                _cstrID.Set(szIdent, cSzIdent);


                // In standard compliant mode we have a different set of allowed selectors than in compatible mode.
                // We mark invalid (with resp to CSS) selectors.
                if (_fIsStrictCSS1 && !tok.IsCSSIdentifier(tt))
                    _fSelectorErr = TRUE;
            }
        }
        else if (tt == Tokenizer::TT_Dot)
        {
            tt = tok.NextToken();

            if (tok.IsIdentifier(tt))
            {
                szIdent = tok.GetStartToken();
                cSzIdent = tok.GetTokenLength();
                _cstrClass.Set(szIdent, cSzIdent);
                _dwStrClassHash = HashStringCiDetectW(szIdent, cSzIdent, 0 /*Hash seed*/);

                // In standard compliant mode we have a different set of allowed selectors than in compatible mode.
                // We mark invalid (with resp to CSS) selectors.
                if (_fIsStrictCSS1 && !tok.IsCSSIdentifier(tt))
                    _fSelectorErr = TRUE;
            }
        }
        else if (tt == Tokenizer::TT_Colon)
        {
            tt = tok.NextToken();

            if (tok.IsKeyword(_T("active")))
                _ePseudoclass = pclassActive;
            else if (tok.IsKeyword(_T("visited")))
                _ePseudoclass = pclassVisited;
            else if (tok.IsKeyword(_T("hover")))
                _ePseudoclass = pclassHover;
            else if (tok.IsKeyword(_T("link")))
                _ePseudoclass = pclassLink;
            else if (tok.IsKeyword(_T("first-letter")))
                _ePseudoElement = pelemFirstLetter;
            else if (tok.IsKeyword(_T("first-line")))
                _ePseudoElement = pelemFirstLine;
            else
            {
                // Unrecognized Pseudoclass/Pseudoelement name!
                _ePseudoElement = pelemUnknown;
            }
        }
        else // unknown token for current selector or end of current selector, bail out.
            break;

        // if we get here then current token is '.',':' or '#'
        if (!tok.IsIdentifier(tt))
        {
            // malformed '.',':' or '#', get outa here.
            if (tt != Tokenizer::TT_Dot &&
                tt != Tokenizer::TT_Colon &&
                tt != Tokenizer::TT_Hash)
                break;
            else
                hr = S_FALSE; // continue with current token.
        }
    }

    return S_OK;
}


//*********************************************************************
//  CStyleSelector::GetSpecificity()
//      This method computes the cascade order specificity from the
//  number of tagnames, IDs, classes, etc. in the selector.
//*********************************************************************
DWORD CStyleSelector::GetSpecificity( void )
{
    DWORD dwRet = 0;

    if ( _eElementType != ETAG_UNKNOWN )
        dwRet += SPECIFICITY_TAG;
    if ( _cstrClass.Length() )
        dwRet += SPECIFICITY_CLASS;
    if ( _cstrID.Length() )
        dwRet += SPECIFICITY_ID;
    switch ( _ePseudoclass )
    {
    case pclassActive:
    case pclassVisited:
    case pclassHover:
        dwRet += SPECIFICITY_PSEUDOCLASS;
        //Intentional fall-through
    case pclassLink:
        dwRet += SPECIFICITY_PSEUDOCLASS;
        break;
    }
    switch ( _ePseudoElement )
    {
    case pelemFirstLetter:
        dwRet += SPECIFICITY_PSEUDOELEMENT;
        //Intentional fall-through
    case pelemFirstLine:
        dwRet += SPECIFICITY_PSEUDOELEMENT;
        break;
    }

    if ( _pParent )
        dwRet += _pParent->GetSpecificity();

    return dwRet;
}


//*********************************************************************
//  CStyleSelector::MatchSimple()
//      This method compares a simple selector with an element.
//*********************************************************************

MtDefine(MStyleSelector, Metrics, "Style Selector Matching");
MtDefine(MStyleSelectorClassCacheMisses, MStyleSelector, "Class Cache Misses");
MtDefine(MStyleSelectorClassMatchAttempts, MStyleSelector, "Class Match Attempts");
MtDefine(MStyleSelectorHashMisses, MStyleSelector, "Hash Misses");

BOOL CStyleSelector::MatchSimple( CElement *pElement, CFormatInfo *pCFI, CStyleClassIDCache *pCIDCache, int iCacheSlot, EPseudoclass *pePseudoclass)
{
    // If that element tag doesn't match what's specified in the selector, then NO match.
    if ( ( _eElementType != ETAG_UNKNOWN ) && ( _eElementType != pElement->TagType() ) || _fSelectorErr)
        return FALSE;

    LPCTSTR pszClass;
    LPCTSTR pszID;

    // if an extended tag, match scope name and tag name
    if ((_eElementType == ETAG_GENERIC))
    {
        // CONSIDER: the _tcsicmp-s below is a potential perf problem. Use atom table for the
        // scope name and tag name to speed this up.
        if(0 != _tcsicmp(pElement->NamespaceHtml(), _Nmsp.GetNamespaceString()))
            // Namespaces don't match
            return FALSE;
        if(0 != _tcsicmp(_T("*"), _cstrTagName) &&                       // not a wild card and
             0 != _tcsicmp(pElement->TagName(), _cstrTagName))           //   tag name does not match
            return FALSE;                                                // then report no match
    }

    // We only need to check when the cache slot is greater than 0
    // This code is required in case of a contextual selector (ie if there is a parent)
    if (iCacheSlot > 0)
    {
        INT nLen = _cstrClass.Length();
        // Only worry about classes on the element if the selector has a class
        if ( nLen )
        {
        
            MtAdd(Mt(MStyleSelectorClassMatchAttempts), 1, 0);
        
            // If we don't know the class of the element, get it now.
            if (!pCIDCache->IsClassSet(iCacheSlot))
            {
                HRESULT hr;

                pszClass = NULL;

                MtAdd(Mt(MStyleSelectorClassCacheMisses), 1, 0);

                hr = pElement->GetStringAt(
                        pElement->FindAAIndex(DISPID_CElement_className, CAttrValue::AA_Attribute),
                        &pszClass);

                if (S_OK != hr && DISP_E_MEMBERNOTFOUND != hr)
                    return FALSE;

                if (pszClass)
                    hr = pCIDCache->PutClass(pszClass, iCacheSlot);
                else
                    hr = pCIDCache->PutNoClass(iCacheSlot);

                if (hr)
                    return FALSE;
            }

            CClassCacheAry* pClassCache = pCIDCache->GetClass(iCacheSlot);

            // pClassCache should never be NULL, if it reaches this point in the code
            Assert(pClassCache != NULL);

            CClassCache *pElem;
            int    i;

            for (i = pClassCache->Size(), pElem = *pClassCache;
                 i > 0;
                 i--, pElem++)
            {
                 if (pElem->_dwHash == _dwStrClassHash)
                 {
                    if (nLen == pElem->_cchClass)
                    {
                        // Case sensitive comparision iff in strict css mode.
                        if (_fIsStrictCSS1 ? 
                              !_tcsncmp ( (LPTSTR)_cstrClass, nLen, pElem->_pszClass, pElem->_cchClass)
                            : !_tcsnicmp ( (LPTSTR)_cstrClass, nLen, pElem->_pszClass, pElem->_cchClass)
                           )
                        {
                                goto CompareIDs;
                        }
#ifdef PERFMETER
                        else
                            MtAdd(Mt(MStyleSelectorHashMisses), 1, 0);
#endif
                    }
                 }
            }

            return FALSE;
        }

    CompareIDs:
        // Only worry about ids on the element if the selector has an id
        if ( _cstrID.Length() )
        {
            pszID = pCIDCache->GetID(iCacheSlot);
            // No match if the selector has an ID but the element doesn't.
            if ( !pszID )
                return FALSE;
            // If we don't know the ID of the element, get it now.
            if (pszID == UNKNOWN_CLASS_OR_ID)
            {
                HRESULT hr;

                hr =  pElement->GetStringAt( 
                        pElement->FindAAIndex( DISPID_CElement_id, CAttrValue::AA_Attribute ),
                        &pszID);

                if (S_OK != hr && DISP_E_MEMBERNOTFOUND != hr)
                    return FALSE;

                pCIDCache->PutID(pszID, iCacheSlot);

                if (!pszID)
                    return FALSE;
            }
            // Case sensitive comparision iff in strict css mode.
            if (_fIsStrictCSS1 ? _tcscmp( _cstrID, pszID ) : _tcsicmp( _cstrID, pszID ))
                return FALSE;
        }
    }

    if ( _ePseudoclass != pclassNone )
    {
        AAINDEX idx;

        if ( pElement->TagType() != ETAG_A )    // NOTE: Eventually, we should allow other hyperlink types here, like form submit buttons or LINKs.
            return FALSE;                       // When we do, change the block below as well.

        if ( pePseudoclass )
        {
            if ( *pePseudoclass == _ePseudoclass )
                return TRUE;
            else
                return FALSE;
        }

        if ( !*(pElement->GetAttrArray()) )
            return FALSE;

                                                // The following is the block that has to change:
        idx = pElement->FindAAIndex( DISPID_CAnchorElement_href, CAttrValue::AA_Attribute );
        if ( idx == AA_IDX_UNKNOWN )
            return FALSE;   // No HREF - must be a target anchor, not a source anchor.

        CAnchorElement *pAElem = DYNCAST( CAnchorElement, pElement );
        EPseudoclass psc = pAElem->IsVisited() ? pclassVisited : pclassLink;

        // Hover and Active are applied in addition to either visited or link
        // Hover is ignored if anchor is active.
        if (    _ePseudoclass == psc
            ||  (pAElem->IsActive()  && _ePseudoclass == pclassActive)
            ||  (pAElem->IsHovered() && _ePseudoclass == pclassHover) )
            return TRUE;
        return FALSE;
    }

    if (pCFI)
    {
        if (_ePseudoElement == pelemUnknown)
        {
            return FALSE;
        }

        // See comment in formats.cxx function CElement::ApplyDefaultFormat for this.
        if (    pCFI->_fFirstLetterOnly
            && _ePseudoElement != pelemFirstLetter
           )
        {
            pCFI->SetMatchedBy(pelemNone);
            return FALSE;
        }

        if (   pCFI->_fFirstLineOnly
            && _ePseudoElement != pelemFirstLine
           )
        {
            pCFI->SetMatchedBy(pelemNone);
            return FALSE;
        }
        
        pCFI->SetMatchedBy(_ePseudoElement);
    }
    else
    {
        return (_ePseudoElement == pelemNone);
    }

    return TRUE;
}

//*********************************************************************
//  CStyleSelector::Match()
//      This method compares a contextual selector with an element context.
//*********************************************************************
BOOL CStyleSelector::Match( CStyleInfo * pStyleInfo, ApplyPassType passType, CStyleClassIDCache *pCIDCache, EPseudoclass *pePseudoclass /*=NULL*/ )
{
    CStyleSelector *pCurrSelector = this;
    int iCacheSlot = 0;
    CTreeNode *pNode = pStyleInfo->_pNodeContext;
    CFormatInfo *pCFI = (passType == APPLY_Behavior) ? NULL : (CFormatInfo*)pStyleInfo;
    EPseudoElement epeSave = pelemNone;
    BOOL fIsComplexRule = FALSE;
    
    // Cache slot 0 stores the original elem's class/id
    if ( !pCurrSelector->MatchSimple( pNode->Element(), pCFI, pCIDCache, iCacheSlot, pePseudoclass) )
        return FALSE;

    if (pCFI)
    {
        epeSave = pCFI->GetMatchedBy();
        pCFI->SetMatchedBy(pelemNone);
    }
    
    pCurrSelector = pCurrSelector->_pParent;
    pNode = pNode->Parent();
    ++iCacheSlot;

    fIsComplexRule = !!pCurrSelector;
    
    // We matched the innermost part of the contextual selector.  Now walk up
    // the remainder of the contextual selector (if it exists), testing whether our
    // element's containers satisfy the remainder of the contextual selector.  MatchSimple()
    // stores our containers' class/id in cache according to their containment level.
    while ( pCurrSelector && pNode )
    {
        if ( pCurrSelector->MatchSimple( pNode->Element(), pCFI, pCIDCache, iCacheSlot, pePseudoclass) )
            pCurrSelector = pCurrSelector->_pParent;
        // Rules like:
        //
        // FORM DIV:first-letter B { color : red }
        //
        // are explicitly disallowed by CSS. Hence the first MatchSimple will set
        // the epe to none and then the one in the loop will set it to eFirstLetter.
        // If we see this happen then we should just return a rule mis-match, since we
        // are supposed to ignore them.
        if (pCFI && pCFI->GetMatchedBy() != pelemNone)
                return FALSE;
        
        pNode = pNode->Parent();
        
        ++iCacheSlot;
    }

    if (pCFI)
    {
        // Restore the psuedo element which we found during match of the first
        // selector. The parent selectors are uninteresting and are explicitly
        // disallowed by CSS
        pCFI->SetMatchedBy(epeSave);
    }
    
    if ( !pCurrSelector )
    {
        if (fIsComplexRule && pCFI)
            pCFI->NoStealing();
        return TRUE;
    }
    return FALSE;
}

HRESULT CStyleSelector::GetString( CStr *pResult )
{
    Assert( pResult );

    if ( _pParent )     // This buys us the context selectors.
        _pParent->GetString( pResult );

    switch ( _eElementType )
    {
    case ETAG_UNKNOWN:  // Wildcard - don't write tag name.
        break;
    case ETAG_NULL:     // Unknown tag name - write it out as "UNKNOWN".
        pResult->Append( _T("UNKNOWN") );
        break;
    case ETAG_GENERIC:     // Peer
        if(!_Nmsp.IsEmpty())
        {
            pResult->Append(_Nmsp.GetNamespaceString());
            pResult->Append(_T("\\:"));
        }
        pResult->Append(_cstrTagName);
        break;
    default:
        pResult->Append( NameFromEtag( _eElementType ) );
        break;
    }

    if ( _cstrClass.Length() )
    {
        pResult->Append( _T(".") );
        pResult->Append( _cstrClass );
    }
    if ( _cstrID.Length() )
    {
        pResult->Append( _T("#") );
        pResult->Append( _cstrID );
    }
    switch ( _ePseudoclass )
    {
    case pclassActive:
        pResult->Append( _T(":active") );
        break;
    case pclassVisited:
        pResult->Append( _T(":visited") );
        break;
    case pclassLink:
        pResult->Append( _T(":link") );
        break;
    case pclassHover:
        pResult->Append( _T(":hover") );
        break;
#ifdef DEBUG
    default:
        Assertsz(0, "Unknown pseudoclass");
#endif
    }
    switch ( _ePseudoElement )
    {
    case pelemFirstLetter:
        pResult->Append( _T(":first-letter") );
        break;
    case pelemFirstLine:
        pResult->Append( _T(":first-line") );
        break;
    case pelemUnknown:
        pResult->Append( _T(":unknown") );
        break;
#ifdef DEBUG
    default:
        Assertsz(0, "Unknown pseudoelement");
#endif
    }
    pResult->Append( _T(" ") );
    return S_OK;
}


//---------------------------------------------------------------------
//  Class Declaration:  CStyleRule
//      This class represents a single rule in the stylesheet - a pairing
//  of a selector (the situation) and a style (the collection of properties
//  affected in that situation).
//---------------------------------------------------------------------

//*********************************************************************
//  CStyleRule::CStyleRule()
//*********************************************************************
CStyleRule::CStyleRule( CStyleSelector *pSelector )
{
    _dwSpecificity = 0;
    _pSelector = NULL;
    if ( pSelector )
        SetSelector( pSelector );
    _paaStyleProperties = NULL;
    _sidRule = 0;
    _dwMedia = 0;
    _dwAtMediaTypeFlags = 0;
#if DBG == 1    
    _dwPreSignature  = PRESIGNATURE;
    _dwPostSignature = POSTSIGNATURE;
#endif    
}


//*********************************************************************
//  CStyleRule::Clone
//*********************************************************************
HRESULT
CStyleRule::Clone(CStyleRule **ppClone)
{
    HRESULT hr = S_OK;

    Assert( ppClone );

    //
    // note _pSelector is shared since it is read only!
    // OM put_selectorText returns E_NOIMPL at this point!
    // 
    *ppClone = new CStyleRule(_pSelector); // this will setup _dwSpecificity 
    if (!*ppClone)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (_paaStyleProperties)
    {
        hr = _paaStyleProperties->Clone( &((*ppClone)->_paaStyleProperties) );
        if (hr)
            goto Cleanup;
    }

    (*ppClone)->_sidRule = _sidRule;
    (*ppClone)->_dwMedia = _dwMedia;
    (*ppClone)->_dwAtMediaTypeFlags = _dwAtMediaTypeFlags;

Cleanup:
    if (hr && *ppClone)
    {
        delete (*ppClone);
        (*ppClone) = NULL;
    }
    RRETURN(hr);
}


//*********************************************************************
//  CStyleRule::~CStyleRule()
//*********************************************************************
CStyleRule::~CStyleRule()
{
    // Make sure we don't die while still attached to a selector
    Assert( (_pSelector == NULL) || (_pSelector == (CStyleSelector*)(LONG_PTR)(-1)) );
}

//*********************************************************************
//  CStyleRule::Free()
//      This method deletes all members of CStyleRule.
//*********************************************************************
void CStyleRule::Free( void )
{
    if ( _pSelector )
    {
        _pSelector->Release();
        _pSelector = NULL;
    }

    if ( _paaStyleProperties )
    {
        delete( _paaStyleProperties );
        _paaStyleProperties  = NULL;
    }
#ifdef DBG
    _pSelector = (CStyleSelector *)(LONG_PTR)(-1);
    _paaStyleProperties = (CAttrArray *)(LONG_PTR)(-1);
#endif
}

//*********************************************************************
//  CStyleRule::SetSelector()
//      This method sets the selector used for this rule.  Note that
//  this method should only be called once on any given CStyleRule object.
//*********************************************************************
void CStyleRule::SetSelector( CStyleSelector *pSelector )
{
    Assert( "Selector is already set for this rule!" && !_pSelector );
    Assert( "Can't set a NULL selector!" && pSelector );

    _pSelector = pSelector;
    _dwSpecificity = pSelector->GetSpecificity();
    _pSelector->AddRef();
}


ELEMENT_TAG  CStyleRule::GetElementTag() const
{
    Assert(_pSelector); 
    return _pSelector->_eElementType; 
}



HRESULT CStyleRule::GetString( CBase *pBase, CStr *pResult )
{
    HRESULT hr;
    BSTR bstr;

    Assert( pResult );

    if ( !_pSelector )
        return E_FAIL;
    _pSelector->GetString( pResult );

    pResult->Append( _T("{\r\n\t") );

    hr = WriteStyleToBSTR( pBase, _paaStyleProperties, &bstr, FALSE );
    if ( hr != S_OK )
        goto Cleanup;

    if ( bstr )
    {
        if ( *bstr )
            pResult->Append( bstr );
        FormsFreeString( bstr );
    }

    pResult->Append( _T("\r\n}\r\n") );
Cleanup:
    RRETURN(hr);
}


HRESULT CStyleRule::GetMediaString(DWORD dwCurMedia, CBufferedStr *pstrMediaString)
{
    HRESULT     hr = S_OK;
    int         i;
    BOOL        fFirst = TRUE;

    Assert(dwCurMedia != (DWORD)MEDIA_NotSet);

    dwCurMedia = dwCurMedia & (DWORD)MEDIA_Bits;

    if(dwCurMedia == (DWORD)MEDIA_All)
    {
        AssertSz(cssMediaTypeTable[0]._mediaType == MEDIA_All, "MEDIA_ALL must me element 0 in the array");
        hr = THR(pstrMediaString->Set(cssMediaTypeTable[0]._szName));
        goto Cleanup;
    }

    for(i = 1; i < ARRAY_SIZE(cssMediaTypeTable); i++)
    {
        if(cssMediaTypeTable[i]._mediaType & dwCurMedia)
        {
            if(fFirst)
            {
                pstrMediaString->Set(NULL);
                fFirst = FALSE;
            }
            else
            { 
                hr = THR(pstrMediaString->QuickAppend(_T(", ")));
            }
            if(hr)
                break;
            hr = THR(pstrMediaString->QuickAppend(cssMediaTypeTable[i]._szName));
            if(hr)
                break;
        }
    }

Cleanup:
    RRETURN(hr);
}


//*********************************************************************
//  CStyleRule::GetNamespace
//      Returns the namespace name that this rule belongs, NULL if none
//*********************************************************************
const CNamespace *
CStyleRule::GetNamespace() const
{
    Assert(_pSelector); 
    return _pSelector->GetNamespace();
}



#if DBG == 1
BOOL 
CStyleRule::DbgIsValid()
{
    //
    // _sidRule should only have rule information
    // 
    unsigned int nSheet = _sidRule.GetSheet();
    if (nSheet)
    {
        Assert("CStyleRule -- _sidRule should only contain rule info" && FALSE);
        return FALSE;
    }
    return TRUE;
}


VOID  CStyleRule::DumpRuleString(CBase *pBase)
{
    CStr        strRule;
    CHAR        szBuffer[2000];

    GetString(pBase, &strRule);
    WideCharToMultiByte(CP_ACP, 0, strRule, -1, szBuffer, sizeof(szBuffer), NULL, NULL);

    TraceTag((tagStyleSheet, "  StyleRule RuleID: %08lX  TagName: %s  Rule: %s", 
            (DWORD) GetRuleID(), GetSelector()->_cstrTagName, szBuffer));
}

#endif

//+---------------------------------------------------------------------------
//
// CStyleRuleArray.
//
//----------------------------------------------------------------------------
//*********************************************************************
//  CStyleRuleArray::Free()
//      This method deletes all members of CStyleRuleArray.
//*********************************************************************
void CStyleRuleArray::Free( )
{

    // We do not own the rules -- need to release them
    
    DeleteAll();
}

//*********************************************************************
//  CStyleRuleArray::InsertStyleRule()
//      This method adds a new rule to the rule array, putting it in
//  order in the stylesheet.  Note that the rules are kept in order of
//  DESCENDING preference (most important rules first) - this is due to
//  the mechanics of our Apply functions.
//*********************************************************************
HRESULT CStyleRuleArray::InsertStyleRule( CStyleRule *pNewRule, BOOL fDefeatPrevious, int *piIndex )
{
    Assert( "Style Rule is NULL!" && pNewRule );
    Assert( "Style Selector is NULL!" && pNewRule->GetSelector() );
    Assert( "Style ID isn't set!" && (pNewRule->GetRuleID() != 0) );

    if (piIndex)
        *piIndex = Size();

    return Append( pNewRule );
}


//*********************************************************************
//  CStyleRuleArray::InsertStyleRule()
//      This method delete a rule from the rule array -- it does not
//      manage the life time of the removed rule
//*********************************************************************
HRESULT 
CStyleRuleArray::RemoveStyleRule( CStyleRule *pOldRule, int *piIndex)
{
    int z;
    CStyleRule *pRule;

    Assert( "Style Rule is NULL!" && pOldRule );
    Assert( "Style Selector is NULL!" && pOldRule->GetSelector() );

    if (piIndex)
        *piIndex = -1;
        
    for ( z = 0; z < Size(); ++z)
    {
        pRule = Item(z);
        if (pRule == pOldRule)
        {
            if (piIndex)
                *piIndex = z;
                
            Delete(z);
            return S_OK;
        }
    }
    
    return E_FAIL;
}




//---------------------------------------------------------------------
//  Class Declaration:  CStyleSheetCtx
//---------------------------------------------------------------------


//---------------------------------------------------------------------
//  Class Declaration:  CStyleSheet
//      This class represents a complete stylesheet.  It (will) hold a
//  list of ptrs to style rules, sorted by source order within the sheet.
//  Storage for the rules is managed by the stylesheet's containing array
//  (a CStyleSheetArray), which sorts them by tag and specificity
//  for fast application to the data.
//---------------------------------------------------------------------

const CStyleSheet::CLASSDESC CStyleSheet::s_classdesc =
{
    {
        &CLSID_HTMLStyleSheet,               // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        NULL,                                // _apClsidPages
#endif // NO_PROPERTY_PAGE
        NULL,                                // _pcpi
        0,                                   // _dwFlags
        &IID_IHTMLStyleSheet,                // _piidDispinterface
        &s_apHdlDescs                        // _apHdlDesc
    },
    (void *)s_apfnIHTMLStyleSheet                    // _apfnTearOff
};

//*********************************************************************
//  CStyleSheet::CStyleSheet()
//  You probably don't want to be calling this yourself to create style
//  sheet objects -- use CStyleSheetArray::CreateNewStyleSheet().
//*********************************************************************
CStyleSheet::CStyleSheet(
    CElement *pParentElem,
    CStyleSheetArray * const pSSAContainer
    )
    :
    _pSSSheet(NULL),
    _pParentElement(pParentElem),
    _pParentStyleSheet(NULL),
    _pImportedStyleSheets(NULL),
    _pSSAContainer(pSSAContainer),
    _pPageRules(NULL),
    _sidSheet(0),
    _fDisabled(FALSE),
    _fComplete(FALSE),
    _fParser(FALSE),
    _fReconstruct(FALSE),
    _pCssCtx(NULL),
    _nExpectedImports(0),
    _nCompletedImports(0),
    _eParsingStatus(CSSPARSESTATUS_NOTSTARTED),
    _dwStyleCookie(0),
    _dwScriptCookie(0),
    _pOMRulesArray(NULL)
{
    Assert( "Stylesheet must have container!" && _pSSAContainer );
    // Stylesheet starts internally w/ ref count of 1, and subrefs its parent.
    // This maintains consistency with the addref/release implementations.
    if (_pParentElement)
        _pParentElement->SubAddRef();
   
    WHEN_DBG( _pts = GetThreadState() );
}


CStyleSheet::~CStyleSheet()
{
    // This will free the Imports because ins ref counts are always one
    //  (it ref counts its parent for other purposes
    if(_pImportedStyleSheets)
        _pImportedStyleSheets->CBase::PrivateRelease(); 

    // This is just in case Passviate is not called
    // before final destruction 
    if (_pSSSheet)
    {
        Assert( FALSE && "CStyleSheet::Passivate should have been called" );
        CSharedStyleSheet *pSSTmp = _pSSSheet;
        _pSSSheet = NULL;
        pSSTmp->Release();
    }
}




//*********************************************************************
//  CStyleSheet::AttachLate()
//
//      S_OK     : successfully attached. 
//
//  Switch to a different Shared Style Sheet.  However we might choose to
//  also reconstruct all the OM related stuff and imported style sheets. 
//
//  fReconstruct means we need to reconstruct.
//  fIsReplacement  means if we do choose to reconstruct, do we need to
//  recreate all the OM related stuffs (in the we don't have any OM stuffs)
//  or simply repopulate exisiting OM related stuffs with the new SSS
//
//*********************************************************************
HRESULT
CStyleSheet::AttachLate(CSharedStyleSheet *pSSS, BOOL fReconstruct, BOOL fIsReplacement)
{
    HRESULT  hr = S_OK;
    Assert( pSSS );

    TraceTag( (tagSharedStyleSheet, "AttachLate - have [%p], attach to [%p]", _pSSSheet, pSSS) );
    if (_pSSSheet == pSSS)
        goto Cleanup;
    
    DisconnectSharedStyleSheet();
    ConnectSharedStyleSheet(pSSS);

    if (fReconstruct)
    {
        hr = THR( ReconstructStyleSheet( GetSSS(), /*fReplace*/fIsReplacement) );
        if (hr)
            goto Cleanup;
    }
    
    
Cleanup:
    RRETURN(hr);
}


//*********************************************************************
//  CStyleSheet::AttachByLastMod()
//
//      S_OK     : successfully attached. no need to download.
//      S_FALSE  :  cannot attach to existing ones
//
// NOTENOTE::::::::::::::::::This function is designed for the following usage:
//
// AttachByLastMod(pSheet, pSSSM, NULL, &pSSSOut, FALSE);
// do someting...
// AttachByLastMod(pSheet, pSSSM, pSSSOut, NULL, TRUE);
//
//*********************************************************************
HRESULT  
CStyleSheet::AttachByLastMod(CSharedStyleSheetsManager *pSSSM, 
                        CSharedStyleSheet *pSSSIn /* = NULL */, CSharedStyleSheet **pSSSOut /*=NULL*/,
                        BOOL fDoAttach /* = TRUE */)
{
    HRESULT  hr = E_FAIL;
    Assert( GetSSS() );
    Assert( pSSSM );

    TraceTag( (tagSharedStyleSheet, "AttachByLastMod - have [%p] with [%p] doattach [%d]", GetSSS(), pSSSIn, fDoAttach) );
    CSharedStyleSheet *pSSS = GetSSS();

    if (pSSSOut)
    {
        *pSSSOut = NULL;
    }

    if (!pSSSIn 
        && _pParentElement 
        && _pParentElement->GetMarkup() 
        && _pParentElement->GetMarkup()->GetWindowedMarkupContext()->GetDwnDoc()
        )     // if the element is in ether, don't attach late
    {
        CSharedStyleSheetCtx  ctxSSS;
        Assert( _pParentElement );

        ctxSSS._dwMedia  = MEDIATYPE(pSSS->_eMediaType);
        ctxSSS._fExpando = !!pSSS->_fExpando;
        ctxSSS._fXMLGeneric = !!pSSS->_fXMLGeneric;
        ctxSSS._cp       = pSSS->_cp;
        ctxSSS._szAbsUrl = pSSS->_achAbsoluteHref;
        ctxSSS._pft      = &(pSSS->_ft);                    // this should have been populated
        WHEN_DBG( ctxSSS._pSSInDbg   = pSSS );
        ctxSSS._dwBindf  = pSSS->_dwBindf;
        ctxSSS._dwFlags  = SSS_IGNOREREFRESH | SSS_IGNORESECUREURLVALIDATION;
        ctxSSS._pParentElement = _pParentElement;
        ctxSSS._fIsStrictCSS1 = !!(_pParentElement->GetMarkupPtr()->IsStrictCSS1Document());

        hr = THR( pSSSM->FindSharedStyleSheet( &pSSSIn, &ctxSSS) );  // addRefed
        if (!SUCCEEDED(hr)) 
            goto Cleanup;
        
        Assert( pSSSIn != pSSS );
        Assert( hr == S_FALSE || (pSSSIn && pSSSIn->_fComplete) );
        Assert( hr == S_FALSE || (pSSSIn && !pSSSIn->_fParsing) );
    }
    else
    {
        // we already have pSSSIn
        hr = S_OK;
    }

    if (S_OK == hr)
    {
        Assert( pSSSIn );

        if (pSSSOut)
        {
            *pSSSOut = pSSSIn;
        }

        if (fDoAttach)
        {
            hr = S_FALSE;
            Assert (pSSSIn != GetSSS());
            Assert( !GetSSS()->_fComplete );
            Assert( !GetSSS()->_fParsing );
            Assert( pSSSIn->_fComplete );
            Assert( !pSSSIn->_fParsing );
            Assert( !pSSSIn->_fModified );
            Assert( pSSSIn->_pManager );
            WHEN_DBG( Assert( GetSSS()->_lReserveCount <= 1 ) );

            //
            // Do not reset the _pManager of GetSSS() to NULL
            // it could have been shared!
            //
            Assert( _pImportedStyleSheets == 0);
            Assert( !_pPageRules );
            Assert( !_pOMRulesArray );
            Assert( _apFontFaces.Size() == 0 );
            Assert( _apOMRules.Size() == 0 );
            hr = THR(AttachLate(pSSSIn, /*fReconstruct*/ TRUE, /*fIsReplacement*/ FALSE));
            WHEN_DBG( InterlockedDecrement( &(pSSSIn->_lReserveCount) ) );
            WHEN_DBG( Assert( GetSSS()->_lReserveCount == 0 ) );
            pSSSIn->Release(); // pSSSIn has been AddRefed, offset the one by FindSharedStyleSheet
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//*********************************************************************
//  CStyleSheet::AttachEarly()
//
//      S_OK     : successfully attached. no need to download.
//      S_FALSE  :  cannot attach to existing ones or existing one not complete
//*********************************************************************
HRESULT  
CStyleSheet::AttachEarly(CSharedStyleSheetsManager *pSSSM, 
                         CSharedStyleSheetCtx *pCtx, CSharedStyleSheet **ppSSSOut)
{
    HRESULT  hr = S_FALSE;
    Assert( _pSSSheet == NULL );
    Assert( pSSSM );
    Assert( pCtx );
    Assert( ppSSSOut );

    *ppSSSOut = NULL;

    if (!pCtx->_pParentElement || !pCtx->_pParentElement->GetMarkup())      // if the element is in the ether, don't attach
        goto Cleanup;
        
    TraceTag( (tagSharedStyleSheet, "AttachEarly") );
    hr = THR( pSSSM->FindSharedStyleSheet( ppSSSOut, pCtx) );
    if (!SUCCEEDED(hr)) 
        goto Cleanup;

    if (hr == S_OK)
    {
        TraceTag( (tagSharedStyleSheet, "AttachEarly - got [%p]", *ppSSSOut) );
        Assert( *ppSSSOut );
        ConnectSharedStyleSheet( *ppSSSOut );
        (*ppSSSOut)->Release(); // to offset the AddRef by FindSharedStyleSheet
        WHEN_DBG( InterlockedDecrement( &((*ppSSSOut)->_lReserveCount) ) );
        WHEN_DBG( Assert( (*ppSSSOut)->_lReserveCount == 0 ) );

        Assert( _pImportedStyleSheets == 0);
        Assert( !_pPageRules );
        Assert( !_pOMRulesArray );
        Assert( _apFontFaces.Size() == 0 );
        Assert( _apOMRules.Size() == 0 );
        hr = THR( ReconstructStyleSheet( GetSSS(), /*fReplace*/FALSE ) );  
        Assert( SUCCEEDED(hr) );
        if (hr == S_OK)
        {
            _eParsingStatus = CSSPARSESTATUS_DONE;
            _fComplete     = TRUE;
        }
        //
        // S_FALSE means the share one is not complete
        //
    }
    //
    // S_FALSE means we cannot find one
    //

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//*********************************************************************
//  CStyleSheet::Create()
//
// This is the factory method for creating a new style sheet. It can
// be called to do the following:
//      1. simply create an empty CStyleSheet with an empty 
//         CSharedStyleSheet
//      2. create an empty CStyleSheet and a CSharedStyleSheet, 
//         prepare CSharedStyleSheet to be shared.
//      3. create an empty CStyleSheet, try to find an existing 
//         CSharedStyleSheet. connect the empty CStyleSheet with 
//         existing CSharedStyleSheet
//
// If the exisiting CSharedStyleSheet has been downloaded and complete, we
// can simply reconstruct CStyleSheet from exisiting CSharedStyleSheet.
// Otherwise a download is needed.
//
// It any case, we might end up in two different situation:
//      S_OK     : no need to download...
//      S_FALSE  : need to download...
//*********************************************************************
HRESULT 
CStyleSheet::Create(
        CStyleSheetCtx *pCtx, 
        CStyleSheet **ppStyleSheet, 
        CStyleSheetArray * const pSSAContainer 
        )
{
    Assert( !pCtx || pCtx->_pParentElement );
    Assert( !pCtx || (pCtx->_pParentStyleSheet == NULL || pCtx->_dwCtxFlag & STYLESHEETCTX_IMPORT) );
    Assert( !pCtx || (pCtx->_pSSS == NULL) );
    
    HRESULT  hr = S_OK;
    BOOL     fNeedDownload  = TRUE;

    DWORD   dwMedia  = MEDIA_All;   
    TCHAR   *pAbsUrl = NULL;
    BOOL    fExpando = TRUE;
    CODEPAGE    cp   = CP_UNDEFINED;
    BOOL fXMLGeneric = FALSE;
    BOOL fIsStrictCSS1 = FALSE;
    CDoc    *pDoc    = NULL;
    CDwnDoc *pDwnDoc = NULL;
    CMarkup *pMarkup  = NULL;

    if (!ppStyleSheet)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    Assert(pSSAContainer && "CStyleSheet cannot live without a container!");

    *ppStyleSheet = new CStyleSheet((pCtx ? pCtx->_pParentElement : NULL), pSSAContainer);
    if (!*ppStyleSheet)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    {
        //
        // give it a temporary sheet ID so that we know nesting level when we 
        // reconstruct. This will be fixed up when it is added to the collection anyway.
        //
        unsigned long uLevel = pSSAContainer->_Level;
        if (uLevel == 0)    uLevel = 1;
        if ( uLevel > MAX_IMPORT_NESTING )
        {
            Assert(FALSE && "Newly created CStyleSheet Exceeds Max Nesting Levels");
            hr = E_FAIL;
            goto Cleanup;
        }
        (*ppStyleSheet)->_sidSheet.SetLevel(uLevel, 1);
    }

    if (pCtx && pCtx->_pParentElement)
    {
        pMarkup = pCtx->_pParentElement->GetMarkup();
        if (!pMarkup)
        {
            pMarkup = pCtx->_pParentElement->GetWindowedMarkupContext();
        }
        if (pMarkup)
        {
            pDwnDoc = pMarkup->GetWindowedMarkupContext()->GetDwnDoc();
        }
    }

    if (pCtx)
    {
        // obtian the media setting
        if (pCtx->_dwCtxFlag & STYLESHEETCTX_IMPORT)
        {
            Assert(pCtx->_pParentStyleSheet);
            // Fix up new SS to reflect the fact that it's imported (give it parent, set its import href)
            (*ppStyleSheet)->_pParentStyleSheet = pCtx->_pParentStyleSheet;
            (*ppStyleSheet)->_cstrImportHref.Set(pCtx->_szUrl);
            dwMedia  = pCtx->_pParentStyleSheet->GetMediaTypeValue();
            if (pCtx->_szUrl && pCtx->_szUrl[0])
            {
                if (pCtx->_pParentStyleSheet->GetAbsoluteHref())
                {
                    hr = ExpandUrlWithBaseUrl(pCtx->_pParentStyleSheet->GetAbsoluteHref(),
                                              pCtx->_szUrl,
                                              &pAbsUrl);
                    if (hr)
                        goto Cleanup;
                }
                else
                {
                    MemAllocString(Mt(CStyleSheet_CreateNewStyleSheet), pCtx->_szUrl, &pAbsUrl);
                    if (!pAbsUrl)
                    {
                        hr = E_OUTOFMEMORY;
                        goto Cleanup;
                    }
                }
            }
            else
            {
                pAbsUrl = NULL;
            }
            
            fExpando = pCtx->_pParentStyleSheet->GetSSS()->_fExpando;
            cp = pCtx->_pParentStyleSheet->GetSSS()->_cp;
            fXMLGeneric = pCtx->_pParentStyleSheet->GetSSS()->_fXMLGeneric;
            fIsStrictCSS1 = pCtx->_pParentStyleSheet->GetSSS()->_fIsStrictCSS1;
            pDoc  = pCtx->_pParentStyleSheet->GetDocument();
        } // end if -- import 
        else
        {            
            Assert( !pCtx->_pParentStyleSheet );
            Assert( pCtx->_pParentElement );

            LPCTSTR pcszMedia = NULL;
            TCHAR   cBuf[pdlUrlLen];

            pDoc  = pCtx->_pParentElement->Doc();
            Assert(pDoc);
            switch (pCtx->_pParentElement->Tag())
            {
            case  ETAG_LINK:
                    {
                        CLinkElement  *pLink = DYNCAST(CLinkElement, pCtx->_pParentElement);
                        pCtx->_szUrl = pLink->GetAAhref();
                        Assert(pMarkup);
                        hr = CMarkup::ExpandUrl(pMarkup, pCtx->_szUrl, ARRAY_SIZE(cBuf), cBuf, pCtx->_pParentElement);
                        if (hr)
                            goto Cleanup;

                        MemAllocString(Mt(CStyleSheet_CreateNewStyleSheet), cBuf, &pAbsUrl);
                        if (pAbsUrl == NULL)
                        {
                            hr = E_OUTOFMEMORY;
                            goto Cleanup;
                        }
                        
                        pcszMedia    = pLink->GetAAmedia();
                    }
                    break;
                    
            case  ETAG_STYLE:
                    {
                        CStyleElement *pStyle = DYNCAST(CStyleElement, pCtx->_pParentElement);
                        Assert(pMarkup);
                        hr = CMarkup::ExpandUrl(pMarkup, _T(""), ARRAY_SIZE(cBuf), cBuf, NULL);
                        if (hr)
                            goto Cleanup;

                        MemAllocString(Mt(CStyleSheet_CreateNewStyleSheet), cBuf, &pAbsUrl);
                        if (pAbsUrl == NULL)
                        {
                            hr = E_OUTOFMEMORY;
                            goto Cleanup;
                        }

                        pcszMedia    = pStyle->GetAAmedia();
                    }
                    break;
                    
            }

            if (NULL != pcszMedia) 
            {
                dwMedia  = TranslateMediaTypeString(pcszMedia);
            }

            Assert(pMarkup);
            fExpando = pMarkup->_fExpando;
            cp = pMarkup->GetCodePage();
            fXMLGeneric = pMarkup->IsXML();
            fIsStrictCSS1 = pMarkup->IsStrictCSS1Document();
        }// end else - Link/Style element
        
        if (pCtx->_dwCtxFlag & STYLESHEETCTX_REUSE)
        {
            if (pDoc && pMarkup)        // we don't want to try the reuse route if the element is in the ether
            {
                CSharedStyleSheetsManager *pSSSM = pDoc->GetSharedStyleSheets();
                CSharedStyleSheetCtx   ctxSSS;

                Assert(pCtx->_pParentElement);
                if (pDwnDoc)        // we cannot AttachEarly if there is no pDwnDoc available.
                {
                    ctxSSS._pParentElement = pCtx->_pParentElement;
                    ctxSSS._dwBindf = pDwnDoc->GetBindf();
                    ctxSSS._dwRefresh = pDwnDoc->GetRefresh();
                    ctxSSS._dwMedia  = dwMedia;
                    ctxSSS._fExpando = fExpando;
                    ctxSSS._fXMLGeneric = fXMLGeneric;
                    ctxSSS._cp       = cp;
                    ctxSSS._szAbsUrl = pAbsUrl;
                    ctxSSS._dwFlags = SSS_IGNORECOMPLETION | SSS_IGNORELASTMOD;
                    ctxSSS._fIsStrictCSS1 = fIsStrictCSS1;

                    Assert(pSSSM);
                    hr = THR( (*ppStyleSheet)->AttachEarly(pSSSM, &ctxSSS, &(pCtx->_pSSS)) );
                    if (!SUCCEEDED(hr)) 
                        goto Cleanup;

                    if (hr == S_OK)
                    {
                        fNeedDownload = FALSE;
                    }
                    
                    // S_FALSE: either we don't have one or we have one but cannot construct
                    if (pCtx->_pSSS) 
                    {
                        // We are done -- we might still need to download though...
                        goto Cleanup;
                    }
                    //
                    // FALL THROUGH
                    // 
                }
                //
                // FALL THROUGH
                //
            }
        } // end if reuse
    }// end if if(pCtx)

    //
    // Create CSharedStyleSheet from scratch
    //
    Assert(fNeedDownload);
    Assert(!pCtx || !pCtx->_pSSS);
    
    CSharedStyleSheet *pNewSSS;
    hr = THR( CSharedStyleSheet::Create( &pNewSSS ) );
    if (hr)
        goto Cleanup;

    Assert( *ppStyleSheet );
    (*ppStyleSheet)->ConnectSharedStyleSheet( pNewSSS );
    pNewSSS->Release();     // offset the addRef inside ConnectSharedStyleSheet;

    if (pCtx)
    {
        //
        // IF this stylesheet is created without a context, which means
        // we are in user style sheet or host style sheet cases, we
        // have problems here since all the settings here are
        // markup dependent while in the above cases, they have
        // to be markup independent.  
        // (zhenbinx)
        //
        (*ppStyleSheet)->GetSSS()->_fExpando = fExpando;
        (*ppStyleSheet)->GetSSS()->_fXMLGeneric = fXMLGeneric;
        (*ppStyleSheet)->GetSSS()->_fIsStrictCSS1 = fIsStrictCSS1;
        (*ppStyleSheet)->GetSSS()->_cp  = cp;
        
        hr = THR( (*ppStyleSheet)->SetMediaType( dwMedia, FALSE ) );
        if (hr)
            goto Cleanup;
        (*ppStyleSheet)->SetAbsoluteHref(pAbsUrl);
        pAbsUrl = NULL;

        if (pCtx->_dwCtxFlag & STYLESHEETCTX_SHAREABLE)
        {
            if (pDoc && pMarkup)    // we don't want to share if the element is in ether
            {
                //
                // Note:  This is assuming that the a download will be initiated after 
                // the CStyleSheet is created.  This can expedite in page style sheets
                // sharing. However, this seems not necessary since we probably will
                // not have style sheets shareable in the same page.
                // However we need to always assign some value to _dwRefresh and _dwBindf.
                // They should be modified after HEADERS callbackup anyways...
                //
                Assert( pCtx->_pParentElement );
                Assert( pCtx->_pParentElement->HasMarkupPtr() );
                if (pDwnDoc)
                {
                    (*ppStyleSheet)->GetSSS()->_dwRefresh = pDwnDoc->GetRefresh();
                    (*ppStyleSheet)->GetSSS()->_dwBindf   = pDwnDoc->GetBindf();
                    // make this SS part of the shared collection -- this will also make sure
                    // to set up CSharedStyleSheet::_pManager
                    pDoc->GetSharedStyleSheets()->AddSharedStyleSheet((*ppStyleSheet)->GetSSS());
                }
            }
        }
        Assert((*ppStyleSheet)->_pSSSheet);
    }

Cleanup:
    if (!SUCCEEDED(hr))
    {
        if (*ppStyleSheet)
        {
            (*ppStyleSheet)->Passivate();
            (*ppStyleSheet)->Release();
            (*ppStyleSheet) = NULL;
        }
        // delete resoruces 
    } 
    else if (fNeedDownload)
    {
        hr = S_FALSE;
    }
    delete pAbsUrl;
    RRETURN1(hr, S_FALSE);
}



//*********************************************************************
//  CStyleSheet::ReconstructStyleSheet()
// Reconstruct a CStyleSheet from an CSharedStyleSheet
// This should only be called in two scenario:
// a.  we have an empty SSS, and need to recreate pSSSheet from existing SSS
//     this is mostly used on creation case when we can reuse existing SSS.
// b.  we have an SSS, and need to replace current SSS with existing SSS, 
//    and reconstruct pSSSheet.  Note in this case, SSS should have the same
//    structure as existing SSS. This is mostly used in copy-on-write case
// 
//*********************************************************************
HRESULT
CStyleSheet::ReconstructStyleSheet(CSharedStyleSheet *pSSSheet, BOOL fReplace)
{
    HRESULT     hr = S_OK;

    Assert( pSSSheet );

    if (!pSSSheet->_fComplete)
    {
        TraceTag( (tagSharedStyleSheet, "Reconstruct style sheet [%p] however sss [%p] is not completed\n", this, pSSSheet));
        hr = S_FALSE;   // still need download...
        goto Cleanup;
    }

    {
        TraceTag( (tagSharedStyleSheet, "Reconstruct style sheet [%p] from existing completed sss [%p]\n", this, pSSSheet));
        hr = THR( ReconstructOMRules(GetSSS(), fReplace) );
        if (hr)
            goto Cleanup;

        hr = THR( ReconstructFontFaces(GetSSS(), fReplace) );
        if (hr)
            goto Cleanup;
            
        hr = THR( ReconstructPages(GetSSS(), fReplace) );
        if (hr)
            goto Cleanup;
        
        if (!fReplace)
        {
            _nExpectedImports = _nCompletedImports = 0;
            _fReconstruct = TRUE;

            TraceTag( (tagSharedStyleSheet, "Reconstruct style sheet [%p] reconstructing imports [%4d]\n", this, GetSSS()->_apImportedStyleSheets.Size()));
            // reconstruct imported style sheets
            CSharedStyleSheet::CImportedStyleSheetEntry    *pRE;
            int n;
            for (pRE = GetSSS()->_apImportedStyleSheets, n = 0;
                 n < GetSSS()->_apImportedStyleSheets.Size();
                 n++, pRE++
                 )
            {
                TraceTag( (tagSharedStyleSheet, "Reconstruct style sheet [%p] reconstruct -- add imports [%4d] \n", this, n) );
                WHEN_DBG( DumpHref(pRE->_cstrImportHref) );
                hr = THR( AddImportedStyleSheet(pRE->_cstrImportHref, /* not parsing */FALSE, /*lPos*/-1, /*plPosNew*/NULL, /*fFireOnCssChange*/FALSE) );
#if DBG == 1
                if (!SUCCEEDED(hr))
                {
                    TraceTag( (tagSharedStyleSheet, "reconstruct style sheet - AddImportedStyleSheet failed - could be because of max-import leve exceeded") );
                }
#endif
            }
                 
            _fReconstruct = FALSE;
            if (FAILED(hr))      // maybe failing due to maximum importing level
            {
                hr = S_OK;
                goto Cleanup;
            }
        }
  }
    
Cleanup:    
    RRETURN1(hr, S_FALSE);
}



//*********************************************************************
//  CStyleSheet::ReconstructOMRules()
// Reconstruct a OMRule array CSharedStyleSheet 
// 
//*********************************************************************
HRESULT
CStyleSheet::ReconstructOMRules(CSharedStyleSheet *pSSSheet, BOOL fReplace)
{
    HRESULT hr = S_OK;
    Assert( pSSSheet );
    Assert( _apOMRules.Size() == 0 );

#if 0
    //
    // Since we are all the style sheets are shared within the same CDoc
    // this is not needed.
    //
        // note we are reproducing the logic in AddStyleRule.
        if (!fReplace)
        {
            TraceTag( (tagSharedStyleSheet, "Reconstruct style sheet [%p] reconstructing rules [%4d]\n", this, GetNumRules()));
            CStyleRule **pRules;
            int z;
            for (z = 0, pRules=GetSSS()->_apRulesList;
                 (DWORD)z < GetNumRules();
                 z++, pRules++
                 )
            {
                if ((*pRules)->GetStyleAA())
                {
                    //
                    // If the rule has the behavior attribute set, turn on the flag on the doc
                    // which forever enables behaviors.
                    //

                    // Only do the Find if PeersPossible is currently not set
                    if (_pParentElement && !_pParentElement->Doc()->AreCssPeersPossible())
                        if ((*pRules)->GetStyleAA()->Find(DISPID_A_BEHAVIOR))
                            _pParentElement->Doc()->SetCssPeersPossible();
                }
            }
        }

        //
        // else if we are replacing an existing one. The OM rule list and imported style sheets
        // are already in place. no need to do anything...
        //
#endif  

    //
    // Since we don't cache CStyleRule on OM objects, there is no need to do recontructions at all.
    //
    return hr;
}



//*********************************************************************
//  CStyleSheet::ReconstructFontFaces()
// Reconstruct a CFontFaces from an CSharedStyleSheet
//*********************************************************************
HRESULT
CStyleSheet::ReconstructFontFaces(CSharedStyleSheet *pSSSheet, BOOL fReplace)
{
    HRESULT hr = S_OK;
    Assert( pSSSheet );
    Assert( fReplace ? pSSSheet->_apFontBlocks.Size() == _apFontFaces.Size() : 0 == _apFontFaces.Size());
    CAtFontBlock **ppAtFonts;
    int n;
    for (n = 0, ppAtFonts = pSSSheet->_apFontBlocks;
         n < pSSSheet->_apFontBlocks.Size();
         n++, ppAtFonts++
         )
    {
        CFontFace *pFontFace;
        if (fReplace)
        {
            CAtFontBlock *pAtFont = _apFontFaces[n]->_pAtFont;

            Assert( _apFontFaces[n]->_pAtFont );
            _apFontFaces[n]->_pAtFont = (*ppAtFonts);
            (*ppAtFonts)->AddRef();
            
            pAtFont->Release();
            pFontFace = _apFontFaces[n];
            //
            // It is possible we have already started a download,
            // before we finish the download, a copy-on-write is
            // initiated. In this case, a font download is warranted.
            //
        }
        else
        {
            hr = THR( CFontFace::Create(&pFontFace, this, *ppAtFonts) );
            if (hr)
                goto Cleanup;
                
            hr = THR( _apFontFaces.Append(pFontFace) );
            if (hr)
                goto Cleanup;

            Assert( pFontFace );
            Assert(!pFontFace->IsInstalled());
            Assert(!pFontFace->DownloadStarted());
            //
            // We need to do font download and installation since
            // it is per-markup installation.
            //
        }

        if (!pFontFace->DownloadStarted())
        {
            //
            // Do per-markup installation. Since embedded font is copy-righted
            // so that it can only be used within specified domain, we have to
            // check the font installation against markup domain. 
            // 
            // e.g. 
            //      A.domain markup
            //          <link ref=B.domain.css>
            //                   B.domain.css -> @font c.eot
            //      c.eot has to be checked against A.domain instead of
            //      B.domain, which means even if B.domain.css is shared,
            //      c.eot is NOT shared between different markups.
            //
            IGNORE_HR(pFontFace->StartDownload());
        }
    }
    
Cleanup:
    RRETURN(hr);
}



//*********************************************************************
//  CStyleSheet::ReconstructPages()
// Reconstruct a CStyleSheetPages from an CSharedStyleSheet
//*********************************************************************
HRESULT
CStyleSheet::ReconstructPages(CSharedStyleSheet *pSSSheet, BOOL fReplace)
{
    HRESULT hr = S_OK;
    Assert( pSSSheet );
    Assert( fReplace ? (_pPageRules ? pSSSheet->_apPageBlocks.Size() == _pPageRules->_aPages.Size() : pSSSheet->_apPageBlocks.Size() == 0)
                     : _pPageRules == NULL);

    if (!fReplace && pSSSheet->_apPageBlocks.Size() > 0)
    {
        Assert( _pPageRules == NULL );
        _pPageRules = new CStyleSheetPageArray(this);
        if (!_pPageRules)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
                     
    CAtPageBlock **ppAtPages;
    int n;
    for (n = 0, ppAtPages = pSSSheet->_apPageBlocks;
         n < pSSSheet->_apPageBlocks.Size();
         n++, ppAtPages++
         )
    {
        Assert( _pPageRules );
        if (fReplace)
        {
            Assert( _pPageRules->_aPages[n]->_pAtPage );
            _pPageRules->_aPages[n]->_pAtPage->Release();
            _pPageRules->_aPages[n]->_pAtPage = (*ppAtPages);
            (*ppAtPages)->AddRef();
        }
        else
        {
            CStyleSheetPage *pPage = new CStyleSheetPage(this, (*ppAtPages));
            if (!pPage)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            hr = THR(_pPageRules->_aPages.Append(pPage));
            if (hr)
                goto Cleanup;
            pPage->AddRef();
        }
    }
    
Cleanup:
    RRETURN(hr);
}



//*********************************************************************
//  CStyleSheet::Passivate()
//*********************************************************************
void CStyleSheet::Passivate()
{
    // The mucking about with _pImportedStyleSheets in Free()
    // will subrel us, which _may_ cause self-destruction.
    // To get around this, we subaddref ourselves and then subrelease.
    SubAddRef();
    Free();
    DisconnectSharedStyleSheet();
    // disconnect from parent element
    _pParentElement = NULL;
    _pParentStyleSheet = NULL;
    SubRelease();

    // Perform CBase passivation last - we need access to the SSA container.
    super::Passivate();
 }



//*********************************************************************
//  CStyleSheet::DisconnectSharedStyleSheet()
//
//*********************************************************************
 void 
 CStyleSheet::DisconnectSharedStyleSheet(void)
 {
    // This is the final construction so we release shared style sheet
    if (_pSSSheet)
    {
        CSharedStyleSheet *pSSTmp = _pSSSheet;
        _pSSSheet = NULL;

        //  disconnect this style sheet from the shared style sheet
        pSSTmp->_apSheetsList.DeleteByValue(this);
        pSSTmp->Release();
    }
 }



//*********************************************************************
//  CStyleSheet::ConnectSharedStyleSheet()
//
//*********************************************************************
 void 
 CStyleSheet::ConnectSharedStyleSheet(CSharedStyleSheet *pSSS)
 {
    Assert( !_pSSSheet );
    Assert( pSSS );

    _pSSSheet = pSSS;
    _pSSSheet->AddRef();
    _pSSSheet->_apSheetsList.Append(this);
 }


//*********************************************************************
//  CStyleSheet::Free()
//  Storage for the stylesheet's rules is managed by the shared SS,
//  so all the stylesheet itself is responsible for is any imported style
//  sheets.  It may be advisable to take over management of our own rules?
//*********************************************************************
void CStyleSheet::Free( void )
{

    SetCssCtx(NULL);

    if ( _pImportedStyleSheets )
    {
        _pImportedStyleSheets->Free( );  // Force our stylesheets collection to release its
                                            // refs on imported stylesheets.
        _pImportedStyleSheets->Release();   // this will subrel us

    }

    if ( _pOMRulesArray )
        _pOMRulesArray->StyleSheetRelease();
    _pOMRulesArray = NULL;

    int idx = _apOMRules.Size();
    while ( idx )
    {
         CStyleSheetRule *pOMRule = _apOMRules[idx-1];
         if (pOMRule)
         {
            pOMRule->StyleSheetRelease();
            _apOMRules[idx - 1] = NULL;
         }
         idx--;
    }
    _apOMRules.DeleteAll();


    idx = _apFontFaces.Size();
    while (idx)
    {
        _apFontFaces[idx - 1]->PrivateRelease();
        idx--;
    }
    _apFontFaces.DeleteAll();
    

    // Free any @page rules
    if ( _pPageRules )
    {
        // Let go of the rules array (which is subref'ing us)
        // This is the only ref that should be held by Trident code.
        // Once the array goes away, it will release its subref on us.
        _pPageRules->Release();
        _pPageRules = NULL;
    }

    _nExpectedImports = _nCompletedImports = 0;
}

//*********************************************************************
//      CStyleSheet::PrivateQueryInterface()
//*********************************************************************
HRESULT
CStyleSheet::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
        QI_TEAROFF(this, IHTMLStyleSheet, NULL)
        QI_TEAROFF(this, IHTMLStyleSheet2, NULL)
        // TODO (KTam): remove the default case as it is unnecessary w/ the above tearoffs
        default:
        {
            const CLASSDESC *pclassdesc = ElementDesc();

            if (pclassdesc &&
                pclassdesc->_apfnTearOff &&
                pclassdesc->_classdescBase._piidDispinterface &&
                iid == *pclassdesc->_classdescBase._piidDispinterface)
            {
                HRESULT hr = THR(CreateTearOffThunk(this, (void *)(pclassdesc->_apfnTearOff), NULL, ppv));
                if (hr)
                    RRETURN(hr);
            }
        }
    }

    if (*ppv)
    {
        Assert( _pParentElement );
        if ( !_pParentStyleSheet && ( _pParentElement->Tag() == ETAG_STYLE ) )
        {
            CStyleElement *pStyle = DYNCAST( CStyleElement, _pParentElement );
            pStyle->SetDirty(); // Force us to build from our internal representation for persisting.
        }
        (*(IUnknown**)ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

ULONG CStyleSheet::PrivateAddRef( void )
{
    // StyleSheet belongs to its parent
    if (_pParentElement)
        _pParentElement->SubAddRef();

    return CBase::PrivateAddRef();
}

ULONG CStyleSheet::PrivateRelease( void )
{
    if (_pParentElement)
        _pParentElement->SubRelease();
    return CBase::PrivateRelease();
}

CStyleSheetArray *CStyleSheet::GetRootContainer( void )
{
    return _pSSAContainer ? _pSSAContainer->_pRootSSA : NULL;
}

CDoc *CStyleSheet::GetDocument( void )
{
    return _pParentElement ? _pParentElement->Doc() : NULL;
}

CMarkup *CStyleSheet::GetMarkup( void )
{
    return _pParentElement ? _pParentElement->GetMarkup() : NULL;
}



//
//
CAtomTable *CStyleSheet::GetAtomTable ( BOOL *pfExpando )
{
    Assert(_pParentElement); 
    if (pfExpando)
    {
        if (_fComplete)
        {
            Assert(GetMarkup());
            CMarkup *pMarkupContext = GetMarkup()->GetWindowedMarkupContext();
            Assert(pMarkupContext);
            *pfExpando = pMarkupContext->_fExpando;
        }
        else
        {
            *pfExpando = GetSSS()->_fExpando;
        }
    }
    
    return _pParentElement->GetAtomTable();         
}



//*********************************************************************
//  CStyleSheet::AddStyleRule()
//      This method adds a new rule to the correct CStyleRuleArray in
//  the hash table (hashed by element (tag) number) (The CStyleRuleArrays
//  are stored in the containing CStyleSheetArray).  This method is
//  responsible for splitting apart selector groups and storing them
//  as separate rules.  May also handle important! by creating new rules.
//
//  We also maintain a list in source order of the rules inserted by
//  this stylesheet -- the list has the rule ID (rule info only, no
//  import nesting info) and etag (no pointers)
//
//  NOTE:  If there are any problems, the CStyleRule will auto-destruct.
//*********************************************************************
HRESULT CStyleSheet::AddStyleRule( CStyleRule *pRule, BOOL fDefeatPrevious /*=TRUE*/, long lIdx /*=-1*/ )
{
    WHEN_DBG( Assert(DbgIsValid()) );
    HRESULT hr = S_OK;
    
    Assert( "Style Rule is NULL!" && pRule );
    Assert( "Style Selector is NULL!" && pRule->GetSelector() );
    Assert( "Stylesheet must have a rule container!" && GetSSS() );
    Assert( "Style ID for StyleSheet has not been set" && _sidSheet );

    hr = THR(GetSSS()->AddStyleRule(pRule, fDefeatPrevious, lIdx));
    if (hr)
        goto Cleanup;

    //
    // Even though pRule could be a group rules, they share the same
    // AA. So we only need to inspect it once here. 
    //
    if (pRule->GetStyleAA())
    {
        //
        // If the rule has the behavior attribute set, turn on the flag on the doc
        // which forever enables behaviors.
        //

        // Only do the Find if PeersPossible is currently not set
        if (_pParentElement && !_pParentElement->Doc()->AreCssPeersPossible())
            if (pRule->GetStyleAA()->Find(DISPID_A_BEHAVIOR))
                _pParentElement->Doc()->SetCssPeersPossible();
    }
    //
    // DONOT update automation array, it will be updated by OnNewStyleRuleAdded
    //

Cleanup:
    RRETURN(hr);
}

HRESULT 
CStyleSheet::OnNewStyleRuleAdded(CStyleRule *pRule)     // callback for new style added
{
#if DBG==1
    if (IsTagEnabled(tagStyleSheet))
    {
        pRule->DumpRuleString(this);
    }
#endif

    // Updating automation array starting from this rule 
    unsigned long lRule = pRule->GetRuleID().GetRule();
    if (lRule <= (unsigned long)_apOMRules.Size())  // if the new rule is inserted in an index <= maximum index
    {
        Assert(lRule > 0);
        // insert one position
        _apOMRules.Insert(lRule - 1, NULL);
    }
    
    for (int n = lRule; n < _apOMRules.Size(); n++)
    {
        if (_apOMRules[n])
        {
            // update _dwID
            Assert(_apOMRules[n]->_dwID >= lRule);
            _apOMRules[n]->_dwID++;
        }
    }
    return S_OK;
}


//*********************************************************************
//  CStyleSheet::RemoveStyleRule()
//  Simply removes style rule  -- not responsible for updating layout,etc.
//*********************************************************************
HRESULT 
CStyleSheet::RemoveStyleRule(long lIdx)
{
    Assert(DbgIsValid());
    
    HRESULT  hr = S_OK;
    CStyleRuleID  sidRule;
    
    // Make sure the index is valid.
    if (  lIdx < 0  || (unsigned long)lIdx >= GetNumRules()  )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    sidRule.SetRule(lIdx + 1);
    hr = THR(GetSSS()->RemoveStyleRule(sidRule));
    
Cleanup:
    RRETURN(hr);
}



HRESULT 
CStyleSheet::OnStyleRuleRemoved(CStyleRuleID sidRule)     // callback for new style added
{
    // Updating automation array starting from this rule 
    unsigned long lRule = sidRule.GetRule();
    for (int n = lRule; n < _apOMRules.Size(); n++)
    {
        if (_apOMRules[n])
        {
            // update _dwID
            Assert(_apOMRules[n]->_dwID > lRule);
            _apOMRules[n]->_dwID--;
        }
    }

    if (lRule <= (unsigned long)_apOMRules.Size())
    {
        if (_apOMRules[lRule-1])
        {
            _apOMRules[lRule - 1]->StyleSheetRelease();
            _apOMRules.Delete(lRule - 1);
        }
    }
    
    return S_OK;
}



//*********************************************************************
//  CStyleSheet::AddImportedStyleSheet()
//      This method adds an imported stylesheet to our imported list
//  (which is created if necessary), and kicks off a download of the
//  imported stylesheet.
//
//  fParsing determines if we are parsing a style block. It is for example
//  not set if we are called through IHTMLStyleSheet interface. See also comment
//  in function.
//*********************************************************************
HRESULT CStyleSheet::AddImportedStyleSheet( TCHAR *pszURL, BOOL fParsing, long lPos /*=-1*/, long *plNewPos /*=NULL*/, BOOL fFireOnCssChange /*=TRUE*/)
{
    Assert(DbgIsValid());
    
    CStyleSheet *pStyleSheet = NULL;
    CCssCtx *pCssCtx = NULL;
    HRESULT hr = E_FAIL;
    CStyleSheetCtx  ctxSS;
    CSharedStyleSheet::CImportedStyleSheetEntry  *pEntry = NULL;
    BOOL    fFinished = FALSE;
    BOOL    fReconstructed = FALSE;

    // Do not support imported SS in User SS as there is no doc!
    if (!_pParentElement)
        goto Cleanup;

    if ( plNewPos )
        *plNewPos = -1;     // -1 means failed to add sheet

    // Check if our URL is a CSS url(xxx) string.  If so, strip "url(" off front,
    // and ")" off back.  Otherwise assume it'a a straight URL.
    // This function modifies the parameter string pointer
    hr = RemoveStyleUrlFromStr(&pszURL);
    if(FAILED(hr))
        goto Cleanup;

   if (!_fReconstruct)
   {
        //
        // If this is a strict CSS document, we shouldn't allow @imports after the first selector rule.
        // This only happens if we are in parsing time -- this assumes that anything that is parsed
        // in is correct so during reconstruction time, we would not need to check this again.
        // Another case where we don't want to apply strict css is, if we are called through the CHTMLStyleSheet 
        // interface to add an import. Therefore fParsing was introduced. More generally fParsing determines
        // if we are _parsing_ a style sheet.
#if DBG == 1
        if (_pParentElement && _pParentElement->IsInMarkup() )
        {
            Assert( _pParentElement->GetMarkup()->IsStrictCSS1Document() == !!GetSSS()->_fIsStrictCSS1 );
        }
#endif
        if (GetSSS()->_fIsStrictCSS1 && GetNumRules() && fParsing)
        {
            hr = S_OK;
            goto Cleanup;
        }

        //
        // add our imported style sheet list - before we even try to create new style sheet
        // because style sheet creation might fail due to MAX level. However we still
        // want to record the information
        //
        GetSSS()->_apImportedStyleSheets.AppendIndirect(NULL, &pEntry);  
        if (!pEntry)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        
        if (pszURL)
        {
            pEntry->_cstrImportHref.Set(pszURL);
        }
    }

    // Bail if we're max'ed out on nesting.
    if ((long)_sidSheet.FindNestingLevel() >= MAX_IMPORT_NESTING)
    {
        TraceTag( (tagStyleSheet, "Maximum import nesting exceeded! (informational)") );
        hr = E_INVALIDARG;  // no need to download
        goto Cleanup;
    }

    hr = E_FAIL;
    // The imports array could already exist because of previous @imports,
    // or because the imports collection was previously requested from script.
    if ( !_pImportedStyleSheets )
    {
        // Imported stylesheets don't manage their own rules.
        _pImportedStyleSheets = new CStyleSheetArray( this, GetRootContainer(), _sidSheet );
        Assert( "Failure to allocate imported stylesheets array! (informational)" && _pImportedStyleSheets );
        if (!_pImportedStyleSheets)
            goto Cleanup;
        if (_pImportedStyleSheets->_fInvalid)
        {
            _pImportedStyleSheets->CBase::PrivateRelease();
            goto Cleanup;
        }
    }
    ++_nExpectedImports; // we will track this one

    // Create the stylesheet in the "imported array".  
    ctxSS._pParentElement    = _pParentElement;
    ctxSS._pParentStyleSheet = this;
    ctxSS._szUrl             = pszURL;
    ctxSS._dwCtxFlag = (STYLESHEETCTX_IMPORT | STYLESHEETCTX_REUSE | STYLESHEETCTX_SHAREABLE);
    hr = _pImportedStyleSheets->CreateNewStyleSheet( &ctxSS, &pStyleSheet, lPos, plNewPos);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    if (hr == S_FALSE)     // hr = S_FALSE means need to download 
    {
        hr = S_OK;
        
        // Kick off the download of the imported sheet
        if (pszURL && pszURL[0])
        {
            CDoc *  pDoc = _pParentElement->Doc();
            BOOL fPendingRoot = FALSE;

            if (_pParentElement->IsInMarkup())
            {
                fPendingRoot = _pParentElement->GetMarkup()->IsPendingRoot();
            }

            Assert(pStyleSheet->_eParsingStatus != CSSPARSESTATUS_DONE);
            hr = THR(pDoc->NewDwnCtx(DWNCTX_CSS, pStyleSheet->GetAbsoluteHref(), _pParentElement,
                                    (CDwnCtx **)&pCssCtx, fPendingRoot));
            
            if (hr == S_OK)
            {
                // For rendering purposes, having an @imported sheet pending is just like having
                // a linked sheet pending.
                pDoc->EnterStylesheetDownload(&(pStyleSheet->_dwStyleCookie));
                _pParentElement->GetMarkup()->BlockScriptExecution(&(pStyleSheet->_dwScriptCookie));

                // Give ownership of bitsctx to the newly created (empty) stylesheet, since it's
                // the one that will need to be filled in by the @import'ed sheet.
                pStyleSheet->SetCssCtx(pCssCtx);
                pCssCtx->Release();
            }
        }
        else
        {
            pStyleSheet->GetSSS()->_fComplete = TRUE;
            fFinished = TRUE;
        }
    }
    else // hr == S_OK
    {
        fFinished = TRUE;
        fReconstructed = TRUE;
    }

    if (fFinished)
    {
        Assert( pStyleSheet );
        // we have reconstructed from exsiting...
        //////////////////////////////////////////////
        pStyleSheet->_eParsingStatus = CSSPARSESTATUS_DONE;
        pStyleSheet->_fComplete      = TRUE;
         // This sheet has finished, one way or another.
        _nCompletedImports++;
        // notify parent that this is done
        pStyleSheet->CheckImportStatus();        
    }

    if (fReconstructed && fFireOnCssChange)
    {
        if (_pParentElement->IsInMarkup())
        {
            IGNORE_HR( _pParentElement->GetMarkup()->OnCssChange( /*fStable = */ FALSE, /* fRecomputePeers = */ TRUE) );
        }
    }
    
    WHEN_DBG( !pStyleSheet || pStyleSheet->DbgIsValid() );

Cleanup:
    RRETURN(hr);
}



//*********************************************************************
//  CStyleSheet::AppendFontFace()
//*********************************************************************
HRESULT
CStyleSheet::AppendFontFace(CFontFace *pFontFace)
{
    HRESULT hr = THR(_apFontFaces.Append(pFontFace));
    if (!hr)
    {
        hr = THR(GetSSS()->AppendFontFace(pFontFace->_pAtFont));
    }
    
    RRETURN(hr);
}



//*********************************************************************
//  CStyleSheet::AppendPage()
//*********************************************************************
HRESULT 
CStyleSheet::AppendPage(CStyleSheetPage *pPage)
{ 
    RRETURN( GetSSS()->AppendPage(pPage->_pAtPage) ); 
}



//*********************************************************************
//  CStyleSheet::ChangeStatus()
//  Enable or disable this stylesheet and its imported children
//*********************************************************************
HRESULT CStyleSheet::ChangeStatus(
    DWORD dwAction,               // CS_ flags as defined in sheets.hxx
    BOOL fForceRender /*=TRUE*/,  // should we force everyone to update their formats and re-render?
                                  // We want to avoid forcing a re-render when the doc/tree is unloading/dying etc.
    BOOL *pfChanged)              // Should only be non-NULL on recursive calls (ext. callers use NULL)
{
    Assert( DbgIsValid() );
    Assert(!( (dwAction & CS_ENABLERULES) && (dwAction & CS_CLEARRULES) ) );
    Assert(!( (dwAction & CS_CLEARRULES) && MEDIATYPE(dwAction)  ));
    Assert( GetRootContainer() );

    HRESULT hr = S_OK;
    int z;
    CStyleSheet *pSS;
    BOOL  fRootStyleSheet = FALSE;
    BOOL  fChanged        = FALSE;
    BOOL  fDisabled       = _fDisabled;
    CMarkup *pMarkup = NULL;


    // The first call pfChange should be NULL
    if (!pfChanged)
    {  
        pfChanged = &fChanged;
        fRootStyleSheet = TRUE;
    }

    if (fRootStyleSheet)
    {
       pMarkup = DYNCAST(CMarkup, GetRootContainer()->_pOwner);  // top CStyleSheetArray's owner is always the markup
    }

    // Mark this stylesheet's status
    _fDisabled = !(dwAction & CS_ENABLERULES);
    if (dwAction & CS_CLEARRULES)
    {
        if (GetSSS())
        {
            hr = THR( EnsureCopyOnWrite(TRUE /*fDetachOnly*/) );
            if (hr)
                goto Cleanup;  
            IGNORE_HR( GetSSS()->ReleaseRules() );
        }

        // clear out our OM list 
        Free();
    }

    if (dwAction & CS_DETACHRULES)
    {
        if (_pSSAContainer)
        {
            //
            // Simpy cut down the connection 
            // so that the style sheet is aware
            // of its status as being detached
            //
            // StyleSheet does not hold any ref
            // to its container. 
            // 
            _pSSAContainer = NULL;
        }
    }


    if ( MEDIATYPE(dwAction) )
    {   
        Assert( !(dwAction & CS_CLEARRULES ) );
        hr = THR( EnsureCopyOnWrite(/*fDetachOnly*/FALSE) );
        if (hr)
            goto Cleanup;
        
        hr = THR( GetSSS()->ChangeRulesStatus(dwAction, pfChanged) );
        if (hr)
            goto Cleanup;
    }


    // Recursively scan sheets of our imports
    if (_pImportedStyleSheets)
    {
        for ( z=0 ; (pSS=(_pImportedStyleSheets->Get(z))) != NULL ; ++z)
        {
            hr = THR( pSS->ChangeStatus( dwAction, fForceRender, pfChanged ) );
            if (hr)
                goto Cleanup;
        }
    }

    // If our imported style sheets did not change anything
    // See if this current style sheet caused any change
    if (!*pfChanged)
    {
        if (fDisabled != _fDisabled || (dwAction & CS_CLEARRULES) || (dwAction & CS_DETACHRULES))
        {
            if (GetNumRules())
            {
                *pfChanged = TRUE;
            }
        }
    }

    if (fRootStyleSheet)   // root stylesheet
    {
        Assert(pfChanged);
        // Force update of element formats to account for new set of rules
        if ( fForceRender && *pfChanged  && pMarkup)
        {
            IGNORE_HR( pMarkup->OnCssChange(/*fStable = */ TRUE, /* fRecomputePeers = */ TRUE) );
        }
    }

Cleanup:
    RRETURN(hr);
}



//*********************************************************************
//  CStyleSheet::AppendListOfProbableRules()
//
//  Add Probable Rules from this sheet to CProbableRules
//  This will only be called by CStyleSheetArray::BuildListOfProbableRules
//*********************************************************************
HRESULT 
CStyleSheet::AppendListOfProbableRules(CTreeNode *pNode, CProbableRules *ppr, CClassIDStr *pclsStrLink, CClassIDStr *pidStr, BOOL fRecursiveCall)
{
    HRESULT  hr;

    if (_fDisabled)
    {
        hr = S_OK;
        goto Cleanup;
    }

#if DBG == 1
    if (IsTagEnabled(tagStyleSheet))
    {
        WHEN_DBG( Dump() );
    }
#endif
    
    // Recursivly call for import SSA -- depth first search 
    if (_pImportedStyleSheets)
    {
        hr = THR(_pImportedStyleSheets->BuildListOfProbableRules(pNode, ppr, pclsStrLink, pidStr, fRecursiveCall));
        if (hr)
            goto Cleanup;
    }

    hr = THR(GetSSS()->AppendListOfProbableRules(_sidSheet, pNode, ppr, pclsStrLink, pidStr, fRecursiveCall));
    if (hr)
        goto Cleanup;

Cleanup:    
    RRETURN(hr);
}




//*********************************************************************
//  CStyleSheet::TestForPseudoclassEffect()
//*********************************************************************

BOOL 
CStyleSheet::TestForPseudoclassEffect(
    CStyleInfo *pStyleInfo,
    BOOL fVisited,
    BOOL fActive,
    BOOL fOldVisited,
    BOOL fOldActive )

{
    if (GetSSS()->TestForPseudoclassEffect(pStyleInfo, fVisited, fActive, fOldVisited, fOldActive))
        return TRUE;
    if (_pImportedStyleSheets)
    {
        return _pImportedStyleSheets->TestForPseudoclassEffect(pStyleInfo, fVisited, fActive, fOldVisited, fOldActive);
    }

    return FALSE;
}       




//*********************************************************************
//  CStyleSheet::ChangeContainer()
//
//  When a StyleSheet moves to another StyleSheetArray, this method changes
//  the container StyleSheetArray -- no need to change container for imported
//  style sheets as their container will be _pImportedStyleSheets
//*********************************************************************
void    
CStyleSheet::ChangeContainer(CStyleSheetArray * pSSANewContainer)
{
    Assert( DbgIsValid() );
    
    Assert(pSSANewContainer);
    _pSSAContainer = pSSANewContainer;

    if (_pImportedStyleSheets)
    {
        _pImportedStyleSheets->_pRootSSA = _pSSAContainer->_pRootSSA;
    }
}

MtDefine(LoadFromURL, Utilities, "CStyleSheet::LoadFromURL");

//*********************************************************************
//  CStyleSheet::LoadFromURL()
//  Marks as "dead" any rules that this stylesheet currently has, and
//  loads a new set of rules from the specified URL.  Because of our
//  ref-counting scheme, if this sheet has an imports collection allocated,
//  that collection object is reused (i.e. any existing imported SS are
//  released).
//*********************************************************************
HRESULT CStyleSheet::LoadFromURL( CStyleSheetCtx *pCtx, BOOL fAutoEnable /*=FALSE*/ )
{
    HRESULT     hr;
    CCssCtx    *pCssCtx = NULL;

    WHEN_DBG( Assert(DbgIsValid()) );

    BOOL fDisabled = _fDisabled;    // remember our current disable value.

    hr = THR( EnsureCopyOnWrite(TRUE /*fDetachOnly*/) );
    if (hr)
        goto Cleanup;
    
    // Force all our rules (and rules of our imports) to be marked as out of the tree ("dead"),
    // but don't patch other rules to fill in the ID hole.
    // Don't force a re-render since we will immediately be loading new rules.
    hr = ChangeStatus( CS_CLEARRULES, FALSE, NULL );   // disabling, detached from tree, no re-render
    if ( hr )
        goto Cleanup;

    GetSSS()->_fParsing   = FALSE;
    GetSSS()->_fComplete = FALSE;
    GetSSS()->_fModified  = TRUE;

    // Note: the ChangeStatus call above will have set us as disabled.  Restore our original disable value.
    _fDisabled = fAutoEnable? FALSE : fDisabled;

    // Clear our readystate information:
    _eParsingStatus = CSSPARSESTATUS_PARSING;
    _nExpectedImports = 0;
    _nCompletedImports = 0;

    if(GetAbsoluteHref())
    {
        MemFreeString(GetAbsoluteHref());
        SetAbsoluteHref(NULL);
    }

    // That's all the cleanup we need; our parent element, parent stylesheet, sheet ID etc.
    // stay the same!


    // Kick off the download of the URL
    if ( pCtx && pCtx->_szUrl && pCtx->_szUrl[0] )
    {
        CDoc *  pDoc = _pParentElement->Doc();
        TCHAR   cBuf[pdlUrlLen];
        BOOL    fPendingRoot = NULL;

        hr = CMarkup::ExpandUrl(
                NULL, pCtx->_szUrl, ARRAY_SIZE(cBuf), cBuf, _pParentElement);
        if (hr)
            goto Cleanup;
        MemAllocString(Mt(LoadFromURL), cBuf, GetRefAbsoluteHref());
        if (GetAbsoluteHref() == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        if (_pParentElement->IsInMarkup())
        {
            fPendingRoot = _pParentElement->GetMarkup()->IsPendingRoot();
        }

        hr = THR(pDoc->NewDwnCtx(DWNCTX_CSS, pCtx->_szUrl,
                    _pParentElement, (CDwnCtx **)&pCssCtx, fPendingRoot));
        if (hr == S_OK)
        {
            // Block rendering while we load..
            pDoc->EnterStylesheetDownload(&_dwStyleCookie);

            GetMarkup()->BlockScriptExecution(&_dwScriptCookie);
            if ( IsAnImport() )
                (_pParentStyleSheet->_nCompletedImports)--;

            // We own the bits context..
            SetCssCtx(pCssCtx);
        }
    }
    else
    {
        SetCssCtx( NULL );
        Fire_onerror();
        CheckImportStatus();
    }

Cleanup:
    if (pCssCtx)
        pCssCtx->Release();

    RRETURN( hr );
}

//*********************************************************************
//  CStyleSheet::PatchID()
//  Patches the ID of this stylesheet and all nested imports
//*********************************************************************

void CStyleSheet::PatchID(
    unsigned long ulLevel,       // Level that will change
    unsigned long ulValue,       // Value level will be given
    BOOL fRecursiveCall)        // Is this a recursive call? (FALSE for ext. callers).
{
    Assert (ulLevel > 0 && ulLevel <= MAX_IMPORT_NESTING );
    Assert ( ulValue <= MAX_SHEETS_PER_LEVEL );

    long i = 0;
    CStyleSheet * pISS;

    // Fix our own ID
    _sidSheet.SetLevel( ulLevel, ulValue );
    Assert( _sidSheet );    // should never become 0

    // Everyone nested below the sheet for which PatchID was first called needs
    // to be patched at the same level with a value that's 1 less.
    if (!fRecursiveCall)
    {
        fRecursiveCall = TRUE;
        --ulValue;
    }

    // If we have imports, ask them to fix all of their IDs.
    if ( _pImportedStyleSheets )
    {
        // Fix ID that imports collection will use to build new imports
        _pImportedStyleSheets->_sidForOurSheets.SetLevel( ulLevel, ulValue );
        // Recursively fix imported stylesheets
        while ( (pISS = _pImportedStyleSheets->Get(i++)) != NULL )
        {
            pISS->PatchID( ulLevel, ulValue, fRecursiveCall );
        }
    }
}

//*********************************************************************
//  CStyleSheet::ChangeID()
//  Changes the ID for this StyleSheet and all the rules
//*********************************************************************
BOOL  CStyleSheet::ChangeID(CStyleSheetID const idNew)
{
    unsigned int ulLevel = idNew.FindNestingLevel();
    unsigned int ulValue = idNew.GetLevel(ulLevel);

    Assert (ulLevel > 0 && ulLevel <= MAX_IMPORT_NESTING );
    Assert ( ulValue <= MAX_SHEETS_PER_LEVEL );

    // Update our ID
    _sidSheet = idNew & ~RULE_MASK;

    // Fix our own ID
    _sidSheet.SetLevel( ulLevel, ulValue );
    Assert( _sidSheet );    // should never become 0

    // Change the Imported sheets
    if (_pImportedStyleSheets)
    {
        if (!_pImportedStyleSheets->ChangeID(_sidSheet))
            return FALSE;
    }
    
    return TRUE;
}

//*********************************************************************
//  CStyleSheet::SetCssCtx()
//  Sets ownership and callback information for a CssCtx.  A stylesheet
//  will have a non-NULL CssCtx if it's @import'ed.
//*********************************************************************
void CStyleSheet::SetCssCtx(CCssCtx * pCssCtx)
{    
    if (_pCssCtx)
    {   // If we're tromping on an in-progress download, fix the completed count up.

        TraceTag( (tagStyleSheet, "SetCssCtx [%p]-- get new bitsctx [%p] while still holding bitsctx [%p] and sss [%p]\n", this, pCssCtx, _pCssCtx, GetSSS()));
        if (!_fComplete)
        {
            if (IsAnImport())
                (_pParentStyleSheet->_nCompletedImports)++;
            _pParentElement->Doc()->LeaveStylesheetDownload(&_dwStyleCookie);
        }
        _pCssCtx->SetProgSink(NULL); // detach download from document's load progress
        _pCssCtx->Disconnect();
        _pCssCtx->Release();
    }

    _fComplete = FALSE;
    _pCssCtx = pCssCtx;

    if (pCssCtx)
    {
        pCssCtx->AddRef();

        pCssCtx->AddRef();     // Keep ourselves alive
        SetReadyState( READYSTATE_LOADING );

        if ( pCssCtx == _pCssCtx )    // Make sure we're still the bitsctx for this stylesheet -
        {                               // it's possible SetReadyState fired and changed the bitsctx.
            TraceTag( (tagStyleSheet, "SetCssCtx [%p]-- ulState is  [%x]", _pCssCtx, _pCssCtx->GetState()) );
            if (pCssCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
            {
               OnDwnChan(pCssCtx);
            }
            else
            {
                pCssCtx->SetProgSink(CMarkup::GetProgSinkHelper(GetMarkup()));
                pCssCtx->SetCallback(OnDwnChanCallback, this);
                pCssCtx->SelectChanges(DWNCHG_COMPLETE|DWNCHG_HEADERS, 0, TRUE);
            }
        }

        pCssCtx->Release();     // Stop keeping ourselves alive
    }
}


//*********************************************************************
//  CStyleSheet::DoParsing()
// Goto parsing state - or in the shared case, fake a parsing session 
//
// S_OK:    Parsing succeeded: either a real one or a reconstructed one
// S_FALSE: Waitting for callback...
//
//*********************************************************************
HRESULT
CStyleSheet::DoParsing(CCssCtx *pCssCtx)
{
    HRESULT  hr = S_OK;
    Assert( _pSSSheet );
    Assert( pCssCtx );
    IStream *pStream = NULL;

    Assert( _fParser == FALSE );

    {
        if (!GetSSS()->_fComplete)
        {
            _eParsingStatus = CSSPARSESTATUS_PARSING;
            if (GetSSS()->_fParsing)
            {
                // someone is doing the parsing. the shared style sheet 
                // should call back to notify us when the parsing is done 
                // so we can do reconstruct from the shared style sheet. 
                // pretend that we are doing the parsing...
                // This could easily happen if there is a circular references A.css - B.css - A.css
                // The second time A.css is trying to do parsing, it will see that the first A.css is 
                // already doing parsing...
                TraceTag( (tagSharedStyleSheet, "DoParsing -- [%p] wait others parsing [%p]", this, GetSSS()));
                hr = S_FALSE;
                goto Cleanup;
            }
            else
            {
                Assert( pCssCtx );
                TraceTag( (tagSharedStyleSheet, "DoParsing -- this [%p] will do parsing for [%p]", this, GetSSS()));
                if ( S_OK == pCssCtx->GetStream(&pStream) )
                {
                    // this is the one that is going to do the parsing
                    GetSSS()->_fParsing = TRUE;
                    _fParser = TRUE;
                }
            }
        }
        else
        {
            Assert( _eParsingStatus != CSSPARSESTATUS_DONE );
            _eParsingStatus = CSSPARSESTATUS_DONE;
        }
    }

    if (_eParsingStatus == CSSPARSESTATUS_DONE )
    {
        TraceTag( (tagSharedStyleSheet, "DoParsing -- [%p] find one that is already completed [%p]", this, GetSSS()));
        hr = THR(ReconstructStyleSheet(GetSSS(), /*fReplace*/FALSE));
        if (hr)
            goto Cleanup;
    }       

    if (pStream && _fParser )
    {
        CMarkup *pMarkup = _pParentElement->GetMarkup();
        
        CCSSParser parser( this, NULL, IsXML(), IsStrictCSS1() );
        parser.LoadFromStream(pStream, pMarkup->GetCodePage());
        pStream->Release();
        
        _eParsingStatus = CSSPARSESTATUS_DONE;    
        TraceTag( (tagSharedStyleSheet, "DoParsing -- [%p] finished parsing for [%p]\n", this, GetSSS()));

        GetSSS()->_fParsing  = FALSE;   // done parsing...
        GetSSS()->_fComplete = TRUE;    // finished construction
        GetSSS()->Notify(NF_SHAREDSTYLESHEET_PARSEDONE);
        _fParser = FALSE;
        TraceTag( (tagSharedStyleSheet, "DoParsing [%p]-- finished notification for PARSEDONE-[%p]\n", this, GetSSS()));
    }
    else if (_fParser)
    {
        _eParsingStatus = CSSPARSESTATUS_DONE;   // Need to make sure we'll walk up to our parent in CheckImportStatus()
        TraceTag((tagError, "CStyleSheet::DoParsing bitsctx failed to get file!"));

        //
        // TODO: impl. CSharedStyleSheet::SwitchParserAway
        //
        GetSSS()->_fParsing  = FALSE;   // done parsing...
        GetSSS()->_fComplete = TRUE;    // finished construction
        GetSSS()->Notify(NF_SHAREDSTYLESHEET_BITSCTXERROR);
        _fParser = FALSE;
        TraceTag( (tagSharedStyleSheet, "DoParsing [%p]-- finished notification for PARSEERROR-[%p]\n", this, GetSSS()));
        
        Fire_onerror();
        EnsureCopyOnWrite(/*fDeatchOnly*/ TRUE);    // disconnect from the shared SS();
    }
    
Cleanup:
    RRETURN1(hr, S_FALSE);
}


//*********************************************************************
//  CStyleSheet::OnDwnChan()
//  Callback used by CssCtx once it's downloaded the @import'ed
//  stylesheet data that will be used to fill us out.  Also used when
//  the HREF on a linked stylesheet changes (we reuse the CStyleSheet
//  object and setup a new bitsctx on it)
//*********************************************************************
void CStyleSheet::OnDwnChan(CDwnChan * pDwnChan)
{
    Assert( GetThreadState() == _pts );
    
    ULONG ulState;
    CMarkup *pMarkup;
    CDoc *pDoc;
    HRESULT  hr;
    BOOL    fDoHeaders;

    Assert(_pCssCtx && "OnDwnChan called while _pCssCtx == NULL, possibely legacy callbacks");
    Assert(_pParentElement);
    _pParentElement->EnsureInMarkup();

    pMarkup = _pParentElement->GetMarkup();
    Assert(pMarkup);

    pDoc = pMarkup->Doc();

    if ( IsAnImport() && !_fDisabled )      // if it's already disabled, leave it.
        _fDisabled = _pParentStyleSheet->_fDisabled;

    ulState = _pCssCtx->GetState();
    fDoHeaders = (BOOL)(ulState & DWNLOAD_HEADERS);
    if (!fDoHeaders)
    {
        fDoHeaders = (ulState & DWNLOAD_COMPLETE) && !(ulState & DWNLOAD_HEADERS);
    }
    
    if (fDoHeaders)
    {
        //
        // TODO: this could have been called twice (although it does no harm) --we can modify this
        // to be called only once in the future.
        //
        BOOL fGotLastMod = FALSE;
        FILETIME ft = {0};
        
        ft = _pCssCtx->GetLastMod();
        if (ft.dwHighDateTime == 0 && ft.dwLowDateTime == 0)
        {
            fGotLastMod = GetUrlTime(&ft, GetAbsoluteHref(), _pParentElement);
        }
        else
            fGotLastMod = TRUE;
        
        if (fGotLastMod)
        {
            GetSSS()->_ft = ft;
            TraceTag( (tagSharedStyleSheet, "OnDwnChan - DoHeaders -- set FT [%x] [%x] for [%p]", GetSSS()->_ft.dwHighDateTime, GetSSS()->_ft.dwLowDateTime, GetSSS()) );
        }
#if DBG==1            
        else
        {   
            TraceTag( (tagSharedStyleSheet, "Link - OnDwnChan cannot get FILETIME from CssCtx") );
        }
#endif             
        GetSSS()->_dwBindf = _pCssCtx->GetBindf();
        GetSSS()->_dwRefresh = _pCssCtx->GetRefresh();
    }

    // try to attach late
    if (ulState & (DWNLOAD_COMPLETE |DWNLOAD_HEADERS))
    {
        CSharedStyleSheetsManager *pSSSM = GetSSS()->_pManager;
        CSharedStyleSheet *pSSS = NULL;
        if (pSSSM && !GetSSS()->_fComplete)
        {
            if (!(GetSSS()->_ft.dwHighDateTime == 0 && GetSSS()->_ft.dwLowDateTime == 0)
               && (S_OK == THR(AttachByLastMod(pSSSM, NULL, &pSSS, FALSE)))
               )
            {
                // Stop downloading
                TraceTag( (tagSharedStyleSheet, "Attached -- stop downloading") );
                if (!(ulState & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED)))
                {
                    _pCssCtx->SetLoad( FALSE, NULL, FALSE );
                    ulState |= DWNLOAD_COMPLETE;
                }
                Assert( pSSS );
                hr = THR(AttachByLastMod(pSSSM, pSSS, NULL, TRUE));
                Assert(hr == S_OK);
                _eParsingStatus = CSSPARSESTATUS_DONE;
            }
        }
        //
        // else simply fall through...
        // 
    }

    // do parsing if necessary 
    if ( ulState & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED) )
    {
       Assert(!_fComplete);
       _fComplete = TRUE;
            
        pDoc->LeaveStylesheetDownload(&_dwStyleCookie);

        // This sheet has finished, one way or another.
        if ( IsAnImport() )
            _pParentStyleSheet->_nCompletedImports++;

        if (ulState & DWNLOAD_COMPLETE)
        {
            // If unsecure download, may need to remove lock icon on Doc
            pDoc->OnSubDownloadSecFlags(pMarkup->IsPendingRoot(), _pCssCtx->GetUrl(), _pCssCtx->GetSecFlags());
            if (_eParsingStatus != CSSPARSESTATUS_DONE)
            {
                IGNORE_HR( DoParsing(_pCssCtx) );
            }
        }
        else
        {
            EnsureCopyOnWrite(/*fDetachOnly*/TRUE, /*fWaitForCompletion*/FALSE);
            _eParsingStatus = CSSPARSESTATUS_DONE;      // Need to make sure we'll walk up to our parent in CheckImportStatus()
            TraceTag((tagError, "CStyleSheet::OnChan bitsctx failed to complete!"));
            if ( ulState & DWNLOAD_ERROR )
                Fire_onerror();
        }

        //
        // If our parsing simply returns -- that is, someone else is doing parsing
        // then we will defer the call to OnCssChange after we got the notifications.
        //
        if (CSSPARSESTATUS_DONE == _eParsingStatus)
        {
            TraceTag( (tagSharedStyleSheet, "parsing status == DONE Notify markup and parent, unblock script execution") );
            // Relayout the doc; new rules may have been loaded (e.g. DWNLOAD_COMPLETE),
            // or we may have killed off rules w/o re-rendering before starting the load
            // for this sheet (e.g. changing src of an existing sheet).
            IGNORE_HR( pMarkup->OnCssChange( /*fStable = */ FALSE, /* fRecomputePeers = */ TRUE) );

            // notify parent that this is done
            CheckImportStatus();    // Needed e.g. if all imports were cached, their OnChan's would all be called
                                    // before parsing finished.
            pMarkup->UnblockScriptExecution(&_dwScriptCookie);
            
            _pCssCtx->SetProgSink(NULL); // detach download from document's load progress
            SetCssCtx(NULL);
        }
    }
    else
    {
       WHEN_DBG( if (!(ulState & DWNLOAD_HEADERS)) Assert( "Unknown result returned from CStyleSheet's bitsCtx!" && FALSE ) );
    }
}

//*********************************************************************
//  CStyleSheet::Fire_onerror()
//      Handles firing onerror on our parent element.
//*********************************************************************
void CStyleSheet::Fire_onerror()
{
    if ( !_pParentElement )
        return;    // In case we're a user stylesheet

    if (_pParentElement->Tag() == ETAG_STYLE)
    {
        CStyleElement *pStyle = DYNCAST( CStyleElement, _pParentElement );
        pStyle->Fire_onerror();
    }
    else
    {
        Assert( _pParentElement->Tag() == ETAG_LINK );
        CLinkElement *pLink = DYNCAST( CLinkElement, _pParentElement );
        pLink->Fire_onerror();
    }
}

//*********************************************************************
//  CStyleSheet::IsXML()
//      Says whether this stylesheet should follow xml generic parsing rules
//*********************************************************************
BOOL CStyleSheet::IsXML(void)
{
    // the parent element may have been detached, is there a problem here?
    return _pParentElement && _pParentElement->IsInMarkup() && _pParentElement->GetMarkupPtr()->IsXML();
}

//*********************************************************************
//  CStyleSheet::IsStrictCSS1()
//*********************************************************************

BOOL CStyleSheet::IsStrictCSS1(void)
{
    return _pParentElement && _pParentElement->IsInMarkup() && _pParentElement->GetMarkupPtr()->IsStrictCSS1Document();
}

//*********************************************************************
//  CStyleSheet::Notify()
// Notifications from CSharedStyleSheet
//*********************************************************************
HRESULT 
CStyleSheet::Notify(DWORD dwNotification)
{
    HRESULT  hr = S_OK;

    Assert( !_fParser );
    switch (dwNotification)
    {
    case NF_SHAREDSTYLESHEET_BITSCTXERROR:
            if (_eParsingStatus == CSSPARSESTATUS_PARSING)    // !_fParser
            {
                Assert( !_fParser );
                TraceTag( (tagSharedStyleSheet, "Notify [%p]-- received notification for BITSCTXERROR-[%p]\n", this, GetSSS()));
                _eParsingStatus = CSSPARSESTATUS_DONE;

                Fire_onerror();
                EnsureCopyOnWrite(/*fDetachOnly*/ TRUE);    // disconnect from the shared SS();
            }
            //
            // FALL THROUGH
            //
        
    case NF_SHAREDSTYLESHEET_PARSEDONE:
            if (_eParsingStatus == CSSPARSESTATUS_PARSING)    // !_fParser
            {
                TraceTag( (tagSharedStyleSheet, "Notify [%p]-- received notification for PARSEDONE-[%p]\n", this, GetSSS()));
                Assert( !_fParser );
                Assert( _fComplete );
                Assert( GetSSS()->_fComplete );
                Assert( !GetSSS()->_fParsing );
                
                _eParsingStatus = CSSPARSESTATUS_DONE;
                // now the shared style sheet is ready to be used -- creating from a new one
                hr = THR( ReconstructStyleSheet(GetSSS(), /*fReplace*/FALSE) ); 
                if (SUCCEEDED(hr))
                {
                    // might still have imports pending
                    hr = S_OK;
                }
            }

            if (_eParsingStatus == CSSPARSESTATUS_DONE)
            {
                Assert( _fComplete );
                CMarkup  *pMarkup = GetMarkup();
                // Link element is responsible for downloading and parsing...
                Assert(!_fParser);
                if (!IsAnImport() && _pParentElement && _pParentElement->Tag() == ETAG_LINK)
                {
                    CLinkElement  *pLink = DYNCAST(CLinkElement, _pParentElement);
                    Assert( pLink );
                    TraceTag( (tagSharedStyleSheet, "Notify [%p]-- PARSEDONE-[%p] -- notify link element [%p]\n", this, GetSSS(), pLink));
                    
                    IGNORE_HR( pLink->OnCssChange(/*fStable = */ FALSE, /* fRecomputePeers = */TRUE) );
                    CheckImportStatus();
                    if (pLink->_dwScriptDownloadCookie)
                    {
                        Assert (pMarkup);
                        pMarkup->UnblockScriptExecution(&(pLink->_dwScriptDownloadCookie));
                        pLink->_dwScriptDownloadCookie = NULL;
                    }
                    pLink->_pCssCtx->SetProgSink(NULL); // detach download from document's load progress
                    pLink->SetCssCtx( NULL );           // No reason to hold on to the data anymore
                }
                else
                {
                    TraceTag( (tagSharedStyleSheet, "Notify [%p]-- PARSEDONE-[%p] -- detach download [%p]\n", this, GetSSS(), _pCssCtx));
                    // Relayout the doc; new rules may have been loaded (e.g. DWNLOAD_COMPLETE),
                    // or we may have killed off rules w/o re-rendering before starting the load
                    // for this sheet (e.g. changing src of an existing sheet).
                    IGNORE_HR( pMarkup->OnCssChange( /*fStable = */ FALSE, /* fRecomputePeers = */ TRUE) );

                    // notify parent that this is done
                    CheckImportStatus();    // Needed e.g. if all imports were cached, their OnChan's would all be called
                                            // before parsing finished.
                    pMarkup->UnblockScriptExecution(&_dwScriptCookie);
                    
                    _pCssCtx->SetProgSink(NULL); // detach download from document's load progress
                    SetCssCtx(NULL);
                }
            }
            else
            {
                TraceTag( (tagSharedStyleSheet, "Notify [%p] is not one that is waitting -- has gone through DoParsing for [%p]  yet", this, GetSSS()) );
            }
            break;
    
    default:
        break;
    }

    RRETURN(hr);
}


//*********************************************************************
//  CStyleSheet::SetReadyState()
//      Handles passing readystate changes to our parent element, which
//  may cause our parent element to fire the onreadystatechange event.
//*********************************************************************
HRESULT CStyleSheet::SetReadyState( long readyState )
{
    TraceTag( (tagStyleSheet, "[%p] set readystate [%x] ready state is %x", this, readyState, READYSTATE_COMPLETE) );
    if ( !_pParentElement )
        return S_OK;    // In case we're a user stylesheet

    if (_pParentElement->Tag() == ETAG_STYLE)
    {
        CStyleElement *pStyle = DYNCAST( CStyleElement, _pParentElement );
        return pStyle->SetReadyStateStyle( readyState );
    }
    else
    {
        Assert( _pParentElement->Tag() == ETAG_LINK );
        CLinkElement *pLink = DYNCAST( CLinkElement, _pParentElement );
        return pLink->SetReadyStateLink( readyState );
    }
}

//*********************************************************************
//  CStyleSheet::CheckImportStatus()
//  Checks whether all our imports have come in, and notify our parent
//  if necessary.  This ultimately includes causing our parent element
//  to fire events.
//*********************************************************************
void CStyleSheet::CheckImportStatus( void )
{
    // If all stylesheets nested below us are finished d/ling..
    if ( _eParsingStatus != CSSPARSESTATUS_PARSING && (_nExpectedImports == _nCompletedImports) )
    {
        if ( IsAnImport() )
        {
            // If we've hit a break in our parentSS chain, just stop..
            if ( !IsDisconnectedFromParentSS() )
            {
                // Notify our parent that we are finished.
                _pParentStyleSheet->CheckImportStatus();
            }
        }
        else
        {
            // We are a top-level SS!  Since everything below us is
            // finished, we can fire.
            SetReadyState( READYSTATE_COMPLETE );
        }
    }
}

//*********************************************************************
//  CStyleSheet::StopDownloads
//      Halt all downloading of stylesheets, including all nested imports.
//*********************************************************************
void CStyleSheet::StopDownloads( BOOL fReleaseCssCtx )
{
    long z;
    CStyleSheet *pSS;

    if ( _pCssCtx )
    {
        CMarkup *pMarkup;

        TraceTag( (tagStyleSheet, "StopDownloads [%p]-- while we are still holding _pCssCtx [%p] for [%p]\n", this, _pCssCtx, GetSSS()));
        Assert( _fParser == FALSE );
        EnsureCopyOnWrite( /*fDeatchOnly*/ TRUE, /*fWaitForCompleteion*/FALSE);
        
       _pCssCtx->SetProgSink(NULL); // detach download from document's load progress
        _pCssCtx->SetLoad( FALSE, NULL, FALSE );

        pMarkup = _pParentElement->GetMarkup();
        if(pMarkup)
            pMarkup->Doc()->LeaveStylesheetDownload(&_dwStyleCookie);
        
         // This sheet has finished, one way or another.
         if ( IsAnImport() )
             _pParentStyleSheet->_nCompletedImports++;
         _eParsingStatus = CSSPARSESTATUS_DONE;   // Need to make sure we'll walk up to our parent in CheckImportStatus()

        if ( fReleaseCssCtx )
            SetCssCtx(NULL);
     }


    if ( _pImportedStyleSheets )
    {
        for ( z=0 ; (pSS=(_pImportedStyleSheets->Get(z))) != NULL ; ++z)
            pSS->StopDownloads( fReleaseCssCtx );
    }

#ifndef NO_FONT_DOWNLOAD
    // If we initiated any downloads of embedded fonts, stop those too
    {
        int n = _apFontFaces.Size();
        int i;
        CFontFace *pFace;

        for( i=0; i < n; i++)
        {
            pFace = ((CFontFace **)(_apFontFaces))[ i ];
            Assert( pFace->ParentStyleSheet() == this );
            pFace->StopDownloads();
        }
    }
#endif // NO_FONT_DOWNLOAD
}

//*********************************************************************
//  CStyleSheet::OMGetOMRule
//      Returns the automation object for a given rule number, creating
//  the automation object if necessary and caching it in _apOMRules.
//  If the index is out of range, may return NULL.
//*********************************************************************
HRESULT CStyleSheet::OMGetOMRule( long lIdx, IHTMLStyleSheetRule **ppSSRule )
{
    HRESULT  hr = S_OK;
    unsigned long     lRule;
    Assert( ppSSRule );

    *ppSSRule = NULL;
    if ( lIdx < 0 || (unsigned int)lIdx >= GetNumRules())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(OMGetOMRuleInternal(lIdx, &lRule));
    if (hr)
        goto Cleanup;

    hr = THR(_apOMRules[lRule]->QueryInterface( IID_IHTMLStyleSheetRule, (void **)ppSSRule ));
    
Cleanup:
    RRETURN(hr);
}


//
//   lIdx is 0 based
//
HRESULT 
CStyleSheet::OMGetOMRuleInternal(unsigned long lIdx, unsigned long *plRule)
{
    HRESULT    hr = S_OK;
    int  iMaxIdx;

    //
    // _apOMRules is a virtual array its size equals to the highest 
    // accessed rule idx. It will grow (leap) if a higher index 
    // rule is accessed.
    //
    Assert(plRule);
    *plRule = 0;

    Assert(lIdx < GetNumRules());
    iMaxIdx = _apOMRules.Size() - 1;
    if (iMaxIdx < 0 || lIdx > (unsigned int)iMaxIdx)    // out-of-bound
    {
        _apOMRules.Grow(lIdx+1);
        for (int n=iMaxIdx+1; n < _apOMRules.Size(); n++)
        {
            _apOMRules[n] = NULL;
        }
        _apOMRules.Insert(lIdx, NULL);
        Assert(!_apOMRules[lIdx]);
    }

    if (_apOMRules[lIdx] == NULL)
    {
        CStyleRule  *pSR = GetSSS()->GetRule((CStyleRuleID)(lIdx + 1));
        if (pSR)
        {
            CStyleSheetRule *pRE = new CStyleSheetRule( this, pSR->GetRuleID(), pSR->GetElementTag() );
            if (!pRE)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            _apOMRules[lIdx] = pRE;
        }
        else
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        
    }
    *plRule = lIdx;
    
Cleanup:
    RRETURN(hr);
}



//*********************************************************************
//  CStyleSheet::EnSureCopyOnWrite
// 
//  fDeatchOnly means we will not try to reconstruct OM rules, imports, Fonts, Pages
//  it generally means we are going to discard everything, and start from
//  scratch again. This could happen such as put_href is called. 
//
//*********************************************************************
HRESULT
CStyleSheet::EnsureCopyOnWrite(BOOL fDetachOnly, BOOL fWaitForCompletion)
{
    HRESULT  hr = S_OK;

    TraceTag( (tagSharedStyleSheet, "EnsureCoypOnWrite - fDetachOnly [%d]", fDetachOnly) );
    if (GetSSS()->_pManager)    // if this is shared
    {
        //
        // Give the fact that there is no script events come in during parsing time
        // _fComplete == FALSE means this function is called during parsing. There
        // is nothing to worry about...
        //
        if (fWaitForCompletion && !GetSSS()->_fComplete)  
            goto Cleanup;

#if DBG == 1        
        if (fWaitForCompletion)
        {
            Assert( GetSSS()->_fComplete );
            Assert( !GetSSS()->_fParsing );
            Assert( GetSSS()->_lReserveCount >= 0 );
        }
#endif     
        if (GetSSS()->_apSheetsList.Size() > 1)     // shared
        {
            CSharedStyleSheet  *pSSS;

            TraceTag( (tagSharedStyleSheet, "EnsureCoypOnWrite - shared, need to clone lReserveCount [%d] _spSheetsList.Size [%d]", GetSSS()->_lReserveCount, GetSSS()->_apSheetsList.Size()) );
            WHEN_DBG( DumpHref(GetAbsoluteHref() ) );
            hr = THR( GetSSS()->Clone(&pSSS, /*fNoContent=*/fDetachOnly) ); // this will set ref to 1
            if (hr)
                goto Cleanup;

            pSSS->_pManager = NULL;     // this is our own private copy
            hr = THR( AttachLate( pSSS, /*fReconstruct*/!fDetachOnly, /*fIsReplacement*/TRUE) );
            pSSS->Release();      // to offset the addref by Clone 
            if (hr)
                goto Cleanup;
            
        }
        else if (GetSSS()->_pManager)
        {
            WHEN_DBG( Assert( GetSSS()->_lReserveCount == 0 ) );
            //
            // remove this from collection as this can no longer be shared
            //
            TraceTag( (tagSharedStyleSheet, "EnsureCoypOnWrite - non-shared, simply remove from collection") );
            WHEN_DBG( DumpHref(GetAbsoluteHref() ) );
            hr = THR( GetSSS()->_pManager->RemoveSharedStyleSheet(GetSSS()) );
            GetSSS()->_pManager = NULL;
        }
        GetSSS()->_fModified = TRUE;
    }
#if DBG == 1
    else
    {
        AssertSz( GetSSS()->_apSheetsList.Size() <= 1, 
            "Shared Style Sheet that is not in the shared array - "
            "probably CDoc is released when there is outstanding stylesheet");
    }
#endif
Cleanup:
    RRETURN(hr);
}



#if 0
//*********************************************************************
// CStyleSheet::Invoke
// Provides access to properties and members of the object
//
// Arguments:   [dispidMember] - Member id to invoke
//              [riid]         - Interface ID being accessed
//              [wFlags]       - Flags describing context of call
//              [pdispparams]  - Structure containing arguments
//              [pvarResult]   - Place to put result
//              [pexcepinfo]   - Pointer to exception information struct
//              [puArgErr]     - Indicates which argument is incorrect
//
// We override this to support copy-on-write for write access 
//*********************************************************************

STDMETHODIMP
CStyleSheet::InvokeEx(DISPID       dispidMember,
                      LCID         lcid,
                      WORD         wFlags,
                      DISPPARAMS * pdispparams,
                      VARIANT *    pvarResult,
                      EXCEPINFO *  pexcepinfo,
                      IServiceProvider *pSrvProvider)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;

    // do copy-on-write if necessary
    Assert( DISPID_CStyleSheet_addImport    ==   DISPID_CStyleSheet_id + 1 );
    Assert( DISPID_CStyleSheet_addRule      ==   DISPID_CStyleSheet_addImport + 1);
    Assert( DISPID_CStyleSheet_removeImport ==   DISPID_CStyleSheet_addRule + 1);
    Assert( DISPID_CStyleSheet_removeRule   ==   DISPID_CStyleSheet_removeImport + 1);
    Assert( DISPID_CStyleSheet_media        ==   DISPID_CStyleSheet_removeRule + 1);
    Assert( DISPID_CStyleSheet_cssText      ==   DISPID_CStyleSheet_media + 1);
    Assert( DISPID_CStyleSheet_rules        ==   DISPID_CStyleSheet_cssText + 1);
    
    if ( dispidMember > DISPID_CStyleSheet_id 
        && dispidMember < DISPID_CStyleSheet_cssText
        )
    {
        if ( !( dispidMember >= DISPID_CStyleSheet_media 
                && (wFlags & DISPATCH_PROPERTYGET) 
              )
           )  // get for media/cssText does need copy on write
        {
            if (!SUCCEEDED(EnsureCopyOnWrite()))
                goto Cleanup;
        }
    }  

    // CBase knows how to handle expando
    hr = THR_NOTRACE(super::InvokeEx( dispidMember,
                                    lcid,
                                    wFlags,
                                    pdispparams,
                                    pvarResult,
                                    pexcepinfo,
                                    pSrvProvider));
                                    
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}
#endif    


//*********************************************************************
//  CStyleSheet::title
//      IHTMLStyleSheet interface method
//*********************************************************************

HRESULT
CStyleSheet::get_title(BSTR *pBSTR)
{
    HRESULT hr = S_OK;

    if (!pBSTR)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pBSTR = NULL;

    Assert( "All sheets must have a parent element!" && _pParentElement );

    // Imports don't support the title property; just return NULL string.
    if ( IsAnImport() )
        goto Cleanup;

    hr = _pParentElement->get_PropertyHelper( pBSTR, (PROPERTYDESC *)&s_propdescCElementtitle );

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

HRESULT
CStyleSheet::put_title(BSTR bstr)
{
    HRESULT hr = S_OK;

    Assert( "All sheets must have a parent element!" && _pParentElement );

    // We don't support the title prop on imports.
    if ( IsAnImport() )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( EnsureCopyOnWrite(/*fDetachOnly*/FALSE) );
    if (hr)
        goto Cleanup;
    hr = _pParentElement->put_StringHelper( bstr, (PROPERTYDESC *)&s_propdescCElementtitle );

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::media
//      IHTMLStyleSheet interface method
//*********************************************************************
HRESULT
CStyleSheet::get_media(BSTR *pBSTR)
{
    HRESULT hr = S_OK;

    if (!pBSTR)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pBSTR = NULL;

    Assert( "All sheets must have a parent element!" && _pParentElement );

    if (_pParentElement->Tag() == ETAG_STYLE)
    {
        CStyleElement *pStyle = DYNCAST( CStyleElement, _pParentElement );
        hr = pStyle->get_PropertyHelper( pBSTR, (PROPERTYDESC *)&s_propdescCStyleElementmedia );
    }
    else
    {
        Assert( _pParentElement->Tag() == ETAG_LINK );
        CLinkElement *pLink = DYNCAST( CLinkElement, _pParentElement );
        hr = pLink->get_PropertyHelper( pBSTR, (PROPERTYDESC *)&s_propdescCLinkElementmedia );
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

HRESULT
CStyleSheet::put_media(BSTR bstr)
{
    HRESULT hr = S_OK;

    Assert( "All sheets must have a parent element!" && _pParentElement );

    hr = THR( EnsureCopyOnWrite(/*fDetachOnly*/FALSE) );
    if (hr)
        goto Cleanup;
    
    if (_pParentElement->Tag() == ETAG_STYLE)
    {
        CStyleElement *pStyle = DYNCAST( CStyleElement, _pParentElement );
        hr = pStyle->put_StringHelper( bstr, (PROPERTYDESC *)&s_propdescCStyleElementmedia );
    }
    else
    {
        Assert( _pParentElement->Tag() == ETAG_LINK );
        CLinkElement *pLink = DYNCAST( CLinkElement, _pParentElement );
        hr = pLink->put_StringHelper( bstr, (PROPERTYDESC *)&s_propdescCLinkElementmedia );
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::get_cssText
//      IHTMLStyleSheet interface method
//*********************************************************************
HRESULT
CStyleSheet::get_cssText(BSTR *pBSTR)
{
    HRESULT hr = S_OK;
    CStr cstr;
    CMarkup *pMarkup;
    TCHAR *pAbsoluteHref;

    if (!pBSTR)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pMarkup = GetMarkup();
    pAbsoluteHref = GetAbsoluteHref();
    if (pMarkup && pAbsoluteHref && !pMarkup->AccessAllowed(pAbsoluteHref))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

    *pBSTR = NULL;

    hr = GetString( &cstr );

    if ( hr != S_OK )
        goto Cleanup;

    hr = cstr.AllocBSTR( pBSTR );

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::put_cssText
//      IHTMLStyleSheet interface method
//*********************************************************************
HRESULT
CStyleSheet::put_cssText(BSTR bstr)
{
    WHEN_DBG( Assert(DbgIsValid()) );

    HRESULT hr = S_OK;
    CElement *pParentElement = _pParentElement;
    CStyleSheet *pParentSS = _pParentStyleSheet;
    CMarkup *pMarkup;
    BOOL fDisabled = _fDisabled;
    CCSSParser *parser;
    Assert(pParentElement);

    hr = THR( EnsureCopyOnWrite(TRUE /*fDetachOnly*/) );
    if (hr)
        goto Cleanup;
    
    // Remove all the rules
    hr = ChangeStatus( CS_CLEARRULES, FALSE, NULL );   // disabling, detached from tree, no re-render
    if ( hr )
        goto Cleanup;

    GetSSS()->_fParsing   = FALSE;
    GetSSS()->_fComplete = FALSE;
    GetSSS()->_fModified  = TRUE;
    
    // Now restore a few bits of information that don't actually change for us.
    _pParentElement = pParentElement;
    _pParentStyleSheet = pParentSS;
    _fDisabled = fDisabled;

    // Parse the new style string!
    parser = new CCSSParser( this, NULL, IsXML(), IsStrictCSS1());
    if ( !parser )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    parser->Open();
    parser->Write( bstr, _tcslen( bstr ) );
    parser->Close();
    delete parser;

    // Reformat and rerender.

    pMarkup = pParentElement->GetMarkup();
    if (pMarkup)
        hr = THR( pMarkup->OnCssChange(/*fStable = */ TRUE, /* fRecomputePeers = */ TRUE) );

Cleanup:
    RRETURN( hr );
}

//*********************************************************************
//  CStyleSheet::parentStyleSheet
//      IHTMLStyleSheet interface method
//*********************************************************************

HRESULT
CStyleSheet::get_parentStyleSheet(IHTMLStyleSheet** ppHTMLStyleSheet)
{
    HRESULT hr = S_OK;

    if (!ppHTMLStyleSheet)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppHTMLStyleSheet = NULL;

    // NOTE: Just return self if we're disconnected?
    if ( IsAnImport() && !IsDisconnectedFromParentSS() )
    {
        hr = _pParentStyleSheet->QueryInterface(IID_IHTMLStyleSheet,
                                              (void**)ppHTMLStyleSheet);
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::owningElement
//      IHTMLStyleSheet interface method
//*********************************************************************

HRESULT
CStyleSheet::get_owningElement(IHTMLElement** ppHTMLElement)
{
    HRESULT hr = S_OK;

    if (!ppHTMLElement)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppHTMLElement = NULL;

    Assert( "All sheets must have a parent element!" && _pParentElement );

    hr = _pParentElement->QueryInterface(IID_IHTMLElement,
                                          (void**)ppHTMLElement);

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::disabled
//      IHTMLStyleSheet interface method
//*********************************************************************

HRESULT
CStyleSheet::get_disabled(VARIANT_BOOL* pvbDisabled)
{
    HRESULT hr = S_OK;

    if (!pvbDisabled)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pvbDisabled = (_fDisabled ? VB_TRUE : VB_FALSE);

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

HRESULT
CStyleSheet::put_disabled(VARIANT_BOOL vbDisabled)
{
    HRESULT hr = S_OK;
    DWORD   dwAction;

    Assert( DbgIsValid() );

    // If the enable/disable status isn't changing, do nothing.
    if ( (_fDisabled ? VB_TRUE : VB_FALSE) != vbDisabled )
    {
        dwAction = (vbDisabled ? 0 : CS_ENABLERULES);   // 0 means disable rules
        hr = ChangeStatus( dwAction, TRUE, NULL);   // Force a rerender

        // We have to stuff these into the AA by hand in order to avoid
        // firing an OnPropertyChange (which would put us into a recursive loop).
        if ( _pParentElement->Tag() == ETAG_STYLE )
            hr = THR(s_propdescCElementdisabled.b.SetNumber( _pParentElement,
                     CVOID_CAST(_pParentElement->GetAttrArray()), vbDisabled, 0 ));
        else
        {
            Assert( _pParentElement->Tag() == ETAG_LINK );
            hr = THR(s_propdescCElementdisabled.b.SetNumber( _pParentElement,
                     CVOID_CAST(_pParentElement->GetAttrArray()), vbDisabled, 0 ));
        }
    }

    RRETURN( SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::readonly
//      IHTMLStyleSheet interface method
//*********************************************************************

HRESULT
CStyleSheet::get_readOnly(VARIANT_BOOL* pvbReadOnly)
{
    HRESULT hr = S_OK;

    if (!pvbReadOnly)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    Assert( "All sheets must have a parent element!" && _pParentElement );

    // Imports are readonly.  Also, if we have a parent element of type LINK, we must
    // be a linked stylesheet, and thus readonly.

    *pvbReadOnly = ( IsAnImport() || (_pParentElement->Tag() == ETAG_LINK) ) ?
                        VB_TRUE : VB_FALSE;

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::imports
//      IHTMLStyleSheet interface method
//*********************************************************************

HRESULT
CStyleSheet::get_imports(IHTMLStyleSheetsCollection** ppHTMLStyleSheetsCollection)
{
    HRESULT hr = S_OK;

    if (!ppHTMLStyleSheetsCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppHTMLStyleSheetsCollection = NULL;

    // If we don't already have an imports collection instantiated, do so now.
    if ( !_pImportedStyleSheets )
    {
        // Imported stylesheets don't manage their own rules.
        _pImportedStyleSheets = new CStyleSheetArray( this, _pSSAContainer, _sidSheet );
        Assert( "Failure to allocate imported stylesheets array! (informational)" && _pImportedStyleSheets );
        if (!_pImportedStyleSheets)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        if (_pImportedStyleSheets->_fInvalid)
        {
            hr = E_OUTOFMEMORY;
            _pImportedStyleSheets->CBase::PrivateRelease();
            goto Cleanup;
        }
    }

    hr = _pImportedStyleSheets->QueryInterface(IID_IHTMLStyleSheetsCollection,
                                            (void**)ppHTMLStyleSheetsCollection);

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::rules
//      IHTMLStyleSheet interface method
//*********************************************************************
HRESULT
CStyleSheet::get_rules(IHTMLStyleSheetRulesCollection** ppHTMLStyleSheetRulesCollection)
{
    HRESULT hr = S_OK;
    CMarkup *pMarkup;
    TCHAR *pAbsoluteHref;

    if (!ppHTMLStyleSheetRulesCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pMarkup = GetMarkup();
    pAbsoluteHref = GetAbsoluteHref();

    static int fRunningInBrowser = -1;

    if (fRunningInBrowser == -1)
        fRunningInBrowser = GetModuleHandle(TEXT("iexplore.exe")) != NULL 
            || GetModuleHandle(TEXT("explorer.exe")) != NULL
            || GetModuleHandle(TEXT("msn6.exe")) != NULL;
    
    if ( fRunningInBrowser == 1 && pMarkup && pAbsoluteHref && !pMarkup->AccessAllowed(pAbsoluteHref))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

    *ppHTMLStyleSheetRulesCollection = NULL;

    hr = THR( EnsureCopyOnWrite(/*fDetachOnly*/FALSE) );     // someone might be writing to it...
    if (hr)
        goto Cleanup;
    
    // If we don't already have a rules collection instantiated, do so now.
    if ( !_pOMRulesArray )
    {
        _pOMRulesArray = new CStyleSheetRuleArray( this );
        if ( !_pOMRulesArray )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = _pOMRulesArray->QueryInterface( IID_IHTMLStyleSheetRulesCollection,
                                            (void**)ppHTMLStyleSheetRulesCollection);

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::href
//      IHTMLStyleSheet interface method
//*********************************************************************

HRESULT
CStyleSheet::get_href(BSTR *pBSTR)
{
    HRESULT hr = S_OK;

    if (!pBSTR)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pBSTR = NULL;

    Assert( "All sheets must have a parent element!" && _pParentElement );

    // If we're an import..
    if ( IsAnImport() )
    {
        hr = _cstrImportHref.AllocBSTR( pBSTR );
    }
    else if ( _pParentElement->Tag() == ETAG_LINK ) // .. if we're a <link>
    {
        CLinkElement *pLink = DYNCAST( CLinkElement, _pParentElement );
        hr = pLink->get_UrlHelper( pBSTR, (PROPERTYDESC *)&s_propdescCLinkElementhref );
    }
    else    // .. we must be a <style>, and have no href.
    {
        Assert( "Bad element type associated with stylesheet!" && _pParentElement->Tag() == ETAG_STYLE );
        goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

HRESULT
CStyleSheet::put_href(BSTR bstr)
{
    HRESULT hr = S_OK;

    // Are we an import?
    if ( IsAnImport() )
    {
        if ( _pParentStyleSheet->IsAnImport() || (_pParentElement->Tag() == ETAG_LINK) )
        {
            // If we're an import, but our parent isn't a top-level stylesheet,
            // (i.e. our parent is also an import), or if we're an import of a linked
            // stylesheet then our href is readonly.
            goto Cleanup;
        }

        CStyleSheetCtx  ctxSS;
        ctxSS._szUrl = (LPCTSTR)bstr;

        hr = THR( EnsureCopyOnWrite(/*fDetachOnly*/FALSE) );
        if (hr)
            goto Cleanup;
        hr = LoadFromURL( &ctxSS );
        if ( hr )
            goto Cleanup;

        _cstrImportHref.Set( bstr );
    }
    // Are we a linked stylesheet?
    else if ( _pParentElement->Tag() == ETAG_LINK )
    {        
        CLinkElement *pLink = DYNCAST( CLinkElement, _pParentElement );
        hr = pLink->put_UrlHelper( bstr, (PROPERTYDESC *)&s_propdescCLinkElementhref );
    }
    // Otherwise we must be a <style>, and have no href.
    else
    {
        Assert( "Bad element type associated with stylesheet!" && _pParentElement->Tag() == ETAG_STYLE );
        goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::get_type
//      IHTMLStyleSheet interface method
//*********************************************************************

HRESULT
CStyleSheet::get_type(BSTR *pBSTR)
{
    HRESULT hr = S_OK;

    if (!pBSTR)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pBSTR = NULL;

    Assert( _pParentElement );

    // NOTE: we currently return the top-level SS's HTML type attribute for imports;
    // this is OK for now since we only support text/css, but in theory stylesheets of
    // one type could import stylesheets of a different type.

    if ( _pParentElement->Tag() == ETAG_STYLE )
    {
        CStyleElement *pStyle = DYNCAST( CStyleElement, _pParentElement );
        hr = pStyle->get_PropertyHelper( pBSTR, (PROPERTYDESC *)&s_propdescCStyleElementtype );
    }
    else if ( _pParentElement->Tag() == ETAG_LINK )
    {
        CLinkElement *pLink = DYNCAST( CLinkElement, _pParentElement );
        hr = pLink->get_PropertyHelper( pBSTR, (PROPERTYDESC *)&s_propdescCLinkElementtype );
    }
    else
    {
        Assert( "Bad element type associated with stylesheet!" && FALSE );
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::get_id
//      IHTMLStyleSheet interface method
//*********************************************************************

HRESULT
CStyleSheet::get_id(BSTR *pBSTR)
{
    HRESULT hr = S_OK;

    if (!pBSTR)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pBSTR = NULL;

    Assert( _pParentElement );

    // Imports have no id; we don't return the parent element's id
    // because that would suggest you could use the id to get to the
    // import (when it would actually get you to the top-level SS).
    if ( IsAnImport() )
    {
        goto Cleanup;
    }

    hr = THR( _pParentElement->get_PropertyHelper( pBSTR, (PROPERTYDESC *)&s_propdescCElementid ) );

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::addImport
//      IHTMLStyleSheet interface method
//*********************************************************************

HRESULT
CStyleSheet::addImport(BSTR bstrURL, long lIndex, long *plNewIndex)
{
    HRESULT hr = S_OK;

    if ( !plNewIndex )
    {
        hr = E_POINTER;

        goto Cleanup;
    }

    // Return value of -1 indicates failure to insert.
    *plNewIndex = -1;

    // Check for zero-length URL, which we ignore.
    if ( FormsStringLen(bstrURL) == 0 )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // If requested index out of bounds, just append the import
    if ( (lIndex < -1) ||
         (_pImportedStyleSheets && (lIndex > _pImportedStyleSheets->Size())) ||
         (!_pImportedStyleSheets && (lIndex > 0)) )
    {
        lIndex = -1;
    }

    hr = THR( EnsureCopyOnWrite(/*fDetachOnly*/FALSE) );
    if (hr)
        goto Cleanup;
 
    hr = AddImportedStyleSheet( (LPTSTR)bstrURL, /* we are not parsing */FALSE, lIndex, plNewIndex);
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

HRESULT CStyleSheet::removeImport( long lIndex )
{
    HRESULT hr = S_OK;

    CStyleSheet *pImportedStyleSheet;

    // If requested index out of bounds, error out
    if ( !_pImportedStyleSheets || (lIndex < 0) || (lIndex >= _pImportedStyleSheets->Size()))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( EnsureCopyOnWrite(/*fDetachOnly*/FALSE) );
    if (hr)
        goto Cleanup;
    
    pImportedStyleSheet = _pImportedStyleSheets->_aStyleSheets[lIndex];
    pImportedStyleSheet->StopDownloads(TRUE);
    hr = _pImportedStyleSheets->ReleaseStyleSheet( pImportedStyleSheet, TRUE );

    if (!hr)
    {
        CSharedStyleSheet::CImportedStyleSheetEntry  *pEntry;
        pEntry = (CSharedStyleSheet::CImportedStyleSheetEntry *)(GetSSS()->_apImportedStyleSheets) + lIndex;
        if (pEntry)
        {
            pEntry->_cstrImportHref.Free();
            GetSSS()->_apImportedStyleSheets.Delete(lIndex);
        }
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::addRule
//      IHTMLStyleSheet interface method
//*********************************************************************

HRESULT
CStyleSheet::addRule(BSTR bstrSelector, BSTR bstrStyle, long lIndex, long *plNewIndex)
{
    HRESULT         hr = E_OUTOFMEMORY;
    CStyleSelector *pNewSelector = NULL;
    CStyleSelector *pChildSelector = NULL;
    CStyleRule     *pNewRule = NULL;
    CCSSParser     *ps = NULL;
    Tokenizer       tok;
    Tokenizer::TOKEN_TYPE tt;

    if (!plNewIndex || !bstrSelector || !bstrStyle)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *plNewIndex = -1;

    if (!(*bstrSelector) || !(*bstrStyle))
    {
        // Strings shouldn't be empty
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    tok.Init(bstrSelector, FormsStringLen(bstrSelector));

    tt = tok.NextToken();

    while (tt != Tokenizer::TT_EOF)
    {
        // the parent element may have been detached, is there a problem here?
        pChildSelector = new CStyleSelector(tok, pNewSelector, IsStrictCSS1(), IsXML());
        if (!pChildSelector)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pNewSelector = pChildSelector;

        tt = tok.TokenType();

        // We do not support grouping of selectors through addRule, only contexttual
        if (tt == Tokenizer::TT_Comma)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    if (!pNewSelector)
    {   // Selector was invalid or empty
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pNewRule = new CStyleRule(pNewSelector);
    if ( !pNewRule )
        goto Cleanup;

    // Actually parse the style text
    ps = new CCSSParser(this, pNewRule->GetRefStyleAA(), IsXML(), IsStrictCSS1(), eSingleStyle, &CStyle::s_apHdlDescs,
                        this, HANDLEPROP_SET|HANDLEPROP_VALUE );
    if ( !ps )
        goto Cleanup;

    ps->Open();
    ps->Write((LPTSTR)bstrStyle, FormsStringLen(bstrStyle));
    ps->Close();

    delete ps;

    hr = THR( EnsureCopyOnWrite(/*fDetachOnly*/FALSE) );
    if (hr)
        goto Cleanup;

    // Add the rule to our stylesheet, and get the index
    hr = AddStyleRule(pNewRule, TRUE, lIndex);
    // The AddStyleRule call will have deleted the new rule for us, so we're OK.
    if (hr)
    {
        pNewRule = NULL;    // already deleted by AddStyleRule _even when it fails_
        goto Cleanup;
    }

    hr = THR(_pParentElement->OnCssChange(/*fStable = */ TRUE, /* fRecomputePeers = */ TRUE));

Cleanup:
    if (hr)
    {
        if (pNewSelector)
            delete pNewSelector;
        if (pNewRule)
            delete pNewRule;
    }

    RRETURN(SetErrorInfo(hr));
}


//*********************************************************************
//  CStyleSheet::removeRule
//      IHTMLStyleSheet interface method
//      This method remove a rule from CStyleRuleArray in the hash table
//  as well as the CRuleEntryArray.
//*********************************************************************
HRESULT CStyleSheet::removeRule( long lIndex )
{
    Assert( DbgIsValid() );

    HRESULT     hr = S_OK;

    Assert( "Stylesheet must have a container!" && _pSSAContainer );

    // Make sure the index is valid.
    if (  lIndex < 0  || (unsigned long)lIndex >= GetNumRules()  )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( EnsureCopyOnWrite(/*fDetachOnly*/FALSE) );
    if (hr)
        goto Cleanup;
    
    //
    // Remove the rules in rule-store.
    //
    hr = THR(RemoveStyleRule(lIndex));
    if (hr)
        goto Cleanup;

    // Force update of element formats to account for new set of rules
    if (GetRootContainer()->_pOwner)
    {
        CMarkup *pMarkup = DYNCAST(CMarkup, GetRootContainer()->_pOwner);  // rule manager's owner is always the markup

        if (pMarkup)
            IGNORE_HR( pMarkup->ForceRelayout() );
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT CStyleSheet::GetString( CStr *pResult )
{
    RRETURN(GetSSS()->GetString( this, pResult));
}


//*********************************************************************
//  CStyleSheet::pages
//      IHTMLStyleSheet2 interface property
//*********************************************************************

HRESULT
CStyleSheet::get_pages(IHTMLStyleSheetPagesCollection** ppHTMLStyleSheetPagesCollection)
{
    HRESULT hr = S_OK;

    if (!ppHTMLStyleSheetPagesCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppHTMLStyleSheetPagesCollection = NULL;

    // Create the "pages" array if we don't already have one.
    if ( !_pPageRules )
    {
        _pPageRules = new CStyleSheetPageArray( this );
        // The stylesheet owns the ref on the page array that it will release when it passivates.
        // The page array holds a subref back on the stylesheet.
    }

    if ( _pPageRules )
    {
        hr = _pPageRules->QueryInterface(IID_IHTMLStyleSheetPagesCollection,
                                            (void**)ppHTMLStyleSheetPagesCollection);
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//*********************************************************************
//  CStyleSheet::addPageRule
//      IHTMLStyleSheet2 interface method
//*********************************************************************

HRESULT
CStyleSheet::addPageRule(BSTR bstrSelector, BSTR bstrStyle, long lIndex, long *plNewIndex)
{
    HRESULT         hr = E_NOTIMPL;

    RRETURN(SetErrorInfo(hr));
}



//*********************************************************************
//  CStyleSheet::GetRule
//      This should only be called from OM
//*********************************************************************
CStyleRule *CStyleSheet::OMGetRule( ELEMENT_TAG eTag, CStyleRuleID ruleID )
{

    // Only look up OM array
    DWORD  dwRule = ruleID.GetRule();

    if (dwRule <= GetNumRules())
    {
        CStyleRule *pRule = GetRule(ruleID);
        if (pRule && pRule->GetElementTag() == eTag)
        {
            return pRule;
        }
    }
    return NULL;
};



CStyleRule  *CStyleSheet::GetRule(CStyleRuleID   ruleID)
{
    Assert( ruleID.GetSheet() == 0  || ruleID.GetSheet() == _sidSheet);
    
    unsigned int nRule = ruleID.GetRule();
    if (nRule <= GetNumRules())
    {
        return GetSSS()->GetRule((CStyleRuleID)nRule);
    }
    Assert("Try to GetRule that is not in current style sheet" && FALSE);
    return NULL;
}



//*********************************************************************
//  CStyleSheet::DbgIsValid
//      Debug functions
//*********************************************************************
#if DBG==1
BOOL 
CStyleSheet::DbgIsValid()
{
    // 
    // Make sure the automation array is okay
    //
    CStyleSheetRule **pRules;
    int i;
    BOOL fRet = TRUE;

    for (i = 0, pRules = _apOMRules;
         i < _apOMRules.Size();
         i++, pRules++
         )
    {
        if (*pRules)
        {
            CStyleRule  *pRule;
            CStyleRuleID sidRule = (CStyleRuleID)((*pRules)->_dwID);
            unsigned int nRule = sidRule.GetRule();

            if ( (*pRules)->_pStyleSheet != this)
            {   
                Assert( "automation rules contain one rule that belongs to different StyleSheet" && FALSE );
                fRet = FALSE;
                goto Cleanup;
            }
            
            if ( sidRule.GetSheet() != 0 ||
                 nRule > GetNumRules() ||
                 nRule != (unsigned int)(i+1)
                )
            {
                Assert( "automation rules contain one rule that has invalid _dwID" && FALSE );
                fRet = FALSE;
                goto Cleanup;
            }


            pRule = (CStyleRule *)(GetSSS()->_apRulesList[nRule - 1]);
            Assert(pRule);
            
            if (pRule->GetElementTag() != (*pRules)->_eTag)
            {
                Assert( "automation rule with different _eTag -- out-of-sync"&&FALSE );
                fRet = FALSE;
                goto Cleanup;
            }
        }
    }

    //
    // Now make sure SSS is valid
    //
    fRet = GetSSS()->DbgIsValid();
Cleanup:
    Assert( fRet && "CStyleSheet::DbgIsValid -- not valid");
    return fRet;
}



VOID CStyleSheet::Dump()
{
    if (!InitDumpFile())
        return;
    
    Dump(FALSE);
    
    CloseDumpFile();
}

VOID CStyleSheet::Dump(BOOL fRecursive)
{
    WriteHelp(g_f, _T("-0x<0x>:<1s>\r\n"), _sidSheet, GetSSS()->_achAbsoluteHref);
    if (_pImportedStyleSheets)
    {
        _pImportedStyleSheets->Dump(fRecursive);
    }
    WriteString(g_f, _T("\r\n"));
    GetSSS()->Dump(this);
}

#endif



//---------------------------------------------------------------------
//  Class Declaration:  CStyleID
//
//  A 32-bit cookie that uniquely identifies a style rule's position
//  in the cascade order (i.e. it encodes the source order within its
//  containing stylesheet, as well as the nesting depth position of
//  its containing stylesheet within the entire stylesheet tree.
//
//  The source order of the rule within the sheet is encoded in the
//  Rules field (12 bits).
//
//  We allow up to MAX_IMPORT_NESTING (4) levels of @import nesting
//  (including the topmost HTML document level).  The position within
//  each nesting level is encoded in 5 bits.
//
//---------------------------------------------------------------------
CStyleID::CStyleID(const unsigned long l1, const unsigned long l2,
                    const unsigned long l3, const unsigned long l4, const unsigned long r)
{
    Assert( "Maximum of 31 stylesheets per level!" && l1 <= MAX_SHEETS_PER_LEVEL && l2 <= MAX_SHEETS_PER_LEVEL && l3 <= MAX_SHEETS_PER_LEVEL && l4 <= MAX_SHEETS_PER_LEVEL );
    Assert( "Maximum of 4095 rules per stylesheet!" && r <= MAX_RULES_PER_SHEET );

    _dwID = ((l1<<27) & LEVEL1_MASK) | ((l2<<22) & LEVEL2_MASK) | ((l3<<17) & LEVEL3_MASK) |
            ((l4<<12) & LEVEL4_MASK) | (r & RULE_MASK);
}

//*********************************************************************
// CStyleID::SetLevel()
// Sets the value of a particular nesting level
//*********************************************************************
void CStyleID::SetLevel(const unsigned long level, const unsigned long value)
{
    Assert( "Maximum of 31 stylesheets per level!" && value <= MAX_SHEETS_PER_LEVEL );
    switch( level )
    {
        case 1:
            _dwID &= ~LEVEL1_MASK;
            _dwID |= ((value<<27) & LEVEL1_MASK);
            break;
        case 2:
            _dwID &= ~LEVEL2_MASK;
            _dwID |= ((value<<22) & LEVEL2_MASK);
            break;
        case 3:
            _dwID &= ~LEVEL3_MASK;
            _dwID |= ((value<<17) & LEVEL3_MASK);
            break;
        case 4:
            _dwID &= ~LEVEL4_MASK;
            _dwID |= ((value<<12) & LEVEL4_MASK);
            break;
        default:
            Assert( "Invalid Level for style ID" && FALSE );
    }
}

//*********************************************************************
// CStyleID::GetLevel()
// Gets the value of a particular nesting level
//*********************************************************************
unsigned long CStyleID::GetLevel(const unsigned long level) const
{
    switch( level )
    {
        case 1:
            return ((_dwID>>27)&0x1F);
        case 2:
            return ((_dwID>>22)&0x1F);
        case 3:
            return ((_dwID>>17)&0x1F);
        case 4:
            return ((_dwID>>12)&0x1F);
        default:
            Assert( "Invalid Level for style ID" && FALSE );
            return 0;
    }
}

//*********************************************************************
// TranslateMediaTypeString()
//      Parses a MEDIA attribute and builds the correct EMediaType from it.
//*********************************************************************
MtDefine(TranslateMediaTypeString_pszMedia, Locals, "TranslateMediaTypeString pszMedia");

DWORD TranslateMediaTypeString( LPCTSTR pcszMedia )
{
    DWORD dwRet = 0;
    LPTSTR pszMedia;
    LPTSTR pszString;
    LPTSTR pszNextToken;
    LPTSTR pszLastChar;

    // TODO: Handle OOM here
    MemAllocString(Mt(TranslateMediaTypeString_pszMedia), pcszMedia, &pszMedia);
    pszString = pszMedia;

    for ( ; pszString && *pszString; pszString = pszNextToken )
    {
        while ( _istspace( *pszString ) )
            pszString++;
        pszNextToken = pszString;
        while ( *pszNextToken && *pszNextToken != _T(',') )
            pszNextToken++;
        if ( pszNextToken > pszString )
        {
            pszLastChar = pszNextToken - 1;
            while ( isspace( *pszLastChar ) && ( pszLastChar >= pszString ) )
                *pszLastChar-- = _T('\0');
        }
        if ( *pszNextToken )
            *pszNextToken++ = _T('\0');
        if ( !*pszString )
            continue;   // This is so empty MEDIA strings will default to All instead of Unknown.
        dwRet |= CSSMediaTypeFromName(pszString);
    }

    if ( !dwRet )
        dwRet = MEDIA_All;
    MemFree( pszMedia );
    return ( dwRet );
}

// 
//*********************************************************************
// CNamespace::SetNamespace
// Parses given string and stores into member variables depending on the type
//*********************************************************************
HRESULT 
CNamespace::SetNamespace(LPCTSTR pchStr)
{
    HRESULT         hr;
    CBufferedStr    strWork;
    LPTSTR          pStr;

    strWork.Set(pchStr);

    pStr = (LPTSTR)strWork;

    if (pStr == NULL)
    {   
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(RemoveStyleUrlFromStr(&pStr));
    if(SUCCEEDED(hr))
    {
        Assert( pStr[0] != 0 );
        _strNamespace.Set(pStr);
        hr = S_OK;
    }
    //_strNameSpace will be empty if we fail

Cleanup:

    RRETURN(hr);
}



//*********************************************************************
// CNamespace::IsEqual
// Returns TRUE if the namspaces  are equal
//*********************************************************************
BOOL 
CNamespace::IsEqual(const CNamespace * pNmsp) const
{
    if(!pNmsp || pNmsp->IsEmpty())
    {
        if(IsEmpty())
            return TRUE;
        else
            return FALSE;
    }

    return (_tcsicmp(_strNamespace, pNmsp->_strNamespace) == 0);
}


const CNamespace& 
CNamespace::operator=(const CNamespace & nmsp)
{
    if(&nmsp != this)
    {
        _strNamespace.Set(nmsp._strNamespace);
    }

    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\style\sprop.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       sprop.cxx
//
//  Contents:   These are the Style Handlers and Helpers
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

///+---------------------------------------------------------------
//
//  Member:     PROPERTYDESC::HandleStyleProperty, public
//
//  Synopsis:   Helper for getting/setting string value properties
//
//  Arguments:  dwOpCode        -- encodes the incoming type (PROPTYPE_FLAG) in the upper WORD and
//                                 the opcode in the lower WORD (HANDLERPROP_FLAGS)
//                                 PROPTYPE_EMPTY means the 'native' type (CStr in this case)
//              pv              -- points to the 'media' the value is stored for the get and set
//              pObject         -- object owns the property
//              pSubObject      -- subobject storing the property (could be the main object)
//
//----------------------------------------------------------------

HRESULT
PROPERTYDESC::HandleStyleProperty(DWORD dwOpCode, void * pv, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT     hr = S_OK;
    VARIANT     varDest;

    varDest.vt = VT_EMPTY;
    if (ISSET(dwOpCode))
    {
        Assert(!(ISSTREAM(dwOpCode))); // we can't do this yet...
        switch(PROPTYPE(dwOpCode))
        {
        case PROPTYPE_LPWSTR:
            break;

        case PROPTYPE_VARIANT:
            if (V_VT((VARIANT *)pv) == VT_BSTR)
            {
                pv = (void *)V_BSTR((VARIANT *)pv);
            }
            else
            {
                hr = THR(VariantChangeTypeSpecial(&varDest, (VARIANT *)pv,  VT_BSTR));
                if (hr)
                    goto Cleanup;
                pv = V_BSTR(&varDest);
            }
        default:
            Assert(PROPTYPE(dwOpCode) == 0);    // assumed native long
            break;
        }

        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_DEFAULT:
            Assert(pv == NULL);
            pv = (void *)ulTagNotPresentDefault;

            if (!pv)
                goto Cleanup;       // zero string

            // fall thru
        case HANDLEPROP_VALUE:
        case HANDLEPROP_AUTOMATION:
            if ( pv && *(TCHAR *)pv )
            {
                CElement *pElem = (CElement *)pObject;
                LPTSTR lpszStyleText = (TCHAR *)pv;
                CAttrArray **ppAA = pElem->CreateStyleAttrArray(DISPID_INTERNAL_INLINESTYLEAA);
                // Keep the poiner that we pass to CCSSParser constructor, because ppAA may get shifted
                CAttrArray *pAA = *ppAA; 

                BOOL fXML = pElem->IsInMarkup() && pElem->GetMarkupPtr()->IsXML();
                BOOL fIsStrictCSS1 = (OPCODE(dwOpCode) == HANDLEPROP_VALUE) ? (dwOpCode & HANDLEPROP_STRICTCSS1)
                                                                            : pElem->IsInMarkup() && pElem->GetMarkupPtr()->IsStrictCSS1Document();

                CCSSParser ps( NULL, &pAA, fXML, fIsStrictCSS1, eSingleStyle, &CStyle::s_apHdlDescs, pObject, OPERATION(dwOpCode) );
        
                ps.Open();
                ps.Write( lpszStyleText, _tcslen( lpszStyleText ) );
                ps.Close();
            }
            break;

        default:
            hr = E_FAIL;
            Assert(FALSE && "Invalid operation");
            break;
        }
    }
    else
    {
        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_VALUE:
            if (PROPTYPE(dwOpCode) == PROPTYPE_VARIANT)
            {
                hr = THR(WriteStyleToBSTR(
                        pObject, 
                        ((CElement *)pObject)->GetInLineStyleAttrArray(), 
                        &((VARIANT *)pv)->bstrVal, 
                        TRUE));
                ((VARIANT *)pv)->vt = VT_BSTR;
            }
            else if (PROPTYPE(dwOpCode) == PROPTYPE_BSTR)
            {
                hr = THR(WriteStyleToBSTR(
                        pObject, 
                        ((CElement *)pObject)->GetInLineStyleAttrArray(), 
                        (BSTR *)pv, 
                        TRUE));
            }
            else
            {
                BSTR    bstr = NULL;
                
                Assert(PROPTYPE(dwOpCode) == 0);

                hr = THR(WriteStyleToBSTR(
                        pObject, 
                        ((CElement *)pObject)->GetInLineStyleAttrArray(), 
                        &bstr, 
                        TRUE));
                if (!hr)
                {
                    hr = ((CStr *)pv)->Set(bstr);
                    FormsFreeString(bstr);
                }
            }
            if (hr)
                goto Cleanup;
                
            break;
            
        case HANDLEPROP_STREAM:
            Assert(PROPTYPE(dwOpCode) == PROPTYPE_LPWSTR);
            {
                BSTR bstrTemp;
                hr = THR( WriteStyleToBSTR( pObject,
                                            ((CElement *)pObject)->GetInLineStyleAttrArray(),
                                            &bstrTemp,
                                            TRUE,
                                            !((CElement *)pObject)->Doc()->_fSaveTempfileForPrinting ));
                if ( !hr )
                {
                    if ( *bstrTemp )
                        hr = THR(((IStream*) (void*) pv)->Write( bstrTemp, _tcslen(bstrTemp) * sizeof(TCHAR), NULL));
                    FormsFreeString( bstrTemp );
                }
            }

            if (hr)
                goto Cleanup;
            break;

        case HANDLEPROP_COMPARE:
            {
                CElement *pElem = (CElement *)pObject;
                CAttrArray *pAA = pElem->GetInLineStyleAttrArray();
                // Check for presence of Attributs and Expandos
                hr = pAA && pAA->HasAnyAttribute(TRUE) ? S_FALSE : S_OK;
            }
            break;

        default:
            hr = E_FAIL;
            Assert(FALSE && "Invalid operation");
            break;
        }
    }

Cleanup:
    if (varDest.vt != VT_EMPTY)
    {
        VariantClear(&varDest);
    }
    RRETURN1(hr,S_FALSE);
}

HRESULT BASICPROPPARAMS::GetStyleComponentProperty(BSTR *pbstr, CBase *pObject, CVoid *pSubObject) const
{
    VARIANT varValue;
    HRESULT hr;
    PROPERTYDESC *ppdPropDesc = ((PROPERTYDESC *)this)-1;

    hr = THR(ppdPropDesc->HandleStyleComponentProperty( HANDLEPROP_VALUE | (PROPTYPE_VARIANT<<16), 
        (void *)&varValue, pObject, pSubObject ));
    if ( !hr )
        *pbstr = V_BSTR(&varValue);

    RRETURN(pObject ? pObject->SetErrorInfo(hr) : hr);
}

HRESULT BASICPROPPARAMS::SetStyleComponentProperty( BSTR bstr, CBase *pObject, CVoid *pSubObject, WORD wFlags ) const
{
    HRESULT hr;
    CBase::CLock    Lock(pObject);
    DWORD dwOpCode = HANDLEPROP_SET|HANDLEPROP_AUTOMATION;
    PROPERTYDESC *ppdPropDesc = ((PROPERTYDESC *)this)-1;

    if (wFlags & CAttrValue::AA_Extra_Important)
        dwOpCode |= HANDLEPROP_IMPORTANT;
    if (wFlags & CAttrValue::AA_Extra_Implied)
        dwOpCode |= HANDLEPROP_IMPLIED;

    SETPROPTYPE( dwOpCode, PROPTYPE_LPWSTR );

    hr = THR(ppdPropDesc->HandleStyleComponentProperty( dwOpCode, (void *) bstr, pObject, pSubObject ));
    
    RRETURN1(pObject ? pObject->SetErrorInfo(hr) : hr, E_INVALIDARG);
}

HRESULT BASICPROPPARAMS::GetStyleComponentBooleanProperty( VARIANT_BOOL * p, CBase *pObject, CVoid *pSubObject) const
{
    VARIANT varValue;
    HRESULT hr;
    PROPERTYDESC *ppdPropDesc = ((PROPERTYDESC *)this)-1;

    if (!pSubObject)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(ppdPropDesc->HandleStyleComponentProperty( HANDLEPROP_VALUE | (PROPTYPE_VARIANT<<16), 
        (void *)&varValue, pObject, pSubObject ));
    if ( !hr )
    {
        Assert( varValue.vt == VT_BOOL );
        *p = varValue.boolVal;
    }

Cleanup:
    RRETURN(pObject->SetErrorInfo(hr));
}

HRESULT BASICPROPPARAMS::SetStyleComponentBooleanProperty( VARIANT_BOOL v, CBase *pObject, CVoid *pSubObject ) const
{
    HRESULT hr;
    CBase::CLock    Lock(pObject);
    DWORD dwOpCode = HANDLEPROP_SET|HANDLEPROP_AUTOMATION;
    PROPERTYDESC *ppdPropDesc = ((PROPERTYDESC *)this)-1;
    VARIANT var;

    if (!pSubObject)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    var.vt = VT_BOOL;
    var.boolVal = v;

    SETPROPTYPE( dwOpCode, PROPTYPE_VARIANT );

    hr = THR(ppdPropDesc->HandleStyleComponentProperty( dwOpCode, (void *) &var, pObject, pSubObject ));

Cleanup:
    RRETURN1(pObject->SetErrorInfo(hr), E_INVALIDARG);
}

STDMETHODIMP CStyle::put_textDecorationNone(VARIANT_BOOL v)
{
	return s_propdescCStyletextDecorationNone.b.SetStyleComponentBooleanProperty(v, this, (CVoid *)(void *)(GetAttrArray()));
}
STDMETHODIMP CStyle::get_textDecorationNone(VARIANT_BOOL * p)
{
	return s_propdescCStyletextDecorationNone.b.GetStyleComponentBooleanProperty(p, this, (CVoid *)(void *)(GetAttrArray()));
}
STDMETHODIMP CStyle::put_textDecorationUnderline(VARIANT_BOOL v)
{
	return s_propdescCStyletextDecorationUnderline.b.SetStyleComponentBooleanProperty(v, this, (CVoid *)(void *)(GetAttrArray()));
}
STDMETHODIMP CStyle::get_textDecorationUnderline(VARIANT_BOOL * p)
{
	return s_propdescCStyletextDecorationUnderline.b.GetStyleComponentBooleanProperty(p, this, (CVoid *)(void *)(GetAttrArray()));
}
STDMETHODIMP CStyle::put_textDecorationOverline(VARIANT_BOOL v)
{
	return s_propdescCStyletextDecorationOverline.b.SetStyleComponentBooleanProperty(v, this, (CVoid *)(void *)(GetAttrArray()));
}
STDMETHODIMP CStyle::get_textDecorationOverline(VARIANT_BOOL * p)
{
	return s_propdescCStyletextDecorationOverline.b.GetStyleComponentBooleanProperty(p, this, (CVoid *)(void *)(GetAttrArray()));
}
STDMETHODIMP CStyle::put_textDecorationLineThrough(VARIANT_BOOL v)
{
	return s_propdescCStyletextDecorationLineThrough.b.SetStyleComponentBooleanProperty(v, this, (CVoid *)(void *)(GetAttrArray()));
}
STDMETHODIMP CStyle::get_textDecorationLineThrough(VARIANT_BOOL * p)
{
	return s_propdescCStyletextDecorationLineThrough.b.GetStyleComponentBooleanProperty(p, this, (CVoid *)(void *)(GetAttrArray()));
}
STDMETHODIMP CStyle::put_textDecorationBlink(VARIANT_BOOL v)
{
	return s_propdescCStyletextDecorationBlink.b.SetStyleComponentBooleanProperty(v, this, (CVoid *)(void *)(GetAttrArray()));
}
STDMETHODIMP CStyle::get_textDecorationBlink(VARIANT_BOOL * p)
{
	return s_propdescCStyletextDecorationBlink.b.GetStyleComponentBooleanProperty(p, this, (CVoid *)(void *)(GetAttrArray()));
}


HRESULT
CStyle::toString(BSTR* String)
{
    RRETURN(super::toString(String));
};



//+---------------------------------------------------------------
//
//  Member:     PROPERTYDESC::HandleStyleComponentProperty, public
//
//  Synopsis:   Helper for getting/setting url style sheet properties...
//              url(string)
//
//  Arguments:  dwOpCode        -- encodes the incoming type (PROPTYPE_FLAG) in the upper WORD and
//                                 the opcode in the lower WORD (HANDLERPROP_FLAGS)
//                                 PROPTYPE_EMPTY means the 'native' type (long in this case)
//              pv              -- points to the 'media' the value is stored for the get and set
//              pObject         -- object owns the property
//              pSubObject      -- subobject storing the property (could be the main object)
//
//----------------------------------------------------------------
HRESULT
PROPERTYDESC::HandleStyleComponentProperty(DWORD dwOpCode, void * pv, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT hr = S_OK;
    VARIANT varDest;
    size_t  nLenIn = (size_t) -1;
	DWORD dispid = GetBasicPropParams()->dispid;
    BSTR bstrTemp;  // Used by some of the stream writers
    BOOL fTDPropertyValue=FALSE;  // If this is a SET of a text-decoration sub-property, this is the value
    WORD wFlags = 0;

    if (ISSET(dwOpCode))
    {
        Assert(!(ISSTREAM(dwOpCode))); // we can't do this yet...
        switch ( dispid )
        {
        case DISPID_A_TEXTDECORATIONNONE:
        case DISPID_A_TEXTDECORATIONUNDERLINE:
        case DISPID_A_TEXTDECORATIONOVERLINE:
        case DISPID_A_TEXTDECORATIONLINETHROUGH:
        case DISPID_A_TEXTDECORATIONBLINK:
            Assert( PROPTYPE(dwOpCode) == PROPTYPE_VARIANT && "Text-decoration subproperties must take variants!" );
            Assert( V_VT((VARIANT *)pv) == VT_BOOL && "Text-decoration subproperties must take BOOLEANs!" );
            fTDPropertyValue = !!((VARIANT *)pv)->boolVal;
            break;

        default:
            switch(PROPTYPE(dwOpCode))
            {
            case PROPTYPE_VARIANT:
                if (V_VT((VARIANT *)pv) == VT_BSTR)
                {
                    pv = (void *)V_BSTR((VARIANT *)pv);
                }
                else
                {
                    hr = VariantChangeTypeSpecial(&varDest, (VARIANT *)pv,  VT_BSTR);
                    if (hr)
                        goto Cleanup;
                    pv = V_BSTR(&varDest);
                }

                //intentional fallthrough
            case PROPTYPE_LPWSTR:
                switch (dispid)
                {
                case DISPID_A_BACKGROUNDIMAGE:
                case DISPID_A_LISTSTYLEIMAGE:
                case DISPID_A_FONTFACESRC:
                    nLenIn = ValidStyleUrl((TCHAR*) pv);
                    if ( OPCODE(dwOpCode) == HANDLEPROP_VALUE )
                    {
                        if (!nLenIn && _tcsicmp( (TCHAR*)pv, _T("none") ) )
                        {
                            hr = E_INVALIDARG;
                            goto Cleanup;
                        }
                    }
                    break;

                case DISPID_A_BEHAVIOR:
                    nLenIn = pv ? _tcslen((TCHAR*) pv) : 0;
                    break;
                }
                break;

		    default:
			    Assert( FALSE );	// We shouldn't get here.
            }
            break;
        }

        switch ( dispid )
        {
        case DISPID_A_LISTSTYLEIMAGE:
        case DISPID_A_BACKGROUNDIMAGE:
        case DISPID_A_FONTFACESRC:
        case DISPID_A_BEHAVIOR:
        
            if (nLenIn && (nLenIn != (size_t) -1))
            {
                if (DISPID_A_BEHAVIOR == dispid)
                {
                    hr = THR(HandleStringProperty(dwOpCode, (TCHAR*) pv, pObject, pSubObject));
                }
                else
                {
                    TCHAR *pch = (TCHAR*) pv;
                    TCHAR *psz = pch+4;
                    TCHAR *quote = NULL;
                    TCHAR *pszEnd;
                    TCHAR terminator;

                    dwOpCode |= HANDLEPROP_URLENCLOSE;

                    while ( _istspace( *psz ) )
                        psz++;
                    if ( *psz == _T('\'') || *psz == _T('"') )
                    {
                        quote = psz++;
                    }
                    nLenIn--;   // Skip back over the ')' character - we know there is one, because ValidStyleUrl passed this string.
                    pszEnd = pch + nLenIn - 1;
                    while ( _istspace( *pszEnd ) && ( pszEnd > psz ) )
                        pszEnd--;
                    if ( quote && ( *pszEnd == *quote ) )
                        pszEnd--;
                    terminator = *(pszEnd+1);
                    *(pszEnd+1) = _T('\0');
                    hr = THR(HandleStringProperty(dwOpCode, psz, pObject, pSubObject));
                    *(pszEnd+1) = terminator;
                }
            }
            else
            {
                // Why are we doing the FindSimpleAndDelete here instead of always
                // doing a HandleStringProperty?  We won't fire a prop change this way
                // and we also won't handle undo.  Ug!
                if ( !pv || !*(TCHAR*)pv )
                {   // Empty string - delete the entry.
                    CAttrArray **ppAA = (CAttrArray **)pSubObject;

                    if ( *ppAA )
                        (*ppAA)->FindSimpleAndDelete( dispid, CAttrValue::AA_StyleAttribute, NULL );
                }
                else if ( !_tcsicmp( (TCHAR*)pv, _T("none") ) )
                {
                    hr = THR(HandleStringProperty(dwOpCode, (void *)_T(""), pObject, pSubObject));
                }
                else
                    hr = E_INVALIDARG;
            }
            break;

        case DISPID_A_BACKGROUND:
            hr = ParseBackgroundProperty( (CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (TCHAR*) pv,
                            ( OPCODE(dwOpCode) == HANDLEPROP_VALUE ) );
            break;
        case DISPID_A_FONT:
            if ( pv && FindSystemFontByName( (TCHAR*) pv ) != sysfont_non_system )
            {
                hr = THR(HandleStringProperty(dwOpCode, pv, pObject, pSubObject));
            }
            else
                hr = ParseFontProperty( (CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (TCHAR*) pv );
            break;
        case DISPID_A_LAYOUTGRID:
            hr = ParseLayoutGridProperty( (CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (TCHAR*) pv );
            break;
        case DISPID_A_TEXTAUTOSPACE:
            if ( dwOpCode & HANDLEPROP_IMPORTANT )
                wFlags |= CAttrValue::AA_Extra_Important;
            if ( dwOpCode & HANDLEPROP_IMPLIED )
                wFlags |= CAttrValue::AA_Extra_Implied;

            hr = ParseTextAutospaceProperty( (CAttrArray **)pSubObject, (LPCTSTR)pv, OPERATION(dwOpCode), wFlags );
            break;
        case DISPID_A_TEXTDECORATION:
            if ( dwOpCode & HANDLEPROP_IMPORTANT )
                wFlags |= CAttrValue::AA_Extra_Important;
            if ( dwOpCode & HANDLEPROP_IMPLIED )
                wFlags |= CAttrValue::AA_Extra_Implied;

            // Don't create undo units if set while parsing (from initAttrBag)
            if (pObject && (OPCODE(dwOpCode) == HANDLEPROP_VALUE))
                pObject = NULL;

            hr = ParseTextDecorationProperty( (CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (LPCTSTR)pv, wFlags );
            break;
        case DISPID_A_TEXTDECORATIONNONE:
        case DISPID_A_TEXTDECORATIONUNDERLINE:
        case DISPID_A_TEXTDECORATIONOVERLINE:
        case DISPID_A_TEXTDECORATIONLINETHROUGH:
        case DISPID_A_TEXTDECORATIONBLINK:
            {
                VARIANT v;
#ifndef NO_EDIT
                CVariant varOld;
                BOOL fTreeSync = FALSE;
                BOOL fCreateUndo = (pObject && (OPCODE(dwOpCode) != HANDLEPROP_VALUE)) ? pObject->QueryCreateUndo( TRUE, FALSE, &fTreeSync ) : FALSE;
                if ( fCreateUndo || fTreeSync )
                {
                    V_VT(&varOld) = VT_BSTR;
                    WriteTextDecorationToBSTR( *((CAttrArray **)pSubObject), &(V_BSTR(&varOld)) );
                }
#endif
                

                v.vt = VT_I4;
                v.lVal = 0;
                if ( *((CAttrArray **)pSubObject) )
                {   // See if we already have a text-decoration value
                    CAttrValue *pAV = (*((CAttrArray **)pSubObject))->Find( DISPID_A_TEXTDECORATION, CAttrValue::AA_Attribute );
                    if ( pAV )
                    {   // We do!  Copy its value into our working variant
                        v.lVal = pAV->GetLong();
                    }
                }
                switch ( dispid )
                {
                case DISPID_A_TEXTDECORATIONNONE:
                    if ( fTDPropertyValue )
                        v.lVal = TD_NONE;   // "none" clears all the other properties (unlike the other properties)
                    else
                        v.lVal &= ~TD_NONE;
                    break;
                case DISPID_A_TEXTDECORATIONUNDERLINE:
                    if ( fTDPropertyValue )
                        v.lVal |= TD_UNDERLINE;
                    else
                        v.lVal &= ~TD_UNDERLINE;
                    break;
                case DISPID_A_TEXTDECORATIONOVERLINE:
                    if ( fTDPropertyValue )
                        v.lVal |= TD_OVERLINE;
                    else
                        v.lVal &= ~TD_OVERLINE;
                    break;
                case DISPID_A_TEXTDECORATIONLINETHROUGH:
                    if ( fTDPropertyValue )
                        v.lVal |= TD_LINETHROUGH;
                    else
                        v.lVal &= ~TD_LINETHROUGH;
                    break;
                case DISPID_A_TEXTDECORATIONBLINK:
                    if ( fTDPropertyValue )
                        v.lVal |= TD_BLINK;
                    else
                        v.lVal &= ~TD_BLINK;
                    break;
                }
                if ( dwOpCode & HANDLEPROP_IMPORTANT )
                    wFlags |= CAttrValue::AA_Extra_Important;
                if ( dwOpCode & HANDLEPROP_IMPLIED )
                    wFlags |= CAttrValue::AA_Extra_Implied;
                hr = CAttrArray::Set( (CAttrArray **)pSubObject, DISPID_A_TEXTDECORATION, &v,
                                (PROPERTYDESC *)&s_propdescCStyletextDecoration, CAttrValue::AA_StyleAttribute, wFlags );

#ifndef NO_EDIT
                if (fTreeSync)
                {
                    CVariant varNew;

                    V_VT(&varNew) = VT_BSTR;
                    WriteTextDecorationToBSTR( *((CAttrArray **)pSubObject), &(V_BSTR(&varNew)) );

                    pObject->LogAttributeChange( DISPID_A_TEXTDECORATION, &varOld, &varNew );
                }

                if( fCreateUndo )
                {
                    hr = THR(pObject->CreatePropChangeUndo(DISPID_A_TEXTDECORATION, &varOld, NULL));
                    if (hr)
                        goto Cleanup;
                }
#endif
            }
            dispid = DISPID_A_TEXTDECORATION;   // This is so we call OnPropertyChange for the right property below.
            break;

        case DISPID_A_MARGIN:
        case DISPID_A_PADDING:
            hr = THR( ParseExpandProperty( (CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (TCHAR*) pv, dispid, TRUE ) );
            break;

        case DISPID_A_BORDERWIDTH:
            // (gschneid) Border width sould be handled with the same behavior like margin and padding (last argument TRUE). 
            // But this one is buggy and needs to be reviewed for Blackcomb in compatible mode. Bug #19500.
            // It's fixed under strict css mode.
            {
                BOOL fIsStrictCSS1 = dwOpCode & HANDLEPROP_STRICTCSS1;
                hr = THR(ParseExpandProperty((CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (TCHAR*) pv, dispid, !!fIsStrictCSS1));
            }
            break;
        case DISPID_A_BORDERCOLOR:
        case DISPID_A_BORDERSTYLE:
            hr = THR( ParseExpandProperty( (CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (TCHAR*) pv, dispid, FALSE ) );
            break;

        case DISPID_A_STYLETEXT:
            {
                LPTSTR lpszStyleText = (TCHAR *)pv;
                CAttrArray **ppAA = (CAttrArray **)pSubObject;

                if ( *ppAA )
                    (*ppAA)->Free();

                if ( lpszStyleText && *lpszStyleText )
                {
                    CStyle *pStyle = DYNCAST(CStyle, pObject);

                    Assert( pStyle );
                    pStyle->MaskPropertyChanges( TRUE );
                    CElement *pElem = pStyle->GetElementPtr();
                    BOOL fXML = pElem && pElem->IsInMarkup() && pElem->GetMarkupPtr()->IsXML();
                    BOOL fIsStrictCSS1 = pElem && pElem->IsInMarkup() && pElem->GetMarkupPtr()->IsStrictCSS1Document();
                    CCSSParser ps( NULL, ppAA, fXML, fIsStrictCSS1, eSingleStyle, &CStyle::s_apHdlDescs, 
                                   pObject, OPERATION(dwOpCode) );

                    ps.Open();
	                ps.Write( lpszStyleText, lstrlen( lpszStyleText ) );
	                ps.Close();
                    pStyle->MaskPropertyChanges( FALSE );
                }
            }
            break;

        case DISPID_A_BORDERTOP:
        case DISPID_A_BORDERRIGHT:
        case DISPID_A_BORDERBOTTOM:
        case DISPID_A_BORDERLEFT:
            hr = ParseAndExpandBorderSideProperty( (CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (TCHAR*) pv, dispid );
            break;

        case DISPID_A_BORDER:
            hr = ParseBorderProperty( (CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (TCHAR*) pv );
            break;

        case DISPID_A_LISTSTYLE:
            hr = ParseListStyleProperty( (CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (TCHAR*) pv );
            break;

        case DISPID_A_BACKGROUNDPOSITION:
            hr = ParseBackgroundPositionProperty( (CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (TCHAR *)pv );
            break;

        case DISPID_A_CLIP:
            hr = ParseClipProperty( (CAttrArray **)pSubObject, pObject, OPERATION(dwOpCode), (TCHAR *)pv );
            break;

        default:
            Assert( "Attempting to set an unknown type of CStyleComponent!" );
        }

        if (hr)
            goto Cleanup;
        else
        {
            // Note that dispid reflects the property that changed, not what was set -
            // e.g., textDecorationUnderline has been changed to textDecoration.
            if ( dwOpCode & HANDLEPROP_AUTOMATION )
            {
                CBase::CLock Lock( pObject );
                hr = THR(pObject->OnPropertyChange(dispid, GetdwFlags()));
            }
        }
    }
    else
    {	// GET value from data
        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_STREAM:
            {
                IStream *pis = (IStream *) pv;

                switch ( dispid )
                {
                case DISPID_A_LISTSTYLEIMAGE:
                case DISPID_A_BACKGROUNDIMAGE:
                case DISPID_A_BEHAVIOR:
                case DISPID_A_FONTFACESRC:
                    if ( (*(CAttrArray **)pSubObject)->Find( dispid, CAttrValue::AA_Attribute ) )
                    {
                        BSTR bstrSub;

                        hr = HandleStringProperty( HANDLEPROP_AUTOMATION | (PROPTYPE_BSTR << 16), 
                                                   &bstrSub, pObject, pSubObject );
                        if ( hr == S_OK )
                        {
                            if ( bstrSub && *bstrSub )
                            {   // This is a normal url.
                                hr = pis->Write(_T("url("), 4*sizeof(TCHAR), NULL);
                                if (!hr)
                                {
                                    hr = pis->Write( bstrSub, FormsStringLen( bstrSub ) * sizeof(TCHAR), NULL);
                                    if (!hr)
                                    {
                                        hr = pis->Write(_T(")"), 1*sizeof(TCHAR), NULL);
                                    }
                                }
                            }
                            else
                            {   // We only get here if a NULL string was stored in the array; i.e., the value is NONE.
                                hr = pis->Write(_T("none"), 4*sizeof(TCHAR), NULL);
                            }
                            FormsFreeString( bstrSub );
                        }
                    }
                    break;

                case DISPID_A_BACKGROUND:
                    hr = WriteBackgroundStyleToBSTR( *(CAttrArray **)pSubObject, &bstrTemp );
                    if ( hr == S_OK )
                    {
                        hr = THR(pis->Write( bstrTemp, FormsStringLen(bstrTemp) * sizeof(TCHAR), NULL));
                        FormsFreeString( bstrTemp );
                    }
                    break;

                case DISPID_A_TEXTAUTOSPACE:
                    // We need to cook up this property.
                    hr = WriteTextAutospaceToBSTR( *(CAttrArray **)pSubObject, &bstrTemp );
                    if ( hr == S_OK )
                    {
                        hr = THR(pis->Write( bstrTemp, FormsStringLen(bstrTemp) * sizeof(TCHAR), NULL));
                        FormsFreeString( bstrTemp );
                    }
                    break;

                case DISPID_A_TEXTDECORATION:
                    // We need to cook up this property.
                    hr = WriteTextDecorationToBSTR( *(CAttrArray **)pSubObject, &bstrTemp );
                    if ( hr == S_OK )
                    {
                        hr = THR(pis->Write( bstrTemp, FormsStringLen(bstrTemp) * sizeof(TCHAR), NULL));
                        FormsFreeString( bstrTemp );
                    }
                    break;

                case DISPID_A_BORDERTOP:
                case DISPID_A_BORDERRIGHT:
                case DISPID_A_BORDERBOTTOM:
                case DISPID_A_BORDERLEFT:
                    hr = WriteBorderSidePropertyToBSTR( dispid, *(CAttrArray **)pSubObject, &bstrTemp );
                    if ( hr == S_OK )
                    {
                        hr = THR(pis->Write( bstrTemp, FormsStringLen(bstrTemp) * sizeof(TCHAR), NULL));
                        FormsFreeString( bstrTemp );
                    }
                    break;

                case DISPID_A_BORDER:
                    hr = WriteBorderToBSTR( *(CAttrArray **)pSubObject, &bstrTemp );
                    if ( hr == S_OK )
                    {
                        hr = THR(pis->Write( bstrTemp, FormsStringLen(bstrTemp) * sizeof(TCHAR), NULL));
                        FormsFreeString( bstrTemp );
                    }
                    break;

                case DISPID_A_MARGIN:
                case DISPID_A_PADDING:
                case DISPID_A_BORDERCOLOR:
                case DISPID_A_BORDERWIDTH:
                case DISPID_A_BORDERSTYLE:
                    hr = WriteExpandedPropertyToBSTR( dispid, *(CAttrArray **)pSubObject, &bstrTemp );
                    if ( hr == S_OK )
                    {
                        hr = THR(pis->Write( bstrTemp, FormsStringLen(bstrTemp) * sizeof(TCHAR), NULL));
                        FormsFreeString( bstrTemp );
                    }
                    break;

                case DISPID_A_LISTSTYLE:
                    hr = WriteListStyleToBSTR( *(CAttrArray **)pSubObject, &bstrTemp );
                    if ( hr == S_OK )
                    {
                        hr = THR(pis->Write( bstrTemp, FormsStringLen(bstrTemp) * sizeof(TCHAR), NULL));
                        FormsFreeString( bstrTemp );
                    }
                    break;
            
                case DISPID_A_BACKGROUNDPOSITION:
                    hr = WriteBackgroundPositionToBSTR( *(CAttrArray **)pSubObject, &bstrTemp );
                    if ( hr == S_OK )
                    {
                        hr = THR(pis->Write( bstrTemp, FormsStringLen(bstrTemp) * sizeof(TCHAR), NULL));
                        FormsFreeString( bstrTemp );
                    }
                    break;

                case DISPID_A_FONT:
                    if ( (*(CAttrArray **)pSubObject)->Find(DISPID_A_FONT, CAttrValue::AA_Attribute ) )
                        hr = HandleStringProperty(dwOpCode, pv, pObject, pSubObject);
                    else
                    {
                        // We need to cook up a "font" property.
                        hr = WriteFontToBSTR( *(CAttrArray **)pSubObject, &bstrTemp );
                        if ( !hr )
                        {
                            if ( *bstrTemp )
                                hr = THR(pis->Write( bstrTemp, FormsStringLen(bstrTemp) * sizeof(TCHAR), NULL));
                            FormsFreeString( bstrTemp );
                        }
                    }
                    break;
                case DISPID_A_LAYOUTGRID:
                    // We need to cook up a "layout grid" property.
                    hr = WriteLayoutGridToBSTR( *(CAttrArray **)pSubObject, &bstrTemp );
                    if ( !hr )
                    {
                        if ( *bstrTemp )
                            hr = THR(pis->Write( bstrTemp, FormsStringLen(bstrTemp) * sizeof(TCHAR), NULL));
                        FormsFreeString( bstrTemp );
                    }
                    break;
                case DISPID_A_CLIP:     // We need to cook up a "clip" property with the "rect" shape.
                    hr = WriteClipToBSTR( *(CAttrArray **)pSubObject, &bstrTemp );
                    if ( !hr )
                    {
                        if ( *bstrTemp )
                            hr = THR(pis->Write( bstrTemp, FormsStringLen(bstrTemp) * sizeof(TCHAR), NULL));
                        FormsFreeString( bstrTemp );
                    }
                    break;
                case DISPID_A_STYLETEXT:
                    hr = WriteStyleToBSTR( pObject, *(CAttrArray **)pSubObject, &bstrTemp, FALSE );
                    if ( !hr )
                    {
                        if ( *bstrTemp )
                            hr = THR(pis->Write( bstrTemp, _tcslen(bstrTemp) * sizeof(TCHAR), NULL));
                        FormsFreeString( bstrTemp );
                    }
                    break;
				}
            }
            break;
        default:
            {
                BSTR *pbstr;
                switch(PROPTYPE(dwOpCode))
                {
                case PROPTYPE_VARIANT:
                    V_VT((VARIANT *)pv) = VT_BSTR;
                    pbstr = &(((VARIANT *)pv)->bstrVal);
                    break;
                case PROPTYPE_BSTR:
                    pbstr = (BSTR *)pv;
                    break;
                default:
                    Assert( "Can't get anything but a VARIANT or BSTR for style component properties!" );
                    hr = S_FALSE;
                    goto Cleanup;
                }
                switch ( dispid )
                {
                case DISPID_A_BACKGROUND:
                    hr = WriteBackgroundStyleToBSTR( *(CAttrArray **)pSubObject, pbstr );
                    break;
                case DISPID_A_LISTSTYLEIMAGE:
                case DISPID_A_BACKGROUNDIMAGE:
                case DISPID_A_FONTFACESRC:
                case DISPID_A_BEHAVIOR:
                    {
                        CStr cstr;
                        if ( (*(CAttrArray **)pSubObject)->Find( dispid, CAttrValue::AA_Attribute ) )
                        {
                            BSTR bstrSub;
                            hr = HandleStringProperty( HANDLEPROP_AUTOMATION | (PROPTYPE_BSTR << 16), 
                                                       &bstrSub, pObject, pSubObject );
                            if ( hr == S_OK )
                            {
                                if ( bstrSub && *bstrSub )
                                {
                                    // CONSIDER (alexz) using Format, to remove the memallocs here

                                    if (dispid != DISPID_A_BEHAVIOR)
                                        cstr.Set( _T("url(") );

                                    cstr.Append( bstrSub );

                                    if (dispid != DISPID_A_BEHAVIOR)
                                        cstr.Append( _T(")") );
                                }
                                else
                                {   // We only get here if a NULL string was stored in the array; i.e., the value is NONE.
                                    cstr.Set( _T("none") );
                                }
                                FormsFreeString( bstrSub );
                            }
                        }
                        hr = cstr.AllocBSTR( pbstr );
                    }
                    break;

                case DISPID_A_TEXTAUTOSPACE:
                    hr = WriteTextAutospaceToBSTR( *(CAttrArray **)pSubObject, pbstr );
                    break;
                case DISPID_A_TEXTDECORATION:
                    hr = WriteTextDecorationToBSTR( *(CAttrArray **)pSubObject, pbstr );
                    break;

                case DISPID_A_TEXTDECORATIONNONE:
                case DISPID_A_TEXTDECORATIONUNDERLINE:
                case DISPID_A_TEXTDECORATIONOVERLINE:
                case DISPID_A_TEXTDECORATIONLINETHROUGH:
                case DISPID_A_TEXTDECORATIONBLINK:
                    if ( PROPTYPE( dwOpCode ) != PROPTYPE_VARIANT )
                    {
                        Assert( "Can't get/set text-decoration subproperties as anything but VARIANTs!" );
                        hr = S_FALSE;
                        goto Cleanup;
                    }

                    V_VT((VARIANT *)pv) = VT_BOOL;
                    ((VARIANT *)pv)->boolVal = 0;

                    if ( *((CAttrArray **)pSubObject) )
                    {   // See if we already have a text-decoration value
                        CAttrValue *pAV = (*((CAttrArray **)pSubObject))->Find( DISPID_A_TEXTDECORATION, CAttrValue::AA_Attribute );
                        if ( pAV )
                        {   // We do!  Copy its value into our working variant
                            long lVal = pAV->GetLong();

                            switch ( dispid )
                            {
                            case DISPID_A_TEXTDECORATIONNONE:
                                lVal &= TD_NONE;
                                break;
                            case DISPID_A_TEXTDECORATIONUNDERLINE:
                                lVal &= TD_UNDERLINE;
                                break;
                            case DISPID_A_TEXTDECORATIONOVERLINE:
                                lVal &= TD_OVERLINE;
                                break;
                            case DISPID_A_TEXTDECORATIONLINETHROUGH:
                                lVal &= TD_LINETHROUGH;
                                break;
                            case DISPID_A_TEXTDECORATIONBLINK:
                                lVal &= TD_BLINK;
                                break;
                            }
                            if ( lVal )
                                ((VARIANT *)pv)->boolVal = -1;
                        }
                    }
                    break;

                case DISPID_A_BORDERTOP:
                case DISPID_A_BORDERRIGHT:
                case DISPID_A_BORDERBOTTOM:
                case DISPID_A_BORDERLEFT:
                    hr = WriteBorderSidePropertyToBSTR( dispid, *(CAttrArray **)pSubObject, pbstr );
                    break;

                case DISPID_A_BORDER:
                    hr = WriteBorderToBSTR( *(CAttrArray **)pSubObject, pbstr );
                    break;

                case DISPID_A_MARGIN:
                case DISPID_A_PADDING:
                case DISPID_A_BORDERCOLOR:
                case DISPID_A_BORDERWIDTH:
                case DISPID_A_BORDERSTYLE:
                    hr = WriteExpandedPropertyToBSTR( dispid, *(CAttrArray **)pSubObject, pbstr );
                    break;

                case DISPID_A_LISTSTYLE:
                    hr = WriteListStyleToBSTR( *(CAttrArray **)pSubObject, pbstr );
                    break;
            
                case DISPID_A_BACKGROUNDPOSITION:
                    hr = WriteBackgroundPositionToBSTR( *(CAttrArray **)pSubObject, pbstr );
                    break;

                case DISPID_A_FONT:
                    if ( (*(CAttrArray **)pSubObject)->Find(DISPID_A_FONT, CAttrValue::AA_Attribute ) )
                        hr = HandleStringProperty(dwOpCode, pv, pObject, pSubObject);
                    else
                    {
                        // We need to cook up a "font" property.
                        hr = WriteFontToBSTR( *(CAttrArray **)pSubObject, pbstr );
                    }
                    break;

                case DISPID_A_LAYOUTGRID:
                    hr = WriteLayoutGridToBSTR( *(CAttrArray **)pSubObject, pbstr );
                    break;

                case DISPID_A_STYLETEXT:
                    hr = WriteStyleToBSTR( pObject, *(CAttrArray **)pSubObject, pbstr, FALSE );
                    break;

                case DISPID_A_CLIP:     // We need to cook up a "clip" property with the "rect" shape.
                    hr = WriteClipToBSTR( *(CAttrArray **)pSubObject, pbstr );
                    break;

                default:
                    Assert( "Unrecognized type being handled by CStyleUrl handler!" && FALSE );
                    break;
                }
                if ( hr == S_FALSE )
                    hr = FormsAllocString( _T(""), pbstr );
            }
            break;
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\style\style.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       style.cxx
//
//  Contents:   Support for Cascading Style Sheets.. including:
//
//              CCSSParser
//              CStyle
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CBUFSTR_HXX_
#define X_CBUFSTR_HXX_
#include "cbufstr.hxx"
#endif

#ifndef X_TOKENZ_HXX_
#define X_TOKENZ_HXX_
#include "tokenz.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_ATBLOCKS_HXX_
#define X_ATBLOCKS_HXX_
#include "atblocks.hxx"
#endif

#ifndef X_FILTCOL_HXX_
#define X_FILTCOL_HXX_
#include "filtcol.hxx"
#endif

#ifndef X_FATSTG_HXX_
#define X_FATSTG_HXX_
#include "fatstg.hxx"
#endif

#ifndef X_RULESTYL_HXX_
#define X_RULESTYL_HXX_
#include "rulestyl.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include <intl.hxx>
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include <strbuf.hxx>
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include "mshtmdid.h"
#endif

#ifndef X_AVUNDO_HXX_
#define X_AVUNDO_HXX_
#include "avundo.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

static const TCHAR strURLBeg[] = _T("url(");

MtDefine(CStyle, StyleSheets, "CStyle")
MtDefine(CCSSParser, StyleSheets, "CCSSParser")
MtDefine(ParseBackgroundProperty_pszCopy, Locals, "ParseBackgroundProperty pszCopy")
MtDefine(ParseFontProperty_pszCopy, Locals, "ParseFontProperty pszCopy")
MtDefine(ParseExpandProperty_pszCopy, Locals, "ParseExpandProperty pszCopy")
MtDefine(ParseAndExpandBorderSideProperty_pszCopy, Locals, "ParseAndExpandBorderSideProperty pszCopy")
MtDefine(ParseTextDecorationProperty_pszCopy, Locals, "ParseTextDecorationProperty pszCopy")
MtDefine(ParseTextAutospaceProperty_pszCopy, Locals, "ParseTextAutospaceProperty pszCopy")
MtDefine(ParseListStyleProperty_pszCopy, Locals, "ParseListStyleProperty pszCopy")
MtDefine(ParseBackgroundPositionProperty_pszCopy, Locals, "ParseBackgroundPositionProperty pszCopy")


#define SINGLEQUOTE _T('\'')
#define DOUBLEQUOTE _T('\"')

DeclareTag(tagStyleInlinePutVariant, "Style", "trace CStyle::put_Variant")

//---------------------------------------------------------------------
//  Class Declaration:  CCSSParser
//      The CCSSParser class implements a parser for data in the
//  Cascading Style Sheets format.
//---------------------------------------------------------------------

//*********************************************************************
//  CCSSParser::CCSSParser()
//      The constructor for the CCSSParser class initializes all member
//  variables for a full stylesheet declaration.
//*********************************************************************
CCSSParser::CCSSParser(
    CStyleSheet *pStyleSheet,
    CAttrArray **ppPropertyArray, /*=NULL*/
    BOOL fXMLGeneric,    /* FALSE */
    BOOL fStrictCSS1,    /* FALSE */
    ePARSERTYPE eType,   /* =eStylesheetDefinition */
    const HDLDESC *pHDLDesc, /*=&CStyle::s_apHdlDescs*/
    CBase * pBaseObj,   /*=NULL*/
    DWORD dwOpcode /*=HANDLEPROP_SETHTML*/) : _pHDLDesc(pHDLDesc)
{
    _ppCurrProperties = ppPropertyArray;
    
    _pStyleSheet = pStyleSheet;
    _eDefType = eType;   

    _pCurrSelector = NULL;
    _pCurrRule = NULL;
    _pSiblings = NULL;
    _pBaseObj = pBaseObj;
    _pDefaultNamespace = NULL;

    _iAtBlockNestLevel = 0;

    _fXMLGeneric = fXMLGeneric;
    _fIsStrictCSS1 = fStrictCSS1;

    _dwOpcode = dwOpcode;
    if (fStrictCSS1)
        _dwOpcode |= HANDLEPROP_STRICTCSS1;
           
}

//*********************************************************************
//  CCSSParser::~CCSSParser()
//      The destructor for the CCSSParser class doesn't explicitly do
//  anything - the CBuffer is automatically deleted, though.
//*********************************************************************
CCSSParser::~CCSSParser()
{
    delete _pCurrSelector;
    delete _pSiblings;
    delete _pDefaultNamespace;

    // Buffers are auto-deleted.
}

// Shortcut for loading from files.
HRESULT CCSSParser::LoadFromFile( LPCTSTR szFilename, CODEPAGE codepage )
{
    IStream * pStream;
    HRESULT hr;

    hr = THR(CreateStreamOnFile(szFilename, STGM_READ | STGM_SHARE_DENY_NONE,
                &pStream));

    if (hr == S_OK)
    {
        hr = THR(LoadFromStream(pStream, codepage));
        pStream->Release();
    }

    RRETURN(hr);
}

#define BUF_SIZE    8192

// Shortcut for loading from files.
HRESULT CCSSParser::LoadFromStream(IStream * pStream, CODEPAGE codepage)
{
    CStreamReadBuff streamReader( pStream, NavigatableCodePage( codepage == CP_UNDEFINED ? g_cpDefault : codepage ) );
    HRESULT hr;
    ULONG uLen;
    ULONG cbToRead = 0;
    TCHAR achBuffer[ BUF_SIZE ];
    TCHAR *pchBuffer = NULL;
    LONG lPosition = 0;
    STATSTG statstg;

    Open();

    IGNORE_HR( streamReader.GetPosition( &lPosition ) );
    
    hr = THR(pStream->Stat(&statstg, STATFLAG_DEFAULT));
    if (hr)
        goto Cleanup;

    cbToRead = statstg.cbSize.LowPart;
    if (cbToRead > BUF_SIZE)
    {
        pchBuffer = new TCHAR[cbToRead];
        if (!pchBuffer)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    else
        pchBuffer = achBuffer;
    
    hr = THR(streamReader.Read(pchBuffer, cbToRead, &uLen));
    if (hr == S_FALSE)
        hr = S_OK;

    if (hr || uLen == 0)
        goto Cleanup;

    codepage = CheckForCharset(pchBuffer, uLen);
    
    if (codepage != CP_UNDEFINED && streamReader.SwitchCodePage( codepage ))
    {
        streamReader.SetPosition(lPosition);

        _codepage = streamReader.GetCodePage();
        
        hr = THR(streamReader.Read(pchBuffer, cbToRead, &uLen));
        if (hr == S_FALSE)
            hr = S_OK;

        if (hr || uLen == 0)
           goto Cleanup;
    }
    
    Write(pchBuffer, uLen);

Cleanup:
    if (cbToRead > BUF_SIZE && pchBuffer)
        delete pchBuffer;
    
    Close();

    RRETURN(hr);
}

//*********************************************************************
//  CCSSParser::CheckForCharset()
//      Looks for the @charset directive.  Returns the codepage if
//      found, CP_UNDEFINED if not.
//*********************************************************************

CODEPAGE
CCSSParser::CheckForCharset( TCHAR * pch, ULONG cch )
{
    CODEPAGE codepage = CP_UNDEFINED;

    // Check the directive

    if (*pch == TEXT('@'))
    {
        // NUL terminate for expedience
        TCHAR *pLastCharPos = &pch[cch-1];
        const TCHAR chTemp = *pLastCharPos;
        *pLastCharPos = 0;
        
        if (StrCmpNIC( ++pch, TEXT("charset"), 7) == 0)
        {
            TCHAR chQuote;
            TCHAR *pchStart;
 
            pch += 7;
            
            // Skip whitespace

            while (isspace(*pch)) pch++;

            // Skip quote char, if any.

            if (*pch == DOUBLEQUOTE || *pch == SINGLEQUOTE)
            {
                chQuote = *pch++;
            }
            else
            {
                chQuote = 0;
            }

            pchStart = pch;

            // Find end of string

            while (!isspace(*pch) && *pch != chQuote && *pch != CHAR_SEMI) pch++;

            // Stash a NULL char temporarily

            const TCHAR chTemp = *pch;
            *pch = 0;

            // Ask MLANG for the numeric codepage value

            codepage = CodePageFromAlias( pchStart );

            // Restore buffer

            *pch = chTemp;
        }

        // Reverse the NUL termination

        *pLastCharPos = chTemp;
    }

    return codepage;
}

//*********************************************************************
//  CCSSParser::Open()
//      This method readies the CCSSParser to parse stylesheet data.
//*********************************************************************
void CCSSParser::Open()
{
    _pCurrSelector = NULL;
    _pSiblings = NULL;
    if ( _eDefType == eStylesheetDefinition )   // full stylesheet definition.
    {
        _pStyleSheet->_eParsingStatus = CSSPARSESTATUS_PARSING;
        _ppCurrProperties = NULL;
    }
}


//*********************************************************************
//  CCSSParser::EndStyleDefinition()
//      The parser calls this internal method when it wants to terminate
//  a style definition (usually on '}' or EOD).
//*********************************************************************
HRESULT CCSSParser::EndStyleDefinition( void )
{
    HRESULT hr = S_OK;

    if ( _iAtBlockNestLevel > 0)
    {
        hr = EndAtBlock();
        // Continue if parsing, S_FALSE means done
        if(hr == S_FALSE)
        {
            if(_pCurrRule)
            {
                // Free the _pCurrSelector
                _pCurrRule->Free( );
                // and then free _pCurrRule
                delete _pCurrRule;
            }
            hr = S_OK;
            goto Cleanup;
        }
    }

    if ( ( _eDefType == eStylesheetDefinition ) && _pCurrSelector )
    {   // This is a full stylesheet definition.
        Assert ( "CSSParser must already have an allocated CStyleSheet!" && _pStyleSheet );
        hr = _pStyleSheet->AddStyleRule( _pCurrRule );  // Siblings are handled internally
    }

Cleanup:
    _ppCurrProperties = NULL;
    _pCurrSelector = NULL;
    _pCurrRule = NULL;
    RRETURN(hr);
}

//*********************************************************************
//  CCSSParser::ProcessAtBlock()
//      This method is used to set up parsing of an at-block, e.g. an
//  @page {} or @font-face {} block.
//*********************************************************************
HRESULT
CCSSParser::ProcessAtBlock (EAtBlockType atBlock, Tokenizer &tok, LPTSTR pchAlt)
{
    // At this point, _cbufPropertyName contains the @token name, and
    // _cbufBuffer contains any text between the @token and the '{'

    Tokenizer::TOKEN_TYPE tt;

    Assert(!_pCurrSelector);
    Assert(!_pSiblings);

    if (_iAtBlockNestLevel >= ATNESTDEPTH)
    {
        // This is purely error-recovery - we've nested deeper than we support
        Assert(!"CSS: @block parsing nested too deep!");
        goto Error;
    }

    switch (atBlock)
    {
    case AT_PAGE:
        _sAtBlock[_iAtBlockNestLevel] = new CAtPage(this, tok);
        if(_sAtBlock[_iAtBlockNestLevel] == NULL)
            goto Error;
        break;

    case AT_FONTFACE:
        _sAtBlock[_iAtBlockNestLevel] = new CAtFontFace(this, tok);
        if(_sAtBlock[_iAtBlockNestLevel] == NULL)
            goto Error;

        break;
 
    case AT_MEDIA:
        _sAtBlock[_iAtBlockNestLevel] = new CAtMedia(this, tok, _pStyleSheet);
        if(_sAtBlock[_iAtBlockNestLevel] == NULL)
            goto Error;

        break;

    default:
        Assert(atBlock == AT_UNKNOWN);
        _sAtBlock[_iAtBlockNestLevel] = new CAtUnknown(this, tok, _pStyleSheet, pchAlt);
        if(_sAtBlock[_iAtBlockNestLevel] == NULL)
            goto Error;

        tt = tok.TokenType();
        // Parse past the @unknown selector. it could have multiple rules.
        if (tt == Tokenizer::TT_LCurly)
        {
            UINT nCurlyCount = 1;
            while (nCurlyCount && tt != Tokenizer::TT_EOF)
            {
                tt = tok.NextToken();
                if (tt == Tokenizer::TT_LCurly)
                    nCurlyCount++;
                else if (tt == Tokenizer::TT_RCurly)
                    nCurlyCount--;
            }
        }

        _iAtBlockNestLevel++;
        EndAtBlock(TRUE);

        return S_OK;
    }

    _iAtBlockNestLevel++;
    return S_OK;

Error:
    return S_FALSE;
}


//*********************************************************************
//  CCSSParser::EndAtBlock()
//      This method is used to clean up after parsing of an at-block,
//  e.g. an @page {} or @font-face {} block.
//*********************************************************************
HRESULT CCSSParser::EndAtBlock(BOOL fForceDecrement)
{
    HRESULT hr = S_FALSE;
        
    // We need to clean up the stack for MULTIPLERULE @blocks only when we are before a selector
    if ( _iAtBlockNestLevel > 0)
    {
        if(!_sAtBlock[ _iAtBlockNestLevel - 1]->IsFlagSet(ATBLOCKFLAGS_MULTIPLERULES) || fForceDecrement) 
        {
            _iAtBlockNestLevel--;
            hr = _sAtBlock[ _iAtBlockNestLevel ]->EndStyleRule( _pCurrRule);
            delete (_sAtBlock[ _iAtBlockNestLevel ]);
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        // We've received too many '}' tokens.  Oh well, just ignore them.
    }
    return hr;
}

//+------------------------------------------------------------------------
//
//  Helper Function:    BackupAttrValue
//
//  Synopsis:
//    This function does a backup of the attr corresponding to the PROPERTYDESC ppd
//    in CAttrArray *pAA. If no value is found in the attr array pAttrValue is set to VT_Empty.
//    BE CAREFUL, because the function doesn't free the former value of pAttrValue!
//
//    Input: CAttrArray*, PROPERTYDESC* 
//    Output: CAttrValue
//-------------------------------------------------------------------------

void
BackupAttrValue(CAttrArray *pAA, PROPERTYDESC *ppd, CAttrValue *pAttrValue)
{
    Assert(pAA && ppd && pAttrValue);
    
    // Initialize the AttrValue. Be careful, this doesn't take care of the former value, which may have to
    // be freed.
    pAttrValue->SetAVType(VT_EMPTY);

    AAINDEX ppdAAIndex = AA_IDX_UNKNOWN;

    // Find the index corresponding to the property desc ppd
    ppdAAIndex = pAA->FindAAIndex(ppd->GetDispid(), CAttrValue::AA_Attribute);

    if (ppdAAIndex != AA_IDX_UNKNOWN)
    { // If this property is stored in our array copy it to pAttrValue and return that we've been successful
        pAttrValue->Copy(pAA->FindAt(ppdAAIndex));
    }
}

//+------------------------------------------------------------------------
//
//  Helper Function:    RestoreAttrArray
//
//  Synopsis:
//      This function either restores the pAttrValue back to our CAttrArray
//      or if pAttrValue is of type VT_EMPTY simply deletes the corresponding entry
//
//  Input: CAttrArray*, PROPERTYDESC*, pAttryValue 
//  Modifies: CAttrArray*
//-------------------------------------------------------------------------

void
RestoreAttrArray(CAttrArray *pAA, PROPERTYDESC *ppd, CAttrValue *pAttrValue)
{
    Assert(pAA && ppd && pAttrValue);

    AAINDEX ppdAAIndex = AA_IDX_UNKNOWN;

    // Find the index corresponding to the property desc ppd
    ppdAAIndex = pAA->FindAAIndex(ppd->GetDispid(), CAttrValue::AA_Attribute);

    if (ppdAAIndex != AA_IDX_UNKNOWN)
    { // There is an entry in the current attribute array
        if (pAttrValue->GetAVType() == VT_EMPTY)
        { // pAttrValue is NULL iff there hasn't been any entry, originally
            (pAA->Delete(ppdAAIndex));
        }
        else 
        {    // Restore the attr value
            (pAA->FindAt(ppdAAIndex))->Copy(pAttrValue);
        }
    }
}
            
//+------------------------------------------------------------------------
//
//  Helper Function:    RemoveQuotes
//
//  Synopsis:
//      This function determines if a string is quoted and removes the matching
//  quotes from the string. If the quots do not match or there are no quotes
//  it returns S_FALSE
//-------------------------------------------------------------------------

HRESULT
RemoveQuotes(LPTSTR *ppszStr)
{
    TCHAR       chQuote;
    LPTSTR      pstrProp;
    LPTSTR      pstrPropEnd;
    HRESULT     hr = S_FALSE;

    // Remove the spaces before the quote (if there are spaces and a quote)
    while (_istspace(**ppszStr)) (*ppszStr)++;

    pstrProp = *ppszStr;

    // Skip the quote if it is present and remember the quote type
    if ((*pstrProp != DOUBLEQUOTE) && (*pstrProp != SINGLEQUOTE))
        // The string does not start with a quote, ignore it
        goto Cleanup;

    chQuote = *pstrProp;
    pstrProp++;

    // Scan for a matching quote
    while(*pstrProp != _T('\0') && *pstrProp != chQuote)
        pstrProp++;

    if(*pstrProp == _T('\0'))
        // No matching quote
        goto Cleanup;

    // Save the ending quote position
    pstrPropEnd = pstrProp;

    pstrProp++;

    // Check to see if the quote is the last thing in the string 
    while (_istspace(*pstrProp)) pstrProp++;
    if(*pstrProp != _T('\0'))
        goto Cleanup;

    /// Remove the starting quote
    (*ppszStr)++;
    // Remove the ending quote
    *pstrPropEnd = _T('\0');
    hr = S_OK;

Cleanup:
    if(hr == S_FALSE)
    {
        // Remove the spaces at the end of the string
        int nUrlLen = _tcslen(*ppszStr);
        while (nUrlLen > 0 && _istspace( (*ppszStr)[--nUrlLen] ) )
            (*ppszStr)[nUrlLen] = _T('\0');
    }

    RRETURN1(hr, S_FALSE);
}



//+------------------------------------------------------------------------
//
//  Helper Function:    RemoveStyleUrlFromStr
//
//  Synopsis:
//      This function determines if a string is a valid CSS-style URL
//  functional notation string (e.g. "url(http://www.foo.com/bar)") and
//  returns the url string without url( and ) and surrounding quotes
//  !!!! This function modifies the parameter string pointer
//
//  Return Values:
//      S_OK if there was a url and S_FALSE it there was no URL string in front
//      
//-------------------------------------------------------------------------

HRESULT 
RemoveStyleUrlFromStr(TCHAR **ppszURL)
{
    HRESULT       hr = S_OK;
    int           nUrlLen;

    // Remove the leading spaces
    while ( _istspace(**ppszURL)) (*ppszURL)++;
    // and the trailing spaces
    nUrlLen = _tcslen(*ppszURL);
    while (nUrlLen > 0  && _istspace( (*ppszURL)[--nUrlLen] ) )  (*ppszURL)[nUrlLen] = _T('\0');

    // Check if our URL is a CSS url(xxx) string.  If so, strip "url(" off front,
    // and ")" off back.  Otherwise assume it'a a straight URL.
    if (!ValidStyleUrl(*ppszURL))
    {
        RemoveQuotes(ppszURL);
        hr = S_FALSE;
        goto Cleanup;
    }

    // Skip the "url(" (-1 for the terminating 0)
    *ppszURL += ARRAY_SIZE(strURLBeg) - 1;

    // Now cut from the end the closing )
    nUrlLen = _tcslen(*ppszURL);
    (*ppszURL)[--nUrlLen] = _T('\0');

    // Remove the leading spaces
    while ( _istspace(**ppszURL))  {(*ppszURL)++; nUrlLen--; }
    // Now remove the trailing spaces
    while (nUrlLen > 0 && _istspace( (*ppszURL)[--nUrlLen] ) )
        (*ppszURL)[nUrlLen] = _T('\0');

    RemoveQuotes(ppszURL); 

Cleanup:
    // Remove the leading spaces
    while ( _istspace(**ppszURL))  {(*ppszURL)++; nUrlLen--; }
    // Now remove the trailing spaces
    while (nUrlLen > 0 && _istspace( (*ppszURL)[--nUrlLen] ) )
        (*ppszURL)[nUrlLen] = _T('\0');

    RRETURN1(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  Helper Function:    NextSize
//
//  Synopsis:
//      This function tokenizes a font-size; we can't just tokenize on space,
//  in case we have a string like "12 pt".  This function returns a pointer
//  to the first character that is not part of the first size specifier in the
//  string.  It may or may not skip whitespace following the size specifier.
//
//  Return Values:
//      NULL on error (no size at the head of this string)
//      "" if the end of the string was reached.
//      pointer to following characters if success.
//-------------------------------------------------------------------------
TCHAR *NextSize( TCHAR *pszSize, const NUMPROPPARAMS *ppp )
{
    TCHAR *pszChar = pszSize;
    TCHAR *pszLastSpace = NULL;

    Assert( pszSize != NULL );

    // Skip any leading whitespace
    while ( _istspace( *pszChar ) )
        pszChar++;

    // it's okay for the first character to be '-' or '+'
    if ( ( *pszChar == _T('-') ) || ( *pszChar == _T('+') ) )
        pszChar++;

    // if the first character (after any '-') is not a digit, check if it's an enumerated size, then error.
    if ( !_istdigit( *pszChar ) && ( *pszChar != _T('.') ) )
    {
        if ( ppp -> bpp.dwPPFlags & PROPPARAM_ENUM )
        {
            TCHAR chTerm;
            TCHAR *pszToken = pszChar;
            long lEnum;

            while ( _istalpha( *pszChar ) || ( *pszChar == _T('-') ) )
                pszChar++;

            chTerm = *pszChar;
            *pszChar = 0;

            HRESULT hr = LookupEnumString ( ppp, pszToken, &lEnum );
            *pszChar = chTerm;
            if ( hr == S_OK )
            {
                return pszChar;
            }
        }

        return NULL;
    }

    // Now we know we have at least one digit, so we can pull a size out of it.

    // Skip over all the digits
    while ( _istdigit( *pszChar ) || ( *pszChar == _T('.') ) )
        pszChar++;

    //  Skip any whitespace between the last digit and the (potential) unit string
    pszLastSpace = pszChar;
    while ( _istspace( *pszChar ) )
        pszChar++;

    //  If the string is "in", parse it as inches
    if (    ( pszChar[0] && pszChar[1] ) // Make sure at least two chars remain
        &&  (   !_tcsnicmp( _T("in"), 2, pszChar, 2 )
            ||  !_tcsnicmp( _T("cm"), 2, pszChar, 2 )
            ||  !_tcsnicmp( _T("mm"), 2, pszChar, 2 )
            ||  !_tcsnicmp( _T("em"), 2, pszChar, 2 )
            ||  !_tcsnicmp( _T("ex"), 2, pszChar, 2 )
            ||  !_tcsnicmp( _T("pt"), 2, pszChar, 2 )
            ||  !_tcsnicmp( _T("pc"), 2, pszChar, 2 )
            ||  !_tcsnicmp( _T("px"), 2, pszChar, 2 ) ) )
        return (pszChar + 2);

    if ( *pszChar == _T('%') )  // If the string ends with '%', it's a percentage
        return pszChar+1;

    // Default is to treat the string as "px" and parse it as pixels
    return pszLastSpace;
}

//+------------------------------------------------------------------------
//
//  Function:     ::SetStyleProperty
//
//  Synopsis:   Add a style property name/value pair to the CAttrArray,
//  store as an unknown pair if the property is not recognized.
//
//-------------------------------------------------------------------------
HRESULT CCSSParser::SetStyleProperty(Tokenizer &tok)
{
    HRESULT                 hr = S_OK;
    TCHAR                   chOld = _T('\0');
    WORD                    wMaxstrlen = 0;
    DISPID                  dispid = DISPID_UNKNOWN;
    const PROPERTYDESC     *found;
    BOOL                    fFoundExpression = FALSE;
    BOOL                    fImportant = FALSE;
    TCHAR                  *pchPropName;
    Tokenizer::TOKEN_TYPE   tt = Tokenizer::TT_Unknown;
    
    Assert(tok.IsIdentifier(tok.TokenType()));
    if (LPTSTR(_cbufPropertyName))
        _cbufPropertyName.Set(tok.GetStartToken(), tok.GetTokenLength());
    pchPropName = LPTSTR(_cbufPropertyName);

    // Get the propertyName.
    Assert(_pHDLDesc && "Should have a propdesc list!");

    found = pchPropName ? _pHDLDesc->FindPropDescForName(pchPropName) : NULL;

    wMaxstrlen = found ? ((found->GetBasicPropParams()->wMaxstrlen == pdlNoLimit) ? 0 : (found->GetBasicPropParams()->wMaxstrlen ? found->GetBasicPropParams()->wMaxstrlen : DEFAULT_ATTR_SIZE)) : 0;

    if (_fIsStrictCSS1) 
    {
    	// Next token must be a colon
    	if (tt != Tokenizer::TT_EOF)
            tt = tok.NextToken();

        // Under strict css the next token _must_ be a colon. If the next token
        // is not a colon we try to bring the parser back in a valid state. I.e.
        // we search for a semicolon or a right curly (both close a property/value pair).
        if (tt != Tokenizer::TT_Colon) 
        {
            // (Error recovery) Next token was _not_ a colon. Eat until we find a 
            // promissing position to begin parsing again.
            while (tt != Tokenizer::TT_EOF && 
                tt != Tokenizer::TT_Semi && 
                tt != Tokenizer::TT_RCurly)
            {
                if (tt == Tokenizer::TT_LCurly)
                {
                    // Eat nested curlies, e.g. color: { { { { }} }};
                    UINT nCurlyCount = 1;
                    while (nCurlyCount && tt != Tokenizer::TT_EOF)
                    {
                        tt = tok.NextToken();
                        if (tt == Tokenizer::TT_LCurly)
                            nCurlyCount++;
                        else if (tt == Tokenizer::TT_RCurly)
                            nCurlyCount--;
                    }
                    Assert(tt == Tokenizer::TT_RCurly || tt == Tokenizer::TT_EOF);
                    // We still need to find a valid end for the property/value pair
                    if (tt != Tokenizer::TT_EOF)
                        tt = tok.NextToken();
                }
                else
                {
                    tt = tok.NextToken();	
                }
            }
            goto Cleanup;
        }
        // If we have found a colon we are fine.
    }
    else
    {
        while (tt != Tokenizer::TT_Colon &&
            tt != Tokenizer::TT_Equal &&
            tt != Tokenizer::TT_Semi &&
            tt != Tokenizer::TT_RCurly &&
            tt != Tokenizer::TT_EOF)
        {
            tt = tok.NextToken();
        }
    }

    Assert (tt == Tokenizer::TT_Colon ||
            tt == Tokenizer::TT_Equal ||
            tt == Tokenizer::TT_Semi ||
            tt == Tokenizer::TT_RCurly ||
            tt == Tokenizer::TT_EOF);

    if (tt != Tokenizer::TT_EOF)
    {
        TCHAR *pchValue;

        if (tt == Tokenizer::TT_RCurly || tt == Tokenizer::TT_Semi)
        {
            _cbufBuffer.Clear();
        }
        else
        {
            Assert (tt == Tokenizer::TT_Colon || tt == Tokenizer::TT_Equal);

            if (tt == Tokenizer::TT_Colon)
            {
                tok.NextNonSpaceChar();
                Assert (tt == Tokenizer::TT_Colon);
            }

            // TODO: for now return the string and pass it to the value type handler (parser).
            //         should really pass the tokenizer (tok) and let the value type handler do the
            //         parsing w/ the tokenizer.
        
            tok.StartSequence(&_cbufBuffer);

            // Get the propertyValue
            while (tt != Tokenizer::TT_EOF && tt != Tokenizer::TT_Semi && tt != Tokenizer::TT_RCurly && tt != Tokenizer::TT_Bang)
            {
                tt = tok.NextToken(TRUE);
                if (tt == Tokenizer::TT_LCurly)
                {
                    UINT nCurlyCount = 1;
                    while (nCurlyCount && tt != Tokenizer::TT_EOF)
                    {
                        tt = tok.NextToken();
                        if (tt == Tokenizer::TT_LCurly)
                            nCurlyCount++;
                        else if (tt == Tokenizer::TT_RCurly)
                            nCurlyCount--;
                    }
                    Assert(tt == Tokenizer::TT_RCurly || tt == Tokenizer::TT_EOF);
                    tt = Tokenizer::TT_LCurly;
                }
                else if (tt == Tokenizer::TT_LParen)
                    tt = tok.NextToken(TRUE, FALSE, !_fIsStrictCSS1);
            }
        
            tok.StopSequence();
        }
        pchValue = LPTSTR(_cbufBuffer);

        if (wMaxstrlen && _cbufBuffer.Length() > wMaxstrlen)
        {
            chOld = pchValue[wMaxstrlen];
            pchValue[wMaxstrlen] = _T('\0');
        }

        // Look for !important
        if (tt == Tokenizer::TT_Bang)
        {
            tt = tok.NextToken();
            if (tok.IsIdentifier(tt) && tok.IsKeyword(_T("important")))
            {
                fImportant = TRUE;
            }
        }

        if (!pchPropName || !pchValue)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        if (_iAtBlockNestLevel > 0)
        {
            // Remove the extra outside quotes form the property value
            RemoveQuotes(&pchValue);
            if (_sAtBlock[_iAtBlockNestLevel - 1])
                hr = _sAtBlock[_iAtBlockNestLevel - 1]->SetProperty(pchPropName, pchValue, FALSE);    // TODO: substitute important
            // S_FALSE means done the at block does not want to continue parsing
            if(hr == S_FALSE)
            {
                hr = S_OK;
                goto Cleanup;
            }
            // We set the properties as usual
        }

        if (found)
        {
            dispid = found->GetDispid();        // remember this for later

            hr = THR(SetExpression(dispid, wMaxstrlen, chOld));
            if (hr == S_OK)
            {
                fFoundExpression = TRUE;
                goto Cleanup;
            }
            else if (hr != S_FALSE)
                goto Cleanup;

            // S_FALSE means we didn't find an expression.  Fall through and process normally
            hr = S_OK;
        }

        if (_ppCurrProperties)
        {
            if (found && (found->pfnHandleProperty))
            {
                DWORD dwOpcode = _dwOpcode;

                // The flag HANDLEPROP_STRICTCSS1 is set in dwOpcode in the CSSParser constructure and should not be altered later.
                Assert(!_fIsStrictCSS1 || (dwOpcode & HANDLEPROP_STRICTCSS1));

                if (fImportant)
                    dwOpcode |= HANDLEPROP_IMPORTANT;

                // Remove the extra outside quotes form the property value, except for the font-family
                // font-family low level handler will take care of the quotes
                // In the case of font-family the problem is that many real world sites use the wrong syntax 
                // for listing fonts like font-face:"a,b,c". If we do not remove the quotes in this case we 
                // would break lots of things. We still want to preserve the quotes in other cases
                if(!_fIsStrictCSS1 && (found != &(s_propdescCStylefontFamily.a) || _tcschr(pchValue, _T(','))))
                {
                    RemoveQuotes(&pchValue);
                }

                // Try and parse attribute
#ifdef WIN16
                hr = THR((found->pfnHandleProperty)((PROPERTYDESC *)found,
                                                    (dwOpcode|(PROPTYPE_LPWSTR<<16)),
                                                    (CVoid *)pchValue,
                                                    _pBaseObj,
                                                    (CVoid *)((found->GetPPFlags() & PROPPARAM_ATTRARRAY) ?
                                                                    (void*)_ppCurrProperties :
                                                                    (void*) _pBaseObj)));
#else
                hr = THR (CALL_METHOD(found,
                                      found->pfnHandleProperty,
                                      ((dwOpcode|(PROPTYPE_LPWSTR<<16)),
                                      (CVoid *)pchValue,
                                      _pBaseObj,
                                      (CVoid *)((found->GetPPFlags() & PROPPARAM_ATTRARRAY) ?
                                                (void*)_ppCurrProperties :
                                                (void*)_pBaseObj))));
#endif
                if (hr)
                {
                    // We got an illegal value for a property, stuff it into the attr array as an unknown
                    if (chOld)
                    {
                        pchValue[wMaxstrlen] = chOld;
                        chOld = 0;
                    }
                    hr = CAttrArray::SetString(_ppCurrProperties, found, pchValue, TRUE, CAttrValue::AA_Extra_DefaultValue);
                    goto Cleanup;
                }
                else
                {
                    // We need to check for position:absolute and position:relative so that 
                    // region collection is not built when not needed. This is a temporary
                    // optimization and will go away soon.
                    if (found == &(s_propdescCStyleposition.a) && (*_ppCurrProperties))
                    {
                        CElement *pElem;
                        CDoc     *pDoc;

                        GetParentElement(&pElem);

                        if (pElem)
                        {
                            pDoc = pElem->Doc();

                            if (!pDoc->NeedRegionCollection())
                            {
                                DWORD dwVal;
                                BOOL fFound = (*_ppCurrProperties)->FindSimple(DISPID_A_POSITION, &dwVal);

                                if (fFound && ((stylePosition)dwVal == stylePositionrelative || 
                                    (stylePosition)dwVal == stylePositionabsolute))
                                {
                                    pDoc->_fRegionCollection = TRUE;
                                }
                            }
                        }
                    }

                    // got a match
                    goto Cleanup;
                }
            }
            else if (!found)
            {   // Not found... should be added as an expando.
                VARIANT     varNew;
                CBase      *pBase;

                // Create an expando
                if (_eDefType == eSingleStyle)
                    pBase = _pBaseObj;
                else
                {
                    if (!_pStyleSheet->GetParentElement())
                        goto Cleanup;
                    pBase = _pStyleSheet;
                }

                Assert(pBase);

                hr = pBase->GetExpandoDispID(pchPropName, &dispid, fdexNameCaseSensitive|fdexNameEnsure);
                if (hr)
                    goto Cleanup;

                hr = THR(SetExpression(dispid));
                if (hr == S_OK)
                {
                    fFoundExpression = TRUE;
                    goto Cleanup;
                }
                else if (hr == S_FALSE)
                {
                    varNew.vt = VT_LPWSTR;
                    varNew.byref = (LPTSTR)pchValue;

                    hr = THR(CAttrArray::Set(_ppCurrProperties, dispid, &varNew, NULL, CAttrValue::AA_Expando));
                    if (hr)
                        goto Cleanup;
                }
                else
                    goto Cleanup;
            }
        }
    }

Cleanup:
    RRETURN(hr);
}

BOOL
CCSSParser::Declaration (Tokenizer &tok, BOOL fCreateSelector)
{
    Tokenizer::TOKEN_TYPE   tt = Tokenizer::TT_Unknown;

    // Begin a style declaration
    if (_eDefType == eStylesheetDefinition && fCreateSelector)   // full stylesheet definition.
    {
        if (_pCurrSelector)
            _pCurrSelector->SetSibling(_pSiblings);
        else
        {
            _pCurrSelector = _pSiblings;
            // If there's a style decl with no selector, we give
            if (!_pCurrSelector)                    
                _pCurrSelector = new CStyleSelector();

            if (!_pCurrSelector)
                goto Cleanup;
        }

        _pSiblings = NULL;
        _pCurrRule = new CStyleRule(_pCurrSelector);
        if (!_pCurrRule)
            goto Cleanup;

        _ppCurrProperties = _pCurrRule->GetRefStyleAA();
    }

    tt = tok.TokenType();

    while (tt != Tokenizer::TT_EOF)
    {
        if (tok.IsIdentifier(tt))
            SetStyleProperty(tok); 

        // continue fetching for more prop/value pairs...
        tt = tok.TokenType();
        if (tt == Tokenizer::TT_RCurly)
            break;

        tt = tok.NextToken();
    }

Cleanup:
    return TRUE;
}

BOOL
CCSSParser::RuleSet(Tokenizer &tok)
{
    Tokenizer::TOKEN_TYPE tt = tok.TokenType();

    while (tt != Tokenizer::TT_EOF)
    {
        // selector+ [pseudo_element | solitary_pseudo_element]? | solitary_pseudo_element
        // 
        CStyleSelector *pNew = new CStyleSelector(tok, _pCurrSelector, _fIsStrictCSS1, _fXMLGeneric);
        if (!pNew)
        {
            goto Cleanup;
        }

        tt = tok.TokenType();
        // skip comments in selector names.
        while(tt == Tokenizer::TT_Comment && tt != Tokenizer::TT_EOF)
            tt = tok.NextToken();

        // More than one selector?
        if (tt == Tokenizer::TT_Comma)
        {   // This is a sibling in a group listing.
            // Push the new selector on the front of the sibling list
            pNew->SetSibling(_pSiblings);
            _pSiblings = pNew;
            _pCurrSelector = NULL;

            while(tt == Tokenizer::TT_Comma || tt == Tokenizer::TT_Comment)
                tt = tok.NextToken();
        }
        else
        {   // This is (or might be) the beginning of a context list.
            _pCurrSelector = pNew;
        }

        // if it is continue with the next selector (which will be the child\sibling of this one) 
        // else get outa here.
        if (!tok.IsIdentifier(tt) &&
            tt != Tokenizer::TT_Asterisk &&
            tt != Tokenizer::TT_Hash &&
            tt != Tokenizer::TT_Dot &&
            tt != Tokenizer::TT_Colon)
            break;
    }

Cleanup:
    return TRUE;
}

//*********************************************************************
//  CCSSParser::Write()
//      This method is used to pass a block of data to the stylesheet
//  parser. It returns the data actually written if it succeeds and 0
//  if it fails.
//*********************************************************************
ULONG
CCSSParser::Write(TCHAR *pData, ULONG ulLen )
{
    HRESULT hr=S_OK;
    BOOL fCreateSelector = TRUE;
    Tokenizer tok;
    tok.Init(pData, ulLen);

    Tokenizer::TOKEN_TYPE tt;
    tt = tok.NextToken();

    if (_eDefType == eSingleStyle)
    {
        while (tt != Tokenizer::TT_EOF)
        {
            Declaration(tok);
            tt = tok.NextToken();
        }
    }
    else
    {
        // [CDO | CDC]* | [import [CDO | CDC]*]* | [ruleset [CDO | CDC]*]*
        while (tt != Tokenizer::TT_EOF)
        {
            if (tt == Tokenizer::TT_At)
            {
                tt = tok.NextToken();

                // @import [STRING | URL] ';'
                if (tok.IsKeyword(_T("import")))
                {
                    BOOL    fNeedRParen = FALSE;
                    BOOL    fSyntaxError = TRUE;

                    // remember start of selector name in case of malformed @import
                    TCHAR *pStart = tok.GetStartSeq();

                    // [STRING | URL]
                    tt = tok.NextToken();
                    while (!tok.IsIdentifier(tt) && tt != Tokenizer::TT_String && tt != Tokenizer::TT_EOF)
                        tt = tok.NextToken();

                    if (tok.IsKeyword(_T("url")))
                    {
                        if (tok.NextToken() == Tokenizer::TT_LParen)
                        {
                            fNeedRParen = TRUE;
                            tt = tok.NextToken(TRUE, FALSE, !_fIsStrictCSS1);
                            // Should be URL string at this point.
                        }
                    }

                    // Get the URL of the @import
                    if (tt == Tokenizer::TT_String || (fNeedRParen && tt == Tokenizer::TT_RParen))
                    {
                        // Semi-colon required for @import
                        tt = tok.NextToken();
                        while (tt == Tokenizer::TT_Comment)
                            tt = tok.NextToken();

                        if (tt == Tokenizer::TT_Semi)
                        {
                            fSyntaxError = FALSE;
                            if (_pStyleSheet)
                                _pStyleSheet->AddImportedStyleSheet(tok.GetTokenValue(), /* parsing */TRUE);
                        }
                    }

                    if (fSyntaxError)
                    {
                        while (tt != Tokenizer::TT_Semi && tt != Tokenizer::TT_LCurly && tt != Tokenizer::TT_EOF)
                            tt = tok.NextToken();

                        CStr cstrAlt;
                        hr = cstrAlt.Set(pStart, tok.GetSeqLength(pStart));
                        if (hr != S_OK)
                            goto Cleanup;

                        if (tt == Tokenizer::TT_LCurly)
                        {
                            // Error parsing @import, treat as unknown @block
                            ProcessAtBlock(AT_UNKNOWN, tok, cstrAlt);
                        }
                        else if (tt == Tokenizer::TT_Semi)
                        {
                            if (_pStyleSheet)
                                _pStyleSheet->AddImportedStyleSheet(cstrAlt, /* parsing */ TRUE);
                        }
                    }
                }
                // @page S* '{' S* declaration [ ';' S* declaration ]* '}'
                else if (tok.IsKeyword(_T("page")))
                {
                    ProcessAtBlock(AT_PAGE, tok);
                    fCreateSelector = FALSE;
                    tt = tok.TokenType();
                    // if already at left curly, skip this loop to process left curly in next.
                    if (tt == Tokenizer::TT_LCurly)
                        continue;
                }
                // @media S* '{' S* ruleset* '}'
                else if (tok.IsKeyword(_T("media")))
                {
                    ProcessAtBlock(AT_MEDIA, tok);
                }
                // @font-face S* '{' S* declaration [ ';' S* declaration ]* '}'
                else if (tok.IsKeyword(_T("font-face")))
                {
                    ProcessAtBlock(AT_FONTFACE, tok);
                    fCreateSelector = FALSE;
                    tt = tok.TokenType();
                    // if already at left curly, skip this loop to process left curly in next.
                    if (tt == Tokenizer::TT_LCurly)
                        continue;
                }
                else
                {
                    // Error, unknown @block
                    ProcessAtBlock(AT_UNKNOWN, tok);
                }
            }
            else if (tt == Tokenizer::TT_Comment ||
                     tt == Tokenizer::TT_EndHTMLComment ||
                     tt == Tokenizer::TT_BeginHTMLComment ||
                     tt == Tokenizer::TT_Comma)
            {

            }
            else if (tt == Tokenizer::TT_RCurly)
            {
                EndAtBlock(TRUE);
            }
            else if (tt == Tokenizer::TT_LCurly)
            {
                // Process values until TT_RCurly.
                tt = tok.NextToken();

                if (Declaration(tok, fCreateSelector))
                {
                    fCreateSelector = TRUE;
                    tt = tok.TokenType();
                    if (tt == Tokenizer::TT_RCurly)
                    {
                        EndStyleDefinition();
                        // End of Declaration we're done with this parse loop.
                        
                        tt = tok.NextToken();
                        // Even though a ';' is invalid between rules, we need this hack to allow
                        // it to be ignored for compat reasons as it is a fairly common occurance.
                        if (tt != Tokenizer::TT_Semi)
                            continue;
                    }
                    else
                        continue;   // Error, start over with this token.
                }
            }
            else if (RuleSet(tok))
            {
                // if selector not followed by a left curly, error! delete current selector and process next token
                tt = tok.TokenType();
                if (tt != Tokenizer::TT_LCurly)
                {
                    if (_pCurrSelector)
                    {
                        delete _pCurrSelector;
                        _pCurrSelector = NULL;
                    }
                    if (_pSiblings)
                    {
                        delete _pSiblings;
                        _pSiblings = NULL;
                    }

                    while (tt != Tokenizer::TT_LCurly &&
                           tt != Tokenizer::TT_RCurly &&
                           tt != Tokenizer::TT_BeginHTMLComment &&
                           tt != Tokenizer::TT_EndHTMLComment &&
                           tt != Tokenizer::TT_EOF)
                        tt = tok.NextToken(FALSE, TRUE);
                }

                // continue to LCurly in the next loop
                Assert(tt == Tokenizer::TT_LCurly ||
                       tt == Tokenizer::TT_RCurly ||
                       tt == Tokenizer::TT_BeginHTMLComment ||
                       tt == Tokenizer::TT_EndHTMLComment ||
                       tt == Tokenizer::TT_EOF);
                continue;
            }
            else
            {
                    // BAD Parsing...
            }

            // Fetch next token...
            tt = tok.NextToken();
        }
    }

Cleanup:
    if (hr != S_OK)
        return 0;
    return ulLen;

}


//*********************************************************************
//  CCSSParser::Close()
//      This method finishes off any current style or stylesheet declaration.
//*********************************************************************
void CCSSParser::Close()
{
    if ( _ppCurrProperties)
        EndStyleDefinition();

    if ( _eDefType == eStylesheetDefinition )
    {
        _pStyleSheet->_eParsingStatus = CSSPARSESTATUS_DONE;
    }

    // If for some reason at blocks are left in the @block stack, delete them
   while(_iAtBlockNestLevel-- > 0)
       delete _sAtBlock[_iAtBlockNestLevel];
}


//+---------------------------------------------------------------------------
//
// CStyle
//
//----------------------------------------------------------------------------
#define _cxx_
#include "style.hdl"


//+------------------------------------------------------------------------
//
//  Member:     CStyle::CStyle
//
//-------------------------------------------------------------------------
CStyle::CStyle(CElement *pElem, DISPID dispID, DWORD dwFlags, CAttrArray * pAA /*=NULL*/)
{
    WHEN_DBG(_dwCookie=eCookie;)

    _pElem = pElem;
    _dispIDAA = dispID;

    if (pElem)
    {
        if (dispID != DISPID_UNKNOWN)
        {
            _pAA = *pElem->CreateStyleAttrArray(_dispIDAA);
        }
    }

    ClearFlag(STYLE_MASKPROPERTYCHANGES);
    SetFlag(dwFlags);
    if (TestFlag(STYLE_SEPARATEFROMELEM))
    {
        Assert(_pElem);
        _pElem->SubAddRef();
    }

    if (pAA && TestFlag(STYLE_DEFSTYLE))
    {
        Assert(dispID == DISPID_UNKNOWN);
        _pAA = pAA;
    }

    Assert( TestFlag(STYLE_REFCOUNTED) || !TestFlag(STYLE_SEPARATEFROMELEM) || TestFlag(STYLE_DEFSTYLE) );
}

//+------------------------------------------------------------------------
//
//  Member:     CStyle::~CStyle
//
//-------------------------------------------------------------------------
CStyle::~CStyle()
{
    if (!TestFlag(STYLE_REFCOUNTED))
    {
        Passivate();
    }
}

void CStyle::Passivate()
{
    if (_pStyleSource)
    {
        _pStyleSource->Release();
        _pStyleSource = NULL;
    }

    if (TestFlag(STYLE_SEPARATEFROMELEM))
    {
        _pElem->SubRelease();
        _pElem = NULL;
    }
    else
    {
        // Don't leave this alone, or CBase::Passivate will try to manage its destruction.
        // Since it doesn't actually belong to us (it belongs to its entry in _pElem->_pAA),
        // this would cause problems.
        _pAA = NULL;
    }
    super::Passivate();
}


ULONG CStyle::PrivateAddRef ( void )
{
    Assert(_pElem);
    if (!TestFlag(STYLE_SEPARATEFROMELEM))
    {
        _pElem->AddRef();
    }
    else if (TestFlag(STYLE_DEFSTYLE))
    {
        CDefaults *pDefaults = _pElem->GetDefaults();
        Assert(pDefaults);
        _pElem->AddRef();
        pDefaults->PrivateAddRef();
    }
    else
    {
        super::PrivateAddRef();
    }

    return 0;
}

ULONG CStyle::PrivateRelease( void )
{
    Assert(_pElem);
    if (!TestFlag(STYLE_SEPARATEFROMELEM))
    {
        _pElem->Release();
    }
    else if (TestFlag(STYLE_DEFSTYLE))
    {
        CDefaults *pDefaults = _pElem->GetDefaults();
        Assert(pDefaults);
        _pElem->Release();
        pDefaults->PrivateRelease();
    }
    else
    {
        super::PrivateRelease();
    }

    return 0;
}


const CStyle::CLASSDESC CStyle::s_classdesc =
{
    {
        &CLSID_HTMLStyle,                    // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        NULL,                                // _apClsidPages
#endif // NO_PROPERTY_PAGE
        NULL,                                // _pcpi
        0,                                   // _dwFlags
        &IID_IHTMLStyle,                     // _piidDispinterface
        &s_apHdlDescs,                       // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLStyle,              // _apfnTearOff
};

BEGIN_TEAROFF_TABLE(CStyle, IServiceProvider)
        TEAROFF_METHOD(CStyle, QueryService, queryservice, (REFGUID guidService, REFIID riid, void **ppvObject))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CStyle, IRecalcProperty)
    TEAROFF_METHOD(CStyle, GetCanonicalProperty, getcanonicalproperty, (DISPID dispid, IUnknown **ppUnk, DISPID *pdispid))
END_TEAROFF_TABLE()


//+---------------------------------------------------------------------------
//
//  Helper Function:    InvokeSourceGet
//
//----------------------------------------------------------------------------

HRESULT
InvokeSourceGet(IDispatch * pdisp, DISPID dispid, VARTYPE varTypeResultRequested, void * pv)
{
    HRESULT     hr;
    CInvoke     invoke(pdisp);

    hr = THR(invoke.Invoke(dispid, DISPATCH_PROPERTYGET));
    if (hr)
        goto Cleanup;


    switch (varTypeResultRequested)
    {
    case VT_VARIANT:
        hr = VariantCopy ((VARIANT*)pv, invoke.Res());
        break;

    case VT_BSTR:
        if (VT_BSTR != V_VT(invoke.Res()))
        {
            Assert (FALSE);
            hr = E_NOTIMPL;
            goto Cleanup;
        }

        *((BSTR*)pv) = V_BSTR(invoke.Res());
        V_VT(invoke.Res()) = VT_EMPTY; // to avoid freeing the result
        V_BSTR(invoke.Res()) = NULL;

        break;

    case VT_I4:

        if (VT_I4 != V_VT(invoke.Res()))
        {
            Assert (FALSE);
            hr = E_NOTIMPL;
            goto Cleanup;
        }

        *((UINT*)pv) = V_I4(invoke.Res());

        break;

    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStyle::NeedToDelegateGet
//
//----------------------------------------------------------------------------

BOOL
CStyle::NeedToDelegateGet(DISPID dispid)
{
    CAttrArray **ppAA = GetAttrArray();
    return (_pStyleSource && ppAA && *ppAA &&
            AA_IDX_UNKNOWN == (*ppAA)->FindAAIndex(dispid, CAttrValue::AA_Attribute));
}

//+---------------------------------------------------------------------------
//
//  Member:     CStyle::DelegateGet
//
//----------------------------------------------------------------------------

HRESULT
CStyle::DelegateGet(DISPID dispid, VARTYPE varType, void * pv)
{
    return InvokeSourceGet(_pStyleSource, dispid, varType, pv);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStyle::getValueHelper, public
//
//  Synopsis:   Helper function to implement get_ top/left/width/height
//
//  Arguments:  [plValue] -- Place to put value
//              [dwFlags] -- Flags indicating whether its an X or Y attribute
//              [puv]     -- CUnitValue containing the value we want to return
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

enum putValueFlags
{
    PUTVF_X     = 0x1,
    PUTVF_SIZE  = 0x2,
    PUTVF_Y     = 0x4,
    PUTVF_POS   = 0x8
};


HRESULT
CStyle::getValueHelper(long *plValue, DWORD dwFlags, const PROPERTYDESC *pPropertyDesc)
{
    HRESULT       hr = S_OK;
    RECT          rcParent;
    CUnitValue    uvTemp;
    DWORD         dwVal;
    CLayout     * pLayoutParent;
    long          lParentSize;

    if (!plValue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (_pElem)
    {    
        hr = THR(_pElem->EnsureInMarkup());
        if (hr)
            goto Cleanup;
            
        if (_pElem->Doc()->_fDefView)
        {
            switch (pPropertyDesc->GetDispid())
            {
            case DISPID_CStyle_width:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedwidth();
                break;
                
            case DISPID_CStyle_left:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedleft();
                break;
                
            case DISPID_CStyle_top:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedtop();
                break;
                
            case DISPID_CStyle_right:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedright();
                break;
                
            case DISPID_CStyle_bottom:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedbottom();
                break;
                
            case DISPID_CStyle_height:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedheight();
                break;

            default:
                Assert(0 && "Unexpected dispid");
                break;
            }
        }
        else
        {
            CAttrArray **ppAA = GetAttrArray();
            if (ppAA)
                CAttrArray::FindSimple(*ppAA, pPropertyDesc, &dwVal);
            else
                dwVal = (DWORD)pPropertyDesc->ulTagNotPresentDefault;

            uvTemp.SetRawValue(dwVal);
        }
    }
    
    if (!uvTemp.IsNull() && _pElem)
    {
        CDocInfo    DCI;


        pLayoutParent = _pElem->GetFirstBranch()->Parent()->GetUpdatedNearestLayout();
        if (!pLayoutParent && _pElem->GetMarkup())
        {
            CElement *pElement = _pElem->GetMarkup()->GetElementClient();

            if (pElement)
            {
                pLayoutParent = pElement->GetUpdatedLayout();
            }
        }

        if (pLayoutParent || _pElem->GetMarkup())
        {
            DCI.Init(pLayoutParent ? pLayoutParent->ElementOwner() : _pElem->GetMarkup()->Root());
        }
        // else, the element is not in a tree. e.g. el = new Image();

        if (pLayoutParent)
        {
            pLayoutParent->GetClientRect(&rcParent);

            if (   rcParent.right == 0
                && rcParent.left == 0
                && rcParent.bottom ==0
                && rcParent.top == 0)
            {
                // MORE OM protection.  This is being called from the style OM, and is accessing 
                // layout properties.  The only way that this can be reliable is for us to try
                // to push the ensureView queues at this point. see get_offset* for other examples.
                hr = _pElem->EnsureRecalcNotify();
                if (hr)
                {
                    *plValue = 0;
                    goto Cleanup;
                }

                // Layout state may have changed.  Reget layout.
                pLayoutParent = _pElem->GetFirstBranch()->Parent()->GetUpdatedNearestLayout();
                if (pLayoutParent)
                    pLayoutParent->GetClientRect(&rcParent);
            }
    
            if (dwFlags & PUTVF_X)
                lParentSize = rcParent.right - rcParent.left;
            else
                lParentSize = rcParent.bottom - rcParent.top;
        }
        else
        {
            // if there is no parent layout and no Element client layout
            // rcParent is empty, therefore lParentSize is NULL
            lParentSize = 0;
        }

        if (dwFlags & PUTVF_X)
        {
            *plValue = uvTemp.XGetPixelValue(&DCI, lParentSize, 
                           _pElem->GetFirstBranch()->GetFontHeightInTwips(&uvTemp));
            *plValue = DCI.DocPixelsFromDeviceX(*plValue);
        }
        else
        {
            *plValue = uvTemp.YGetPixelValue(&DCI, lParentSize, 
                           _pElem->GetFirstBranch()->GetFontHeightInTwips(&uvTemp));
            *plValue = DCI.DocPixelsFromDeviceY(*plValue);
        }
    }
    else
    {
        *plValue = 0;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CStyle::putValueHelper, public
//
//  Synopsis:   Helper function for implementing put_ top/left/width/height
//
//  Arguments:  [lValue]  -- New value to store
//              [dwFlags] -- Flags indicating direction and what it affects
//              [dispid]  -- DISPID of property
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

// NOTE (carled) there is a compiler bug that manifest with this function
//  do NOT reorder the local variables below or else dwFlags will incorrectly
//  get reset to 0 and the site postion
HRESULT
CStyle::putValueHelper(long lValue, DWORD dwFlags, DISPID dispid, const PROPERTYDESC *ppropdesc)
{
    BOOL    fChanged    = FALSE;
    RECT    rcParent;
    long    delta;
    DWORD   dwPropFlags = ELEMCHNG_CLEARCACHES;
    HRESULT hr          = S_OK;
    CLayout *pParentLayout;
    const PROPERTYDESC *pPropDesc = NULL;

    if(!_pElem)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    pParentLayout = _pElem->GetUpdatedParentLayout(GUL_USEFIRSTLAYOUT);

    if (dwFlags & PUTVF_SIZE)
        dwPropFlags |= ELEMCHNG_SIZECHANGED;
    else
        dwPropFlags |= ELEMCHNG_SITEPOSITION;

    if (_dispIDAA == DISPID_INTERNAL_INLINESTYLEAA)
    {
        pPropDesc = ppropdesc;
        dwPropFlags |= ELEMCHNG_INLINESTYLE_PROPERTY;
    }

#ifndef NO_EDIT
    {
        CUndoPropChangeNotificationPlaceHolder
                notfholder( TRUE, _pElem, dispid, dwPropFlags );
#endif // NO_EDIT

        if (!pParentLayout && _pElem->GetMarkup())
        {
            CElement *pElement = _pElem->GetMarkup()->GetElementClient();
            // if there is no parent layout.
            // we are either a body ot framesetsite.
            // we should get client element rect
            if (pElement)
            {
                pParentLayout = pElement->GetUpdatedLayout();
            }
        }

        if (pParentLayout)
        {
            pParentLayout->GetClientRect(&rcParent);

            if (dwFlags & PUTVF_X)
                delta = rcParent.right - rcParent.left;
            else
                delta = rcParent.bottom - rcParent.top;
        }
        else
        {
            // if there is no parent layout and no Element client layout
            // rcParent is empty, therefore delta is NULL
            delta = 0;
        }

        hr = THR(_pElem->SetDim(dispid,
                                (float)lValue,
                                CUnitValue::UNIT_PIXELS,
                                delta,
                                GetAttrArray(),
                                _dispIDAA == DISPID_INTERNAL_INLINESTYLEAA,
                                &fChanged));
        if (hr)
            goto Cleanup;

        if (fChanged)
        {
            _pElem->OnPropertyChange(dispid, dwPropFlags, pPropDesc);
        }

#ifndef NO_EDIT
        notfholder.SetHR( fChanged ? hr : S_FALSE );
    }
#endif // NO_EDIT

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CStyle::get_pixelWidth(long * plValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_pixelWidth)

    if (NeedToDelegateGet(DISPID_CStyle_pixelWidth))
    {
        return DelegateGet(DISPID_CStyle_pixelWidth, VT_I4, plValue);
    }

    RRETURN(getValueHelper(plValue, PUTVF_X, &s_propdescCStylewidth.a));
}

HRESULT
CStyle::put_pixelWidth(long lValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_pixelWidth)

    RRETURN(putValueHelper(lValue, 
                           PUTVF_X|PUTVF_SIZE, 
                           STDPROPID_XOBJ_WIDTH, 
                           (PROPERTYDESC *)&s_propdescCStylewidth));
}

HRESULT
CStyle::get_pixelHeight(long * plValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_pixelHeight)

    if (NeedToDelegateGet(DISPID_CStyle_pixelHeight))
    {
        return DelegateGet(DISPID_CStyle_pixelHeight, VT_I4, plValue);
    }

    RRETURN(getValueHelper(plValue, PUTVF_Y, &s_propdescCStyleheight.a));
}

HRESULT
CStyle::put_pixelHeight(long lValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_pixelHeight)

    RRETURN(putValueHelper(lValue, 
                           PUTVF_Y|PUTVF_SIZE, 
                           STDPROPID_XOBJ_HEIGHT, 
                           (PROPERTYDESC *)&s_propdescCStyleheight));
}

HRESULT
CStyle::get_pixelLeft(long * plValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_pixelLeft)

    if (NeedToDelegateGet(DISPID_CStyle_pixelLeft))
    {
        return DelegateGet(DISPID_CStyle_pixelLeft, VT_I4, plValue);
    }

    RRETURN(getValueHelper(plValue, PUTVF_X, &s_propdescCStyleleft.a));
}

HRESULT
CStyle::put_pixelLeft(long lValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_pixelLeft)

    RRETURN(putValueHelper(lValue, 
                           PUTVF_X|PUTVF_POS, 
                           STDPROPID_XOBJ_LEFT, 
                           (PROPERTYDESC *)&s_propdescCStyleleft));
}

HRESULT
CStyle::get_pixelRight(long * plValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_pixelRight)

    if (NeedToDelegateGet(DISPID_CStyle_pixelRight))
    {
        return DelegateGet(DISPID_CStyle_pixelRight, VT_I4, plValue);
    }

    RRETURN(getValueHelper(plValue, PUTVF_X, &s_propdescCStyleright.a));
}

HRESULT
CStyle::put_pixelRight(long lValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_pixelRight)

    RRETURN(putValueHelper(lValue, 
                           PUTVF_X|PUTVF_POS, 
                           STDPROPID_XOBJ_RIGHT, 
                           (PROPERTYDESC *)&s_propdescCStyleright));
}

HRESULT
CStyle::get_pixelTop(long * plValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_pixelTop)

    if (NeedToDelegateGet(DISPID_CStyle_pixelTop))
    {
        return DelegateGet(DISPID_CStyle_pixelTop, VT_I4, plValue);
    }

    RRETURN(getValueHelper(plValue, PUTVF_Y, &s_propdescCStyletop.a));
}

HRESULT
CStyle::put_pixelTop(long lValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_pixelTop)
    RRETURN(putValueHelper(lValue, 
                           PUTVF_Y|PUTVF_POS, 
                           STDPROPID_XOBJ_TOP, 
                           (PROPERTYDESC *)&s_propdescCStyletop));
}

HRESULT
CStyle::get_pixelBottom(long * plValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_pixelBottom)

    if (NeedToDelegateGet(DISPID_CStyle_pixelBottom))
    {
        return DelegateGet(DISPID_CStyle_pixelBottom, VT_I4, plValue);
    }

    RRETURN(getValueHelper(plValue, PUTVF_Y, &s_propdescCStylebottom.a));
}

HRESULT
CStyle::put_pixelBottom(long lValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_pixelBottom)

    RRETURN(putValueHelper(lValue, 
                           PUTVF_Y|PUTVF_POS, 
                           STDPROPID_XOBJ_BOTTOM, 
                           (PROPERTYDESC *)&s_propdescCStylebottom));
}


HRESULT
CStyle::getfloatHelper(float *pfValue, DWORD dwFlags, const PROPERTYDESC *pPropertyDesc)
{
    HRESULT                   hr = S_OK;
    CUnitValue                uvTemp;
    DWORD                     dwVal;
    
    if (!pfValue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    if (_pElem)
    {
        hr = THR(_pElem->EnsureInMarkup());
        if (hr)
            goto Cleanup;

        if (_pElem->Doc()->_fDefView)
        {
            switch (pPropertyDesc->GetDispid())
            {
            case DISPID_CStyle_width:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedwidth();
                break;
                
            case DISPID_CStyle_left:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedleft();
                break;
                
            case DISPID_CStyle_top:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedtop();
                break;
                
            case DISPID_CStyle_right:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedright();
                break;
                
            case DISPID_CStyle_bottom:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedbottom();
                break;
                
            case DISPID_CStyle_height:
                uvTemp = _pElem->GetFirstBranch()->GetCascadedheight();
                break;

            default:
                Assert(0 && "Unexpected dispid");
                break;
            }
        }
        else
        {
            CAttrArray **ppAA = GetAttrArray();
            if (ppAA)
                CAttrArray::FindSimple(*ppAA, pPropertyDesc, &dwVal);
            else
                dwVal = (DWORD)pPropertyDesc->ulTagNotPresentDefault;

            uvTemp.SetRawValue(dwVal);
        }
    }
    
    if (!uvTemp.IsNull())
    {
        *pfValue = uvTemp.GetFloatValue();
    }
    else
    {
        *pfValue = 0;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CStyle::putfloatHelper(float fValue, DWORD dwFlags, DISPID dispid, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr          = S_OK;
    DWORD   dwPropFlags = ELEMCHNG_CLEARCACHES;
    BOOL    fChanged    = FALSE;
    RECT    rcParent;
    long    delta;
    const PROPERTYDESC *pPropDesc = NULL;

    if(!_pElem)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    if (!_pElem->GetUpdatedParentLayout())
    {
        delta = 0;
    }
    else
    {
        _pElem->GetUpdatedParentLayout()->GetClientRect(&rcParent);

        if (dwFlags & PUTVF_X)
            delta = rcParent.right - rcParent.left;
        else
            delta = rcParent.bottom - rcParent.top;
    }

    hr = THR(_pElem->SetDim(dispid,
                            fValue,
                            CUnitValue::UNIT_NULLVALUE,
                            delta,
                            GetAttrArray(),
                            _dispIDAA == DISPID_INTERNAL_INLINESTYLEAA,
                            &fChanged));
    if (hr)
        goto Cleanup;

    if (fChanged)
    {
        if (dwFlags & PUTVF_SIZE)
            dwPropFlags |= ELEMCHNG_SIZECHANGED;
        else
            dwPropFlags |= ELEMCHNG_SITEPOSITION;

        if (_dispIDAA == DISPID_INTERNAL_INLINESTYLEAA)
        {
            pPropDesc = ppropdesc;
            dwPropFlags |= ELEMCHNG_INLINESTYLE_PROPERTY;
        }

        _pElem->OnPropertyChange(dispid, dwPropFlags, pPropDesc);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CStyle::get_posWidth(float * pfValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_posWidth)

    if (NeedToDelegateGet(DISPID_CStyle_posWidth))
    {
        Assert (FALSE && "Not implemented");
        return E_NOTIMPL;
    }

    RRETURN(getfloatHelper(pfValue, PUTVF_X, &s_propdescCStylewidth.a));
}

HRESULT
CStyle::put_posWidth(float fValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_posWidth)

    RRETURN(putfloatHelper(fValue, 
                           PUTVF_X|PUTVF_SIZE, 
                           STDPROPID_XOBJ_WIDTH, 
                           (PROPERTYDESC *)&s_propdescCStylewidth));
}

HRESULT
CStyle::get_posHeight(float * pfValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_posHeight)

    if (NeedToDelegateGet(DISPID_CStyle_posHeight))
    {
        Assert (FALSE && "Not implemented");
        return E_NOTIMPL;
    }

    RRETURN(getfloatHelper(pfValue, PUTVF_Y, &s_propdescCStyleheight.a));
}

HRESULT
CStyle::put_posHeight(float fValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_posHeight)

    RRETURN(putfloatHelper(fValue, 
                           PUTVF_Y|PUTVF_SIZE, 
                           STDPROPID_XOBJ_HEIGHT, 
                           (PROPERTYDESC *)&s_propdescCStyleheight));
}

HRESULT
CStyle::get_posLeft(float * pfValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_posLeft)

    if (NeedToDelegateGet(DISPID_CStyle_posLeft))
    {
        Assert (FALSE && "Not implemented");
        return E_NOTIMPL;
    }

    RRETURN(getfloatHelper(pfValue, PUTVF_X, &s_propdescCStyleleft.a));
}

HRESULT
CStyle::put_posLeft(float fValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_posLeft)

    RRETURN(putfloatHelper(fValue, 
                           PUTVF_X|PUTVF_POS, 
                           STDPROPID_XOBJ_LEFT, 
                           (PROPERTYDESC *)&s_propdescCStyleleft));
}


HRESULT
CStyle::get_posRight(float * pfValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_posRight)

    if (NeedToDelegateGet(DISPID_CStyle_posRight))
    {
        Assert (FALSE && "Not implemented");
        return E_NOTIMPL;
    }

    RRETURN(getfloatHelper(pfValue, PUTVF_X, &s_propdescCStyleright.a));
}

HRESULT
CStyle::put_posRight(float fValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_posRight)

    RRETURN(putfloatHelper(fValue, 
                           PUTVF_X|PUTVF_POS, 
                           STDPROPID_XOBJ_RIGHT, 
                           (PROPERTYDESC *)&s_propdescCStyleright));
}

HRESULT
CStyle::get_posTop(float * pfValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_posTop)

    if (NeedToDelegateGet(DISPID_CStyle_posTop))
    {
        Assert (FALSE && "Not implemented");
        return E_NOTIMPL;
    }

    RRETURN(getfloatHelper(pfValue, PUTVF_Y, &s_propdescCStyletop.a));
}

HRESULT
CStyle::put_posTop(float fValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_posTop)
    RRETURN(putfloatHelper(fValue, 
                           PUTVF_Y|PUTVF_POS, 
                           STDPROPID_XOBJ_TOP, 
                           (PROPERTYDESC *)&s_propdescCStyletop));
}

HRESULT
CStyle::get_posBottom(float * pfValue)
{
    RECALC_GET_HELPER(DISPID_CStyle_posBottom)

    if (NeedToDelegateGet(DISPID_CStyle_posBottom))
    {
        Assert (FALSE && "Not implemented");
        return E_NOTIMPL;
    }

    RRETURN(getfloatHelper(pfValue, PUTVF_Y, &s_propdescCStylebottom.a));
}

HRESULT
CStyle::put_posBottom(float fValue)
{
    RECALC_PUT_HELPER(DISPID_CStyle_posBottom)
    RRETURN(putfloatHelper(fValue, 
                           PUTVF_Y|PUTVF_POS, 
                           STDPROPID_XOBJ_BOTTOM, 
                           (PROPERTYDESC *)&s_propdescCStylebottom));
}



//+------------------------------------------------------------------------
//
//  Function:   EscapeQuotes
//
//  Synopsis:   Changes all the double quotes in the string to single quotes
//              Future implementations of this function must escape the quotes,
//                  so the information is saved. They might also need to allocate
//                  and return another string.
//-------------------------------------------------------------------------

void
EscapeQuotes(LPTSTR lpPropValue)
{
    if(!lpPropValue)
        return;

    while(*lpPropValue != 0)
    {
        if(*lpPropValue == DOUBLEQUOTE)
            *lpPropValue = SINGLEQUOTE;
        lpPropValue++;
    }
}


//+------------------------------------------------------------------------
//
//  Function:   ::WriteStyleToBSTR
//
//  Synopsis:   Converts a collection of style properties to a BSTR for display on grid
//
//  Note:       Look at size member of GlobalAlloc on large style sheets
//
//-------------------------------------------------------------------------
HRESULT WriteStyleToBSTR( CBase *pObject, CAttrArray *pAA, BSTR *pbstr, BOOL fQuote, BOOL fSaveExpressions)
{
    CPtrBagVTableAggregate::CIterator vTableIterator(CStyle::s_apHdlDescs.pStringTableAggregate);
    HRESULT hr=S_OK;
    BASICPROPPARAMS *pbpp;
    LPCTSTR pchLastOut = NULL;
    const CAttrValue *pAV;
    CStr cstrStyle;
    BSTR bstr = NULL;
    BOOL fUseCompositeBackground    = FALSE;
    BOOL fUseCompositeBGPosition    = FALSE;
    BOOL fUseCompositeFont          = FALSE;
    BOOL fUseCompositeBorderTop     = FALSE;
    BOOL fUseCompositeBorderRight   = FALSE;
    BOOL fUseCompositeBorderBottom  = FALSE;
    BOOL fUseCompositeBorderLeft    = FALSE;
    BOOL fUseCompositeMargin        = FALSE;
    BOOL fUseCompositeLayoutGrid    = FALSE;
    BOOL fUseCompositeListStyle     = FALSE;

    int iLen;
    int idx;
    LPCTSTR lpPropName = NULL;
    LPCTSTR lpPropValue;
    BSTR bstrTemp;

    if ( !pbstr )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstr = NULL;

    if ( !(pAA && pAA->HasAnyAttribute(TRUE)) )
        goto Cleanup;

    //Quote style string?
    if (fQuote)
    {
        hr = cstrStyle.Append( _T("\"") );
        if (hr != S_OK)
            goto Cleanup;
    }

    if ( pAA->Find( DISPID_A_BACKGROUNDPOSX, CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_BACKGROUNDPOSY, CAttrValue::AA_Attribute ) )
        fUseCompositeBGPosition = TRUE;
    if ( fUseCompositeBGPosition &&
         pAA->Find( DISPID_A_BACKGROUNDIMAGE , CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_BACKCOLOR, CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_BACKGROUNDREPEAT, CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_BACKGROUNDATTACHMENT, CAttrValue::AA_Attribute ) )
        fUseCompositeBackground = TRUE;

    if ( pAA->Find( DISPID_A_FONTWEIGHT,  CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_FONTSTYLE,   CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_FONTVARIANT, CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_FONTSIZE,    CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_LINEHEIGHT,  CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_FONTFACE,    CAttrValue::AA_Attribute ) )
        fUseCompositeFont = TRUE;

    if ( pAA->Find( DISPID_A_LAYOUTGRIDMODE,  CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_LAYOUTGRIDTYPE,   CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_LAYOUTGRIDLINE,  CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_LAYOUTGRIDCHAR,    CAttrValue::AA_Attribute ) )
        fUseCompositeLayoutGrid = TRUE;

    if ( pAA->Find( DISPID_A_BORDERTOPSTYLE,  CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_BORDERTOPWIDTH,  CAttrValue::AA_Attribute ) )
        fUseCompositeBorderTop = TRUE;

    if ( pAA->Find( DISPID_A_BORDERRIGHTSTYLE,  CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_BORDERRIGHTWIDTH,  CAttrValue::AA_Attribute ) )
        fUseCompositeBorderRight = TRUE;

    if ( pAA->Find( DISPID_A_BORDERBOTTOMSTYLE,  CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_BORDERBOTTOMWIDTH,  CAttrValue::AA_Attribute ) )
        fUseCompositeBorderBottom = TRUE;

    if ( pAA->Find( DISPID_A_BORDERLEFTSTYLE,  CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_BORDERLEFTWIDTH,  CAttrValue::AA_Attribute ) )
        fUseCompositeBorderLeft = TRUE;

    if ( pAA->Find( DISPID_A_MARGINTOP,  CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_MARGINRIGHT,  CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_MARGINBOTTOM,  CAttrValue::AA_Attribute ) &&
         pAA->Find( DISPID_A_MARGINLEFT,  CAttrValue::AA_Attribute ) )
        fUseCompositeMargin = TRUE;
        
    if ( (pAA->Find(DISPID_A_LISTSTYLETYPE,  CAttrValue::AA_Attribute) &&
          pAA->Find(DISPID_A_LISTSTYLEPOSITION,  CAttrValue::AA_Attribute) &&
          pAA->Find(DISPID_A_LISTSTYLEIMAGE,  CAttrValue::AA_Attribute)) ||
         pAA->Find(DISPID_A_LISTSTYLE,  CAttrValue::AA_Attribute) )
        fUseCompositeListStyle = TRUE;

    for (vTableIterator.Start(VTABLEDESC_BELONGSTOPARSE); !vTableIterator.End(); vTableIterator.Next())
    {
        const VTABLEDESC *pVTblDesc = vTableIterator.Item();
        const PROPERTYDESC *ppropdesc = pVTblDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOPARSE);
        Assert(ppropdesc);

        DWORD dispid = ppropdesc->GetBasicPropParams()->dispid;

        pAV = NULL;

        // NOTE: for now check for the method pointer because of old property implementation...
        if (!ppropdesc->pfnHandleProperty)
            continue;

        pbpp = (BASICPROPPARAMS *)(ppropdesc+1);

        if ( (pbpp->dwPPFlags & PROPPARAM_NOPERSIST) ||
                (!(pbpp->dwPPFlags&PROPPARAM_ATTRARRAY)))
            continue;

        switch ( dispid )
        {
        case DISPID_A_BACKGROUNDPOSX:
        case DISPID_A_BACKGROUNDPOSY:
            if ( fUseCompositeBGPosition )
                continue;
            break;
        case DISPID_A_BACKGROUNDIMAGE:
        case DISPID_BACKCOLOR:
        case DISPID_A_BACKGROUNDREPEAT:
        case DISPID_A_BACKGROUNDATTACHMENT:
            if ( fUseCompositeBackground )
                continue;
            break;
        case DISPID_A_FONTWEIGHT:
        case DISPID_A_FONTSTYLE:
        case DISPID_A_FONTVARIANT:
        case DISPID_A_FONTSIZE:
        case DISPID_A_LINEHEIGHT:
        case DISPID_A_FONTFACE:
            if ( fUseCompositeFont )
                continue;
            break;
        case DISPID_A_LAYOUTGRIDMODE:
        case DISPID_A_LAYOUTGRIDTYPE:
        case DISPID_A_LAYOUTGRIDLINE:
        case DISPID_A_LAYOUTGRIDCHAR:
            if ( fUseCompositeLayoutGrid )
                continue;
            break;
        case DISPID_A_BORDERTOPSTYLE:
        case DISPID_A_BORDERTOPWIDTH:
        case DISPID_A_BORDERTOPCOLOR:
            if ( fUseCompositeBorderTop )
                continue;
            break;
        case DISPID_A_BORDERRIGHTSTYLE:
        case DISPID_A_BORDERRIGHTWIDTH:
        case DISPID_A_BORDERRIGHTCOLOR:
            if ( fUseCompositeBorderRight )
                continue;
            break;
        case DISPID_A_BORDERBOTTOMSTYLE:
        case DISPID_A_BORDERBOTTOMWIDTH:
        case DISPID_A_BORDERBOTTOMCOLOR:
            if ( fUseCompositeBorderBottom )
                continue;
            break;
        case DISPID_A_BORDERLEFTSTYLE:
        case DISPID_A_BORDERLEFTWIDTH:
        case DISPID_A_BORDERLEFTCOLOR:
            if ( fUseCompositeBorderLeft )
                continue;
            break;
        case DISPID_A_MARGINTOP:
        case DISPID_A_MARGINRIGHT:
        case DISPID_A_MARGINBOTTOM:
        case DISPID_A_MARGINLEFT:
            if ( fUseCompositeMargin )
                continue;
            break;

        case DISPID_A_LISTSTYLETYPE:
        case DISPID_A_LISTSTYLEPOSITION:
        case DISPID_A_LISTSTYLEIMAGE:
            if ( fUseCompositeListStyle )
                continue;
            break;

        case DISPID_A_CLIPRECTTOP:
        case DISPID_A_CLIPRECTRIGHT:
        case DISPID_A_CLIPRECTBOTTOM:
        case DISPID_A_CLIPRECTLEFT:
            // We do not write out the components
            continue;

        case DISPID_A_CLIP:
        if ( pAA->Find( DISPID_A_CLIPRECTTOP,  CAttrValue::AA_Attribute ) ||
                 pAA->Find( DISPID_A_CLIPRECTRIGHT,  CAttrValue::AA_Attribute ) ||
                 pAA->Find( DISPID_A_CLIPRECTBOTTOM,  CAttrValue::AA_Attribute ) ||
                 pAA->Find( DISPID_A_CLIPRECTLEFT,  CAttrValue::AA_Attribute ) )
             goto WriteOutName;
        continue;

        case DISPID_A_BACKGROUNDPOSITION:
            if ( fUseCompositeBGPosition && !fUseCompositeBackground )
                goto WriteOutName;
            continue;
        case DISPID_A_BACKGROUND:
            if ( fUseCompositeBackground )
                goto WriteOutName;
            continue;
        case DISPID_A_FONT:
            if ( fUseCompositeFont )
                goto WriteOutName;
            break;  // Font may be in the attr array, if it's a system font.
        case DISPID_A_LAYOUTGRID:
            if ( fUseCompositeLayoutGrid )
                goto WriteOutName;
            break;
        case DISPID_A_BORDERTOP:
            if ( fUseCompositeBorderTop )
                goto WriteOutName;
            continue;
        case DISPID_A_BORDERRIGHT:
            if ( fUseCompositeBorderRight )
                goto WriteOutName;
            continue;
        case DISPID_A_BORDERBOTTOM:
            if ( fUseCompositeBorderBottom )
                goto WriteOutName;
            continue;
        case DISPID_A_BORDERLEFT:
            if ( fUseCompositeBorderLeft )
                goto WriteOutName;
            continue;
        case DISPID_A_LISTSTYLE:
            if ( fUseCompositeListStyle )
                goto WriteOutName;
            continue;
        case DISPID_A_MARGIN:
            if ( fUseCompositeMargin )
                goto WriteOutName;
            continue;
        }
        // does this property exist in the aa?  We may skip this test if
        // this is a composite property (hence the gotos above), since they
        // may not actually be in the AA.
        if ( ( pAV = pAA->Find(ppropdesc->GetDispid(), CAttrValue::AA_Attribute ) ) != NULL )
        {

WriteOutName:

            //Write out property name
            if (!pchLastOut || 0!=StrCmpC(pchLastOut, ppropdesc->pstrName))
            {
                if (pchLastOut)
                {
                    hr = cstrStyle.Append( _T("; ") );
                    if (hr != S_OK)
                        goto Cleanup;
                }
                hr = cstrStyle.Append( ppropdesc->pstrName );
                if (hr != S_OK)
                    goto Cleanup;
                hr = cstrStyle.Append( _T(": ") );
                if (hr != S_OK)
                    goto Cleanup;
                pchLastOut = ppropdesc->pstrName;
            }
            else
            {
                hr = cstrStyle.Append( _T(" ") );
                if (hr != S_OK)
                    goto Cleanup;
            }

            //Write out value
    #ifdef WIN16
            hr = (ppropdesc->pfnHandleProperty)( (PROPERTYDESC *)ppropdesc, HANDLEPROP_AUTOMATION | (PROPTYPE_BSTR << 16),
                                 (void *)&bstr, NULL, (CVoid*) (void*) &pAA);
    #else
            hr = CALL_METHOD( ppropdesc, ppropdesc->pfnHandleProperty, ( HANDLEPROP_AUTOMATION | (PROPTYPE_BSTR << 16),
                                 (void *)&bstr, NULL, (CVoid*) (void*) &pAA));
    #endif
            if (hr == S_OK)
            {
                if(fQuote)
                {
                    // We are outputing to an inline style. For now we have to replace the 
                    //  double quotes to single, because of external pair of double quotes. Later
                    //   we might want to escape the quotes. We might also want to change how we pass
                    // in and out the string, because changing inplace will not work when escaping
                    // changes the string length, of course.
                    EscapeQuotes((LPTSTR)bstr);
                }
                hr = cstrStyle.Append( bstr );
                if (hr != S_OK)
                    goto Cleanup;
                FormsFreeString( bstr );
            }

            // TODO: Don't handle "! important" on composite properties.
            if ( pAV && pAV->IsImportant() )
            {
                hr = cstrStyle.Append( _T("! important") );
                if (hr != S_OK)
                    goto Cleanup;
            }
        }

        // See if there's an expression
        if (    fSaveExpressions
            && ((pAV = pAA->Find(ppropdesc->GetDispid(), CAttrValue::AA_Expression)) != NULL) )
        {
            //
            // TODO (michaelw) this will probably mess up if expressions are applied to composite properties
            //
            // The problem is actually caused by the poor way we loop through every possible attribute
            // apparently to make composite props come out right.  Sheesh!
            //
            if (pchLastOut)
            {
                hr = cstrStyle.Append(_T("; "));
                if (hr != S_OK)
                    goto Cleanup;
            }

            hr = cstrStyle.Append( _T("; ") );
            if (hr != S_OK)
                goto Cleanup;
            hr = cstrStyle.Append( ppropdesc->pstrName );
            if (hr != S_OK)
                goto Cleanup;
            hr = cstrStyle.Append( _T(": expression(") );
            if (hr != S_OK)
                goto Cleanup;
            hr = cstrStyle.Append(pAV->GetLPWSTR());
            if (hr != S_OK)
                goto Cleanup;
            hr = cstrStyle.Append(_T(")"));
            if (hr != S_OK)
                goto Cleanup;
            pchLastOut = ppropdesc->pstrName;
        }
    }

    // Look for all expandos & dump them out
    if ( pObject )
    {
        pAV = (CAttrValue *)(*pAA);
        iLen = pAA->Size();
        for ( idx=0; idx < iLen; idx++ )
        {
            if ((pAV->AAType() == CAttrValue::AA_Expando))
            {
                hr = pObject->GetExpandoName( pAV->GetDISPID(), &lpPropName );
                if (hr)
                    continue;

                if ( pAV->GetIntoString( &bstrTemp, &lpPropValue ) )
                    continue;   // Can't convert to string
                if(fQuote)
                {
                    // We are outputing to an inline style. For now we have to replace the 
                    //  double quotes to single, because of external pair of double quotes. Later
                    //   we might want to escape the quotes.
                    EscapeQuotes((LPTSTR)lpPropValue);
                }

                if (pchLastOut)
                {
                    hr = cstrStyle.Append( _T("; ") );
                    if (hr != S_OK)
                        goto Cleanup;
                }
                hr = cstrStyle.Append( lpPropName );
                if (hr != S_OK)
                    goto Cleanup;
                pchLastOut = lpPropName;
                hr = cstrStyle.Append( _T(": ") );
                if (hr != S_OK)
                    goto Cleanup;
                hr = cstrStyle.Append( lpPropValue );
                if (hr != S_OK)
                    goto Cleanup;
                if ( bstrTemp )
                    SysFreeString ( bstrTemp );
            }
            pAV++;
        }
    }

    // Quote style string?
    if (fQuote)
    {
        hr = cstrStyle.Append( _T("\"") );
        if (hr != S_OK)
            goto Cleanup;
    }

    if (cstrStyle.Length() )
    {
        hr = cstrStyle.AllocBSTR( pbstr );
        if (hr != S_OK)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   ::WriteBackgroundStyleToBSTR
//
//  Synopsis:   Converts 'background' property to a BSTR
//
//-------------------------------------------------------------------------

HRESULT WriteBackgroundStyleToBSTR( CAttrArray *pAA, BSTR *pbstr )
{
    CStr cstrBackground;
    BSTR bstr = NULL;
    CAttrValue *pAV;
    HRESULT hr=S_OK;

    if ( S_OK == s_propdescCStylebackgroundImage.b.GetStyleComponentProperty(&bstr, NULL, (CVoid *)&pAA ) && bstr && *bstr )
    {
        if ( _tcsicmp( bstr, _T("none") ) )
        {
            hr = cstrBackground.Append( (TCHAR *)bstr );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        goto Cleanup;
    }

    pAV = pAA->Find( DISPID_BACKCOLOR, CAttrValue::AA_Attribute );
    if ( pAV )
    {
        TCHAR szBuffer[64];
        CColorValue cvColor = (CColorValue)pAV->GetLong();

        if ( S_OK == cvColor.FormatBuffer(szBuffer, ARRAY_SIZE(szBuffer), NULL ) )
        {
            if ( _tcsicmp( szBuffer, _T("transparent") ) )
            {
                if ( cstrBackground.Length() )
                {
                    hr = cstrBackground.Append( _T(" ") );
                    if (hr != S_OK)
                        goto Cleanup;
                }
                hr = cstrBackground.Append( szBuffer );
                if (hr != S_OK)
                    goto Cleanup;
            }
        }
    }
    else
    {
        hr = cstrBackground.Set( _T( "" ) );
        goto Cleanup;
    }

    FormsFreeString(bstr);
    bstr = NULL;

    if ( S_OK == s_propdescCStylebackgroundAttachment.b.GetEnumStringProperty( &bstr, NULL, (CVoid *)&pAA ) && bstr && *bstr )
    {
        if ( _tcsicmp( bstr, _T("scroll") ) )
        {
            if ( cstrBackground.Length() )
            {
                hr = cstrBackground.Append( _T(" ") );
                if (hr != S_OK)
                    goto Cleanup;
            }
            hr = cstrBackground.Append( (TCHAR *)bstr );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        hr = cstrBackground.Set( _T( "" ) );
        goto Cleanup;
    }

    FormsFreeString( bstr );
    bstr = NULL;

    if ( S_OK == s_propdescCStylebackgroundRepeat.b.GetEnumStringProperty( &bstr, NULL, (CVoid *)&pAA ) && bstr && *bstr )
    {
        if ( _tcsicmp( bstr, _T("repeat") ) )
        {
            if ( cstrBackground.Length() )
            {
                hr = cstrBackground.Append( _T(" ") );
                if (hr != S_OK)
                    goto Cleanup;
            }
            hr = cstrBackground.Append( (TCHAR *)bstr );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        hr = cstrBackground.Set( _T( "" ) );
        goto Cleanup;
    }

    FormsFreeString( bstr );
    bstr = NULL;

    if ( S_OK == WriteBackgroundPositionToBSTR( pAA, &bstr ) && bstr && *bstr )
    {
        if ( _tcsicmp( bstr, _T("0% 0%") ) )
        {
            if ( cstrBackground.Length() )
            {
                hr = cstrBackground.Append( _T(" ") );
                if (hr != S_OK)
                    goto Cleanup;
            }
            hr = cstrBackground.Append( (TCHAR *)bstr );
            if (hr != S_OK)
                goto Cleanup;
        }
    }
    else
    {
        hr = cstrBackground.Set( _T( "" ) );
        goto Cleanup;
    }

    // If we got this far, we have all the right properties in the AA... but if all of them were default,
    if ( !cstrBackground.Length() )
    {   // We want to put all the defaults in the string.
        hr = cstrBackground.Set( _T("none transparent scroll repeat 0% 0%") );
        goto Cleanup;
    }

Cleanup:
    FormsFreeString(bstr);
    if (hr == S_OK)
    {
        bstr = NULL;
        return cstrBackground.AllocBSTR( pbstr );
    }
    return (hr);
}

void    
CStyle::MaskPropertyChanges(BOOL fMask)
{ 
    if (fMask)
    {
        SetFlag(STYLE_MASKPROPERTYCHANGES);
    }
    else
    {
        ClearFlag(STYLE_MASKPROPERTYCHANGES);
    }
}


//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange
//
//  Note:       Called after a property has changed to notify derived classes
//              of the change.  All properties (except those managed by the
//              derived class) are consistent before this call.
//
//              Also, fires a property change notification to the site.
//
//-------------------------------------------------------------------------

HRESULT
CStyle::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;
    const PROPERTYDESC *pPropDesc = NULL;

    Assert(!ppropdesc || ppropdesc->GetDispid() == dispid);
    //Assert(!ppropdesc || ppropdesc->GetdwFlags() == dwFlags);

    if (TestFlag(STYLE_MASKPROPERTYCHANGES))
        goto Cleanup;

    DeleteCSSExpression(dispid);

    if (_pElem)
    {
        if(dispid == DISPID_A_POSITION)
        {
            CDoc * pDoc = _pElem->Doc();

            if(!pDoc->_fRegionCollection)
            {
                DWORD dwVal = 0;
                CAttrArray **ppAA = GetAttrArray();
                BOOL fFound = ppAA && *ppAA && (*ppAA)->FindSimple(DISPID_A_POSITION, &dwVal);

                if(fFound && ((stylePosition)dwVal == stylePositionrelative || 
                    (stylePosition)dwVal == stylePositionabsolute))
                {
                    pDoc->_fRegionCollection = TRUE;
                }
            }
        }

        // allow Element to make a decision based on distinguishing the same DISPID from
        // element vs in-line style, by OR'ing in the ELEMCHNG_INLINESTYLE_PROPERTY
        if (_dispIDAA == DISPID_INTERNAL_INLINESTYLEAA)
        {
            pPropDesc = ppropdesc;
            dwFlags |= ELEMCHNG_INLINESTYLE_PROPERTY;
        }

        if (TestFlag(STYLE_NOCLEARCACHES))
        {
            //
            // NOTE: (anandra) HACK ALERT.  This is completely a workaround
            // for the fact that CElement::OnPropertyChange turns around and calls 
            // ComputeFormat.  This causes recursion for the behavior onstyleapply stuff.
            // By not clearing the formats here, we prevent this from happening.  
            // CPeerHolder::ApplyStyleMulti will clear the caches correctly.
            //
            
            dwFlags &= ~(ELEMCHNG_CLEARCACHES | ELEMCHNG_CLEARFF);
        }
        
        if (TestFlag(STYLE_DEFSTYLE))
        {
            dwFlags |= ELEMCHNG_DONTFIREEVENTS;
        }

        hr = THR(_pElem->OnPropertyChange(dispid, dwFlags, pPropDesc));
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CStyle::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------
HRESULT
CStyle::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr=S_OK;
    AssertSz(eCookie==_dwCookie, "NOT A CSTYLE");

    // All interfaces derived from IDispatch must be handled
    // using the ElementDesc()->_apfnTearOff tearoff interface.
    // This allows classes such as COleSite to override the
    // implementation of IDispatch methods.

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
        QI_HTML_TEAROFF(this, IHTMLStyle2, NULL)
        QI_HTML_TEAROFF(this, IHTMLStyle3, NULL)
        QI_HTML_TEAROFF(this, IHTMLStyle4, NULL)
        QI_TEAROFF(this, IServiceProvider, NULL)
        QI_TEAROFF(this, IPerPropertyBrowsing, NULL)
        QI_TEAROFF(this, IRecalcProperty, NULL)
        QI_CASE(IConnectionPointContainer)
        {
            *((IConnectionPointContainer **)ppv) =
                    new CConnectionPointContainer(_pElem, (IUnknown*)(IPrivateUnknown*)this);

            if (!*ppv)
                RRETURN(E_OUTOFMEMORY);
            break;
        }
    default:
        {
            const CLASSDESC *pclassdesc = (CLASSDESC *) BaseDesc();

            if (iid == CLSID_CStyle)
            {
                *ppv = this;    // Weak ref
                return S_OK;
            }

            if (pclassdesc &&
                pclassdesc->_apfnTearOff &&
                pclassdesc->_classdescBase._piidDispinterface &&
                (iid == IID_IHTMLStyle || DispNonDualDIID(iid) ))
            {
                hr = THR(CreateTearOffThunk(this,
                                            (void *)(pclassdesc->_apfnTearOff),
                                            NULL,
                                            ppv,
                                            (void *)(CStyle::s_ppropdescsInVtblOrderIHTMLStyle)));
            }
        }
    }
    if (!hr)
    {
        if (*ppv)
            (*(IUnknown **)ppv)->AddRef();
        else
            hr = E_NOINTERFACE;
    }
    RRETURN(hr);
}

STDMETHODIMP
CStyle::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT hr;

    if (!_pAA && _dispIDAA == DISPID_INTERNAL_INLINESTYLEAA)
    {
        Assert(_pElem);
        _pAA = *_pElem->CreateStyleAttrArray(_dispIDAA);
    }

    hr = THR_NOTRACE(CBase::GetDispID(bstrName, grfdex, pid));

    RRETURN(hr);
}

//*********************************************************************
// CStyle::Invoke, IDispatch
// Provides access to properties and members of the object. We use it
//      to invalidate the caches when a expando is changed on the style
//      so that it is propagated down to the elements it affects
//
// Arguments:   [dispidMember] - Member id to invoke
//              [riid]         - Interface ID being accessed
//              [wFlags]       - Flags describing context of call
//              [pdispparams]  - Structure containing arguments
//              [pvarResult]   - Place to put result
//              [pexcepinfo]   - Pointer to exception information struct
//              [puArgErr]     - Indicates which argument is incorrect
//
//*********************************************************************

STDMETHODIMP
CStyle::InvokeEx( DISPID       dispidMember,
                        LCID         lcid,
                        WORD         wFlags,
                        DISPPARAMS * pdispparams,
                        VARIANT *    pvarResult,
                        EXCEPINFO *  pexcepinfo,
                        IServiceProvider *pSrvProvider)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;

    // CBase knows how to handle this
    hr = THR_NOTRACE(CBase::InvokeEx( dispidMember,
                                    lcid,
                                    wFlags,
                                    pdispparams,
                                    pvarResult,
                                    pexcepinfo,
                                    pSrvProvider));

    if(hr)
        goto Cleanup;

    if (IsExpandoDISPID(dispidMember) && (wFlags & DISPATCH_PROPERTYPUT))
    {
        // pElem can be 0 only if we are a CRuleStyle. But in that case we
        // will not come here because CRuleStyle::InvokeEx will handle it and
        // call CBase::InvokeEx directly.
        Assert(_pElem != 0);
        // Invalidate the branch only, this is an inline style
        DWORD   dwFlag = ELEMCHNG_CLEARCACHES;
        _pElem->EnsureFormatCacheChange(dwFlag);
    }


Cleanup:
    SetErrorInfo( hr );
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}

STDMETHODIMP
CStyle::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    Assert(_pElem);
    RRETURN(SetErrorInfo(_pElem->QueryService(guidService, riid, ppvObject)));
}


//+------------------------------------------------------------------------
//
//  Helper Function:    ValidStyleUrl
//
//  Synopsis:
//      This function determines if a string is a valid CSS-style URL
//  functional notation string (e.g. "url(http://www.foo.com/bar)").
//
//  Return Values:
//      zero if invalid, otherwise the length of the string inside
//-------------------------------------------------------------------------
size_t ValidStyleUrl(TCHAR *pch)
{
    size_t nLen = pch ? _tcslen(pch) : 0;
    if (   (nLen>=5)
          && (0==_tcsnicmp(pch, ARRAY_SIZE(strURLBeg) - 1, strURLBeg, ARRAY_SIZE(strURLBeg) - 1))
          && (_T(')') == pch[nLen-1])
    )
    {
        return nLen;
    }
    return 0;
}

//+------------------------------------------------------------------------
//
// Member:      DeleteCSSExpression
//
// Description: Delete a CSS expression by dispid
//
// Notes:       This function gets called by OnPropertyChange so
//              it needs to be pretty quick for the non recalc case
//
//+------------------------------------------------------------------------

BOOL
CStyle::DeleteCSSExpression(DISPID dispid)
{
    if (_pElem && (_pElem->Doc()->_recalcHost.GetSetValueDispid(_pElem) != dispid))
    {
        CAttrArray **ppAA = GetAttrArray();
        return ppAA && *ppAA && (*ppAA)->FindSimpleAndDelete(dispid, CAttrValue::AA_Expression);
    }
    return FALSE;
}


//+----------------------------------------------------------------------------
//
//  Function:   CStyle::GetCanonicalProperty
//
//  Synopsis:   Returns the canonical pUnk/dispid pair for a particular dispid
//              Used by the recalc engine to catch aliased properties.
//
//  Parameters: ppUnk will contain the canonical object
//              pdispid will contain the canonical dispid
//
//  Returns:    S_OK if successful
//              S_FALSE if property has no alias
//
//-----------------------------------------------------------------------------

HRESULT
CStyle::GetCanonicalProperty(DISPID dispid, IUnknown **ppUnk, DISPID *pdispid)
{
    HRESULT hr;

    switch (dispid)
    {
    case DISPID_IHTMLSTYLE_LEFT:
    case DISPID_IHTMLSTYLE_PIXELLEFT:
    case DISPID_IHTMLSTYLE_POSLEFT:
        *pdispid = DISPID_IHTMLELEMENT_OFFSETLEFT;
        hr = THR(GetElementPtr()->PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        break;
    case DISPID_IHTMLSTYLE_TOP:
    case DISPID_IHTMLSTYLE_PIXELTOP:
    case DISPID_IHTMLSTYLE_POSTOP:
        *pdispid = DISPID_IHTMLELEMENT_OFFSETTOP;
        hr = THR(GetElementPtr()->PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        break;

    case DISPID_IHTMLSTYLE_WIDTH:
    case DISPID_IHTMLSTYLE_PIXELWIDTH:
    case DISPID_IHTMLSTYLE_POSWIDTH:
        *pdispid = DISPID_IHTMLELEMENT_OFFSETWIDTH;
        hr = THR(GetElementPtr()->PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        break;

    case DISPID_IHTMLSTYLE_HEIGHT:
    case DISPID_IHTMLSTYLE_PIXELHEIGHT:
    case DISPID_IHTMLSTYLE_POSHEIGHT:
        *pdispid = DISPID_IHTMLELEMENT_OFFSETHEIGHT;
        hr = THR(GetElementPtr()->PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        break;
    default:
        *ppUnk = 0;
        *pdispid = 0;
        hr = S_FALSE;
    }

    RRETURN1(hr, S_FALSE);
}

STDMETHODIMP
CStyle::removeExpression(BSTR strPropertyName, VARIANT_BOOL *pfSuccess)
{
    CTreeNode *pNode = _pElem->GetUpdatedNearestLayoutNode();
    if (pNode)
        pNode->GetFancyFormatIndex();

    RRETURN(SetErrorInfo(_pElem->Doc()->_recalcHost.removeExpression(this, strPropertyName, pfSuccess)));
}

ExternTag(tagRecalcDisableCSS);

STDMETHODIMP
CStyle::setExpression(BSTR strPropertyName, BSTR strExpression, BSTR strLanguage)
{
    WHEN_DBG(if (IsTagEnabled(tagRecalcDisableCSS)) return S_FALSE;)

    Assert( _pElem );

    if ( _pElem->IsPrintMedia() )
        return S_OK;

    _pElem->_fHasExpressions = TRUE;

    CTreeNode *pNode = _pElem->GetUpdatedNearestLayoutNode();
    if (pNode)
        pNode->GetFancyFormatIndex();

    RRETURN(SetErrorInfo(_pElem->Doc()->_recalcHost.setExpression(this, strPropertyName, strExpression, strLanguage)));
}

STDMETHODIMP
CStyle::getExpression(BSTR strPropertyName, VARIANT *pvExpression)
{
    CTreeNode *pNode = _pElem->GetUpdatedNearestLayoutNode();
    if (pNode)
        pNode->GetFancyFormatIndex();

    RRETURN(SetErrorInfo(_pElem->Doc()->_recalcHost.getExpression(this, strPropertyName, pvExpression)));
}

HRESULT 
CCSSParser::SetExpression(DISPID dispid, WORD wMaxstrlen /* = 0 */, TCHAR chOld /* = 0 */)
{
    WHEN_DBG(if (IsTagEnabled(tagRecalcDisableCSS)) return S_FALSE;)

    HRESULT hr;
    TCHAR *p = (LPTSTR)_cbufBuffer;
    VARIANT v;

    if (chOld)
        p[wMaxstrlen] = chOld;

    // trim trailing whitespace
    _cbufBuffer.TrimTrailingWhitespace();

    // skip leading whitespace
    while (isspace(*p))
        p++;

    unsigned len = _cbufBuffer.Length() - (p - (LPTSTR)_cbufBuffer);

    // Are we looking at an expression()
    if (len > 11 &&
        !_tcsnicmp(p, 11, _T("expression("), 11) &&
        p[len - 1] == _T(')'))
    {
        p[len - 1] = 0;

        v.vt = VT_LPWSTR;
        v.byref = p + 11;

        hr = THR(CAttrArray::Set(_ppCurrProperties, dispid, &v, NULL, CAttrValue::AA_Expression));
    }
    else
        hr = S_FALSE;

    if (chOld)
        p[wMaxstrlen] = 0;

    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     GetParentElement
//
//-------------------------------------------------------------------------

void
CCSSParser::GetParentElement(CElement ** ppElement)
{
    *ppElement = NULL;

    if (!_pStyleSheet)
    {
        HRESULT     hr;

        Assert(_pBaseObj);
        hr = _pBaseObj->PrivateQueryInterface(CLSID_CElement, (LPVOID *)ppElement);
        if (hr)
        {
            CStyle * pStyle;
            hr = _pBaseObj->PrivateQueryInterface(CLSID_CStyle, (LPVOID *)&pStyle);
            if(!hr)
                (*ppElement) = pStyle->GetElementPtr();
        }
    }
    else
    {
        (*ppElement) = _pStyleSheet->GetParentElement();
    }
}


//+------------------------------------------------------------------------
//
//  Function:     CCSSParser::SetDefaultNamespace
//
//  Synopsis:   Sets default namespace; in particular used by CXmlDeclElement
//
//-------------------------------------------------------------------------
void
CCSSParser::SetDefaultNamespace(LPCTSTR pchNamespace)
{
    _pDefaultNamespace = new CNamespace();
    if (!_pDefaultNamespace)
        goto Cleanup;

    _pDefaultNamespace->SetShortName(pchNamespace);

Cleanup:
    return;
}



//+------------------------------------------------------------------------
//
//  Function:     ::ParseBackgroundProperty
//
//  Synopsis:
//      This function reads a background property string from the given
//  data string, setting the internal style data of the CAttrArray to reflect any
//  given background styling.
//-------------------------------------------------------------------------
HRESULT ParseBackgroundProperty( CAttrArray **ppAA, CBase *pObject, DWORD dwOpCode, LPCTSTR pcszBGString, BOOL bValidate )
{
    LPTSTR pszString, pszCopy;
    LPTSTR  pszNextToken;
    HRESULT hr = S_OK;
    BOOL fSeenXPos = FALSE;
    BOOL fSeenYPos = FALSE;
    PROPERTYDESC *pPropertyDesc;
    PROPERTYDESC *ppdPosX                 = (PROPERTYDESC *)&s_propdescCStylebackgroundPositionX.a;
    PROPERTYDESC *ppdPosY                 = (PROPERTYDESC *)&s_propdescCStylebackgroundPositionY.a;
    PROPERTYDESC *ppdBackgroundRepeat     = (PROPERTYDESC *)&s_propdescCStylebackgroundRepeat.a;
    PROPERTYDESC *ppdBackgroundAttachment = (PROPERTYDESC *)&s_propdescCStylebackgroundAttachment.a;
    PROPERTYDESC *ppdBackgroundImage      = (PROPERTYDESC *)&s_propdescCStylebackgroundImage.a;
    PROPERTYDESC *ppdBackgroundColor      = (PROPERTYDESC *)&s_propdescCStylebackgroundColor.a;
    BOOL fSeenBGColor      = FALSE;
    BOOL fSeenBGImage      = FALSE;
    BOOL fSeenBGRepeat     = FALSE;
    BOOL fSeenBGAttachment = FALSE;
    TCHAR *pszLastXToken = NULL;

    CAttrValue      avPosX, avPosY, avRepeat, avAttachment, avImage, avColor;
    
    // In strict css1 shorthand properties nothing is recognized if one token is invalid. In compatibility mode we recognize everything that 