t_info_t mpcibg;      /* bridge information is saved */
	mda_pcislot_info_t mpcirp;      /* RP information is saved */
	mpcibg.mpci_BusNo = ctp->cd_BusNo; mpcirp.mpci_BusNo = ctp->cd_BusNo;
	mpcibg.mpci_SlotNo = ctp->cd_SlotNo; mpcirp.mpci_SlotNo = ctp->cd_SlotNo;
	mpcibg.mpci_FuncNo = 0; mpcirp.mpci_FuncNo = ctp->cd_FuncNo;
	if (mdac_pcislotinfo(&mpcibg, MDAC_RQOP_READ)) return MLXERR_NODEV;
	if (mdac_pcislotinfo(&mpcirp, MDAC_RQOP_READ)) return MLXERR_NODEV;
	mlx_rwpcicfg32bits(ctp->cd_BusNo, ctp->cd_SlotNo, 0, MDAC_960RP_BCREG, MDAC_RQOP_WRITE, MDAC_960RP_RESET_SECBUS); /* assert reset */
	mlx_rwpcicfg32bits(ctp->cd_BusNo, ctp->cd_SlotNo, 0, MDAC_960RP_EBCREG, MDAC_RQOP_WRITE, MDAC_960RP_RESET); /* assert reset */
	mlx_rwpcicfg32bits(ctp->cd_BusNo, ctp->cd_SlotNo, 0, MDAC_960RP_BCREG, MDAC_RQOP_WRITE, 0); /* remove reset */
	mlx_rwpcicfg32bits(ctp->cd_BusNo, ctp->cd_SlotNo, 0, MDAC_960RP_EBCREG, MDAC_RQOP_WRITE, 0); /* remove reset */

	for(inx=1000000; inx; mlx_delay10us(),inx--);
	mlx_rwpcicfg32bits(ctp->cd_BusNo, ctp->cd_SlotNo, ctp->cd_FuncNo, 0, MDAC_RQOP_READ, 0); /* read config */
	mdac_pcislotinfo(&mpcibg, MDAC_RQOP_WRITE);     /* restore the config */
	mdac_pcislotinfo(&mpcirp, MDAC_RQOP_WRITE);     /* restore the config */
	return 0;
}

u32bits MLXFAR
mdac_reset_PCIPV(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	return MLXERR_NOCODE;
}

u32bits MLXFAR
mdac_reset_PCIBA(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	return MLXERR_NOCODE;
}

u32bits MLXFAR
mdac_reset_PCILP(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	return MLXERR_NOCODE;
}

/*------------------------------------------------------------------*/
/* Disable HW interrupt */
void    MLXFAR
mdac_disable_intr_MCA(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u08bits_out_mdac(ctp->cd_DacIntrMaskReg,MDAC_DACMC_INTRS_OFF);
}

void    MLXFAR
mdac_disable_intr_EISA(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u08bits_out_mdac(ctp->cd_BmicIntrMaskReg, MDAC_BMIC_INTRS_OFF);
	u08bits_out_mdac(ctp->cd_DacIntrMaskReg, MDAC_DAC_INTRS_OFF);
}

void    MLXFAR
mdac_disable_intr_PCIPDIO(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u08bits_out_mdac(ctp->cd_DacIntrMaskReg, MDAC_DAC_INTRS_OFF);
}

void    MLXFAR
mdac_disable_intr_PCIPDMEM(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u08bits_write(ctp->cd_DacIntrMaskReg, MDAC_DAC_INTRS_OFF);
}

void    MLXFAR
mdac_disable_intr_PCIPG(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u08bits_write(ctp->cd_DacIntrMaskReg, MDAC_DACPG_INTRS_OFF);
}

void    MLXFAR
mdac_disable_intr_PCIPV(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u08bits_write(ctp->cd_DacIntrMaskReg, MDAC_DACPV_INTRS_OFF);
}

void    MLXFAR
mdac_disable_intr_PCIBA(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u08bits_write(ctp->cd_DacIntrMaskReg, MDAC_DACBA_INTRS_OFF);
}


void    MLXFAR
mdac_disable_intr_PCILP(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u08bits_write(ctp->cd_DacIntrMaskReg, MDAC_DACLP_INTRS_OFF);
}

/*------------------------------------------------------------------*/
/* Enable HW interrupt */
void    MLXFAR
mdac_enable_intr_MCA(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u08bits_out_mdac(ctp->cd_DacIntrMaskReg, MDAC_DACMC_INTRS_ON);
}

void    MLXFAR
mdac_enable_intr_EISA(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u08bits_out_mdac(ctp->cd_BmicIntrMaskReg, MDAC_BMIC_INTRS_ON);
	u08bits_out_mdac(ctp->cd_DacIntrMaskReg, MDAC_DAC_INTRS_ON);
}

void    MLXFAR
mdac_enable_intr_PCIPDIO(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u08bits_out_mdac(ctp->cd_DacIntrMaskReg, MDAC_DAC_INTRS_ON);
}

void    MLXFAR
mdac_enable_intr_PCIPDMEM(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u08bits_write(ctp->cd_DacIntrMaskReg, MDAC_DAC_INTRS_ON);
}

void    MLXFAR
mdac_enable_intr_PCIPG(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u08bits_write(ctp->cd_DacIntrMaskReg, MDAC_DACPG_INTRS_ON);
}

void    MLXFAR
mdac_enable_intr_PCIPV(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u08bits_write(ctp->cd_DacIntrMaskReg, MDAC_DACPV_INTRS_ON);
}

void    MLXFAR
mdac_enable_intr_PCIBA(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u08bits_write(ctp->cd_DacIntrMaskReg, MDAC_DACBA_INTRS_ON);
}

void    MLXFAR
mdac_enable_intr_PCILP(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u08bits_write(ctp->cd_DacIntrMaskReg, MDAC_DACLP_INTRS_ON);
}

/*-------------------------------------------------------------*/
/* Check the mail box status, return 0 if free */
u32bits MLXFAR
mdac_check_mbox_MCA(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	return u08bits_read(ctp->cd_MemBaseVAddr); /* +MDAC_CMD_CODE); */
}

u32bits MLXFAR
mdac_check_mbox_EISA_PCIPD(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	return u08bits_in_mdac(ctp->cd_LocalDoorBellReg) & MDAC_MAILBOX_FULL;
}

u32bits MLXFAR
mdac_check_mbox_PCIPDMEM(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	return u08bits_read(ctp->cd_LocalDoorBellReg) & MDAC_MAILBOX_FULL;
}

u32bits MLXFAR
mdac_check_mbox_PCIPG(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	return u08bits_read(ctp->cd_LocalDoorBellReg) & MDAC_MAILBOX_FULL;
}

u32bits MLXFAR
mdac_check_mbox_PCIPV(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	return (!(u08bits_read(ctp->cd_LocalDoorBellReg) & MDAC_MAILBOX_FULL));
}

u32bits MLXFAR
mdac_check_mbox_PCIBA(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	return (!(u08bits_read(ctp->cd_LocalDoorBellReg) & MDAC_MAILBOX_FULL));
}

/* 
** Unlike Big Apple, Leopard ODR bits are in asserted state if its 1 
*/
u32bits MLXFAR
mdac_check_mbox_PCILP(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	return (u08bits_read(ctp->cd_LocalDoorBellReg) & MDAC_MAILBOX_FULL);
}

/* We send more commands than what can be accomodated in mail box */
u32bits MLXFAR
mdac_check_mbox_mmb(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	return *((u32bits MLXFAR *)(ctp->cd_HostCmdQue + ctp->cd_HostCmdQueIndex));
}

/*-------------------------------------------------------------*/
/* check if interrupt is pending, return interrupt status */
#ifndef MLX_OS2
u32bits MLXFAR
mdac_pending_intr_MCA(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u32bits irqs=u08bits_in_mdac(ctp->cd_IOBaseAddr+MDAC_DMC_CBSP) & MDAC_DMC_IV;
	if(!irqs) return irqs; /* No interrupt */
	u08bits_out_mdac(ctp->cd_DacIntrMaskReg, MDAC_DACMC_INTRS_ON|0x40);
	u08bits_in_mdac(ctp->cd_IOBaseAddr+MDAC_DMC_CBSP); /* Clear interrupt by reading */
	u08bits_out_mdac(ctp->cd_DacIntrMaskReg,MDAC_DACMC_INTRS_ON); /* Set not to clear on read */
	return irqs;
}

u32bits MLXFAR
mdac_pending_intr_EISA_PCIPD(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	return u08bits_in_mdac(ctp->cd_SystemDoorBellReg) & MDAC_PENDING_INTR;
}
#endif
u32bits MLXFAR
mdac_pending_intr_PCIPDMEM(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	return u08bits_read(ctp->cd_SystemDoorBellReg) & MDAC_PENDING_INTR;
}

u32bits MLXFAR
mdac_pending_intr_PCIPG(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	return u08bits_read(ctp->cd_SystemDoorBellReg)&MDAC_DACPG_PENDING_INTR;
}

u32bits MLXFAR
mdac_pending_intr_PCIPV(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	return u08bits_read(ctp->cd_SystemDoorBellReg)&MDAC_DACPV_PENDING_INTR;
}

u32bits MLXFAR
mdac_pending_intr_PCIBA(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	return u08bits_read(ctp->cd_SystemDoorBellReg)&MDAC_DACBA_PENDING_INTR;
}

u32bits MLXFAR
mdac_pending_intr_PCILP(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	return u08bits_read(ctp->cd_SystemDoorBellReg)&MDAC_DACLP_PENDING_INTR;
}

u32bits MLXFAR
mdac_pending_intr_PCIPG_mmb(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	return u32bits_read_mmb(ctp->cd_HostStatusQue+ctp->cd_HostStatusQueIndex);
}

/*-------------------------------------------------------------*/
/* read the command ID and completion status */
#ifndef MLX_OS2
u32bits MLXFAR
mdac_cmdid_status_MCA(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u32bits status = u32bits_read(ctp->cd_CmdIDStatusReg); MLXSWAP(status);
	u08bits_out_mdac(ctp->cd_IOBaseAddr+MDAC_DMC_ATTN, MDAC_DMC_GOT_STAT);
	return (status&0xFFFF0000) + ((status>>8)&0xFF);
}

u32bits MLXFAR
mdac_cmdid_status_EISA_PCIPD(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u32bits status = u32bits_in_mdac(ctp->cd_CmdIDStatusReg); MLXSWAP(status);
	u08bits_out_mdac(ctp->cd_SystemDoorBellReg, MDAC_CLEAR_INTR);
	u08bits_out_mdac(ctp->cd_LocalDoorBellReg, MDAC_GOT_STATUS);
	return (status&0xFFFF0000) + ((status>>8)&0xFF);
}
#endif

u32bits MLXFAR
mdac_cmdid_status_PCIPDMEM(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u32bits status = u32bits_read(ctp->cd_CmdIDStatusReg); MLXSWAP(status);
	u08bits_write(ctp->cd_SystemDoorBellReg, MDAC_CLEAR_INTR);
	u08bits_write(ctp->cd_LocalDoorBellReg, MDAC_GOT_STATUS);
	return (status&0xFFFF0000) + ((status>>8)&0xFF);
}

u32bits MLXFAR
mdac_cmdid_status_PCIPG(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u32bits status = u32bits_read(ctp->cd_CmdIDStatusReg); MLXSWAP(status);
	u08bits_write(ctp->cd_SystemDoorBellReg, MDAC_CLEAR_INTR);
	u08bits_write(ctp->cd_LocalDoorBellReg, MDAC_GOT_STATUS);
	return status;
}

u32bits MLXFAR
mdac_cmdid_status_PCIPV(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u32bits status = u32bits_read(ctp->cd_CmdIDStatusReg); MLXSWAP(status);
	u08bits_write(ctp->cd_SystemDoorBellReg, MDAC_CLEAR_INTR);
	u08bits_write(ctp->cd_LocalDoorBellReg, MDAC_GOT_STATUS);
	return (status&0xFFFF0000) + ((status>>8)&0xFF);
}

u32bits MLXFAR
mdac_cmdid_status_PCIBA(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u32bits status = u32bits_read(ctp->cd_CmdIDStatusReg); MLXSWAP(status);
	ctp->cd_LastCmdResdSize = u32bits_read(ctp->cd_CmdIDStatusReg+4); MLXSWAP(ctp->cd_LastCmdResdSize);
	u08bits_write(ctp->cd_SystemDoorBellReg, MDAC_CLEAR_INTR);
	u08bits_write(ctp->cd_LocalDoorBellReg, MDAC_GOT_STATUS);
	return status;
}

u32bits MLXFAR
mdac_cmdid_status_PCILP(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u32bits status = u32bits_read(ctp->cd_CmdIDStatusReg); MLXSWAP(status);
	ctp->cd_LastCmdResdSize = u32bits_read(ctp->cd_CmdIDStatusReg+4); MLXSWAP(ctp->cd_LastCmdResdSize);
	u08bits_write(ctp->cd_SystemDoorBellReg, MDAC_CLEAR_INTR);
	u08bits_write(ctp->cd_LocalDoorBellReg, MDAC_GOT_STATUS);
	return status;
}

u32bits MLXFAR
mdac_cmdid_status_PCIPG_mmb(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u32bits status, index = ctp->cd_HostStatusQueIndex;
	status = u32bits_read_mmb(ctp->cd_HostStatusQue+index); MLXSWAP(status);
	u32bits_write_mmb(ctp->cd_HostStatusQue+index,0);
	ctp->cd_HostStatusQueIndex = (index + 4) & 0xFFF;
	return status & 0xFFFF7FFF;
}

u32bits MLXFAR
mdac_cmdid_status_PCIBA_mmb(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u32bits status, index = ctp->cd_HostStatusQueIndex;
	ctp->cd_LastCmdResdSize = u32bits_read_mmb(ctp->cd_HostStatusQue+index+4); MLXSWAP(ctp->cd_LastCmdResdSize);
	status = u32bits_read_mmb(ctp->cd_HostStatusQue+index); MLXSWAP(status);
	u32bits_write_mmb(ctp->cd_HostStatusQue+index,0);
	ctp->cd_HostStatusQueIndex = (index + 8) & 0xFFF;

	return status;
}

/*-------------------------------------------------------------*/
/* send command to controller, enter here interrupt protected */

u32bits MLXFAR
mdac_send_cmd(rqp)
mdac_req_t MLXFAR *rqp;
{
	mdac_ctldev_t MLXFAR *ctp = rqp->rq_ctp;
    u08bits irql;
    mdac_prelock(&irql);
	mdac_ctlr_lock(ctp);

	/* if the controller is stopped by HPP service,
	 * only allow STOP/RESUME CONTROLLER command till the DACMD_STOP_CONTROLLER
	 * flag is cleared
	 */

	if ((ctp->cd_Status & MDACD_CTRL_SHUTDOWN) &&
	    (rqp->rq_DacCmd.mb_Command != DACMD_IOCTL))
	{
	    goto outq;
	}

	if (ctp->cd_ActiveCmds >= ctp->cd_MaxCmds) goto outq; /* too many cmds*/
issue_cmd:
	if ((*ctp->cd_CheckMailBox)(ctp)) goto outqm;   /* mail box not free */
	mdac_get_cmdid(ctp,rqp);
	ctp->cd_cmdid2req[rqp->rq_cmdidp->cid_cmdid] = rqp;
	ctp->cd_ActiveCmds++;
	(*ctp->cd_SendCmd)(rqp);

/* #if defined(_WIN64) || defined(SCSIPORT_COMPLIANT)  */
/* #ifdef NEVER  // there are too many problems associated w/ the time trace stuff */
	if (ctp->cd_TimeTraceEnabled)
	{       /* Note down the starting time */
		if (mdac_tthrtime) rqp->rq_ttHWClocks = (unsigned short) mdac_read_hwclock();
		rqp->rq_ttTime = MLXCLBOLT();
	}
/* #endif */
/* #endif */
	mdac_ctlr_unlock(ctp);
    mdac_postlock(irql);


zerointr:/* Zero Interrupt Support logic */
	if ((!mda_TotalCmdsToWaitForZeroIntr) || (!mdac_masterintrctp)) return 0;
	if ((++mda_TotalCmdsSentSinceLastIntr) < mda_TotalCmdsToWaitForZeroIntr) return 0;
	  if (!mdac_allmsintr())  return 0;  
/* do not reset interrupt if driver did not process completions 8.24.99 */

    mdac_prelock(&irql);
	mdac_ctlr_lock(mdac_masterintrctp);
	u08bits_write(mdac_masterintrctp->cd_SystemDoorBellReg, MDAC_ZERO_INTR);
	mdac_ctlr_unlock(mdac_masterintrctp);
    mdac_postlock(irql);
	/* mdac_allmsintr(); */
	return 0;

outqm: MLXSTATS(ctp->cd_MailBoxCmdsWaited++;)
outq:
	/*
	 * if the controller is shutdown by PCI HotPlug Service,
	 * allow STOP/START CONTROLLER command only, until
	 * MDACD_CONTROLLER_SHUTDOWN flag is cleared.
	 */

	if ((ctp->cd_Status & MDACD_CTRL_SHUTDOWN) &&
	    (rqp->rq_DacCmd.mb_Command == DACMD_IOCTL))
	{
	    if (ctp->cd_ActiveCmds < ctp->cd_MaxCmds)
		goto issue_cmd;
	}

	qreq(ctp,rqp); /* queue the request, it will start later */
	rqp->rq_StartReq = mdac_send_cmd;       /* we will be called later */
	mdac_ctlr_unlock(ctp);
    mdac_postlock(irql);
	goto zerointr;
}

#ifndef MLX_OS2
u32bits MLXFAR
mdac_send_cmd_MCA(rqp)
mdac_req_t MLXFAR *rqp;
{
	UINT_PTR mbox = rqp->rq_ctp->cd_MailBox;
	u32bits_write(mbox+0x0,dcmd4p->mb_MailBox0_3);
	u32bits_write(mbox+0x4,dcmd4p->mb_MailBox4_7);
	u32bits_write(mbox+0x8,dcmd4p->mb_MailBox8_B);
	u08bits_write(mbox+0xC, dcmdp->mb_MailBoxC);
	if (u08bits_read(mbox) != dcmdp->mb_Command)
	for(mlx_delay10us(); 1; mlx_delay10us())
		if (u08bits_read(mbox) == dcmdp->mb_Command) break;
	u08bits_out_mdac(rqp->rq_ctp->cd_IOBaseAddr+MDAC_DMC_ATTN, MDAC_DMC_NEW_CMD);
	return 0;
}

/* This will work for EISA/PCIPD in IO mode */
u32bits MLXFAR
mdac_send_cmd_EISA_PCIPD(rqp)
mdac_req_t MLXFAR *rqp;
{
	UINT_PTR mbox = rqp->rq_ctp->cd_MailBox;
	u32bits_out_mdac(mbox+0x0,dcmd4p->mb_MailBox0_3);
	u32bits_out_mdac(mbox+0x4,dcmd4p->mb_MailBox4_7);
	u32bits_out_mdac(mbox+0x8,dcmd4p->mb_MailBox8_B);
	u08bits_out_mdac(mbox+0xC, dcmdp->mb_MailBoxC);
	u08bits_out_mdac(rqp->rq_ctp->cd_LocalDoorBellReg, MDAC_MAILBOX_FULL);
	return 0;
}
#endif

u32bits MLXFAR
mdac_send_cmd_PCIPDMEM(rqp)
mdac_req_t MLXFAR *rqp;
{
	UINT_PTR mbox = rqp->rq_ctp->cd_MailBox;
	u32bits_write(mbox+0x0,dcmd4p->mb_MailBox0_3);
	u32bits_write(mbox+0x4,dcmd4p->mb_MailBox4_7);
	u32bits_write(mbox+0x8,dcmd4p->mb_MailBox8_B);
	u08bits_write(mbox+0xC, dcmdp->mb_MailBoxC);
	u08bits_write(rqp->rq_ctp->cd_LocalDoorBellReg, MDAC_MAILBOX_FULL);
	return 0;
}

u32bits MLXFAR
mdac_send_cmd_PCIPG(rqp)
mdac_req_t MLXFAR *rqp;
{
	UINT_PTR mbox = rqp->rq_ctp->cd_MailBox;
	u32bits_write(mbox+0x0,dcmd4p->mb_MailBox0_3);
	u32bits_write(mbox+0x4,dcmd4p->mb_MailBox4_7);
	u32bits_write(mbox+0x8,dcmd4p->mb_MailBox8_B);
	u08bits_write(mbox+0xC, dcmdp->mb_MailBoxC);
	u08bits_write(rqp->rq_ctp->cd_LocalDoorBellReg, MDAC_MAILBOX_FULL);
	return 0;
}

u32bits MLXFAR
mdac_send_cmd_PCIPV(rqp)
mdac_req_t MLXFAR *rqp;
{
	UINT_PTR mbox = rqp->rq_ctp->cd_MailBox;
	u32bits_write(mbox+0x0,dcmd4p->mb_MailBox0_3);
	u32bits_write(mbox+0x4,dcmd4p->mb_MailBox4_7);
	u32bits_write(mbox+0x8,dcmd4p->mb_MailBox8_B);
	u08bits_write(mbox+0xC, dcmdp->mb_MailBoxC);
	u08bits_write(rqp->rq_ctp->cd_LocalDoorBellReg, MDAC_MAILBOX_FULL);
	return 0;
}

u32bits MLXFAR
mdac_send_cmd_PCIBA(rqp)
mdac_req_t MLXFAR *rqp;
{
	UINT_PTR mbox = rqp->rq_ctp->cd_MailBox;
#ifdef  OLD_WAY
	u32bits MLXFAR *cmdp = (u32bits MLXFAR *)ncmdp;
	u32bits_write(mbox+0x00,*(cmdp+0)); u32bits_write(mbox+0x04,*(cmdp+1));
	u32bits_write(mbox+0x08,*(cmdp+2)); u32bits_write(mbox+0x0C,*(cmdp+3));
	u32bits_write(mbox+0x10,*(cmdp+4)); u32bits_write(mbox+0x14,*(cmdp+5));
	u32bits_write(mbox+0x18,*(cmdp+6)); u32bits_write(mbox+0x1C,*(cmdp+7));
	u32bits_write(mbox+0x20,*(cmdp+8)); u32bits_write(mbox+0x24,*(cmdp+9));
	u32bits_write(mbox+0x28,*(cmdp+10));u32bits_write(mbox+0x2C,*(cmdp+11));
	u32bits_write(mbox+0x30,*(cmdp+12));u32bits_write(mbox+0x34,*(cmdp+13));
	u32bits_write(mbox+0x38,*(cmdp+14));u32bits_write(mbox+0x3C,*(cmdp+15));
#else
	u64bits pa;
	u32bits MLXFAR *cmdp = (u32bits MLXFAR *)&pa;
	mlx_add64bits(pa,rqp->rq_PhysAddr,offsetof(mdac_req_t,rq_DacCmdNew));
	MLXSWAP(pa);
	u32bits_write(mbox+0x00,*(cmdp+0)); u32bits_write(mbox+0x04,*(cmdp+1));
#endif  /* OLD_WAY */
	u08bits_write(rqp->rq_ctp->cd_LocalDoorBellReg, MDAC_MAILBOX_FULL);
	return 0;
}

#ifndef MLX_EFI
u32bits MLXFAR
mdac_send_cmd_PCILP(rqp)
mdac_req_t MLXFAR *rqp;
{
	UINT_PTR mbox = rqp->rq_ctp->cd_MailBox;
#ifdef  OLD_WAY
	u32bits MLXFAR *cmdp = (u32bits MLXFAR *)ncmdp;
	u32bits_write(mbox+0x00,*(cmdp+0)); u32bits_write(mbox+0x04,*(cmdp+1));
	u32bits_write(mbox+0x08,*(cmdp+2)); u32bits_write(mbox+0x0C,*(cmdp+3));
	u32bits_write(mbox+0x10,*(cmdp+4)); u32bits_write(mbox+0x14,*(cmdp+5));
	u32bits_write(mbox+0x18,*(cmdp+6)); u32bits_write(mbox+0x1C,*(cmdp+7));
	u32bits_write(mbox+0x20,*(cmdp+8)); u32bits_write(mbox+0x24,*(cmdp+9));
	u32bits_write(mbox+0x28,*(cmdp+10));u32bits_write(mbox+0x2C,*(cmdp+11));
	u32bits_write(mbox+0x30,*(cmdp+12));u32bits_write(mbox+0x34,*(cmdp+13));
	u32bits_write(mbox+0x38,*(cmdp+14));u32bits_write(mbox+0x3C,*(cmdp+15));
#else
	u64bits pa;
	u32bits MLXFAR *cmdp = (u32bits MLXFAR *)&pa;
	pa.bit31_0 = rqp->rq_PhysAddr.bit31_0 + offsetof(mdac_req_t,rq_DacCmdNew);
	pa.bit63_32 = 0;
	MLXSWAP(pa);
	u32bits_write(mbox+0x00,*(cmdp+0)); u32bits_write(mbox+0x04,*(cmdp+1));
#endif  /* OLD_WAY */
	u08bits_write(rqp->rq_ctp->cd_LocalDoorBellReg, MDAC_MAILBOX_FULL);
	return 0;
}

#else

u32bits MLXFAR
mdac_send_cmd_PCILP(rqp)
mdac_req_t MLXFAR *rqp;
{
	UINT_PTR mbox = rqp->rq_ctp->cd_MailBox;
	mdac_commandnew_t *xcmdp;
#ifdef  OLD_WAY
	u32bits MLXFAR *cmdp = (u32bits MLXFAR *)ncmdp;
	u32bits_write(mbox+0x00,*(cmdp+0)); u32bits_write(mbox+0x04,*(cmdp+1));
	u32bits_write(mbox+0x08,*(cmdp+2)); u32bits_write(mbox+0x0C,*(cmdp+3));
	u32bits_write(mbox+0x10,*(cmdp+4)); u32bits_write(mbox+0x14,*(cmdp+5));
	u32bits_write(mbox+0x18,*(cmdp+6)); u32bits_write(mbox+0x1C,*(cmdp+7));
	u32bits_write(mbox+0x20,*(cmdp+8)); u32bits_write(mbox+0x24,*(cmdp+9));
	u32bits_write(mbox+0x28,*(cmdp+10));u32bits_write(mbox+0x2C,*(cmdp+11));
	u32bits_write(mbox+0x30,*(cmdp+12));u32bits_write(mbox+0x34,*(cmdp+13));
	u32bits_write(mbox+0x38,*(cmdp+14));u32bits_write(mbox+0x3C,*(cmdp+15));
#else
	u64bits pa;
	u32bits MLXFAR *cmdp = (u32bits MLXFAR *)&pa;

	u08bits *ptr = *((u08bits **)cmdp);
	pa.bit31_0 = rqp->rq_PhysAddr.bit31_0 + offsetof(mdac_req_t,rq_DacCmdNew);
	pa.bit63_32 = rqp->rq_PhysAddr.bit63_32; /*efi64 added by KFR */
	MLXSWAP(pa);
	xcmdp = pa.bit31_0 + (((UINT_PTR)pa.bit63_32) << 32);

	u32bits_write(mbox+0x00,*(cmdp+0)); u32bits_write(mbox+0x04,*(cmdp+1));
#endif  /* OLD_WAY */
	u08bits_write(rqp->rq_ctp->cd_LocalDoorBellReg, MDAC_MAILBOX_FULL);

	return 0;
}

#endif /* MLX_EFI */

u32bits MLXFAR
mdac_send_cmd_PCIBA_mmb_mode(rqp)
mdac_req_t MLXFAR *rqp;
{
	mdac_ctldev_t MLXFAR *ctp = rqp->rq_ctp;
	u32bits MLXFAR *mbx = (u32bits MLXFAR *)(ctp->cd_HostCmdQue + ctp->cd_HostCmdQueIndex);
	u32bits MLXFAR *cmdp = (u32bits MLXFAR *)ncmdp;
	ctp->cd_HostCmdQueIndex = (ctp->cd_HostCmdQueIndex + 64) & 0xFFF;
	
	*(mbx+1) = *(cmdp+1); *(mbx+2) = *(cmdp+2); *(mbx+3) = *(cmdp+3);
	*(mbx+4) = *(cmdp+4); *(mbx+5) = *(cmdp+5); *(mbx+6) = *(cmdp+6);
	*(mbx+7) = *(cmdp+7); *(mbx+8) = *(cmdp+8); *(mbx+9) = *(cmdp+9);
	*(mbx+10) = *(cmdp+10); *(mbx+11) = *(cmdp+11); *(mbx+12) = *(cmdp+12);
	*(mbx+13) = *(cmdp+13); *(mbx+14) = *(cmdp+14); *(mbx+15) = *(cmdp+15);

	*mbx = *cmdp;

	mbx = (u32bits MLXFAR *)(ctp->cd_HostCmdQue + ((ctp->cd_HostCmdQueIndex-128)&0xFFF));
	if (*mbx) return MLXSTATS(ctp->cd_DoorBellSkipped++), 0;
	u08bits_write(ctp->cd_LocalDoorBellReg, MDAC_MAILBOX_FULL_DUAL_MODE);
	return 0;
}

u32bits MLXFAR
mdac_send_cmd_PCIPG_mmb(rqp)
mdac_req_t MLXFAR *rqp;
{
	mdac_ctldev_t MLXFAR *ctp = rqp->rq_ctp;
	u32bits MLXFAR *mbx = (u32bits MLXFAR *)(ctp->cd_HostCmdQue + ctp->cd_HostCmdQueIndex);
	ctp->cd_HostCmdQueIndex = (ctp->cd_HostCmdQueIndex + 16) & 0xFFF;
	*(mbx+1) = dcmd4p->mb_MailBox4_7;
	*(mbx+2) = dcmd4p->mb_MailBox8_B;
	*(mbx+3) = dcmdp->mb_MailBoxC;
	*mbx = dcmd4p->mb_MailBox0_3;
	mbx = (u32bits MLXFAR *)(ctp->cd_HostCmdQue + ((ctp->cd_HostCmdQueIndex-32)&0xFFF));
	if (*mbx) return MLXSTATS(ctp->cd_DoorBellSkipped++), 0;
	u08bits_write(ctp->cd_LocalDoorBellReg, MDAC_MAILBOX_FULL);
	return 0;
}

u32bits MLXFAR
mdac_send_cmd_mmb_mode(rqp)
mdac_req_t MLXFAR *rqp;
{
	mdac_ctldev_t MLXFAR *ctp = rqp->rq_ctp;
	u32bits MLXFAR *mbx = (u32bits MLXFAR *)(ctp->cd_HostCmdQue + ctp->cd_HostCmdQueIndex);
	ctp->cd_HostCmdQueIndex = (ctp->cd_HostCmdQueIndex + 16) & 0xFFF;
	*(mbx+1) = dcmd4p->mb_MailBox4_7;
	*(mbx+2) = dcmd4p->mb_MailBox8_B;
	*(mbx+3) = dcmdp->mb_MailBoxC;
	*mbx = dcmd4p->mb_MailBox0_3;
	mbx = (u32bits MLXFAR *)(ctp->cd_HostCmdQue + ((ctp->cd_HostCmdQueIndex-32)&0xFFF));
	if (*mbx) return MLXSTATS(ctp->cd_DoorBellSkipped++), 0;
	u08bits_write(ctp->cd_LocalDoorBellReg, MDAC_MAILBOX_FULL_DUAL_MODE);
	return 0;
}

/* send 32 byte command */
u32bits MLXFAR
mdac_send_cmd_mmb32(rqp)
mdac_req_t MLXFAR *rqp;
{
	mdac_ctldev_t MLXFAR *ctp = rqp->rq_ctp;
	u32bits MLXFAR *mbx = (u32bits MLXFAR *)(ctp->cd_HostCmdQue + ctp->cd_HostCmdQueIndex);
	ctp->cd_HostCmdQueIndex = (ctp->cd_HostCmdQueIndex + 32) & 0xFFF;
	*(mbx+1) = dcmd32p->mb_MailBox04_07;
	*(mbx+2) = dcmd32p->mb_MailBox08_0B;
	*(mbx+3) = dcmd32p->mb_MailBox0C_0F;
	*(mbx+4) = dcmd32p->mb_MailBox10_13;
	*(mbx+5) = dcmd32p->mb_MailBox14_17;
	*(mbx+6) = dcmd32p->mb_MailBox18_1B;
	*(mbx+7) = dcmd32p->mb_MailBox1C_1F;
	*(mbx+0) = dcmd32p->mb_MailBox00_03;
	mbx = (u32bits MLXFAR *)(ctp->cd_HostCmdQue + ((ctp->cd_HostCmdQueIndex-64)&0xFFF));
	if (*mbx) return MLXSTATS(ctp->cd_DoorBellSkipped++), 0;
	u08bits_write(ctp->cd_LocalDoorBellReg, MDAC_MAILBOX_FULL_DUAL_MODE);
	return 0;
}

/* send 64 byte command */
u32bits MLXFAR
mdac_send_cmd_mmb64(rqp)
mdac_req_t MLXFAR *rqp;
{
	mdac_ctldev_t MLXFAR *ctp = rqp->rq_ctp;
	u32bits MLXFAR *mbx = (u32bits MLXFAR *)(ctp->cd_HostCmdQue + ctp->cd_HostCmdQueIndex);
	u32bits MLXFAR *cmdp = (u32bits MLXFAR *)ncmdp;
	ctp->cd_HostCmdQueIndex = (ctp->cd_HostCmdQueIndex + mdac_commandnew_s) & 0xFFF;
	*(mbx+1) = *(cmdp+1);   *(mbx+2) = *(cmdp+2);
	*(mbx+3) = *(cmdp+3);   *(mbx+4) = *(cmdp+4);
	*(mbx+5) = *(cmdp+5);   *(mbx+6) = *(cmdp+6);
	*(mbx+7) = *(cmdp+7);   *(mbx+8) = *(cmdp+8);
	*(mbx+9) = *(cmdp+9);   *(mbx+10) = *(cmdp+10);
	*(mbx+11) = *(cmdp+11); *(mbx+12) = *(cmdp+12);
	*(mbx+13) = *(cmdp+13); *(mbx+14) = *(cmdp+14);
	*(mbx+15) = *(cmdp+15); *(mbx+0) = *(cmdp+0);
	mbx = (u32bits MLXFAR *)(ctp->cd_HostCmdQue + ((ctp->cd_HostCmdQueIndex-(mdac_commandnew_s*2))&0xFFF));
	if (*mbx) return MLXSTATS(ctp->cd_DoorBellSkipped++), 0;
	u08bits_write(ctp->cd_LocalDoorBellReg, MDAC_MAILBOX_FULL_DUAL_MODE);
	return 0;
}
/*-------------------------------------------------------------*/
u32bits MLXFAR
mdac_commoninit()
{
	u32bits inx;

#ifdef MLX_NT
	#ifndef MLX_FIXEDPOOL
	/* if we are using ScsiPortfixedpool approach, need to defer any memory allocation 
	   till after call to ScsiPortGetUncachedExtension in HwInitializeFindAdapter routine
	*/
	mdac_flushdatap=(u08bits MLXFAR*)mlx_memmapiospace2(mlx_kvtophys2(mdac_allocmem(mdac_ctldevtbl,4*ONEKB)),4*ONEKB);  
	#endif
#elif MLX_WIN9X
//      mdac_flushdatap=(u08bits MLXFAR*)mlx_memmapiospace2(mlx_kvtophys2(mdac_allocmem(mdac_ctldevtbl,4*ONEKB)),4*ONEKB);
#elif MLX_SOL_SPARC
	;
#elif MLX_SOL_X86
	mdac_flushdatap = (u08bits MLXFAR *)&mdac_flushdata;
#elif MLX_NW
	mdac_flushdatap=(u08bits MLXFAR*)mdac_allocmem(mdac_ctldevtbl,4*ONEKB);
#else
	mdac_flushdatap=(u08bits MLXFAR*)mlx_memmapiospace(mlx_kvtophys(mdac_devtbl,mdac_allocmem(mdac_ctldevtbl,4*ONEKB)),4*ONEKB);
#endif

#if !defined(MLX_SOL) && !defined(_WIN64) && !defined(SCSIPORT_COMPLIANT)
#if defined MLX_NT
	if (KeGetCurrentIrql() == PASSIVE_LEVEL)
	    mdac_biosp = (dac_biosinfo_t MLXFAR*)mlx_maphystokv(DAC_BIOSSTART,DAC_BIOSSIZE);
#elif MLX_WIN9X
//          mdac_biosp = (dac_biosinfo_t MLXFAR*)mlx_maphystokv(DAC_BIOSSTART,DAC_BIOSSIZE);
#else
	mdac_biosp = (dac_biosinfo_t MLXFAR*)mlx_maphystokv(DAC_BIOSSTART,DAC_BIOSSIZE);
#endif
#endif
	mda_RevStr[0] = ' ';
	mda_RevStr[1] = mdac_driver_version.dv_MajorVersion + '0';
	mda_RevStr[2] = '.';
	mda_RevStr[3] =(mdac_driver_version.dv_MinorVersion/10)+'0';
	mda_RevStr[4] =(mdac_driver_version.dv_MinorVersion%10)+'0';
	mda_RevStr[5] = '-';
	mda_RevStr[6] =(mdac_driver_version.dv_BuildNo/10)+'0';
	mda_RevStr[7] =(mdac_driver_version.dv_BuildNo%10)+'0';
	if (((inx=mdac_driver_version.dv_BuildMonth)>=1) && (inx<=12))
		mdaccopy(&mdac_monthstr[(inx-1)*3],&mda_DateStr[0],3);
	mda_DateStr[3] = ' ';
	mda_DateStr[4] = (mdac_driver_version.dv_BuildDate/10)+'0';
	mda_DateStr[5] = (mdac_driver_version.dv_BuildDate%10)+'0';
	mda_DateStr[6] = ',';
	mda_DateStr[7] = ' ';
	mda_DateStr[8] = (mdac_driver_version.dv_BuildYearMS/10)+'0';
	mda_DateStr[9] = (mdac_driver_version.dv_BuildYearMS%10)+'0';
	mda_DateStr[10] = (mdac_driver_version.dv_BuildYearLS/10)+'0';
	mda_DateStr[11] = (mdac_driver_version.dv_BuildYearLS%10)+'0';
	mdac_setctlnos();
	mdac_check_cputype();
	mdac_driver_ready = 1;
#ifndef  WINNT_50
	mlx_timeout(mdac_timer,MDAC_IOSCANTIME);
#endif
	return 0;
}

/* set controller numbers */
u32bits MLXFAR
mdac_setctlnos()
{
	u08bits ctl;
	mdac_ctldev_t   MLXFAR *ctp = mdac_ctldevtbl;
	for(ctl=0; ctl<MDAC_MAXCONTROLLERS; ctp++,ctl++)
	{
		ctp->cd_ControllerNo = ctl;
		ctp->cd_EndMarker[0] = 'D'; ctp->cd_EndMarker[1] = 'A';
		ctp->cd_EndMarker[2] = 'C'; ctp->cd_EndMarker[3] = 'C';
	}
	return 0;
}

/* this function must be called before unloading the driver */
u32bits MLXFAR
mdac_release()
{
	mdac_ctldev_t   MLXFAR *ctp = &mdac_ctldevtbl[0];
	mdac_mem_t      MLXFAR *mp;
	mdac_ttbuf_t    MLXFAR *ttbp;
	mdac_driver_ready = 0;
	for (ttbp=mdac_ttbuftbl; ttbp<mdac_ttbuftblend; ttbp++)
	{
		if (ttbp->ttb_Datap) mdacfree4kb(ctp,ttbp->ttb_Datap);
		ttbp->ttb_Datap = NULL;
	}
	for (ctp=mdac_ctldevtbl; ctp<mdac_lastctp; ctp++)
	{       /* free all controller related memory */
		if (ctp->cd_CmdIDMemAddr)
			mdac_free4kb(ctp, (mdac_mem_t MLXFAR *)ctp->cd_CmdIDMemAddr);
		ctp->cd_CmdIDMemAddr = NULL;
	}
	for (ctp=mdac_ctldevtbl; ctp<mdac_lastctp; ctp++)
	{       /* free all controller related memory */
		while (mp=ctp->cd_8KBMemList)
		{
			ctp->cd_4KBMemList = mp->dm_next;
			ctp->cd_FreeMemSegs4KB--;
			MLXSTATS(ctp->cd_MemAlloced4KB -= 4*ONEKB;)
			mlx_free4kb(ctp,(u08bits *)mp);
		}
	}
	for (ctp=mdac_ctldevtbl; ctp<mdac_lastctp; ctp++)
	{       /* free all controller related memory */
		while (mp=ctp->cd_8KBMemList)
		{
			ctp->cd_8KBMemList = mp->dm_next;
			ctp->cd_FreeMemSegs8KB--;
			MLXSTATS(ctp->cd_MemAlloced8KB -= 8*ONEKB;)
			mlx_free8kb(ctp,(u08bits *)mp);
		}
	}

	return 0;
}

/*==========================SCAN CONTROLLERS STARTS===========================*/
/* initialize all controllers, return number of controllers init OK */
u32bits MLXFAR
mdac_initcontrollers()
{
	u32bits ctls;
	mdac_ctldev_t MLXFAR *ctp = mdac_ctldevtbl;
	for (ctp=mdac_ctldevtbl,ctls=0; ctp<mdac_lastctp; ctp++)
	{
		if ((*ctp->cd_InitAddr)(ctp)) continue;
		ctp->cd_ServiceIntr = mdac_oneintr;
		if (mdac_ctlinit(ctp)) continue;
		ctls++;
	}
	return ctls;
}

/* Scan for controllers */

#ifndef MLX_NT
u32bits MLXFAR
mdac_scan_MCA()
{
	u08bits slot;
	mdac_ctldev_t MLXFAR *ctp = &mdac_ctldevtbl[mda_Controllers];
	for (slot=0; slot<MDAC_MAXMCASLOTS; slot++)
	{
		ctp->cd_BusNo = 0; ctp->cd_SlotNo = slot;
		if (mdac_cardis_MCA(ctp)) continue;
		ctp->cd_InitAddr = mdac_init_addrs_MCA;
		mdac_newctlfound();
	}
	return 0;
}


#if !defined(_WIN64) && !defined(SCSIPORT_COMPLIANT)
u32bits MLXFAR
mdac_scan_EISA()
{
	u32bits ioaddr=MDAC_EISA_BASE, slot;
	mdac_ctldev_t MLXFAR *ctp = &mdac_ctldevtbl[mda_Controllers];
	for (slot=0; slot<MDAC_MAXEISASLOTS; ioaddr+=0x1000,slot++)
	{
		ctp->cd_IOBaseAddr = ioaddr;
		ctp->cd_BusNo = 0; ctp->cd_SlotNo = slot;
		if (mdac_cardis_EISA(ctp)) continue;
		ctp->cd_InitAddr = mdac_init_addrs_EISA;
		mdac_newctlfound();
	}
	return 0;
}
#endif
#endif /* MLX_NT */

/* Assumption : We need to use either Config_Mechanism 1 or Config_Mechanism 2,
** but not both. If first adapter is found using Config_Mechanism 1 use only
** that, else use Config Mechanism 2 only.
*/
u32bits MLXFAR
mdac_scan_PCI()
{
	u32bits found;
	mda_pcislot_info_t mpci;
	mdac_ctldev_t MLXFAR *ctp = &mdac_ctldevtbl[mda_Controllers];

	/* Scan the PCI devices by mechanism 1 */
	mda_PCIMechanism = MDAC_PCI_MECHANISM1;
	for(mpci.mpci_BusNo=0,found=0; mpci.mpci_BusNo<MDAC_MAXBUS; mpci.mpci_BusNo++)
	 for (mpci.mpci_SlotNo=0; mpci.mpci_SlotNo<MDAC_MAXPCIDEVS; mpci.mpci_SlotNo++)
	{
		ctp->cd_BusNo = mpci.mpci_BusNo; ctp->cd_SlotNo = mpci.mpci_SlotNo;
		if (mdac_scan_PCI_oneslot(ctp,&mpci)) continue;
		ctp->cd_InitAddr = mdac_init_addrs_PCI;
		found++; mdac_newctlfound();
	}
	if (found || mdac_valid_mech1) return 0;

	/* Scan the PCI devices by mechanism 2 */
	mda_PCIMechanism = MDAC_PCI_MECHANISM2;
	for(mpci.mpci_BusNo=0; mpci.mpci_BusNo<MDAC_MAXBUS; mpci.mpci_BusNo++)
	 for (mpci.mpci_SlotNo=0; mpci.mpci_SlotNo<MDAC_MAXPCISLOTS; mpci.mpci_SlotNo++)
	{
		ctp->cd_BusNo = mpci.mpci_BusNo; ctp->cd_SlotNo = mpci.mpci_SlotNo;
		if (mdac_scan_PCI_oneslot(ctp,&mpci)) continue;
		ctp->cd_InitAddr = mdac_init_addrs_PCI;
		mdac_newctlfound();
	}
	return 0;
}

u32bits MLXFAR
mdac_scan_PCI_oneslot(ctp,mpcip)
mdac_ctldev_t MLXFAR *ctp;
mda_pcislot_info_t MLXFAR *mpcip;
{
	ctp->cd_FuncNo=0; mpcip->mpci_FuncNo=0; /* function 0 device check */
	if (mdac_pcislotinfo(mpcip, MDAC_RQOP_READ)) return MLXERR_NODEV;
	if (!mdac_cardis_PCI(ctp,(mdac_pcicfg_t MLXFAR*)mpcip->mpci_Info)) return 0;
	ctp->cd_FuncNo=1; mpcip->mpci_FuncNo=1; /* function 1 device check */
	if (mdac_pcislotinfo(mpcip, MDAC_RQOP_READ)) return MLXERR_NODEV;
	return mdac_cardis_PCI(ctp,(mdac_pcicfg_t MLXFAR*)mpcip->mpci_Info);
}

/*-------------------------------------------------------------*/
/* Check presence of controller */

#ifndef MLX_NT
#ifndef MLX_OS2 
u32bits MLXFAR
mdac_cardis_MCA(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u32bits id;
	u08bits_out_mdac(MDAC_DMC_REGSELPORT,8+ctp->cd_SlotNo);/* enable POS for slot*/
	ctp->cd_vidpid=mlxswap2bytes(u16bits_in_mdac(MDAC_DMC_DATAPORT));
	id = ctp->cd_vidpid & 0x8FFF;
	if ((id != 0x8FBB) && (id != 0x8F82) && (id != 0x8F6C))
	{
		u08bits_out_mdac(MDAC_DMC_REGSELPORT,0); /* disable POS */
		return ERR_NODEV;
	}
	ctp->cd_BusType = DAC_BUS_MCA;
	ctp->cd_IOBaseSize = MDAC_IOSPACESIZE;
	ctp->cd_MemBaseSize = 4*ONEKB;
	switch (u08bits_in_mdac(MDAC_DMC_CONFIG1) & MDAC_DMC_IRQ_MASK)
	{
	case 0x00:      ctp->cd_InterruptVector = 14; break;
	case 0x40:      ctp->cd_InterruptVector = 12; break;
	case 0x80:      ctp->cd_InterruptVector = 11; break;
	case 0xC0:      ctp->cd_InterruptVector = 10; break;
	}
	ctp->cd_MemBasePAddr = 0xC0000+(((u08bits_in_mdac(MDAC_DMC_CONFIG1) & MDAC_DMC_BIOS_MASK) >> 2) * 0x2000);
	ctp->cd_IOBaseAddr = 0x1C00 + (((u08bits_in_mdac(MDAC_DMC_CONFIG2) & MDAC_DMC_IO_MASK)>>3) * 0x2000);
	u08bits_out_mdac(MDAC_DMC_REGSELPORT, 0);       /* disable POS */
	return 0;
}

u32bits MLXFAR
mdac_cardis_EISA(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	ctp->cd_vidpid=u32bits_in_mdac(ctp->cd_IOBaseAddr); MLXSWAP(ctp->cd_vidpid);
	if ((ctp->cd_vidpid&MDAC_DEVPIDPE_MASK)!=MDAC_DEVPIDPE) return ERR_NODEV;
	switch (u08bits_in_mdac(ctp->cd_IOBaseAddr+MDAC_EISA_IRQ_BYTE) & MDAC_EISA_IRQ_MASK)
	{
	case 0x00: ctp->cd_InterruptVector = 15; break;
	case 0x20: ctp->cd_InterruptVector = 11; break;
	case 0x40: ctp->cd_InterruptVector = 12; break;
	case 0x60: ctp->cd_InterruptVector = 14; break;
	}
	ctp->cd_BusType = DAC_BUS_EISA;
	ctp->cd_IOBaseSize = MDAC_IOSPACESIZE;
	ctp->cd_MemBasePAddr = 0; ctp->cd_MemBaseVAddr = 0;
	ctp->cd_MemBaseSize = 0;
	return 0;
}

#else

/* Check presence of controller */
u32bits MLXFAR
mdac_cardis_MCA(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
		return ERR_NODEV;
}

/* Check presence of controller */
u32bits MLXFAR
mdac_cardis_EISA(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
		return ERR_NODEV;
}

#endif
#endif /* MLX_NT */

/* Read/Write PCI Slot information */
u32bits MLXFAR
mdac_pcislotinfo(mpcip, op)
mda_pcislot_info_t MLXFAR *mpcip;
u32bits op;
{
	u32bits inx;
	u32bits MLXFAR *dp = (u32bits MLXFAR*)mpcip->mpci_Info;
	if (mpcip->mpci_FuncNo >= MDAC_MAXPCIFUNCS) return MLXERR_INVAL;
	if ( ((mda_PCIMechanism == MDAC_PCI_MECHANISM1) &&
	    (mpcip->mpci_SlotNo >= MDAC_MAXPCIDEVS)) ||
	   ((mda_PCIMechanism == MDAC_PCI_MECHANISM2) &&
	    (mpcip->mpci_SlotNo >= MDAC_MAXPCISLOTS)) )
		return MLXERR_INVAL;
	if (((inx=mlx_rwpcicfg32bits(mpcip->mpci_BusNo,mpcip->mpci_SlotNo,mpcip->mpci_FuncNo,0,MDAC_RQOP_READ,0)) == 0xFFFFFFFF) ||
	    (inx == 0)) return MLXERR_NODEV;
	for (inx=0; inx<64; dp++, inx+=4)
		*dp = mlx_rwpcicfg32bits(mpcip->mpci_BusNo,mpcip->mpci_SlotNo,mpcip->mpci_FuncNo,inx,op,*dp);
	mdac_valid_mech1 = 1;
	return 0;
}

/* Read/Write 32bits PCI configuration */
u32bits MLXFAR
mdac_rwpcicfg32bits(bus,slot,func,pcireg,op,val)
u32bits bus,slot,func,pcireg,op,val;
{
	if (mda_PCIMechanism != MDAC_PCI_MECHANISM1) goto try2;
	pcireg += (((bus*MDAC_MAXPCIDEVS)+slot)*MDAC_PCICFGSIZE_M1)+ MDAC_PCICFG_ENABLE_M1 + (func<<8);

#ifdef _WIN64
	u32bits_out_mdac(MDAC_PCICFG_CNTL_REG,(ULONG_PTR) pcireg);
	if (op == MDAC_RQOP_WRITE)
		u32bits_out_mdac(MDAC_PCICFG_DATA_REG,(ULONG_PTR)val);
#else
	u32bits_out_mdac(MDAC_PCICFG_CNTL_REG, pcireg);
	if (op == MDAC_RQOP_WRITE)
		u32bits_out_mdac(MDAC_PCICFG_DATA_REG, val);

#endif
	else
		val = u32bits_in_mdac(MDAC_PCICFG_DATA_REG);
	return val;

try2:   if (mda_PCIMechanism != MDAC_PCI_MECHANISM2) return -1;
	u08bits_out_mdac(MDAC_PCICFG_ENABLE_REG, MDAC_PCICFG_ENABLE|(func<<1));
	u08bits_out_mdac(MDAC_PCICFG_FORWARD_REG, MDAC_CFGMECHANISM2_TYPE0);
	u08bits_out_mdac(MDAC_PCICFG_FORWARD_REG, bus);
	pcireg += (((bus*MDAC_MAXPCISLOTS)+slot)*MDAC_PCICFGSIZE_M2) + MDAC_PCISCANSTART;
	if (op == MDAC_RQOP_WRITE)
		u32bits_out_mdac((ULONG_PTR)pcireg,val);
	else
		val = u32bits_in_mdac((ULONG_PTR)pcireg);
	mdac_disable_cfg_m2();
	return val;
}

u32bits MLXFAR
mdac_cardis_PCI(ctp,cfgp)
mdac_ctldev_t   MLXFAR *ctp;
mdac_pcicfg_t   MLXFAR *cfgp;
{
	switch(mlxswap(cfgp->pcfg_DevVid))
	{

#ifdef WINXX
#ifdef LEGACY_API
	case MDAC_DEVPIDPV:
		if (mlxswap(cfgp->pcfg_SubSysVid) != MDAC_SUBDEVPIDPV) return(ERR_NODEV);
	case MDAC_DEVPIDFWV2x:
	case MDAC_DEVPIDFWV3x:
	case MDAC_DEVPIDPG:
			break;
#elif NEW_API
	case MDAC_DEVPIDBA:
	case MDAC_DEVPIDLP:
			break;
	#else
		return ERR_NODEV;
	#endif
#else /* non-Windows OS */
	case MDAC_DEVPIDPV:
		if (mlxswap(cfgp->pcfg_SubSysVid) != MDAC_SUBDEVPIDPV) return(ERR_NODEV);
	case MDAC_DEVPIDFWV2x:
	case MDAC_DEVPIDFWV3x:
	case MDAC_DEVPIDPG:
	case MDAC_DEVPIDBA:
	case MDAC_DEVPIDLP:
			break;
#endif
	default: return ERR_NODEV;
	}
	ctp->cd_BusType = DAC_BUS_PCI;
	ctp->cd_MemIOSpaceNo = 0; /* first set of address being used */
	ctp->cd_Status=0; ctp->cd_IOBaseAddr = 0; ctp->cd_IOBaseSize = 0;
	ctp->cd_MemBasePAddr=0; ctp->cd_MemBaseVAddr=0; ctp->cd_MemBaseSize=0;
	ctp->cd_InterruptVector = mlxswap(cfgp->pcfg_BCIPIL) & MDAC_PCIIRQ_MASK;
	if ((ctp->cd_vidpid=mlxswap(cfgp->pcfg_DevVid)) == MDAC_DEVPIDPG)
	{
		ctp->cd_MemBaseSize = 8*ONEKB;
		ctp->cd_MemBasePAddr = mlxswap(cfgp->pcfg_MemIOAddr) & MDAC_PCIPGMEMBASE_MASK;
	}
	else if (ctp->cd_vidpid == MDAC_DEVPIDPV)
	{
		ctp->cd_MemBaseSize = MDAC_HWIOSPACESIZE;
		ctp->cd_MemBasePAddr = mlxswap(cfgp->pcfg_MemIOAddr)&MDAC_PCIPDMEMBASE_MASK;
	}
	else if ((ctp->cd_vidpid == MDAC_DEVPIDBA) || (ctp->cd_vidpid == MDAC_DEVPIDLP))

	{
		ctp->cd_Status |= MDACD_NEWCMDINTERFACE;
		ctp->cd_MemBaseSize = 4*ONEKB;
		ctp->cd_MemBasePAddr = mlxswap(cfgp->pcfg_MemIOAddr)&MDAC_PCIPDMEMBASE_MASK;
	}
	else if ((mlxswap(cfgp->pcfg_CCRevID) & 0xFF) == 2) /* PCU 3 */
	{
		ctp->cd_MemIOSpaceNo = 1; /* second set of address being used */
		ctp->cd_MemBaseSize = MDAC_HWIOSPACESIZE;
		ctp->cd_MemBasePAddr = mlxswap(cfgp->pcfg_MemAddr)&MDAC_PCIPDMEMBASE_MASK;
	}
	else
	{
		ctp->cd_IOBaseSize = MDAC_HWIOSPACESIZE;
		ctp->cd_IOBaseAddr = mlxswap(cfgp->pcfg_MemIOAddr)&MDAC_PCIIOBASE_MASK;
	}
	return 0;
}

/*==========================SCAN CONTROLLERS ENDS=============================*/

/* map the controller memory/IO space */
UINT_PTR
mdac_memmapctliospace(ctp)
mdac_ctldev_t   MLXFAR *ctp;
{
#ifdef MLX_NW
	u32bits off = ctp->cd_MemBaseVAddr & MDAC_PAGEOFFSET;
	u32bits addr = ctp->cd_MemBaseVAddr & MDAC_PAGEMASK;
	return (addr)? addr + off : (u32bits)NULL;
#else
	UINT_PTR off = ctp->cd_BaseAddr & MDAC_PAGEOFFSET;
	UINT_PTR addr = mlx_memmapiospace(ctp->cd_BaseAddr & MDAC_PAGEMASK,mlx_max(MDAC_PAGESIZE,ctp->cd_BaseSize));
	return (addr)? addr + off : (UINT_PTR) NULL;
#endif
}

/* Initialize the physical addresses of controllers */
#ifndef MLX_OS2
u32bits MLXFAR
mdac_init_addrs_MCA(ctp)
mdac_ctldev_t   MLXFAR *ctp;
{
	ctp->cd_BaseAddr = ctp->cd_MemBasePAddr;
	ctp->cd_BaseSize = ctp->cd_MemBaseSize;
	ctp->cd_irq = ctp->cd_InterruptVector;
#ifndef MLX_NW
/* Not required for Netware, since the Virtual Address is got while */
/* Registering the options - Refer mdacnw_Check_Options */
	if (!ctp->cd_MemBaseVAddr)
		if (!(ctp->cd_MemBaseVAddr=mlx_memmapiospace(ctp->cd_MemBasePAddr,ctp->cd_MemBaseSize))) return ERR_NOMEM;
#endif
	ctp->cd_MailBox = ctp->cd_MemBaseVAddr + MDAC_DMC_REG_OFF;
	ctp->cd_CmdIDStatusReg = ctp->cd_MailBox+MDAC_CMDID_STATUS_REG;
	ctp->cd_DacIntrMaskReg = ctp->cd_IOBaseAddr+MDAC_DACMC_INTR_MASK_REG;
	mdac_setctlfuncs((mdac_ctldev_t   MLXFAR *)ctp,
		 mdac_disable_intr_MCA,mdac_enable_intr_MCA,
		 mdac_cmdid_status_MCA,mdac_check_mbox_MCA,
		 mdac_pending_intr_MCA,mdac_send_cmd_MCA,
		 mdac_reset_MCA);
	return 0;
}

u32bits MLXFAR
mdac_init_addrs_EISA(ctp)
mdac_ctldev_t   MLXFAR *ctp;
{
	ctp->cd_BaseAddr = ctp->cd_IOBaseAddr;
	ctp->cd_BaseSize = ctp->cd_IOBaseSize;
	ctp->cd_BmicIntrMaskReg = ctp->cd_IOBaseAddr+MDAC_BMIC_MASK_REG;
	mdac_setctladdrs(ctp, ctp->cd_IOBaseAddr,
		MDAC_MAIL_BOX_REG_EISA, MDAC_CMDID_STATUS_REG, MDAC_DACPE_INTR_MASK_REG,
		MDAC_DACPE_LOCAL_DOOR_BELL_REG, MDAC_DACPE_SYSTEM_DOOR_BELL_REG,
		MDAC_DACPD_ERROR_STATUS_REG);
	ctp->cd_Status = (u08bits_in_mdac(ctp->cd_IOBaseAddr+MDAC_EISA_BIOS_BYTE) & MDAC_EISA_BIOS_ENABLED)? MDACD_BIOS_ENABLED : 0;
#ifndef MLX_NW
/* May not be required for Netware. For PCI based cards this is not done. */
/* So we may not be required to do this for this card also. */
	if (ctp->cd_Status & MDACD_BIOS_ENABLED)
	{       /* BIOS is enabled, check if this is boot device too */
		u08bits MLXFAR *dp;
		ctp->cd_BIOSAddr= 0x00C00000 + ((u08bits_in_mdac(ctp->cd_IOBaseAddr+MDAC_EISA_BIOS_BYTE)&MDAC_EISA_BIOS_ADDR_MASK)*0x4000);
		if (dp=(u08bits MLXFAR*)mlx_memmapiospace(ctp->cd_BIOSAddr+0x3000,MDAC_PAGESIZE))
		{       /* looking for BIOSBASE + 0x3800 + 0x20 address */
			if (!(*(dp+0x800+0x20))) ctp->cd_Status|=MDACD_BOOT_CONTROLLER;
			mlx_memunmapiospace(dp,MDAC_PAGESIZE);
		}
	}
#endif
	ctp->cd_irq = ctp->cd_InterruptVector;
	mdac_setctlfuncs((mdac_ctldev_t   MLXFAR *)ctp,
		 mdac_disable_intr_EISA,  mdac_enable_intr_EISA,
		 mdac_cmdid_status_EISA_PCIPD,  mdac_check_mbox_EISA_PCIPD,
		 mdac_pending_intr_EISA_PCIPD,  mdac_send_cmd_EISA_PCIPD,
		 mdac_reset_EISA_PCIPD);
	return 0;
}

#else
u32bits MLXFAR
mdac_init_addrs_MCA(ctp)
mdac_ctldev_t   MLXFAR *ctp;
{
    return 0;
}

u32bits MLXFAR
mdac_init_addrs_EISA(ctp)
mdac_ctldev_t   MLXFAR *ctp;
{
    return 0;
}

#endif

/* initialize different address spaces */
u32bits MLXFAR
mdac_init_addrs_PCI(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	ctp->cd_irq = ctp->cd_InterruptVector;
	ctp->cd_BaseAddr = ctp->cd_MemBasePAddr;
	if (ctp->cd_BaseSize = ctp->cd_MemBaseSize)
		if (!ctp->cd_MemBaseVAddr)
			if (!(ctp->cd_MemBaseVAddr=mlx_memmapctliospace(ctp))) return ERR_NOMEM;
	if (ctp->cd_vidpid == MDAC_DEVPIDPG)
	{       /* memory mapped io */
		mdac_setctladdrs(ctp, ctp->cd_MemBaseVAddr,
			MDAC_DACPG_MAIL_BOX, MDAC_DACPG_CMDID_STATUS_REG,
			MDAC_DACPG_INTR_MASK_REG,
			MDAC_DACPG_LOCAL_DOOR_BELL_REG,
			MDAC_DACPG_SYSTEM_DOOR_BELL_REG,
			MDAC_DACPG_ERROR_STATUS_REG);
		mdac_setctlfuncs((mdac_ctldev_t   MLXFAR *)ctp,
			 mdac_disable_intr_PCIPG,  mdac_enable_intr_PCIPG,
			 mdac_cmdid_status_PCIPG,  mdac_check_mbox_PCIPG,
			 mdac_pending_intr_PCIPG,  mdac_send_cmd_PCIPG,
			 mdac_reset_PCIPG);
		return 0;
	}
	if (ctp->cd_vidpid == MDAC_DEVPIDPV)
	{       /* memory mapped io for Little Apple*/
		mdac_setctladdrs(ctp, ctp->cd_MemBaseVAddr,
			MDAC_DACPV_MAIL_BOX, MDAC_DACPV_CMDID_STATUS_REG,
			MDAC_DACPV_INTR_MASK_REG,
			MDAC_DACPV_LOCAL_DOOR_BELL_REG,
			MDAC_DACPV_SYSTEM_DOOR_BELL_REG,
			MDAC_DACPV_ERROR_STATUS_REG);
		mdac_setctlfuncs((mdac_ctldev_t   MLXFAR *)ctp,
			 mdac_disable_intr_PCIPV,  mdac_enable_intr_PCIPV,
			 mdac_cmdid_status_PCIPV,  mdac_check_mbox_PCIPV,
			 mdac_pending_intr_PCIPV,  mdac_send_cmd_PCIPV,
			 mdac_reset_PCIPV);
		return 0;
	}
	if (ctp->cd_vidpid == MDAC_DEVPIDBA)
	{       /* memory mapped io for Big Apple */
		mdac_setctladdrs(ctp, ctp->cd_MemBaseVAddr,
			MDAC_DACBA_MAIL_BOX, MDAC_DACBA_CMDID_STATUS_REG,
			MDAC_DACBA_INTR_MASK_REG,
			MDAC_DACBA_LOCAL_DOOR_BELL_REG,
			MDAC_DACBA_SYSTEM_DOOR_BELL_REG,
			MDAC_DACBA_ERROR_STATUS_REG);
		mdac_setctlfuncs((mdac_ctldev_t   MLXFAR *)ctp,
			 mdac_disable_intr_PCIBA,  mdac_enable_intr_PCIBA,
			 mdac_cmdid_status_PCIBA,  mdac_check_mbox_PCIBA,
			 mdac_pending_intr_PCIBA,  mdac_send_cmd_PCIBA,
			 mdac_reset_PCIBA);
		return 0;
	}
		if (ctp->cd_vidpid == MDAC_DEVPIDLP)
	{       /* memory mapped io for Leopard */
		mdac_setctladdrs(ctp, ctp->cd_MemBaseVAddr,
			MDAC_DACLP_MAIL_BOX, MDAC_DACLP_CMDID_STATUS_REG,
			MDAC_DACLP_INTR_MASK_REG,
			MDAC_DACLP_LOCAL_DOOR_BELL_REG,
			MDAC_DACLP_SYSTEM_DOOR_BELL_REG,
			MDAC_DACLP_ERROR_STATUS_REG);
		mdac_setctlfuncs((mdac_ctldev_t   MLXFAR *)ctp,
			mdac_disable_intr_PCILP, mdac_enable_intr_PCILP,
			mdac_cmdid_status_PCILP, mdac_check_mbox_PCILP,
			mdac_pending_intr_PCILP, mdac_send_cmd_PCILP,
			mdac_reset_PCILP);
		return 0;
	}
	if (ctp->cd_MemBasePAddr)
	{       /* memory mapped io for PCU 3 */
		mdac_setctladdrs(ctp, ctp->cd_MemBaseVAddr,
			MDAC_MAIL_BOX_REG_PCI, MDAC_CMDID_STATUS_REG,
			MDAC_DACPD_INTR_MASK_REG,
			MDAC_DACPD_LOCAL_DOOR_BELL_REG,
			MDAC_DACPD_SYSTEM_DOOR_BELL_REG,
			MDAC_DACPD_ERROR_STATUS_REG);
		mdac_setctlfuncs((mdac_ctldev_t   MLXFAR *)ctp,
			mdac_disable_intr_PCIPDMEM, mdac_enable_intr_PCIPDMEM,
			mdac_cmdid_status_PCIPDMEM, mdac_check_mbox_PCIPDMEM,
			mdac_pending_intr_PCIPDMEM, mdac_send_cmd_PCIPDMEM,
			mdac_reset_PCIPDMEM);
		return 0;
	}
#ifndef MLX_OS2
	ctp->cd_BaseAddr = ctp->cd_IOBaseAddr;
	ctp->cd_BaseSize = ctp->cd_IOBaseSize;
	mdac_setctladdrs(ctp, ctp->cd_IOBaseAddr,
		MDAC_MAIL_BOX_REG_PCI, MDAC_CMDID_STATUS_REG,
		MDAC_DACPD_INTR_MASK_REG,
		MDAC_DACPD_LOCAL_DOOR_BELL_REG,
		MDAC_DACPD_SYSTEM_DOOR_BELL_REG,
		MDAC_DACPD_ERROR_STATUS_REG);
	mdac_setctlfuncs((mdac_ctldev_t   MLXFAR *)ctp,
		mdac_disable_intr_PCIPDIO, mdac_enable_intr_PCIPDIO,
		mdac_cmdid_status_EISA_PCIPD, mdac_check_mbox_EISA_PCIPD,
		mdac_pending_intr_EISA_PCIPD, mdac_send_cmd_EISA_PCIPD,
		mdac_reset_EISA_PCIPD);
	return 0;
#endif
}

/* check if controller has shared interrupts, return # controllers sharing.
** This function should be used where same irq can be running on different
** cpu at same time.
*/
u32bits MLXFAR
mdac_isintr_shared(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	mdac_ctldev_t MLXFAR *tctp=mdac_ctldevtbl;
	for (ctp->cd_IntrShared=0; tctp<mdac_lastctp; tctp++)
		if ((ctp->cd_irq == tctp->cd_irq) && (ctp!=tctp))
			ctp->cd_IntrShared++;
	if (ctp->cd_IntrShared) ctp->cd_IntrShared++;
	return ctp->cd_IntrShared;
}

/*------------------------------------------------------------------*/
/* wait for Mail box to become ready */
u32bits MLXFAR
mdac_wait_mbox_ready(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u32bits inx;
	if (!(*ctp->cd_CheckMailBox)(ctp)) return 0;
	for (inx=MDAC_MAILBOX_POLL_TIMEOUT; inx; mlx_delay10us(), inx--)
		if (!(*ctp->cd_CheckMailBox)(ctp)) return 0;
	MLXSTATS(ctp->cd_MailBoxTimeOutDone++;)
	return 0xFFFFFFFE;
}

/* wait for command to complete and return command status */
u32bits MLXFAR
mdac_wait_cmd_done(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u32bits inx;
	if ((*ctp->cd_PendingIntr)(ctp)) return (*ctp->cd_ReadCmdIDStatus)(ctp);
	for (inx=MDAC_CMD_POLL_TIMEOUT; inx; mlx_delay10us(),inx--)
		if ((*ctp->cd_PendingIntr)(ctp))
			return (*ctp->cd_ReadCmdIDStatus)(ctp);
	MLXSTATS(ctp->cd_MailBoxTimeOutDone++;)
	return 0xFFFFFFFF;
}

/* Initialize the controller and information */
u32bits MLXFAR
mdac_ctlinit(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u32bits inx,ch,tgt,lun;
	dac_biosinfo_t MLXFAR *biosp;


#ifdef MLX_NT
	#ifdef MLX_FIXEDPOOL
		/* moved so ScsiPort-provided mem pool used by mdac_allocmem would be set up */
	   if (mdac_flushdatap == (u08bits *)&mdac_flushdata)
		#if (!defined(_WIN64)) && (!defined(SCSIPORT_COMPLIANT)) 
// this guys calls MMMapIoSpace (no can do)-looks like mdac_flushdatap is never used anyway
		       mdac_flushdatap =  (u08bits MLXFAR*)mlx_memmapiospace2(mlx_kvtophys3(ctp,
						(VOID MLXFAR *)mdac_allocmem(mdac_ctldevtbl,4*ONEKB)),4*ONEKB);  
		#endif
	#endif
#endif
	if (!ctp->cd_CmdIDMemAddr)
	{       /* allocate the command IDs */
#ifdef MLX_DOS
	#define nsz  (32 * mdac_cmdid_s)
#else
	#define nsz  (512 * mdac_cmdid_s)
#endif
/*****mdac_cmdid_t MLXFAR *cidp=(mdac_cmdid_t MLXFAR*)mdac_alloc4kb(ctp);***/
		mdac_cmdid_t MLXFAR *cidp=(mdac_cmdid_t MLXFAR*)mdac_allocmem(ctp,nsz);
		if (!(ctp->cd_CmdIDMemAddr=(u08bits MLXFAR*)cidp)) return ERR_NOMEM;
		ctp->cd_FreeCmdIDs=(nsz)/mdac_cmdid_s;
		ctp->cd_FreeCmdIDList=cidp;
		for (inx=0,cidp->cid_cmdid=inx+1; inx<(((nsz)/mdac_cmdid_s)-1); cidp++,inx++,cidp->cid_cmdid=inx+1)
			cidp->cid_Next = cidp+1;
#undef nsz
	}
	if (!ctp->cd_PhysDevTbl)
	{       /* allocate the physical device table */
#define sz      MDAC_MAXPHYSDEVS*mdac_physdev_s
		mdac_physdev_t MLXFAR *pdp=(mdac_physdev_t MLXFAR*)mdac_allocmem(ctp,sz);
		if (!(ctp->cd_PhysDevTbl=pdp)) return ERR_NOMEM;
		MLXSTATS(mda_MemAlloced+=sz;)
		ctp->cd_PhysDevTblMemSize = sz;
		for (ch=0; ch<MDAC_MAXCHANNELS; ch++)
		 for (tgt=0; tgt<MDAC_MAXTARGETS; tgt++)
		  for (lun=0; lun<MDAC_MAXLUNS; pdp++, lun++)
		{
			pdp->pd_ControllerNo = ctp->cd_ControllerNo;
			pdp->pd_ChannelNo = (u08bits) ch;
			pdp->pd_TargetID = (u08bits) tgt;
			pdp->pd_LunID = (u08bits) lun;
			pdp->pd_BlkSize = 1;
		}
		ctp->cd_Lastpdp = pdp;
#undef  sz
	}

	if (biosp=mdac_getpcibiosaddr(ctp))
	{       /* we got the BIOS information address */
		ctp->cd_MajorBIOSVersion = biosp->bios_MajorVersion;
		ctp->cd_MinorBIOSVersion = biosp->bios_MinorVersion;
		ctp->cd_InterimBIOSVersion = biosp->bios_InterimVersion;
		ctp->cd_BIOSVendorName = biosp->bios_VendorName;
		ctp->cd_BIOSBuildMonth = biosp->bios_BuildMonth;
		ctp->cd_BIOSBuildDate = biosp->bios_BuildDate;
		ctp->cd_BIOSBuildYearMS = biosp->bios_BuildYearMS;
		ctp->cd_BIOSBuildYearLS = biosp->bios_BuildYearLS;
		ctp->cd_BIOSBuildNo = biosp->bios_BuildNo;
		ctp->cd_BIOSAddr = biosp->bios_MemAddr;
		ctp->cd_BIOSSize = biosp->bios_RunTimeSize * 512;
	}
	if (inx=mdac_ctlhwinit(ctp))
	{
#ifdef MLX_NT
	DebugPrint((0, "mdac_ctlhwinit ret 0x%x\n", inx));
#endif
	     return inx;        /* set HW parameters */
	}
	if (!ctp->cd_ReqBufsAlloced)
	{
#ifdef  MLX_DOS
	    mdac_allocreqbufs(ctp, 1);
#elif  MLX_NT
	    mdac_allocreqbufs(ctp, 10);
#else
	    mdac_allocreqbufs(ctp, ctp->cd_MaxCmds*2);          /* two sets of bufs */
#endif  /* MLX_DOS */
	}

	mdac_setnewsglimit(ctp->cd_FreeReqList, ctp->cd_MaxSGLen);

	ctp->cd_Status |= MDACD_PRESENT;
	return 0;
}


#define mdac_ck64mb(x,y)        (((x) & 0xFC000000) != ((y) & 0xFC000000))
/* initialize the controller hardware information */
u32bits MLXFAR
mdac_ctlhwinit(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u32bits inx;
#define dp      ((u08bits MLXFAR *) (rqp+1))

#ifndef WINNT_50
	u64bits                 rtcvalue;
#else
#define rtcvalue  ((u64bits MLXFAR *) (rqp+1))
#endif

	mdac_req_t      MLXFAR *rqp;
	dac_inquiryrest_t MLXFAR *iq;
	u32bits status;
    u08bits irql;

	DebugPrint((0, "mdac_ctlhwinit: try to alloc4kb. ctp 0x%I\n", ctp));
	if (!(rqp=(mdac_req_t MLXFAR *)mdac_alloc4kb(ctp))) return ERR_NOMEM;
	DebugPrint((0, "mdac_ctlhwinit: allocated 4kb\n"));
	mlx_kvtophyset(rqp->rq_PhysAddr,ctp,rqp);
	rqp->rq_ctp = ctp;
    mdac_prelock(&irql);
	mdac_ctlr_lock(ctp);
	if (mdac_start_controller(ctp)== 0xffffffff)
		goto out_err3;
/* do it twice to absolutely insure fw/driver synchronization */
	if (mdac_start_controller(ctp)== 0xffffffff)
		goto out_err3;
	mdac_get_cmdid(ctp,rqp);
	(*ctp->cd_DisableIntr)(ctp); /* Disable interrupts */
	if (mdac_flushintr(ctp)== 0xffffffff)
		goto out_err2;
	for(inx=0; inx<MDAC_MAXCHANNELS; inx++) /* init default host id */
		if (!ctp->cd_HostID[inx]) ctp->cd_HostID[inx] = 7;
	DebugPrint((0, "mdac_ctlhwinit: check for mbox ready 1\n"));
	if (mdac_wait_mbox_ready(ctp)) goto out_err;
	DebugPrint((0, "mdac_ctlhwinit: mbox ready 1\n"));
	DebugPrint((0, "mdac_ctlhwinit: check for newcmd interface\n"));
	if (ctp->cd_Status & MDACD_NEWCMDINTERFACE) goto donewi;
	DebugPrint((0, "mdac_ctlhwinit: old interface\n"));
	mdac_setcmd_v2x(ctp);
	dcmdp->mb_Command = ctp->cd_InquiryCmd;
	dcmdp->mb_Datap = mlx_kvtophys(ctp,dp); MLXSWAP(dcmdp->mb_Datap);
	(*ctp->cd_SendCmd)(rqp);
	if (mdac_status(mdac_wait_cmd_done(ctp)))
	{       /* Firmware 3.x */
		mdac_setcmd_v3x(ctp);
		dcmdp->mb_Command = ctp->cd_InquiryCmd;
		DebugPrint((0, "3.x issue Inquiry cmd\n"));
		if (mdac_wait_mbox_ready(ctp)) goto out_err;
		(*ctp->cd_SendCmd)(rqp);
		DebugPrint((0, "3.x check status\n"));
		if (mdac_status(mdac_wait_cmd_done(ctp))) goto out_err;
	}
	iq = (dcmdp->mb_Command == DACMD_INQUIRY_V2x)?
	    &((dac_inquiry2x_t MLXFAR*)dp)->iq_rest2x:
	    &((dac_inquiry3x_t MLXFAR*)dp)->iq_rest3x;
	ctp->cd_FWVersion = (iq->iq_MajorFirmwareVersion<<8) + iq->iq_MinorFirmwareVersion;
	if ((ctp->cd_MaxCmds=iq->iq_MaxCommands - 2) > MDAC_MAXCOMMANDS)
		ctp->cd_MaxCmds = MDAC_MAXCOMMANDS;
	dcmdp->mb_Command = DACMD_INQUIRY2;
		DebugPrint((0, "2.x issue Inquiry cmd\n"));
	if (mdac_wait_mbox_ready(ctp)) goto out_err;
	(*ctp->cd_SendCmd)(rqp);
	ctp->cd_MaxSysDevs = 8; ctp->cd_InterruptType = DAC_LEVELMODEINTERRUPT;
	ctp->cd_MaxTargets = 8; ctp->cd_MaxChannels = 2;
	ctp->cd_PhysChannels = ctp->cd_MaxChannels;
	ctp->cd_MaxTags = 2; ctp->cd_MaxDataTxSize = 0x10000;   /* 64KB */
	ctp->cd_MaxSGLen = 17; ctp->cd_MinSGLen = 17;
	if (mdac_status(mdac_wait_cmd_done(ctp))) goto out_def;
#define ip      ((dac_inquiry2_t MLXFAR *)dp)
	ctp->cd_FWBuildNo = mlxswap(ip->iq2_FirmwareBuildNo);
	ctp->cd_FWTurnNo = ip->iq2_FWTurnNo;
	ctp->cd_MaxSysDevs = ip->iq2_MaxSystemDrives;
	ctp->cd_InterruptType=ip->iq2_InterruptLevelFlag&DAC_INTERRUPTLEVELMASK;
	ctp->cd_MaxTags = ip->iq2_MaxTags;
	ctp->cd_MaxTargets = ip->iq2_MaxTargets;
	if (ctp->cd_MaxTargets & 1) ctp->cd_MaxTargets++; /* max is 8 not 7 */
	ctp->cd_MaxChannels = ip->iq2_MaxChannels;
	ctp->cd_PhysChannels = ctp->cd_MaxChannels;
	ctp->cd_MaxSGLen = mlx_min(ip->iq2_MaxSGEntries, MDAC_MAXSGLISTSIZEIND);
	ctp->cd_MinSGLen = mlx_min(ip->iq2_MaxSGEntries, MDAC_MAXSGLISTSIZE);
	if (!ctp->cd_MaxSGLen) ctp->cd_MaxSGLen = ctp->cd_MinSGLen = 17;
#ifdef MLX_SOL_SPARC
out_def:
	ctp->cd_MaxDataTxSize = 0x100000;
	ctp->cd_MaxSCDBTxSize = 0x100000;
#else
	ctp->cd_MaxDataTxSize = (ctp->cd_MaxSGLen & ~1) * MDAC_PAGESIZE;
out_def:
	if ((ctp->cd_MaxSCDBTxSize=ctp->cd_MaxDataTxSize) == (64*ONEKB))
		ctp->cd_MaxSCDBTxSize = ctp->cd_MaxDataTxSize-(4*ONEKB); /* 60K */

	ctp->cd_MaxSGLen = mlx_min(ctp->cd_MaxSGLen, (ctp->cd_MaxSCDBTxSize/MDAC_PAGESIZE));
#endif

#if defined(MLX_NT) || defined(MLX_DOS)
	if (ip->iq2_FirmwareFeatures & DAC_FF_CLUSTERING_ENABLED)
	{
	    ctp->cd_Status|=MDACD_CLUSTER_NODE;
	    ctp->cd_ReadCmd = DACMD_READ_WITH_DPO_FUA;
	    ctp->cd_WriteCmd = DACMD_WRITE_WITH_DPO_FUA;
	}
#endif
	ctp->cd_MaxLuns = 1;
	if (ctp->cd_BusType == DAC_BUS_EISA)
		ctp->cd_ControllerType = DACTYPE_DAC960E;
	else if (ctp->cd_BusType == DAC_BUS_MCA)
		ctp->cd_ControllerType = DACTYPE_DAC960M;
	else if (ctp->cd_BusType == DAC_BUS_PCI)
	{
		MLXSWAP(ip->iq2_HardwareID);
		ctp->cd_InterruptType = DAC_LEVELMODEINTERRUPT;
		if (ctp->cd_vidpid == MDAC_DEVPIDPG) ctp->cd_ControllerType = DACTYPE_DAC960PG;
		switch(ip->iq2_HardwareID & 0xFF)
		{
		case 0x01:
			ctp->cd_ControllerType = (ip->iq2_SCSICapability&DAC_SCSICAP_SPEED_20MHZ)?
				DACTYPE_DAC960PDU : DACTYPE_DAC960PD;
			break;
		case 0x02: ctp->cd_ControllerType = DACTYPE_DAC960PL;   break;
		case 0x10: ctp->cd_ControllerType = DACTYPE_DAC960PG;   break;
		case 0x11: ctp->cd_ControllerType = DACTYPE_DAC960PJ;   break;
		case 0x12: ctp->cd_ControllerType = DACTYPE_DAC960PR;   break;
		case 0x13: ctp->cd_ControllerType = DACTYPE_DAC960PT;   break;
		case 0x14: ctp->cd_ControllerType = DACTYPE_DAC960PTL0; break;
		case 0x15: ctp->cd_ControllerType = DACTYPE_DAC960PRL;  break;
		case 0x16: ctp->cd_ControllerType = DACTYPE_DAC960PTL1; break;
		case 0x20: ctp->cd_ControllerType = DACTYPE_DAC1164P;   break;
		}
	}
#undef  ip
	ctp->cd_BIOSHeads = 128; ctp->cd_BIOSTrackSize = 32;    /* 2GB BIOS */
	mdaccopy(mdac_ctltype2str(ctp->cd_ControllerType),ctp->cd_ControllerName,USCSI_PIDSIZE);
	for (inx=USCSI_PIDSIZE; inx; inx--)
		if (ctp->cd_ControllerName[inx-1] != ' ') break;
		else ctp->cd_ControllerName[inx-1] = 0; /* remove the trailing blanks */
	if (ctp->cd_FWVersion >= DAC_FW300)
	{
		dcmdp->mb_Command = DACMD_READ_CONF2;
		if (mdac_wait_mbox_ready(ctp)) goto out_err;
		(*ctp->cd_SendCmd)(rqp);
		if (mdac_status(mdac_wait_cmd_done(ctp))) goto out_err;
#define cfp     ((dac_config2_t MLXFAR *)dp)
		if (!(cfp->cf2_BIOSCfg & DACF2_BIOS_DISABLED)) ctp->cd_Status|=MDACD_BIOS_ENABLED;
		if ((cfp->cf2_BIOSCfg & DACF2_BIOS_MASK) == DACF2_BIOS_8GB)
			ctp->cd_BIOSHeads = 255, ctp->cd_BIOSTrackSize = 63;
#undef  cfp
	}
	if (ctp->cd_FWVersion >= DAC_FW400)
	{
		if (mdac_advancefeaturedisable) goto mmb_stuff;
		if (!ctp->cd_HostCmdQue)
		    if (!(ctp->cd_HostCmdQue = (u08bits MLXFAR*)mdac_alloc8kb(ctp))) goto host_stuff;
		ctp->cd_HostStatusQue = ctp->cd_HostCmdQue + 4*ONEKB;
		ctp->cd_HostCmdQueIndex = 0;
		ctp->cd_HostStatusQueIndex = 0;
		dcmd4p->mb_MailBox4_7 = mlx_kvtophys(ctp,ctp->cd_HostCmdQue);
		dcmd4p->mb_MailBox8_B = mlx_kvtophys(ctp,ctp->cd_HostStatusQue);
		if (mdac_ck64mb(dcmd4p->mb_MailBox4_7,dcmd4p->mb_MailBox8_B)) goto host_stuff;
		MLXSWAP(dcmd4p->mb_MailBox4_7); MLXSWAP(dcmd4p->mb_MailBox8_B);
		dcmdp->mb_Command = DACMD_IOCTL;

		/* Try to set controller firmware mode 32 byte memory mailbox mode */
		dcmdp->mb_MailBox2 = DACMDIOCTL_HOSTMEMBOX32;
		if (mdac_wait_mbox_ready(ctp)) goto host_stuff;
		(*ctp->cd_SendCmd)(rqp);
		if (mdac_status(mdac_wait_cmd_done(ctp))) goto trydualmailbox;
		MLXSWAP(dcmd4p->mb_MailBox4_7); MLXSWAP(dcmd4p->mb_MailBox8_B);
		ctp->cd_SendCmd = mdac_send_cmd_mmb32;
		ctp->cd_Status |= MDACD_HOSTMEMAILBOX32;
		goto memboxmode;

trydualmailbox: /* Try to set controller firmware mode to dual mailbox mode */
		dcmdp->mb_MailBox2 = DACMDIOCTL_HOSTMEMBOX_DUAL_MODE;
		if (mdac_wait_mbox_ready(ctp)) goto host_stuff;
		(*ctp->cd_SendCmd)(rqp);
		if (mdac_status(mdac_wait_cmd_done(ctp))) goto trymembox;
		MLXSWAP(dcmd4p->mb_MailBox4_7); MLXSWAP(dcmd4p->mb_MailBox8_B);
		ctp->cd_SendCmd = mdac_send_cmd_mmb_mode;
		goto memboxmode;

trymembox:      /* Try to set the controller firmware more to simple memory mailbox mode */
		dcmdp->mb_MailBox2 = DACMDIOCTL_HOSTMEMBOX;
		if (mdac_wait_mbox_ready(ctp)) goto host_stuff;
		(*ctp->cd_SendCmd)(rqp);
		if (mdac_status(mdac_wait_cmd_done(ctp))) goto host_stuff;
		MLXSWAP(dcmd4p->mb_MailBox4_7); MLXSWAP(dcmd4p->mb_MailBox8_B);
		ctp->cd_SendCmd = mdac_send_cmd_PCIPG_mmb;
memboxmode:     /* common code to set the memory mailbox functions */
		ctp->cd_Status |= MDACD_HOSTMEMAILBOX;
		ctp->cd_ReadCmdIDStatus = mdac_cmdid_status_PCIPG_mmb;
		ctp->cd_CheckMailBox = mdac_check_mbox_mmb;
		ctp->cd_HwPendingIntr = ctp->cd_PendingIntr;
		ctp->cd_PendingIntr = mdac_pending_intr_PCIPG_mmb;
		ctp->cd_ServiceIntr = mdac_multintr;
		if (mdac_advanceintrdisable) goto mmb_stuff;
		if (mdac_intrstatp)
		{       /* This memory is initialized, we must be slave */
			dcmdp->mb_Datap = mlx_kvtophys(ctp,&mdac_intrstatp[ctp->cd_ControllerNo]);
			if (mdac_ck64mb(dcmd4p->mb_MailBox4_7,dcmdp->mb_Datap)) goto mmb_stuff;
			MLXSWAP(dcmd4p->mb_MailBox4_7); MLXSWAP(dcmdp->mb_Datap);
			dcmdp->mb_MailBox2 = DACMDIOCTL_SLAVEINTR;
			inx = MDACD_SLAVEINTRCTLR;
		}
		else
		{       /* This is going to be master controller */
			if (!(mdac_intrstatp = (u32bits MLXFAR*)mdac_alloc4kb(ctp))) goto mmb_stuff;
			dcmdp->mb_Datap = mlx_kvtophys(ctp,mdac_intrstatp);
			if (mdac_ck64mb(dcmd4p->mb_MailBox4_7,dcmdp->mb_Datap)) goto freeintrstatmem;
			dcmd4p->mb_MailBox4_7 = mlx_kvtophys(ctp,&mdac_hwfwclock);
			MLXSWAP(dcmd4p->mb_MailBox4_7); MLXSWAP(dcmdp->mb_Datap);
			dcmdp->mb_MailBox2 = DACMDIOCTL_MASTERINTR;
			inx = MDACD_MASTERINTRCTLR;
		}
		if (mdac_wait_mbox_ready(ctp)) goto mmb_stuff;
		(*ctp->cd_SendCmd)(rqp);
		if (mdac_status(mdac_wait_cmd_done(ctp)))
		{
			u08bits_write(ctp->cd_SystemDoorBellReg, MDAC_CLEAR_INTR); /* Work around for spurious interrupts */
			if (inx != MDACD_MASTERINTRCTLR) goto mmb_stuff;
freeintrstatmem:        /* Freeup the memory */
			mdacfree4kb(ctp,mdac_intrstatp);
			mdac_intrstatp = NULL;
			goto mmb_stuff;
		}
		ctp->cd_Status |= inx;
		if (inx == MDACD_MASTERINTRCTLR) mdac_masterintrctp = ctp;
		goto mmb_stuff;
	}
host_stuff:
	if (ctp->cd_HostCmdQue) mdacfree8kb(ctp,ctp->cd_HostCmdQue);
	ctp->cd_HostCmdQue = NULL;
	ctp->cd_HostStatusQue = NULL;
mmb_stuff:
	DebugPrint((0, "reached: mmb_stuff \n"));
	(*ctp->cd_EnableIntr)(ctp); /* Enable interrupts */
	mdac_free_cmdid(ctp,rqp);
	mdac_ctlr_unlock(ctp);
    mdac_postlock(irql);
	mdac_free4kbret(ctp,rqp,0);

out_err:(*ctp->cd_EnableIntr)(ctp); /* Enable interrupts */
out_err2: mdac_free_cmdid(ctp,rqp);
out_err3: mdac_ctlr_unlock(ctp);
         mdac_postlock(irql);
	mdac_free4kbret(ctp,rqp,ERR_IO);

donewi: /* do new interface to get the controller information */
	/* The new command structure is clean here */
	DebugPrint((0, "mdac_ctlhwinit: newcmd interface\n"));
	mdac_setcmd_new(ctp);

/* we will no longer send the unpause command because a) in normal mode, the 
** firmware now takes care of this with auto-unpause and b) it causes failures 
** in maintenance mode which no longer supports it
*/
#if 0
	/*
	** must issue MDACIOCTL_UNPAUSE first thing
	*/
	rqp->rq_FinishTime=mda_CurTime + (rqp->rq_TimeOut=ncmdp->nc_TimeOut=17);
	ncmdp->nc_Command = MDACMD_IOCTL;
	ncmdp->nc_SubIOCTLCmd = MDACIOCTL_UNPAUSEDEV;
	ncmdp->nc_Cdb[0] = MDACDEVOP_RAIDCONTROLLER;
	DebugPrint((0, "mdac_ctlhwinit: issuing unpause device\n"));
	(*ctp->cd_SendCmd)(rqp);
#if 0
	mdac_status(mdac_wait_cmd_done(ctp)); /* ignore error status */
#else
	status = mdac_status(mdac_wait_cmd_done(ctp));
	if (status)
	{
	    DebugPrint((0, "UnpauseDevice cmd failed: sts 0x%x\n", status));
	    goto out_err;
	}
#endif
#endif /* issue MDACIOCTL_PAUSE */

#if defined(_WIN64) || defined(SCSIPORT_COMPLIANT) 
#ifdef NEVER  // there are problems associated w/ MLXCTIME
 
	rqp->rq_FinishTime=mda_CurTime + (rqp->rq_TimeOut=ncmdp->nc_TimeOut=17);
	ncmdp->nc_Command = MDACMD_IOCTL;
	ncmdp->nc_SubIOCTLCmd = MDACIOCTL_SETREALTIMECLOCK;
	ncmdp->nc_SGList0.sg_DataSize.bit31_0 = ncmdp->nc_TxSize = 8;
	MLXSWAP(ncmdp->nc_SGList0.sg_DataSize); MLXSWAP(ncmdp->nc_TxSize);
#ifndef WINNT_50
		rtcvalue.bit63_32 = 0;
#ifndef MLX_DOS
		rtcvalue.bit31_0  = MLXCTIME();
#else
		rtcvalue.bit31_0 = mdac_compute_seconds();
#endif
		mlx_kvtophyset(ncmdp->nc_SGList0.sg_PhysAddr,ctp,&rtcvalue); MLXSWAP(ncmdp->nc_SGList0.sg_PhysAddr);
#else
		rtcvalue->bit63_32 = 0;
		rtcvalue->bit31_0  = MLXCTIME();
		mlx_kvtophyset(ncmdp->nc_SGList0.sg_PhysAddr,ctp,rtcvalue); MLXSWAP(ncmdp->nc_SGList0.sg_PhysAddr);
#endif  // if WINNT_50
	    (*ctp->cd_SendCmd)(rqp);
#if 1

		/* ignore error status because maintenance mode does not support */
	mdac_status(mdac_wait_cmd_done(ctp)); 
#else
	status = mdac_status(mdac_wait_cmd_done(ctp));
	if (status)
	{
	    DebugPrint((0, "SetRealTimeClock cmd failed: sts 0x%x\n", status));
	    goto out_err;
	}
#endif

	rqp->rq_FinishTime=mda_CurTime + (rqp->rq_TimeOut=ncmdp->nc_TimeOut=17);

#endif //ifdef NEVER
#endif //_WIN64 or SCSIPORT_COMPLIANT

	ncmdp->nc_Command = MDACMD_IOCTL;
	ncmdp->nc_SubIOCTLCmd = MDACIOCTL_GETCONTROLLERINFO;
	ncmdp->nc_CCBits = MDACMDCCB_READ;
	ncmdp->nc_SGList0.sg_DataSize.bit31_0 = ncmdp->nc_TxSize = (4*ONEKB) - mdac_req_s;
	MLXSWAP(ncmdp->nc_SGList0.sg_DataSize); MLXSWAP(ncmdp->nc_TxSize);
	mlx_kvtophyset(ncmdp->nc_SGList0.sg_PhysAddr,ctp,dp); MLXSWAP(ncmdp->nc_SGList0.sg_PhysAddr);
	(*ctp->cd_SendCmd)(rqp);
	DebugPrint((0, "mdac_ctlhwinit: sent getcontroller info\n"));
	if (status = mdac_status(mdac_wait_cmd_done(ctp)))
	{
	    DebugPrint((0, "GetControllerInfo cmd failed. sts 0x%x\n", status));
	    goto out_err;
	}
	DebugPrint((0, "mdac_ctlhwinit: getcontrollerinfo done\n"));
#define cip     ((mdacfsi_ctldev_info_t MLXFAR *)dp)
	ctp->cd_InterruptType = DAC_LEVELMODEINTERRUPT;
	ctp->cd_BIOSHeads = 255;
	 ctp->cd_BIOSTrackSize = 63;  /* assume 8 gb geometry */
	ctp->cd_MaxLuns = 128;
	ctp->cd_MaxSysDevs = 32;
	ctp->cd_MaxTargets = 128;
	ctp->cd_MaxTags = 64;
	ctp->cd_FWVersion = (cip->cdi_FWMajorVersion<<8) + cip->cdi_FWMinorVersion;
	if ((ctp->cd_MaxCmds=mlxswap(cip->cdi_MaxCmds)) > MDAC_MAXCOMMANDS)
		ctp->cd_MaxCmds = MDAC_MAXCOMMANDS;
	ctp->cd_FWBuildNo = cip->cdi_FWBuildNo;
	ctp->cd_FWTurnNo = cip->cdi_FWTurnNo;
	ctp->cd_PhysChannels = cip->cdi_PhysChannels;
	ctp->cd_MaxChannels = cip->cdi_PhysChannels + cip->cdi_VirtualChannels;
	ctp->cd_MaxDataTxSize = mlxswap(cip->cdi_MaxDataTxSize) * DAC_BLOCKSIZE;
	ctp->cd_MaxSCDBTxSize = ctp->cd_MaxDataTxSize;
	ctp->cd_MaxSGLen = mlx_min(mlxswap(cip->cdi_MaxSGLen), MDAC_MAXSGLISTSIZEIND);
	ctp->cd_MaxSGLen = mlx_min(ctp->cd_MaxSGLen, (ctp->cd_MaxDataTxSize/MDAC_PAGESIZE));
	ctp->cd_MinSGLen = mlx_min(mlxswap(cip->cdi_MaxSGLen), MDAC_MAXSGLISTSIZENEW);

	ctp->cd_ControllerType = cip->cdi_ControllerType;
	mdaccopy(cip->cdi_ControllerName,ctp->cd_ControllerName,USCSI_PIDSIZE);

	rqp->rq_FinishTime      = mda_CurTime + (rqp->rq_TimeOut=ncmdp->nc_TimeOut=17);
	ncmdp->nc_Command       = MDACMD_IOCTL;
	ncmdp->nc_SubIOCTLCmd   = MDACIOCTL_GETLOGDEVINFOVALID;
	ncmdp->nc_LunID         = 0;    /* logical device 0 */
	ncmdp->nc_TargetID      = 0;
	ncmdp->nc_CCBits        = MDACMDCCB_READ;
	ncmdp->nc_SGList0.sg_DataSize.bit31_0 = ncmdp->nc_TxSize = (4*ONEKB) - mdac_req_s;
	MLXSWAP(ncmdp->nc_SGList0.sg_DataSize); MLXSWAP(ncmdp->nc_TxSize);
	mlx_kvtophyset(ncmdp->nc_SGList0.sg_PhysAddr,ctp,dp); MLXSWAP(ncmdp->nc_SGList0.sg_PhysAddr);
	(*ctp->cd_SendCmd)(rqp);
	DebugPrint((0, "mdac_ctlhwinit: sent getlogdevinfovalid \n"));
	if (status = mdac_status(mdac_wait_cmd_done(ctp)))
	{
	    DebugPrint((0, "GetLogDevInfoValid cmd failed. sts 0x%x\n", status));
	    goto CheckForAdvancFeature;
	}
	DebugPrint((0, "mdac_ctlhwinit: GetLogDevInfoValid done\n"));
#undef cip
#define cip     ((mdacfsi_logdev_info_t MLXFAR *)dp)
	if ((cip->ldi_BiosGeometry & DACF2_BIOS_MASK) == DACF2_BIOS_8GB)
	{
		ctp->cd_BIOSHeads = 255;
		ctp->cd_BIOSTrackSize = 63;  /* use 8 gb geometry */
	}
	else
	{
		ctp->cd_BIOSHeads = 128; 
		ctp->cd_BIOSTrackSize = 32;  /* 2GB geometry */
	}
CheckForAdvancFeature:
	DebugPrint((0, "Checking for advance feature\n"));
	if (mdac_advancefeaturedisable) goto mmb_stuff;
	DebugPrint((0, "advance feature enabled\n"));

	/*
	 * try setting the controller mode to advanced.
	 *
	 * If the command is successful, Fw will operate in dual mode.
	 */

	if (!ctp->cd_HostCmdQue)
	    if (!(ctp->cd_HostCmdQue = (u08bits MLXFAR*)mdac_alloc8kb(ctp))) goto host_stuff;
	ctp->cd_HostStatusQue = ctp->cd_HostCmdQue + 4*ONEKB;
	ctp->cd_HostCmdQueIndex = 0;
	ctp->cd_HostStatusQueIndex = 0;

	ncmdp->nc_Command = MDACMD_IOCTL;
	ncmdp->nc_SubIOCTLCmd = MDACIOCTL_SETMEMORYMAILBOX;
	ncmdp->nc_CCBits = MDACMDCCB_WRITE;
	ncmdp->nc_TxSize = ((4 << 8) | 4);      /* 4KB Command MailBox + 4KB Status MB */
		mlx_kvtophyset(ncmdp->nc_SGList0.sg_PhysAddr,ctp, ctp->cd_HostCmdQue);
		mlx_kvtophyset(ncmdp->nc_SGList0.sg_DataSize,ctp, ctp->cd_HostStatusQue);
/*
	if (mdac_ck64mb(ncmdp->nc_SGList0.sg_PhysAddr.bit31_0, ncmdp->nc_SGList0.sg_DataSize.bit31_0))
	{
	    goto host_stuff;
	}
*/

	MLXSWAP(ncmdp->nc_SGList0.sg_PhysAddr); MLXSWAP(ncmdp->nc_SGList0.sg_DataSize);
	ncmdp->nc_SGList1.sg_PhysAddr.bit31_0 = 0;
	ncmdp->nc_SGList1.sg_DataSize.bit31_0 = 0;
	if (mdac_wait_mbox_ready(ctp))
	{
	    goto host_stuff;
	}
	(*ctp->cd_SendCmd)(rqp);
	if (mdac_status(mdac_wait_cmd_done(ctp)))
	{
	    goto host_stuff;
	}

	ctp->cd_SendCmd = mdac_send_cmd_PCIBA_mmb_mode;
	ctp->cd_Status |= MDACD_HOSTMEMAILBOX;
	ctp->cd_ReadCmdIDStatus = mdac_cmdid_status_PCIBA_mmb;
	ctp->cd_CheckMailBox = mdac_check_mbox_mmb;
	ctp->cd_HwPendingIntr = ctp->cd_PendingIntr;
	ctp->cd_PendingIntr = mdac_pending_intr_PCIPG_mmb;
	ctp->cd_ServiceIntr = mdac_multintr;

/* 9/22/99 - added support for SIR on new API cards (judyb) */

		if (mdac_advanceintrdisable) goto mmb_stuff;
			if (mdac_intrstatp)
			{       /* This memory is initialized, we must be slave */
				ncmdp->nc_Command = MDACMD_IOCTL;
			    ncmdp->nc_SubIOCTLCmd = MDACIOCTL_SETMASTERSLAVEMODE;
				ncmdp->nc_CCBits = MDACMDCCB_WRITE;
				ncmdp->nc_NumEntries = MDAC_MAXCONTROLLERS;
				ncmdp->nc_CmdInfo = MDAC_SETSLAVE;
#ifdef MLX_FIXEDPOOL
                mlx_add64bits(ncmdp->nc_CommBufAddr, mdac_pintrstatp, sizeof(*mdac_intrstatp)*ctp->cd_ControllerNo);
#else
				mlx_kvtophyset(ncmdp->nc_CommBufAddr,ctp,
								&mdac_intrstatp[ctp->cd_ControllerNo]);
#endif
				MLXSWAP(ncmdp->nc_SGList0.sg_PhysAddr);   
/*
				if (mdac_ck64mb(mlx_kvtophys(ctp,ctp->cd_HostCmdQue),ncmdp->nc_SGList0.sg_PhysAddr.bit31_0))
				{
					goto mmb_stuff;
				}
*/
		inx = MDACD_SLAVEINTRCTLR;
			} /* end slave case */
	    else
	    {       /* This is going to be master controller */

				if (!(mdac_intrstatp = (u32bits MLXFAR*)mdac_alloc4kb(ctp))) 
					goto mmb_stuff;
			ncmdp->nc_Command = MDACMD_IOCTL;
			    ncmdp->nc_SubIOCTLCmd = MDACIOCTL_SETMASTERSLAVEMODE;
				ncmdp->nc_CCBits = MDACMDCCB_WRITE;
				ncmdp->nc_NumEntries = MDAC_MAXCONTROLLERS;
				ncmdp->nc_CmdInfo = MDAC_SETMASTER;
				mlx_kvtophyset(ncmdp->nc_CommBufAddr,ctp,mdac_intrstatp);
#ifdef MLX_FIXEDPOOL
                mdac_pintrstatp = ncmdp->nc_CommBufAddr;    /* Remember for slave. */
#endif
				MLXSWAP(ncmdp->nc_SGList0.sg_PhysAddr); 
/*
				if (mdac_ck64mb(mlx_kvtophys(ctp,ctp->cd_HostCmdQue),ncmdp->nc_CommBufAddrLow))
				{
					goto freeintrstatmem2;
				}
*/
		inx = MDACD_MASTERINTRCTLR;
			} /* end master case */

			ncmdp->nc_SGList1.sg_PhysAddr.bit31_0  = 0; /* set reserved fields to zero */
			ncmdp->nc_SGList1.sg_DataSize.bit31_0  = 0;
			ncmdp->nc_SGList1.sg_PhysAddr.bit63_32 = 0; /* set reserved fields to zero */
			ncmdp->nc_SGList1.sg_DataSize.bit63_32 = 0;

			if (mdac_wait_mbox_ready(ctp))
			{
				goto freeintrstatmem2;
			}
		    (*ctp->cd_SendCmd)(rqp);
			if (mdac_status(mdac_wait_cmd_done(ctp)))
			{
				DebugPrint((0, "failed SetMasterSlaveMode IOCTL, inx = % ctp = %\n", inx, ctp));

				if (inx != MDACD_MASTERINTRCTLR) 
					goto mmb_stuff;
freeintrstatmem2:
				mdacfree4kb(ctp,mdac_intrstatp);
		mdac_intrstatp = NULL;
		goto mmb_stuff;

			}
			DebugPrint((0, "successful SetMasterSlaveMode IOCTL, inx = %  ctp = %x \n", inx, ctp));

	    ctp->cd_Status |= inx;
	    if (inx == MDACD_MASTERINTRCTLR)
				mdac_masterintrctp = ctp;

	    goto mmb_stuff;

#undef  dp
}

#ifdef MLX_DOS
/* 
Compute number of seconds elapsed from Jan 1, 1970 
This algorithm is a rough estimate. There may difference
in time by 24 hours. This is used so that F/W can be 
given a unique number.
*/
#ifndef MLX_EFI
u32bits mdac_compute_seconds()                                  
{
	s32bits s32SecInMin  = 60;
	s32bits s32SecInHour = s32SecInMin * 60;
	s32bits s32SecInDay  =  s32SecInHour * 24;
	s32bits s32SecInMon  =  s32SecInDay * 30;
	s32bits s32SecInYear = s32SecInDay * 365;
	s32bits s32year=0;
	u32bits u32TotalSecs=0;
	u32bits u32Date=0,u32Time=0;
	u16bits u16Day=0,u16Mon=0,u16Year=0,u16Hour=0,u16Min=0,u16Sec=0;
	u08bits u08DeltaMon[12] = {0,1,1,2,2,3,3,4,5,5,6,6};

	u32Date = mdac_datebin();
    u16Day = u32Date & 0xFF; u16Mon = (u32Date >> 8) & 0xFF; 
	u16Year = (u32Date >> 16) & 0xFF;

	u32Time = mdac_daytimebin();
    u16Sec  = u32Time & 0xFF; u16Min = (u32Time >> 8) & 0xFF; 
	u16Hour = (u32Time >> 16) & 0xFF;
    u16Year = (u16Year -70)>0?u16Year-70:u16Year+30;

	u32TotalSecs = ( (u16Year * 365 * s32SecInDay ) + (u16Mon -1) * s32SecInMon + 
			     (u16Day -1) * s32SecInDay + (u16Hour -1) * s32SecInHour +
		     (u16Min -1) * s32SecInMin + u16Sec);

	// Leap days ~~~approx
	u32TotalSecs += ((u16Year /4)-1) * s32SecInDay;
	// Months with days 31
    u32TotalSecs += (u08DeltaMon[u16Mon] -1) * s32SecInDay;

	return u32TotalSecs;
}
#else
u32bits mdac_compute_seconds()                                  
{
	u32bits u32year=0;
	u32bits u32TotalSecs=0;
	u32bits u32Date=0,u32Time=0;
	u16bits u16Day=0,u16Mon=0,u16Year=0,u16Hour=0,u16Min=0,u16Sec=0, u16Days, i;
/*	u08bits u08DeltaMon[12] = {0,1,1,2,2,3,3,4,5,5,6,6}; */
	u08bits u08Mon[12] = {31,28,31,30,31,30,31,31,30,31,30,31};

	u32Date = mdac_datebin();
    u16Day = u32Date & 0xFF; 
	u16Mon = (u32Date >> 8) & 0xFF; 
	u16Year = (u32Date >> 16) & 0xFF;


	/* CR4172, dk, 6-22-00 */
	u32Time = mdac_daytimebin();
    u16Sec  = u32Time & 0xFF; 
	u16Min = (u32Time >> 8) & 0xFF; 
	u16Hour = (u32Time >> 16) & 0xFF;
/*    if ((u16Year - 70) > 0)
		u16Year = u16Year - 70;
	else
		u16Year = u16Year + 30;   years since 1970 */
	u16Year = u16Year + 30;

	for (i=0, u16Days = 0; i < u16Mon - 1; i++)
		u16Days += ((u32bits)u08Mon[i]);
	u16Days += u16Day - 1;   /* not end of day-24 hours yet */
	u32TotalSecs = (u32bits)( (((u32bits)u16Year * (u32bits)365 + (u32bits)u16Days) * 24 * 60 * 60) + 
							  ((u32bits)u16Hour) * 60 * 60 +
							  ((u32bits)u16Min) * 60 + 
							   (u32bits)u16Sec);

/* Leap days ~~~approx   first leap year since 1970 is 1972*/
	u32TotalSecs += ((u32bits)(u16Year - 2) / 4) * 24 * 60 * 60;
	return u32TotalSecs;
}

#endif /* MLX_EFI */
#endif

#define mlx_printstring(x)      /* printf(x) */

#if (!defined(_WIN64)) || (!defined(SCSIPORT_COMPLIANT)) 
#define u08bits_memiowrite(addr,val) if (((u32bits)(addr))<0x10000) u08bits_out_mdac(addr,val); else u08bits_write(addr,val)
#define u08bits_memioread(addr) ((((u32bits)(addr))<0x10000)? u08bits_in_mdac(addr) : u08bits_read(addr))
#else
#define u08bits_memiowrite(addr,val) if ((addr)<0x10000) u08bits_out_mdac(addr,val); else u08bits_write(addr,val)
#define u08bits_memioread(addr) (((addr)<0x10000)? u08bits_in_mdac(addr) : u08bits_read(addr))
#endif

/* start the controller i.e. do BIOS initialization */
u32bits MLXFAR
mdac_start_controller(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u32bits sequp, fatalflag, status, chn,tgt, scantime, dotime;

	if (ctp->cd_Status & MDACD_NEWCMDINTERFACE) 
			DebugPrint((0, "mdac_start_controller\n"));

start_again:
	fatalflag = 0; sequp = 0;
	(*ctp->cd_DisableIntr)(ctp); /* Disable interrupts */
	u08bits_memiowrite(ctp->cd_LocalDoorBellReg, MDAC_GOT_STATUS);

rst_flash_loop:
	scantime = MLXCLBOLT() + (120*MLXHZ);   /* 120 second */
dot_wait:
	dotime = MLXCLBOLT() + (2*MLXHZ);       /* 2 seconds */
flash_wait:
	for(status=100; status; mlx_delay10us(),status--);
	status = u08bits_memioread(ctp->cd_LocalDoorBellReg);
	if ((ctp->cd_vidpid==MDAC_DEVPIDPV) || (ctp->cd_vidpid==MDAC_DEVPIDBA) )
	{
			if (status & MDAC_GOT_STATUS)
			{
				goto time_status;
			}
	}
		else if (ctp->cd_vidpid==MDAC_DEVPIDLP)
		{
			if (!(status & MDAC_GOT_STATUS))
				goto time_status;
		}
	else if (!(status & MDAC_GOT_STATUS))
		{
			DebugPrint((0, "PG etc: Got Status\n"));
			goto time_status;
		}
	if ((status=u08bits_memioread(ctp->cd_ErrorStatusReg)) & MDAC_MSG_PENDING) goto ckfwmsg;
	if (status & MDAC_DRIVESPINMSG_PENDING)
	{
	    status = ((ctp->cd_vidpid==MDAC_DEVPIDPV) || (ctp->cd_vidpid==MDAC_DEVPIDBA) ||
					 (ctp->cd_vidpid==MDAC_DEVPIDLP))?
			status & MDAC_DRIVESPINMSG_PENDING :
			status ^ MDAC_DRIVESPINMSG_PENDING;
	    u08bits_memiowrite(ctp->cd_ErrorStatusReg,(u08bits)status);
	    if (!sequp) mlx_printstring("\nSpinning up drives ... ");
	    if (!sequp) DebugPrint((0, "\nSpinning up drives ... "));
	    sequp++;
	    goto rst_flash_loop;
	}
	if (sequp)
	{
	    if (dotime < MLXCLBOLT()) mlx_printstring(".");
	    if (dotime < MLXCLBOLT()) DebugPrint((0, "."));
	    goto dot_wait;
	}
	if (scantime > MLXCLBOLT()) goto flash_wait;
inst_abrt:
	mlx_printstring("\nController not responding-no drives installed!\n");
	DebugPrint((0, "\nController not responding-no drives installed!\n"));
	return 1;

time_status:
	if (mdac_flushintr(ctp)== 0xffffffff)
		return 0xffffffff;
	if (fatalflag) goto inst_abrt;
	if (sequp) mlx_printstring("done\n");
	if (sequp) DebugPrint((0, "\ndone\n"));
	return 0;

ckfwmsg:
	if (sequp) mlx_printstring("done\n");
	if (sequp) DebugPrint((0, "\ndone\n"));
	sequp = 0;
	switch (status & MDAC_DIAGERROR_MASK)
	{
	    case 0:
		tgt = u08bits_memioread(ctp->cd_MailBox+8);
		chn = u08bits_memioread(ctp->cd_MailBox+9);
/*              printf("SCSI device at Channel=%d target=%d not responding!\n",chn,tgt); */
		fatalflag = 1;
	    break;
	    case MDAC_PARITY_ERR:
		mlx_printstring("Fatal error - memory parity failure!\n");
		DebugPrint((0, "Fatal error - memory parity failure!\n"));
	    break;
	    case MDAC_DRAM_ERR:
		mlx_printstring("Fatal error - memory test failed!\n");
		DebugPrint((0, "Fatal error - memory test failed!\n"));
	    break;
	    case MDAC_BMIC_ERR:
		mlx_printstring("Fatal error - command interface test failed!\n");
		DebugPrint((0, "Fatal error - command interface test failed!\n"));
	    break;
	    case MDAC_FW_ERR:
		mlx_printstring("firmware checksum error - reload firmware\n");
		DebugPrint((0, "firmware checksum error - reload firmware\n"));
	    break;
	    case MDAC_CONF_ERR:
		mlx_printstring("configuration checksum error!\n");
		DebugPrint((0, "configuration checksum error!\n"));
	    break;
	    case MDAC_MRACE_ERR:
		mlx_printstring("Recovery from mirror race in progress\n");
		DebugPrint((0, "Recovery from mirror race in progress\n"));
	    break;
	    case MDAC_MISM_ERR:
		mlx_printstring("Mismatch between NVRAM & Flash EEPROM configurations!\n");
		DebugPrint((0, "Mismatch between NVRAM & Flash EEPROM configurations!\n"));
	    break;
	    case MDAC_CRIT_MRACE:
		mlx_printstring("cannot recover from mirror race!\nSome logical drives are inconsistent!\n");
		DebugPrint((0, "cannot recover from mirror race!\nSome logical drives are inconsistent!\n"));
	    break;
	    case MDAC_MRACE_ON:
		mlx_printstring("Recovery from mirror race in progress\n");
		DebugPrint((0, "Recovery from mirror race in progress\n"));
	    break;
	    case MDAC_NEW_CONFIG:
		mlx_printstring("New configuration found, resetting the controller ... ");
		DebugPrint((0,"New configuration found, resetting the controller ... "));
		if ((ctp->cd_vidpid!=MDAC_DEVPIDPV) && (ctp->cd_vidpid!=MDAC_DEVPIDBA) &&
					(ctp->cd_vidpid!=MDAC_DEVPIDLP))
						status = 0;
				else
						status =  MDAC_MSG_PENDING;
		u08bits_memiowrite(ctp->cd_ErrorStatusReg,(u08bits)status);
		(*ctp->cd_ResetController)(ctp);
		mlx_printstring("done.\n");
		DebugPrint((0,"done.\n"));
		goto start_again;
			break;
	}
	if ((ctp->cd_vidpid!=MDAC_DEVPIDPV) && (ctp->cd_vidpid!=MDAC_DEVPIDBA) &&
			(ctp->cd_vidpid!=MDAC_DEVPIDLP))
			status = 0;
		else
			status =  MDAC_MSG_PENDING;
	u08bits_memiowrite(ctp->cd_ErrorStatusReg,(u08bits)status);
	goto rst_flash_loop;
}



/* look into BIOS area for BIOS information */
dac_biosinfo_t  MLXFAR*
mdac_getpcibiosaddr(ctp)
mdac_ctldev_t   MLXFAR  *ctp;
{
#ifdef AI64 // because we can't get mdac_biosp value
	return NULL;
#else
	dac_biosinfo_t MLXFAR *biosp = mdac_biosp;
	u32bits inx, cnt = DAC_BIOSSIZE/dac_biosinfo_s;
	if (!biosp) return NULL;
	for (; cnt; biosp++, cnt--)
		if ((biosp->bios_Signature == 0xAA55) &&
		    (biosp->bios_VersionSignature == 0x68536C4B))
		for (inx=0; inx<16; inx++)
			if (ctp->cd_BaseAddr==biosp->bios_IOBaseAddr[inx])
				return biosp;
	return NULL;
#endif
}

/* Use this function on system shutdown. Just issue a cache flush, wait for it
** to be done and return. Do it for all the active DACs in this system.
** It must enter interrupt protected.
*/
u32bits MLXFAR
mdac_flushcache(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u32bits rc;
	mdac_req_t MLXFAR *rqp;
    u08bits irql;
	mdac_alloc_req_ret(ctp,rqp,NULL,MLXERR_NOMEM);
	dcmd4p->mb_MailBox0_3 = 0; dcmd4p->mb_MailBox4_7 = 0;
	dcmd4p->mb_MailBox8_B = 0; dcmd4p->mb_MailBoxC_F = 0;
	dcmdp->mb_Command = DACMD_FLUSH;
	if (ctp->cd_Status & MDACD_NEWCMDINTERFACE)
	{       /* pause or flush the device for new interface */
		mdaczero(ncmdp,mdac_commandnew_s);
		rqp->rq_FinishTime=mda_CurTime + (rqp->rq_TimeOut=ncmdp->nc_TimeOut=17);
		ncmdp->nc_Command = MDACMD_IOCTL;
		ncmdp->nc_SubIOCTLCmd = MDACIOCTL_PAUSEDEV;
		ncmdp->nc_Cdb[0] = MDACDEVOP_RAIDCONTROLLER;
	}
    mdac_prelock(&irql);
	mdac_ctlr_lock(ctp);
	mdac_get_cmdid(ctp,rqp);
	(*ctp->cd_DisableIntr)(ctp); /* Disable interrupts */
	mdac_flushintr(ctp);
	if (rc=mdac_wait_mbox_ready(ctp)) goto out;
	(*ctp->cd_SendCmd)(rqp);
	rc = mdac_status(mdac_wait_cmd_done(ctp));
out:    (*ctp->cd_EnableIntr)(ctp); /* Enable interrupts */
	mdac_free_cmdid(ctp,rqp);
	mdac_ctlr_unlock(ctp);
    mdac_postlock(irql);
	mdac_free_req(ctp,rqp);
	return rc;
}


/* flush all pending interrupts, return the # interrupts flushed */
u32bits MLXFAR
mdac_flushintr(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u32bits intc = 0;
	u32bits inx;

	if (!(*ctp->cd_PendingIntr)(ctp)) return 0;
	for(intc=0; intc < 512; intc++)
	{
		(*ctp->cd_ReadCmdIDStatus)(ctp);
		for(inx=100; inx; mlx_delay10us(),inx--);
		if (!(*ctp->cd_PendingIntr)(ctp)) return intc;
	}
	return 0xffffffff;
}

/* This function is used to set the boot controller right, return 0 if OK */
u32bits MLXFAR
mdac_setbootcontroller()
{
	mdac_ctldev_t   MLXFAR *ctp;
	dac_biosinfo_t  MLXFAR *biosp;
	for(ctp=mdac_ctldevtbl; ctp<mdac_lastctp; ctp++)
		if ((biosp=mdac_getpcibiosaddr(ctp)) && !biosp->bios_SysDevs && 
		   (!(biosp->bios_BIOSFlags & DACBIOSFL_BOOTDISABLED)))
			ctp->cd_Status |= MDACD_BOOT_CONTROLLER;
	for(ctp=mdac_ctldevtbl; ctp<mdac_lastctp; ctp++)
	{
		if (!(ctp->cd_Status & MDACD_BOOT_CONTROLLER)) continue;
		if (ctp == mdac_ctldevtbl) return 0;
		mdac_ctldevtbl[MDAC_MAXCONTROLLERS]=mdac_ctldevtbl[0]; /*save*/
		mdac_ctldevtbl[0] = *ctp;
		*ctp = mdac_ctldevtbl[MDAC_MAXCONTROLLERS];
		return mdac_setctlnos();
	}
	return ERR_NODEV;
}

/* save the sense data for future request sense */
u32bits MLXFAR
mdac_save_sense_data(ctl,sysdev,esp)
u32bits ctl,sysdev;
ucscsi_exsense_t MLXFAR *esp;
{
	mdac_reqsense_t MLXFAR *mrqsp;
	mdac_link_lock();
	/* see if this device entry exist, if yes update it. */
	for (mrqsp=mdac_reqsensetbl; mrqsp<mdac_lastrqsp; mrqsp++)
		if ((mrqsp->mrqs_ControllerNo == ctl) && (mrqsp->mrqs_SysDevNo==sysdev)) goto outok;
	/* find free slot */
	for (mrqsp=mdac_reqsensetbl; mrqsp<mdac_lastrqsp; mrqsp++)
		if (!(mrqsp->mrqs_SenseData[0])) goto outok;
	/* no free space, let us pick one in round robin mode */
	mrqsp = &mdac_reqsensetbl[mdac_reqsenseinx++ % MDAC_MAXREQSENSES];
outok:  mrqsp->mrqs_ControllerNo = (u08bits)ctl;
	mrqsp->mrqs_SysDevNo = (u08bits) sysdev;
	mdaccopy(esp,mrqsp->mrqs_SenseData,MDAC_REQSENSELEN);
	mdac_link_unlock();
	return 0;
}

/* get the sense data value from saved space */
u32bits MLXFAR
mdac_get_sense_data(ctl,sysdev,sp)
u32bits ctl,sysdev;
u08bits MLXFAR *sp;
{
	mdac_reqsense_t MLXFAR *mrqsp;
	mdac_link_lock();
	for (mrqsp=mdac_reqsensetbl; mrqsp<mdac_lastrqsp; mrqsp++)
	{       /* return even if old sense data was cleared */
		if ((mrqsp->mrqs_ControllerNo != ctl) || (mrqsp->mrqs_SysDevNo!=sysdev)) continue;
		if (!(mrqsp->mrqs_SenseData[0])) continue;
		mdaccopy(mrqsp->mrqs_SenseData,sp,MDAC_REQSENSELEN);
		mrqsp->mrqs_SenseData[0] = 0;
		mdac_link_unlock();
		return 0;
	}
	mdaczero(sp,MDAC_REQSENSELEN);
	mdac_link_unlock();
	return 0;
}

/* Create the sense data for given SCSI error code values */
#define esp     ((ucscsi_exsense_t MLXFAR *)dcdbp->db_SenseData)
u32bits MLXFAR
mdac_create_sense_data(rqp,key,asc)
mdac_req_t MLXFAR *rqp;
u32bits key,asc;
{
	esp->es_classcode = UCSES_VALID | UCSES_CLASS;
	esp->es_keysval = (u08bits)key;
	esp->es_asc = asc>>8;                   /* bits 15..8 */
	esp->es_ascq = (u08bits)asc;                     /* bits  7..0 */
	esp->es_add_len = 6;                    /* To reach ASC & ASCQ */
	esp->es_info3=0; esp->es_info2=0;
	esp->es_info1=0; esp->es_info0=0;
	dcdbp->db_SenseLen = ucscsi_exsense_s;
	dcmdp->mb_Status = UCST_CHECK;
	dcdbp->db_Reserved1 = 1;        /* Used by solaris to find out  */
					/* if sense data is cooked up   */
					/* 1=yes, 0=no                  */
	return mdac_save_sense_data(rqp->rq_ctp->cd_ControllerNo,rqp->rq_SysDevNo,esp);
}
#undef  esp

/* Generate the SCSI inquiry information and return address */
ucscsi_inquiry_t MLXFAR *
mdac_create_inquiry(ctp,iqp,dtype)
mdac_ctldev_t   MLXFAR *ctp;
ucscsi_inquiry_t MLXFAR *iqp;
u32bits dtype;
{
	u32bits ver;
	iqp->ucsinq_dtype = (u08bits)dtype;
	iqp->ucsinq_hopts=UCSHOPTS_WBUS16|UCSHOPTS_SYNC|UCSHOPTS_CMDQ;
	iqp->ucsinq_version = 2;
	iqp->ucsinq_dtqual = 0; iqp->ucsinq_sopts = 0;
	iqp->ucsinq_drvstat = 0; iqp->ucsinq_resv0 = 0;
	iqp->ucsinq_len = USCSI_VIDPIDREVSIZE + 2;
	ver = (ctp->cd_FWVersion>>8) & 0xFF;    /* get major version */
	iqp->ucsinq_rev[0] = (ver / 10) + '0';
	iqp->ucsinq_rev[1] = (ver % 10) + '0';
	ver = ctp->cd_FWVersion & 0xFF;         /* get minor version */
	iqp->ucsinq_rev[2] = (ver / 10) + '0';
	iqp->ucsinq_rev[3] = (ver % 10) + '0';
	mdaccopy(mdac_VendorID,iqp->ucsinq_vid,USCSI_VIDSIZE);
	mdaccopy(ctp->cd_ControllerName,iqp->ucsinq_pid,USCSI_PIDSIZE);
	return iqp;
}

/*====================INTERRUPT HANDLING CODE STARTS======================*/
/* primary interrupt handler function. Deals with completion interrupts
** and starts the next command (if any).
*/
s32bits MLXFAR
mdacintr(irq)
UINT_PTR irq;
{
	mdac_ctldev_t MLXFAR *ctp;
	if ((ctp = mdac_masterintrctp) && (ctp->cd_irq == irq))
	{       /* ack the interrupt, handle all IOs */
		MLXSTATS(ctp->cd_IntrsDone++;)
		u08bits_write(ctp->cd_SystemDoorBellReg, MDAC_CLEAR_INTR);
		if (mdac_allmsintr()) return 0; /* some interrupts were present */
	}
	
	/* handle one controller interrupt at a time */
	for (ctp=mdac_ctldevtbl; ctp<mdac_lastctp; ctp++)
	{
		if (!(ctp->cd_Status & MDACD_PRESENT)) continue;
		if (ctp->cd_Status & MDACD_MASTERINTRCTLR) continue;
		if (ctp->cd_irq != irq) continue;
		if (!ctp->cd_IntrShared)
		{       /* Interrupt is not shared */
			if ((*ctp->cd_PendingIntr)(ctp))
				return (*ctp->cd_ServiceIntr)(ctp); /* main interrupt handler */
			goto nextintr;
		}
		if (ctp->cd_IntrActive) continue;
		mdac_link_lock();
		if (ctp->cd_IntrActive) { mdac_link_unlock(); continue; }
		ctp->cd_IntrActive = 1;
		mdac_link_unlock();
#ifdef MLX_WIN9X
		if (! (*ctp->cd_PendingIntr)(ctp))
		{
		    MLXSTATS(mda_StrayIntrsDone++;)
		    return ctp->cd_IntrActive=0, ERR_NOPACTIVE;
		}
#endif
		if (!(*ctp->cd_ServiceIntr)(ctp)) /* main interrupt handler */
			return ctp->cd_IntrActive=0, 0;
		ctp->cd_IntrActive = 0;
nextintr:       if (!(ctp->cd_Status & MDACD_HOSTMEMAILBOX)) continue;
		if (!(*ctp->cd_HwPendingIntr)(ctp)) continue;
		MLXSTATS(ctp->cd_IntrsDone++;ctp->cd_IntrsDoneWOCmd++;)
		(*ctp->cd_ServiceIntr)(ctp);    /* just in case */
		return 0;
	}
	MLXSTATS(mda_StrayIntrsDone++;)
	return ERR_NOPACTIVE;
}

/* service one interrupt at a time. */
u32bits MLXFAR
mdac_oneintr(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u32bits cmdidstatus;
	mdac_req_t MLXFAR *rqp;
    u08bits irql;
    mdac_prelock(&irql);
	mdac_ctlr_lock(ctp);
	MLXSTATS(ctp->cd_IntrsDone++;)
	if ((mdac_cmdid(cmdidstatus=(*ctp->cd_ReadCmdIDStatus)(ctp))) > ctp->cd_MaxCmds) goto out_bad;
	if (!(rqp = ctp->cd_cmdid2req[mdac_cmdid(cmdidstatus)])) goto out_bad;
	ctp->cd_cmdid2req[mdac_cmdid(cmdidstatus)] = NULL;
	ctp->cd_ActiveCmds--;
	mdac_free_cmdid(ctp,rqp);
	mdac_setiostatus(ctp,mdac_status(cmdidstatus));
	mdac_ctlr_unlock(ctp);
    mdac_postlock(irql);
	mdac_completereq(ctp,rqp);
	return 0;

out_bad:MLXSTATS(ctp->cd_IntrsDoneSpurious++;) /* spurious interrupt */
	mdac_ctlr_unlock(ctp);
    mdac_postlock(irql);
	return ERR_NOACTIVITY;
}

/* This interrupt service handles multple interrupts at a time */
u32bits MLXFAR
mdac_multintr(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	MLXSTATS(ctp->cd_IntrsDone++;)
	u08bits_write(ctp->cd_SystemDoorBellReg, MDAC_CLEAR_INTR);
	if (mdac_multintrwoack(ctp)) return 0;
	MLXSTATS(ctp->cd_IntrsDoneSpurious++;) /* spurious interrupt */
	return ERR_NOACTIVITY;
}

/* cluster completion macro */
#define mdac_completecluster() \
{ \
	for (ids=0, rqp=hrqp; rqp; rqp=hrqp, ids++) \
	{       /* post all completed request to requester */ \
		hrqp = rqp->rq_Next; \
		ctp = rqp->rq_ctp; \
		if (ctp->cd_TimeTraceEnabled) mdac_tracetime(rqp); \
		if (ctp->cd_CmdsWaiting) mdac_reqstart(ctp); \
		if (ctp->cd_OSCmdsWaiting) mdac_osreqstart(ctp); \
		if ((rqp->rq_OpFlags & MDAC_RQOP_CLUST) && \
		   ((!crqp || (crqp->rq_CompIntr == rqp->rq_CompIntr)))) \
		{       /* queue the clustered request */ \
			rqp->rq_Next = crqp; \
			crqp = rqp; \
			MLXSTATS(mda_ClustCmdsDone++;) \
			continue; \
		} \
		rqp->rq_Next = NULL; \
		(*rqp->rq_CompIntr)(rqp); \
	} \
	if (!crqp) return ids; \
	(*crqp->rq_CompIntr)(crqp); \
	MLXSTATS(mda_ClustCompDone++;) \
	return ids; \
}

/* This interrupt service handles multple interrupts at a time  without ack.
** It returns the number of request processed. This information is used to
** find out if there was a genuine interrupt or not.
*/
u32bits MLXFAR
mdac_multintrwoack(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u32bits ids;                    /* command ID and status */
	mdac_req_t MLXFAR *rqp;
	mdac_req_t MLXFAR *crqp = NULL; /* clustered request queue head */
	mdac_req_t MLXFAR *hrqp = NULL; /* completed request queue head */
    u08bits irql;
    mdac_prelock(&irql);
	mdac_ctlr_lock(ctp);
	while ((*ctp->cd_PendingIntr)(ctp))
	{       /* pick up all interrupt status values possible */
		if (((mdac_cmdid(ids=(*ctp->cd_ReadCmdIDStatus)(ctp))) <= ctp->cd_MaxCmds) &&
		    (rqp = ctp->cd_cmdid2req[mdac_cmdid(ids)]))
		{       /* good interrupt */
			ctp->cd_cmdid2req[mdac_cmdid(ids)] = NULL;
			ctp->cd_ActiveCmds--;
			mdac_free_cmdid(ctp,rqp);
			mdac_setiostatus(ctp,mdac_status(ids));
			rqp->rq_Next = hrqp;
			hrqp = rqp;
			continue;
		}
		MLXSTATS(ctp->cd_CmdsDoneSpurious++;ctp->cd_SpuriousCmdStatID=ids;) /* spurious interrupt */
	}
	mdac_ctlr_unlock(ctp);
    mdac_postlock(irql);
	mdac_completecluster();
}

/* process all interrupts for master and slave controller, return IO completed*/
u32bits MLXFAR
mdac_allmsintr()
{
	mdac_ctldev_t MLXFAR *ctp;
	mdac_req_t MLXFAR *rqp;
	mdac_req_t MLXFAR *crqp = NULL; /* clustered request queue head */
	mdac_req_t MLXFAR *hrqp = NULL; /* completed request queue head */
	u32bits ids;                    /* command ID and status */
    u08bits irql;

	mda_TotalCmdsSentSinceLastIntr = 0; /* Zero Interrupt support */
	for (ctp=mdac_ctldevtbl; ctp<mdac_lastctp; ctp++)
	{
		if (!(ctp->cd_Status & MDACD_PRESENT)) continue;
		if (!(ctp->cd_Status & (MDACD_MASTERINTRCTLR|MDACD_SLAVEINTRCTLR))) continue;
		if (!(*ctp->cd_PendingIntr)(ctp)) continue; /* no interrupt */
        mdac_prelock(&irql);
		mdac_ctlr_lock(ctp);
		while ((*ctp->cd_PendingIntr)(ctp))
		{       /* pick up all interrupt status values possible */
			if (((mdac_cmdid(ids=(*ctp->cd_ReadCmdIDStatus)(ctp))) <= ctp->cd_MaxCmds) &&
			    (rqp = ctp->cd_cmdid2req[mdac_cmdid(ids)]))
			{       /* good interrupt */
				ctp->cd_cmdid2req[mdac_cmdid(ids)] = NULL;
				ctp->cd_ActiveCmds--;
				mdac_free_cmdid(ctp,rqp);
				mdac_setiostatus(ctp,mdac_status(ids));
				rqp->rq_Next = hrqp;
				hrqp = rqp;
				continue;
			}
			MLXSTATS(ctp->cd_CmdsDoneSpurious++;ctp->cd_SpuriousCmdStatID=ids;) /* spurious interrupt */
		}
		mdac_ctlr_unlock(ctp);
        mdac_postlock(irql);
	}
	mdac_completecluster();
}

/* start the pending request, if nothing is pending here start the OS ones */
u32bits MLXFAR
mdac_reqstart(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	mdac_req_t MLXFAR *rqp;
    u08bits irql;
	if (ctp->cd_ActiveCmds >= ctp->cd_MaxCmds) return 0;    /* just for optimization */
next:   
    mdac_prelock(&irql);
    mdac_ctlr_lock(ctp);
	if (ctp->cd_ActiveCmds >= ctp->cd_MaxCmds) goto out;    /* no room */
	dqreq(ctp,rqp);
	mdac_ctlr_unlock(ctp);
    mdac_postlock(irql);
	if (!rqp) return mdac_osreqstart(ctp);  /* start OS request */
	(*rqp->rq_StartReq)(rqp);               /* start this request */
	if (ctp->cd_Status & MDACD_HOSTMEMAILBOX) 
	    if (!(((*ctp->cd_CheckMailBox)(ctp)))) 
		goto next; /* if mailbox free, start one more cmd */
	return 0;
out:    mdac_ctlr_unlock(ctp); 
        mdac_postlock(irql);
	return 0;
}
/*====================INTERRUPT HANDLING CODE ENDS========================*/

/*==========================================================================
** Some SCSI commands need to be faked, since they don't apply to system
** drives (RAIDed disks). Meaningful information is returned in each case.
** This is very dependent on the SCSI-2 spec and you really need to have it
** handy to understand all the magic numbers used here. Comments are added
** for clarity. Can't just send the CDB down the cable, since it's not a
** physical device we're talking about. Instead, We have to issue a
** DAC_SYS_DEV_INFO command, get the system drives data and return a
** meaningful status upstream. Unsolicited sense info is returned.
*/

#define dp      ((u08bits MLXFAR *)(rqp + 2))

u32bits MLXFAR
mdac_fake_scdb(ctp,osrqp,devno,cmd, cdbp, datalen)
mdac_ctldev_t   MLXFAR *ctp;
OSReq_t         MLXFAR *osrqp;
u32bits         devno,cmd;
u08bits         MLXFAR *cdbp;
u32bits         datalen;
{
	mdac_req_t MLXFAR *rqp;
	mdac_alloc_req_ret(ctp,rqp,osrqp,MLXERR_NOMEM);
	rqp->rq_ctp = ctp;
	mlx_kvtophyset(rqp->rq_PhysAddr,ctp,rqp);
#if 1
	rqp->rq_FinishTime=mda_CurTime + (rqp->rq_TimeOut=ncmdp->nc_TimeOut=40);
#endif
	rqp->rq_OSReqp = osrqp;
	rqp->rq_SysDevNo = (u08bits)devno;
	rqp->rq_FakeSCSICmd = (u16bits)cmd;
	rqp->rq_CompIntr = mdac_fake_scdb_intr;
	rqp->rq_DataSize = datalen;
	dcmdp->mb_Command = DACMD_DRV_INFO;
	dcmdp->mb_Datap=mlx_kvtophys(ctp, dp); MLXSWAP(dcmdp->mb_Datap);
	dcmdp->mb_SysDevNo = (u08bits)devno;

	if (!(ctp->cd_Status & MDACD_CLUSTER_NODE)) return mdac_send_cmd(rqp);

	/* clustering support */

	switch (cmd) {
	    case UCSCMD_TESTUNITREADY:
		dcmdp->mb_Command = DACMD_TUR_SYSTEM_DRIVE;
		break;
	    case UCSCMD_INQUIRY:
		dcmdp->mb_Command = DACMD_INQUIRE_SYSTEM_DRIVE;
		dcmdp->mb_ChannelNo = datalen & 0xFF;
		dcmdp->mb_TargetID = (datalen >> 8) & 0xFF;
		break;
	    case UCSCMD_READCAPACITY:
		dcmdp->mb_Command = DACMD_CAPACITY_SYSTEM_DRIVE;
		break;
	    case UCSCMD_RESERVE:
		dcmdp->mb_Command = DACMD_RESERVE_SYSTEM_DRIVE;
		dcmdp->mb_ChannelNo = cdbp[1];
		dcmdp->mb_TargetID = cdbp[2];
		dcmdp->mb_DevState = cdbp[3];
		dcmdp->mb_MailBox5 = cdbp[4];
		break;
	    case UCSCMD_RELEASE:
		dcmdp->mb_Command = DACMD_RELEASE_SYSTEM_DRIVE;
		dcmdp->mb_ChannelNo = cdbp[1];
		dcmdp->mb_TargetID = cdbp[2];
		break;
	    case DACMD_RESET_SYSTEM_DRIVE:
		dcmdp->mb_Command = DACMD_RESET_SYSTEM_DRIVE;
		dcmdp->mb_ChannelNo = (devno == 0xFF) ? 0 : 0xFF;
		break;
	}
	return mdac_send_cmd(rqp);
}

u32bits MLXFAR
mdac_fake_scdb_intr(rqp)
mdac_req_t MLXFAR *rqp;
{
	u32bits dev, cmd;
	OSReq_t         MLXFAR *osrqp = rqp->rq_OSReqp;
	dac_sd_info_t   MLXFAR *sip = (dac_sd_info_t MLXFAR *)dp;
	mdac_ctldev_t   MLXFAR *ctp = rqp->rq_ctp;

	if (dcmdp->mb_Status) goto out_nolun;
	if ((ctp->cd_Status & MDACD_CLUSTER_NODE) &&
	    (rqp->rq_FakeSCSICmd != DACMD_DRV_INFO))  goto out_good;

	for (dev=0; dev<ctp->cd_MaxSysDevs; sip++, dev++)
	{
		if ((sip->sdi_DevSize == 0xFFFFFFFF) || (sip->sdi_DevSize == 0))
			goto out_nolun;         /* The end of table */
		if (dev != rqp->rq_SysDevNo) continue; /* keep looking */
		switch (sip->sdi_DevState) /* We got the required device */
		{
		case DAC_SYS_DEV_ONLINE:        goto out_good; /* GOK OLD STATES */
		case DAC_SYS_DEV_CRITICAL:      goto out_good; /* GOK OLD STATES */
		case DAC_SYS_DEV_OFFLINE:
			mdac_create_sense_data(rqp,UCSK_NOTREADY,UCSASC_TARGETINERR);
			goto out_err;
		}
	}

out_nolun: mdac_create_sense_data(rqp,UCSK_NOTREADY,UCSASC_LUNOTSUPPORTED); /* no Lun */
out_err:mdac_fake_scdb_done(rqp,NULL,0,(ucscsi_exsense_t MLXFAR *)rqp->rq_scdb.db_SenseData);
	mdac_free_req(ctp,rqp);
	return(0);

out_good:/* We are here to process good status */

	switch(rqp->rq_FakeSCSICmd & 0xFF)
	{
	case UCSCMD_INQUIRY:

/*jhr	if (! (ctp->cd_Status & MDACD_CLUSTER_NODE)) */	/* Always fake the inquriy data. */
														/* What comes back from the adapter is */
														/* not correct for normal SCSI-2 operations. */
														/* jhr */

		mdac_create_inquiry(ctp,(ucscsi_inquiry_t MLXFAR *)dp,UCSTYP_DAD);
		mdac_fake_scdb_done(rqp,dp,mlx_min(rqp->rq_DataSize, ucscsi_inquiry_s),NULL);
		mdac_free_req(ctp,rqp);
		return(0);

	case UCSCMD_READCAPACITY:
#define cp      ((ucsdrv_capacity_t MLXFAR *)(rqp+1))

		if (!(ctp->cd_Status & MDACD_CLUSTER_NODE))
		{
		    cp->ucscap_seclen3 = (DAC_BLOCKSIZE>>24);
		    cp->ucscap_seclen2 = (DAC_BLOCKSIZE>>16);
		    cp->ucscap_seclen1 = (DAC_BLOCKSIZE>>8);
		    cp->ucscap_seclen0 = DAC_BLOCKSIZE & 0xFF;
		    dev=mlxswap(sip->sdi_DevSize)-1; /* SCSI standard is last block */
		    cp->ucscap_capsec3 = (dev >> 24);
		    cp->ucscap_capsec2 = (dev >> 16);
		    cp->ucscap_capsec1 = (dev >> 8);
		    cp->ucscap_capsec0 = (dev & 0xFF);
		    mdac_fake_scdb_done(rqp,(u08bits MLXFAR*)cp,mlx_min(rqp->rq_DataSize, ucsdrv_capacity_s),NULL);
		}
		else
		    mdac_fake_scdb_done(rqp,(u08bits MLXFAR*)dp,mlx_min(rqp->rq_DataSize, ucsdrv_capacity_s),NULL);
		mdac_free_req(ctp,rqp);
		return(0);
#undef  cp
	case UCSCMD_REQUESTSENSE:
		mdac_get_sense_data(ctp->cd_ControllerNo,rqp->rq_SysDevNo,dp);
		mdac_fake_scdb_done(rqp,dp,ucscsi_exsense_s,NULL);
		mdac_free_req(ctp,rqp);
		return(0);

	case UCSCMD_MODESENSEG0:
	case UCSCMD_MODESENSEG1:
		cmd = rqp->rq_FakeSCSICmd;
		dev = mlxswap(sip->sdi_DevSize);
#define mhp     ((ucs_modeheader_t MLXFAR *)(rqp+1))
		mdaczero(mhp, mdac_req_s);
		mhp->ucsmh_device_specific = 0; /* ADD DPO and FUA required */
		mhp->ucsmh_bdesc_length = ucs_blockdescriptor_s;
#define bdp     ((ucs_blockdescriptor_t MLXFAR *)(mhp+1))
		bdp->ucsbd_blks2 = (DAC_BLOCKSIZE>>16);
		bdp->ucsbd_blks1 = (DAC_BLOCKSIZE>>8);
		bdp->ucsbd_blks0 = DAC_BLOCKSIZE & 0xFF;
		bdp->ucsbd_blksize2 = dev >> 16;
		bdp->ucsbd_blksize1 = dev >> 8;
		bdp->ucsbd_blksize0 = dev & 0xFF;
		switch((cmd >> 8) & 0x3F)
		{
		case UCSCSI_MODESENSEPAGE3: 
#define msp     ((ucs_mode_format_t MLXFAR *)(bdp+1))
			mhp->ucsmh_length = ucs_modeheader_s + ucs_blockdescriptor_s + ucs_mode_format_s - 1;
			msp->mf_pagecode = UCSCSI_MODESENSEPAGE3;
			msp->mf_pagelen = ucs_mode_format_s - 2 ;
			msp->mf_track_size = ctp->cd_BIOSTrackSize; NETSWAP(msp->mf_track_size);
			msp->mf_sector_size = DAC_BLOCKSIZE; NETSWAP(msp->mf_sector_size);
			msp->mf_alt_tracks_zone = 1; NETSWAP(msp->mf_alt_tracks_zone);
			msp->mf_alt_tracks_vol = 1; NETSWAP(msp->mf_alt_tracks_vol);
			mdac_fake_scdb_done(rqp,(u08bits MLXFAR*)mhp,
			ucs_modeheader_s + ucs_blockdescriptor_s + ucs_mode_format_s,NULL);
			mdac_free_req(ctp,rqp);
			return(0);
#undef msp

		case UCSCSI_MODESENSEPAGE4:
#define mgp     ((ucs_mode_geometry_t MLXFAR *)(bdp+1))
			mhp->ucsmh_length = ucs_modeheader_s + ucs_blockdescriptor_s + ucs_mode_geometry_s - 1;
			mgp->mg_pagecode = UCSCSI_MODESENSEPAGE4;
			mgp->mg_pagelen  = ucs_mode_geometry_s - 2;
			dev = dev / (ctp->cd_BIOSHeads * ctp->cd_BIOSTrackSize);
			mgp->mg_cyl2 = dev >> 16;       /* number of cylinders */
			mgp->mg_cyl1 = dev >> 8;
			mgp->mg_cyl0 = dev & 0xFF;
			mgp->mg_heads = ctp->cd_BIOSHeads;      /* number of heads */
			mgp->mg_rpm = 10000;    NETSWAP(mgp->mg_rpm);
			mdac_fake_scdb_done(rqp,(u08bits MLXFAR*)mhp,
			ucs_modeheader_s + ucs_blockdescriptor_s + ucs_mode_geometry_s,NULL);
			mdac_free_req(ctp,rqp);
			return(0);
#undef mgp
		} /* switch FakeSCSICmd */
#undef mdp
#undef mhp
		break;
	case UCSCMD_VERIFYG0:
	case UCSCMD_VERIFY:
	case UCSCMD_TESTUNITREADY:
	case UCSCMD_STARTSTOP:
	case UCSCMD_DOORLOCKUNLOCK:
	case UCSCMD_SEEK:
	case UCSCMD_ESEEK:
	case UCSCMD_RESERVE:
	case UCSCMD_RELEASE:
	case DACMD_RESET_SYSTEM_DRIVE:
		mdac_fake_scdb_done(rqp,NULL,0,NULL);
		mdac_free_req(ctp,rqp);
		return(0);
	}
	mdac_create_sense_data(rqp,UCSK_ILLREQUEST,UCSASC_INVFIELDINCDB);
	goto out_err;
}
#undef dp

/*==========================READ/WRITE STARTS=============================*/
/* send read/write command, enter here interrupt protected */
u32bits MLXFAR
mdac_send_rwcmd_v2x(ctp,osrqp,devno,cmd,blk,sz,timeout)
mdac_ctldev_t   MLXFAR *ctp;
OSReq_t         MLXFAR *osrqp;
u32bits         devno,cmd,blk,sz,timeout;
{
	mdac_req_t MLXFAR *rqp;
	if (ctp->cd_CmdsWaiting>=ctp->cd_MaxCmds) return ERR_BUSY; /*too many*/
	mdac_alloc_req_ret(ctp,rqp,osrqp,MLXERR_NOMEM);
	rqp->rq_OSReqp = osrqp;
	rqp->rq_FinishTime = mda_CurTime + (rqp->rq_TimeOut=timeout);
	dcmdp->mb_Command = (u08bits)cmd;
	MLXSTATS(ctp->cd_CmdsDone++;)
	rqp->rq_OpFlags |= MDAC_RQOP_CLUST;
	rqp->rq_DataSize = sz; rqp->rq_ResdSize = sz;
	rqp->rq_SysDevNo = (u08bits)devno; rqp->rq_BlkNo = blk;
	rqp->rq_DataOffset = 0; dcmd4p->mb_MailBoxC_F = 0;
	if ((sz > MDAC_SGTXSIZE) && (!rqp->rq_LSGVAddr))
		if (!(mdac_setuplsglvaddr(rqp))) /* setup large SG list memory */
			return (MLXERR_NOMEM);       
	if (mdac_setupdma_32bits(rqp)) goto outdmaq;    /* we should que in DMA stopped que */
	if (dcmdp->mb_MailBoxC = (u08bits) rqp->rq_SGLen)
		dcmdp->mb_Command |= DACMD_WITHSG;      /* command has SG List */

	if (rqp->rq_DMASize < sz) goto out_big;
	dcmdp->mb_Datap = rqp->rq_DMAAddr.bit31_0; MLXSWAP(dcmdp->mb_Datap);
	dcmd4p->mb_MailBox4_7 = blk; MLXSWAP(dcmd4p->mb_MailBox4_7);
	dcmdp->mb_MailBox3 = (blk >> (24-6)) & 0xC0;
	dcmdp->mb_SysDevNo = (u08bits)devno;     /* This must come after block setup */
	dcmdp->mb_MailBox2 = mdac_bytes2blks(sz);
	rqp->rq_CompIntr = mdac_rwcmdintr;
	return mdac_send_cmd(rqp);
out_big:
	MLXSTATS(ctp->cd_CmdsDoneBig++;)
	rqp->rq_CompIntrBig = mdac_rwcmdintr;
	return mdac_send_rwcmd_v2x_big(rqp);

outdmaq: /* queue the request for DMA resource */
	rqp->rq_CompIntrBig = mdac_rwcmdintr;
	rqp->rq_StartReq = mdac_send_rwcmd_v2x_big;     /* we will be called later */
	dmaqreq(ctp, rqp);      /* queue the request, it will start later */
	return 0;
}

/* clustered command completion */
u32bits MLXFAR
mdac_send_rwcmd_v2x_bigcluster(rqp)
mdac_req_t MLXFAR *rqp;
{
	mdac_req_t MLXFAR *srqp;
	for ( ; rqp ; rqp=srqp)
		srqp=rqp->rq_Next, mdac_send_rwcmd_v2x_big(rqp);
	return 0;
}

u32bits MLXFAR
mdac_send_rwcmd_v2x_big(rqp)
mdac_req_t MLXFAR *rqp;
{
	u32bits sz;
	if (mdac_setupdma_32bits(rqp)) goto outdmaq;    /* DMA stopped queue */
	if (dcmdp->mb_MailBoxC = (u08bits)rqp->rq_SGLen)
		dcmdp->mb_Command |= DACMD_WITHSG;      /* command has SG List */
	else
		dcmdp->mb_Command &= ~DACMD_WITHSG;     /* command does not have SG List*/
	dcmdp->mb_Datap = rqp->rq_DMAAddr.bit31_0; MLXSWAP(dcmdp->mb_Datap);
	sz = rqp->rq_DMASize;
	rqp->rq_ResdSize -= sz;         /* remaining size for next request */
	rqp->rq_DataOffset += sz;       /* data covered until next request */
	dcmd4p->mb_MailBox4_7 = rqp->rq_BlkNo; MLXSWAP(dcmd4p->mb_MailBox4_7);
	dcmdp->mb_MailBox3 = (rqp->rq_BlkNo >> (24-6)) & 0xC0;
	dcmdp->mb_SysDevNo = rqp->rq_SysDevNo;  /* must be after block setup */
	sz = mdac_bytes2blks(sz);
	dcmdp->mb_MailBox2 = (u08bits)sz;
	rqp->rq_BlkNo += sz;            /* Block number for next request */
	rqp->rq_CompIntr = (!rqp->rq_ResdSize)? rqp->rq_CompIntrBig :
		((rqp->rq_OpFlags & MDAC_RQOP_CLUST)?
		mdac_send_rwcmd_v2x_bigcluster : mdac_send_rwcmd_v2x_big);
	return (dcmdp->mb_Status)? (*rqp->rq_CompIntrBig)(rqp) : mdac_send_cmd(rqp);

outdmaq:        /* queue the request for DMA resource */
	rqp->rq_StartReq = mdac_send_rwcmd_v2x_big;     /* we will be called later */
	dmaqreq(rqp->rq_ctp, rqp);
	return 0;
}

u32bits MLXFAR
mdac_send_rwcmd_v3x(ctp,osrqp,devno,cmd,blk,sz,timeout)
mdac_ctldev_t   MLXFAR *ctp;
OSReq_t         MLXFAR *osrqp;
u32bits         devno,cmd,blk,sz,timeout;
{
	mdac_req_t MLXFAR *rqp;
	mdac_alloc_req_ret(ctp,rqp,osrqp,MLXERR_NOMEM);
	rqp->rq_OSReqp = osrqp;
	rqp->rq_FinishTime = mda_CurTime + (rqp->rq_TimeOut=timeout);
	dcmdp->mb_Command = (u08bits)cmd;
	MLXSTATS(ctp->cd_CmdsDone++;)
	rqp->rq_OpFlags |= MDAC_RQOP_CLUST;
	rqp->rq_DataSize = sz; rqp->rq_ResdSize = sz;
	rqp->rq_SysDevNo = (u08bits)devno; rqp->rq_BlkNo = blk;
	rqp->rq_DataOffset=0; dcmd4p->mb_MailBoxC_F=0;
	if ((sz > MDAC_SGTXSIZE) && (!rqp->rq_LSGVAddr))
		if (!(mdac_setuplsglvaddr(rqp))) /* setup large SG list memory */
			return (MLXERR_NOMEM);       
	if (mdac_setupdma_32bits(rqp)) goto outdmaq;    /* we should que in DMA stopped queue */
	if (dcmdp->mb_MailBoxC = (u08bits)rqp->rq_SGLen)
		dcmdp->mb_Command |= DACMD_WITHSG;      /* command has SG List */
	if (rqp->rq_DMASize < sz) goto out_big;
	dcmdp->mb_Datap = rqp->rq_DMAAddr.bit31_0; MLXSWAP(dcmdp->mb_Datap);
	dcmd4p->mb_MailBox4_7 = blk; MLXSWAP(dcmd4p->mb_MailBox4_7);
	sz = mdac_bytes2blks(sz);
	dcmdp->mb_MailBox2 = (u08bits)sz;
	dcmdp->mb_MailBox3 = (devno<<3) + (sz>>8) + (cmd>>8);
	rqp->rq_CompIntr = mdac_rwcmdintr;
	mdac_16to32bcmdiff(rqp);        /* change 16 byte cmd to 32 bytes iff possible */
	return mdac_send_cmd(rqp);

out_big:MLXSTATS(ctp->cd_CmdsDoneBig++;)
	dcmdp->mb_StatusID = (cmd>>8); /* save Read/Write Cmd FUA/DPO bits */
	rqp->rq_CompIntrBig = mdac_rwcmdintr;
	return mdac_send_rwcmd_v3x_big(rqp);

outdmaq:/* queue the request for DMA resource */
	dcmdp->mb_StatusID = (cmd>>8); /* save Read/Write Cmd FUA/DPO bits */
	rqp->rq_CompIntrBig = mdac_rwcmdintr;
	rqp->rq_StartReq = mdac_send_rwcmd_v3x_big;/* we will be called later */
	dmaqreq(ctp,rqp);       /* queue the request, it will start later */
	return 0;
}

u32bits MLXFAR
mdac_send_rwcmd_v3x_bigcluster(rqp)
mdac_req_t MLXFAR *rqp;
{
	mdac_req_t MLXFAR *srqp;
	for ( ; rqp ; rqp=srqp)
		srqp=rqp->rq_Next, mdac_send_rwcmd_v3x_big(rqp);
	return 0;
}

u32bits MLXFAR
mdac_send_rwcmd_v3x_big(rqp)
mdac_req_t MLXFAR *rqp;
{
	u32bits sz;
	if (mdac_setupdma_32bits(rqp)) goto outdmaq;    /*  DMA stopped queue */
	if (dcmdp->mb_MailBoxC = (u08bits)rqp->rq_SGLen)
		dcmdp->mb_Command |= DACMD_WITHSG;      /* command has SG List */
	else
		dcmdp->mb_Command &= ~DACMD_WITHSG;     /* command does not have SG List */
	dcmdp->mb_Datap = rqp->rq_DMAAddr.bit31_0; MLXSWAP(dcmdp->mb_Datap);
	sz = rqp->rq_DMASize;
	rqp->rq_ResdSize -= sz;         /* remaining size for next request */
	rqp->rq_DataOffset += sz;       /* data covered until next request */
	dcmd4p->mb_MailBox4_7=rqp->rq_BlkNo; MLXSWAP(dcmd4p->mb_MailBox4_7);
	sz = mdac_bytes2blks(sz);
	rqp->rq_BlkNo += sz;            /* Block number for next request */
	dcmdp->mb_MailBox2 = (u08bits)sz;
	dcmdp->mb_MailBox3 = (rqp->rq_SysDevNo<<3) + (sz>>8) + dcmdp->mb_StatusID;
	mdac_16to32bcmdiff(rqp);        /* change 16 byte cmd to 32 bytes iff possible */
	rqp->rq_CompIntr = (!rqp->rq_ResdSize)? rqp->rq_CompIntrBig :
		((rqp->rq_OpFlags & MDAC_RQOP_CLUST)?
		mdac_send_rwcmd_v3x_bigcluster : mdac_send_rwcmd_v3x_big);
	return (dcmdp->mb_Status)? (*rqp->rq_CompIntrBig)(rqp) : mdac_send_cmd(rqp);

outdmaq:/* queue the request for DMA resource */
	rqp->rq_StartReq = mdac_send_rwcmd_v3x_big;/* we will be called later */
	dmaqreq(rqp->rq_ctp,rqp);       /* queue the request, it will start later */
	return 0;
}

/* #if defined(_WIN64) || defined(SCSIPORT_COMPLIANT)  */
/* #ifdef NEVER */ // problems associated w/ mlx_copyin

/* send user direct command to controller, enter here interrupt protected */
u32bits MLXFAR
mdac_user_dcmd(ctp,ucp)
mdac_ctldev_t   MLXFAR *ctp;
mda_user_cmd_t  MLXFAR *ucp;
{
#define dp      (((u08bits MLXFAR *)rqp) + MDAC_PAGESIZE)
	mdac_req_t      MLXFAR *rqp;
	if (ctp->cd_Status & MDACD_NEWCMDINTERFACE) return MLXERR_INVAL;
	if (ucp->ucmd_DataSize > MDACA_MAXUSERCMD_DATASIZE) return ERR_BIGDATA;
	if (!(rqp=(mdac_req_t MLXFAR *)mdac_alloc8kb(ctp))) return ERR_NOMEM;
	mlx_kvtophyset(rqp->rq_PhysAddr,ctp,rqp);
	if ((ucp->ucmd_TransferType == DAC_XFER_WRITE) &&
	    (mlx_copyin(ucp->ucmd_Datap,dp,ucp->ucmd_DataSize)))
		mdac_free8kbret(ctp,rqp,ERR_FAULT);
	rqp->rq_ctp = ctp;
	rqp->rq_Poll = 1;
	rqp->rq_DacCmd = ucp->ucmd_cmd;
	dcmdp->mb_Command &= ~DACMD_WITHSG; /* No Scatter/gather */
	dcmdp->mb_Datap = (u32bits)mlx_kvtophys(ctp,dp); MLXSWAP(dcmdp->mb_Datap);
	rqp->rq_CompIntr = mdac_req_pollwake;
	rqp->rq_FinishTime = mda_CurTime + (rqp->rq_TimeOut=ucp->ucmd_TimeOut);
	if (mdac_send_cmd(rqp)) mdac_free8kbret(ctp,rqp,ERR_IO);
	mdac_req_pollwait(rqp);
	ucp->ucmd_Status = dcmdp->mb_Status;
	if ((ucp->ucmd_TransferType == DAC_XFER_READ) &&
	    (mlx_copyout(dp,ucp->ucmd_Datap,ucp->ucmd_DataSize)))
		mdac_free8kbret(ctp,rqp,ERR_FAULT);
	mdac_free8kbret(ctp,rqp,0);
#undef  dp
}

/* #endif */	// NEVER
/* #endif */	// _WIN64 or SCSIPORT_COMPLIANT

/* Read Write entry for logical drives. Currently called from NT disk driver */
#ifdef MLX_OS2
u32bits MLXFAR _loadds 
#else
u32bits MLXFAR
#endif
mdac_readwrite(rqp)
mdac_req_t MLXFAR *rqp;
{
	mdac_ctldev_t MLXFAR *ctp = &mdac_ctldevtbl[rqp->rq_ControllerNo];
	if (rqp->rq_ControllerNo >= mda_Controllers) return ERR_NODEV;
	rqp->rq_ResdSize = rqp->rq_DataSize;
	rqp->rq_ResdSizeBig = rqp->rq_DataSize;		/* @KawaseForMacdisk */
	rqp->rq_ctp = ctp;
	dcmd4p->mb_MailBoxC_F=0;
	rqp->rq_FinishTime = mda_CurTime + rqp->rq_TimeOut;

	if (ctp->cd_Status & MDACD_NEWCMDINTERFACE)
	{
	    ncmdp->nc_Command = MDACMD_SCSI;
	    ncmdp->nc_TargetID = rqp->rq_TargetID;
	    ncmdp->nc_ChannelNo = rqp->rq_ChannelNo;
	    ncmdp->nc_LunID = 0;
	}

	switch(dcmdp->mb_Command)
	{
	case 0:
		ncmdp->nc_CCBits = MDACMDCCB_WRITE;
		dcmdp->mb_Command = nscdbp->ucs_cmd = ctp->cd_WriteCmd;
		MLXSTATS(ctp->cd_Writes++;ctp->cd_WriteBlks+=rqp->rq_DataSize>>9;)
		break;
	default:
		ncmdp->nc_CCBits = MDACMDCCB_READ;
		dcmdp->mb_Command = nscdbp->ucs_cmd = ctp->cd_ReadCmd;
		MLXSTATS(ctp->cd_Reads++;ctp->cd_ReadBlks+=rqp->rq_DataSize>>9;)
		break;
	}

	/*
	 * NT MACDisk driver does not set these fields.
	 *
	 * Set these fields the first time. Once set, they will be valid for this
	 * rqp forever.
	 */
	if (! rqp->rq_MaxDMASize)
	{
#if 0	/* @KawaseForMacdisk	- Set these in macdisk driver. */
	    rqp->rq_SGVAddr = (mdac_sglist_t MLXFAR *)&rqp->rq_SGList;
		mlx_kvtophyset(rqp->rq_SGPAddr,ctp,rqp->rq_SGVAddr);
#endif
	    rqp->rq_MaxSGLen = (ctp->cd_Status & MDACD_NEWCMDINTERFACE)? MDAC_MAXSGLISTSIZENEW : MDAC_MAXSGLISTSIZE;
	    rqp->rq_MaxDMASize = (rqp->rq_MaxSGLen & ~1) * MDAC_PAGESIZE;
	}

	/*
	 * Setup buffer for Large Scattger/Gather list once per rqp.
	 */
	if ((rqp->rq_DataSize > MDAC_SGTXSIZENEW) && (!rqp->rq_LSGVAddr))
		if (!(mdac_setuplsglvaddr(rqp))) /* setup large SG list memory */
			return (MLXERR_NOMEM);       

	return (*(ctp->cd_SendRWCmdBig))(rqp);
}

#ifdef MLX_DOS
u32bits MLXFAR
mdac_dosreadwrite(rqp)
mdac_req_t MLXFAR *rqp;
{
	mdac_ctldev_t MLXFAR *ctp = &mdac_ctldevtbl[rqp->rq_ControllerNo];
	if (rqp->rq_ControllerNo >= mda_Controllers) return ERR_NODEV;
	rqp->rq_ResdSize = rqp->rq_DataSize;
	rqp->rq_ctp = ctp;
	dcmd4p->mb_MailBoxC_F=0;
	rqp->rq_FinishTime = mda_CurTime + rqp->rq_TimeOut;
	if (ctp->cd_Status & MDACD_NEWCMDINTERFACE)
	{
		ncmdp->nc_Command = MDACMD_SCSI;
		ncmdp->nc_TargetID = rqp->rq_TargetID;
		ncmdp->nc_LunID = rqp->rq_LunID;
		ncmdp->nc_ChannelNo = rqp->rq_ChannelNo;
	}
	switch(dcmdp->mb_Command)
	{
		case 0:
			if (ctp->cd_Status & MDACD_NEWCMDINTERFACE)
				ncmdp->nc_CCBits = MDACMDCCB_WRITE;
			dcmdp->mb_Command = nscdbp->ucs_cmd = ctp->cd_WriteCmd;
			MLXSTATS(ctp->cd_Writes++;ctp->cd_WriteBlks+=rqp->rq_DataSize>>9;)
		break;
		default:
			if (ctp->cd_Status & MDACD_NEWCMDINTERFACE)
				ncmdp->nc_CCBits = MDACMDCCB_READ;
			dcmdp->mb_Command = nscdbp->ucs_cmd = ctp->cd_ReadCmd;
			MLXSTATS(ctp->cd_Reads++;ctp->cd_ReadBlks+=rqp->rq_DataSize>>9;)
		break;
	}
	return (*(ctp->cd_SendRWCmdBig))(rqp);
}
#endif
/*==========================READ/WRITE ENDS===============================*/

/*==========================NEW COMMAND INTERFACE STARTS==================*/
u32bits MLXFAR
mdac_send_newcmd(ctp,osrqp,ch,tgt,lun,cdbp,cdbsz,sz,ccb,timeout)
mdac_ctldev_t   MLXFAR *ctp;
OSReq_t         MLXFAR *osrqp;
u08bits         MLXFAR *cdbp;
u32bits         ch,tgt,lun,sz,cdbsz,ccb,timeout;
{
	u08bits MLXFAR *dp;
	mdac_req_t MLXFAR *rqp;
	u64bits phys_cdbp;

	mdac_alloc_req_ret(ctp,rqp,osrqp,MLXERR_NOMEM);
	rqp->rq_OSReqp = osrqp;
	rqp->rq_FinishTime = mda_CurTime + (rqp->rq_TimeOut=timeout);
	ncmdp->nc_TimeOut = (u08bits) timeout;
	ncmdp->nc_Command = (cdbsz > 10 ) ? MDACMD_SCSILC : MDACMD_SCSI;
	ncmdp->nc_CCBits = (u08bits) ccb;
	ncmdp->nc_LunID = rqp->rq_LunID = (u08bits)lun;
	ncmdp->nc_TargetID = rqp->rq_TargetID = (u08bits)tgt;
	ncmdp->nc_ChannelNo = rqp->rq_ChannelNo = (u08bits)ch;
	ncmdp->nc_CdbLen = (u08bits)cdbsz;
	dp = ncmdp->nc_Cdb;

	switch(ncmdp->nc_CdbLen)
	{/* do not move more than one byte because cdbp may not be aligned */
	case 10:
		*(dp+0) = *(cdbp+0);    *(dp+1) = *(cdbp+1);
		*(dp+2) = *(cdbp+2);    *(dp+3) = *(cdbp+3);
		*(dp+4) = *(cdbp+4);    *(dp+5) = *(cdbp+5);
		*(dp+6) = *(cdbp+6);    *(dp+7) = *(cdbp+7);
		*(dp+8) = *(cdbp+8);    *(dp+9) = *(cdbp+9);
		break;
	case 6:
		*(dp+0) = *(cdbp+0);    *(dp+1) = *(cdbp+1);
		*(dp+2) = *(cdbp+2);    *(dp+3) = *(cdbp+3);
		*(dp+4) = *(cdbp+4);    *(dp+5) = *(cdbp+5);
		break;
	default:
		mlx_kvtophyset(phys_cdbp,ctp,cdbp);
		MLXSWAP(phys_cdbp);
		*((u64bits  MLXFAR *) &ncmdp->nc_CdbPtr) = phys_cdbp;
		break;
	}

	MLXSTATS(ctp->cd_CmdsDone++;)

#ifdef MLX_NT
#else
	rqp->rq_OpFlags |= MDAC_RQOP_CLUST;
#endif

	rqp->rq_DataSize = sz;  rqp->rq_ResdSize = sz, rqp->rq_ResdSizeBig = sz;
	rqp->rq_DataOffset = 0;

	/* uncomment the three lines below per the original code */
	if ((sz > MDAC_SGTXSIZENEW) && (!rqp->rq_LSGVAddr))			
		if (!(mdac_setuplsglvaddr(rqp))) 	 /* setup large SG list memory */
			return (MLXERR_NOMEM);	

	if (mdac_setupdma_64bits(rqp))
	{       /* we should que in DMA stopped queue */
		rqp->rq_DMASize = 0;
		goto outdmaq;
	}
	mdac_setupnewcmdmem(rqp);
	if (rqp->rq_DMASize < sz) goto out_big;
	rqp->rq_ResdSize = 0;                   /* no more data to transfer */
	rqp->rq_CompIntr = mdac_newcmd_intr;
	return mdac_send_cmd(rqp);
	
out_big:MLXSTATS(ctp->cd_CmdsDoneBig++;)
outdmaq:
	switch (nscdbp->ucs_cmd)
	{       /* get the block and check right command for breakup */
	case UCSCMD_READ:
	case UCSCMD_WRITE:
		rqp->rq_BlkNo = UCSGETG0ADDR(nscdbp);
		break;
	case UCSCMD_EWRITEVERIFY:
	case UCSCMD_EWRITE:
	case UCSCMD_EREAD:
		rqp->rq_BlkNo = UCSGETG1ADDR(nscdbp);
		break;
	default:
		if (!rqp->rq_DMASize) break;    /* no DMA resource */
		dcmdp->mb_Status = DACMDERR_INVALID_PARAMETER;
		return mdac_newcmd_intr(rqp);
	}

	rqp->rq_CompIntrBig = mdac_newcmd_intr; 	/* JB */
	return mdac_send_newcmd_big(rqp);		/* JB */

	ncmdp->nc_TimeOut = (u08bits)rqp->rq_TimeOut;
	rqp->rq_FinishTime = mda_CurTime + rqp->rq_TimeOut;
	sz = rqp->rq_DMASize;
	rqp->rq_ResdSizeBig -= sz;         /* remaining size for next request */
	rqp->rq_DataOffset += sz;       /* data covered until next request */
	sz = mdac_bytes2blks(sz);
	switch (nscdbp->ucs_cmd)
	{       /* get the block and check right command for breakup */
	case UCSCMD_READ:
	case UCSCMD_WRITE:
		UCSMAKECOM_G0(nscdbp,nscdbp->ucs_cmd,0,rqp->rq_BlkNo,sz);
		ncmdp->nc_CdbLen = (u08bits)6;
		break;
	case UCSCMD_EWRITEVERIFY:
	case UCSCMD_EWRITE:
	case UCSCMD_EREAD:
		UCSMAKECOM_G1(nscdbp,nscdbp->ucs_cmd,0,rqp->rq_BlkNo,sz);
		ncmdp->nc_CdbLen = 10;
		break;
	default:
			if (!rqp->rq_ResdSizeBig) 
				break;   /* this was due to DMA resource */

		dcmdp->mb_Status = DACMDERR_INVALID_PARAMETER;
		return (*rqp->rq_CompIntrBig)(rqp);
	}

	rqp->rq_BlkNo += sz;            /* Block number for next request */

	rqp->rq_CompIntrBig = mdac_newcmd_intr;	 /*jhr - Used for last S/G completion */
	rqp->rq_CompIntr = mdac_send_newcmd_big; /*jhr - Used for 2nd and subsequent segments. */

	return ( mdac_send_cmd(rqp) );

}

u32bits MLXFAR
mdac_send_newcmd_bigcluster(rqp)
mdac_req_t MLXFAR *rqp;
{
	mdac_req_t MLXFAR *srqp;
	for ( ; rqp ; rqp=srqp)
		srqp=rqp->rq_Next, mdac_send_newcmd_big(rqp);
	return 0;
}

u32bits MLXFAR
mdac_send_newcmd_big(rqp)
mdac_req_t MLXFAR *rqp;
{
	u32bits sz;
	rqp->rq_ResdSize = rqp->rq_ResdSizeBig;	/*jhr - refresh rq_ResdSize because mdac_setiostatus
													corrupts it.
											 */

	if (mdac_setupdma_64bits(rqp)) goto outdmaq;    /*  DMA stopped queue */
	mdac_setupnewcmdmem(rqp);
	ncmdp->nc_TimeOut = (u08bits)rqp->rq_TimeOut;
	rqp->rq_FinishTime = mda_CurTime + rqp->rq_TimeOut;
	sz = rqp->rq_DMASize;
	rqp->rq_ResdSizeBig -= sz;         /* remaining size for next request */
	rqp->rq_DataOffset += sz;       /* data covered until next request */
	sz = mdac_bytes2blks(sz);
	switch (nscdbp->ucs_cmd)
	{       /* get the block and check right command for breakup */
	case UCSCMD_READ:
	case UCSCMD_WRITE:
		UCSMAKECOM_G0(nscdbp,nscdbp->ucs_cmd,0,rqp->rq_BlkNo,sz);
		ncmdp->nc_CdbLen = (u08bits)6;
		break;
	case UCSCMD_EWRITEVERIFY:
	case UCSCMD_EWRITE:
	case UCSCMD_EREAD:
		UCSMAKECOM_G1(nscdbp,nscdbp->ucs_cmd,0,rqp->rq_BlkNo,sz);
		ncmdp->nc_CdbLen = 10;
		break;
	default:
			if (!rqp->rq_ResdSizeBig) 
				break;   /* this was due to DMA resource */

		dcmdp->mb_Status = DACMDERR_INVALID_PARAMETER;
		return (*rqp->rq_CompIntrBig)(rqp);
	}

	rqp->rq_BlkNo += sz;            /* Block number for next request */

	rqp->rq_CompIntr = (!rqp->rq_ResdSizeBig)? mdac_newcmd_intr : mdac_send_newcmd_big;

/*
	rqp->rq_CompIntr = (!rqp->rq_ResdSize)? rqp->rq_CompIntrBig :
		((rqp->rq_OpFlags & MDAC_RQOP_CLUST)?
		mdac_send_newcmd_bigcluster : mdac_send_newcmd_big);
*/
#if 1	/* @KawaseForMacdisk - Hold Call Back routine of macdisk driver. */
	rqp->rq_CompIntr = (!rqp->rq_ResdSizeBig)? rqp->rq_CompIntrBig :
		((rqp->rq_OpFlags & MDAC_RQOP_CLUST)?
		mdac_send_newcmd_bigcluster : mdac_send_newcmd_big);
#endif

	/* jhr - if mb_Status is non-zero fail the command */
	return (dcmdp->mb_Status)? (*rqp->rq_CompIntrBig)(rqp) : mdac_send_cmd(rqp);

outdmaq:/* queue the request for DMA resource */
	rqp->rq_StartReq = mdac_send_newcmd_big;/* we will be called later */
	dmaqreq(rqp->rq_ctp,rqp);       /* queue the request, it will start later */
	return 0;
}
/*==========================NEW COMMAND INTERFACE ENDS====================*/

/*==========================SCDB STARTS=====================================*/
/* send SCSI command, enter here interrupt protected */
u32bits MLXFAR
mdac_send_scdb(ctp,osrqp,pdp,sz,cdbp,cdbsz,dirbits,timeout)
mdac_ctldev_t   MLXFAR *ctp;
OSReq_t         MLXFAR *osrqp;
mdac_physdev_t  MLXFAR *pdp;
u08bits         MLXFAR *cdbp;
u32bits         sz,cdbsz,dirbits,timeout;
{
	mdac_req_t      MLXFAR *rqp;
	mdac_alloc_req_ret(ctp,rqp,osrqp,MLXERR_NOMEM);
	rqp->rq_pdp = pdp;
	rqp->rq_OSReqp = osrqp;
	rqp->rq_FinishTime = mda_CurTime + (rqp->rq_TimeOut=timeout);
	dcdbp->db_ChannelTarget = ChanTgt(pdp->pd_ChannelNo,pdp->pd_TargetID);
	MLXSTATS(ctp->cd_SCDBDone++;)
	return mdac_send_scdb_req(rqp,sz,cdbp,cdbsz,dirbits);
}

#ifdef MLX_SMALLSGLIST

u32bits MLXFAR
mdac_send_scdb_req(rqp,sz,cdbp,cdbsz,dirbits)
mdac_req_t      MLXFAR *rqp;
u08bits         MLXFAR *cdbp;
u32bits         sz,cdbsz,dirbits;
{
	mdac_physdev_t  MLXFAR *pdp=rqp->rq_pdp;
	mdac_ctldev_t   MLXFAR *ctp=rqp->rq_ctp;
	rqp->rq_CompIntr = mdac_send_scdb_intr;
	dcdbp->db_CdbLen = mlx_min(cdbsz,DAC_CDB_LEN);
	mdaccopy(cdbp,dcdbp->db_Cdb,dcdbp->db_CdbLen);
	dcdbp->db_DATRET = dirbits;
#if defined MLX_NT
	if (rqp->rq_OSReqp)
	    dcdbp->db_SenseLen = mlx_min(DAC_SENSE_LEN, (((OSReq_t *)rqp->rq_OSReqp)->SenseInfoBufferLength));
	else
	    dcdbp->db_SenseLen = DAC_SENSE_LEN;
#else
	dcdbp->db_SenseLen = DAC_SENSE_LEN;
#endif
	dcdbp->db_StatusIn=0; dcdbp->db_Reserved1=0;
	dcmd4p->mb_MailBox0_3=0;dcmd4p->mb_MailBox4_7=0;dcmd4p->mb_MailBoxC_F=0;
	dcmdp->mb_Command = DACMD_DCDB;
	if (!(pdp->pd_Status & MDACPDS_PRESENT)) goto out_ck;/* not present */
	if (sz > ctp->cd_MaxSCDBTxSize) goto out_big;
	mdac_setcdbtxsize(sz);
	mdac_setupdma(rqp);
	mdac_setscdbsglen(ctp);
	if (!(pdp->pd_Status & MDACPDS_BIGTX)) return mdac_send_cmd_scdb(rqp);
	 /* big transfer was there, do not change the flag for normal op */
	mdac_link_lock();
	switch(pdp->pd_DevType)
	{
	case UCSTYP_DAD:
	case UCSTYP_WORMD:
	case UCSTYP_OMDAD:
	case UCSTYP_RODAD:
		if ((scdbp->ucs_cmd != UCSCMD_READ) &&
		    (scdbp->ucs_cmd != UCSCMD_EREAD) &&
		    (scdbp->ucs_cmd != UCSCMD_WRITE) &&
		    (scdbp->ucs_cmd != UCSCMD_EWRITE) &&
		    (scdbp->ucs_cmd != UCSCMD_EWRITEVERIFY))
			pdp->pd_Status &= ~MDACPDS_BIGTX;
		break;
	case UCSTYP_SAD:
		if ((scdbp->ucs_cmd != UCSCMD_READ) && (scdbp->ucs_cmd != UCSCMD_WRITE))
			pdp->pd_Status &= ~MDACPDS_BIGTX;
		break;
	default: pdp->pd_Status &= ~MDACPDS_BIGTX; break;
	}
	mdac_link_unlock();
	return mdac_send_cmd_scdb(rqp);

out_ck: /* device is not present, check its presense */
	MLXSTATS(ctp->cd_PhysDevTestDone++;)
	rqp->rq_StartReq = mdac_test_physdev;   /* called later, if required */
	rqp->rq_DataSize = sz;                  /* save size value */
	rqp->rq_DataOffset = dirbits;           /* save dirbits value */
	rqp->rq_PollWaitChan = (u32bits)cdbp;   /* save cdbp value */
	rqp->rq_Poll = cdbsz;                   /* save cdbsz value */
	scdbp->ucs_cmd = UCSCMD_INIT;           /* let start from beg */
	mdac_link_lock();
	if (pdp->pd_Status & MDACPDS_BUSY) goto out_q;
	pdp->pd_Status |= MDACPDS_BUSY; /* mark device busy */
	mdac_link_unlock();
	return mdac_test_physdev(rqp);

out_big:/* We have big SCDB, try to break it up */
	if (!(pdp->pd_Status & MDACPDS_BIGTX))
	{
		mdac_link_lock_st(pdp->pd_Status|=MDACPDS_BIGTX);
		goto out_ck;
	}
	MLXSTATS(ctp->cd_SCDBDoneBig++;)
	rqp->rq_DataSize = sz; rqp->rq_ResdSize = sz; rqp->rq_ResdSizeBig = sz;
	rqp->rq_DataOffset = 0;
	switch(pdp->pd_DevType)
	{
	case UCSTYP_DAD:
	case UCSTYP_WORMD:
	case UCSTYP_OMDAD:
	case UCSTYP_RODAD:
		switch(scdbp->ucs_cmd)
		{
		case UCSCMD_EREAD:
		case UCSCMD_EWRITE:
		case UCSCMD_EWRITEVERIFY:
			rqp->rq_BlkNo = UCSGETG1ADDR(scdbp);
			goto out_bigend;
		case UCSCMD_READ:
		case UCSCMD_WRITE:
			rqp->rq_BlkNo = UCSGETG0ADDR(scdbp);
			goto out_bigend;
		}
		return mdac_send_scdb_err(rqp,UCSK_ILLREQUEST,UCSASC_INVFIELDINCDB);
	case UCSTYP_SAD:
		switch(scdbp->ucs_cmd)
		{
		case UCSCMD_READ:
		case UCSCMD_WRITE:
			if (scdbp->s_tag&1) goto out_bigend;/*fix bit set*/
		}
		return mdac_send_scdb_err(rqp,UCSK_ILLREQUEST,UCSASC_INVFIELDINCDB);
	default: return mdac_send_scdb_err(rqp,UCSK_ILLREQUEST,UCSASC_INVFIELDINCDB);
	}
out_bigend:
	rqp->rq_StartReq = mdac_send_scdb_big;  /* called later if required */
	rqp->rq_CompIntrBig = mdac_send_scdb_intr;
	mdac_link_lock();
	if (pdp->pd_Status & MDACPDS_BUSY) goto out_q;
	pdp->pd_Status |= MDACPDS_BUSY;         /* mark device busy */
	mdac_link_unlock();
	return mdac_send_scdb_big(rqp);

out_q:  pdqreq(ctp,rqp,pdp);
	mdac_link_unlock();
	return 0;
}

u32bits MLXFAR
mdac_send_scdb_big(rqp)
mdac_req_t MLXFAR *rqp;
{
	u32bits sz = mlx_min(rqp->rq_DataSize,rqp->rq_ctp->cd_MaxSCDBTxSize);
	u32bits blks = sz / (rqp->rq_pdp->pd_BlkSize*DAC_BLOCKSIZE);
	switch(rqp->rq_pdp->pd_DevType)
	{
	case UCSTYP_DAD:
	case UCSTYP_WORMD:
	case UCSTYP_OMDAD:
	case UCSTYP_RODAD:
		switch(scdbp->ucs_cmd)
		{
		case UCSCMD_EREAD:
		case UCSCMD_EWRITE:
		case UCSCMD_EWRITEVERIFY:
			UCSSETG1ADDR(scdbp,rqp->rq_BlkNo);
			UCSSETG1COUNT(scdbp,blks);
			break;
		case UCSCMD_READ:
		case UCSCMD_WRITE:
			UCSSETG0ADDR(scdbp,rqp->rq_BlkNo);
			UCSSETG0COUNT(scdbp,blks);
			break;
		}
		break;
	case UCSTYP_SAD:
		UCSSETG0COUNT_S(scdbp,blks);
		break;
	}
	mdac_setcdbtxsize(sz);
	mdac_setupdma_big(rqp,sz);
	mdac_setscdbsglen(rqp->rq_ctp);
	rqp->rq_BlkNo += blks;          /* Block number for next request */
	rqp->rq_DataSize -= sz;         /* remaining size for next request */
	rqp->rq_DataOffset += sz;       /* data covered until next request */
	rqp->rq_CompIntr=(rqp->rq_DataSize)? mdac_send_scdb_big : rqp->rq_CompIntrBig;
	return (dcmdp->mb_Status)? (*rqp->rq_CompIntrBig)(rqp):mdac_send_cmd(rqp);
}

#else // MLX_SMALLSGLIST

u32bits MLXFAR
mdac_send_scdb_req(rqp,sz,cdbp,cdbsz,dirbits)
mdac_req_t      MLXFAR *rqp;
u08bits         MLXFAR *cdbp;
u32bits         sz,cdbsz,dirbits;
{
	mdac_physdev_t  MLXFAR *pdp=rqp->rq_pdp;
	mdac_ctldev_t   MLXFAR *ctp=rqp->rq_ctp;
	rqp->rq_CompIntr = mdac_send_scdb_intr;
	dcdbp->db_CdbLen = mlx_min(cdbsz,DAC_CDB_LEN);
	mdaccopy(cdbp,dcdbp->db_Cdb,dcdbp->db_CdbLen);
	dcdbp->db_DATRET = (u08bits)dirbits;
#if defined MLX_NT
	if (rqp->rq_OSReqp)
	    dcdbp->db_SenseLen = mlx_min(DAC_SENSE_LEN, (((OSReq_t *)rqp->rq_OSReqp)->SenseInfoBufferLength));
	else
	    dcdbp->db_SenseLen = DAC_SENSE_LEN;
#else
	dcdbp->db_SenseLen = DAC_SENSE_LEN;
#endif
	dcdbp->db_StatusIn=0; dcdbp->db_Reserved1=0;
	dcmd4p->mb_MailBox0_3=0;dcmd4p->mb_MailBox4_7=0;dcmd4p->mb_MailBoxC_F=0;
	rqp->rq_DataOffset = 0;
	dcmdp->mb_Command = DACMD_DCDB;
	if (!(pdp->pd_Status & MDACPDS_PRESENT)) goto out_ck;/* not present */
	if ((sz > MDAC_SGTXSIZE) && (! rqp->rq_LSGVAddr))
		if (!(mdac_setuplsglvaddr(rqp))) /* setup large SG list memory */
			return (MLXERR_NOMEM);       
	rqp->rq_ResdSize = sz; rqp->rq_ResdSizeBig = sz;
#if 0
	if (mdac_setupdma_32bits(rqp)) goto outdmaq;    /* we should que in DMA stopped queue */
#else
	mdac_setupdma_32bits(rqp);
#endif
	if (rqp->rq_DMASize < sz) goto out_big;

	if (rqp->rq_SGLen)
	    dcmdp->mb_Command |= DACMD_WITHSG;
	mdac_setcdbtxsize(rqp->rq_DMASize);
	mdac_setscdbsglen(ctp);


	if (!(pdp->pd_Status & (u08bits)MDACPDS_BIGTX)) return mdac_send_cmd_scdb(rqp);
	 /* big transfer was there, do not change the flag for normal op */
	mdac_link_lock();
	switch(pdp->pd_DevType)
	{
	case UCSTYP_DAD:
	case UCSTYP_WORMD:
	case UCSTYP_OMDAD:
	case UCSTYP_RODAD:
		if ((scdbp->ucs_cmd != UCSCMD_READ) &&
		    (scdbp->ucs_cmd != UCSCMD_EREAD) &&
		    (scdbp->ucs_cmd != UCSCMD_WRITE) &&
		    (scdbp->ucs_cmd != UCSCMD_EWRITE) &&
		    (scdbp->ucs_cmd != UCSCMD_EWRITEVERIFY))
			pdp->pd_Status &= ~MDACPDS_BIGTX;
		break;
	case UCSTYP_SAD:
		if ((scdbp->ucs_cmd != UCSCMD_READ) && (scdbp->ucs_cmd != UCSCMD_WRITE))
			pdp->pd_Status &= ~MDACPDS_BIGTX;
		break;
	default: pdp->pd_Status &= ~MDACPDS_BIGTX; break;
	}
	mdac_link_unlock();
	return mdac_send_cmd_scdb(rqp);

out_ck: /* device is not present, check its presense */
	MLXSTATS(ctp->cd_PhysDevTestDone++;)
	rqp->rq_StartReq = mdac_test_physdev;   /* called later, if required */
	rqp->rq_DataSize = sz;                  /* save size value */
	rqp->rq_DataOffset = dirbits;           /* save dirbits value */
	rqp->rq_PollWaitChan = (UINT_PTR)cdbp;	/* save cdbp value */
	rqp->rq_Poll = cdbsz;                   /* save cdbsz value */
	scdbp->ucs_cmd = UCSCMD_INIT;           /* let start from beg */
	mdac_link_lock();
	if (pdp->pd_Status & MDACPDS_BUSY) goto out_q;
	pdp->pd_Status |= MDACPDS_BUSY; /* mark device busy */
	mdac_link_unlock();
	return mdac_test_physdev(rqp);

out_big:/* We have big SCDB, try to break it up */
	if (!(pdp->pd_Status & MDACPDS_BIGTX))
	{
		mdac_link_lock_st(pdp->pd_Status|=MDACPDS_BIGTX);
		goto out_ck;
	}
	MLXSTATS(ctp->cd_SCDBDoneBig++;)
	rqp->rq_DataSize = sz; rqp->rq_ResdSize = sz; rqp->rq_ResdSizeBig = sz;
	rqp->rq_DataOffset = 0;
	switch(pdp->pd_DevType)
	{
	case UCSTYP_DAD:
	case UCSTYP_WORMD:
	case UCSTYP_OMDAD:
	case UCSTYP_RODAD:
		switch(scdbp->ucs_cmd)
		{
		case UCSCMD_EREAD:
		case UCSCMD_EWRITE:
		case UCSCMD_EWRITEVERIFY:
			rqp->rq_BlkNo = UCSGETG1ADDR(scdbp);
			goto out_bigend;
		case UCSCMD_READ:
		case UCSCMD_WRITE:
			rqp->rq_BlkNo = UCSGETG0ADDR(scdbp);
			goto out_bigend;
		}
		return mdac_send_scdb_err(rqp,UCSK_ILLREQUEST,UCSASC_INVFIELDINCDB);
	case UCSTYP_SAD:
		switch(scdbp->ucs_cmd)
		{
		case UCSCMD_READ:
		case UCSCMD_WRITE:
			if (scdbp->s_tag&1) goto out_bigend;/*fix bit set*/
		}
		return mdac_send_scdb_err(rqp,UCSK_ILLREQUEST,UCSASC_INVFIELDINCDB);
	default: return mdac_send_scdb_err(rqp,UCSK_ILLREQUEST,UCSASC_INVFIELDINCDB);
	}
out_bigend:
	rqp->rq_StartReq = mdac_send_scdb_big;  /* called later if required */
	rqp->rq_CompIntrBig = mdac_send_scdb_intr;
	mdac_link_lock();
	if (pdp->pd_Status & MDACPDS_BUSY) goto out_q;
	pdp->pd_Status |= MDACPDS_BUSY;         /* mark device busy */
	mdac_link_unlock();
	return mdac_send_scdb_big(rqp);

out_q:  pdqreq(ctp,rqp,pdp);
	mdac_link_unlock();
	return 0;
}

u32bits MLXFAR
mdac_send_scdb_big(rqp)
mdac_req_t MLXFAR *rqp;
{
	u32bits sz, blks;

#if 0
	if (mdac_setupdma_32bits(rqp)) goto outdmaq;    /* DMA stopped queue */
#else
	mdac_setupdma_32bits(rqp);
#endif
	
	sz = mlx_min(rqp->rq_ResdSizeBig, rqp->rq_DMASize);
	blks = sz / (rqp->rq_pdp->pd_BlkSize*DAC_BLOCKSIZE);

	switch(rqp->rq_pdp->pd_DevType)
	{
	case UCSTYP_DAD:
	case UCSTYP_WORMD:
	case UCSTYP_OMDAD:
	case UCSTYP_RODAD:
		switch(scdbp->ucs_cmd)
		{
		case UCSCMD_EREAD:
		case UCSCMD_EWRITE:
		case UCSCMD_EWRITEVERIFY:
			UCSSETG1ADDR(scdbp,rqp->rq_BlkNo);
			UCSSETG1COUNT(scdbp,blks);
			break;
		case UCSCMD_READ:
		case UCSCMD_WRITE:
			UCSSETG0ADDR(scdbp,rqp->rq_BlkNo);
			UCSSETG0COUNT(scdbp,blks);
			break;
		}
		break;
	case UCSTYP_SAD:
		UCSSETG0COUNT_S(scdbp,blks);
		break;
	}
	mdac_setcdbtxsize(rqp->rq_DMASize);
	mdac_setscdbsglen(rqp->rq_ctp);
	rqp->rq_BlkNo += blks;          /* Block number for next request */
	rqp->rq_DataSize -= sz;         /* remaining size for next request */
	rqp->rq_ResdSizeBig -= sz;         /* remaining size for next request */
	rqp->rq_DataOffset += sz;       /* data covered until next request */
	rqp->rq_CompIntr=(rqp->rq_DataSize)? mdac_send_scdb_big : rqp->rq_CompIntrBig;
	return (dcmdp->mb_Status)? (*rqp->rq_CompIntrBig)(rqp):mdac_send_cmd(rqp);
}

#endif // MLX_SMALLSGLIST

u32bits MLXFAR
mdac_test_physdev(rqp)
mdac_req_t MLXFAR *rqp;
{
	mdac_physdev_t MLXFAR *pdp = rqp->rq_pdp;
	if (dcmdp->mb_Status)
	{       /* it is possible */
		if (scdbp->ucs_cmd != UCSCMD_INQUIRY) goto out_ok;
		return mdac_send_scdb_intr(rqp);
	}
	dcdbp->db_SenseLen = DAC_SENSE_LEN;
	if (scdbp->ucs_cmd == UCSCMD_INIT)
	{       /* get inquiry data */
		rqp->rq_CompIntr = mdac_test_physdev;
		dcdbp->db_DATRET = DAC_DCDB_XFER_READ|DAC_DCDB_DISCONNECT|DAC_DCDB_TIMEOUT_10sec;
		dcdbp->db_CdbLen = UCSGROUP0_LEN;
		mdac_setcdbtxsize(ucscsi_inquiry_s);
		UCSMAKECOM_G0(scdbp,UCSCMD_INQUIRY,pdp->pd_LunID,0,(u32bits)ucscsi_inquiry_s);
		dcdbp->db_PhysDatap=rqp->rq_PhysAddr.bit31_0+offsetof(mdac_req_t,rq_SGList);
		MLXSWAP(dcdbp->db_PhysDatap);
		dcmdp->mb_Datap=rqp->rq_PhysAddr.bit31_0+offsetof(mdac_req_t,rq_scdb);
		MLXSWAP(dcmdp->mb_Datap);
		return mdac_send_cmd(rqp);
	}
	if (scdbp->ucs_cmd == UCSCMD_INQUIRY)
	{
#define inqp    ((ucscsi_inquiry_t MLXFAR *)rqp->rq_SGList)
		if (inqp->ucsinq_dtqual & UCSQUAL_RMBDEV) goto out_pres;
		if ((inqp->ucsinq_dtype == UCSTYP_NOTPRESENT) ||
		    (inqp->ucsinq_dtype == UCSTYP_HOST) ||
		    (inqp->ucsinq_dtype == UCSTYP_HOSTRAID) ||
		    ((inqp->ucsinq_dtype == UCSTYP_DAD))) /* && !rqp->rq_ctp->cd_ControllerNo)) */
		{       /* do not allow access on disk */
			rqp->rq_CompIntr = mdac_send_scdb_intr;
			return mdac_send_scdb_err(rqp,UCSK_NOTREADY,UCSASC_LUNOTSUPPORTED);
		}
out_pres:       mdac_link_lock_st(pdp->pd_Status|=MDACPDS_PRESENT);
		switch(pdp->pd_DevType=inqp->ucsinq_dtype)
		{
		default: goto out_ok;
		case UCSTYP_DAD:
		case UCSTYP_WORMD:
		case UCSTYP_OMDAD:
		case UCSTYP_RODAD:
			dcdbp->db_CdbLen = UCSGROUP1_LEN;
			mdac_setcdbtxsize(ucsdrv_capacity_s);
			UCSMAKECOM_G1(scdbp,UCSCMD_READCAPACITY,pdp->pd_LunID,0,0);
			return mdac_send_cmd(rqp);
		case UCSTYP_SAD:
			dcdbp->db_CdbLen = UCSGROUP0_LEN;
			mdac_setcdbtxsize(ucstmode_s);
			UCSMAKECOM_G0(scdbp,UCSCMD_MODESENSEG0,pdp->pd_LunID,0,(u32bits)ucstmode_s);
			return mdac_send_cmd(rqp);
		}
#undef  inqp
	}
	if (scdbp->ucs_cmd == UCSCMD_READCAPACITY)      /* Block device */
		if (!(pdp->pd_BlkSize = mdac_bytes2blks(UCSGETDRVSECLEN(((ucsdrv_capacity_t MLXFAR *)rqp->rq_SGList)))))
			pdp->pd_BlkSize = 1;
	if (scdbp->ucs_cmd == UCSCMD_MODESENSEG0) /* sequential device (tape) */
		if (!(pdp->pd_BlkSize = mdac_bytes2blks(ucstmodegetseclen((ucstmode_t MLXFAR *)rqp->rq_SGList))))
			pdp->pd_BlkSize = 1;
out_ok: mdac_link_lock_st(pdp->pd_Status&=~MDACPDS_BUSY);/* let be free for mdac_send_scdb_req */

#if defined(_WIN64) || defined(SCSIPORT_COMPLIANT) 
	return mdac_send_scdb_req(rqp,rqp->rq_DataSize,(u08bits MLXFAR*)rqp->rq_PollWaitChan,((u32bits)rqp->rq_Poll),rqp->rq_DataOffset);
#else
	return mdac_send_scdb_req(rqp,rqp->rq_DataSize,(u08bits MLXFAR*)rqp->rq_PollWaitChan,rqp->rq_Poll,rqp->rq_DataOffset);
#endif
}

u32bits MLXFAR
mdac_send_scdb_err(rqp,key,asc)
mdac_req_t MLXFAR *rqp;
u32bits key,asc;
{
	mdac_create_sense_data(rqp,key,asc);
	rqp->rq_Next = NULL;
	(*rqp->rq_CompIntr)(rqp);
	return 0;
}

/* send scsi command to hardware if possible otherwise queue it */
u32bits MLXFAR
mdac_send_cmd_scdb(rqp)
mdac_req_t MLXFAR *rqp;
{
	mdac_physdev_t MLXFAR *pdp=rqp->rq_pdp;
	mdac_link_lock();
	if (!(pdp->pd_Status & MDACPDS_BUSY))
	{       /* device is is not busy, mark it busy */
		pdp->pd_Status |= MDACPDS_BUSY;
		mdac_link_unlock();
		return mdac_send_cmd(rqp);
	}
	rqp->rq_StartReq=mdac_send_cmd; /* device is busy, let it start later */
	pdqreq(rqp->rq_ctp,rqp,pdp);
	mdac_link_unlock();
	return 0;
}

u32bits MLXFAR
mdac_start_next_scdb(pdp)
mdac_physdev_t MLXFAR *pdp;
{
	mdac_req_t MLXFAR *rqp;
	mdac_link_lock();
	if (!(rqp=pdp->pd_FirstWaitingReq))
	{       /* nothing is pending */
		pdp->pd_Status &= ~MDACPDS_BUSY;
		mdac_link_unlock();
		return 0;
	}
	/* start the next request */
	pdp->pd_FirstWaitingReq=rqp->rq_Next;
	rqp->rq_ctp->cd_SCDBWaiting--;
	mdac_link_unlock();
	return (*rqp->rq_StartReq)(rqp);
}


/* #if defined(_WIN64) || defined(SCSIPORT_COMPLIANT)  */
/* #ifdef NEVER */ // problems associated w/ mlx_copyin


/* send user SCSI command to device */
u32bits MLXFAR
mdac_user_dcdb(ctp,ucp)
mdac_ctldev_t   MLXFAR *ctp;
mda_user_cdb_t  MLXFAR *ucp;
{
#define dp      (((u08bits MLXFAR *)rqp) + MDAC_PAGESIZE)
	mdac_req_t      MLXFAR *rqp;
	if (ctp->cd_Status & MDACD_NEWCMDINTERFACE) return MLXERR_INVAL;
	if (ucp->ucdb_ChannelNo >= ctp->cd_MaxChannels) return ERR_NODEV;
	if (ucp->ucdb_TargetID >= ctp->cd_MaxTargets) return ERR_NODEV;
	if (ucp->ucdb_LunID >= ctp->cd_MaxLuns) return ERR_NODEV;
	if (ucp->ucdb_DataSize > MDACA_MAXUSERCDB_DATASIZE) return ERR_BIGDATA;
	if (!(rqp=(mdac_req_t MLXFAR *)mdac_alloc8kb(ctp))) return ERR_NOMEM;
	mlx_kvtophyset(rqp->rq_PhysAddr,ctp,rqp);
	if ((ucp->ucdb_TransferType == DAC_XFER_WRITE) &&
	    (mlx_copyin(ucp->ucdb_Datap,dp,ucp->ucdb_DataSize)))
		mdac_free8kbret(ctp,rqp,ERR_FAULT);
	rqp->rq_pdp=dev2pdp(ctp,ucp->ucdb_ChannelNo,ucp->ucdb_TargetID,ucp->ucdb_LunID);
	rqp->rq_ctp = ctp;
	rqp->rq_Poll = 1;
	rqp->rq_CompIntr = mdac_req_pollwake;   /* Callback function */
	mdaccopy(ucp->ucdb_scdb.db_Cdb,dcdbp->db_Cdb, DAC_CDB_LEN);
	mlx_kvtophyset(rqp->rq_PhysAddr,ctp,rqp);
	dcdbp->db_SenseLen = DAC_SENSE_LEN;
	dcdbp->db_DATRET = (ucp->ucdb_scdb.db_DATRET|DAC_DCDB_DISCONNECT)& ~DAC_DCDB_EARLY_STATUS;
	rqp->rq_TimeOut = mdac_dactimeout2timeout(dcdbp->db_DATRET & DAC_DCDB_TIMEOUT_MASK);
	rqp->rq_FinishTime = mda_CurTime + rqp->rq_TimeOut;
	dcdbp->db_ChannelTarget=ChanTgt(ucp->ucdb_ChannelNo,ucp->ucdb_TargetID);
	dcdbp->db_CdbLen = ucp->ucdb_scdb.db_CdbLen;
	mdac_setcdbtxsize(ucp->ucdb_DataSize);
	dcmdp->mb_Command = DACMD_DCDB;
	dcdbp->db_PhysDatap = mlx_kvtophys(ctp,dp); MLXSWAP(dcdbp->db_PhysDatap);
	dcmdp->mb_Datap = rqp->rq_PhysAddr.bit31_0 + offsetof(mdac_req_t, rq_scdb); 
	MLXSWAP(dcmdp->mb_Datap);
	mdac_send_cmd_scdb(rqp);
	mdac_req_pollwait(rqp);
	mdac_start_next_scdb(rqp->rq_pdp);
	ucp->ucdb_scdb.db_CdbLen = dcdbp->db_CdbLen;
	ucp->ucdb_scdb.db_TxSize = mlxswap(dcdbp->db_TxSize);
	ucp->ucdb_scdb.db_StatusIn = dcdbp->db_StatusIn;
	ucp->ucdb_Status = dcmdp->mb_Status;
	ucp->ucdb_scdb.db_SenseLen = dcdbp->db_SenseLen;
	mdaccopy(dcdbp->db_SenseData,ucp->ucdb_scdb.db_SenseData,DAC_SENSE_LEN);
	if ((ucp->ucdb_TransferType == DAC_XFER_READ) &&
	    (mlx_copyout(dp,ucp->ucdb_Datap,ucp->ucdb_DataSize)))
		mdac_free8kbret(ctp,rqp,ERR_FAULT);
	mdac_free8kbret(ctp,rqp,0);
#undef  dp
}

/* #endif */ //NEVER
/* #endif */ //_WIN64 or SCSIPORT_COMPLIANT

/*==========================SCDB ENDS=======================================*/

/*==========================TIMER STARTS====================================*/
#ifdef MLX_DOS
/* start scan requests waiting in the scan que */
u32bits MLXFAR
mdac_start_scanq()
{
    mdac_req_t MLXFAR *srqp, *rqp;

    if (! mdac_scanq) return 0;

    mdac_link_lock();
    srqp = mdac_scanq;
    mdac_scanq = NULL;
    mdac_link_unlock();

    for (rqp = srqp; rqp; rqp = srqp)
    {
	srqp = rqp->rq_Next;
	rqp->rq_Next = NULL;
	(*rqp->rq_StartReq)(rqp);               /* start this request */
    }

    return 0;
}
#endif /* MLX_DOS */


#if defined(_WIN64) || defined(SCSIPORT_COMPLIANT) 
#ifdef NEVER  // problems associated w/ MLXSPL,etc.

void    MLXFAR
mdac_timer()
{
	MLXSPLVAR;
	mdac_ctldev_t MLXFAR *ctp, MLXFAR *lastctp;
	if (!mdac_driver_ready) return; /* driver is stopping */
	MLXSPL();
	mda_CurTime = MLXCLBOLT() / MLXHZ;
	if (mda_ttWaitCnts && (mdac_ttwaitime<mda_CurTime)) mdac_wakeup(&mdac_ttwaitchan);
	MLXSTATS(mda_TimerDone++;)
	for (ctp=mdac_ctldevtbl,lastctp=mdac_lastctp; ctp<lastctp; ctp++)
	{
		if (!(ctp->cd_Status & MDACD_PRESENT)) continue;
		if (ctp->cd_CmdsWaiting) mdac_checkcmdtimeout(ctp);
		if (ctp->cd_SCDBWaiting) mdac_checkcdbtimeout(ctp);
	}
#ifdef MLX_DOS
	/* Start scan requests waiting in the mdac_scanq. */
	mdac_start_scanq();
#endif /* MLX_DOS */
	MLXSPLX();
	mlx_timeout(mdac_timer,MDAC_IOSCANTIME);
}
#else

void    MLXFAR
mdac_timer()
{
}

#endif // NEVER

#endif //_WIN64 or SCSIPORT_COMPLIANT

/* remove request from queue, return 0 if OK. enter with proper lock */
u32bits MLXFAR
mdac_removereq(chp,rqp)
mdac_reqchain_t MLXFAR *chp;
mdac_req_t      MLXFAR *rqp;
{
	mdac_req_t MLXFAR *srqp=chp->rqc_FirstReq;
	if (srqp == rqp)
	{       /* remove first entry from chain */
		chp->rqc_FirstReq = srqp->rq_Next;
		return 0;
	}
	for (; srqp; srqp=srqp->rq_Next)
	{       /* let us scan in the chain */
		if (srqp->rq_Next != rqp) continue;
		srqp->rq_Next=rqp->rq_Next;
		if (rqp->rq_Next) rqp->rq_Next = NULL;
		else chp->rqc_LastReq = srqp;
		return 0;
	}
	return ERR_NOENTRY;
}



/* Return timedout request ptr else 0. enter with proper lock */
mdac_req_t MLXFAR *
mdac_checktimeout(chp)
mdac_reqchain_t MLXFAR *chp;
{
	mdac_req_t MLXFAR *rqp;
	for (rqp=chp->rqc_FirstReq; rqp; rqp=rqp->rq_Next)
	{
		if (rqp->rq_FinishTime >= mda_CurTime) continue;
		if (rqp->rq_FinishTime)
		{       /* Just Notice it, we will timeout next time */
			rqp->rq_FinishTime = 0;
			MLXSTATS(rqp->rq_ctp->cd_CmdTimeOutNoticed++;)
			return 0;/* one is enough, next one will be next time */
		}
		MLXSTATS(rqp->rq_ctp->cd_CmdTimeOutDone++;)
		mdac_removereq(chp,rqp);
		dcmdp->mb_Status = DCMDERR_DRIVERTIMEDOUT;
		return rqp;
	}
	return 0;
}

void    MLXFAR
mdac_checkcmdtimeout(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	mdac_req_t MLXFAR *rqp;
    u08bits irql;
    mdac_prelock(&irql);
	mdac_ctlr_lock(ctp);
	if (rqp = mdac_checktimeout(&ctp->cd_WaitingReqQ))
	{
		ctp->cd_CmdsWaiting--;
		mdac_ctlr_unlock(ctp);
        mdac_postlock(irql);

/* #if (!defined(_WIN64)) || (!defined(SCSIPORT_COMPLIANT))  */
		if (ctp->cd_TimeTraceEnabled) mdac_tracetime(rqp);
/* #endif */
		rqp->rq_Next = NULL;
		(*rqp->rq_CompIntr)(rqp);
		return;
	}
	mdac_ctlr_unlock(ctp);
    mdac_postlock(irql);
	if (ctp->cd_ActiveCmds < ctp->cd_MaxCmds) mdac_reqstart(ctp);
}

void    MLXFAR
mdac_checkcdbtimeout(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	mdac_req_t      MLXFAR *rqp;
	mdac_physdev_t  MLXFAR *pdp;
	mdac_link_lock();
	for (pdp=ctp->cd_PhysDevTbl; pdp<ctp->cd_Lastpdp; pdp++)
	{
		if (!pdp->pd_FirstWaitingReq) continue;
		if (!(rqp=mdac_checktimeout(&pdp->pd_WaitingReqQ))) continue;
		ctp->cd_SCDBWaiting--;
		mdac_link_unlock();

/* #if (!defined(_WIN64)) || (!defined(SCSIPORT_COMPLIANT))  */
		if (ctp->cd_TimeTraceEnabled) mdac_tracetime(rqp);
/* #endif */
		rqp->rq_Next = NULL;
		(*rqp->rq_CompIntr)(rqp);
		return;
	}
	mdac_link_unlock();
}
/*==========================TIMER ENDS======================================*/

/*=====================GAM INTERFACE STARTS=================================*/


/* #if defined(_WIN64) || defined(SCSIPORT_COMPLIANT)  */
/* #ifdef NEVER */ // there are too many compliance problems associated w/ the GAM stuff

u32bits MLXFAR
mdac_gam_scdb_intr(rqp)
mdac_req_t MLXFAR *rqp;
{
	mdac_start_next_scdb(rqp->rq_pdp);
	rqp->rq_CompIntr = rqp->rq_CompIntrBig; /* Restore the function */
	rqp->rq_Next = NULL;
	(*rqp->rq_CompIntr)(rqp);
	return 0;
}

/* send gam cmd */
#ifdef MLX_OS2
u32bits MLXFAR _loadds 
#else
u32bits MLXFAR
#endif
mdac_gam_cmd(rqp)
mdac_req_t MLXFAR *rqp;
{
	MLXSPLVAR; u32bits rc;
	mdac_ctldev_t MLXFAR *ctp = &mdac_ctldevtbl[rqp->rq_ControllerNo];
	if (!(ctp->cd_Status & MDACD_PRESENT))
	{
		return ERR_NODEV;
	}
	if (rqp->rq_ControllerNo >= mda_Controllers) return ERR_NODEV;
	rqp->rq_ctp = ctp;
	rqp->rq_FinishTime = rqp->rq_TimeOut + mda_CurTime;
	if ((dcmdp->mb_Command & ~DACMD_WITHSG) != DACMD_DCDB)
	{      
		if (!(rqp->rq_CompIntr))
		{
#ifdef MLX_NT 
			Gam_Mdac_MisMatch(rqp);
#endif
			return ERR_ILLOP;
		}
		/* direct command, no problem */
		MLXSPL();
		rc = mdac_send_cmd(rqp);
		MLXSPLX();
		return rc;
	}
	if (rqp->rq_ChannelNo >= ctp->cd_MaxChannels) return ERR_NODEV;
	if (rqp->rq_TargetID >= ctp->cd_MaxTargets) return ERR_NODEV;
	if (rqp->rq_LunID >= ctp->cd_MaxLuns) return ERR_NODEV;
	rqp->rq_pdp=dev2pdp(ctp,rqp->rq_ChannelNo,rqp->rq_TargetID,rqp->rq_LunID);
	rqp->rq_CompIntrBig = rqp->rq_CompIntr; /* save it for future */
	rqp->rq_CompIntr = mdac_gam_scdb_intr;
	rqp->rq_ResdSize = mdac_getcdbtxsize();
	MLXSPL();
	rc = mdac_send_cmd_scdb(rqp);
	MLXSPLX();
	return rc;
}

/* send gam cmd - new API format */
#ifdef MLX_OS2
u32bits MLXFAR _loadds 
#else
u32bits MLXFAR
#endif
mdac_gam_new_cmd(rqp)
mdac_req_t MLXFAR *rqp;
{
	MLXSPLVAR; u32bits rc;
	mdac_ctldev_t MLXFAR *ctp = &mdac_ctldevtbl[rqp->rq_ControllerNo];
	if (!(ctp->cd_Status & MDACD_PRESENT))
	{
		return ERR_NODEV;
	}
	if (rqp->rq_ControllerNo >= mda_Controllers) return ERR_NODEV;
	if (! (ctp->cd_Status & MDACD_NEWCMDINTERFACE)) return MLXERR_INVAL;
	rqp->rq_ctp = ctp;
	rqp->rq_FinishTime = rqp->rq_TimeOut + mda_CurTime;

	/* send command directly to controller. */
	MLXSPL();
	rc = mdac_send_cmd(rqp);
	MLXSPLX();
	return rc;
}

#if     defined(MLX_NT_ALPHA) || defined(MLX_SOL_SPARC) || defined(WINNT_50)
#define MLXDIR_TO_DEV   0x01
#define MLXDIR_FROM_DEV 0x02

#define dsmdcmdp        (&dsmrqp->rq_DacCmd)
#define dsmdcdbp        (&dsmrqp->rq_scdb)

#ifndef _WIN64
#define dsmdp   (((u32bits)dsmrqp)+4*ONEKB)
#else
#define dsmdp   (((UCHAR *)dsmrqp)+4*ONEKB)
#endif

u32bits MLXFAR
mdac_data_size(rqp, control_flow)
mdac_req_t MLXFAR *rqp;
u32bits control_flow;
{
    u32bits size = rqp->rq_DataSize;

    if (control_flow == MLXDIR_TO_DEV) {
	switch (dcmdp->mb_Command)
	{
	case DACMD_INQUIRY_V2x : return(0);
	case DACMD_INQUIRY_V3x : return(0);
	case DACMD_DCDB : return(((dcdbp->db_DATRET&DAC_XFER_WRITE)==DAC_XFER_WRITE)?size:0);
	default: return(size);
	}
    }
    else {
	switch (dcmdp->mb_Command)
	{
	case DACMD_INQUIRY_V2x : return(sizeof(dac_inquiry2x_t));
	case DACMD_INQUIRY_V3x : return(sizeof(dac_inquiry3x_t));
	case DACMD_DCDB : return(((dcdbp->db_DATRET&DAC_XFER_READ)==DAC_XFER_READ) ? size:0);
	default: return(size);
	}
    }
}

u32bits MLXFAR
mdac_os_gam_cmdintr(dsmrqp)
mdac_req_t MLXFAR *dsmrqp;
{
	u32bits rc;
	mdac_req_t MLXFAR *rqp = (mdac_req_t MLXFAR *)dsmrqp->rq_OSReqp;
	mdac_ctldev_t MLXFAR *ctp = &mdac_ctldevtbl[rqp->rq_ControllerNo];

	dcmdp->mb_Status =  dsmdcmdp->mb_Status;
	if ((dsmdcmdp->mb_Command & ~DACMD_WITHSG) == DACMD_DCDB)
	    mdaccopy(dsmdcdbp, dcdbp, dac_scdb_s);
	if (rc = mdac_data_size(rqp, MLXDIR_FROM_DEV))
		 mdaccopy(dsmdp, rqp->rq_DataVAddr, rc);
	mdac_free8kb(ctp, (mdac_mem_t MLXFAR *)dsmrqp);
	(*rqp->rq_CompIntr)(rqp);
	return(0);
}

#define dsmrqp  ((mdac_req_t MLXFAR*)dsmdsp)
/* 
 *	This function executes commands that had to be queued by the GAM driver while in
 *	GAM driver context.
 *
 *	You will notice that this function is line for line exactly like the original
 *	function (below) except that the IRQL manipulation macros have been removed.
 *
 */

u32bits MLXFAR
mdac_os_gam_cmd_mdac_context(rqp)
mdac_req_t MLXFAR *rqp;
{
	u32bits rc;
	mdac_ctldev_t MLXFAR *ctp = &mdac_ctldevtbl[rqp->rq_ControllerNo];
	dac_scdb_t MLXFAR *dsmdsp;
    u08bits irql;


	if (rqp->rq_ControllerNo >= mda_Controllers) return ERR_NODEV;
	if (!(dsmdsp = (dac_scdb_t MLXFAR *)mdac_alloc8kb(ctp))) {
            mdac_prelock(&irql);
			mdac_ctlr_lock(ctp);
			qreq(ctp,rqp);                          /* requeue the request, it will start later */

#if !defined(_WIN64) && !defined(SCSIPORT_COMPLIANT)
		rqp->rq_StartReq = mdac_os_gam_cmd_mdac_context;     /* we will be called later */
#elif defined(_WIN64)
		rqp->rq_StartReq = (unsigned int (__cdecl *__ptr64 )(struct mdac_req *__ptr64 ))
			mdac_os_gam_cmd_mdac_context;     /* we will be called later */
#elif defined(SCSIPORT_COMPLIANT)
		rqp->rq_StartReq = 
			mdac_os_gam_cmd_mdac_context;

#endif
	    mdac_ctlr_unlock(ctp);
        mdac_postlock(irql);
	    return 0;
	}
	mdaccopy(rqp, dsmrqp, sizeof(mdac_req_t));
	dsmrqp->rq_OSReqp = (OSReq_t MLXFAR *)rqp;
	dsmrqp->rq_CompIntr = mdac_os_gam_cmdintr;
	if (rc = mdac_data_size(rqp, MLXDIR_TO_DEV))
		 mdaccopy(rqp->rq_DataVAddr, dsmdp, rc);
	if ((dsmdcmdp->mb_Command & ~DACMD_WITHSG) != DACMD_DCDB) {
		dsmdcmdp->mb_Datap = (u32bits)mlx_kvtophys(ctp, (VOID MLXFAR *)dsmdp);
		MLXSWAP(dsmdcmdp->mb_Datap);
	}
	else {
	    dsmdcdbp->db_PhysDatap = (u32bits)mlx_kvtophys(ctp, (VOID MLXFAR *)dsmdp);
	    MLXSWAP(dsmdcdbp->db_PhysDatap);
	    dsmdcmdp->mb_Datap = (u32bits)mlx_kvtophys(ctp,
		(UCHAR *)dsmrqp + offsetof(mdac_req_t, rq_scdb));
	    MLXSWAP(dsmdcmdp->mb_Datap);
	}
	rc = mdac_gam_cmd(dsmrqp);
	return rc;
}
u32bits MLXFAR
mdac_os_gam_cmd(rqp)
mdac_req_t MLXFAR *rqp;
{
	MLXSPLVAR; u32bits rc;
	mdac_ctldev_t MLXFAR *ctp = &mdac_ctldevtbl[rqp->rq_ControllerNo];
	dac_scdb_t MLXFAR *dsmdsp;
    u08bits irql;

	if (rqp->rq_ControllerNo >= mda_Controllers) return ERR_NODEV;
	MLXSPL();
	if (!(dsmdsp = (dac_scdb_t MLXFAR *)mdac_alloc8kb(ctp))) {
            mdac_prelock(&irql);
			mdac_ctlr_lock(ctp);
			qreq(ctp,rqp);             /* queue the request, it will start later in mdac context */
#if !defined(_WIN64) && !defined(SCSIPORT_COMPLIANT)
		rqp->rq_StartReq = mdac_os_gam_cmd_mdac_context;     /* we will be called later */
#elif defined(_WIN64)
		rqp->rq_StartReq = (unsigned int (__cdecl *__ptr64 )(struct mdac_req *__ptr64 ))
			mdac_os_gam_cmd_mdac_context;     /* we will be called later */
#elif defined(SCSIPORT_COMPLIANT)
		rqp->rq_StartReq = mdac_os_gam_cmd_mdac_context;

#endif
			mdac_ctlr_unlock(ctp);
            mdac_postlock(irql);
	    MLXSPLX();
	    return 0;
	}
	mdaccopy(rqp, dsmrqp, sizeof(mdac_req_t));
	dsmrqp->rq_OSReqp = (OSReq_t MLXFAR *)rqp;
	dsmrqp->rq_CompIntr = mdac_os_gam_cmdintr;
	if (rc = mdac_data_size(rqp, MLXDIR_TO_DEV)) mdaccopy(rqp->rq_DataVAddr, dsmdp, rc);
	if ((dsmdcmdp->mb_Command & ~DACMD_WITHSG) != DACMD_DCDB) {
		dsmdcmdp->mb_Datap = (u32bits)mlx_kvtophys(ctp, (VOID MLXFAR *)dsmdp);
		MLXSWAP(dsmdcmdp->mb_Datap);
	}
	else {
	    dsmdcdbp->db_PhysDatap = (u32bits)mlx_kvtophys(ctp, (VOID MLXFAR *)dsmdp);
	    MLXSWAP(dsmdcdbp->db_PhysDatap);
	    dsmdcmdp->mb_Datap = (u32bits)mlx_kvtophys(ctp,
		(UCHAR *)dsmrqp+ offsetof(mdac_req_t, rq_scdb));
	    MLXSWAP(dsmdcmdp->mb_Datap);
	}
	rc = mdac_gam_cmd(dsmrqp);
	MLXSPLX();
	return rc;
}
#undef dsmrqp

#define dsmncmdp        ((mdac_commandnew_t MLXFAR *)&dsmrqp->rq_DacCmdNew)

u32bits MLXFAR
mdac_os_gam_newcmdintr(dsmrqp)
mdac_req_t MLXFAR *dsmrqp;
{
	mdac_req_t MLXFAR *rqp = (mdac_req_t MLXFAR *)dsmrqp->rq_OSReqp;
	mdac_ctldev_t MLXFAR *ctp = &mdac_ctldevtbl[rqp->rq_ControllerNo];
	mdac_req_t MLXFAR *rqp2 = (mdac_req_t MLXFAR *)(dsmdp);

	dcmdp->mb_Status        = dsmdcmdp->mb_Status;
	rqp->rq_TargetStatus    = dsmrqp->rq_TargetStatus;
	rqp->rq_HostStatus      = dsmrqp->rq_HostStatus;
	if (rqp->rq_HostStatus == UCST_CHECK) 
		ncmdp->nc_SenseSize = rqp->rq_TargetStatus; 
	rqp->rq_CurIOResdSize   = dsmrqp->rq_CurIOResdSize;
	rqp->rq_ResdSize        = dsmrqp->rq_ResdSize;

	if (rqp->rq_DataSize && ((dsmncmdp->nc_CCBits & MDACMDCCB_READ) == MDACMDCCB_READ))
		mdaccopy(rqp2, rqp->rq_DataVAddr, rqp->rq_DataSize);

	mdac_free8kb(ctp, (mdac_mem_t MLXFAR *)dsmrqp);
	(*rqp->rq_CompIntr)(rqp);
	return(0);
}

#define dsmrqp  ((mdac_req_t MLXFAR*)dsmdsp)
/* 
 *	This function executes commands that had to be queued by the GAM driver while in
 *	GAM driver context.
 *
 *	You will notice that this function is line for line exactly like the original
 *	function (below) except that the IRQL manipulation macros have been removed.
 *
 */
u32bits MLXFAR
mdac_os_gam_new_cmd_mdac_context(
mdac_req_t MLXFAR *rqp
)
{
	u32bits rc;
	mdac_ctldev_t MLXFAR *ctp = &mdac_ctldevtbl[rqp->rq_ControllerNo];
	dac_scdb_t MLXFAR *dsmdsp;
    u08bits irql;

	if (rqp->rq_ControllerNo >= mda_Controllers) return ERR_NODEV;
	if (! (ctp->cd_Status & MDACD_NEWCMDINTERFACE)) return MLXERR_INVAL;

	if (!(dsmdsp = (dac_scdb_t MLXFAR *)mdac_alloc8kb(ctp))) {
            mdac_prelock(&irql);
			mdac_ctlr_lock(ctp);
			qreq(ctp,rqp);        /* queue the request, it will start later */
			rqp->rq_StartReq = mdac_os_gam_new_cmd_mdac_context; /* we will be called later */
			mdac_ctlr_unlock(ctp);
            mdac_postlock(irql);
	    return 0;
	}
	mdaccopy(rqp, dsmrqp, sizeof(mdac_req_t));
	mlx_kvtophyset(dsmrqp->rq_PhysAddr,ctp,(VOID MLXFAR *)dsmrqp);
	dsmrqp->rq_OSReqp = (OSReq_t MLXFAR *)rqp;
	dsmrqp->rq_CompIntr = mdac_os_gam_newcmdintr;
	if (rqp->rq_DataSize && ((dsmncmdp->nc_CCBits & MDACMDCCB_READ) != MDACMDCCB_READ))
		mdaccopy(rqp->rq_DataVAddr, dsmdp, rqp->rq_DataSize);
		mlx_kvtophyset(dsmncmdp->nc_SGList0.sg_PhysAddr,ctp, (VOID MLXFAR *)dsmdp);
	MLXSWAP(dsmncmdp->nc_SGList0.sg_PhysAddr);

	/* dsmncmdp->nc_SGList0.sg_DataSize.bit31_0 is already filled and swapped */

	dsmrqp->rq_SGLen = 0;
	dsmncmdp->nc_CCBits &= ~MDACMDCCB_WITHSG;
	rc = mdac_gam_new_cmd(dsmrqp);
	return rc;
}

u32bits MLXFAR
mdac_os_gam_new_cmd(
mdac_req_t MLXFAR *rqp
)
{
	MLXSPLVAR;
	u32bits rc;
	mdac_ctldev_t MLXFAR *ctp = &mdac_ctldevtbl[rqp->rq_ControllerNo];
	dac_scdb_t MLXFAR *dsmdsp;
    u08bits irql;

	if (rqp->rq_ControllerNo >= mda_Controllers) return ERR_NODEV;
	if (! (ctp->cd_Status & MDACD_NEWCMDINTERFACE)) return MLXERR_INVAL;

	MLXSPL();
	if (!(dsmdsp = (dac_scdb_t MLXFAR *)mdac_alloc8kb(ctp))) {
            mdac_prelock(&irql);
			mdac_ctlr_lock(ctp);
			qreq(ctp,rqp);        /* queue the request, it will start later in mdac context*/
			rqp->rq_StartReq = mdac_os_gam_new_cmd_mdac_context; /* we will be called later */
			mdac_ctlr_unlock(ctp);
            mdac_postlock(irql);
	    MLXSPLX();
	    return 0;
	}
	mdaccopy(rqp, dsmrqp, sizeof(mdac_req_t));
	mlx_kvtophyset(dsmrqp->rq_PhysAddr,ctp,(VOID MLXFAR *)dsmrqp);
	dsmrqp->rq_OSReqp = (OSReq_t MLXFAR *)rqp;
	dsmrqp->rq_CompIntr = mdac_os_gam_newcmdintr;
	if (rqp->rq_DataSize && ((dsmncmdp->nc_CCBits & MDACMDCCB_READ) != MDACMDCCB_READ))
		mdaccopy(rqp->rq_DataVAddr, dsmdp, rqp->rq_DataSize);
		mlx_kvtophyset(dsmncmdp->nc_SGList0.sg_PhysAddr,ctp, (VOID MLXFAR *)dsmdp);
	MLXSWAP(dsmncmdp->nc_SGList0.sg_PhysAddr);

	/* dsmncmdp->nc_SGList0.sg_DataSize.bit31_0 is already filled and swapped */

	dsmrqp->rq_SGLen = 0;
	dsmncmdp->nc_CCBits &= ~MDACMDCCB_WITHSG;
	rc = mdac_gam_new_cmd(dsmrqp);
	MLXSPLX();
	return rc;
}
#undef  dsmdp
#undef  dsmrqp
#undef  dsmncmdp
#endif  /* MLX_NT_ALPHA || MLX_SOL */


/* #endif */   // NEVER
/* #endif */  // _WIN64 or SCSIPORT_COMPLIANT

/*=====================GAM INTERFACE ENDS===================================*/

/*=====================SCAN DEVICES STARTS==================================*/
/* Scan for physical and logical devices present on the system. At end of the
** scan it call back the func with rqp which points to osrqp.
** We will start the parallel scan. This helps in two way, 1. memory allocation,
** 2. faster scan. We will allocate one extra request buffer from first controller
** and it's rq_Poll will keep track on number of parallel scan. When count goes,
** to 0, the call back function will be called.
*/
#define vadp    ((u08bits MLXFAR *)(rqp->rq_SGList))                    /* virtual  address of data */
#define pad32p  (rqp->rq_PhysAddr.bit31_0+offsetof(mdac_req_t,rq_SGList))       /* physical address of data */
#ifdef MDACNW_DEBUG        
#define padsensep    (rqp->rq_PhysAddr+offsetof(mdac_req_t,rq_Sensedata)) /* physical address of sense data */
#endif
#ifdef MLX_DOS

u32bits MLXFAR
mdac_scandevs(func,osrqp)
u32bits (MLXFAR *func)(mdac_req_t MLXFAR*);
OSReq_t MLXFAR* osrqp;
{
	mdac_req_t MLXFAR *rqp;
	mdac_req_t MLXFAR *prqp;        /* poll request tracker */
	mdac_ctldev_t MLXFAR *ctp = mdac_firstctp;

	mdac_alloc_req_ret(ctp, prqp,osrqp, MLXERR_NOMEM);
	prqp->rq_OSReqp = osrqp;

	prqp->rq_CompIntrBig = func;    /* function called after scan */
	prqp->rq_Poll = 1;              /* successful completion should not finish this operation before last one started */
	for ( ; ctp < mdac_lastctp; ctp++)
	{
		if (!(ctp->cd_Status & MDACD_NEWCMDINTERFACE)) 
		{
			mdac_link_lock();
			if (!(rqp = ctp->cd_FreeReqList))
			{       /* no buffer, return ERR_NOMEM */
				mdac_link_unlock();
				continue;
			}
			ctp->cd_FreeReqList = rqp->rq_Next;
			mdac_link_unlock();
		}
		else
		{
			if (!(rqp=(mdac_req_t MLXFAR *)mdac_alloc4kb(ctp))) continue;
			mdaczero(rqp,4096);
			mlx_kvtophyset(rqp->rq_PhysAddr,ctp,rqp);
			mlx_kvtophyset(rqp->rq_DataPAddr,ctp,vadp);
		}
		rqp->rq_OpFlags = 0;
		rqp->rq_ctp = ctp;
		rqp->rq_OSReqp = (OSReq_t MLXFAR *)prqp;

		if (!(ctp->cd_Status & MDACD_NEWCMDINTERFACE)) 
		{
			rqp->rq_CompIntr = mdac_scanldintr;
			dcmdp->mb_Command = DACMD_DRV_INFO;
			dcmdp->mb_Datap = pad32p; MLXSWAP(dcmdp->mb_Datap);
			rqp->rq_FinishTime = mda_CurTime + (rqp->rq_TimeOut=17);
		}
		else
		{
			// New interface
			setreqdetailsnew(rqp,MDACIOCTL_SCANDEVS);
			rqp->rq_CompIntr = mdac_checkscanprogress;
			rqp->rq_StartReq = mdac_checkscanprogress;

			ncmdp->nc_SGList0.sg_DataSize.bit31_0 = ncmdp->nc_TxSize = (4*ONEKB) - mdac_req_s;
			MLXSWAP(ncmdp->nc_SGList0.sg_DataSize);
			MLXSWAP(ncmdp->nc_TxSize);
			mlx_kvtophyset(ncmdp->nc_SGList0.sg_PhysAddr,ctp,vadp);
			MLXSWAP(ncmdp->nc_SGList0.sg_PhysAddr); 
		}
		
		mdac_link_lock_st(prqp->rq_Poll++);
		if (!mdac_send_cmd(rqp)) continue;
		mdac_link_lock_st(prqp->rq_Poll--);
		if (!(ctp->cd_Status & MDACD_NEWCMDINTERFACE)) 
		{
			mdac_free_req(ctp,rqp);
		}
		else
		{
			mdacfree4kb(ctp,rqp);
		}

	}
	return mdac_scandevsdone(prqp);
}

#ifdef OLD
u32bits MLXFAR
mdac_scandevs(func,osrqp)
u32bits (MLXFAR *func)(mdac_req_t MLXFAR*);
OSReq_t MLXFAR* osrqp;
{
	mdac_req_t MLXFAR *rqp;
	mdac_req_t MLXFAR *prqp;        /* poll request tracker */
	mdac_ctldev_t MLXFAR *ctp = mdac_firstctp;
	mdac_alloc_req_ret(ctp, prqp, osrqp, MLXERR_NOMEM);
	prqp->rq_OSReqp = osrqp;
	prqp->rq_CompIntrBig = func;    /* function called after scan */
	prqp->rq_Poll = 1;              /* successful completion should not finish this operation before last one started */
	for ( ; ctp < mdac_lastctp; ctp++)
	{
		mdac_link_lock();
		if (!(rqp = ctp->cd_FreeReqList))
		{       /* no buffer, return ERR_NOMEM */
			mdac_link_unlock();
			continue;
		}
		ctp->cd_FreeReqList = rqp->rq_Next;
		mdac_link_unlock();
		rqp->rq_OpFlags = 0;
		rqp->rq_ctp = ctp;
		rqp->rq_OSReqp = (OSReq_t MLXFAR *)prqp;
		rqp->rq_CompIntr = mdac_scanldintr;
		dcmdp->mb_Command = DACMD_DRV_INFO;
		dcmdp->mb_Datap = pad32p; MLXSWAP(dcmdp->mb_Datap);
		rqp->rq_FinishTime = mda_CurTime + (rqp->rq_TimeOut=17);
		mdac_link_lock_st(prqp->rq_Poll++);
		if (!mdac_send_cmd(rqp)) continue;
		mdac_link_lock_st(prqp->rq_Poll--);
		mdac_free_req(ctp,rqp);
	}
	return mdac_scandevsdone(prqp);
}
#endif

#endif /* MLX_DOS */

/* check if all scan has completed, if so, call the caller and free the resource */
u32bits MLXFAR
mdac_scandevsdone(rqp)
mdac_req_t      MLXFAR *rqp;
{
	UINT_PTR polls;
	mdac_link_lock();
	rqp->rq_Poll--; polls = rqp->rq_Poll;
	mdac_link_unlock();
	if (polls) return 0;    /* some more scan is active */
	if (rqp->rq_CompIntrBig) (*rqp->rq_CompIntrBig)(rqp);
	mdac_free_req(rqp->rq_ctp, rqp);
	return 0;
}

/* logical device scan interrupt */
u32bits MLXFAR
mdac_scanldintr(rqp)
mdac_req_t      MLXFAR* rqp;
{
	mdac_setscannedld(rqp, (dac_sd_info_t MLXFAR *)vadp);
	mdaczero(vadp,128);
	rqp->rq_FinishTime = mda_CurTime + (rqp->rq_TimeOut=17);
	/* logical device scanning is over, start physical device scanning */
	rqp->rq_CompIntr = mdac_scanpdintr;
	rqp->rq_ChannelNo = 0; rqp->rq_TargetID = 0;
	rqp->rq_LunID = -1;     /* mdac_scanpd does ++, it will start at 0 */
	mailboxzero(dcmd4p);
	dcmdp->mb_Command = DACMD_DCDB;
	dcmdp->mb_Status = DACMDERR_NOCODE; /* make error for intr function */
	dcmdp->mb_Datap = rqp->rq_PhysAddr.bit31_0+offsetof(mdac_req_t,rq_scdb);
	dcdbp->db_PhysDatap = pad32p;
	MLXSWAP(dcmdp->mb_Datap);
	MLXSWAP(dcdbp->db_PhysDatap);
	dcdbp->db_DATRET = DAC_XFER_READ|DAC_DCDB_DISCONNECT|DAC_DCDB_TIMEOUT_10sec;
	return mdac_scanpd(rqp);
}

/* physical device scan interrupt */
u32bits MLXFAR
mdac_scanpdintr(rqp)
mdac_req_t      MLXFAR* rqp;
{
	mdac_start_next_scdb(rqp->rq_pdp);
	return mdac_scanpd(rqp);
}

u32bits MLXFAR
mdac_scanpd(rqp)
mdac_req_t      MLXFAR* rqp;
{
	mdac_ctldev_t   MLXFAR* ctp = rqp->rq_ctp;
	mdac_setscannedpd(rqp, (ucscsi_inquiry_t MLXFAR*)vadp);
	if (rqp->rq_LunID) dcmdp->mb_Status = 0; /* let next lun be tried */
	 for (rqp->rq_LunID++; rqp->rq_ChannelNo<ctp->cd_MaxChannels;rqp->rq_TargetID=0,rqp->rq_ChannelNo++)
	  for ( ;rqp->rq_TargetID<ctp->cd_MaxTargets; dcmdp->mb_Status=0, rqp->rq_LunID=0, rqp->rq_TargetID++)
	   for ( ; (rqp->rq_LunID<ctp->cd_MaxLuns)&& !dcmdp->mb_Status; rqp->rq_LunID++)
	{
		if ((rqp->rq_LunID >= 8) && (rqp->rq_Dev<3)) break;
		if (mda_PDScanCancel) break;
		rqp->rq_FinishTime = mda_CurTime + (rqp->rq_TimeOut=10);
		dcdbp->db_ChannelTarget = ChanTgt(rqp->rq_ChannelNo,rqp->rq_TargetID);
		dcdbp->db_TxSize = ucscsi_inquiry_s; MLXSWAP(dcdbp->db_TxSize);
		dcdbp->db_CdbLen = UCSGROUP0_LEN;
		UCSMAKECOM_G0(scdbp,UCSCMD_INQUIRY,rqp->rq_LunID,0,(u32bits)ucscsi_inquiry_s);
		dcdbp->db_StatusIn=0; dcdbp->db_Reserved1=0;
		dcdbp->db_SenseLen = DAC_SENSE_LEN;
		rqp->rq_pdp=dev2pdp(ctp,rqp->rq_ChannelNo,rqp->rq_TargetID,rqp->rq_LunID);
		mdac_link_lock();
		ctp->cd_PDScanChannelNo = rqp->rq_ChannelNo;
		ctp->cd_PDScanTargetID = rqp->rq_TargetID;
		ctp->cd_PDScanLunID = rqp->rq_LunID;
		ctp->cd_PDScanValid = 1;
		mda_PDScanControllerNo = ctp->cd_ControllerNo;
		mda_PDScanChannelNo = rqp->rq_ChannelNo;
		mda_PDScanTargetID = rqp->rq_TargetID;
		mda_PDScanLunID = rqp->rq_LunID;
		mda_PDScanValid = 1;
		mdac_link_unlock();
		if (!mdac_send_cmd_scdb(rqp)) return 0;
	}
	mdac_link_lock_st(mda_PDScanValid=0;mda_PDScanCancel=0;ctp->cd_PDScanValid=0;ctp->cd_PDScanCancel=0);
	mdac_scandevsdone((mdac_req_t MLXFAR *)rqp->rq_OSReqp);
	mdac_free_req(ctp,rqp);
	return 0;
}

/* find free physdev/logical pointer and fill it to make not free */
mdac_pldev_t    MLXFAR *
mdac_freeplp(ctl, ch, tgt, lun, dt)
u32bits ctl, ch, tgt, lun, dt;
{
	mdac_pldev_t    MLXFAR *plp;
	mdac_link_lock();
	for (plp=mdac_pldevtbl; plp<&mdac_pldevtbl[MDAC_MAXPLDEVS]; plp++)
	{
		if (plp->pl_DevType) continue;
		plp->pl_DevType = (u08bits) dt;
		plp->pl_ControllerNo = (u08bits) ctl;
		plp->pl_ChannelNo = (u08bits) ch;
		plp->pl_TargetID = (u08bits) tgt;
		plp->pl_LunID = (u08bits) lun;
		plp->pl_DevSizeKB = (u08bits) 0;
		plp->pl_ScanDevState = MDACPLSDS_NEW;
		if (plp>=&mdac_pldevtbl[mda_PLDevs]) mda_PLDevs++;
		mdac_lastplp = &mdac_pldevtbl[mda_PLDevs];
		mdac_link_unlock();
		return plp;
	}
	mda_TooManyPLDevs++;
	mdac_link_unlock();
	return NULL;    /* free device space not found */
}

/* translate the physical/logical device information into dev pointer */
mdac_pldev_t    MLXFAR  *
mdac_devtoplp(ctl, ch, tgt, lun, dt)
u32bits ctl, ch, tgt, lun, dt;
{
	mdac_pldev_t    MLXFAR* plp = mdac_pldevtbl;
	for (; plp<mdac_lastplp; plp++)
		if ((plp->pl_ControllerNo==ctl) && (plp->pl_ChannelNo==ch) &&
		    (plp->pl_TargetID == tgt) && (plp->pl_LunID == lun) &&
		    (plp->pl_DevType == dt))
			return plp;
	return NULL;    /* device not found */
}

/* translate the physical/logical device information into dev pointer */
mdac_pldev_t    MLXFAR  *
mdac_devtoplpnew(
mdac_ctldev_t MLXFAR* ctp,
u32bits ch,
u32bits tgt,
u32bits lun)
{
	mdac_pldev_t    MLXFAR* plp = mdac_pldevtbl;
	for (; plp<mdac_lastplp; plp++)
		if ((plp->pl_ControllerNo==ctp->cd_ControllerNo) &&
			(plp->pl_ChannelNo==ch) &&
			(plp->pl_TargetID == tgt) &&
			(plp->pl_LunID == lun)) 
				return plp;
	return NULL;    /* device not found */
}

/* map the SCSI device to respective channel number. This is required where
** an OS does not support channel number. For example, SCO ODT 3.0.
*/
u32bits MLXFAR
mdac_setscsichanmap(rqp)
mdac_req_t      MLXFAR* rqp;
{
	mdac_pldev_t    MLXFAR* plp;
	for (plp=mdac_pldevtbl; plp<mdac_lastplp; plp++)
		if ((plp->pl_DevType == MDACPLD_PHYSDEV) &&
		    (plp->pl_TargetID < MDAC_MAXTARGETS))
			mdac_ctldevtbl[plp->pl_ControllerNo].cd_scdbChanMap[plp->pl_TargetID] = plp->pl_ChannelNo;
	return 0;
}

/* setup the information about a scanned physical device */
u32bits MLXFAR
mdac_setscannedpd(rqp,inqp)
mdac_req_t MLXFAR *rqp;
ucscsi_inquiry_t MLXFAR *inqp;
{
	mdac_pldev_t MLXFAR *plp = mdac_devtoplp(rqp->rq_ctp->cd_ControllerNo,rqp->rq_ChannelNo,rqp->rq_TargetID,rqp->rq_LunID,MDACPLD_PHYSDEV);
	if (!dcmdp->mb_Status && ((inqp->ucsinq_dtype!=UCSTYP_DAD)||mdac_reportscanneddisks) && (inqp->ucsinq_dtype!=UCSTYP_NOTPRESENT))
	{
		if (!plp) /* create new entry */
			if (!(plp = mdac_freeplp(rqp->rq_ctp->cd_ControllerNo,rqp->rq_ChannelNo,rqp->rq_TargetID,rqp->rq_LunID,MDACPLD_PHYSDEV))) return 0;
		mdaccopy(inqp,plp->pl_inq,VIDPIDREVSIZE+8);
		if (!rqp->rq_LunID) rqp->rq_Dev = inqp->ucsinq_version; /* LUN scan limit */
	}
	else if (plp)
		plp->pl_DevType = 0;     /* device is gone */
	return 0;
}

/* setup the information about a scanned physical device */
u32bits MLXFAR
mdac_setscannedpd_new(rqp,inqp)
mdac_req_t MLXFAR *rqp;
ucscsi_inquiry_t MLXFAR *inqp;
{
	mdac_pldev_t MLXFAR *plp;
	u32bits dt;

	dt = (rqp->rq_ChannelNo < rqp->rq_ctp->cd_PhysChannels) ? MDACPLD_PHYSDEV : MDACPLD_LOGDEV;
	
/*
#ifdef MDACNW_DEBUG        
	if ((rqp->rq_ChannelNo == 3) && (rqp->rq_TargetID == 0))
		EnterDebugger();
#endif
*/
	plp = mdac_devtoplpnew(rqp->rq_ctp,rqp->rq_ChannelNo,rqp->rq_TargetID,rqp->rq_LunID);
	if (!dcmdp->mb_Status && (inqp->ucsinq_dtype!=UCSTYP_NOTPRESENT))
	{
	    if ((dt == MDACPLD_PHYSDEV) && (inqp->ucsinq_dtype == UCSTYP_DAD))
	    {
		if (plp)
		    plp->pl_DevType = 0;         /* device is gone */

		    return 0;
	    }

	    if (!plp) /* create new entry */
		if (!(plp = mdac_freeplp(rqp->rq_ctp->cd_ControllerNo,rqp->rq_ChannelNo,rqp->rq_TargetID,rqp->rq_LunID,dt))) return 0;
	    mdaccopy(inqp,plp->pl_inq,VIDPIDREVSIZE+8);
	    if (!rqp->rq_LunID) rqp->rq_Dev = inqp->ucsinq_version; /* LUN scan limit */
	}
	return 0;
}

/* setup the information about a scanned logical/system devices */
u32bits MLXFAR
mdac_setscannedld(rqp, sp)
mdac_req_t      MLXFAR *rqp;
dac_sd_info_t   MLXFAR *sp;
{
	u32bits dev;
	mdac_pldev_t    MLXFAR* plp;
	mdac_ctldev_t   MLXFAR* ctp = rqp->rq_ctp;
	if (dcmdp->mb_Status) return MLXERR_IO;
	for (dev=0; dev<ctp->cd_MaxSysDevs; sp++, dev++)
	{
		plp=mdac_devtoplp(ctp->cd_ControllerNo,0,0,dev,MDACPLD_LOGDEV);
		if ((sp->sdi_DevSize == 0xFFFFFFFF) || !sp->sdi_DevSize)
		{       /* The device is not present */
#ifdef  MLXFW_BUGFIXED
			if (plp) plp->pl_DevType = 0;/* device is gone */
			continue;
#else
			/* The following statement has been added because FW
			** does not give clean entry after last entery
			*/
			for ( ; dev<ctp->cd_MaxSysDevs; dev++)
				if (plp=mdac_devtoplp(ctp->cd_ControllerNo,0,0,dev,MDACPLD_LOGDEV))
					plp->pl_DevType = 0;/* device is gone */
			break;
#endif  /* MLXFW_BUGFIXED */
		}
		/* found a logical device, update/create device information */
		if (!plp)
		{
			if (!(plp=mdac_freeplp(ctp->cd_ControllerNo,0,0,dev,MDACPLD_LOGDEV))) break; /* create new entry */
		}
		else if ((plp->pl_DevSizeKB != (mlxswap(sp->sdi_DevSize/2))) ||
		   ((plp->pl_RaidType&DAC_RAIDMASK)!=(sp->sdi_RaidType&DAC_RAIDMASK)))
			plp->pl_ScanDevState = MDACPLSDS_CHANGED;
		plp->pl_DevSizeKB = plp->pl_OrgDevSizeKB = mlxswap(sp->sdi_DevSize)/2;
		mdac_fixpdsize(plp);
		plp->pl_RaidType = sp->sdi_RaidType; /* GOK OLD STATES */
#ifdef MLX_DOS
		plp->pl_DevState = GetSysDeviceState(sp->sdi_DevState); /* GOK OLD STATES */
#else
		plp->pl_DevState = sp->sdi_DevState; /* GOK OLD STATES */
#endif /* MLX_DOS */
		if ((sp->sdi_DevState != DAC_SYS_DEV_ONLINE) && mdac_ignoreofflinesysdevs &&
		    (sp->sdi_DevState != DAC_SYS_DEV_CRITICAL))
			plp->pl_DevType = 0;/* device is gone */
		mdac_create_inquiry(ctp,(ucscsi_inquiry_t MLXFAR*)plp->pl_inq,UCSTYP_DAD);
	}
	return 0;
}

/* scan a logical/physical device and return device pointer after scan, it needs wait context */
mdac_pldev_t    MLXFAR  *
mdac_scandev(ctp,chn,tgt,lun,dt)
mdac_ctldev_t   MLXFAR  *ctp;
u32bits chn,tgt,lun,dt;
{
	mdac_req_t MLXFAR *rqp;

	if (ctp->cd_Status & MDACD_NEWCMDINTERFACE)
		return (mdac_scandev_new(ctp, chn, tgt, lun, dt));
#if !defined(_WIN64) && !defined(SCSIPORT_COMPLIANT)
	mdac_alloc_req_ret(ctp,rqp,NULL,(mdac_devtoplp(ctp->cd_ControllerNo,chn,tgt,lun,dt)));
#else
/* had to replicate the macro inline to get the return value cast to work!!! */
	mdac_link_lock(); 
	if (!(rqp = (ctp)->cd_FreeReqList)) 
	{	/* no buffer, return ERR_NOMEM */ 
		mdac_link_unlock(); 
		return ((mdac_pldev_t  MLXFAR*)MLXERR_NOMEM); 
	} 
	(ctp)->cd_FreeReqList = rqp->rq_Next; 
	mdac_link_unlock(); 
	rqp->rq_OpFlags = 0; 
	rqp->rq_ctp = ctp; 
       	mdaczero(rqp->rq_SGList,rq_sglist_s); 
#endif
	rqp->rq_Poll = 1;
	rqp->rq_CompIntr = mdac_req_pollwake;   /* Callback function */
	rqp->rq_FinishTime = mda_CurTime + (rqp->rq_TimeOut=10);
	rqp->rq_ChannelNo = (u08bits) chn;
	rqp->rq_TargetID = (u08bits) tgt;
	rqp->rq_LunID = (u08bits) lun;
	if (dt == MDACPLD_LOGDEV)
	{       /* scan the system/logical device */
		dcmdp->mb_Command = DACMD_DRV_INFO;
		dcmdp->mb_Datap = pad32p; MLXSWAP(dcmdp->mb_Datap);
		if (mdac_send_cmd(rqp)) goto out;
		mdac_req_pollwait(rqp);
		mdac_setscannedld(rqp, (dac_sd_info_t MLXFAR *)vadp);
		goto out;
	}
	else if (dt == MDACPLD_PHYSDEV)
	{       /* scan the physical device */
		dcmdp->mb_Command = DACMD_DCDB;
		dcmdp->mb_Datap = rqp->rq_PhysAddr.bit31_0+offsetof(mdac_req_t,rq_scdb);
		dcdbp->db_PhysDatap = pad32p;
		MLXSWAP(dcmdp->mb_Datap);
		MLXSWAP(dcdbp->db_PhysDatap);
		dcdbp->db_DATRET = DAC_XFER_READ|DAC_DCDB_DISCONNECT|DAC_DCDB_TIMEOUT_10sec;
		dcdbp->db_ChannelTarget = ChanTgt(rqp->rq_ChannelNo,rqp->rq_TargetID);
		dcdbp->db_TxSize = ucscsi_inquiry_s; MLXSWAP(dcdbp->db_TxSize);
		dcdbp->db_CdbLen = UCSGROUP0_LEN;
		UCSMAKECOM_G0(scdbp,UCSCMD_INQUIRY,rqp->rq_LunID,0,(u32bits)ucscsi_inquiry_s);
		dcdbp->db_StatusIn=0; dcdbp->db_Reserved1=0;
		dcdbp->db_SenseLen = DAC_SENSE_LEN;
		rqp->rq_pdp=dev2pdp(ctp,rqp->rq_ChannelNo,rqp->rq_TargetID,rqp->rq_LunID);
		if (mdac_send_cmd_scdb(rqp)) goto out;
		mdac_req_pollwait(rqp);
		mdac_start_next_scdb(rqp->rq_pdp);
		mdac_setscannedpd(rqp, (ucscsi_inquiry_t MLXFAR*)vadp);
	}
out:    mdac_free_req(ctp,rqp);
	return mdac_devtoplp(ctp->cd_ControllerNo,chn,tgt,lun,dt);
}

/* scan a logical/physical device and return device pointer after scan, it needs wait context */
/* used for scanning a device using new FW/SW API */
mdac_pldev_t    MLXFAR  *
mdac_scandev_new(ctp,chn,tgt,lun,dt)
mdac_ctldev_t   MLXFAR  *ctp;
u32bits chn,tgt,lun,dt;
{
	mdac_req_t MLXFAR *rqp;

#if !defined(_WIN64) && !defined(SCSIPORT_COMPLIANT)
	mdac_alloc_req_ret(ctp,rqp,NULL,(mdac_devtoplpnew(ctp,chn,tgt,lun)));
#else
/* had to replicate the macro inline to get the return value cast to work!!! */
	mdac_link_lock(); 
	if (!(rqp = (ctp)->cd_FreeReqList)) 
	{	/* no buffer, return ERR_NOMEM */ 
		mdac_link_unlock(); 
		return ((mdac_pldev_t  MLXFAR*)MLXERR_NOMEM); 
	} 
	(ctp)->cd_FreeReqList = rqp->rq_Next; 
	mdac_link_unlock(); 
	rqp->rq_OpFlags = 0; 
	rqp->rq_ctp = ctp; 
       	mdaczero(rqp->rq_SGList,rq_sglist_s); 
#endif
	rqp->rq_Poll = 1;
	rqp->rq_CompIntr = mdac_req_pollwake;   /* Callback function */
	rqp->rq_FinishTime = mda_CurTime + (rqp->rq_TimeOut=10);
	ncmdp->nc_TimeOut = (u08bits) rqp->rq_TimeOut;
	ncmdp->nc_Command = (u08bits) MDACMD_SCSI;
	ncmdp->nc_CCBits = MDACMDCCB_READ;
	ncmdp->nc_LunID = rqp->rq_LunID = (u08bits) lun;
	ncmdp->nc_TargetID = rqp->rq_TargetID = (u08bits) tgt;
	ncmdp->nc_ChannelNo = rqp->rq_ChannelNo = (u08bits) chn;
	ncmdp->nc_CdbLen = UCSGROUP0_LEN;
	UCSMAKECOM_G0(nscdbp,UCSCMD_INQUIRY,rqp->rq_LunID,0,(u32bits)ucscsi_inquiry_s);

	rqp->rq_DataSize = ucscsi_inquiry_s;
	rqp->rq_DMASize = rqp->rq_DataSize;
	rqp->rq_DataOffset = 0;
	rqp->rq_SGLen = 0;
	mlx_add64bits(rqp->rq_DMAAddr,rqp->rq_PhysAddr,offsetof(mdac_req_t,rq_SGList)); /* pad32 */

	mdac_setupnewcmdmem(rqp);
	rqp->rq_ResdSize = 0;                   /* no more data to transfer */
	MLXSTATS(ctp->cd_CmdsDone++;)
/*        
#ifdef MDACNW_DEBUG        
	if ((rqp->rq_ChannelNo == 3) && (rqp->rq_TargetID == 0))
	{
		EnterDebugger();
		
		ncmdp->nc_Sensep.bit31_0 = padsensep;
		ncmdp->nc_Sensep.bit63_32=0;
		ncmdp->nc_SenseSize=14;
		
	}                
#endif
*/
	if (mdac_send_cmd(rqp)) goto out;
	mdac_req_pollwait(rqp);
	mdac_setscannedpd_new(rqp, (ucscsi_inquiry_t MLXFAR *)vadp);

out:    mdac_free_req(ctp,rqp);
	return mdac_devtoplpnew(ctp,chn,tgt,lun);
}

#ifdef MLX_DOS

///////////////////////////////////////////////////////////
/// All new interface related scanning code starts here
///////////////////////////////////////////////////////////
u32bits MLXFAR
mdac_checkscanprogress(rqp)
mdac_req_t MLXFAR *rqp;
{
mdac_ctldev_t MLXFAR *ctp=rqp->rq_ctp;

    setreqdetailsnew(rqp,MDACIOCTL_GETCONTROLLERINFO);
	rqp->rq_CompIntr = mdac_checkscanprogressintr;
	ncmdp->nc_ChannelNo = ( (u08bits) ( ( (ctp->cd_ControllerNo & 0x1f) << 3) + \
					       (0 & 0x07) ) ) ;
	return mdac_send_cmd(rqp);
}

/* controller scan is compplete logical device scan interrupt new interface*/
u32bits MLXFAR
mdac_checkscanprogressintr(rqp)
mdac_req_t      MLXFAR* rqp;
{
	mdac_ctldev_t MLXFAR *ctp= rqp->rq_ctp;

#define ctip    ((mdacfsi_ctldev_info_t MLXFAR *) vadp) 

	if ( (ctip->cdi_PDScanActive & MDACFSI_PD_SCANACTIVE) && 
		  !((&rqp->rq_DacCmd)->mb_Status) && (!mda_PDScanCancel) )
	{
		// scan active update the chnl, tid and lun
		mdac_link_lock();
		ctp->cd_PDScanChannelNo=ctip->cdi_PDScanChannelNo;      /* physical device scan channel no */
		ctp->cd_PDScanTargetID=ctip->cdi_PDScanTargetID;        /* physical device scan target ID */
		ctp->cd_PDScanLunID=ctip->cdi_PDScanLunID;              /* physical device scan LUN ID */
		ctp->cd_PDScanValid = 1;       /* Physical device scan is valid if non zero */
		mdac_link_unlock();

		// QUEUE THE REQUEST
		qscanreq(rqp);
		return 0;
	}
	rqp->rq_LunID=0xFF;
	rdcmdp->mb_Status = DACMDERR_NOCODE;
#undef cip
	return(mdac_getlogdrivesintr(rqp));
}

u32bits MLXFAR
mdac_getlogdrivesintr(rqp)
mdac_req_t      MLXFAR* rqp;
{
	mdac_ctldev_t MLXFAR *ctp = rqp->rq_ctp;

	if ((rdcmdp->mb_Status == 0) && (rqp->rq_LunID != 0xFF)) mdac_updatelogdrives(rqp);

	if ( ( (rdcmdp->mb_Status > 0) && (rqp->rq_LunID == 0xFF)) || (rdcmdp->mb_Status == 0) )
	{
		for (++rqp->rq_LunID; rqp->rq_LunID<ctp->cd_MaxSysDevs; rqp->rq_LunID++)
		{
			setreqdetailsnew(rqp,MDACIOCTL_GETLOGDEVINFOVALID);
			ncmdp->nc_TargetID = 0;
			ncmdp->nc_LunID = rqp->rq_LunID;
			rqp->rq_CompIntr = mdac_getlogdrivesintr;
			// send the command for the next logical drive
			if (!mdac_send_cmd(rqp)) return 0;
		}
	}

	if ( ((rqp->rq_LunID != -1) && (rdcmdp->mb_Status != 0)) || 
			  (rqp->rq_LunID == ctp->cd_MaxSysDevs) )
	{
		// Failed - means no more Logical drives
		rqp->rq_LunID = 0xFF;
		rqp->rq_TargetID = 0;
		rdcmdp->mb_Status=DACMDERR_NOCODE;
		mdac_getphysicaldrivesintr(rqp);
	}
	return 0;
}

#define MDACIOCTL_GPDIV_DEVSIZE_MBORBLK            0x80000000
u32bits MLXFAR
mdac_updatelogdrives(rqp)
mdac_req_t      MLXFAR *rqp;
{
	mdac_ctldev_t MLXFAR *ctp=rqp->rq_ctp;
	mdac_pldev_t MLXFAR *plp;

#define sip ((mdacfsi_logdev_info_t MLXFAR *) vadp)
	plp=mdac_devtoplp(rqp->rq_ctp->cd_ControllerNo,
		      sip->ldi_ChannelNo,sip->ldi_TargetID,sip->ldi_LunID,
			  MDACPLD_LOGDEV);
	
	/* found a logical device, update/create device information */
	if (!plp)
	{
		if (!(plp=mdac_freeplp( rqp->rq_ctp->cd_ControllerNo,
			     sip->ldi_ChannelNo, sip->ldi_TargetID, 
				 sip->ldi_LunID, MDACPLD_LOGDEV))) return 0; /* create new entry */
	}
	else if ((plp->pl_DevSizeKB != (mlxswap(sip->ldi_BlockSize/2))) ||
		   ((plp->pl_RaidType&DAC_RAIDMASK)!=(sip->ldi_RaidLevel&DAC_RAIDMASK)))
	{
		plp->pl_ScanDevState = MDACPLSDS_CHANGED;
	}
	if (!(sip->ldi_DevSize & MDACIOCTL_GPDIV_DEVSIZE_MBORBLK))
		plp->pl_DevSizeKB = plp->pl_OrgDevSizeKB = (sip->ldi_DevSize)/2; // Device size - COD size in blocks
	else
		plp->pl_DevSizeKB = plp->pl_OrgDevSizeKB = (sip->ldi_DevSize)*1024;
	mdac_fixpdsize(plp);
	plp->pl_RaidType = sip->ldi_RaidLevel; /* GOK NEW STATES */
#ifdef MLX_DOS
	plp->pl_DevState = GetSysDeviceState(sip->ldi_DevState);  /* GOK NEW STATES */
#else
	plp->pl_DevState = sip->ldi_DevState;  /* GOK NEW STATES */
#endif /* MLX_DOS */
	if ((sip->ldi_DevState != DAC_SYS_DEV_ONLINE_NEW) && mdac_ignoreofflinesysdevs &&
		    (sip->ldi_DevState != DAC_SYS_DEV_CRITICAL_NEW)) /* GOK */
			plp->pl_DevType = 0;/* device is gone */
	mdac_create_inquiry(ctp,(ucscsi_inquiry_t MLXFAR*) plp->pl_inq,
		UCSTYP_DAD);

#undef sip
	return 0;
}
#undef MDACIOCTL_GPDIV_DEVSIZE_MBORBLK

/* physical device scan interrupt new interface*/
u32bits MLXFAR
mdac_getphysicaldrivesintr(rqp)
mdac_req_t      MLXFAR* rqp;
{
	mdac_ctldev_t MLXFAR *ctp = rqp->rq_ctp;
	mdac_pldev_t MLXFAR *plp = mdac_pldevtbl;
#define pip ((mdacfsi_physdev_info_t MLXFAR *) vadp)

	if ( (rqp->rq_LunID != 0xFF) && (rdcmdp->mb_Status > 0) )
	{
		// No more physical drives
		plp--;
		rqp->rq_CompIntrSave = (mdac_pldev_t MLXFAR *) plp;
		rdcmdp->mb_Status=DACMDERR_NOCODE;
		return (mdac_secondpassintr(rqp));
	}
	if ((rdcmdp->mb_Status == 0) && (rqp->rq_LunID != 0xFF)) 
	{
		mdac_updatephysicaldrives(rqp);

		rqp->rq_LunID = pip->pdi_LunID;
		rqp->rq_TargetID = pip->pdi_TargetID;
		rqp->rq_ChannelNo = pip->pdi_ChannelNo;
	}

	// Check LOGIC HERE
	if (rqp->rq_LunID == 0xFF) rdcmdp->mb_Status=0;
	for (rqp->rq_LunID++; rqp->rq_ChannelNo<ctp->cd_MaxChannels;
			rqp->rq_TargetID=0,rqp->rq_ChannelNo++)
	  for ( ;rqp->rq_TargetID<ctp->cd_MaxTargets;
			rdcmdp->mb_Status=0, rqp->rq_LunID=0, rqp->rq_TargetID++)
	    for ( ; (rqp->rq_LunID<ctp->cd_MaxLuns)&& !(rdcmdp->mb_Status);
			rqp->rq_LunID++)
		{
			if ((rqp->rq_LunID >= 8) && (rqp->rq_Dev<3)) break;
			setreqdetailsnew(rqp,MDACIOCTL_GETPHYSDEVINFOVALID);
			ncmdp->nc_LunID = rqp->rq_LunID;
			ncmdp->nc_TargetID = rqp->rq_TargetID;
			ncmdp->nc_ChannelNo = ( (u08bits) ( ( (ctp->cd_ControllerNo & 0x1f) << 3) + \
						(rqp->rq_ChannelNo & 0x07) ) ) ;
			rqp->rq_CompIntr = mdac_getphysicaldrivesintr;
			rqp->rq_pdp=dev2pdp(ctp,rqp->rq_ChannelNo,rqp->rq_TargetID,rqp->rq_LunID);
			mdac_link_lock();

			ctp->cd_PDScanChannelNo=rqp->rq_ChannelNo;      /* physical device scan channel no */
			ctp->cd_PDScanTargetID=rqp->rq_TargetID;        /* physical device scan target ID */
			ctp->cd_PDScanLunID=rqp->rq_LunID;              /* physical device scan LUN ID */
			ctp->cd_PDScanValid = 1;       /* Physical device scan is valid if non zero */
			mda_PDScanControllerNo = ctp->cd_ControllerNo;
			mda_PDScanChannelNo = rqp->rq_ChannelNo;
			mda_PDScanTargetID = rqp->rq_TargetID;
			mda_PDScanLunID = rqp->rq_LunID;
			mda_PDScanValid = 1;

			mdac_link_unlock();

			if (!mdac_send_cmd(rqp)) return 0;
		}
#undef pip
	return 0;
}

u32bits MLXFAR
mdac_updatephysicaldrives(rqp)
mdac_req_t      MLXFAR *rqp;
{
	mdac_pldev_t MLXFAR *plp;
	ucscsi_inquiry_t MLXFAR *inqp;

#define pip ((mdacfsi_physdev_info_t MLXFAR *) vadp)
    inqp = (ucscsi_inquiry_t MLXFAR *) (pip->pdi_SCSIInquiry);

	plp = mdac_devtoplp(rqp->rq_ctp->cd_ControllerNo,
		      pip->pdi_ChannelNo,pip->pdi_TargetID,pip->pdi_LunID,MDACPLD_PHYSDEV);
	if (!dcmdp->mb_Status && ((inqp->ucsinq_dtype!=UCSTYP_DAD)||mdac_reportscanneddisks) && 
		(inqp->ucsinq_dtype!=UCSTYP_NOTPRESENT))
	{
		if (!plp) /* create new entry */
			if (!(plp = mdac_freeplp(rqp->rq_ctp->cd_ControllerNo,
			      pip->pdi_ChannelNo,pip->pdi_TargetID,pip->pdi_LunID,
				  MDACPLD_PHYSDEV)))
			{
				return 0;
			}
		mdaccopy(inqp,plp->pl_inq,VIDPIDREVSIZE+8);
		if (!rqp->rq_LunID) rqp->rq_Dev = inqp->ucsinq_version; /* LUN scan limit */
	}
	else if (plp)
		plp->pl_DevType = 0;     /* device is gone */

#undef pip
	return 0;
}


u32bits MLXFAR
mdac_secondpassintr(rqp)
mdac_req_t      MLXFAR* rqp;
{
	mdac_pldev_t MLXFAR  *plp=(mdac_pldev_t MLXFAR *) rqp->rq_CompIntrSave;
	mdac_ctldev_t MLXFAR *ctp=rqp->rq_ctp;
	
	if (rdcmdp->mb_Status == 0) 
	{
#define pip  ((mdacfsi_physdev_info_t MLXFAR *) vadp)
#define oplp  ((mdac_pldev_t *) rqp->rq_CompIntrSave)
		if ( (pip->pdi_ChannelNo != oplp->pl_ChannelNo) ||
				 (pip->pdi_TargetID  != oplp->pl_TargetID) || 
				 (pip->pdi_LunID     != oplp->pl_LunID) ||
			     (pip->pdi_ControllerNo  != oplp->pl_ControllerNo) )
			plp->pl_DevState = MDACPLD_FREE;
#undef oplp
#undef pip
	}

	for (plp = (mdac_pldev_t MLXFAR *) (rqp->rq_CompIntrSave), plp++; plp<mdac_lastplp; plp++)
	{
		if (!(ctp->cd_Status & MDACD_NEWCMDINTERFACE)) continue;
		if (plp->pl_DevType == MDACPLD_PHYSDEV) {
		    setreqdetailsnew(rqp,MDACIOCTL_GETPHYSDEVINFOVALID);
		}
		else {
			setreqdetailsnew(rqp,MDACIOCTL_GETLOGDEVINFOVALID);
		}
		
		ncmdp->nc_ChannelNo = ( (u08bits) ( ( (plp->pl_ControllerNo & 0x1f) << 3) + \
						(plp->pl_ChannelNo & 0x07) ) );
		ncmdp->nc_LunID = plp->pl_LunID;
		if (plp->pl_DevType == MDACPLD_PHYSDEV)
			ncmdp->nc_TargetID = plp->pl_TargetID;
		rqp->rq_CompIntrSave = (mdac_pldev_t MLXFAR *)plp;
		rqp->rq_CompIntr = mdac_secondpassintr;
		if (!mdac_send_cmd(rqp)) return 0;
	}
	mdac_link_lock_st(mda_PDScanValid=0;mda_PDScanCancel=0;ctp->cd_PDScanValid=0;ctp->cd_PDScanCancel=0);    
    mdac_scandevsdone((mdac_req_t MLXFAR *) rqp->rq_OSReqp);
	mdac_free_req(ctp,rqp);

	return 0;
}

///////////////////////////////////////////////////////////
/// All new interface related scanning code ends here
///////////////////////////////////////////////////////////

#endif /* MLX_DOS */

#undef  vadp
#undef  padp
/*=====================SCAN DEVICES ENDS====================================*/

/*========================SIZE LIMIT CODE STARTS=========================*/
/* fix the physical device size */
uosword MLXFAR
mdac_fixpdsize(plp)
mdac_pldev_t    MLXFAR* plp;
{
	mda_sizelimit_t MLXFAR* slp;
	if (!(slp=mdac_devidtoslp(((ucscsi_inquiry_t MLXFAR*)plp->pl_inq)->ucsinq_vid))) return MLXERR_NODEV;
	plp->pl_DevSizeKB = mlx_min(slp->sl_DevSizeKB, plp->pl_OrgDevSizeKB);
	return 0;
}

/* find device size entry for given id */
mda_sizelimit_t MLXFAR* MLXFAR
mdac_devidtoslp(idp)
u08bits MLXFAR* idp;
{
	mda_sizelimit_t MLXFAR* slp;
	for(slp=mdac_sizelimitbl; slp<mdac_lastslp; slp++)
		if (slp->sl_DevSizeKB && !mdac_strcmp(slp->sl_vidpidrev,idp,VIDPIDREVSIZE))
			return slp;
	return NULL;
}

/* get the size limit information for given index */
uosword MLXFAR
mdac_getsizelimit(slip)
mda_sizelimit_info_t    MLXFAR* slip;
{
	mda_sizelimit_t MLXFAR* slp = &mdac_sizelimitbl[slip->sli_TableIndex];
	if (slip->sli_TableIndex >= MDAC_MAXSIZELIMITS) return MLXERR_NODEV;
	slip->sli_DevSizeKB = slp->sl_DevSizeKB;
	mdaccopy(slp->sl_vidpidrev,slip->sli_vidpidrev,VIDPIDREVSIZE);
	slip->sli_Reserved0 = 0; slip->sli_Reserved1 = 0;
	return 0;
}

/* set the size limit, fix the phys dev sizes */
uosword MLXFAR
mdac_setsizelimit(slip)
mda_sizelimit_info_t    MLXFAR* slip;
{
	mda_sizelimit_t MLXFAR* slp;
	mdac_pldev_t    MLXFAR* plp;
	mdac_link_lock();
	if (slp = mdac_devidtoslp(slip->sli_vidpidrev)) goto setinfo;
	if (!slip->sli_DevSizeKB) { mdac_link_unlock(); return 0; } /* no entry to remove */
	for (slp=mdac_sizelimitbl; slp<&mdac_sizelimitbl[MDAC_MAXSIZELIMITS]; slp++)
	{
		if (slp->sl_DevSizeKB) continue;
		if (slp>=&mdac_sizelimitbl[mda_SizeLimits]) mda_SizeLimits++;
		mdac_lastslp = &mdac_sizelimitbl[mda_SizeLimits];
setinfo:        slp->sl_DevSizeKB = slip->sli_DevSizeKB;
		mdaccopy(slip->sli_vidpidrev,slp->sl_vidpidrev,VIDPIDREVSIZE);
		break;
	}
	mdac_link_unlock();
	if (slp >= &mdac_sizelimitbl[MDAC_MAXSIZELIMITS]) return MLXERR_NOSPACE;
	for (plp=mdac_pldevtbl; plp<mdac_lastplp; plp++)
		mdac_fixpdsize(plp);
	return 0;
}
/*========================SIZE LIMIT CODE ENDS===========================*/

#ifndef MLX_DOS
/*==========================DATAREL STARTS==================================*/
u32bits mdac_datarel_debug=0;
#define mdac_datarel_send_cmd(rqp) \
	(drl_isosinterface(rqp->rq_Dev)? mdac_datarel_send_cmd_os(rqp) : \
	((rqp->rq_ctp->cd_CmdsDone++,(rqp->rq_OpFlags&MDAC_RQOP_READ)? \
	(rqp->rq_ctp->cd_Reads++,rqp->rq_ctp->cd_ReadBlks+=rqp->rq_DataSize>>9): \
	(rqp->rq_ctp->cd_Writes++,rqp->rq_ctp->cd_WriteBlks+=rqp->rq_DataSize>>9)), \
	(drl_isscsidev(rqp->rq_Dev)? mdac_send_cmd_scdb(rqp) : mdac_send_cmd(rqp))))
#define mdac_datarel_setcmd(rqp)        (drl_isosinterface(rqp->rq_Dev)? mdac_datarel_setrwcmd_os(rqp) : mdac_datarel_setrwcmd(rqp))
#define mdac_datarel_setsglist(rqp)     (drl_isosinterface(rqp->rq_Dev)? mdac_datarel_setsgsize_os(rqp) : mdac_datarel_setsgsize(rqp))
#define CURPAT(rqp)     rqp->rq_Poll
#define IOSP(rqp)       rqp->rq_OSReqp
#define DIOSP(rqp)      ((drliostatus_t MLXFAR *)IOSP(rqp))
/* We try to generate unique random number by checking duplicates. The
** following tables summarizes the duplicates with iterations. We generated
** 8192 random numbers between 0 to 8191 range.
** iterations   duplicates      %duplicates
**      1       3039            39%
**      2       1936            23%
**      3       1441            17%
**      4       1153            14%
**      5        957            11%
**      6        825            10%
**      7        722             8%
**     17        318             3%
**     77         72            .9%
**    177         33            .4%
**    777          9            .1%
**
** July 17, 1990.
** Kailash
*/

#ifndef MLX_OS2
#if (!defined(_WIN64)) || (!defined(SCSIPORT_COMPLIANT)) 
u32bits MLXFAR
mdac_datarel_rand(iosp)
drliostatus_t MLXFAR *iosp;
{
	u32bits val, inx;
	for (inx = 777; inx; inx--)
	{
		val = (((iosp->drlios_randx = iosp->drlios_randx * 1103515245L + 12345)>>8) & 0x7FFFFF);
		val = (val % iosp->drlios_randlimit);
		if (TESTBIT(iosp->drlios_randbit,val)) continue;
		SETBIT(iosp->drlios_randbit,val);
		return val;
	}
	iosp->drlios_randups++;
	return val;
}

/* generate the random read/write flags */
u32bits MLXFAR
mdac_datarel_randrw(iosp)
drliostatus_t *iosp;
{
	u32bits val = (((iosp->drlios_rwmixrandx = iosp->drlios_rwmixrandx * 1103515245L + 12345)>>8) & 0x7FFFFF);
	if ((val % 10000) > (iosp->drlios_rwmixcnt*100))
		return (iosp->drlios_opflags & DRLOP_READ)? MDAC_RQOP_WRITE:MDAC_RQOP_READ;
	return (iosp->drlios_opflags & DRLOP_READ)? MDAC_RQOP_READ:MDAC_RQOP_WRITE;
}

/* generate the random IO size */
u32bits MLXFAR
mdac_datarel_randiosize(iosp)
drliostatus_t *iosp;
{
	u32bits val;
	if (!iosp->drlios_ioinc && !(iosp->drlios_opflags & DRLOP_RANDIOSZ)) goto out;
	if (iosp->drlios_minblksize == iosp->drlios_maxblksize) goto out; 
	if (!(iosp->drlios_opflags & DRLOP_RANDIOSZ))
	{
		iosp->drlios_curblksize += iosp->drlios_ioinc;
		goto outl;
	}
	val = (((iosp->drlios_ioszrandx = iosp->drlios_ioszrandx * 1103515245L + 12345)>>8) & 0x7FFFFF);
	val = val % (iosp->drlios_maxblksize-iosp->drlios_minblksize);
	iosp->drlios_curblksize = iosp->drlios_minblksize+((val+(DRL_DEV_BSIZE/2)) & ~(DRL_DEV_BSIZE-1));
outl:   if (iosp->drlios_curblksize > iosp->drlios_maxblksize)
		iosp->drlios_curblksize = iosp->drlios_minblksize;
out:    return iosp->drlios_curblksize;
}

/* check datarel device for validity, return ctp if ok else 0 */
mdac_ctldev_t   MLXFAR*
mdac_datarel_dev2ctp(dev)
u32bits dev;
{
	mdac_ctldev_t   MLXFAR *ctp = &mdac_ctldevtbl[drl_ctl(dev)];
	if (drl_ctl(dev)>= mda_Controllers) return NULL;
	if (!(ctp->cd_Status&MDACD_PRESENT)) return NULL;
	if (!drl_isscsidev(dev)) return (drl_sysdev(dev)<ctp->cd_MaxSysDevs)? ctp : NULL;
	if (drl_chno(dev) >= ctp->cd_MaxChannels) return NULL;
	if (drl_tgt(dev) >= ctp->cd_MaxTargets) return NULL;
	if (drl_lun(dev) >= ctp->cd_MaxLuns) return NULL;
	return ctp;
}

/* get the device size */
u32bits MLXFAR
mdac_datarel_devsize(dsp)
drldevsize_t MLXFAR *dsp;
{
	mdac_req_t      MLXFAR *rqp;
	mdac_ctldev_t   MLXFAR *ctp;
	if (!(ctp = mdac_datarel_dev2ctp(dsp->drlds_bdev))) return DRLERR_NODEV;
	if ((!drl_isscsidev(dsp->drlds_bdev)) && (ctp->cd_Status & MDACD_NEWCMDINTERFACE)) return MLXERR_INVAL;
	if (!(rqp=(mdac_req_t MLXFAR *)mdac_alloc4kb(ctp))) return ERR_NOMEM;
	rqp->rq_ctp = ctp;
	mlx_kvtophyset(rqp->rq_PhysAddr,ctp,rqp);
	rqp->rq_Poll = 1;
	rqp->rq_FinishTime = mda_CurTime + (rqp->rq_TimeOut=17);
	rqp->rq_CompIntr = mdac_req_pollwake;
	if (drl_isscsidev(dsp->drlds_bdev)) goto out_scsi;
	dcmdp->mb_Command = DACMD_SIZE_DRIVE;
	dcmdp->mb_SysDevNo = drl_sysdev(dsp->drlds_bdev);
	dcmdp->mb_Datap=rqp->rq_PhysAddr.bit31_0+mdac_req_s; MLXSWAP(dcmdp->mb_Datap);
	if (mdac_send_cmd(rqp)) mdac_free4kbret(ctp,rqp,DRLERR_IO);
	mdac_req_pollwait(rqp);
	if (dcmdp->mb_Status) mdac_free4kbret(ctp,rqp,DRLERR_NODEV);
	dsp->drlds_blocksize = 512;
	dsp->drlds_devsize = *((u32bits MLXFAR*)(rqp+1)); MLXSWAP(dsp->drlds_devsize);
	mdac_free4kbret(ctp,rqp,0);

out_scsi:/* read capacity of SCSI device */
	rqp->rq_ChannelNo = drl_chno(dsp->drlds_bdev);
	rqp->rq_TargetID = drl_tgt(dsp->drlds_bdev);
	rqp->rq_LunID = drl_lun(dsp->drlds_bdev);
	if (ctp->cd_Status & MDACD_NEWCMDINTERFACE) goto donewi;
	dcdbp->db_ChannelTarget = ChanTgt(rqp->rq_ChannelNo,rqp->rq_TargetID);
	dcdbp->db_SenseLen = DAC_SENSE_LEN;
	dcdbp->db_DATRET = DAC_DCDB_XFER_READ|DAC_DCDB_DISCONNECT|DAC_DCDB_TIMEOUT_10sec;
	dcdbp->db_CdbLen = UCSGROUP1_LEN;
	mdac_setcdbtxsize(ucsdrv_capacity_s);
	UCSMAKECOM_G1(scdbp,UCSCMD_READCAPACITY,rqp->rq_LunID,0,0);
	dcdbp->db_PhysDatap=rqp->rq_PhysAddr.bit31_0+mdac_req_s;
	MLXSWAP(dcdbp->db_PhysDatap);
	dcmdp->mb_Datap=rqp->rq_PhysAddr.bit31_0+offsetof(mdac_req_t,rq_scdb);
	MLXSWAP(dcmdp->mb_Datap);
	dcmdp->mb_Command = DACMD_DCDB;
	rqp->rq_pdp=dev2pdp(ctp,rqp->rq_ChannelNo,rqp->rq_TargetID,rqp->rq_LunID);
	rqp->rq_CompIntrBig = mdac_req_pollwake; /* save it for gam comp func */
	rqp->rq_CompIntr = mdac_gam_scdb_intr;
	if (mdac_send_cmd_scdb(rqp)) mdac_free4kbret(ctp,rqp,DRLERR_IO);
docapop:
	mdac_req_pollwait(rqp);
	if (dcmdp->mb_Status) mdac_free4kbret(ctp,rqp,DRLERR_NODEV);
	dsp->drlds_blocksize=UCSGETDRVSECLEN((ucsdrv_capacity_t MLXFAR *)(rqp+1));
	dsp->drlds_devsize=UCSGETDRVCAPS((ucsdrv_capacity_t MLXFAR *)(rqp+1))+1;
	mdac_free4kbret(ctp,rqp,0);

donewi: /* new interface command */
	ncmdp->nc_Command = MDACMD_SCSI;
	ncmdp->nc_CCBits = MDACMDCCB_READ;
	ncmdp->nc_LunID = rqp->rq_LunID;
	ncmdp->nc_TargetID = rqp->rq_TargetID;
	ncmdp->nc_ChannelNo = (u08bits) rqp->rq_ChannelNo;
	ncmdp->nc_TimeOut = (u08bits) rqp->rq_TimeOut;
	ncmdp->nc_CdbLen = UCSGROUP1_LEN;
	UCSMAKECOM_G1(nscdbp,UCSCMD_READCAPACITY,0,0,0);
	rqp->rq_DataSize = ncmdp->nc_TxSize = ucsdrv_capacity_s; MLXSWAP(ncmdp->nc_TxSize);
	mlx_add64bits(ncmdp->nc_SGList0.sg_PhysAddr,rqp->rq_PhysAddr,mdac_req_s);
	mlx_add64bits(ncmdp->nc_SGList0.sg_PhysAddr,rqp->rq_PhysAddr,mdac_req_s);
	ncmdp->nc_SGList0.sg_DataSize.bit31_0 = ucsdrv_capacity_s;
	MLXSWAP(ncmdp->nc_SGList0.sg_PhysAddr);
	MLXSWAP(ncmdp->nc_SGList0.sg_DataSize);
	if (mdac_send_cmd(rqp)) mdac_free4kbret(ctp,rqp,DRLERR_IO);
	goto docapop;
}

#define mdac_datarel_blkno(iosp) ((iosp->drlios_randlimit) ? \
	mdac_datarel_rand(iosp)*iosp->drlios_maxblksperio : iosp->drlios_nextblkno)
#define mdac_datarel_nextblk(iosp,sz) \
{ \
	if (iosp->drlios_devcnt == 1) \
	{ \
		iosp->drlios_nextblkno += drl_btodb(sz); \
		if (iosp->drlios_opflags & DRLOP_CACHETEST) iosp->drlios_nextblkno = 0; \
	} \
	else \
	{ \
		iosp->drlios_nextblkno += iosp->drlios_maxblksperio; \
		if ((iosp->drlios_opflags & DRLOP_CACHETEST) && \
		    (iosp->drlios_nextblkno >= iosp->drlios_maxcylszuxblk)) \
			iosp->drlios_nextblkno = 0; \
	} \
}

/* This function is called when operation is done */
u32bits MLXFAR
mdac_datarel_rwtestintr(rqp)
mdac_req_t MLXFAR *rqp;
{
	u64bits reg0;
	u32bits dev,devno;
	drliostatus_t MLXFAR *iosp = DIOSP(rqp);
	rqp->rq_BlkNo -= iosp->drlios_startblk; /* get block within operation */
	if (iosp->drlios_eventrace)
	{
		dev = mdac_disable_intr_CPU();
		mdac_writemsr(EM_MSR_CESR, 0, 0);
		mdac_readmsr(EM_MSR_CTR0, (u64bits MLXFAR*)&reg0);
		mdac_restore_intr_CPU(dev);
	}
	mdac_sleep_lock();
	if (iosp->drlios_eventrace)
		iosp->drlios_eventcnt[iosp->drlios_eventinx++ & (DRLMAX_EVENT-1)] = reg0.bit31_0;
	if (!dcmdp->mb_Status)
	{
		add8byte(&iosp->drlios_dtdone,rqp->rq_DataSize);
		iosp->drlios_diodone++;
		if ((iosp->drlios_datacheck||((iosp->drlios_opflags&DRLOP_CHECKIMD)&&(rqp->rq_OpFlags&MDAC_RQOP_BUSY))) && (rqp->rq_OpFlags&MDAC_RQOP_READ))
			mdac_datarel_checkpat(iosp,(u32bits MLXFAR*)rqp->rq_DataVAddr,CURPAT(rqp),iosp->drlios_patinc,rqp->rq_DataSize/sizeof(u32bits),rqp->rq_BlkNo);
		if (rqp->rq_OpFlags & MDAC_RQOP_READ) iosp->drlios_reads++; else iosp->drlios_writes++;
	}
	else iosp->drlios_opstatus |= DRLOPS_ERR;
	if (!iosp->drlios_pendingios) iosp->drlios_opstatus |= DRLOPS_STOP;
	if (iosp->drlios_opstatus & DRLOPS_ANYSTOP)
	{
		iosp->drlios_opcounts--;
		if (!iosp->drlios_opcounts) mdac_wakeup(&iosp->drlios_slpchan);
		mdac_sleep_unlock();
		return 0;
	}
	rqp->rq_DataVAddr=(u08bits MLXFAR *)((((u32bits)(rqp->rq_DataVAddr))&DRLPAGEMASK)+iosp->drlios_memaddroff);
	iosp->drlios_memaddroff = (iosp->drlios_memaddroff+iosp->drlios_memaddrinc) & DRLPAGEOFFSET;
	if (rqp->rq_OpFlags & MDAC_RQOP_BUSY) rqp->rq_OpFlags &= ~(MDAC_RQOP_BUSY|MDAC_RQOP_READ);
	else if ((iosp->drlios_opflags & DRLOP_CHECKIMD) && !(rqp->rq_OpFlags&MDAC_RQOP_READ))
	{       /* do immediate read for data check and it comes after write */
		rqp->rq_OpFlags |= MDAC_RQOP_READ|MDAC_RQOP_BUSY;       /* BUSY indicates immediate read */
		goto out_imdread;
	}
	iosp->drlios_pendingios--;
	rqp->rq_DataSize = mdac_datarel_randiosize(iosp);
	rqp->rq_BlkNo = mdac_datarel_blkno(iosp);
	mdac_datarel_nextblk(iosp,rqp->rq_DataSize);
	devno = uxblktodevno(iosp,rqp->rq_BlkNo);
	rqp->rq_BlkNo = pduxblk(iosp,rqp->rq_BlkNo);
	rqp->rq_ctp = iosp->drlios_ctp[devno];
	rqp->rq_Dev = dev = iosp->drlios_bdevs[devno];
	rqp->rq_ControllerNo=drl_ctl(dev); rqp->rq_ChannelNo=drl_ch(dev);
	rqp->rq_TargetID=drl_tgt(dev); rqp->rq_SysDevNo=drl_sysdev(dev);
	CURPAT(rqp) = iosp->drlios_curpat;
	iosp->drlios_curpat += rqp->rq_DataSize/sizeof(u32bits);
	if ((iosp->drlios_opflags & DRLOP_RWMIXIO) && iosp->drlios_rwmixcnt)
		rqp->rq_OpFlags = (rqp->rq_OpFlags & ~MDAC_RQOP_READ)|mdac_datarel_randrw(iosp);
out_imdread:
	mdac_sleep_unlock();
	if ((iosp->drlios_datacheck||(iosp->drlios_opflags&DRLOP_CHECKIMD)) && (!(rqp->rq_OpFlags & MDAC_RQOP_READ)))
		mdac_datarel_fillpat((u32bits MLXFAR*)rqp->rq_DataVAddr,CURPAT(rqp),iosp->drlios_patinc,rqp->rq_DataSize/sizeof(u32bits));
	rqp->rq_BlkNo += iosp->drlios_startblk;
	if (iosp->drlios_memaddrinc || iosp->drlios_ioinc || (iosp->drlios_opflags & DRLOP_RANDIOSZ))
		mdac_datarel_setsglist(rqp);
	mdac_datarel_setcmd(rqp);
	if (iosp->drlios_eventrace)
	{
		dev = mdac_disable_intr_CPU();
		mdac_writemsr(EM_MSR_CTR0,0,0);
		mdac_writemsr(EM_MSR_CESR,iosp->drlios_eventcesr, 0);
		mdac_restore_intr_CPU(dev);
	}
	return mdac_datarel_send_cmd(rqp);
}

#define iosp_s  ((drliostatus_s+DRLPAGEOFFSET+(DRLMAX_PARALLELIOS*sizeof(u32bits)))&DRLPAGEMASK)

u08bits MLXFAR
mdac_datarel_rwtestfreemem(ctp, iosp)
mdac_ctldev_t MLXFAR *ctp;
drliostatus_t MLXFAR *iosp;
{
	u32bits inx;
	for(inx=0; inx<iosp->drlios_rqs; inx++)
		mlx_freemem(ctp,(u08bits *)iosp->drlios_rqp[inx],iosp->drlios_rqsize);
	if (iosp->drlios_randbit) mlx_freemem(ctp,(u08bits *)(iosp->drlios_randbit),iosp->drlios_randmemsize);
	mlx_freemem(ctp,(u08bits *)iosp,iosp_s);
	return 0;
}

/*** This code will not work for Sparc and Alpha ***/
#define MDAC_DATAREL_REQPAGES   2       /* # pages used in request buffer */
#define rwtestret(rc) { mdac_datarel_rwtestfreemem(ctp,iosp); return rc; }
u32bits MLXFAR
mdac_datarel_rwtest(rwp,op)
drlrwtest_t MLXFAR *rwp;
u32bits op;
{
	u32bits dev,devno,inx;
	mdac_sglist_t   MLXFAR *sgp;
	u08bits         MLXFAR *dp;
	mdac_req_t      MLXFAR *rqp;
	mdac_ctldev_t   MLXFAR *ctp;
	drliostatus_t   MLXFAR *iosp;

	if (rwp->drlrw_signature != DRLRW_SIG) return DRLERR_ACCESS;
	if (rwp->drlrw_maxblksize > DRLMAX_BLKSIZE) return DRLERR_BIGDATA;
	if (rwp->drlrw_devcnt < 1) return DRLERR_SMALLDATA;
	if (rwp->drlrw_devcnt > DRLMAX_BDEVS) return DRLERR_NODEV;
	if (rwp->drlrw_parallelios > DRLMAX_PARALLELIOS) return DRLERR_BIGDATA;
	if (rwp->drlrw_randlimit > DRLMAX_RANDLIMIT) return DRLERR_BIGDATA;
	rwp->drlrw_maxblksize = drl_alignsize(rwp->drlrw_maxblksize);
	if (!rwp->drlrw_maxblksize) rwp->drlrw_maxblksize = DAC_BLOCKSIZE;
	if (!rwp->drlrw_minblksize) rwp->drlrw_minblksize = rwp->drlrw_maxblksize;
	rwp->drlrw_minblksize = drl_alignsize(rwp->drlrw_minblksize);
	rwp->drlrw_ioinc = drl_alignsize(rwp->drlrw_ioinc);
	if (!rwp->drlrw_parallelios) rwp->drlrw_parallelios = 1;
	if (!(iosp=(drliostatus_t MLXFAR *)mdac_allocmem(mdac_ctldevtbl,iosp_s))) return DRLERR_NOMEM;
	for (devno=0; devno<rwp->drlrw_devcnt; devno++)
	{
		iosp->drlios_bdevs[devno] = dev = rwp->drlrw_bdevs[devno];
		if (!(ctp = mdac_datarel_dev2ctp(dev))) rwtestret(DRLERR_NODEV);
		iosp->drlios_ctp[devno] = ctp;
		if (rwp->drlrw_maxblksize <= ctp->cd_MaxDataTxSize) continue;
		if (drl_isosinterface(dev) && (rwp->drlrw_maxblksize <= 0x180000)) continue;
		rwtestret(DRLERR_BIGDATA);
	}
	iosp->drlios_randmemsize = (((rwp->drlrw_randlimit>>3)+32) + DRLPAGEOFFSET) & DRLPAGEMASK;
	if (iosp->drlios_randlimit = rwp->drlrw_randlimit)
		if (!(iosp->drlios_randbit=(u32bits MLXFAR *)mdac_allocmem(mdac_ctldevtbl,iosp->drlios_randmemsize)))
			rwtestret(DRLERR_NOMEM);
	iosp->drlios_rqsize = (DRLPAGESIZE*MDAC_DATAREL_REQPAGES) + ((rwp->drlrw_maxblksize+DRLPAGEOFFSET)&DRLPAGEMASK);
	if (rwp->drlrw_memaddroff || rwp->drlrw_memaddrinc) iosp->drlios_rqsize += DRLPAGESIZE;
	for (devno=0;devno<rwp->drlrw_parallelios;iosp->drlios_rqs++,devno++)
	{
		if (!(dp=mdac_allocmem(mdac_ctldevtbl,iosp->drlios_rqsize))) break;
		iosp->drlios_rqp[devno] = rqp = (mdac_req_t MLXFAR *)dp;
		dp += (DRLPAGESIZE*MDAC_DATAREL_REQPAGES);
		rqp->rq_DataVAddr = dp;
		dp[0]=0x6B; dp[1]=0x61; dp[2]=0x69; dp[3]=0x6C;
		dp[4]=0x61; dp[5]=0x73; dp[6]=0x68; dp[7]=0x20;
		mdaccopy(dp,dp+8,rwp->drlrw_maxblksize-8);
		mlx_kvtophyset(rqp->rq_PhysAddr,ctp,rqp);
		rqp->rq_DataOffset = mlx_kvtophys(ctp,dp); dp+=DRLPAGESIZE;
		sgp=rqp->rq_SGList; sgp++;
		for(dev=(iosp->drlios_rqsize/DRLPAGESIZE)-(MDAC_DATAREL_REQPAGES+1); dev; sgp++,dp+=DRLPAGESIZE,dev--)
			sgp->sg_PhysAddr = mlxswap(((u32bits)mlx_kvtophys(ctp,dp)));
	}
	if (!iosp->drlios_rqs) rwtestret(DRLERR_NOMEM);

/*      iosp->drlios_slpchan = DRL_EVENT_NULL;  AIX */
	iosp->drlios_signature = DRLIOS_SIG;
	iosp->drlios_randx = rwp->drlrw_randx;
	iosp->drlios_ioszrandx = rwp->drlrw_ioszrandx;
	iosp->drlios_rwmixrandx = rwp->drlrw_rwmixrandx;
	iosp->drlios_rwmixcnt = rwp->drlrw_rwmixcnt;
	iosp->drlios_startblk = rwp->drlrw_startblk;
	iosp->drlios_pendingios = iosp->drlios_iocount = rwp->drlrw_iocount;
	iosp->drlios_curpat = rwp->drlrw_pat;
	iosp->drlios_patinc = rwp->drlrw_patinc;
	iosp->drlios_parallelios = rwp->drlrw_parallelios;
	iosp->drlios_opflags = (rwp->drlrw_opflags & (~(DRLOP_READ|DRLOP_WRITE))) |
				((op & MDAC_RQOP_READ)? DRLOP_READ:DRLOP_WRITE);
	iosp->drlios_datacheck = rwp->drlrw_datacheck;
	iosp->drlios_memaddroff = rwp->drlrw_memaddroff & DRLPAGEOFFSET;
	iosp->drlios_memaddrinc = rwp->drlrw_memaddrinc & DRLPAGEOFFSET;
	iosp->drlios_maxblksperio = rwp->drlrw_maxblksize / DAC_BLOCKSIZE;
	iosp->drlios_devcnt = rwp->drlrw_devcnt;
	iosp->drlios_maxcylszuxblk = rwp->drlrw_devcnt * iosp->drlios_maxblksperio;
	iosp->drlios_minblksize = rwp->drlrw_minblksize;
	iosp->drlios_maxblksize = iosp->drlios_curblksize = rwp->drlrw_maxblksize;
	iosp->drlios_ioinc = rwp->drlrw_ioinc;
	iosp->drlios_eventcesr = rwp->drlrw_eventcesr;
	iosp->drlios_eventrace = ((rwp->drlrw_eventrace == DRLIO_EVENTRACE) && (mdac_datarel_cpu_family == 5)) ?
		rwp->drlrw_eventrace : 0;
	mdac_sleep_lock();
	rwp->drlrw_stime = iosp->drlios_stime = MLXCTIME();
	rwp->drlrw_slbolt = iosp->drlios_slbolt = MLXCLBOLT();
	for (inx=0; inx<iosp->drlios_rqs; inx++)
	{
		rqp = iosp->drlios_rqp[inx];
		rqp->rq_OpFlags = op;
		IOSP(rqp) = (OSReq_t MLXFAR *)iosp;
		rqp->rq_DataVAddr += iosp->drlios_memaddroff;
		rqp->rq_DataSize = mdac_datarel_randiosize(iosp);
		rqp->rq_CompIntr = mdac_datarel_rwtestintr;
		rqp->rq_BlkNo = mdac_datarel_blkno(iosp);
		mdac_datarel_nextblk(iosp,rqp->rq_DataSize);
		devno = uxblktodevno(iosp,rqp->rq_BlkNo);
		rqp->rq_BlkNo = pduxblk(iosp,rqp->rq_BlkNo);
		rqp->rq_ctp = iosp->drlios_ctp[devno];
		rqp->rq_Dev = dev = iosp->drlios_bdevs[devno];
		rqp->rq_ControllerNo=drl_ctl(dev);rqp->rq_ChannelNo=drl_ch(dev);
		rqp->rq_TargetID=drl_tgt(dev); rqp->rq_SysDevNo=drl_sysdev(dev);
		CURPAT(rqp) = iosp->drlios_curpat;
		iosp->drlios_curpat += rqp->rq_DataSize/sizeof(u32bits);
		iosp->drlios_opcounts++;
		iosp->drlios_pendingios--;
		iosp->drlios_memaddroff = (iosp->drlios_memaddroff+iosp->drlios_memaddrinc) & DRLPAGEOFFSET;
		mdac_sleep_unlock();
		if ((iosp->drlios_datacheck||(iosp->drlios_opflags&DRLOP_CHECKIMD)) && (!(rqp->rq_OpFlags & MDAC_RQOP_READ)))
			mdac_datarel_fillpat((u32bits*)rqp->rq_DataVAddr,CURPAT(rqp),iosp->drlios_patinc,rqp->rq_DataSize/sizeof(u32bits));
		rqp->rq_BlkNo += iosp->drlios_startblk;
		mdac_datarel_setsglist(rqp);
		mdac_datarel_setcmd(rqp);
		mdac_datarel_send_cmd(rqp);
		mdac_sleep_lock();
		if (iosp->drlios_opstatus & DRLOPS_ANYSTOP) break;
		if (iosp->drlios_pendingios) continue;
		iosp->drlios_opstatus |= DRLOPS_STOP;
		break;
	}
	for (inx=0; inx<DRLMAX_RWTEST; inx++)
	{       /* register the test operation */
		if (mdac_drliosp[inx]) continue;
		mdac_drliosp[inx] = iosp; /* This op started */
		break;
	}
	if (iosp->drlios_eventrace)
	{
		MLXSPLVAR;
		mdac_sleep_unlock();
		MLXSPL0();
		while (iosp->drlios_opcounts)
			mdac_datarel_halt_cpu();
		MLXSPL();
		mdac_sleep_lock();
	}
	else while (iosp->drlios_opcounts)
	{
		if (mdac_sleep(&iosp->drlios_slpchan,
		   (iosp->drlios_opstatus & DRLOPS_SIGSTOP)?
		    MLX_WAITWITHOUTSIGNAL:MLX_WAITWITHSIGNAL))
			iosp->drlios_opstatus |= DRLOPS_SIGSTOP;
	}
	rwp->drlrw_etime = MLXCTIME();
	rwp->drlrw_elbolt = MLXCLBOLT();
	for (inx=0; inx<DRLMAX_RWTEST; inx++)
		if (mdac_drliosp[inx] == iosp)
			mdac_drliosp[inx] = NULL; /* This op over */
	mdac_sleep_unlock();
	rwp->drlrw_diodone = iosp->drlios_diodone;
	rwp->drlrw_dtdone = iosp->drlios_dtdone;
	rwp->drlrw_reads = iosp->drlios_reads;
	rwp->drlrw_writes = iosp->drlios_writes;
	rwp->drlrw_iocount = iosp->drlios_pendingios;
	rwp->drlrw_randups = iosp->drlios_randups;
	rwp->drlrw_opstatus = iosp->drlios_opstatus;
	rwp->drlrw_randx = iosp->drlios_randx;
	rwp->drlrw_ioszrandx = iosp->drlios_ioszrandx;
	rwp->drlrw_rwmixrandx = iosp->drlios_rwmixrandx;
	rwp->drlrw_miscnt = iosp->drlios_miscnt;
	rwp->drlrw_goodpat = iosp->drlios_goodpat;
	rwp->drlrw_badpat = iosp->drlios_badpat;
	rwp->drlrw_uxblk = iosp->drlios_uxblk;
	rwp->drlrw_uxblkoff = iosp->drlios_uxblkoff;
	if (iosp->drlios_eventrace) mlx_copyout(&iosp->drlios_eventcnt,rwp->drlrw_eventcntp,sizeof(iosp->drlios_eventcnt));
	if (iosp->drlios_opstatus & DRLOPS_SIGSTOP) mdaccopy(rwp,&mdac_drlsigrwt,drlrwtest_s);
	rwtestret(0);
}
#undef  rwtestret
#undef  MDAC_DATAREL_REQPAGES

#ifndef i386
u32bits MLXFAR
mdac_datarel_fillpat(dp, curpat, patinc, patlen)
u32bits MLXFAR *dp, curpat, patinc, patlen;
{
	for (; patlen; curpat += patinc, dp++, patlen--)
		*dp = curpat;
	return 0;
}
#endif  /* i386 */

u32bits MLXFAR
mdac_datarel_checkpat(iosp,dp,curpat,patinc,patlen,blkno)
drliostatus_t MLXFAR *iosp;
u32bits MLXFAR *dp, curpat, patinc, patlen,blkno;
{
	u32bits sdp = (u32bits) dp;
	for (; patlen; curpat += patinc, dp++, patlen--)
	{
		if (*dp == curpat) continue;
		if (iosp->drlios_miscnt++) continue;
		iosp->drlios_goodpat = curpat;
		iosp->drlios_badpat = *dp;
		iosp->drlios_uxblk = blkno + iosp->drlios_startblk;
		iosp->drlios_uxblkoff = (u32bits)dp - sdp;
		if (iosp->drlios_opflags & DRLOP_STOPENABLED) iosp->drlios_opstatus |= DRLOPS_ERR;
#if     MLX_SCO || MLX_UW
		if ((iosp->drlios_opflags&DRLOP_KDBENABLED) && mdac_datarel_debug)
		{
			cmn_err(CE_CONT,"mdac_datarel_checkpat: good-data=%x bad-data=%x addr=%x\n",curpat,*dp, dp);
			mdac_calldebug();
		}
#endif  /* MLX_SCO || MLX_UW */
	}
	return 0;
}

/* set SG List sizes, and first memory address only */
u32bits MLXFAR
mdac_datarel_setsgsize(rqp)
mdac_req_t MLXFAR *rqp;
{
	u32bits sz = rqp->rq_DataSize;
	mdac_sglist_t MLXFAR *sgp=rqp->rq_SGList;
	sgp->sg_PhysAddr = rqp->rq_DataOffset;
	rqp->rq_SGLen = 0;
	if (rqp->rq_ctp->cd_MaxDataTxSize<sz) return DRLERR_BIGDATA; /* too big */
	if (sgp->sg_DataSize = ((u32bits)(rqp->rq_DataVAddr))&DRLPAGEOFFSET)
	{
		rqp->rq_SGLen = 1;
		sgp->sg_PhysAddr+=sgp->sg_DataSize; MLXSWAP(sgp->sg_PhysAddr);
		if ((sgp->sg_DataSize=DRLPAGESIZE-sgp->sg_DataSize) >= sz)
		{
			sgp->sg_DataSize = sz; MLXSWAP(sgp->sg_DataSize);
			return 0;
		}
		sz-=sgp->sg_DataSize; MLXSWAP(sgp->sg_DataSize);
		sgp++;
	}
	else MLXSWAP(sgp->sg_PhysAddr);
	for (; sz ; sgp++,rqp->rq_SGLen++)
	{
		sgp->sg_DataSize = mlx_min(sz,DRLPAGESIZE);
		sz-=sgp->sg_DataSize; MLXSWAP(sgp->sg_DataSize);
	}
	return 0;
}

/* set read/write command in DAC format */
u32bits MLXFAR
mdac_datarel_setrwcmd(rqp)
mdac_req_t MLXFAR *rqp;
{
	mdac_ctldev_t MLXFAR *ctp = rqp->rq_ctp;
	u32bits sz = mdac_bytes2blks(rqp->rq_DataSize);
	rqp->rq_FinishTime = mda_CurTime + (rqp->rq_TimeOut=17);
	dcmdp->mb_Datap=rqp->rq_PhysAddr.bit31_0+offsetof(mdac_req_t,rq_SGList);
	if (drl_isscsidev(rqp->rq_Dev)) goto out_scsi;
	MLXSWAP(dcmdp->mb_Datap);
	dcmdp->mb_MailBox2 = (u08bits) sz;
	dcmdp->mb_Command = DACMD_WITHSG | ((rqp->rq_OpFlags & MDAC_RQOP_READ)?
		ctp->cd_ReadCmd : ctp->cd_WriteCmd);
	if ((dcmdp->mb_MailBoxC = (u08bits)rqp->rq_SGLen) <= 1)
	{       /* send non SG List command */
		dcmdp->mb_Command &= ~DACMD_WITHSG;
		dcmdp->mb_MailBoxC = 0;
		dcmdp->mb_Datap = rqp->rq_SGList[0].sg_PhysAddr;
		MLXSWAP(dcmdp->mb_Datap);
	}
	dcmd4p->mb_MailBox4_7 = rqp->rq_BlkNo; MLXSWAP(dcmd4p->mb_MailBox4_7);
	if (ctp->cd_FWVersion < DAC_FW300)
	{       /* firmware 1.x and 2.x command */
		dcmdp->mb_MailBox3 = (rqp->rq_BlkNo >> (24-6)) & 0xC0;
		dcmdp->mb_SysDevNo=rqp->rq_SysDevNo;/* This must come after block setup */
		return 0;
	}
	dcmdp->mb_MailBox3=(rqp->rq_SysDevNo<<3)+(sz>>8); /* FW 3.x command */
	return 0;

out_scsi:/* generate SCSI CDB command for operation */
	dcmd4p->mb_MailBox0_3=0;dcmd4p->mb_MailBox4_7=0;dcmd4p->mb_MailBoxC_F=0;
	dcmdp->mb_Command = DACMD_DCDB | DACMD_WITHSG;
	dcdbp->db_ChannelTarget = mdac_chantgt(rqp->rq_ChannelNo,rqp->rq_TargetID);
	dcdbp->db_SenseLen = DAC_SENSE_LEN;
	dcdbp->db_CdbLen = UCSGROUP1_LEN;
	mdac_setcdbtxsize(rqp->rq_DataSize);
	if (rqp->rq_OpFlags & MDAC_RQOP_READ)
	{       /* read command */
		dcdbp->db_DATRET = DAC_DCDB_XFER_READ|DAC_DCDB_DISCONNECT|DAC_DCDB_TIMEOUT_10sec;
		UCSMAKECOM_G1(scdbp,UCSCMD_EREAD,rqp->rq_LunID,rqp->rq_BlkNo,sz);
	}
	else
	{       /* write  command */
		dcdbp->db_DATRET = DAC_DCDB_XFER_WRITE|DAC_DCDB_DISCONNECT|DAC_DCDB_TIMEOUT_10sec;
		UCSMAKECOM_G1(scdbp,UCSCMD_EWRITE,rqp->rq_LunID,rqp->rq_BlkNo,sz);
	}
	rqp->rq_pdp=dev2pdp(ctp,rqp->rq_ChannelNo&0x3F,rqp->rq_TargetID,rqp->rq_LunID);
	rqp->rq_CompIntrBig = rqp->rq_CompIntr; /* save it for gam comp func */
	rqp->rq_CompIntr = mdac_gam_scdb_intr;
	mdac_setscdbsglen(ctp);
	if (rqp->rq_SGLen > 1) return 0;
	dcmdp->mb_Command &= ~DACMD_WITHSG;
	dcmdp->mb_MailBoxC = 0;
	dcdbp->db_PhysDatap = rqp->rq_SGList[0].sg_PhysAddr;
	MLXSWAP(dcdbp->db_PhysDatap);
	return 0;
}

/* return the status of rwtest operation */
u32bits MLXFAR
mdac_datarel_rwtest_status(rwsp,cmd)
drl_rwteststatus_t MLXFAR *rwsp;
u32bits cmd;
{
	u32bits inx;
	drliostatus_t MLXFAR *iosp;
	mdac_sleep_lock();
	if ((inx=rwsp->drlrwst_TestNo) >= DRLMAX_RWTEST) goto outerr;
	if (cmd == DRLIOC_GETRWTESTSTATUS)
		if (iosp=mdac_drliosp[inx]) goto out;
		else goto outerr;
	if (cmd == DRLIOC_STOPRWTEST)
	{
		if (!(iosp=mdac_drliosp[inx])) goto outerr;
		iosp->drlios_opstatus |= DRLOPS_USERSTOP;
		goto out;
	}
	for ( ; inx<DRLMAX_RWTEST; inx++)
		if (iosp=mdac_drliosp[inx]) goto out;
outerr: mdac_sleep_unlock();
	return DRLERR_NODEV;

#define rwp     (&rwsp->drlrwst_rwtest)
out:    mdaczero(rwsp,drl_rwteststatus_s);
	rwsp->drlrwst_TestNo = (u16bits)inx;
	rwp->drlrw_etime = MLXCTIME();
	rwp->drlrw_elbolt = MLXCLBOLT();
	drl_txios2rw(iosp,rwp);
	mdac_sleep_unlock();
	return 0;
#undef  rwp
}
/*==========================DATAREL ENDS====================================*/

/*====================DATAREL COPY/COMPARE CODE STARTS======================*/
#define ALIGNTODRLPAGE(ad)      (((u32bits)ad+DRLPAGEOFFSET) & DRLPAGEMASK)
#define IODCP(rqp)      rqp->rq_OSReqp
#define DIODCP(rqp)     ((drlcopy_t MLXFAR *)IODCP(rqp))
#define CCSETIOSIZE(rqp,dcp) \
	if ((dcp->drlcp_opsizeblks - rqp->rq_BlkNo) < dcp->drlcp_blksperio)\
		rqp->rq_DataSize=drl_dbtob(dcp->drlcp_opsizeblks-rqp->rq_BlkNo);
#define CCSETDEV(rqp,dev) \
{       /* setup the device information */ \
	rqp->rq_Dev = dev; \
	rqp->rq_ctp = mdac_datarel_dev2ctp(dev); \
	rqp->rq_ControllerNo=drl_ctl(dev);rqp->rq_ChannelNo=drl_ch(dev); \
	rqp->rq_TargetID=drl_tgt(dev); rqp->rq_SysDevNo=drl_sysdev(dev); \
}


/* This function is called when source read is done for copy */
u32bits MLXFAR
mdac_datarelsrc_copyintr(rqp)
mdac_req_t MLXFAR *rqp;
{
	MLXSPLVAR;
	drlcopy_t MLXFAR *dcp = DIODCP(rqp);
	MLXSPL();
	mdac_sleep_lock();
	if (dcmdp->mb_Status) goto out_err;
	if (rqp->rq_ResdSize) goto out;
	dcp->drlcp_srcdtdone += drl_btodb(rqp->rq_DataSize);
	dcp->drlcp_reads++;
	if (dcp->drlcp_opstatus & DRLOPS_ANYSTOP) goto out;
	mdac_sleep_unlock();
	MLXSPLX();
	rqp->rq_OpFlags = MDAC_RQOP_WRITE;
	CCSETDEV(rqp,dcp->drlcp_tgtedev);
	rqp->rq_BlkNo = (rqp->rq_BlkNo - dcp->drlcp_srcstartblk) + dcp->drlcp_tgtstartblk;
	rqp->rq_CompIntr = mdac_datareltgt_copyintr;
	mdac_datarel_setcmd(rqp);
	return mdac_datarel_send_cmd(rqp);

out_err:dcp->drlcp_opstatus |= DRLOPS_ERR;
	dcp->drlcp_erredev = rqp->rq_Dev;
	dcp->drlcp_errblkno = rqp->rq_BlkNo;
out:    dcp->drlcp_opcounts--;
	if (!dcp->drlcp_opcounts) mdac_wakeup(&dcp->drlcp_oslpchan);
	mdac_sleep_unlock();
	MLXSPLX();
	return 0;
}

/* This function is called when target write is done for copy */
u32bits MLXFAR
mdac_datareltgt_copyintr(rqp)
mdac_req_t MLXFAR *rqp;
{
	MLXSPLVAR;
	drlcopy_t MLXFAR *dcp = DIODCP(rqp);
	MLXSPL();
	mdac_sleep_lock();
	if (dcmdp->mb_Status) goto out_err;
	if (rqp->rq_ResdSize) goto out;
	dcp->drlcp_tgtdtdone += drl_btodb(rqp->rq_DataSize);
	dcp->drlcp_writes++;
	if (dcp->drlcp_nextblkno>=dcp->drlcp_opsizeblks) goto out;
	if (dcp->drlcp_opstatus & DRLOPS_ANYSTOP) goto out;
	rqp->rq_BlkNo = dcp->drlcp_nextblkno + dcp->drlcp_srcstartblk;
	dcp->drlcp_nextblkno += dcp->drlcp_blksperio;
	mdac_sleep_unlock();
	MLXSPLX();
	CCSETIOSIZE(rqp,dcp);
	CCSETDEV(rqp,dcp->drlcp_srcedev);
	rqp->rq_OpFlags = MDAC_RQOP_READ;
	rqp->rq_CompIntr = mdac_datarelsrc_copyintr;
	mdac_datarel_setcmd(rqp);
	return mdac_datarel_send_cmd(rqp);

out_err:dcp->drlcp_opstatus |= DRLOPS_ERR;
	dcp->drlcp_erredev = rqp->rq_Dev;
	dcp->drlcp_errblkno = rqp->rq_BlkNo;
out:    dcp->drlcp_opcounts--;
	if (!dcp->drlcp_opcounts) mdac_wakeup(&dcp->drlcp_oslpchan);
	mdac_sleep_unlock();
	MLXSPLX();
	return 0;
}

/* compare the data which has errors */
u32bits MLXFAR
mdac_datarel_datacmp(dcp,srqp,trqp,count)
drlcopy_t       MLXFAR *dcp;
mdac_req_t      MLXFAR *srqp;
mdac_req_t      MLXFAR *trqp;
u32bits count;
{
	u32bits MLXFAR *sp = (u32bits MLXFAR *)srqp->rq_DataVAddr;
	u32bits MLXFAR *tp = (u32bits MLXFAR *)trqp->rq_DataVAddr;
	for (count = count/sizeof(u32bits); count; sp++,tp++,count--)
	{
		if (*sp == *tp) continue;
		if (dcp->drlcp_mismatchcnt++) continue;
		dcp->drlcp_firstmmblkno=srqp->rq_BlkNo+drl_btodb(((u32bits)sp)-((u32bits)srqp->rq_DataVAddr));
		dcp->drlcp_firstmmblkoff= (((u32bits)sp)-((u32bits)srqp->rq_DataVAddr)) & (DRL_DEV_BSIZE-1);
	}
	return 0;
}

#ifndef i386
u32bits MLXFAR
mdac_datarel_fastcmp4(sp, dp, count)
u32bits MLXFAR *sp;
u32bits MLXFAR *dp;
u32bits count;
{
	for (count = count/sizeof(u32bits); count; sp++, dp++, count--)
		if (*sp != *dp) return count;
	return 0;
}
#endif  /* i386 */

mdac_req_t MLXFAR*
mdac_datarel_cmpaireq(rqp)
mdac_req_t MLXFAR *rqp;
{
	drlcopy_t       MLXFAR *dcp = DIODCP(rqp);
	mdac_req_t      MLXFAR *trqp;
	mdac_req_t      MLXFAR *savedrqp;
	if (!(trqp=dcp->drlcp_firstcmpbp)) return trqp;
	if (trqp->rq_BlkNo == rqp->rq_BlkNo)
	{       /* very first entry, no need to scan */
		dcp->drlcp_firstcmpbp = trqp->rq_Next;
		return trqp;
	}
	for (savedrqp=trqp,trqp=trqp->rq_Next; trqp; savedrqp=trqp,trqp=trqp->rq_Next)
	{       /* let us scan the chain */
		if (trqp->rq_BlkNo != rqp->rq_BlkNo) continue;
		savedrqp->rq_Next = trqp->rq_Next;
		if (trqp->rq_Next)
			trqp->rq_Next = NULL;
		else
			savedrqp->rq_Next = NULL;
		return trqp;
	}
	return NULL;
}

/* This function is called when source read is done for compare */
u32bits MLXFAR
mdac_datarelsrc_cmpintr(srqp)
mdac_req_t MLXFAR *srqp;
{
	MLXSPLVAR;
	drlcopy_t       MLXFAR *dcp = DIODCP(srqp);
	mdac_req_t      MLXFAR *trqp;
	MLXSPL();
	mdac_sleep_lock();
	srqp->rq_BlkNo -= dcp->drlcp_srcstartblk;       /* get block in op area */
	trqp = mdac_datarel_cmpaireq(srqp);
	if (srqp->rq_DacCmd.mb_Status) goto out_err;
	if (srqp->rq_ResdSize) goto out_one;
	dcp->drlcp_srcdtdone += drl_btodb(srqp->rq_DataSize);
	dcp->drlcp_reads++;
	if (dcp->drlcp_opstatus & DRLOPS_ANYSTOP) goto out_all;
	if (!trqp)
	{
		srqp->rq_Next = dcp->drlcp_firstcmpbp;
		dcp->drlcp_firstcmpbp = srqp;
		mdac_sleep_unlock();
		MLXSPLX();
		return 0;
	}
	mdac_sleep_unlock();
	if (mdac_datarel_fastcmp4((u32bits MLXFAR*)srqp->rq_DataVAddr,(u32bits MLXFAR*)trqp->rq_DataVAddr,srqp->rq_DataSize))
		mdac_datarel_datacmp(dcp,srqp,trqp,srqp->rq_DataSize);
	mdac_sleep_lock();
	if (dcp->drlcp_nextblkno >= dcp->drlcp_opsizeblks) goto out_one;
	srqp->rq_BlkNo = dcp->drlcp_nextblkno + dcp->drlcp_srcstartblk;
	trqp->rq_BlkNo = dcp->drlcp_nextblkno + dcp->drlcp_tgtstartblk;
	dcp->drlcp_nextblkno += dcp->drlcp_blksperio;
	mdac_sleep_unlock();
	MLXSPLX();
	CCSETIOSIZE(srqp,dcp);
	CCSETIOSIZE(trqp,dcp);
	mdac_datarel_setcmd(srqp);
	mdac_datarel_setcmd(trqp);
	mdac_datarel_send_cmd(srqp);
	mdac_datarel_send_cmd(trqp);
	return 0;

out_err:dcp->drlcp_opstatus |= DRLOPS_ERR;
	dcp->drlcp_erredev = srqp->rq_Dev;
	dcp->drlcp_errblkno = srqp->rq_BlkNo + dcp->drlcp_srcstartblk;
out_all:for (srqp=dcp->drlcp_firstcmpbp; srqp; srqp=srqp->rq_Next)
		dcp->drlcp_opcounts--;
	dcp->drlcp_firstcmpbp=NULL;
out_one:if (trqp) dcp->drlcp_opcounts--;
	dcp->drlcp_opcounts--;
	if (!dcp->drlcp_opcounts) mdac_wakeup(&dcp->drlcp_oslpchan);
	mdac_sleep_unlock();
	MLXSPLX();
	return 0;
}

/* This function is called when target read is done for compare */
u32bits MLXFAR
mdac_datareltgt_cmpintr(trqp)
mdac_req_t MLXFAR *trqp;
{
	MLXSPLVAR;
	drlcopy_t       MLXFAR *dcp = DIODCP(trqp);
	mdac_req_t      MLXFAR *srqp;
	MLXSPL();
	mdac_sleep_lock();
	trqp->rq_BlkNo -= dcp->drlcp_tgtstartblk;       /* get block in op area */
	srqp = mdac_datarel_cmpaireq(trqp);
	if (trqp->rq_DacCmd.mb_Status) goto out_err;
	if (trqp->rq_ResdSize) goto out_one;
	dcp->drlcp_tgtdtdone += drl_btodb(trqp->rq_DataSize);
	dcp->drlcp_reads++;
	if (dcp->drlcp_opstatus & DRLOPS_ANYSTOP) goto out_all;
	if (!srqp)
	{
		trqp->rq_Next = dcp->drlcp_firstcmpbp;
		dcp->drlcp_firstcmpbp = trqp;
		mdac_sleep_unlock();
		MLXSPLX();
		return 0;
	}
	mdac_sleep_unlock();
	if (mdac_datarel_fastcmp4((u32bits MLXFAR*)srqp->rq_DataVAddr,(u32bits MLXFAR*)trqp->rq_DataVAddr,trqp->rq_DataSize))
		mdac_datarel_datacmp(dcp,srqp,trqp,trqp->rq_DataSize);
	mdac_sleep_lock();
	if (dcp->drlcp_nextblkno >= dcp->drlcp_opsizeblks) goto out_one;
	srqp->rq_BlkNo = dcp->drlcp_nextblkno + dcp->drlcp_srcstartblk;
	trqp->rq_BlkNo = dcp->drlcp_nextblkno + dcp->drlcp_tgtstartblk;
	dcp->drlcp_nextblkno += dcp->drlcp_blksperio;
	mdac_sleep_unlock();
	MLXSPLX();
	CCSETIOSIZE(srqp,dcp);
	CCSETIOSIZE(trqp,dcp);
	mdac_datarel_setcmd(srqp);
	mdac_datarel_setcmd(trqp);
	mdac_datarel_send_cmd(srqp);
	mdac_datarel_send_cmd(trqp);
	return 0;

out_err:dcp->drlcp_opstatus |= DRLOPS_ERR;
	dcp->drlcp_erredev = trqp->rq_Dev;
	dcp->drlcp_errblkno = trqp->rq_BlkNo + dcp->drlcp_tgtstartblk;
out_all:for (trqp=dcp->drlcp_firstcmpbp; trqp; trqp=trqp->rq_Next)
		dcp->drlcp_opcounts--;
	dcp->drlcp_firstcmpbp=NULL;
out_one:if (srqp) dcp->drlcp_opcounts--;
	dcp->drlcp_opcounts--;
	if (!dcp->drlcp_opcounts) mdac_wakeup(&dcp->drlcp_oslpchan);
	mdac_sleep_unlock();
	MLXSPLX();
	return 0;
}

/* send the first time copy/compare command to hardware */
u32bits MLXFAR
mdac_datarelcopycmpsendfirstcmd(rqp)
mdac_req_t MLXFAR *rqp;
{
	u32bits         inx;
	mdac_ctldev_t   MLXFAR *ctp = rqp->rq_ctp;
	drlcopy_t       MLXFAR *dcp = DIODCP(rqp);
	u08bits         MLXFAR *dp = (u08bits MLXFAR*)rqp->rq_DataVAddr;
	mdac_sglist_t   MLXFAR *sgp = rqp->rq_SGList; sgp++;
	mlx_kvtophyset(rqp->rq_PhysAddr,ctp,rqp);
	rqp->rq_DataOffset = mlx_kvtophys(ctp,dp); dp+=DRLPAGESIZE;
	for(inx=(ALIGNTODRLPAGE(rqp->rq_DataSize)/DRLPAGESIZE)-1; inx; sgp++,dp+=DRLPAGESIZE,inx--)
		sgp->sg_PhysAddr = mlxswap(((u32bits)mlx_kvtophys(ctp,dp)));
	CCSETIOSIZE(rqp,dcp);
	mdac_datarel_setsglist(rqp);
	mdac_datarel_setcmd(rqp);
	return mdac_datarel_send_cmd(rqp);
}

#define copycmpret(rc)  { mlx_freemem(ctp,memp,memsize); return DRLERR_INVAL; }
u32bits MLXFAR
mdac_datarel_copycmp(udcp,cmd)
drlcopy_t MLXFAR *udcp;
u32bits cmd;
{
	u32bits memsize,inx,nextblkno;
	u08bits         MLXFAR *memp;
	u08bits         MLXFAR *tmemp;
	mdac_req_t      MLXFAR *rqp;
	drlcopy_t       MLXFAR *kdcp;
	mdac_ctldev_t   MLXFAR *ctp;
	drldevsize_t    ds;
	MLXSPLVAR;

	if (udcp->drlcp_signature != DRLCP_SIG) return DRLERR_ACCESS;
	if (udcp->drlcp_blksize > DRLMAX_BLKSIZE) return DRLERR_BIGDATA;
	if (udcp->drlcp_parallelios > DRLMAX_PARALLELIOS) return DRLERR_BIGDATA;
	if (!udcp->drlcp_blksize) udcp->drlcp_blksize = DRL_DEV_BSIZE;
	if (!udcp->drlcp_parallelios) udcp->drlcp_parallelios = 2;
	memsize = ((udcp->drlcp_blksize+DRLPAGESIZE+DRLPAGESIZE+DRLPAGESIZE) * udcp->drlcp_parallelios) + DRLPAGESIZE + DRLPAGESIZE;
	if (cmd == DRLIOC_DATACMP) memsize += memsize;
	if (!(memp=mdac_allocmem(mdac_ctldevtbl,memsize))) return DRLERR_NOMEM;
	tmemp = memp;
	kdcp =  (drlcopy_t MLXFAR *)tmemp; tmemp += DRLPAGESIZE;
	rqp = (mdac_req_t MLXFAR*)tmemp; tmemp += udcp->drlcp_parallelios * DRLPAGESIZE;
		ctp = rqp->rq_ctp;
	if (cmd == DRLIOC_DATACMP) tmemp+=udcp->drlcp_parallelios*DRLPAGESIZE;

	kdcp->drlcp_signature = DRLCP_SIG;
	kdcp->drlcp_opflags = udcp->drlcp_opflags;
/*      kdcp->drlcp_oslpchan = DRL_EVENT_NULL;  AIX */
	kdcp->drlcp_blksperio = drl_btodb(udcp->drlcp_blksize);
	if (!kdcp->drlcp_blksperio) kdcp->drlcp_blksperio = 1;
	kdcp->drlcp_blksize = drl_dbtob(kdcp->drlcp_blksperio);
	kdcp->drlcp_srcstartblk = udcp->drlcp_srcstartblk;
	kdcp->drlcp_tgtstartblk = udcp->drlcp_tgtstartblk;
	kdcp->drlcp_opsizeblks = udcp->drlcp_opsizeblks;
	kdcp->drlcp_parallelios = udcp->drlcp_parallelios;

	kdcp->drlcp_srcedev = ds.drlds_bdev = udcp->drlcp_srcedev;
	if (mdac_datarel_devsize(&ds)) copycmpret(DRLERR_NODEV);
	if ((kdcp->drlcp_srcdevsz = ds.drlds_devsize) < kdcp->drlcp_opsizeblks) copycmpret(DRLERR_BIGDATA);
	if ((kdcp->drlcp_srcstartblk+kdcp->drlcp_opsizeblks)>kdcp->drlcp_srcdevsz) copycmpret(DRLERR_BIGDATA);
	ctp = mdac_datarel_dev2ctp(kdcp->drlcp_srcedev);
	if(!ctp) return DRLERR_NODEV;
	if (kdcp->drlcp_blksize > ctp->cd_MaxDataTxSize)
		if (!(drl_isosinterface(kdcp->drlcp_srcedev) && (kdcp->drlcp_blksize <= 0x180000)))
			copycmpret(DRLERR_BIGDATA);

	kdcp->drlcp_tgtedev = ds.drlds_bdev = udcp->drlcp_tgtedev;
	if (mdac_datarel_devsize(&ds)) copycmpret(DRLERR_NODEV);
	if ((kdcp->drlcp_tgtdevsz = ds.drlds_devsize) < kdcp->drlcp_opsizeblks) copycmpret(DRLERR_BIGDATA);
	if ((kdcp->drlcp_tgtstartblk+kdcp->drlcp_opsizeblks)>kdcp->drlcp_tgtdevsz) copycmpret(DRLERR_BIGDATA);
	ctp = mdac_datarel_dev2ctp(kdcp->drlcp_tgtedev);
	if(!ctp) return DRLERR_NODEV;
	if (kdcp->drlcp_blksize > ctp->cd_MaxDataTxSize)
		if (!(drl_isosinterface(kdcp->drlcp_tgtedev) && (kdcp->drlcp_blksize <= 0x180000)))
			copycmpret(DRLERR_BIGDATA);
	MLXSPL();
	mdac_sleep_lock();
	kdcp->drlcp_timelbolt = MLXCLBOLT();
	for (inx=udcp->drlcp_parallelios; inx; inx--)
	{
		rqp->rq_OpFlags |= MDAC_RQOP_READ;
		IODCP(rqp) = (OSReq_t MLXFAR*)kdcp;
		rqp->rq_DataVAddr = (u08bits MLXFAR *)ALIGNTODRLPAGE(tmemp);
		rqp->rq_DataSize = kdcp->drlcp_blksize;
		tmemp += kdcp->drlcp_blksize;
		CCSETDEV(rqp,kdcp->drlcp_srcedev);
		rqp->rq_CompIntr = (cmd == DRLIOC_DATACOPY) ?
			mdac_datarelsrc_copyintr : mdac_datarelsrc_cmpintr;
		rqp->rq_BlkNo = kdcp->drlcp_nextblkno + kdcp->drlcp_srcstartblk;
		kdcp->drlcp_nextblkno += kdcp->drlcp_blksperio;
		kdcp->drlcp_opcounts++;
		mdac_sleep_unlock();
		mdac_datarelcopycmpsendfirstcmd(rqp);
		mdac_sleep_lock();
		rqp = (mdac_req_t MLXFAR*)(((u32bits)rqp) + DRLPAGESIZE);
	}
	if (cmd == DRLIOC_DATACMP)
	for (inx=udcp->drlcp_parallelios,nextblkno=0; inx; inx--)
	{       /* start IOs on target device too */
		rqp->rq_OpFlags |= MDAC_RQOP_READ;
		IODCP(rqp) = (OSReq_t MLXFAR*)kdcp;
		rqp->rq_DataVAddr = (u08bits MLXFAR *)ALIGNTODRLPAGE(tmemp);
		rqp->rq_DataSize = kdcp->drlcp_blksize;
		tmemp += kdcp->drlcp_blksize;
		CCSETDEV(rqp,kdcp->drlcp_tgtedev);
		rqp->rq_CompIntr = mdac_datareltgt_cmpintr;
		rqp->rq_BlkNo = nextblkno + kdcp->drlcp_tgtstartblk;
		nextblkno += kdcp->drlcp_blksperio;
		kdcp->drlcp_opcounts++;
		mdac_sleep_unlock();
		mdac_datarelcopycmpsendfirstcmd(rqp);
		mdac_sleep_lock();
		rqp = (mdac_req_t MLXFAR*)(((u32bits)rqp)+DRLPAGESIZE);
	}
	for (inx=0; inx<DRLMAX_COPYCMP; inx++)
	{       /* register the new copy/compare operation */
		if (mdac_drlcopyp[inx]) continue;
		mdac_drlcopyp[inx] = kdcp;      /* This op started */
		break;
	}
	while (kdcp->drlcp_opcounts)
	{
		if (mdac_sleep(&kdcp->drlcp_oslpchan,
		   (kdcp->drlcp_opstatus & DRLOPS_SIGSTOP)?
		    MLX_WAITWITHOUTSIGNAL:MLX_WAITWITHSIGNAL))
			kdcp->drlcp_opstatus |= DRLOPS_SIGSTOP;
	}
	kdcp->drlcp_timelbolt = MLXCLBOLT() - kdcp->drlcp_timelbolt;
	for (inx=0; inx<DRLMAX_COPYCMP; inx++)
		if (mdac_drlcopyp[inx] == kdcp)
			mdac_drlcopyp[inx] = NULL;      /* This op over */
	mdac_sleep_unlock();
	MLXSPLX();
	mdaccopy(kdcp,udcp,drlcopy_s);
	if (kdcp->drlcp_opstatus & DRLOPS_SIGSTOP) mdaccopy(kdcp,&mdac_drlsigcopycmp,drlcopy_s);
	mlx_freemem(ctp,memp,memsize);
	return 0;
}

/* return the status of copy/compare operation */
u32bits MLXFAR
mdac_datarel_copycmp_status(cpsp,cmd)
drl_copycmpstatus_t MLXFAR *cpsp;
u32bits cmd;
{
	u32bits inx;
	drlcopy_t MLXFAR *dcp;
	cpsp->drlcpst_Reserved0=0; cpsp->drlcpst_Reserved1=0; cpsp->drlcpst_Reserved2=0;
	mdac_sleep_lock();
	if ((inx=cpsp->drlcpst_TestNo) >= DRLMAX_COPYCMP) goto outerr;
	if (cmd == DRLIOC_GETCOPYCMPSTATUS)
		if (dcp=mdac_drlcopyp[inx]) goto out;
		else goto outerr;
	if (cmd == DRLIOC_STOPCOPYCMP)
	{
		if (!(dcp=mdac_drlcopyp[inx])) goto outerr;
		dcp->drlcp_opstatus |= DRLOPS_USERSTOP;
		goto out;
	}
	for ( ; inx<DRLMAX_COPYCMP; inx++)
		if (dcp=mdac_drlcopyp[inx]) goto out;
outerr: mdac_sleep_unlock();
	return DRLERR_NODEV;

out:    cpsp->drlcpst_copycmp = *dcp;
	cpsp->drlcpst_copycmp.drlcp_timelbolt = MLXCLBOLT() - dcp->drlcp_timelbolt;
	mdac_sleep_unlock();
	return 0;
}
#else

u32bits MLXFAR
mdac_datarel_copycmp_status(drl_copycmpstatus_t MLXFAR* cpsp, u32bits cmd)
{

   return 0;
}

u32bits MLXFAR
mdac_datarel_rwtestintr(rqp)
mdac_req_t MLXFAR *rqp;
{
    return 0;
}
u32bits MLXFAR
mdac_datarel_copycmp(udcp,cmd)
drlcopy_t MLXFAR *udcp;
u32bits cmd;
{
    return 0;
}
u32bits MLXFAR
mdac_datarel_rwtest_status(rwsp,cmd)
drl_rwteststatus_t MLXFAR *rwsp;
u32bits cmd;
{
    return 0;
}

u32bits MLXFAR
mdac_datarel_devsize(dsp)
drldevsize_t MLXFAR *dsp;
{
    return 0;
}

u32bits MLXFAR
mdac_datarel_rwtest(rwp,op)
drlrwtest_t MLXFAR *rwp;
u32bits op;
{
    return 0;
}
#endif /* defined(_WIN64) || defined(SCSIPORT_COMPLIANT) */
#endif /* end if not OS2 */

#else
u32bits MLXFAR
mdac_datarel_copycmp_status(drl_copycmpstatus_t MLXFAR* cpsp, u32bits cmd)
{

   return 0;
}

u32bits MLXFAR
mdac_datarel_rwtestintr(rqp)
mdac_req_t MLXFAR *rqp;
{
    return 0;
}
u32bits MLXFAR
mdac_datarel_copycmp(udcp,cmd)
drlcopy_t MLXFAR *udcp;
u32bits cmd;
{
    return 0;
}
u32bits MLXFAR
mdac_datarel_rwtest_status(rwsp,cmd)
drl_rwteststatus_t MLXFAR *rwsp;
u32bits cmd;
{
    return 0;
}

u32bits MLXFAR
mdac_datarel_devsize(dsp)
drldevsize_t MLXFAR *dsp;
{
    return 0;
}

u32bits MLXFAR
mdac_datarel_rwtest(rwp,op)
drlrwtest_t MLXFAR *rwp;
u32bits op;
{
    return 0;
}


/*====================DATAREL COPY/COMPARE CODE ENDS========================*/
#endif /* MLX_DOS */

#ifdef MLX_OS2
u32bits  mdac_driver_data_end;
#endif


#ifdef OLD /**** To be removed ***/
/* Initialize the controller and information */
u32bits MLXFAR
mdac_ctlinit(ctp)
mdac_ctldev_t MLXFAR *ctp;
{
	u32bits inx,ch,tgt,lun;
	dac_biosinfo_t MLXFAR *biosp;
	if (!ctp->cd_CmdIDMemAddr)
	{       /* allocate the command IDs */
		mdac_cmdid_t MLXFAR *cidp=(mdac_cmdid_t MLXFAR*)mdac_alloc4kb(ctp);
		if (!(ctp->cd_CmdIDMemAddr=(u08bits MLXFAR*)cidp)) return ERR_NOMEM;
		ctp->cd_FreeCmdIDs=(4*ONEKB)/mdac_cmdid_s;
		ctp->cd_FreeCmdIDList=cidp;
		for (inx=0,cidp->cid_cmdid=inx+1; inx<(((4*ONEKB)/mdac_cmdid_s)-1); cidp++,inx++,cidp->cid_cmdid=inx+1)
			cidp->cid_Next = cidp+1;
	}

	if (!ctp->cd_PhysDevTbl)
	{       /* allocate the physical device table */
#define sz      MDAC_MAXPHYSDEVS*mdac_physdev_s
		mdac_physdev_t MLXFAR *pdp=(mdac_physdev_t MLXFAR*)mdac_allocmem(ctp,sz);
		if (!(ctp->cd_PhysDevTbl=pdp)) return ERR_NOMEM;
		MLXSTATS(mda_MemAlloced+=sz;)
		ctp->cd_PhysDevTblMemSize = sz;
		for (ch=0; ch<MDAC_MAXCHANNELS; ch++)
		 for (tgt=0; tgt<MDAC_MAXTARGETS; tgt++)
		  for (lun=0; lun<MDAC_MAXLUNS; pdp++, lun++)
		{
			pdp->pd_ControllerNo = ctp->cd_ControllerNo;
			pdp->pd_ChannelNo = ch;
			pdp->pd_TargetID = tgt;
			pdp->pd_LunID = lun;
			pdp->pd_BlkSize = 1;
		}
		ctp->cd_Lastpdp = pdp;
#undef  sz
	}

	if (biosp=mdac_getpcibiosaddr(ctp))
	{       /* we got the BIOS information address */
		ctp->cd_MajorBIOSVersion = biosp->bios_MajorVersion;
		ctp->cd_MinorBIOSVersion = biosp->bios_MinorVersion;
		ctp->cd_InterimBIOSVersion = biosp->bios_InterimVersion;
		ctp->cd_BIOSVendorName = biosp->bios_VendorName;
		ctp->cd_BIOSBuildMonth = biosp->bios_BuildMonth;
		ctp->cd_BIOSBuildDate = biosp->bios_BuildDate;
		ctp->cd_BIOSBuildYearMS = biosp->bios_BuildYearMS;
		ctp->cd_BIOSBuildYearLS = biosp->bios_BuildYearLS;
		ctp->cd_BIOSBuildNo = biosp->bios_BuildNo;
		ctp->cd_BIOSAddr = biosp->bios_MemAddr;
		ctp->cd_BIOSSize = biosp->bios_RunTimeSize * 512;
	}
	if (inx=mdac_ctlhwinit(ctp)) return inx;        /* set HW parameters */
	if (!ctp->cd_ReqBufsAlloced)
	{
#ifdef  MLX_DOS
	    mdac_allocreqbufs(ctp, 1);
#else
	    mdac_allocreqbufs(ctp, ctp->cd_MaxCmds*2);          /* two sets of bufs */
#endif  /* MLX_DOS */
	}

	mdac_setnewsglimit(ctp->cd_FreeReqList, ctp->cd_MaxSGLen);

	ctp->cd_Status |= MDACD_PRESENT;
	return 0;
}
#endif /*** OLD628 ***/

void ia64debug(UINT_PTR i);
void ia64debugPointer(UINT_PTR add);
void IOCTLTrack(u32bits ioctl);
void mybreak(void);

void ia64debug(UINT_PTR i)
{
	globaldebug[globaldebugcount++] = i;
    if (globaldebugcount >= 200)
		globaldebugcount = 0;
	globaldebug[globaldebugcount]= (UINT_PTR)0xFF0FF0FF0FF0FF0;
}

void mybreak()
{
   int u=7;

   u= u+7;
}

void IOCTLTrack(u32bits ioctl)
{
   IOCTLTrackBuf[IOCTLTrackBufCount++]=ioctl;
   if (IOCTLTrackBufCount>= 200)
		IOCTLTrackBufCount = 0;

}

void ia64debugPointer(UINT_PTR add)
{
	debugPointer[debugPointerCount++]= add;
		if (debugPointerCount >= 100 )
              debugPointerCount = 0;

}

u32bits MLXFAR
mdac_prelock(irql)
u08bits *irql;
{
    if (mdac_spinlockfunc!=0) {
        mdac_prelockfunc(mdac_irqlevel, irql);
    }
    return 0;
}

u32bits MLXFAR
mdac_postlock(irql)
u08bits irql;
{
    if (mdac_spinlockfunc!=0) {
        mdac_postlockfunc(irql);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\io\stubs.c ===
#ifdef _WIN64 
MdacInt3() {}
mdac_enable_hwclock () {}
mdac_read_hwclock () {}

mdac_readtsc() {}
mdac_readmsr() {}
mdac_writemsr () {}

mdac_disable_intr_CPU() {}
mdac_restore_intr_CPU() {}
mdac_datarel_halt_cpu() {}
mdac_check_cputype() {}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\io\i386\mdac_nt.asm ===
ifdef 0

/**************************************************************************
/*                COPYRIGHT (C) Mylex Corporation 1992-1998               *
/*                                                                        *
/* This software is furnished under a license and may be used and copied  * 
/* only in accordance with the terms and conditions of such license and   * 
/* with inclusion of the above copyright notice. This software or any     * 
/* other copies thereof may not be provided or otherwise made available   * 
/* to any other person. No title to, nor ownership of the software is     * 
/* hereby transferred.                                                    *
/*                                                                        *
/* The information in this software is subject to change without notices  *
/* and should not be construed as a commitment by Mylex Corporation       *
/*                                                                        *
/**************************************************************************/

        .globl  u08bits_in_mdac
u08bits_in_mdac:
        movl    4(%esp), %edx
        xorl    %eax, %eax
        inb     (%dx)
        ret

        .globl  u16bits_in_mdac
u16bits_in_mdac:
        movl    4(%esp), %edx
        xorl    %eax, %eax
        inw     (%dx)
        ret

        .globl  u32bits_in_mdac
u32bits_in_mdac:
        movl    4(%esp), %edx
        inl     (%dx)
        ret

        .globl  u08bits_out_mdac
u08bits_out_mdac:
        movl    4(%esp), %edx
        movl    8(%esp), %eax
        outb    (%dx)
        ret

        .globl  u16bits_out_mdac
u16bits_out_mdac:
        movl    4(%esp), %edx
        movl    8(%esp), %eax
        outw    (%dx)
        ret

        .globl  u32bits_out_mdac
u32bits_out_mdac:
        movl    4(%esp), %edx
        movl    8(%esp), %eax
        outl    (%dx)
        ret
endif   


; ---------------------------------------------------------------------------
;
;
; ---------------------------------------------------------------------------



.386P
.model FLAT, C

        .xlist
include callconv.inc
        .list   

.DATA

EXTERNDEF       mdac_datarel_cpu_family:DWORD
EXTERNDEF       mdac_datarel_cpu_model:DWORD
EXTERNDEF       mdac_datarel_cpu_stepping:DWORD
EXTERNDEF	mdac_simple_waitlock_cnt:DWORD
EXTERNDEF	mdac_simple_waitloop_cnt:DWORD
EXTERNDEF	mdac_flushdatap:DWORD


.CODE

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

cPublicProc     MdacInt3
;	int	3
	ret
stdENDP			MdacInt3

ifndef SCSIPORT_COMPLIANT

cPublicProc mdac_simple_unlock, 1, arg1:DWORD
ifdef 0 
        movl    4(%esp), %eax
        lock
        xorl    %eax, (%eax)
        ret
else    
ifdef MLX_WIN9X
else
	mov	eax, mdac_flushdatap	; get non cacheable memory address
	mov	eax, [eax]		; access will flush pending writes
	mov	eax, arg1		; get the lock address
	mov	[eax], 00h		; unlock the lock
;       mov     eax, arg1
;       lock xor        [eax], eax
endif
        stdRET  mdac_simple_unlock
        
stdENDP mdac_simple_unlock
endif   


cPublicProc     mdac_simple_trylock, 1, arg1:DWORD
ifdef 0
        movl    4(%esp), %eax
        xchgl   %eax, (%eax)
        ret
else
        mov     eax, arg1
        xchg    eax, [eax]
        stdRET  mdac_simple_trylock

stdENDP mdac_simple_trylock
endif

cPublicProc     mdac_simple_lock, 1, arg1:DWORD
ifdef 0 
        movl    4(%esp), %eax
        xchg    %eax, (%eax)
        orl     %eax, %eax
        jnz     mdac_simple_waitlock
        ret
else
ifdef MLX_WIN9X
	xor	eax, eax
        stdRET  mdac_simple_lock
else
mdac_simple_lock_bbb:
        mov     eax, arg1
        xchg    eax, [eax]
        or      eax, eax
        jnz     mdac_simple_waitlock
        stdRET  mdac_simple_lock
	
mdac_simple_waitlock:
	
        inc     mdac_simple_waitlock_cnt        ; just keep track
        mov     eax, arg1
        xor     ecx, ecx
        xor     edx, edx
mdac_simple_waitlock1:
        inc     edx
        cmp     [eax], ecx
        jne     mdac_simple_waitlock1           ; try again
        add     mdac_simple_waitloop_cnt, edx   ; just keep track count
        jmp     mdac_simple_lock_bbb            ; lock is available
endif        
stdENDP mdac_simple_lock
endif   
endif ; if !SCSIPORT_COMPLIANT

ifdef 0
        .set    PITCTR2_PORT,0x42       /* counter 2 port */    
        .set    PITCTL_PORT,0x43        /* PIT control port */
        .set    PITAUX_PORT,0x61        /* PIT auxiliary port */
        .set    PIT_C2,0x80
        .set    PITAUX_GATE2,0x01       /* aux port, PIT gate 2 input */
else
PITCTR2_PORT    equ     42h             ; counter 2 port
PITCTL_PORT     equ     43h             ; PIT control port
PITAUX_PORT     equ     61h             ; PIT auxiliary port
PIT_C2          equ     80h
PITAUX_GATE2    equ     01h             ; aux port, PIT gate 2 input
endif
        
        
cPublicProc     mdac_enable_hwclock
ifdef 0
        pushfl
        cli
        movl    $PITCTL_PORT, %edx
        movb    $0xB4, %al
        outb    (%dx)
        movl    $PITCTR2_PORT, %edx
        movb    $0xFF, %al
        outb    (%dx)
        outb    (%dx)
        movl    $PITAUX_PORT, %edx
        inb     (%dx)
        orb     $PITAUX_GATE2, %al      /* auxiliary port, PIT gate 2 input */
        outb    (%dx)                   /* enable the PIT2 counter */
        popfl
        ret
else
        pushfd
        cli
        mov     edx, PITCTL_PORT
        mov     al, 0B4h
        out     dx, al  
        mov     edx, PITCTR2_PORT
        mov     al, 0FFh
        out     dx, al  
        out     dx, al  
        mov     edx, PITAUX_PORT
        in      al, dx  
        or      al, PITAUX_GATE2        ; auxiliary port, PIT gate 2 input
        out     dx, al  
        popfd
        stdRET  mdac_enable_hwclock
        
stdENDP mdac_enable_hwclock
endif   

cPublicProc     mdac_read_hwclock
ifdef 0
        pushfl
        cli
        movl    $PITCTL_PORT, %edx
        movb    $PIT_C2, %al
        outb    (%dx)
        movl    $PITCTR2_PORT, %edx
        xorl    %eax, %eax
        inb     (%dx)
        movb    %al, %cl
        inb     (%dx)
        movb    %al, %ah
        movb    %cl, %al
        popfl
        ret
else
        pushfd
        cli
        mov     edx, PITCTL_PORT
        mov     al, PIT_C2
        out     dx, al
        mov     edx, PITCTR2_PORT
        xor     eax, eax
        in      al, dx
        mov     cl, al
        in      al, dx
        mov     ah, al
        mov     al, cl
        popfd
        stdRET  mdac_read_hwclock
        
stdENDP mdac_read_hwclock               ; read the hardware clock
endif   

; halt the cpu, this useful in measing performance information

cPublicProc     mdac_datarel_halt_cpu
        sti
        hlt
        stdRET  mdac_datarel_halt_cpu
        
stdENDP mdac_datarel_halt_cpu

cPublicProc     mdac_disable_intr_CPU
ifdef 0
        pushfl
        cli
        popl    %eax
        ret
else
        pushfd
        cli
        pop     eax
        stdRET  mdac_disable_intr_CPU
        
stdENDP mdac_disable_intr_CPU
endif   

; enable the cpu interrupt and return the old flag

cPublicProc mdac_enable_intr_CPU

	pushfd
	sti
	pop	eax
	ret
	
stdENDP mdac_enable_intr_CPU

cPublicProc     mdac_restore_intr_CPU, 1, arg1:DWORD
ifdef 0
        movl    4(%esp), %eax
        pushl   %eax
        popfl
        ret
else    
        mov     eax, arg1
        push    eax
        popfd
        stdRET  mdac_restore_intr_CPU
        
stdENDP mdac_restore_intr_CPU
endif

; This function writes a model specific register of Pentium family processor.
; Where reg is the model specific register number to write, val0 is the
; data value bits 31..0 and val1 is the data value bits 63..32.
; mdac_writemsr(reg,val0,val1)

cPublicProc     mdac_writemsr, 3
ifdef 0
        movl    4(%esp), %ecx
        movl    8(%esp), %eax
        movl    12(%esp), %edx
        .byte   0x0F, 0x30              /* wrmsr */
        ret
else    
        mov     ecx, [esp+4]
        mov     eax, [esp+8]
        mov     edx, [esp+12]
        db      0Fh
        db      30h                     ; wrmsr 
        stdRET  mdac_writemsr
        
stdENDP mdac_writemsr
endif

; function reads a model specific register of Pentium family processor.
; reg is the model specific register number to read and valp is
; address where the 64 bit value from the register is written.
; (reg,valp)

cPublicProc     mdac_readmsr, 2
ifdef 0
        movl    4(%esp), %ecx
        .byte   0x0F, 0x32      /* rdmsr */
        movl    8(%esp), %ecx
        movl    %eax, (%ecx)
        movl    %edx, 4(%ecx)
        ret
else
        mov     ecx, [esp+4]
        db      0Fh
        db      32h                             ; rdmsr
        mov     ecx, [esp+8]
        mov     [ecx], eax
        mov     [ecx+4], edx
        stdRET  mdac_readmsr
        
stdENDP mdac_readmsr
endif   

; This function reads the time stamp counter of the Pentium family processor.
; The valp is the address where the 64 bit value read is stored.
; mdac_readtsc(valp)

cPublicProc     mdac_readtsc, 1, arg1:DWORD
ifdef 0
        movl    4(%esp), %ecx
        .byte   0x0F, 0x31      /* rdtsc */
        movl    %eax, (%ecx)
        movl    %edx, 4(%ecx)
        ret
else
        mov     ecx, arg1
        db      0Fh
        db      31h                     ; rdtsc 
        mov     [ecx], eax
        mov     [ecx+4], edx
        stdRET  mdac_readtsc
        
stdENDP mdac_readtsc
endif   

;       This routine determines the cpuid of the current processor 

EFL_AC  equ     40000h                  ; alignment check (1->check)
EFL_ID  equ     200000h                 ; cpuid opcode (flippable->supported)

cPublicProc     mdac_check_cputype
ifdef 0
        pushl   %ebx                    / save %ebx
        pushl   %esi                    / save %esi
        pushl   %edi                    / save %edi
        pushfl                          / save FLAGS

        pushfl                          / push FLAGS value on stack
        popl    %eax                    / get FLAGS into AX
        movl    %eax, %ecx              / save copy of FLAGS

        xorl    $EFL_AC, %eax           / flip AC bit for new FLAGS
        pushl   %eax                    / push new value on stack
        popfl                           / attempt setting FLAGS.AC
        pushfl                          / push resulting FLAGS on stack
        popl    %eax                    / get that into AX
        cmpl    %eax, %ecx              / succeeded in flipping AC?
        je      mdac_datarel_cpuis_i386 / AX is same as CX for i386 CPU

        movl    %ecx, %eax              / get original FLAGS again
        xorl    $EFL_ID, %eax           / flip ID bit for new FLAGS
        pushl   %eax                    / push new value on stack
        popfl                           / attempt setting FLAGS.ID
        pushfl                          / push resulting FLAGS on stack
        popl    %eax                    / get that into AX
        cmpl    %eax, %ecx              / succeeded in flipping ID?
        je      mdac_datarel_cpuis_i486 / AX is same as CX for i486 CPU

        movl    $1, %eax                / set first cpuid parameter
        .byte   0x0F, 0xA2 /* cpuid */  / get CPU family-model-stepping

        movl    %eax, %ebx              / extract stepping id
        andl    $0xF, %ebx              / from bits [3..0]
        movl    %ebx, mdac_datarel_cpu_stepping

        movl    %eax, %ebx              / extract model
        shrl    $4, %ebx                / from bits [7..4]
        andl    $0xF, %ebx
        movl    %ebx, mdac_datarel_cpu_model

        movl    %eax, %ebx              / extract family
        shrl    $8, %ebx                / from bits [11..8]
        andl    $0xF, %ebx
        movl    %ebx, mdac_datarel_cpu_family

mdac_datarel_cpu_identified:
        popfl                           / restore original FLAGS
        popl    %edi
        popl    %esi
        popl    %ebx
        ret

mdac_datarel_cpuis_i486:
        movl    $4, mdac_datarel_cpu_family
        jmp     mdac_datarel_cpu_identified
mdac_datarel_cpuis_i386:
        movl    $3, mdac_datarel_cpu_family
        jmp     mdac_datarel_cpu_identified
else    
        push    ebx                     ; save %ebx
        push    esi                     ; save %esi
        push    edi                     ; save %edi
        pushfd                          ; save FLAGS

        pushfd                          ; push FLAGS value on stack
        pop     eax                     ; get FLAGS into AX
        mov     ecx, eax                ; save copy of FLAGS

        xor     eax, EFL_AC             ; flip AC bit for new FLAGS
        push    eax                     ; push new value on stack
        popfd                           ; attempt setting FLAGS.AC
        pushfd                          ; push resulting FLAGS on stack
        pop     eax                     ; get that into AX
        cmp     eax, ecx                ; succeeded in flipping AC?
        je      mdac_datarel_cpuis_i386 ; AX is same as CX for i386 CPU

        mov     ecx, eax                ; get original FLAGS again
        xor     eax, EFL_ID             ; flip ID bit for new FLAGS
        push    eax                     ; push new value on stack
        popfd                           ; attempt setting FLAGS.ID
        pushfd                          ; push resulting FLAGS on stack
        pop     eax                     ; get that into AX
        cmp     eax, ecx                ; succeeded in flipping ID?
        je      mdac_datarel_cpuis_i486 ; AX is same as CX for i486 CPU

        mov     eax, 1                  ; set first cpuid parameter
        db      0Fh
        db      0A2h    ; cpuid ;       ; get CPU family-model-stepping

        mov     ebx, eax                ; extract stepping id
        and     ebx, 0Fh                ; from bits [3..0]
        mov     mdac_datarel_cpu_stepping, ebx

        mov     ebx, eax                ; extract model
        shr     ebx, 4                  ; from bits [7..4]
        and     ebx, 0Fh
        mov     mdac_datarel_cpu_model, ebx

        mov     ebx, eax                ; extract family
        shr     ebx, 8                  ; from bits [11..8]
        and     ebx, 0Fh
        mov     mdac_datarel_cpu_family, ebx

mdac_datarel_cpu_identified:
        popfd                           ; restore original FLAGS
        pop     edi
        pop     esi
        pop     ebx
        ret

mdac_datarel_cpuis_i486:
        mov     mdac_datarel_cpu_family, 4
        jmp     mdac_datarel_cpu_identified
mdac_datarel_cpuis_i386:
        mov     mdac_datarel_cpu_family, 3
        jmp     mdac_datarel_cpu_identified
        
stdENDP mdac_check_cputype
endif   

if 0

/* compare only multiples of 4 bytes data */
/* u32bits mdac_datarel_fastcmd4(src, dst, count)
	.globl	mdac_datarel_fastcmp4
mdac_datarel_fastcmp4:
	movl	4(%esp), %edx	/ save source in edx
	movl	8(%esp), %eax	/ save destination in eax
	movl	12(%esp), %ecx	/ get the data transfer length
	pushl	%esi		/ save esi register
	pushl	%edi		/ save edi register
	movl	%eax, %edi	/ get destination memory address
	movl	%edx, %esi	/ get source memory address
	shrl	$2, %ecx
	rep
	scmpl			/ first move 4 bytes long
	jne	mdac_datarel_fastcmp_l1	/ 2 instructions for jne and 2 for xorl
	xorl	%eax, %eax	/ eax was non zero because it contained address
mdac_datarel_fastcmp_l1:
	popl	%edi		/ restore edi register
	popl	%esi		/ restore esi register
	ret

/* mdac_datarel_fillpat(dp, curpat, patinc, patlen) */
/* u32bits MLXFAR *dp, curpat, patinc, patlen; */
/* { */
/* 	for (; patlen; curpat += patinc, dp++, patlen--) */
/* 		*dp = curpat; */
/* } */
	.globl	mdac_datarel_fillpat
mdac_datarel_fillpat:
	push	%esi
	movl	8(%esp), %esi	/* get memory address */
	movl	12(%esp), %eax	/* get current pattern */
	movl	16(%esp), %edx	/* get pattern increment */
	movl	20(%esp), %ecx	/* get number of pattern to be filled */
mdac_datarel_fillpat_l1:
	mov	%eax, (%esi)
	add	%edx, %eax
	add	$4, %esi
	loop	mdac_datarel_fillpat_l1
	pop	%esi
	ret
	
else

; compare only multiples of 4 bytes data */
; u32bits mdac_datarel_fastcmd4(src, dst, count)

cPublicProc mdac_datarel_fastcmp4, 3
	
	mov	edx, 4[esp]	; save source in edx
	mov	eax, 8[esp]	; save destination in eax
	mov	ecx, 12[esp]	; get the data transfer length
	push	esi		; save esi register
	push	edi		; save edi register
	mov	edi, eax	; get destination memory address
	mov	esi, edx	; get source memory address
	shr	ecx, 2
	repe cmpsd
	jne	mdac_datarel_fastcmp_l1	; 2 instructions for jne and 2 for xorl
	xor	eax, eax	; eax was non zero because it contained address
mdac_datarel_fastcmp_l1:
	pop	edi		; restore edi register
	pop	esi		; restore esi register
	ret
	
stdENDP mdac_datarel_fastcmp4

;/* mdac_datarel_fillpat(dp, curpat, patinc, patlen) */
;/* u32bits MLXFAR *dp, curpat, patinc, patlen; */
;/* { */
;/* 	for (; patlen; curpat += patinc, dp++, patlen--) */
;/* 		*dp = curpat; */
;/* } */

cPublicProc mdac_datarel_fillpat, 4
 
	push	esi
	mov	esi, 8[esp]	;/* get memory address */
	mov	eax, 12[esp]	;/* get current pattern */
	mov	edx, 16[esp]	;/* get pattern increment */
	mov	ecx, 20[esp]	;/* get number of pattern to be filled */
mdac_datarel_fillpat_l1:
	mov	[esi], eax
	add	eax, edx
	add	esi, 4
	loop	mdac_datarel_fillpat_l1
	pop	esi
	ret
stdENDP mdac_datarel_fillpat

endif	
        
_TEXT   ends
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\sys\dac960if.h ===
/**************************************************************************
 *                COPYRIGHT (C) Mylex Corporation 1992-1998               *
 *                                                                        *
 * This software is furnished under a license and may be used and copied  * 
 * only in accordance with the terms and conditions of such license and   * 
 * with inclusion of the above copyright notice. This software or any     * 
 * other copies thereof may not be provided or otherwise made available   * 
 * to any other person. No title to, nor ownership of the software is     * 
 * hereby transferred.                                                    *
 *                                                                        *
 * The information in this software is subject to change without notices  *
 * and should not be construed as a commitment by Mylex Corporation       *
 *                                                                        *
 **************************************************************************/

#ifndef	_SYS_DAC960IF_H
#define	_SYS_DAC960IF_H


/* This file defines all DAC960 interface informations */

#define	DAC_PCI_NEWAPI_LEVEL	0x53C	/* Fw with new API */
#define	DAC_EXT_NEWAPI_LEVEL	0x663	/* Fw with new API */
#define	DAC_FWMAJOR_V2x		2  /* major version 2 */
#define	DAC_FWMAJOR_V3x		3  /* major version 3 */
#define	DAC_FW507		0x0507 /* Firmware rev 5.07 with cluster */
#define	DAC_FW499		0x0463 /* Firmware revision 4.99 for S2S */
#define	DAC_FW420		0x0413 /* Firmware revision 4.20 for S2S only */
#define	DAC_FW407		0x0407 /* Firmware revision 4.07 */
#define	DAC_FW400		0x035B /* Firmware revision 4.00 */
#define	DAC_FW320		0x0313 /* Firmware revision 3.20 for S2S only */
#define	DAC_FW300		0x0300 /* Firmware revision 3.00 */
#define	DAC_FW260		0x023C /* Firmware revision 2.60 */
#define	DAC_FW250		0x0232 /* Firmware revision 2.50 */

#define DAC_FW515               0x0515 /* Firmware rev 5.15 with cluster - */
									   /* We will support till FW Ver 5.15.*/ 
									   /* Incase it increase, increase the defines*/
#define DAC_FWTURN_CLUSTER      75     /* Turn number 75-99 for cluster */

#define	DAC_MAXSYSDEVS_V3x	32 /* Max logical device on DAC V3x */
#define	DAC_MAXCHANNELS		5  /* Max Channels on DAC */
#define	DAC_MAXTARGETS_V3x	16 /* Max Targets on DAC V3x */

#ifdef MLX_DOS
/* Max logical device on DAC V2x */
#define	DAC_MAXSYSDEVS_V2x	    32 // Will be reduced to 8 for 2.x when checked with ctp
#define	DAC_MAXPHYSDEVS_INPACK	16  /* max physical device is possible in pack */
#define	DAC_MAXPACKS		    32  /* max packs are possible */
#define	DAC_MAXSPAN		        4  /* max spans */
#define	DAC_MAXPHYSDEVS_INPACK_V2x3x	8  /* max physical device is possible in pack */
#define	DAC_MAXPACKS_V2x3x		8  /* max packs are possible */
#define	DAC_MAXSPAN_V2x3x		4  /* max spans */
#define	DAC_CODSIZEKB		64 /* DAC COD size in KB */
#define	DAC_MAXTARGETS_V2x	16  /* Max Targets on DAC V2x */
#else
#define	DAC_MAXSYSDEVS_V2x	8  /* Max logical device on DAC V2x */
#define	DAC_MAXPHYSDEVS_INPACK	16  /* max physical device is possible in pack */
#define	DAC_MAXPACKS		    64  /* max packs are possible */
#define	DAC_MAXSPAN		        16  /* max spans */
#define	DAC_MAXPHYSDEVS_INPACK_V2x3x	8  /* max physical device is possible in pack */
#define	DAC_MAXPACKS_V2x3x		8  /* max packs are possible */
#define	DAC_MAXSPAN_V2x3x		4  /* max spans */
#define	DAC_CODSIZEKB		64 /* DAC COD size in KB */
#define	DAC_MAXTARGETS_V2x	7  /* Max Targets on DAC V2x */
#endif

/* Gokhale, 01/12/98, Added 3 #defines below
 * allocate Max possible area to accomodate all combinations
 * Max Dead devices appear to always 20, both in FW 2.x and 3.x
 */
#define DAC_MAX_DEV_V2x		(DAC_MAXCHANNELS * DAC_MAXTARGETES_V2x)
#define DAC_MAX_DEV_V3x		(DAC_MAXCHANNELS * DAC_MAXTARGETES_V3x)
#define DAC_MAX_DEAD_DEV	20

/* RAID LEVEL information */
#define	DAC_RAIDMASK		0x7F /* mask to get only raid values */
#define	DAC_WRITEBACK		0x80 /* write buffer in write back mode */
#define	DAC_WRITETHROUGH	0x00 /* write buffer in write through mode */
#define	DAC_RAID0		0x00 /* data striping */
#define	DAC_RAID1		0x01 /* data mirroring */
#define	DAC_RAID3		0x03 /* data parity on fixed device */
#define	DAC_RAID5		0x05 /* data parity on different device */
#define	DAC_RAID6		0x06 /* RAID0 + RAID1 */
#define	DAC_RAID7		0x07 /* JBOD */

#define	DAC_BLOCKSIZE		512  /* dac block size */

/* DAC command error */
#define	DACMDERR_NOERROR	0x0000 /* No error */
#define DACMDERR_DATAERROR_FW2X 0x0001 /* Unrecoverable data error - 2X */
#define DACMDERR_OFFLINEDRIVE   0x0002 /* Logical drive OFFLINE/not-exist */
#define DACMDERR_SELECTION_TIMEOUT 0x000E /* sel timeout on physical device  */
#define DACMDERR_RESET_TIMEOUT     0x000F /* timeout due to reset */
#define DACMDERR_DATAERROR_FW3X 0x010C /* Unrecoverable data error - 3X,PG */
#define	DACMDERR_SUCCESS	0x0100 /* operation completed successfully*/
#define	DACMDERR_NOCODE		0x0105 /* no activity, no device, */
#define	DACMDERR_ACTIVE		0x0106 /* specified activity is active */
#define	DACMDERR_CANCELED	0x0107 /* operation was canceled by command */

/* Clustering support specific command error values */
#define DACMDERR_INVALID_SYSTEM_DRIVE	0x0102
#define DACMDERR_CONTROLLER_BUSY	0x0106
#define DACMDERR_INVALID_PARAMETER	0x0109
#define DACMDERR_RESERVATION_CONFLICT	0x0110

/* PCI Hot Plug support specific command error values */
#define DACMDERR_MIGRATION_IN_PROGRESS	0x0120
#define DACMDERR_TOUT_CMDS_PENDING	0x0121
#define DACMDERR_TOUT_CACHE_NOT_FLUSHED	0x0122
#define DACMDERR_DRIVE_SPIN_FAILED	0x0123
#define DACMDERR_TARGET_NOT_OFFLINE	0x0124
#define DACMDERR_UNEXPECTED_CMD		0x0125

					/********************************/
					/* 	DxC960 command codes	*/
#define	DACMD_WITHSG		0x80 /* command with SG will have this bit */
#define	DACMD_INQUIRY_V2x	0x05 /* Fw Ver < 3.x			*/
#define	DACMD_INQUIRY_V3x	0x53 /* Fw Ver >= 3.x		*/
#define	DACMD_READ_V2x		0x02 /* read data in plain memory */
#define	DACMD_READ_SG_V2x	0x82 /* read data in scatter/gather memory */
#define	DACMD_READ_V3x		0x33 /* read data in plain memory */
#define	DACMD_READ_SG_V3x	0xB3 /* read data in scatter/gather memory */
#define	DACMD_READ_OLD_V3x	0x36 /* read data in plain memory */
#define	DACMD_READ_OLD_SG_V3x	0xB6 /* read data in FW 2.x SG memory */
#define	DACMD_READ_AHEAD_V2x	0x01 /* read ahead */
#define	DACMD_READ_AHEAD_V3x	0x35 /* read ahead */
#define	DACMD_READ_WITH2SG	0x5E /* read with 2SG in command */

#define	DACMD_WRITE_V2x		0x03 /* write data from plain memory */
#define	DACMD_WRITE_SG_V2x	0x83 /* write data from scatter/gather memory */
#define	DACMD_WRITE_V3x		0x34 /* write data from plain memory */
#define	DACMD_WRITE_SG_V3x	0xB4 /* write data from scatter/gather memory */
#define	DACMD_WRITE_OLD_V3x	0x37 /* write data from plain memory */
#define	DACMD_WRITE_OLD_SG_V3x	0xB7 /* write data from FW 2.x SG memory */
#define	DACMD_WRITE_WITH2SG	0x5F /* write with 2SG in command */

#define	DACMD_DCDB		0x04 /*    			        */
#define	DACMD_FLUSH		0x0A /* Flush controller cache */
#define	DACMD_SIZE_DRIVE	0x08 /*				*/
#define	DACMD_DCDB_STATUS	0x0D /* get DCDB status information */
#define	DACMD_DRV_INFO		0x19 /*				*/
/* Gokhale, 01/12/98, Added, command code for getsysdevelement 0x51 */
#define DACMD_GETSYSDEVELEMENT_V3x	0x51
#define	DACMD_PHYSDEV_START	0x10 /* start physical device	*/
#define	DACMD_PHYSDEV_STATE_V2x	0x14 /* get physical device state for 2.x */
#define	DACMD_PHYSDEV_STATE_V3x	0x50 /* get physical device state for 3.x */
#define	DACMD_START_CHANNEL	0x12 /* start activity on channel */
#define	DACMD_STOP_CHANNEL	0x13 /* stop  activity on channel */
#define	DACMD_RESET_CHANNEL	0x1A /* reset channel (SCSI bus) */
#define	DACMD_INQUIRY2		0x1C /*                              */ 
#define DACMD_READ_CONF_ONDISK	0x4A
#define DACMD_WRITE_CONF_ONDISK	0x4B
#define	DACMD_READ_ROM_CONFIG	0x07 /*				*/
#define	DACMD_READ_BCKUP_CONF_V3x 0x4D	/*				*/
#define	DACMD_READ_CONFIG_V3x	0x4E /* Read core configuration */
#define	DACMD_WRITE_CONFIG	0x06 /*				*/
#define	DACMD_WRITE_CONF2	0x3C /*				*/
#define	DACMD_READ_CONFLABEL	0x48 /* Read  configuration label */
#define	DACMD_WRITE_CONFLABEL	0x49 /* Write configuration label */
#define	DACMD_WRITE_CONFIG_V3x	0x4F /*				*/
#define	DACMD_ADD_CONFIG_V2x	0x18 /*				*/
#define	DACMD_ADD_CONFIG_V3x	0x4C /*				*/
#define	DACMD_RD_RPL_TAB	0x0E /* 				*/
#define	DACMD_CLR_RPL_TAB	0x30 /*				*/
#define	DACMD_GETSYSDEVELEMENT	0x15 /* get system device element */
#define	DACMD_LOAD_IMAGE	0x20 /*				*/
#define	DACMD_STORE_IMAGE	0x21 /*				*/
#define	DACMD_PRGM_IMAGE	0x22 /*				*/
#define	DACMD_CHECK_STAT	0x24 /* Check consistency status */
#define	DACMD_READ_BADATATABLE	0x25 /* Read  bad data table */
#define	DACMD_CLEAR_BADATATABLE	0x26 /* Clear bad data table */
#define	DACMD_REBUILD_PROGRESS	0x27 /* Get rebuild progress information */
#define	DACMD_SYSDEV_INIT_START	0x28 /* system device init start */
#define	DACMD_SYSDEV_INIT_STAT	0x29 /* system device init status */
#define	DACMD_SET_DIAG_MD	0x31 /*				*/
#define	DACMD_RUN_DIAGS		0x32 /*				*/
#define	DACMD_REBUILD		0x09 /* 3) Disk array specific	*/
#define	DACMD_REBUILD_STATUS	0x0C/* get rebuild/check status	*/
#define	DACMD_REBUILD_ASYNC	0x16 /* asynchronous physdev rebuild	*/
#define	DACMD_CONSISTENCY	0x0F /*				*/
#define	DACMD_CONSISTENCY_CHECK_RESTORE	0x1B /* consistency check and restore */
#define	DACMD_CONSISTENCY_CHECK_ASYNC	0x1E /* logical dev consistency check*/
#define	DACMD_REBUILD_CONTROL	0x1F /* do rebuild/check control */
#define	DACMD_READ_BADBLOCKTABLE 0x0B /* read bad block table */
#define	DACMD_GET_ERRORS	0x17 /* get physical device error table */
#define	DACMD_ADD_CAPACITY	0x2A /* add physical drives to existing array */
#define	DACMD_MISC_OPCODE  	0x2B /* For Misc Sub opcodes below..*/
#define	DACMD_GETENVSTS		0x69 /* Get Environment Status, for ExPro above 4.99 */

#define SubOpcMisc_ProgramImage         0x01
#define SubOpcMisc_ReadFlashDescriptor  0x02
#define SubOpcMisc_WriteFlashDescriptor 0x03
#define SubOpcMisc_SetChannelSpeed      0x04
#define SubOpcMisc_SetChannelWidth      0x05
#define SubOpcMisc_SetupMirrorMbox      0x06   
#define SubOpcMisc_SetRebuildRate       0x07
#define SubOpcMisc_SetTagDepth          0x08
#define SubOpcMisc_ChangeWritePolicy    0x09
#define SubOpcMisc_GetBcu               0x0A
#define SubOpcMisc_StoreDriverInfo      0x0B
#define SubOpcMisc_GetDriveInfo         0x0C

#define	DACMD_READ_NVRAM_CONFIG	0x38 /* read configuration from NVRAM */
#define	DACMD_READ_IOPORT	0x39 /* read  port B */
#define	DACMD_WRITE_IOPORT	0x3A /* write port B */
#define	DACMD_READ_CONF2	0x3D /*	read configure2 information */
#define DACMD_SYS_DEV_STATISTICS 0x3E /* get system devices statistics */
#define DACMD_PHYS_DEV_STATISTICS 0x3F/* get physical devices statistics */

#define	DACMD_GET_ECI		0x42 /* get essential configuration info */
#define	DACMD_LONGOP_STATUS	0x43 /* get long operation status */
#define	DACMD_LONGOP_START	0x44 /* start long operation */
#define	DACMD_LONGOP_CONTROL	0x45 /* long operation rate control */

#define	DACMD_S2S_WRITESIG	0x4D /* write signature information */
#define	DACMD_S2S_READSIG	0x4E /* read  signature information */
#define	DACMD_PHYS2PHYSCOPY	0x54 /* copy data from one physical to another physical space */
#define	DACMD_GET_DUAL_CTRL_STS 0x55 /* S2S Dual controller status */

#define	DACMD_S2S_WRITELUNMAP_OLD	0x58 /* write LUN map information */
#define	DACMD_S2S_READLUNMAP_OLD	0x59 /* read  LUN map information */
#define	DACMD_S2S_WRITEFULLCONF		0x60 /* write full configuration */
#define	DACMD_S2S_READFULLCONF		0x61 /* read  full configuration */
#define	DACMD_S2S_ADDFULLCONF		0x62 /* add   full configuration */
#define	DACMD_S2S_GET_ERRORS		0x63 /* get expanded physical device error table */
#define DACMD_S2S_PHYSDEV_STATISTICS 0x64 /* get expanded physical device statistics */
#define	DACMD_S2S_READ_IOPORT	0x65 /*	read  expanded IO port */
#define	DACMD_S2S_WRITE_IOPORT	0x66 /* write expanded IO port */

#define	DACMD_GETSUBSYSTEMDATA	0x70 /* get sub system data */
#define	DACMD_SETSUBSYSTEMDATA	0x71 /* set sub system data */
#define	DACMD_GETEVENTLOG	0x72 /* get event log information */

#define GET_DEVICE_DATA		0x75 /* I2O only */

#define DACMD_S2S_READLUNMAP			0xD1	/* Read LUN Map Information */
#define DACMD_S2S_WRITELUNMAP			0xD2	/* Write LUN MAP Information */
#define DACMD_S2S_READ_HOST_WWN_TABLE	0xD3	/* Read Host WWN Table */
#define DACMD_S2S_GET_HOST_INFO			0xD4	/* Read Host WWN Table */

/* clustering support */
#define DACMD_RESERVE_SYSTEM_DRIVE	0x60
#define DACMD_RELEASE_SYSTEM_DRIVE	0x61
#define DACMD_RESET_SYSTEM_DRIVE	0x62
#define DACMD_TUR_SYSTEM_DRIVE		0x63
#define DACMD_INQUIRE_SYSTEM_DRIVE	0x64
#define DACMD_CAPACITY_SYSTEM_DRIVE	0x65	/* DACMD_READ_CAPACITY_SYSTEM DRIVE */
#define DACMD_READ_WITH_DPO_FUA		0x66
#define DACMD_WRITE_WITH_DPO_FUA	0x67
#define DACMD_CLUSTER_CONTROL           0x68

#define SubOpClust_Read         0
#define SubOpClust_Write        1

#define	DACMD_IOCTL		0x2B /* IOCTL command */
#define	DACMDIOCTL_MIRRORMBOX	0x06 /* set mirror mail box */
#define	DACMDIOCTL_DISABLEDIRTX	0x0F /* disable the direct SCSI to system data transfer */
#define	DACMDIOCTL_HOSTMEMBOX	0x10 /* set host memory mail box */
#define	DACMDIOCTL_MASTERINTR	0x11 /* set master controller for interrupt */
#define	DACMDIOCTL_SLAVEINTR	0x12 /* set slave controller for interrupt */
#define	DACMDIOCTL_HOSTMEMBOX_DUAL_MODE	0x14 /* set controller in dual mailbox mode */
#define	DACMDIOCTL_HOSTMEMBOX32	0x015 /* set 32 byte long host memory mail box */
/* PCI Hot Plug support */
#define	DACMDIOCTL_STARTSTOP_CONTROLLER	0x40 /* stop/start controller */
#define	START_CONTROLLER	0x01 /* start controller bit */


/* 64 bit address mode scatter/gather list information */
typedef	struct	mdac_sglist64b
{
	u64bits	sg_PhysAddr;		/* Physical address */
	u64bits	sg_DataSize;		/* Data transfer size in bytes */
} mdac_sglist64b_t;
#define	mdac_sglist64b_s	sizeof(mdac_sglist64b_t)


/* signature data record, fault tolerant controller mode */
typedef	struct	dac_faultsignature
{
	u08bits	dfsig_Status;		/* status information used only for read */
	u08bits	dfsig_ControllerNo;	/* controller number of this unit */
	u08bits	dfsig_Reserved0;
	u08bits	dfsig_Reserved1;
	u32bits	dfsig_Signature1;	/* first signature value */
	u32bits	dfsig_Signature2;	/* second signature value */
	u32bits	dfsig_Signature3;	/* third signature value */
} dac_faultsignature_t;
#define	dac_faultsignature_s	sizeof(dac_faultsignature_t)

#define DFSIG_STATUS_VALID	0x01
#define DFSIG_STATUS_FAILED	0x02
#define DFSIG_STATUS_WHICH	0x04

typedef struct	dac_phys_dead_drive
{
	u08bits	dead_TargetID;
	u08bits	dead_ChannelNo;
}dac_phys_dead_drive_t;
#define	dac_phys_dead_drive_s	sizeof(dac_phys_dead_drive_t)


/* DAC960 Flash record information format. This record format is used for each
** independent flashed information. For example, Boot Block, Firmware, BIOS,
** etc.
** NOTE:
**	All data which are more than one byte long, are present in
**	Little Endian format.
*/
typedef struct dac_flash_image_record
{
	u32bits	fir_ImageAddr;		/* Flash address where image starts */
	u32bits	fir_ImageSize;		/* Flash space used */

	u08bits	fir_FlashRecordType;	/* The type of information flashed */
	u08bits	fir_EncodingFormat;	/* Encoding format of the information */
	u16bits	fir_SWBuildNo;		/* Software build number */

	u08bits	fir_SWMajorVersion;	/* Software Major version number */
	u08bits	fir_SWMinorVersion;	/* Software Minor version number */
	u08bits	fir_SWTurnNo;		/* Software interim Rev A, B, C, etc. */
	u08bits	fir_SWVendorId;		/* Software vendor name */


	u08bits	fir_SWBuildMonth;	/* Software Build Date - Month */
	u08bits	fir_SWBuildDate;	/* Software Build Date - Date */
	u08bits	fir_SWBuildYearMS;	/* Software Build Date - Year */
	u08bits	fir_SWBuildYearLS;	/* Software Build Date - Year */

	u08bits	fir_FlashMonth;		/* Flash Date - Month */
	u08bits	fir_FlashDate;		/* Flash Date - Date */
	u08bits	fir_FlashYearMS;	/* Flash Date - Year */
	u08bits	fir_FlashYearLS;	/* Flash Date - Year */

	u32bits	fir_Reserved0[10];
} dac_flash_image_record_t;
#define	dac_flash_image_record_s	sizeof(dac_flash_image_record_t)

/* fir_RecordType */
#define	DACFIR_FLASHRECORD	0x01 /* flash record */
#define	DACFIR_BOOTBLOCK	0x02 /* boot block */
#define	DACFIR_BIOS		0x03 /* BIOS */
#define	DACFIR_FW		0x04 /* Firmware */
#define	DACFIR_BCU		0x05 /* BIOS Config Utilitiy */
#define	DACFIR_HWDIAG		0x06 /* Hardware Diagnostics */

/* For fih_ImageType */
#define MLXIMG_BOOTBLOCK		0x01
#define MLXIMG_FW				0x02
#define MLXIMG_BIOS				0x03
#define MLXIMG_BCU				0x04
#define MLXIMG_HWDIAG			0x05
#define MLXIMG_BIOS_FW			0x06
#define MLXIMG_I2O				0x07
#define MLXIMG_FEATURE_CONTROL	0x08
#define MLXIMG_ENTIRE_FLASH		0x09
#define MLXIMG_FLASH_DESC		0x0E
#define MLXIMG_FLASH_TEST		0x0F
#define MLXIMG_DAC960_MASK		0x00
#define MLXIMG_DAC1100_MASK		0x10
#define MLXIMG_UNKNOWN			0xFF

/* fir_EncodingFormat */
#define	DACFIR_PLAIN		0x01 /* No encoding has been done */
#define	DACFIR_ZIP		0x02 /* the data is zipped before flash */
#define FlashImageEncoding_Unzipped 0x01
#define FlashImageEncoding_Zipped   0x02

#define MLXIMG_VENDOR_ID	0x1069		/* Mylex Id */
#define MLXIMG_COMMON_ID	0x474D494D	/*GMIM*/
#define MLXIMG_SIGNATURE	0x584C594D	/*XLYM*/
#define MLXIMG_FW_SIGNATURE	0x4D594C58	/*MYLX*/

/* Flash images */
#define DAC_FLASH_MAXIMAGES	5
#define DAC_FLASH_BOOTBLOCK_IMAGE	0
#define DAC_FLASH_FW_IMAGE			1
#define DAC_FLASH_BIOS_IMAGE		2
#define DAC_FLASH_CFG_UTIL_IMAGE	3
#define DAC_FLASH_MFG_DIAG_IMAGE	4

/* Flash record is 4KB space which contains the information about all flashed
** images record, hardware serial number, manufacturing date, etc.
*/
typedef struct dac_flash_record
{
	u32bits	fr_Signature;		/* valid signature if record is valid */
	u32bits	fr_SerialNo;		/* hardware serial number */

	u16bits	fr_NoofFlashes;		/* # times flash has been programmed */
	u08bits	fr_NoofImages;		/* # images present */
	u08bits fr_BootFromI2O;
	
	u08bits	fr_CustomerId[4];	/* OEM for whom it is manufactured */

	u08bits fr_HWMfgMemType1;
	u08bits fr_HwMfgFabYear;	/* from 1900 */
	u16bits fr_HwMfgWeekFabCode;	/*6 bits week(msb)+10 bits vendor code*/

	u32bits fr_HwMfgNum;

	u08bits fr_HwMfgType;
	u08bits fr_HwMfgMemType;
	u16bits fr_HwMfgMem;

	u08bits fr_HwMfgRev[2];
	u08bits fr_HwMfgOffset;	/* within 1K of the Flash. Offset=value << 6*/
	u08bits fr_Reserved0;
				/* flash image information from here */
	dac_flash_image_record_t fr_FlashImages[DAC_FLASH_MAXIMAGES];
} dac_flash_record_t;
#define	dac_flash_record_s	sizeof(dac_flash_record_t)

typedef	struct dac_file_imghdr {
    u32bits fih_CommonId;
    u32bits fih_Signature;
    u32bits fih_Size;	/* In bytes */

    u08bits fih_EncodingFormat;
    u08bits fih_ImageType;
    u08bits fih_OEMId;
    u08bits fih_Reserved1;

    u08bits fih_MajorVersion;
    u08bits fih_MinorVersion;
    u08bits fih_TurnNumber;
    u08bits fih_BuildNumber;

    u08bits fih_BuildDate;
    u08bits fih_BuildMonth;
    u16bits fih_BuildYear;

    u08bits fih_VersionString[64];
    u16bits fih_PciDevId;
} dac_file_imghdr_t;
#define	dac_file_imghdr_s	sizeof(dac_file_imghdr_t)

#define BIOS_SIZE		0x08000L
#define BOOT_SIZE		0x04000L
#define DIAG_SIZE		0x11C00L
#define FW_SIZE			0x38000L
#define BCU_SIZE		0x28000L
#define FLASH_DESC_SIZE		0x00400L
#define I2O_SIZE		0x00400L

#define BCU_OFFSET		0x00000L
#define BIOS_OFFSET		0x28000L
#define FW_OFFSET		0x30000L
#define HWDIAG_OFFSET		0x68000L
#define FLASH_DESC_OFFSET	0x79C00L
#define FLASH_TEST_OFFSET	0x7A000L
#define BOOTBLOCK_OFFSET	0x7C000L
#define I2O_OFFSET		0x80000L

typedef struct FlashMapRecTag {
    unsigned long Type;
    unsigned long Size;
    unsigned long Offset;
    int Status;
    int	FixedSize;
} FlashMapRec;

#define	MLXIMG_NEEDED		0
#define	MLXIMG_OPTIONAL		1
#define	MLXIMG_VARIABLE		0
#define	MLXIMG_FIXED		1

#define FLASH_128K	0x020000L
#define FLASH_256K	0x040000L
#define FLASH_512K	0x080000L
#define FLASH_1M	0x100000L

typedef struct file_img_node {
	u16bits img_fd;
	u08bits img_reserved0;
	u08bits img_type;
	u08bits img_padding[4];	/* efi64 */	// for alignment kfr
	PCHAR img_addr;		/* efi64 */	// was u32bits kfr
	u32bits img_size;
	u32bits img_filesize;
	PCHAR img_allocaddr;			// was u32bits  kfr
} file_img_node_t;
#define	file_img_node_s		sizeof(file_img_node_t)

typedef struct ctlr_info_node {
	u08bits cin_tsop_pres;
	u08bits cin_dual_eeprom;
	u08bits cin_flashromsize;
	u08bits cin_reserved0;
} ctlr_info_node_t;
#define	ctlr_info_node_s	sizeof(ctlr_info_node_t)

/*====================================================================*/
/* DACMD_INQUIRY data structure */
/* structure to get the inquiry data other than size and system device counts */
typedef struct	dac_inquiryrest
{
	u16bits	iq_FlashAge;		/* # times FLASH ROM programmed */
	u08bits	iq_StatusFlag;		/* some error status flags */
	u08bits	iq_FreeStateChanges;	/* # free state space available */

	u08bits	iq_MinorFirmwareVersion;/* Firmware Minor Version Number*/
	u08bits	iq_MajorFirmwareVersion;/* Firmware Major Version Number*/
	u08bits	iq_RebuildFlag;		/* Rebuild flag */
	u08bits	iq_MaxCommands;		/* max concurrent on this DAC */

	u08bits	iq_SysDevOffline;	/* # system devices offline */
	u08bits iq_CODState;		/* Configuration On Disk State */
	u16bits	iq_SenseSeqNo;		/* Sense data sequence number */

	u08bits	iq_SysDevCritical;	/* # system devices critical */
	u08bits iq_Reserved2;
	u16bits	iq_StateChanges;	/* number of states changes recorded */

	u08bits	iq_PhysDevOffline;	/* # Physical Devices offline (dead) */
	u08bits	iq_reserved3;
	u08bits	iq_RebuildPhysDevs;	/* # physical devices in rebuild state*/
	u08bits	iq_MiscFlag;		/* misc flags and reserved */

	dac_phys_dead_drive_t iq_PhysDevOfflineTable[20];
} dac_inquiryrest_t;
#define	dac_inquiryrest_s	sizeof(dac_inquiryrest_t)

typedef struct	dac_inquiry2x
{
	u08bits	iq_SysDevs;		/* # system devices configured */
	u08bits	iq_Reserved0[3];

	u32bits	iq_SysDevSizes[DAC_MAXSYSDEVS_V2x];/* System device sizes in blocks */
	dac_inquiryrest_t iq_rest2x;	/* rest of the data */
} dac_inquiry2x_t;
#define	dac_inquiry2x_s	sizeof(dac_inquiry2x_t)

typedef struct	dac_inquiry3x
{
	u08bits	iq_SysDevs;		/* # system devices configured */
	u08bits	iq_Reserved0[3];

	u32bits	iq_SysDevSizes[DAC_MAXSYSDEVS_V3x];/* System device sizes in blocks */
	dac_inquiryrest_t iq_rest3x;	/* reset of the data */
} dac_inquiry3x_t;
#define	dac_inquiry3x_s	sizeof(dac_inquiry3x_t)
/*====================================================================*/


/* iq_StatusFlag bits */
#define	DAC_DEFERRED_WRITE_ERROR	0x01 /* =1 some deferred write errors */
#define	DAC_BBU_POWER_LOW			0x02 /* =1 if battery running low */
#define DAC_BBU_NORESPONSE			0x08 /* =1 No Reponse From BBU */

/* iq_MiscFlag bits */
#define	DAC_BBU_PRESENT				0x08 /* =1 IBBU is present */
#define DAC_EXPRO_BBU_PRESENT		0x20 /* ExPro BBU Present bit */

/* iq_RebuildFlag Values */
#define	DAC_RF_NONE			0x00 /* No activity */
#define	DAC_RF_AUTOREBUILD		0x01 /* automatic rebuild */
#define	DAC_RF_MANUALREBUILD		0x02 /* mannual rebuild */
#define	DAC_RF_CHECK			0x03 /* consistency check */
#define	DAC_RF_EXPANDCAPACITY		0x04 /* expand capacity */
#define	DAC_RF_PHYSDEVFAILED		0xF0 /* new/one physical device failed*/
#define	DAC_RF_LOGDEVFAILED		0xF1 /* logical device failed */
#define	DAC_RF_JUSTFAILED		0xF2 /* some reason */
#define	DAC_RF_CANCELED			0xF3 /* canceled */
#define	DAC_RF_EXPANDCAPACITYFAILED	0xF4 /* expand capacity failed*/
#define	DAC_RF_AUTOREBUILDFAILED	0xFF /* auto rebuild failed */

/* iq2_FirmwareFeatures Values */
#define DAC_FF_CLUSTERING_ENABLED	0x00000001

/* DACMD_INQUIRY2 structure definitions. */
typedef struct dac_inquiry2
{
	u32bits	iq2_HardwareID;		/* what is board type */
/*	u32bits	iq2_EisaBoardID; */	/* Only EISA ID */
	u08bits	iq2_MajorFWVersion;
	u08bits	iq2_MinorFWVersion;
	u08bits	iq2_FWTurnNo;
	u08bits	iq2_FWType;

	u08bits	iq2_InterruptLevelFlag;	/* interrupt mode and reserved bits */
	u08bits	iq2_reserved2[3];

	u08bits	iq2_MaxChannelsPossible;/* maximum possible channels */
	u08bits	iq2_MaxChannels;	/* number of real channels present */
	u08bits	iq2_MaxTargets;		/* Maximum targets supported */
	u08bits	iq2_MaxTags;		/* maximum tags supported per physdev */

	u08bits	iq2_MaxSystemDrives;	/* maximum system drives supported */
	u08bits	iq2_MaxDrivesPerStripe;	/* maximum arms */
	u08bits	iq2_MaxSpansPerSystemDrive;/* maximum spans */
	u08bits iq2_SpanAlgorithm;	/* Span Algorithm  */
	u08bits iq2_AccessibleChannels; /* bitmap for cable check results */
	u08bits	iq2_Reserved3[3];

	u32bits	iq2_MemorySize;		/* memory size in bytes */
	u32bits	iq2_CacheSize;		/* memory used for cache in bytes */
	u32bits	iq2_FlashRomSize;	/* EE Prom SIze in bytes */
	u32bits	iq2_NVRamSize;		/* NV Ram Size in Bytes */
	u16bits	iq2_MemoryType;		/* Memory Type information */

	u16bits	iq2_ClockSpeed;		/* CPU clock in nano seconds */
	u16bits	iq2_MemorySpeed;	/* Memory speed in nano seconds */
	u16bits	iq2_HardwareSpeed;	/* Hardware speed in nano seconds */
	u08bits	iq2_Reserved4[12];

	u16bits	iq2_MaxCommands;
	u16bits	iq2_MaxSGEntries;	/* maximum scatter/gather entries */
	u16bits	iq2_MaxDevCommands;
	u16bits	iq2_MaxIODescriptors;

	u16bits	iq2_MaxBlockComb;
	u08bits	iq2_Latency;
	u08bits	iq2_Reserved5;

	u08bits	iq2_SCSITimeout;
	u08bits	iq2_Rserved6;
	u16bits	iq2_MinFreeLines;

	u08bits	iq2_Reserved7[8];
	u08bits	iq2_RebuildRate;
	u08bits	iq2_Reserved8[3];
	u08bits	iq2_Reserved9[4];

    /* partner firmware version: 92-95 */
    u16bits iq2_PartnerFWVer;    /* partner's mismatching firmware version */
    u08bits iq2_PartnerFWBuild;
    u08bits iq2_FWMismatchCode;   /* reason for mismatch */

	u16bits	iq2_PhysicalBlockSize;
	u16bits	iq2_LogicalBlockSize;
	u16bits	iq2_MaxBlocksPerRequest;
	u16bits	iq2_BlockFactor;

	u16bits	iq2_CacheLineSize;
	u08bits	iq2_SCSICapability;	/* SCSI capabilities */
	u08bits	iq2_Reserved6[5];

	u16bits	iq2_FirmwareBuildNo;	/* firmware build number */
	u08bits	iq2_FaultMgmtType;	/* different fault management */
	u08bits	iq2_Reserved10;
	u08bits	iq2_MacAddr[6];		/* hardware address */
        u08bits iq2_Reserved11[2];
        u32bits iq2_FirmwareFeatures;   /* Firmware features */
}dac_inquiry2_t;
#define	dac_inquiry2_s	sizeof(dac_inquiry2_t)

#define	MLX_I2O_TYPE	0xDC000000

/* iq2_HardwareID information */
/* Byte 3 is BUS Information  as follows */
#define DAC_BUS_EISA	1		/* EISA bus card (DAC960)    */
#define DAC_BUS_MCA	2		/* MCA  bus card (DMC960)    */
#define DAC_BUS_PCI	3		/* PCI  bus card (DAC960P)   */
#define	DAC_BUS_VESA	4		/* VESA bus card */
#define	DAC_BUS_ISA	5		/* ISA  bus card */
#define	DAC_BUS_SCSI	6		/* SCSI bus card (DAC960SU, DAC960SX) */
#define DAC_NUM_BUS	6		/* Number of buses supported */

/* iq2_InterruptLevelFlag */
#define	DAC_INTERRUPTLEVELMASK	0x01
#define	DAC_EDGEMODEINTERRUPT	0x00 /* Edge Mode interrupt */
#define	DAC_LEVELMODEINTERRUPT	0x01 /* Level Mode interrupt */

/* iq2_FaultMgmtType */
#define	DAC_FAULTMGMT_AEMI		0x01
#define	DAC_FAULTMGMT_INTEL		0x02
#define	DAC_FAULTMGMT_STORAGEWORKS	0x04
#define	DAC_FAULTMGMT_IBM		0x08
#define	DAC_FAULTMGMT_CONNER		0x10
#define	DAC_FAULTMGMT_SAFTE		0x20
#define DAC_FAULTMGMT_SES		0x40

/* iq2_SCSICapability */
#define	DAC_SCSICAP_DIFF		0x10 /* =1 differential, =0 single end*/
#define	DAC_SCSICAP_SPEEDMASK		0x0C
#define	DAC_SCSICAP_SPEED_10MHZ		0x00 /* 10 MHz */
#define	DAC_SCSICAP_SPEED_20MHZ		0x04 /* 20 MHz */
#define	DAC_SCSICAP_SPEED_40MHZ		0x08 /* 40 MHz */
#define	DAC_SCSICAP_SPEED_80MHZ		0x0C /* 80 MHz */
#define	DAC_SCSICAP_WIDTHMASK		0x03
#define	DAC_SCSICAP_32BIT		0x02
#define	DAC_SCSICAP_16BIT		0x01
#define	DAC_SCSICAP_8BIT		0x00

/* Port B values for AEMI bits (8..13) */
#define	DAC_AEMI_FORCE_SCSI_SCAN	0x0100 /* SWI0: force scsi scan */
#define	DAC_AEMI_POWER_FAULT		0x0200 /* SHI0: power Failed */
#define	DAC_AEMI_ALARMRESET		0x0400 /* SWI1: Alaram reset */
#define	DAC_AEMI_FAN_FAULT		0x0800 /* SHI1: fan failed */
#define	DAC_AEMI_ARM_CERT_INPUT		0x1000 /* SWI2: ARM certified input */
#define	DAC_AEMI_TEMPERATURE_FAULT	0x2000 /* over temperature */
#define	DAC_AEMI_ALL_FAULT		(DAC_AEMI_POWER_FAULT|DAC_AEMI_FAN_FAULT|DAC_AEMI_TEMPERATURE_FAULT)	/* DAC_AEMI_POWER_FAN_TEMPERATURE_FAULT */

/* Port B values for Storage Works bits (8..13) for DAC960PD, PL, etc.*/
#define	DAC_STWK_SWAP_CH0		0x0100 /* ch0: device remove/insert */
#define	DAC_STWK_FAULT_CH0		0x0200 /* ch0: power, fan, failed */
#define	DAC_STWK_SWAP_CH1		0x0400 /* ch1: device remove/insert */
#define	DAC_STWK_FAULT_CH1		0x0800 /* ch1: power, fan, failed */
#define	DAC_STWK_SWAP_CH2		0x1000 /* ch2: device remove/insert */
#define	DAC_STWK_FAULT_CH2		0x2000 /* ch2: power, fan, failed */
#define	DAC_STWK_FAULT			(DAC_STWK_FAULT_CH0|DAC_STWK_FAULT_CH1|DAC_STWK_FAULT_CH2)

/* iq2_MemorySpeed */
#define	DAC_DRAMSPEED	70 /* DRAM  speed */
#define	DAC_EDRAMSPEED	35 /* EDRAM speed */

/* iq2_MemoryType */
#define	DACIQ2_DRAM		0x00 /* DRAM */
#define	DACIQ2_EDO		0x01 /* EDO */
#define	DACIQ2_SDRAM		0x02 /* SDRAM */
#define	DACIQ2_MEMORYMASK	0x07
#define	DACIQ2_PARITY		0x08
#define	DACIQ2_ECC		0x10
#define	DACIQ2_MEMPROTMASK	0x38

/* MemoryType memory types used in DAC960 family */
#define	DAC_MEMPROTMASK	0xE0
#define	DAC_ECC		0x80 /* =1 if memory has ECC protection */
#define	DAC_PARITY	0x40 /* =1 if memory has Parity protection */
#define	DAC_MEMORYMASK	0x1F
#define	DAC_DRAM	0x01 /* Dynamic RAM */
#define	DAC_EDRAM	0x02 /* EDRAM */
#define	DAC_EDO		0x03 /* EDO */
#define	DAC_SDRAM	0x04 /* SDRAM */

/* DACMD_GETEVENTLOG : sense information */
typedef	struct	dac_senselog
{
	u08bits	dsl_MsgType;	/* Message type = 0 */
	u08bits	dsl_MsgSize;	/* Message size = 20 */
	u08bits	dsl_ChTgt;	/* bits 7..5 channel, bits 4..0 Target */
	u08bits	dsl_LunID;	/* LUN ID */
	u16bits	dsl_SeqNo;	/* sequenece number */
	u08bits	dsl_SenseData[14];	/* request sense data */
}dac_senselog_t;
#define	dac_senselog_s	sizeof(dac_senselog_t)

typedef struct dac_command
{
	u08bits	mb_Command;	/* Mail Box register 0	*/
	u08bits	mb_CmdID;	/* Mail Box register 1	*/
	u08bits	mb_ChannelNo;	/* Mail Box register 2	*/
	u08bits	mb_TargetID;	/* Mail Box register 3	*/
	u08bits	mb_DevState;	/* Mail Box register 4	*/
	u08bits	mb_MailBox5;	/* Mail Box register 5	*/
	u08bits	mb_MailBox6;	/* Mail Box register 6	*/
	u08bits	mb_SysDevNo;	/* Mail Box register 7	*/
	u32bits	mb_Datap;	/* Mail Box register 8-B */
	u08bits	mb_MailBoxC;	/* Mail Box register C	*/ 
	u08bits	mb_StatusID;	/* Mail box register D	*/
	u16bits	mb_Status;	/* Mail Box Register E,F */
}dac_command_t;
#define	dac_command_s	sizeof(dac_command_t)
#define	mb_MailBox2	mb_ChannelNo
#define	mb_MailBox3	mb_TargetID
#define	mb_MailBox4	mb_DevState
#define	mb_MailBox7	mb_SysDevNo
#define	mb_MailBoxD	mb_StatusID

/* this structure is used to access command information in 4 bytes */
typedef struct dac_command4b
{
	u32bits	mb_MailBox0_3;	/* Mail Box register 0, 1, 2, 3 */
	u32bits	mb_MailBox4_7;	/* Mail Box register 4, 5, 6, 7 */
	u32bits	mb_MailBox8_B;	/* Mail Box register 8, 9, A, B */
	u32bits	mb_MailBoxC_F;	/* Mail Box register C, D, E, F */ 
}dac_command4b_t;

/* this structure is used to access 32 byte command information in 4 bytes */
typedef struct dac_command32b
{
	u32bits	mb_MailBox00_03; /* Mail Box register 0, 1, 2, 3 */
	u32bits	mb_MailBox04_07; /* Mail Box register 4, 5, 6, 7 */
	u32bits	mb_MailBox08_0B; /* Mail Box register 8, 9, A, B */
	u32bits	mb_MailBox0C_0F; /* Mail Box register C, D, E, F */
	u32bits	mb_MailBox10_13; /* Mail Box register 0, 1, 2, 3 */
	u32bits	mb_MailBox14_17; /* Mail Box register 4, 5, 6, 7 */
	u32bits	mb_MailBox18_1B; /* Mail Box register 8, 9, A, B */
	u32bits	mb_MailBox1C_1F; /* Mail Box register C, D, E, F */
}dac_command32b_t;

#define	mb_Parameter	mb_ChannelNo	/* this field is for parameters */

/* The following structure is used to send and receive 64 byte DAC commands */
typedef	struct	mdac_commandnew
{
	u16bits	nc_CmdID;	/* Unique command identifire */
	u08bits	nc_Command;	/* Acutal command value */
	u08bits	nc_CCBits;	/* Command control bits */
	u32bits	nc_TxSize;	/* Data transfer size in bytes */
	u64bits	nc_Sensep;	/* Request sense memory address */

	u08bits	nc_LunID;	/* Physical device LUN or RAID device number low byte */
	u08bits	nc_TargetID;	/* Physical device Target ID or RAID device number high byte */
	u08bits	nc_ChannelNo;	/* Channel number of physical device bit 2..0 */
	u08bits	nc_TimeOut;	/* Time out value for the command */
	u08bits	nc_SenseSize;	/* Request Sense size if error happens */
	u08bits	nc_CdbLen;	/* SCSI CDB length value */
	u08bits	nc_Cdb[10];	/* 10 byte CDB value or other parameters */

	mdac_sglist64b_t nc_SGList0;	/* first  SG list for command */
	mdac_sglist64b_t nc_SGList1;	/* second SG list for command */
} mdac_commandnew_t;
#define	mdac_commandnew_s	sizeof(mdac_commandnew_t)
#define	nc_SubIOCTLCmd	nc_CdbLen	/* Sub IOCTL command */
#define	nc_RAIDDevNoLo	nc_LunID	/* RAID device number byte 0 value */
#define	nc_RAIDDevNoHi	nc_TargetID	/* RAID device number byte 1 value */
#define	nc_DevState	nc_Cdb[0]	/* RAID Device State */
#define	nc_SeqNumByte2	nc_LunID
#define	nc_SeqNumByte3	nc_TargetID
#define	nc_SeqNumByte0	nc_Cdb[0]
#define	nc_SeqNumByte1	nc_Cdb[1]

/* 9/22/99 - added support for SIR on new API cards (judyb) */
#define	nc_NumEntries	nc_TxSize
#define	nc_CmdInfo		nc_Cdb[0]
#define	nc_CommBufAddr	nc_SGList0.sg_PhysAddr
#define	nc_CommBufAddrLow	nc_SGList0.sg_PhysAddr.bit31_0
#define	nc_CommBufAddrHigh	nc_SGList0.sg_PhysAddr.bit63_32
#define MDAC_SETSLAVE		0
#define MDAC_SETMASTER		1

/*10/29/99 - add support for 12 byte SCSICMDs on new API cards(judyb)*/
#define	nc_CdbPtr		nc_Cdb[2]

/* Added by MM on 12/02/1999 */
/* Note: FW Group calls nc_StatisticsType as IOCTL_clear_counters */
#define	nc_StatisticsType	nc_Cdb[0]	/* Used only for MDACIOCTL_GETPHYSDEVSTATISTICS & MDACIOCTL_GETLOGDEVSTATISTICS */

/* Posible values for nc_StatisticsType */
#define CUMULATIVE_STATISTICS 0x00 /* (the default value) Number of reads or writes are cumulated and returned by the firmware */
#define DELTA_STATISTICS	  0x01 /* Only the delta of the number of reads or writes are returned by the firmware */

/* The following structure is used to get the status of a command */
typedef	struct	mdac_statusnew
{
	u16bits	ns_CmdID;	/* Unique command identifire */
	u16bits	ns_Status;	/* Acutal status value */
	u32bits	ns_ResdSize;	/* The number of bytes that did not transfer */
} mdac_statusnew_t;
#define	mdac_statusnew_s	sizeof(mdac_statusnew_t)


/* The following structure is used to send SG structure for new command interface */
typedef	struct	mdac_newcmdsglist
{
	u16bits	ncsg_ListLen0;	/* First SG List length */
	u16bits	ncsg_ListLen1;	/* second SG List length */
	u16bits	ncsg_ListLen2;	/* third SG List length */
	u16bits	ncsg_Reserved0;
	u64bits	ncsg_ListPhysAddr0;	/* First SG list physical address */
	u64bits	ncsg_ListPhysAddr1;	/* First SG list physical address */
	u64bits	ncsg_ListPhysAddr2;	/* First SG list physical address */
} mdac_newcmdsglist_t;
#define	mdac_newcmdsglist_s	sizeof(mdac_newcmdsglist_t)


/* some comman values for mb_Status values */
#define	DCMDERR_NOCODE		0x0104 /* command not implemented */
#define	DCMDERR_DRIVERTIMEDOUT	0xFFFF /* driver timed out on the command */

#define	DAC_CDB_LEN	12	/* Maximum SCSI command size allowed */
#define	DAC_SENSE_LEN	64	/* Input from device, if enabled */

/* Direct CDB command, as sent to the DAC */
typedef struct	dac_scdb
{
	u08bits db_ChannelTarget;	/* ChannelNo 7..4 & Target 3..0 */
	u08bits db_DATRET;		/* different bits, see below */
	u16bits	db_TransferSize;	/* Request/done size in bytes */ 
	u32bits db_PhysDatap;		/* Physical addr in host memory	*/
	u08bits db_CdbLen;		/* 6, 10 or 12			*/
	u08bits db_SenseLen;		/* If returned from DAC (<= 64)	*/
	u08bits	db_Cdb[DAC_CDB_LEN];	/* The CDB itself		*/
	u08bits	db_SenseData[DAC_SENSE_LEN];/* Result of request sense	*/
	u08bits db_StatusIn;		/* SCSI status returned		*/
	u08bits	db_Reserved1;		/* subbu: used by solaris as a  */
					/* flag to indicate that sense  */
					/* data is cooked up and needs  */
					/* to be copiued from           */
					/* db_SenseData[]               */
}dac_scdb_t;
#define	dac_scdb_s	sizeof(dac_scdb_t)
#define	db_TxSize	db_TransferSize

#define	DAC_DCDB_CHANNEL_MASK	0xF0 /* upper 4 bits */
#define	DAC_DCDB_TARGET_MASK	0x0F /* lower 4 bits */
#define	mdac_chantgt(ch,tgt)	((((ch)&0x0F) << 4) + ((tgt)&0x0F))
#define	ChanTgt(ch,tgt)	mdac_chantgt(ch,tgt)

/* db_DATRET bits values
** bit 1..0	Data transfer direction 1=read, 2=write, 0=no xfer
** bit 2..2	Early status 1=earlystatus, 0=normal completion
** bit 3..3	Reserved
** bit 5..4	Timeout 0=1hr 1=10sec 2=1min 3=20min
** bit 6..6	AutoSense 1=autorequest sense 0=no
** bit 7..7	Disconnect 1=allow disconnect, 0=no
*/
#define	DAC_XFER_NONE		0x00 /* no data transfer */
#define	DAC_XFER_READ		0x01 /* data transfer from device to system */
#define	DAC_XFER_WRITE		0x02 /* data transfer from system to device */
#define	DAC_DCDB_XFER_NONE	0x00
#define	DAC_DCDB_XFER_READ	0x01 /* data transfer from device to system */
#define	DAC_DCDB_XFER_WRITE	0x02 /* data transfer from system to device */
#define	DAC_DCDB_XFER_MASK	0x03
#define	DAC_DCDB_EARLY_STATUS	0x04 /* return early status */
#define	DAC_DCDB_RESERVED	0x08 /* reserved bit value */
#define	DAC_DCDB_TIMEOUT_1hr	0x00 /* one hour */
#define	DAC_DCDB_TIMEOUT_10sec	0x10 /* 10 seconds */
#define	DAC_DCDB_TIMEOUT_1min	0x20 /* 60 seconds */
#define	DAC_DCDB_TIMEOUT_20min	0x30 /* 20 minutes */
#define	DAC_DCDB_TIMEOUT_MASK	0x30
#define	DAC_DCDB_NOAUTOSENSE	0x40 /* do not allow auto request sense */
#define	DAC_DCDB_DISCONNECT	0x80 /* allow disconnect */



/* DACMD_DRV_INFO data format for a logical device */
typedef struct	dac_sd_info
{
	u32bits	sdi_DevSize;		/* ... in sectors (blocks)	*/
	u08bits	sdi_DevState;		/* ... see #defines below	*/
	u08bits	sdi_RaidType;		/* 0, 1, 5, 6, 7		*/
	u16bits	sdi_Reserved;
}dac_sd_info_t;
#define	dac_sd_info_s	sizeof(dac_sd_info_t)

/* logical device DevState values */
#define	DAC_SYS_DEV_ONLINE	0x03 /* logical device is online */
#define	DAC_SYS_DEV_CRITICAL	0x04 /* logical device is critical */
#define	DAC_SYS_DEV_OFFLINE	0xFF /* logical device is offline */

/* logical device DevState NEW values */
#define	DAC_SYS_DEV_ONLINE_NEW	0x01 /* logical device is online */
#define	DAC_SYS_DEV_CRITICAL_NEW 0x09 /* logical device is critical */
#define	DAC_SYS_DEV_OFFLINE_NEW	0x08 /* logical device is offline */


/* DACMD_PHYSDEV_STATE data format */
typedef struct	dac_phys_dev_state
{
	u08bits	pdst_Present;		/* Present and other bits value */
	u08bits	pdst_DevType;
	u08bits	pdst_DevState3x;	/* DevState for version 3.x */
	u08bits	pdst_DevState2x;	/* DevState for version 2.x */
	u08bits	pdst_SyncMultiplier3x;
	u08bits	pdst_SyncMultiplier2x;
	u08bits	pdst_SyncOffset;
	u08bits	pdst_Reserved2;
	u32bits	pdst_DevSize;		/* configured device size in blocks */
}dac_phys_dev_state_t;
#define	dac_phys_dev_state_s	sizeof(dac_phys_dev_state_t)

/* pdst_Present bits value */
#define	DAC_PHYSDEVPS_CONFIGURED 0x01 /* device is configured */

/* pdst_DevType bits value */
#define	DAC_PHYSDEVSTATE_TAG	0x80 /* =1 tag supported/=0 not supported */
#define	DAC_PHYSDEVSTATE_WIDE	0x40 /* =1 WIDE SCSI / =0 8 bit SCSI */
#define	DAC_PHYSDEVSTATE_SPEED	0x20 /* =1 FAST SCSI? / =0 5MHz SCSI */
#define	DAC_PHYSDEVSTATE_SYNC	0x10 /* =1 synchronous / =0 asynchronous */
#define	DAC_PHYSDEVSTATE_TYPEMASK 0x07/* mask to get the device type info */
#define	DAC_PHYSDEVSTATE_DISK	0x01 /* it is disk */
#define	DAC_PHYSDEVSTATE_NONDISK 0x02/* it is non disk */

/* pdst_DevState values */
#define	DAC_PHYSDEVSTATE_DEAD		0x00 /* Device is DEAD */
#define	DAC_PHYSDEVSTATE_WRITEONLY	0x02 /* Device is WRITE-ONLY */
#define	DAC_PHYSDEVSTATE_RBCANCELED	0x82 /* Device is Rebuild cancelled */
#define	DAC_PHYSDEVSTATE_ONLINE		0x03 /* Device is ONLINE */
#define	DAC_PHYSDEVSTATE_HOTSPARE	0x10 /* Device is on HOTSPARE */
#define	DAC_PHYSDEVSTATE_STOPOPRATION	0xFF /* Device is on stop operation */

/* pdst_DevState NEW values */
#define	DAC_PHYSDEVSTATE_DEAD_NEW			0x08 /* Device is DEAD */
#define DAC_PHYSDEVSTATE_UNAVAILABLE		0x0C /* Device is unavailable */
#define	DAC_PHYSDEVSTATE_UNCONFIGURED_NEW	0x00 /* Device is DEAD */
#define	DAC_PHYSDEVSTATE_WRITEONLY_NEW		0x03 /* Device is WRITE-ONLY */
#define	DAC_PHYSDEVSTATE_RBCANCELED_NEW		0x82 /* Device is Rebuild cancelled */
#define	DAC_PHYSDEVSTATE_ONLINE_NEW			0x01 /* Device is ONLINE */
#define	DAC_PHYSDEVSTATE_HOTSPARE_NEW		0x21 /* Device is on HOTSPARE */
#define	DAC_PHYSDEVSTATE_INSTABORTBIT_NEW	0x04 /* Device is INSTABORT */
#define	DAC_PHYSDEVSTATE_STOPOPRATION_NEW	0xFF /* Device is on stop operation. Is it 0xFF? */

/* DACMD_S2S_PHYSDEV_STATISTICS	 data format */
/* DACMD_PHYS_DEV_STATISTICS	 data format */
typedef struct dac_phys_dev_statistics
{
	u32bits	pdss_ReadCommands;	/* # read commands */
	u32bits	pdss_ReadBlocks;	/* # Blocks read */
	u32bits	pdss_WriteCommands;	/* # write commands */
	u32bits	pdss_WriteBlocks;	/* # Blocks written */
	u32bits	pdss_Reserved[4];
}dac_phys_dev_statistics_t;
#define	dac_phys_dev_statistics_s	sizeof(dac_phys_dev_statistics_t)

/* DACMD_SYS_DEV_STATS data format */
typedef struct dac_sys_dev_statistics
{
	u32bits	sdss_ReadCommands;	/* # read commands */
	u32bits	sdss_ReadBlocks;	/* # blocks read */
	u32bits	sdss_WriteCommands;	/* # write commands */
	u32bits	sdss_WriteBlocks;	/* # blocks written */
	u32bits	sdss_ReadHitBlocks;	/* # blocks read from cache */
	u32bits	sdss_Reserved[3];
}dac_sys_dev_statistics_t;
#define	dac_sys_dev_statistics_s	sizeof(dac_sys_dev_statistics_t)



/* DACMD_GET_ERRORS data format */
typedef struct dac_ctl_error
{
	u08bits cer_ParityErrors;	/* Parity error count */
	u08bits cer_SoftErrors;	/* Soft error count */
	u08bits cer_HardErrors;	/* Hard error count */
	u08bits cer_MiscErrors;	/* Misc error count */
} dac_ctl_error_t;
#define	dac_ctl_error_s	sizeof(dac_ctl_error_t)

/* MSbit of cer_HardError is set then it PFA */
#define	DAC_HARD_PFA_ERROR	0x80 /* =1 it Predictive Filure Analisys */


/* DACMD_REBUILD_STATUS data format */
typedef struct dac_sys_dev_rebuild_status
{
	u08bits	sdrs_DevNo;	/* System device number */
	u08bits	sdrs_OpStatus;	/* Operation Status */
	u08bits	sdrs_Reserved0;
	u08bits	sdrs_Reserved1;
	u32bits	sdrs_DevSize;	/* System device size */
	u32bits	sdrs_RebuildSize;/* rebuild remaining size */
} dac_sys_dev_rebuild_status_t;
#define	dac_sys_dev_rebuild_status_s	sizeof(dac_sys_dev_rebuild_status_t)
/* sdrs_Opstatus values */
#define	DACSDRS_NONE		0x00 /* No activity in progress */
#define	DACSDRS_AUTOREBUILD	0x01 /* automatic rebuild in progress */
#define	DACSDRS_MANUALREBUILD	0x02 /* mannual rebuild in progress */
#define	DACSDRS_CHECK		0x03 /* consistency check in progress */
#define	DACSDRS_DATAMIGRATION	0x04 /* Data migration in progress */
#define	DACSDRS_INIT		0x05 /* device initilazation in progress */


/* DACMD_READ_CONF2/DACMD_WRITE_CONF2 data structures */
typedef struct dac_config2
{
					/* HARDWARE INFORMATION */
	u08bits	cf2_HardwareControlBits;/* bits to controll hardware */
	u08bits	cf2_VendorFlag;		/* Vendor specific flags */
	u08bits	cf2_OEMCode;		/* OEM identifire code */
	u08bits	cf2_Reserved0;

					/* PHYSICAL DEVICE INFORMATION */
	u08bits	cf2_PhysDevBlockSize;	/* Physical Device Block Size in 512 */
	u08bits	cf2_SysDevBlockSize;	/* logical Device Block Size in 512 */
	u08bits	cf2_BlockFactor;
	u08bits	cf2_FirmwareControlBits;
	u08bits	cf2_DefRebuildRate;	/* Default Rebuild Rate */
	u08bits	cf2_CODControlBits;
	u08bits	cf2_BlocksPerCacheLine;
	u08bits	cf2_BlocksPerStripe;

					/* SCSI TRANSFER INFORMATION */
	u08bits	cf2_SCSIControlBits[6];	/* one byte per channel */
	u08bits cf2_SCSITagLimit; /* 1 -231 , default 32 */
	u08bits cf2_SCSIDeviceQueFlag;

					/* SCSI STARTUP INFORMATION */
	u08bits	cf2_StartMode;
	u08bits	cf2_NoDevs;
	u08bits	cf2_Delay1;
	u08bits	cf2_Delay2;
	u08bits	cf2_Reserved3[4];

	u08bits cf2_SCSITargetFlag0;   /* Flag */
	u08bits cf2_SCSITargetFlag1;   
	u08bits cf2_SCSITargetSCSIDCmdOpCode;  /* Direct Command Opcode=20h */
	u08bits cf2_SCSITargetSCSICDBOpCode; /* Pass-Thru Command Opcode=21h */
	u08bits cf2_Reserved4[4];

					/* HOST CONFIGURATION INFORMATION */
	u08bits cf2_HostConfigFlag0; 
	u08bits cf2_HostConfigCtrl1;	/* Not Used */
	u08bits cf2_HostConfigMAXIOPs;	/* Default = 244 */
	u08bits cf2_HostConfigCtrl2;	/* Not Used */

					/* SLIP_PM */
	u08bits cf2_SlipPMType0; 
	u08bits cf2_SlipPMSpeed0; 
	u08bits cf2_SlipPMControl0;	/* Must be set to 0, 8 bits /2 stop bits even parity */
	u08bits cf2_SlipPMProtocol0;	/* Must be set to 0 */
	u08bits cf2_SlipPMFlag0;	/* Must be set to P0ACKEN = 1 */
	u08bits cf2_SlipPMRsvd0;
	u08bits cf2_SlipPMType1; 
	u08bits cf2_SlipPMSpeed1; 
	u08bits cf2_SlipPMControl1; 
	u08bits cf2_SlipPMProtocol1; 
	u08bits cf2_SlipPMFlag1;
	u08bits cf2_SlipPMRsvd1;

	u08bits	cf2_BIOSCfg;		/* BIOS CONFIGURATIONS BITS */
					/* MS CONFIG */
	u08bits cf2_MSConfigPingTime;   /* MS unit time hardcoded at 4 secs */
	u08bits cf2_MSConfigProtocolControl;   /* Not Used */
	u08bits cf2_MSConfigAAConfig; 
	u08bits cf2_MSConfigMiscFlags;	/* Miscellaneous Control Flags */

					/* FIBRE CONFIGURATION */
	u08bits cf2_FibreConfigFibreControl; /* Fibre Channel config fields */
	/*
	** The following 4 bytes will contain the Hard Loop IDs 
	** for Controller 0 Port 0, Controller 0 Port 1,
	** Controller 1 Port 0, Controller 1 Port 1,
	*/
	u08bits cf2_FibreConfigHardLoopId[4];

	u16bits	cf2_CheckSum;
} dac_config2_t;
#define	dac_config2_s	sizeof(dac_config2_t)

/* Bit values of cf2_HardwareControlBits */
#define DACF2_EXPRO_BGINIT_DISABLE  0x80 /* ExPro BGINIT  DISable (opposite of the FSI) */
#define	DACF2_NORESCANONRESET	0x80 /* no rescan if reset during scan */
#define	DACF2_MS_MDLY		0x40
#define	DACF2_MASTERSLAVENABLE	0x20 /* enable master/slave mode */
#define	DACF2_WRITECACHENABLE	0x10 /* enable write cache */
#define	DACF2_ACTIVENEGENABLE	0x02 /* enable active negation is */
#define	DACF2_BATBACKUP_ENABLE	0x01 /* enable battery backup */

/* Bit values of cf2_VendorFlag */
#define	DACF2_REMOVEMEDIA	0x80 /* enable removeable media */
#define DACF2_OPERATIONAL_FMT   0x40 /* enable storage fault management */  /* ExPro: Operational Fault Management */
#define	DACF2_STORAGE_FMT	0x01 /* enable storage fault management */
#define	DACF2_AEMI_FMT		0x20 /* enable AEMI fault management */
#define	DACF2_DDFC		0x04 /* disable disconnect on first command */

/* Bit values of cf2_SCSIControlBits */
#define	DACF2_TAG		0x80 /* Tag is enabled */
#define	DACF2_F20_DISABLE	0x08 /* disable fast 20 */
#define	DACF2_S2S_SPEED_20MHZ	0x08 /* 20 MHz bit 3=1, bit1,0=0 */
#define	DACF2_FORCE_8BIT	0x04 /* =1 force it to 8 bit narrow */
#define	DACF2_SPEED_MASKNEW	(DACF2_SPEED_MASK|DACF2_F20_DISABLE)
#define	DACF2_SPEED_MASK	0x03 /* scsi speed mask */
#define	DACF2_SPEED_160MHZ	0x0A /*160 MHz speed */
#define	DACF2_SPEED_80MHZ	0x09 /* 80 MHz speed */
#define	DACF2_SPEED_40MHZ	0x08 /* 40 MHz speed */
#define	DACF2_SPEED_40MHZ_S2S   0x10 /* 40 MHz speed <- ExPro */
#define	DACF2_SPEED_20MHZ_S2S	0x08 /* 20 MHz speed <- ExPro */
#define	DACF2_SPEED_20MHZ	0x03 /* 20 MHz speed, F20_DISABLE=0 */
#define	DACF2_SPEED_10MHZNEW	(DACF2_SPEED_10MHZ|DACF2_F20_DISABLE)
#define	DACF2_SPEED_10MHZ	0x03 /* 10 MHz speed <- ExPro */
#define	DACF2_SPEED_5MHZ	0x02 /*  5 MHz speed <- ExPro */
#define	DACF2_SPEED_8MHZ	0x01 /*  8 MHz speed <- ExPro */
#define	DACF2_SPEED_ASYNC	0x00 /* asynchronous speed */
#define	DACF2_SPEED_MASK_S2S    (DACF2_SPEED_40MHZ_S2S|DACF2_SPEED_20MHZ_S2S|DACF2_SPEED_10MHZ) /* <- ExPro speed mask */

/* Bit values cf2_SCSIDeviceQueFlag */
#define DACF2_SCHN_COMB_ENABLE 0x01
#define DACF2_SCHN_ELO_ENABLE  0x02

/* Bit values of cf2_FirmwareControlBits */
#define	DACF2_RAID5LEFTSYMETRIC	0x80 /* RAID5 algo control, left symetric */
#define	DACF2_REASSIGN1BLK	0x10 /* reassign one block per command */
#define	DACF2_BILODLY		0x02
#define	DACF2_READAHEADENABLE	0x01 /* enable read ahead */
#define DACF2_ENABLE_SUPER_MSREADAHEAD 0x04 /* Super Read Ahead with MS */
#define DACF2_ENABLE_SUPER_READAHEAD   0x08 /* Super Read Ahead */
#define DACF2_ENABLE_TRUEVER_DATA      0x20 /* True ver of data */
#define DACF2_ENABLE_WRITE_THRUVER     0x40 /* Write/Read from media for vrfy on error */

/* Bit values of cf2_BIOSCfg */
#define	DACF2_BIOS_DISABLED	0x01 /* =1 BIOS disabled, =0 BIOS enabled */
#define	DACF2_CDROMBOOT_ENABLED	0x02 /* =1 CD-ROM boot enabled, =0 disabled */
#define	DACF2_BIOS_2GB		0x00 /* 128 heads, 32 sectors */
#define	DACF2_BIOS_8GB		0x20 /* 255 heads, 63 sectors */
#define	DACF2_BIOS_MASK		0x60

/* Bits values in SCSI TARGET INFORMATION */
/* u08bits cf2_SCSITargetFlag0;     */
#define DACF2_DISABLE_WIDE_OPER         0x08    
/* u08bits cf2_SCSITargetFlag1;     */
#define DACF2_VENDOR_UNIQUE_TUR         0x08
#define DACF2_DISABLE_CCFOR_INVALID_LUN 0x10
#define DACF2_NO_PAUSE_SOME_COMMANDS    0x20
#define DACF2_DISABLE_QFULL_GIVE_BUSY   0x40
#define DACF2_DISABLE_BUSY_ON_FAILBACK  0x80     // DISBUSY - disable busy on failback 
                /*  Title:      disable busy on failback
                    Category:   On-The-Fly
                    Operation:  During failback this causes all pending commands to be
                        quietly dropped. 
                        Clr: Pending commands return busy during failback.
                        Set: Pending commands are dropped during failback.
                    Side Effects:
                        This is intended to help hosts that are confused by Queue Full.
                */


/* Bit values in HOST Configuration Information */
/* u08bits cf2_HostConfigFlag0;  */
#define DACF2_LUNALTMAP           	0x01
#define DACF2_FAILOVER_NODE_NAME  	0x04
#define DACF2_FIBRE_TOPOLOGY_MASK 	0x70
#define DACF2_FIBRE_TOPOLOGY_SHIFT	4
#define DACF2_FTOPO_INACTIVE_PORT 	0x00
#define DACF2_FTOPO_MULTIPORT     	0x01
#define DACF2_FTOPO_CLUSTERING    	0x02	/* Not implemented */
#define DACF2_FTOPO_MULTI_TID     	0x03
#define DACF2_FTOPO_MASTER_SLAVE	0x04
#define DACF2_DISABLE_UPS         	0x80

/* u08bits cf2_HostConfigCtrl1;  */
#define DACF2_PROPAGATE_RESET	0x02    /* Propagate Reset */
#define DACF2_NONSTD_MP_RESET	0x04    /* Non-Standard Multiple Port Reset */

/* Bit fields SLIP_PM */
/* u08bits cf2_SlipPMType0;  */
#define DACF2_SLDEBUG    0x01
#define DACF2_SLMASTER   0x02
#define DACF2_SLSLIP     0x03

/* Bit Fileds MS Config */
/* u08bits cf2_MSConfigProtocolControl;   */
#define DACF2_MS_AUTORESTORE 0x01
/* u08bits cf2_HostConfigAAConfig; */
#define DACF2_MS_AA_FSIM           0x01  /* Force Simplex */
#define DACF2_MS_AA_CCACH          0x02  /* Conservative Cache Mode */
#define DACF2_MS_AA_FAULT_SIGNALS  0x04  /* Duplex fault signals available */
#define DACF2_MS_AA_C4_FAULTS      0x08  /* Duplex fault signals on ch4 */
        /* Host SCSI reset delay in seconds 0 = no reset */
#define DACF2_MS_HOST_RESET_DELAY_MASK 0xF0 
/* u08bits cf2_HostConfigMiscFlags;  */
        /* Don't assert RSTCOM in simplex mode */
#define DACF2_MS_FLG_SIMPLEX_NORSTCOM 0x80
       
/* Fields Fibre Configuration */
/*    u08bits cf2_FibreConfigFibreControl; */
#define DACF2_PCI_LATENCY_MASK    0x30 /* PCI latency cntlr field mask */
#define DACF2_PCI_LATENCY_SHORT   0x00 /* short 0x80 */
#define DACF2_PCI_LATENCY_MED     0x01 /* medium 0xab */
#define DACF2_PCI_LATENCY_LONG    0x02 /* long 0xff */	
#define DACF2_PCI_LATENCY_DEFAULT DACF2_PCI_LATENCY_SHORT
#define DACF2_PCI_LATENCY_SHIFT   4

#define DACF2_FRAME_CTL_SHIFT     2
#define DACF2_FRAME_CTL_MASK      0x0C	
#define DACF2_FRAME_CTL_LONG      0x00 /* 2k bytes */	
#define DACF2_FRAME_CTL_MED       0x02 /* 1k bytes */	
#define DACF2_FRAME_CTL_SMALL     0x01 	/* 512 bytes */
#define DACF2_FRAME_CTL_DEFAULT   DACF2_FRAME_CTL_SMALL

#define DACF2_HOST_ALG_MASK       0x03 /* host algo cntl field mask */
#define DACF2_HOST_ALG_XFR_DATA   0x01 /* xfr data as valid */
#define DACF2_HOST_ALG_COALESCE   0x00
#define DACF2_HOST_ALG_DEFAULT    DACF2_HOST_ALG_XFR_DATA

/* u08bits cf2_FibreConfigHardLoopId[4]; */
#define DACF2_LOOP_ID_VALID    0x80 /* Loop id valid bit for  Fibre Port Loop ID */
#define DACF2_LOOP_ID_MASK     0x7F /* Valid range 0 - 125 */

typedef	struct dac_rebuild_status
{
	u08bits	rbs_SysDevNo;	/* rebuild/check device number */
	u08bits	rbs_OpStatus;	/* Rebuild, Check, Expand Cap */
	u08bits	rbs_Resvd0;
	u08bits	rbs_Resvd1;
	u32bits	rbs_SysDevSize;	/* System Device Size */
	u32bits	rbs_SysDevResd;	/* Remaining Blocks */
}dac_rebuild_status_t;
#define	dac_rebuild_status_s	sizeof(dac_rebuild_status_t)

/* DACMD_READ_BADBLOCKTABLE data format */
typedef	struct dac_badblock_v2x
{
	u08bits	bb_BlockNo0;	/* block number, byte 0 */
	u08bits	bb_BlockNo1;	/* block number, byte 1 */
	u08bits	bb_BlockNo2;	/* block number, byte 2 */
	u08bits	bb_BlockNoSysDevNo;/* Block and System device combination */
	u16bits	bb_BadBlocks;	/* number of blocks that are bad */
	u16bits	bb_Type;	/* when bad blocks were encountered */
} dac_badblock_v2x_t;
#define	dac_badblock_v2x_s	sizeof(dac_badblock_v2x_t)
/* bb_BlockNoSysDevNo bits */
#define	DACBB_MSBLOCKMASK	0x03 /* bits 1..0 */
#define	DACBB_SYSDEVMASK	0x1C /* bits 4..2 */
#define	DACBB_RESEREDMASK	0xC0 /* bits 7..5 */
#define	dacbb_blocksysdev2sysdev(bs)	((u32bits)((bs)& DACBB_SYSDEVMASK) >>((u32bits)2))
#define	dacbbv2x_blockno(bbp) \
	(((bbp->bb_BlockNoSysDevNo & DACBB_MSBLOCKMASK)<<24)+ \
	  (bbp->bb_BlockNo2<<16) + (bbp->bb_BlockNo1<<8) + bbp->bb_BlockNo0)
#define	dacbbv2x_sysdevno(bbp)	dacbb_blocksysdev2sysdev(bbp->bb_BlockNoSysDevNo)

typedef	struct dac_badblock_v4x
{
	u32bits	bb_BlockNo;	/* block number */
	u16bits	bb_BadBlocks;	/* number of blocks that are bad */
	u08bits	bb_Type;	/* when bad blocks were encountered */
	u08bits	bb_SysDevNo;	/* Block and System device combination */
} dac_badblock_v4x_t;
#define	dac_badblock_v4x_s	sizeof(dac_badblock_v4x_t)

typedef	struct dac_badblocktable
{
	u32bits	bbt_BadBlocks;	/* number of bad blocks entries */
	u32bits	bbt_Reserved;
	dac_badblock_v2x_t bbt_BadBlockTable[100]; /* bad blocks start here */
} dac_badblocktable_t;
#define	dac_badblocktable_s	sizeof(dac_badblocktable_t)


/* DACMD_ADD_CAPACITY data format */
typedef struct dac_addcap
{
	u08bits	adc_PhysDevices;	/* # physical devices to configure */
	u08bits	adc_SysDevOps;		/* system device operations */
	u08bits	adc_Reserved0[6];
	u08bits	adc_ChanID[14];		/* six devices Channel & ID values */
} dac_addcap_t;
#define	dac_addcap_s	sizeof(dac_addcap_t)
/* adc_SysDevOps bits value */
#define	DACADC_CREATESYSDEV	0x01 /* create system device */
#define	DACADC_INITSYSDEV	0x02 /* initialize the system device */

/* GET/SET SUBSYSTEMDATA */

/* SSD subsystem IDs */
#define DACSSD_IBBUID           0x10    /* Intel. Battery Backup Unit Subsystem ID (<<4)*/
#define DACSSD_AASID            0x20    /* Active-Active Shutdown     Subsystem ID (<<4)*/

/* IBBU operation IDs --------------------------------------------- */
#define DACSSD_GETDATA          0x00    /* Get subsystem data */
#define DACSSD_GETREGVAL        0x01    /* Get register value */

#define DACSSD_SETBBUTHRESHOLD  0x00    /* Set BBU threshold value */
#define DACSSD_SETREGVAL        0x01    /* Set register value */
#define DACSSD_BBUOP            0x02    /* Start BBU operation */

/* IBBU commands */
#define DACBBUOP_RECONDITION    0x01    /* Recondition the battery */
#define DACBBUOP_DISCHARGE      0x02    /* Discharge the battery */
#define DACBBUOP_STOPDISCHARGE  0x03    /* Stop ANY operation: dischg, recond, fastchg */
#define DACBBUOP_FAST_CHARGE    0x04    /* Fast charge operation */


/* AA Shutdown operation IDs -------------------------------------- */
#define DACSSD_AAS_GET_STATUS   0x01    /* Get AA shutdown status */
#define DACSSD_AAS_START_OP     0x02    /* Start AA shutdown operation */

/* AA Shutdown commands */
#define DACBBUOP_AAS_PREPARE    0x01    /* Prepare for shutdown */
#define DACBBUOP_AAS_CANCEL     0x02    /* Cancel shutdown, return to normal operation */

/* IBBU */
typedef	struct	dac_getibbuinfo
{
	u16bits	ibbu_CurPower;		/* current power in minutes */
	u16bits	ibbu_MaxPower;		/* Maximum power in minutes */
	u16bits	ibbu_ThresholdPower;	/* Threshold for FW operation */
	u08bits	ibbu_ChargeLevel;	/* Charge level of battery in % */
	u08bits	ibbu_Version;		/* Hardware version number */
	u08bits	ibbu_BatteryType;	/* Battery type used */
	u08bits	ibbu_Reserved0;
	u08bits	ibbu_OpStatus;		/* Operation Status */
	u08bits	ibbu_Reserved1;
} dac_getibbuinfo_t;
#define	dac_getibbuinfo_s	sizeof(dac_getibbuinfo_t)

/* ibbu_BatteryType values */
#define DACIBBUBT_UNKNOWN       0x00    /* unknown battery */
#define DACIBBUBT_NICAD         0x01    /* Nicad battery */
#define DACIBBUBT_NIMH          0x02    /* Nickel Metal Hydride battery */
#define DACIBBUBT_LITHIUM_ION    0x03    /* Lithium Ion battery */
#define DACIBBUBT_MISSING       0xfe    /* no battery */

/* ibbu_OpStatus */
#define	DACIBBUOPST_NOSYNC		0x01	/* No recondition since power on */
#define	DACIBBUOPST_OUTOF_SYNC	0x02	/* Recondition needed           */
#define	DACIBBUOPST_EODFIRST	0x04	/* First warning on low battery */
#define	DACIBBUOPST_EODLAST		0x08	/* Last  warning on low battery */
#define DACIBBUOPST_RECOND_ON   0x10    /* Reconditioning ON */
#define DACIBBUOPST_DISCHG_ON   0x20    /* Discharging ON */
#define DACIBBUOPST_FASTCHG_ON  0x40    /* Fast Discharging ON */
#define DACIBBUOPST_ALARM_ON    0x80    /* Low Power Alarm ON */

/* AA Shutdown */
typedef struct  dac_getaasinfo
{
    u08bits aasShutdownRequested ;      
    u08bits aasShutdownComplete ;       
    u08bits aasReserved0;               
    u08bits aasReserved1;               
} dac_getaasinfo_t;
#define dac_getaasinfo_s   sizeof(dac_getaasinfo_t)

/* DACMD_LONGOP_STATUS data format */
typedef	struct	dacinit_status
{
	u16bits	is_Status;		/* status of the command */
	u08bits	is_Reserved;
	u08bits	is_StatusLen;		/* Length of this status message */
	u32bits	is_InitDoneBlocks;	/* Init done in blocks */
} dacinit_status_t;
#define	dacinit_status_s	sizeof(dacinit_status_t)

/* Get Environment Status Related */
#define	GES_FAN_PAGE			0x01
#define	GES_POWER_PAGE			0x02
#define	GES_TEMPERATURE_PAGE	0x03
#define	GES_ALARM_PAGE			0x04
#define	GES_UPS_PAGE			0x05
#define	GES_ENCLOSURE_PAGE		0x06
#define	GES_ALL_SUPPORTED_PAGE	0xFF

#define GES_PAGE_HDR_LEN		   3

typedef struct {
    u08bits ges_PageCount;	/* bits 0:3. bits 4:7 reserved */
    u08bits ges_AllocLengthMsb;
    u08bits ges_AllocLengthLsb;
    u08bits ges_reserved3;
    u08bits ges_reserved4;
    u08bits ges_NumByteMsb;
    u08bits ges_NumByteLsb;
    u08bits ges_reserved7;
} dac_get_env_sts_hdr_t;

typedef struct {
    u08bits ges_PageCode;
    u08bits ges_PageLengthMsb;
    u08bits ges_PageLengthLsb;
    u08bits ges_NumElement;
    u08bits ges_Data[4];
} dac_ges_page_hdr_t;

typedef struct {
    u08bits gesd_Status;
    u08bits gesd_Speed;
    u08bits gesd_EnclosureId;
    u08bits gesd_Reserved3;
} dac_ges_fan_data_t;

typedef struct {
    u08bits gesd_Status;
    u08bits gesd_Reserved1;
    u08bits gesd_EnclosureId;
    u08bits gesd_Reserved3;
} dac_ges_power_data_t;

typedef struct {
    u08bits gesd_Status;
    u08bits gesd_Temperature;
    u08bits gesd_EnclosureId;
    u08bits gesd_Reserved3;
} dac_ges_temp_data_t;

typedef struct {
    u08bits gesd_Status;
    u08bits gesd_Reserved1;
    u08bits gesd_EnclosureId;
    u08bits gesd_Reserved3;
} dac_ges_alarm_data_t;

typedef struct {
    u08bits gesd_Status;
    u08bits gesd_Reserved1;
    u08bits gesd_EnclosureId;
    u08bits gesd_Reserved3;
} dac_ges_ups_data_t;

typedef struct {
    u08bits gesd_Status;
    u08bits gesd_NumSlots;
    u08bits gesd_EnclosureId;
    u08bits gesd_ControllerType;
    u08bits gesd_EnclosureInfo[36];	/* MSB first */
} dac_ges_encl_data_t;

#define GES_FAN_NOTPRESENT	0x00
#define GES_FAN_PRESENT		0x01
#define GES_FAN_FAILED		0x02
#define GES_FAN_MASK		0x03
#define GES_POWER_NOTPRESENT	0x00
#define GES_POWER_PRESENT	0x01
#define GES_POWER_FAILED	0x02
#define GES_POWER_MASK		0x03
#define GES_POWER_IGN_CNT	0x04
#define GES_TEMP_NOTPRESENT	0x00
#define GES_TEMP_PRESENT	0x01
#define GES_TEMP_FAILED		0x02
#define GES_TEMP_MASK		0x03
#define GES_TEMP_OTWARN		0x04
#define GES_ENCL_SES_BIT	0x10
#define GES_ENCL_PRIPATH_FAILED	0x04
#define GES_ENCL_SECPATH_FAILED	0x08
#define GES_ENCL_IGN_ACCESS		0x20
#define GES_ENCL_SES		0x10

/*==================DAC CONFIGURATIONS STARTS==========================*/
typedef	struct dacfg_spandev_v2x
{
	u08bits	cfg_ChannelNo;	/* Channel number */
	u08bits	cfg_TargetID;	/* Target ID */
	u08bits	cfg_Reserved0;
	u08bits	cfg_Reserved1;

	u32bits	cfg_StartBlocks;/* Start block for this logical device */
	u32bits	cfg_SizeBlocks;	/* number of blocks in logical device */
} dacfg_spandev_v2x_t;
#define	dacfg_spandev_v2x_s	sizeof(dacfg_spandev_v2x_t)

typedef	struct dacfg_spandev_v3x
{
	u32bits	cfg_StartBlocks;/* Start block for this logical device */
	u32bits	cfg_SizeBlocks;	/* number of blocks in logical device */
	u08bits	cfg_DevTbl[DAC_MAXPHYSDEVS_INPACK_V2x3x];/* bit 7..4 ch, bit 3..0 tgt*/
} dacfg_spandev_v3x_t;
#define	dacfg_spandev_v3x_s	sizeof(dacfg_spandev_v3x_t)


typedef	struct dacfg_arm_v2x
{
	u08bits	cfg_SpanDevs;	/* # Spanned devices on this ARM */
	u08bits	cfg_Reserved0;
	u08bits	cfg_Reserved1;
	u08bits	cfg_Reserved2;
#ifdef MLX_DOS
	dacfg_spandev_v2x_t cfg_SpanDevTbl[DAC_MAXSPAN];
#else
	dacfg_spandev_v2x_t cfg_SpanDevTbl[DAC_MAXSPAN_V2x3x];
#endif
} dacfg_arm_v2x_t;
#define	dacfg_arm_v2x_s	sizeof(dacfg_arm_v2x_t)

typedef	struct dacfg_sysdevinfo_v2x
{
	u08bits	cfg_DevState;	/* device state */
	u08bits	cfg_RaidLevel;	/* Raid Level */
	u08bits	cfg_Arms;	/* number of Arms */
	u08bits	cfg_InitState;	/* device init state */
#ifdef MLX_DOS
	dacfg_arm_v2x_t cfg_ArmTbl[DAC_MAXPHYSDEVS_INPACK];
#else
	dacfg_arm_v2x_t cfg_ArmTbl[DAC_MAXPHYSDEVS_INPACK_V2x3x];
#endif
} dacfg_sysdevinfo_v2x_t;
#define	dacfg_sysdevinfo_v2x_s	sizeof(dacfg_sysdevinfo_v2x_t)

typedef	struct dacfg_sysdevinfo_v3x
{
	u08bits	cfg_DevState;	/* device state */
	u08bits	cfg_DevStatusEx;/* extended device status */
	u08bits	cfg_Modifier1;	
	u08bits	cfg_Modifier2;

	u08bits	cfg_RaidLevel;	/* Raid Level */
	u08bits	cfg_Arms;	/* number of Arms */
	u08bits	cfg_Spans;	/* number of spans in this system device */
	u08bits	cfg_InitState;	/* device init state */

	dacfg_spandev_v3x_t cfg_SpanTbl[DAC_MAXSPAN_V2x3x];
} dacfg_sysdevinfo_v3x_t;
#define	dacfg_sysdevinfo_v3x_s	sizeof(dacfg_sysdevinfo_v3x_t)

/* cfg_InitState */
#define	CFGIST_NOINITDONE	0x80	/* device is not initilized */
#define	CFGIST_INITDONE		0x81	/* device is initialized */

typedef	struct dacfg_physdevinfo_v2x
{
	u08bits	cfg_Present;		/* bit 0, bit 7..1 reserved */
	u08bits	cfg_DevParams;		/* 0x91 for disk else 0x92 */
	u08bits	cfg_CfgDevState;	/* configured State */
	u08bits	cfg_CurrentDevState;	/* Current State */

	u08bits	cfg_Reserved0;
	u08bits	cfg_SyncParams;
	u08bits	cfg_SyncOffset;
	u08bits	cfg_Reserved1;

	u32bits	cfg_CfgDevSize;		/* Configured Device Size */
} dacfg_physdevinfo_v2x_t;
#define	dacfg_physdevinfo_v2x_s	sizeof(dacfg_physdevinfo_v2x_t)

typedef	struct dacfg_physdevinfo_v3x
{
	u08bits	cfg_Present;		/* bit 0, bit 7..1 reserved */
	u08bits	cfg_DevParams;		/* 0x91 for disk else 0x92 */
	u08bits	cfg_CurrentDevState;	/* Current State */
	u08bits	cfg_Reserved0;
	u08bits	cfg_Reserved1;
	u08bits	cfg_Reserved2;
	u08bits	cfg_CfgDevSize0;	/* Configured Device Size byte 0 */
	u08bits	cfg_CfgDevSize1;	/* Configured Device Size byte 1 */
	u08bits	cfg_CfgDevSize2;	/* Configured Device Size byte 2 */
	u08bits	cfg_CfgDevSize3;	/* Configured Device Size byte 3 */
} dacfg_physdevinfo_v3x_t;
#define	dacfg_physdevinfo_v3x_s	10	/* WARNING: structure size is not
					** aligned to 4 byte boundary.
					*/

/* Firmware 1.x and 2.x configuration structure */
typedef	struct dac_config_v2x
{
	u08bits	cfg_SysDevs;	/* # logical devices */
	u08bits	cfg_Reserved0;
	u08bits	cfg_Reserved1;
	u08bits	cfg_Reserved2;
	dacfg_sysdevinfo_v2x_t cfg_SysDevTbl[DAC_MAXSYSDEVS_V2x];
	dacfg_physdevinfo_v2x_t cfg_PhysDevTbl[DAC_MAXCHANNELS][DAC_MAXTARGETS_V2x];
}dac_config_v2x_t;
#define	dac_config_v2x_s	sizeof(dac_config_v2x_t)

/* core configuration of firmware 3.x */
typedef	struct dac_config_v3x
{
	u08bits	cfg_SysDevs;	/* # system devices */
	u08bits	cfg_Reserved5;
	u08bits	cfg_Reserved6;
	u08bits	cfg_Reserved7;

	dacfg_sysdevinfo_v3x_t cfg_SysDevTbl[DAC_MAXSYSDEVS_V3x];
/*	dacfg_physdevinfo_v3x_t cfg_PhysDevTbl[DAC_MAXCHANNELS][DAC_MAXTARGETS_V3x]; */
	u08bits cfg_PhysDevTbl[DAC_MAXCHANNELS*DAC_MAXTARGETS_V3x*dacfg_physdevinfo_v3x_s]; 
} dac_config_v3x_t;
#define	dac_config_v3x_s	sizeof(dac_config_v3x_t)

/* Firmware 3.x and above configuration structure */
typedef	struct dac_diskconfig_v3x
{
	/* HEADR STARTS */
	u32bits	cfg_Signature;	/* validity of configuration */

				/* Configration Label */
	u08bits	cfg_name[64];	/* configuration name */
	u32bits	cfg_ID;		/* cofiguration unique ID number */
	u16bits	cfg_SeqNo;	/* # times configuration has changed */
	u16bits	cfg_Reserved0;


	u32bits	cfg_TimeStamp;	/* second elasped since Jan 1, 1970 */

	u08bits	cfg_MaxSysDevs;	/* Maximum system devices */
	u08bits	cfg_MaxArms;	/* maximum arms */
	u08bits	cfg_MaxSpans;	/* maximum spans */
	u08bits	cfg_MaxChannels;/* maximum channels/controller */

	u08bits	cfg_MaxTargets;	/* maximum targets/channel */
	u08bits	cfg_MaxLuns;	/* maximum luns/target */
	u08bits	cfg_Reserved1;
	u08bits	cfg_ChannelNo;	/* Channel number of this physical device */

	u08bits	cfg_TargetID;	/* Target ID of this device */
	u08bits	cfg_LunID;	/* Lun of this device */
	u08bits	cfg_Reserved2;
	u08bits	cfg_Reserved3;

	dac_config2_t	cfg_cfg2;
	u08bits	cfg_Reserved4[30];
	u16bits	cfg_Checksum;	/* Checksum of whole header portions */
	/* HEADER ENDS*/

	dac_config_v3x_t cfg_core; /* core configuration */

	u08bits	cfg_Reserved10[128];
}dac_diskconfig_v3x_t;
#define	dac_diskconfig_v3x_s	sizeof(dac_diskconfig_v3x_t)

/* convert channel and target to physical device information pointer */
#define	cfgv3x_physdevp(cfgp,ch,tgt) \
	(dacfg_physdevinfo_v3x_t MLXFAR *)&((cfgp)->cfg_PhysDevTbl[ \
	((ch)*DAC_MAXTARGETS_V3x*dacfg_physdevinfo_v3x_s) + /*channel offset*/ \
	((tgt)*dacfg_physdevinfo_v3x_s)]) 


/*==================DAC CONFIGURATIONS ENDS============================*/



/*=====================PACK INFO STARTS==================================*/
/* These information is not part of standard dac960 but has been simplified
** for user functions.
*/
typedef	struct dac_packphysdev
{
	u08bits	pk_ChannelNo;		/* physical device channel */
	u08bits	pk_TargetID;		/* physical device Target ID */
	u08bits	pk_LunID;		/* physical device LUN ID */
	u08bits	pk_ArmNo;		/* physical device Arm Number */

	u08bits	pk_Present;
	u08bits	pk_DevParams;
	u08bits	pk_CfgDevState;		/* configured State */
	u08bits	pk_CurrentDevState;	/* Current State */

	u32bits	pk_CfgDevSize;		/* Configured Device Size */
	u32bits	pk_DevSizeUsed;		/* device size used in blocks */
} dac_packphysdev_t;
#define	dac_packphysdev_s	sizeof(dac_packphysdev_t)

typedef	struct dac_pack
{
	u08bits	pk_PackNo;	/* Pack number */
	u08bits	pk_PhysDevs;	/* # physical device present in pack */
	u16bits	pk_RaidDevNo;	/* Raid device no. for new COD */

	u32bits	pk_PackSize;	/* pack size in blocks */
	u32bits	pk_PackSizeUsed;/* used pack size in blocks */
	u32bits	pk_PackSizeUsable;/* usable pack size in blocks */

	dac_packphysdev_t pk_PhysDevTbl[DAC_MAXPHYSDEVS_INPACK];
} dac_pack_t;
#define	dac_pack_s	sizeof(dac_pack_t)

/* system device to physical and pack information */
typedef	struct dac_sysphysdev
{
	u08bits	spk_ChannelNo;	/* physical device channel */
	u08bits	spk_TargetID;	/* physical device Target ID */
	u08bits	spk_LunID;	/* physical device LUN ID */
	u08bits	spk_PackNo;	/* physical device Pack Number */

	u32bits	spk_StartBlocks;/* Start block for this logical device */
	u32bits	spk_SizeBlocks;	/* number of blocks in logical device */
} dac_sysphysdev_t;
#define	dac_sysphysdev_s	sizeof(dac_sysphysdev_t)

typedef	struct dac_syspack
{
	u08bits	spk_Packs;	/* # packs  present in system device */
	u08bits	spk_PhysDevs;	/* # physical device present in system device */
	u08bits	spk_RaidLevel;	/* Raid Level */
	u08bits	spk_InitState;	/* System device init state */
	u08bits spk_RWControl;
	u08bits spk_StripeSize;
	u08bits spk_CacheLineSize;
	u08bits spk_ConfigGroup; /* system drive config group no. */
	u32bits	spk_PhysSize;	/* used physical size in blocks */
	u32bits	spk_PackNoTbl[DAC_MAXSPAN];	/* different pack used */
	u32bits	spk_PackSizeTbl[DAC_MAXSPAN];	/* different pack sizes used */
	dac_sysphysdev_t spk_PhysDevTbl[DAC_MAXPHYSDEVS_INPACK*DAC_MAXSPAN];
} dac_syspack_t;
#define	dac_syspack_s	sizeof(dac_syspack_t)

/*=====================PACK INFO ENDS====================================*/

/* different controller types */
/* ci_ControllerType
** 0x01 .. 0x7F will be disk array controller
** 0x60 .. 0x7F will be disk array controller SCSI to SCSI
** 0x80 .. 0xFF will be host bus adapters
*/
#define	DACTYPE_DAC960E		0x01 /* DAC960 EISA */
#define	DACTYPE_DAC960M		0x08 /* DAC960 MCA */
#define	DACTYPE_DAC960PD	0x10 /* DAC960 PCI Dual */
#define	DACTYPE_DAC960PL	0x11 /* DAC960 PCI Low cost */
#define	DACTYPE_DAC960PDU	0x12 /* DAC960PD Ultra */
#define	DACTYPE_DAC960PE	0x13 /* DAC960 Peregrine low cost */
#define	DACTYPE_DAC960PG	0x14 /* DAC960 Peregrine high performance */
#define	DACTYPE_DAC960PJ	0x15 /* DAC960 Road Runner */
#define	DACTYPE_DAC960PTL0	0x16 /* DAC960 Jaguar */
#define	DACTYPE_DAC960PR	0x17 /* DAC960 Road Runner */
#define	DACTYPE_DAC960PRL	0x18 /* DAC960 Tomcat */
#define	DACTYPE_DAC960PT	0x19 /* DAC960 Road Runner */
#define	DACTYPE_DAC1164P	0x1A /* DAC1164 Little Apple */
#define	DACTYPE_DAC960PTL1	0x1B /* DAC960 Jaguar+ */

/* The following 3 was updated on 11-8-99 by Manoj */
#define	DACTYPE_EXR2000P		0x1C /* Big Apple - Notes: Replaces #DACTYPE_DAC1264P*/
#define	DACTYPE_EXR3000P		0x1D /* Fiber Apple - Notes: Replaces #DACTYPE_DAC1364P*/
#define	DACTYPE_ACCELERAID352	0x1E /* Leopard  - Notes: Newely added*/
#define	DACTYPE_ACCELERAID170	0x1F /* Lynx */


#define DACTYPE_I2O		0x50 /* I2O Device */

/* External Products */
#define	DACTYPE_DAC960S		0x60 /* DAC960S  -- not supported by GAM 2.21+ */
#define	DACTYPE_DAC960SU	0x61 /* DAC960SU -- not supported by GAM 2.21+ */
#define	DACTYPE_DAC960SX	0x62 /* DAC960SX */
#define	DACTYPE_DAC960SF	0x63 /* DAC960SF */
#define DACTYPE_DAC960SS	0x64 /* DAC960SS */
#define DACTYPE_DAC960FL	0x65 /* DAC960FL */
#define DACTYPE_DAC960LL	0x66 /* DAC960LL */
#define DACTYPE_DAC960FF	0x67 /* DAC960FF */
#define DACTYPE_DAC960HP	0x68 /* DAC960HP */
#define DACTYPE_DAC960MFL 	0x69 /* Meteor FL */
#define DACTYPE_DAC960MFF	0x6a /* Meteor FF */
#define DACTYPE_DAC960FFX	0x6b /* Brick FF  */
#define	DACTYPE_EXPRO_LO	DACTYPE_DAC960SX    /* this is the numerically lowest  supported ExPro controller */
#define	DACTYPE_EXPRO_HI	DACTYPE_DAC960FFX   /* this is the numerically highest supported ExPro controller */
/* External Products - end - 0x60 through 0x7f are reserved for ExPro */

#define	dactype_ishba(dactype)	((dactype) & DACTYPE_HBA) /* is HBA adater */
#define	dactype_isdac(dactype)	(!dactype_ishba(dactype)) /* is DAC adapter */
#define	dactype_isi2o(dt)	((dt) == DACTYPE_I2O)
        /* External Products of all models */
#define	dactype_isdacscsi(dt)	(((dt)>=DACTYPE_EXPRO_LO) && ((dt)<=DACTYPE_EXPRO_HI))
        /* External Products with FC-AL front ends */
#define	IsExProFibreHost(dt)    ( (dt)==DACTYPE_DAC960SF  || (dt)==DACTYPE_DAC960FL  ||\
                                  (dt)==DACTYPE_DAC960FF  || (dt)==DACTYPE_DAC960HP  ||\
                                  (dt)==DACTYPE_DAC960MFL || (dt)==DACTYPE_DAC960MFF ||\
                                  (dt)==DACTYPE_DAC960FFX   )
        /* External Products with FC-AL back ends */
#define	IsExProFibreDev(dt)     ( (dt)==DACTYPE_DAC960FF || (dt)==DACTYPE_DAC960FFX )
        /* External Products with LVD back ends */
#define	IsExProLvdDev(dt)       ( (dt)==DACTYPE_DAC960FL || (dt)==DACTYPE_DAC960LL ||\
                                  (dt)==DACTYPE_DAC960HP || (dt)==DACTYPE_DAC960MFL     )
#define	DACTYPE_HBA		0x80 /* HBA starts from here */
#define	DACTYPE_HBAVLBSTART	0x81
#define	DACTYPE_HBAVLBEND	0x87
#define	DACTYPE_HBA440		0x81 /* BT-440		VL Bus */
#define	DACTYPE_HBA440C		0x82 /* BT-440C		VL Bus */
#define	DACTYPE_HBA445		0x83 /* BT-445		VL Bus */
#define	DACTYPE_HBA445C		0x84 /* BT-445C		VL Bus */
#define	DACTYPE_HBA44xC		0x85 /* BT-44xC		VL Bus */
#define	DACTYPE_HBA445S		0x86 /* BT-445S		VL Bus */

#define	DACTYPE_HBAMCASTART	0x88
#define	DACTYPE_HBAMCAEND	0x8F
#define	DACTYPE_HBA640		0x88 /* BT-640		MCA Bus */
#define	DACTYPE_HBA640A		0x89 /* BT-640A		MCA Bus */
#define	DACTYPE_HBA646		0x8A /* BT-646		MCA Bus */
#define	DACTYPE_HBA646D		0x8B /* BT-646D		MCA Bus */
#define	DACTYPE_HBA646S		0x8C /* BT-646S		MCA Bus */

#define	DACTYPE_HBAEISASTART	0x90
#define	DACTYPE_HBAEISAEND	0x9F
#define	DACTYPE_HBA742		0x90 /* BT-742		EISA Bus */
#define	DACTYPE_HBA742A		0x91 /* BT-742A		EISA Bus */
#define	DACTYPE_HBA747		0x92 /* BT-747		EISA Bus */
#define	DACTYPE_HBA747D		0x93 /* BT-747D		EISA Bus */
#define	DACTYPE_HBA747S		0x94 /* BT-747S		EISA Bus */
#define	DACTYPE_HBA74xC		0x95 /* BT-74xC		EISA Bus */
#define	DACTYPE_HBA757		0x96 /* BT-757		EISA Bus */
#define	DACTYPE_HBA757D		0x97 /* BT-757D		EISA Bus */
#define	DACTYPE_HBA757S		0x98 /* BT-757S		EISA Bus */
#define	DACTYPE_HBA757CD	0x99 /* BT-757CD	EISA Bus */
#define	DACTYPE_HBA75xC		0x9A /* BT-75xC		EISA Bus */
#define	DACTYPE_HBA747C		0x9B /* BT-747C		EISA Bus */
#define	DACTYPE_HBA757C		0x9C /* BT-757C		EISA Bus */

#define	DACTYPE_HBAISASTART	0xA0
#define	DACTYPE_HBAISAEND	0xAF
#define	DACTYPE_HBA540		0xA0 /* BT-540		ISA Bus */
#define	DACTYPE_HBA540C		0xA1 /* BT-540C		ISA Bus */
#define	DACTYPE_HBA542		0xA2 /* BT-542		ISA Bus */
#define	DACTYPE_HBA542B		0xA3 /* BT-542B		ISA Bus */
#define	DACTYPE_HBA542C		0xA4 /* BT-542C		ISA Bus */
#define	DACTYPE_HBA542D		0xA5 /* BT-542D		ISA Bus */
#define	DACTYPE_HBA545		0xA6 /* BT-545		ISA Bus */
#define	DACTYPE_HBA545C		0xA7 /* BT-545C		ISA Bus */
#define	DACTYPE_HBA545S		0xA8 /* BT-545S		ISA Bus */
#define	DACTYPE_HBA54xC		0xA9 /* BT-54xC		ISA Bus */

#define	DACTYPE_HBAMMSTART	0xB0
#define	DACTYPE_HBAMMEND	0xBF
#define	DACTYPE_HBA946		0xB0 /* BT-946		PCI MULTIMASTER */
#define	DACTYPE_HBA946C		0xB1 /* BT-946C		PCI MULTIMASTER */
#define	DACTYPE_HBA948		0xB2 /* BT-948		PCI MULTIMASTER */
#define	DACTYPE_HBA948C		0xB3 /* BT-948C		PCI MULTIMASTER */
#define	DACTYPE_HBA956		0xB4 /* BT-956		PCI MULTIMASTER */
#define	DACTYPE_HBA956C		0xB5 /* BT-956C		PCI MULTIMASTER */
#define	DACTYPE_HBA958		0xB6 /* BT-958		PCI MULTIMASTER */
#define	DACTYPE_HBA958C		0xB7 /* BT-958C		PCI MULTIMASTER */
#define	DACTYPE_HBA958D		0xB8 /* BT-958D		PCI MULTIMASTER */
#define	DACTYPE_HBA956CD	0xB9 /* BT-956CD	PCI MULTIMASTER */
#define	DACTYPE_HBA958CD	0xBA /* BT-958CD	PCI MULTIMASTER */

#define	DACTYPE_HBAFPSTART	0xC0
#define	DACTYPE_HBAFPEND	0xCF
#define	DACTYPE_HBA930		0xC0 /* BT-930		PCI FLASHPOINT */
#define	DACTYPE_HBA932		0xC1 /* BT-932		PCI FLASHPOINT */
#define	DACTYPE_HBA950		0xC2 /* BT-950		PCI FLASHPOINT */
#define	DACTYPE_HBA952		0xC3 /* BT-952		PCI FLASHPOINT */

#define	DAC_BIOSSTART	0xC0000	/* BIOS space start address */
#define	DAC_BIOSEND	0xF0000	/* BIOS space end+1 address */
#define	DAC_BIOSSIZE	(DAC_BIOSEND - DAC_BIOSSTART) /* bios space size */

/* BIOS header information. This is the format used by BIOS to keep info */
typedef	struct dac_biosinfo
{
	u16bits	bios_Signature;		/* signature, 0xAA55 */
	u08bits	bios_RunTimeSize;	/* run time size in 512 bytes */
	u08bits	bios_InsJmp[3];		/* jump instruction size */
	u08bits	bios_Reserved0[18];	/* reserved 18 bytes */
	u16bits	bios_PCIDataOffset;	/* offset to PCI data structure in this table */
	u16bits	bios_Reserved1;		/* reserved to align 4 bytes boundary */
	u08bits	bios_PCIData[4];	/* "PCIR", Mylex signature for PCI */

	u16bits	bios_MylexID;		/* Mylex PCI ID */
	u16bits	bios_DeviceID;		/* DAC960 device ID */
	u16bits	bios_VPD;		/* pointer to VPD */
	u16bits	bios_PCIDataSize;	/* size of pci data structure */
	u08bits	bios_PCIRev;		/* PCI revision supported (0=2.1) */
	u08bits	bios_PCIHWInterface;	/* hardware interface (0=progam I/O) */
	u08bits	bios_PCISubClass;	/* PCI sub class device (4=RAID) */
	u08bits	bios_PCIClass;		/* PCI class (1=mass storage */
	u16bits	bios_ImageSize;		/* BIOS code+data size */
	u16bits	bios_Version;		/* BIOS version */
	u08bits	bios_CodeType;		/* BIOS code type (0=x86) */
	u08bits	bios_LastImageInd;	/* last image indicator (0x80=last) */
	u16bits	bios_Reserved10;
	u32bits	bios_Reserved11;
	u32bits	bios_Reserved12;
	u32bits	bios_Reserved13;

	u32bits	bios_OldIntVecs[16];	/* 0x40 : old interrupt vectors */
	u08bits	bios_V34PlusSign[7];
	u08bits	bios_VendorString[20];	/* Mylex Corporation(c) */
	u08bits	bios_PlusSign[5];

	u16bits	bios_PCIBusDevFunc[24];	/* 0xA0 PCI BUS+DEVICE+FUNCTION */
	u08bits	bios_SysDevs;		/* system devices installed before this BIOS */
	u08bits	bios_DacDevs[31];	/* system devices present on DACs */
	u16bits	bios_PicMask[16];	/* PIC1+PIC2 mask */
	u32bits	bios_IOBaseAddr[16];	/* PCI Memory/IO Base address */
	u32bits	bios_OldInt13;		/* Old interrupt 13 vector */
	u08bits	bios_OtherDacs;		/* Other DACs before this BIOS */
	u08bits	bios_TotalDacs;		/* Total DACs on this BIOS */
	u08bits	bios_BIOSFlags;		/* BIOS Flags */
	u08bits	bios_Reserved20;
	u32bits	bios_OldInt40;		/* Old interrupt 40 vector */
	u32bits	bios_OldInt19;		/* Old interrupt 19 vector */

					/* The following 12 bytes are same as
					** dga_driver_version */
	u32bits	bios_VersionSignature;	/* BIOS version signature 0x68536C4B */
	u08bits	bios_MajorVersion;	/* Major version number */
	u08bits	bios_MinorVersion;	/* Minor version number */
	u08bits	bios_InterimVersion;	/* interim version number */
	u08bits	bios_VendorName;	/* VendorName */
	u08bits	bios_BuildMonth;	/* Build Month */
	u08bits	bios_BuildDate;		/* Build Day */
	u08bits	bios_BuildYearMS;	/* Build MS year */
	u08bits	bios_BuildYearLS;	/* Build LS Year */
	u16bits	bios_BuildNo;		/* Build number */
	u08bits	bios_OSType;		/* Operating system name (BIOS) */
	u08bits	bios_Reserved21;
	u08bits	bios_VersionString[7];	/* Version string */
	u08bits	bios_DateString[14];	/* Build Date string */
	u08bits	bios_Reserved22[3];
	u32bits	bios_Reserved23;
	u32bits	bios_MemAddr;		/* BIOS run time memory address */

	u08bits	bios_IRQ[32];		/* 0x190 The IRQ values of DACs */

	u08bits	bios_Reserved40[80];	/* 0x1B0 */
} dac_biosinfo_t;
#define	dac_biosinfo_s	sizeof(dac_biosinfo_t)

/* bios_BIOSFlags bits */
#define	DACBIOSFL_BOOTDISABLED	0x01 /* 1=BIOS disabled, 0=BIOS enabled */
#define	DACBIOSFL_CDBOOTENABLED	0x02 /* 1=CD-ROM boot enabled, 0=disabled */
#define	DACBIOSFL_8GBENABLED	0x20 /* 1=8GB 0=2GB disk geometry enabled */

/* hardware clock information from DAC */
typedef	struct	dac_hwfwclock
{
	u32bits	hfclk_ms;	/* MS clock value */
	u32bits	hfclk_us;	/* US clock value */
	u32bits	hfclk_reserved0;
	u32bits	hfclk_reserved1;
} dac_hwfwclock_t;
#define	dac_hwfwclock_s	sizeof(dac_hwfwclock_t)

/* Gokhale, 01/12/98, Added dac_altmap_t, dac_rpltbl_t */
/* DACMD_RD_RPL_TAB data structures */

#define MAX_ALT_MAP		8 /* Max Replacement table entries */
typedef struct	dac_altmap
{
	u08bits	alt_o_chn;    		
	u08bits	alt_o_dev;             
	u08bits	alt_n_chn;            
	u08bits	alt_n_dev;           
} dac_altmap_t;
#define	dac_altmap_s	sizeof(dac_altmap_t)

typedef struct	dac_rpltbl
{
	u08bits	     rpl_n_entries;
	u08bits      rpl_Reserved0;
	u08bits      rpl_Reserved1;
	u08bits      rpl_Reserved2;
	dac_altmap_t rpl_altmap[MAX_ALT_MAP];
} dac_rpltbl_t;
#define	dac_rpltbl_s	sizeof(dac_rpltbl_t) /* 36 bytes */

/* Gokhale, 01/12/98, Added below dac_bdt_sd_t */
/* DACMD_READ_BADATATABLE data structure for getting Bad Data Info
 * for a system drive. The entire BDT Table is too big to be mapped
 * Virt to Phys, (normally <= 4K can be mapped) so it was logically spilt 
 * FW Ver 3.x returns smaller chunks of Info based on parameter and 
 * operation bytes in the command.
 * Following is ONLY for getting bad data info for 1 drive
 * I have NOT defined the other parts of BAD DATA TABLE structure because
 * they is not used so far.
 */

/* ONLY Part of DACMD_READ_BADATATABLE data structures */
#define MAX_BAD_DATA_BLKS	100
typedef struct dac_bdt_sd {
    u08bits sd_bad_data_cnt;
    u32bits sd_list[MAX_BAD_DATA_BLKS];
} dac_bdt_sd_t;
#define	dac_bdt_sd_s	sizeof(dac_bdt_sd_t)

/* GET DUAL CONTROLLER STATUS structure */
typedef struct dac_dual_ctrl_status
{
	u08bits	dcs_Format;		/* set to 2 */
	u08bits	dcs_Lun;		/* Lun on which cmd was recieved */
	u08bits	dcs_SysDrive;		/* System Drive to which Lun maps */
	u08bits	dcs_InfoLength;		/* Length of data following */
	u32bits	dcs_MasterSlaveState;	/* State info */
	u32bits	dcs_MSAdditionalInfo;
	u32bits	dcs_PartnerStatus;
	u32bits	dcs_DualActiveCtrlInfo;	
}dac_dual_ctrl_status_t;
#define dac_dual_ctrl_status_s sizeof(dac_dual_ctrl_status_t)
#define	DAC_S2S_NATIVE_TID	0x1000

typedef struct dac_config_label
{
	u08bits	dcl_Name[64];   /* free format - usually text */
	u32bits	dcl_ConfigID;  /* a unique number */
	u16bits	dcl_SeqNum; 	/* sequence# : # of times this config changed */
	u16bits	dcl_Reserved1;
} dac_config_label_t;
#define dac_config_label_s sizeof(dac_config_label_t)

typedef	struct dac_brconfig_v3x_t
{
	u08bits	brcfg_SysDevs;	/* # logical devices */
	u08bits	brcfg_Reserved0;
	u08bits	brcfg_Reserved1;
	u08bits	brcfg_Reserved2;

	dacfg_sysdevinfo_v2x_t brcfg_SysDevTbl[DAC_MAXSYSDEVS_V3x];
	dacfg_physdevinfo_v2x_t brcfg_PhysDevTbl[DAC_MAXCHANNELS][DAC_MAXTARGETS_V3x];
}dac_brconfig_v3x_t;
#define	dac_brconfig_v3x_s	sizeof(dac_brconfig_v3x_t)

#define	DAC_EXPRO_NATIVE_TID              0x00001000
#define	DAC_EXPRO_NATIVE_SLOT             0x000000f0
#define	DAC_EXPRO_CTRLR_SLOT              0x0000000f
#define	DAC_EXPRO_SLOT_MASK               0x000000ff
#define	DAC_EXPRO_NATIVE_SLOT_SHIFT       4
#define	DAC_EXPRO_CTRLR_SLOT_SHIFT        0

typedef struct daccluster_scsicontrol {
        u32bits         dsc_Initiator;
        u32bits         dsc_Control;
} dacluster_scsicontrol_t;

typedef struct dac_clustercontrol {
        u32bits                 dcc_Control;
        dacluster_scsicontrol_t dcc_ScsiControlTbl[DAC_MAXCHANNELS];
        u08bits                 dcc_Reserved[210];
        u16bits                 dcc_CheckSum;
} dac_clustercontrol_t;
#define dac_clustercontrol_s    sizeof(dac_clustercontrol_t)

/*=====================NEW INTERFACE STARTS==============================*/
/* The Mylex Disk Array Controller Firmware Software Interface (MDACFSI) */


/* command control bits */
#define	MDACMDCCB_FUA		0x01 /* Force Unit Access */
#define	MDACMDCCB_DPO		0x02 /* Disable Page out */
#define	MDACMDCCB_SYNTAXCHECK	0x04 /* do only syntax check on operation */
#define	MDACMDCCB_WITHSG	0x08 /* data address is in SG List format */
#define	MDACMDCCB_READ		0x10 /* =1 data read, =0 data write */
#define	MDACMDCCB_WRITE		0x00 
#define	MDACMDCCB_NOAUTOSENSE	0x40 /* =1 no auto sense, =0 auto sense */
#define	MDACMDCCB_AUTOSENSE	0x00
#define	MDACMDCCB_NODISCONNECT	0x80 /* =1 do not allow disconnect, =0 allow disconnect */
#define	MDACMDCCB_DISCONNECT	0x00

/* command values */
#define	MDACMD_MEMCOPY		0x01 /* memory to memory copy command */
#define	MDACMD_SCSIPT		0x02 /* SCSI pass through upto 10 bytes CDB */
#define	MDACMD_SCSILCPT		0x03 /* SCSI pass through upto 255 bytes CDB */
#define	MDACMD_SCSI		0x04 /* SCSI command upto 10 bytes CDB */
#define	MDACMD_SCSILC		0x05 /* SCSI command upto 255 bytes CDB */
#define	MDACMD_IOCTL		0x20 /* IOCTL command */

/* MDACMD_IOCTL values */
#define	MDACIOCTL_GETCONTROLLERINFO	0x01 /* get controller information */

#define	MDACIOCTL_GETLOGDEVINFOVALID	0x03 /* get valid logical dev info */

#define	MDACIOCTL_GETPHYSDEVINFOVALID	0x05 /* get valid physical dev info */

#define	MDACIOCTL_GETCTLDEVSTATISTICS	0x0B /* get controller statistics */

#define	MDACIOCTL_GETLOGDEVSTATISTICS	0x0D /* get logical dev statistics */

#define	MDACIOCTL_GETPHYSDEVSTATISTICS	0x0F /* get physical dev statistics */

#define	MDACIOCTL_GETHEALTHSTATUS	0x11 /* get health status */

#define	MDACIOCTL_GETREQUESTSENSE	0x13 /* get request sense */

#define	MDACIOCTL_GETEVENT		0x15 /* get event */

#define	MDACIOCTL_ENABLECTLTIMETRACE	0x18 /* enable controller time trace */
#define	MDACIOCTL_GETFIRSTIMETRACEDATA	0x19 /* get first time trace data */
#define	MDACIOCTL_DISABLECTLTIMETRACE	0x1A /* disable controller time trace */
#define	MDACIOCTL_GETIMETRACEDATA	0x1B /* get time trace data */
#define	MDACIOCTL_ENABLEALLTIMETRACE	0x1C /* enable all time trace */
#define	MDACIOCTL_WAITIMETRACEDATA	0x1D /* wait for time trace data */
#define	MDACIOCTL_DISABLEALLTIMETRACE	0x1E /* disable all time trace */
#define	MDACIOCTL_FLUSHALLTIMETRACEDATA	0x1F /* flush all time trace data */
#define	MDACIOCTL_ENABLEPROFILER	0x20 /* enable profiler */
#define	MDACIOCTL_GETFIRSTPROFILERDATA	0x21 /* get first profiler data */
#define	MDACIOCTL_DISABLEPROFILER	0x22 /* disable profiler data */
#define	MDACIOCTL_GETPROFILERDATA	0x23 /* get profiler data */
#define	MDACIOCTL_FLUSHALLPROFILERDATA	0x24 /* flush all profiler data */
#define	MDACIOCTL_WAITPROFILERDATA	0x25 /* wait for profiler data */
#define	MDACIOCTL_SETCLUSTERHOSTINFO	0x26 /* set cluster host info */
#define	MDACIOCTL_GETCLUSTERHOSTINFO	0x27 /* get cluster host info */
#define	MDACIOCTL_SETFTHOSTINFO		0x28 /* set fault tolerant host info */
#define	MDACIOCTL_GETFTHOSTINFO		0x29 /* get fault tolerant host info */
#define	MDACIOCTL_SETHOSTSTATE		0x2A /* set host state */
#define	MDACIOCTL_INCREMENTALIVECOUNTER	0x2B /* increment alive counter */
#define	MDACIOCTL_STOREIMAGE		0x2C /* store flash image */
#define	MDACIOCTL_READIMAGE		0x2D /* read flash image */
#define	MDACIOCTL_FLASHIMAGE		0x2E /* flash image */

#define	MDACIOCTL_RUNDIAGS		0x30 /* run diagnostics */

#define	MDACIOCTL_SETBBUPOWERTHRESHOLD	0x34 /* set BBU power threshold */
#define	MDACIOCTL_GETBBUINFO		0x35 /* get BBU information */
#define	MDACIOCTL_BBUIOSTART		0x36 /* start BBU operation */
#define	MDACIOCTL_GETSUBSYSTEMDATA		0x70 /* start BBU operation */
#define	MDACIOCTL_SETSUBSYSTEMDATA		0x71 /* start BBU operation */

#define	MDACIOCTL_ABORTCMD		0x80 /* abort a command */
#define	MDACIOCTL_SCANDEVS		0x81 /* scan devices */
#define	MDACIOCTL_SETRAIDDEVSTATE	0x82 /* set RAID device state */

#define	MDACIOCTL_INITPHYSDEVSTART	0x84 /* start physical device init */
#define	MDACIOCTL_INITPHYSDEVSTOP	0x85 /* stop physical device init */
#define	MDACIOCTL_INITRAIDDEVSTART	0x86 /* start RAID device init */
#define	MDACIOCTL_INITRAIDDEVSTOP	0x87 /* stop RAID device init */
#define	MDACIOCTL_REBUILDRAIDDEVSTART	0x88 /* start RAID device rebuild */
#define	MDACIOCTL_REBUILDRAIDDEVSTOP	0x89 /* stop RAID device rebuild */
#define	MDACIOCTL_MAKECONSISTENTDATASTART 0x8A /* start BGI */
#define	MDACIOCTL_MAKECONSISTENTDATASTOP 0x8B /* stop BGI */
#define	MDACIOCTL_CONSISTENCYCHECKSTART	0x8C /* start consistency check */
#define	MDACIOCTL_CONSISTENCYCHECKSTOP	0x8D /* stop consistency check */
#define	MDACIOCTL_SETMEMORYMAILBOX	0x8E /* set memory mail box */
#define	MDACIOCTL_SETDEBUGMAILBOX	0x8F /* set debug mail box */
#define	MDACIOCTL_RESETDEV		0x90 /* reset a device */
#define	MDACIOCTL_FLUSHDEVICEDATA	0x91 /* flush a device data */
#define	MDACIOCTL_PAUSEDEV		0x92 /* pause a device */
#define	MDACIOCTL_UNPAUSEDEV		0x93 /* un pause a device */
#define	MDACIOCTL_LOCATEDEVICE	0x94 /* locate device by blinking once */
#define MDACIOCTL_SETMASTERSLAVEMODE 0x95 /* set SIR master/slave mode */
#define MDACIOCTL_GETNVRAMEVENTLOG	 0x99 /* Get NVRAM error event log */
#define MDACIOCTL_BKGNDPTRLOP		 0x9A /* Background Patrol Read operation */
#define	MDACIOCTL_SETREALTIMECLOCK	0xAC /* set real time clock */
#define	MDACIOCTL_CREATENEWCONF		0xC0 /* create new configuration */
#define	MDACIOCTL_DELETERAIDDEV		0xC1 /* delete a RAID device */
#define	MDACIOCTL_REPLACEINTERNALDEV	0xC2 /* replace internal RAID device */
#define	MDACIOCTL_RENAMERAIDDEV		0xC3 /* rename RAID device */
#define	MDACIOCTL_ADDNEWCONF		0xC4 /* add new configuration */
#define	MDACIOCTL_XLATEPHYSDEVTORAIDDEV	0xC5 /* translate physical device to RAID device */
#define	MDACIOCTL_MORE			0xC6 /* do MORE */
#define	MDACIOCTL_COPYRAIDDEV		0xC7 /* copy RAID device */
#define	MDACIOCTL_SETPHYSDEVPARAMETER	0xC8 /* set physical device parameter */
#define	MDACIOCTL_GETPHYSDEVPARAMETER	0xC9 /* get physical device parameter */
#define	MDACIOCTL_CLEARCONF		0xCA /* clear configuration */
#define	MDACIOCTL_GETDEVCONFINFOVALID	0xCB /* get a valid device configuration */
#define	MDACIOCTL_GETGROUPCONFINFO	0xCC /* get a group configuration */
#define	MDACIOCTL_GETDEVFREESPACELIST	0xCD /* get devices free space list */
#define	MDACIOCTL_GETLOGDEVPARAMETER        0xCE /* get logical device parameters */
#define	MDACIOCTL_SETLOGDEVPARAMETER        0xCF /* set logical device parameters */
#define	MDACIOCTL_GETCONTROLLERPARAMETER    0xD0 /* get controller parameters */
#define	MDACIOCTL_SETCONTROLLERPARAMETER    0xD1 /* set controller parameters */
#define	MDACIOCTL_CLEARCONFSUSPMODE         0xD2 /* clear installation abort mode */
#define	MDACIOCTL_GETENVSTATUS		        0xD7 /* get Environmental status */
#define	MDACIOCTL_GETENCLOSUREINFO	        0xD8 /* get enclosure info */
#define MDACIOCTL_GETBADDATATABLE           0xE0 /* Gets bad data table */



/* same IOCTL command can be performed on different devices. The operation
** device defines the device type.
*/
#define	MDACDEVOP_PHYSDEV	0x00 /* Physical device */
#define	MDACDEVOP_RAIDDEV	0x01 /* RAID device */
#define	MDACDEVOP_PHYSCHANNEL	0x02 /* physical channel */
#define	MDACDEVOP_RAIDCHANNEL	0x03 /* RAID channel */
#define	MDACDEVOP_PHYSCONTROLLER 0x04 /* physical controller */
#define	MDACDEVOP_RAIDCONTROLLER 0x05 /* RAID controller */
#define	MDACDEVOP_ENCLOSURE 0x011 /* Enclosure Device */
#define	MDACDEVOP_ARRAY 0x10 /* RAID Array */

#define MDACFSI_PD_SCANACTIVE 0x01
/* The controller information is returned in the following format */
#define	MDAC_CDI_INSTALLATION_ABORT	0x00000001
#define	MDAC_CDI_MAINTENENCE_MODE	0x00000002

/* Patrol Read Command Option byte values */
#define START_PATROL_READ	0x00
#define STOP_PATROL_READ	0x01
#define GET_PATROL_READ_STATUS	0x02

/* NVRAM Event Log Command Option byte values */
#define NVRAMEVENT_CLEAR_LOG		0x00
#define NVRAMEVENT_GET_INFO			0x01
#define NVRAMEVENT_GET_ENTRY		0x02
#define NVRAMEVENT_GET_VALID_ENTRY		0x03
#define NVRAMEVENT_GET_BITMAP_CODE	0x81
#define NVRAMEVENT_SET_BITMAP_CODE	0x82


typedef struct mdacfsi_ctldev_info
{
	u08bits	cdi_ControllerNo;	/* Controller number */
	u08bits	cdi_BusType;		/* System Bus Interface Type */
	u08bits	cdi_ControllerType;	/* type of controller */
	u08bits	cdi_Reserved0;		/* Reserved for type extension */
	u16bits	cdi_BusSpeed;		/* Bus speed in MHz */
	u08bits	cdi_BusWidth;		/* Bus width in bits */
	u08bits	cdi_ImageControllerType;
	u32bits	cdi_Reserved2;
	u32bits	cdi_Reserved3;

	u08bits	cdi_BusName[16];	/* Bus interface name */
	u08bits	cdi_ControllerName[32];	/* Controller name */

					/* Firmware release information */
	u08bits	cdi_FWMajorVersion;	/* Firmware Major Version Number */
	u08bits	cdi_FWMinorVersion;	/* Firmware Minor Version Number */
	u08bits	cdi_FWTurnNo;		/* Firmware turn Number */
	u08bits	cdi_FWBuildNo;		/* Firmware build Number */
	u08bits	cdi_FWReleaseDate;	/* Firmware Release Date - Date */
	u08bits	cdi_FWReleaseMonth;	/* Firmware Release Date - Month */
	u08bits	cdi_FWReleaseYearMS;	/* Firmware Release Date - Year */
	u08bits	cdi_FWReleaseYearLS;	/* Firmware Release Date - Year */

					/* Hardware release information */
	u08bits	cdi_HWVersion;		/* Hardware Version Number */
	u08bits	cdi_Reserved4;
	u16bits	cdi_Reserved5;
	u08bits	cdi_HWReleaseDate;	/* Hardware release Date - Date */
	u08bits	cdi_HWReleaseMonth;	/* Hardware release Date - Month */
	u08bits	cdi_HWReleaseYearMS;	/* Hardware release Date - Year */
	u08bits	cdi_HWReleaseYearLS;	/* Hardware release Date - Year */

					/* Hardware manufacturing information */
	u08bits	cdi_HWMBatchNo;		/* Manufacturing batch number */
	u08bits	cdi_Reserved6;
	u08bits	cdi_HWMPlantNo;		/* Manufacturing plant number */
	u08bits	cdi_Reserved7;
	u08bits	cdi_HWMBuildDate;	/* Manufacturing Date - Date */
	u08bits	cdi_HWMBuildMonth;	/* Manufacturing Date - Month */
	u08bits	cdi_HWMBuildYearMS;	/* Manufacturing Date - Year */
	u08bits	cdi_HWMBuildYearLS;	/* Manufacturing Date - Year */

	u08bits	cdi_MaxArms;
	u08bits	cdi_MaxSpans;
	u16bits	cdi_NVRAMSize;		/* NVRAM size in KB */
	u32bits	cdi_Reserved8;

	u08bits	cdi_SerialNo[32];	/* Controller serial number string */

					/* OEM vendor information */
	u16bits	cdi_Reserved10;
	u08bits	cdi_Reserved11;
	u08bits	cdi_OEMCode;		/* OEM assigned code value */
	u08bits	cdi_OEMName[16];	/* OEM name */

	u08bits	cdi_HWOpStatus;		/* some HW operating status */
	u08bits	cdi_Reserved12;
	u16bits	cdi_Reserved13;

					/* Physical device scan information */
	u08bits	cdi_PDScanActive;	/* bit-0 is 1, scan is active */
	u08bits	cdi_PDScanChannelNo;	/* Scan Channel number */
	u08bits	cdi_PDScanTargetID;	/* Scan target ID */
	u08bits	cdi_PDScanLunID;	/* Scan Lun ID */

					/* Maximum data transfer sizes */
	u16bits	cdi_MaxDataTxSize;	/* maximum data transfer size in 512 bytes blocks */
	u16bits	cdi_MaxSGLen;		/* Maximum SG entries allowed */


					/* Logical / physical device counts */
	u16bits	cdi_LDPresent;		/* # logical  devices present */
	u16bits	cdi_LDCritical;		/* # logical  devices critical */
	u16bits	cdi_LDOffline;		/* # logical  devices offline */
	u16bits	cdi_PDPresent;		/* # physical devices present */
	u16bits	cdi_PDDiskPresent;	/* # physical disk devices present */
	u16bits	cdi_PDDiskCritical;	/* # physical disk devices critical */
	u16bits	cdi_PDDiskOffline;	/* # physical disk devices offline */
	u16bits	cdi_MaxCmds;		/* max parallel commands supported */

					/* Channel and target ID information */
	u08bits	cdi_PhysChannels;	/* # physical channels present */
	u08bits	cdi_VirtualChannels;	/* # virtual channels present */
	u08bits	cdi_MaxPhysChannels;	/* # max physical channels possible */
	u08bits	cdi_MaxVirtualChannels;	/* # max virtual channels possible */

	u08bits	cdi_MaxTargets[16];	/* maximum targets per channel */
	u08bits	cdi_Reserved20[12];

					/* Memory/Cache information */
	u16bits	cdi_MemorySize;		/* Memory size in MB */
	u16bits	cdi_CacheSize;		/* Cache size in MB */
	u32bits	cdi_ValidCacheSize;	/* Valid cache size in bytes */
	u32bits	cdi_DirtyCacheSize;	/* Dirty cache size in bytes */
	u16bits	cdi_MemorySpeed;	/* memory speed in MHz */
	u08bits	cdi_MemoryWidth;	/* Memory data witdh in bits */
	u08bits	cdi_MemoryType;		/* Memory types, eg. ECC, DRAM, etc. */
	u08bits	cdi_MemoryName[16];	/* Memory type string */

					/* Execution Memory information */
	u16bits	cdi_ExecMemorySize;	/* Memory size in MB, =0 if no memory */
	u16bits	cdi_L2CacheSize;	/* L2 Cache size in KB */
	u32bits	cdi_Reserved21;
	u32bits	cdi_Reserved22;
	u16bits	cdi_ExecMemorySpeed;	/* memory speed in MHz */
	u08bits	cdi_ExecMemoryWidth;	/* Memory data witdh in bits */
	u08bits	cdi_ExecMemoryType;	/* Memory types, eg. ECC, DRAM, etc. */
	u08bits	cdi_ExecMemoryName[16];	/* Memory type string */

					/* First CPU type information */
	u16bits	cdi_CPUSpeed;		/* CPU speed in MHz */
	u08bits	cdi_CPUType;		/* CPU type, e.g. i960, Strong Arm */
	u08bits	cdi_CPUs;		/* # CPU present */
	u08bits	cdi_Reserved24[12];
	u08bits	cdi_CPUName[16];	/* CPU name */

					/* Second CPU type information */
	u16bits	cdi_SCPUSpeed;		/* CPU speed in MHz,=0 if CPU not present */
	u08bits	cdi_SCPUType;		/* CPU type, e.g. i960, Strong Arm */
	u08bits	cdi_SCPUs;		/* # CPU present */
	u08bits	cdi_Reserved25[12];
	u08bits	cdi_SCPUName[16];	/* CPU name */

					/* Debugging/profiling/command trace information */
	u16bits	cdi_ProfPageNo;		/* Profiler page number */
	u16bits	cdi_ProfWaiting;	/* # profiler program waiting */
	u16bits	cdi_ttPageNo;		/* time trace page number */
	u16bits	cdi_ttWaiting;		/* # time trace program waiting */
	u32bits	cdi_Reserved26;
	u32bits	cdi_Reserved27;

					/* Error counters on physical devices */
	u16bits	cdi_PDBusResetDone;	/* # bus reset done */
	u16bits	cdi_PDParityErrors;	/* # parity errors */
	u16bits	cdi_PDSoftErrors;	/* # soft errors */
	u16bits	cdi_PDCmdFailed;	/* # commands failed */
	u16bits	cdi_PDMiscErrors;	/* # Miscellaneous errors */
	u16bits	cdi_PDCmdTimeouts;	/* # command time outs */
	u16bits	cdi_PDSelectTimeouts;	/* # Selection time outs */
	u16bits	cdi_PDRetryDone;	/* # retries done */
	u16bits	cdi_PDAbortDone;	/* # command abort done */
	u16bits	cdi_PDHostAbortDone;	/* # hot coommand abort done */
	u16bits	cdi_PDPFADetected;	/* # PFA detected */
	u16bits	cdi_PDHostCmdFailed;	/* # host command failed */
	u32bits	cdi_Reserved30;
	u32bits	cdi_Reserved31;

					/* Error counters on logical devices */
	u16bits	cdi_LDSoftErrors;	/* # soft errors */
	u16bits	cdi_LDCmdFailed;	/* # command failed */
	u16bits	cdi_LDHostAbortDone;	/* # host command abort done */
	u16bits	cdi_Reserved32;

					/* Error counters on controller */
	u16bits	cdi_MemParityErrors;	/* # memory parity/ECC errors */
	u16bits	cdi_HostCmdAbortDone;	/* # host command abort done */
	u32bits	cdi_Reserved33;

					/* Long duration activity information */
	u16bits	cdi_BGIActive;		/* # Back ground initialization active */
	u16bits	cdi_LDInitActive;	/* # logical device init is active */
	u16bits	cdi_PDInitActive;	/* # physical device init is active */
	u16bits	cdi_CheckActive;	/* # consistency check active */
	u16bits	cdi_RebuildActive;	/* # rebuild active */
	u16bits	cdi_MOREActive;		/* # MORE active */
	u16bits	cdi_PatrolActive;	/* # Patrol active */
	u16bits	cdi_Reserved34;

					/* Flash Rom information */
	u08bits	cdi_FlashType;		/* flash type */
	u08bits	cdi_Reserved35;
	u16bits	cdi_FlashSize;		/* flash size in KB */
	u32bits	cdi_MaxFlashes;		/* maximum # flash possible */
	u32bits	cdi_Flashed;		/* # times flashed */
	u32bits	cdi_Reserved36;
	u08bits	cdi_FlashName[16];

					/* Firmware Run time information */
	u08bits	cdi_RebuildRate;	/* Rebuild rate */
	u08bits	cdi_BGIRate;		/* back ground init rate */
	u08bits	cdi_FGIRate;		/* foreground init rate */
	u08bits	cdi_CheckRate;		/* consistency check rate */
	u32bits	cdi_Reserved40;
	u32bits	cdi_MaxDP;
	u32bits	cdi_FreeDP;
	u32bits	cdi_MaxIOP;
	u32bits	cdi_FreeIOP;
	u16bits	cdi_MaxComb;		/* max comb length in 512 byte blocks */
	u16bits	cdi_ConfigGroups;	/* No. of configuration groups on the controller */
	u32bits	cdi_ControllerStatus;

	u08bits	cdi_Reserved50[32];

	u08bits	cdi_Reserved70[512];
} mdacfsi_ctldev_info_t;
#define	mdacfsi_ctldev_info_s	sizeof(mdacfsi_ctldev_info_t)


/* The logical / RAID device information is returned in the following format */
typedef struct mdacfsi_logdev_info
{
					/* The logical device is presented on
					** virtual channels, therefore the
					** channel, target, LUN corresponds to
					** that.
					*/
	u08bits	ldi_ControllerNo;	/* Controller number */
	u08bits	ldi_ChannelNo;		/* Channel number */
	u08bits	ldi_TargetID;		/* Target ID */
	u08bits	ldi_LunID;		/* LUN */
 
	u08bits	ldi_DevState;		/* Drive State */
	u08bits	ldi_RaidLevel;		/* Raid Level 0,1,3,5,6,7 */
	u08bits	ldi_StripeSize;		/* Stripe size coded value */
	u08bits	ldi_CacheLineSize;	/* Cache line size coded value */

	u08bits	ldi_RWControl;		/* Read/Write control flag */
	u08bits	ldi_OpStatus;		/* long-operation status bits */
	u08bits	ldi_RAID5Update;	/* ar5_limit */
	u08bits	ldi_RAID5Algorithm;	/* ar5_algo */

	u16bits	ldi_DevNo;		/* device number */
	u16bits	ldi_BiosGeometry;	/* 2gb/8gb setting */

					/* Error Counters */
	u16bits	ldi_SoftErrors;		/* # soft errors */
	u16bits	ldi_CmdFailed;		/* # command failed */
	u16bits	ldi_HostAbortDone;	/* # host command abort done */
	u16bits	ldi_DefWriteErrors;	/* Deffered write errors */
	u32bits	ldi_Reserved2;
	u32bits	ldi_Reserved3;
	
	u16bits	ldi_Reserved4;
	u16bits	ldi_BlockSize;		/* device block size in bytes */
	u32bits	ldi_OrgDevSize;		/* original device capacity in MB or blocks */
	u32bits	ldi_DevSize;		/* device capacity in MB or blocks */
	u32bits	ldi_Reserved5;

	u08bits	ldi_DevName[32];	/* device name */

	u08bits	ldi_SCSIInquiry[36];	/* First 36 bytes of SCSI inquiry */
	u32bits	ldi_Reserved6;
	u32bits	ldi_Reserved7;
	u32bits	ldi_Reserved8;

	u64bits	ldi_LastReadBlkNo;	/* last read block number */
	u64bits	ldi_LastWrittenBlkNo;	/* Last Written block number */
	u64bits	ldi_CheckBlkNo;		/* Consistency check block number */
	u64bits	ldi_RebuildBlkNo;	/* Rebuild block number */
	u64bits	ldi_BGIBlkNo;		/* Backgound init block number */
	u64bits	ldi_InitBlkNo;		/* Init block number */
	u64bits	ldi_MigrationBlkNo;	/* Data migration block number */
	u64bits	ldi_PatrolBlkNo;	/* Patrol block number */

	u08bits	ldi_Reserved9[64];
} mdacfsi_logdev_info_t;

#define	mdacfsi_logdev_info_s	sizeof(mdacfsi_logdev_info_t)
#define	MDAC_LDI_CONSISTENCYCHECK_ON	0x01
#define	MDAC_LDI_REBUILD_ON		0x02
#define	MDAC_LDI_MAKEDATACONSISTENT_ON	0x04
#define	MDAC_LDI_LOGICALDEVICEINIT_ON	0x08
#define	MDAC_LDI_DATAMIGRATION_ON	0x10
#define	MDAC_LDI_PATROLOPERATION_ON	0x20

#if defined (_WIN64)|| (MLX_NT)
/* The physical device information is returned in the following format */
typedef struct mdacfsi_physdev_info
{
	u08bits	pdi_ControllerNo;	/* Controller number */
	u08bits	pdi_ChannelNo;		/* Channel number */
	u08bits	pdi_TargetID;		/* Target ID */
	u08bits	pdi_LunID;		/* LUN */

	u08bits	pdi_ConfStatus;		/* configuration status bits */
	u08bits	pdi_HostStatus;		/* multiple host status bits */
	u08bits	pdi_DevState;		/* physical device operating state */
	u08bits	pdi_DataWidth;		/* negotiated data width */
	u16bits	pdi_Speed;		/* negotiated speed in MHz */
	u08bits	pdi_Ports;		/* # port connection available */
	u08bits	pdi_PortAccess;		/* device is accessed on what port */

	u32bits	pdi_Reserved0;

	u08bits	pdi_MacAddr[16];	/* network address */

	u16bits	pdi_MaxTags;		/* maximum tags supported */
	u08bits	pdi_OpStatus;		/* long-operation status bits */
	u08bits	pdi_Reserved1;

					/* Error Counters */
	u08bits	pdi_ParityErrors;	/* # parity errors */
	u08bits	pdi_SoftErrors;		/* # soft errors */
	u08bits	pdi_HardErrors;		/* # hard errors */
	u08bits	pdi_MiscErrors;		/* # Miscellaneous errors */
	u08bits	pdi_TimeoutErrors;	/* # command time out errors */
	u08bits	pdi_Retries;		/* # retries done */
	u08bits	pdi_AbortDone;		/* # command abort done */
	u08bits	pdi_PFADetected;	/* # PFA detected */

	u08bits	pdi_SenseKey;
	u08bits	pdi_ASC;
	u08bits	pdi_ASCQ;
	u08bits	pdi_Reserved2;

	u16bits	pdi_Reserved3;
	u16bits	pdi_BlockSize;		/* device block size in bytes */
	u32bits	pdi_OrgDevSize;		/* original device capacity in MB or blocks */
	u32bits	pdi_DevSize;		/* device capacity in MB or blocks */
	u32bits	pdi_Reserved4;

	u08bits	pdi_DevName[16];	/* device name */
    u08bits	pdi_Reserved5[48];

	u08bits	pdi_SCSIInquiry[36];	/* First 36 bytes of SCSI inquiry */
	u32bits	pdi_Reserved6;
	u64bits	pdi_Reserved7;
	u08bits	pdi_Reserved8[16];

	u64bits	pdi_LastReadBlkNo;	/* last read block number */
	u64bits	pdi_LastWrittenBlkNo;	/* Last Written block number */
	u64bits	pdi_CheckBlkNo;		/* Consistency check block number */
	u64bits	pdi_RebuildBlkNo;	/* Rebuild block number */
	u64bits	pdi_BGIBlkNo;		/* Backgound init block number */
	u64bits	pdi_InitBlkNo;		/* Init block number */
	u64bits	pdi_MigrationBlkNo;	/* Data migration block number */
	u64bits	pdi_PatrolBlkNo;	/* Patrol block number */

	u08bits	pdi_Reserved9[256];
} mdacfsi_physdev_info_t;

#else

/* The physical device information is returned in the following format */
typedef struct mdacfsi_physdev_info
{
	u08bits	pdi_ControllerNo;	/* Controller number */
	u08bits	pdi_ChannelNo;		/* Channel number */
	u08bits	pdi_TargetID;		/* Target ID */
	u08bits	pdi_LunID;		/* LUN */

	u08bits	pdi_ConfStatus;		/* configuration status bits */
	u08bits	pdi_HostStatus;		/* multiple host status bits */
	u08bits	pdi_DevState;		/* physical device operating state */
	u08bits	pdi_DataWidth;		/* negotiated data width */
	u16bits	pdi_Speed;		/* negotiated speed in MHz */
	u08bits	pdi_Ports;		/* # port connection available */
	u08bits	pdi_PortAccess;		/* device is accessed on what port */

	u32bits	pdi_Reserved0;

	u08bits	pdi_MacAddr[16];	/* network address */

	u16bits	pdi_MaxTags;		/* maximum tags supported */
	u08bits	pdi_OpStatus;		/* long-operation status bits */
	u08bits	pdi_Reserved1;

					/* Error Counters */
	u08bits	pdi_ParityErrors;	/* # parity errors */
	u08bits	pdi_SoftErrors;		/* # soft errors */
	u08bits	pdi_HardErrors;		/* # hard errors */
	u08bits	pdi_MiscErrors;		/* # Miscellaneous errors */
	u08bits	pdi_TimeoutErrors;	/* # command time out errors */
	u08bits	pdi_Retries;		/* # retries done */
	u08bits	pdi_AbortDone;		/* # command abort done */
	u08bits	pdi_PFADetected;	/* # PFA detected */

	u08bits	pdi_SenseKey;
	u08bits	pdi_ASC;
	u08bits	pdi_ASCQ;
	u08bits	pdi_Reserved2;
	
	u08bits	pdi_MRIE;			/* MRIE mode */
	u08bits	pdi_Reserved3;
	u16bits	pdi_BlockSize;		/* device block size in bytes */
	u32bits	pdi_OrgDevSize;		/* original device capacity in MB or blocks */
	u32bits	pdi_DevSize;		/* device capacity in MB or blocks */
	u32bits	pdi_Reserved4;

	u08bits	pdi_DevName[16];	/* device name */
    u08bits	pdi_Reserved5[48];

	u08bits	pdi_SCSIInquiry[36];	/* First 36 bytes of SCSI inquiry */
	u32bits	pdi_Reserved6;
	u64bits	pdi_Reserved7;
	u08bits	pdi_Reserved8[16];

	u64bits	pdi_LastReadBlkNo;	/* last read block number */
	u64bits	pdi_LastWrittenBlkNo;	/* Last Written block number */
	u64bits	pdi_CheckBlkNo;		/* Consistency check block number */
	u64bits	pdi_RebuildBlkNo;	/* Rebuild block number */
	u64bits	pdi_BGIBlkNo;		/* Backgound init block number */
	u64bits	pdi_InitBlkNo;		/* Init block number */
	u64bits	pdi_MigrationBlkNo;	/* Data migration block number */
	u64bits	pdi_PatrolBlkNo;	/* Patrol block number */

	u08bits	pdi_Reserved9[256];
} mdacfsi_physdev_info_t;
#endif

#define	mdacfsi_physdev_info_s	sizeof(mdacfsi_physdev_info_t)

#define	MDAC_PDI_CONSISTENCYCHECK_ON	0x01
#define	MDAC_PDI_REBUILD_ON				0x02
#define	MDAC_PDI_MAKEDATACONSISTENT_ON	0x04
#define	MDAC_PDI_PHYSICALDEVICEINIT_ON	0x08
#define	MDAC_PDI_DATAMIGRATION_ON		0x10
#define	MDAC_PDI_PATROLOPERATION_ON		0x20

/* The logical / RAID device statistics is returned in the following format */
typedef struct mdacfsi_logdev_stats
{
	u32bits	lds_Time;		/* number of milli second from start */
	u32bits	lds_Reserved0;
	u08bits	lds_ControllerNo;	/* Controller number */
	u08bits	lds_ChannelNo;		/* Channel number */
	u08bits	lds_TargetID;		/* Target ID */
	u08bits	lds_LunID;		/* LUN */
	u16bits	lds_DevNo;		/* device number */
	u16bits	lds_Reserved1;

					/* Total real/write performance data */
	u32bits	lds_Read;		/* # read done */
	u32bits	lds_Write;		/* # write done */
	u32bits	lds_ReadKB;		/* amount of data read in KB */
	u32bits	lds_WriteKB;		/* amount of data written in KB */

					/* Cache read/write performance data */
	u32bits	lds_CacheRead;		/* # cached read done */
	u32bits	lds_CacheWrite;		/* # cached write done */
	u32bits	lds_CacheReadKB;	/* amount of cached data read in KB */
	u32bits	lds_CacheWriteKB;	/* amount of cached data written in KB */

					/* commands active/wait information */
	u32bits	lds_CmdsWaited;		/* # commands waited */
	u16bits	lds_CmdsActive;		/* # commands active on device */
	u16bits	lds_CmdsWaiting;	/* # commands waiting to go on device */
	u32bits	lds_Reserved10;
	u32bits	lds_Reserved11;
} mdacfsi_logdev_stats_t;
#define	mdacfsi_logdev_stats_s	sizeof(mdacfsi_logdev_stats_t)


/* The physical device statistics is returned in the following format */
typedef struct mdacfsi_physdev_stats
{
	u32bits	pds_Time;		/* number of milli second from start */
	u32bits	pds_Reserved0;
	u08bits	pds_ControllerNo;	/* Controller number */
	u08bits	pds_ChannelNo;		/* Channel number */
	u08bits	pds_TargetID;		/* Target ID */
	u08bits	pds_LunID;		/* LUN */
	u32bits	pds_Reserved1;

					/* Total real/write performance data */
	u32bits	pds_Read;		/* # read done */
	u32bits	pds_Write;		/* # write done */
	u32bits	pds_ReadKB;		/* amount of data read in KB */
	u32bits	pds_WriteKB;		/* amount of data written in KB */

					/* Cache read/write performance data */
	u32bits	pds_CacheRead;		/* # cached read done */
	u32bits	pds_CacheWrite;		/* # cached write done */
	u32bits	pds_CacheReadKB;	/* amount of cached data read in KB */
	u32bits	pds_CacheWriteKB;	/* amount of cached data written in KB */

					/* commands active/wait information */
	u32bits	pds_CmdsWaited;		/* # commands waited */
	u16bits	pds_CmdsActive;		/* # commands active on device */
	u16bits	pds_CmdsWaiting;	/* # commands waiting to go on device */
	u32bits	pds_Reserved10;
	u32bits	pds_Reserved11;
} mdacfsi_physdev_stats_t;
#define	mdacfsi_physdev_stats_s	sizeof(mdacfsi_physdev_stats_t)

/* The controller statistics is returned in the following format */
typedef struct mdacfsi_ctldev_stats
{
	u32bits	cds_Time;		/* number of milli second from start */
	u32bits	cds_Reserved0;
	u08bits	cds_ControllerNo;	/* Controller number */
	u08bits	cds_Reserved1;
	u16bits	cds_Reserved2;
	u32bits	cds_Reserved4;

					/* Target physical device performance */
	u32bits	cds_TPDIntrsDone;	/* # interrupts done */
	u32bits	cds_TPDIntrsDoneSpurious;/* # interrupts done spurious */
	u64bits	cds_Reserved5;

	u32bits	cds_TPDRead;		/* # read done */
	u32bits	cds_TPDWrite;		/* # write done */
	u32bits	cds_TPDReadKB;		/* amount of data read in KB */
	u32bits	cds_TPDWriteKB;		/* amount of data written in KB */

					/* Host system performance data */
	u32bits	cds_HostIntrsRxd;	/* # interrupts received from host */
	u32bits	cds_HostIntrsRxdSpurious;/* # spurious interrupts received from host */
	u32bits	cds_HostIntrsTxd;	/* # host interrupts generated */
	u32bits	cds_Reserved6;

					/* host accessing physical device */
	u32bits	cds_HPDRead;		/* # read done */
	u32bits	cds_HPDWrite;		/* # write done */
	u32bits	cds_HPDReadKB;		/* amount of data read in KB */
	u32bits	cds_HPDWriteKB;		/* amount of data written in KB */

					/* physical device cached IO */
	u32bits	cds_PDCacheRead;	/* # read done */
	u32bits	cds_PDCacheWrite;	/* # write done */
	u32bits	cds_PDCacheReadKB;	/* amount of data read in KB */
	u32bits	cds_PDCacheWriteKB;	/* amount of data written in KB */

					/* host accessing logical device */
	u32bits	cds_LDRead;		/* # read done */
	u32bits	cds_LDWrite;		/* # write done */
	u32bits	cds_LDReadKB;		/* amount of data read in KB */
	u32bits	cds_LDWriteKB;		/* amount of data written in KB */

					/* logical device cached IO */
	u32bits	cds_LDCacheRead;	/* # read done */
	u32bits	cds_LDCacheWrite;	/* # write done */
	u32bits	cds_LDCacheReadKB;	/* amount of data read in KB */
	u32bits	cds_LDCacheWriteKB;	/* amount of data written in KB */

	u16bits	cds_TPDCmdsActive;	/* # Physical device cmd active */
	u16bits	cds_TPDCmdsWaiting;	/* # physical device cmd waiting */
	u16bits cds_HostCmdsActive;	/* # Host commands active */
	u16bits	cds_HostCmdsWaiting;	/* # Host commands waiting */
	u64bits	cds_Reserved10;

	u08bits	cds_Reserved11[48];

	u08bits	cds_Reserved12[64];
} mdacfsi_ctldev_stats_t;
#define	mdacfsi_ctldev_stats_s	sizeof(mdacfsi_ctldev_stats_t)


/* The Physical Device Definition (PDD) for configuration */
typedef struct mdacfsi_physdev_definition
{
	u08bits	pdd_DevType;		/* device type, 0x0F */
	u08bits	pdd_DevState;		/* state of the device */
	u16bits	pdd_DevNo;		/* RAID device number */

	u32bits	pdd_DevSize;		/* device size in blocks or MB */
	u08bits	pdd_ControllerNo;	/* Controller number */
	u08bits	pdd_ChannelNo;		/* Channel number */
	u08bits	pdd_TargetID;		/* Target ID */
	u08bits	pdd_LunID;		/* LUN */

	u32bits	pdd_DevStartAddr;	/* device start address in blocks or MB */
} mdacfsi_physdev_definition_t;
#define	mdacfsi_physdev_definition_s	sizeof(mdacfsi_physdev_definition_t)


/* The RAID Device Use Definition (RDUD) for configuration */
typedef struct mdacfsi_raiddevuse_definition
{
	u08bits	rdud_Reserved0;
	u08bits	rdud_DevState;		/* state of the RAID device */
	u16bits	rdud_DevNo;		/* RAID device number */
	u32bits	rdud_DevStartAddr;	/* RAID device start address in blocks or MB */
} mdacfsi_raiddevuse_definition_t;
#define	mdacfsi_raiddevuse_definition_s	sizeof(mdacfsi_raiddevuse_definition_t)

/* The RAID Device Definition (RDD) for configuration */
typedef struct mdacfsi_raiddev_definition
{
	u08bits	rdd_DevType;		/* device type, RAID5, RAID0, etc. */
	u08bits	rdd_DevState;		/* state of the RAID device */
	u16bits	rdd_DevNo;		/* RAID device number */

	u32bits	rdd_DevSize;		/* device size in blocks or MB */

	u08bits	rdd_DevUsed;		/* # RAID devices used to create this RAID device */
	u08bits	rdd_StripeSize;		/* Stripe Size */
	u08bits	rdd_CacheLineSize;	/* Cache Line Size */
	u08bits	rdd_RWControl;		/* Read/Write control */

	u32bits	rdd_UsedDevSize;	/* Used device size in blocks or MB */

	mdacfsi_raiddevuse_definition_t	rdd_UsedDevs[1];	/* used device table */
} mdacfsi_raiddev_definition_t;
#define	mdacfsi_raiddev_definition_s	(sizeof(mdacfsi_raiddev_definition_t) - mdacfsi_raiddevuse_definition_s)


/* One free space reporting format */
typedef struct mdacfsi_raiddev_freespace
{
	u16bits	rdfs_DevNo;	/* RAID device number */
	u16bits	rdfs_Reserved0;
	u32bits	rdfs_Reserved1;
	u32bits	rdfs_StartAddr;	/* free space start address in blocks or MB */
	u32bits	rdfs_Size;	/* free space size in blocks or MB */
} mdacfsi_raiddev_freespace_t;
#define	mdacfsi_raiddev_freespace_s	sizeof(mdacfsi_raiddev_freespace_t)


/* The free space list reporting format */
typedef struct mdacfsi_raiddev_freespacelist
{
	u16bits	rdfsl_Len;	/* # of entries present in the table */
	u16bits	rdfsl_Reserved0;
	u32bits	rdfsl_Reserved1;
	u64bits	rdfsl_Reserved2;
	mdacfsi_raiddev_freespace_t	rdfsl_FreeSpaceList[1];	/* free space list */
} mdacfsi_raiddev_freespacelist_t;
#define	mdacfsi_raiddev_freespacelist_s	(sizeof(mdacfsi_raiddev_freespacelist_t) - mdacfsi_raiddev_freespace_s)


/* The request sense information */
typedef struct mdacfsi_reqsense_info
{
	u32bits	rsi_EventSeqNo;		/* Event Sequence Number */
	u32bits	rsi_EventTime;		/* Time Stamp for this request sense */

	u08bits	rsi_ControllerNo;	/* Controller Number of the event */
	u08bits	rsi_ChannelNo;		/* Channel number of the evet */
	u08bits	rsi_TargetID;		/* Target ID of event */
	u08bits	rsi_LunID;		/* Logical unit of event */

	u32bits	rsi_Reserved0;

	u08bits	rsi_ReqSense[48];	/* actual request sense data */
} mdacfsi_reqsense_info_t;
#define	mdacfsi_reqsense_info_s	sizeof(mdacfsi_reqsense_info_t)


/* The event information */
typedef struct mdacfsi_event_info
{
	u32bits	evi_EventSeqNo;		/* Event Sequence Number */
	u32bits	evi_EventTime;		/* Time Stamp for this event */
	u32bits	evi_EventCode;		/* Event Code value */

	u08bits	evi_ControllerNo;	/* Controller Number of the event */
	u08bits	evi_ChannelNo;		/* Channel number of the evet */
	u08bits	evi_TargetID;		/* Target ID of event */
	u08bits	evi_LunID;		/* Logical unit of event */

	u32bits	evi_Reserved0;
	u32bits	evi_SpecInfo;		/* Event Specific information */
        u08bits evi_ReqSense[40];       /* New API sense data */
} mdacfsi_event_info_t;
#define	mdacfsi_event_info_s	sizeof(mdacfsi_event_info_t)


/* The health status information */
typedef struct mdacfsi_healthstatus
{
	u32bits	hs_Timeus;		/* # micro second since start */
	u32bits	hs_Timems;		/* # mili second since start */
	u32bits	hs_Time;		/* # seconds since Jan 1, 1970 */
	u32bits	hs_TimeReserved;	/* reserved for time extension */

	u32bits	hs_StatusChanges;	/* # status have changed */
	u32bits	hs_ReqSenseNo;		/* Request sense event number */
	u32bits	hs_DebugOutMsgInx;	/* debug output message index */
	u32bits	hs_CodedMsgInx;		/* coded message output index */

	u32bits	hs_ttPageNo;		/* current time trace page number */
	u32bits	hs_ProfPageNo;		/* current profiler page number */
	u32bits	hs_EventSeqNo;		/* Event Sequence Number */
	u32bits	hs_Reserved0;

	u08bits	hs_Reserved1[16];

	u08bits	hs_Reserved2[64];
} mdacfsi_healthstatus_t;
#define	mdacfsi_healthstatus_s	sizeof(mdacfsi_healthstatus_t)

/* PhysDev Parameter information */
typedef struct mdacfsi_physdev_parameters
{
	u16bits	pdp_Tag;		/* Current Tag Value */
	u16bits	pdp_TransferSpeed;	/* Current transfer speed in MHz (negotiated) */
	u08bits	pdp_TransferWidth;	/* Current transfer width size in bits(negotiated)*/
	u08bits	pdp_Reserved0[3];
	u08bits	pdp_Reserved1[8];
} mdacfsi_physdev_parameters_t;
#define	mdacfsi_physdev_parameters_s	sizeof(mdacfsi_physdev_parameters_t)

/* LogDev Parameter information */
/* mdacfsi_logdev_parameter:ldp_BiosGeometry definition */
#define LDP_BIOSGEOMETRY_MASK 0x60
#define LDP_BIOSGEOMETRY_2GB 0x00
#define LDP_BIOSGEOMETRY_8GB 0x20

typedef struct mdacfsi_logdev_parameter
{
	u08bits	ldp_DevType;		/* Device type */
	u08bits	ldp_DevState;		/* Device state */
	u16bits	ldp_DevNo;			/* Raid device no.*/

	u08bits	ldp_RaidControl;	/* Raid control. b7 0x00: Right asymmetric(default), 0x80:left symmetric. b6-0: reserved*/ 
	u08bits	ldp_BiosGeometry;	/* 2GB or 8 GB geometry. */
	u08bits	ldp_StripeSize;		/* Stripe size */
	u08bits	ldp_RWControl;		/* Read/write control */

	u08bits ldp_Reserved[8];
} mdacfsi_logdev_parameter_t;
#define	mdacfsi_logdev_parameter_s	sizeof(mdacfsi_logdev_parameter_t)


/* CONTROLLER_CONFIGURATION:FirmwareControl definition */
#define CP_READ_AHEAD_ENABLE           0x00000001
#define CP_BIOS_LOW_DELAY              0x00000002
#define CP_FUA_ENABLE                  0x00000004
#define CP_REASSIGN_1_SECTOR           0x00000008
#define CP_TRUE_VERIFY                 0x00000010
#define CP_DISK_WRITE_THRU_VERIFY      0x00000020
#define CP_ENALE_BGINIT                0x00000040
#define CP_ENABLE_CLUSTERING           0x00000080
#define CP_BIOS_DISABLE                0x00000100
#define CP_BOOT_FROM_CDROM             0x00000200
#define CP_DRIVE_SIZING_ENABLE         0x00000400
#define CP_WRITE_SAME_ENABLE           0x00000800
#define CP_BIOSGEOMETRY_MASK		0x00006000
#define CP_BIOSGEOMETRY_2GB			0x00000000
#define CP_BIOSGEOMETRY_8GB			0x00002000
#define CP_TEMP_OFFLINE_ENABLE		0x00100000
#define CP_PATROL_READ_ENABLE		0x00200000
#define CP_SMART_ENABLE				0x00400000


/* CONTROLLER_CONFIGURATION:FaultManagement definition */
#define CP_STORAGE_WORKS_ENABLE        0x01
#define CP_SAFTE_ENABLE                0x02
#define CP_SES_ENABLE                  0x04
#define CP_ARM_ENABLE                  0x20
#define CP_OFM_ENABLE                  0x40

/* CONTROLLER_CONFIGURATION:OEMCode definition */
#define CP_OEM_MLX0                    0x00
#define CP_OEM_IBM                     0x08
#define CP_OEM_HP                      0x0a
#define CP_OEM_DEC                     0x0c
#define CP_OEM_INTEL                   0x10

/* CONTROLLER_CONFIGURATION:DiskStartupMode definition */
#define CP_AUTOSPIN     0   /* issue starts to all devices automatically */
#define CP_PWRSPIN      1   /* devices spin on power */
#define CP_WSSUSPIN     2   /* await system ssu, then start devices */

/* CONTROLLER_CONFIGURATION:StartupOption definition */
#define CP_STARTUP_IF_NO_CHANGE        0x00
#define CP_STARTUP_IF_NO_LUN_CHANGE    0x01
#define CP_STARTUP_IF_NO_LUN_OFFLINE   0x02
#define CP_STARTUP_IF_LUN0_NO_CHANGE   0x03
#define CP_STARTUP_IF_LUN0_NOT_OFFLINE 0x04
#define CP_STARTUP_ALWAYS              0x05

#define CP_NUM_OF_HOST_PORTS           2
#define CP_HARD_LOOP_ID_SIZE           2
#define CP_CONTROLLER_SERIALNO_SIZE    16
#if defined (_WIN64) || (MLX_NT)
typedef struct mdacfsi_ctldev_parameter
{
    u32bits cdp_FirmwareControl;

	u08bits cdp_FaultManagement;
    u08bits cdp_BackgroundTaskRate;
    u08bits cdp_CacheLineSize;
    u08bits cdp_OEMCode;

    u08bits cdp_DiskStartupMode;
    u08bits cdp_Devices2Spin;
    u08bits cdp_StartDelay1;
    u08bits cdp_StartDelay2;

    u08bits cdp_ExproControl1;
    u08bits cdp_FTPOControl;
    u08bits cdp_ExproControl2;
    u08bits cdp_Reserved0;

    u08bits cdp_SerialPortBaudRate;
    u08bits cdp_SerialControl;
    u08bits cdp_DeveloperFlag;
    u08bits cdp_FiberControl;

    u08bits cdp_MasterSlaveControl1;
    u08bits cdp_MasterSlaveControl2;
    u08bits cdp_MasterSlaveControl3;
    u08bits cdp_Reserved1;

    u08bits cdp_HardLoopId[CP_NUM_OF_HOST_PORTS][CP_HARD_LOOP_ID_SIZE];

    u08bits cdp_CtrlName[CP_NUM_OF_HOST_PORTS][CP_CONTROLLER_SERIALNO_SIZE+1];
    u08bits cdp_Reserved2[2];

    u08bits cdp_InitiatorId;
    u08bits cdp_StartupOption;
    u08bits cdp_DebugDumpEnable;
    u08bits cdp_SmartPollingInterval;

    u08bits cdp_BkgPtrlNoOfParallelChns;
    u08bits cdp_BkgPtrlNoOfParallelTgts;
    u08bits cdp_BkgPtrlBufferSize;
    u08bits cdp_BkgPtrlHaltOnNoOfIOs;

    u08bits cdp_BkgPtrlExecInterval;
    u08bits cdp_BkgPtrlExecDelay;
    u08bits cdp_Reserved3[2];

    u08bits cdp_Reserved4[60];
} mdacfsi_ctldev_parameter_t;

#else
typedef struct mdacfsi_ctldev_parameter
{
    u32bits cdp_FirmwareControl;

	u08bits cdp_FaultManagement;
    u08bits cdp_BackgroundTaskRate;
    u08bits cdp_CacheLineSize;
    u08bits cdp_OEMCode;

    u08bits cdp_DiskStartupMode;
    u08bits cdp_Devices2Spin;
    u08bits cdp_StartDelay1;
    u08bits cdp_StartDelay2;

    u08bits cdp_ExproControl1;
    u08bits cdp_FTPOControl;
    u08bits cdp_ExproControl2;
    u08bits cdp_Reserved0;

    u08bits cdp_SerialPortBaudRate;
    u08bits cdp_SerialControl;
    u08bits cdp_DeveloperFlag;
    u08bits cdp_FiberControl;

    u08bits cdp_MasterSlaveControl1;
    u08bits cdp_MasterSlaveControl2;
    u08bits cdp_MasterSlaveControl3;
    u08bits cdp_Reserved1;

    u08bits cdp_HardLoopId[CP_NUM_OF_HOST_PORTS][CP_HARD_LOOP_ID_SIZE];

    u08bits cdp_CtrlName[CP_NUM_OF_HOST_PORTS][CP_CONTROLLER_SERIALNO_SIZE+1];
    u08bits cdp_Reserved2[2];

    u08bits cdp_InitiatorId;
    u08bits cdp_StartupOption;
    u08bits cdp_DebugDumpEnable;
    u08bits cdp_SmartPollingInterval;

    u08bits cdp_BkgPtrlNoOfParallelChns;
    u08bits cdp_BkgPtrlNoOfParallelTgts;
    u08bits cdp_BkgPtrlBufferSize;
    u08bits cdp_BkgPtrlHaltOnNoOfIOs;

    u08bits cdp_BkgPtrlExecInterval;
    u08bits cdp_BkgPtrlExecDelay;
    u08bits cdp_Reserved3[2];

    u08bits cdp_Reserved4[52];
} mdacfsi_ctldev_parameter_t;
#endif
#define mdacfsi_ctldev_parameter_s sizeof(mdacfsi_ctldev_parameter_t)

/* Patrol Read status */
typedef struct mdacfsi_ptrl_status
{
    u16bits ptrl_Iterations;
    u16bits ptrl_LogDevNo;
    u08bits ptrl_PercentCompleted;
    u08bits ptrl_Reserved0;
    u16bits ptrl_PhysDevsInProcess;
} mdacfsi_ptrl_status_t;
#define mdacfsi_ptrl_status_s sizeof(mdacfsi_ptrl_status_t)

/*NVRAM event log related data structures*/
typedef struct mdacfsi_NVRAM_event_info
{
    u32bits nei_MaxEntries;
    u32bits nei_EntriesInUse;
    u32bits nei_FirstEntrySeqNo;
    u32bits nei_LastEntrySeqNo;
} mdacfsi_NVRAM_event_info_t;
#define mdacfsi_NVRAM_event_info_s sizeof(mdacfsi_NVRAM_event_info_t)

/*=====================NEW INTERFACE ENDS================================*/
#endif	/* _SYS_DAC960IF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\sys\drlapi.h ===
/*
**		Proprietary program material
**
** This material is proprietary to KAILASH and is not to be reproduced,
** used or disclosed except in accordance with a written license
** agreement with KAILASH.
**
** (C) Copyright 1990-1997 KAILASH.  All rights reserved.
**
** KAILASH believes that the material furnished herewith is accurate and
** reliable.  However, no responsibility, financial or otherwise, can be
** accepted for any consequences arising out of the use of this material.
*/


#ifndef _SYS_DRLAPI_H
#define _SYS_DRLAPI_H

#define	DRLEOF	(-1)

#ifndef	s08bits
#define	s08bits	char
#define	s16bits	short
#define	s32bits	int
#define	u08bits	unsigned s08bits
#define	u16bits	unsigned s16bits
#define	u32bits	unsigned s32bits
#define	S08BITS	s08bits
#define	S16BITS	s16bits
#define	S32BITS	s32bits
#define	U08BITS	u08bits
#define	U16BITS	u16bits
#define	U32BITS	u32bits
/* data structure to handle 64 bit values */
typedef struct
{
#ifdef	DRL_LITTLENDIAN
#define	DRLENDIAN_TYPE		0x00
	u32bits	bit31_0;		/* bits 00-31 */
	u32bits	bit63_32;		/* bits 32-63 */
#else	/* DRL_BIGENDIAN */
#define	DRLENDIAN_TYPE		0x01
	u32bits	bit63_32;		/* bits 63-32 */
	u32bits	bit31_0;		/* bits 31-0 */
#endif	/* DRL_LITTLENDIAN || DRL_BIGENDIAN */
} u64bits;
#define	u64bits_s	sizeof(u64bits)

/* macros to compare 64 bits values, 1 if contition is true else 0 */
#define	u64bitseq(sp,dp) /* check if source is equal to destination */ \
	(((sp.bit63_32==dp.bit63_32) && (sp.bit31_0==dp.bit31_0))? 1 : 0)
#define	u64bitsgt(sp,dp) /* check if source is greater than destination */\
	((sp.bit63_32>dp.bit63_32)? 1 : \
	((sp.bit63_32<dp.bit63_32)? 0 : \
	((sp.bit31_0>dp.bit31_0)? 1 : 0)))
#define	u64bitslt(sp,dp) /* check if source is less than destination */ \
	((sp.bit63_32<dp.bit63_32)? 1 : \
	((sp.bit63_32>dp.bit63_32)? 0 : \
	((sp.bit31_0<dp.bit31_0)? 1 : 0)))

#endif	/* s08bits */
#define	DRLFAR

/* device number will be as follows for MDAC driver.
** bit 31..24	Controller Number.
** bit 23..16	Channel number.
**		Channel number is 0 for logical drive access.
**		Channel number + 0x80 for SCSI device access.
** bit 15..8	Target number.
** bit  7..0	Lun Number/Logical device number.
*/
#define	drl_mdacdev(ctl,ch,tgt,lun) (((ctl)<<24)+((ch)<<16)+((tgt)<<8)+(lun))
#define	drl_ctl(dev)	(((dev)>>24)&0xFF)
#define	drl_ch(dev)	(((dev)>>16)&0xFF)
#define	drl_chno(dev)	(((dev)>>16)&0x3F)
#define	drl_tgt(dev)	(((dev)>>8 )&0xFF)
#define	drl_lun(dev)	(((dev)    )&0xFF)
#define	drl_sysdev(dev)	(((dev)    )&0xFF)
#define	drl_isscsidev(dev) ((dev) & 0x00800000)	/* check channel no */
#define	drl_isosinterface(dev) ((dev) & 0x00400000)	/* if OS interface */

#define	DRL_WS		4	/* machine word size */
#define	DRL_DEV_BSIZE	512
#define	DRLMAX_CPUS	32	/* must be 2**n format */
#define	DRLMAX_EVENT	1024	/* max event trace buffer, must be 2**n */
#define	DRLMAX_MP	32	/* maximum master process allowed */
#define	DRLMAX_BDEVS	16	/* parallel 16 devices are allowed */
#define	DRLMAX_RWTEST	128	/* maximum read/write test monitored */
#define	DRLMAX_COPYCMP	128	/* maximum copy/compare monitored */

/* convert bytes to block and block to bytes */
#define	drl_btodb(sz)		((sz)/DRL_DEV_BSIZE)
#define	drl_dbtob(bc)		((bc)*DRL_DEV_BSIZE)
#define	drl_alignsize(sz)	drl_dbtob(drl_btodb((sz)+DRL_DEV_BSIZE-1))
#define	drl_blk2mb(blk)		((blk)/2048)	/* convert blocks to MB */

/* get the difference of two clock counts. The clock value comes from
** PIT2 and it counts from 0xFFFF to 0.
*/
#define	drlclkdiff(nclk,oclk) (((nclk)>(oclk))? (0x10000-(nclk)+(oclk)):((oclk)-(nclk)))
#define	DRLHZ		100		/* assume all OS run at 100 ticks/second */
#define	DRLKHZ		1000		/* not binary number 1024 */
#define	DRLMHZ		(DRLKHZ * DRLKHZ)
#define	DRLCLKFREQ	1193180		/* clock frequency fed to PIT */
#define	DRLUSEC(clk)	(((clk)*DRLMHZ)/DRLCLKFREQ)

/* different information about page */
#define	DRLPAGESIZE	0x1000
#define	DRLPAGESHIFT	12
#define	DRLPAGEOFFSET	(DRLPAGESIZE - 1)
#define	DRLPAGEMASK	(~DRLPAGEOFFSET)

#ifdef	SVR40
#define	NBITSMINOR	18
#elif	DRL_AIX
#define	NBITSMINOR	16
#else
#define	NBITSMINOR	8
#endif	/* SVR40 */

/* MACROS to manupulate bits in u32bits arrays. */
#define	BITINDEX(POS)	(POS >> 5)		/* get index in array */
#define	BITMASK(POS)	(1 << (POS & 0x1F))	/* get mask bit in 32 bit */
#define	TESTBIT(ADDR,POS)	(ADDR[BITINDEX(POS)] & BITMASK(POS))
#define	SETBIT(ADDR,POS)	 ADDR[BITINDEX(POS)] |= BITMASK(POS)
#define	RESETBIT(ADDR,POS)	 ADDR[BITINDEX(POS)] &= ~(BITMASK(POS))

/*
** datarel ioctls macros.
** IN  | I : copy in the data from user space to system space.
** OUT | O : copy out the data from system space to user space.
** IO	: IN and OUT.
** The fields which are not marked are assumed OUT i.e. data is copied
** from system space to user space.
**
** Ioctl's have the command encoded in the lower word, and the size of any
** IN or OUT parameters in the upper word.  The high 2 bits of the upper word
** are used to encode the IN/OUT status of the parameter; for now we restrict
** parameters to at most 511 bytes.
**
** The ioctl interface
** ioctl(file descriptor, ioctl command, command data structure address)
** If the returned value is non zero then there is OS ioctl error. If the return
** value is zero then spefic data structure may contain the error code.
**
** NOTE:
**	Every data structure should contain first 4 byte as error code.
*/
#define	DRLIOCPARM_SIZE	0x200	/* parameters must be less than 512 bytes */
#define	DRLIOCPARM_MASK		(DRLIOCPARM_SIZE -1)
#define	DRLIOCPARM_LEN(x)	(((u32bits)(x) >> 16) & DRLIOCPARM_MASK)
#define	DRLIOCBASECMD(x)	((x) & ~DRLIOCPARM_MASK)
#define	DRLIOCGROUP(x)		(((u32bits)(x) >> 8) & 0xFF)

#define	DRLIOC_NEWIOCTL	0x10000000 /* distinguish new ioctl's from old */
#define	DRLIOC_OUT	0x20000000 /* copy out data from kernel to user space */
#define	DRLIOC_IN	0x40000000 /* copy in  data from user to kernel space */
#define	DRLIOC_INOUT	(DRLIOC_IN|DRLIOC_OUT)
#define	DRLIOC_DIRMASK	(DRLIOC_INOUT)

#define	_DRLIOC(inout, group, num, len) \
	(inout | ((((u32bits)(len)) & DRLIOCPARM_MASK) << 16) \
	| ((group) << 8) | (num))
#define	_DRLIO(x,y)	_DRLIOC(DRLIOC_NEWIOCTL,x,y,0)
#define	_DRLIOR(x,y,t)	_DRLIOC(DRLIOC_OUT,x,y,sizeof(t))
#define	_DRLIORN(x,y,t)	_DRLIOC(DRLIOC_OUT,x,y,t)
#define	_DRLIOW(x,y,t)	_DRLIOC(DRLIOC_IN,x,y,sizeof(t))
#define	_DRLIOWN(x,y,t)	_DRLIOC(DRLIOC_IN,x,y,t)
#define	_DRLIOWR(x,y,t)	_DRLIOC(DRLIOC_INOUT,x,y,sizeof(t))

#define	DRLIOC	'D'

/* The time trace information is strored in the following format */
typedef struct drltimetrace
{
	u32bits	tt_iocnt;	/* frequency count */
	u64bits	tt_usecs;	/* total response time in usecs */
} drltimetrace_t;
#define	drltimetrace_s	sizeof(drltimetrace_t)

/* the above and below cutoff time values are stored in the following format */
typedef struct drlnxtimetrace
{
	u32bits	nxtt_iocnt;	/* frequency count */
	u64bits	nxtt_usecs;	/* total response time in usecs */
	u32bits	nxtt_reserved0;

	u32bits	nxtt_minusec;	/* minimum response time in usecs */
	u32bits	nxtt_maxusec;	/* maximum response time in usecs */
	u32bits	nxtt_reserved1;
	u32bits	nxtt_reserved2;
} drlnxtimetrace_t;
#define	drlnxtimetrace_s	sizeof(drlnxtimetrace_t)


/* different test ioctls */
#define	DRLIOC_STARTHWCLK	_DRLIOR(DRLIOC,0,drltime_t)/*start timer clock*/
#define DRLIOC_GETTIME		_DRLIOR(DRLIOC,1,drltime_t)/*get system's time*/
typedef	struct drltime
{
	u32bits	drltm_ErrorCode;	/* Non zero if data is not valid */
	u32bits	drltm_time;		/* time in seconds */
	u32bits	drltm_lbolt;		/* time in lbolts */
	u32bits	drltm_hwclk;		/* timer clock running at 1193180 Hz */

	u64bits	drltm_pclk;		/* processor clock counter */
	u32bits	drltm_Reserved10;	/* Reserved to make 16 byte alignment */
	u32bits	drltm_Reserved11;
} drltime_t;
#define	drltime_s	sizeof(drltime_t)

#define	DRLIOC_READTEST		_DRLIOWR(DRLIOC,2,drlrwtest_t) /*do read test */
#define	DRLIOC_WRITETEST	_DRLIOWR(DRLIOC,3,drlrwtest_t) /*do write test*/
#define	DRLIOC_GETSIGINFO	_DRLIOR(DRLIOC,4,drlrwtest_t) /*get signal stop info*/
typedef	struct drlrwtest
{
	u32bits	drlrw_ErrorCode;	/* Non zero if data is not valid */
	u32bits	drlrw_devcnt;		/* # test device */
	u32bits	drlrw_maxblksize;	/* test block size */
	u32bits	drlrw_iocount;		/* test io counts */

	u32bits	drlrw_memaddroff;	/* memory page offset */
	u32bits	drlrw_memaddrinc;	/* memory address increment */
	u32bits	drlrw_randx;		/* random number base */
	u32bits	drlrw_randlimit;	/* random number limit */

	u32bits	drlrw_randups;		/* random number duplicated */
	u32bits	*drlrw_eventcntp;	/* event trace count mem addr */
#define	DRLIO_EVENTRACE	0x4B61496C	/* value for event trace */
	u32bits	drlrw_eventrace;	/* specific value to event trace */
	u32bits	drlrw_eventcesr;	/* control and event select register */

	u32bits	drlrw_rwmixrandx;	/* read/write mix random base */
	u32bits	drlrw_rwmixcnt;		/* % of current ops (R/W) to be done */
	u32bits	drlrw_startblk;		/* start block number for test */
	u32bits	drlrw_minblksize;	/* test block size */

					/* followings are only return type */
	u32bits	drlrw_stime;		/* test start time in seconds */
	u32bits	drlrw_slbolt;		/* test start time in lbolts */
	u32bits	drlrw_etime;		/* test end   time in seconds */
	u32bits	drlrw_elbolt;		/* test end   time in lbolts */

	u64bits	drlrw_dtdone;		/* data transfered in bytes */
	u32bits	drlrw_diodone;		/* number of data io done */
	u32bits	drlrw_opstatus;		/* same as drlios_opstatus */

	u32bits	drlrw_oldsleepwakeup;	/* nonzero to use old sleepwakeup */
	u32bits	drlrw_kshsleepwakeup;	/* nonzero to use ksh sleepwakeup */
	u32bits	*drlrw_cpuruncntp;	/* run count of different cpus */
	drltimetrace_t *drlrw_ttp;	/* time trace mem addr */

	u32bits	drlrw_timetrace;	/* non zero if time tracing to be done*/
	u32bits	drlrw_ttgrtime;		/* time granular value */
	u32bits	drlrw_ttlotime;		/* low cutoff time */
	u32bits	drlrw_tthitime;		/* high cutoff time */

	u32bits	drlrw_pat;		/* starting pattern value */
	u32bits	drlrw_patinc;		/* pattern increment value */
	u32bits	drlrw_datacheck;	/* != 0 if data check required */
	u32bits	drlrw_miscnt;		/* mismatch count */

	u32bits	drlrw_goodpat;		/* good pattern value */
	u32bits	drlrw_badpat;		/* bad pattern value */
	u32bits	drlrw_uxblk;		/* unix block number where failed */
	u32bits	drlrw_uxblkoff;		/* byte offset in block */

	u32bits	drlrw_opflags;		/* operation flags */
	u32bits	drlrw_parallelios;	/* number of ios done in parallel */
#define	DRLRW_SIG	0x44695277
	u32bits	drlrw_signature;
	u32bits	drlrw_opcounts;		/* number of operations active */

	u32bits	drlrw_reads;		/* # reads done */
	u32bits	drlrw_writes;		/* # writes done */
	u32bits	drlrw_ioszrandx;	/* each IO size random base */
	u32bits	drlrw_ioinc;		/* io increment in bytes */

	u32bits	drlrw_bdevs[DRLMAX_BDEVS];/* all parallel devices */
	drlnxtimetrace_t drlrw_nxlo;	/* trace information below cutoff time*/
	drlnxtimetrace_t drlrw_nxhi;	/* trace information above cutoff time*/

} drlrwtest_t;
#define	drlrwtest_s	sizeof(drlrwtest_t)

/* datarel operation bits (drlrw_opflags,drlcp_opflags) */
#define	DRLOP_KDBENABLED 0x00000001/* kernel debugger enabled (do not change) */
#define	DRLOP_STOPENABLED 0x00000002/* stop enabled  (do not change) */
#define	DRLOP_ALLMIS	0x00000004 /* display all mismatch */
#define	DRLOP_VERBOSE	0x00000008 /* display data mismatch */
#define	DRLOP_DEBUG	0x00000010 /* display debug information */
#define	DRLOP_RANDTEST	0x00000020 /* random IO test to be done */
#define	DRLOP_SEEKTEST	0x00000040 /* do seek test */
#define	DRLOP_CACHETEST	0x00000080 /* do cached data test */
#define	DRLOP_WRITE	0x00000100 /* write the data before read */
#define	DRLOP_READ	0x00000200 /* read the data */
#define	DRLOP_VERIFY	0x00000400 /* verify data */
#define	DRLOP_SRCEXCL	0x00000800 /* open source device in execlusive mode */
#define	DRLOP_COPY	0x00001000 /* copy data */
#define	DRLOP_IPC	0x00002000 /* do IPC creation/deletion */
#define	DRLOP_MSG	0x00004000 /* do message send/receive operations */
#define	DRLOP_MSGOP	0x00008000 /* do message send/receive operations */
#define	DRLOP_SEM	0x00010000 /* do IPC semaphore creation/deletion */
#define	DRLOP_SEMOP	0x00020000 /* do IPC semop lock/unlock operations */
#define	DRLOP_SHM	0x00040000 /* do shared memory creation/deletion */
#define	DRLOP_SHMOP	0x00080000 /* do shared memory operations */
#define	DRLOP_PROTOCOL	0x00100000 /* test different protocols */
#define	DRLOP_MDACIO	0x00200000 /* test using mdac IO */
#define	DRLOP_RWMIXIO	0x00400000 /* test read/write mixed mode */
#define	DRLOP_RANDIOSZ	0x00800000 /* change every io sizes */ 
#define	DRLOP_CHECKIMD	0x01000000 /* check imediatly after write */
#define	DRLOP_RPCIOCTL	0x02000000 /* do remote procedure call for IOCTL */


#define	DRLIOC_STARTCPUSTATS	_DRLIOWR(DRLIOC,5,drlcpustart_t) /* start cpu statistics */
typedef	struct drlcpustart
{
	u32bits	drlcs_ErrorCode;	/* Non zero if data is not valid */
	u32bits	drlcs_cesr;
	u32bits	drlcs_Reserved10;	/* Reserved to make 16 byte alignment */
	u32bits	drlcs_Reserved11;
} drlcpustart_t;
#define	drlcpustart_s	sizeof(drlcpustart_t)

#define	DRLIOC_GETCPUSTATS	_DRLIOR(DRLIOC,6,drlcpustat_t) /* get cpu statistics */
typedef struct drlcpustat
{
	u32bits	cs_ErrorCode;	/* Non zero if data is not valid */
	u32bits	cs_Reserved;
	u64bits	cs_ctr0;	/* control counter 0 */
	u64bits	cs_ctr1;	/* control counter 1 */
	u64bits	cs_pclk;	/* processor clock counter */
} drlcpustat_t;
#define	drlcpustat_s	sizeof(drlcpustat_t)

#define	DRLIOC_CALLDEBUGR	_DRLIOWR(DRLIOC,7,drldbg_t) /* call kernel debugger */
typedef	struct drldbg
{
	u32bits	dbg_ErrorCode;	/* Non zero if data is not valid */
	u08bits DRLFAR *dbg_erraddr;/* address where errror occured */
	u32bits	dbg_goodata;	/* good data value */
	u32bits	dbg_badata;	/* bad data value */
} drldbg_t;
#define	drldbg_s	sizeof(drldbg_t)

#define	DRLIOC_PREPCONTEXTSW	_DRLIOWR(DRLIOC,8,drlcsw_t) /* prepare for context switch */
#define	DRLIOC_TESTCONTEXTSW	_DRLIOWR(DRLIOC,9,drlcsw_t) /* test context switch */
#define	DRLIOC_GETCONTEXTSWSIG	_DRLIOWR(DRLIOC,10,drlcsw_t) /* get context switch info after sig */
typedef	struct drlcsw
{
	u32bits	drlcsw_ErrorCode;	/* Non zero if data is not valid */
	u32bits	drlcsw_flags;		/* same as drlmp_flags */
	u32bits	drlcsw_procnt;		/* even # process for context switch */
	u32bits	drlcsw_mpid;		/* master process id */

	u32bits	drlcsw_cswcnt;		/* # context switch for a process */
	u32bits	drlcsw_cswdone;		/* # context switch done in all */
	u32bits	drlcsw_peekscswdone;	/* # cswdone at peek start time */
	u32bits	drlcsw_peekecswdone;	/* # cswdone at peek end   time */

	u32bits	drlcsw_forkstime;	/* fork  process start time in seconds*/
	u32bits	drlcsw_forkslbolt;	/* fork  process start time in lbolts */
	u32bits	drlcsw_forketime;	/* fork  process end   time in seconds*/
	u32bits	drlcsw_forkelbolt;	/* fork  process end   time in lbolts */

	u32bits	drlcsw_firststime;	/* first process start time in seconds*/
	u32bits	drlcsw_firstslbolt;	/* first process start time in lbolts */
	u32bits	drlcsw_laststime;	/* last  process start time in seconds*/
	u32bits	drlcsw_lastslbolt;	/* last  process start time in lbolts */

	u32bits	drlcsw_firstetime;	/* first process end   time in seconds*/
	u32bits	drlcsw_firstelbolt;	/* first process end   time in lbolts */
	u32bits	drlcsw_lastetime;	/* last  process end   time in seconds*/
	u32bits	drlcsw_lastelbolt;	/* last  process end   time in lbolts */

	u32bits	drlcsw_kshsleepwakeup;	/* non zero for ksh sleep/wakeup */
	u32bits	drlcsw_Reserved10;	/* Reserved to make 16 byte alignment */
	u32bits	drlcsw_Reserved11;
	u32bits	drlcsw_Reserved12;
} drlcsw_t;
#define	drlcsw_s	sizeof(drlcsw_t)

#define	DRLIOC_DOCONTEXTSW	_DRLIOWR(DRLIOC,11,drldocsw_t) /* do context switch */
typedef	struct drldocsw
{
	u32bits	drldocsw_ErrorCode;	/* Non zero if data is not valid */
	u32bits	drldocsw_mpid;		/* master process id */
	u32bits	drldocsw_opid;		/* our process id */
	u32bits	drldocsw_ppid;		/* partner process id */

	u32bits	drldocsw_stime;		/* test start time in seconds */
	u32bits	drldocsw_slbolt;	/* test start time in lbolts  */
	u32bits	drldocsw_etime;		/* test end   time in seconds */
	u32bits	drldocsw_elbolt;	/* test end   time in lbolts  */

	u32bits	drldocsw_cswdone;	/* # context switch done */
	u32bits	drldocsw_Reserved10;	/* Reserved to make 16 byte alignment */
	u32bits	drldocsw_Reserved11;
	u32bits	drldocsw_Reserved12;
} drldocsw_t;
#define	drldocsw_s	sizeof(drldocsw_t)

#define	DRLIOC_DATACOPY	_DRLIOWR(DRLIOC,12,drlcopy_t) /* data copy from disk to disk*/
#define	DRLIOC_DATACMP	_DRLIOWR(DRLIOC,13,drlcopy_t) /* data compare between disks */
#define	DRLIOC_SIGCOPY	_DRLIOR(DRLIOC,14,drlcopy_t) /* get data copy/compare info after sig */
#ifdef	MLXNET
#define	drl_buf_t	struct mdac_req
#else
#define	drl_buf_t	struct buf
#endif
typedef	struct drlcopy
{
	u32bits	drlcp_ErrorCode;	/* Non zero if data is not valid */
	u32bits	drlcp_srcedev;		/* source 32 bits device number */
	u32bits	drlcp_tgtedev;		/* target 32 bits device number */
	u32bits	drlcp_blksize;		/* copy block size in bytes */

	u32bits	drlcp_srcstartblk;	/* starting block number of source */
	u32bits	drlcp_tgtstartblk;	/* starting block number of target */
	u32bits	drlcp_opsizeblks;	/* operation size in blocks */
	u32bits	drlcp_nextblkno;	/* next block number for IOs */
					/* following informations returned */
	u32bits	drlcp_timelbolt;	/* time took to do operation in lbolt */
	u32bits	drlcp_blksperio;	/* per io size in blocks */
	u32bits	drlcp_opcounts;		/* number of operations pending */
	u32bits	drlcp_opstatus;		/* operation status */

	u32bits	drlcp_partiosdone;	/* number of partial ios done */
	u32bits	drlcp_mismatchcnt;	/* number of mismatch happened */
	u32bits	drlcp_firstmmblkno;	/* first mismatch block in unix blocks*/
	u32bits	drlcp_firstmmblkoff;	/* first mismatch byte offset in block*/

	u32bits	drlcp_reads;		/* # reads done */
	u32bits	drlcp_writes;		/* # writes done */
	u32bits	drlcp_srcdevsz;		/* source disk size in unix blocks */
	u32bits	drlcp_tgtdevsz;		/* target disk size in unix blocks */

	u32bits	drlcp_srcdtdone;	/* data transfered in unix blocks */
	u32bits	drlcp_tgtdtdone;	/* data transfered in unix blocks */
	s32bits	(*drlcp_srcstrategy)();	/* source disk driver strategy */
	s32bits	(*drlcp_tgtstrategy)();	/* target disk driver strategy */

	u32bits	drlcp_srcdev;		/* source 16 bits device number */
	u32bits	drlcp_tgtdev;		/* target 16 bits device number */
	drl_buf_t *drlcp_firstcmpbp;	/* first buf structure for compare */
	u32bits drlcp_reserved2;

	u32bits	drlcp_erredev;		/* device number of failed device */
	u32bits	drlcp_errblkno;		/* error block number in unix blocks */
	u32bits	drlcp_signature;	/* signature for structure */
#define	DRLCP_SIG	0x70434c44
	u32bits	drlcp_oslpchan;		/* operating system sleep channel */

	u32bits	drlcp_parallelios;	/* number of ios done in parallel */
	u32bits	drlcp_opflags;		/* operation flags */
	u32bits	drlcp_Reserved10;	/* Reserved to make 16 byte alignment */
	u32bits	drlcp_Reserved11;
} drlcopy_t;
#define	drlcopy_s	sizeof(drlcopy_t)

#define	DRLIOC_GETDEVSIZE	_DRLIOWR(DRLIOC,15,drldevsize_t) /* get disk size */
typedef struct drldevsize
{
	u32bits	drlds_ErrorCode;	/* Non zero if data is not valid */
	u32bits	drlds_bdev;		/* block device whose size to be found*/
	u32bits	drlds_devsize;		/* device size in blocks */
	u32bits	drlds_blocksize;	/* block size in bytes */
} drldevsize_t;
#define	drldevsize_s	sizeof(drldevsize_t)


/*
** Datarel Driver Version Number format
**
** drl_version_t dv;
** if (ioctl(gfd,DRLIOC_GETDRIVERVERSION,&dv) || dv.dv_ErrorCode)
**	return some_error;
*/
#define	DRLIOC_GETDRIVERVERSION	_DRLIOR(DRLIOC,16,drl_version_t)

/* The driver date information stored in the following format */
typedef struct drl_version
{
	u32bits	dv_ErrorCode;		/* Non zero if data is not valid */
	u08bits	dv_MajorVersion;	/* Driver Major version number */
	u08bits	dv_MinorVersion;	/* Driver Minor version number */
	u08bits	dv_InterimVersion;	/* interim revs A, B, C, etc. */
	u08bits	dv_VendorName;		/* vendor name */

	u08bits	dv_BuildMonth;		/* Driver Build Date - Month */
	u08bits	dv_BuildDate;		/* Driver Build Date - Date */
	u08bits	dv_BuildYearMS;		/* Driver Build Date - Year */
	u08bits	dv_BuildYearLS;		/* Driver Build Date - Year */

	u16bits	dv_BuildNo;		/* build number */
	u08bits	dv_OSType;		/* Operating system name */
	u08bits	dv_SysFlags;		/* System Flags */
} drl_version_t;
#define	drl_version_s	sizeof(drl_version_t)

/* The dv_SysFlags bits are */
#define	DRLDVSF_BIGENDIAN	0x01 /* bit0=0 little endian, =1 big endian cpu */

/*
** Datarel read/write test status/stop operation
**
** drl_rwteststatus drlrwst;
** To get the status of a perticular read/write test.
** drlrwst.drlrwst_TestNo = 0;
** if (ioctl(gfd,DRLIOC_GETRWTESTSTATUS,&drlrwst) || drlrwst.drlrwst_ErrorCode)
**	return some_error;
**
** To get the status of a current or next read/write test.
** drlrwst.drlrwst_TestNo = 0;
** if (ioctl(gfd,DRLIOC_GOODRWTESTSTATUS,&drlrwst) || drlrwst.drlrwst_ErrorCode)
**	return some_error;
**
** To stop a perticular read/write test.
** drlrwst.drlrwst_TestNo = 1;
** if (ioctl(gfd,DRLIOC_STOPRWTEST,&drlrwst) || drlrwst.drlrwst_ErrorCode)
**	return some_error;
*/
#define	DRLIOC_GETRWTESTSTATUS	_DRLIOWR(DRLIOC,17,drl_rwteststatus_t)
#define	DRLIOC_GOODRWTESTSTATUS	_DRLIOWR(DRLIOC,18,drl_rwteststatus_t)
#define	DRLIOC_STOPRWTEST	_DRLIOWR(DRLIOC,19,drl_rwteststatus_t)

/* The driver date information stored in the following format */
typedef struct drl_rwteststatus
{
	u32bits	drlrwst_ErrorCode;	/* Non zero if data is not valid */
	u16bits	drlrwst_TestNo;		/* TestNo number to be */
	u16bits	drlrwst_Reserved0;
	u32bits	drlrwst_Reserved1;
	u32bits	drlrwst_Reserved2;

	drlrwtest_t	drlrwst_rwtest;	/* read/write test state */
} drl_rwteststatus_t;
#define	drl_rwteststatus_s	sizeof(drl_rwteststatus_t)


/*
** Datarel copy/compare status/stop operation
**
** drl_copycmpstatus drlcpst;
** To get the status of a perticular copy/compare test.
** drlcpst.drlcpst_TestNo = 0;
** if (ioctl(gfd,DRLIOC_GETcopycmpSTATUS,&drlcpst) || drlcpst.drlcpst_ErrorCode)
**	return some_error;
**
** To get the status of a current or next copy/compare test.
** drlcpst.drlcpst_TestNo = 0;
** if (ioctl(gfd,DRLIOC_GOODcopycmpSTATUS,&drlcpst) || drlcpst.drlcpst_ErrorCode)
**	return some_error;
**
** To stop a perticular copy/compare test.
** drlcpst.drlcpst_TestNo = 1;
** if (ioctl(gfd,DRLIOC_STOPcopycmp,&drlcpst) || drlcpst.drlcpst_ErrorCode)
**	return some_error;
*/
#define	DRLIOC_GETCOPYCMPSTATUS		_DRLIOWR(DRLIOC,20,drl_copycmpstatus_t)
#define	DRLIOC_GOODCOPYCMPSTATUS	_DRLIOWR(DRLIOC,21,drl_copycmpstatus_t)
#define	DRLIOC_STOPCOPYCMP		_DRLIOWR(DRLIOC,22,drl_copycmpstatus_t)

/* The driver date information stored in the following format */
typedef struct drl_copycmpstatus
{
	u32bits	drlcpst_ErrorCode;	/* Non zero if data is not valid */
	u16bits	drlcpst_TestNo;		/* TestNo number */
	u16bits	drlcpst_Reserved0;
	u32bits	drlcpst_Reserved1;
	u32bits	drlcpst_Reserved2;

	drlcopy_t drlcpst_copycmp;	/* read/write test state */
} drl_copycmpstatus_t;
#define	drl_copycmpstatus_s	sizeof(drl_copycmpstatus_t)


#ifdef	DRL_SCO
#define	DRLMAX_BLKSIZE		0x10000	/* maximum block size allowed */
#else
#define	DRLMAX_BLKSIZE		0x80000	/* maximum block size allowed */
#endif	/* DRL_SCO */
#define	DRLMAX_PARALLELIOS	0x1000	/* maximum parallel ios allowed */
#define	DRLMAX_RANDLIMIT	((u32bits)0x80000000)

/* opstatus bits */
#define	DRLOPS_STOP	0x00000001	/* stop the operations now on */
#define	DRLOPS_SIGSTOP	0x00000002	/* stop due to signal */
#define	DRLOPS_ERR	0x00000004	/* some error has happened */
#define	DRLOPS_USERSTOP	0x00000008	/* stop due to user request */
#define	DRLOPS_ANYSTOP	(DRLOPS_STOP|DRLOPS_SIGSTOP|DRLOPS_ERR|DRLOPS_USERSTOP)

/* get physical device number from given unix block */
#define	uxblktodevno(iosp,uxblk) \
	(((uxblk) / iosp->drlios_maxblksperio) % iosp->drlios_devcnt)

/* get the unix block number in physical device area */
#define	pduxblk(iosp,uxblk) \
	((iosp->drlios_devcnt == 1)? uxblk : \
	(((uxblk)/iosp->drlios_maxcylszuxblk)*iosp->drlios_maxblksperio))

/* Performance Monitor Model Specific Registers */

#define EM_MSR_TSC		0x10	/* Time Stamp Counter */
#define EM_MSR_CESR		0x11	/* Control and Event Select */
#define EM_MSR_CTR0		0x12	/* Counter 0 */
#define EM_MSR_CTR1		0x13	/* Counter 1 */

/*
 * CESR Format:
 *
 *  332222 2 222 221111 111111 0 000 000000
 *  109876 5 432 109876 543210 9 876 543210
 * +------+-+---+------+------+-+---+------+
 * |      |P|   |      |      |P|   |      |
 * | rsvd |C|CC1| ES1  | rsvd |C|CC0| ES0  |
 * |      |1|   |      |      |0|   |      |
 * +------+-+---+------+------+-+---+------+
 *
 */

#define EM_ES0_MASK	0x0000003F
#define EM_CC0_MASK	0x000001C0
#define EM_PC0_MASK	0x00000200
#define EM_ES1_MASK	0x003F0000
#define EM_CC1_MASK	0x01C00000
#define EM_PC1_MASK	0x02000000

#define	EM_ES0(x)	((x)    &EM_ES0_MASK)
#define	EM_CC0(x)	((x<<6) &EM_CC0_MASK)
#define	EM_PC0(x)	((x<<9) &EM_PC0_MASK)
#define	EM_ES1(x)	((x<<16)&EM_ES1_MASK)
#define	EM_CC1(x)	((x<<22)&EM_CC1_MASK)
#define	EM_PC1(x)	((x<<25)&EM_PC1_MASK)

#define EM_CC0_ENABLED	0x000000C0
#define EM_CC1_ENABLED	0x00C00000
#define EM_CTR0_MASK	0x0000FFFF
#define EM_CTR1_MASK	0xFFFF0000

#ifdef	DRLASM
/*
**	This macro writes a model specific register of the Pentium processor.
**	Where reg is the model specific register number to write, val0 is the
**	data value bits 31..0 and val1 is the data value bits 63..32.
*/
asm	writemsr(reg,val0,val1)
{
%mem	reg,val0,val1;
	movl    reg, %ecx
	movl	val0, %eax
	movl	val1, %edx
	wrmsr
}

/*
**	This macro reads a model specific register of the Pentium processor.
**	Where reg is the model specific register number to read and valp is
**	the address where the 64 bit value from the register is written.
*/
asm	readmsr(reg,valp)
{
%mem	reg,valp;
	movl	reg, %ecx
	rdmsr
	movl    valp, %ecx
	movl	%eax, (%ecx)
	movl	%edx, 4(%ecx)
}

/*
**	This macro reads the time stamp counter of the Pentium processor.
**	The &valp is the address where the 64 bit value read is stored.
*/
asm	readtsc(valp)
{
%mem	valp;
	movl	valp, %ecx
	rdtsc
	movl	%eax, (%ecx)
	movl	%edx, 4(%ecx)
}

/* enable the hardware timer */
asm u32bits drlenablepit2()
{
	pushfl
	cli
	movl	$PITCTL_PORT, %edx
	movb	$0xB4, %al
	outb	(%dx)
	movl	$PITCTR2_PORT, %edx
	movb	$0xFF, %al
	outb	(%dx)
	outb	(%dx)
	movl	$PITAUX_PORT, %edx
	inb	(%dx)
	orb	$1, %al
	outb	(%dx)		/ enable the pit2 counter
	popfl
}

/* read the hardware timer */
#define	PIT_C2	0x80
asm u32bits drlreadhwclk()
{
	pushfl
	cli
	movl	$PITCTL_PORT, %edx
	movb	$PIT_C2, %al
	outb	(%dx)
	movl	$PITCTR2_PORT, %edx
	xorl	%eax, %eax
	inb	(%dx)
	movb	%al, %cl
	inb	(%dx)
	movb	%al, %ah
	movb	%cl, %al
	popfl
}

asm add8byte(dp,val)
{
%mem	dp,val;
	movl	dp, %ecx
	movl	val, %eax
	addl	%eax, (%ecx)
	adcl	$0, 4(%ecx)
}

asm add88byte(dp,sp)
{
%mem	dp,sp;
	movl	dp, %ecx
	movl	sp, %eax
	movl	4(%eax), %edx
	movl	(%eax), %eax
	addl	%eax, (%ecx)
	adcl	%edx, 4(%ecx)
}

asm u32bits div8byte(dp,val)
{
%mem	dp,val;
	movl	dp, %ecx
	movl	(%ecx), %eax
	movl	4(%ecx), %edx
	movl	val, %ecx
	divl	%ecx
}

asm void mul8byte(dp,val0,val1)
{
%mem	dp,val0,val1;
	movl	dp, %ecx
	movl	val0, %eax
	movl	val1, %edx
	mull	%edx
	movl	%eax, (%ecx)
	movl	%edx, 4(%ecx)
}

/* clear only multiples of 4 bytes */
asm void fast_bzero4(memp, count)
{
%mem	memp, count;
	pushl	%edi		/ save edi register
	movl	count, %ecx	/ get the data transfer length
	movl	memp, %edi	/ get memory address
	shrl	$2, %ecx
	xorl	%eax, %eax
	rep
	sstol			/ first zero 4 bytes long
	popl	%edi		/ restore edi register
}

asm void fast_bzero(memp, count)
{
%mem	memp, count;
	pushl	%edi		/ save edi register
	movl	memp, %eax	/ save it edx
	movl	count, %ecx	/ get the data transfer length
	movl	%eax, %edi	/ get memory address
	movl	%ecx, %edx	/ save the count
	shrl	$2, %ecx
	xorl	%eax, %eax
	rep
	sstol			/ first zero 4 bytes long
	movl	%edx, %ecx
	andl	$3, %ecx
	rep
	sstob			/ rest (maximum 3) move byte by byte
	popl	%edi		/ restore edi register
}

/* copy only multiples of 4 bytes data with given len (size=len*4) */
asm void fast_bcopy4cnt(from, to, len)
{
%mem	from,to, len;
	pushl	%esi		/ save esi register
	pushl	%edi		/ save edi register
	movl	from, %edx	/ save it edx
	movl	to, %eax	/ save it in eax
	movl	len, %ecx	/ get the data transfer length
	movl	%eax, %edi	/ get destination memory address
	movl	%edx, %esi	/ get source memory address
	rep
	smovl			/ first move 4 bytes long
	popl	%edi		/ restore edi register
	popl	%esi		/ restore esi register
}


/* copy only multiples of 4 bytes data */
asm void fast_bcopy4(from, to, count)
{
%mem	from,to, count;
	pushl	%esi		/ save esi register
	pushl	%edi		/ save edi register
	movl	from, %edx	/ save it edx
	movl	to, %eax	/ save it in eax
	movl	count, %ecx	/ get the data transfer length
	movl	%eax, %edi	/ get destination memory address
	movl	%edx, %esi	/ get source memory address
	shrl	$2, %ecx
	rep
	smovl			/ first move 4 bytes long
	popl	%edi		/ restore edi register
	popl	%esi		/ restore esi register
}

asm void fast_bcopy(from, to, count)
{
%mem	from,to, count;
	pushl	%esi		/ save esi register
	pushl	%edi		/ save edi register
	movl	from, %edx	/ save it edx
	movl	to, %eax	/ save it in eax
	movl	count, %ecx	/ get the data transfer length
	movl	%eax, %edi	/ get destination memory address
	movl	%edx, %esi	/ get source memory address
	movl	%ecx, %edx	/ save the count
	shrl	$2, %ecx
	rep
	smovl			/ first move 4 bytes long
	movl	%edx, %ecx
	andl	$3, %ecx
	rep
	smovb			/ rest (maximum 3) move byte by byte
	popl	%edi		/ restore edi register
	popl	%esi		/ restore esi register
}

#ifdef	__MLX_STDC__
extern	void fast_bzero(caddr_t,u32bits);
extern	void fast_bzero4(caddr_t,u32bits);
extern	void fast_bcopy(caddr_t,caddr_t,u32bits);
extern	void fast_bcopy4(caddr_t,caddr_t,u32bits);
extern	add8byte(u64bits*,u32bits);
extern	add88byte(u64bits*,u64bits*);
#endif	/* __MLX_STDC__ */

#else	/* C macros */
#define	add8byte(dp,val) \
	((dp)->bit63_32 += (((dp)->bit31_0+=val)<val)? 1: 0)
#define	add88byte(dp,sp) \
	((dp)->bit63_32 += (sp)->bit63_32 + \
		(((dp)->bit31_0+=(sp)->bit31_0)<(sp)->bit31_0)? 1: 0)
#define	fast_bzero(dp,sz)	bzero(dp,sz)
#define	fast_bzero4(dp,sz)	bzero(dp,sz)
#define	fast_bcopy(sp,dp,sz)	bcopy(sp,dp,sz)
#define	fast_bcopy4(sp,dp,sz)	bcopy(sp,dp,sz)

#define	MSB	0x80000000
u32bits static
div8byte(sp, val)
u64bits DRLFAR *sp;
u32bits val;
{
	u64bits dd = *sp;
	u32bits inx,rc=0;
	for (inx=32; inx; inx--)
	{
		rc <<=1;
		dd.bit63_32 <<= 1;
		if (dd.bit31_0 & MSB) dd.bit63_32++;
		dd.bit31_0 <<= 1;
		if (dd.bit63_32 >= val)
		{
			rc++;
			dd.bit63_32 -= val;
		}
	}
	return rc;
}

static void
mul8byte(dp, val0, val1)
u64bits *dp;
u32bits val0,val1;
{
	u32bits inx;
	dp->bit63_32 = 0; dp->bit31_0 = 0;
	for (inx=32; inx; inx--)
	{
		dp->bit63_32 <<= 1;
		if (dp->bit31_0 & MSB) dp->bit63_32++;
		dp->bit31_0 <<= 1;
		if (val1 & MSB) add8byte(dp,val0);
		val1 <<= 1;
	}
}
/* #define	asm(x) */
#endif	/* DRLASM */

#ifdef	__MLX_STDC__
extern	u32bits div8byte(u64bits DRLFAR *,u32bits);
extern	void mul8byte(u64bits DRLFAR *, u32bits, u32bits);
#endif	/* __MLX_STDC__ */

/* transfer the ios status to rw status */
#define	drl_txios2rw(iosp,rwp) \
{ \
	rwp->drlrw_stime = iosp->drlios_stime; \
	rwp->drlrw_slbolt = iosp->drlios_slbolt; \
	rwp->drlrw_diodone = iosp->drlios_diodone; \
	rwp->drlrw_dtdone = iosp->drlios_dtdone; \
	rwp->drlrw_randups = iosp->drlios_randups; \
	rwp->drlrw_opstatus = iosp->drlios_opstatus; \
	rwp->drlrw_randx = iosp->drlios_randx; \
	rwp->drlrw_miscnt = iosp->drlios_miscnt; \
	rwp->drlrw_goodpat = iosp->drlios_goodpat; \
	rwp->drlrw_badpat = iosp->drlios_badpat; \
	rwp->drlrw_uxblk = iosp->drlios_uxblk; \
	rwp->drlrw_uxblkoff = iosp->drlios_uxblkoff; \
	rwp->drlrw_opflags = iosp->drlios_opflags; \
	rwp->drlrw_parallelios = iosp->drlios_parallelios; \
	rwp->drlrw_opcounts = iosp->drlios_opcounts; \
	rwp->drlrw_devcnt = iosp->drlios_devcnt; \
	rwp->drlrw_maxblksize = iosp->drlios_maxblksize; \
	rwp->drlrw_minblksize = iosp->drlios_minblksize; \
	rwp->drlrw_ioinc = iosp->drlios_ioinc; \
	rwp->drlrw_iocount = iosp->drlios_iocount; \
	rwp->drlrw_opcounts = iosp->drlios_opcounts; \
	rwp->drlrw_randx = iosp->drlios_randx; \
	rwp->drlrw_pat = iosp->drlios_curpat; \
	rwp->drlrw_patinc = iosp->drlios_patinc; \
 	rwp->drlrw_randlimit = iosp->drlios_randlimit; \
	rwp->drlrw_signature = iosp->drlios_signature; \
	rwp->drlrw_ioszrandx = iosp->drlios_ioszrandx; \
	rwp->drlrw_rwmixrandx = iosp->drlios_rwmixrandx; \
	rwp->drlrw_rwmixcnt = iosp->drlios_rwmixcnt; \
	rwp->drlrw_startblk = iosp->drlios_startblk; \
	rwp->drlrw_reads = iosp->drlios_reads; \
	rwp->drlrw_writes = iosp->drlios_writes; \
	for (inx=0; inx<DRLMAX_BDEVS; inx++) \
		rwp->drlrw_bdevs[inx] = iosp->drlios_bdevs[inx]; \
}

/* All DATAREL error codes are here */
#define	DRLERR_NOTSUSER		0x01 /* Not super-user */
#define	DRLERR_ACCESS		0x02 /* Permission denied */
#define	DRLERR_NOMEM		0x03 /* Not enough memory */
#define	DRLERR_INTR		0x04 /* interrupted system call */
#define	DRLERR_IO		0x05 /* I/O error */
#define	DRLERR_NOSPACE		0x06 /* No space left on device */
#define	DRLERR_FAULT		0x07 /* Bad address */
#define	DRLERR_NODEV		0x08 /* No such device */
#define	DRLERR_INVAL		0x09 /* Invalid argument */
#define	DRLERR_NOCODE		0x0A /* feature is not implemented */
#define	DRLERR_BIGDATA		0x0B /* data size is too big */
#define	DRLERR_SMALLDATA	0x0C /* data size is too small */
#define	DRLERR_BUSY		0x0D /* device is device busy */

#endif	/* _SYS_DRLAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\sys\hppifevt.h ===
/**********************************************************************
// Compaq Confidential

  Author:       Compaq Computer Corporation.
		Systems Engineering -- System Software Development (NT Dev)
		Copyright 1996-98 Compaq Computer Corporation.
		All rights reserved.

  Date:         1 August 1996 

  File:         HPPIFEVT.H	- Generic Hot Plug Event Structures

  Purpose:      This file contains all the event specific information
				necessary to interface to a hot plug device driver.
                
				This file details the data structures and Application Programming 
                Interfaces (APIs) for PCI Hot Plug support running in a Windows 
                NT 4.0 server.  These data structures and APIs are used between 
                the Adapter Card drivers and the PCI Hot Plug Service for NT 4.0.  
                These files are considered vital to maintaining the Compatibility 
                of the PCI Hot Plug Functionality.

  Created:  11/4/97		mib		Split off of hppif3p

  Verison: 1.0
***********************************************************************/

#ifndef _HPPIFEVT_H_
#define _HPPIFEVT_H_


#pragma pack(1)

//**********************************************************************
//              EVENT MESSAGE DEFINITIONS 
//**********************************************************************


//====================================================================
//                      CPQRCMC EVENT TYPES
//====================================================================
//
//  CPQRCMC event types are used when passing events to
//    the CPQRCMC Service.
//  Events passed from drivers to the service are sent by passing
//  the events via the call back address provided in the rcmc Info 
//  struct. The driver Id from the same structure should be used 
//  for the sender id
    
//Event ID's

//   00-FF  RESERVED BY COMPAQ
#define HR_DD_STATUS_CHANGE_EVENT        0x20     
#define HR_DD_DEVICE_STATUS_EVENT        0x21
#define HR_DD_LOG_EVENT                  0x30	


#ifndef _HR_H_

//====================================================================
//            SUPPORT STRUCTURES AND DEFINES FOR MESSAGING
//====================================================================

#define HR_MAX_EVENTS         16
#define HR_EVENT_DATA_SIZE    64 

//
//  HR event types are used when passing events to the CPQRCMC Service.  
//   
#define HR_CPQRCMC_COMMAND_EXIT_EVENT    0x01	 


typedef struct _HREvent {
   ULONG                 ulEventId;    // @field . 
   ULONG                 ulSenderId;   // @field .
   
   union {                               
       ULONG   ulData1;          // @field .
       
       struct {
               UCHAR  ucEventSeverity;        //@field .
               UCHAR  ucRes;                  //@field .
               USHORT usEventDataLength;      //@field .
       };     
   };        
    
   union {                        
       ULONG   ulData2;          // @field .
       
       struct {
               USHORT  usEventClass;          //@field .
               USHORT  usEventCode;           //@field .
       };     
   };        
   
   UCHAR     ulEventData[HR_EVENT_DATA_SIZE];   // @field .
   
} HR_EVENT, *PHR_EVENT;

#endif _HR_H_



/* Eventlog revision supported by this file (bHdrRev in the header structure) */

#define EVT_LOG_REVISION         0x01

/* Time stamp of event (creation or last update) */

typedef struct _evtTimeStamp
{
   BYTE     bCentury;            /* hi-order two digits of year (19 of 1996) */
   BYTE     bYear;               /* lo-order two digits of year (96 of 1996) */
   BYTE     bMonth;              /* one-based month number (1-12) */
   BYTE     bDay;                /* one-based day number (1-31) */
   BYTE     bHour;               /* zero-based hour (0-23) */
   BYTE     bMinute;             /* zero-based minute (0-59) */
} EVT_TIME_STAMP, *PEVT_TIME_STAMP;


/* Eventlog severity codes */

#define EVT_STAT_INFO            0x02     /* Status or informational message */
#define EVT_STAT_POPUP           0x03     /* Status with popup on LCD */
#define EVT_STAT_REPAIRED        0x06     /* Degraded or worse cond repaired */
#define EVT_STAT_CAUTION         0x09     /* Component in degraded condition */
#define EVT_STAT_FAILED          0x0F     /* Failed with loss of functionality */
#define EVT_STAT_CRITICAL        EVT_STAT_FAILED /* Same as Failed */

/* Chassis type defines */
#define EVT_CHASSIS_SYSTEM          0x01
#define EVT_CHASSIS_EXTERN_STORAGE  0x02
#define EVT_CHASSIS_INTERN_STORAGE  0x03

typedef struct _evtChassis
{
   UCHAR     bType;               /* Chassis Type (System==1; Extern==2) */
   UCHAR    bId;                 /* Chassis id */
                                 /*   for type 1 - chassis id (0 is system) */
                                 /*   for type 2 or 3 - adapter slot */
   UCHAR    bPort;               /* Chassis port or bus number */
} EVT_CHASSIS, *PEVT_CHASSIS;


/* Eventlog Header -- common to all event log entries */

typedef struct _evtLogHdr
{
   WORD     wEvtLength;          /* Length of event including header */
   DWORD    dwEvtNumber;         /* Unique event number (can wrap) */
   BYTE     bHdrRev;             /* Header version (see EVT_LOG_REVISION) */
   BYTE     bSeverity;           /* Event severity code */
   WORD     wClass;              /* Event class or sub-system */
   WORD     wCode;               /* Event code for event in the class */
   EVT_TIME_STAMP InitTime;      /* Time of initial event */
   EVT_TIME_STAMP UpdateTime;    /* Time of last update */
   DWORD    dwCount;             /* Occurrence count (at least 1) */
} EVT_HEADER, *PEVT_HEADER;


#define EVT_CLASS_EXPANSION_SLOT    0x09
   #define EVT_SLOT_SWITCH_OPEN        0x01
   #define EVT_SLOT_SWITCH_CLOSED      0x02
   #define EVT_SLOT_POWER_ON           0x03
   #define EVT_SLOT_POWER_OFF          0x04
   #define EVT_SLOT_FATAL_POWER_FAULT  0x05
   #define EVT_SLOT_POWER_UP_FAULT     0x06
   #define EVT_SLOT_POWER_LOSS         0x07
   #define EVT_SLOT_CANNOT_CONFIG      0x08
   #define EVT_SLOT_BOARD_FAILURE      0x09

/* Eventlog Expansion Slot structs */

typedef struct _evtExpansionSlot
{
   EVT_CHASSIS Chassis;          /* Standard chassis info */
   BYTE     bSlot;               /* 0 is embedded */
} EVT_EXPANSION_SLOT, *PEVT_EXPANSION_SLOT;

#define EVT_HOT_PLUG_BUS   EVT_EXPANSION_SLOT
#define PEVT_HOT_PLUG_BUS  PEVT_EXPANSION_SLOT

#define EVT_SLOT_WRONG_TYPE         0x01
#define EVT_SLOT_WRONG_REVISION     0x02
#define EVT_SLOT_GENERAL_FAULT      0x03
#define EVT_SLOT_OUT_OF_RESOURCES   0x04

typedef struct _evtExpansionSlotConfigErr
{
   EVT_CHASSIS Chassis;          /* Standard chassis info */
   BYTE     bSlot;               /* 0 is embedded */
   BYTE     bError;              /* Board configuration error */
} EVT_EXPANSION_SLOT_CONFIG_ERR, *PEVT_EXPANSION_SLOT_CONFIG_ERR;


#define EVT_NETWORK_ADAPTER         0x11
   #define EVT_NIC_ADAPTER_CHECK       0x01
   #define EVT_NIC_LINK_DOWN           0x02
   #define EVT_NIC_XMIT_TIMEOUT        0x03
   
typedef struct _evtNicError
{
   EVT_CHASSIS Chassis;          /* Standard chassis info */
   UCHAR    bSlot;               /* Slot number */
   CHAR     cChassisName[1];     /* Chassis name; '\0' if undefined */
} EVT_NIC_ERROR, *PEVT_NIC_ERROR;

/* Eventlog free form data union */

typedef union _evtFreeForm
{
   EVT_NIC_ERROR                    NicErr;
} EVT_FREE_FORM, *PEVT_FREE_FORM;


/* Eventlog Entry */

typedef struct _evtLogEntry
{
   EVT_HEADER        Hdr;        /* Common header */
   EVT_FREE_FORM     Data;       /* Free form entry specific */
} EVT_LOG_ENTRY, *PEVT_LOG_ENTRY;





#pragma pack()
#endif                  /* End of #ifndef _HPPIF3P_H_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\sys\hppif3p.h ===
/**********************************************************************
// Compaq Confidential

  Author:       Compaq Computer Corporation.
		Systems Engineering -- System Software Development (NT Dev)
		Copyright 1996-98 Compaq Computer Corporation.
		All rights reserved.

  Date:         1 August 1996 

  File:         HPPIF3P.H	Hot Plug Interface MINIPORT Defs

  Purpose:      This file contains all miniport specific information necessary
		        to interface to a hot plug device driver.
                
				This file details the data structures and Application Programming 
                Interfaces (APIs) for PCI Hot Plug support running in a Windows 
                NT 4.0 server.  These data structures and APIs are used between 
                the Adapter Card drivers and the PCI Hot Plug Service for NT 4.0.  
                These files are considered vital to maintaining the Compatibility 
                of the PCI Hot Plug Functionality.

  Revision History:
	11/4/97		mib		Split into hppifio (IOCTLs) and hppifevt (Event) Defs
    06/11/98            Added PCS_HBA_OFFLINE_PENDING for cpqarray
  Version: 1.2

***********************************************************************/

#ifndef _HPPIF3P_H_
#define _HPPIF3P_H_

#include "hppifio.h"		// defines for driver hotplug interfaces
#include <ntddscsi.h>		// Scsi Miniport Interface (See SDK)

#pragma pack(1)


//**********************************************************************
//            DEFINES FOR MINIPORT DRIVERS
//**********************************************************************

// NIC Controller Status Defines

#define NIC_STATUS_NORMAL			0x00
#define NIC_STATUS_MEDIA_FAILURE		0x01
#define NIC_STATUS_ADAPTER_CHECK		0x02

#define NIC_STATUS_USER_SIMULATED_FAILURE	0x10
#define NIC_STATUS_POWER_OFF_PENDING		0x20
#define NIC_STATUS_POWER_OFF			0x30
#define NIC_STATUS_POWER_OFF_FAULT		0x40
#define NIC_STATUS_POWER_ON_PENDING		0x50
#define NIC_STATUS_POWER_ON			0x60
#define NIC_STATUS_POWER_FAULT			0x70



// IOCTL defines supporting Compaq Hot Plug PCI for SCSI Miniport

//#define HPP_BASE_SCSI_ADDRESS_DEFAULT	0x0004d008

#define CPQ_HPP_SIGNATURE				"CPQHPP"
#define CPQ_HPP_TIMEOUT					180

// Defines for completion codes
#define IOP_HPP_ISSUED				0x1
#define IOP_HPP_COMPLETED			0x2
#define IOP_HPP_CMDBUILT			0x3
#define IOP_HPP_NONCONTIGUOUS		0x4
#define IOP_HPP_ERROR				0x5

// IOCTL control codes

#define IOC_HPP_RCMC_INFO           0x1
#define IOC_HPP_HBA_STATUS          0x2
#define IOC_HPP_HBA_INFO            0x3
#define IOC_HPP_SLOT_TYPE           0x4
#define IOC_HPP_SLOT_EVENT          0x5
#define IOC_HPP_PCI_CONFIG_MAP      0x6
#define IOC_HPP_DIAGNOSTICS         0x7

// IOCTL Status

#define	IOS_HPP_SUCCESS                 0x0000
#define	IOS_HPP_BUFFER_TOO_SMALL        0x2001
#define	IOS_HPP_INVALID_CONTROLLER      0x2002
#define IOS_HPP_INVALID_BUS_TYPE        0x2003
#define	IOS_HPP_INVALID_CALLBACK        0x2004
#define	IOS_HPP_INVALID_SLOT_TYPE       0x2005
#define	IOS_HPP_INVALID_SLOT_EVENT      0x2006
#define	IOS_HPP_NOT_HOTPLUGABLE         0x2007
#define IOS_HPP_NO_SERVICE              0x2008
#define IOS_HPP_HBA_FAILURE             0x2009
#define IOS_HPP_INVALID_SERVICE_STATUS  0x200a
#define IOS_HPP_HBA_BUSY                0x200b
#define IOS_HPP_NO_DIAGNOSTICS          0x200c



// Health Driver Status Codes

#define CBS_HBA_FAIL_MESSAGE_COUNT     0x8 // Number of failure health messages.
										   // This must be updated if messages are
                                           // added or removed.
                                           // This is a compile time check.

#define CBS_HBA_STATUS_NORMAL          0x0000
#define CBS_HBA_STATUS_FAILED          0x1001
#define CBS_HBA_POWER_FAULT            0x1002
#define CBS_HBA_CABLE_CHECK            0x1003
#define CBS_HBA_MEDIA_CHECK            0x1004
#define CBS_HBA_USER_FAILED            0x1005
#define CBS_HBA_FAILED_CACHE_IN_USE    0x1006
#define CBS_HBA_PWR_FAULT_CACHE_IN_USE 0x1007

//Compaq reserves values 0x1010 and 0x1011

// IOCTL buffer data structures

typedef struct _HPP_RCMC_INFO_BUFFER {
    SRB_IO_CONTROL  IoctlHeader;
    HPP_RCMC_INFO   RcmcInfo;
} HPP_RCMC_INFO_BUFFER, *PHPP_RCMC_INFO_BUFFER;

typedef struct _HPP_CTRL_INFO_BUFFER {
    SRB_IO_CONTROL  IoctlHeader;
    HPP_CTRL_INFO   CtrlInfo;
} HPP_CTRL_INFO_BUFFER, *PHPP_CTRL_INFO_BUFFER;

typedef struct _HPP_CTRL_STATUS_BUFFER {
    SRB_IO_CONTROL  IoctlHeader;
    HPP_CTRL_STATUS CtrlStatus;
} HPP_CTRL_STATUS_BUFFER, *PHPP_CTRL_STATUS_BUFFER;

typedef struct _HPP_CTRL_SLOT_TYPE_BUFFER {
    SRB_IO_CONTROL      IoctlHeader;
    HPP_CTRL_SLOT_TYPE  CtrlSlotType;
} HPP_CTRL_SLOT_TYPE_BUFFER, *PHPP_CTRL_SLOT_TYPE_BUFFER;

typedef struct _HPP_SLOT_EVENT_BUFFER {
    SRB_IO_CONTROL      IoctlHeader;
    HPP_SLOT_EVENT      SlotEvent;
} HPP_SLOT_EVENT_BUFFER, *PHPP_SLOT_EVENT_BUFFER;

typedef struct _HPP_PCI_CONFIG_MAP_BUFFER {
    SRB_IO_CONTROL      IoctlHeader;
    HPP_PCI_CONFIG_MAP  PciConfigMap;
} HPP_PCI_CONFIG_MAP_BUFFER, *PHPP_PCI_CONFIG_MAP_BUFFER;

// Physical Controller State flags:
//
// Flags utilized to maintain controller state for Hot-Plug
//___________________________________________________________________________ 

// state flags 

#define PCS_HBA_OFFLINE       0x00000001 // Adaptor has been taken off-line
#define PCS_HBA_FAILED        0x00000002 // Adaptor is considered faulted
#define PCS_HBA_TEST          0x00000004 // Adaptor is being tested
#define PCS_HBA_CABLE_CHECK   0x00000008 // Failure due to cable fault
#define PCS_HBA_MEDIA_CHECK   0x00000010 // Failure due to media fault
#define PCS_HBA_EXPANDING     0x00000020 // Indicates that one or more LUNS is expanding
#define PCS_HBA_USER_FAILED   0x00000040 // Indicates user failed slot
#define PCS_HBA_CACHE_IN_USE  0x00000080 // Lazy write cache active
#define PCS_HPP_HOT_PLUG_SLOT 0x00000400 // Slot is Hot-Plugable
#define PCS_HPP_SERVICE_READY 0x00000800 // RCMC service is running
#define PCS_HPP_POWER_DOWN    0x00001000 // Normal power down on slot
#define PCS_HPP_POWER_LOST    0x00002000 // Slot power was lost
#define PCS_HBA_EVENT_SUBMIT  0x0000100	 // Stall IO while AEV req submitted
#define PCS_HBA_IO_QUEUED     0x0000200	 // IO is queuing.  
#define PCS_HBA_UNFAIL_PENDING 0x00010000 // Return error until PCS_HBA_OFFLINE is reset

//Macros related to Hot Plug Support

// The below defined macro can be used to determine active controller
// state.  Its use would be appropriate when deciding whether to
// handle a request via the startio entry point.

#define PCS_HBA_NOT_READY(FLAGS) (FLAGS & (PCS_HBA_FAILED       |	\
					   PCS_HBA_TEST         |	\
					   PCS_HBA_OFFLINE      |	\
					   PCS_HBA_EVENT_SUBMIT |	\
					   PCS_HPP_POWER_DOWN))

// Note that the following set does *not* flip the offline bit. It is the
// responsibility  of the initialization routine to bring a controller
// online if startup is successful.

#define PCS_SET_UNFAIL(FLAGS)        (FLAGS &= ~(PCS_HBA_FAILED      |	\
						 PCS_HBA_USER_FAILED))

#define PCS_SET_PWR_OFF(FLAGS)       (FLAGS |= (PCS_HPP_POWER_DOWN |	\
						PCS_HBA_OFFLINE))

#define PCS_SET_PWR_FAULT(FLAGS)     (FLAGS |= (PCS_HPP_POWER_DOWN |	\
						PCS_HPP_POWER_LOST |	\
						PCS_HBA_OFFLINE))


#define PCS_SET_PWR_ON(FLAGS)        (FLAGS &= ~(PCS_HPP_POWER_DOWN |	\
						 PCS_HPP_POWER_LOST))

#define PCS_SET_USER_FAIL(FLAGS)     (FLAGS |= (PCS_HBA_FAILED      |	\
						PCS_HBA_USER_FAILED |	\
						PCS_HBA_OFFLINE))

#define PCS_SET_VERIFY(FLAGS)        (FLAGS |= (PCS_HBA_OFFLINE))

#define PCS_SET_CABLE_CHECK(FLAGS)   (FLAGS |= (PCS_HBA_FAILED      |	\
						PCS_HBA_OFFLINE))

#define PCS_SET_ADAPTER_CHECK(FLAGS) (FLAGS |= (PCS_HBA_FAILED |	\
						PCS_HBA_OFFLINE))

#define PCS_SET_MEDIA_CHECK(FLAGS)   (FLAGS |= (PCS_HBA_MEDIA_CHECK |	\
						PCS_HBA_OFFLINE))

#define PCS_SET_TEST(FLAGS)          (FLAGS |= (PCS_HBA_TEST |		\
						PCS_HBA_OFFLINE))

#define PCS_SET_NO_TEST(FLAGS)       (FLAGS &= ~(PCS_HBA_TEST |		\
						PCS_HBA_OFFLINE))

// The following macro is used by the array driver to set the status member
// of the RCMC event structure.

#define RCMC_SET_STATUS(FLAGS, EVENTCODE)	\
if (FLAGS & PCS_HPP_POWER_LOST) {		\
  if (FLAGS & PCS_HBA_CACHE_IN_USE) {		\
    EVENTCODE = CBS_HBA_PWR_FAULT_CACHE_IN_USE;	\
  } else {					\
    EVENTCODE = CBS_HBA_POWER_FAULT;		\
  }						\
} else if (FLAGS & PCS_HBA_MEDIA_CHECK) {	\
  EVENTCODE = CBS_HBA_MEDIA_CHECK;		\
} else if (FLAGS & PCS_HBA_CABLE_CHECK) {	\
  EVENTCODE = CBS_HBA_CABLE_CHECK;		\
} else if (FLAGS & PCS_HBA_USER_FAILED) {	\
  EVENTCODE = CBS_HBA_USER_FAILED;		\
} else if (FLAGS & PCS_HBA_FAILED) {		\
  if (FLAGS & PCS_HBA_CACHE_IN_USE) {		\
    EVENTCODE = CBS_HBA_FAILED_CACHE_IN_USE;	\
  } else {					\
    EVENTCODE = CBS_HBA_STATUS_FAILED;		\
  }						\
} else {					\
  EVENTCODE = CBS_HBA_STATUS_NORMAL;		\
}


// Logical Controller State Flags:
//
// Flags utilized to signal driver internal procedures relevant to the
// maintenance of Hot-Plug.
//___________________________________________________________________________

// control flags

#define LCS_HBA_FAIL_ACTIVE  0x00000001 // Fail active controller
#define LCS_HBA_READY_ACTIVE 0x00000002 // Un-Fail active controller
#define LCS_HBA_TEST         0x00000004 // Perform tests on controller
#define LCS_HBA_OFFLINE      0x00000008 // Take adaptor off-line
#define LCS_HBA_TIMER_ACTIVE 0x00000010 // Timer routine running
#define LCS_HBA_INIT         0x00000020 // Used for power-up
#define LCS_HBA_IDENTIFY     0x00000040 // Send Indentify command
#define LCS_HBA_READY        0x00000080 // Free controller 
#define LCS_HBA_GET_EVENT    0x00000100 // Send async event req
#define LCS_HBA_HOLD_TIMER   0x00000200	// Don't process timer now
#define LCS_HBA_CHECK_CABLES 0x00000400	// Verify cables are secure
#define LCS_HPP_STOP_SERVICE 0x00001000	// Request stop of RCMC Service
#define LCS_HPP_SLOT_RESET   0x00002000	// Service reseting slot power


#define LCS_HPP_POWER_DOWN  LCS_HBA_FAIL_ACTIVE // Put adaptor in Hot-Plug
						// Stall 

#define LCS_HPP_POWER_FAULT LCS_HBA_FAIL_ACTIVE // Send power-fault event

// The followimg macro is used in the array driver to setup the sequence of
// events required to initialize a powered-up controller to working
// condition.  Bits are flipped by each process until they are clear.

#define LCS_HPP_POWER_UP (LCS_HBA_INIT			|	\
			  LCS_HBA_READY_ACTIVE)



//
// SRB Return codes.
// 

#define RETURN_BUSY                     0x00 // default value
#define RETURN_NO_HBA                   0x01
#define RETURN_ABORTED                  0x02
#define RETURN_ABORT_FAILED             0x03
#define RETURN_ERROR                    0x04
#define RETURN_INVALID_PATH_ID          0x05
#define RETURN_NO_DEVICE                0x06
#define RETURN_TIMEOUT                  0x07
#define RETURN_COMMAND_TIMEOUT          0x08
#define RETURN_MESSAGE_REJECTED         0x09
#define RETURN_BUS_RESET                0x0A
#define RETURN_PARITY_ERROR             0x0B
#define RETURN_REQUEST_SENSE_FAILED     0x0C
#define RETURN_DATA_OVERRUN             0x0D
#define RETURN_UNEXPECTED_BUS_FREE      0x0E
#define RETURN_INVALID_LUN              0x0F
#define RETURN_INVALID_TARGET_ID        0x10
#define RETURN_BAD_FUNCTION             0x11
#define RETURN_ERROR_RECOVERY           0x12
#define RETURN_PENDING                  0x13


#pragma pack()
#endif                  /* End of #ifndef _HPPIF3P_H_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\sys\mdacapi.h ===
/**************************************************************************
 *                COPYRIGHT (C) Mylex Corporation 1992-1998               *
 *                                                                        *
 * This software is furnished under a license and may be used and copied  * 
 * only in accordance with the terms and conditions of such license and   * 
 * with inclusion of the above copyright notice. This software or any     * 
 * other copies thereof may not be provided or otherwise made available   * 
 * to any other person. No title to, nor ownership of the software is     * 
 * hereby transferred.                                                    *
 *                                                                        *
 * The information in this software is subject to change without notices  *
 * and should not be construed as a commitment by Mylex Corporation       *
 *                                                                        *
 **************************************************************************/

#ifndef	_SYS_MDACAPI_H
#define	_SYS_MDACAPI_H

#ifdef	WIN_NT
#define	mdacdevname		"\\\\.\\MdacDevice0"
#else
#define	mdacdevname		"/dev/mdacdev"
#endif

#ifndef IA64
#define	MDAC_PAGESIZE		(4*ONEKB)	/* page size for mdac driver */
#define	MDAC_PAGEOFFSET		(MDAC_PAGESIZE-1)
#define	MDAC_PAGEMASK		(~MDAC_PAGEOFFSET)
#else
#define	MDAC_PAGESIZE		(PAGE_SIZE)	/* use system-defined pg size */
#define	MDAC_PAGEOFFSET		(PAGE_SIZE-1)
#define	MDAC_PAGEMASK		(~MDAC_PAGEOFFSET)
#endif


#ifdef	MLX_NT
#define	MDAC_MAXCOMMANDS	512	/* Max commands/controller */
#else
#define	MDAC_MAXCOMMANDS	256	/* Max commands/controller */
#endif
#define	MDAC_MAXREQSENSES	256	/* maximum senses can be saved */
#define	MDAC_MAXLOGDEVS		32	/* Max logical device on DAC */
#define	MDAC_MAXBUS		32	/* Max buses allowed */

#ifdef MLX_OS2
	#define	MDAC_MAXCONTROLLERS	8	/* Max allowed controller */
#elif  MLX_DOS
	#define	MDAC_MAXCONTROLLERS	16	/* Max allowed controller */
#else
	#define	MDAC_MAXCONTROLLERS	32	/* Max allowed controller */
#endif

#ifdef MLX_DOS
#define	MDAC_MAXCHANNELS	3	/* Max Channel allowed in Controller */
#define	MDAC_MAXLUNS		1	/* for test purpose only */
#else
#define	MDAC_MAXCHANNELS	8	/* Max Channel allowed in Controller */
#define	MDAC_MAXLUNS		8	/* for test purpose only */
#endif
#define	MDAC_MAXTARGETS		16	/* for test purpose only */


#define	MDAC_MAXPHYSDEVS	(MDAC_MAXCHANNELS*MDAC_MAXTARGETS*MDAC_MAXLUNS)

#ifndef _WIN64
#define	MDAC_MAXSGLISTSIZE	(64+16)	/* Max SG List size */
#else
#define	MDAC_MAXSGLISTSIZE	(64+14)	/* Max SG List size */
#endif  /* because rq_SGList now starts at offset 0x190 in rqp struc - not offset 0x180!
	   and there is an assumption that the OS struc will not exceed size 1k (1024) */

#define	MDAC_MAXSGLISTSIZENEW	(MDAC_MAXSGLISTSIZE/2)	/* Max SG List size for new interface */
#define	MDAC_MAXSGLISTSIZEIND	256	/* Max SG List size for indirect SG */
#define	MDAC_MAXDATATXSIZE	0x20000	/* Max Data Transfer Size */
				/* data transfer size due SG List within
				** request buffer
				*/
#define	MDAC_SGTXSIZE		((MDAC_MAXSGLISTSIZE-1)*MDAC_PAGESIZE)
#define	MDAC_SGTXSIZENEW	((MDAC_MAXSGLISTSIZENEW-1)*MDAC_PAGESIZE)
#define	MDAC_MAXTTENTS		0x00100000 /* Max Trace entries allowed */
#define	MDAC_MINTTENTS		0x00000100 /* Min Trace entries allowed */
#define	mdac_bytes2blks(sz)	((sz)>>9)/* 512 bytes per blocks */
#define	mdac_bytes2pages(sz)	(((sz)+MDAC_PAGEOFFSET)/MDAC_PAGESIZE)

/* All ioctl calls must check for zero return after ioctl call. Zero value in
** ErrorCode which is part of every given structure. Check any other non zero
** value which may be part of the request data structure.
** The ioctl calls as follows
** ioctl(file descriptor, cmd, cmd-buf)
*/
#define	MIOC	'M'

/*
** Get the controller information.
** Set ci_ControllerNo and make ioctl call
** mda_controller_info_t ci;
** ci.ci_ControllerNo = 0;
** if (ioctl(gfd,MDACIOC_GETCONTROLLERINFO,&ci) || ci.ci_ErrorCode)
**	return some_error;
**
** ci.ci_ControllerNo = 1;
** if (ioctl(gfd,MDACIOC_RESETCONTROLLERSTAT,&ci) || ci.ci_ErrorCode)
**	return some_error;
**
** if (ioctl(gfd,MDACIOC_RESETALLCONTROLLERSTAT,&ci))
**	return some_error;
*/
#define	MDACIOC_GETCONTROLLERINFO	_MLXIOWR(MIOC,0,mda_controller_info_t)
#define	MDACIOC_RESETCONTROLLERSTAT	_MLXIOWR(MIOC,1,mda_controller_info_t)
#define	MDACIOC_RESETALLCONTROLLERSTAT	_MLXIOR(MIOC,2,mda_controller_info_t)
#ifdef _WIN64
typedef struct mda_controller_info
{
	u32bits	ci_ErrorCode;		/* Non zero if data is not valid */
	u32bits	ci_Status;		/* Controller status */
	u32bits	ci_OSCap;		/* Capability for OS */
	u32bits	ci_vidpid;		/* PCI device id + product id */
/* 0x10 */
	u08bits	ci_ControllerType;	/* type of controller */
	u08bits	ci_ControllerNo;	/* IO: adapter number */
	u08bits	ci_BusNo;		/* System Bus No, HW is sitting on */
	u08bits	ci_BusType;		/* System Bus Interface Type */

	u08bits	ci_FuncNo;		/* PCI function number */
	u08bits	ci_SlotNo;		/* System EISA/PCI/MCA Slot Number */
	u08bits	ci_TimeTraceEnabled;	/* !=0 if time trace enabled */
	u08bits	ci_FWTurnNo;		/* firmware turn number */

	u08bits	ci_BIOSHeads;		/* # heads for BIOS */
	u08bits	ci_BIOSTrackSize;	/* # sectors per track for BIOS */
	u16bits	ci_Reserved1;
	u32bits	ci_FreeCmdIDs;		/* # free command IDs */
/* 0x20 */
	u08bits	ci_MaxChannels;		/* Maximum Channels present */
	u08bits	ci_MaxTargets;		/* Max # Targets/Channel supported */
	u08bits	ci_MaxLuns;		/* Max # LUNs/Target supported */
	u08bits	ci_MaxSysDevs;		/* Max # Logical Drives supported */
	u16bits	ci_MaxTags;		/* Maximum Tags supported */
	u16bits	ci_FWVersion;		/* Firmware Version Number */
	u08bits	ci_IntrShared;		/* != 0, interrupt is shared */
	u08bits	ci_IntrActive;		/* != 0, interrupt processing active */
	u08bits	ci_InterruptVector;	/* Interrupt Vector Number */
	u08bits	ci_InterruptType;	/* Interrupt Mode: Edge/Level */
	u32bits	ci_MaxCmds;		/* Max # Concurrent commands supported*/
/* 0x30 */
	u32bits	ci_ActiveCmds;		/* # commands active on cntlr */
	u32bits	ci_MaxDataTxSize;	/* Max data transfer size in bytes */
	u32bits	ci_MaxSCDBTxSize;	/* Max SCDB transfer size in bytes */
	u32bits  ci_DoorBellSkipped;	/* # door bell skipped to send cmd */
/* 0x40 */
	UINT_PTR ci_irq;			/* system's IRQ, may be vector */
	UINT_PTR ci_MailBox;		/* Mail Box starting address */
/* 0x50 */
	UINT_PTR ci_CmdIDStatusReg;	/* Command ID and Status Register */
	UINT_PTR ci_BmicIntrMaskReg;	/* BMIC interrupt mask register */
/* 0x60 */
	UINT_PTR ci_DacIntrMaskReg;	/* DAC  interrupt mask register */
	UINT_PTR ci_LocalDoorBellReg;	/* Local Door Bell register */
/* 0x70 */
	UINT_PTR ci_SystemDoorBellReg;	/* System Door Bell register */
	UINT_PTR ci_IOBaseAddr;		/* IO Base Address */
/* 0x80 */
	UINT_PTR ci_BaseAddr;		/* Physical IO/Memory Base Address */
	UINT_PTR ci_MemBasePAddr;	/* Physical Memory Base Address */
/* 0x90 */
	UINT_PTR ci_MemBaseVAddr;	/* Virtual  Memory Base Address */
	UINT_PTR ci_BIOSAddr;		/* Adapter BIOS Address */
/* 0xA0 */
	u32bits	ci_BaseSize;		/* Physical IO/Memory Base size */
	u32bits	ci_IOBaseSize;		/* IO/Memory space size */
	u32bits	ci_MemBaseSize;		/* IO/Memory space size */
	u32bits	ci_BIOSSize;		/* BIOS size */
/* 0xB0 */
	u32bits	ci_SCDBDone;		/* # SCDB done */
	u32bits	ci_SCDBDoneBig;		/* # SCDB done larger size */
	u32bits	ci_SCDBWaited;		/* # SCDB waited for turn */
	u32bits	ci_SCDBWaiting;		/* # SCDB waiting for turn */
/* 0xC0 */
	u32bits	ci_CmdsDone;		/* # Read/Write commands done */
	u32bits	ci_CmdsDoneBig;		/* # R/W Cmds done larger size*/
	u32bits	ci_CmdsWaited;		/* # R/W Cmds waited for turn */
	u32bits	ci_CmdsWaiting;		/* # R/W Cmds waiting for turn */
/* 0xD0 */
	u32bits	ci_OSCmdsWaited;	/* # OS Cmds waited at OS */
	u32bits	ci_OSCmdsWaiting;	/* # OS R/W Cmds waiting for turn */
	u16bits	ci_IntrsDoneSpurious;	/* # interrupts done spurious */
	u16bits	ci_CmdsDoneSpurious;	/* # commands done spurious */
	u32bits	ci_IntrsDone;		/* # Interrupts done */
/* 0xE0 */
	u32bits	ci_PhysDevTestDone;	/* # Physical device test done*/
	u08bits	ci_CmdTimeOutDone;	/* # Command time out done */
	u08bits	ci_CmdTimeOutNoticed;	/* # Command time out noticed */
	u08bits	ci_MailBoxTimeOutDone;	/* # Mail Box time out done */
	u08bits	ci_Reserved2;
	u32bits	ci_MailBoxCmdsWaited;	/* # cmds waited due to MailBox Busy */
	u32bits	ci_IntrsDoneWOCmd;	/* # Interrupts done without command */
/* 0xF0 */
	u08bits	ci_MinorBIOSVersion;	/* BIOS Minor Version Number */
	u08bits	ci_MajorBIOSVersion;	/* BIOS Major Version Number */
	u08bits	ci_InterimBIOSVersion;	/* interim revs A, B, C, etc. */
	u08bits	ci_BIOSVendorName;	/* vendor name */
	u08bits	ci_BIOSBuildMonth;	/* BIOS Build Date - Month */
	u08bits	ci_BIOSBuildDate;	/* BIOS Build Date - Date */
	u08bits	ci_BIOSBuildYearMS;	/* BIOS Build Date - Year */
	u08bits	ci_BIOSBuildYearLS;	/* BIOS Build Date - Year */
	u16bits	ci_BIOSBuildNo;		/* BIOS Build Number */
	u16bits	ci_FWBuildNo;		/* FW Build Number */
	u32bits	ci_SpuriousCmdStatID;	/* Spurious command status and ID */
/* 0x100 */
	u08bits	ci_ControllerName[USCSI_PIDSIZE]; /* controller name */
/* 0x110 */
	UINT_PTR 	MLXFAR *ci_Ctp;
	u08bits	ci_PDScanChannelNo;	/* physical device scan channel no */
	u08bits	ci_PDScanTargetID;	/* physical device scan target ID */
	u08bits	ci_PDScanLunID;		/* physical device scan LUN ID */
	u08bits	ci_PDScanValid;		/* Physical device scan is valid if non zero */
	u32bits	ci_Reserved2A;
/* 0x120 */
	u32bits	ci_Reserved2B;
	u32bits	ci_Reserved2C;
	u32bits	ci_Reserved2D;
	u32bits	ci_Reserved2E;
	u32bits	ci_Reserved2F;
} mda_controller_info_t;
#define	mda_controller_info_s	sizeof(mda_controller_info_t)

#else
typedef struct mda_controller_info
{
	u32bits	ci_ErrorCode;		/* Non zero if data is not valid */
	u32bits	ci_Status;		/* Controller status */
	u32bits	ci_OSCap;		/* Capability for OS */
	u32bits	ci_vidpid;		/* PCI device id + product id */

	u08bits	ci_ControllerType;	/* type of controller */
	u08bits	ci_ControllerNo;	/* IO: adapter number */
	u08bits	ci_BusNo;		/* System Bus No, HW is sitting on */
	u08bits	ci_BusType;		/* System Bus Interface Type */

	u08bits	ci_FuncNo;		/* PCI function number */
	u08bits	ci_SlotNo;		/* System EISA/PCI/MCA Slot Number */
	u08bits	ci_TimeTraceEnabled;	/* !=0 if time trace enabled */
	u08bits	ci_FWTurnNo;		/* firmware turn number */

	u08bits	ci_BIOSHeads;		/* # heads for BIOS */
	u08bits	ci_BIOSTrackSize;	/* # sectors per track for BIOS */
	u16bits	ci_Reserved1;
	u32bits	ci_FreeCmdIDs;		/* # free command IDs */

	u08bits	ci_MaxChannels;		/* Maximum Channels present */
	u08bits	ci_MaxTargets;		/* Max # Targets/Channel supported */
	u08bits	ci_MaxLuns;		/* Max # LUNs/Target supported */
	u08bits	ci_MaxSysDevs;		/* Max # Logical Drives supported */
	u16bits	ci_MaxTags;		/* Maximum Tags supported */
	u16bits	ci_FWVersion;		/* Firmware Version Number */

	u32bits	ci_irq;			/* system's IRQ, may be vector */
	u08bits	ci_IntrShared;		/* != 0, interrupt is shared */
	u08bits	ci_IntrActive;		/* != 0, interrupt processing active */
	u08bits	ci_InterruptVector;	/* Interrupt Vector Number */
	u08bits	ci_InterruptType;	/* Interrupt Mode: Edge/Level */

	u32bits	ci_MaxCmds;		/* Max # Concurrent commands supported*/
	u32bits	ci_ActiveCmds;		/* # commands active on cntlr */
	u32bits	ci_MaxDataTxSize;	/* Max data transfer size in bytes */
	u32bits	ci_MaxSCDBTxSize;	/* Max SCDB transfer size in bytes */

	u32bits	ci_MailBox;		/* Mail Box starting address */
	u32bits	ci_CmdIDStatusReg;	/* Command ID and Status Register */
	u32bits	ci_BmicIntrMaskReg;	/* BMIC interrupt mask register */
	u32bits	ci_DacIntrMaskReg;	/* DAC  interrupt mask register */

	u32bits	ci_LocalDoorBellReg;	/* Local Door Bell register */
	u32bits	ci_SystemDoorBellReg;	/* System Door Bell register */
	u32bits	ci_DoorBellSkipped;	/* # door bell skipped to send cmd */
	u32bits	ci_IOBaseAddr;		/* IO Base Address */

	u32bits	ci_BaseAddr;		/* Physical IO/Memory Base Address */
	u32bits	ci_BaseSize;		/* Physical IO/Memory Base size */
	u32bits	ci_MemBasePAddr;	/* Physical Memory Base Address */
	u32bits	ci_MemBaseVAddr;	/* Virtual  Memory Base Address */

	u32bits	ci_IOBaseSize;		/* IO/Memory space size */
	u32bits	ci_MemBaseSize;		/* IO/Memory space size */
	u32bits	ci_BIOSAddr;		/* Adapter BIOS Address */
	u32bits	ci_BIOSSize;		/* BIOS size */

	u32bits	ci_SCDBDone;		/* # SCDB done */
	u32bits	ci_SCDBDoneBig;		/* # SCDB done larger size */
	u32bits	ci_SCDBWaited;		/* # SCDB waited for turn */
	u32bits	ci_SCDBWaiting;		/* # SCDB waiting for turn */

	u32bits	ci_CmdsDone;		/* # Read/Write commands done */
	u32bits	ci_CmdsDoneBig;		/* # R/W Cmds done larger size*/
	u32bits	ci_CmdsWaited;		/* # R/W Cmds waited for turn */
	u32bits	ci_CmdsWaiting;		/* # R/W Cmds waiting for turn */

	u32bits	ci_OSCmdsWaited;	/* # OS Cmds waited at OS */
	u32bits	ci_OSCmdsWaiting;	/* # OS R/W Cmds waiting for turn */
	u16bits	ci_IntrsDoneSpurious;	/* # interrupts done spurious */
	u16bits	ci_CmdsDoneSpurious;	/* # commands done spurious */
	u32bits	ci_IntrsDone;		/* # Interrupts done */

	u32bits	ci_PhysDevTestDone;	/* # Physical device test done*/
	u08bits	ci_CmdTimeOutDone;	/* # Command time out done */
	u08bits	ci_CmdTimeOutNoticed;	/* # Command time out noticed */
	u08bits	ci_MailBoxTimeOutDone;	/* # Mail Box time out done */
	u08bits	ci_Reserved2;
	u32bits	ci_MailBoxCmdsWaited;	/* # cmds waited due to MailBox Busy */
	u32bits	ci_IntrsDoneWOCmd;	/* # Interrupts done without command */

	u08bits	ci_MinorBIOSVersion;	/* BIOS Minor Version Number */
	u08bits	ci_MajorBIOSVersion;	/* BIOS Major Version Number */
	u08bits	ci_InterimBIOSVersion;	/* interim revs A, B, C, etc. */
	u08bits	ci_BIOSVendorName;	/* vendor name */
	u08bits	ci_BIOSBuildMonth;	/* BIOS Build Date - Month */
	u08bits	ci_BIOSBuildDate;	/* BIOS Build Date - Date */
	u08bits	ci_BIOSBuildYearMS;	/* BIOS Build Date - Year */
	u08bits	ci_BIOSBuildYearLS;	/* BIOS Build Date - Year */
	u16bits	ci_BIOSBuildNo;		/* BIOS Build Number */
	u16bits	ci_FWBuildNo;		/* FW Build Number */
	u32bits	ci_SpuriousCmdStatID;	/* Spurious command status and ID */

	u08bits	ci_ControllerName[USCSI_PIDSIZE]; /* controller name */

					/* physical device scan information */
	u08bits	ci_PDScanChannelNo;	/* physical device scan channel no */
	u08bits	ci_PDScanTargetID;	/* physical device scan target ID */
	u08bits	ci_PDScanLunID;		/* physical device scan LUN ID */
	u08bits	ci_PDScanValid;		/* Physical device scan is valid if non zero */
	u32bits	MLXFAR *ci_Ctp;
	u32bits	ci_Reserved2A;
	u32bits	ci_Reserved2B;

	u32bits	ci_Reserved2C;
	u32bits	ci_Reserved2D;
	u32bits	ci_Reserved2E;
	u32bits	ci_Reserved2F;
} mda_controller_info_t;
#define	mda_controller_info_s	sizeof(mda_controller_info_t)

#endif /* _WIN64 */

/*
** Time Trace operation.
** Enable/Disable Time tracing information for one controller
** mda_timetrace_info_t tti;
**
** tti.tti_ControllerNo = 0;
** tti.tti_MaxEnts = 10000;
** if (ioctl(gfd,MDACIOC_ENABLECTLTIMETRACE,&tti) || tti.tti_ErrorCode)
**	return some_error;
**
** tti.tti_ControllerNo = 1;
** if (ioctl(gfd,MDACIOC_DISABLECTLTIMETRACE,&tti) || tti.tti_ErrorCode)
**	return some_error;
**
** tti.tti_MaxEnts = 17000;
** if (ioctl(gfd,MDACIOC_ENABLEALLTIMETRACE,&tti) || tti.tti_ErrorCode)
**	return some_error;
**
** if (ioctl(gfd,MDACIOC_DISBLEALLTIMETRACE,&tti) || tti.tti_ErrorCode)
**	return some_error;
**
** if (ioctl(gfd,MDACIOC_FLUSHALLTIMETRACEDATA,&tti) || tti.tti_ErrorCode)
**	return some_error;
**
** tti.tti_Datap = buffer address;
** if (ioctl(gfd,MDACIOC_FIRSTIMETRACESIZE,&tti) || tti.tti_ErrorCode)
**	return some_error;
**
** tti.tti_PageNo = 1024;
** tti.tti_Datap = buffer address;
** if (ioctl(gfd,MDACIOC_GETIMETRACEDATA,&tti) || tti.tti_ErrorCode)
**	return some_error;
**
** Wait until some data become available.
** tti.tti_PageNo = 700;
** tti.tti_TimeOut = 17;
** tti.tti_Datap = buffer address;
** if (ioctl(gfd,MDACIOC_WAITIMETRACEDATA,&tti) || tti.tti_ErrorCode)
**	return some_error;
*/
#define	MDACIOC_ENABLECTLTIMETRACE	_MLXIOWR(MIOC,3,mda_timetrace_info_t)
#define	MDACIOC_DISABLECTLTIMETRACE	_MLXIOWR(MIOC,4,mda_timetrace_info_t)
#define	MDACIOC_ENABLEALLTIMETRACE	_MLXIOWR(MIOC,5,mda_timetrace_info_t)
#define	MDACIOC_DISABLEALLTIMETRACE	_MLXIOWR(MIOC,6,mda_timetrace_info_t)
#define	MDACIOC_FIRSTIMETRACEDATA	_MLXIOWR(MIOC,7,mda_timetrace_info_t)
#define	MDACIOC_GETIMETRACEDATA		_MLXIOWR(MIOC,8,mda_timetrace_info_t)
#define	MDACIOC_WAITIMETRACEDATA	_MLXIOWR(MIOC,9,mda_timetrace_info_t)
#define	MDACIOC_FLUSHALLTIMETRACEDATA	_MLXIOWR(MIOC,10,mda_timetrace_info_t)
/* structure for time trace information */
typedef	struct	mda_timetrace
{
	u08bits	tt_ControllerNo;/* Controller Number */
	u08bits	tt_DevNo;	/* SysDev/channel&Target */
	u08bits	tt_OpStatus;	/* Operation status bits */
	u08bits	tt_Cmd;		/* DAC/SCSI command */
	u32bits	tt_FinishTime;	/* Finish Time in 10ms from system start */
	u16bits	tt_HWClocks;	/* Time in HW clocks or 10ms */
	u16bits	tt_IOSizeBlocks;/* Request size in 512 bytes blocks */
	u32bits	tt_BlkNo;	/* Block number of request */
} mda_timetrace_t;
#define	mda_timetrace_s	sizeof(mda_timetrace_t)

/* tt_OpStatus bits */
#define	MDAC_TTOPS_READ		0x01 /* is same as B_READ, =0 for write */
#define	MDAC_TTOPS_ERROR	0x02 /* there was error on the request */
#define	MDAC_TTOPS_RESID	0x04 /* there was residue on the request */
#define	MDAC_TTOPS_SCDB		0x08 /* request was SCSI cdb */
#define	MDAC_TTOPS_WITHSG	0x10 /* request was with SG List */
#define	MDAC_TTOPS_HWCLOCKS10MS	0x20 /* tt_HWClocks value is 10ms */

#ifndef _WIN64
/* ioctl structure to control the tracing */
typedef	struct	mda_timetrace_info
{
	u32bits	tti_ErrorCode;	/* O: Non zero if data is not valid */
	u32bits	tti_PageNo;	/* IO: page number */
	u32bits	tti_DataSize;	/* O: #Entries present */
	u08bits MLXFAR *tti_Datap;/*IO: Data buffer */
	u08bits	tti_Reserved0;
	u08bits	tti_ControllerNo;/*IO: only enable and disable */
	u16bits	tti_TimeOut;	/* IO: in secs for WAIT ops, =0 no limit */
	u32bits	tti_time;	/* O: time in seconds from 1970 */
	u32bits	tti_ticks;	/* O: time in ticks (100/second) */
	u16bits	tti_hwclocks;	/* O: timer clock running at 1193180 Hz */
	u16bits	tti_Reserved1;

	u32bits	tti_MaxEnts;	/* IO: max# trace entries  for enable/disable */
	u32bits	tti_LastPageNo;	/* Last page number available */
	u32bits	tti_Reserved2;
	u32bits	tti_Reserved3;

	u32bits	tti_Reserved10;
	u32bits	tti_Reserved11;
	u32bits	tti_Reserved12;
	u32bits	tti_Reserved13;
} mda_timetrace_info_t;
#else
/* ioctl structure to control the tracing */
typedef	struct	mda_timetrace_info
{
	u32bits	tti_ErrorCode;	/* O: Non zero if data is not valid */
	u32bits	tti_PageNo;	/* IO: page number */
/* switch these next two fields around for 64-bit alignment */
	u08bits MLXFAR *tti_Datap;/*IO: Data buffer */
	u32bits	tti_DataSize;	/* O: #Entries present */

	u08bits	tti_Reserved0;
	u08bits	tti_ControllerNo;/*IO: only enable and disable */
	u16bits	tti_TimeOut;	/* IO: in secs for WAIT ops, =0 no limit */
	u32bits	tti_time;	/* O: time in seconds from 1970 */
	u32bits	tti_ticks;	/* O: time in ticks (100/second) */
	u16bits	tti_hwclocks;	/* O: timer clock running at 1193180 Hz */
	u16bits	tti_Reserved1;

	u32bits	tti_MaxEnts;	/* IO: max# trace entries  for enable/disable */
	u32bits	tti_LastPageNo;	/* Last page number available */
	u32bits	tti_Reserved2;
	u32bits	tti_Reserved3;

	u32bits	tti_Reserved10;
	u32bits	tti_Reserved11;
	u32bits	tti_Reserved12;
	u32bits	tti_Reserved13;
} mda_timetrace_info_t;
#endif /* if _WIN64 */

#define	mda_timetrace_info_s	sizeof(mda_timetrace_info_t)

/*
** Driver  Version Number format
**
** dga_driver_version_t vn;
** if (ioctl(gfd,MDACIOC_GETDRIVERVERSION,&vn) || vn.dv_ErrorCode)
**	return some_error;
*/
#define	MDACIOC_GETDRIVERVERSION	_MLXIOR(MIOC,10,dga_driver_version_t)

/*
** SCSI Physical Device Status Information
**
** mda_physdev_stat_t pds;
** pds.pds_ControllerNo = 0;
** pds.pds_ChannelNo = 1;
** pds.pds_TargetID = 5;
** pds.pds_LunID = 0;
** if (ioctl(gfd,MDACIOC_GETPHYSDEVSTAT,&pds) || pds.pds_ErrorCode)
**	return some_error;
**
*/
#define	MDACIOC_GETPHYSDEVSTAT		_MLXIOWR(MIOC,11,mda_physdev_stat_t)
typedef struct mda_physdev_stat
{
	u32bits	pds_ErrorCode;		/* Non zero if data is not valid */

	u08bits	pds_ControllerNo;	/* IO: Controller Number */
	u08bits	pds_ChannelNo;		/* IO: SCSI Channel Number */
	u08bits	pds_TargetID;		/* IO: SCSI Target ID */
	u08bits	pds_LunID;		/* IO: SCSI LUN ID */

	u08bits	pds_Status;		/* device status */
	u08bits	pds_DevType;		/* SCSI device type */
	u08bits	pds_BlkSize;		/* Device block size in 512 multiples */
	u08bits	pds_Reserved0;

	u32bits	pds_Reserved10;		/* Reserved to make 16 byte alignment */
} mda_physdev_stat_t;
#define	mda_physdev_stat_s	sizeof(mda_physdev_stat_t)

/* get system information
**
** mda_sysinfo_t si;
** if (ioctl(gfd,MDACIOC_GETSYSINFO,&si) || si.si_ErrorCode)
**	return some_error;
** to set the field information, one must give the si_SetOffset value which
** offset of the field for which parameter has to be set.
** si.si_TotalCmdsToWaitForZeroIntr = 10;
** si.si_SetOffset = offsetof (mda_sysinfo_t, si_TotalCmdsToWaitForZeroIntr);
** if (ioctl(gfd,MDACIOC_SETSYSINFO,&si) || si.si_ErrorCode)
**	return some_error;
*/
#define	MDACIOC_SETSYSINFO	_MLXIOW(MIOC,11,mda_sysinfo_t)
#define	MDACIOC_GETSYSINFO	_MLXIOR(MIOC,12,mda_sysinfo_t)
typedef struct mda_sysinfo
{
	u32bits	si_ErrorCode;		/* Non zero if data is not valid */
	u32bits	si_Controllers;		/* # controllers */
	u32bits	si_TooManyControllers;	/* # too many controllers in system */
	u32bits	si_MemAlloced;		/* memory allocated non 4KB&8KB(bytes)*/

	u32bits	si_MemAlloced4KB;	/* memory allocated in 4KB (in bytes)*/
	u32bits	si_MemAlloced8KB;	/* memory allocated in 8KB (in bytes)*/
	u32bits	si_FreeMemSegs4KB;	/* # free 4KB memory segments */
	u32bits	si_FreeMemSegs8KB;	/* # free 8KB memory segments */

	u32bits	si_MemUnAligned4KB;	/* # unaligned 4KB memory allocated */
	u32bits	si_MemUnAligned8KB;	/* # unaligned 8KB memory allocated */
	u32bits	si_CurTime;		/* # seconds from system start */
	u32bits	si_ttCurTime;		/* current time in 10 ms for time trace */

	u32bits	si_StrayIntrsDone;	/* # Stray interrupts done */
	u32bits	si_IoctlsDone;		/* # ioctl calls done */
	u32bits	si_TimerDone;		/* # timer done */
	u32bits	si_TimeTraceDone;	/* # time trace done */

	u32bits	si_ReqBufsAlloced;	/* # Request buffer allocated */
	u32bits	si_ReqBufsFree;		/* # request buffers free */
	u32bits	si_OSReqBufsAlloced;	/* # OS Request buffer allocated */
	u32bits	si_OSReqBufsFree;	/* # OS request buffers free */

	u08bits	si_PDScanControllerNo;	/* Physical device scan controller no */
	u08bits	si_PDScanChannelNo;	/* physical device scan channel no */
	u08bits	si_PDScanTargetID;	/* physical device scan target ID */
	u08bits	si_PDScanLunID;		/* physical device scan LUN ID */
	u08bits	si_PDScanValid;		/* Physical device scan is valid if non zero */
	u08bits	si_PDScanCancel;	/* if non zero Cancel the Scan process */
	u16bits	si_SizeLimits;		/* # device size limit enteries */
	u32bits	si_ttCurPage;		/* Current time trace collection page */
	u32bits	si_ttWaitCnts;		/* number of processes waiting */

	u08bits	si_RevStr[16];		/* Driver Revision String */
	u08bits	si_DateStr[16];		/* Driver build date string */

	u32bits	si_PLDevs;		/* # physical/logical devices */
	u32bits	si_TooManyPLDevs;	/* Too many physical/logical devices */
	u32bits	si_ClustCmdsDone;	/* # clustered command completion done*/
	u32bits	si_ClustCompDone;	/* # clustered completion done */

	u64bits	si_LockWaitLoopDone;	/* # times lock loop wait done */
	u32bits	si_LockWaitDone;	/* # time locking has to wait */
	u08bits	si_PCIMechanism;	/* PCI Mechanism available */
	u08bits	si_TotalCmdsToWaitForZeroIntr;
	u08bits	si_TotalCmdsSentSinceLastIntr; /* # of cmds sent since last intr */
	u08bits	si_Reserved27;

	u32bits	si_SetOffset;		/* offset field value to set the parameter */
	u32bits	si_Reserved29;
	u32bits	si_Reserved2A;
	u32bits	si_Reserved2B;

	u32bits	si_Reserved2C;
	u32bits	si_Reserved2D;
	u32bits	si_Reserved2E;
	u32bits	si_Reserved2F;

	u32bits	si_Reserved30;
	u32bits	si_Reserved31;
	u32bits	si_Reserved32;
	u32bits	si_Reserved33;

	u32bits	si_Reserved34;
	u32bits	si_Reserved35;
	u32bits	si_Reserved36;
	u32bits	si_Reserved37;

	u32bits	si_Reserved38;
	u32bits	si_Reserved39;
	u32bits	si_Reserved3A;
	u32bits	si_Reserved3B;

	u32bits	si_Reserved3C;
	u32bits	si_Reserved3D;
	u32bits	si_Reserved3E;
	u32bits	si_Reserved3F;
} mda_sysinfo_t;
#define	mda_sysinfo_s		sizeof(mda_sysinfo_t)

/* define mda_sysi as mda_sysinfo_t and use the following variable names */
#define	mda_Controllers		mda_sysi.si_Controllers
#define	mda_TooManyControllers	mda_sysi.si_TooManyControllers
#define	mda_MemAlloced		mda_sysi.si_MemAlloced
#define	mda_MemAlloced4KB	mda_sysi.si_MemAlloced4KB
#define	mda_MemAlloced8KB	mda_sysi.si_MemAlloced8KB
#define	mda_MemUnAligned4KB	mda_sysi.si_MemUnAligned4KB
#define	mda_MemUnAligned8KB	mda_sysi.si_MemUnAligned8KB
#define	mda_FreeMemSegs4KB	mda_sysi.si_FreeMemSegs4KB
#define	mda_FreeMemSegs8KB	mda_sysi.si_FreeMemSegs8KB
#define	mda_StrayIntrsDone	mda_sysi.si_StrayIntrsDone
#define	mda_IoctlsDone		mda_sysi.si_IoctlsDone
#define	mda_TimerDone		mda_sysi.si_TimerDone
#define	mda_CurTime		mda_sysi.si_CurTime
#define	mda_SizeLimits		mda_sysi.si_SizeLimits
#define	mda_ttCurTime		mda_sysi.si_ttCurTime
#define	mda_TimeTraceDone	mda_sysi.si_TimeTraceDone
#define	mda_ReqBufsAlloced	mda_sysi.si_ReqBufsAlloced
#define	mda_ReqBufsFree		mda_sysi.si_ReqBufsFree
#define	mda_OSReqBufsAlloced	mda_sysi.si_OSReqBufsAlloced
#define	mda_OSReqBufsFree	mda_sysi.si_OSReqBufsFree
#define	mda_PDScanControllerNo	mda_sysi.si_PDScanControllerNo
#define	mda_PDScanChannelNo	mda_sysi.si_PDScanChannelNo
#define	mda_PDScanTargetID	mda_sysi.si_PDScanTargetID
#define	mda_PDScanLunID		mda_sysi.si_PDScanLunID
#define	mda_PDScanValid		mda_sysi.si_PDScanValid
#define	mda_PDScanCancel	mda_sysi.si_PDScanCancel
#define	mda_ttCurPage		mda_sysi.si_ttCurPage
#define	mda_ttWaitCnts		mda_sysi.si_ttWaitCnts
#define	mda_RevStr		mda_sysi.si_RevStr
#define	mda_DateStr		mda_sysi.si_DateStr
#define	mda_PLDevs		mda_sysi.si_PLDevs
#define	mda_TooManyPLDevs	mda_sysi.si_TooManyPLDevs
#define	mda_ClustCmdsDone	mda_sysi.si_ClustCmdsDone
#define	mda_ClustCompDone	mda_sysi.si_ClustCompDone
#define	mda_LockWaitDone	mda_sysi.si_LockWaitDone
#define	mda_LockWaitLoopDone	mda_sysi.si_LockWaitLoopDone
#define	mda_PCIMechanism	mda_sysi.si_PCIMechanism
#define	mda_TotalCmdsToWaitForZeroIntr	mda_sysi.si_TotalCmdsToWaitForZeroIntr
#define mda_TotalCmdsSentSinceLastIntr 	mda_sysi.si_TotalCmdsSentSinceLastIntr

/*
** setup ucmd_DataSize, ucmd_Datap, ucmd_ControllerNo, ucmd_TrnasferType and
** ucmd_cmd. do ioctl call and check ioctl return, ucmd_ErrorCode, ucmd_Status
** for non zero value as error. Make sure data size is not more than 4KB.
*/
#define	MDACIOC_USER_CMD	_MLXIOWR(MIOC,13,mda_user_cmd_t) /*send command*/
#define	MDACA_MAXUSERCMD_DATASIZE 4096 /* maximum possible transfer size */
typedef	struct mda_user_cmd
{
	u32bits	ucmd_ErrorCode;		/* Non zero if data is not valid */
	u32bits	ucmd_DataSize;		/* IO: data size for the command */
	u08bits	MLXFAR *ucmd_Datap;	/* IO: data address */
	u08bits	ucmd_ControllerNo;	/* IO: Controller number */
	u08bits	ucmd_TransferType;	/* IO: db_TransferType in dac960if.h */
	u16bits	ucmd_Status;		/* completion status */
	u32bits	ucmd_TimeOut;		/* command time out value in seconds */
	u32bits	ucmd_Rserved0;
	u32bits	ucmd_Rserved1;
	u32bits	ucmd_Rserved2;

	dac_command_t ucmd_cmd;		/* IO: user_cmd information */
} mda_user_cmd_t;
#define	mda_user_cmd_s	sizeof(mda_user_cmd_t)

/*
** setup uncmd_DataSize, uncmd_Datap, uncmd_Sensep,
** uncmd_ControllerNo, uncmd_ChannelNo, uncmd_TargetID, uncmd_LunID,
** uncmd_TrnasferType, uncmd_TimeOut.
**
** Fill the following fields from mdac_commandnew_t structure:
** nc_Command, nc_CCBits, nc_SenseSize, nc_CdbLen, nc_Cdb. If nc_CdbLen is more
** than 10 bytes, nc_Cdb[2...9] points to the actual CDB address.
**
** Do ioctl call and check ioctl return, ucmd_ErrorCode, ucmd_Status
** for non zero value as error. Make sure data size is not more than 4KB.
**
** NOTE:
** Old SCSI CDB: sending SCSI CDB to old command interface is same as
** new command interface. The DAC/GAM driver does the appropriate translation.
** Old DCMD : Use the old interface.
*/
#define	MDACIOC_USER_NCMD	_MLXIOWR(MIOC,14,mda_user_cmd_t) /*send command*/
#define	MDACA_MAXUSERNCMD_DATASIZE 4096 /* maximum possible transfer size */
typedef	struct mda_user_ncmd
{
	u32bits	uncmd_ErrorCode;	/* Non zero if data is not valid */
	u32bits	uncmd_DataSize;		/* IO: data size for the command */
	u32bits	uncmd_TimeOut;		/* IO: command time out value in seconds */

	u08bits	uncmd_ControllerNo;	/* IO: Controller number */
	u08bits	uncmd_ChannelNo;	/* IO: Channel number of physical device */
	u08bits	uncmd_TargetID;		/* IO: Physical device Target ID or RAID device number high byte */
	u08bits	uncmd_LunID;		/* IO: Physical device LUN or RAID device number low byte */

	u08bits	uncmd_Reserved0;
	u08bits	uncmd_TransferType;	/* IO: db_TransferType in dac960if.h */
	u16bits	uncmd_Status;		/* completion status */
	u32bits	uncmd_ResdSize;		/* Residue size */

	u32bits	uncmd_Reserved1;
	u32bits	uncmd_Reserved2;

	u08bits	MLXFAR *uncmd_Datap;	/* IO: data address */
	MLX_VA32BITOSPAD(u32bits	uncmd_VReserved10;)
	u08bits	MLXFAR *uncmd_Sensep;	/* IO: Request sense address */
	MLX_VA32BITOSPAD(u32bits	uncmd_VReserved11;)

	u32bits	uncmd_Reserved20;
	u32bits	uncmd_Reserved21;
	u32bits	uncmd_Reserved22;
	u32bits	uncmd_Reserved23;

	mdac_commandnew_t uncmd_ncmd;	/* IO: user_cmd information */
} mda_user_ncmd_t;
#define	mda_user_ncmd_s	sizeof(mda_user_ncmd_t)


/*
** setup ucdb_DataSize, ucdb_Datap, ucdb_ControllerNo, ucdb_ChannelNo,
** ucdb_TargetID, ucdb_LunID, ucdb_TrnasferType and
** ucdb_cdb. do ioctl call and check ioctl return, ucdb_ErrorCode, ucdb_Status
** for non zero value as error. Make sure data size is not more than 4KB.
*/
#define	MDACIOC_USER_CDB _MLXIOWR(MIOC,20,mda_user_cdb_t) /* send SCSI cdb */
#define	MDACA_MAXUSERCDB_DATASIZE 4096 /* maximum possible transfer size */
typedef struct mda_user_cdb
{
	u32bits	ucdb_ErrorCode;		/* Non zero if data is not valid */
	u32bits	ucdb_DataSize;		/* IO: data size for the command */
	u08bits	MLXFAR *ucdb_Datap;	/* IO: data address */
	u08bits	ucdb_ControllerNo;	/* IO: Controller number */
	u08bits	ucdb_ChannelNo;		/* IO: Channel number */
	u08bits	ucdb_TargetID;		/* IO: Target ID */
	u08bits	ucdb_LunID;		/* IO: LUN ID */

	u08bits	ucdb_TransferType;	/* IO: db_TransferType in dac960if.h */
	u08bits	ucdb_Reserved;
	u16bits	ucdb_Status;		/* completion status */

	dac_scdb_t ucdb_scdb;		/* IO: SCSI command */
	u32bits	ucdb_ResdSize;		/* # bytes did not transfer */
} mda_user_cdb_t;
#define	mda_user_cdb_s	sizeof(mda_user_cdb_t)

#define	MDACIOC_STARTHWCLK _MLXIOR(MIOC,27,mda_time_t) /*start timer clock*/
#define MDACIOC_GETSYSTIME _MLXIOR(MIOC,28,mda_time_t) /*get system's time*/
typedef	struct mda_time
{
	u32bits	dtm_ErrorCode;		/* Non zero if data is not valid */
	u32bits	dtm_time;		/* time in seconds from 1970 */
	u32bits	dtm_ticks;		/* time in ticks (100/second) */
	u32bits	dtm_hwclk;		/* timer clock running at 1193180 Hz */
	u64bits	dtm_cpuclk;		/* processor clock counter */
	u32bits	dtm_Reserved10;		/* Reserved to make 16 byte alignment */
	u32bits	dtm_Reserved11;
} mda_time_t;
#define	mda_time_s	sizeof(mda_time_t)

#define	MDACIOC_GETGAMFUNCS	_MLXIOR(MIOC,29,mda_gamfuncs_t)

#ifndef _WIN64
typedef	struct	mda_gamfuncs
{
	u32bits	gf_ErrorCode;		/* Non zero if data is not valid */
	u32bits	(MLXFAR *gf_Ioctl)();	/* ioctl function address */
	u32bits	(MLXFAR *gf_GamCmd)();	/* GAM command function address */
	u32bits	(MLXFAR *gf_ReadWrite)();/* read/write function entry */

	u32bits	gf_MaxIrqLevel;		/* Maximum interrupt request level */
	u32bits	gf_Signature;
	u32bits	gf_MacSignature;
	u32bits	(MLXFAR *gf_GamNewCmd)(); /* GAM command function address for new API */

	u32bits	(MLXFAR *gf_Alloc4KB)();
	u32bits	(MLXFAR *gf_Free4KB)();
	u32bits	(MLXFAR *gf_KvToPhys)();
	u32bits	(MLXFAR *gf_RealGamCmd)(); /* GOK */

	u32bits	MLXFAR *gf_AdpObj;
	u32bits	MLXFAR *gf_Ctp;
	u08bits	gf_CtlNo;
	u08bits	gf_MaxMapReg;
	u08bits	gf_ScsiPort;
	u08bits	gf_ScsiPathId;
	u32bits	(MLXFAR *gf_RealGamNewCmd)(); /* GOK */
} mda_gamfuncs_t;
#define	mda_gamfuncs_s	sizeof(mda_gamfuncs_t)

/* HOTLINKS */
#define	MDACIOC_SETGAMFUNCS	_MLXIOWR(MIOC,37,mda_setgamfuncs_t)
typedef	struct	mda_setgamfuncs
{
	u32bits	gfs_ErrorCode;		/* Non zero if data is not valid */
	u32bits	gfs_Signature;
	u32bits	gfs_MacSignature;
	u32bits	MLXFAR *gfs_Ctp;	

	u08bits	gfs_CtlNo;
	u08bits	gfs_Selector;
	u16bits	gfs_Reserved02;
	u32bits	MLXFAR *gfs_mdacpres;
	u32bits	gfs_gampres;
	u32bits	gfs_Reserved01;
} mda_setgamfuncs_t;
#else
typedef	struct	mda_gamfuncs
{
/* several fields moved around for 64-bit alignment */

	u32bits	gf_ErrorCode;		/* Non zero if data is not valid */
	u32bits	gf_MaxIrqLevel;		/* Maximum interrupt request level */
	u32bits	gf_Signature;
	u32bits	gf_MacSignature;

	u32bits	(MLXFAR *gf_Ioctl)();	/* ioctl function address */
	u32bits	(MLXFAR *gf_GamCmd)();	/* GAM command function address */

	u32bits	(MLXFAR *gf_ReadWrite)();/* read/write function entry */
	u32bits	(MLXFAR *gf_GamNewCmd)(); /* GAM command function address for new API */

	
	u32bits	(MLXFAR *gf_Alloc4KB)();
	u32bits	(MLXFAR *gf_Free4KB)();

	u32bits	(MLXFAR *gf_KvToPhys)();
	u32bits	(MLXFAR *gf_RealGamCmd)(); /* GOK */

	u32bits	MLXFAR *gf_AdpObj;
	u32bits	MLXFAR *gf_Ctp;

	u32bits	(MLXFAR *gf_RealGamNewCmd)(); /* GOK */
	u08bits	gf_CtlNo;
	u08bits	gf_MaxMapReg;
	u08bits	gf_ScsiPort;
	u08bits	gf_ScsiPathId;

} mda_gamfuncs_t;
#define	mda_gamfuncs_s	sizeof(mda_gamfuncs_t)

/* HOTLINKS */
#define	MDACIOC_SETGAMFUNCS	_MLXIOWR(MIOC,37,mda_setgamfuncs_t)
typedef	struct	mda_setgamfuncs
{
	u32bits	gfs_ErrorCode;		/* Non zero if data is not valid */
	u32bits	gfs_Signature;
	u32bits	gfs_MacSignature;
	u08bits	gfs_CtlNo;
	u08bits	gfs_Selector;
	u16bits	gfs_Reserved02;

	u32bits	MLXFAR *gfs_Ctp;
	u32bits	MLXFAR *gfs_mdacpres;


	u32bits	gfs_gampres;
	u32bits	gfs_Reserved01;
} mda_setgamfuncs_t;
#endif /* if _WIN64 */

#define	mda_setgamfuncs_s	sizeof(mda_setgamfuncs_t)
/* HOTLINKS */

#define MDAC_PRESENT_ADDR	0x1
#define GAM_PRESENT		0x2

#define MDA_GAMFUNCS_SIGNATURE		0x4D674661
#define MDA_GAMFUNCS_SIGNATURE_1	0x4D674665
#define MDA_GAMFUNCS_SIGNATURE_2	0x4D674666
#define MDA_MACFUNCS_SIGNATURE		0x4D674662
#define MDA_MACFUNCS_SIGNATURE_1	0x4D674663
#define MDA_MACFUNCS_SIGNATURE_2	0x4D674664
#define MDA_MACFUNCS_SIGNATURE_3	0x4D674665

/*
** Get the controller/system performance data information.
** Set ci_ControllerNo and make ioctl call
** mda_ctlsysperfdata_t prf;
** prf.prf_ControllerNo = 0;
** if (ioctl(gfd,MDACIOC_GETCTLPERFDATA,&prf) || prf.prf_ErrorCode)
**	return some_error;
**
** if (ioctl(gfd,MDACIOC_GETSYSPERFDATA,&prf))
**	return some_error;
*/
#define	MDACIOC_GETCTLPERFDATA	_MLXIOWR(MIOC,30,mda_ctlsysperfdata_t)
#define	MDACIOC_GETSYSPERFDATA	_MLXIOWR(MIOC,31,mda_ctlsysperfdata_t)

typedef struct mda_ctlsysperfdata
{
	u32bits	prf_ErrorCode;		/* Non zero if data is not valid */
	u08bits	prf_ControllerNo;	/* IO: adapter number/# controllers */
	u08bits	prf_CmdTimeOutDone;	/* # Command time out done */
	u08bits	prf_CmdTimeOutNoticed;	/* # Command time out noticed */
	u08bits	prf_MailBoxTimeOutDone;	/* # Mail Box time out done */
	u32bits	prf_MailBoxCmdsWaited;	/* # cmds waited due to MailBox Busy */
	u32bits	prf_ActiveCmds;		/* # commands active on cntlr */

	u32bits	prf_SCDBDone;		/* # SCDB done */
	u32bits	prf_SCDBDoneBig;	/* # SCDB done larger size */
	u32bits	prf_SCDBWaited;		/* # SCDB waited for turn */
	u32bits	prf_SCDBWaiting;	/* # SCDB waiting for turn */

	u32bits	prf_CmdsDone;		/* # Read/Write commands done */
	u32bits	prf_CmdsDoneBig;	/* # R/W Cmds done larger size*/
	u32bits	prf_CmdsWaited;		/* # R/W Cmds waited for turn */
	u32bits	prf_CmdsWaiting;	/* # R/W Cmds waiting for turn */

	u32bits	prf_OSCmdsWaited;	/* # OS Cmds waited at OS */
	u32bits	prf_OSCmdsWaiting;	/* # OS R/W Cmds waiting for turn */
	u32bits	prf_IntrsDoneSpurious;	/* # interrupts done spurious */
	u32bits	prf_IntrsDone;		/* # Interrupts done */

	u32bits	prf_Reads;		/* # reads done */
	u32bits	prf_ReadsKB;		/* data read in KB */
	u32bits	prf_Writes;		/* # writes done */
	u32bits	prf_WritesKB;		/* data written in KB */

	u32bits	prf_time;		/* time in seconds from 1970 */
	u32bits	prf_ticks;		/* time in ticks (100/second) */
	u32bits	prf_Reserved12;
	u32bits	prf_Reserved13;

	u32bits	prf_Reserved14;
	u32bits	prf_Reserved15;
	u32bits	prf_Reserved16;
	u32bits	prf_Reserved17;

	u32bits	prf_Reserved18;
	u32bits	prf_Reserved19;
	u32bits	prf_Reserved1A;
	u32bits	prf_Reserved1B;

	u32bits	prf_Reserved20;
	u32bits	prf_Reserved21;
	u32bits	prf_Reserved22;
	u32bits	prf_Reserved23;

	u32bits	prf_Reserved24;
	u32bits	prf_Reserved25;
	u32bits	prf_Reserved26;
	u32bits	prf_Reserved27;

	u32bits	prf_Reserved28;
	u32bits	prf_Reserved29;
	u32bits	prf_Reserved2A;
	u32bits	prf_Reserved2B;

	u32bits	prf_Reserved2C;
	u32bits	prf_Reserved2D;
	u32bits	prf_Reserved2E;
	u32bits	prf_Reserved2F;

	u32bits	prf_Reserved30;
	u32bits	prf_Reserved31;
	u32bits	prf_Reserved32;
	u32bits	prf_Reserved33;

	u32bits	prf_Reserved34;
	u32bits	prf_Reserved35;
	u32bits	prf_Reserved36;
	u32bits	prf_Reserved37;

	u32bits	prf_Reserved38;
	u32bits	prf_Reserved39;
	u32bits	prf_Reserved3A;
	u32bits	prf_Reserved3B;

	u32bits	prf_Reserved3C;
	u32bits	prf_Reserved3D;
	u32bits	prf_Reserved3E;
	u32bits	prf_Reserved3F;
} mda_ctlsysperfdata_t;
#define	mda_ctlsysperfdata_s	sizeof(mda_ctlsysperfdata_t)

/*
** Get the controller BIOS information.
** Set biosi_ControllerNo and make ioctl call
** mda_biosinfo_t biosi;
** biosi.biosi_ControllerNo = 0;
** if (ioctl(gfd,MDACIOC_GETBIOSINFO,&biosi) || biosi.biosi_ErrorCode)
**	return some_error;
**
*/
#define	MDAC_BIOSINFOSIZE	(MLXIOCPARM_SIZE - 16)
#define	MDACIOC_GETBIOSINFO	_MLXIOWR(MIOC,32,mda_biosinfo_t)

typedef struct mda_biosinfo
{
	u32bits	biosi_ErrorCode;	/* Non zero if data is not valid */
	u08bits	biosi_ControllerNo;	/* IO: adapter number */
	u08bits	biosi_Reserved0;
	u08bits	biosi_Reserved1;
	u08bits	biosi_Reserved2;
	u08bits	biosi_Info[MDAC_BIOSINFOSIZE];	/* dac_biosinfo_t format */
} mda_biosinfo_t;
#define	mda_biosinfo_s	sizeof(mda_biosinfo_t)

/*
** Get valid active command information. This useful to find out which command
** is lost or taking longer time. If the current command is not valid, it finds
** the next one.
** Set acmdi_ControllerNo and make ioctl call
** mda_activecmd_info_t acmdi;
** acmdi.acmdi_ControllerNo = 0;
** acmdi.acmdi_TimeOut=17; command has been active for atleast 17 seconds
** acmdi.CmdID = 0;	start from first command
** if (ioctl(gfd,MDACIOC_GETACTIVECMDINFO,&acmdi) || acmdi.acmdi_ErrorCode)
**	return some_error;
**
*/
#define	MDAC_ACTIVECMDINFOSIZE		(MLXIOCPARM_SIZE - 32)
#define	MDACIOC_GETACTIVECMDINFO	_MLXIOWR(MIOC,33,mda_activecmd_info_t)

typedef struct mda_activecmd_info
{
	u32bits	acmdi_ErrorCode;	/* Non zero if data is not valid */
	u08bits	acmdi_ControllerNo;	/* IO: adapter number */
	u08bits	acmdi_TimeOut;		/* IO: cmd has this many secs delay */
	u16bits	acmdi_CmdID;		/* IO: command id/Index */
	u32bits	acmdi_ActiveTime;	/* time in seconds from boot */
	u32bits	acmdi_Reserved0;

	u08bits	acmdi_Info[MDAC_ACTIVECMDINFOSIZE];	/* mdac_req_t format */
} mda_activecmd_info_t;
#define	mda_activecmd_info_s	sizeof(mda_activecmd_info_t)

/*
** Get PCI configuration information.
** mda_pcislot_info_t mpci;
** mpci.mpci_BusNo = 1;
** mpci.mpci_SlotNo = 2;
** mpci.mpci_FuncNo = 0;
** if (ioctl(gfd,MDACIOC_GETPCISLOTINFO,&mpci) || mpci.mpci_ErrorCode)
**	return some_error;
**
*/
#define	MDAC_PCISLOTINFOSIZE		(MLXIOCPARM_SIZE - 32)
#define	MDACIOC_GETPCISLOTINFO	_MLXIOWR(MIOC,34,mda_pcislot_info_t)

typedef struct mda_pcislot_info
{
	u32bits	mpci_ErrorCode;	/* Non zero if data is not valid */
	u08bits	mpci_BusNo;	/* IO: Bus number */
	u08bits	mpci_SlotNo;	/* IO: Slot Number */
	u08bits	mpci_FuncNo;	/* IO: Function number */
	u08bits	mpci_Reserved0;
	u32bits	mpci_Reserved1;
	u32bits	mpci_Reserved2;

	u08bits	mpci_Info[MDAC_PCISLOTINFOSIZE];	/* PCI information */
} mda_pcislot_info_t;
#define	mda_pcislot_info_s	sizeof(mda_pcislot_info_t)

/*
** scsi device size limit functions
**
** mda_sizelimit_info_t sli;
** sli.sli_TableIndex = 0;
** if (ioctl(gfd,MDACIOC_GETSIZELIMIT,&sli) || sli.sli_ErrorCode)
**	return some_error;
**
** sli.sli_DevSizeKB = 4096;
** gamcopy("Mylex   DAC960PD         2.47",sli.sli_vidpidrev,VIDPIDREVSIZE);
** if (ioctl(gfd,MDACIOC_SETSIZELIMIT,&sli) || sli.sli_ErrorCode)
**	return some_error;
**
*/
#define	MDACIOC_GETSIZELIMIT		_MLXIOWR(MIOC,35,mda_sizelimit_info_t)
#define	MDACIOC_SETSIZELIMIT		_MLXIOWR(MIOC,36,mda_sizelimit_info_t)
/* struct to get/set the device size limit_info table */
typedef	struct	mda_sizelimit_info
{
	u32bits	sli_ErrorCode;		/* Non zero if data is not valid */
	u32bits	sli_TableIndex;		/* IO: Table index */
	u32bits	sli_DevSizeKB;		/* IO: Device size in KB */
	u32bits	sli_Reserved0;

	u32bits	sli_Reserved1;
	u08bits	sli_vidpidrev[VIDPIDREVSIZE]; /* IO: vendor, product, rev */
}mda_sizelimit_info_t;
#define	mda_sizelimit_info_s	sizeof(mda_sizelimit_info_t)


/* MDACIOC provided for MACDISK driver */
#define MDACIOC_GETMACDISKFUNC  _MLXIOR(MIOC,38,mda_macdiskfunc_t)
#define MDACIOC_SETMACDISKFUNC  _MLXIOR(MIOC,39,mda_setmacdiskfunc_t)

typedef	struct	mda_macdiskfunc
{
    u32bits mf_ErrorCode;
	u32bits	mf_MaxIrqLevel;

	u32bits	mf_Signature;
	u32bits	mf_MacSignature;

	u32bits	(MLXFAR *mf_ReadWrite)();   /* ReadWrite entry point in MDAC driver */
    u32bits (MLXFAR *mf_ReservedFunc)();
	
	u32bits	(MLXFAR *mf_Alloc4KB)();
	u32bits	(MLXFAR *mf_Free4KB)();

	u32bits	(MLXFAR *mf_KvToPhys)();
    u32bits (MLXFAR *mf_ReservedFunc2)();

	u32bits	MLXFAR *mf_AdpObj;
	u32bits	MLXFAR *mf_Ctp;

    u32bits (MLXFAR *mf_ReservedFunc3)();
	u08bits	mf_CtlNo;
	u08bits	mf_MaxMapReg;
    u08bits mf_Reserved8bits1;
    u08bits mf_Reserved8bits2;

} mda_macdiskfunc_t;

typedef	struct	mda_setmacdiskfunc
{
    u32bits mfs_ErrorCode;
    u32bits mfs_Reserved;

	u32bits	(MLXFAR *mfs_SpinLock)();
	u32bits	(MLXFAR *mfs_UnLock)();

    u32bits (MLXFAR *mfs_PreLock)();
    u32bits (MLXFAR *mfs_PostLock)();

} mda_setmacdiskfunc_t;

#define	mda_macdiskfunc_s	sizeof(mda_macdiskfunc_t)
#define	mda_setmacdiskfunc_s	sizeof(mda_setmacdiskfunc_t)


#endif	/* _SYS_MDACAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\sys\hppifio.h ===
/**********************************************************************
// Compaq Confidential

  Author:       Compaq Computer Corporation.
		Systems Engineering -- System Software Development (NT Dev)
		Copyright 1996-98 Compaq Computer Corporation.
		All rights reserved.

  Date:         1 August 1996 

  File:         HPPIFIO.H	- Hot Plug Interface IOCTLs Defs

  Purpose:      This file contains all the hot plug IOCTL specific information 
				necessary to interface to a hot plug device driver.
                
				This file details the data structures and Application Programming 
                Interfaces (APIs) for PCI Hot Plug support running in a Windows 
                NT 4.0 server.  These data structures and APIs are used between 
                the Adapter Card drivers and the PCI Hot Plug Service for NT 4.0.  
                These files are considered vital to maintaining the Compatibility 
                of the PCI Hot Plug Functionality.

  Created:		11/4/97		Split off of hppif3p

  Version: 1.0
***********************************************************************/

#ifndef _HPPIFIO_H_
#define _HPPIFIO_H_

#include "hppifevt.h"  // Hot Plug Event Messages.

#pragma pack(1)



//**********************************************************************
//                  IOCTL DEFINITIONS         
//**********************************************************************

//====================================================================
//                      Common Defines & Structs
//====================================================================/

//
// Security defines
//

#define HPP_SECURITY_SIGNATURE  0x53505058      // Service Stop security flag 
						// "HPPS"


//
// Hot Plug OIDs
// Each OID for NICs is relative to a base address value.
// The offset for the specific OID is added to the base value 
// to get the specific OID address value.
//
// The following is a list of OIDs which HPP compliant 
// drivers must respond to.  
//
// These offset values are also used to construct the Completion Codes.
// Each IOCTL has a specific family of completion codes.
//
// *** CAUTION ***
// Always update the 'HPP_IOCTL_COUNT' when adding/deleting IOCTLs.
//
//      Name                                    Offset          Get     Set
//--------------------------------------------------------------------------
#define HPP_IOCTL_RCMC_INFO_OFFSET              0x01    //      X       X
#define HPP_IOCTL_CONTROLLER_INFO_OFFSET        0x02    //      X
#define HPP_IOCTL_CONTROLLER_STATUS_OFFSET      0x03    //      X
#define HPP_IOCTL_SLOT_TYPE_OFFSET              0x04    //      X       X
#define HPP_IOCTL_SLOT_EVENT_OFFSET             0x05    //      X       X
#define HPP_IOCTL_PCI_CONFIG_MAP_OFFSET         0x06    //      X
#define HPP_IOCTL_STOP_RCMC_OFFSET              0x07    //              X
#define HPP_IOCTL_RUN_DIAGS_OFFSET              0x08    //              X

#define HPP_IOCTL_COUNT                         0x08


//
// Completion Codes.
// The following completion codes are defined from the 
// the driver IOCTLS.
//
// Completion codes are broken into families.  Each IOCTL will
// have its own family of completion codes.  This allows for easier
// debug at the cost of some extra code.
//
// The generic form of the completion codes is as follows:
//      0xrrrrIICC
//        --------
//        |   |  |
//        |   |  +-- CC == Individual Completion Code.
//        |   +----- II == IOCTL Offset (see above)
//        +--------- rrrr == Reserved at this time.
//
// Each IOCTL is assigned a specific family code.  All completion
// codes are defined relative to the IOCTL.
//
//  IOCTL               Offset:
//--------------------------------------------------------------------------
//  Service Info        0x000001xx
//  Controller Info     0x000002xx
//  Controller Status   0x000003xx
//  Slot Type           0x000004xx
//  Slot Status         0x000005xx
//  PCI Config Space    0x000006xx
//  Stop RCMC           0x000007xx



//
// Successful completion.  All IOCTLs will return success (HPP_SUCCESS)
// unless something fails.
//


#define HPP_SUCCESS                             0x00000000
#define HPP_INSUFICIENT_BUFFER_SPACE            0x00000001
#define HPP_INVALID_CONTROLLER                  0x00000002

#define HPP_INVALID_SERVICE_STATUS              0x00000101
#define HPP_INVALID_DRIVER_ID                   0x00000102
#define HPP_INVALID_CALLBACK_ADDR               0x00000103

#define HPP_INVALID_SLOT_TYPE                   0x00000401

#define HPP_INVALID_SLOT_EVENT                  0x00000501
#define HPP_INVALID_SIMULATED_FAILURE           0x00000502

#define HPP_DIAGS_NOT_SUPPORTED					0x00000801



//----------------------------------------------------------------------
// Structure Name:      PCI Device/Function number
//
// Description:         Describes a PCI device.
//                      This is a general purpose PCI definition.
//                      It is used by many of the following requests.
//
// Example:             PCI_DESC        PciDescription
//
//                              PciDescription.ucBusNumber
//                              PciDescription.ucPCIDevFuncNum
//                              PciDescription.fcFunctionNumber
//                              PciDescription.fcDeviceNumber
//
// Note:                This structure is used by many IOCTLs.
//---------------------------------------------------------------------

typedef struct  _pci_descriptor
{
  UCHAR ucBusNumber;            // PCI Bus # (0-255)
  union
  {
    struct
    {
      UCHAR fcDeviceNumber:5;   // PCI Device # (0-31)
      UCHAR fcFunctionNumber:3; // PCI Function # (0-7)
    };
    UCHAR   ucPciDevFuncNum;    // Combined Dev and Func #
  };
} PCI_DESC, *PPCI_DESC;




//----------------------------------------------------------------------
// Structure Name:      HPP Controller Identification
//
// Description:         Specifies which controller an IOCTL is referring
//                      to.  HPP IOCTLs can be sent to any driver instance
//                      for any controller (for SCSI miniport).
//
// Note:                This structure is used by many IOCTLs.
//---------------------------------------------------------------------

typedef enum _hpp_controller_id_method
{
    // COMPAQ RESERVES VALUES 0x0 - 0x4 
	HPCID_PCI_DEV_FUNC = 0x5,	 // 5 --  req PciDescriptor field
	HPCID_IO_BASE_ADDR = 0x6     // 6 --  req IOBaseAddress field
} E_HPP_CTRL_ID_METHOD;


typedef struct  _hpp_controller_id
{
  E_HPP_CTRL_ID_METHOD eController;             // Controller Selection
  union
  {
    struct
    {
      PCI_DESC  sPciDescriptor;                 // Used if 'eController'
      USHORT    reserved;                       // is set to: 'PCIDevFunc'
    };
    ULONG ulIOBaseAddress;                      // Used if 'eController'
  };                                            // is set to: 'IOBaseAddress'
} HPP_CTRL_ID, *PHPP_CTRL_ID;


//
// Common 'Template' header which can be applied to all
// Hot Plug PCI IOCTLs.
//

typedef struct  _hpp_common_header              // Get          Set
{                                               // -------------------
	ULONG           ulCompletionStatus;			// Output       Output
	HPP_CTRL_ID     sControllerID;				// Input        Input
} HPP_HDR, *PHPP_HDR;


//====================================================================
//              SPECIFIC IOCTL: STRUCTS
//====================================================================/

//----------------------------------------------------------------------
// Structure Name:      HPP Service Info
//
// Description:         Called by the HPP RCMC to get or set
//                      the HPP's status.
//                      Service will notify when it starts and stops.
//
//                      IOCTL:          HPP_IOCTL_RCMC_INFO_OFFSET
//
//---------------------------------------------------------------------


//
// Service status information.
// The service will call the driver and notify it of
// Service Start and Stop.
//

typedef enum _hpp_rcmc_status
{
	HPRS_UNKNOWN_STATUS,    // 0
	HPRS_SERVICE_STARTING,  // 1
	HPRS_SERVICE_STOPPING,  // 2
} E_HPP_RCMC_STATUS;





// Callback prototype for service async messaging.

typedef 
ULONG 
(*PHR_CALLBACK) (
    PHR_EVENT pEvent
    );

typedef struct _hpp_rcmc_info                           // Get          Set
{                                                       // ------------------
	ULONG                   ulCompletionStatus;     // Output       Output
	HPP_CTRL_ID             sControllerID;          // Input        Input
	E_HPP_RCMC_STATUS       eServiceStatus;         // Output       Input
	ULONG                   ulDriverID;             // Output       Input
	PHR_CALLBACK			vpCallbackAddress;      // Output       Input
	ULONG                   ulCntrlChassis;         // Output       Input
	ULONG                   ulPhysicalSlot;         // Output       Input
} HPP_RCMC_INFO, *PHPP_RCMC_INFO;


//----------------------------------------------------------------------
// Structure Name:      HPP Controller Info
//
// Description:         Called by the HPP RCMC to get 
//                      configuration information of the all controllers
//                      controlled by the instance of the driver.
//
//
//                      IOCTL:          HPP_IOCTL_CONTROLLER_INFO_OFFSET
//
//---------------------------------------------------------------------

//
// Defines for the Support Version
//
//      Version information:
//      0xrrrrMMmm
//      ----------
//          | |  |
//          | |  +-- Minor Version information
//          | +----- Major Version information
//          +------- Currently reserved
//
// The RCMC service will consider minor revisions within the same
// Major version compatible (i.e. all structures are the same size,
// etc.).  If the service encounters an unknown Major Version
// it should consider the interface incompatible.
//

#define SUPPORT_VERSION_10      0x00000100              // Version 1.00


//
// Description of the various support classes
//

typedef enum _hpp_support_class
{
	HPSC_UNKNOWN_CLASS = 0,             // 0
	HPSC_MINIPORT_NIC = 1,              // 1
	HPSC_MINIPORT_STORAGE = 3,          // 3
	HPSC_GNR_MONOLITHIC   = 5,			// 5
	//COMPAQ RESERVES VALUES 0x2, 0x4, 0x6 TO 0xF
} E_HPP_SUPPORT_CLASS;



typedef enum    _hpp_bus_type           // Duplicates of the NT definition
{                                       // Copied from MINIPORT.H
	HPPBT_EISA_BUS_TYPE = 2,
	HPPBT_PCI_BUS_TYPE  = 5,
} E_HPP_BUS_TYPE;


// NIC Miniport
typedef struct _nic_miniport_class_config_info
{
	ULONG   ulPhyType;
	ULONG   ulMaxMediaSpeed;
} NICM_CLASS_CONFIG_INFO, *PNICM_CLASS_COFNIG_INFO;


//
// Address descriptors.
// Used to describe either an IO or Memory Address used
// by the controller.
//

typedef enum    _hpp_addr_type
{
	HPPAT_UNKNOWN_ADDR_TYPE,                // 0
	HPPAT_IO_ADDR,                          // 1 -- IO Port Address
	HPPAT_MEM_ADDR,                         // 2 -- Memory Address
} E_HPP_ADDR_TYPE;

typedef struct  _hpp_ctrl_address_descriptor
{
	BOOLEAN         fValid;                 // TRUE iff entry is valid
	E_HPP_ADDR_TYPE eAddrType;              // IOAddress or Memory
	ULONG           ulStart;                // Starting address
	ULONG           ulLength;               // Length of addresses
} HPP_CTRL_ADDR, *PHPP_CTRL_ADDR;



//
// Definition of the Controller configuration.
//

typedef struct _hpp_controller_config_info
{
	E_HPP_BUS_TYPE  eBusType;               // PCI or EISA
	PCI_DESC        sPciDescriptor;         // Bus #, DevFunc
	ULONG           ulSlotNumber;           // EISA or PCI slot num
	ULONG           ulProductID;            // 32-Bit EISA ID,
											// PCI Vendor or Device ID
	HPP_CTRL_ADDR   asCtrlAddress [16];     // IO/Memory Address
	ULONG           ulIRQ;                  // Controller Interrupt
	UCHAR           szControllerDesc [256]; // Text description
	NICM_CLASS_CONFIG_INFO  sNICM;			// NIC Miniport
} HPP_CTRL_CONFIG_INFO, *PHPP_CTRL_CONFIG_INFO;


//
// Information returned by the Controller Configuration Query.
//

typedef struct _hpp_controller_info                     // Get          Set
{                                                       // ----------------
	ULONG                   ulCompletionStatus;     // Output       Output
	HPP_CTRL_ID             sControllerID;          // Input        N/A
	E_HPP_SUPPORT_CLASS     eSupportClass;          // Output       N/A
	ULONG                   ulSupportVersion;       // Output       N/A
	HPP_CTRL_CONFIG_INFO    sController;            // Output       N/A
} HPP_CTRL_INFO, *PHPP_CTRL_INFO;




//----------------------------------------------------------------------
// Structure Name:      HPP Controller Status
//
// Description:         Called by the HPP RCMC to determine the status
//                      information of the all controllers controlled 
//                      by the instance of the driver.
//
//                      IOCTL:          HPP_IOCTL_CONTROLLER_STATUS_OFFSET
//
//---------------------------------------------------------------------

//
// Information returned by the Controller Status Query.
// Each support class will return different information.
// 

//HOT PLUG DRIVER STATUS Defines

#define HPP_STATUS_NORMAL					0x00
#define HPP_STATUS_ADAPTER_CHECK			0x01
#define HPP_STATUS_LINK_FAILURE				0x02
#define HPP_STATUS_MEDIA_FAILURE			0x03


#define HPP_STATUS_USER_SIMULATED_FAILURE	0x10
#define HPP_STATUS_POWER_OFF_FAULT			0x40
#define HPP_STATUS_ADAPTER_BUSY				0x50



typedef struct _hpp_controller_status           // Get          Set
{                                               // -------------------
	ULONG           ulCompletionStatus;     // Output       Output
	HPP_CTRL_ID     sControllerID;          // Input        N/A
	ULONG           ulStatus;               // Output       N/A
} HPP_CTRL_STATUS, *PHPP_CTRL_STATUS;


//----------------------------------------------------------------------
// Structure Name:      HPP Controller Slot Type
//
// Description:         Called by the HPP RCMC to get or set
//                      what type of slot the controller is installed in.
//
//                      Can also be used to query slot information.
//
//                      IOCTL:          HPP_IOCTL_SLOT_TYPE_OFFSET
//
//---------------------------------------------------------------------

//
// Controller slot type definition
//

typedef enum    _hpp_slot_type
{
	HPPST_UNKNOWN_SLOT,             // 0
	HPPST_NORMAL_SLOT,              // 1 -- Could PCI or EISA
	HPPST_HOTPLUG_PCI_SLOT,         // 2 -- PCI only
} E_HPP_SLOT_TYPE;


typedef struct _hpp_controller_slot_type        // Get          Set
{                                               // -------------------
	ULONG           ulCompletionStatus;     // Output       Output
	HPP_CTRL_ID     sControllerID;          // Input        Input
	E_HPP_SLOT_TYPE eSlotType;              // Output       Input
} HPP_CTRL_SLOT_TYPE, *PHPP_CTRL_SLOT_TYPE;



//----------------------------------------------------------------------
// Structure Name:      HPP Controller Slot Event
//
// Description:         Called by the HPP Service to get or set
//                      the Controller's slot status.
//                                           
//
//                      IOCTL:          HPP_IOCTL_SLOT_EVENT_OFFSET
//
//---------------------------------------------------------------------

//
// Each of the following are mutually exclusive.  If two 
// status events occur simultaneously, the service will serialize
// them to the drivers.
//

typedef enum    _hpp_slot_status
{
	HPPSS_UNKNOWN,          // 0

	HPPSS_NORMAL_OPERATION, // 1    // Restore from Simulated Failure
	HPPSS_SIMULATED_FAILURE,// 2    // Enter Simulated Failure Mode

	HPPSS_POWER_FAULT,      // 3    // Power fault occured, error!!!!

	HPPSS_POWER_OFF_WARNING,// 4    // Power On/Off conditions
	HPPSS_POWER_OFF,        // 5
	HPPSS_POWER_ON_WARNING, // 6
	HPPSS_POWER_ON,         // 7
	//The following defines are for the SCSI miniport drivers
	HPPSS_RESET_WARNING,    // 8    // PCI level slot reset
	HPPSS_RESET,            // 9	
    // Compaq reserves A to F
} E_HPP_SLOT_STATUS;


typedef struct _hpp_slot_event                          // Get          Set
{                                                       // -------------------
	ULONG                   ulCompletionStatus;     // Output       Output
	HPP_CTRL_ID             sControllerID;          // Input        Input
	E_HPP_SLOT_STATUS       eSlotStatus;            // Output       Input
} HPP_SLOT_EVENT, *PHPP_SLOT_EVENT;


//----------------------------------------------------------------------
// Structure Name:      HPP PCI Configuration Map
//
// Description:         Called by the HPP Service to get the
//                      device's PCI configuration map.
//
//                      IOCTL:          HPP_IOCTL_PCI_CONFIG_MAP_OFFSET
//
//---------------------------------------------------------------------



//
// Defines for the Map Version
//
//      Version information:
//      0xrrrrMMmm
//      ----------
//          | |  |
//          | |  +-- Minor Version information
//          | +----- Major Version information
//          +------- Currently reserved
//
// The RCMC service will consider minor revisions within the same
// Major version compatible (i.e. all structures are the same size,
// etc.).  If the service encounters an unknown Major Version
// it should consider the interface incompatible.
//



#define HPP_CONFIG_MAP_VERSION_10       0x00000100      // Version 1.00




typedef struct _hpp_pci_config_range
{
	UCHAR   ucStart;        // Start Offset of PCI config space.
	UCHAR   ucEnd;          // Ending Offset of PCI config space.
	ULONG   ulControlFlags; // RCMC flags, not for driver's use.

	ULONG   ulReserved [4]; // Reserved for Future use
} HPP_PCI_CONFIG_RANGE, *PHPP_PCI_CONFIG_RANGE;

typedef struct _hpp_device_info
{
	PCI_DESC                sPciDescriptor; // Bus Number, Dev/Func #
	ULONG                   ulReserved [4]; // Reserved for Future use.

	UCHAR					ucBaseAddrVerifyCount;	//Number of base address register lengths to verify
	ULONG					ulBaseAddrLength[6];	//Base address lengths for each device
													//the hot plug service verifys the new length on a powered on
													//board to be <= what is saved here by the driver at init
													//The verify is done on each device that has a non-zero count
													//from length[0] to length[count-1]
	ULONG                   ulNumberOfRanges;// Number of ranges for this device
	HPP_PCI_CONFIG_RANGE    sPciConfigRangeDesc [16];
	void *                  pPciConfigSave [16];//used by RCMC service to save config values
												//not for driver's use.
} HPP_DEVICE_INFO, *PHPP_DEVICE_INFO;

typedef struct _hpp_pci_config_map              // Get          Set
{                                               // --------------------
	ULONG           ulCompletionStatus;     // Output       Output
	HPP_CTRL_ID     sControllerID;          // Input        N/A

	ULONG           ulPciConfigMapVersion;  // Output       N/A
	ULONG           ulReserved [4];         // N/A          N/A

	ULONG           ulNumberOfPciDevices;   // Output       N/A
	HPP_DEVICE_INFO sDeviceInfo [3];        // Output       N/A
} HPP_PCI_CONFIG_MAP, *PHPP_PCI_CONFIG_MAP;




//----------------------------------------------------------------------
// Structure Name:      HPP Stop RCMC Service
//
// Description:         Called by an application to request the driver
//                      issue the 'Stop Service' IOCTL to the RCMC.
//
//                      IOCTL:          HPP_IOCTL_STOP_RCMC_OFFSET
//
//---------------------------------------------------------------------

typedef struct  _hpp_stop_service               // Get          Set
{                                               // ---------------------
	ULONG           ulCompletionStatus;     // Output       Output
	HPP_CTRL_ID     sControllerID;          // N/A          Input
	ULONG           ulHppSecuritySignature; // N/A          Input
} HPP_STOP_RCMC, *PHPP_STOP_RCMC;



//----------------------------------------------------------------------
// Structure Name:      HPP Run Diagnostics
//
// Description:         Called by the HPP Service to start diagnostics
//                      on the given controller.
//
//                      The service will request the diags to begin
//						and expect the driver to return immediately with
//						SUCCESS if the diags are supported or with
//						HPP_DIAGS_NOT_SUPPORTED	if diags are not supported.
//
//						Once the diags are completed, the drivers will 
//						send an event via Sysmgmt to inform the service
//						of the outcome of the diags.
//
//                      IOCTL:     #define HPP_IOCTL_RUN_DIAGS_OFFSET              0x08    //              X

//
//---------------------------------------------------------------------

//
// List of modes of diags to run.
//

typedef enum    _hpp_diag_mode
{
	HPPDT_ON_LINE,          // 0
	HPPDT_OFF_LINE,			// 1
} E_HPP_DIAG_MODE;


typedef struct _hpp_start_diags                     // Get          Set
{                                                   // -------------------
	ULONG                   ulCompletionStatus;     // Output       Output
	HPP_CTRL_ID             sControllerID;          // Input        Input
	E_HPP_DIAG_MODE	        eDiagMode;              // Input        Input
} HPP_RUN_DIAGS, *PHPP_RUN_DIAGS;



//----------------------------------------------------------------------
// Structure Name:	SetOIDValue
//
// Description: 	
//
//			NT's miniport architecture doesn't allow
//			an application to issue a 'Set' request
//			to the driver.	This is a very nice and
//			needed functionality.  Therefore we have
//			implemented this jumbo hack.
//			This OID is a 'Get' OID, but it calls the
//			'Set' handler within the driver.  Therefore
//			it will work with whatever OID we support via
//			sets.
//
//			
//---------------------------------------------------------------------

typedef struct _set_oid_value
{
	ULONG	Signature;		
	ULONG	OID;
	PVOID	InformationBuffer;
	ULONG	InformationBufferLength;
	PULONG	BytesRead;
	PULONG	BytesNeeded;
} SET_OID_VALUE, *PSET_OID_VALUE;

//
// 'Security' signature used for the 'Set' OID.  Since this
// is accessed through the 'Get' handler, we don't just want
// anyone using it.
//

#define OID_SECURITY_SIGNATURE                  0x504D4450
#define HPP_OID_BASE_ADDRESS_DEFAULT	        0xff020400
#define OID_NETFLEX3_SET_OID_VALUE_RELATIVE		0xff020316
#define NETFLEX3_OID_SECURITY_SIGNATURE         0x504D4450


#pragma pack()
#endif                  /* End of #ifndef _HPPIF3P_H_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\sys\mdacdrv.h ===
/**************************************************************************
 *                COPYRIGHT (C) Mylex Corporation 1992-1996               *
 *                                                                        *
 * This software is furnished under a license and may be used and copied  * 
 * only in accordance with the terms and conditions of such license and   * 
 * with inclusion of the above copyright notice. This software or any     * 
 * other copies thereof may not be provided or otherwise made available   * 
 * to any other person. No title to, nor ownership of the software is     * 
 * hereby transferred.                                                    *
 *                                                                        *
 * The information in this software is subject to change without notices  *
 * and should not be construed as a commitment by Mylex Corporation       *
 *                                                                        *
 **************************************************************************/

#ifndef _SYS_MDACDRV_H
#define _SYS_MDACDRV_H

#define MDAC_IOSCANTIME         7       /* interval between event scan */
#define MDAC_MAILBOX_POLL_TIMEOUT       0x00100000 /*in 10 Us (10 secs) */
#define MDAC_CMD_POLL_TIMEOUT           0x00400000 /*in 10 Us (40 secs) */

/* convert timeout value in seconds to DAC time out values */
#define mdac_timeout2dactimeout(to) \
        ((to<=10)? DAC_DCDB_TIMEOUT_10sec : \
        ((to<=60)? DAC_DCDB_TIMEOUT_1min : \
        ((to<=60*20)? DAC_DCDB_TIMEOUT_20min : DAC_DCDB_TIMEOUT_1hr) ))

/* convert DAC timeout values to timeout value in seconds */
#define mdac_dactimeout2timeout(to) \
        (((to) == DAC_DCDB_TIMEOUT_10sec)? 10 : \
        (((to) == DAC_DCDB_TIMEOUT_1min)? 60 : \
        (((to) == DAC_DCDB_TIMEOUT_20min)? 20*60 : 60*60) ))

/* the new device number consists of controller, channel, target and LUN */
#define ndevtoctl(devno)        (((devno)>>24)&0xFF)
#define ndevtoch(devno)         (((devno)>>16)&0xFF)
#define ndevtotgt(devno)        (((devno)>>8)&0xFF)
#define ndevtolun(devno)        (((devno)&0xFF)
#define ctlchtgtluntondev(ctl,ch,tgt,lun)       (((ctl)<<24)+((ch)<<16)+((tgt)<<8)+(lun))

/* read one 4 bytes and then split the information */
#define MDAC_CMDID_STATUS_REG           0x0C /* C, D cmdid, E+F status */
#define MDAC_DACPG_CMDID_STATUS_REG     0x18 /* 18+19 cmd_id, 1A+1B status */
#define MDAC_DACPV_CMDID_STATUS_REG     0x0C /* C, D cmdid, E+F status */
#define MDAC_DACBA_CMDID_STATUS_REG     0x08 /* cmdid, status, residue values */
#define MDAC_DACLP_CMDID_STATUS_REG     0x08 /* cmdid, status, residue values */
#define mdac_status(st) (((st)>>16) & 0xFFFF)   /* get status part */
#define mdac_cmdid(st)  (((st)) & 0xFFFF)       /* get command id part */

/* local door bell registers and associated bits */
#define MDAC_DACPE_LOCAL_DOOR_BELL_REG  0x0D
#define MDAC_DACPD_LOCAL_DOOR_BELL_REG  0x40
#define MDAC_DACPG_LOCAL_DOOR_BELL_REG  0x20
#define MDAC_DACPV_LOCAL_DOOR_BELL_REG  0x60
#define MDAC_DACBA_LOCAL_DOOR_BELL_REG  0x60
#define MDAC_DACLP_LOCAL_DOOR_BELL_REG  0x20
#define MDAC_MAILBOX_FULL       0x01    /* =1 if mail box is full */
#define MDAC_MAILBOX_FULL_DUAL_MODE     0x10
#define MDAC_GOT_STATUS         0x02    /* Host got status */
#define MDAC_RESET_CONTROLLER   0x08    /* reset controller */
#define MDAC_960RP_BCREG        0x3C    /* bridge control register */
#define MDAC_960RP_RESET_SECBUS 0x400000/* reset secondary bus */
#define MDAC_960RP_EBCREG       0x40    /* bridge control register */
#define MDAC_960RP_RESET        0x20    /* reset 960 RP */

/* system door bell registers and associated bits */
#define MDAC_DACPE_SYSTEM_DOOR_BELL_REG 0x0F
#define MDAC_DACPD_SYSTEM_DOOR_BELL_REG 0x41
#define MDAC_DACPG_SYSTEM_DOOR_BELL_REG 0x2C
#define MDAC_DACPV_SYSTEM_DOOR_BELL_REG 0x61
#define MDAC_DACBA_SYSTEM_DOOR_BELL_REG 0x61
#define MDAC_DACLP_SYSTEM_DOOR_BELL_REG 0x2C
#define MDAC_DACPG_PENDING_INTR         0x03 /* !=0 interrupt is pending */
#define MDAC_DACPV_PENDING_INTR         0x03 /* =1, 2, 3 interrupt is pending */
#define MDAC_DACBA_PENDING_INTR         0x03 /* =1, 2, 3 interrupt is pending */
#define MDAC_DACLP_PENDING_INTR         0x03 /* =1, 2, 3 interrupt is pending */
#define MDAC_PENDING_INTR               0x01 /* =1 interrupt is pending */
#define MDAC_CLEAR_INTR                 0x03 /* clear interrupt by this write */
#define MDAC_ZERO_INTR                  0x04 /* interrupt has been processed */

/* interrupt mask register and associated bits */
#define MDAC_DACMC_INTR_MASK_REG        0x05
#define MDAC_DACPE_INTR_MASK_REG        0x0E
#define MDAC_DACPD_INTR_MASK_REG        0x43
#define MDAC_DACPG_INTR_MASK_REG        0x34
#define MDAC_DACPV_INTR_MASK_REG        0x34
#define MDAC_DACBA_INTR_MASK_REG        0x34
#define MDAC_DACLP_INTR_MASK_REG        0x34
#define MDAC_DACPG_INTRS_OFF            0xFF /* Disable DACPG interrupt */
#define MDAC_DACPG_INTRS_ON             0xFB /* Enable  DACPG interrupt */
#define MDAC_DACPV_INTRS_OFF            0x04 /* Disable DACPV interrupt */
#define MDAC_DACPV_INTRS_ON             0x00 /* Enable  DACPV interrupt */
#define MDAC_DACBA_INTRS_OFF            0x04 /* Disable DACPV interrupt */
#define MDAC_DACLP_INTRS_OFF            0xFF /* Disable DACPV interrupt */
#define MDAC_DACBA_INTRS_ON             0x00 /* Enable  DACPV interrupt */
#define MDAC_DACLP_INTRS_ON             0xFB /* Enable  DACPV interrupt */
#define MDAC_DACMC_INTRS_OFF            0x02 /* Disable DACMC interrupt */
#define MDAC_DACMC_INTRS_ON             0x03 /* Enable  DACMC interrupt */
#define MDAC_DAC_INTRS_OFF              0x00 /* Disable interrupt */
#define MDAC_DAC_INTRS_ON               0x01 /* Enable interrupt */

/* Error Status registers and associated bits */
#define MDAC_DACPD_ERROR_STATUS_REG     0x3F
#define MDAC_DACPG_ERROR_STATUS_REG     0x103F
#define MDAC_DACPV_ERROR_STATUS_REG     0x63
#define MDAC_DACBA_ERROR_STATUS_REG     0x63
#define MDAC_DACLP_ERROR_STATUS_REG     0x2E
#define MDAC_MSG_PENDING                0x04 /* some error message pending */
#define MDAC_DRIVESPINMSG_PENDING       0x08 /* drive sping message pending */
#define MDAC_DIAGERROR_MASK             0xF0 /* diagnostic error mask */
#define MDAC_HARD_ERR           0x10 /* hard error */
#define MDAC_FW_ERR             0x20 /* firmware error */
#define MDAC_CONF_ERR           0x30 /* configration error */
#define MDAC_BMIC_ERR           0x40 /* BMIC error */
#define MDAC_MISM_ERR           0x50 /* mismatch between NVRAM and Flash */
#define MDAC_MRACE_ERR          0x60 /* mirror race error */
#define MDAC_MRACE_ON           0x70 /* recovering mirror */
#define MDAC_DRAM_ERR           0x80 /* memory error */
#define MDAC_ID_MISM            0x90 /* unidentified device found */
#define MDAC_GO_AHEAD           0xA0 /* go ahead */
#define MDAC_CRIT_MRACE         0xB0 /* mirror race on critical device */
#define MDAC_NEW_CONFIG         0xD0 /* new configuration found */
#define MDAC_PARITY_ERR         0xF0 /* memory parity error */


#define MDAC_DACPG_MAIL_BOX     0x1000  /* Mail Box Start address for PG */
#define MDAC_DACPV_MAIL_BOX     0x0050  /* Mail Box Start address for PV */
#define MDAC_DACBA_MAIL_BOX     0x0050  /* Mail Box Start address for BA */
#define MDAC_DACLP_MAIL_BOX     0x0010  /* Mail Box Start address for LP */
#define MDAC_MAIL_BOX_REG_EISA  0x10    /* Mail Box Start address */
#define MDAC_MAIL_BOX_REG_PCI   0x00    /* Mail Box Start address */
#define MDAC_IOSPACESIZE        0x44    /* # bytes required for DAC io space */
#define MDAC_HWIOSPACESIZE      128     /* 128 bytes */

/*=========================EISA STARTS==================================*/
#define MDAC_MAXEISASLOTS       16      /* Max number of EISA slots */
#define MDAC_EISA_BASE          0x0C80 /* base address */

/* All addresses are offset from MDAC_EISA_BASE */
#define MDAC_BMIC_MASK_REG      0x09    /* BMIC interrupt mask register */
#define MDAC_BMIC_INTRS_OFF     0x00    /* Disable interrupt */
#define MDAC_BMIC_INTRS_ON      0x01    /* Enable  interrupt */


#define MDAC_EISA_BIOS_BYTE     0x41
#define MDAC_EISA_BIOS_ENABLED  0x40    /* bit 6=1 if enabled */
#define MDAC_EISA_BIOS_ADDR_MASK 0x3    /* BIOS address mask */

#define MDAC_EISA_IRQ_BYTE      0x43
#define MDAC_EISA_IRQ_MASK      0x60

#define MDAC_DEVPIDPE_MASK      0x70FFFFFF /* Mask to get the right ID value */
#define MDAC_DEVPIDPE           0x70009835 /* DAC960PE id */

/*=========================EISA ENDS====================================*/

/*=========================MCA  STARTS==================================*/
#define MDAC_MAXMCASLOTS        8       /* Max number of MCA slots */

                                        /* MIAMI interface */
#define MDAC_DMC_REGSELPORT     0x0096  /* register selection port */
#define MDAC_DMC_DATAPORT       0x0100  /* data port */
#define MDAC_DMC_REG_OFF        0x1890  /* Offset from BIOS base address */

#define MDAC_DMC_ATTN           0x04    /* Attention Port  */
#define MDAC_DMC_NEW_CMD        0xD0    /* Host->DMC I/F   */
#define MDAC_DMC_GOT_STAT       0xD1    /* Host got status */

#define MDAC_DMC_CBSP           0x07    /* Status Port     */
#define MDAC_DMC_BUSY           0x01    /* DMC->host I/F   */
#define MDAC_DMC_IV             0x02    /*                 */
                                        /*******************/

#define MDAC_DMC_CONFIG1        (MDAC_DMC_DATAPORT + 2)
#define MDAC_DMC_IRQ_MASK       0xC0
#define MDAC_DMC_BIOS_MASK      0x3C

#define MDAC_DMC_CONFIG2        (MDAC_DMC_DATAPORT + 5)
#define MDAC_DMC_IO_MASK        0x38

/*=========================MCA  ENDS====================================*/

/*=========================PCI  STARTS==================================*/
#define MDAC_MAXPCISLOTS        16      /* maximum PCI slots per bus */
#define MDAC_MAXPCIDEVS         32      /* Max PCI devices per bus */
#define MDAC_MAXPCIFUNCS        8       /* maximum PCI functions */
#define MDAC_PCISCANSTART       0xC000  /* Start scanning from this Address */
#define MDAC_PCICFGSIZE_M1      0x800   /* PCI conf space size for mechanism 1*/
#define MDAC_PCICFGSIZE_M2      0x100   /* PCI conf space size for mechanism 2*/
#define MDAC_PCICFG_ENABLE_REG  0xCF8   /* Enable configuration register */
#define MDAC_PCICFG_FORWARD_REG 0xCFA   /* Used for Config Mechanism# 2 */
#define MDAC_PCICFG_ENABLE      0x10    /* enable configuration */
#define MDAC_PCICFG_DISABLE     0x00    /* Disable configuration */
#define MDAC_CFGMECHANISM2_TYPE0 0x0    /* Type 0 Config. Access */
#define MDAC_PCICFG_CNTL_REG    0xCF8   /* Control register mechanism# 1 */
#define MDAC_PCICFG_DATA_REG    0xCFC   /* Data    register mechanism# 1 */
#define MDAC_PCICFG_ENABLE_M1   0x80000000
#define MDAC_PCI_MECHANISM1     0x01    /* PCI mechanism 1 hardware */
#define MDAC_PCI_MECHANISM2     0x02    /* PCI mechanism 2 hardware */

#define MDAC_PCIIRQ_MASK        0x0F    /* IRQ Mask */
#define MDAC_PCIIOBASE_MASK     0x0000FF80 /* Mask for Base IO Address */
#define MDAC_PCIPDMEMBASE_MASK  0xFFFFFFF0 /* Mask for Base Memory Address */
#define MDAC_PCIPGMEMBASE_MASK  0xFFFFE000 /* Mask for Base Memory address */

#define MDAC_DEVPIDFWV2x        0x00011069 /* FW < 3.x */
#define MDAC_DEVPIDFWV3x        0x00021069 /* FW >= 3.x */
#define MDAC_DEVPIDPG           0x00101069 /* FW Perigrine */
#define MDAC_SUBDEVPIDPV        0x00201069 /* FW Little Apple */
#define MDAC_DEVPIDPV           0x10651011 /* DEC's processror */
#define MDAC_DEVPIDBA           0xBA561069 /* Mylex Big Bass device */
#define MDAC_DEVPIDPJBOOTBLK    0x00111069 /* PJ Boot Block */
#define MDAC_DEVPIDBBDACPVX     0x00211069 /* BB DACPVX */
#define MDAC_DEVPIDLP           0x00501069 /* Mylex Leopard */

/* PCI Vendor ID */
#define MLXPCI_VID_DIGITAL      0x1011  /* Digital Equipment Corporation */
#define MLXPCI_VID_BUSLOGIC     0x104B  /* BusLogic/Mylex Corporation */
#define MLXPCI_VID_MYLEX        0x1069  /* Mylex Corporation */
#define MLXPCI_VID_INTEL        0x8086  /* Intel Corporation */

/* Mylex PCI Device ID */
#define MLXPCI_DEVID_PDFW2x     0x0001  /* DAC960PD with FW 2.x */
#define MLXPCI_DEVID_PDFW3x     0x0002  /* DAC960PD with FW 3.x */
#define MLXPCI_DEVID_PG         0x0010  /* DAC960PG family */
#define MLXPCI_DEVID_PVX        0x0020  /* DAC1100PVX family */
#define MLXPCI_DEVID_FA         0x0030  /* EXR3000 Fibre Apple family */
#define MLXPCI_DEVID_BA         0x0040  /* EXR2000 Big Apple family */
#define MLXPCI_DEVID_LP         0x0050  /* Leopard */
#define MLXPCI_DEVID_LX         0x0052  /* Lynx */
#define MLXPCI_DEVID_BC         0x0054  /* BobCat */
#define MLXPCI_DEVID_HARPOON    0x8130  /* Harpoon SCSI chip */
#define MLXPCI_DEVID_BASS       0xBA55  /* BASS chip */
#define MLXPCI_DEVID_BASS_2		0xBA56	/* BASS 2 chip */
/* Digital PCI Device Ids */
#define MLXPCI_DEVID_DEC_BRIDGE 0x0026  /* Digital Bridge device */
#define MLXPCI_DEVID_DEC_FOOT_BRIDGE    0x1065  /* Digital Foot Bridge device */

/* PCI Base Class Code */
#define MLXPCI_BASECC_OLD       0x00    /* devices built before class code */
#define MLXPCI_BASECC_MASS      0x01    /* mass storage controller */
#define MLXPCI_BASECC_NETWORK   0x02    /* network controller */
#define MLXPCI_BASECC_DISPLAY   0x03    /* display controller */
#define MLXPCI_BASECC_MULTMED   0x04    /* multimedia device */
#define MLXPCI_BASECC_MEMORY    0x05    /* memory controller */
#define MLXPCI_BASECC_BRIDGE    0x06    /* bridge device */
#define MLXPCI_BASECC_SCOMM     0x07    /* simple communication controller */
#define MLXPCI_BASECC_BASEIO    0x08    /* base system peripheral */
#define MLXPCI_BASECC_IO        0x09    /* Input Devices */
#define MLXPCI_BASECC_DOCKS     0x0A    /* docking stations */
#define MLXPCI_BASECC_CPU       0x0B    /* processors */
#define MLXPCI_BASECC_SBC       0x0C    /* serial bus controller */

/* different sub class devices */
/* MLXPCI_BASECC_MASS Mass storage sub class devices */
#define MLXPCI_SUBCC_SCSI       0x00    /* SCSI bus controller */
#define MLXPCI_SUBCC_IDE        0x01    /* IDE controller */
#define MLXPCI_SUBCC_FLOPPY     0x02    /* floppy disk controller */
#define MLXPCI_SUBCC_IPI        0x03    /* IPI bus controller */
#define MLXPCI_SUBCC_RAID       0x04    /* RAID controller */
#define MLXPCI_SUBCC_OTHERMASS  0x80    /* other mass storage controller */

/* MLXPCI_BASECC_NETWORK network controllers */
#define MLXPCI_SUBCC_ETHERNET   0x00    /* ethernet controller */
#define MLXPCI_SUBCC_TOKENRING  0x01    /* token ring controller */
#define MLXPCI_SUBCC_FDDI       0x02    /* FDDI controller */
#define MLXPCI_SUBCC_ATM        0x03    /* ATM controller */
#define MLXPCI_SUBCC_OTHERNET   0x80    /* other network controller */

/* MLXPCI_BASECC_DISPLAY display controllers */
#define MLXPCI_SUBCC_VGA        0x00    /* VGA controller */
#define MLXPCI_SUBCC_XGA        0x01    /* XGA controller */
#define MLXPCI_SUBCC_OTHERDISP  0x80    /* other display controller */

/* MLXPCI_BASECC_MULTMED multimedia devices */
#define MLXPCI_SUBCC_VIDEO      0x00    /* video device */
#define MLXPCI_SUBCC_AUDIO      0x01    /* audio device */
#define MLXPCI_SUBCC_OTHERMULT  0x80    /* other multimedia device */

/* MLXPCI_BASECC_MEMORY memory controller */
#define MLXPCI_SUBCC_RAM        0x00    /* RAM */
#define MLXPCI_SUBCC_FLASH      0x01    /* FLASH */
#define MLXPCI_SUBCC_OTHERMEM   0x80    /* other memory controller */

/* MLXPCI_BASECC_BRIDGE bridge device */
#define MLXPCI_SUBCC_HOSTBRIDGE         0x00    /* host bridge */
#define MLXPCI_SUBCC_ISABRDIGE          0x01    /* ISA bridge */
#define MLXPCI_SUBCC_EISABRIDGE         0x02    /* EISA bridge */
#define MLXPCI_SUBCC_MCABRDIGE          0x03    /* MCA bridge */
#define MLXPCI_SUBCC_PCI2PCIBRIDGE      0x04    /* PCI-to-PCI bridge */
#define MLXPCI_SUBCC_PCMCIABRIDGE       0x05    /* PCMCIA bridge */
#define MLXPCI_SUBCC_NUBUSBRIDGE        0x06    /* NuBus bridge */
#define MLXPCI_SUBCC_CARDBUSBRIDGE      0x07    /* CardBus bridge */
#define MLXPCI_SUBCC_OTHERBRIDGE        0x80    /* other bridge device */

/* MLXPCI_BASECC_SCOMM simple communication controller */
#define MLXPCI_SUBCC_SERIALPORT         0x00    /* serial port */
#define MLXPCI_SUBCC_PARALLELPORT       0x01    /* parallel port */
#define MLXPCI_SUBCC_OTHERPORT          0x80    /* other communication port */

/* MLXPCI_BASECC_BASEIO base system peripheral */
#define MLXPCI_SUBCC_PIC                0x00    /* PIC interrupt controller */
#define MLXPCI_SUBCC_DMA                0x01    /* DMA controller */
#define MLXPCI_SUBCC_TIMER              0x02    /* TIMER controller */
#define MLXPCI_SUBCC_RTC                0x03    /* real time clock */
#define MLXPCI_SUBCC_OTHERBASEIO        0x80    /* other system peripheral */

/* MLXPCI_BASECC_IO Input Devices */
#define MLXPCI_SUBCC_KEYBOARD   0x00    /* keyboard controller */
#define MLXPCI_SUBCC_PEN        0x01    /* digitizer (pen) */
#define MLXPCI_SUBCC_MOUSE      0x02    /* mouse controller */
#define MLXPCI_SUBCC_OTHERIO    0x80    /* other input controller */

/* MLXPCI_BASECC_DOCKS docking stations */
#define MLXPCI_SUBCC_GENDOCK    0x00    /* generic docking station */
#define MLXPCI_SUBCC_OTHERDOCKS 0x80    /* other type of docking station */

/* MLXPCI_BASECC_CPU processors */
#define MLXPCI_SUBCC_386                0x00    /* i386 */
#define MLXPCI_SUBCC_486                0x01    /* i486 */
#define MLXPCI_SUBCC_PENTIUM            0x02    /* Pentium */
#define MLXPCI_SUBCC_ALPHA              0x10    /* Alpha */
#define MLXPCI_SUBCC_POWERPC            0x20    /* PowerPC */
#define MLXPCI_SUBCC_COPROCESSOR        0x040   /* co-processor */

/* MLXPCI_BASECC_SBC serial bus controller */
#define MLXPCI_SUBCC_1394               0x00    /* FireWire (IEEE 1394) */
#define MLXPCI_SUBCC_ACCESS             0x01    /* ACCESS bus */
#define MLXPCI_SUBCC_SSA                0x02    /* SSA */
#define MLXPCI_SUBCC_USB                0x03    /* Universal Serial Bus (USB) */
#define MLXPCI_SUBCC_FIBRE              0x04    /* Fibre Channel */

/* Enable PCI config space for mechanism 2 */
#define mdac_enable_cfg_m2(ctp) \
{ \
        u08bits_out_mdac(MDAC_PCICFG_ENABLE_REG, MDAC_PCICFG_ENABLE|(ctp->cd_FuncNo<<1)); \
        u08bits_out_mdac(MDAC_PCICFG_FORWARD_REG, MDAC_CFGMECHANISM2_TYPE0); \
        u08bits_out_mdac(MDAC_PCICFG_FORWARD_REG,ctp->cd_BusNo); \
}

/* Disable PCI config space for mechanism 2 */
#define mdac_disable_cfg_m2() \
        u08bits_out_mdac(MDAC_PCICFG_ENABLE_REG, MDAC_PCICFG_DISABLE)
typedef struct mdac_pcicfg
{
        u32bits pcfg_DevVid;            /* device and vendor id */
        u32bits pcfg_CmdStat;           /* command and status */
        u32bits pcfg_CCRevID;           /* class code and revision ID */
        u32bits pcfg_BHdrLCache;        /* BIST+Header+LatencyTimer+CacheLine*/

        u32bits pcfg_MemIOAddr;         /* Memory/IO Base address */
        u32bits pcfg_MemAddr;           /* Memory Base Address for PD */
        u32bits pcfg_Reserved0;
        u32bits pcfg_Reserved1;

        u32bits pcfg_Reserved10;
        u32bits pcfg_Reserved11;
        u32bits pcfg_CBUSCIS;           /* Card Bus CIS pointer */
        u32bits pcfg_SubSysVid;         /* sub system and sub vendor id */

        u32bits pcfg_ExpROMAddr;        /* expansion ROM Base Address */
        u32bits pcfg_Reserved20;
        u32bits pcfg_Reserved21;
        u32bits pcfg_BCIPIL;            /* BridgeControl+IntrPin+IntrLine */
} mdac_pcicfg_t;
#define mdac_pcicfg_s   sizeof(mdac_pcicfg_t)

/* field extraction macros */
#define mlxpci_cfg2vid(cfgp)            ((cfgp)->pcfg_DevVid & 0xFFFF)
#define mlxpci_cfg2devid(cfgp)          ((cfgp)->pcfg_DevVid>>16)
#define mlxpci_cfg2subvid(cfgp)         ((cfgp)->pcfg_SubSysVid & 0xFFFF)
#define mlxpci_cfg2subdevid(cfgp)       ((cfgp)->pcfg_SubSysVid>>16)
#define mlxpci_cfg2cmd(cfgp)            ((cfgp)->pcfg_CmdStat & 0xFFFF)
#define mlxpci_cfg2status(cfgp)         ((cfgp)->pcfg_CmdStat>>16)
#define mlxpci_cfg2revid(cfgp)          ((cfgp)->pcfg_CCRevID & 0xFF)
#define mlxpci_cfg2interface(cfgp)      (((cfgp)->pcfg_CCRevID>>8) & 0xFF)
#define mlxpci_cfg2subcc(cfgp)          (((cfgp)->pcfg_CCRevID>>16) & 0xFF)
#define mlxpci_cfg2basecc(cfgp)         ((cfgp)->pcfg_CCRevID>>24)
#define mlxpci_cfg2cachelinesize(cfgp)  ((cfgp)->pcfg_BHdrLCache&0xFF)
#define mlxpci_cfg2latencytimer(cfgp)   (((cfgp)->pcfg_BHdrLCache>>8)&0xFF)
#define mlxpci_cfg2headertype(cfgp)     (((cfgp)->pcfg_BHdrLCache>>16)&0xFF)
#define mlxpci_cfg2BIST(cfgp)           ((cfgp)->pcfg_BHdrLCache>>24)
#define mlxpci_cfg2interruptline(cfgp)  ((cfgp)->pcfg_BCIPIL&0xFF)
#define mlxpci_cfg2interruptpin(cfgp)   (((cfgp)->pcfg_BCIPIL>>8)&0xFF)
#define mlxpci_cfg2maxlatencytime(cfgp) (((cfgp)->pcfg_BCIPIL>>16)&0xFF)
#define mlxpci_cfg2mingrant(cfgp)       ((cfgp)->pcfg_BCIPIL>>24)

/*=========================PCI  ENDS====================================*/

/* structure to store the command id information */
typedef struct mdac_cmdid
{
        struct mdac_cmdid MLXFAR *cid_Next;     /* link to next command id */
        u32bits cid_cmdid;                      /* command id value */
} mdac_cmdid_t;
#define mdac_cmdid_s    sizeof(mdac_cmdid_t)

/* scatter/gather list information */
typedef struct  mdac_sglist
{
        u32bits sg_PhysAddr;            /* Physical address */
        u32bits sg_DataSize;            /* Data transfer size */
} mdac_sglist_t;
#define mdac_sglist_s   sizeof(mdac_sglist_t)

#ifndef _WIN64
/* struct to send request to controller */
typedef struct mdac_req
{
        struct  mdac_req MLXFAR *rq_Next;       /* Next in chain */
	MLX_VA32BITOSPAD(u32bits        rq_VReserved00;)
	u64bits	rq_PhysAddr;			/* Request's physical addr */
/* 0x10 */
        u32bits (MLXFAR * rq_CompIntr)(struct mdac_req MLXFAR*);        /* comp func */
	MLX_VA32BITOSPAD(u32bits        rq_VReserved02;)
        u32bits (MLXFAR * rq_CompIntrBig)(struct mdac_req MLXFAR*);/*comp func */
	MLX_VA32BITOSPAD(u32bits        rq_VReserved03;)
/* 0x20 */
        u32bits (MLXFAR * rq_StartReq)();        /* start Req */
	MLX_VA32BITOSPAD(u32bits        rq_VReserved04;)
        struct  mdac_ctldev MLXFAR *rq_ctp;     /* Controller pointer */
	MLX_VA32BITOSPAD(u32bits        rq_VReserved05;)
/* 0x30 */
        struct  mdac_physdev MLXFAR *rq_pdp;    /* Physical device addr */
	MLX_VA32BITOSPAD(u32bits        rq_VReserved06;)
        mdac_cmdid_t MLXFAR *rq_cmdidp;         /* Command ID */
	MLX_VA32BITOSPAD(u32bits        rq_VReserved07;)
/* 0x40 */
        u32bits rq_FinishTime;          /* when supposed to finish in seconds */
        u32bits rq_TimeOut;             /* Time out value in second */
        u32bits rq_PollWaitChan;        /* sleep/wakeup channel */
        u32bits rq_Poll;                /* if =0 op complete */
/* 0x50 */
        u08bits rq_ControllerNo;        /* Controller number */
        u08bits rq_ChannelNo;           /* channel number */
        u08bits rq_TargetID;            /* Target ID */
        u08bits rq_LunID;               /* Lun ID / Logical Dev No */
        u16bits rq_FakeSCSICmd;         /* SCSI command value */
        u08bits rq_HostStatus;          /* Host Status */
        u08bits rq_TargetStatus;        /* Target Status */
        u08bits rq_ScsiPortNo;          /* Used by MACDISK */
        u08bits rq_Reserved0;
        u16bits rq_ttHWClocks;          /* time trace time in HW clocks */
        u32bits rq_ttTime;              /* time trace time in 10ms */
/* 0x60 */
        u32bits rq_BlkNo;               /* Block number */
        u32bits rq_DataOffset;          /* Offset in data space */
        u32bits rq_DataSize;            /* Data transfer size */
        u32bits rq_ResdSize;            /* Data not transfered (residue) */
/* 0x70 */
        OSReq_t MLXFAR *rq_OSReqp;      /* OS request buffer */
	MLX_VA32BITOSPAD(u32bits        rq_VReserved08;)
        u32bits (MLXFAR * rq_CompIntrSave)(struct mdac_req MLXFAR*);/*comp func, used for OS2 */
	MLX_VA32BITOSPAD(u32bits        rq_VReserved09;)
/* 0x80 */
        u32bits rq_OpFlags;             /* Operation Flags */
        u32bits rq_Dev;                 /* Device address */
	u32bits	rq_Reserved00;
	u32bits	rq_Reserved01;
/* 0x90 */
	u32bits	rq_Reserved02;
        u32bits rq_MapRegBase;          /* Used by MACDISK */
        u32bits *rq_PageList;           /* Used by MACDISK */
        u32bits rq_MapRegCount;         /* Used by MACDISK */
/* 0xa0 */
                                        /* The rq_DacCmd and rq_DacCmdExt are 
                                        ** used for 32 bytes command.
                                        ** rq_scdb is used for 64 byte command.
                                        */
/* additionally, the rq_DacCmd field is also used to store a copy of the CDB (rq_Cdb_Long) under Windows OSes if the CDB is greater
    than 10 bytes in length on new API cards. This is because the rqp is built within the Windows SRB structure which is one of the legal inputs 
   to the OS-supplied virt-to-phys operation (ScsiPortGetPhysicalAddress). Since in this case we need a physical ptr to the CDB for the new 
   API,  we have to move it somewhere it can be addressed legally */

        dac_command_t rq_DacCmd;        /* DAC command structure */
/* 0xb0 */
        u32bits rq_DacCmdExt[4];        /* Space to fit 32 byte cmd struct */
/* 0xc0 */
        dac_scdb_t rq_scdb;             /* SCSI CDB */
        u32bits rq_DMASize;             /* DMA Size for current transfer */
        u32bits rq_MaxDMASize;          /* Maximum DMA size possible with SG */
/* 0x120 */
        u08bits MLXFAR *rq_LSGVAddr;    /* memory for large SG List */
        MLX_VA32BITOSPAD(u32bits        rq_VReserved10;)
        mdac_sglist_t   MLXFAR *rq_SGVAddr;     /* SG list virtual address */
        MLX_VA32BITOSPAD(u32bits        rq_VReserved11;)
/* 0x130 */
        u64bits rq_SGPAddr;             /* SG List physical address */
        u64bits rq_DMAAddr;             /* DMA (SG/Direct) physical addr */
/* 0x140 */
	u64bits	rq_DataPAddr;		/* Physical Data address if some one is using */
	u08bits	MLXFAR *rq_DataVAddr;	/* Virtual data address */
        MLX_VA32BITOSPAD(u32bits        rq_VReserved12;)
/* 0x150 */
        u64bits rq_Reserved20;
        u64bits rq_Reserved21;
/* 0x160 */
        u64bits rq_Reserved22;
        u64bits rq_Reserved23;
/* 0x170 */
        u32bits rq_ResdSizeBig;
        u32bits rq_CurIOResdSize;       /* Current IO Data not transfered (residue) */
        u32bits rq_MaxSGLen;            /* max SG entry possible in SGVAddr */
        u32bits rq_SGLen;               /* # entry in SG List */
/* 0x180 */
        mdac_sglist_t   rq_SGList[MDAC_MAXSGLISTSIZE]; /* SG list */

} mdac_req_t;
#define mdac_req_s      sizeof(mdac_req_t)

#else

/* struct to send request to controller */
typedef struct mdac_req
{
        struct  mdac_req MLXFAR *rq_Next;       /* Next in chain */
	u64bits	rq_PhysAddr;			/* Request's physical addr */
/* 0x10 */
        u32bits (MLXFAR * rq_CompIntr)(struct mdac_req MLXFAR*);        /* comp func */
        u32bits (MLXFAR * rq_CompIntrBig)(struct mdac_req MLXFAR*);	/*comp func */
/* 0x20 */
        u32bits (MLXFAR * rq_StartReq)(struct mdac_req MLXFAR*);        /* start Req */
        struct  mdac_ctldev MLXFAR *rq_ctp;     /* Controller pointer */
/* 0x30 */
        struct  mdac_physdev MLXFAR *rq_pdp;    /* Physical device addr */
        mdac_cmdid_t MLXFAR *rq_cmdidp;         /* Command ID */
/* 0x40 */
        u32bits rq_FinishTime;          /* when supposed to finish in seconds */
        u32bits rq_TimeOut;             /* Time out value in second */
		UINT_PTR rq_Reserved00
/* 0x50 */			;
        UINT_PTR rq_PollWaitChan;        /* sleep/wakeup channel */
        UINT_PTR rq_Poll;                /* if =0 op complete */
/* 0x60 */
        u08bits rq_ControllerNo;        /* Controller number */
        u08bits rq_ChannelNo;           /* channel number */
        u08bits rq_TargetID;            /* Target ID */
        u08bits rq_LunID;               /* Lun ID / Logical Dev No */
        u16bits rq_FakeSCSICmd;         /* SCSI command value */
        u08bits rq_HostStatus;          /* Host Status */
        u08bits rq_TargetStatus;        /* Target Status */
        u08bits rq_ScsiPortNo;          /* Used by MACDISK */
        u08bits rq_Reserved0;
        u16bits rq_ttHWClocks;          /* time trace time in HW clocks */
        u32bits rq_ttTime;              /* time trace time in 10ms */
/* 0x70 */
        u32bits rq_BlkNo;               /* Block number */
        u32bits rq_DataOffset;          /* Offset in data space */
        u32bits rq_DataSize;            /* Data transfer size */
        u32bits rq_ResdSize;            /* Data not transfered (residue) */
/* 0x80 */
        OSReq_t MLXFAR *rq_OSReqp;      /* OS request buffer */
        UINT_PTR (MLXFAR * rq_CompIntrSave)(struct mdac_req MLXFAR*);/*comp func, used for OS2 */
/* 0x90 */
        u32bits rq_OpFlags;             /* Operation Flags */
        u32bits rq_Dev;                 /* Device address */
        UINT_PTR rq_MapRegBase;          /* Used by MACDISK */
/* 0xA0 */
        UINT_PTR *rq_PageList;            /* Used by MACDISK */

        u32bits rq_MapRegCount;         /* Used by MACDISK */
                                        /* The rq_DacCmd and rq_DacCmdExt are 
                                        ** used for 32 bytes command.
                                        ** rq_scdb is used for 64 byte command.
					*/
        u32bits rq_Reserved1;
/* 0xB0 */
        dac_command_t rq_DacCmd;        /* DAC command structure */
/* 0xC0 */
        u32bits rq_DacCmdExt[4];        /* Space to fit 32 byte cmd struct */
/* 0xD0 */
        dac_scdb_t rq_scdb;             /* SCSI CDB */
        u32bits rq_DMASize;             /* DMA Size for current transfer */
        u32bits rq_MaxDMASize;          /* Maximum DMA size possible with SG */
/* 0x130 */
        u08bits MLXFAR *rq_LSGVAddr;    /* memory for large SG List */
        mdac_sglist_t   MLXFAR *rq_SGVAddr;  /* SG list virtual address */
/* 0x140 */
        u64bits rq_SGPAddr;             /* SG List physical address */
        u64bits rq_DMAAddr;             /* DMA (SG/Direct) physical addr */
/* 0x150 */
	u64bits	rq_DataPAddr;		/* Physical Data address if some one is using */
	u08bits	MLXFAR *rq_DataVAddr;	/* Virtual data address */
/* 0x160 */
        u64bits rq_Reserved20;
        u64bits rq_Reserved21;
/* 0x170 */
        u64bits rq_Reserved22;
        u64bits rq_Reserved23;
/* 0x180 */
        u32bits rq_ResdSizeBig;
        u32bits rq_CurIOResdSize;       /* Current IO Data not transfered (residue) */
        u32bits rq_MaxSGLen;            /* max SG entry possible in SGVAddr */
        u32bits rq_SGLen;               /* # entry in SG List */
/* 0x190 */
        mdac_sglist_t   rq_SGList[MDAC_MAXSGLISTSIZE]; /* SG list */

} mdac_req_t;
#define mdac_req_s      sizeof(mdac_req_t)

#endif // _WIN64




#define rq_SysDevNo     rq_LunID
#define rq_DacCmdNew    rq_scdb
#define rq_Cdb_Long    rq_DacCmd
#define rq_sglist_s ((sizeof(mdac_sglist_t)) * MDAC_MAXSGLISTSIZE)

/* rq_OpFlags bits */
#define MDAC_RQOP_WRITE 0x00000000 /* =1 read, =0 write */
#define MDAC_RQOP_READ  0x00000001 /* =1 read, =0 write */
#define MDAC_RQOP_DONE  0x00000002 /* operation done */
#define MDAC_RQOP_ERROR 0x00000004 /* operation has error */
#define MDAC_RQOP_BUSY  0x00000008 /* request is busy or not free */
#define MDAC_RQOP_CLUST 0x00000010 /* clustered completion allowed */
#define MDAC_RQOP_ABORTED       0x00000020 /* Polled mode cmd aborted */
#define MDAC_RQOP_TIMEDOUT      0x00000040 /* Polled mode cmd timedout */
#define MDAC_RQOP_SGDONE        0x00000080 /* Scatter Gather List done */
#define MDAC_RQOP_FROM_SRB      0x00000100 /* assoc. w/an SRB extension */
typedef struct mdac_reqchain
{
        mdac_req_t MLXFAR *rqc_FirstReq;/* first request in chain */
        mdac_req_t MLXFAR *rqc_LastReq; /* last  request in chain */
} mdac_reqchain_t;

/* structure to store the physical device information for SCDB */
typedef struct mdac_physdev
{
        u08bits pd_ControllerNo;        /* Controller Number */
        u08bits pd_ChannelNo;           /* Channel Number */
        u08bits pd_TargetID;            /* Target ID */
        u08bits pd_LunID;               /* Lun ID */

        u08bits pd_Status;              /* device status */
        u08bits pd_DevType;             /* SCSI device type */
        u08bits pd_BlkSize;             /* Device block size in 512 multiples */
        u08bits pd_Reserved0;

        mdac_reqchain_t pd_WaitingReqQ; /* Waiting request queue */
}mdac_physdev_t;
#define mdac_physdev_s  sizeof(mdac_physdev_t)
#define pd_FirstWaitingReq      pd_WaitingReqQ.rqc_FirstReq
#define pd_LastWaitingReq       pd_WaitingReqQ.rqc_LastReq

/* pd_Status bit value */
#define MDACPDS_PRESENT         0x01 /* device is present */
#define MDACPDS_BUSY            0x02 /* device has active request */
#define MDACPDS_BIGTX           0x04 /* if there was a large transfer */
#define MDACPDS_WAIT            0x08 /* some command is waiting */

#ifdef MLX_SOL
typedef kmutex_t mdac_lock_t;
#else
typedef struct {
        u32bits lock_var;
        u32bits reserved;
} mdac_lock_t;
#endif

typedef struct mdac_mem
{
        struct mdac_mem MLXFAR *dm_next;        /* next memory address */
        u32bits dm_Size;                        /* memory size in bytes */
} mdac_mem_t;

#ifndef _WIN64
/* structure to store all the controller device information */
typedef struct mdac_ctldev
{
        u08bits cd_ControllerName[USCSI_PIDSIZE]; /* controller name */
/* 0x10 */
        u32bits cd_Status;              /* Controller status */
        u32bits cd_OSCap;               /* Capability for OS */
        u32bits cd_Reserved0;           /* lock for controller structure */
        u32bits cd_vidpid;              /* PCI device id + product id */
/* 0x20 */
        u08bits cd_ControllerNo;        /* Controller Number */
        u08bits cd_ControllerType;      /* type of controller */
        u08bits cd_BusType;             /* System Bus Interface Type */
        u08bits cd_BusNo;               /* System Bus No, HW is sitting on */

        u08bits cd_SlotNo;              /* System EISA/PCI/MCA Slot Number */
        u08bits cd_FuncNo;              /* PCI function number */
        u08bits cd_IrqMapped;           /* !=0 irq mapped by OS system */
        u08bits cd_TimeTraceEnabled;    /* !=0 if time trace is enabled */

        u08bits cd_MaxChannels;         /* Maximum Channels present */
        u08bits cd_MaxTargets;          /* Max # Targets/Channel supported */
        u08bits cd_MaxLuns;             /* Max # LUNs/Target supported */
        u08bits cd_MaxSysDevs;          /* Max # Logical Drives supported */

        u08bits cd_BIOSHeads;           /* # heads for BIOS */
        u08bits cd_BIOSTrackSize;       /* # sectors per track for BIOS */
        u08bits cd_MemIOSpaceNo;        /* Memory/IO space number used from PCI */
        u08bits cd_PhysChannels;        /* # of Physical Channels present */
                                        /* All allocated memory for this ctlr.
                                        ** This is done for driver release. */
/* 0x30 */
        u08bits MLXFAR*cd_CmdIDMemAddr; /* Memory addr of allocated cmd ids */
        u32bits cd_PhysDevTblMemSize;   /* Memory size of allocated physdevtbl*/
        mdac_physdev_t MLXFAR *cd_PhysDevTbl;/* Physical device table */
        mdac_physdev_t MLXFAR *cd_Lastpdp;/* last+1 Physical device entry */
/* 0x40 */
        mdac_reqchain_t cd_WaitingReqQ; /* Waiting Request queue */
        mdac_reqchain_t cd_DMAWaitingReqQ;      /* Waiting Request queue for DMA resource */
/* 0x50 */
        u32bits cd_DMAWaited;           /* # IO waited for DMA resource */
        u32bits cd_DMAWaiting;          /* # IO waiting for DMA resource */
        OSReq_t MLXFAR *cd_FirstWaitingOSReq;   /* First OS Request waiting */
        OSReq_t MLXFAR *cd_LastWaitingOSReq;    /* Last  OS Request waiting */
/* 0x60 */
        u32bits cd_irq;                 /* system's IRQ, may be vector */
        u08bits cd_IntrShared;          /* != 0, interrupt is shared */
        u08bits cd_IntrActive;          /* != 0, interrupt processing active */
        u08bits cd_InterruptVector;     /* Interrupt Vector Number */
        u08bits cd_InterruptType;       /* Interrupt Mode: Edge/Level */

        u08bits cd_InquiryCmd;          /* inquiry command for controller */
        u08bits cd_ReadCmd;             /* Read  command for controller */
        u08bits cd_WriteCmd;            /* write command for controller */
        u08bits cd_FWTurnNo;            /* firmware turn number */

        u16bits cd_FWVersion;           /* Firmware Version Major:Minor */
        u16bits cd_MaxTags;             /* Maximum Tags supported */
/* 0x70 */
        u32bits cd_ActiveCmds;          /* # commands active on cntlr */
        u32bits cd_MaxCmds;             /* Max # Concurrent commands supported*/
        u32bits cd_MaxDataTxSize;       /* Max data transfer size in bytes */
        u32bits cd_MaxSCDBTxSize;       /* Max SCDB transfer size in bytes */
/* 0x80 */
        u32bits cd_BaseAddr;            /* Physical IO/Memory Base Address */
        u32bits cd_BaseSize;            /* Base IO/Memory Size */
        u32bits cd_MemBasePAddr;        /* Physical Memory Base Address */
        u32bits cd_MemBaseVAddr;        /* Virtual  Memory Base Address */
/* 0x90 */
        u32bits cd_IOBaseSize;          /* IO space size */
        u32bits cd_MemBaseSize;         /* Memory space size */
        u32bits cd_BIOSAddr;            /* BIOS Address */
        u32bits cd_BIOSSize;            /* BIOS size */
/* 0xa0 */
        u32bits cd_IOBaseAddr;          /* IO Base Address */
        u32bits cd_ErrorStatusReg;      /* Error Status Register */
        u32bits cd_MailBox;             /* Mail Box starting address */
        u32bits cd_CmdIDStatusReg;      /* Command ID and Status Register */
/* 0xb0 */
        u32bits cd_BmicIntrMaskReg;     /* BMIC interrupt mask register */
        u32bits cd_DacIntrMaskReg;      /* DAC  interrupt mask register */
        u32bits cd_LocalDoorBellReg;    /* Local Door Bell register */
        u32bits cd_SystemDoorBellReg;   /* System Door Bell register */
/* 0xc0 */
        u32bits cd_HostLocalDoorBellReg; 
        u32bits cd_HostSystemDoorBellReg;
        u32bits cd_HostCmdIDStatusReg;
        u32bits cd_HostReserved;
/* 0xd0 */
        u32bits cd_HostCmdQueIndex;
        u32bits cd_HostStatusQueIndex;
        u08bits MLXFAR *cd_HostCmdQue;
        u08bits MLXFAR *cd_HostStatusQue;
/* 0xe0 */
        u08bits cd_RebuildCompFlag;     /* Rebuild completion flag */
        u08bits cd_RebuildFlag;         /* Rebuild Flag value to keep track */
        u08bits cd_RebuildSysDevNo;     /* rebuilding system device number */
        u08bits cd_Reserved10;
        mdac_lock_t cd_Lock;            /* lock for controller structure */
        u32bits cd_Reserved13;
/* 0xf0 */
        u08bits cd_MinorBIOSVersion;    /* BIOS Minor Version Number */
        u08bits cd_MajorBIOSVersion;    /* BIOS Major Version Number */
        u08bits cd_InterimBIOSVersion;  /* interim revs A, B, C, etc. */
        u08bits cd_BIOSVendorName;      /* vendor name */
        u08bits cd_BIOSBuildMonth;      /* BIOS Build Date - Month */
        u08bits cd_BIOSBuildDate;       /* BIOS Build Date - Date */
        u08bits cd_BIOSBuildYearMS;     /* BIOS Build Date - Year */
        u08bits cd_BIOSBuildYearLS;     /* BIOS Build Date - Year */
        u16bits cd_BIOSBuildNo;         /* BIOS Build Number */
        u16bits cd_FWBuildNo;           /* FW Build number */
        u32bits cd_SpuriousCmdStatID;   /* Spurious command status and ID */
/* 0x100 */
#define _cp     struct  mdac_ctldev     MLXFAR *
#define _rp     struct  mdac_req        MLXFAR *
        void    (MLXFAR *cd_DisableIntr)(_cp);  /* Disable Interrupt */
        void    (MLXFAR *cd_EnableIntr)(_cp);   /* Enable  Interrupt */
        u32bits (MLXFAR *cd_CheckMailBox)(_cp); /* Check Mail Box */
        u32bits (MLXFAR *cd_PendingIntr)(_cp);  /* Check Pending Interrupt */
/* 0x110 */
        u32bits (MLXFAR *cd_ReadCmdIDStatus)(_cp);/* Read Command ID & Status */
        u32bits (MLXFAR *cd_SendCmd)(_rp);      /* Send full command */
        u32bits (MLXFAR *cd_SendRWCmd)(_cp,OSReq_t MLXFAR*,u32bits,u32bits,u32bits,u32bits,u32bits);
        u32bits (MLXFAR *cd_SendRWCmdBig)(_rp); /* send big read/write cmd */
/* 0x120 */
        u32bits (MLXFAR *cd_InitAddr)(_cp);     /* Initialize the address */
        u32bits (MLXFAR *cd_ServiceIntr)(_cp);  /* Service Interrupt */
        u32bits (MLXFAR *cd_HwPendingIntr)(_cp);/* Check Hw Pending Interrupt */
        u32bits (MLXFAR *cd_ResetController)(_cp);/* Reset controller */
#undef  _cp
#undef  _rp
/* 0x130 */
                                                /* Statistics information */
        u32bits cd_SCDBDone;                    /* # SCDB done */
        u32bits cd_SCDBDoneBig;                 /* # SCDB done larger size */
        u32bits cd_SCDBWaited;                  /* # SCDB waited for turn */
        u32bits cd_SCDBWaiting;                 /* # SCDB waiting for turn */
/* 0x140 */
        u32bits cd_CmdsDone;                    /* # Read/Write commands done */
        u32bits cd_CmdsDoneBig;                 /* # R/W Cmds done larger size*/
        u32bits cd_CmdsWaited;                  /* # R/W Cmds waited for turn */
        u32bits cd_CmdsWaiting;                 /* # cmds waiting for turn */
/* 0x150 */
        u32bits cd_OSCmdsWaited;        /* # OS Cmds waited at OS */
        u32bits cd_OSCmdsWaiting;       /* # cmds waiting for turn */
        u32bits cd_OS0;                 /* used by OS specific code */
        OSctldev_t MLXFAR *cd_OSctp;    /* OS controller pointer */
/* 0x160 */
        u16bits cd_CmdsDoneSpurious;    /* # commands done spurious */
        u16bits cd_IntrsDoneSpurious;   /* # interrupts done spurious */
        u32bits cd_IntrsDone;           /* # Interrupts done */
        u32bits cd_IntrsDoneWOCmd;      /* # Interrupts done without command */
        u32bits cd_MailBoxCmdsWaited;   /* # cmds waited due to MailBox Busy */
/* 0x170 */
        u32bits cd_Reads;               /* # reads done */
        u32bits cd_ReadBlks;            /* data read in 512 bytes */
        u32bits cd_Writes;              /* # writes done */
        u32bits cd_WriteBlks;           /* data written in 512 bytes */
/* 0x180 */
                                        /* physical device scan information */
        u08bits cd_PDScanChannelNo;     /* physical device scan channel no */
        u08bits cd_PDScanTargetID;      /* physical device scan target ID */
        u08bits cd_PDScanLunID;         /* physical device scan LUN ID */
        u08bits cd_PDScanValid;         /* Physical device scan is valid if non zero */
        u08bits cd_PDScanCancel;        /* if non zero Cancel the Scan process */
        u08bits cd_Reserved00;
        u16bits cd_Reserved01;
        u32bits cd_LastCmdResdSize;     /* last command residue size, (move to mdac_req) */
        u16bits cd_MaxSGLen;            /* maximum # SG list entry possible */
        u16bits cd_MinSGLen;            /* minimum # SG list entry possible */
/* 0x190 */
        u32bits cd_DoorBellSkipped;     /* # door bell skipped to send cmd */
        u32bits cd_PhysDevTestDone;     /* # Physical device test done */
        u08bits cd_HostID[MDAC_MAXCHANNELS]; /* Host initiator id for each channel */
        u08bits cd_scdbChanMap[MDAC_MAXTARGETS];/* id to chan map for some OS */
        mdac_req_t MLXFAR *cd_cmdid2req[MDAC_MAXCOMMANDS+4];

        mdac_mem_t MLXFAR *cd_4KBMemList;      /* 4KB memory list */
        mdac_mem_t MLXFAR *cd_8KBMemList;      /* 8KB memory list */
        mdac_req_t MLXFAR *cd_FreeReqList;     /* Complete free request list */
        u16bits cd_FreeMemSegs4KB;
        u16bits cd_FreeMemSegs8KB;

        u32bits cd_MemAlloced4KB;
        u32bits cd_MemAlloced8KB;
        u16bits cd_MemUnAligned4KB;
        u16bits cd_MemUnAligned8KB;
        u16bits cd_ReqBufsAlloced;
        u16bits cd_ReqBufsFree;

        u32bits cd_mdac_pres_addr;
        u32bits cd_Reserved21;
        u32bits cd_Reserved22;
        u32bits cd_Reserved23;

        u32bits cd_FreeCmdIDs;                  /* # free command IDs */
/* 0x9F4 */
        mdac_cmdid_t MLXFAR *cd_FreeCmdIDList;  /* free command id pointer */
        u08bits cd_CmdTimeOutDone;              /* # Command time out done */
        u08bits cd_CmdTimeOutNoticed;           /* # Command time out noticed */
        u08bits cd_MailBoxTimeOutDone;          /* # Mail Box time out done */
        u08bits cd_Reserved15;
        u08bits cd_EndMarker[4];        /* structure end marker */
} mdac_ctldev_t;
#define mdac_ctldev_s   sizeof(mdac_ctldev_t)

#else // _WIN64 bit version follows

/* structure to store all the controller device information */
typedef struct mdac_ctldev
{
        u08bits cd_ControllerName[USCSI_PIDSIZE]; /* controller name */
/* 0x10 */
        u32bits cd_Status;              /* Controller status */
        u32bits cd_OSCap;               /* Capability for OS */
        u32bits cd_Reserved0;           /* lock for controller structure */
        u32bits cd_vidpid;              /* PCI device id + product id */
/* 0x20 */
        u08bits cd_ControllerNo;        /* Controller Number */
        u08bits cd_ControllerType;      /* type of controller */
        u08bits cd_BusType;             /* System Bus Interface Type */
        u08bits cd_BusNo;               /* System Bus No, HW is sitting on */

        u08bits cd_SlotNo;              /* System EISA/PCI/MCA Slot Number */
        u08bits cd_FuncNo;              /* PCI function number */
        u08bits cd_IrqMapped;           /* !=0 irq mapped by OS system */
        u08bits cd_TimeTraceEnabled;    /* !=0 if time trace is enabled */

        u08bits cd_MaxChannels;         /* Maximum Channels present */
        u08bits cd_MaxTargets;          /* Max # Targets/Channel supported */
        u08bits cd_MaxLuns;             /* Max # LUNs/Target supported */
        u08bits cd_MaxSysDevs;          /* Max # Logical Drives supported */

        u08bits cd_BIOSHeads;           /* # heads for BIOS */
        u08bits cd_BIOSTrackSize;       /* # sectors per track for BIOS */
        u08bits cd_MemIOSpaceNo;        /* Memory/IO space number used from PCI */
        u08bits cd_PhysChannels;        /* # of Physical Channels present */
                                        /* All allocated memory for this ctlr.
                                        ** This is done for driver release. */
/* 0x30 */
        u08bits MLXFAR*cd_CmdIDMemAddr; /* Memory addr of allocated cmd ids */
        mdac_physdev_t MLXFAR *cd_PhysDevTbl;/* Physical device table */
/* 0x40 */
        OSReq_t MLXFAR *cd_FirstWaitingOSReq;   /* First OS Request waiting */
        OSReq_t MLXFAR *cd_LastWaitingOSReq;    /* Last  OS Request waiting */
/* 0x50 */
        mdac_physdev_t MLXFAR *cd_Lastpdp;/* last+1 Physical device entry */
        mdac_reqchain_t cd_WaitingReqQ; /* Waiting Request queue */
/* 0x60 */
        mdac_reqchain_t cd_DMAWaitingReqQ;      /* Waiting Request queue for DMA resource */
        u32bits cd_DMAWaited;           /* # IO waited for DMA resource */
        u32bits cd_DMAWaiting;          /* # IO waiting for DMA resource */
/* 0x70 */
        UINT_PTR cd_irq;                 /* system's IRQ, may be vector */
        u08bits cd_IntrShared;          /* != 0, interrupt is shared */
        u08bits cd_IntrActive;          /* != 0, interrupt processing active */
        u08bits cd_InterruptVector;     /* Interrupt Vector Number */
        u08bits cd_InterruptType;       /* Interrupt Mode: Edge/Level */
/* 0x80 */
        u08bits cd_InquiryCmd;          /* inquiry command for controller */
        u08bits cd_ReadCmd;             /* Read  command for controller */
        u08bits cd_WriteCmd;            /* write command for controller */
        u08bits cd_FWTurnNo;            /* firmware turn number */
        u16bits cd_FWVersion;           /* Firmware Version Major:Minor */
        u16bits cd_MaxTags;             /* Maximum Tags supported */
        u32bits cd_ActiveCmds;          /* # commands active on cntlr */
        u32bits cd_MaxCmds;             /* Max # Concurrent commands supported*/
/* 0x90 */
        u32bits cd_MaxDataTxSize;       /* Max data transfer size in bytes */
        u32bits cd_MaxSCDBTxSize;       /* Max SCDB transfer size in bytes */
        u32bits cd_IOBaseSize;          /* IO space size */
        u32bits cd_MemBaseSize;         /* Memory space size */
/* 0xA0 */
        UINT_PTR cd_BaseAddr;            /* Physical IO/Memory Base Address */
        UINT_PTR cd_MemBasePAddr;        /* Physical Memory Base Address */
/* 0xB0 */
        UINT_PTR cd_MemBaseVAddr;        /* Virtual  Memory Base Address */
        UINT_PTR cd_BIOSAddr;            /* BIOS Address */
/* 0xC0 */
        u32bits cd_BaseSize;            /* Base IO/Memory Size */
        u32bits cd_BIOSSize;            /* BIOS size */
        UINT_PTR cd_Reserved1;
/* 0xD0 */
        UINT_PTR cd_IOBaseAddr;          /* IO Base Address */
        UINT_PTR cd_ErrorStatusReg;      /* Error Status Register */
/* 0xE0 */
        UINT_PTR cd_MailBox;             /* Mail Box starting address */
        UINT_PTR cd_CmdIDStatusReg;      /* Command ID and Status Register */
/* 0xF0 */
        UINT_PTR cd_BmicIntrMaskReg;     /* BMIC interrupt mask register */
        UINT_PTR cd_DacIntrMaskReg;      /* DAC  interrupt mask register */
/* 0x100 */
        UINT_PTR cd_LocalDoorBellReg;    /* Local Door Bell register */
        UINT_PTR cd_SystemDoorBellReg;   /* System Door Bell register */
/* 0x110 */
        UINT_PTR cd_HostLocalDoorBellReg; 
        UINT_PTR cd_HostSystemDoorBellReg;
/* 0x120 */
        UINT_PTR cd_HostCmdIDStatusReg;
        UINT_PTR cd_HostReserved;
/* 0x130 */
        u32bits cd_HostCmdQueIndex;
        u32bits cd_HostStatusQueIndex;
        u08bits MLXFAR *cd_HostCmdQue;
        u08bits MLXFAR *cd_HostStatusQue;
        u08bits cd_RebuildCompFlag;     /* Rebuild completion flag */
        u08bits cd_RebuildFlag;         /* Rebuild Flag value to keep track */
        u08bits cd_RebuildSysDevNo;     /* rebuilding system device number */
        u08bits cd_Reserved2[3];
/* 0x140 */
        mdac_lock_t cd_Lock;            /* lock for controller structure */
        u32bits cd_PhysDevTblMemSize;   /* Memory size of allocated physdevtbl*/
        u32bits cd_Reserved3;
/* 0x150 */
        u08bits cd_MinorBIOSVersion;    /* BIOS Minor Version Number */
        u08bits cd_MajorBIOSVersion;    /* BIOS Major Version Number */
        u08bits cd_InterimBIOSVersion;  /* interim revs A, B, C, etc. */
        u08bits cd_BIOSVendorName;      /* vendor name */
        u08bits cd_BIOSBuildMonth;      /* BIOS Build Date - Month */
        u08bits cd_BIOSBuildDate;       /* BIOS Build Date - Date */
        u08bits cd_BIOSBuildYearMS;     /* BIOS Build Date - Year */
        u08bits cd_BIOSBuildYearLS;     /* BIOS Build Date - Year */
        u16bits cd_BIOSBuildNo;         /* BIOS Build Number */
        u16bits cd_FWBuildNo;           /* FW Build number */
        u32bits cd_SpuriousCmdStatID;   /* Spurious command status and ID */
/* 0x160 */
#define _cp     struct  mdac_ctldev     MLXFAR *
#define _rp     struct  mdac_req        MLXFAR *
        void    (MLXFAR *cd_DisableIntr)(struct  mdac_ctldev MLXFAR *cp);  /* Disable Interrupt */
        void    (MLXFAR *cd_EnableIntr)(struct  mdac_ctldev MLXFAR *cp);   /* Enable  Interrupt */
/* 0x170 */
        u32bits (MLXFAR *cd_CheckMailBox)(struct  mdac_ctldev MLXFAR *cp); /* Check Mail Box */
        u32bits (MLXFAR *cd_PendingIntr)(struct  mdac_ctldev MLXFAR *cp);  /* Check Pending Interrupt */
	UINT_PTR cd_Reserved22;
/* 0x180 */
        u32bits (MLXFAR *cd_ReadCmdIDStatus)(struct  mdac_ctldev MLXFAR *cp);/* Read Command ID & Status */
        u32bits (MLXFAR *cd_SendCmd)(_rp);      /* Send full command */
	UINT_PTR cd_Reserved23;
/* 0x190 */
        u32bits (MLXFAR *cd_SendRWCmd)(struct  mdac_ctldev MLXFAR *cp,OSReq_t MLXFAR*,u32bits,u32bits,u32bits,u32bits,u32bits);
        u32bits (MLXFAR *cd_SendRWCmdBig)(_rp); /* send big read/write cmd */
	UINT_PTR cd_Reserved24;
/* 0x1A0 */
        u32bits (MLXFAR *cd_InitAddr)(struct  mdac_ctldev MLXFAR *cp);     /* Initialize the address */
        u32bits (MLXFAR *cd_ServiceIntr)(struct  mdac_ctldev MLXFAR *cp);  /* Service Interrupt */
	UINT_PTR cd_Reserved25;
/* 0x1B0 */
        u32bits (MLXFAR *cd_HwPendingIntr)(struct  mdac_ctldev MLXFAR *cp);/* Check Hw Pending Interrupt */
        u32bits (MLXFAR *cd_ResetController)(struct  mdac_ctldev MLXFAR *cp);/* Reset controller */
	UINT_PTR cd_Reserved26;
#undef  _cp
#undef  _rp
/* 0x1C0 */
                                                /* Statistics information */
        u32bits cd_SCDBDone;                    /* # SCDB done */
        u32bits cd_SCDBDoneBig;                 /* # SCDB done larger size */
        u32bits cd_SCDBWaited;                  /* # SCDB waited for turn */
        u32bits cd_SCDBWaiting;                 /* # SCDB waiting for turn */
/* 0x1D0 */
        u32bits cd_CmdsDone;                    /* # Read/Write commands done */
        u32bits cd_CmdsDoneBig;                 /* # R/W Cmds done larger size*/
        u32bits cd_CmdsWaited;                  /* # R/W Cmds waited for turn */
        u32bits cd_CmdsWaiting;                 /* # cmds waiting for turn */
/* 0x1E0 */
	 UINT_PTR cd_OS0;                 /* used by OS specific code */
        u32bits cd_OSCmdsWaited;        /* # OS Cmds waited at OS */
        u32bits cd_OSCmdsWaiting;       /* # cmds waiting for turn */
/* 0x1F0 */
        OSctldev_t MLXFAR *cd_OSctp;    /* OS controller pointer */
	UINT_PTR cd_Reserved4;
/* 0x200 */
        u16bits cd_CmdsDoneSpurious;    /* # commands done spurious */
        u16bits cd_IntrsDoneSpurious;   /* # interrupts done spurious */
        u32bits cd_IntrsDone;           /* # Interrupts done */
        u32bits cd_IntrsDoneWOCmd;      /* # Interrupts done without command */
        u32bits cd_MailBoxCmdsWaited;   /* # cmds waited due to MailBox Busy */
/* 0x210 */
        u32bits cd_Reads;               /* # reads done */
        u32bits cd_ReadBlks;            /* data read in 512 bytes */
        u32bits cd_Writes;              /* # writes done */
        u32bits cd_WriteBlks;           /* data written in 512 bytes */
/* 0x220 */
                                        /* physical device scan information */
        u08bits cd_PDScanChannelNo;     /* physical device scan channel no */
        u08bits cd_PDScanTargetID;      /* physical device scan target ID */
        u08bits cd_PDScanLunID;         /* physical device scan LUN ID */
        u08bits cd_PDScanValid;         /* Physical device scan is valid if non zero */
        u08bits cd_PDScanCancel;        /* if non zero Cancel the Scan process */
        u08bits cd_Reserved00;
        u16bits cd_Reserved01;
        u32bits cd_LastCmdResdSize;     /* last command residue size, (move to mdac_req) */
        u16bits cd_MaxSGLen;            /* maximum # SG list entry possible */
        u16bits cd_MinSGLen;            /* minimum # SG list entry possible */
/* 0x230 */
        mdac_cmdid_t MLXFAR *cd_FreeCmdIDList;  /* free command id pointer */
        mdac_req_t MLXFAR *cd_cmdid2req[MDAC_MAXCOMMANDS+4];
        UINT_PTR cd_mdac_pres_addr;
        mdac_mem_t MLXFAR *cd_4KBMemList;      /* 4KB memory list */
        mdac_mem_t MLXFAR *cd_8KBMemList;      /* 8KB memory list */
        mdac_req_t MLXFAR *cd_FreeReqList;     /* Complete free request list */

        u32bits cd_DoorBellSkipped;     /* # door bell skipped to send cmd */
        u32bits cd_PhysDevTestDone;     /* # Physical device test done */
        u08bits cd_HostID[MDAC_MAXCHANNELS]; /* Host initiator id for each channel */
        u08bits cd_scdbChanMap[MDAC_MAXTARGETS];/* id to chan map for some OS */

        u16bits cd_FreeMemSegs4KB;
        u16bits cd_FreeMemSegs8KB;

        u32bits cd_MemAlloced4KB;
        u32bits cd_MemAlloced8KB;
        u16bits cd_MemUnAligned4KB;
        u16bits cd_MemUnAligned8KB;
        u16bits cd_ReqBufsAlloced;
        u16bits cd_ReqBufsFree;

        u32bits cd_Reserved21;
        u32bits cd_FreeCmdIDs;                  /* # free command IDs */

        u08bits cd_CmdTimeOutDone;              /* # Command time out done */
        u08bits cd_CmdTimeOutNoticed;           /* # Command time out noticed */
        u08bits cd_MailBoxTimeOutDone;          /* # Mail Box time out done */
        u08bits cd_Reserved15;
        u08bits cd_EndMarker[4];        /* structure end marker */
} mdac_ctldev_t;
#define mdac_ctldev_s   sizeof(mdac_ctldev_t)

#endif // _WIN64


#define cd_FirstWaitingReq      cd_WaitingReqQ.rqc_FirstReq
#define cd_LastWaitingReq       cd_WaitingReqQ.rqc_LastReq
#define cd_FirstDMAWaitingReq   cd_DMAWaitingReqQ.rqc_FirstReq
#define cd_LastDMAWaitingReq    cd_DMAWaitingReqQ.rqc_LastReq

/* cd_Status bit values */
#define MDACD_PRESENT           0x00000001 /* Controller is present */
#define MDACD_BIOS_ENABLED      0x00000002 /* BIOS is enabled */
#define MDACD_BOOT_CONTROLLER   0x00000004 /* This is boot controller */
#define MDACD_HOSTMEMAILBOX32   0x00000008 /* 32 byte host memory mail box */
#define MDACD_MASTERINTRCTLR    0x00000010 /* master interrupt controller */
#define MDACD_SLAVEINTRCTLR     0x00000020 /* slave interrupt controller */
#define MDACD_HOSTMEMAILBOX     0x00000040 /* host memory memory mail box */

/* Clustering support */
#define MDACD_CLUSTER_NODE      0x00000080 /* controller is part of clustering */

/* Hot Plug PCI support */
#define MDACD_PHP_ENABLED       0x00000100 /* PCI Hot Plug supported on this controller*/
#define MDACD_CTRL_SHUTDOWN     0x00000200 /* controller is stopped by HPP service */
#define MDACD_NEWCMDINTERFACE   0x00000400 /* controller is using new command interface */


/* physical/logical device information */
#define MDAC_MAXPLDEVS  256             /* maximum physical/logical devices */
typedef struct  mdac_pldev
{
        u08bits pl_ControllerNo;        /* Controller Number */
        u08bits pl_ChannelNo;           /* SCSI Channel Number */
        u08bits pl_TargetID;            /* SCSI Target ID */
        u08bits pl_LunID;               /* SCSI LUN ID/ logical device no */

        u08bits pl_RaidType;            /* DAC Raid type */
        u08bits pl_DevType;             /* Physical / Logical device */
        u08bits pl_ScanDevState;        /* device scan state */
        u08bits pl_DevState;            /* Physical/logical device state */

        u08bits pl_inq[VIDPIDREVSIZE+8];/* 36 byts SCSI inquiry info */
        u32bits pl_DevSizeKB;           /* Device in KB */
        u32bits pl_OrgDevSizeKB;        /* original device size in KB */
} mdac_pldev_t;
#define mdac_pldev_s    sizeof(mdac_pldev_t)

/* pl_DevType */
#define MDACPLD_FREE    0x00 /* The entry is free */
#define MDACPLD_PHYSDEV 0x01 /* Physical device */
#define MDACPLD_LOGDEV  0x02 /* Physical device */

/* pl_ScanDevState */
#define MDACPLSDS_NEW           0x01 /* device information is new */
#define MDACPLSDS_CHANGED       0x02 /* device information changed */


/* device size limit record format */
#define MDAC_MAXSIZELIMITS      128     /* Max device size limit entries */
typedef struct  mda_sizelimit
{
        u32bits sl_DevSizeKB;                   /* Device size in KB */
        u08bits sl_vidpidrev[VIDPIDREVSIZE];    /* vendor, product, rev */
}mda_sizelimit_t;
#define mda_sizelimit_s sizeof(mda_sizelimit_t)


/* MDAC 4KB/8KB memory managements */
#ifdef  MLX_DOS
#define MDAC_MAX4KBMEMSEGS      0 /* # 4KB segements */
#define MDAC_MAX8KBMEMSEGS      0 /* # 8KB segements */
#else
#define MDAC_MAX4KBMEMSEGS      64 /* # 4KB segements */
#define MDAC_MAX8KBMEMSEGS      64 /* # 8KB segements */
#endif  /* MLX_DOS */

#ifdef MLX_SOL_SPARC
typedef struct mdacsol_memtbl
{
        u32bits dm_stat;        /* next memory address */
        u32bits dm_Vaddr;                       /* memory size in bytes */
        u32bits dm_AlignVaddr;                  /* memory size in bytes */
        u32bits dm_Vsize;                       /* memory size in bytes */
        u32bits dm_Paddr;                       /* memory size in bytes */
        u32bits dm_AlignPaddr;                  /* memory size in bytes */
        u32bits dm_Psize;                       /* memory size in bytes */
        ddi_dma_handle_t dm_dmahandle;
        ddi_acc_handle_t dm_acchandle;
} mdacsol_memtbl_t;
#endif

#ifndef _WIN64
/* time trace buffer management structure information */
#define MDAC_MAXTTBUFS  1024    /* maximum buffer allowed for time trace */
typedef struct  mdac_ttbuf
{
        struct  mdac_ttbuf MLXFAR *ttb_Next;    /* next buffer in chain */
        u32bits ttb_PageNo;             /* page number of this buffer */
        u32bits ttb_DataSize;           /* amount of data present in buffer */
        u08bits MLXFAR* ttb_Datap;      /* data buffer address */
} mdac_ttbuf_t;
#else
/* time trace buffer management structure information */
#define MDAC_MAXTTBUFS  1024    /* maximum buffer allowed for time trace */
typedef struct  mdac_ttbuf
{
        struct  mdac_ttbuf MLXFAR *ttb_Next;    /* next buffer in chain */
        u08bits MLXFAR* ttb_Datap;      /* data buffer address */
        u32bits ttb_PageNo;             /* page number of this buffer */
        u32bits ttb_DataSize;           /* amount of data present in buffer */
} mdac_ttbuf_t;

#endif /* if _WIN64 */
#define mdac_ttbuf_s    sizeof(mdac_ttbuf_t)

/* request sense information for logical devices */
#define MDAC_REQSENSELEN        14
typedef struct  mdac_reqsense
{
        u08bits mrqs_ControllerNo;              /* Controller number */
        u08bits mrqs_SysDevNo;                  /* system device number */
        u08bits mrqs_SenseData[MDAC_REQSENSELEN];/* sense data value */
} mdac_reqsense_t;
#define mdac_reqsense_s sizeof(mdac_reqsense_t)

#ifndef MLX_DOS
#ifndef _WIN64 /* no datarel support for _WIN64 */

/*==========================DATAREL STARTS==================================*/
typedef struct
{
        u32bits drlios_signature;       /* signature for structure */
#define DRLIOS_SIG      0x44694f73
        u32bits drlios_opstatus;        /* operation status bits */
        u32bits drlios_maxblksperio;    /* maximum io size in blocks */
        u32bits drlios_opcounts;        /* number of operations pending */

        u32bits drlios_nextblkno;       /* next block number for IOs */
        u64bits drlios_dtdone;          /* data transfered in bytes */
        u32bits drlios_diodone;         /* number of data io done */

        u32bits drlios_reads;           /* # reads done */
        u32bits drlios_writes;          /* # writes done */
        u32bits drlios_ioszrandx;       /* each IO size random base */
        u32bits drlios_ioinc;           /* IO increment size in bytes */

        u32bits drlios_rwmixrandx;      /* read/write mix random base */
        u32bits drlios_rwmixcnt;        /* % of current ops (R/W) to be done */
        u32bits drlios_startblk;        /* start block number for test */
        u32bits drlios_reserved2;

        u32bits drlios_maxblksize;      /* maximum block size */
        u32bits drlios_minblksize;      /* minimum block size */
        u32bits drlios_curblksize;      /* current block size */
        u32bits drlios_reserved0;

        u32bits drlios_randx;           /* radix value of random generater */
        u32bits drlios_randlimit;       /* random number limit */
        u32bits drlios_randups;         /* random number duplicates */
        u32bits *drlios_randbit;        /* random memory address */

        u32bits drlios_randmemsize;     /* random memory size */
        u32bits drlios_opflags;         /* operation flags */
        u32bits drlios_stime;           /* test start time in seconds */
        u32bits drlios_slbolt;          /* test start time in lbolts */

        u32bits drlios_pendingios;      /* number of ios are pending */
        u32bits drlios_datacheck;       /* != 0 data check is required */
        u32bits drlios_memaddroff;      /* memory page offset */
        u32bits drlios_memaddrinc;      /* memory address increment */

        u32bits drlios_slpchan;         /* sleep channel */
        u32bits drlios_eventrace;       /* specific value to event trace */
        u32bits drlios_eventcesr;       /* control and event select register */
        u32bits drlios_eventinx;        /* index in eventcnt array */

        u32bits drlios_curpat;          /* current pattern value */
        u32bits drlios_patinc;          /* pattern increment value */
        u32bits drlios_reserved3;
        u32bits drlios_miscnt;          /* mismatch count */

        u32bits drlios_goodpat;         /* good pattern value */
        u32bits drlios_badpat;          /* bad pattern value */
        u32bits drlios_uxblk;           /* unix block number where failed */
        u32bits drlios_uxblkoff;        /* byte offset in block */

        u32bits drlios_devcnt;          /* number of parallel devices */
        u32bits drlios_maxcylszuxblk;   /* cylinder size in unix blocks */
        u32bits drlios_bdevs[DRLMAX_BDEVS];
        mdac_ctldev_t MLXFAR*drlios_ctp[DRLMAX_BDEVS];
        u32bits drlios_eventcnt[DRLMAX_EVENT];/* event trace count */

        u32bits drlios_rqsize;          /* each io memory size */
        u32bits drlios_rqs;             /* # io buffers allocated */
        u32bits drlios_iocount;         /* test io counts */
        u32bits drlios_parallelios;     /* number of ios done in parallel */

        mdac_req_t MLXFAR*drlios_rqp[1];/* all io memory will be from here */
} drliostatus_t;
#define drliostatus_s   sizeof(drliostatus_t)
/*==========================DATAREL ENDS====================================*/
#endif /* MLX_DOS */
#endif /* _WIN64 */
#endif  /* _SYS_MDACDRV_H */

#ifdef MLX_DOS
extern u08bits MLXFAR GetPhysDeviceState(u08bits dac_state);
extern u08bits MLXFAR SetPhysDeviceState(u08bits state);
extern u08bits MLXFAR GetSysDeviceState(u08bits dac_state);
extern u08bits MLXFAR SetSysDeviceState(u08bits state);
#endif /* MLX_DOS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\sys\mbvdef.h ===
/**************************************************************************
 *                COPYRIGHT (C) Mylex Corporation 1992-1997               *
 *                                                                        *
 * This software is furnished under a license and may be used and copied  * 
 * only in accordance with the terms and conditions of such license and   * 
 * with inclusion of the above copyright notice. This software or any     * 
 * other copies thereof may not be provided or otherwise made available   * 
 * to any other person. No title to, nor ownership of the software is     * 
 * hereby transferred.                                                    *
 *                                                                        *
 * The information in this software is subject to change without notices  *
 * and should not be construed as a commitment by Mylex Corporation       *
 *                                                                        *
 **************************************************************************/
#ifndef INC_MBVDEF_H
#define INC_MBVDEF_H
char *MbvStartStr =	"MYLEX SOFTWARE VERSION START";
char *MbvEndStr =	"MYLEX SOFTWARE VERSION END.";

#define MBV_BUF_SIZE	256
#define MBV_MAX_BUF	0x01100
#define MBV_MAX_READ	0x1000

#define MBV_TOG_NOCHANGE	0
#define MBV_TOG_START_LOWER	1
#define MBV_TOG_START_UPPER	2

#define MBV_INFO	1
#define	MBV_HDR_LEN	33
#define	MBV_VER_LEN	8
#define	MBV_DATE_LEN	11 /* was 12 */
#define	MBV_OS_LEN	16 /*was 8*/
#define	MBV_RSVD_LEN	64
#define	MBV_CSUM_LEN	4
#define	MBV_TRAIL_LEN	28
typedef	struct {
	char header[MBV_HDR_LEN];
	char version[MBV_VER_LEN+1];
	char releasedate[MBV_DATE_LEN+1];
	char platform[MBV_OS_LEN+1];
	char reserved[MBV_RSVD_LEN+1];
	char checksum[MBV_CSUM_LEN+1];
	char trailer[MBV_TRAIL_LEN+1];
} MbvRec;
#define dec2hex(x)	(((x) < 10) ? ('0' + (x)) : ('A' + (x) - 10))
#define hex2dec(x)	(((x) >= '0' && (x) <= '9') ? (x) - 0x30 : (x) - 0x37)

#ifdef	MBV_DEBUG
#define DBGMSG(s)	s
#else
#define DBGMSG(s)	
#endif

typedef	unsigned char uchar;
typedef	unsigned int uint;
typedef	unsigned short ushort;
typedef	unsigned long ulong;

int MbvCopy(char *src, char *dst, int toggle);
ushort MbvCsum(uchar *addr, int size);

#endif /*INC_MBVDEF_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\sys\mdacntd.h ===
/**************************************************************************
 *                COPYRIGHT (C) Mylex Corporation 1992-1998               *
 *                                                                        *
 * This software is furnished under a license and may be used and copied  * 
 * only in accordance with the terms and conditions of such license and   * 
 * with inclusion of the above copyright notice. This software or any     * 
 * other copies thereof may not be provided or otherwise made available   * 
 * to any other person. No title to, nor ownership of the software is     * 
 * hereby transferred.                                                    *
 *                                                                        *
 * The information in this software is subject to change without notices  *
 * and should not be construed as a commitment by Mylex Corporation       *
 *                                                                        *
 **************************************************************************/

/*++

Module Name:

    Dac960Nt.h

Abstract:

    This is header file for the driver for the Mylex DiskArray Controller family.

Author:


Environment:

    kernel mode only

Revision History:

--*/

#define MAX_ACCESS_RANGES_PER_PCI_DEVICE        4
#define MAX_PCI_DEVICES_PER_CONTROLLER          4


typedef struct  memfrag
{
	unsigned char *         mf_Addr;        /* starting address of this fragment */
	unsigned long           mf_Size;        /* size of this fragment */
} memfrag_t;
#define memfrag_s       sizeof(memfrag_t)

/* for this allocation, the page size is 16 bits */
#define MAXMEMSIZE      ((u32bits)(1024 * 384))       /* 384 KB */
#define REDUCEDMEMSIZE  ((u32bits)(1024 * 44))       /* 44 KB */
#define MAXMEMFRAG      1024            /* Maximum memory fragments allowed */

/* the following defines still work under W64 - we can still manage 
	our internal memory pool in 4k chunks even though the system
	page size is 8k or something larger
*/
#define MEMOFFSET       0x00000FFFL     /* to get our memory offset */
#define MEMPAGE         0xFFFFF000L     /* to get memory page */


#if defined(MLX_NT)

#define GAM_SUPPORT     1

//
// Hot Plug Support
//

#ifndef BYTE
#define BYTE unsigned char
#endif

#ifndef WORD
#define WORD unsigned short
#endif

#ifndef DWORD
#define DWORD unsigned long
#endif

#ifndef INT
#define INT int
#endif

#ifndef STATIC
#if DBG
#define STATIC
#else
#define STATIC static
#endif
#endif

#include "scsi.h"
#include "hppif3p.h"
#include "hppifevt.h"

//
// PCI Hot Plug Definitions
//

#define MLX_HPP_SIGNATURE               "MYLEXPHP"

#define TIMER_TICKS_PER_SEC             1000000

#define MDACD_HOLD_IO(pExtension)       (pExtension->stateFlags |= PCS_HBA_OFFLINE)
#define MDACD_FREE_IO(pExtension)       (pExtension->stateFlags &= ~PCS_HBA_OFFLINE)

#define IOS_HPP_HBA_EXPANDING           0x00001070
#define IOS_HPP_HBA_CACHE_IN_USE        0x00001075
#define IOS_HPP_BAD_REQUEST             0x000010ff

#define EVT_DRIVEARRAY_SUBSYSTEM        0x13;
#define EVT_ARRAY_CTRL_FAILED           0x01;
#define EVT_ARRAY_CTRL_NORMAL           0x02;

#define EVT_TYPE_RCMC                   0x00
#define EVT_TYPE_SYSLOG                 0x01

/* Event Log Drive Array Sub-system structs */

typedef struct _EVT_ARRAY_CTRL
{
    EVT_CHASSIS Chassis;                /* Standard chassis info */
    BYTE bSlot;                         /* slot number (0 == system board) */
    CHAR cChassisName[1];               /* Chassis name, '\0' if undefined */
} EVT_ARRAY_CTRL, *PEVT_ARRAY_CTRL;

#define EVT_HBA_FAIL(event, driverId, boardId, slot) {          \
    PEVT_ARRAY_CTRL pEventArrayCtrl;                            \
    pEventArrayCtrl = (PEVT_ARRAY_CTRL) &event.ulEventData;     \
    event.ulEventId = HR_DD_LOG_EVENT;                          \
    event.ulSenderId = driverId;                                \
    event.ucEventSeverity = EVT_STAT_FAILED;                    \
    event.usEventDataLength = sizeof(EVT_ARRAY_CTRL);           \
    event.usEventClass = EVT_DRIVEARRAY_SUBSYSTEM;              \
    event.usEventCode = EVT_ARRAY_CTRL_FAILED;                  \
    pEventArrayCtrl->Chassis.bType = EVT_CHASSIS_SYSTEM;        \
    pEventArrayCtrl->Chassis.bId = boardId;                     \
    pEventArrayCtrl->Chassis.bPort = 0;                         \
    pEventArrayCtrl->bSlot = slot;                              \
    pEventArrayCtrl->cChassisName[0] = 0;                       \
}

#define EVT_HBA_REPAIRED(event, driverId, boardId, slot) {      \
    PEVT_ARRAY_CTRL pEventArrayCtrl;                            \
    pEventArrayCtrl = (PEVT_ARRAY_CTRL) &event.ulEventData;     \
    event.ulEventId = HR_DD_LOG_EVENT;                          \
    event.ulSenderId = driverId;                                \
    event.ucEventSeverity = EVT_STAT_REPAIRED;                  \
    event.usEventDataLength = sizeof(EVT_ARRAY_CTRL);           \
    event.usEventClass = EVT_DRIVEARRAY_SUBSYSTEM;              \
    event.usEventCode = EVT_ARRAY_CTRL_FAILED;                  \
    pEventArrayCtrl->Chassis.bType = EVT_CHASSIS_SYSTEM;        \
    pEventArrayCtrl->Chassis.bId = boardId;                     \
    pEventArrayCtrl->Chassis.bPort = 0;                         \
    pEventArrayCtrl->bSlot = slot;                              \
    pEventArrayCtrl->cChassisName[0] = 0;                       \
}

typedef struct _MDAC_HPP_IOCTL_BUFFER {

    SRB_IO_CONTROL      Header;
    UCHAR               ReturnData[1];

} MDAC_HPP_IOCTL_BUFFER, *PMDAC_HPP_IOCTL_BUFFER;

typedef struct _MDAC_HPP_RCMC_DATA {

    ULONG               serviceStatus;
    ULONG               driverId;
    PHR_CALLBACK        healthCallback;
    ULONG               controllerChassis;
    ULONG               physicalSlot;

} MDAC_HPP_RCMC_DATA, *PMDAC_HPP_RCMC_DATA;

typedef struct _MDAC_PCI_DEVICE_INFO {

    UCHAR       busNumber;
    UCHAR       deviceNumber;
    UCHAR       functionNumber;
    UCHAR       baseClass;

} MDAC_PCI_DEVICE_INFO, *PMDAC_PCI_DEVICE_INFO;

#define CTRL_STATUS_INSTALLATION_ABORT  0x00000001
#define MDAC_CTRL_HOTPLUG_SUPPORTED     0x00000001

//
// Pseudo Device extension
//

typedef struct _PSEUDO_DEVICE_EXTENSION {

    ULONG               driverID;
    ULONG               hotplugVersion;
    PHR_CALLBACK        eventCallback;
    PSCSI_REQUEST_BLOCK completionQueueHead;
    PSCSI_REQUEST_BLOCK completionQueueTail;
    ULONG               numberOfPendingRequests;
    ULONG               numberOfCompletedRequests;

} PSEUDO_DEVICE_EXTENSION, *PPSEUDO_DEVICE_EXTENSION;

//
// Device extension
//

typedef struct CAD_DEVICE_EXTENSION {

    struct mdac_ctldev          *ctp;
    ULONG                       busInterruptLevel;
    ULONG                       ioBaseAddress;
    ULONG                       numAccessRanges;
    ULONG                       accessRangeLength[MAX_ACCESS_RANGES_PER_PCI_DEVICE];

    ULONG                       numPCIDevices;
    ULONG                       status;
    ULONG                       stateFlags;
    ULONG                       controlFlags;
    MDAC_HPP_RCMC_DATA          rcmcData;
    MDAC_PCI_DEVICE_INFO        pciDeviceInfo[MAX_PCI_DEVICES_PER_CONTROLLER];
	memfrag_t               freemem[MAXMEMFRAG];
	memfrag_t               *lastmfp;
	PVOID                   lastSrb;
	PVOID                   lastErrorSrb;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

typedef struct _MIOC_REQ_HEADER {

	SRB_IO_CONTROL  SrbIoctl;
	ULONG           Command;

} MIOC_REQ_HEADER, *PMIOC_REQ_HEADER;

#else

// Device extension

typedef struct CAD_DEVICE_EXTENSION {

    struct mdac_ctldev  *ctp;
    ULONG               busInterruptLevel;
    ULONG               ioBaseAddress;
    ULONG               numAccessRanges;
    ULONG               accessRangeLength[MAX_ACCESS_RANGES_PER_PCI_DEVICE];
	memfrag_t       freemem[MAXMEMFRAG];
	memfrag_t       *lastmfp;
	PVOID                   lastSrb;
	PVOID                   lastErrorSrb;


} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#define MDAC_MEM_LIST_SIZE      1024

#ifndef IA64
	#define PAGE_SIZE               4096
	#define PAGE_SHIFT              12
#endif

typedef struct _MIOC_REQ_HEADER {
	ULONG           Command;
} MIOC_REQ_HEADER, *PMIOC_REQ_HEADER;

typedef struct _MDAC_MEM_BLOCK {

    UINT_PTR    physicalAddress;
    ULONG       virtualPageNumber;      // vaddress >> 12
    ULONG       size;                   // in pages
    ULONG       used;                   // 1: used

} MDAC_MEM_BLOCK, *PMDAC_MEM_BLOCK;

#endif

#define MDACNT_1SEC_TICKS       -10000000       // For 1 second interval       

#define MAXIMUM_EISA_SLOTS  0x10
#define MAXIMUM_CHANNELS 0x05
#define DAC960_SYSTEM_DRIVE_CHANNEL 0x03

#ifdef GAM_SUPPORT
#define GAM_DEVICE_PATH_ID      0x04
#define GAM_DEVICE_TARGET_ID    0x06
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\sys\mdacver.h ===
#ifndef INC_MDACVER_H
#define INC_MDACVER_H
#define DGA_DRV_MAJ 6
#define DGA_DRV_MIN 00
#define DGA_DRIVER_VERSION 0x600
#define DGA_DBM 8
#define DGA_DBD 27
#define DGA_DBC 20
#define DGA_DBY 00
#define DGA_DBN 21
#undef VER_FILEVERSION
#undef VER_FILEVERSION_STR
#undef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION_STR
#undef VER_BUILD_DATE_STR
#define VER_FILEVERSION 6,00,21,0
#define VER_FILEVERSION_STR "6.00-21"
#define VER_PRODUCTVERSION 6,00,21,0
#define VER_PRODUCTVERSION_STR "6.00-21"
#define VER_BUILD_DATE_STR "27 Aug 2000"
static char *mdacverData = "MyLeX SoFtWaRe vErSiOn sTaRt 001:6.00-21  Aug 27 2000 Windows 2000                                                                      B123 mYlEx sOfTwArE VeRsIoN EnD. ";
#endif /*INC_MDACVER_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\sys\mlxhw.h ===
/**************************************************************************
 *                COPYRIGHT (C) Mylex Corporation 1992-1996               *
 *                                                                        *
 * This software is furnished under a license and may be used and copied  * 
 * only in accordance with the terms and conditions of such license and   * 
 * with inclusion of the above copyright notice. This software or any     * 
 * other copies thereof may not be provided or otherwise made available   * 
 * to any other person. No title to, nor ownership of the software is     * 
 * hereby transferred.                                                    *
 *                                                                        *
 * The information in this software is subject to change without notices  *
 * and should not be construed as a commitment by Mylex Corporation       *
 *                                                                        *
 **************************************************************************/

#ifndef	_SYS_MLXHW_H
#define	_SYS_MLXHW_H

/* get the difference of two clock counts. The clock value comes from
** PIT2 and it counts from 0xFFFF to 0.
*/
#define	mlxclkdiff(nclk,oclk) (((nclk)>(oclk))? (0x10000-(nclk)+(oclk)):((oclk)-(nclk)))
#define	MLXHZ	100		/* assume all OS run at 100 ticks/second */
#define	MLXKHZ	1000		/* not binary number 1024 */
#define	MLXMHZ	(MLXKHZ * MLXKHZ)
#define	MLXCLKFREQ	1193180	/* clock frequency fed to PIT */
#define	MLXUSEC(clk)	(((clk)*MLXMHZ)/MLXCLKFREQ)

#endif	/* _SYS_MLXHW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\sys\mlxdisk.h ===
/*************************************************************************
 *                COPYRIGHT (C) Mylex Corporation 1992-1998               *
 *                                                                        *
 * This software is furnished under a license and may be used and copied  * 
 * only in accordance with the terms and conditions of such license and   * 
 * with inclusion of the above copyright notice. This software or any     * 
 * other copies thereof may not be provided or otherwise made available   * 
 * to any other person. No title to, nor ownership of the software is     * 
 * hereby transferred.                                                    *
 *                                                                        *
 * The information in this software is subject to change without notices  *
 * and should not be construed as a commitment by Mylex Corporation       *
 *                                                                        *
 **************************************************************************/

#ifndef _MLXDISK_H

#define _MLXDISK_H


#define INQUIRY_DATA_SIZE	2048
#define MAX_MLX_DISK_DEVICES	256

// Per Partition Information

#define MLX_DISK_DEVICE_STATE_INITIALIZED	0x00000001

typedef struct _MLX_DISK_EXTENSION {

	PDEVICE_OBJECT DeviceObject;
	PDEVICE_OBJECT TargetDeviceObject;
    PDEVICE_OBJECT PhysicalDeviceObject;        // PDO @For Win2K
    ULONG          (*ReadWrite)();
	ULONG	       Reserved[2];

	LARGE_INTEGER  StartingOffset;
	LARGE_INTEGER  PartitionLength;
	PIRP		   IrpQueHead;
	PIRP		   IrpQueTail;
	ULONG		   IrpCount;
	ULONG		   Reserved2;                      // @For 64bit alignment

    KEVENT         PagingPathCountEvent;           // @For Win2K
    ULONG          PagingPathCount;                // @For Win2K
    ULONG          Reserved3;                      // @For 64bit alignment

	u32bits        State;
	u08bits        ControllerNo;
	u08bits        PathId;
	u08bits        TargetId;
	u08bits        Reserved4;                      // @For 64bit alignment

	u32bits        PartitionNo;
	u08bits        LastPartitionNo;
	u08bits        DiskNo;
	u08bits        PartitionType;
	u08bits        SectorShift;

	u32bits        BytesPerSector;
	u32bits        BytesPerSectorMask;

} MLXDISK_DEVICE_EXTENSION, *PMLXDISK_DEVICE_EXTENSION;

typedef struct _MIOC_REQ_HEADER {

        SRB_IO_CONTROL  SrbIoctl;
        ULONG		Command;

} MIOC_REQ_HEADER, *PMIOC_REQ_HEADER;

#define	MLX_REQ_DATA_SIZE 1024
typedef struct _MLX_REQ {
    MIOC_REQ_HEADER MiocReqHeader;
    UCHAR Data[MLX_REQ_DATA_SIZE];
} MLX_REQ;

typedef struct _MLX_COMPLETION_CONTEXT {
    SCSI_REQUEST_BLOCK  Srb;
    MDL	                Mdl;
    ULONG		Pages[4];
    KEVENT		Event;
    IO_STATUS_BLOCK	IoStatusBlock;
    union _generic_buffer {
	DISK_GEOMETRY	DiskGeometry;
	PARTITION_INFORMATION PartitionInformation[MAX_MLX_DISK_DEVICES + 1];
	UCHAR		InquiryDataPtr[INQUIRYDATABUFFERSIZE];
	UCHAR		ReadCapacityBuffer[sizeof(READ_CAPACITY_DATA)];
	UCHAR           ScsiBusData[INQUIRY_DATA_SIZE];
	MLX_REQ		MlxIoctlRequest;
    } buf;

} MLX_COMPLETION_CONTEXT, *PMLX_COMPLETION_CONTEXT;

#define MAX_MLX_CTRL	32

#define MLX_CTRL_STATE_ENLISTED     0x00000001
#define MLX_CTRL_STATE_INITIALIZED	0x00000002

typedef struct {
    ULONG State;
    ULONG ControllerNo;
    ULONG PortNumber;
} MLX_CTRL_INFO;

typedef struct {
    PVOID CtrlPtr;
    PVOID AdpObj;
    UCHAR CtrlNo;
    UCHAR MaxMapReg;
    USHORT Reserved;
//    mdac_req_t *FreeReqList;
//    mdac_req_t *CompReqHead;
//    PIRP IrpQueHead;
//    PIRP IrpQueTail;
//    PKDPC Dpc;
} MLX_MDAC_INFO, *PMLX_MDAC_INFO;

#define	MLX_MAX_REQ_BUF	512		// Per Controller

#define	MLX_MAX_IRP_TRACE	0x1000
#define	MLX_MAX_IRP_TRACE_MASK	(MLX_MAX_IRP_TRACE -1)
typedef	struct {
	ULONG Tx1;
	ULONG Tx2;
	ULONG Tx3;
	ULONG Rx;
} IRP_TRACE_INFO;

#endif // _MLXDISK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\sys\mlxparam.h ===
/**************************************************************************
 *                COPYRIGHT (C) Mylex Corporation 1992-1996               *
 *                                                                        *
 * This software is furnished under a license and may be used and copied  * 
 * only in accordance with the terms and conditions of such license and   * 
 * with inclusion of the above copyright notice. This software or any     * 
 * other copies thereof may not be provided or otherwise made available   * 
 * to any other person. No title to, nor ownership of the software is     * 
 * hereby transferred.                                                    *
 *                                                                        *
 * The information in this software is subject to change without notices  *
 * and should not be construed as a commitment by Mylex Corporation       *
 *                                                                        *
 **************************************************************************/

#ifndef	_SYS_MLXPARAM_H
#define	_SYS_MLXPARAM_H

/*
** This files defines different parameter limit values.
*/

#define	DGA_MAXOSICONTROLLERS	32/* maximum GAM OS interface controllers */

#define	HBA_MAXCONTROLLERS	8 /* maximum HBA controllers */
#define	HBA_MAXFLASHPOINTS	8 /* maximum flash point adapters */
#define	HBA_MAXMULTIMASTERS	8 /* maximum multimasters */
#define MAX_CARDS		8 /* only for budioctl.h */

/* name sizes in bytes */
#define	MLX_DEVGRPNAMESIZE	32 /* device group name size */
#define	MLX_DEVNAMESIZE		32 /* device name size */

#endif	/* _SYS_MLXPARAM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\sys\mlxperf.h ===
/**************************************************************************
 *                COPYRIGHT (C) Mylex Corporation 1992-1998               *
 *                                                                        *
 * This software is furnished under a license and may be used and copied  * 
 * only in accordance with the terms and conditions of such license and   * 
 * with inclusion of the above copyright notice. This software or any     * 
 * other copies thereof may not be provided or otherwise made available   * 
 * to any other person. No title to, nor ownership of the software is     * 
 * hereby transferred.                                                    *
 *                                                                        *
 * The information in this software is subject to change without notices  *
 * and should not be construed as a commitment by Mylex Corporation       *
 *                                                                        *
 **************************************************************************/

#ifndef	_SYS_MLXPERF_H
#define	_SYS_MLXPERF_H

/*
** This files contains the structure required to store the performance data.
** One should be able to get the whole system and operation information
** from the given performance data file. Each performance record has fixed
** header size of 4 bytes. The first byte defines the record type,
** for example, physical drive information, logical drive information, etc.
**
** The optimization has been done to reduce the store space but it will
** increase the processing overhead.
**
** The data will be packed in page by page basis. Therefore one page of data
** will carry absolute time. This will help in doing forward and backward
** skiping from given location.
**
** FEW RULES:
**	1. ABSOLUTE Time record after Every PAUSE record, biginning of every
**	   page, if relative time is greater than 10 minutes.
**
** PERFORMANCE DATA COLLECTION UNDER GAM
** The data collection is be done by GAM driver at highest rate specified
** by any program. The fastest rate of statistics collection is 1 sample per
** second. Only one statistics is collected for all programs collecting
** statistics. The program reads the statistics data from GAM driver by page
** numbers (0,1,2,3,...,4g-2,4g-1,0). The GAM driver has 16 pages where it
** collects statistics. If no one reads and all buffers are full, it stop
** the statistics collection and put a PAUSE record automatically. It reenables
** the collection if some one reads. It collects the following:
**
** 1. Controllers information enable time and when changed.
** 2. Physical drives information enable time and when changed.
** 3. Logical drives information enable time and when changed.
** 4. Physical drives performance data.
** 5. Logical drives performance data.
*/

#define	MLXPERF_HEADER_VERSION100 0x10 /* bit 7..4 major, bit 3..0 minor */
#define	MLXPERF_HEADER_VERSION	0x10
#define	mlxperf_majorversion(x)	((x)>>4)
#define	mlxperf_minorversion(x)	((x)&0x0F)

#define	MLXPERF_PAGESIZE	4096
#define	MLXPERF_PAGEOFFSET	(MLXPERF_PAGESIZE-1)
#define	MLXPERF_PAGEMASK	(~MLXPERF_PAGEOFFSET)

/* The different record types */
#define	MLXPERF_SIGNATURE	0x01 /* signature */
#define	MLXPERF_VERSION		0x02 /* version */
#define	MLXPERF_CREATIONDAY	0x03 /* data creation day */
#define	MLXPERF_RESERVED	0x04 /* reserved space */
#define	MLXPERF_PAUSE		0x05 /* pause, data capture stopped */
#define	MLXPERF_SYSTEMIP	0x06 /* system IP address */
#define	MLXPERF_ABSTIME		0x07 /* data capture time in secs from 1970 */
#define	MLXPERF_RELTIME		0x08 /* relative time in 10 ms from last time */
#define	MLXPERF_SYSTEMINFO	0x09 /* system information */
#define	MLXPERF_CONTROLLERINFO	0x0A /* controller information */
#define	MLXPERF_PHYSDEVINFO	0x0B /* Physical device information */
#define	MLXPERF_SYSDEVINFO	0x0C /* System Device information */
#define	MLXPERF_UNUSEDSPACE	0x0D /* rest of the page is unused */
#define	MLXPERF_DRIVER		0x0E /* protocol driver version */
#define	MLXPERF_SYSTARTIME	0x0F /* system start time */
#define	MLXPERF_TIMETRACE	0x10 /* performance time trace data */
#define	MLXPERF_SAMPLETIME	0x11 /* performance sample period time */

				     /* physical device read performance data */
#define	MLXPERF_PDRDPERF1B	0x20 /* each field is 1 byte long */
#define	MLXPERF_PDRDPERF2B	0x21 /* each field is 2 byte long */
#define	MLXPERF_PDRDPERF4B	0x22 /* each field is 4 byte long */
#define	MLXPERF_PDRDPERF8B	0x23 /* each field is 8 byte long */

				     /* physical device write performance data */
#define	MLXPERF_PDWTPERF1B	0x24 /* each field is 1 byte long */
#define	MLXPERF_PDWTPERF2B	0x25 /* each field is 2 byte long */
#define	MLXPERF_PDWTPERF4B	0x26 /* each field is 4 byte long */
#define	MLXPERF_PDWTPERF8B	0x27 /* each field is 8 byte long */

				     /* physical device read+write performance data */
#define	MLXPERF_PDRWPERF1B	0x28 /* each field is 1 byte long */
#define	MLXPERF_PDRWPERF2B	0x29 /* each field is 2 byte long */
#define	MLXPERF_PDRWPERF4B	0x2A /* each field is 4 byte long */
#define	MLXPERF_PDRWPERF8B	0x2B /* each field is 8 byte long */

				     /* system device read performance data */
#define	MLXPERF_SDRDPERF1B	0x30 /* each field is 1 byte long */
#define	MLXPERF_SDRDPERF2B	0x31 /* each field is 2 byte long */
#define	MLXPERF_SDRDPERF4B	0x32 /* each field is 4 byte long */
#define	MLXPERF_SDRDPERF8B	0x33 /* each field is 8 byte long */

				     /* system device write performance data */
#define	MLXPERF_SDWTPERF1B	0x34 /* each field is 1 byte long */
#define	MLXPERF_SDWTPERF2B	0x35 /* each field is 2 byte long */
#define	MLXPERF_SDWTPERF4B	0x36 /* each field is 4 byte long */
#define	MLXPERF_SDWTPERF8B	0x37 /* each field is 8 byte long */

				     /* system device read+write performance data */
#define	MLXPERF_SDRWPERF1B	0x38 /* each field is 1 byte long */
#define	MLXPERF_SDRWPERF2B	0x39 /* each field is 2 byte long */
#define	MLXPERF_SDRWPERF4B	0x3A /* each field is 4 byte long */
#define	MLXPERF_SDRWPERF8B	0x3B /* each field is 8 byte long */


/* Performance Data Header */
typedef  struct mlxperf_header
{
	u08bits	ph_RecordType;	/* Record Type */
	u08bits	ph_CtlChan;	/* bit 7..5 Channel, bit 4..0 controller */
	u08bits	ph_TargetID;	/* TargetID of the device */
	u08bits	ph_LunID;	/* LUN ID/Logical device number */
} mlxperf_header_t;
#define	mlxperf_header_s	sizeof(mlxperf_header_t)

typedef	struct mlxperf_hd
{
	mlxperf_header_t perfhd;	/* performance header */
} mlxperf_hd_t;
#define	mlxperf_hd_s	sizeof(mlxperf_hd_t)

/* if structure has defined perfhd as first field, it can use following names */
#define	MlxPerfRecordType	perfhd.ph_RecordType
#define	MlxPerfCtlChan		perfhd.ph_CtlChan
#define	MlxPerfTargetID		perfhd.ph_TargetID
#define	MlxPerfLunID		perfhd.ph_LunID
#define	MlxPerfSysDevNo		MlxPerfLunID

#define	mlxperf_getctl(hp)	((hp)->MlxPerfCtlChan&0x1F) /* get controller */
#define	mlxperf_getchan(hp)	((hp)->MlxPerfCtlChan>>5) /* get channel no */
#define	mlxperf_setctlchan(hp,ctl,chan) ((hp)->MlxPerfCtlChan=((chan)<<5)|(ctl))

/* MLXPEFF_SIGNATURE structure */
#define	MLXPERF_SIGSIZE	60	/* signature value size in bytes */
#define	MLXPERF_SIGSTR	"Mylex Performance Data"
typedef	struct mlxperf_signature
{
	mlxperf_header_t perfhd;		/* performance header */
	u08bits	sig_Signature[MLXPERF_SIGSIZE];	/* Signature value */
} mlxperf_signature_t;
#define	mlxperf_signature_s	sizeof(mlxperf_signature_t)


/* MLXPEFF_VERSION structure */
typedef	struct mlxperf_version
{
	mlxperf_header_t perfhd;	/* performance header */
} mlxperf_version_t;
#define	mlxperf_version_s	sizeof(mlxperf_version_t)
#define	MlxPerfVersion		MlxPerfLunID /* major+minor version number */


/* MLXPERF_CREATIONDAY structure */
#define	MLXPERF_CRDSTRSIZE	124 /* creation string size in bytes */
#define	MLXPERF_CRDSTR	"Created on July 4, 1997 at 17:00 PST by system test for Mylex Corporation"
typedef	struct mlxperf_creationday
{
	mlxperf_header_t perfhd;		/* performance header */
	u08bits	cr_daystr[MLXPERF_CRDSTRSIZE];	/* creation day string format */
} mlxperf_creationday_t;
#define	mlxperf_creationday_s	sizeof(mlxperf_creationday_t)

/* MLXPERF_UNUSEDSPACE structure */
/* Only the first byte of the header is valid, the rest of the data should be
** zero. Therefore, this can be used to ignore 1 to n bytes at end of the page.
** There should not be any data in the after this record. All information after
** this record should be zero.
*/

/* MLXPERF_RESERVED structure */
typedef	struct mlxperf_reserved
{
	mlxperf_header_t perfhd;		/* performance header */
} mlxperf_reserved_t;
#define	mlxperf_reserved_s	sizeof(mlxperf_reserved_t)
#define	MlxPerfReservedSize	MlxPerfLunID	/* Reserved Data Size including header */

/* MLXPERF_PAUSE structure */
typedef	struct mlxperf_pause
{
	mlxperf_header_t perfhd;		/* performance header */
} mlxperf_pause_t;
#define	mlxperf_pause_s	sizeof(mlxperf_pause_t)

/* MLXPERF_SYSTEMIP structure */
typedef	struct mlxperf_systemip
{
	mlxperf_header_t perfhd;	/* performance header */
	u32bits	sip_IPAddr;		/* system's internet address */
} mlxperf_systemip_t;
#define	mlxperf_systemip_s	sizeof(mlxperf_systemip_t)

/* MLXPERF_ABSTIME and MLXPERF_SYSTARTIME structure */
typedef	struct mlxperf_abstime
{
	u08bits	abs_RecordType;		/* Record Type */
					/* abosulte time in 10 ms from system start */
	u08bits	abs_Time10ms2;		/* Bit 23..16 */
	u08bits	abs_Time10ms1;		/* Bit 15..08 */
	u08bits	abs_Time10ms0;		/* Bit 07..00 */
	u32bits	abs_Time;		/* absolute time in seconds from 1970 */
} mlxperf_abstime_t;
#define	mlxperf_abstime_s	sizeof(mlxperf_abstime_t)

/* MLXPERF_RELTIME structure */
typedef	struct mlxperf_reltime
{
	u08bits	rel_RecordType;		/* Record Type */
	u08bits	rel_Reserved;
	u16bits	rel_Time;		/* relative time in 10 ms from last */
} mlxperf_reltime_t;
#define	mlxperf_reltime_s	sizeof(mlxperf_reltime_t)

/* MLXPERF_SAMPLETIME structure */
typedef	struct mlxperf_sampletime
{
	u08bits	sample_RecordType;	/* Record Type */
	u08bits	sample_Reserved;
	u16bits	sample_Time;		/* sample time in 10 ms */
} mlxperf_sampletime_t;
#define	mlxperf_sampletime_s	sizeof(mlxperf_sampletime_t)

/* MLXPERF_SYSTEMINFO */
typedef	struct mlxperf_systeminfo
{
	mlxperf_header_t perfhd;	/* performance header */

	u32bits	si_MemorySizeKB;	/* Memory size in KB */
	u32bits	si_CPUCacheSizeKB;	/* CPU cache size in KB */
	u32bits	si_SystemCacheLineSize;	/* system cache line size in bytes */


	u08bits	si_cpus;		/* # CPUs on the system */
	u08bits	si_DiskControllers;	/* # Disk controllers */
	u08bits	si_NetworkControllers;	/* # Network controllers */
	u08bits	si_MiscControllers;	/* # Misc controllers */

	u16bits	si_PhysDevsOffline;	/* # physical devices dead */
	u16bits	si_PhysDevsCritical;	/* # physical devices critical */

	u16bits	si_PhysDevs;		/* # Physical Devs currently detected */
	u16bits	si_SysDevs;		/* # Logical devs currently configured*/
	u16bits	si_SysDevsOffline;	/* # logical device offline */
	u16bits	si_SysDevsCritical;	/* # logical devices are critial */


	u08bits	si_MinorGAMDriverVersion;/* Driver Minor Version Number */
	u08bits	si_MajorGAMDriverVersion;/* Driver Major Version Number */
	u08bits	si_InterimGAMDriverVersion;/* interim revs A, B, C, etc. */
	u08bits	si_GAMDriverVendorName;	/* vendor name */
	u08bits	si_GAMDriverBuildMonth;	/* Driver Build Date - Month */
	u08bits	si_GAMDriverBuildDate;	/* Driver Build Date - Date */
	u08bits	si_GAMDriverBuildYearMS;/* Driver Build Date - Year */
	u08bits	si_GAMDriverBuildYearLS;/* Driver Build Date - Year */
	u16bits	si_GAMDriverBuildNo;	/* Driver Build Number */
	u16bits	si_Reserved0;

	u32bits	si_Reserved5;

	u32bits	si_Reserved10;
	u32bits	si_Reserved11;
	u32bits	si_Reserved12;
	u32bits	si_Reserved13;


	u32bits	si_Reserved20;
	u32bits	si_Reserved21;
	u32bits	si_Reserved22;
	u32bits	si_Reserved23;

	u32bits	si_Reserved24;
	u32bits	si_Reserved25;
	u32bits	si_Reserved26;
	u32bits	si_Reserved27;

	u32bits	si_Reserved28;
	u32bits	si_Reserved29;
	u32bits	si_Reserved2A;
	u32bits	si_Reserved2B;

	u32bits	si_Reserved2C;
	u32bits	si_Reserved2D;
	u32bits	si_Reserved2E;
	u32bits	si_Reserved2F;

	u32bits	si_Reserved30;
	u32bits	si_Reserved31;
	u32bits	si_Reserved32;
	u32bits	si_Reserved33;

	u32bits	si_Reserved34;
	u32bits	si_Reserved35;
	u32bits	si_Reserved36;
	u32bits	si_Reserved37;

	u32bits	si_Reserved38;
	u32bits	si_Reserved39;
	u32bits	si_Reserved3A;
	u32bits	si_Reserved3B;

	u32bits	si_Reserved3C;
	u32bits	si_Reserved3D;
	u32bits	si_Reserved3E;
	u32bits	si_Reserved3F;

	u32bits	si_Reserved40;
	u32bits	si_Reserved41;
	u32bits	si_Reserved42;
	u32bits	si_Reserved43;

	u32bits	si_Reserved44;
	u32bits	si_Reserved45;
	u32bits	si_Reserved46;
	u32bits	si_Reserved47;

	u32bits	si_Reserved48;
	u32bits	si_Reserved49;
	u32bits	si_Reserved4A;
	u32bits	si_Reserved4B;

	u32bits	si_Reserved4C;
	u32bits	si_Reserved4D;
	u32bits	si_Reserved4E;
	u32bits	si_Reserved4F;
} mlxperf_systeminfo_t;
#define	mlxperf_systeminfo_s		sizeof(mlxperf_systeminfo_t)


/* MLXPERF_CONTROLLERINFO */
typedef	struct mlxperf_ctldevinfo
{
	mlxperf_header_t perfhd;	/* performance header */

	u08bits	pcd_ControllerNo;	/* Controller number */
	u08bits	pcd_SlotNo;		/* System EISA/PCI/MCA Slot Number */
	u08bits	pcd_BusType;		/* System Bus Interface Type */
	u08bits	pcd_BusNo;		/* System Bus No, HW is sitting on */

	u08bits	pcd_FaultMgmtType;	/* Fault Management Type */
	u08bits	pcd_PhysDevs;		/* # Physical Devs currently detected */
	u08bits	pcd_PhysDevsOffline;	/* # physical devices dead */
	u08bits	pcd_PhysDevsCritical;	/* physical devices critical */

	u08bits	pcd_SysDevsOffline;	/* # logical device offline */
	u08bits	pcd_SysDevsCritical;	/* # logical devices are critial */
	u08bits	pcd_SysDevs;		/* # Logical devs currently configured*/
	u08bits	pcd_MaxSysDevs;		/* Max # Logical Drives supported*/


	u08bits	pcd_MinorDriverVersion;	/* Driver Minor Version Number */
	u08bits	pcd_MajorDriverVersion;	/* Driver Major Version Number */
	u08bits	pcd_InterimDriverVersion;/* interim revs A, B, C, etc. */
	u08bits	pcd_DriverVendorName;	/* vendor name */
	u08bits	pcd_DriverBuildMonth;	/* Driver Build Date - Month */
	u08bits	pcd_DriverBuildDate;	/* Driver Build Date - Date */
	u08bits	pcd_DriverBuildYearMS;	/* Driver Build Date - Year */
	u08bits	pcd_DriverBuildYearLS;	/* Driver Build Date - Year */
	u16bits	pcd_DriverBuildNo;	/* Driver Build Number */
	u16bits	pcd_Reserved0;

	u08bits	pcd_MaxChannels;	/* Maximum Channels present */
	u08bits	pcd_MaxChannelsPossible;/* Maximum Channels possible */
	u08bits	pcd_MaxTargets;		/* Max # Targets/Channel supported */
	u08bits	pcd_MaxLuns;		/* Max # LUNs/Target supported */


	u08bits	pcd_MinorFWVersion;	/* Firmware Minor Version Number */
	u08bits	pcd_MajorFWVersion;	/* Firmware Major Version Number */
	u08bits	pcd_InterimFWVersion;	/* interim revs A, B, C, etc. */
	u08bits	pcd_FWVendorName;	/* vendor name */
	u08bits	pcd_FWBuildMonth;	/* Firmware Build Date - Month */
	u08bits	pcd_FWBuildDate;	/* Firmware Build Date - Date */
	u08bits	pcd_FWBuildYearMS;	/* Firmware Build Date - Year */
	u08bits	pcd_FWBuildYearLS;	/* Firmware Build Date - Year */
	u16bits	pcd_FWBuildNo;		/* Firmware Build Number */
	u08bits	pcd_FWTurnNo;		/* Firmware Turn  Number */
	u08bits	pcd_Reserved1;

	u08bits	pcd_FMTCabinets;	/* # Fault management cabinets */
	u08bits	pcd_MemoryType;		/* type of memory used on board */
	u08bits	pcd_InterruptVector;	/* Interrupt Vector Number */
	u08bits	pcd_InterruptType;	/* Interrupt Mode: Edge/Level */


	u08bits	pcd_MinorBIOSVersion;	/* BIOS Minor Version Number */
	u08bits	pcd_MajorBIOSVersion;	/* BIOS Major Version Number */
	u08bits	pcd_InterimBIOSVersion;	/* interim revs A, B, C, etc. */
	u08bits	pcd_BIOSVendorName;	/* vendor name */
	u08bits	pcd_BIOSBuildMonth;	/* BIOS Build Date - Month */
	u08bits	pcd_BIOSBuildDate;	/* BIOS Build Date - Date */
	u08bits	pcd_BIOSBuildYearMS;	/* BIOS Build Date - Year */
	u08bits	pcd_BIOSBuildYearLS;	/* BIOS Build Date - Year */
	u16bits	pcd_BIOSBuildNo;	/* BIOS Build Number */
	u16bits	pcd_Reserved2;

	u08bits	pcd_ControllerType;	/* Controller type, DAC960PD, Flashpt */
	u08bits	pcd_OEMCode;		/* controller - OEM Identifier Code */
	u16bits	pcd_HWSCSICapability;	/* HW SCSI capability */


	u32bits	pcd_MaxRequests;	/* Max # Concurrent Requests supported*/
	u32bits	pcd_MaxTags;		/* Maximum Tags supported */
	u32bits	pcd_CacheSizeKB;	/* controller Cache Size in KB */
	u32bits	pcd_DataCacheSizeKB;	/* actual memory used for data cache */

	u16bits	pcd_StripeSizeKB;	/* Current Stripe Size - in KB */
	u16bits	pcd_CacheLineSizeKB;	/* controller cache line size in KB */
	u16bits	pcd_FlashRomSizeKB;	/* Flash rom size in KB */
	u16bits	pcd_NVRamSizeKB;	/* Non Volatile Ram Size in KB */
	u32bits	pcd_MemBaseAddr;	/* Adapter Memory Base Address */
	u32bits	pcd_MemBaseSize;	/* size from Memory Base Address */

	u16bits	pcd_IOBaseAddr;		/* Adapter IO Base Address */
	u16bits	pcd_IOBaseSize;		/* Size from IO Base Address */
	u32bits	pcd_BIOSAddr;		/* Adapter BIOS Address */
	u32bits	pcd_BIOSSize;		/* BIOS Size */
	u32bits	pcd_Reserved5;

	u08bits	pcd_ControllerName[USCSI_PIDSIZE]; /* controller name */

	u32bits	pcd_Reserved20;
	u32bits	pcd_Reserved21;
	u32bits	pcd_Reserved22;
	u32bits	pcd_Reserved23;

	u32bits	pcd_Reserved24;
	u32bits	pcd_Reserved25;
	u32bits	pcd_Reserved26;
	u32bits	pcd_Reserved27;

	u32bits	pcd_Reserved28;
	u32bits	pcd_Reserved29;
	u32bits	pcd_Reserved2A;
	u32bits	pcd_Reserved2B;

	u32bits	pcd_Reserved2C;
	u32bits	pcd_Reserved2D;
	u32bits	pcd_Reserved2E;
	u32bits	pcd_Reserved2F;


	u32bits	pcd_Reserved30;
	u32bits	pcd_Reserved31;
	u32bits	pcd_Reserved32;
	u32bits	pcd_Reserved33;

	u32bits	pcd_Reserved34;
	u32bits	pcd_Reserved35;
	u32bits	pcd_Reserved36;
	u32bits	pcd_Reserved37;

	u32bits	pcd_Reserved38;
	u32bits	pcd_Reserved39;
	u32bits	pcd_Reserved3A;
	u32bits	pcd_Reserved3B;

	u32bits	pcd_Reserved3C;
	u32bits	pcd_Reserved3D;
	u32bits	pcd_Reserved3E;
	u32bits	pcd_Reserved3F;
} mlxperf_ctldevinfo_t;
#define	mlxperf_ctldevinfo_s		sizeof(mlxperf_ctldevinfo_t)


/* MLXPERF_PHYSDEVINFO */
typedef	struct mlxperf_physdevinfo
{
	mlxperf_header_t perfhd;	/* performance header */

	u08bits	ppd_ControllerNo;	/* Controller Number */
	u08bits	ppd_ChannelNo;		/* SCSI Channel Number */
	u08bits	ppd_TargetID;		/* SCSI Target ID */
	u08bits	ppd_LunID;		/* SCSI LUN ID */

	u08bits	ppd_Reserved0;
	u08bits	ppd_ControllerType;	/* Controller type eg. DAC960PD */
	u16bits	ppd_SWSCSICapability;	/* SW set SCSI capability */

	u08bits	ppd_dtype;		/* SCSI_INQ: device type */
	u08bits	ppd_dtqual;		/* SCSI_INQ: RMD & dev type qualifier */
	u08bits	ppd_version;		/* SCSI_INQ: version */
	u08bits	ppd_sopts;		/* SCSI_INQ: response data format */

	u08bits	ppd_hopts;		/* SCSI_INQ: hardware options */
	u08bits	ppd_DevState;		/* Device State, see pdst_DevState */
	u08bits	ppd_Present;		/* Present State, see pdst_Present */
	u08bits	ppd_Reserved1;

	u08bits	ppd_FMTCabinetType;	/* cabinet types */
	u08bits	ppd_FMTCabinetNo;	/* Cabinet Number */
	u08bits	ppd_FMTFans;		/* # Fans in cabinet */
	u08bits	ppd_FMTPowerSupplies;	/* # Power Supplies */

	u08bits	ppd_FMTHeatSensors;	/* # Temprature senor */
	u08bits	ppd_FMTDriveSlots;	/* # Drive Slots */
	u08bits	ppd_FMTDoorLocks;	/* # Door Locks */
	u08bits	ppd_FMTSpeakers;	/* # Speekers */

	u32bits	ppd_FMTFansCritical;	/* fans in critical state */

	u32bits	ppd_FMTPowersCritical;	/* power supplies in critical state */
	u32bits	ppd_FMTHeatsCritical;	/* Tempratures in critical state */
	u32bits	ppd_FMTFansFailed;	/* fans Failed */
	u32bits	ppd_FMTPowersFailed;	/* power supplies failed */

	u32bits	ppd_FMTHeatsFailed;	/* Tempratures failed */
	u32bits	ppd_DevSizeKB;		/* device capacity in KB */
	u32bits	ppd_OrgDevSizeKB;	/* original device capacity in KB */
	u32bits	ppd_BlockSize;		/* device block size in bytes */

	u08bits	ppd_VendorID[8];	/* SCSI_INQ: vendor ID */
	u08bits	ppd_ProductID[16];	/* SCSI_INQ: product ID */
	u08bits	ppd_RevisionLevel[4];	/* SCSI_INQ: revision level */
	u32bits	ppd_Reserved2;

	u16bits ppd_BusSpeed; /* Bus Speed */
	u08bits ppd_BusWidth; /* Bus Width */
	u08bits ppd_Reserved20;

	u32bits	ppd_Reserved21;
	u32bits	ppd_Reserved22;
	u32bits	ppd_Reserved23;

	u32bits	ppd_Reserved24;
	u32bits	ppd_Reserved25;
	u32bits	ppd_Reserved26;
	u32bits	ppd_Reserved27;
} mlxperf_physdevinfo_t;
#define	mlxperf_physdevinfo_s		sizeof(mlxperf_physdevinfo_t)


/* MLXPERF_SYSDEVINFO */
typedef	struct mlxperf_sysdevinfo
{
	mlxperf_header_t perfhd;	/* performance header */

	u08bits	psd_ControllerType;	/* Controller type eg. DAC960PD */
	u08bits	psd_ControllerNo;	/* Controller Number */
	u08bits	psd_DevNo;		/* system device number */
	u08bits	psd_Reserved0;

	u08bits	psd_DevState;		/* Device State */
	u08bits	psd_RaidType;		/* Raid Type 0,1,3,5,6,7 */
	u08bits	psd_Reserved1;
	u08bits	psd_Reserved2;

	u32bits	psd_DevSizeKB;		/* device capacity in KB */

	u08bits	psd_DevGroupName[MLX_DEVGRPNAMESIZE];
	u08bits	psd_DevName[MLX_DEVNAMESIZE];

	u16bits	psd_StripeSizeKB;	/* Current Stripe Size - in KB */
	u16bits	psd_CacheLineSizeKB;	/* controller cache line size in KB */
	u32bits	psd_Reserved11;
	u32bits	psd_Reserved12;
	u32bits	psd_Reserved13;

	u32bits	psd_Reserved20;
	u32bits	psd_Reserved21;
	u32bits	psd_Reserved22;
	u32bits	psd_Reserved23;

	u32bits	psd_Reserved24;
	u32bits	psd_Reserved25;
	u32bits	psd_Reserved26;
	u32bits	psd_Reserved27;
} mlxperf_sysdevinfo_t;
#define	mlxperf_sysdevinfo_s		sizeof(mlxperf_sysdevinfo_t)

/* MLXPERF_DRIVER */
typedef	struct	mlxperf_driver
{
	mlxperf_header_t perfhd;	/* performance header */
	dga_driver_version_t pdv_dv;	/* driver version */
	u08bits	pdv_name[MLX_DEVNAMESIZE]; /* driver name */
} mlxperf_driver_t;
#define	mlxperf_driver_s	sizeof(mlxperf_driver_t)

/* MLXPERF_TIMETRACE, this record is used by MDAC driver for time tracing */
typedef	struct	mlxperf_timetrace
{
	u08bits	tt_RecordType;		/* Record Type */
	u08bits	tt_Reserved;
	u16bits	tt_TraceSize;		/* trace size including header */
	u08bits	tt_Data[1];		/* time trace data starts here */
} mlxperf_timetrace_t;
#define	mlxperf_timetrace_s	mlxperf_hd_s


/*===========PHYSICAL DEVICE PERFORMANCE DATA STRUCTURES STARTS=============*/
/* MLXPERF_PDRDPERF1B */
typedef	struct mlxperf_pdrdperf1b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u08bits	pdrd1b_Reads;		/* # read requests done */
	u08bits	pdrd1b_ReadKB;		/* # KB data read */
	u08bits	pdrd1b_ReadCacheHit;	/* Read cache hit in percentage */
} mlxperf_pdrdperf1b_t;
#define	mlxperf_pdrdperf1b_s		(mlxperf_hd_s + 3)

/* MLXPERF_PDRDPERF2B */
typedef	struct mlxperf_pdrdperf2b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u16bits	pdrd2b_Reads;		/* # read requests done */
	u16bits	pdrd2b_ReadKB;		/* # KB data read */
	u08bits	pdrd2b_ReadCacheHit;	/* Read cache hit in percentage */
} mlxperf_pdrdperf2b_t;
#define	mlxperf_pdrdperf2b_s		(mlxperf_hd_s + 5)

/* MLXPERF_PDRDPERF4B */
typedef	struct mlxperf_pdrdperf4b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u32bits	pdrd4b_Reads;		/* # read requests done */
	u32bits	pdrd4b_ReadKB;		/* # KB data read */
	u08bits	pdrd4b_ReadCacheHit;	/* Read cache hit in percentage */
} mlxperf_pdrdperf4b_t;
#define	mlxperf_pdrdperf4b_s		(mlxperf_hd_s + 9)

/* MLXPERF_PDRDPERF8B */
typedef	struct mlxperf_pdrdperf8b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u64bits	pdrd8b_Reads;		/* # read requests done */
	u64bits	pdrd8b_ReadKB;		/* # KB data read */
	u08bits	pdrd8b_ReadCacheHit;	/* Read cache hit in percentage */
} mlxperf_pdrdperf8b_t;
#define	mlxperf_pdrdperf8b_s		(mlxperf_hd_s + 17)


/* MLXPERF_PDWTPERF1B */
typedef	struct mlxperf_pdwtperf1b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u08bits	pdwt1b_Writes;		/* # write requests done */
	u08bits	pdwt1b_WriteKB;		/* # KB data write */
	u08bits	pdwt1b_WriteCacheHit;	/* Write cache hit in percentage */
} mlxperf_pdwtperf1b_t;
#define	mlxperf_pdwtperf1b_s		(mlxperf_hd_s + 3)

/* MLXPERF_PDWTPERF2B */
typedef	struct mlxperf_pdwtperf2b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u16bits	pdwt2b_Writes;		/* # write requests done */
	u16bits	pdwt2b_WriteKB;		/* # KB data write */
	u08bits	pdwt2b_WriteCacheHit;	/* Write cache hit in percentage */
} mlxperf_pdwtperf2b_t;
#define	mlxperf_pdwtperf2b_s		(mlxperf_hd_s + 5)

/* MLXPERF_PDWTPERF4B */
typedef	struct mlxperf_pdwtperf4b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u32bits	pdwt4b_Writes;		/* # write requests done */
	u32bits	pdwt4b_WriteKB;		/* # KB data write */
	u08bits	pdwt4b_WriteCacheHit;	/* Write cache hit in percentage */
} mlxperf_pdwtperf4b_t;
#define	mlxperf_pdwtperf4b_s		(mlxperf_hd_s + 9)

/* MLXPERF_PDWTPERF8B */
typedef	struct mlxperf_pdwtperf8b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u64bits	pdwt8b_Writes;		/* # write requests done */
	u64bits	pdwt8b_WriteKB;		/* # KB data write */
	u08bits	pdwt8b_WriteCacheHit;	/* Write cache hit in percentage */
} mlxperf_pdwtperf8b_t;
#define	mlxperf_pdwtperf8b_s		(mlxperf_hd_s + 17)


/* MLXPERF_PDRWPERF1B */
typedef	struct mlxperf_pdrwperf1b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u08bits	pdrw1b_Reads;		/* # read requests done */
	u08bits	pdrw1b_ReadKB;		/* # KB data read */
 	u08bits	pdrw1b_Writes;		/* # write requests done */
	u08bits	pdrw1b_WriteKB;		/* # KB data write */
	u08bits	pdrw1b_ReadCacheHit;	/* Read cache hit in percentage */
	u08bits	pdrw1b_WriteCacheHit;	/* Write cache hit in percentage */
} mlxperf_pdrwperf1b_t;
#define	mlxperf_pdrwperf1b_s		(mlxperf_hd_s + 6)

/* MLXPERF_PDRWPERF2B */
typedef	struct mlxperf_pdrwperf2b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u16bits	pdrw2b_Reads;		/* # read requests done */
	u16bits	pdrw2b_ReadKB;		/* # KB data read */
 	u16bits	pdrw2b_Writes;		/* # write requests done */
	u16bits	pdrw2b_WriteKB;		/* # KB data write */
	u08bits	pdrw2b_ReadCacheHit;	/* Read cache hit in percentage */
	u08bits	pdrw2b_WriteCacheHit;	/* Write cache hit in percentage */
} mlxperf_pdrwperf2b_t;
#define	mlxperf_pdrwperf2b_s		(mlxperf_hd_s + 10)

/* MLXPERF_PDRWPERF4B */
typedef	struct mlxperf_pdrwperf4b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u32bits	pdrw4b_Reads;		/* # read requests done */
	u32bits	pdrw4b_ReadKB;		/* # KB data read */
 	u32bits	pdrw4b_Writes;		/* # write requests done */
	u32bits	pdrw4b_WriteKB;		/* # KB data write */
	u08bits	pdrw4b_ReadCacheHit;	/* Read cache hit in percentage */
	u08bits	pdrw4b_WriteCacheHit;	/* Write cache hit in percentage */
} mlxperf_pdrwperf4b_t;
#define	mlxperf_pdrwperf4b_s		(mlxperf_hd_s + 18)

/* MLXPERF_PDRWPERF8B */
typedef	struct mlxperf_pdrwperf8b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u64bits	pdrw8b_Reads;		/* # read requests done */
	u64bits	pdrw8b_ReadKB;		/* # KB data read */
 	u64bits	pdrw8b_Writes;		/* # write requests done */
	u64bits	pdrw8b_WriteKB;		/* # KB data write */
	u08bits	pdrw8b_ReadCacheHit;	/* Read cache hit in percentage */
	u08bits	pdrw8b_WriteCacheHit;	/* Write cache hit in percentage */
} mlxperf_pdrwperf8b_t;
#define	mlxperf_pdrwperf8b_s		(mlxperf_hd_s + 34)

/*===========PHYSICAL DEVICE PERFORMANCE DATA STRUCTURES ENDS===============*/

/*===========SYSTEM DEVICE PERFORMANCE DATA STRUCTURES STARTS=============*/
/* MLXPERF_SDRDPERF1B */
typedef	struct mlxperf_sdrdperf1b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u08bits	sdrd1b_Reads;		/* # read requests done */
	u08bits	sdrd1b_ReadKB;		/* # KB data read */
	u08bits	sdrd1b_ReadCacheHit;	/* Read cache hit in percentage */
} mlxperf_sdrdperf1b_t;
#define	mlxperf_sdrdperf1b_s		(mlxperf_hd_s + 3)

/* MLXPERF_SDRDPERF2B */
typedef	struct mlxperf_sdrdperf2b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u16bits	sdrd2b_Reads;		/* # read requests done */
	u16bits	sdrd2b_ReadKB;		/* # KB data read */
	u08bits	sdrd2b_ReadCacheHit;	/* Read cache hit in percentage */
} mlxperf_sdrdperf2b_t;
#define	mlxperf_sdrdperf2b_s		(mlxperf_hd_s + 5)

/* MLXPERF_SDRDPERF4B */
typedef	struct mlxperf_sdrdperf4b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u32bits	sdrd4b_Reads;		/* # read requests done */
	u32bits	sdrd4b_ReadKB;		/* # KB data read */
	u08bits	sdrd4b_ReadCacheHit;	/* Read cache hit in percentage */
} mlxperf_sdrdperf4b_t;
#define	mlxperf_sdrdperf4b_s		(mlxperf_hd_s + 9)

/* MLXPERF_SDRDPERF8B */
typedef	struct mlxperf_sdrdperf8b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u64bits	sdrd8b_Reads;		/* # read requests done */
	u64bits	sdrd8b_ReadKB;		/* # KB data read */
	u08bits	sdrd8b_ReadCacheHit;	/* Read cache hit in percentage */
} mlxperf_sdrdperf8b_t;
#define	mlxperf_sdrdperf8b_s		(mlxperf_hd_s + 17)


/* MLXPERF_SDWTPERF1B */
typedef	struct mlxperf_sdwtperf1b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u08bits	sdwt1b_Writes;		/* # write requests done */
	u08bits	sdwt1b_WriteKB;		/* # KB data write */
	u08bits	sdwt1b_WriteCacheHit;	/* Write cache hit in percentage */
} mlxperf_sdwtperf1b_t;
#define	mlxperf_sdwtperf1b_s		(mlxperf_hd_s + 3)

/* MLXPERF_SDWTPERF2B */
typedef	struct mlxperf_sdwtperf2b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u16bits	sdwt2b_Writes;		/* # write requests done */
	u16bits	sdwt2b_WriteKB;		/* # KB data write */
	u08bits	sdwt2b_WriteCacheHit;	/* Write cache hit in percentage */
} mlxperf_sdwtperf2b_t;
#define	mlxperf_sdwtperf2b_s		(mlxperf_hd_s + 5)

/* MLXPERF_SDWTPERF4B */
typedef	struct mlxperf_sdwtperf4b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u32bits	sdwt4b_Writes;		/* # write requests done */
	u32bits	sdwt4b_WriteKB;		/* # KB data write */
	u08bits	sdwt4b_WriteCacheHit;	/* Write cache hit in percentage */
} mlxperf_sdwtperf4b_t;
#define	mlxperf_sdwtperf4b_s		(mlxperf_hd_s + 9)

/* MLXPERF_SDWTPERF8B */
typedef	struct mlxperf_sdwtperf8b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u64bits	sdwt8b_Writes;		/* # write requests done */
	u64bits	sdwt8b_WriteKB;		/* # KB data write */
	u08bits	sdwt8b_WriteCacheHit;	/* Write cache hit in percentage */
} mlxperf_sdwtperf8b_t;
#define	mlxperf_sdwtperf8b_s		(mlxperf_hd_s + 17)


/* MLXPERF_SDRWPERF1B */
typedef	struct mlxperf_sdrwperf1b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u08bits	sdrw1b_Reads;		/* # read requests done */
	u08bits	sdrw1b_ReadKB;		/* # KB data read */
 	u08bits	sdrw1b_Writes;		/* # write requests done */
	u08bits	sdrw1b_WriteKB;		/* # KB data write */
	u08bits	sdrw1b_ReadCacheHit;	/* Read cache hit in percentage */
	u08bits	sdrw1b_WriteCacheHit;	/* Write cache hit in percentage */
} mlxperf_sdrwperf1b_t;
#define	mlxperf_sdrwperf1b_s		(mlxperf_hd_s + 6)

/* MLXPERF_SDRWPERF2B */
typedef	struct mlxperf_sdrwperf2b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u16bits	sdrw2b_Reads;		/* # read requests done */
	u16bits	sdrw2b_ReadKB;		/* # KB data read */
 	u16bits	sdrw2b_Writes;		/* # write requests done */
	u16bits	sdrw2b_WriteKB;		/* # KB data write */
	u08bits	sdrw2b_ReadCacheHit;	/* Read cache hit in percentage */
	u08bits	sdrw2b_WriteCacheHit;	/* Write cache hit in percentage */
} mlxperf_sdrwperf2b_t;
#define	mlxperf_sdrwperf2b_s		(mlxperf_hd_s + 10)

/* MLXPERF_SDRWPERF4B */
typedef	struct mlxperf_sdrwperf4b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u32bits	sdrw4b_Reads;		/* # read requests done */
	u32bits	sdrw4b_ReadKB;		/* # KB data read */
 	u32bits	sdrw4b_Writes;		/* # write requests done */
	u32bits	sdrw4b_WriteKB;		/* # KB data write */
	u08bits	sdrw4b_ReadCacheHit;	/* Read cache hit in percentage */
	u08bits	sdrw4b_WriteCacheHit;	/* Write cache hit in percentage */
} mlxperf_sdrwperf4b_t;
#define	mlxperf_sdrwperf4b_s		(mlxperf_hd_s + 18)

/* MLXPERF_SDRWPERF8B */
typedef	struct mlxperf_sdrwperf8b
{
	mlxperf_header_t perfhd;	/* performance header */
 	u64bits	sdrw8b_Reads;		/* # read requests done */
	u64bits	sdrw8b_ReadKB;		/* # KB data read */
 	u64bits	sdrw8b_Writes;		/* # write requests done */
	u64bits	sdrw8b_WriteKB;		/* # KB data write */
	u08bits	sdrw8b_ReadCacheHit;	/* Read cache hit in percentage */
	u08bits	sdrw8b_WriteCacheHit;	/* Write cache hit in percentage */
} mlxperf_sdrwperf8b_t;
#define	mlxperf_sdrwperf8b_s		(mlxperf_hd_s + 34)

/*===========SYSTEM DEVICE PERFORMANCE DATA STRUCTURES ENDS===============*/

#endif	/* _SYS_MLXPERF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\sys\mdrvos.h ===
/**************************************************************************
 *                COPYRIGHT (C) Mylex Corporation 1992-1998               *
 *                                                                        *
 * This software is furnished under a license and may be used and copied  * 
 * only in accordance with the terms and conditions of such license and   * 
 * with inclusion of the above copyright notice. This software or any     * 
 * other copies thereof may not be provided or otherwise made available   * 
 * to any other person. No title to, nor ownership of the software is     * 
 * hereby transferred.                                                    *
 *                                                                        *
 * The information in this software is subject to change without notices  *
 * and should not be construed as a commitment by Mylex Corporation       *
 *                                                                        *
 **************************************************************************/

#ifndef _SYS_MDRVOS_H
#define _SYS_MDRVOS_H

#if !defined(MLX_NT) && !defined(MLX_LINUX) && !defined(MLX_IRIX)
#define MLXSPLVAR               u32bits oldsplval
#endif

#define MLX_MAX_WAIT_COUNT      128 /* Max sleeps for any shared channel*/
#define MLX_WAITWITHOUTSIGNAL   0 /* wait/sleep without signal option open */
#define MLX_WAITWITHSIGNAL      1 /* wait/sleep with    signal option open */

#ifdef  MLX_SCO
#define OSReq_t                 REQ_IO          /* OS Request type */
#define OSctldev_t              u08bits         /* OS controller type none */
#define mlx_copyin(sp,dp,sz)    copyin(sp,dp,sz)
#define mlx_copyout(sp,dp,sz)   copyout(sp,dp,sz)
#define mlx_timeout(func,tm)    timeout(func,0,tm*MLXHZ)
#define mlx_allocmem(ctp, sz)   sptalloc(mdac_bytes2pages(sz), PG_P, 0, (DMAABLE|NOSLEEP))
#define mlx_freemem(ctp, dp,sz) sptfree(dp, mdac_bytes2pages(sz), 1)
#define mlx_alloc4kb(ctp)       mlx_allocmem(ctp, 4*ONEKB)
#define mlx_free4kb(ctp, dp)    mlx_freemem(ctp, dp,4*ONEKB)
#define mlx_alloc8kb(ctp)       mlx_allocmem(ctp, 8*ONEKB)
#define mlx_free8kb(ctp, dp)    mlx_freemem(ctp, dp,8*ONEKB)
#define mlx_kvtophys(ctp, dp)   kvtophys(dp)
#define	mlx_kvtophyset(da, ctp, dp)	((da).bit63_32=0, (da).bit31_0 = mlx_kvtophys(ctp,dp)) /* set the physical address in 64 bit memory location */
#define mlx_maphystokv(dp,sz)   phystokv(dp)
#define mlx_unmaphystokv(dp,sz)
#define mlx_memmapctliospace(ctp)       mdac_memmapctliospace(ctp)
#define mlx_memmapiospace(dp,sz) sptalloc(mdac_bytes2pages(sz), PG_P|PG_PCD, btoc(dp), NOSLEEP)
#define mlx_memunmapiospace(dp,sz)
#define mlx_rwpcicfg32bits(bus,slot,func,reg,op,val) mdac_rwpcicfg32bits(bus,slot,func,reg,op,val)
#define mlx_delay10us()         suspend(1)
#define MLXSPL0()               spl0()
#define MLXSPL()                oldsplval = spl5()
#define MLXSPLX()               splx(oldsplval)
#ifdef	_KERNEL
extern  u32bits lbolt, time;
#endif	/* _KERNEL */
#define MLXCTIME()      time
#define MLXCLBOLT()     lbolt

#elif   MLX_UW
#define OSReq_t                 struct mdac_srb /* OS Request type */
#define OSctldev_t              struct hba_idata_v5/* OS controller type none */
#define mlx_copyin(sp,dp,sz)    copyin(sp,dp,sz)
#define mlx_copyout(sp,dp,sz)   copyout(sp,dp,sz)
#define mlx_timeout(func,tm)    itimeout(func,0,tm*MLXHZ,pldisk)
/*
#define mlx_allocmem(ctp, sz)   kmem_alloc(sz,KM_NOSLEEP)
*/
#define mlx_allocmem(ctp, sz)   gam_kmem_alloc(sz)
#define mlx_freemem(ctp, dp,sz) kmem_free(dp,sz)
#define mlx_alloc4kb(ctp)       mlx_allocmem(ctp, 4*ONEKB)
#define mlx_free4kb(ctp, dp)    mlx_freemem(ctp, dp,4*ONEKB)
#define mlx_alloc8kb(ctp)       mlx_allocmem(ctp, 8*ONEKB)
#define mlx_free8kb(ctp, dp)    mlx_freemem(ctp, dp,8*ONEKB)
#define mlx_kvtophys(ctp, dp)   vtop((caddr_t)dp,0)
#define	mlx_kvtophyset(da, ctp, dp)	((da).bit63_32=0, (da).bit31_0 = mlx_kvtophys(ctp,dp)) /* set the physical address in 64 bit memory location */
#define mlx_maphystokv(dp,sz)   physmap(dp,sz,KM_NOSLEEP)
#define mlx_unmaphystokv(dp,sz) physmap_free((caddr_t)dp,sz,0)
#define mlx_memmapctliospace(ctp)       mdac_memmapctliospace(ctp)
#define mlx_memmapiospace(dp,sz)        (u32bits)physmap(dp,sz,KM_NOSLEEP)
#define mlx_memunmapiospace(dp,sz)      physmap_free((caddr_t)dp,sz,0)
#define mlx_rwpcicfg32bits(bus,slot,func,reg,op,val) mdac_rwpcicfg32bits(bus,slot,func,reg,op,val)
#define mlx_delay10us()         drv_usecwait(10)
#define MLXSPL0()               spl0()
#define MLXSPL()                oldsplval = spldisk()
#define MLXSPLX()               splx(oldsplval)
extern  u32bits time;
#define MLXCTIME()      mdacuw_ctime()
#define MLXCLBOLT()     mdacuw_clbolt()

#elif   MLX_SOL_X86

#define OSReq_t                 struct scsi_cmd /* OS Request type */
#define OSctldev_t              struct mdac_hba /* OS controller type none */
#define mlx_copyin(sp,dp,sz)    copyin(sp,dp,sz)
#define mlx_copyout(sp,dp,sz)   copyout(sp,dp,sz)
#define mlx_timeout(func,tm)    mdac_timeoutid = timeout(func,0,tm*MLXHZ)
#define mlx_untimeout(id)       untimeout(id)
#define mlx_allocmem(ctp, sz)   kmem_zalloc(sz,KM_NOSLEEP)
#define mlx_freemem(ctp, dp,sz) kmem_free(dp,sz)
#define mlx_alloc4kb(ctp)       mlx_allocmem(ctp,4*ONEKB)
#define mlx_free4kb(ctp, dp)    mlx_freemem(ctp,dp,4*ONEKB)
#define mlx_alloc8kb(ctp)       mlx_allocmem(ctp,8*ONEKB)
#define mlx_free8kb(ctp, dp)    mlx_freemem(ctp,dp,8*ONEKB)
#define HBA_KVTOP(vaddr, shf, msk) \
                ((paddr_t)(hat_getkpfnum((caddr_t)(vaddr)) << (shf)) | \
                            ((paddr_t)(vaddr) & (msk)))
#define mlx_kvtophys(ctp, dp)   HBA_KVTOP((caddr_t)dp, mdac_pgshf, mdac_pgmsk)
#define mlx_kvtophyset(da, ctp, dp)     ((da).bit63_32=0, (da).bit31_0 = mlx_kvtophys(ctp,dp)) /* set the physical address in 64 bit memory location */
#define mlx_delay10us()         drv_usecwait(10)
#define mlx_maphystokv(dp,sz)   0
#define mlx_memmapctliospace(ctp)       mdacsol_memmapctliospace(ctp)
#define mlx_memmapiospace(dp,sz)        0
#define mlx_memunmapiospace(dp,sz) 0
#define mlx_memunmapctliospace(dp,sz)   mlxsol_memunmapctliospace(ctp,dp,sz)
#define mlx_rwpcicfg32bits(bus,slot,func,reg,op,val) mdacsol_rwpcicfg32bits(bus,slot,func,reg,op,val)
#define MLXSPLVAR               u32bits oldsplval
#define MLXSPL0()               spl0()
#define MLXSPL()                oldsplval = spl6()
#define MLXSPLX()               splx(oldsplval)
extern  u32bits time;
#define MLXCTIME()      mdacsol_ctime()
#define MLXCLBOLT()     mdacsol_clbolt()

#elif   MLX_SOL_SPARC
#define OSReq_t                 struct scsi_cmd /* OS Request type */
#define OSctldev_t              struct mdac_hba /* OS controller type none */
#define mlx_copyin(sp,dp,sz)    copyin(sp,dp,sz)
#define mlx_copyout(sp,dp,sz)   copyout(sp,dp,sz)
#define mlx_timeout(func,tm)    mdac_timeoutid = timeout(func,0,tm*MLXHZ)
#define mlx_untimeout(id)       untimeout(id)
#define mlx_allocmem(ctp,sz)    mdacsol_dma_memalloc(ctp,sz)
#define mlx_freemem(ctp,dp,sz)  mdacsol_dma_memfree(ctp,(u08bits *)dp,sz)
#define mlx_kvtophys(ctp,dp)    mdacsol_kvtop(ctp,(u08bits *)dp)
#define mlx_alloc4kb(ctp)       mlx_allocmem(ctp,8*ONEKB)
#define mlx_free4kb(ctp,dp)     mlx_freemem(ctp,dp,8*ONEKB)
#define mlx_alloc8kb(ctp)       mlx_allocmem(ctp,8*ONEKB)
#define mlx_free8kb(ctp,dp)     mlx_freemem(ctp,dp,8*ONEKB)
#define mlx_delay10us()         drv_usecwait(10)
#define mlx_maphystokv(dp,sz)   0
#define mlx_memmapctliospace(ctp)       mdacsol_memmapctliospace(ctp)
#define mlx_memmapiospace(dp,sz)        0
#define mlx_memunmapiospace(dp,sz) 0
#define mlx_memunmapctliospace(dp,sz)   mlxsol_memunmapctliospace(ctp,dp,sz)
#define mlx_rwpcicfg32bits(bus,slot,func,reg,op,val) mdacsol_rwpcicfg32bits(bus,slot,func,reg,op,val)
#define MLXSPLVAR               u32bits oldsplval
#define MLXSPL0()               spl0()
#define MLXSPL()                oldsplval = spl5()
#define MLXSPLX()               splx(oldsplval)
extern  u32bits time;
#define MLXCTIME()              mdacsol_ctime()
#define MLXCLBOLT()             mdacsol_clbolt()
#define mdac_simple_lock(lck)   mutex_enter(lck)
#define mdac_simple_unlock(lck) mutex_exit(lck)

#elif   MLX_NT
#define MLXSPLVAR                       KIRQL oldIrqLevel; BOOLEAN irqRaised = FALSE
#define OSReq_t                         SCSI_REQUEST_BLOCK     /* OS Request type */
#define OSctldev_t                      u08bits  /* OS controller type none */
#define cd_deviceExtension				cd_OSctp
#ifdef MLX_MINIPORT
#define sleep_chan                      u32bits
#define mlx_copyin(sp,dp,sz)            nt_copyin((PVOID)(sp),(PVOID)(dp),sz)
#define mlx_copyout(sp,dp,sz)           nt_copyout((PVOID)(sp), (PVOID)(dp),sz)
#define mlx_timeout(func,tm)            mdacnt_timeout(func, tm)
#else
#ifndef _WIN64 
#define sleep_chan                      u32bits
#define mlx_copyin(sp,dp,sz)            nt_copyin((PVOID)(sp),(PVOID)(dp),sz)
#define mlx_copyout(sp,dp,sz)           nt_copyout((PVOID)(sp), (PVOID)(dp),sz)
#define mlx_timeout(func,tm)            mdacnt_timeout(func, tm)
#endif 
#endif 
#ifdef  MLX_NT_ALPHA
#define mlx_allocmem(ctp, sz)           kmem_alloc((ctp),(sz)) 
#define mlx_freemem(ctp,dp,sz)          kmem_free((ctp),(dp),(sz))
#define mlx_alloc4kb(ctp)               mlx_allocdsm4kb(ctp)
#define mlx_free4kb(ctp, dp)            mlx_freedsm4kb(ctp, dp)
#define mlx_alloc8kb(ctp)               mlx_allocdsm8kb(ctp)
#define mlx_free8kb(ctp, dp)            mlx_freedsm8kb(ctp, dp)
#define mlx_kvtophys(ctp, dp)           MdacKvToPhys(ctp, dp)
#else   /* !MLX_NT_ALPHA*/

#define mlx_alloc4kb(ctp)               mlx_allocmem(ctp, 4*ONEKB)
#define mlx_free4kb(ctp, dp)            mlx_freemem(ctp, dp,4*ONEKB)
#define mlx_alloc8kb(ctp)               mlx_allocmem(ctp, 8*ONEKB)
#define mlx_free8kb(ctp, dp)            mlx_freemem(ctp, dp,8*ONEKB)
#define mlx_kvtophys2(dp)		MmGetPhysicalAddress((PVOID)(dp))
#define mlx_kvtophys3(ctp,dp)		mdacnt_kvtophys3(ctp,dp)

#ifdef MLX_MINIPORT
	#ifdef MLX_FIXEDPOOL
		#define mlx_allocmem(ctp, sz)           kmem_alloc((ctp),(sz)) 
		#define mlx_freemem(ctp,dp,sz)          kmem_free((ctp),(dp),(sz))
		#define mlx_kvtophys(ctp, dp)           mdacnt_kvtophys(ctp,dp)   
		#define	mlx_kvtophyset(dest,ctp,dp) *((SCSI_PHYSICAL_ADDRESS *)&(dest))=mlx_kvtophys3(ctp,dp)
	#else
		#define mlx_allocmem(ctp, sz)           ExAllocatePool(NonPagedPool, (sz))
		#define mlx_freemem(ctp, dp,sz)         ExFreePool((void *)(dp))
		#define mlx_kvtophys(ctp, dp)                \
			ScsiPortConvertPhysicalAddressToUlong(MmGetPhysicalAddress((PVOID)(dp)))
		#define	mlx_kvtophyset(dest,ctp,dp) *((PHYSICAL_ADDRESS *)&(dest))=MmGetPhysicalAddress((PVOID)(dp))
	#endif
#else
#define mlx_allocmem(ctp, sz)           ExAllocatePool(NonPagedPool, (sz))
#define mlx_freemem(ctp, dp,sz)         ExFreePool((void *)(dp))
#define mlx_kvtophys(ctp, dp)                \
        ScsiPortConvertPhysicalAddressToUlong(MmGetPhysicalAddress((PVOID)(dp)))
#define	mlx_kvtophyset(da, ctp, dp)	((da).bit63_32=0, (da).bit31_0 = mlx_kvtophys(ctp,dp)) /* set the physical address in 64 bit memory location */
#endif

#define mlx_alloc4kb(ctp)               mlx_allocmem(ctp, 4*ONEKB)
#define mlx_free4kb(ctp, dp)            mlx_freemem(ctp, dp,4*ONEKB)
#define mlx_alloc8kb(ctp)               mlx_allocmem(ctp, 8*ONEKB)
#define mlx_free8kb(ctp, dp)            mlx_freemem(ctp, dp,8*ONEKB)
#define mlx_kvtophys2(dp)				MmGetPhysicalAddress((PVOID)(dp))
#define mlx_kvtophys3(ctp,dp)			mdacnt_kvtophys3(ctp,dp)

#endif  /* !MLX_NT_ALPHA*/

#define	mlx_kvtophyset2(dest,ctp,dp,srb,len)  *((SCSI_PHYSICAL_ADDRESS *)&(dest))=mdacnt_kvtophys2(ctp,dp,srb,len)

#define mlx_maphystokv(dp,sz)           \
        MmMapIoSpace(ScsiPortConvertUlongToPhysicalAddress((ULONG)dp), \
                        (ULONG)sz, FALSE)
#define mlx_unmaphystokv(dp,sz)         
#define mlx_memmapctliospace(ctp)       mdac_memmapctliospace(ctp)
#ifndef _WIN64 
#define mlx_memmapiospace(dp,sz)        ((u32bits) (dp))
#else
#define mlx_memmapiospace(dp,sz)        ((ULONG_PTR) (dp))
#endif
#define mlx_memunmapiospace(dp,sz)      
#define mlx_memmapiospace2(dp,sz)       MmMapIoSpace(dp, (ULONG)sz, FALSE)
#define mlx_rwpcicfg32bits(bus,slot,func,reg,op,val) mdac_rwpcicfg32bits(bus,slot,func,reg,op,val)
#define mlx_delay10us()                 nt_delay10us()


#if !defined(_WIN64) && !defined(SCSIPORT_COMPLIANT)

#define MLXSPL()                                                        \
        if ((oldIrqLevel = KeGetCurrentIrql()) < mdac_irqlevel)       \
        {                                                               \
                KeRaiseIrql(mdac_irqlevel, &oldIrqLevel);             \
                irqRaised = TRUE;                                       \
        }

#define MLXSPL0()       MLXSPL()

#define MLXSPLX()                               \
        if (irqRaised)                          \
                KeLowerIrql(oldIrqLevel);       \

#else
#define MLXSPL() 
#define MLXSPL0()    MLXSPL()
#define MLXSPLX()   
#endif

#define MLXCTIME()                      nt_ctime()
#define MLXCLBOLT()                     nt_clbolt()
#define u08bits_in_mdac(port)           ScsiPortReadPortUchar((u08bits *)(port))       /* input  08 bits data*/
#define u16bits_in_mdac(port)           ScsiPortReadPortUshort((u16bits *)(port))       /* input  16 bits data*/
#define u32bits_in_mdac(port)           ScsiPortReadPortUlong((u32bits *)(port))       /* input  32 bits data*/
#define u08bits_out_mdac(port,data)     ScsiPortWritePortUchar((u08bits *)(port),(u08bits)(data)) /* output 08 bits data*/
#define u16bits_out_mdac(port,data)     ScsiPortWritePortUshort((u16bits *)(port),(u16bits)(data)) /* output 16 bits data*/
#define u32bits_out_mdac(port,data)     ScsiPortWritePortUlong((u32bits *)(port),(u32bits)(data)) /* output 32 bits data*/

#ifdef MDAC_CLEAN_IOCTL

// GAM-to-MDAC "Clean" IOCTL interface Definitions

#define MDAC_NEWFSI_IOCTL	0xc1
#define MDAC_NEWFSI_FWBOUND	0xc2
#define MDAC_BOUND_SIGNATURE	"GAM2MDAC"

#endif /* MDAc_CLEAN_IOCTL */

#elif	MLX_LINUX
#include <string.h>
#include <stdlib.h>
#include <linux/param.h>
#define OSReq_t                  u32bits	/* OS Request type - XXX: IO_Request_T? */
#define OSctldev_t               u08bits	/* OS controller type none - XXX */
#define mlx_copyin(sp,dp,sz)     gam_copy(sp,dp,sz)
#define mlx_copyout(sp,dp,sz)    gam_copy(sp,dp,sz)
#define mlx_allocmem(ctp, sz)    malloc(sz)
#define mlx_freemem(ctp, dp,sz)  free(dp)
#define mlx_alloc4kb(ctp)        mlx_allocmem(ctp, 4*ONEKB)
#define mlx_free4kb(ctp, dp)     mlx_freemem(ctp, dp,4*ONEKB)
#define mlx_alloc8kb(ctp)        mlx_allocmem(ctp, 8*ONEKB)
#define mlx_free8kb(ctp, dp)     mlx_freemem(ctp, dp,8*ONEKB)
#define mlx_alloc16kb(ctp)       mlx_allocmem(ctp, 16*ONEKB)
#define mlx_free16kb(ctp, dp)    mlx_freemem(ctp, dp,16*ONEKB)
#define mlx_kvtophys(ctp, dp)    0
#define mlx_kvtophyset(da, ctp, dp)
#define MLXSPLVAR                u32bits oldsplval
#define MLXSPL0()
#define MLXSPL()
#define MLXSPLX()
#define MLXCTIME()              time(NULL)
/* Using the system define for HZ can be dangerous - it's 100 on ia32 
 * but 1024 on _WIN64 - this breaks the statistics view 
 */
/* #define MLXCLBOLT()             (MLXCTIME() * HZ) */
#define MLXCLBOLT()             (MLXCTIME() * MLXHZ)

#elif	MLX_IRIX
#include <string.h>
#include <stdlib.h>
#include <sys/param.h>
#define OSReq_t                  u32bits	/* OS Request type - XXX: IO_Request_T? */
#define OSctldev_t               u08bits	/* OS controller type none - XXX */
#define mlx_copyin(sp,dp,sz)     gam_copy(sp,dp,sz)
#define mlx_copyout(sp,dp,sz)    gam_copy(sp,dp,sz)
#define mlx_allocmem(ctp, sz)    malloc(sz)
#define mlx_freemem(ctp, dp,sz)  free(dp)
#define mlx_alloc4kb(ctp)        mlx_allocmem(ctp, 4*ONEKB)
#define mlx_free4kb(ctp, dp)     mlx_freemem(ctp, dp,4*ONEKB)
#define mlx_alloc8kb(ctp)        mlx_allocmem(ctp, 8*ONEKB)
#define mlx_free8kb(ctp, dp)     mlx_freemem(ctp, dp,8*ONEKB)
#define mlx_alloc16kb(ctp)       mlx_allocmem(ctp, 16*ONEKB)
#define mlx_free16kb(ctp, dp)    mlx_freemem(ctp, dp,16*ONEKB)
#define mlx_kvtophys(ctp, dp)    0
#define mlx_kvtophyset(da, ctp, dp)
#define MLXSPLVAR
#define MLXSPL0()
#define MLXSPL()
#define MLXSPLX()
#define MLXCTIME()              time(NULL)
#define MLXCLBOLT()             (MLXCTIME() * HZ)

#elif   MLX_NW
#define OSReq_t                 hacbDef         /* OS Request type */
#define OSctldev_t              mdacnw_ctldev_t /* OS controller pointer */
#define mlx_copyin(sp,dp,sz)    mdac_copy(sp,dp,sz)
#define mlx_copyout(sp,dp,sz)   mdac_copy((u08bits MLXFAR *)sp,(u08bits MLXFAR *)dp,sz)
#define mlx_timeout(func,tm)    mdacnw_newthread(func, 0, tm*NPA_TICKS_PER_SECOND, NPA_NON_BLOCKING_THREAD)
#define mlx_freemem(ctp, dp,sz) NPA_Return_Memory(mdacnw_npaHandle,dp)
#define mlx_alloc4kb(ctp)       mlx_allocmem(ctp, 4*ONEKB)
#define mlx_free4kb(ctp, dp)    mlx_freemem(ctp, dp,4*ONEKB)
#define mlx_alloc8kb(ctp)       mlx_allocmem(ctp, 8*ONEKB)
#define mlx_free8kb(ctp, dp)    mlx_freemem(ctp, dp,8*ONEKB)
#define mlx_kvtophys(ctp, dp)   MapDataOffsetToAbsoluteAddress((LONG)dp)
#define	mlx_kvtophyset(da, ctp, dp)	((da).bit63_32=0, (da).bit31_0 = mlx_kvtophys(ctp,dp)) /* set the physical address in 64 bit memory location */
#define mlx_maphystokv(mp,sz)   0
#define mlx_memmapctliospace(ctp)       mdac_memmapctliospace(ctp)
#define mlx_memmapiospace(mp,sz) MapAbsoluteAddressToDataOffset((LONG)(mp))
#define mlx_memunmapiospace(mp,sz)
#define mlx_rwpcicfg32bits(bus,slot,func,reg,op,val) mdac_rwpcicfg32bits(bus,slot,func,reg,op,val)
#define MLXSPL0()               mdac_enable_intr_CPU
#define MLXSPL()                oldsplval = DisableAndRetFlags()
#define MLXSPLX()               SetFlags(oldsplval)
#define MLXCTIME()              (GetCurrentTime()/18)
#define MLXCLBOLT()             mdacnw_lbolt(GetCurrentTime())
#define mlx_delay10us()         NPA_Micro_Delay(10)
#define mdac_disable_intr_CPU() DisableAndRetFlags()
#define mdac_restore_intr_CPU(flags) SetFlags(flags)

#define MDACNW_DIAGOPTION       0
#define MDACNW_MAXCHANNELS      8
#define MDACNW_MAXVCHANNELS     2       /* maximum virtual channels */

/* Logical/Physical device structure */
typedef struct mdacnw_device
{
        u32bits dev_State;              /* state of the Device */
        u32bits dev_Handle;
        hacbDef *dev_WaitingHacb;       /* Waiting HACB in chain */
        ucscsi_inquiry_t dev_Inquiry;   /* device INQUIRY data */
} mdacnw_device_t;
#define mdacnw_device_s sizeof(mdacnw_device_t)

/* dev_state bit information */
#define MDACNW_QUEUE_FROZEN     0x0001 /* queue is frozen */
#define MDACNW_DEVICE_ACTIVE    0x0008 /* In Main device list */
#define MDACNW_PRIVATE_DEVICE   0x0010 /* Flag showing a PRIVATE device */

/* Controller Specific Info : not found in mdac_ctldev */
typedef struct mdacnw_ctldev
{
      u32bits nwcd_busTag;            /* Required for NPA_Add_Option */
        u32bits nwcd_uniqueID;          /* Unique ID received during scan */
        u32bits nwcd_errorInterjectEnabled;
        u32bits nwcd_maxChannels;
        u32bits nwcd_MaxTargets;
        u32bits nwcd_MaxLuns;
        u32bits nwcd_slotNo;            /* Netware Logical Slot Number */
        u32bits nwcd_loaded;            /* 1: Driver loaded for this instance */
        u32bits nwcd_instanceNo;        /* Netware load order Instance Number */
        u32bits nwcd_productid_added;   /* 1: PRODUCT ID registered for this instance */
        mdacnw_device_t *nwcd_devtbl;   /* This is an array of device */
        mdacnw_device_t *nwcd_lastdevp; /* last+1 device address */
        u32bits nwcd_devtblsize;        /* size of allocated memory in bytes */

        u32bits nwcd_npaBusHandle[MDACNW_MAXCHANNELS+1];  /* holds NWPA generated handle */
        u32bits nwcd_hamBusHandle[MDACNW_MAXCHANNELS+1];  /* holds HAM  generated handle */
}mdacnw_ctldev_t;

#elif   MLX_DOS
/* struct to send request to controller using dos interface */
typedef struct mdac_dosreq
{
        struct  mdac_dosreq MLXFAR *drq_Next;   /* Next in chain */
        u32bits (MLXFAR *drq_CompIntr)(struct mdac_req MLXFAR*);        /* comp func */
        u32bits (MLXFAR *drq_CompIntrBig)(struct mdac_req MLXFAR*);     /* comp func */
        u32bits (MLXFAR *drq_StartReq)(struct mdac_req MLXFAR*);        /* start Req */

        u08bits drq_ControllerNo;       /* Controller number */
        u08bits drq_ChannelNo;          /* channel number */
        u08bits drq_TargetID;           /* Target ID */
        u08bits drq_LunID;              /* Lun ID / Logical Dev No */
        u32bits drq_TimeOut;            /* Time out value in second */
        u32bits drq_Reserved0;
        u32bits drq_Reserved1;

        u32bits drq_Reserved10;
        u32bits drq_Reserved11;
        u32bits drq_Reserved12;
        u32bits drq_Reserved13;

        dac_command_t drq_DacCmd;       /* DAC command structure */
} mdac_dosreq_t;
#define mdac_dosreq_s   sizeof(mdac_dosreq_t)
#define drq_SysDevNo    drq_LunID

#define OSReq_t                 mdac_dosreq_t
#define OSctldev_t              u32bits
#define mlx_copyin(sp,dp,sz)    mdac_copy(sp,dp,sz)
#define mlx_copyout(sp,dp,sz)   mdac_copy((u08bits MLXFAR*)(sp),(u08bits MLXFAR*)(dp),sz)
#define mlx_timeout(func,tm)
#define mlx_allocmem(ctp, sz)   kmem_alloc(sz)
#define mlx_freemem(ctp, dp,sz) kmem_free((u08bits MLXFAR*)(dp),sz)
#define mlx_alloc4kb(ctp)       mlx_allocmem(ctp, 4*ONEKB)
#define mlx_free4kb(ctp, dp)    mlx_freemem(ctp, dp,4*ONEKB)
#define mlx_alloc8kb(ctp)       mlx_allocmem(ctp, 8*ONEKB)
#define mlx_free8kb(ctp,dp)     mlx_freemem(ctp, dp,8*ONEKB)
#define mlx_kvtophys(ctp,dp)    mdac_kvtophys((u08bits MLXFAR*)dp)
#define	mlx_kvtophyset(da, ctp, dp)	((da).bit63_32=0, (da).bit31_0 = mlx_kvtophys(ctp,dp)) /* set the physical address in 64 bit memory location */
#define mlx_maphystokv(dp,sz)   mdac_phystokv(dp)
#define mlx_unmaphystokv(dp,sz)
#define mlx_memmapctliospace(ctp)       mdac_memmapctliospace(ctp)
#define mlx_memmapiospace(dp,sz) dp
#define mlx_memunmapiospace(dp,sz)
#define mlx_rwpcicfg32bits(bus,slot,func,reg,op,val) mdac_rwpcicfg32bits(bus,slot,func,reg,op,val)
#define mlx_delay10us()         mlx_delayus(10)
#define MLXSPL0()               mlx_spl0()
#define MLXSPL()                oldsplval = mlx_spl5()
#define MLXSPLX()               mlx_splx(oldsplval)
#define MLXCTIME()              mlx_time()
#define MLXCLBOLT()             mdac_lbolt()

#elif MLX_WIN9X
#define OSReq_t                         SCSI_REQUEST_BLOCK     /* OS Request type */
#define OSctldev_t                      DEVICE_EXTENSION         /* OS controller type none */
#define cd_deviceExtension		cd_OSctp
#define sleep_chan                      u32bits
#define mlx_copyin(sp,dp,sz)            mdacw95_copyin((PVOID)(sp),(PVOID)(dp),sz)
#define mlx_copyout(sp,dp,sz)           mdacw95_copyout((PVOID)(sp), (PVOID)(dp),sz)
#define mlx_timeout(func,tm)            mdacw95_timeout(((u32bits)func), ((u32bits)tm))
#define mlx_allocmem(ctp, sz)           mdacw95_allocmem(ctp, (u32bits)(sz))
#define mlx_freemem(ctp, dp,sz)         mdacw95_freemem(ctp, (u32bits)(dp), (u32bits)(sz))
#define mlx_alloc4kb(ctp)               mlx_allocmem(ctp, 4*ONEKB)
#define mlx_free4kb(ctp, dp)            mlx_freemem(ctp, dp,4*ONEKB)
#define mlx_alloc8kb(ctp)               mlx_allocmem(ctp, 8*ONEKB)
#define mlx_free8kb(ctp, dp)            mlx_freemem(ctp, dp,8*ONEKB)
#define mlx_kvtophys(ctp, dp)           mdacw95_kvtophys(ctp, ((u32bits)(dp)))
#define mlx_kvtophys2(dp)               mlx_kvtophys((dp))
#define mlx_maphystokv(dp,sz)           mdacw95_maphystokv((u32bits)(dp), (u32bits)(sz))
#define	mlx_kvtophyset(da, ctp, dp)	((da).bit63_32=0, (da).bit31_0 = mlx_kvtophys(ctp,dp)) /* set the physical address in 64 bit memory location */

#define mlx_memmapctliospace(ctp)       mdac_memmapctliospace(ctp)
#define mlx_memmapiospace(dp,sz)        ((u32bits) (dp))
#define mlx_memmapiospace2(dp,sz)       mlx_maphystokv(dp, sz)
#define mlx_memunmapiospace(dp,sz)      
#define mlx_rwpcicfg32bits(bus,slot,func,reg,op,val) mdac_rwpcicfg32bits(bus,slot,func,reg,op,val)
#define mlx_delay10us()                 mdacw95_delay10us()

#define MLXSPL()
#define MLXSPL0()
#define MLXSPLX()

#define MLXCTIME()                      mdacw95_ctime()
#define MLXCLBOLT()                     mdacw95_clbolt()
#define u08bits_in_mdac(port)           ScsiPortReadPortUchar((u08bits *)(port))       /* input  08 bits data*/
#define u16bits_in_mdac(port)           ScsiPortReadPortUshort((u16bits *)(port))       /* input  16 bits data*/
#define u32bits_in_mdac(port)           ScsiPortReadPortUlong((u32bits *)(port))       /* input  32 bits data*/
#define u08bits_out_mdac(port,data)     ScsiPortWritePortUchar((u08bits *)(port),(u08bits)(data)) /* output 08 bits data*/
#define u16bits_out_mdac(port,data)     ScsiPortWritePortUshort((u16bits *)(port),(u16bits)(data)) /* output 16 bits data*/
#define u32bits_out_mdac(port,data)     ScsiPortWritePortUlong((u32bits *)(port),(u32bits)(data)) /* output 32 bits data*/

#elif MLX_OS2                                   
#define MLXSPL()                                        oldsplval = mdac_disable_intr_CPU()
#define MLXSPL0()                                       mdac_enable_intr_CPU()
#define MLXSPLX()                                       mdac_restore_intr_CPU(oldsplval)
#define MLXCTIME()                                      mdacos2_ctime()
#define MLXCLBOLT()                                      mdacos2_clbolt()
#define MDACOS2_NUMVCHANNELS            2                 
#define MAX_DEVS_WHOLE_DRIVER           256
#define OSReq_t                                         IORBH     
#define OSctldev_t                              ACB               
#define ConstructedCDB                          ((ucscsi_cdbg1_t MLXFAR *) &(((PIORB_EXECUTEIO)pIORB)->iorbh.ADDWorkSpace[4]))

#define mlx_copyin(sp, dp, sz)  mdac_copy((u08bits      MLXFAR *)(sp), (u08bits MLXFAR *)(dp),sz)
#define mlx_copyout(sp, dp, sz)         mdac_copy((u08bits MLXFAR *)(sp),(u08bits MLXFAR *) (dp),sz)
#define mlx_memmapctliospace(ctp)       mdac_memmapctliospace(ctp)
#define mlx_memmapiospace(dp,sz)   OS2phystovirt((u32bits)(dp),(u32bits)(sz))
#define mlx_memunmapiospace(dp,sz) 0
#define mlx_delay10us()                         DevHelp_ProcBlock(((u32bits) &DelayEventId),(u32bits)1,(u16bits)0)
#define mlx_rwpcicfg32bits(bus,slot,func,reg,op,val) \
                 mdac_rwpcicfg32bits((u32bits)(bus),(u32bits)(slot),(u32bits)(func),(u32bits)(reg),(u32bits)(op),(u32bits)(val))

/* #define      mapOS2dev(npacb,chn,tgt) &npacb->OS2devs[(chn * MDAC_MAXTARGETS) + tgt] */

//#define       mlx_alloc4kb(ctp)                               mdacos2_alloc4kb()
//#define       mlx_alloc8kb(ctp)                               mdacos2_alloc8kb()
//#define       mlx_free4kb(ctp,a)                      mdacos2_free4kb(a)
//#define       mlx_free8kb(ctp,b)                      mdacos2_free8kb(b)

#define mlx_alloc4kb(ctp)                               kmem_alloc(4 * ONEKB)
#define mlx_alloc8kb(ctp)                               kmem_alloc(8 * ONEKB)
#define mlx_free4kb(ctp,a)                      kmem_free((a),4 * ONEKB)
#define mlx_free8kb(ctp,b)                      kmem_free((b),8 * ONEKB)
#define mlx_freemem(ctp,dp,sz)          0
#define mlx_allocmem(ctp,c)         mdacos2_allocmem(c)
#define mlx_kvtophys(ctp,dp)                OS2kvtophys((PBYTE) (dp))
#define mlx_maphystokv(dp,sz)           OS2phystovirt(dp,sz)
#define TICK_FACTOR                                     32 

#ifndef MLX_GAM_BUILD
/*
** memory pool strucs 
*/

typedef struct _MemPool4KB{
    u32bits PhysAddr;
    u32bits VirtAddr;
    u32bits  InUse;
}MEMPOOL4KB;

typedef struct _MemPool8KB{
    u32bits PhysAddr;
    u32bits VirtAddr;
    u32bits InUse;
}MEMPOOL8KB;

/*
** OS/2 device structure extension 
*/
typedef struct _mdacOS2_dev  MLXFAR *POS2DEV;
typedef struct _mdacOS2_dev   NEAR *NPOS2DEV;

typedef struct _mdacOS2_dev
{
        u08bits                 ScsiType;               // Scsi device type 
        u08bits                 UnitInfoType;   // UnitInfo type UIB_TYPE_(xx)
        u08bits                 Flags;                  // Present, allocated, removable,etc.
        u08bits                 SysDrvNum;              // RAID drive number
        u32bits                 MLXFAR *os_plp; // Common code Phys/Log dev struc 
        u32bits             MLXFAR *os_ctp; // Common code Controller pointer
        POS2DEV         pNextDev;               // Next detected device
    u16bits         MasterDevTblIndex; //Index into Master Dev Table
        PUNITINFO               pChangedUnitInfo; // Ptr to OS/2-defined UnitInfo struc
        HDEVICE                 hDevice;                // Resource Mgr Handle for this unit

}mdacOS2_dev_t;

/*
 * Driver Name,Vendor Name,Controller Name structure
*/
typedef struct DriverString{
        u08bits DrvrNameLength; /* Number of Characters to check Vendor */
        u08bits DrvrName[12];
        u08bits DrvrDescription[50];
        u08bits VendorName[50];
        u08bits AdaptDescriptName[50];
} DRIVERSTRING,NEAR *PDRIVERSTRING;

// Flags definitions

#define OS_PRESENT                      1               // we detected it
#define OS_ALLOCATED            2               // a CDM allocated it
#define OS_REMOVABLE            4               // its removable


/*
**      Adapter Control Block Structure
*/
typedef struct _ACB
{
        HDRIVER         hDriver;
        HADAPTER        hAdapter;
    u08bits             ResMgrBusType;          // OS/2 Resource Mgr Host Bus Type 
        u08bits         CardDisabled;           // if card init fails, mark it dead
        u16bits         TotalDevsFound;         // total log RAID + scsi phys devs found
        POS2DEV pFirstDev;                      // ptr  to first detected device
        POS2DEV pLastDev;                       // ptr  to first detected device
    u16bits     Reserved;
/*      mdacOS2_dev_t OS2devs[(MDAC_MAXCHANNELS +MDACOS2_NUMVCHANNELS )* MDAC_MAXTARGETS]; */
    u08bits     ResourceBuf[sizeof(AHRESOURCE)+sizeof(HRESOURCE)*3];

} ACB, MLXFAR *PACB, NEAR *NPACB;

typedef struct mdac_ctldev MLXFAR *PCTP;
#endif  /*MLX_GAM_BUILD*/

#else   /* No operating system */
#define mdac_u08bits_in(port)           inb(port)       /* input  08 bits data*/
#define mdac_u16bits_in(port)           inw(port)       /* input  16 bits data*/
#define mdac_u32bits_in(port)           ind(port)       /* input  32 bits data*/
#define mdac_u08bits_out(port,data)     outb(port,data) /* output 08 bits data*/
#define mdac_u16bits_out(port,data)     outw(port,data) /* output 16 bits data*/
#define mdac_u32bits_out(port,data)     outd(port,data) /* output 32 bits data*/
#endif  /* MLX_SCO */

#ifdef  MLX_NT
#define mlx_timeout_with_spl(func,tm)   mdacnt_timeout_with_spl(func, tm)
#else   /*MLX_NT*/
#define mlx_timeout_with_spl(func,tm)   mlx_timeout(func,tm)
#endif  /*MLX_NT*/

#ifdef  MLX_ASM
asm     u32bits mdac_u08bits_in(port)
{
%mem    port;
        xorl    %eax, %eax;
        movl    port, %edx;
        inb     (%dx);
}

asm     u32bits mdac_u16bits_in(port)
{
%mem    port;
        xorl    %eax, %eax;
        movl    port, %edx;
        inw     (%dx);
}

asm     u32bits mdac_u32bits_in(port)
{
%mem    port;
        movl    port, %edx;
        inl     (%dx);
}

asm     u32bits mdac_u08bits_out(port,val)
{
%mem    port,val;
        movl    port, %edx;
        movl    val, %eax;
        outb    (%dx);
}

asm     u32bits mdac_u16bits_out(port,val)
{
%mem    port,val;
        movl    port, %edx;
        movl    val, %eax;
        outw    (%dx);
}

asm     u32bits mdac_u32bits_out(port,val)
{
%mem    port,val;
        movl    port, %edx;
        movl    val, %eax;
        outl    (%dx);
}
#endif  /* MLX_ASM */

#endif  /* _SYS_MDRVOS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\sys\mlxtypes.h ===
/**************************************************************************
 *                COPYRIGHT (C) Mylex Corporation 1992-1997               *
 *                                                                        *
 * This software is furnished under a license and may be used and copied  * 
 * only in accordance with the terms and conditions of such license and   * 
 * with inclusion of the above copyright notice. This software or any     * 
 * other copies thereof may not be provided or otherwise made available   * 
 * to any other person. No title to, nor ownership of the software is     * 
 * hereby transferred.                                                    *
 *                                                                        *
 * The information in this software is subject to change without notices  *
 * and should not be construed as a commitment by Mylex Corporation       *
 *                                                                        *
 **************************************************************************/

#ifndef	_SYS_MLXTYPES_H
#define	_SYS_MLXTYPES_H

#define	MLXSTATS(x)		x	/* statistics statesments */
#define	MLXDBG(x)		/*x*/	/* debug statesments */


/* The MLX_VA64BITS should be defined for those OS environment where compiler
** generates 64 bit virtual address. This has been done to keep the structure
** size same for 16, 32, 64 bits operating system support.
*/
#if defined(MLX_VA64BITS) || defined(_WIN64)
#define	MLX_VA32BITOSPAD(x)		/* no padding is required for this OS */
#define	MLX_VA64BITOSPAD(x)	x       /* padding is required for this OS */
#else
#define	MLX_VA32BITOSPAD(x)	x	/* padding is required for this OS */
#define	MLX_VA64BITOSPAD(x)		/* no padding is required for this OS */
#endif	/* MLX_VA64BITS */

#ifdef	WIN_NT
#ifndef	MLX_NT
#define	MLX_NT	1
#endif	/* MLX_NT */
#endif	/* WIN_NT */

#ifdef	OS2
#ifndef	MLX_OS2
#define	MLX_OS2	1
#endif	/* MLX_OS2 */
#endif	/* OS2 */

#ifdef	NETWARE
#ifndef	MLX_NW
#define	MLX_NW	1
#endif	/* MLX_NW */
#endif	/* NETWARE */

#define	mlx_space(c)	(((c) == ' ') || ((c) == 0x09))
#define	mlx_numeric(c)	((c) >= '0' && (c) <= '9')
#define	mlx_hex(c)	(mlx_numeric(c) || mlx_lohex(c) || mlx_uphex(c))
#define	mlx_lohex(c)	((c) >= 'a' && (c) <= 'f')
#define	mlx_uphex(c)	((c) >= 'A' && (c) <= 'F')
#define	mlx_digit(c)	(mlx_numeric(c)? (c)-'0' : mlx_lohex(c)? (c)+10-'a' : (c)+10-'A')
#define mlx_alnum(c)	(mlx_numeric(c) || ((c)>='a' && (c)<='z') || ((c)>='A' && (c)<='Z'))
#define	mlx_max(a,b) 	((a)<(b) ? (b) : (a))
#define	mlx_min(a,b) 	((a)>(b) ? (b) : (a))
#define	mlx_abs(x)	((x)>=0 ? (x) : -(x))

#define	S32BITS_MAX       2147483647L  /* max decimal value of a "s32bits" */
#define	S32BITS_MIN     (-2147483647L-1L) /* min decimal value of a "s32bits" */

#define	s08bits	char
#define	s16bits	short
#define	sosword	INT_PTR	/* the best value for operating system */
#if defined(MLX_OS2) || defined(MLX_WIN31) || defined(MLX_DOS)
#define	s32bits	long
#else
#define	s32bits	int
#endif

#ifndef	NULL
#define	NULL	0
#endif

#ifndef GAMUTILS
#if     defined(MLX_OS2) || defined(MLX_WIN31) || defined(MLX_DOS)
#define	MLXFAR	far
#else
#define	MLXFAR
#endif	/* OS2 */
#else
#define	MLXFAR
#endif /* GAMUTILS */

#define	MLXHZ	100	/* most of the system run at 100Hz clock ticks */

#define	u08bits	unsigned s08bits
#define	u16bits	unsigned s16bits
#define	u32bits	unsigned s32bits
/* #define	uosword	unsigned sosword */
#define	uosword	UINT_PTR

#define	_08bits	u08bits
#define	_16bits	u16bits
#define	_32bits	u32bits
#define	_osword	uosword
#define	S08BITS	s08bits
#define	S16BITS	s16bits
#define	S32BITS	s32bits
#define	SOSWORD	sosword
#define	U08BITS	u08bits
#define	U16BITS	u16bits
#define	U32BITS	u32bits
#define	UOSWORD	uosword
#ifdef _WIN64
/* _WIN64-specific defines go here */
#endif

#ifndef	offsetof
	#ifndef _WIN64
#define offsetof(type,field) (u32bits)(&(((type *)0)->field))
	#else
		#define offsetof(type,field) (size_t)(&(((type *)0)->field))
	#endif
#endif	/* offsetof */

/*/ EFI - added by KFR starts */
/*/ EFI - added by KFR starts */
/* 
	the following data type (PVOID) is used to replace incorrect "pointer" references in the base
	code for the _WIN64 port.  note that PVOID resolves to "u32bits" if not _WIN64, so should have 0
	effect on original code if you use PVOID for pointers/memory addresses.
*/
#ifdef MLX_EFI
#include "efi.h"			// needed to get the "INT64" data types
#include "efilib.h"
#endif

#ifdef MLX_DOS
#ifdef MLX_IA64
typedef void * PVOID;
typedef char * PCHAR;
typedef UINT64 UINT_PTR;
typedef INT64 INT_PTR;
// assign 64 bit value macro
#define set64(src,val) \
	src.bit31_0 = (u32bits)val; \
	src.bit63_32 = (u32bits)((UINT_PTR)val >> 32)
#else
typedef u32bits PVOID;
typedef u32bits PCHAR;
typedef u32bits UINT_PTR;
typedef s32bits INT_PTR;
#endif
#endif
/*/ EFI - added by KFR ends */
/*/ EFI - added by KFR ends */

/* The different operating system supported by GAM/DRIVER server */
#define	GAMOS_UNKNOWN	0x00
#define	GAMOS_SVR4MP	0x01 /* SVR4/MP operating system */
#define	GAMOS_SOLARIS	0x02 /* Sun Solaris */
#define	GAMOS_SCO	0x03 /* SCO operating system */
#define	GAMOS_UW	0x04 /* Unixware */
#define	GAMOS_UNIXWARE	0x04 /* Unixware */
#define	GAMOS_AIX	0x05 /* AIX */
#define	GAMOS_NT	0x06 /* NT */
#define	GAMOS_NW	0x07 /* netware */
#define	GAMOS_NETWARE	0x07 /* netware */
#define	GAMOS_OS2	0x08 /* OS/2 */
#define	GAMOS_BV	0x09 /* Banyan Vines */
#define	GAMOS_DOS	0x0A /* DOS */
#define	GAMOS_BIOS	0x0B /* BIOS */
#define	GAMOS_WIN95	0x0C /* Windows 95 */
#define	GAMOS_WIN98	0x0D /* Windows 98 */

#define GAMOS_WIN31     0x10 /* Windows 3.1 */
#define GAMOS_LINUX	0x11 /* Linux */
#define GAMOS_W2K	0x12 /* Windows 2000 */
#define GAMOS_IRIX   0x13 /* IRIX */
#define GAMOS_W64	0x14 /* Win64 */

#if MLX_W64
#define GAMOS_TYPE  GAMOS_W64
#elif MLX_W2K
#define GAMOS_TYPE  GAMOS_W2K
#elif	MLX_NW
#define	GAMOS_TYPE	GAMOS_NW
#elif	MLX_NETWARE
#define	GAMOS_TYPE	GAMOS_NETWARE
#elif	MLX_AIX
#define	GAMOS_TYPE	GAMOS_AIX
#elif	MLX_NT
#define	GAMOS_TYPE	GAMOS_NT
#elif	MLX_SOL_SPARC
#define	GAMOS_TYPE	GAMOS_SOLARIS
#elif	MLX_SOL_X86
#define	GAMOS_TYPE	GAMOS_SOLARIS
#elif	MLX_UW
#define	GAMOS_TYPE	GAMOS_UW
#elif	MLX_UNIXWARE
#define	GAMOS_TYPE	GAMOS_UNIXWARE
#elif	MLX_OS2
#define	GAMOS_TYPE	GAMOS_OS2
#elif	MLX_SCO
#define	GAMOS_TYPE	GAMOS_SCO
#elif	MLX_BV
#define	GAMOS_TYPE	GAMOS_BV
#elif   MLX_WIN31
#define GAMOS_TYPE      GAMOS_WIN31
#elif   MLX_DOS
#define GAMOS_TYPE      GAMOS_DOS
#elif MLX_WIN95
#define GAMOS_TYPE      GAMOS_WIN95
#elif MLX_WIN9X
#define GAMOS_TYPE      GAMOS_WIN98
#elif MLX_LINUX
#define GAMOS_TYPE      GAMOS_LINUX
#elif MLX_IRIX
#define GAMOS_TYPE      GAMOS_IRIX

#endif	/* GAMOS_TYPE */

/* The different vendor name supported under GAM/DRIVER server */
#define	MLXVID_MYLEX	0x00 /* Mylex corporation */
#define	MLXVID_IBM	0x01 /* International Business Machine */
#define	MLXVID_HP	0x02 /* Hewlett Packard */
#define	MLXVID_DEC	0x03 /* Digital Equipment Corporation */
#define	MLXVID_ATT	0x04 /* American Telegraph and Telephony */
#define	MLXVID_DELL	0x05 /* DELL */
#define	MLXVID_NEC	0x06 /* NEC */
#define	MLXVID_SNI	0x07 /* Siemens Nixdroff */
#define	MLXVID_NCR	0x08 /* National Cash Register */
#if	MLX_DEC
#define	MLXVID_TYPE	MLXVID_DEC
#elif	MLX_HP
#define	MLXVID_TYPE	MLXVID_HP
#else
#define	MLXVID_TYPE	MLXVID_MYLEX
#endif

/* some conversion macros */
#define	MLX_ONEKB	0x00000400	/* one Kilo Bytes value */
#define	MLX_ONEMB	0x00100000	/* one Mega Bytes value */
#define	ONEKB		MLX_ONEKB
#define	ONEMB		MLX_ONEMB
#define	bytestokb(val)	((val)/MLX_ONEKB) /* convert Bytes to Kilo  Bytes */
#define	bytestomb(val)	((val)/MLX_ONEMB) /* convert Bytes to Mega  Bytes */
#define	kbtomb(val)	((val)/MLX_ONEKB) /* convert Mega Bytes to Kilo Bytes */
#define	kbtobytes(val)	((val)*MLX_ONEKB) /* convert Kilo Bytes to Bytes */
#define	mbtobytes(val)	((val)*MLX_ONEMB) /* convert Mega Bytes to Bytes */
#define	mbtokb(val)	((val)*MLX_ONEKB) /* convert Mega Bytes to Kilo Bytes */
#define	blks2kb(blks,blksz) 		/* convert blocks to Kilo Bytes */ \
	(((blksz)>=MLX_ONEKB)? ((blks)*((blksz)/MLX_ONEKB)) : ((blks)/(MLX_ONEKB/(blksz))))
#define	kb2blks(kb,blksz) 		/* convert Kilo Bytes to Blocks */ \
	(((blksz)>=MLX_ONEKB)? ((kb)/((blksz)/MLX_ONEKB)) : ((kb)*(MLX_ONEKB/(blksz))))

#define	MLXEOF	(-1)


#if (!defined(MLX_DOS)) && (!defined(MLX_NT_ALPHA))
#define	u08bits_read(addr)		(*((u08bits MLXFAR *)(addr)))
#define	u16bits_read(addr)		(*((u16bits MLXFAR *)(addr)))
#define	u32bits_read(addr)		(*((u32bits MLXFAR *)(addr)))
#define	u08bits_write(addr,data)	*((u08bits MLXFAR *)(addr)) = data
#define	u16bits_write(addr,data)	*((u16bits MLXFAR *)(addr)) = data
#define	u32bits_write(addr,data)	*((u32bits MLXFAR *)(addr)) = data
#endif  /* MLX_DOS && MLX_NT_ALPHA */

#ifndef	MLX_NT_ALPHA
#define	u08bits_read_mmb(addr)		u08bits_read(addr)
#define	u16bits_read_mmb(addr)		u16bits_read(addr)
#define	u32bits_read_mmb(addr)		u32bits_read(addr)
#define	u08bits_write_mmb(addr,data)	u08bits_write(addr,data)
#define	u16bits_write_mmb(addr,data)	u16bits_write(addr,data)
#define	u32bits_write_mmb(addr,data)	u32bits_write(addr,data)
#endif	/*MLX_NT_ALPHA*/

/*
** Mylex ioctls macros.
** IN  | I : copy in the data from user space to system space.
** OUT | O : copy out the data from system space to user space.
** IO	: IN and OUT.
** The fields which are not marked are assumed OUT i.e. data is copied
** from system space to user space.
**
** Ioctl's have the command encoded in the lower word, and the size of any
** IN or OUT parameters in the upper word.  The high 2 bits of the upper word
** are used to encode the IN/OUT status of the parameter; for now we restrict
** parameters to at most 511 bytes.
**
** The ioctl interface
** ioctl(file descriptor, ioctl command, command data structure address)
** If the returned value is non zero then there is OS ioctl error. If the return
** value is zero then spefic data structure may contain the error code.
**
** NOTE:
**	Every data structure should contain first 4 byte as error code.
*/
#define	MLXIOCPARM_SIZE	0x200	/* parameters must be less than 512 bytes */
#define	MLXIOCPARM_MASK		(MLXIOCPARM_SIZE -1)
#define	MLXIOCPARM_LEN(x)	(((u32bits)(x) >> 16) & MLXIOCPARM_MASK)
#define	MLXIOCBASECMD(x)	((x) & ~MLXIOCPARM_MASK)
#define	MLXIOCGROUP(x)		(((u32bits)(x) >> 8) & 0xFF)

#define	MLXIOC_NEWIOCTL	0x10000000 /* distinguish new ioctl's from old */
#define	MLXIOC_OUT	0x20000000 /* copy out data from kernel to user space */
#define	MLXIOC_IN	0x40000000 /* copy in  data from user to kernel space */
#define	MLXIOC_INOUT	(MLXIOC_IN|MLXIOC_OUT)
#define	MLXIOC_DIRMASK	(MLXIOC_INOUT)

#define	_MLXIOC(inout, group, num, len) \
	(inout | ((((u32bits)(len)) & MLXIOCPARM_MASK) << 16) \
	| ((group) << 8) | (num))
#define	_MLXIO(x,y)	_MLXIOC(MLXIOC_NEWIOCTL,x,y,0)
#define	_MLXIOR(x,y,t)	_MLXIOC(MLXIOC_OUT,x,y,sizeof(t))
#define	_MLXIORN(x,y,t)	_MLXIOC(MLXIOC_OUT,x,y,t)
#define	_MLXIOW(x,y,t)	_MLXIOC(MLXIOC_IN,x,y,sizeof(t))
#define	_MLXIOWN(x,y,t)	_MLXIOC(MLXIOC_IN,x,y,t)
#define	_MLXIOWR(x,y,t)	_MLXIOC(MLXIOC_INOUT,x,y,sizeof(t))



#ifdef	MLXNET
/* data structure to handle 64 bit values */
typedef struct
{
#ifdef	LITTLENDIAN
	u32bits	bit31_0;		/* bits 00-31 */
	u32bits	bit63_32;		/* bits 32-63 */
#else	/* BIGENDIAN */
	u32bits	bit63_32;		/* bits 63-32 */
	u32bits	bit31_0;		/* bits 31-0 */
#endif	/* LITTLENDIAN || BIGENDIAN */
} u64bits;
#define	u64bits_s	sizeof(u64bits)

/* macros to compare 64 bits values, 1 if contition is true else 0 */
#define	u64bitseq(sp,dp) /* check if source is equal to destination */ \
	(((sp.bit63_32==dp.bit63_32) && (sp.bit31_0==dp.bit31_0))? 1 : 0)
#define	u64bitsgt(sp,dp) /* check if source is greater than destination */\
	((sp.bit63_32>dp.bit63_32)? 1 : \
	((sp.bit63_32<dp.bit63_32)? 0 : \
	((sp.bit31_0>dp.bit31_0)? 1 : 0)))
#define	u64bitslt(sp,dp) /* check if source is less than destination */ \
	((sp.bit63_32<dp.bit63_32)? 1 : \
	((sp.bit63_32>dp.bit63_32)? 0 : \
	((sp.bit31_0<dp.bit31_0)? 1 : 0)))

/* add 32 bits value to 64 bits value and assign to 64 bit location */
#define	mlx_add64bits(dv,sv,val) \
	((dv).bit63_32 = ((sv).bit63_32 + \
		((  ((dv).bit31_0=((sv).bit31_0+val)) <val)? 1: 0)) )

#ifdef	__MLX_STDC__
static	u16bits	justswap2bytes(u16bits);
static	u32bits	justswap4bytes(u32bits);
static	u64bits	justswap8bytes(u64bits);
#endif	/* __MLX_STDC__ */

static u16bits
#ifdef	MLX_ANSI
justswap2bytes(u16bits val)
#else
justswap2bytes(val)
u16bits val;
#endif	/* not MLX_ANSI */
{
	u08bits tv, MLXFAR *dp = (u08bits MLXFAR *)&val;
	tv = dp[0];
	dp[0] = dp[1];
	dp[1] = tv;
	return val;
}

static u32bits
#ifdef	MLX_ANSI
justswap4bytes(u32bits val)
#else
justswap4bytes(val)
u32bits val;
#endif	/* not MLX_ANSI */
{
	u08bits tv, MLXFAR *dp = (u08bits MLXFAR *)&val;
	tv = dp[0];
	dp[0] = dp[3];
	dp[3] = tv;
	tv = dp[1];
	dp[1] = dp[2];
	dp[2] = tv;
	return val;
}

/* This macro will be changed when compiler start supporting 64 bits. This has
** been done solve some compiler error problem.
*/
static u64bits
#ifdef	MLX_ANSI
justswap8bytes(u64bits val)
#else
justswap8bytes(val)
u64bits val;
#endif	/* not MLX_ANSI */
{
	u08bits tv, MLXFAR *dp = (u08bits MLXFAR *)&val;
	tv = dp[0]; dp[0] = dp[7]; dp[7] = tv;
	tv = dp[1]; dp[1] = dp[6]; dp[6] = tv;
	tv = dp[2]; dp[2] = dp[5]; dp[5] = tv;
	tv = dp[3]; dp[3] = dp[4]; dp[4] = tv;
	return val;
}

#define	justswap(x)	\
( /*	(sizeof(x) == 8) ? justswap8bytes(x) : */ \
	(	(sizeof(x) == 4) ? justswap4bytes(x) : \
		(	(sizeof(x) == 2) ?  justswap2bytes(x) : x \
		) \
	) \
)
#define	JUSTSWAP(x)		x = justswap(x)
#define	JUSTSWAP2BYTES(x)	x = justswap2bytes(x)
#define	JUSTSWAP4BYTES(x)	x = justswap4bytes(x)

/* just use these macros to solve your processor dependency problem */
#ifdef	LITTLENDIAN
#define	MDACENDIAN_TYPE		0x00 /* Little Endian */
/* swap network data format (TCP/IP, KURL) */
#define	NETSWAP(x)		JUSTSWAP(x)
#define	NETSWAP2BYTES(x)	JUSTSWAP2BYTES(x)
#define	NETSWAP4BYTES(x)	JUSTSWAP4BYTES(x)
#define	netswap(x)		justswap(x)
#define	netswap2bytes(x)	justswap2bytes(x)
#define	netswap4bytes(x)	justswap4bytes(x)
/* swap the Mylex network data format */
#define	MLXSWAP(x)
#define	MLXSWAP2BYTES(x)
#define	MLXSWAP4BYTES(x)
#define	mlxswap(x)		x
#define	mlxswap2bytes(x)	x
#define	mlxswap4bytes(x)	x
#else	/* BIGENDIAN */
#define	MDACENDIAN_TYPE		0x01 /* Big Endian */
/* swap network data format (TCP/IP, KURL) */
#define	NETSWAP(x)
#define	NETSWAP2BYTES(x)
#define	NETSWAP4BYTES(x)
#define	netswap(x)		x
#define	netswap2bytes(x)	x
#define	netswap4bytes(x)	x
/* swap the Mylex network data format */
#define	MLXSWAP(x)		JUSTSWAP(x)
#define	MLXSWAP2BYTES(x)	JUSTSWAP2BYTES(x)
#define	MLXSWAP4BYTES(x)	JUSTSWAP4BYTES(x)
#define	mlxswap(x)		justswap(x)
#define	mlxswap2bytes(x)	justswap2bytes(x)
#define	mlxswap4bytes(x)	justswap4bytes(x)
#endif	/* LITTLENDIAN */
#endif	/* MLXNET */


/* All Mylex error codes are here  from 0x80 onwards, leave room OS errors */
#define	MLXERR_NOTSUSER		0x80 /* Not super-user */
#define	MLXERR_ACCESS		0x81 /* Permission denied */
#define	MLXERR_NOENTRY		0x82 /* No such file or directory */
#define	MLXERR_SEARCH		0x83 /* No such process */
#define	MLXERR_INTRRUPT		0x84 /* interrupted system call	*/
#define	MLXERR_IO		0x85 /* I/O error */
#define	MLXERR_REMOTEIO		0x86/* Remote I/O error */
#define	MLXERR_PROTO		0x87 /* Protocol error */
#define	MLXERR_NOSPACE		0x88 /* No space left on device */
#define	MLXERR_NOCHILD		0x89 /* No children */
#define	MLXERR_TRYAGAIN		0x8A /* No more processes */
#define	MLXERR_NOMEM		0x8B /* Not enough core */
#define	MLXERR_FAULT		0x8C /* Bad address */
#define	MLXERR_BUSY		0x8D /* device busy */
#define	MLXERR_EXIST		0x8E /* File exists */
#define	MLXERR_NODEV		0x8F /* No such device */
#define	MLXERR_INVAL		0x90 /* Invalid argument */
#define	MLXERR_TBLOVFL		0x91 /* File table overflow */
#define	MLXERR_TIMEDOUT		0x92 /* Connection timed out */
#define	MLXERR_CONNREFUSED	0x93 /* Connection refused */
#define	MLXERR_NOCODE		0x94 /* feature is not implemented */
#define	MLXERR_NOCONF		0x95 /* not configured */
#define	MLXERR_ILLOP		0x96 /* illegal operation */
#define	MLXERR_DEADEVS		0x97 /* some devices may be dead */
#define	MLXERR_NEWDEVFAIL	0x98 /* new device failed */
#define	MLXERR_NOPACTIVE	0x99 /* no such operation is active */
#define	MLXERR_RPCINVAL		0x9A /* invalid parameter in rpc area */
#define	MLXERR_OSERROR		0x9B /* Operating System call failed */
#define	MLXERR_LOGINREQD	0x9C /* login is required */
#define	MLXERR_NOACTIVITY	0x9D /* there is no such activity */
#define	MLXERR_BIGDATA		0x9E /* data size is too big */
#define	MLXERR_SMALLDATA	0x9F /* data size is too small */
#define	MLXERR_NOUSER		0xA0 /* No such user exists */
#define	MLXERR_INVALPASSWD	0xA1 /* invalid password */
#define	MLXERR_EXCEPTION	0xA2 /* OS Exception */

#define	ERR_NOTSUSER	MLXERR_NOTSUSER
#define	ERR_ACCESS	MLXERR_ACCESS
#define	ERR_NOENTRY	MLXERR_NOENTRY
#define	ERR_SEARCH	MLXERR_SEARCH	
#define	ERR_INTRRUPT	MLXERR_INTRRUPT	
#define	ERR_IO		MLXERR_IO		
#define	ERR_REMOTEIO	MLXERR_REMOTEIO
#define	ERR_PROTO	MLXERR_PROTO	
#define	ERR_NOSPACE	MLXERR_NOSPACE	
#define	ERR_NOCHILD	MLXERR_NOCHILD	
#define	ERR_TRYAGAIN	MLXERR_TRYAGAIN	
#define	ERR_NOMEM	MLXERR_NOMEM	
#define	ERR_FAULT	MLXERR_FAULT	
#define	ERR_BUSY	MLXERR_BUSY	
#define	ERR_EXIST	MLXERR_EXIST	
#define	ERR_NODEV	MLXERR_NODEV	
#define	ERR_INVAL	MLXERR_INVAL	
#define	ERR_TBLOVFL	MLXERR_TBLOVFL	
#define	ERR_TIMEDOUT	MLXERR_TIMEDOUT	
#define	ERR_CONNREFUSED	MLXERR_CONNREFUSED	
#define	ERR_NOCODE	MLXERR_NOCODE	
#define	ERR_NOCONF	MLXERR_NOCONF	
#define	ERR_ILLOP	MLXERR_ILLOP	
#define	ERR_DEADEVS	MLXERR_DEADEVS	
#define	ERR_NEWDEVFAIL	MLXERR_NEWDEVFAIL	
#define	ERR_NOPACTIVE	MLXERR_NOPACTIVE	
#define	ERR_RPCINVAL	MLXERR_RPCINVAL	
#define	ERR_OSERROR	MLXERR_OSERROR	
#define	ERR_LOGINREQD	MLXERR_LOGINREQD	
#define	ERR_NOACTIVITY	MLXERR_NOACTIVITY	
#define	ERR_BIGDATA	MLXERR_BIGDATA	
#define	ERR_SMALLDATA	MLXERR_SMALLDATA	
#define	ERR_NOUSER	MLXERR_NOUSER	
#define	ERR_INVALPASSWD	MLXERR_INVALPASSWD	
#define	ERR_EXCEPTION	MLXERR_EXCEPTION	

/* The driver date information stored in the following format */
typedef struct dga_driver_version
{
	u32bits	dv_ErrorCode;		/* Non zero if data is not valid */
	u08bits	dv_MajorVersion;	/* Driver Major version number */
	u08bits	dv_MinorVersion;	/* Driver Minor version number */
	u08bits	dv_InterimVersion;	/* interim revs A, B, C, etc. */
	u08bits	dv_VendorName;		/* vendor name */

	u08bits	dv_BuildMonth;		/* Driver Build Date - Month */
	u08bits	dv_BuildDate;		/* Driver Build Date - Date */
	u08bits	dv_BuildYearMS;		/* Driver Build Date - Year */
	u08bits	dv_BuildYearLS;		/* Driver Build Date - Year */

	u16bits	dv_BuildNo;		/* build number */
	u08bits	dv_OSType;		/* Operating system name */
	u08bits	dv_SysFlags;		/* System Flags */
} dga_driver_version_t;
#define	dga_driver_version_s	sizeof(dga_driver_version_t)

/* The dv_SysFlags bits are */
#define	MDACDVSF_BIGENDIAN	0x01 /* bit0=0 little endian, =1 big endian cpu */

#endif	/* _SYS_MLXTYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\sys\mlxscsi.h ===
/**************************************************************************
 *                COPYRIGHT (C) Mylex Corporation 1992-1996               *
 *                                                                        *
 * This software is furnished under a license and may be used and copied  * 
 * only in accordance with the terms and conditions of such license and   * 
 * with inclusion of the above copyright notice. This software or any     * 
 * other copies thereof may not be provided or otherwise made available   * 
 * to any other person. No title to, nor ownership of the software is     * 
 * hereby transferred.                                                    *
 *                                                                        *
 * The information in this software is subject to change without notices  *
 * and should not be construed as a commitment by Mylex Corporation       *
 *                                                                        *
 **************************************************************************/

#ifndef	_SYS_MLXSCSI_H
#define	_SYS_MLXSCSI_H

/*
** Standard SCSI control blocks definitions.
** These go in or out over the SCSI bus.
** The first 11 bits of the command block are the same for all three
** defined command groups.  The first byte is an operation which consists
** of a command code component and a group code component. The first 3 bits
** of the second byte are the logical unit number.
** The group code determines the length of the rest of the command.
** Group 0 commands are 6 bytes, Group 1 are 10 bytes, and Group 5
** are 12 bytes.  Groups 2-4 are Reserved. Groups 6 and 7 are Vendor
** Unique.
** At present, our standard cdb's will reserve 20 bytes space for
** use with up to Group 5 commands. This may have to change soon
** if optical disks have longer than 20 byte commands.
*/

#define	UCSGROUP0_LEN	6
#define	UCSGROUP1_LEN	10
#define	UCSGROUP5_LEN	12
#define	UCSCDB_SIZE	32
#define	UCSENSE_SIZE	96

union ucscsi_cdb
{		/* scsi command description block */
	struct
	{
		_08bits	cmd;		/* cmd code (byte 0) */
		_08bits	luntag;		/* byte 1:bit 7..5 lun, bit 4..0 tag */
		union
		{			/* bytes 2 - 31 */
		_08bits	ucscdb_scsi[UCSCDB_SIZE-2];

		/* G R O U P   0   F O R M A T (6 bytes) */
#define		ucs_cmd		cdb_un.cmd
#define		ucs_lun		cdb_un.luntag
#define		g0_addr2	cdb_un.luntag
#define		g0_addr1	cdb_un.sg.g0.addr1
#define		g0_addr0	cdb_un.sg.g0.addr0
#define		g0_count0	cdb_un.sg.g0.count0
#define		g0_cb		cdb_un.sg.g0.cb

		/* defines for SCSI tape cdb. */
#define		s_tag		cdb_un.luntag
#define		s_count2	cdb_un.sg.g0.addr1
#define		s_count1	cdb_un.sg.g0.addr0
#define		s_count0	cdb_un.sg.g0.count0
		struct g0_cdb
		{
			_08bits addr1;		/* middle part of address */
			_08bits addr0;		/* low part of address */
			_08bits count0;		/* usually block count */
			_08bits	cb;		/* byte 5 */
		} g0;

		/* G R O U P   1   F O R M A T  (10 byte) */
#define		g1_reladdr	cdb_un.luntag
#define		g1_rsvd0	cdb_un.sg.g1.rsvd1
#define		g1_addr3	cdb_un.sg.g1.addr3	/* msb */
#define		g1_addr2	cdb_un.sg.g1.addr2
#define		g1_addr1	cdb_un.sg.g1.addr1
#define		g1_addr0	cdb_un.sg.g1.addr0	/* lsb */
#define		g1_count1	cdb_un.sg.g1.count1	/* msb */
#define		g1_count0	cdb_un.sg.g1.count0	/* lsb */
#define		g1_cb		cdb_un.sg.g1.cb
#ifdef MLX_SOL
		struct ucs_scsi_g1
#else
		struct scsi_g1
#endif
		{
			_08bits addr3;		/* most sig. byte of address*/
			_08bits addr2;
			_08bits addr1;
			_08bits addr0;
			_08bits rsvd1;		/* reserved (byte 6) */
			_08bits count1;		/* transfer length (msb) */
			_08bits count0;		/* transfer length (lsb) */
			_08bits	cb;		/* byte 9 */
		} g1;

		/* G R O U P   5   F O R M A T  (12 byte) */
#define		g5_reladdr	cdb_un.luntag
#define		g5_addr3	cdb_un.sg.g5.addr3	/* msb */
#define		g5_addr2	cdb_un.sg.g5.addr2
#define		g5_addr1	cdb_un.sg.g5.addr1
#define		g5_addr0	cdb_un.sg.g5.addr0	/* lsb */
#define		g5_count1	cdb_un.sg.g5.count1	/* msb */
#define		g5_count0	cdb_un.sg.g5.count0	/* lsb */
#define		g5_cb		cdb_un.sg.g5.cb
#ifdef MLX_SOL
		struct ucs_scsi_g5
#else
		struct scsi_g5
#endif
		{
			_08bits addr3;		/* most sig. byte of address*/
			_08bits addr2;
			_08bits addr1;
			_08bits addr0;
			_08bits rsvd3;		/* reserved */
			_08bits rsvd2;		/* reserved */
			_08bits rsvd1;		/* reserved */
			_08bits count1;		/* transfer length (msb) */
			_08bits count0;		/* transfer length (lsb) */
			_08bits	cb;		/* byte 11 */
		} g5;
		}sg;
	} cdb_un;
};

/* scsi command description block for  GROUP 0 FORMAT (6 bytes) */
typedef	struct	ucscsi_cdbg0
{
	u08bits	ucsg0_cmd;		/* cmd code (byte 0) */
	u08bits	ucsg0_luntag;		/* byte 1:bit 7..5 lun, bit 4..0 tag */
	u08bits	ucsg0_addr1;		/* middle part of address */
	u08bits	ucsg0_addr0;		/* low part of address */
	u08bits	ucsg0_count0;		/* usually block count */
	u08bits	ucsg0_cb;		/* byte 5 */
} ucscsi_cdbg0_t;
#define	ucscsi_cdbg0_s	6
#define	ucsg0_addr2	ucsg0_luntag
#define	ucsg0_count2	ucsg0_addr1	/* for sequential device */
#define	ucsg0_count1	ucsg0_addr0	/* for sequential device */

/* scsi command description block for  GROUP 1 FORMAT (10 bytes) */
typedef	struct	ucscsi_cdbg1
{
	u08bits	ucsg1_cmd;		/* cmd code (byte 0) */
	u08bits	ucsg1_luntag;		/* byte 1:bit 7..5 lun, bit 4..0 tag */
	u08bits	ucsg1_addr3;		/* most sig. byte of address*/
	u08bits	ucsg1_addr2;
	u08bits	ucsg1_addr1;
	u08bits	ucsg1_addr0;
	u08bits	ucsg1_rsvd1;		/* reserved (byte 6) */
	u08bits	ucsg1_count1;		/* transfer length (msb) */
	u08bits	ucsg1_count0;		/* transfer length (lsb) */
	u08bits	ucsg1_cb;		/* byte 9 */
}ucscsi_cdbg1_t;
#define	ucscsi_cdbg1_s	10

/* bit fields of control byte (cb) */
#define	UCSCB_LINK	0x01 /* another command follows */
#define	UCSCB_FLAG	0x02 /* interrupt when done */
#define	UCSCB_VU6	0x40 /* vendor unique bit 6 */
#define	UCSCB_VU7	0x80 /* vendor unique bit 7 */

/* defines for getting/setting fields within the various command groups */
#define	UCSGETCMD(cdbp)		((cdbp)->ucs_cmd & 0x1F)
#define	UCSGETGROUP(cdbp)	(UCSCMD_GROUP((cdbp)->ucs_cmd))
#define	UCSGETG0TAG(cdbp)	((cdbp)->g0_addr2 & 0x1F)
#define	UCSGETG1TAG(cdbp)	((cdbp)->g1_reladdr & 0x1F)
#define	UCSGETG5TAG(cdbp)	((cdbp)->g5_reladdr & 0x1F)
#define	UCSSETG0COUNT(cdbp,count) (cdbp)->g0_count0 = (u08bits)count
#define	UCSSETG0CB(cdbp,cb)	(cdbp)->g0_cb = (u08bits)cb

#define	UCSSETG0ADDR(cdbp,addr)	((cdbp)->g0_addr2 &= (u08bits)0xE0,\
				(cdbp)->g0_addr2|=(u08bits)((addr)>>16)&0x1F,\
				(cdbp)->g0_addr1 = (u08bits)((u08bits)((addr) >> 8)),\
				(cdbp)->g0_addr0 = (u08bits)((u08bits)(addr)) )

#define	UCSGETG0ADDR(cdbp)	((((cdbp)->g0_addr2 & 0x1F) << 16) + \
		 		((cdbp)->g0_addr1 << 8)+((cdbp)->g0_addr0))

#define	UCSGETG0COUNT(cdbp)     (((cdbp)->g0_count0 == 0) ? 0x100 : (cdbp)->g0_count0)
#define	UCSSETG0COUNT_S(cdbp,count) ((cdbp)->s_count2= (u08bits)(count) >> 16,\
				(cdbp)->s_count1 = (u08bits)(count) >> 8,\
				(cdbp)->s_count0 = (u08bits)(count))

#define	UCSGETG1COUNT(cdbp)     (((cdbp)->g1_count1 << 8) |(cdbp)->g1_count0)
#define	UCSSETG1COUNT(cdbp,count) ((cdbp)->g1_count1= ((u08bits)((count) >> 8)),\
				(cdbp)->g1_count0 = ((u08bits)(count)))

#define	UCSSETG1ADDR(cdbp,addr)	((cdbp)->g1_addr3= ((u08bits)((addr) >> 24)),\
				(cdbp)->g1_addr2 = ((u08bits)((addr) >> 16)),\
				(cdbp)->g1_addr1 = ((u08bits)((addr) >> 8)),\
				(cdbp)->g1_addr0 = ((u08bits)(addr)) )

#define	UCSSETG1CB(cdbp,cb)	(cdbp)->g1_cb = cb

#define	UCSGETG1ADDR(cdbp)	(((cdbp)->g1_addr3 << 24) + \
				((cdbp)->g1_addr2 << 16) + \
				((cdbp)->g1_addr1 << 8)  + \
				((cdbp)->g1_addr0))

#define	UCSGETG5COUNT(cdbp)     (((cdbp)->g5_count1 << 8) |(cdbp)->g5_count0)
#define	UCSSETG5COUNT(cdbp,count) ((cdbp)->g5_count1 = ((count) >> 8),\
				(cdbp)->g5_count0 = (count))

#define	UCSSETG5ADDR(cdbp,addr)	((cdbp)->g5_addr3= (addr) >> 24,\
				(cdbp)->g5_addr2 = (addr) >> 16,\
				(cdbp)->g5_addr1 = (addr) >> 8,\
				(cdbp)->g5_addr0 = (addr))

#define	UCSSETG5CB(cdbp,cb)	(cdbp)->g5_cb = cb

#define	UCSGETG5ADDR(cdbp)	(((cdbp)->g5_addr3 << 24) + \
				((cdbp)->g5_addr2 << 16) + \
				((cdbp)->g5_addr1 << 8)  + \
				((cdbp)->g5_addr0))

/* macros for forming commands */
#define	UCSMAKECOM_COMMON(cdbp,cmd,lun) ((cdbp)->ucs_cmd=(u08bits)(cmd), \
		(cdbp)->ucs_lun&=(u08bits)0x1F,(cdbp)->ucs_lun|= (u08bits)(lun)<<5)

#define	UCSMAKECOM_G0(cdbp, cmd, lun, addr, count)	\
		(UCSMAKECOM_COMMON(cdbp,cmd,lun), \
		UCSSETG0ADDR(cdbp, addr), \
		UCSSETG0COUNT(cdbp, count), \
		UCSSETG0CB(cdbp, 0))

#define	UCSMAKECOM_G0_S(cdbp, cmd, lun,count, fixbit)	\
		(UCSMAKECOM_COMMON(cdbp,cmd,lun), \
		UCSSETG0COUNT_S(cdbp, count), \
		(cdbp)->s_tag &= 0xE0, \
		(cdbp)->s_tag |= (fixbit) & 0x1F, \
		UCSSETG0CB(cdbp, 0))

#define	UCSMAKECOM_G1(cdbp, cmd, lun, addr, count)	\
		(UCSMAKECOM_COMMON(cdbp,cmd,lun), \
		UCSSETG1ADDR(cdbp, addr), \
		UCSSETG1COUNT(cdbp, count), \
		UCSSETG1CB(cdbp, 0))

#define	UCSMAKECOM_G5(cdbp, cmd, lun, addr, count)	\
		(UCSMAKECOM_COMMON(cdbp,cmd,lun), \
		UCSSETG5ADDR(cdbp, addr), \
		UCSSETG5COUNT(cdbp, count), \
		UCSSETG5CB(cdbp, 0))

/* make DAC960 command */
#define	UCSMAKECOM_DACMD(cdbp, cmd, count) \
		(UCSMAKECOM_G1(cdbp, UCSCSI_DCMD, 0, 0, count), \
		(cdbp)->g1_addr3 = cmd)

/* SCSI commands */
#define	UCSCMD_TESTUNITREADY	0x00 /* test unit ready */
#define	UCSCMD_REZEROUNIT	0x01 /* rezero unit */
#define	UCSCMD_REWIND		0X01 /* rewind the seq device */
#define	UCSCMD_INIT		0x02
#define	UCSCMD_REQUESTSENSE	0x03 /* request sense (read error info) */
#define	UCSCMD_FORMAT		0x04 /* format the unit */
#define	UCSCMD_READBLOCKLIMIT	0x05 /* read block limit of seq device */
#define	UCSCMD_REASSIGNBADBLK	0x07 /* reassign bad block */
#define	UCSCMD_INITELEMENT	0x07 /* 8mm: Initialize Element Status */
#define	UCSCMD_CONNRECEIVEDATA	0x08 /* receive data command for conners */
#define	UCSCMD_READ		0x08 /* read  data group0 command */
#define	UCSCMD_WRITE		0x0A /* write data group0 command */
#define	UCSCMD_SEEK		0x0B /* seek to a block */
#define	UCSCMD_TRACKSELECT	0x0B /* select track of seq device */
#define	UCSCMD_READREVERSE	0x0F /* read reverse direction from seq dev */
#define	UCSCMD_WRITEFM		0x10 /* write file mark */
#define	UCSCMD_RDUCNT		0x11
#define	UCSCMD_SPACE		0x11 /* space command for sequential device */
#define	UCSCSI_SKIPBLOCKS	0x000000 /* Skip Blocks */
#define	UCSCSI_READFM		0x010000 /* Read File Marks */
#define	UCSCSI_READSFM		0x020000 /* Read Sequential File Marks */
#define	UCSCSI_READEOD		0x030000 /* Read End of Data */
#define	UCSCSI_WRITESM		0x040000 /* Write Setmarks */
#define	UCSCSI_WRITESSM		0x050000 /* Write Sequential Setmarks */
#define	UCSCMD_INQUIRY		0x12 /* inquiry:read controller & drive info */
#define	UCSCMD_VERIFYG0		0x13
#define	UCSCMD_RECOVERBUF	0x14
#define	UCSCMD_MODESELECTG0	0x15 /* Mode select */
#define	UCSCSI_MODESENSEPAGE3	3	/* page code 3 */
#define	UCSCSI_MODESENSEPAGE4	4	/* page code 4 */
#define	UCSCMD_RESERVE		0x16
#define	UCSCMD_RELEASE		0x17
#define	UCSCMD_COPY		0x18
#define	UCSCMD_ERASE		0x19 /* erase media on seq device */
#define	UCSCMD_MODESENSEG0	0x1A /* mode sense command */
#define	UCSCMD_STARTSTOP	0x1B /* start/stop the unit */
#define	UCSCSI_STOPDRIVE	0	/* stop the drive */
#define	UCSCSI_STARTDRIVE	1	/* start the drive */
#define	UCSCMD_LOAD		0x1B /* load tape media */
#define	UCSCSI_UNLOADMEDIA	0	/* unload tape media */
#define	UCSCSI_LOADMEDIA	1	/*   load tape media */
#define	UCSCSI_RETENS		2	/* retenstion the tape media */
#define	UCSCMD_RECEIVEDIAG	0x1C /* receive diagnostics result */
#define	UCSCMD_SENDDIAG		0x1D /* send diagnostics */
#define	UCSCMD_DOORLOCKUNLOCK	0x1E /* lock/unlock the drive door */
#define	UCSCSI_DOORUNLOCK	0	/* unlock the drive door */
#define	UCSCSI_DOORLOCK		1	/* lock the drive door */
#define	UCSCSI_DCMD		0x20 /* DAC960 direct command */
#define	UCSCSI_DCDB		0x21 /* DAC960 direct SCSI CDB */
#define	UCSCMD_READCAPACITY	0x25 /* read the drive capacity */
#define	UCSCMD_EREAD		0x28 /* extended read  group1 command */
#define	UCSCMD_EWRITE		0x2A /* extended write group1 command */
#define	UCSCMD_ESEEK		0x2B /* extended seek to a block */
#define	UCSCMD_POSTOELEMENT	0x2B /* 8mm: position to element */
#define	UCSCMD_SEARCHBLANKSEC	0x2C /* search blank (unwritten) sector */
#define	UCSCMD_SEARCHWRITTENSEC	0x2D /* search written sector */
#define	UCSCMD_EWRITEVERIFY	0x2E /* write and verify */
#define	UCSCMD_VERIFY		0x2F /* verify the data on disk */
#define	UCSCMD_READPOSITION	0x34 /* 8mm: read position */
#define	UCSCMD_READEFECTDATA	0x37 /* read defect data */
#define	UCSCMD_WRITEBUFR	0x3B /* write buffer */
#define	UCSCMD_SAFTEREADBUFR	0x3C /* read buffer for SAFTE */
#define	UCSCMD_READLONG		0x3E /* read data + ecc */
#define	UCSCMD_WRITELONG	0x3F /* write data + ecc */
#define	UCSCMD_DISKEJECT	0xC0 /* eject disk from drive */
#define	UCSCMD_LOGSELECT	0x4C /* log select */
#define	UCSCMD_LOGSENSE		0x4D /* 8mm: log sense */
#define	UCSCMD_MODESELECTG1	0x55 /* Mode select */
#define	UCSCMD_MODESENSEG1	0x5A /* mode sense command */
#define	UCSCMD_MOVEMEDIA	0xA5 /* 8mm: move medium */
#define	UCSCMD_READELEMENT	0xB8 /* 8mm: read element status */
#define	UCSCMD_GROUP(cmd)	(((cmd) >> 5) & 7)

#define	USCSI_VIDSIZE		8  /* Vendor ID name size */
#define	USCSI_PIDSIZE		16 /* Product name */
#define	USCSI_REVSIZE		4  /* Product version size */
#define	USCSI_VIDPIDREVSIZE	28 /* combinded size of all 3 fields */
typedef struct ucscsi_inquiry
{
	_08bits	ucsinq_dtype;	/* Bits 7..5 Peripheral Device Qualifier */
				/* Bits 4..0 Peripheral Device Type */
	_08bits	ucsinq_dtqual;	/* Bit 7 removable media */
				/* Bits 6..0 device type qualifier */
	_08bits	ucsinq_version;	/* Bits 7..6 ISO version */
				/* Bits 5..3 ECMA version */
				/* Bits 2..0 ANSI version */
	_08bits	ucsinq_sopts;	/* Bit 7 async event notification cap. */
				/* Bit 6 supports TERMINATE I/O PROC msg */
				/* Bits 5..4 reserved */
				/* Bits 3..0 response data format */
	_08bits	ucsinq_len;	/* additional length */
	_08bits	ucsinq_drvstat;	/* drive status */
	_08bits	ucsinq_resv0;	/* reserved */

	_08bits	ucsinq_hopts;
#define	UCSHOPTS_RELADDR	0x80 /* Bit 7 supports relative addressing */
#define	UCSHOPTS_WBUS32		0x40 /* Bit 6 supports 32 bit wide data xfers */
#define	UCSHOPTS_WBUS16		0x20 /* Bit 5 supports 16 bit wide data xfers */
#define	UCSHOPTS_SYNC		0x10 /* Bit 4 supports synchronous data xfers */
#define	UCSHOPTS_LINK		0x08 /* Bit 3 supports linked commands */
				     /* Bit 2 reserved */
#define	UCSHOPTS_CMDQ		0x02 /* Bit 1 supports command queueing */
#define	UCSHOPTS_SOFTRESET	0x01 /* Bit 0 supports Soft Reset option */

				/* bytes 8-35 */
	_08bits	ucsinq_vid[8];	/* vendor ID */
	_08bits	ucsinq_pid[16];	/* product ID */
	_08bits	ucsinq_rev[4];	/* revision level */
#define	VIDPIDREVSIZE	28	/* combinded size of all 3 fields */

				/*
				** Bytes 36-55 are vendor-specific.
				** Bytes 56-95 are reserved.
				** Bytes 96 to 'n' are vendor-specific
				**	 parameter bytes
				*/

				/* Following fields has been added for SAF-TE */
	u08bits	ucsinq_safte_eui[8];	/* Encloser unique indentifire */
	u08bits	ucsinq_safte_iistr[6];	/* SAF-TE Interface Identification String */
	u08bits	ucsinq_safte_specrev[4];/* SAF-TE Specification Revision Level*/
	u08bits	ucsinq_safte_vup[42];	/* Vendor Unique Parameters */
} ucscsi_inquiry_t;
#define	ucscsi_inquiry_s	sizeof(ucscsi_inquiry_t)

/* define peripheral device type(dtype) returned by inquiry command */
#define	UCSTYP_DAD		0x00 /* direct access device */
#define	UCSTYP_SAD		0x01 /* sequential access device */
#define	UCSTYP_PRINTER		0x02 /* printer device */
#define	UCSTYP_PROCESSOR	0x03 /* processor type device */
#define	UCSTYP_WORMD		0x04 /* write once read mult dev*/
#define	UCSTYP_RODAD		0x05 /* read only DAD */
#define	UCSTYP_SCANNER		0x06 /* scanner device */
#define	UCSTYP_OMDAD		0x07 /* optical memory device */
#define	UCSTYP_MCD		0x08 /* Medium Changer device */
#define	UCSTYP_COMM		0x09 /* communication device */
#define	UCSTYP_ARRAYCONTROLLER	0x0C /* Array Controller Device */

#define	UCSTYP_ENCLSERVICE	0x0D /* Enclosure services device */
				     /* 0x0A to 0x7E reserved */
#define	UCSTYP_NOTPRESENT	0x7F /* LUN not present */
#define	UCSTYP_VENDOR		0x80 /* vendor unique, up to 0xFF */
#define	UCSTYP_HOST		0xC7 /* host (initiator) device */
#define	UCSTYP_HOSTRAID		0xCC /* host (initiator) device as RAID */
/* peripheral device quilifier(ucsinq_dtqual)returned by inquiry command */
#define	UCSQUAL_RMBDEV		0x80 /* removeable device */


/* scsi drive capacity data format */
typedef struct ucsdrv_capacity
{
	_08bits	ucscap_capsec3;		/* byte 3 of disk capacity */
	_08bits	ucscap_capsec2;		/* byte 2 of disk capacity */
	_08bits	ucscap_capsec1;		/* byte 1 of disk capacity */
	_08bits	ucscap_capsec0;		/* byte 0 of disk capacity */
	_08bits	ucscap_seclen3;		/* byte 3 of sector length */
	_08bits	ucscap_seclen2;		/* byte 2 of sector length */
	_08bits	ucscap_seclen1;		/* byte 1 of sector length */
	_08bits	ucscap_seclen0;		/* byte 0 of sector length */
}ucsdrv_capacity_t;
#define	ucsdrv_capacity_s	sizeof(ucsdrv_capacity_t)


/* structure to access bad block table */

typedef	struct ucscsi_badblock
{
	u08bits	bb_block3;
	u08bits	bb_block2;
	u08bits	bb_block1;
	u08bits	bb_block0;
} ucscsi_badblock_t;
#define	ucscsi_badblock_s	sizeof(ucscsi_badblock_t)

typedef	struct ucscsi_badblocktable
{
	u08bits	bbt_Reserved;
	u08bits bbt_fmt;
	u08bits	bbt_len1;
	u08bits	bbt_len0;
	ucscsi_badblock_t bbt_table[1];
}ucscsi_badblocktable_t;
#define	ucscsi_badblocktable_s	sizeof(ucscsi_badblocktable_t)

/* bbt_fmt bit values */
#define	UCSCSI_BBTFMT_DLFMASK	0x07 /* defect list format mask */
#define	UCSCSI_BBTFMT_BLOCK	0x00 /* defect list is block format */
#define	UCSCSI_BBTFMT_INDEX	0x04 /* defect list in byte index format */
#define	UCSCSI_BBTFMT_SECTOR	0x05 /* defect list in sector format */
#define	UCSCSI_BBTFMT_GLIST	0x08 /* grown list is present */
#define	UCSCSI_BBTFMT_PLIST	0x10 /* primary list is present */


/* For Error Classe 0-6. This is all Vendor Unique sense information. */
typedef	struct ucscsi_sense
{
	u08bits	ns_classcode;	/* Bit 7 Logical Block Address is valid */
				/* Bits 6..4 Error class */
				/* Bits 3..0 Vendor Uniqe error code */
	u08bits	ns_vusec2;	/* Bits 7..5 Vendor Unique value */
				/* Bits 4..0 High Logical Block Address */
	u08bits	ns_sec1;	/* Middle Logical Block Address */
	u08bits	ns_sec0;	/* Low part of Logical Block Address */
} ucscsi_sense_t;
#define	ucscsi_sense_s	sizeof(ucscsi_sense_t)

/*
** SCSI Extended Sense structure
** For Error Class 7, the Extended Sense Structure is applicable.
** Since we are moving to SCSI-2 Compliance, the following structure
** will be the one typically used.
*/

typedef	struct ucscsi_exsense
{
	u08bits	es_classcode;	/* Bit 7 sense data is valid */
				/* Bits 6..4 Error Class- fixed at 0x7 */
				/* Bits 3..1 reserved (SCSI-2) */
				/* Bit 0 this is a deferred error (SCSI-2) */
	u08bits	es_segnum;	/* segment number: for COPY cmd only */
	u08bits	es_keysval;	/* Sense key (see below) */
	u08bits	es_info3;	/* information msb */
	u08bits	es_info2;	/* information  */
	u08bits	es_info1;	/* information */
	u08bits	es_info0;	/* information lsb */
	u08bits	es_add_len;	/* number of additional bytes */
	u08bits	es_cmd_info[4];	/* command specific information */
	u08bits	es_asc;		/* Additional Sense Code */
	u08bits	es_ascq;	/* Additional Sense Code Qualifier */
	u08bits	es_fru_code;	/* Field Replaceable Unit Code */
	u08bits	es_skey_specific[3];/* Sense Key Specific information */

	/*
	** Additional bytes may be defined in each implementation.
	** The actual amount of space allocated for Sense Information
	** is also implementation dependent.
	** Modulo that, the declaration of an array two bytes in size
	** nicely rounds this entire structure to a size of 20 bytes.
	*/
	u08bits	es_add_info[2];		/* additional information */
} ucscsi_exsense_t;
#define	ucscsi_exsense_s	sizeof(ucscsi_exsense_t)
#define	UCSENSE_LENGTH		ucscsi_exsense_s
#define	UCSEXSENSE_LENGTH	(ucscsi_exsense_s - 2)

/* classcode bit fields */
#define UCSES_CLASS	0x70 /* indicates extended sense */
#define	UCSES_CLASSMASK	0x70 /* class mask */
#define	UCSES_VALID	0x80 /* sense data is valid */

/* sense key field values */
#define	UCSES_KEYMASK		0x0F /* to get sense key value */
#define	UCSES_ILI		0x20 /* incorrect length indicator */
#define	UCSES_EOM		0x40 /* end of media detected */
#define	UCSES_FILMK		0x80 /* file mark detected */

/* test the msb of Sense Key Specific data, which functions a VALID bit. */
#define	UCSKS_VALID(sep)	((sep)->es_skey_specific[0] & 0x80)

/* sense key (error codes return by sense key command) */
#define UCSK_NOSENSE		0x00	/* no error */
#define	UCSK_RECOVEREDERR	0x01	/* recovered error */
#define	UCSK_NOTREADY		0x02	/* drive is not ready */
#define	UCSK_MEDIUMERR		0x03	/* drive media failed */
#define	UCSK_HARDWAREERR	0x04	/* controller/drive hardware failed */
#define	UCSK_ILLREQUEST		0x05	/* illegal request */
#define	UCSK_UNITATTENTION	0x06	/* target device has been reset */
#define	UCSK_DATAPROTECT	0x07	/* drive is write protected */
#define	UCSK_BLANKCHECK		0x08	/* blank block i.e. was not written */
#define	UCSK_VENDORUNIQUE	0x09	/* code is vendor unique */
#define	UCSK_COPYABORTED	0x0A	/* copy command aborted */
#define	UCSK_ABORTEDCMD		0x0B	/* command aborted */
#define	UCSK_EQUAL		0x0C
#define	UCSK_VOLUMEOVERFLOW	0x0D
#define	UCSK_MISCOMPARE		0x0E
#define	UCSK_RESERVED		0x0F

/*
** SCSI status. The SCSI standard specifies one byte of status.
** Some deviations from the one byte of Status are known. Each
** implementation will define them specifically
** Bit Mask definitions, for use accessing the status as a byte.
*/
#define	UCST_MASK			0x3E
#define	UCST_GOOD			0x00
#define	UCST_CHECK			0x02 /* check condition */
#define	UCST_MET			0x04 /* condition met */
#define	UCST_BUSY			0x08 /* device busy or reserved */
#define	UCST_INTERMEDIATE		0x10 /* intermediate status sent */
#define	UCST_SCSI2			0x20 /* SCSI-2 modifier bit */
#define	UCST_INTERMEDIATE_MET		(UCST_INTERMEDIATE|UCST_MET)
#define	UCST_RESERVATION_CONFLICT	(UCST_INTERMEDIATE|UCST_BUSY)
#define	UCST_TERMINATED			(UCST_SCSI2|UCST_CHECK)
#define	UCST_QFULL			(UCST_SCSI2|UCST_BUSY)


/* additional sense code  & additional sense qualifier values.
** ASC  bits 15..8.
** ASCQ bits  7..0.
*/
/*added for displaying asc info in RSD property page. (in bbt.cpp)*/
/* additional sense code  & additional sense qualifier values.
** ASC  bits 15..8.
** ASCQ bits  7..0.
*/
#define	UCSASC_NOASC		0x0000 /* no addtional sense information */
#define	UCSASC_FILEMARKFOUND	0x0001 /* file mark detected */
#define	UCSASC_EOMFOUND		0x0002 /* end of parition/medium detected */
#define	UCSASC_SETMARKFOUND	0x0003 /* setmark detected */
#define	UCSASC_BOMFOUND		0x0004 /* beginning of parition/medium detected */
#define	UCSASC_EODFOUND		0x0005 /* end of data detected */
#define	UCSASC_IOPROCEND	0x0006 /* I/O process terminated */
#define	UCSASC_AUDIOACTIVE	0x0011 /* audio play operation in progress */
#define	UCSASC_AUDIOPAUSED	0x0012 /* audio play operation paused */
#define	UCSASC_AUDIODONE	0x0013 /* audio play operation successfully completed */
#define	UCSASC_AUDIOERR		0x0014 /* audio play operation stopped due to error */
#define	UCSASC_NOAUDIOSTATUS	0x0015 /* no current audio status to return */

#define	UCSASC_0016	0x0016 /* operation in progress */
#define	UCSASC_0017	0x0017 /* cleaning requested */

#define	UCSASC_NOSECSIGNAL	0x0100 /* no index/sector signal */
#define	UCSASC_NOSEEKCOMP	0x0200 /* no seek complete */
#define	UCSASC_WRITEFAULT	0x0300 /* peripheral device write fault */
#define	UCSASC_NOWRITECURRENT	0x0301 /* no write current */
#define	UCSASC_TOOMANYWRITERR	0x0302 /* excessive write errors */
#define	UCSASC_LUNOTREADYBAD	0x0400 /* logical unit not ready - cause not reportable */
#define	UCSASC_LUGOINGREADY	0x0401 /* logical unit is in process of becoming ready */
#define	UCSASC_LUNOTREADYINITRQ	0x0402 /* logical unit not ready - initializing command is required */
#define	UCSASC_LUNOTREADYMANREQ	0x0403 /* logical unit not ready - manual intervention is required */
#define	UCSASC_LUNOTREADYFORMAT	0x0404 /* logical unit not ready - format in progress */

#define	UCSASC_0405	0x0405 /* logical unit not ready - rebuild in progress */
#define	UCSASC_0406	0x0406 /* logical unit not ready - recalculation in progress */
#define	UCSASC_0407	0x0407 /* logical unit not ready - operation in progress */
#define	UCSASC_0408	0x0408 /* logical unit not ready - long write in progress */

#define	UCSASC_LUSELERR		0x0500 /* logical unit does not respond to selection */
#define	UCSASC_NOREFPOSFOUND	0x0600 /* no reference position found */
#define	UCSASC_MULSELECTED	0x0700 /* multiple peripheral device selected */
#define	UCSASC_LUCOMMFAIL	0x0800 /* logical unit communication failure */
#define	UCSASC_LUCOMMTIMEOUT	0x0801 /* logical unit communication time-out */
#define	UCSASC_LUCOMMPARITYERR	0x0802 /* logical unit communication parity error */

#define	UCSASC_0803	0x0803 /* logical unit communication crc error Ultra-DMA/32 */

#define	UCSASC_TRACKERR		0x0900 /* track following error */
#define	UCSASC_TRACKSERVOFAIL	0x0901 /* tracking servo failure */
#define	UCSASC_FOCUSEVOFAIL	0x0902 /* focus servo failure */
#define	UCSASC_SPINDLESERVOFAIL	0x0903 /* spindles servo failure */

#define	UCSASC_HEADSELFAULT	0x0904 /* head select fault */
#define	UCSASC_0904	0x0904 /* head select fault */

#define	UCSASC_ERRLOGOVERFLOW	0x0A00 /* error log overflow */

#define	UCSASC_0B00	0x0B00 /* Warning */
#define	UCSASC_0B01	0x0B01 /* Warning - specified temperature exceeded */
#define	UCSASC_0B02	0x0B02 /* Warning - Enclosure degraded */


#define	UCSASC_HARDWRITERR	0x0C00 /* write error */
#define	UCSASC_SOFTWRITEREALLOC	0x0C01 /* write error recovered with auto reallocation */
#define	UCSASC_HARDWRITEREALLOC	0x0C02 /* write error - auto reallocation failed */

#define	UCSASC_HARDWRITERASGN	0x0C03 /* write error - recommended reassignment */
#define	UCSASC_CCMISCOMPERR	0x0C04 /* compression check miscompare error */
#define	UCSASC_DATAEXPERR	0x0C05 /* data expansion occurred during compression */
#define	UCSASC_NOBLOCKCOMPRESS	0x0C06 /* block not compressable */

#define	UCSASC_0C03	0x0C03 /* write error - recommend reassignment */
#define	UCSASC_0C04	0x0C04 /* compression check miscompare error */
#define	UCSASC_0C05	0x0C05 /* data expansion occurred during compression */
#define	UCSASC_0C06 0x0C06 /* block not compressible */
#define	UCSASC_0C07	0x0C07 /* write error - recover neede */
#define	UCSASC_0C08	0x0C08 /* write error - recover failed */
#define	UCSASC_0C09	0x0C09 /* write error - loss of stream */
#define	UCSASC_0C0A	0x0C0A /* write error - padding block added */

#define	UCSASC_IDCRCECCERR	0x1000 /* ID CRC or ECC error */
#define	UCSASC_HARDREADERR	0x1100 /* unrecovered read error */
#define	UCSASC_READTRYFAILED	0x1101 /* read retries exhausted */
#define	UCSASC_ERRTOOLONG	0x1102 /* error too long to correct */
#define	UCSASC_MULREADERR	0x1103 /* multiple read errors */
#define	UCSASC_HARDREADAREALLOC	0x1104 /* unrecovered read error - auto reallocate failed */
#define	UCSASC_LECORRECTIONERR	0x1105 /* L-EC uncorrectible error */
#define	UCSASC_HARDCIRCERR	0x1106 /* CIRC unrecovered error */
#define	UCSASC_DATARESYNCERR	0x1107 /* data resynchronization error */
#define	UCSASC_PARTBLOCKREAD	0x1108 /* incomplete block read */
#define	UCSASC_NOGAPFOUND	0x1109 /* no gap found */
#define	UCSASC_MISCORRECTEDERR	0x110A /* miscorrected error */
#define	UCSASC_HARDREADREASSGN	0x110B /* unrecovered read error - recommended reassignment */
#define	UCSASC_HARDREADREWRITE	0x110C /* unrecovered read error - recommended rewrite the data */

#define	UCSASC_DECOMPSERR	0x110D /* de-compression error */
#define	UCSASC_CANNOTDECOMP	0x110E /* cannot decompress using declared alogrithm */
#define	UCSASC_110D	0x110D /* de-compression crc error */
#define	UCSASC_110E	0x110E /* cannot decompress using declared algorithm */
#define	UCSASC_110F	0x110F /* error reading upc/ean number */
#define	UCSASC_1110	0x1110 /* error reading isrc number */
#define	UCSASC_1111	0x1111			/* read error - loss of stream */

#define	UCSASC_NOIDFIELDMARK	0x1200 /* address mark not found for id field */
#define	UCSASC_NODATAFIELDMARK	0x1300 /* address mark not found for data field */
#define	UCSASC_NORECORDEDENTITY	0x1400 /* recorded entity not found */
#define	UCSASC_NORECORD		0x1401 /* record not found */
#define	UCSASC_NOFILEMARK	0x1402 /* file mark or setmark not found */
#define	UCSASC_NOEOD		0x1403 /* end of data not found */
#define	UCSASC_BLOCKSEQERR	0x1404 /* block sequence error */

#define	UCSASC_NORECORDREASGN	0x1405 /* record not found - recommend reassign */
#define	UCSASC_NORECORDAUTOREAL	0x1406 /* record not found - data auto reallocated */
#define	UCSASC_1405	0x1405 /* Record not found - recommend reassignment */
#define	UCSASC_1406	0x1406 /* Record not found - data auto-reallocated */

#define	UCSASC_RANDPOSITIONERR	0x1500 /* random positioning error */
#define	UCSASC_MECHPOSITIONERR	0x1501 /* mechanical positioning error */
#define	UCSASC_READPOSITIONERR	0x1502 /* position error detected by read of medium */
#define	UCSASC_DATASYNCMARKERR	0x1600 /* data synchronization mark error */

#define	UCSASC_SYNCERREWRITTEN	0x1601 /* data sync error - data rewritten */
#define	UCSASC_SYNCERRECREWRITE	0x1602 /* data sync error - recommend rewrite */
#define	UCSASC_SYNCERRAUTOREAL	0x1603 /* data sync error - data auto reallocated */
#define	UCSASC_SYNCERREASSIGN	0x1604 /* data sync error - recommend reassign */
#define	UCSASC_1601	0x1601 /* Data sync error - data rewritten */
#define	UCSASC_1602	0x1602 /* Data sync error - recommend rewrite */
#define	UCSASC_1603	0x1603 /* Data sync error - data auto-reallocated */
#define	UCSASC_1604	0x1604 /* Data sync error - recommend reassignment */

#define	UCSASC_SOFTNOCORRECTION	0x1700 /* recovered data with no error correction applied */
#define	UCSASC_SOFTRETRIES	0x1701 /* recovered data with retries */
#define	UCSASC_SOFTPLUSHEADOFF	0x1702 /* recovered data with positive head offset */
#define	UCSASC_SOFTNEGHEADOFF	0x1703 /* recovered data with negative head offset */
#define	UCSASC_SOFTRETRYCIRC	0x1704 /* recovered data with and/or CIRC applied */
#define	UCSASC_SOFTPREVSECID	0x1705 /* recovered data using previous sector id */ 
#define	UCSASC_SOFTWOECCREALLOC	0x1706 /* recovered data without ECC - data auto reallocated */ 
#define	UCSASC_SOFTWOECCREASSGN	0x1707 /* recovered data without ECC - recommended reassignment */
#define	UCSASC_SOFTWOECCREWRITE	0x1708 /* recovered data without ECC - recommended rewrite */

#define	UCSASC_SOFTWOECCWRITTEN	0x1709 /* recovered data without ECC - data rewritten */
#define	UCSASC_1709	0x1709 /* Recovered data without ECC - data rewritten */

#define	UCSASC_SOFTCORRECTION	0x1800 /* recovered data with error correction applied */
#define	UCSASC_SOFTRETRYCORREC	0x1801 /* recovered data with error correction & retries applied */
#define	UCSASC_SOFTREALLOC	0x1802 /* recovered data - data auto reallocated */
#define	UCSASC_SOFTCIRC		0x1803 /* recovered data with CIRC */ 
#define	UCSASC_SOFTLEC		0x1804 /* recovered data with L-EC */ 
#define	UCSASC_SOFTREASSIGN	0x1805 /* recovered data - recommended reassignment */
#define	UCSASC_SOFTREWRITE	0x1806 /* recovered data - recommended rewrite */

#define	UCSASC_SOFTWRITTEN	0x1807 /* recovered data with ECC - data rewritten */
#define	UCSASC_1807	0x1807 /* Recovered data with ECC - data rewritten */

#define	UCSASC_DEFECTLISTERR	0x1900 /* defect list error */
#define	UCSASC_DEFECTLISTNA	0x1901 /* defect list not available */
#define	UCSASC_PRIMARYDEFECTERR	0x1902 /* defect list error in primary list */
#define	UCSASC_GROWNDEFECTERR	0x1903 /* defect list error in grown list */
#define	UCSASC_ILLPARAMLEN	0x1A00 /* parameter list length error */
#define	UCSASC_SYNCTXERR	0x1B00 /* synchronous data transfer error */
#define	UCSASC_NODEFECTLIST	0x1C00 /* defect list not found */
#define	UCSASC_NOPRIMARYDEFECT	0x1C01 /* primary defect list not found */
#define	UCSASC_NOGROWNDEFECT	0x1C02 /* grown defect list not found */
#define	UCSASC_VERIFYMISMATCH	0x1D00 /* miscompare during verify operation */
#define	UCSASC_SOFTIDECC	0x1E00 /* recovered ID with ECC correction */

#define	UCSASC_PARTDEFECTLIST	0x1F00 /* partial defect list transfer */
#define	UCSASC_1F00	0x1F00 /* Partial defect list transfer */

#define	UCSASC_INVCMDOPCODE	0x2000 /* invalid command operation code */
#define	UCSASC_INVBLOCKADDR	0x2100 /* logical block address out of range */
#define	UCSASC_INVELEMENTADDR	0x2101 /* invalid element address */
#define	UCSASC_ILLFUNC		0x2200 /* illegal function (should use 20 00, 24 00, or 26 00) */
#define	UCSASC_INVFIELDINCDB	0x2400 /* invalid field in CDB */
#define	UCSASC_LUNOTSUPPORTED	0x2500 /* logical unit not supported */
#define	UCSASC_INVFIELDINPARAM	0x2600 /* invalid field in parameter list */
#define	UCSASC_PARAMNOTSUPPORT	0x2601 /* parameter not supported */
#define	UCSASC_INVPARAM		0x2602 /* parameter value invalid */
#define	UCSASC_NOPFAPARAM	0x2603 /* threshold parameters not supported */

#define	UCSASC_2604	0x2604 /* Invalid release of active persistent reservation */

#define	UCSASC_WRITEPROTECTED	0x2700 /* write protected */

#define	UCSASC_2701	0x2701 /* Hardware write protected */
#define	UCSASC_2702	0x2702 /* Logical unit software write protected */
#define	UCSASC_2703	0x2703 /* Associated write protect */
#define	UCSASC_2704	0x2704 /* Persistent write protect */
#define	UCSASC_2705	0x2705 /* Permanent write protect */

#define	UCSASC_NOTREADYTOTRANS	0x2800 /* not ready to ready transition, medium may have changed */
#define	UCSASC_IMPORTEXPORTUSED	0x2801 /* import or export element accessed */
#define	UCSASC_RESET		0x2900 /* power on, reset, or bus device reset occurred */

#define	UCSASC_POWERONOCCURRED	0x2901 /* power on occurred */
#define	UCSASC_SCSIBUSRESET	0x2902 /* SCSI BUS reset occurred */
#define	UCSASC_BUSDEVRESETMSG	0x2903 /* BUS device reset message occurred */
#define	UCSASC_2901	0x2901	/* Power on occurred */
#define	UCSASC_2902	0x2902	/* SCSI bus reset occurred */
#define	UCSASC_2903	0x2903	/* Bus device reset function occurred */
#define	UCSASC_2904	0x2904	/* Device internal reset */

#define	UCSASC_PARAMCHANGED	0x2A00 /* parameters changed */
#define	UCSASC_MODEPARAMCHANGED	0x2A01 /* mode parameters changed */
#define	UCSASC_LOGPARAMCHANGED	0x2A02 /* log parameters changed */

#define	UCSASC_2A03	0x2A03 /* Reservations preempted */

#define	UCSASC_COPYDISCONNECT	0x2B00 /* copy cannot execute since host cannot disconnect */
#define	UCSASC_CMDSEQERR	0x2C00 /* command sequence error */
#define	UCSASC_TOOMANYWINDOWS	0x2C01 /* too many windows specified */
#define	UCSASC_INVWINDOWCOMB	0x2C02 /* invalid combination of windows specified */

#define	UCSASC_2C03	0x2C03 /* Current program area is not empty */
#define	UCSASC_2C04	0x2C04 /* Current program area is empty */

#define	UCSASC_OVERWRITERR	0x2D00 /* overwrite error on update in place */
#define	UCSASC_CMDCLEARED	0x2F00 /* command cleared by another initiator*/

#define	UCSASC_INCOMPATMEDIUM	0x3000 /* incompatible medium installed */
#define	UCSASC_UNKNOWNFORMAT	0x3001 /* cannot read medium - unknown format */
#define	UCSASC_INCOMPATFORMAT	0x3002 /* cannot read medium - incompatible format */
#define	UCSASC_CLEANCARTRIDGE	0x3003 /* cleaning cartridge installed */

#define	UCSASC_WRITERRUNFORMAT	0x3004 /* cannot write medium - unknown format */
#define	UCSASC_WRITERRBADFORMAT	0x3005 /* cannot write medium - incompatible format */
#define	UCSASC_FORMATERRBADMED	0x3006 /* cannot format medium - incompatible medium */
#define	UCSASC_3004	0x3004 /* Cannot write medium - unknown format */
#define	UCSASC_3005	0x3005 /* Cannot write medium - incompatible format */
#define	UCSASC_3006	0x3006 /* Cannot format medium - incompatible medium */
#define	UCSASC_3007	0x3007 /* Cleaning failure */
#define	UCSASC_3008	0x3008 /* Cannot write - application code mismatch */
#define	UCSASC_3009	0x3009 /* Current session not fixated for append */

#define	UCSASC_BADFORMAT	0x3100 /* medium format corrupted */
#define	UCSASC_FORMATERR	0x3101 /* format command failed */
#define	UCSASC_NODEFECTSPARE	0x3200 /* no defect spare location available */
#define	UCSASC_DEFECTLISTUPERR	0x3201 /* defect list update failure */
#define	UCSASC_TAPELENERR	0x3300 /* tape length error */

#define	UCSASC_3400	0x3400 /* Enclosure failure */
#define	UCSASC_3500	0x3500 /* Enclosure services failure */
#define	UCSASC_3501	0x3501 /* Unsupported enclosure function */
#define	UCSASC_3502	0x3502 /* Enclosure services unavailable */
#define	UCSASC_3503	0x3503 /* Enclosure services transfer failure */
#define	UCSASC_3504	0x3504 /* Enclosure services transfer refused */

#define	UCSASC_NOINK		0x3600 /* ribbon, ink, or toner failure */
#define	UCSASC_ROUNDEDPARAM	0x3700 /* rounded parameter */
#define	UCSASC_NOSAVEPARAM	0x3900 /* saving parameters not supported */
#define	UCSASC_NOMEDIA		0x3A00 /* medium not present */

#define	UCSASC_3A01	0x3A01 /* Medium not present - tray closed */
#define	UCSASC_3A02	0x3A02 /* Medium not present - tray open */

#define	UCSASC_SEQPOSITIONERR	0x3B00 /* sequential positioning error */
#define	UCSASC_TAPEBOMERR	0x3B01 /* tape position error at beginning of medium */
#define	UCSASC_TAPEEOMERR	0x3B02 /* tape position error at end of medium */
#define	UCSASC_TAPENOTREADY	0x3B03 /* tape or electronic vertical forms unit not ready */
#define	UCSASC_SLEWFAIL		0x3B04 /* SLEW failure */
#define	UCSASC_PAPERJAM		0x3B05 /* paper jam */
#define	UCSASC_TOPFORMERR	0x3B06 /* failed to sense top of form */
#define	UCSASC_BOTTOMFORMERR	0x3B07 /* failed to sense bottom of form */
#define	UCSASC_POSITIONERR	0x3B08 /* position error */
#define	UCSASC_READPASTEOM	0x3B09 /* read past end of medium */
#define	UCSASC_READPASTBOM	0x3B0A /* read past beginning of medium */
#define	UCSASC_POSITIONPASTEOM	0x3B0B /* position past end of medium */
#define	UCSASC_POSITIONPASTBOM	0x3B0C /* position past beginning of medium */
#define	UCSASC_MEDIADESTFULL	0x3B0D /* medium destination element full */
#define	UCSASC_NOMEDIAELEMENT	0x3B0E /* medium source element empty */

#define	UCSASC_3B0F	0x3B0F /* End of medium reached */
#define	UCSASC_3B11	0x3B11 /* Medium magazine not accessible */
#define	UCSASC_3B12	0x3B12 /* Medium magazine removed */
#define	UCSASC_3B13	0x3B13 /* Medium magazine inserted */
#define	UCSASC_3B14	0x3B14 /* Medium magazine locked */
#define	UCSASC_3B15	0x3B15 /* Medium magazine unlocked */

#define	UCSASC_INVIDMSG		0x3D00 /* invalid bits in identify message */
#define	UCSASC_LUNOTCONFIGYET	0x3E00 /* logical unit has not self configured yet */

#define	UCSASC_3E01	0x3E01 /* Logical unit failure */
#define	UCSASC_3E02	0x3E02 /* Timeout on logical unit */

#define	UCSASC_TARGETOPCHANGED	0x3F00 /* target operating conditions have changed */
#define	UCSASC_MICROCODECHANGED	0x3F01 /* microcode has been changed */
#define	UCSASC_OPDEFCHANGED	0x3F02 /* changed operating definition */
#define	UCSASC_INQCHANGED	0x3F03 /* inquiry data has changed */

#define	UCSASC_RAMFAIL		0x4000 /* RAM failure (should use 40 nn) */
#define	UCSASC_DIAGERR		0x4080 /* diagnostic failure on component NN(80-FF) */

#define UCSASC_40FF			0x40FF

#define	UCSASC_DATAPATHERR	0x4100 /* data path failure ( should use 40 nn) */
#define	UCSASC_RESETFAIL	0x4200 /* power-on, self-test failure ( should use 40 nn) */
#define	UCSASC_MESSAGERR	0x4300 /* message error */
#define	UCSASC_TARGETINERR	0x4400 /* internal target failure */
#define	UCSASC_RESELERR		0x4500 /* select or reselect failure */
#define	UCSASC_SOFTRESETERR	0x4600 /* unsuccessful soft reset */
#define	UCSASC_SCSIPARITYERR	0x4700 /* SCSI parity error */
#define	UCSASC_CMDPHASERR	0x4A00 /* command phase error */
#define	UCSASC_HOSTERRMESSAGE	0x4800 /* initiator detected error message received */
#define	UCSASC_INVMSGERR	0x4900 /* invalid message error */
#define	UCSASC_CMDPHASERR	0x4A00 /* command phase error */
#define	UCSASC_DATAPHASEERR	0x4B00 /* data phase error */
#define	UCSASC_LUCONFIGERR	0x4C00 /* logical unit failed self configuration */

#define UCSASC_4D00			0x4D00 /* Tagged overlapped commands (NN = queue tag) */
#define UCSASC_4DNN			0x4DFF /* Tagged overlapped commands (NN = queue tag) */

#define	UCSASC_OVERLAPPEDCMD	0x4E00 /* overlapped commands attempted */

#define	UCSASC_WRITEAPPENDERR	0x5000 /* write append error */
#define	UCSASC_WRITEAPPENDPOSER	0x5001 /* write append position error */
#define	UCSASC_TIMEPOSITIONERR	0x5002 /* position error related to timing */
#define	UCSASC_ERASEFAIL	0x5100 /* erase failure */
#define	UCSASC_CARTRIDGEFAULT	0x5200 /* cartridge fault */
#define	UCSASC_MEDIALOADFAIL	0x5300 /* media load or eject failed */
#define	UCSASC_TAPEUNLOADFAIL	0x5301 /* unload tape failure */
#define	UCSASC_MEDIALOCKED	0x5302 /* medium removal prevented */
#define	UCSASC_SCSIHOSTIFFAIL	0x5400 /* SCSI to host system interface failure */
#define	UCSASC_RESOURCEFAIL	0x5500 /* system resource failure */

#define	UCSASC_5501	0x5501 /* System buffer full */

#define	UCSASC_NOTOC		0x5700 /* unable to recover table of contents */
#define	UCSASC_NOGENERATION	0x5800 /* generation does not exist */
#define	UCSASC_BLOCKREADUPDATE	0x5900 /* updated block read */
#define	UCSASC_MEDIASTATECHG	0x5A00 /* operator request or state change input (unspecified) */
#define	UCSASC_MEDIARMREQ	0x5A01 /* operator medium removal request */
#define	UCSASC_OPSELWRITEPROT	0x5A02 /* operator selected write protect */
#define	UCSASC_OPSELWRITEOK	0x5A03 /* operator selected write permit */
#define	UCSASC_LOGEXCEPTION	0x5B00 /* log exception */
#define	UCSASC_PFA		0x5B01 /* threshold condition met */
#define	UCSASC_LOGCOUNTMAX	0x5B02 /* log counter at maximum */
#define	UCSASC_LOGLISTCODEND	0x5B03 /* log list codes exhausted */
#define	UCSASC_RPLSTATCHANGED	0x5C00 /* RPL status change */
#define	UCSASC_SPINDLESYNCD	0x5C01 /* spindles synchronized */
#define	UCSASC_SPINDLENOTSYNCD	0x5C02 /* spindles not synchronized */

#define	UCSASC_5D00	0x5D00 /* Failure prediction threshold exceeded */
#define	UCSASC_PFTE		0x5D00 /* failure prediction threshold exceeded */
#define	UCSASC_LOWPOWER		0x5E00 /* low power condition active */
#define	UCSASC_IDLEBYTIMER	0x5E01 /* idle condition activated by timer */
#define	UCSASC_STANDBYTIMER	0x5E02 /* standby condition activated by timer */
#define	UCSASC_IDLEBYCMD	0x5E03 /* idle condition activated by command */
#define	UCSASC_STANDBYCMD	0x5E04 /* standby condition activated by command */
#define	UCSASC_5DFF	0x5DFF /* Failure prediction threshold exceeded (FALSE) */
#define	UCSASC_5E00	0x5E00 /* Low power condition on */
#define	UCSASC_5E01	0x5E01 /* Idle condition activated by timer */
#define	UCSASC_5E02	0x5E02 /* Standby condition activated by timer */
#define	UCSASC_5E03	0x5E03 /* Idle condition activated by command */
#define	UCSASC_5E04	0x5E04 /* Standby condition activated by command */

#define	UCSASC_LAMPFAIL		0x6000 /* lamp failure */
#define	UCSASC_VIDEOERR		0x6100 /* video acquisition error */
#define	UCSASC_NOVIDEO		0x6101 /* unable to acquire video */
#define	UCSASC_OUTOFOCUS	0x6102 /* out of focus */
#define	UCSASC_SCANHEADPOSERR	0x6200 /* scan head positioning error */
#define	UCSASC_ENDOFUSERAREA	0x6300 /* end of user area encountered on this track */

#define UCSASC_6301		0x6301 /* Packet does not fit in available space */

#define	UCSASC_ILLTRACKMODE	0x6400 /* illegal mode for this track */

#define UCSASC_6401		0x6401 /* Invalid packet size */

#define UCSASC_6500		0x6500	/* Voltage fault */

#define UCSASC_6600		0x6600	/* Automatic document feeder cover up */
#define UCSASC_6601		0x6601	/* Automatic document feeder lift up */
#define UCSASC_6602		0x6602	/* Document jam in automatic document feeder */
#define UCSASC_6603		0x6603	/* Document miss feed in automatic document feeder */

#define UCSASC_6700		0x6700	/* Configuration failure */
#define UCSASC_6701		0x6701	/* Configuration of incapable logical units failed */
#define UCSASC_6702		0x6702	/* Add logical unit failed */
#define UCSASC_6703		0x6703	/* Modification of logical unit failed */
#define UCSASC_6704		0x6704	/* Exchange of logical unit failed */
#define UCSASC_6705		0x6705	/* Remove of logical unit failed */
#define UCSASC_6706		0x6706	/* Attachment of logical unit failed */
#define UCSASC_6707		0x6707	/* Creation of logical unit failed */

#define UCSASC_6800		0x6800  /* Logical unit not configured */
#define UCSASC_6900		0x6900  /* Data loss on logical unit */
#define UCSASC_6901		0x6901  /* Multiple logical unit failures */
#define UCSASC_6902		0x6902  /* Parity/Data mismatch */
#define UCSASC_6A00		0x6A00  /* Informational, refer to log */

#define UCSASC_6B00		0x6B00	/* State change has occurred */
#define UCSASC_6B01		0x6B01	/* Redundancy level got better */
#define UCSASC_6B02		0x6B02	/* Redundancy level got worse */

#define UCSASC_6C00		0x6C00	/* Rebuild failure occurred */
#define UCSASC_6D00		0x6D00	/* Recalculate failure occurred */
#define UCSASC_6E00		0x6E00	/* Command to logical unit failed */

#define UCSASC_7000		0x7000	/* Decompression exception short algorithm ID of NN */
#define UCSASC_70NN		0x70FF	/* Decompression exception short algorithm ID of NN */
#define UCSASC_7100		0x7100	/* Decompression exception long algorithm ID */

#define UCSASC_7200		0x7200	/* Session fixation error */
#define UCSASC_7201		0x7201	/* Session fixation error writing lead-in */
#define UCSASC_7202		0x7202	/* Session fixation error writing lead-out */
#define UCSASC_7203		0x7203	/* Session fixation error - incomplete track in session */
#define UCSASC_7204		0x7204	/* Empty of partially written reserved track */

#define UCSASC_7300		0x7300	/* CD control error */
#define UCSASC_7301		0x7301	/* Power calibration area almost full */
#define UCSASC_7302		0x7302	/* Power calibration area is full */
#define UCSASC_7303		0x7303	/* Power calibration area error */
#define UCSASC_7304		0x7304	/* Program memory area update failure */
#define UCSASC_7305		0x7305	/* Program memory area is full */

/* Mylex specific code */
#define	UCSASC_DEADEVWRITERR	0x8000 /* drive killed - write recovery failed */
#define	UCSASC_DEADEVBUSRESETER	0x8001 /* drive killed - scsi bus reset failed */
#define	UCSASC_DEADEVTWOCHECK	0x8002 /* drive killed - double check condition */
#define	UCSASC_DEADEVREMOVED	0x8003 /* drive killed - it was removed */
#define	UCSASC_DEADEVSIOP	0x8004 /* drive killed - gross error on siop */
#define	UCSASC_DEADEVBADTAG	0x8005 /* drive killed - bad tag from drive */
#define	UCSASC_DEADEVTIMEOUT	0x8006 /* drive killed - scsi timeout */
#define	UCSASC_DEADEVRESETSYS	0x8007 /* drive killed - reset from system */
#define	UCSASC_DEADEVBUSY	0x8008 /* drive killed - busy or parity count hi */
#define	UCSASC_DEADEVCMD	0x8009 /* drive killed - by system command */
#define	UCSASC_DEADEVSELTIMEOUT	0x800A /* drive killed - selection timeout */
#define	UCSASC_DEADEVSEQERR	0x800B /* drive killed - sequence error */
#define	UCSASC_DEADEVUNKNOWNSTS	0x800C /* drive killed - unknown status */

/* add more sense code from latest SCSI document */
#define UCSASC_0409		0x0409	/* Logical unit not ready, self-test in progress */

#define UCSASC_0804		0x0804	/* Unreachable copy target */

#define UCSASC_2401		0x2401	/* CDB decryption error */

#define UCSASC_2605		0x2605	/* Data decryption error */
#define UCSASC_2606		0x2606	/* Too many target descriptors */
#define UCSASC_2607		0x2607	/* Unsupported target descriptor type code */
#define UCSASC_2608		0x2608	/* Too many segment descriptors */
#define UCSASC_2609		0x2609	/* Unsupported segment descriptor type code */
#define UCSASC_260A		0x260A	/* Unexpected inexact segment */
#define UCSASC_260B		0x260B	/* Inline data length exceeded */
#define UCSASC_260C		0x260C	/* Invalid operation for copy source or destination */
#define UCSASC_260D		0x260D	/* Copy segment granularity violation */

#define UCSASC_2905		0x2905	/* Transceiver mode changed to single-ended */
#define UCSASC_2906		0x2906	/* Transceiver mode changed to LVD */

#define UCSASC_2A04		0x2A04	/* Reservations released */
#define UCSASC_2A05		0x2A05	/* Registrations preempted */

#define UCSASC_2C05		0x2C05	/* Illegal power condition request */

#define UCSASC_2E00		0x2E00	/* Error detected by third party temporary initiator */
#define UCSASC_2E01		0x2E01	/* Third party device failure */
#define UCSASC_2E02		0x2E02	/* Copy target device not reachable */
#define UCSASC_2E03		0x2E03	/* Incorrect copy target device type */
#define UCSASC_2E04		0x2E04	/* Copy target device data underrun */
#define UCSASC_2E05		0x2E05	/* Copy target device data overrun */

#define UCSASC_3800		0x3800	/* Event status notification */
#define UCSASC_3802		0x3802	/* ESN - power management class event */
#define UCSASC_3804		0x3804	/* ESN - media class event */
#define UCSASC_3806		0x3806	/* ESN - device busy class event */

#define UCSASC_3A03		0x3A03	/* Medium not present - loadable */
#define UCSASC_3A04		0x3A04	/* Medium not present - medium auxiliary memory accessible */

#define UCSASC_3B16		0x3B16	/* Mechanical positioning or changer error */

#define UCSASC_3E03		0x3E03	/* Logical unit failed self-test */
#define UCSASC_3E04		0x3E04	/* Logical unit unable to update self-test log */

#define UCSASC_3F04		0x3F04	/* Component device attached */
#define UCSASC_3F05		0x3F05	/* Device identifier changed */
#define UCSASC_3F06		0x3F06	/* Redundancy group created or modified */
#define UCSASC_3F07		0x3F07	/* Redundancy group deleted */
#define UCSASC_3F08		0x3F08	/* Spare created or modified */
#define UCSASC_3F09		0x3F09	/* Spare deleted */
#define UCSASC_3F0A		0x3F0A	/* Volume set created or modified */
#define UCSASC_3F0B		0x3F0B	/* Volume set deleted */
#define UCSASC_3F0C		0x3F0C	/* Volume set deassigned */
#define UCSASC_3F0D		0x3F0D	/* Volume set reassigned */
#define UCSASC_3F0E		0x3F0E	/* Reported luns data has changed */
#define UCSASC_3F0F		0x3F0F	/* Echo buffer overwritten */
#define UCSASC_3F10		0x3F10	/* Medium loadable */
#define UCSASC_3F11		0x3F11	/* Medium auxiliary memory accessible */

#define UCSASC_4701		0x4701	/* Data phase CRC error detected */
#define UCSASC_4702		0x4702	/* SCSI parity error detected during ST data phase */
#define UCSASC_4703		0x4703	/* Information unit CRC error detected */
#define UCSASC_4704		0x4704	/* Asynchronous information protection error detected */

#define UCSASC_5502		0x5502	/* Insufficient reservation resources */
#define UCSASC_5503		0x5503	/* Insufficient resources */
#define UCSASC_5504		0x5504	/* Insufficient registration resources */

#define UCSASC_5D01		0x5D01	/* Media failure prediction threshold exceeded */
#define UCSASC_5D02		0x5D02	/* Logical unit failure prediction threshold exceeded */

#define UCSASC_5D10		0x5D10	/* Hardware impending failure general hard drive failure */
#define UCSASC_5D11		0x5D11	/* Hardware impending failure drive error rate too high */
#define UCSASC_5D12		0x5D12	/* Hardware impending failure data error rate too high */
#define UCSASC_5D13		0x5D13	/* Hardware impending failure seek error rate too high */
#define UCSASC_5D14		0x5D14	/* Hardware impending failure too many block reassigns */
#define UCSASC_5D15		0x5D15	/* Hardware impending failure access times too high */
#define UCSASC_5D16		0x5D16	/* Hardware impending failure start unit times too high */
#define UCSASC_5D17		0x5D17	/* Hardware impending failure channel parametrics */
#define UCSASC_5D18		0x5D18	/* Hardware impending failure controller detected */
#define UCSASC_5D19		0x5D19	/* Hardware impending failure throughput performance */
#define UCSASC_5D1A		0x5D1A	/* Hardware impending failure seek time performance */
#define UCSASC_5D1B		0x5D1B	/* Hardware impending failure spin-up retry count */
#define UCSASC_5D1C		0x5D1C	/* Hardware impending failure drive calibration retry count */

#define UCSASC_5D20		0x5D20	/* Controller impending failure general hard drive failure */
#define UCSASC_5D21		0x5D21	/* Controller impending failure drive error rate too high */
#define UCSASC_5D22		0x5D22	/* Controller impending failure data error rate too high */
#define UCSASC_5D23		0x5D23	/* Controller impending failure seek error rate too high */
#define UCSASC_5D24		0x5D24	/* Controller impending failure too many block reassigns */
#define UCSASC_5D25		0x5D25	/* Controller impending failure access times too high */
#define UCSASC_5D26		0x5D26	/* Controller impending failure start unit times too high */
#define UCSASC_5D27		0x5D27	/* Controller impending failure channel parametrics */
#define UCSASC_5D28		0x5D28	/* Controller impending failure controller detected */
#define UCSASC_5D29		0x5D29	/* Controller impending failure throughput performance */
#define UCSASC_5D2A		0x5D2A	/* Controller impending failure seek time performance */
#define UCSASC_5D2B		0x5D2B	/* Controller impending failure spin-up retry count */
#define UCSASC_5D2C		0x5D2C	/* Controller impending failure drive calibration retry count */

#define UCSASC_5D30		0x5D30	/* Data channel impending failure general hard drive failure */
#define UCSASC_5D31		0x5D31	/* Data channel impending failure drive error rate too high */
#define UCSASC_5D32		0x5D32	/* Data channel impending failure data error rate too high */
#define UCSASC_5D33		0x5D33	/* Data channel impending failure seek error rate too high */
#define UCSASC_5D34		0x5D34	/* Data channel impending failure too many block reassigns */
#define UCSASC_5D35		0x5D35	/* Data channel impending failure access times too high */
#define UCSASC_5D36		0x5D36	/* Data channel impending failure start unit times too high */
#define UCSASC_5D37		0x5D37	/* Data channel impending failure channel parametrics */
#define UCSASC_5D38		0x5D38	/* Data channel impending failure controller detected */
#define UCSASC_5D39		0x5D39	/* Data channel impending failure throughput performance */
#define UCSASC_5D3A		0x5D3A	/* Data channel impending failure seek time performance */
#define UCSASC_5D3B		0x5D3B	/* Data channel impending failure spin-up retry count */
#define UCSASC_5D3C		0x5D3C	/* Data channel impending failure drive calibration retry count */

#define UCSASC_5D40		0x5D40	/* Servo impending failure general hard drive failure */
#define UCSASC_5D41		0x5D41	/* Servo impending failure drive error rate too high */
#define UCSASC_5D42		0x5D42	/* Servo impending failure data error rate too high */
#define UCSASC_5D43		0x5D43	/* Servo impending failure seek error rate too high */
#define UCSASC_5D44		0x5D44	/* Servo impending failure too many block reassigns */
#define UCSASC_5D45		0x5D45	/* Servo impending failure access times too high */
#define UCSASC_5D46		0x5D46	/* Servo impending failure start unit times too high */
#define UCSASC_5D47		0x5D47	/* Servo impending failure channel parametrics */
#define UCSASC_5D48		0x5D48	/* Servo impending failure controller detected */
#define UCSASC_5D49		0x5D49	/* Servo impending failure throughput performance */
#define UCSASC_5D4A		0x5D4A	/* Servo impending failure seek time performance */
#define UCSASC_5D4B		0x5D4B	/* Servo impending failure spin-up retry count */
#define UCSASC_5D4C		0x5D4C	/* Servo impending failure drive calibration retry count */

#define UCSASC_5D50		0x5D50	/* Spindle impending failure general hard drive failure */
#define UCSASC_5D51		0x5D51	/* Spindle impending failure drive error rate too high */
#define UCSASC_5D52		0x5D52	/* Spindle impending failure data error rate too high */
#define UCSASC_5D53		0x5D53	/* Spindle impending failure seek error rate too high */
#define UCSASC_5D54		0x5D54	/* Spindle impending failure too many block reassigns */
#define UCSASC_5D55		0x5D55	/* Spindle impending failure access times too high */
#define UCSASC_5D56		0x5D56	/* Spindle impending failure start unit times too high */
#define UCSASC_5D57		0x5D57	/* Spindle impending failure channel parametrics */
#define UCSASC_5D58		0x5D58	/* Spindle impending failure controller detected */
#define UCSASC_5D59		0x5D59	/* Spindle impending failure throughput performance */
#define UCSASC_5D5A		0x5D5A	/* Spindle impending failure seek time performance */
#define UCSASC_5D5B		0x5D5B	/* Spindle impending failure spin-up retry count */
#define UCSASC_5D5C		0x5D5C	/* Spindle impending failure drive calibration retry count */

#define UCSASC_5D60		0x5D60	/* Firmware impending failure general hard drive failure */
#define UCSASC_5D61		0x5D61	/* Firmware impending failure drive error rate too high */
#define UCSASC_5D62		0x5D62	/* Firmware impending failure data error rate too high */
#define UCSASC_5D63		0x5D63	/* Firmware impending failure seek error rate too high */
#define UCSASC_5D64		0x5D64	/* Firmware impending failure too many block reassigns */
#define UCSASC_5D65		0x5D65	/* Firmware impending failure access times too high */
#define UCSASC_5D66		0x5D66	/* Firmware impending failure start unit times too high */
#define UCSASC_5D67		0x5D67	/* Firmware impending failure channel parametrics */
#define UCSASC_5D68		0x5D68	/* Firmware impending failure controller detected */
#define UCSASC_5D69		0x5D69	/* Firmware impending failure throughput performance */
#define UCSASC_5D6A		0x5D6A	/* Firmware impending failure seek time performance */
#define UCSASC_5D6B		0x5D6B	/* Firmware impending failure spin-up retry count */
#define UCSASC_5D6C		0x5D6C	/* Firmware impending failure drive calibration retry count */

#define UCSASC_5E41		0x5E41	/* Power state change to active */
#define UCSASC_5E42		0x5E42	/* Power state change to idle */
#define UCSASC_5E43		0x5E43	/* Power state change to standby */
#define UCSASC_5E45		0x5E45	/* Power state change to sleep */
#define UCSASC_5E47		0x5E47	/* Power state change to device control */

#define UCSASC_6708		0x6708	/* Assign failure occurred */
#define UCSASC_6709		0x6709	/* Multiply assigned logical unit */

#define UCSASC_6F00		0x6F00	/* Copy protection key exchange failure - authentication failure */
#define UCSASC_6F01		0x6F01	/* Copy protection key exchange failure - key not present */
#define UCSASC_6F02		0x6F02	/* Copy protection key exchange failure - key not established */
#define UCSASC_6F03		0x6F03	/* Read of scrambled sector without authentication */
#define UCSASC_6F04		0x6F04	/* Media region code is mismatched to logical unit region */
#define UCSASC_6F05		0x6F05	/* Drive region must be permanent/region reset count error */

#define UCSASC_7306		0x7306	/* RMA/PMA is full */


/* UCSCMD_CONNRECEIVEDATA sub commands and data */
#define	CR6_MAXFANS		2
#define	CR6_MAXPOWERSUPPLIES	3
#define	CR6_MAXDRIVESLOTS	6
#define	UCSCSI_CR6_READ_CAB_STATUS	0x00 /* CR6: read cabinet status */
#define	UCSCSI_SCR_READ_CAB_STATUS	0x01 /* SCR: read cabinet status */
#define	SCR_CAB_STATUS_SIZE		128  /* SCR: cabinet status size */
#define	SAFTE_CAB_STATUS_SIZE		0x7FC/* SAFTE: cabinet status size */
#define	SAFTE_CAB_TOO_HOT		158  /* 70 degree centigrate */
#define	SAFTE_CAB_CRITICAL_HOT		122  /* 50 degree centrigate */
#define	SAFTE_THERMOSTAT_ETA		0x8000	/* Enclosure temp alert */
#define ENVSTAT_CAB_TOO_HOT         70      /* 70 degree centigrate */
#define ENVSTAT_CAB_CRITICAL_HOT    50      /* 50 degree centrigate */

/* SAF-TE fan status values */
#define	SAFTE_FAN_OK		0x00 /* fan is operational */
#define	SAFTE_FAN_BAD		0x01 /* fan is malfunctioning */
#define	SAFTE_FAN_NOTPRESENT	0x02 /* fan is not installed */
#define	SAFTE_FAN_UNKNOWN	0x80 /* Unknown status, or not reportable */

/* SAF-TE power supplies status values */
#define	SAFTE_PWR_OK		0x00 /* power supply is operational and on */
#define	SAFTE_PWR_OFF		0x01 /* power supply is operational and off */
#define	SAFTE_PWR_BADON		0x10 /* power supply is malfunctioning and on */
#define	SAFTE_PWR_BADOFF	0x11 /* power supply is malfunctioning and off*/
#define	SAFTE_PWR_NOTPRESENT	0x20 /* power supply is not present */
#define	SAFTE_PWR_PRESENT	0x21 /* power supply is present */
#define	SAFTE_PWR_UNKNOWN	0x80 /* unknown status, or not reportable */

/* structure to get CONNER'S CR6-RAID system status */
typedef	struct ucscsi_cr6sysstatus
{
	u08bits	cr6_ChannelLEDState;	/* channel LED state value */
	u08bits	cr6_Drive1LEDState;	/* Driver 1 LED State */
	u08bits	cr6_Drive2LEDState;	/* Driver 2 LED State */
	u08bits	cr6_Drive3LEDState;	/* Driver 3 LED State */

	u08bits	cr6_Drive4LEDState;	/* Driver 4 LED State */
	u08bits	cr6_Drive5LEDState;	/* Driver 5 LED State */
	u08bits	cr6_Drive6LEDState;	/* Driver 6 LED State */
	u08bits	cr6_FanStatus;		/* Fan States */

	u08bits	cr6_PowerStatus;	/* power state */
	u08bits	cr6_SpeakerSwitchStatus;/* Speaker kill switch state */
	u08bits	cr6_DataIn;		/* Data in ports */
	u08bits	cr6_Reserved0;

	u32bits	cr6_Reserved1;
}ucscsi_cr6sysstatus_t;
#define	ucscsi_cr6sysstatus_s	sizeof(ucscsi_cr6sysstatus_t)

#define	UCSCSI_SCR_READ_CAB_CONF	0x00 /* read cabinet conf */
#define	UCSCSI_SAFTE_READ_CAB_CONF	0x00000000 /* read cabinet conf */
#define	UCSCSI_SAFTE_READ_CAB_STATUS	0x01000000 /* read cabinet status */
/* structure to get CONNER'S Smart Cabinet Configuration */
typedef	struct ucscsi_scrconf
{
	u08bits	scr_Fans;		/* # fans */
	u08bits	scr_PowerSupplies;	/* # power supplies */
	u08bits	scr_DriveSlots;		/* # drive slots */
	u08bits	scr_DoorLocks;		/* # door locks */

	u08bits	scr_HeatSensors;	/* # temperature sensors */
	u08bits	scr_Speakers;		/* # speakers */
	u08bits	scr_Reserved0;
	u08bits	scr_Reserved1;

	u32bits	scr_Reserved2;
	u32bits	scr_Reserved3;
}ucscsi_scrconf_t;
#define	ucscsi_scrconf_s	sizeof(ucscsi_scrconf_t)


/*
** Mode Sense/Select Header.
** Mode Sense/Select data consists of a header, followed by zero or more
** block descriptors, followed by zero or more mode pages.
*/

typedef	struct ucs_modeheader
{
	u08bits ucsmh_length;		/* number of bytes following */
	u08bits ucsmh_medium_type;	/* device specific */
	u08bits ucsmh_device_specific;	/* device specfic parameters */
	u08bits ucsmh_bdesc_length;	/* block descriptor(s) length,if any*/
}ucs_modeheader_t;
#define	ucs_modeheader_s	sizeof(ucs_modeheader_t)
#define	UCSCSI_MODEHEADERLENGTH	ucs_modeheader_s

/*
** Block Descriptor. Zero, one, or more may normally follow the mode header.
** The density code is device specific.
** The 24-bit value described by blks{2,1,0} describes the number of
** blocks which this block descriptor applies to. A value of zero means
** 'the rest of the blocks on the device'.
** The 24-bit value described by blksize{2, 1, 0} describes the blocksize
** (in bytes) applicable for this block descriptor. For Sequential Access
** devices, if this value is zero, the block size will be derived from
** the transfer length in I/O operations.
**
*/

typedef	struct ucs_blockdescriptor
{
	u08bits ucsbd_density_code;	/* device specific */
	u08bits ucsbd_blks2;		/* hi  */
	u08bits ucsbd_blks1;		/* mid */
	u08bits ucsbd_blks0;		/* low */
	u08bits ucsbd_reserved;		/* reserved */
	u08bits ucsbd_blksize2;		/* hi  */
	u08bits ucsbd_blksize1;		/* mid */
	u08bits ucsbd_blksize0;		/* low */
}ucs_blockdescriptor_t;
#define	ucs_blockdescriptor_s	sizeof(ucs_blockdescriptor_t)

/*
** Define a macro to take an address of a mode header to the address
** of the nth (0..n) block_descriptor, or NULL if there either aren't any
** block descriptors or the nth block descriptor doesn't exist.
*/
#define	UCS_GETBLOCKDESCRIPTOR_ADDR(ucsmhdrp, bdnum) \
	((((bdnum)<((ucsmhdrp)->ucsmh_bdesc_length/ucs_blockdescriptor_s))) ? \
	((ucs_blockdescriptor_t *)(((u32bits)(ucsmhdrp))+ucs_modeheader_s+ \
	((bdnum) * ucs_blockdescriptor_s))) : NULL)

/*
** Mode page header. Zero or more Mode Pages follow either the block
** descriptor(s) (if any), or the Mode Header.
*/
#define	UCS_GETMODEPAGE_ADDR(ucsmhdp)	\
	((((u32bits)(ucsmhdp))+ucs_modeheader_s+(ucsmhdp)->ucsmh_bdesc_length))

/* read/write error recovery paramters */
typedef	struct ucsdad_modepage1
{
	u08bits	ucsdad_pagecode;	/* page code number */
	u08bits	ucsdad_pagelen;		/* page size in bytes */
	u08bits	ucsdad_erretrycnfg;
	u08bits	ucsdad_retrycount;
	u08bits	ucsdad_correctspan;
	u08bits	ucsdad_headoffsetcount;
	u08bits	ucsdad_datastrobeoffset;
	u08bits	ucsdad_reserved0;
	u08bits	ucsdad_writeretrycount;
	u08bits	ucsdad_reserved1;
	u08bits	ucsdad_recoverytimelimit;
} ucsdad_modepage1_t;
#define	ucsdad_modepage1_s	sizeof(ucsdad_modepage1_t)

/* Disconnect / Reconnect control parameters */
typedef	struct	ucsdad_modepage2
{
	u08bits	ucsdad_pagecode;	/* page code number */
	u08bits	ucsdad_pagelen;		/* page size in bytes */
	u08bits	ucsdad_bufferfullratio;
	u08bits	ucsdad_bufferwmptyratio;
	u08bits	ucsdad_businactivelimit1;
	u08bits	ucsdad_businactivelimit0;
	u08bits	ucsdad_disctimelimit1;
	u08bits	ucsdad_disctimelimit0;
	u08bits	ucsdad_connecttimelimit1;
	u08bits	ucsdad_connecttimelimit0;
	u08bits	ucsdad_reserve0;
	u08bits	ucsdad_reserve1;
} ucsdad_modepage2_t;
#define	ucsdad_modepage2_s	sizeof(ucsdad_modepage2_t)

/* Format parameters */
typedef	struct ucsdad_modepage3
{
	u08bits	ucsdad_pagecode;	/* page code number */
	u08bits	ucsdad_pagelen;		/* page size in bytes */
	u08bits	ucsdad_trkperzone1;
	u08bits	ucsdad_trkperzone0;
	u08bits	ucsdad_altsecperzone1;
	u08bits	ucsdad_altsecperzone0;
	u08bits	ucsdad_alttrkperzone1;
	u08bits	ucsdad_alttrkperzone0;
	u08bits	ucsdad_alttrkpervol1;
	u08bits	ucsdad_alttrkpervol0;
	u08bits	ucsdad_secpertrk1;	
	u08bits	ucsdad_secpertrk0;	
	u08bits	ucsdad_bytespersec1;
	u08bits	ucsdad_bytespersec0;
	u08bits	ucsdad_interleave1;
	u08bits	ucsdad_interleave0;
	u08bits	ucsdad_trkskewfactor1;
	u08bits	ucsdad_trkskewfactor0;
	u08bits	ucsdad_cylskewfactore1;
	u08bits	ucsdad_cylskewfactore0;
	u08bits	ucsdad_drivetypecnfg;
	u08bits	ucsdad_reserve0;
	u08bits	ucsdad_reserve1;
	u08bits	ucsdad_reserve2;
} ucsdad_modepage3_t;
#define	ucsdad_modepage3_s	sizeof(ucsdad_modepage3_t)

/* Rigid Disc Drive Geometry parameters */
typedef	struct ucsdad_modepage4
{
	u08bits	ucsdad_pagecode;	/* page code number */
	u08bits	ucsdad_pagelen;		/* page size in bytes */
	u08bits	ucsdad_cyl2;
	u08bits	ucsdad_cyl1;
	u08bits	ucsdad_cyl0;
	u08bits	ucsdad_heads;
	u08bits	ucsdad_writepreccyl2;
	u08bits	ucsdad_writepreccyl1;
	u08bits	ucsdad_writepreccyl0;
	u08bits	ucsdad_reducecurrcyl2;
	u08bits	ucsdad_reducecurrcyl1;
	u08bits	ucsdad_reducecurrcyl0;
	u08bits	ucsdad_steprate1;
	u08bits	ucsdad_steprate0;
	u08bits	ucsdad_landingcyl2;
	u08bits	ucsdad_landingcyl1;
	u08bits	ucsdad_landingcyl0;
	u08bits	ucsdad_reserve0;
	u08bits	ucsdad_reserve1;
	u08bits	ucsdad_reserve2;
} ucsdad_modepage4_t;
#define	ucsdad_modepage4_s	sizeof(ucsdad_modepage4_t)

typedef	struct	ucsdad_modepage5
{
	u08bits	ucsdad_pagecode;	/* page code number */
	u08bits	ucsdad_pagelen;		/* page size in bytes */
	u08bits	ucsdad_xferrate1;
	u08bits	ucsdad_xferrate0;
	u08bits	ucsdad_heads;
	u08bits	ucsdad_secpertrk;
	u08bits	ucsdad_bytespersec1;
	u08bits	ucsdad_bytespersec0;
	u08bits	ucsdad_cyl1;
	u08bits	ucsdad_cyl0;
	u08bits	ucsdad_writepreccyl1;
	u08bits	ucsdad_writepreccyl0;
	u08bits	ucsdad_reducecurrcyl1;
	u08bits	ucsdad_reducecurrcyl0;
	u08bits	ucsdad_steprate1;
	u08bits	ucsdad_steprate0;
	u08bits	ucsdad_steppulsewidth;
	u08bits	ucsdad_headsettledelay;
	u08bits	ucsdad_motorondelay;
	u08bits	ucsdad_motoroffdelay;
	u08bits	ucsdad_trueready;
	u08bits	ucsdad_headloaddelay;
	u08bits	ucsdad_startingsecsidezero;
	u08bits	ucsdad_startingsecsideone;
} ucsdad_modepage5_t;
#define	ucsdad_modepage5_s	sizeof(ucsdad_modepage5_t)

/* cache control mode page */
typedef	struct	ucsdad_modepage8
{
	u08bits	ucsdad_pagecode;		/* page code number */
	u08bits	ucsdad_pagelen;			/* page size in bytes */
	u08bits	ucsdad_cachecontrol;		/* cache control bits */
	u08bits	ucsdad_retention;		/* retention control */
	u08bits	ucsdad_disprefetchtxlen1;	/* disable pre-fetch transfer length */
	u08bits	ucsdad_disprefetchtxlen0;
	u08bits	ucsdad_minprefetch1;		/* minimum pre-fetch  */
	u08bits	ucsdad_minprefetch0;
	u08bits	ucsdad_maxprefetch1;		/* maximum pre-fetch */
	u08bits	ucsdad_maxprefetch0;
	u08bits	ucsdad_maxprefetchceiling1;	/* maximum pre-fetch ceiling */
	u08bits	ucsdad_maxprefetchceiling0;
} ucsdad_modepage8_t;
#define	ucsdad_modepage8_s	sizeof(ucsdad_modepage8_t)

/* ucsdad_cachecontrol bits */
#define	UCSCSICC_RCD	0x01 /* read cache disable */
#define	UCSCSICC_MF	0x02 /* multiplication factor */
#define	UCSCSICC_WCE	0x04 /* write cache enabled */

/* reassign a bad block data structure */
typedef	struct ucsreasnbadblk
{
	u08bits	reasnbblk_resvd0;
	u08bits	reasnbblk_resvd1;
	u08bits	reasnbblk_len1;
	u08bits	reasnbblk_len0;
	u08bits	reasnbblk_addr3;
	u08bits	reasnbblk_addr2;
	u08bits	reasnbblk_addr1;
	u08bits	reasnbblk_addr0;
} ucsreasnbadblk_t;
#define	ucsreasnbadblk_s	sizeof(ucsreasnbadblk_t)

/* UCSCMD_MODESELECTG0 and UCSCMD_MODESELECTG0 parameter informations */
typedef	struct ucscsi_modeparamg0
{
	u08bits	mpg0_Len;		/* data length excluding this byte */
	u08bits	mpg0_DevType;		/* device type */
	u08bits	mpg0_DevSpecParam;	/* device specific parameters */
	u08bits	mpg0_BDLen;		/* block descriptor length */
} ucscsi_modeparamg0_t;
#define	ucscsi_modeparamg0_s	sizeof(ucscsi_modeparamg0_t)

/* exception handling control page */
#define	UCSCSI_ECPAGECODE	0x1C /* exception handle page code */
#define	UCSCSI_PAGECODEMASK	0x3F /* 6 bit mask value */
typedef	struct ucscsi_ecpagecode
{
	u08bits	ecpc_PSPageCode;	/* PS and Page Code */
	u08bits	ecpc_PageLen;		/* page length excluding this byte */
	u08bits	ecpc_PerfExcptTestLog;	/* combo performace, exception, log */
	u08bits	ecpc_ReportMethod;	/* Reporting method */
	u32bits	ecpc_TimerInterval;	/* timer interval */
	u32bits	ecpc_ReportCount;	/* Reporting count */
} ucscsi_ecpagecode_t;
#define	ucscsi_ecpagecode_s	sizeof(ucscsi_ecpagecode_t)

/* ecpc_PSPageCode */
#define	UCSCSI_ECPS	0x80	/* bit7 = 1 the target can save the Mode page
				** in non volatile space, =0 it can not
				*/
/* ecpc_PerfExcptTestLog */
#define	UCSCSI_ECPERFOK	0x80	/* =1 target shall not cause delay when
				** exceptions, =0 it can
				*/
#define	UCSCSI_ECDEXCPT	0x08	/* =1 disable exception reporting, =0 report */
#define	UCSCSI_ECTEST	0x04	/* =1 create false device failure */
#define	UCSCSI_ECLOGERR	0x01	/* =1 */

/* ecpc_ReportMethod */
#define	UCSCSI_ECREPORTMETHODMASK	0x0F
#define	UCSCSI_ECRM_AE		0x01 /* generate Async event */
#define	UCSCSI_ECRM_GUA		0x02 /* generate General Unit Attention */
#define	UCSCSI_ECRM_CRE		0x03 /* Conditionally Generate Recovered Err */
#define	UCSCSI_ECRM_URE		0x04 /* Unconditionally Generate Recovered Err*/
#define	UCSCSI_ECRM_NOSENSE	0x05 /* Generate No Sense */
#define	UCSCSI_ECRM_ONREQ	0x06 /* Only report info exception on request */

/* Sequential device (tape) mode sense/select information */
typedef	struct	ucstmode
{
	u08bits	ucstmode_byte0;
	u08bits	ucstmode_mediumtype;
	u08bits	ucstmode_wpbufspeed;
	u08bits	ucstmode_desc_len;
	u08bits	ucstmode_density;
	u08bits	ucstmode_blks2;
	u08bits	ucstmode_blks1;
	u08bits	ucstmode_blks0;
	u08bits	ucstmode_byte8;
	u08bits	ucstmode_blksize2;
	u08bits	ucstmode_blksize1;
	u08bits	ucstmode_blksize0;
	u08bits	ucstmode_byte12;
} ucstmode_t;
#define	ucstmode_s	sizeof(ucstmode_t)
#define	ucstmodegetseclen(mp) (((mp)->ucstmode_blksize2<<16) + ((mp)->ucstmode_blksize1<<8) + (mp)->ucstmode_blksize0)

/* Page 0x3 - Direct Access Device Format Parameters */
typedef struct ucs_mode_format
{
	u08bits	mf_pagecode;		/* Page Code 3 */
	u08bits	mf_pagelen;		/* Page length 0x16 */
	u16bits	mf_tracks_per_zone;	/* Handling of Defects Fields */
	u16bits	mf_alt_sect_zone;	/* Alternate sector on zone */
	u16bits mf_alt_tracks_zone;	/* Alternate tracks on zone */
	u16bits	mf_alt_tracks_vol;	/* Alternate tracks on voulme */
	u16bits	mf_track_size;		/* Track Format Field */
	u16bits mf_sector_size;		/* Sector Format Fields */
	u16bits	mf_interleave;		/* interleave factor */
	u16bits	mf_track_skew;
	u16bits	mf_cylinder_skew;
	u08bits mf_surfsec;
	u08bits	mf_reserved[3];
} ucs_mode_format_t;
#define ucs_mode_format_s	sizeof(ucs_mode_format_t)

/* Page 0x4 - Rigid Disk Drive Geometry Parameters */
typedef struct ucs_mode_geometry
{
	u08bits	mg_pagecode;		/* Page Code 4 */
	u08bits	mg_pagelen;		/* Page length 16 */
	u08bits	mg_cyl2;		/* number of cylinders */
	u08bits	mg_cyl1;
	u08bits	mg_cyl0;
	u08bits	mg_heads;		/* number of heads */
	u08bits	mg_precomp_cyl2;	/* cylinder to start precomp */
	u08bits	mg_precomp_cyl1;
	u08bits	mg_precomp_cyl0;
	u08bits	mg_current_cyl2;	/* cyl to start reduced current */
	u08bits	mg_current_cyl1;
	u08bits	mg_current_cyl0;
	u16bits	mg_step_rate;		/* drive step rate */
	u08bits	mg_landing_cyl2;	/* landing zone cylinder */
	u08bits	mg_landing_cyl1;
	u08bits	mg_landing_cyl0;
	u08bits	mg_rpl;	      		/*  rotational position locking */
	u08bits	mg_rotational_offset;	/* rotational offset */
	u08bits	mg_reserved;
	u16bits	mg_rpm;			/* rotations per minute */
	u08bits	mg_reserved2[2];
} ucs_mode_geometry_t;
#define ucs_mode_geometry_s	sizeof(ucs_mode_geometry_t)

#define	UCSGETDRVCAPS(SDRVCAP) \
	(((u32bits)(SDRVCAP)->ucscap_capsec3 << 24)|((u32bits)(SDRVCAP)->ucscap_capsec2 << 16) | \
	 ((u32bits)(SDRVCAP)->ucscap_capsec1 <<  8)|((u32bits)(SDRVCAP)->ucscap_capsec0))
#define	UCSGETDRVSECLEN(SDRVCAP) \
	(((u32bits)(SDRVCAP)->ucscap_seclen3 << 24)|((u32bits)(SDRVCAP)->ucscap_seclen2 << 16) | \
	 ((u32bits)(SDRVCAP)->ucscap_seclen1 <<  8)|((u32bits)(SDRVCAP)->ucscap_seclen0))

#endif	/* _SYS_MLXSCSI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac2w2k\sys\mmstruct.h ===
#ifndef __MMSTRUCT_H__


struct IOConfigurationStructure
{
      LONG reserved0;
      WORD flags;
      WORD slot;
      WORD IOPort0;
      WORD IOLength0;
      WORD IOPort1;
      WORD IOLength1;
      LONG MemoryDecode0;
      WORD MemoryLength0;
      LONG MemoryDecode1;
      WORD MemoryLength1;
      BYTE Interrupt0;
      BYTE Interrupt1;
      BYTE DMAUsage0;
      BYTE DMAUsage1;
      LONG IORTag;
      LONG Reserved1;
      BYTE *CMDLineOptionStr;
      BYTE Reserved2[18];
      LONG LinearMemory0;
      LONG LinearMemory1;
      BYTE Reserved3[8];
};

/* struct AdapterInfoDef
    This structure is returned by MM_Return_Object_Specific_Info( ) 
	when the application requests information about an adapter object. */

struct  AdapterInfoDef { 
     BYTE systemType;    							/*Novell-assigned driver type*/ 
     BYTE processorNumber;    						/*server number for SFT III*/ 
     WORD uniqueTag;      
     LONG systemNumber; 
     LONG devices[32];   							/*object IDs of dependent devices/changers*/ 
     struct IOConfigurationStructure configInfo; 	/*contains I/O port information such as share flags, DMA address, and LAN port address*/ 
     BYTE driverName[36];     						/*name of NLM; lengthpreceeded and null-terminated string*/ 
     BYTE systemName[64];     						/*length-preceded ASCII string*/ 
     LONG numberOfDevices;    						/*Number of devices attached to this adapter*/ 
     LONG reserved[7]; 
};

/* struct AttributeInfoDef
    This structure is used by MM_Return_Objects_Attributes( ) to 
	provide information about an object. */

struct AttributeInfoDef { 
     BYTE name[64]; 			/* Name of attribute type, Length preceeded & null terminated string */   
     WORD attributeType; 		/* See Appendix B for Attribute Types */   
     WORD settableFlag;  		/* 	0 = Cannot be set using MM_Set_Object_Attribute, 
									1 = Settable by MM_Set_Object_Attribute */   
     LONG nextAttributeID;    	/* ID of the next available object attribute */   
     LONG attributeSize; 		/* sizeof(attributeType) */ 
};

/* struct DeviceInfoDef
    This structure is returned by MM_Return_Object_Specific_Info( ) 
	when the application requests information about device objects. */

struct  DeviceInfoDef {
     LONG status;  				/*Media Manager object status; bits represent activated, loaded, etc.*/ 
     BYTE controllerNumber; 	/*ID number of adapter board*/
     BYTE driveNumber;  		/*device number assigned by driver*/ 
     BYTE cardNumber;    		/*driver-assigned card number*/ 
     BYTE systemType;    		/*driver type*/ 
     BYTE accessFlags;   		/*removable, read-only, write sequential, dual port, HotFixInhibit or MirrorInhibit*/
     BYTE type; 
     BYTE blockSize;     		/*size of group of sectors to be transferred at once (in bytes)*/ 
     BYTE sectorSize;    		/*requested size for sectors (in bytes); default 512 bytes*/ 
     BYTE heads;    			/*parameter 1 for device objects*/ 
     BYTE sectors;  			/*parameter 2 for device objects*/ 
     WORD cylinders;     		/*parameter 3 for device objects*/ 
     LONG capacity; 			/*total capacity of device in sectors*/ 
	  LONG mmAdapterNumber; 		/*Media Manager object ID for adapter board*/
     LONG mmMediaNumber; 		/*Media Manager object ID for media in device*/ 
     BYTE rawName[40];   		/*device name passed from driver*/ 
     LONG reserved[8]; 
};

/* struct MediaInfoDef
	 This structure is used to identify or create a physical media item
	in MM_Create_Media_Object( ). MediaInfoDef is also passed when
	labeling new media. It is filled in when registering ID functions. */

struct  MediaInfoDef {
	  BYTE label[64];     			/* ASCII string name */
	  LONG identificationType; 		/* Novell-assigned number */
	  LONG identificationTimeStamp; 	/* UNIX time stamp */
};

/* struct GenericInfoDef
    This structure is returned by MM_Return_Object_Generic_Info( ) 
	when the application requests information about a fixed device object.*/

struct GenericInfoDef { 
	  struct MediaInfoDef mediaInfo; 	/*See MediaInfoDef structure definition */
     LONG mediaType;    				/*media type (i.e., cdrom, changer, disk*/ 
     LONG cartridgeType; 				/*cartridge/magazine type the device can use*/ 
     LONG unitSize; 					/*bytes per sector*/ 
     LONG blockSize;     				/*max number of sectors driver can handle per I/O request*/ 
     LONG capacity; 					/*maximum number of sectors on device*/
     LONG preferredUnitSize;  			/*formatted devices can request 512 bytes up to 1K*/ 
     BYTE name[64]; 					/*length-preceded ASCII string*/ 
     LONG type;     					/*database object type (i.e., mirror, partition, magazine, etc.)*/ 
     LONG status; 
     LONG functionMask;  				/*bit map of functions supported by device; 20h2Fh*/ 
     LONG controlMask;   				/*Media Manager function (0-1F)*/ 
     LONG parentCount;   				/*number of objects the device depends on (usually only 1)*/ 
     LONG siblingCount;  				/*number of objects with common dependencies*/ 
     LONG childCount;    				/*number of objects that depend on the device*/ 
     LONG specificInfoSize;   			/*size of data structures that will be returned*/
     LONG objectUniqueID;    			/*Object ID for this instance of GenericInfoDef */
     LONG mediaSlot;    				/*automatically tells which slot media occupies*/ 
};

/* struct HotFixInfoDef 
    This structure is returned by MM_Return_Object_Specific_Info( ) 
	when the application requests information about a HotFix object. */

struct  HotFixInfoDef { 
     LONG hotFixOffset;  			/*HotFix starts at 0000h; hotfixoffset is the location where the real data is located*/ 
     LONG hotFixIdentifier;   		/*unique identifier created when partition is HotFixed*/ 
     LONG numberOfTotalBlocks;     	/*total 4K blocks available in HotFix area*/ 
     LONG numberOfUsedBlocks; 		/*# of 4K blocks containing redirected data*/ 
     LONG numberOfAvailableBlocks; 	/*# of blocks in HotFix area not allocated*/ 
     LONG numberOfSystemBlocks;    	/*blocks used for internal HotFix tables and bad blocks*/ 
     LONG reserved[8]; 
};

/* struct InsertRequestDef 
    This structure handles requests from an application or driver 
	for a particular piece of media within a media changer. */

struct InsertRequestDef { 
     LONG deviceNumber;  	/* # of the device within the media changer that media will move in or out of*/
     LONG mailSlot;     	/*slot in media changer where operators insert/remove media*/ 
     LONG mediaNumber;   	/*slot number*/  
     LONG mediaCount;    	/*total # of media present in the media changer*/ 
};

/* struct MagazineInfoDef 
    This structure is returned by MM_Return_Object_Specific_Info( ) 
	when the application requests information about a Magazine object. */

struct  MagazineInfoDef { 
     LONG numberOfSlots; 					/*equals the number of slots in the magazine +1 (count one extra for the device)*/ 
     LONG reserved[8]; 
     LONG slotMappingTable[]; 	/*byte table of all slots; 
												0 = empty, 
												non-zero = has media; 
											  slotMappingTable[0] is the location 
											  that indicates the media status for 
											  the device, and slotMappingTable[1] 
											  through slotMappingTable[numberOfSlots] 
											  represent all the slots of the magazine.*/ 
};

/* struct MappingInfo 
    This structure is not prototyped in MM.H because the parentCount, 
	siblingCount, and childCount parameters are not known before run
	time.

    MappingInfo is used to hold the information returned by 
	MM_Return_Object_Mapping_Info( ). The minimum possible size of this
	structure is the first 3 LONGs shown, which would occur if there are 
	no parents, siblings, or children.  For any existing object, 
	siblingCount will always be at least 1, since each object is its own 
	sibling. 

    Note: If the device is a magazine, this structure will list one child. 
	That child will be the magazine object.  To obtain the list of media
	associated with this magazine, call  MM_Return_Object_Mapping_Info( ) 
	for this magazine object. */

#if 0
struct  MappingInfo { 
     LONG parentCount;   					/* number of objects an object depends on */ 
     LONG siblingCount;  					/* number of objects depending on same parent */ 
     LONG childCount;    					/* number of objects depending on this device */
     LONG parentObjectID[]; 		/* array of object IDs of parent objects, parentObjectID[parentCount] */
     LONG siblingObjectIDs[]; 	/* array of object IDs of sibling objects, siblingObjectIDs[siblingCount] */
     LONG childObjectIDs[]; 		/* array of object IDs of child objects, childObjectIDs[childCount] */
};
#endif

/* struct MediaRequestDef
	 This structure handles requests from an application or driver for
	a particular piece of media within a media changer. */

struct  MediaRequestDef {
	  LONG deviceNumber;  		/*(object ID) number of the device within the media changer that media will move in or out of*/
     LONG mailSlot; 			/*(slot ID) slot in the media changer where operators insert and remove media*/ 
     LONG mediaNumber;   		/*(object ID) slot number*/ 
     LONG mediaCount;    		/*total number of media present in the media changer*/ 
};

/* struct MirrorInfoDef 
    This structure is returned by MM_Return_Object_Specific_Info( ) 
	when the application requests information about a Mirror object. */

struct  MirrorInfoDef { 
     LONG mirrorCount;   		/*number of partitions in the mirror group*/ 
     LONG mirrorIdentifier;   	/*unique number created when mirror group is created*/ 
     LONG mirrorMembers[8];   	/*object ID's of all HotFix objects in the mirror group*/ 
     BYTE mirrorSyncFlags[8]; 	/*indicates partitions that have current data; 
									0 = old data; 
									non-zero = data is current*/ 
     LONG reserved[8]; 
};

/* struct PartitionInfoDef 
    This structure is returned by MM_Return_Object_Specific_Info when 
	the application requests information about a Partition object. */

struct  PartitionInfoDef { 
     LONG partitionerType;    	/*partition scheme identifier (i.e. DOS, IBM, etc.)*/ 
     LONG partitionType; 		/*number representing partition type. Only the lower BYTE is important.*/ 
	  LONG partitionOffset;    	/*beginning sector number of the partition */
	  LONG partitionSize; 		/*number of sectors in partition; default size is 512Kb*/
     LONG reserved[8];
};

#define	__MMSTRUCT_H__
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac960\dac960nt.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Dac960Nt.h

Abstract:

    This is header file for the driver for the Mylex 960 family.

Author:

    Mike Glass  (mglass)

Environment:

    kernel mode only

Revision History:

--*/

#include "scsi.h"


#define DAC960_PG_ADAPTER   2
#define DAC1164_PV_ADAPTER  3
#define INITIATOR_BUSID     0xFE /* To Support >=32 Targets */

//
// SG list size is 17, one additional entry to support Fw 3.x format
//

#define MAXIMUM_SGL_DESCRIPTORS 0x12
//
// SG list size is 33 for DAC960PG controllers. Limit to 18, since max
// xfer length is 0xF000
//
#define MAXIMUM_SGL_DESCRIPTORS_PG 0x12

//
// SG list size is 33 for DAC1164PV controllers. Limit to 18, since max
// xfer length is 0xF000
//
#define MAXIMUM_SGL_DESCRIPTORS_PV 0x12

#define MAXIMUM_TRANSFER_LENGTH 0xF000
#define MAXIMUM_EISA_SLOTS  0x10
#define MAXIMUM_CHANNELS 0x05
#define MAXIMUM_TARGETS_PER_CHANNEL 0x10

#define DAC_EISA_ID 0x70009835

#define DAC960_SYSTEM_DRIVE_CHANNEL 0x03
#define DAC960_DEVICE_NOT_ACCESSIBLE 0x00
#define DAC960_DEVICE_ACCESSIBLE     0x01
#define DAC960_DEVICE_BUSY           0x10

typedef struct _MAILBOX_AS_ULONG {
    ULONG   data1;
    ULONG   data2;
    ULONG   data3;
    UCHAR   data4;
} MAILBOX_AS_ULONG, *PMAILBOX_AS_ULONG;

//
// DAC960 mailbox register definition
//

typedef struct _MAILBOX {
    UCHAR OperationCode;              // zC90
    UCHAR CommandIdSubmit;            // zC91
    USHORT BlockCount;                // zC92
    UCHAR BlockNumber[3];             // zC94
    UCHAR DriveNumber;                // zC97
    ULONG PhysicalAddress;            // zC98
    UCHAR ScatterGatherCount;         // zC9C
    UCHAR CommandIdComplete;          // zC9D
    USHORT Status;                    // zC9E
} MAILBOX, *PMAILBOX;

//
// DAC960 mailbox register definition for DAC960 Extended Commands
//

typedef struct _EXTENDED_MAILBOX {
    UCHAR OperationCode;              // zC90
    UCHAR CommandIdSubmit;            // zC91
    USHORT BlockCount;                // zC92
    UCHAR BlockNumber[4];             // zC94
    ULONG PhysicalAddress;            // zC98
    UCHAR DriveNumber;                // zC9C
    UCHAR CommandIdComplete;          // zC9D
    USHORT Status;                    // zC9E
} EXTENDED_MAILBOX, *PEXTENDED_MAILBOX;

//
// DAC960 mailbox register definition for Requests
// Supporting Commands 0x36,0x37,0xB6,0xB7.
// Currently Suported only For Peregrine controller in the driver.
//

typedef struct _PGMAILBOX {
    UCHAR OperationCode;              // Mail Box 0
    UCHAR CommandIdSubmit;            // Mail Box 1
    USHORT BlockCount;                // Mail Box 2-3
    UCHAR BlockNumber[4];             // Mail Box 4-7
    ULONG PhysicalAddress;            // Mail Box 8-11
    UCHAR ScatterGatherCount;         // Mail Box 12
    UCHAR Reserved[11];               // Mail Box 13-23
    UCHAR CommandIdComplete;          // Mail Box 24
    UCHAR Reserved1;                  // Mail Box 25
    USHORT Status;                    // Mail Box 26-27
} PGMAILBOX, *PPGMAILBOX;


//
// DAC960 EISA register definition
//

typedef struct _EISA_REGISTERS {
    ULONG EisaId;                     // zC80
    UCHAR NotUsed1[4];                // zC84
    UCHAR GlobalConfiguration;        // zC88
    UCHAR InterruptEnable;            // zC89
    UCHAR NotUsed2[2];                // zC9A
    UCHAR LocalDoorBellEnable;        // zC8C
    UCHAR LocalDoorBell;              // zC8D
    UCHAR SystemDoorBellEnable;       // zC8E
    UCHAR SystemDoorBell;             // zC8F
    MAILBOX MailBox;                  // zC90
    UCHAR Unused4[33];                // zCA0
    UCHAR BiosAddress;                // zCC1
    UCHAR Unused5;                    // zCC2
    UCHAR InterruptLevel;             // zCC3
} EISA_REGISTERS, *PEISA_REGISTERS;

//
// DAC960 PCI register definition
//

typedef struct _PCI_REGISTERS {
    MAILBOX MailBox;                  // 0x00
    UCHAR NotUsed1[48];               // 0x10
    UCHAR LocalDoorBell;              // 0x40
    UCHAR SystemDoorBell;             // 0x41
    UCHAR NotUsed2[1];                // 0x42
    UCHAR InterruptEnable;            // 0x43
} PCI_REGISTERS, *PPCI_REGISTERS;


//
// Local doorbell definition
//

#define DAC960_LOCAL_DOORBELL_SUBMIT_BUSY   0x01
#define DAC960_LOCAL_DOORBELL_MAILBOX_FREE 0x02

//
// System doorbell definition
//

#define DAC960_SYSTEM_DOORBELL_COMMAND_COMPLETE 0x01
#define DAC960_SYSTEM_DOORBELL_SUBMISSION_COMPLETE 0x02

//
// Command complete status
//

#define DAC960_STATUS_GOOD            0x0000
#define DAC960_STATUS_ERROR           0x0001
#define DAC960_STATUS_NO_DRIVE        0x0002  // system drives
#define DAC960_STATUS_CHECK_CONDITION 0x0002  // pass-through
#define DAC960_STATUS_BUSY            0x0008
#define DAC960_STATUS_SELECT_TIMEOUT  0x000F
#define DAC960_STATUS_DEVICE_TIMEOUT  0x000E
#define DAC960_STATUS_NOT_IMPLEMENTED 0x0104
#define DAC960_STATUS_BOUNDS_ERROR    0x0105
#define DAC960_STATUS_BAD_DATA        0x010C // Fw 3.x

//
// Command codes
//

#define DAC960_COMMAND_READ        0x02     // DAC960 Fw Ver <  3.x
#define DAC960_COMMAND_READ_EXT    0x33     // DAC960 Fw Ver >= 3.x
#define DAC960_COMMAND_WRITE       0x03     // DAC960 Fw Ver <  3.x
#define DAC960_COMMAND_WRITE_EXT   0x34     // DAC960 Fw Ver >= 3.x
#define DAC960_COMMAND_OLDREAD     0x36     // Read for OLD Scatter/gather
#define DAC960_COMMAND_OLDWRITE    0x37     // Write for OLD Scatter/gather
#define DAC960_COMMAND_DIRECT      0x04    
#define DAC960_COMMAND_ENQUIRE     0x05     // DAC960 Fw Ver <  3.x
#define DAC960_COMMAND_ENQUIRE_3X  0x53     // DAC960 Fw Ver >= 3.x
#define DAC960_COMMAND_FLUSH       0x0A
#define DAC960_COMMAND_RESET       0x1A
#define DAC960_COMMAND_ENQUIRE2    0x1C
#define DAC960_COMMAND_SG          0x80
#define DAC960_COMMAND_EXTENDED    0x31     // DAC960 Fw Ver >= 3.x 
#define DAC960_COMMAND_GET_SD_INFO 0x19

//
// Define BIOS enabled bit
//

#define DAC960_BIOS_ENABLED    0x40

//
// Error Status registers and associated bits
//

#define MDAC_DACPD_ERROR_STATUS_REG 0x3F
#define MDAC_DACPG_ERROR_STATUS_REG 0x103F
#define MDAC_DACPV_ERROR_STATUS_REG 0x63
#define MDAC_MSG_PENDING        0x04 // some error message pending
#define MDAC_DRIVESPINMSG_PENDING   0x08 // drive sping message pending
#define MDAC_DIAGERROR_MASK     0xF0 // diagnostic error mask */
#define MDAC_HARD_ERR       0x10 // hard error
#define MDAC_FW_ERR     0x20 // firmware error
#define MDAC_CONF_ERR       0x30 // configration error
#define MDAC_BMIC_ERR       0x40 // BMIC error
#define MDAC_MISM_ERR       0x50 // mismatch between NVRAM and Flash
#define MDAC_MRACE_ERR      0x60 // mirror race error
#define MDAC_MRACE_ON       0x70 // recovering mirror
#define MDAC_DRAM_ERR       0x80 // memory error
#define MDAC_ID_MISM        0x90 // unidentified device found
#define MDAC_GO_AHEAD       0xA0 // go ahead
#define MDAC_CRIT_MRACE     0xB0 // mirror race on critical device
#define MDAC_NEW_CONFIG     0xD0 // new configuration found
#define MDAC_PARITY_ERR     0xF0 // memory parity error

//
// Scatter Gather List
//

typedef struct _SG_DESCRIPTOR {
    ULONG Address;
    ULONG Length;
} SG_DESCRIPTOR, *PSG_DESCRIPTOR;

typedef struct _SGL {
    SG_DESCRIPTOR Descriptor[1];
} SGL, *PSGL;

//
// Enquiry data, DAC960 Fw < 3.x 
//

typedef struct _DAC960_ENQUIRY {
    UCHAR NumberOfDrives;                // 00
    UCHAR Unused1[3];                    // 01
    ULONG SectorSize[8];                 // 04
    USHORT NumberOfFlashes;              // 36
    UCHAR StatusFlags;                   // 38
    UCHAR FreeStateChangeCount;          // 39
    UCHAR MinorFirmwareRevision;         // 40
    UCHAR MajorFirmwareRevision;         // 41
    UCHAR RebuildFlag;                   // 42
    UCHAR NumberOfConcurrentCommands;    // 43
    UCHAR NumberOfOfflineDrives;         // 44
    UCHAR Unused2[3];                    // 45
    UCHAR NumberOfCriticalDrives;        // 48
    UCHAR Unused3[3];                    // 49
    UCHAR NumberOfDeadDisks;             // 52
    UCHAR Unused4;                       // 53
    UCHAR NumberOfRebuildingDisks;       // 54
    UCHAR MiscellaneousFlags;            // 55
} DAC960_ENQUIRY, *PDAC960_ENQUIRY;

//
// Enquiry data, DAC960 Fw >= 3.x
//

typedef struct _DAC960_ENQUIRY_3X {
    UCHAR NumberOfDrives;                // 00
    UCHAR Unused1[3];                    // 01
    ULONG SectorSize[32];                // 04
    USHORT NumberOfFlashes;              // 100
    UCHAR StatusFlags;                   // 102
    UCHAR FreeStateChangeCount;          // 103
    UCHAR MinorFirmwareRevision;         // 104
    UCHAR MajorFirmwareRevision;         // 105
    UCHAR RebuildFlag;                   // 106
    UCHAR NumberOfConcurrentCommands;    // 107
    UCHAR NumberOfOfflineDrives;         // 108
    UCHAR Unused2[3];                    // 109
    UCHAR NumberOfCriticalDrives;        // 112
    UCHAR Unused3[3];                    // 113
    UCHAR NumberOfDeadDisks;             // 116
    UCHAR Unused4;                       // 117
    UCHAR NumberOfRebuildingDisks;       // 118
    UCHAR MiscellaneousFlags;            // 119
} DAC960_ENQUIRY_3X, *PDAC960_ENQUIRY_3X;


//
// Pass-through command
//

typedef struct _DIRECT_CDB {
    UCHAR TargetId:4;                    // 00 (bits 0-3)
    UCHAR Channel:4;                     // 00 (bits 4-7)
    UCHAR CommandControl;                // 01
    USHORT DataTransferLength;           // 02
    ULONG DataBufferAddress;             // 04
    UCHAR CdbLength;                     // 08
    UCHAR RequestSenseLength;            // 09
    UCHAR Cdb[12];                       // 10
    UCHAR RequestSenseData[64];          // 22
    UCHAR Status;                        // 86
    UCHAR Reserved;                      // 87
} DIRECT_CDB, *PDIRECT_CDB;

//
// Direct CDB command control bit definitions
//

#define DAC960_CONTROL_ENABLE_DISCONNECT      0x80
#define DAC960_CONTROL_DISABLE_REQUEST_SENSE  0x40
#define DAC960_CONTROL_DATA_IN                0x01
#define DAC960_CONTROL_DATA_OUT               0x02
#define DAC960_CONTROL_TIMEOUT_10_SECS        0x10
#define DAC960_CONTROL_TIMEOUT_60_SECS        0x20
#define DAC960_CONTROL_TIMEOUT_20_MINUTES     0x30


//
// Enquire 2 structure
//

typedef struct _ENQUIRE2 {
    ULONG Reserved1;
    ULONG EisaId;
    ULONG InterruptMode:1;
    ULONG Unused1:31;
    UCHAR ConfiguredChannels;
    UCHAR ActualChannels;
    UCHAR MaximumTargets;
    UCHAR MaximumTags;
    UCHAR MaximumSystemDrives;
    UCHAR MaximumDrivesPerStripe;
    UCHAR MaximumSpansPerSystemDrive;
    UCHAR Reserved2[5];
    ULONG DramSize;
    UCHAR DramForCache[5];
    UCHAR SizeOfFlash[3];
    ULONG SizeOfNvram;
    ULONG Reserved3[5];
    USHORT PhysicalSectorSize;
    USHORT LogicalSectorSize;
    USHORT MaximumSectorsPerCommand;
    USHORT BlockingFactor;
    USHORT CacheLineSize;
} ENQUIRE2, *PENQUIRE2;

//
// System Drive Info structure
//

typedef struct _SYSTEM_DRIVE_INFO {
    ULONG   Size;
    UCHAR   OperationalState;
    UCHAR   RAIDLevel;
    USHORT  Reserved;
} SYSTEM_DRIVE_INFO, *PSYSTEM_DRIVE_INFO;

typedef struct _SDINFOL {
    SYSTEM_DRIVE_INFO SystemDrive[32];
} SDINFOL, *PSDINFOL;


#define SYSTEM_DRIVE_OFFLINE    0xFF



//
// Device extension
//

typedef struct _DEVICE_EXTENSION {

    //
    // DAC960 register base address - physical
    //

    ULONG PhysicalAddress;

    //
    // DAC960 register base address - virtual
    //

    PUCHAR BaseIoAddress;

    //
    // Command submission mailbox address
    //

    PMAILBOX PmailBox;

    //
    // Mailbox structure space
    //

    MAILBOX MailBox;

    //
    // System doorbell address
    //

    PUCHAR SystemDoorBell;

    //
    // Local doorbell address
    //

    PUCHAR LocalDoorBell;

    //
    // Interrupt Enable/Disable address
    //

    PUCHAR InterruptControl;

    //
    // Command ID for Completed requests
    //

    PUCHAR CommandIdComplete;

    //
    // Status address
    //

    PUCHAR StatusBase;

    //
    // Error Satus Register
    //

    PUCHAR ErrorStatusReg;

    //
    // Noncached extension
    //

    PVOID NoncachedExtension;

    //
    // Pending request queue
    //

    PSCSI_REQUEST_BLOCK SubmissionQueueHead;
    PSCSI_REQUEST_BLOCK SubmissionQueueTail;

    //
    // Maximum number of outstanding requests per adapter
    //

    USHORT MaximumAdapterRequests;

    //
    // Current number of outstanding requests per adapter
    //

    USHORT CurrentAdapterRequests;

    //
    // Last active request index used
    //

    UCHAR CurrentIndex;

    //
    // HBA Slot number.
    //

    UCHAR Slot;

    //
    // Memory Mapped I/O
    //

    ULONG MemoryMapEnabled;

    //
    // Number of SCSI channels. (Used for resetting adapter.)
    //

    ULONG NumberOfChannels;

    //
    // System I/O Bus Number.
    //

    ULONG SystemIoBusNumber;

    //
    // Host Bus Adapter Interface Type.
    //

    INTERFACE_TYPE AdapterInterfaceType;

    //
    // Host Bus Adapter Interrupt Level.
    //

    ULONG BusInterruptLevel;

    //
    // Adapter Interrupt Mode: Level/Latched.
    //

    KINTERRUPT_MODE InterruptMode;

    //
    // BIOS Base Address. 
    //

    PUCHAR BaseBiosAddress;

    //
    // Adapter Type (DAC960 PCI device id 0x0002 - new adapter, else old)
    //

    ULONG AdapterType;

    //
    // Read Opcode for the controller.
    //

    ULONG ReadOpcode;

    //
    // Write Opcode for the controller.
    //

    ULONG WriteOpcode;

    //
    // Maximum Scatter/Gather Elements Supported
    //

    ULONG MaximumSgElements;

    //
    // Maximum Transfer Length Supported.
    //

    ULONG MaximumTransferLength;

    //
    // Active request pointers
    //

    PSCSI_REQUEST_BLOCK ActiveRequests[256];

    //
    // DMC960 POS Registers.
    //

    POS_DATA PosData;

    //
    // Support NonDisk Devices - set based on the value in Registry.
    //

    BOOLEAN SupportNonDiskDevices;

    //
    // Contains List Of Physical Devices that are accessible 
    //

    UCHAR DeviceList[MAXIMUM_CHANNELS][MAXIMUM_TARGETS_PER_CHANNEL];
    

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#ifdef GAM_SUPPORT
#define GAM_DEVICE_PATH_ID      0x04
#define GAM_DEVICE_TARGET_ID    0x06
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac960\dac960p.h ===
/*****************************************************************************
*									     *
*	COPYRIGHT (C) Mylex Corporation 1992-1995			     *
* This software is furnished under a license and may be used and copied      *
* only in accordance with the terms and conditions of such license           *
* and with inclusion of the above copyright notice. This software or nay     *
* other copies thereof may not be provided or otherwise made available to    *
* any other person. No title to and ownership of the software is hereby      *
* transferred. 						                     *
* 								             *
* The information in this software is subject to change without notices      *
* and should not be construed as a commitment by Mylex Corporation           *
*****************************************************************************/

/************************************************************************
 *                                                                      *
 *    Name:DAC960P.H                                                    *
 *                                                                      *
 *    Description:  Definitions for PCI RAID Controller                 *
 *                                                                      *
 *                                                                      *
 *    Environment:    Watcomm 'C' Version 9.5, Watcomm Linker 9.5       *
 *                    AT&T C Compiler                                   *
 *                                                                      *
 *    Operating System:  Netware 3.1x/Netware 4.xx                      *
 *                       Banyan Vines, IBM AIX                          *
 *                       IBM OS/2 2.11                                  *
 *                                                                      *
 *------------------------- Revision History----------------------------*
 *                                                                      *
 *    Date           Author            Change                           *
 *    ----           ------            ------------------------------   *
 *  08/19/96         Subra.Hegde       defines for DAC960PG Controller  *
 ************************************************************************/

#ifndef _DAC960P_H
#define _DAC960P_H

/* 
 * PCI Specific defines for Config Mechanism #2
*/
#define		PCICFGSPACE_ENABLE_REGISTER	0xCF8
#define		PCICFG_ENABLE		0x10
#define		PCICFG_DISABLE		0x00
#define		PCICFG_FORWARD_REGISTER	0xCFA
#define		CFGMECHANISM2_TYPE0	0x0
#define		PCISCAN_START	0xC000

/* 
 * For Config Mechanism#1 support.
 PCICONFIG_ADDRESS:
   Bit 31     : Enable/Disable Config Cycle
   Bits 24-30 : Reserved
   Bits 16-23 : Bus Number
   Bits 11-15 : Device Number
   Bits 8-10  : Function Number
   Bits 2-7   : Register Number
   Bits 0,1   : 0
*/

#define		PCICONFIG_ADDRESS	0xCF8
#define		PCICONFIG_DATA_ADDRESS	0xCFC

#define         PCIMAX_BUS       256	/* Bus  0 - 255 */
#define         PCIMAX_DEVICES   32	/* Devices 0 - 31 */
#define         PCIENABLE_CONFIG_CYCLE 0x80000000 /* Bit 31 = 1 */
#define		DEVICENO_SHIFT   11 /* Device Number is at bits 11-15 */
#define         BUSNO_SHIFT      16 /* Bus Number at bits 16-23 */

/*
 * Offsets in PCI Configuration space.
*/
#define		PCIVENDID_ADDR	0x00	/* Vendor ID */
#define		PCIDEVID_ADDR	0x02	/* Device ID */
#define		PCIBASEIO_ADDR	0x10	/* Base IO Register */
#define		PCIINT_ADDR	0x3C	/* Interrupt */
#define		PCIBASEIO_MASK	0xFF80	/* Mask for Base IO Address */

#define		MAXPCI_SLOTS	16
#define		PCICFGSPACE_LEN	0x100

/*
 * Vendor ID, Device ID, Product ID
*/
#define		HBA_VENDORID	0x1069	/* Vendor ID for Mylex */
#define		HBA_DEVICEID	0x0001	/* Device ID for DAC960P */
#define         HBA_DEVICEID1   0x0002  /* Device ID for DAC960p */
#define		HBA_PRODUCTID	0x00011069 /* Product ID for DAC960P */

#define         MLXPCI_VENDORID  HBA_VENDORID 
#define         MLXPCI_DEVICEID0 HBA_DEVICEID 
#define         MLXPCI_DEVICEID1 HBA_DEVICEID1 
#define         MLXPCI_PRODUCTID HBA_PRODUCTID 

/*
 * Offsets from Base IO Address.
*/
#define		PCI_LDBELL	0x40   /* Local Doorbell register */
#define		PCI_DBELL	0x41   /* System Doorbell int/stat reg */
#define		PCI_DENABLE	0x43   /* System Doorbell enable reg */

/* 
 * Offsets from Base Command Base Address.
*/
#define		PCI_MBXOFFSET	0x00	/* Status(word) for completed command */
#define		PCI_CMDID	0x0D	/* Command Identifier passed */
#define		PCI_STATUS	0x0E	/* Status(word) for completed command */

#define		PCI_IRQCONFIG	0x3c	/* IRQ configuration */
#define		PCI_IRQMASK	0x0f	/* IRQ Mask */

/*
 * Masks for Memory base for Peregrine Controller
*/
#define		DAC960PG_MEMBASE_MASK	0xFFFFE000	/* Mask for Memory address */

/*
 * DAC960PG Device ID 
*/
#define         DAC960PG_DEVICEID  0x0010 /* Device ID for DAC960PG */

/*
 * Offsets from Base Memory Address for DAC960PG.
*/
#define		DAC960PG_LDBELL	0x20   /* Inbound Doorbell Register */
#define		DAC960PG_DBELL	0x2C   /* Outbound Doorbell Register */
#define		DAC960PG_DENABLE 0x34   /* Outbound Interrupt Mask Register */
/*
 * Values to be programmed into DAC960PG_DENABLE register
*/
#define		DAC960PG_INTENABLE 0xFB   /* Enable Interrupt */
#define		DAC960PG_INTDISABLE 0xFF   /* Disable Interrupt */

/* 
 * Offsets from Base Memory address for DAC960PG
*/
#define		DAC960PG_MBXOFFSET 0x1000 /* Command Code - Mail Box 0 */
#define		DAC960PG_CMDID	   0x1018 /* Command Identifier passed */
#define		DAC960PG_STATUS	   0x101A /* Status(word) for completed command */

#define		DAC960PG_MEMLENGTH 0x2000  /* Memory Range */

//
// DAC1164PV controller specific stuff
//

#define MLXPCI_VENDORID_DIGITAL		0x1011	/* Digital Equipment Corporation */
#define MLXPCI_DEVICEID_DIGITAL		0x1065	/* Digital Equipment Corporation */
#define MLXPCI_VENDORID_MYLEX		0x1069	/* Mylex Corporation */
#define MLXPCI_DEVICEID_DAC1164PV	0x0020	/* Device ID for DAC1164PV */

//
// Offsets from Base Memory Address for DAC1164PV.
//

#define		DAC1164PV_LDBELL	0x0060	/* Inbound Doorbell Register */
#define		DAC1164PV_DBELL		0x0061	/* Outbound Doorbell Register */
#define		DAC1164PV_DENABLE	0x0034	/* Outbound Interrupt Mask Register */

//
// Values to be programmed into DAC1164PV_DENABLE register
//

#define		DAC1164PV_INTENABLE	0x00   /* Enable Interrupt */
#define		DAC1164PV_INTDISABLE	0x04   /* Disable Interrupt */

//
// Offsets from Base Memory address for DAC1164PV
//

#define		DAC1164PV_MBXOFFSET	0x0050	/* Command Code - Mail Box 0 */
#define		DAC1164PV_CMDID		0x005D	/* Command Identifier passed */
#define		DAC1164PV_STATUS	0x005E	/* Status(word) for completed command */

#define		DAC1164PV_MEMLENGTH	0x0080  /* Memory Range */
#define		DAC1164PV_MEMBASE_MASK	0xFFFFFFF0	/* Mask for Memory address */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac960\dac960nt.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

        Dac960Nt.c

Abstract:

        This is the device driver for the Mylex 960 family of disk array controllers.

Author:

        Mike Glass  (mglass)

Environment:

        kernel mode only

Revision History:

--*/

#include "miniport.h"
#include "dac960p.h"
#include "Dmc960Nt.h"
#include "Dac960Nt.h"
#include "D960api.h"

//
// Global variable to verify whether DAC960PG/DAC1164PV Controller is seen
// by the Standard Method (NT Calls our FindAdapter Routine) or not.
// note that when there are no DAC960PG/DAC1164PV Controllers in the system,
// we will be unnecessarily scanning the PCI BUS/DEVICE/FUNC.
// New Scanning method is required to recognize DAC960PG Under Windows NT
// 3.51 only.

BOOLEAN forceScanForPGController = TRUE;
BOOLEAN forceScanForPVXController = TRUE;
ULONG   slotNumber;
ULONG   dac960nt_dbg = 1;

//
// Function declarations
//

ULONG
Dac960StringCompare(
    PUCHAR      String1,
    PUCHAR      String2,
    ULONG       Size
)
{
    for ( ; Size; String1++, String2++, Size--)
        if ((*String1) != (*String2)) return (1);

    return (0);
}

//
// Start the controller i.e. do BIOS initialization
//

#define mlx_delay10us()         ScsiPortStallExecution(10)

ULONG
DacDoPciAdapterBiosInitialization(
    IN PDEVICE_EXTENSION HwDeviceExtension
)
{
        ULONG   sequp, fatalflag, chn, tgt, scantime, intcount;
        UCHAR   status;

start_again:
        fatalflag = 0; sequp = 0;

        ScsiPortWriteRegisterUchar(HwDeviceExtension->LocalDoorBell,
                                   DAC960_LOCAL_DOORBELL_MAILBOX_FREE);

rst_flash_loop:
        scantime = 0;

dot_wait:

flash_wait:
        scantime++;

        for(status=100; status; mlx_delay10us(),status--);      // 1 milli second

        status = ScsiPortReadRegisterUchar(HwDeviceExtension->LocalDoorBell);

        if (HwDeviceExtension->AdapterType == DAC1164_PV_ADAPTER)
        {
            if (status & DAC960_LOCAL_DOORBELL_MAILBOX_FREE) goto time_status;
        }
        else if (!(status & DAC960_LOCAL_DOORBELL_MAILBOX_FREE)) goto time_status;

        if ((status=ScsiPortReadRegisterUchar(HwDeviceExtension->ErrorStatusReg)) & MDAC_MSG_PENDING) goto ckfwmsg;

        if (status & MDAC_DRIVESPINMSG_PENDING)
        {
                status = (HwDeviceExtension->AdapterType == DAC1164_PV_ADAPTER)?
                        status & MDAC_DRIVESPINMSG_PENDING :
                        status ^ MDAC_DRIVESPINMSG_PENDING;

                ScsiPortWriteRegisterUchar(HwDeviceExtension->ErrorStatusReg, status);
                if (!sequp) DebugPrint((1, "\nSpinning up drives ... "));
                sequp++;
                goto rst_flash_loop;
        }
        if (sequp)
            goto dot_wait;

        //
        // Up to 120 seconds
        //

        if (scantime < 120000) goto flash_wait;

inst_abrt:
        DebugPrint((1, "\nController not responding-no drives installed!\n"));
        return 1;

time_status:

        //
        // Flush Controller interrupts.
        //

        for (intcount = 0; 1; intcount++)
        {
            if (! (ScsiPortReadRegisterUchar(HwDeviceExtension->SystemDoorBell) &
                    DAC960_SYSTEM_DOORBELL_COMMAND_COMPLETE))
            {
                break;
            }

            Dac960EisaPciAckInterrupt(HwDeviceExtension);
            ScsiPortStallExecution(1000);       // 1 milli second
        }

        if (fatalflag) goto inst_abrt;
        if (sequp) DebugPrint((1, "done\n"));
        return 0;

ckfwmsg:
        if (sequp) DebugPrint((1, "done\n"));
        sequp = 0;
        switch (status & MDAC_DIAGERROR_MASK)
        {
        case 0:
                tgt = ScsiPortReadRegisterUchar((PUCHAR)HwDeviceExtension->PmailBox+8);
                chn = ScsiPortReadRegisterUchar((PUCHAR)HwDeviceExtension->PmailBox+9);
/*              DebugPrint((0, "SCSI device at Channel=%d target=%d not responding!\n",chn,tgt)); */
                fatalflag = 1;
                break;
        case MDAC_PARITY_ERR:
                DebugPrint((0, "Fatal error - memory parity failure!\n"));
                break;
        case MDAC_DRAM_ERR:
                DebugPrint((0, "Fatal error - memory test failed!\n"));
                break;
        case MDAC_BMIC_ERR:
                DebugPrint((0, "Fatal error - command interface test failed!\n"));
                break;
        case MDAC_FW_ERR:
                DebugPrint((0, "firmware checksum error - reload firmware\n"));
                break;
        case MDAC_CONF_ERR:
                DebugPrint((0, "configuration checksum error!\n"));
                break;
        case MDAC_MRACE_ERR:
                DebugPrint((0, "Recovery from mirror race in progress\n"));
                break;
        case MDAC_MISM_ERR:
                DebugPrint((0, "Mismatch between NVRAM & Flash EEPROM configurations!\n"));
                break;
        case MDAC_CRIT_MRACE:
                DebugPrint((0, "cannot recover from mirror race!\nSome logical drives are inconsistent!\n"));
                break;
        case MDAC_MRACE_ON:
                DebugPrint((0, "Recovery from mirror race in progress\n"));
                break;
        case MDAC_NEW_CONFIG:
                DebugPrint((0, "New configuration found, resetting the controller ... "));
                if (HwDeviceExtension->AdapterType != DAC1164_PV_ADAPTER) status = 0;
                ScsiPortWriteRegisterUchar(HwDeviceExtension->ErrorStatusReg,status);
                DebugPrint((0, "done.\n"));
                goto start_again;
        }
        if (HwDeviceExtension->AdapterType != DAC1164_PV_ADAPTER) status = 0;
        ScsiPortWriteRegisterUchar(HwDeviceExtension->ErrorStatusReg,status);
        goto rst_flash_loop;
}

BOOLEAN
Dac960EisaPciSendRequestPolled(
        IN PDEVICE_EXTENSION DeviceExtension,
        IN ULONG TimeOutValue
)

/*++

Routine Description:

        Send Request to DAC960-EISA/PCI Controllers and poll for command 
        completion

Assumptions:
        Controller Interrupts are turned off
        Supports Dac960 Type 5 Commands only
        
Arguments:

        DeviceExtension - Adapter state information.
        TimeoutValue    - TimeOut value (0xFFFFFFFF - Polled Mode)  
        
Return Value:

        TRUE if commands complete successfully.

--*/

{
        ULONG i;
        BOOLEAN completionStatus = TRUE;
        BOOLEAN status = TRUE;

        //
        // Check whether Adapter is ready to accept commands.
        //

        status = DacCheckForAdapterReady(DeviceExtension);

        //
        // If adapter is not ready return
        //

        if (status == FALSE)
        {
            DebugPrint((dac960nt_dbg, "Dac960EisaPciSendRequestPolled: Adapter Not ready.\n"));

            return(FALSE);
        }

        //
        // Issue Request
        //

        switch (DeviceExtension->AdapterType)
        {
            case DAC960_OLD_ADAPTER:
            case DAC960_NEW_ADAPTER:

                if (! DeviceExtension->MemoryMapEnabled)
                {
                    ScsiPortWritePortUchar(&DeviceExtension->PmailBox->OperationCode,
                               DeviceExtension->MailBox.OperationCode);

                    ScsiPortWritePortUlong(&DeviceExtension->PmailBox->PhysicalAddress,
                               DeviceExtension->MailBox.PhysicalAddress);

                    ScsiPortWritePortUchar(DeviceExtension->LocalDoorBell,
                               DAC960_LOCAL_DOORBELL_SUBMIT_BUSY);

                    break;
                }

            case DAC960_PG_ADAPTER:
            case DAC1164_PV_ADAPTER:

                ScsiPortWriteRegisterUchar(&DeviceExtension->PmailBox->OperationCode,
                               DeviceExtension->MailBox.OperationCode);

                ScsiPortWriteRegisterUlong(&DeviceExtension->PmailBox->PhysicalAddress,
                               DeviceExtension->MailBox.PhysicalAddress);

                ScsiPortWriteRegisterUchar(DeviceExtension->LocalDoorBell,
                                           DAC960_LOCAL_DOORBELL_SUBMIT_BUSY);

                break;
        }

        //
        // Poll for completion.
        //

        completionStatus = DacPollForCompletion(DeviceExtension,TimeOutValue);

        Dac960EisaPciAckInterrupt(DeviceExtension);

        return(completionStatus);
}

BOOLEAN
Dac960McaSendRequestPolled(
        IN PDEVICE_EXTENSION DeviceExtension,
        IN ULONG TimeOutValue
)

/*++

Routine Description:

        Send Request to DAC960-MCA Controller and poll for command completion

Assumptions:
        Controller Interrupts are turned off
        Supports Dac960 Type 5 Commands only
        
Arguments:

        DeviceExtension - Adapter state information.
        TimeoutValue    - TimeOut value (0xFFFFFFFF - Polled Mode)  
        
Return Value:

        TRUE if commands complete successfully.

--*/

{
        ULONG i;
        BOOLEAN completionStatus = TRUE;

        //
        // Issue Request
        //

        ScsiPortWriteRegisterUchar(&DeviceExtension->PmailBox->OperationCode,
                           DeviceExtension->MailBox.OperationCode);

        ScsiPortWriteRegisterUlong(&DeviceExtension->PmailBox->PhysicalAddress,
                           DeviceExtension->MailBox.PhysicalAddress);

        ScsiPortWritePortUchar(DeviceExtension->LocalDoorBell,
                           DMC960_SUBMIT_COMMAND);

        //
        // Poll for completion.
        //

        for (i = 0; i < TimeOutValue; i++) {

        if (ScsiPortReadPortUchar(DeviceExtension->SystemDoorBell) & 
                DMC960_INTERRUPT_VALID) {

                //
                // Update Status field
                //

                DeviceExtension->MailBox.Status = 
                 ScsiPortReadRegisterUshort(&DeviceExtension->PmailBox->Status);

                break;

        } else {

                ScsiPortStallExecution(50);
        }
        }

        //
        // Check for timeout.
        //

        if (i == TimeOutValue) {
            DebugPrint((dac960nt_dbg,
                       "DAC960: Request: %x timed out\n", 
                       DeviceExtension->MailBox.OperationCode));
    
            completionStatus = FALSE;
        }

        //
        // Dismiss interrupt and tell host mailbox is free.
        //

        ScsiPortWritePortUchar(DeviceExtension->BaseIoAddress +
                           DMC960_SUBSYSTEM_CONTROL_PORT,
                           (DMC960_DISABLE_INTERRUPT | DMC960_CLEAR_INTERRUPT_ON_READ));

        ScsiPortReadPortUchar(DeviceExtension->SystemDoorBell);

        ScsiPortWritePortUchar(DeviceExtension->LocalDoorBell,
                           DMC960_ACKNOWLEDGE_STATUS);

        ScsiPortWritePortUchar(DeviceExtension->BaseIoAddress +
                           DMC960_SUBSYSTEM_CONTROL_PORT,
                           DMC960_DISABLE_INTERRUPT);

        return (completionStatus);
}

BOOLEAN
Dac960ScanForNonDiskDevices(
        IN PDEVICE_EXTENSION DeviceExtension
)

/*++

Routine Description:

        Issue SCSI_INQUIRY request to all Devices, looking for Non
        Hard Disk devices and construct the NonDisk device table

Arguments:

        DeviceExtension - Adapter state information.
        
Return Value:

        TRUE if commands complete successfully.

--*/

{
        ULONG i;
        PINQUIRYDATA inquiryData;
        PDIRECT_CDB directCdb = (PDIRECT_CDB) DeviceExtension->NoncachedExtension;
        BOOLEAN status;
        UCHAR channel;
        UCHAR target;
        

        //
        // Fill in Direct CDB Table with SCSI_INQUIRY command information
        //
        
        directCdb->CommandControl = (DAC960_CONTROL_ENABLE_DISCONNECT | 
                                 DAC960_CONTROL_TIMEOUT_10_SECS |
                                 DAC960_CONTROL_DATA_IN);

        inquiryData = (PINQUIRYDATA) ((PUCHAR) directCdb + sizeof(DIRECT_CDB));

        directCdb->DataBufferAddress = 
        ScsiPortConvertPhysicalAddressToUlong(
                ScsiPortGetPhysicalAddress(DeviceExtension,
                                           NULL,
                                           ((PUCHAR) inquiryData),
                                           &i));

        directCdb->CdbLength = 6;
        directCdb->RequestSenseLength = SENSE_BUFFER_SIZE;
                
        ((PCDB) directCdb->Cdb)->CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY; 
        ((PCDB) directCdb->Cdb)->CDB6INQUIRY.Reserved1 = 0;
        ((PCDB) directCdb->Cdb)->CDB6INQUIRY.LogicalUnitNumber = 0;
        ((PCDB) directCdb->Cdb)->CDB6INQUIRY.PageCode = 0;
        ((PCDB) directCdb->Cdb)->CDB6INQUIRY.IReserved = 0;
        ((PCDB) directCdb->Cdb)->CDB6INQUIRY.AllocationLength = INQUIRYDATABUFFERSIZE;
        ((PCDB) directCdb->Cdb)->CDB6INQUIRY.Control = 0;

        directCdb->Status = 0;
        directCdb->Reserved = 0;

        //
        // Set up Mail Box registers for DIRECT_CDB command information.
        //

        DeviceExtension->MailBox.OperationCode = DAC960_COMMAND_DIRECT;

        DeviceExtension->MailBox.PhysicalAddress =
        ScsiPortConvertPhysicalAddressToUlong(
                ScsiPortGetPhysicalAddress(DeviceExtension,
                                           NULL,
                                           directCdb,
                                           &i));


        for (channel = 0; channel < MAXIMUM_CHANNELS; channel++)
        {
        for (target = 0; target < MAXIMUM_TARGETS_PER_CHANNEL; target++)
        {
                //
                // Initialize this device state to not present/not accessible
                //

                DeviceExtension->DeviceList[channel][target] = 
                                                DAC960_DEVICE_NOT_ACCESSIBLE;

                if (channel >= DeviceExtension->NumberOfChannels)
                {
                        target = MAXIMUM_TARGETS_PER_CHANNEL;
                        continue;
                }

                //
                // Fill up DCDB Table
                //

                directCdb->TargetId = target;
                directCdb->Channel = channel;

                directCdb->DataTransferLength = INQUIRYDATABUFFERSIZE;

                //
                // Issue Direct CDB command
                //

                if (DeviceExtension->AdapterInterfaceType == MicroChannel)            
                    status = Dac960McaSendRequestPolled(DeviceExtension, 0xFFFFFFFF);
                else
                    status = Dac960EisaPciSendRequestPolled(DeviceExtension, 0xFFFFFFFF);

                if (status) {
                    if (DeviceExtension->MailBox.Status == DAC960_STATUS_GOOD)
                    {
                        if (inquiryData->DeviceType != DIRECT_ACCESS_DEVICE)
                            DeviceExtension->DeviceList[channel][target] = 
                                                      DAC960_DEVICE_ACCESSIBLE;
                    }
                } else {
                    DebugPrint((dac960nt_dbg, "DAC960: ScanForNonDisk Devices failed\n"));

                    return (status);
                }
        }
        }

        return (TRUE);
}

BOOLEAN
GetEisaPciConfiguration(
        IN PDEVICE_EXTENSION DeviceExtension,
        IN PPORT_CONFIGURATION_INFORMATION ConfigInfo
)

/*++

Routine Description:

        Issue ENQUIRY and ENQUIRY 2 commands to DAC960 (EISA/PCI).

Arguments:

        DeviceExtension - Adapter state information.
        ConfigInfo - Port configuration information structure.

Assmues:
        DeviceExtension->MaximumSgElements is set to valid value
        DeviceExtension->MaximumTransferLength is set to valid value.
Return Value:

        TRUE if commands complete successfully.

--*/

{
        ULONG   i;
        ULONG   physicalAddress;
        USHORT  status;
        UCHAR   statusByte;
        UCHAR   dbtemp1, dbtemp2;

        //
        // Maximum number of physical segments is 16.
        //

        ConfigInfo->NumberOfPhysicalBreaks = DeviceExtension->MaximumSgElements - 1;

        //
        // Indicate that this adapter is a busmaster, supports scatter/gather,
        // caches data and can do DMA to/from physical addresses above 16MB.
        //

        ConfigInfo->ScatterGather     = TRUE;
        ConfigInfo->Master            = TRUE;
        ConfigInfo->CachesData        = TRUE;
        ConfigInfo->Dma32BitAddresses = TRUE;
        ConfigInfo->BufferAccessScsiPortControlled = TRUE;

        //
        // Get noncached extension for enquiry command.
        //

        DeviceExtension->NoncachedExtension =
            ScsiPortGetUncachedExtension(DeviceExtension,
                                         ConfigInfo,
                                         256);

        //
        // Get physical address of noncached extension.
        //

        physicalAddress =
            ScsiPortConvertPhysicalAddressToUlong(
                ScsiPortGetPhysicalAddress(DeviceExtension,
                                           NULL,
                                           DeviceExtension->NoncachedExtension,
                                           &i));

        if (DeviceExtension->AdapterType == DAC1164_PV_ADAPTER)
        {
            if (DacDoPciAdapterBiosInitialization(DeviceExtension))
            {
                DebugPrint((0, "DacDoPciAdapterBiosInitialization failed\n"));
                return (FALSE);
            }

            goto issue_enq2_cmd;
        }

        //
        // We sync result interrupt.
        //

        dbtemp1 = 0;
        dbtemp2 = 0;

        switch (DeviceExtension->AdapterType)
        {
            case DAC960_OLD_ADAPTER:
            case DAC960_NEW_ADAPTER:

                if (! DeviceExtension->MemoryMapEnabled)
                {
                    for (i = 0; i < 200; i++)
                    {
                        if (ScsiPortReadPortUchar(DeviceExtension->SystemDoorBell) &
                            DAC960_SYSTEM_DOORBELL_COMMAND_COMPLETE)
                        {
                            dbtemp1++;
                            Dac960EisaPciAckInterrupt(DeviceExtension);
                        }
                        else {
                            ScsiPortStallExecution(5000);
                            dbtemp2++;
                        }
                    }
                    break;
                }

            case DAC960_PG_ADAPTER:
            case DAC1164_PV_ADAPTER:

                for (i = 0; i < 200; i++)
                {
                    if (ScsiPortReadRegisterUchar(DeviceExtension->SystemDoorBell) &
                            DAC960_SYSTEM_DOORBELL_COMMAND_COMPLETE)
                    {
                        dbtemp1++;
                        Dac960EisaPciAckInterrupt(DeviceExtension);
                    }
                    else {
                        ScsiPortStallExecution(5000);
                        dbtemp2++;
                    }
                }
                break;
        }

        DebugPrint((dac960nt_dbg,"GetEisaPciConfiguration: Int-Count : %d\n",dbtemp1));
        DebugPrint((dac960nt_dbg,"GetEisaPciConfiguration: Wait-Count: %d\n",dbtemp2));

        //
        // Check to see if adapter is initialized and ready to accept commands.
        //

        switch (DeviceExtension->AdapterType)
        {
            case DAC960_OLD_ADAPTER:
            case DAC960_NEW_ADAPTER:

                if (! DeviceExtension->MemoryMapEnabled)
                {
                    ScsiPortWritePortUchar(DeviceExtension->LocalDoorBell,
                               DAC960_LOCAL_DOORBELL_MAILBOX_FREE);
                    //
                    // Wait for controller to clear bit.
                    //
            
                    for (i = 0; i < 5000; i++) {
            
                        if (!(ScsiPortReadPortUchar(DeviceExtension->LocalDoorBell) &
                                DAC960_LOCAL_DOORBELL_MAILBOX_FREE)) {
                            break;
                        }
            
                        ScsiPortStallExecution(5000);
                    }
            
                    //
                    // Claim submission semaphore.
                    //
            
                    if (ScsiPortReadPortUchar(DeviceExtension->LocalDoorBell) & DAC960_LOCAL_DOORBELL_SUBMIT_BUSY)
                    {

                        //
                        // Clear any bits set in system doorbell and tell controller
                        // that the mailbox is free.
                        //
                
                        Dac960EisaPciAckInterrupt(DeviceExtension);
                
                        //
                        // Check semaphore again.
                        //
                
                        if (ScsiPortReadPortUchar(DeviceExtension->LocalDoorBell) & DAC960_LOCAL_DOORBELL_SUBMIT_BUSY)
                        {
                                return FALSE;
                        }
                    }

                    break;
                }

            case DAC960_PG_ADAPTER:
            case DAC1164_PV_ADAPTER:
    
                ScsiPortWriteRegisterUchar(DeviceExtension->LocalDoorBell,
                                       DAC960_LOCAL_DOORBELL_MAILBOX_FREE);

                //
                // Wait for controller to clear bit.
                //
        
                for (i = 0; i < 5000; i++) {
        
                    if (!(ScsiPortReadRegisterUchar(DeviceExtension->LocalDoorBell) &
                            DAC960_LOCAL_DOORBELL_MAILBOX_FREE)) {
                        break;
                    }
        
                    ScsiPortStallExecution(5000);
                }
        
                //
                // Claim submission semaphore.
                //

                if (DeviceExtension->AdapterType == DAC1164_PV_ADAPTER)
                {
                    if (!(ScsiPortReadRegisterUchar(DeviceExtension->LocalDoorBell) & DAC960_LOCAL_DOORBELL_SUBMIT_BUSY))
                    {
                        //
                        // Clear any bits set in system doorbell and tell controller
                        // that the mailbox is free.
                        //
                
                        Dac960EisaPciAckInterrupt(DeviceExtension);
                
                        //
                        // Check semaphore again.
                        //
        
                        statusByte = ScsiPortReadRegisterUchar(DeviceExtension->LocalDoorBell);
        
                        if ( !(ScsiPortReadRegisterUchar(DeviceExtension->LocalDoorBell) & DAC960_LOCAL_DOORBELL_SUBMIT_BUSY))
                        {
                            return FALSE;
                        }
                    }
                }
                else
                {
                    if (ScsiPortReadRegisterUchar(DeviceExtension->LocalDoorBell) & DAC960_LOCAL_DOORBELL_SUBMIT_BUSY)
                    {
                        //
                        // Clear any bits set in system doorbell and tell controller
                        // that the mailbox is free.
                        //
                
                        Dac960EisaPciAckInterrupt(DeviceExtension);
                
                        //
                        // Check semaphore again.
                        //
        
                        statusByte = ScsiPortReadRegisterUchar(DeviceExtension->LocalDoorBell);
        
                        if (ScsiPortReadRegisterUchar(DeviceExtension->LocalDoorBell) & DAC960_LOCAL_DOORBELL_SUBMIT_BUSY) {
                                return FALSE;
                        }
                    }
                }
    
                break;

            default:
                break;
        }

issue_enq2_cmd:

        //
        // Set up Mail Box registers with ENQUIRY 2 command information.
        //    

        DeviceExtension->MailBox.OperationCode = DAC960_COMMAND_ENQUIRE2;

        DeviceExtension->MailBox.PhysicalAddress = physicalAddress;

        //
        // Issue ENQUIRY 2 command
        //

        if (Dac960EisaPciSendRequestPolled(DeviceExtension, 1000))
        {
            //
            // Set interrupt mode.
            //

            if (DeviceExtension->MailBox.Status) {

                //
                // Enquire 2 failed so assume Level.
                //

                ConfigInfo->InterruptMode = LevelSensitive;
                
                ConfigInfo->MaximumTransferLength = DeviceExtension->MaximumTransferLength;

            } else {

                //
                // Check enquire 2 data for interrupt mode.
                //

                if (((PENQUIRE2)DeviceExtension->NoncachedExtension)->InterruptMode) {
                        ConfigInfo->InterruptMode = LevelSensitive;
                } else {
                        ConfigInfo->InterruptMode = Latched;
                }

                ConfigInfo->MaximumTransferLength = 512 * \
                        ((PENQUIRE2)DeviceExtension->NoncachedExtension)->MaximumSectorsPerCommand;

            }
        } else {
            //
            // ENQUIRY 2 command timed out, so assume Level.
            //

            ConfigInfo->InterruptMode = LevelSensitive;
            
            ConfigInfo->MaximumTransferLength = DeviceExtension->MaximumTransferLength;

            DebugPrint((dac960nt_dbg, "DAC960: ENQUIRY2 command timed-out\n"));
        }

        if (DeviceExtension->SupportNonDiskDevices)
        {
            //
            // Scan For Non Hard Disk devices
            // 
            
            Dac960ScanForNonDiskDevices(DeviceExtension);

            ConfigInfo->MaximumTransferLength = DeviceExtension->MaximumTransferLength;
        }

        //
        // Set up Mail Box registers with ENQUIRE command information.
        //

        if (DeviceExtension->AdapterType == DAC960_OLD_ADAPTER)
            DeviceExtension->MailBox.OperationCode = DAC960_COMMAND_ENQUIRE;
        else
            DeviceExtension->MailBox.OperationCode = DAC960_COMMAND_ENQUIRE_3X;

        DeviceExtension->MailBox.PhysicalAddress = physicalAddress;

        //
        // Issue ENQUIRE command.
        //

        if (! Dac960EisaPciSendRequestPolled(DeviceExtension, 2000)) {
            DebugPrint((dac960nt_dbg, "DAC960: ENQUIRE command timed-out\n"));
        }
   
        //
        // Ask system to scan target ids 32. System drives will appear
        // at PathID DAC960_SYSTEM_DRIVE_CHANNEL, target ids 0-31.
        //

        ConfigInfo->MaximumNumberOfTargets = 32;

        //
        // Record maximum number of outstanding requests to the adapter.
        //

        if (DeviceExtension->AdapterType == DAC960_OLD_ADAPTER)
        {
            DeviceExtension->MaximumAdapterRequests = ((PDAC960_ENQUIRY)
                DeviceExtension->NoncachedExtension)->NumberOfConcurrentCommands;
        }
        else
        {
            DeviceExtension->MaximumAdapterRequests = ((PDAC960_ENQUIRY_3X)
                DeviceExtension->NoncachedExtension)->NumberOfConcurrentCommands;
        }

        //
        // This shameless hack is necessary because this value is coming up
        // with zero most of time. If I debug it, then it works find, the COD
        // looks great. I have no idea what's going on here, but for now I will
        // just account for this anomoly.
        //

        if (!DeviceExtension->MaximumAdapterRequests) {
            DebugPrint((dac960nt_dbg,
                       "GetEisaPciConfiguration: MaximumAdapterRequests is 0!\n"));
            DeviceExtension->MaximumAdapterRequests = 0x40;
        }

        //
        // Say max commands is 60. This may be necessary to support asynchronous
        // rebuild etc.  
        //

        DeviceExtension->MaximumAdapterRequests -= 4;

        //
        // Indicate that each initiator is at id 254 for each bus.
        //

        for (i = 0; i < ConfigInfo->NumberOfBuses; i++) {
            ConfigInfo->InitiatorBusId[i] = (UCHAR) INITIATOR_BUSID;
        }

        return TRUE;

} // end GetEisaPciConfiguration()

BOOLEAN
GetMcaConfiguration(
        IN PDEVICE_EXTENSION DeviceExtension,
        IN PPORT_CONFIGURATION_INFORMATION ConfigInfo
)

/*++

Routine Description:

        Issue ENQUIRY and ENQUIRY 2 commands to DAC960 (MCA).

Arguments:

        DeviceExtension - Adapter state information.
        ConfigInfo - Port configuration information structure.

Return Value:

        TRUE if commands complete successfully.

--*/

{
        ULONG i;
        ULONG physicalAddress;
        USHORT status;

        //
        // Maximum number of physical segments is 16.
        //

        ConfigInfo->NumberOfPhysicalBreaks = DeviceExtension->MaximumSgElements - 1;
        
        //
        // Indicate that this adapter is a busmaster, supports scatter/gather,
        // caches data and can do DMA to/from physical addresses above 16MB.
        //

        ConfigInfo->ScatterGather     = TRUE;
        ConfigInfo->Master            = TRUE;
        ConfigInfo->CachesData        = TRUE;
        ConfigInfo->Dma32BitAddresses = TRUE;
        ConfigInfo->BufferAccessScsiPortControlled = TRUE;

        //
        // Get noncached extension for enquiry command.
        //

        DeviceExtension->NoncachedExtension =
        ScsiPortGetUncachedExtension(DeviceExtension,
                                         ConfigInfo,
                                         256);

        //
        // Get physical address of noncached extension.
        //

        physicalAddress =
        ScsiPortConvertPhysicalAddressToUlong(
                ScsiPortGetPhysicalAddress(DeviceExtension,
                                           NULL,
                                           DeviceExtension->NoncachedExtension,
                                           &i));
        //
        // Check to see if adapter is initialized and ready to accept commands.
        //

        ScsiPortWriteRegisterUchar(DeviceExtension->BaseBiosAddress + 0x188d, 2);

        ScsiPortWritePortUchar(DeviceExtension->LocalDoorBell, 
                                   DMC960_ACKNOWLEDGE_STATUS);

        //
        // Wait for controller to clear bit.
        //

        for (i = 0; i < 5000; i++) {

        if (!(ScsiPortReadRegisterUchar(DeviceExtension->BaseBiosAddress + 0x188d) & 2)) {
                break;
        }

        ScsiPortStallExecution(5000);
        }

        //
        // Claim submission semaphore.
        //

        if (ScsiPortReadRegisterUchar(&DeviceExtension->PmailBox->OperationCode) != 0) {

        //
        // Clear any bits set in system doorbell.
        //

        ScsiPortWritePortUchar(DeviceExtension->SystemDoorBell, 0);

        //
        // Check for submission semaphore again.
        //

        if (ScsiPortReadRegisterUchar(&DeviceExtension->PmailBox->OperationCode) != 0) {
                DebugPrint((dac960nt_dbg,"Dac960nt: MCA Adapter initialization failed\n"));

                return FALSE;
        }
        }


        //
        // Set up Mail Box registers with ENQUIRY 2 command information.
        //

        DeviceExtension->MailBox.OperationCode = DAC960_COMMAND_ENQUIRE2;

        DeviceExtension->MailBox.PhysicalAddress = physicalAddress;

        //
        // Issue ENQUIRY 2 command
        //

        if (Dac960McaSendRequestPolled(DeviceExtension, 200)) {

        // 
        // Set Interrupt Mode
        //

        if (DeviceExtension->MailBox.Status)
        {
                //
                // Enquire 2 failed so assume Level.
                //

                ConfigInfo->InterruptMode = LevelSensitive;
                ConfigInfo->MaximumTransferLength = MAXIMUM_TRANSFER_LENGTH;

        } else {

                //
                // Check enquire 2 data for interrupt mode.
                //

                if (((PENQUIRE2)DeviceExtension->NoncachedExtension)->InterruptMode) {
                ConfigInfo->InterruptMode = LevelSensitive;
                } else {
                ConfigInfo->InterruptMode = Latched;
                }

                ConfigInfo->MaximumTransferLength = 512 * \
                                ((PENQUIRE2)DeviceExtension->NoncachedExtension)->MaximumSectorsPerCommand;

        }
        }
        else {
        //
        // Enquire 2 timed-out, so assume Level.
        //

        ConfigInfo->InterruptMode = LevelSensitive;
        ConfigInfo->MaximumTransferLength = MAXIMUM_TRANSFER_LENGTH;

        }

        //
        // Enquiry 2 is always returning Latched Mode. Needs to be fixed
        // in Firmware. Till then assume LevelSensitive.
        //

        ConfigInfo->InterruptMode = LevelSensitive;

        if (DeviceExtension->SupportNonDiskDevices)
        {
                //
                // Scan For Non Hard Disk devices
                // 
                
                Dac960ScanForNonDiskDevices(DeviceExtension);

                ConfigInfo->MaximumTransferLength = MAXIMUM_TRANSFER_LENGTH;
        }

        //
        // Set up Mail Box registers with ENQUIRE command information.
        //

        DeviceExtension->MailBox.OperationCode = DAC960_COMMAND_ENQUIRE;

        DeviceExtension->MailBox.PhysicalAddress = physicalAddress;

        //
        // Issue ENQUIRE command.
        // 

        if (! Dac960McaSendRequestPolled(DeviceExtension, 100)) {
            DebugPrint((dac960nt_dbg, "DAC960: Enquire command timed-out\n"));
        }

        //
        // Ask system to scan target ids 32. System drives will appear
        // at PathId DAC960_SYSTEM_DRIVE_CHANNEL target ids 0-31.
        //

        ConfigInfo->MaximumNumberOfTargets = 32;

        //
        // Record maximum number of outstanding requests to the adapter.
        //

        DeviceExtension->MaximumAdapterRequests =
        ((PDAC960_ENQUIRY)DeviceExtension->NoncachedExtension)->NumberOfConcurrentCommands;

        //
        // This shameless hack is necessary because this value is coming up
        // with zero most of time. If I debug it, then it works find, the COD
        // looks great. I have no idea what's going on here, but for now I will
        // just account for this anomoly.
        //

        if (!DeviceExtension->MaximumAdapterRequests) {
            DebugPrint((dac960nt_dbg,
                       "GetMcaConfiguration: MaximumAdapterRequests is 0!\n"));
            DeviceExtension->MaximumAdapterRequests = 0x40;
        }

        //
        // Say max commands is 60. This may be necessary to support asynchronous
        // rebuild etc.  
        //

        DeviceExtension->MaximumAdapterRequests -= 4;

        //
        // Indicate that each initiator is at id 254 for each bus.
        //

        for (i = 0; i < ConfigInfo->NumberOfBuses; i++) {
        ConfigInfo->InitiatorBusId[i] = (UCHAR) INITIATOR_BUSID;
        }

        return TRUE;

} // end GetMcaConfiguration()

CHAR
ToLower(
    IN CHAR c
    )
{
    if((c >= 'A') && (c <= 'Z')) {
        c += ('a' - 'A');
    }
    return c;
}

BOOLEAN
Dac960ParseArgumentString(
        IN PCHAR String,
        IN PCHAR KeyWord
        )

/*++

Routine Description:

        This routine will parse the string for a match on the keyword, then
        calculate the value for the keyword and return it to the caller.

Arguments:

        String - The ASCII string to parse.
        KeyWord - The keyword for the value desired.

Return Values:

        TRUE    if setting not found in Registry OR 
                if setting found in the Registry and the value is set to TRUE.
        FALSE   if setting found in the Registry and the value is set to FALSE.

--*/

{
        PCHAR cptr;
        PCHAR kptr;
        ULONG value;
        ULONG stringLength = 0;
        ULONG keyWordLength = 0;
        ULONG index;


        if (String == (PCHAR) NULL)
                return TRUE;

        //
        // Calculate the string length and lower case all characters.
        //

        cptr = String;
        while (*cptr) {
            cptr++;
            stringLength++;
        }

        //
        // Calculate the keyword length and lower case all characters.
        //
        cptr = KeyWord;
        while (*cptr) {
            cptr++;
            keyWordLength++;
        }

        if (keyWordLength > stringLength) {

            //
            // Can't possibly have a match.
            //
            return TRUE;
        }

        //
        // Now setup and start the compare.
        //
        cptr = String;

ContinueSearch:
        //
        // The input string may start with white space.  Skip it.
        //
        while (*cptr == ' ' || *cptr == '\t') {
            cptr++;
        }

        if (*cptr == '\0') {

            //
            // end of string.
            //
            return TRUE;
        }

        kptr = KeyWord;
        while (ToLower(*cptr++) == ToLower(*kptr++)) {

            if (*(cptr - 1) == '\0') {
    
                    //
                    // end of string
                    //
                    return TRUE;
            }
        }

        if (*(kptr - 1) == '\0') {

            //
            // May have a match backup and check for blank or equals.
            //
    
            cptr--;
            while (*cptr == ' ' || *cptr == '\t') {
                    cptr++;
        }

        //
        // Found a match.  Make sure there is an equals.
        //
        if (*cptr != '=') {

            //
            // Not a match so move to the next semicolon.
            //
            while (*cptr) {
                if (*cptr++ == ';') {
                        goto ContinueSearch;
                }
            }
            return TRUE;
        }

        //
        // Skip the equals sign.
        //
        cptr++;

        //
        // Skip white space.
        //
        while ((*cptr == ' ') || (*cptr == '\t')) {
                cptr++;
        }

        if (*cptr == '\0') {

                //
                // Early end of string, return not found
                //
                return TRUE;
        }

        if (*cptr == ';') {

                //
                // This isn't it either.
                //
                cptr++;
                goto ContinueSearch;
        }

        value = 0;
        if ((*cptr == '0') && (ToLower(*(cptr + 1)) == 'x')) {

                //
                // Value is in Hex.  Skip the "0x"
                //
                cptr += 2;
                for (index = 0; *(cptr + index); index++) {

                if (*(cptr + index) == ' ' ||
                        *(cptr + index) == '\t' ||
                        *(cptr + index) == ';') {
                         break;
                }

                if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) {
                        value = (16 * value) + (*(cptr + index) - '0');
                } else {
                        if ((ToLower(*(cptr + index)) >= 'a') && (ToLower(*(cptr + index)) <= 'f')) {
                        value = (16 * value) + (ToLower(*(cptr + index)) - 'a' + 10);
                        } else {

                        //
                        // Syntax error, return not found.
                        //
                        return TRUE;
                        }
                }
                }
        } else {

                //
                // Value is in Decimal.
                //
                for (index = 0; *(cptr + index); index++) {

                        if (*(cptr + index) == ' ' ||
                                *(cptr + index) == '\t' ||
                                *(cptr + index) == ';') {
                                break;
                        }

                        if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) {
                                value = (10 * value) + (*(cptr + index) - '0');
                        } else {

                                //
                                // Syntax error return not found.
                                //
                                return TRUE;
                        }
                }
        }

        if (value) return TRUE;
        else    return FALSE;
        } else {

        //
        // Not a match check for ';' to continue search.
        //
        while (*cptr) {
                if (*cptr++ == ';') {
                goto ContinueSearch;
                }
        }

        return TRUE;
        }
}   // end Dac960ParseArgumentString()


ULONG
Dac960EisaFindAdapter(
        IN PVOID HwDeviceExtension,
        IN PVOID Context,
        IN PVOID BusInformation,
        IN PCHAR ArgumentString,
        IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
        OUT PBOOLEAN Again
)

/*++

Routine Description:

        This function is called by the OS-specific port driver after
        the necessary storage has been allocated, to gather information
        about the adapter's configuration.

Arguments:

        HwDeviceExtension - HBA miniport driver's adapter data storage
        Context - Not used.
        BusInformation - Not used.
        ArgumentString - Not used.
        ConfigInfo - Data shared between system and driver describing an adapter.
        Again - Indicates that driver wishes to be called again to continue
        search for adapters.

Return Value:

        TRUE if adapter present in system

--*/

{
        PDEVICE_EXTENSION deviceExtension = HwDeviceExtension;
        PEISA_REGISTERS eisaRegisters;
        ULONG        eisaSlotNumber;
        ULONG        eisaId;
        PUCHAR       baseAddress;
        UCHAR        interruptLevel;
        UCHAR        biosAddress;
        BOOLEAN      found=FALSE;


        DebugPrint((dac960nt_dbg, "Dac960EisaFindAdapter\n"));

#ifdef WINNT_50

        //
        // Is this a new controller ?
        //

        if (deviceExtension->BaseIoAddress)
        {
            DebugPrint((dac960nt_dbg, "EisaFindAdapter: devExt 0x%p already Initialized.\n",
                        deviceExtension));

            goto controllerAlreadyInitialized;
        }
#endif

        //
        // Scan EISA bus for DAC960 adapters.
        //

        for (eisaSlotNumber = slotNumber + 1;
            eisaSlotNumber < MAXIMUM_EISA_SLOTS;
            eisaSlotNumber++) {

        //
        // Update the slot count to indicate this slot has been checked.
        //

        DebugPrint((dac960nt_dbg, "Dac960EisaFindAdapter: scanning EISA slot 0x%x\n", eisaSlotNumber));

        slotNumber++;

        //
        // Store physical address for this card.
        //

        deviceExtension->PhysicalAddress = ((0x1000 * eisaSlotNumber) + 0xC80);

        //
        // Get the system address for this card. The card uses I/O space.
        //

        baseAddress = (PUCHAR)
                ScsiPortGetDeviceBase(deviceExtension,
                                      ConfigInfo->AdapterInterfaceType,
                                      ConfigInfo->SystemIoBusNumber,
                                      ScsiPortConvertUlongToPhysicalAddress(0x1000 * eisaSlotNumber),
                                      0x1000,
                                      TRUE);

        eisaRegisters =
                (PEISA_REGISTERS)(baseAddress + 0xC80);
        deviceExtension->BaseIoAddress = (PUCHAR)eisaRegisters;

        //
        // Look at EISA id.
        //

        eisaId = ScsiPortReadPortUlong(&eisaRegisters->EisaId);

        if ((eisaId & 0xF0FFFFFF) == DAC_EISA_ID) {
                deviceExtension->Slot = (UCHAR) eisaSlotNumber;
                found = TRUE;
                break;
        }

        //
        // If an adapter was not found unmap address.
        //

        ScsiPortFreeDeviceBase(deviceExtension, baseAddress);

        } // end for (eisaSlotNumber ...

        //
        // If no more adapters were found then indicate search is complete.
        //

        if (!found) {
            *Again = FALSE;
            return SP_RETURN_NOT_FOUND;
        }

        //
        // Set the address of mailbox and doorbell registers.
        //

        deviceExtension->PmailBox = (PMAILBOX)&eisaRegisters->MailBox.OperationCode;
        deviceExtension->LocalDoorBell = &eisaRegisters->LocalDoorBell;
        deviceExtension->SystemDoorBell = &eisaRegisters->SystemDoorBell;

        //
        // Fill in the access array information.
        //

        (*ConfigInfo->AccessRanges)[0].RangeStart =
                ScsiPortConvertUlongToPhysicalAddress(0x1000 * eisaSlotNumber + 0xC80);
        (*ConfigInfo->AccessRanges)[0].RangeLength = sizeof(EISA_REGISTERS);
        (*ConfigInfo->AccessRanges)[0].RangeInMemory = FALSE;

        //
        // Determine number of SCSI channels supported by this adapter by
        // looking low byte of EISA ID.
        //

        switch (eisaId >> 24) {

        case 0x70:
        ConfigInfo->NumberOfBuses = MAXIMUM_CHANNELS;
        deviceExtension->NumberOfChannels = 5;
        break;

        case 0x75:
        case 0x71:
        case 0x72:
        deviceExtension->NumberOfChannels = 3;
        ConfigInfo->NumberOfBuses = MAXIMUM_CHANNELS;
        break;

        case 0x76:
        case 0x73:
        deviceExtension->NumberOfChannels = 2;
        ConfigInfo->NumberOfBuses = MAXIMUM_CHANNELS;
        break;

        case 0x77:
        case 0x74:
        default:
        deviceExtension->NumberOfChannels = 1;
        ConfigInfo->NumberOfBuses = MAXIMUM_CHANNELS;
        break;
        }

        //
        // Set Max SG Supported, Max Transfer Length Supported.
        //

        deviceExtension->MaximumSgElements = MAXIMUM_SGL_DESCRIPTORS;
        deviceExtension->MaximumTransferLength = MAXIMUM_TRANSFER_LENGTH;

        //
        // Read adapter interrupt level.
        //

        interruptLevel =
        ScsiPortReadPortUchar(&eisaRegisters->InterruptLevel) & 0x60;

        switch (interruptLevel) {

        case 0x00:
                 ConfigInfo->BusInterruptLevel = 15;
         break;

        case 0x20:
                 ConfigInfo->BusInterruptLevel = 11;
         break;

        case 0x40:
                 ConfigInfo->BusInterruptLevel = 12;
         break;

        case 0x60:
                 ConfigInfo->BusInterruptLevel = 14;
         break;
        }

        ConfigInfo->BusInterruptVector = ConfigInfo->BusInterruptLevel;

        //
        // Read BIOS ROM address.
        //

        biosAddress = ScsiPortReadPortUchar(&eisaRegisters->BiosAddress);

        //
        // Check if BIOS enabled.
        //

        if (biosAddress & DAC960_BIOS_ENABLED) {

        ULONG rangeStart;

        switch (biosAddress & 7) {

        case 0:
                rangeStart = 0xC0000;
                break;
        case 1:
                rangeStart = 0xC4000;
                break;
        case 2:
                rangeStart = 0xC8000;
                break;
        case 3:
                rangeStart = 0xCC000;
                break;
        case 4:
                rangeStart = 0xD0000;
                break;
        case 5:
                rangeStart = 0xD4000;
                break;
        case 6:
                rangeStart = 0xD8000;
                break;
        case 7:
                rangeStart = 0xDC000;
                break;
        }

        DebugPrint((dac960nt_dbg, "Dac960EisaFindAdapter: BIOS enabled addr 0x%x, len 0x4000\n", rangeStart));

        //
        // Fill in the access array information.
        //

        (*ConfigInfo->AccessRanges)[1].RangeStart =
                ScsiPortConvertUlongToPhysicalAddress((ULONG_PTR)rangeStart);
        (*ConfigInfo->AccessRanges)[1].RangeLength = 0x4000;
        (*ConfigInfo->AccessRanges)[1].RangeInMemory = TRUE;

        //
        // Set BIOS Base Address in Device Extension.
        //

        deviceExtension->BaseBiosAddress = (PUCHAR)ULongToPtr( rangeStart );
        }

controllerAlreadyInitialized:

        //
        // Disable DAC960 Interupts.
        //

        ScsiPortWritePortUchar(&((PEISA_REGISTERS)deviceExtension->BaseIoAddress)->InterruptEnable, 0);
        ScsiPortWritePortUchar(&((PEISA_REGISTERS)deviceExtension->BaseIoAddress)->SystemDoorBellEnable, 0);

        //
        // Set Adapter Interface Type.
        //

        deviceExtension->AdapterInterfaceType =
                                  ConfigInfo->AdapterInterfaceType;

        //
        // Set Adapter Type
        //

        deviceExtension->AdapterType = DAC960_OLD_ADAPTER; 

        deviceExtension->SupportNonDiskDevices = 
            Dac960ParseArgumentString(ArgumentString, 
                                    "SupportNonDiskDevices"); 
        //
        // Issue ENQUIRY and ENQUIRY 2 commands to get adapter configuration.
        //

        if (!GetEisaPciConfiguration(deviceExtension,
                          ConfigInfo)) {
            DebugPrint((dac960nt_dbg, "GetEisaConfiguration returned Error\n"));

            return SP_INTERNAL_ADAPTER_ERROR;
        }

        //
        // Fill in System Resources used by Adapter, in device extension.
        //

        deviceExtension->SystemIoBusNumber =
                                  ConfigInfo->SystemIoBusNumber;

        deviceExtension->BusInterruptLevel =
                                  ConfigInfo->BusInterruptLevel;

        deviceExtension->InterruptMode = ConfigInfo->InterruptMode;


        //
        // Enable interrupts. For the local doorbell, enable interrupts to host
        // when a command has been submitted and when a completion has been
        // processed. For the system doorbell, enable only an interrupt when a
        // command is completed by the host. Note: I am noticing that when I get
        // a completion interrupt, not only is the bit set that indicates a command
        // is complete, but the bit that indicates that the submission channel is
        // free is also set. If I don't clear both bits, the interrupt won't go
        // away. (MGLASS)
        //

        ScsiPortWritePortUchar(&((PEISA_REGISTERS)deviceExtension->BaseIoAddress)->InterruptEnable, 1);
        ScsiPortWritePortUchar(&((PEISA_REGISTERS)deviceExtension->BaseIoAddress)->SystemDoorBellEnable, 1);

        deviceExtension->ReadOpcode = DAC960_COMMAND_READ;
        deviceExtension->WriteOpcode = DAC960_COMMAND_WRITE;

        DebugPrint((dac960nt_dbg,
                   "DAC960: Active request array address %x\n",
                   deviceExtension->ActiveRequests));

        //
        // Tell system to keep on searching.
        //

        *Again = TRUE;

        return SP_RETURN_FOUND;

} // end Dac960EisaFindAdapter()

ULONG
Dac960PciFindAdapter(
        IN PVOID HwDeviceExtension,
        IN PVOID Context,
        IN PVOID BusInformation,
        IN PCHAR ArgumentString,
        IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
        OUT PBOOLEAN Again
)

/*++

Routine Description:
                                                   
        This function is called by the OS-specific port driver after
        the necessary storage has been allocated, to gather information
        about the adapter's configuration.

Arguments:

        HwDeviceExtension - HBA miniport driver's adapter data storage
        Context - Not used.
        BusInformation - Bus Specific Information.
        ArgumentString - Not used.
        ConfigInfo - Data shared between system and driver describing an adapter.
        Again - Indicates that driver wishes to be called again to continue
        search for adapters.

Return Value:

        TRUE if adapter present in system

--*/

{
        PDEVICE_EXTENSION deviceExtension = HwDeviceExtension;
        PCI_COMMON_CONFIG pciConfig;
        ULONG   rc, i;
        ULONG   Index = 0;
        ULONG   address;
        USHORT  vendorID;
        USHORT  deviceID;
        USHORT  subVendorID;
        USHORT  subSystemID;
        USHORT  commandRegister;
        BOOLEAN disableDac960MemorySpaceAccess = FALSE;

#ifdef WINNT_50

        //
        // Is this a new controller ?
        //

        if (deviceExtension->BaseIoAddress)
        {
            DebugPrint((dac960nt_dbg, "PciFindAdapter: devExt 0x%p already Initialized.\n",
                        deviceExtension));

            goto controllerAlreadyInitialized;
        }
#endif

        //                                 
        // Check for configuration information passed in from system.
        //

        if ((*ConfigInfo->AccessRanges)[0].RangeLength == 0) {

            DebugPrint((dac960nt_dbg,
                       "PciFindAdapter: devExt 0x%p No configuration information\n",
                       deviceExtension));
    
            *Again = FALSE;
            return SP_RETURN_NOT_FOUND;
        }

        //
        // Patch for DAC960 PCU3 - System does not reboot after shutdown.
        //

        for (i = 0; i < ConfigInfo->NumberOfAccessRanges; i++) {
            if ((*ConfigInfo->AccessRanges)[i].RangeInMemory && 
                    (*ConfigInfo->AccessRanges)[i].RangeLength != 0)
            {
                DebugPrint((dac960nt_dbg, "PciFindAdapter: Memory At Index %X\n",i));
                DebugPrint((dac960nt_dbg, "PciFindAdapter: Memory Base %X\n", (*ConfigInfo->AccessRanges)[i].RangeStart));
                DebugPrint((dac960nt_dbg, "PciFindAdapter: Memory Length %X\n", (*ConfigInfo->AccessRanges)[i].RangeLength));

                Index = i;
                deviceExtension->MemoryMapEnabled = 1;

                address = ScsiPortConvertPhysicalAddressToUlong(
                                  (*ConfigInfo->AccessRanges)[i].RangeStart);

                if (address >= 0xFFFC0000) {
                        disableDac960MemorySpaceAccess = TRUE;
                }
                break; // We support only One Memory Address
            }
        }

        //
        // Look at PCI Config Information to determine board type
        //

        if (BusInformation != (PVOID) NULL) {

            //
            // Get Command Register value from PCI Config Space
            //

            commandRegister = ((PPCI_COMMON_CONFIG) BusInformation)->Command;

            //
            // Get VendorID and DeviceID from PCI Config Space
            //

            vendorID = ((PPCI_COMMON_CONFIG) BusInformation)->VendorID;
            deviceID = ((PPCI_COMMON_CONFIG) BusInformation)->DeviceID;

            //
            // Get SubVendorID and SubSystemID from PCI Config Space
            //

            subVendorID = ((PPCI_COMMON_CONFIG) BusInformation)->u.type0.SubVendorID;
            subSystemID = ((PPCI_COMMON_CONFIG) BusInformation)->u.type0.SubSystemID;
        }
        else {

            //
            // Get PCI Config Space information for DAC960 Pci Controller
            //

            rc = ScsiPortGetBusData(deviceExtension,
                                    PCIConfiguration,
                                    ConfigInfo->SystemIoBusNumber,
                                    (ULONG) ConfigInfo->SlotNumber,
                                    (PVOID) &pciConfig,
                                    sizeof(PCI_COMMON_CONFIG));

            if (rc == 0 || rc == 2) {
                DebugPrint((dac960nt_dbg, "PciFindAdapter: ScsiPortGetBusData Error: 0x%x\n", rc));

                *Again = TRUE;
                return SP_RETURN_NOT_FOUND;
            }
            else {

                //
                // Get Command Register value from PCI config space
                //

                commandRegister = pciConfig.Command;

                //
                // Get VendorID and DeviceID from PCI Config Space
                //
    
                vendorID = pciConfig.VendorID;
                deviceID = pciConfig.DeviceID;

                //
                // Get SubVendorID and SubSystemID from PCI Config Space
                //
    
                subVendorID = pciConfig.u.type0.SubVendorID;
                subSystemID = pciConfig.u.type0.SubSystemID;
            }
        }

        DebugPrint((dac960nt_dbg, "PciFindAdapter: vendorID 0x%x, deviceID 0x%x, subVendorID 0x%x, subSystemID 0x%x\n",
                        vendorID, deviceID, subVendorID, subSystemID));

        DebugPrint((dac960nt_dbg, "PciFindAdapter: devExt 0x%p commandRegister 0x%x\n",
                        deviceExtension, commandRegister));

        if ((vendorID == MLXPCI_VENDORID_DIGITAL) &&
            ((deviceID != MLXPCI_DEVICEID_DIGITAL) ||
            (subVendorID != MLXPCI_VENDORID_MYLEX) ||
            (subSystemID != MLXPCI_DEVICEID_DAC1164PV)))
        {
            DebugPrint((dac960nt_dbg, "PciFindAdapter: Not our device.\n"));

            *Again = TRUE;
            return SP_RETURN_NOT_FOUND;
        }

        if (disableDac960MemorySpaceAccess &&
            ((deviceID == MLXPCI_DEVICEID0) || (deviceID == MLXPCI_DEVICEID1)))
        {

           deviceExtension->MemoryMapEnabled = 0; // disabled

            //
            // Check if Memory Space Access Bit is enabled in Command Register
            //
    
            if (commandRegister & PCI_ENABLE_MEMORY_SPACE) {
                //
                // Disable Memory Space Access for DAC960 Pci Controller
                //

                commandRegister &= ~PCI_ENABLE_MEMORY_SPACE;

                //
                // Set Command Register value in DAC960 Pci Config Space
                //

                rc = ScsiPortSetBusDataByOffset(deviceExtension,
                                                PCIConfiguration,
                                                ConfigInfo->SystemIoBusNumber,
                                                (ULONG) ConfigInfo->SlotNumber,
                                                (PVOID) &commandRegister,
                                                0x04,    // Command Register Offset
                                                2);      // 2 Bytes

                if (rc != 2) {
                    DebugPrint((dac960nt_dbg, "PciFindAdapter: ScsiPortSetBusDataByOffset Error: 0x%x\n",rc));

                    *Again = TRUE;
                    return SP_RETURN_NOT_FOUND;
                }
            }
        }

        //                                 
        // Check for configuration information passed in from system.
        //

        if ((*ConfigInfo->AccessRanges)[0].RangeLength == 0) {

            DebugPrint((dac960nt_dbg,
                       "PciFindAdapter: devExt 0x%p No configuration information\n",
                       deviceExtension));
    
            *Again = FALSE;
            return SP_RETURN_NOT_FOUND;
        }



        DebugPrint((dac960nt_dbg, "PciFindAdapter: AccessRange0.RangeStart %x\n",
                        (*ConfigInfo->AccessRanges)[0].RangeStart));

        DebugPrint((dac960nt_dbg,"PciFindAdapter: AccessRange0.RangeLength %x\n",
                        (*ConfigInfo->AccessRanges)[0].RangeLength));
                
        //
        // Get the system address for this card. The card uses I/O space.
        //

        if (deviceExtension->MemoryMapEnabled) {

            // KLUDGE
            //
            // When booting under the loader, these cards may attempt to use more than
            // 4MB of memory.  The NTLDR can only map up to 4MB of memory
            // and its a bad idea to even take that much.
            //
            // So we're going to limit them to 8K of memory under the loader
            //
            PCHAR   tmp_pchar = ArgumentString;

            if (ArgumentString != NULL) {
                ULONG   len = 0;

                // Figure out the length of the argument string
                for (tmp_pchar = ArgumentString; tmp_pchar[0] != '\0'; tmp_pchar++) {
                    len++;
                }

                // There are  8 characters in ntldr=1;
                // notice that i'm not couniting the NULL's in both strings
                // this is very prone to breaking if the ntldr changes this string
                //
                // Per peterwie's email, I will also ignore the trailing ; when doing
                // the comparison
                //
                if (len >= 7) {
                    //
                    // Only care to compare the first 7 characters
                    //
                    if (Dac960StringCompare(ArgumentString, "ntldr=1", 7) == 0) {
                        DebugPrint((dac960nt_dbg,
                            "PciFindAdapter: Applying DAC960 NTLDR kludge\n"));

                        //
                        // Drivers works if we only allocate 8K bytes
                        //
                        (*ConfigInfo->AccessRanges)[Index].RangeLength = 0x2000;

                        DebugPrint((dac960nt_dbg,
                                    "PciFindAdapter: AccessRange0.RangeLength %x\n",
                                        (*ConfigInfo->AccessRanges)[0].RangeLength));

                    } // under ntldr
                }

            } // Argument String is not NULL


            deviceExtension->PhysicalAddress =
                ScsiPortConvertPhysicalAddressToUlong((*ConfigInfo->AccessRanges)[Index].RangeStart);

            deviceExtension->BaseIoAddress =
                ScsiPortGetDeviceBase(deviceExtension,
                                      ConfigInfo->AdapterInterfaceType,
                                      ConfigInfo->SystemIoBusNumber,
                                      (*ConfigInfo->AccessRanges)[Index].RangeStart,
                                      (*ConfigInfo->AccessRanges)[Index].RangeLength,
                                      FALSE);

            DebugPrint((dac960nt_dbg, "PciFindAdapter: Memory Mapped Base %x\n",deviceExtension->BaseIoAddress));
    
            //
            // Fill in the access array information.
            //

            if (Index)
            {
                (*ConfigInfo->AccessRanges)[0].RangeStart =
                                (*ConfigInfo->AccessRanges)[Index].RangeStart,
                        
                (*ConfigInfo->AccessRanges)[0].RangeLength = 
                                (*ConfigInfo->AccessRanges)[Index].RangeLength,
        
                (*ConfigInfo->AccessRanges)[0].RangeInMemory = TRUE;
        
                ConfigInfo->NumberOfAccessRanges = 1;
            }
        }
        else {
            deviceExtension->PhysicalAddress =
                ScsiPortConvertPhysicalAddressToUlong((*ConfigInfo->AccessRanges)[0].RangeStart);

            deviceExtension->BaseIoAddress =
                ScsiPortGetDeviceBase(deviceExtension,
                                      ConfigInfo->AdapterInterfaceType,
                                      ConfigInfo->SystemIoBusNumber,
                                      (*ConfigInfo->AccessRanges)[0].RangeStart,
                                      sizeof(PCI_REGISTERS),
                                      TRUE);
        }

        //
        // If BaseIoAddress is zero, don't ask for the same controller,
        // return controller not found. This was the case when During memory
        // dump after system panic, we enter this routine even though
        // this controller is not present in the system.
        // Looks like it is DISDUMP Driver(Disk Driver + SCSI PORT) Bug.
        //

        if (deviceExtension->BaseIoAddress == 0) {
            DebugPrint((dac960nt_dbg, "PciFindAdapter: BaseIoAddress NULL\n"));

            *Again = FALSE;
            return SP_RETURN_NOT_FOUND;
        }
        
        //
        // Setup Adapter specific stuff.
        //

        if ((vendorID == MLXPCI_VENDORID_MYLEX) && (deviceID == MLXPCI_DEVICEID0))
        {
            deviceExtension->AdapterType = DAC960_OLD_ADAPTER;
            
            deviceExtension->PmailBox = (PMAILBOX)deviceExtension->BaseIoAddress;
            deviceExtension->LocalDoorBell = deviceExtension->BaseIoAddress + PCI_LDBELL;
            deviceExtension->SystemDoorBell = deviceExtension->BaseIoAddress + PCI_DBELL;
            deviceExtension->InterruptControl = deviceExtension->BaseIoAddress + PCI_DENABLE;
            deviceExtension->CommandIdComplete = deviceExtension->BaseIoAddress + PCI_CMDID;
            deviceExtension->StatusBase = deviceExtension->BaseIoAddress + PCI_STATUS;
            deviceExtension->ErrorStatusReg = deviceExtension->BaseIoAddress + MDAC_DACPD_ERROR_STATUS_REG;
            
            deviceExtension->MaximumSgElements = MAXIMUM_SGL_DESCRIPTORS;
            
            deviceExtension->ReadOpcode = DAC960_COMMAND_READ;
            deviceExtension->WriteOpcode = DAC960_COMMAND_WRITE;
            
            DebugPrint((dac960nt_dbg, "PciFindAdapter: Adapter Type set to 0x%x\n",
                            deviceExtension->AdapterType));
        }
        else if ((vendorID == MLXPCI_VENDORID_MYLEX) && (deviceID == MLXPCI_DEVICEID1))
        {
            deviceExtension->AdapterType = DAC960_NEW_ADAPTER;
            
            deviceExtension->PmailBox = (PMAILBOX)deviceExtension->BaseIoAddress;
            deviceExtension->LocalDoorBell = deviceExtension->BaseIoAddress + PCI_LDBELL;
            deviceExtension->SystemDoorBell = deviceExtension->BaseIoAddress + PCI_DBELL;
            deviceExtension->InterruptControl = deviceExtension->BaseIoAddress + PCI_DENABLE;
            deviceExtension->CommandIdComplete = deviceExtension->BaseIoAddress + PCI_CMDID;
            deviceExtension->StatusBase = deviceExtension->BaseIoAddress + PCI_STATUS;
            deviceExtension->ErrorStatusReg = deviceExtension->BaseIoAddress + MDAC_DACPD_ERROR_STATUS_REG;

            deviceExtension->MaximumSgElements = MAXIMUM_SGL_DESCRIPTORS;
            
            deviceExtension->ReadOpcode = DAC960_COMMAND_READ_EXT;
            deviceExtension->WriteOpcode = DAC960_COMMAND_WRITE_EXT;
            
            DebugPrint((dac960nt_dbg, "PciFindAdapter: Adapter Type set to 0x%x\n",
                            deviceExtension->AdapterType));
        }
        else if ((vendorID == MLXPCI_VENDORID_MYLEX) && (deviceID == DAC960PG_DEVICEID))
        {
            deviceExtension->AdapterType = DAC960_PG_ADAPTER;
            
            deviceExtension->PmailBox = (PMAILBOX)(deviceExtension->BaseIoAddress+DAC960PG_MBXOFFSET);
            deviceExtension->LocalDoorBell = deviceExtension->BaseIoAddress + DAC960PG_LDBELL;
            deviceExtension->SystemDoorBell = deviceExtension->BaseIoAddress + DAC960PG_DBELL;
            deviceExtension->InterruptControl = deviceExtension->BaseIoAddress + DAC960PG_DENABLE;
            deviceExtension->CommandIdComplete = deviceExtension->BaseIoAddress + DAC960PG_CMDID;
            deviceExtension->StatusBase = deviceExtension->BaseIoAddress + DAC960PG_STATUS;
            deviceExtension->ErrorStatusReg = deviceExtension->BaseIoAddress + MDAC_DACPG_ERROR_STATUS_REG;

            deviceExtension->MaximumSgElements = MAXIMUM_SGL_DESCRIPTORS_PG;
            
            deviceExtension->ReadOpcode = DAC960_COMMAND_OLDREAD;
            deviceExtension->WriteOpcode = DAC960_COMMAND_OLDWRITE;
            
            forceScanForPGController = FALSE;
            
            DebugPrint((dac960nt_dbg, "PciFindAdapter: Adapter Type set to 0x%x\n",
                            deviceExtension->AdapterType));
        }
        else if (vendorID == MLXPCI_VENDORID_DIGITAL)
        {
            //
            // DAC1164PV controller.
            //

            deviceExtension->AdapterType = DAC1164_PV_ADAPTER;
            
            deviceExtension->PmailBox = (PMAILBOX)(deviceExtension->BaseIoAddress+DAC1164PV_MBXOFFSET);
            deviceExtension->LocalDoorBell = deviceExtension->BaseIoAddress + DAC1164PV_LDBELL;
            deviceExtension->SystemDoorBell = deviceExtension->BaseIoAddress + DAC1164PV_DBELL;
            deviceExtension->InterruptControl = deviceExtension->BaseIoAddress + DAC1164PV_DENABLE;
            deviceExtension->CommandIdComplete = deviceExtension->BaseIoAddress + DAC1164PV_CMDID;
            deviceExtension->StatusBase = deviceExtension->BaseIoAddress + DAC1164PV_STATUS;
            deviceExtension->ErrorStatusReg = deviceExtension->BaseIoAddress + MDAC_DACPV_ERROR_STATUS_REG;
            
            deviceExtension->MaximumSgElements = MAXIMUM_SGL_DESCRIPTORS_PV;
            
            deviceExtension->ReadOpcode = DAC960_COMMAND_OLDREAD;
            deviceExtension->WriteOpcode = DAC960_COMMAND_OLDWRITE;

            DebugPrint((dac960nt_dbg, "PciFindAdapter: Adapter Type set to 0x%x\n",
                            deviceExtension->AdapterType));

            forceScanForPVXController = FALSE;
            
        }
        else {
            DebugPrint((dac960nt_dbg, "PciFindAdapter: Unknown deviceID 0x%x\n", deviceID));

            *Again = TRUE;
            return SP_RETURN_NOT_FOUND;
        }

        DebugPrint((dac960nt_dbg,"PciFindAdapter: Mail Box %x\n",deviceExtension->PmailBox));
        DebugPrint((dac960nt_dbg,"PciFindAdapter: Local DoorBell %x\n",deviceExtension->LocalDoorBell));
        DebugPrint((dac960nt_dbg,"PciFindAdapter: System DoorBell %x\n",deviceExtension->SystemDoorBell));
        DebugPrint((dac960nt_dbg,"PciFindAdapter: Interrupt Control %x\n",deviceExtension->InterruptControl));
        DebugPrint((dac960nt_dbg,"PciFindAdapter: CommandID Base %x\n",deviceExtension->CommandIdComplete));
        DebugPrint((dac960nt_dbg,"PciFindAdapter: Status Base %x\n",deviceExtension->StatusBase));
        DebugPrint((dac960nt_dbg,"PciFindAdapter: ErrorStatusReg %x\n",deviceExtension->ErrorStatusReg));

        //
        // Set number of channels.
        //

        deviceExtension->NumberOfChannels = 3;
        ConfigInfo->NumberOfBuses = MAXIMUM_CHANNELS;

        //
        // Set Max SG Supported, Max Transfer Length Supported.
        //

        deviceExtension->MaximumTransferLength = MAXIMUM_TRANSFER_LENGTH;

controllerAlreadyInitialized:

        //
        // Disable Interrupts from DAC960P board.
        //

        Dac960PciDisableInterrupt(deviceExtension);

        //
        // Set Adapter Interface Type.
        //

        deviceExtension->AdapterInterfaceType =
                                  ConfigInfo->AdapterInterfaceType;

        deviceExtension->SupportNonDiskDevices = 
            Dac960ParseArgumentString(ArgumentString, 
                                    "SupportNonDiskDevices");
        //
        // Issue ENQUIRY and ENQUIRY 2 commands to get adapter configuration.
        //

        if (!GetEisaPciConfiguration(deviceExtension,
                                      ConfigInfo)) {
            DebugPrint((dac960nt_dbg, "PciFindAdapter: GetEisaPciConfiguratin returned error.\n"));

            return SP_INTERNAL_ADAPTER_ERROR;
        }

        //
        // Fill in System Resources used by Adapter, in device extension.
        //

        deviceExtension->SystemIoBusNumber =
                                  ConfigInfo->SystemIoBusNumber;

        deviceExtension->BusInterruptLevel =
                                  ConfigInfo->BusInterruptLevel;

        //
        // DAC960P FW 2.0 returns Interrupt Mode as 'Latched'.
        // Assume 'Level Sensitive' till it is fixed in Firmware.
        //

        ConfigInfo->InterruptMode = LevelSensitive;

        deviceExtension->InterruptMode = ConfigInfo->InterruptMode;


        deviceExtension->BaseBiosAddress = 0;

        deviceExtension->Slot = (UCHAR) ConfigInfo->SlotNumber;

        //
        // Enable completion interrupts.
        //

        Dac960PciEnableInterrupt(deviceExtension);

        //
        // Tell system to keep on searching.
        //

        *Again = TRUE;

        DebugPrint((dac960nt_dbg, "PciFindAdapter: devExt 0x%p, active req array addr 0x%x\n",
                     deviceExtension, deviceExtension->ActiveRequests));

        return SP_RETURN_FOUND;

} // end Dac960PciFindAdapter()

ULONG
Dac960McaFindAdapter(
        IN PVOID HwDeviceExtension,
        IN PVOID Context,
        IN PVOID BusInformation,
        IN PCHAR ArgumentString,
        IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
        OUT PBOOLEAN Again
)

/*++

Routine Description:

        This function is called by the OS-specific port driver after
        the necessary storage has been allocated, to gather information
        about the adapter's configuration.

Arguments:

        HwDeviceExtension - HBA miniport driver's adapter data storage
        Context - Not used.
        BusInformation - Not used.
        ArgumentString - Not used.
        ConfigInfo - Data shared between system and driver describing an adapter.
        Again - Indicates that driver wishes to be called again to continue
        search for adapters.

Return Value:

        TRUE if adapter present in system

--*/

{
        PDEVICE_EXTENSION deviceExtension = HwDeviceExtension;
        ULONG       baseBiosAddress;
        ULONG       baseIoAddress;
        ULONG       mcaSlotNumber;
        LONG        i;
        BOOLEAN     found=FALSE;

#ifdef WINNT_50

        //
        // Is this a new controller ?
        //

        if (deviceExtension->BaseIoAddress)
        {
            DebugPrint((dac960nt_dbg, "McaFindAdapter: devExt 0x%p already Initialized.\n",
                        deviceExtension));

            goto controllerAlreadyInitialized;
        }
#endif

        //
        // Scan MCA bus for DMC960 adapters.
        //

        for (mcaSlotNumber = slotNumber;
         mcaSlotNumber < MAXIMUM_MCA_SLOTS;
         mcaSlotNumber++) {

         //
         // Update the slot count to indicate this slot has been checked.
         //

         slotNumber++;

         //
         //  Get POS data for this slot.
         //

         i = ScsiPortGetBusData (deviceExtension,
                                 Pos,
                                 0,
                                 mcaSlotNumber,
                                 &deviceExtension->PosData,
                                 sizeof( POS_DATA )
                                 );

         //
         // If less than the requested amount of data is returned, then
         // insure that this adapter is ignored.
         //
                
         if ( i < (sizeof( POS_DATA ))) {
                 continue;
         }

         if (deviceExtension->PosData.AdapterId == MAGPIE_ADAPTER_ID ||
                 deviceExtension->PosData.AdapterId == HUMMINGBIRD_ADAPTER_ID ||
                 deviceExtension->PosData.AdapterId == PASSPLAY_ADAPTER_ID) {

                 deviceExtension->Slot = (UCHAR) mcaSlotNumber;
                 found = TRUE;
                 break;
         }      
        }

        if (!found) {
            *Again = FALSE;
            return SP_RETURN_NOT_FOUND;
        }

        //
        // Set adapter base I/O address.
        //

        i =  (deviceExtension->PosData.OptionData4 >> 3) & 0x07;

        baseIoAddress = 0x1c00 + ((i * 2) << 12); 

        //
        // Set adapter base Bios address.
        //

        i = (deviceExtension->PosData.OptionData1 >> 2) & 0x0f;

        baseBiosAddress =  0xc0000 + ((i * 2) << 12);


        //
        // Fill in the access array information.
        //

        (*ConfigInfo->AccessRanges)[0].RangeStart =
                ScsiPortConvertUlongToPhysicalAddress(baseIoAddress);
        (*ConfigInfo->AccessRanges)[0].RangeLength = sizeof(MCA_REGISTERS);
        (*ConfigInfo->AccessRanges)[0].RangeInMemory = FALSE;

        (*ConfigInfo->AccessRanges)[1].RangeStart =
        ScsiPortConvertUlongToPhysicalAddress(baseBiosAddress);
        (*ConfigInfo->AccessRanges)[1].RangeLength = 0x2000;
        (*ConfigInfo->AccessRanges)[1].RangeInMemory = TRUE;


        deviceExtension->BaseBiosAddress = 
                          ScsiPortGetDeviceBase(deviceExtension,
                                                ConfigInfo->AdapterInterfaceType,
                                                ConfigInfo->SystemIoBusNumber,
                                                ScsiPortConvertUlongToPhysicalAddress(baseBiosAddress),
                                                0x2000,
                                                FALSE);

        deviceExtension->PhysicalAddress = baseIoAddress;

        deviceExtension->BaseIoAddress = 
                        ScsiPortGetDeviceBase(deviceExtension,
                                          ConfigInfo->AdapterInterfaceType,
                                          ConfigInfo->SystemIoBusNumber,
                                          ScsiPortConvertUlongToPhysicalAddress(baseIoAddress),
                                          sizeof(MCA_REGISTERS),
                                          TRUE);

        //
        // Set up register pointers.
        //

        deviceExtension->PmailBox = (PMAILBOX)(deviceExtension->BaseBiosAddress + 
                                                   0x1890);

        //
        // DMC960 Attention Port is equivalent to EISA/PCI Local Door Bell register.
        //

        deviceExtension->LocalDoorBell = deviceExtension->BaseIoAddress + 
                                         DMC960_ATTENTION_PORT;

        //
        // DMC960 Command Status Busy Port is equivalent to EISA/PCI System DoorBell
        // register.
        //

        deviceExtension->SystemDoorBell = deviceExtension->BaseIoAddress + 
                                          DMC960_COMMAND_STATUS_BUSY_PORT;

        //
        // Set configuration information
        //

        switch(((deviceExtension->PosData.OptionData1 >> 6) & 0x03)) {

        case 0x00:
        ConfigInfo->BusInterruptLevel =  14;
        break;

        case 0x01:
        ConfigInfo->BusInterruptLevel =  12;
        break;

        case 0x02:
        ConfigInfo->BusInterruptLevel =  11;
        break;

        case 0x03:
        ConfigInfo->BusInterruptLevel =  10;
        break;

        }

        ConfigInfo->NumberOfBuses = MAXIMUM_CHANNELS;

        //
        // Set Max SG Supported, Max Transfer Length Supported.
        //

        deviceExtension->MaximumSgElements = MAXIMUM_SGL_DESCRIPTORS;
        deviceExtension->MaximumTransferLength = MAXIMUM_TRANSFER_LENGTH;

controllerAlreadyInitialized:

        //
        // Disable DMC960 Interrupts.
        //

        ScsiPortWritePortUchar(deviceExtension->BaseIoAddress + 
                                   DMC960_SUBSYSTEM_CONTROL_PORT,
                                   DMC960_DISABLE_INTERRUPT);
        //
        // Set Adapter Interface Type.
        //
 
        deviceExtension->AdapterInterfaceType = ConfigInfo->AdapterInterfaceType;
        deviceExtension->NumberOfChannels = 2;

        //
        // Set Adapter Type
        //

        deviceExtension->AdapterType = DAC960_OLD_ADAPTER; 

        deviceExtension->SupportNonDiskDevices = 
                        Dac960ParseArgumentString(ArgumentString, 
                                                "SupportNonDiskDevices");

        //
        // Issue ENQUIRY and ENQUIRY2 commands to get adapter configuration.
        //

        if(!GetMcaConfiguration(deviceExtension,
                         ConfigInfo)) {
            return SP_INTERNAL_ADAPTER_ERROR; 
        }

        //
        // Fill in System Resources used by Adapter, in device extension.
        //

        deviceExtension->SystemIoBusNumber = ConfigInfo->SystemIoBusNumber;

        deviceExtension->BusInterruptLevel = ConfigInfo->BusInterruptLevel;

        deviceExtension->InterruptMode = ConfigInfo->InterruptMode;


        //
        // Enable DMC960 Interrupts.
        //

        ScsiPortWritePortUchar(deviceExtension->BaseIoAddress + 
                                   DMC960_SUBSYSTEM_CONTROL_PORT,
                                   DMC960_ENABLE_INTERRUPT);

        deviceExtension->ReadOpcode = DAC960_COMMAND_READ;
        deviceExtension->WriteOpcode = DAC960_COMMAND_WRITE;

        *Again = TRUE;

        return SP_RETURN_FOUND;

} // end Dac960McaFindAdapter()

BOOLEAN
Dac960Initialize(
        IN PVOID HwDeviceExtension
        )

/*++

Routine Description:

        Inititialize adapter.

Arguments:

        HwDeviceExtension - HBA miniport driver's adapter data storage
                          - Not used.

Return Value:

        TRUE - if initialization successful.
        FALSE - if initialization unsuccessful.

--*/

{
        return(TRUE);

} // end Dac960Initialize()

BOOLEAN
BuildScatterGather(
        IN PDEVICE_EXTENSION DeviceExtension,
        IN PSCSI_REQUEST_BLOCK Srb,
        OUT PULONG PhysicalAddress,
        OUT PULONG DescriptorCount
)

/*++

Routine Description:

        Build scatter/gather list.

Arguments:

        DeviceExtension - Adapter state
        SRB - System request

Return Value:

        TRUE if scatter/gather command should be used.
        FALSE if no scatter/gather is necessary.

--*/

{
        PSG_DESCRIPTOR sgList;
        ULONG descriptorNumber;
        ULONG bytesLeft;
        PUCHAR dataPointer;
        ULONG length;

        //
        // Get data pointer, byte count and index to scatter/gather list.
        //

        sgList = (PSG_DESCRIPTOR)Srb->SrbExtension;
        descriptorNumber = 0;
        bytesLeft = Srb->DataTransferLength;
        dataPointer = Srb->DataBuffer;

        //
        // Build the scatter/gather list.
        //

        while (bytesLeft) {

        //
        // Get physical address and length of contiguous
        // physical buffer.
        //

        sgList[descriptorNumber].Address =
                ScsiPortConvertPhysicalAddressToUlong(
                ScsiPortGetPhysicalAddress(DeviceExtension,
                                           Srb,
                                           dataPointer,
                                           &length));

        //
        // If length of physical memory is more
        // than bytes left in transfer, use bytes
        // left as final length.
        //

        if  (length > bytesLeft) {
                length = bytesLeft;
        }

        //
        // Complete SG descriptor.
        //

        sgList[descriptorNumber].Length = length;

        //
        // Update pointers and counters.
        //

        bytesLeft -= length;
        dataPointer += length;
        descriptorNumber++;
        }

        //
        // Return descriptior count.
        //

        *DescriptorCount = descriptorNumber;

        //
        // Check if number of scatter/gather descriptors is greater than 1.
        //

        if (descriptorNumber > 1) {

        //
        // Calculate physical address of the scatter/gather list.
        //

        *PhysicalAddress =
                ScsiPortConvertPhysicalAddressToUlong(
                ScsiPortGetPhysicalAddress(DeviceExtension,
                                           NULL,
                                           sgList,
                                           &length));

        return TRUE;

        } else {

        //
        // Calculate physical address of the data buffer.
        //

        *PhysicalAddress = sgList[0].Address;
        return FALSE;
        }

} // BuildScatterGather()

BOOLEAN
BuildScatterGatherExtended(
        IN PDEVICE_EXTENSION DeviceExtension,
        IN PSCSI_REQUEST_BLOCK Srb,
        OUT PULONG PhysicalAddress,
        OUT PULONG DescriptorCount
)

/*++

Routine Description:

        Build scatter/gather list using extended format supported in Fw 3.x.

Arguments:

        DeviceExtension - Adapter state
        SRB - System request

Return Value:

        TRUE if scatter/gather command should be used.
        FALSE if no scatter/gather is necessary.

--*/

{
        PSG_DESCRIPTOR sgList;
        ULONG descriptorNumber;
        ULONG bytesLeft;
        PUCHAR dataPointer;
        ULONG length;
        ULONG i;
        PSG_DESCRIPTOR sgElem;

        //
        // Get data pointer, byte count and index to scatter/gather list.
        //

        sgList = (PSG_DESCRIPTOR)Srb->SrbExtension;
        descriptorNumber = 1;
        bytesLeft = Srb->DataTransferLength;
        dataPointer = Srb->DataBuffer;

        //
        // Build the scatter/gather list.
        //

        while (bytesLeft) {

        //
        // Get physical address and length of contiguous
        // physical buffer.
        //

        sgList[descriptorNumber].Address =
                ScsiPortConvertPhysicalAddressToUlong(
                ScsiPortGetPhysicalAddress(DeviceExtension,
                                           Srb,
                                           dataPointer,
                                           &length));

        //
        // If length of physical memory is more
        // than bytes left in transfer, use bytes
        // left as final length.
        //

        if  (length > bytesLeft) {
                length = bytesLeft;
        }

        //
        // Complete SG descriptor.
        //

        sgList[descriptorNumber].Length = length;

        //
        // Update pointers and counters.
        //

        bytesLeft -= length;
        dataPointer += length;
        descriptorNumber++;
        }

        //
        // Return descriptior count.
        //

        *DescriptorCount = --descriptorNumber;

        //
        // Check if number of scatter/gather descriptors is greater than 1.
        //

        if (descriptorNumber > 1) {

        //
        // Calculate physical address of the scatter/gather list.
        //

        *PhysicalAddress =
                ScsiPortConvertPhysicalAddressToUlong(
                ScsiPortGetPhysicalAddress(DeviceExtension,
                                           NULL,
                                           sgList,
                                           &length));

        //
        // Store count of data blocks in SG list 0th element.
        //

        sgList[0].Address = (USHORT)
                   (((PCDB)Srb->Cdb)->CDB10.TransferBlocksLsb |
                   (((PCDB)Srb->Cdb)->CDB10.TransferBlocksMsb << 8));

        sgList[0].Length = 0;

        return TRUE;

        } else {

        //
        // Calculate physical address of the data buffer.
        //

        *PhysicalAddress = sgList[1].Address;
        return FALSE;
        }

} // BuildScatterGatherExtended()

BOOLEAN
IsAdapterReady(
        IN PDEVICE_EXTENSION DeviceExtension
)

/*++

Routine Description:

        Determine if Adapter is ready to accept new request.

Arguments:

        DeviceExtension - Adapter state.

Return Value:

        TRUE if adapter can accept new request.
        FALSE if host adapter is busy

--*/
{
        ULONG i;

        //
        // Claim submission semaphore.
        //

        if(DeviceExtension->AdapterInterfaceType == MicroChannel) {

            for (i=100; i; --i) {
    
                if (ScsiPortReadRegisterUchar(&DeviceExtension->PmailBox->OperationCode)) {
                    ScsiPortStallExecution(5);
                } else {
                    break;
                }
            }
        }
        else {
            switch (DeviceExtension->AdapterType)
            {
                case DAC960_OLD_ADAPTER:
                case DAC960_NEW_ADAPTER:

                    if (! DeviceExtension->MemoryMapEnabled)
                    {
                        if (ScsiPortReadPortUchar(DeviceExtension->LocalDoorBell) & DAC960_LOCAL_DOORBELL_SUBMIT_BUSY)
                        {
                            if (DeviceExtension->CurrentAdapterRequests)
                                return FALSE;
        
                            i = 100;
                            do {
                                ScsiPortStallExecution(5);
                                if (!(ScsiPortReadPortUchar(DeviceExtension->LocalDoorBell) & DAC960_LOCAL_DOORBELL_SUBMIT_BUSY))
                                    return TRUE;
                            } while (--i);
    
                            break;
                        }
                        else
                            return TRUE;
                    }

                case DAC960_PG_ADAPTER:

                    if (ScsiPortReadRegisterUchar(DeviceExtension->LocalDoorBell) & DAC960_LOCAL_DOORBELL_SUBMIT_BUSY)
                    {
                        if (DeviceExtension->CurrentAdapterRequests)
                            return FALSE;

                        i = 100;
                        do {
                            ScsiPortStallExecution(5);
                            if (!(ScsiPortReadRegisterUchar(DeviceExtension->LocalDoorBell) & DAC960_LOCAL_DOORBELL_SUBMIT_BUSY))
                                return TRUE;
                        } while (--i);

                        break;
                    }
                    else
                        return TRUE;

                case DAC1164_PV_ADAPTER:

                    if (!(ScsiPortReadRegisterUchar(DeviceExtension->LocalDoorBell) & DAC960_LOCAL_DOORBELL_SUBMIT_BUSY))
                    {
                        if (DeviceExtension->CurrentAdapterRequests)
                            return FALSE;

                        i = 100;
                        do {
                            ScsiPortStallExecution(5);
                            if (ScsiPortReadRegisterUchar(DeviceExtension->LocalDoorBell) & DAC960_LOCAL_DOORBELL_SUBMIT_BUSY)
                                return TRUE;
                        } while (--i);

                        break;
                    }
                    else
                        return TRUE;
            }
        }

        // Check for timeout.

        if (!i) {
            DebugPrint((dac960nt_dbg,"IsAdapterReady: Timeout waiting for submission channel on de  0x%p\n",
                        DeviceExtension));

            return FALSE;
        }

        return TRUE;
}

VOID
SendRequest(
        IN PDEVICE_EXTENSION DeviceExtension
)

/*++

Routine Description:

        submit request to DAC960. 

Arguments:

        DeviceExtension - Adapter state.

Return Value:

        None.

--*/

{

        PMAILBOX mailBox = (PMAILBOX) &DeviceExtension->MailBox;
        PMAILBOX_AS_ULONG mbdata = (PMAILBOX_AS_ULONG) &DeviceExtension->MailBox;
        PMAILBOX_AS_ULONG mbptr = (PMAILBOX_AS_ULONG) DeviceExtension->PmailBox;

        if(DeviceExtension->AdapterInterfaceType == MicroChannel) {

            //
            // Write scatter/gather descriptor count to controller.
            //
    
            ScsiPortWriteRegisterUchar(&DeviceExtension->PmailBox->ScatterGatherCount,
                                       mailBox->ScatterGatherCount);
            //
            // Write physical address to controller.
            //
    
            ScsiPortWriteRegisterUlong(&DeviceExtension->PmailBox->PhysicalAddress,
                               mailBox->PhysicalAddress);
    
            //
            // Write starting block number to controller.
            //
    
            ScsiPortWriteRegisterUchar(&DeviceExtension->PmailBox->BlockNumber[0],
                                       mailBox->BlockNumber[0]);
    
            ScsiPortWriteRegisterUchar(&DeviceExtension->PmailBox->BlockNumber[1],
                                       mailBox->BlockNumber[1]);
    
            ScsiPortWriteRegisterUchar(&DeviceExtension->PmailBox->BlockNumber[2],
                                       mailBox->BlockNumber[2]);
    
            //
            // Write block count to controller (bits 0-13)
            // and msb block number (bits 14-15).
            //
    
            ScsiPortWriteRegisterUshort(&DeviceExtension->PmailBox->BlockCount,
                                            mailBox->BlockCount);
    
            //
            // Write command to controller.
            //
    
            ScsiPortWriteRegisterUchar(&DeviceExtension->PmailBox->OperationCode,
                                       mailBox->OperationCode);
    
            //
            // Write request id to controller.
            //
    
            ScsiPortWriteRegisterUchar(&DeviceExtension->PmailBox->CommandIdSubmit,
                                       mailBox->CommandIdSubmit),
    
            //
            // Write drive number to controller.
            //
    
            ScsiPortWriteRegisterUchar(&DeviceExtension->PmailBox->DriveNumber,
                                       mailBox->DriveNumber);
    
            //
            // Ring host submission doorbell.
            //
    
            ScsiPortWritePortUchar(DeviceExtension->LocalDoorBell,
                                       DMC960_SUBMIT_COMMAND);

            return;
        }

        switch (DeviceExtension->AdapterType)
        {
            case DAC960_OLD_ADAPTER:
            case DAC960_NEW_ADAPTER:

                if (!  DeviceExtension->MemoryMapEnabled)
                {
                    ScsiPortWritePortUlong(&mbptr->data1, mbdata->data1);
                    ScsiPortWritePortUlong(&mbptr->data2, mbdata->data2);
                    ScsiPortWritePortUlong(&mbptr->data3, mbdata->data3);
                    ScsiPortWritePortUchar(&mbptr->data4, mbdata->data4);
            
#if defined(_M_ALPHA)
                    ScsiPortReadPortUchar(DeviceExtension->LocalDoorBell);
#endif
            
                    //
                    // Ring host submission doorbell.
                    //
            
                    ScsiPortWritePortUchar(DeviceExtension->LocalDoorBell,
                                               DAC960_LOCAL_DOORBELL_SUBMIT_BUSY);

                    return;
                }

            case DAC960_PG_ADAPTER:
            case DAC1164_PV_ADAPTER:

                ScsiPortWriteRegisterUlong(&mbptr->data1, mbdata->data1);
                ScsiPortWriteRegisterUlong(&mbptr->data2, mbdata->data2);
                ScsiPortWriteRegisterUlong(&mbptr->data3, mbdata->data3);
                ScsiPortWriteRegisterUchar(&mbptr->data4, mbdata->data4);

#if defined(_M_ALPHA)
                ScsiPortReadRegisterUchar(DeviceExtension->LocalDoorBell);
#endif
                //
                // Ring host submission doorbell.
                //
        
                ScsiPortWriteRegisterUchar(DeviceExtension->LocalDoorBell,
                                           DAC960_LOCAL_DOORBELL_SUBMIT_BUSY);

                return;
        }

} // end SendRequest()


BOOLEAN
SubmitSystemDriveInfoRequest(
        IN PDEVICE_EXTENSION DeviceExtension,
        IN PSCSI_REQUEST_BLOCK Srb
)

/*++

Routine Description:

        Build and submit System Drive Info request to DAC960. 

Arguments:

        DeviceExtension - Adapter state.
        SRB - System request.

Return Value:

        TRUE if command was started
        FALSE if host adapter is busy

--*/
{
        ULONG physicalAddress;
        UCHAR busyCurrentIndex;
        ULONG i;

        //
        // Determine if adapter can accept new request.
        //

        if(!IsAdapterReady(DeviceExtension))
                return FALSE;

        //
        // Check that next slot is vacant.
        //

        if (DeviceExtension->ActiveRequests[DeviceExtension->CurrentIndex]) {

                //
                // Collision occurred.
                //

                busyCurrentIndex = DeviceExtension->CurrentIndex++;

                do {
                        if (! DeviceExtension->ActiveRequests[DeviceExtension->CurrentIndex]) {
                                break;
                        }
                } while (++DeviceExtension->CurrentIndex != busyCurrentIndex) ;

                if (DeviceExtension->CurrentIndex == busyCurrentIndex) {

                        //
                        // We should never encounter this condition.
                        //

                        DebugPrint((dac960nt_dbg,
                                       "DAC960: SubmitSystemDriveInfoRequest-Collision in active request array\n"));
                        return FALSE;
                }
        }

        //
        // Initialize NonCachedExtension buffer
        //

        for (i=0; i<256; i++)
                ((PUCHAR)DeviceExtension->NoncachedExtension)[i] = 0xFF;

        
        physicalAddress = ScsiPortConvertPhysicalAddressToUlong(
                                                ScsiPortGetPhysicalAddress(DeviceExtension,
                                                                                                   NULL,
                                                                                                   DeviceExtension->NoncachedExtension,
                                                                                                   &i)); 

        if (i < 256)  {
                DebugPrint((dac960nt_dbg, "Dac960SubmitSystemDriveInfoRequest: NonCachedExtension not mapped, length = %d\n",
                                i));

                return FALSE;
        }

        //
        // Write physical address in Mailbox.
        //

        DeviceExtension->MailBox.PhysicalAddress = physicalAddress;

        //
        // Write command to controller.
        //

        DeviceExtension->MailBox.OperationCode = DAC960_COMMAND_GET_SD_INFO;

        //
        // Write request id to controller.
        //

        DeviceExtension->MailBox.CommandIdSubmit = DeviceExtension->CurrentIndex;

        //
        // Start writing mailbox to controller.
        //

        SendRequest(DeviceExtension);

        return TRUE;

} // SubmitSystemDriveInfoRequest()


BOOLEAN
SubmitRequest(
        IN PDEVICE_EXTENSION DeviceExtension,
        IN PSCSI_REQUEST_BLOCK Srb
)

/*++

Routine Description:

        Build and submit request to DAC960. 

Arguments:

        DeviceExtension - Adapter state.
        SRB - System request.

Return Value:

        TRUE if command was started
        FALSE if host adapter is busy

--*/

{
        ULONG descriptorNumber;
        ULONG physicalAddress;
        UCHAR command;
        UCHAR busyCurrentIndex;
        UCHAR TDriveNumber;

        //
        // Determine if adapter can accept new request.
        //

        if(!IsAdapterReady(DeviceExtension))
            return FALSE;

        //
        // Check that next slot is vacant.
        //

        if (DeviceExtension->ActiveRequests[DeviceExtension->CurrentIndex]) {

        //
        // Collision occurred.
        //

        busyCurrentIndex = DeviceExtension->CurrentIndex++;

        do {
                if (! DeviceExtension->ActiveRequests[DeviceExtension->CurrentIndex]) {
                 break;
                }
        } while (++DeviceExtension->CurrentIndex != busyCurrentIndex) ;

        if (DeviceExtension->CurrentIndex == busyCurrentIndex) {

                //
                // We should never encounter this condition.
                //

                DebugPrint((dac960nt_dbg,
                               "DAC960: SubmitRequest-Collision in active request array\n"));
                return FALSE;
        }
        }

        //
        // Determine command.
        //

        if (Srb->SrbFlags & SRB_FLAGS_DATA_IN) {

        command = (UCHAR)DeviceExtension->ReadOpcode;

        } else if (Srb->SrbFlags & SRB_FLAGS_DATA_OUT) {

        command = (UCHAR)DeviceExtension->WriteOpcode;

        } else if (Srb->Function == SRB_FUNCTION_SHUTDOWN) {

        command = DAC960_COMMAND_FLUSH;
        goto commonSubmit;

        } else {

        //
        // Log this as illegal request.
        //

        ScsiPortLogError(DeviceExtension,
                         NULL,
                         0,
                         0,
                         0,
                         SRB_STATUS_INVALID_REQUEST,
                         1 << 8);

        return FALSE;
        }

        if (DeviceExtension->AdapterType == DAC960_NEW_ADAPTER) {

        //
        // Build scatter/gather list if memory is not physically contiguous.
        //

        if (BuildScatterGatherExtended(DeviceExtension,
                                           Srb,
                                           &physicalAddress,
                                           &descriptorNumber)) {

                //
                // OR in scatter/gather bit.
                //

                command |= DAC960_COMMAND_SG;

                //
                // Write scatter/gather descriptor count in Mailbox.
                //

                ((PEXTENDED_MAILBOX) &DeviceExtension->MailBox)->BlockCount = 
                                (USHORT) descriptorNumber;
        }
        else {
                //
                // Write block count to controller
                //

                ((PEXTENDED_MAILBOX) &DeviceExtension->MailBox)->BlockCount = 
                 (USHORT) (((PCDB)Srb->Cdb)->CDB10.TransferBlocksLsb |
                           (((PCDB)Srb->Cdb)->CDB10.TransferBlocksMsb << 8));
        }

        //
        // Write physical address in Mailbox.
        //

        ((PEXTENDED_MAILBOX) &DeviceExtension->MailBox)->PhysicalAddress = 
                                                         physicalAddress;

        //
        // Write starting block number in Mailbox.
        //

        ((PEXTENDED_MAILBOX) &DeviceExtension->MailBox)->BlockNumber[0] = 
                                        ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3;

        ((PEXTENDED_MAILBOX) &DeviceExtension->MailBox)->BlockNumber[1] =
                                        ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2;

        ((PEXTENDED_MAILBOX) &DeviceExtension->MailBox)->BlockNumber[2] =
                                        ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1;

        ((PEXTENDED_MAILBOX) &DeviceExtension->MailBox)->BlockNumber[3] =
                                        ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0;

        //
        // Write drive number to controller.
        //

        ((PEXTENDED_MAILBOX) &DeviceExtension->MailBox)->DriveNumber = (UCHAR)
                                                                                                                                Srb->TargetId;
        }
        else if ((DeviceExtension->AdapterType == DAC960_PG_ADAPTER) ||
                (DeviceExtension->AdapterType == DAC1164_PV_ADAPTER)) {

                //
                // Build scatter/gather list if memory is not physically contiguous.
                //

                if (BuildScatterGather(DeviceExtension,
                                   Srb,
                                   &physicalAddress,
                                   &descriptorNumber)) {

                        //
                        // OR in scatter/gather bit.
                        //

                        command |= DAC960_COMMAND_SG;

                        //
                        // Write scatter/gather descriptor count in Mailbox.
                        //

                        ((PPGMAILBOX)&DeviceExtension->MailBox)->ScatterGatherCount =
                                   (UCHAR)descriptorNumber;
                }

                //
                // Write physical address in Mailbox.
                //
        
                ((PPGMAILBOX)&DeviceExtension->MailBox)->PhysicalAddress = physicalAddress;
        
                //
                // Write starting block number in Mailbox.
                //
                
                ((PPGMAILBOX)&DeviceExtension->MailBox)->BlockNumber[0] =
                                         ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3;
        
                ((PPGMAILBOX)&DeviceExtension->MailBox)->BlockNumber[1] =
                                         ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2;
        
                ((PPGMAILBOX)&DeviceExtension->MailBox)->BlockNumber[2] =
                                         ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1;
        
                ((PPGMAILBOX)&DeviceExtension->MailBox)->BlockNumber[3] =
                                         ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0;
        
        
                //
                // Write block count to controller (bits 0-7)
                // and msb block number (bits 8-10).
                //
        
                TDriveNumber = (((PCDB)Srb->Cdb)->CDB10.TransferBlocksMsb & 0x07) |
                                (Srb->TargetId << 3);
                                        
        
                ((PPGMAILBOX)&DeviceExtension->MailBox)->BlockCount = 
                                (USHORT)(((PCDB)Srb->Cdb)->CDB10.TransferBlocksLsb |
                                         (TDriveNumber << 8 ));
        
                goto commonSubmit;
        }
        else if ( (DeviceExtension->AdapterType == DAC960_OLD_ADAPTER) ){
                  

        //
        // Build scatter/gather list if memory is not physically contiguous.
        //

        if (BuildScatterGather(DeviceExtension,
                                   Srb,
                                   &physicalAddress,
                                   &descriptorNumber)) {

                //
                // OR in scatter/gather bit.
                //

                command |= DAC960_COMMAND_SG;

                //
                // Write scatter/gather descriptor count in Mailbox.
                //

                DeviceExtension->MailBox.ScatterGatherCount = 
                                   (UCHAR)descriptorNumber;
        }

        //
        // Write physical address in Mailbox.
        //

        DeviceExtension->MailBox.PhysicalAddress = physicalAddress;

        //
        // Write starting block number in Mailbox.
        //

        DeviceExtension->MailBox.BlockNumber[0] = 
                                   ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3;

        DeviceExtension->MailBox.BlockNumber[1] =
                                   ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2;

        DeviceExtension->MailBox.BlockNumber[2] =
                                   ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1;

        //
        // Write block count to controller (bits 0-13)
        // and msb block number (bits 14-15).
        //

        DeviceExtension->MailBox.BlockCount = (USHORT)
                                (((PCDB)Srb->Cdb)->CDB10.TransferBlocksLsb |
                                ((((PCDB)Srb->Cdb)->CDB10.TransferBlocksMsb & 0x3F) << 8) |
                                ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 << 14);

        //
        // Write drive number to controller.
        //

        DeviceExtension->MailBox.DriveNumber = (UCHAR) Srb->TargetId;
        }

commonSubmit:

        //
        // Write command to controller.
        //

        DeviceExtension->MailBox.OperationCode = command;

        //
        // Write request id to controller.
        //

        DeviceExtension->MailBox.CommandIdSubmit = 
                           DeviceExtension->CurrentIndex;

        //
        // Start writing mailbox to controller.
        //

        SendRequest(DeviceExtension);

        return TRUE;

} // SubmitRequest()

BOOLEAN
MarkNonDiskDeviceBusy(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN UCHAR ChannelId,
    IN UCHAR TargetId
)
/*++

Routine Description:

        if this not disk device is not busy, Mark it's state to busy.

Arguments:

        DeviceExtension - Adapter state.
        SRB - System request.

Return Value:

        TRUE if device state marked busy
        FALSE if device state is already busy

--*/
{
        if ((DeviceExtension->DeviceList[ChannelId][TargetId] & DAC960_DEVICE_BUSY) == DAC960_DEVICE_BUSY)
        {
            DebugPrint((dac960nt_dbg, "device at ch 0x%x tgt 0x%x is busy, state 0x%x\n",
                            ChannelId, TargetId,
                            DeviceExtension->DeviceList[ChannelId][TargetId]));

            return (FALSE);
        }


        DeviceExtension->DeviceList[ChannelId][TargetId] |= DAC960_DEVICE_BUSY;

        DebugPrint((dac960nt_dbg, "device at ch 0x%x tgt 0x%x state set to 0x%x\n",
                        ChannelId, TargetId,
                        DeviceExtension->DeviceList[ChannelId][TargetId]));
        return (TRUE);
}

VOID
SendCdbDirect(
        IN PDEVICE_EXTENSION DeviceExtension
)

/*++

Routine Description:

        Send CDB directly to device - DAC960.

Arguments:

        DeviceExtension - Adapter state.

Return Value:

        None.

--*/
{
        PMAILBOX mailBox = &DeviceExtension->MailBox;
        PMAILBOX_AS_ULONG mbdata = (PMAILBOX_AS_ULONG) &DeviceExtension->MailBox;
        PMAILBOX_AS_ULONG mbptr = (PMAILBOX_AS_ULONG) DeviceExtension->PmailBox;

        if(DeviceExtension->AdapterInterfaceType == MicroChannel) {

            //
            // Write Scatter/Gather Count to controller.
            // For Fw Ver < 3.x, scatter/gather count goes to register C
            // For Fw Ver >= 3.x, scattre/gather count goes to register 2
            //
    
            if (DeviceExtension->AdapterType == DAC960_NEW_ADAPTER) {
                    ScsiPortWriteRegisterUshort(&DeviceExtension->PmailBox->BlockCount,
                                            mailBox->BlockCount);
            }
            else {
                    ScsiPortWriteRegisterUchar(&DeviceExtension->PmailBox->ScatterGatherCount,
                                               mailBox->ScatterGatherCount);
            }
    
            //
            // Write physical address to controller.
            //
    
            ScsiPortWriteRegisterUlong(&DeviceExtension->PmailBox->PhysicalAddress,
                                       mailBox->PhysicalAddress);
    
            //
            // Write command to controller.
            //
    
            ScsiPortWriteRegisterUchar(&DeviceExtension->PmailBox->OperationCode,
                                       mailBox->OperationCode);
    
            //
            // Write request id to controller.
            //
    
            ScsiPortWriteRegisterUchar(&DeviceExtension->PmailBox->CommandIdSubmit,
                                       mailBox->CommandIdSubmit);
    
            //
            // Ring host submission doorbell.
            //
    
            ScsiPortWritePortUchar(DeviceExtension->LocalDoorBell,
                                       DMC960_SUBMIT_COMMAND);

            return;
        }

        switch (DeviceExtension->AdapterType)
        {
            case DAC960_NEW_ADAPTER:
            case DAC960_OLD_ADAPTER:

                if (! DeviceExtension->MemoryMapEnabled)
                {
                    ScsiPortWritePortUlong(&mbptr->data1, mbdata->data1);
                    ScsiPortWritePortUlong(&mbptr->data2, mbdata->data2);
                    ScsiPortWritePortUlong(&mbptr->data3, mbdata->data3);
                    ScsiPortWritePortUchar(&mbptr->data4, mbdata->data4);

#if defined(_M_ALPHA)
                    ScsiPortReadPortUchar(DeviceExtension->LocalDoorBell);
#endif
                    //
                    // Ring host submission doorbell.
                    //
    
                    ScsiPortWritePortUchar(DeviceExtension->LocalDoorBell,
                               DAC960_LOCAL_DOORBELL_SUBMIT_BUSY);
                    return;
                }

            case DAC960_PG_ADAPTER:
            case DAC1164_PV_ADAPTER:

                ScsiPortWriteRegisterUlong(&mbptr->data1, mbdata->data1);
                ScsiPortWriteRegisterUlong(&mbptr->data2, mbdata->data2);
                ScsiPortWriteRegisterUlong(&mbptr->data3, mbdata->data3);
                ScsiPortWriteRegisterUchar(&mbptr->data4, mbdata->data4);

#if defined(_M_ALPHA)
                ScsiPortReadRegisterUchar(DeviceExtension->LocalDoorBell);
#endif
               //
               // Ring host submission doorbell.
               //

               ScsiPortWriteRegisterUchar(DeviceExtension->LocalDoorBell,
                               DAC960_LOCAL_DOORBELL_SUBMIT_BUSY);
        }

} // SendCdbDirect()


BOOLEAN
SubmitCdbDirect(
        IN PDEVICE_EXTENSION DeviceExtension,
        IN PSCSI_REQUEST_BLOCK Srb
)

/*++

Routine Description:

        Build direct CDB and send directly to device - DAC960.

Arguments:

        DeviceExtension - Adapter state.
        SRB - System request.

Return Value:

        TRUE if command was started
        FALSE if host adapter is busy

--*/
{
        ULONG physicalAddress;
        PDIRECT_CDB directCdb;
        UCHAR command;
        ULONG descriptorNumber;
        ULONG i;
        UCHAR busyCurrentIndex;

        //
        // Determine if adapter is ready to accept new request.
        //

        if(!IsAdapterReady(DeviceExtension)) {
            return FALSE;
        }

        //
        // Check that next slot is vacant.
        //

        if (DeviceExtension->ActiveRequests[DeviceExtension->CurrentIndex]) {

        //
        // Collision occurred.
        //

        busyCurrentIndex = DeviceExtension->CurrentIndex++;

        do {
                if (! DeviceExtension->ActiveRequests[DeviceExtension->CurrentIndex]) {
                 break;
                }
        } while (++DeviceExtension->CurrentIndex != busyCurrentIndex) ;

        if (DeviceExtension->CurrentIndex == busyCurrentIndex) {

                //
                // We should never encounter this condition.
                //

                DebugPrint((dac960nt_dbg,
                           "DAC960: SubmitCdbDirect-Collision in active request array\n"));
                return FALSE;
        }
        }

        //
        // Check if this device is busy
        //

        if (! MarkNonDiskDeviceBusy(DeviceExtension, Srb->PathId, Srb->TargetId))
                return FALSE;

        //
        // Set command code.
        //

        command = DAC960_COMMAND_DIRECT;

        //
        // Build scatter/gather list if memory is not physically contiguous.
        //

        if (DeviceExtension->AdapterType == DAC960_OLD_ADAPTER)
        {
            if (BuildScatterGather(DeviceExtension,
                                   Srb,
                                   &physicalAddress,
                                   &descriptorNumber)) {
    
                    //
                    // OR in scatter/gather bit.
                    //
    
                    command |= DAC960_COMMAND_SG;
    
                    //
                    // Write scatter/gather descriptor count in mailbox.
                    //
    
                    DeviceExtension->MailBox.ScatterGatherCount =
                                       (UCHAR)descriptorNumber;
            }
        }
        else
        {
            if (BuildScatterGatherExtended(DeviceExtension,
                                           Srb,
                                           &physicalAddress,
                                           &descriptorNumber)) {
                //
                // OR in scatter/gather bit.
                //

                command |= DAC960_COMMAND_SG;

                //
                // Write scatter/gather descriptor count in mailbox.
                // For Fw Ver >= 3.x, scatter/gather count goes to reg 2
                //

                DeviceExtension->MailBox.BlockCount =
                                   (USHORT)descriptorNumber;
            }
        }

        //
        // Get address of data buffer offset after the scatter/gather list.
        //

        directCdb =
            (PDIRECT_CDB)((PUCHAR)Srb->SrbExtension +
                DeviceExtension->MaximumSgElements * sizeof(SG_DESCRIPTOR));

        //
        // Set device SCSI address.
        //

        directCdb->TargetId = Srb->TargetId;
        directCdb->Channel = Srb->PathId;

        //
        // Set Data transfer length.
        //

        directCdb->DataBufferAddress = physicalAddress;
        directCdb->DataTransferLength = (USHORT)Srb->DataTransferLength;

        //
        // Initialize control field indicating disconnect allowed.
        //

        directCdb->CommandControl = DAC960_CONTROL_ENABLE_DISCONNECT;

        //
        // Set data direction bit and allow disconnects.
        //

        if (Srb->SrbFlags & SRB_FLAGS_DATA_IN) {
            directCdb->CommandControl |= DAC960_CONTROL_DATA_IN;
        } else if (Srb->SrbFlags & SRB_FLAGS_DATA_OUT) {
            directCdb->CommandControl |= DAC960_CONTROL_DATA_OUT;
        }
        //
        // Set the Timeout Value for Direct CDB Commands depending on
        // the timeout value  set in SRB
        //
        if ( Srb->TimeOutValue ){
            if ( Srb->TimeOutValue <= 10 ){
                directCdb->CommandControl |= DAC960_CONTROL_TIMEOUT_10_SECS;
            } else if ( Srb->TimeOutValue <= 60 ){
                directCdb->CommandControl |= DAC960_CONTROL_TIMEOUT_60_SECS;
            } else if ( Srb->TimeOutValue <= 1200 ){
                directCdb->CommandControl |= DAC960_CONTROL_TIMEOUT_20_MINUTES;
           }
        }

        DebugPrint((dac960nt_dbg,
                        "DAC960: DCDB: CH %d TARG %d Command %d: TimeOut Value %d\n",
                        Srb->PathId,Srb->TargetId,Srb->Cdb[0],Srb->TimeOutValue));


        //
        // Copy CDB from SRB.
        //

        for (i = 0; i < 12; i++) {
            directCdb->Cdb[i] = ((PUCHAR)Srb->Cdb)[i];
        }

        //
        // Set lengths of CDB and request sense buffer.
        //

        directCdb->CdbLength = Srb->CdbLength;
        directCdb->RequestSenseLength = Srb->SenseInfoBufferLength;

        //
        // Get physical address of direct CDB packet.
        //

        physicalAddress =
            ScsiPortConvertPhysicalAddressToUlong(
                ScsiPortGetPhysicalAddress(DeviceExtension,
                                           NULL,
                                           directCdb,
                                           &i));
        //
        // Write physical address in mailbox.
        //

        DeviceExtension->MailBox.PhysicalAddress = physicalAddress;

        //
        // Write command in mailbox.
        //

        DeviceExtension->MailBox.OperationCode = command;

        //
        // Write request id in mailbox.
        //

        DeviceExtension->MailBox.CommandIdSubmit = 
                           DeviceExtension->CurrentIndex;

        //
        // Start writing Mailbox to controller.
        //

        SendCdbDirect(DeviceExtension);

        return TRUE;

} // SubmitCdbDirect()

BOOLEAN
Dac960ResetChannel(
        IN PVOID HwDeviceExtension,
        IN ULONG PathId
)

/*++

Routine Description:

        Reset Non Disk device associated with Srb.

Arguments:

        HwDeviceExtension - HBA miniport driver's adapter data storage
        PathId - SCSI channel number.

Return Value:

        TRUE if resets issued to all channels.

--*/

{
        PDEVICE_EXTENSION deviceExtension = HwDeviceExtension;

        DebugPrint((dac960nt_dbg, "Dac960ResetChannel Enter\n"));

        if (!IsAdapterReady(deviceExtension))
        {

            DebugPrint((dac960nt_dbg,
                            "DAC960: Timeout waiting for submission channel %x on reset\n"));

            if (deviceExtension->AdapterInterfaceType == MicroChannel) {
                //
                // This is bad news. The DAC960 doesn't have a direct hard reset.
                // Clear any bits set in system doorbell.
                //

                ScsiPortWritePortUchar(deviceExtension->SystemDoorBell, 0);

                //
                // Now check again if submission channel is free.
                //

                if (ScsiPortReadRegisterUchar(&deviceExtension->PmailBox->OperationCode) != 0)
                {

                    //
                    // Give up.
                    //
    
                    return FALSE;
                }
            }
            else {

                switch (deviceExtension->AdapterType)
                {
                    case DAC960_OLD_ADAPTER:
                    case DAC960_NEW_ADAPTER:

                        if (! deviceExtension->MemoryMapEnabled)
                        {
                            //
                            // This is bad news. The DAC960 doesn't have a direct hard reset.
                            // Clear any bits set in system doorbell.
                            //
    
                            ScsiPortWritePortUchar(deviceExtension->SystemDoorBell,
                                ScsiPortReadPortUchar(deviceExtension->SystemDoorBell));
    
                            //
                            // Now check again if submission channel is free.
                            //
        
                            if (ScsiPortReadPortUchar(deviceExtension->LocalDoorBell) & DAC960_LOCAL_DOORBELL_SUBMIT_BUSY)
                            {
        
                                //
                                // Give up.
                                //
            
                                return FALSE;
                            }

                            break;
                        }

                    case DAC960_PG_ADAPTER:
                    case DAC1164_PV_ADAPTER:

                        ScsiPortWriteRegisterUchar(deviceExtension->SystemDoorBell,
                            ScsiPortReadRegisterUchar(deviceExtension->SystemDoorBell));
    
                        //
                        // Now check again if submission channel is free.
                        //
    
                        if (deviceExtension->AdapterType == DAC1164_PV_ADAPTER)
                        {
                            if (!(ScsiPortReadRegisterUchar(deviceExtension->LocalDoorBell) & DAC960_LOCAL_DOORBELL_SUBMIT_BUSY))
                                return FALSE;
                        }
                        else
                        {
                            if (ScsiPortReadRegisterUchar(deviceExtension->LocalDoorBell) & DAC960_LOCAL_DOORBELL_SUBMIT_BUSY)
                                return FALSE;
                        }

                        break;
                }
            }
        }

        //
        // Write command in mailbox.
        //

        deviceExtension->MailBox.OperationCode = 
                           DAC960_COMMAND_RESET;

        //
        // Write channel number in mailbox.
        //

        deviceExtension->MailBox.BlockCount = 
                                   (UCHAR)PathId;


        //
        // Indicate Soft reset required.
        //

        deviceExtension->MailBox.BlockNumber[0] = 0;


        deviceExtension->MailBox.CommandIdSubmit = 
                           deviceExtension->CurrentIndex;

        //
        // Start writing mail box to controller.
        //

        SendRequest(deviceExtension);

        DebugPrint((dac960nt_dbg, "Dac960ResetChannel Exit\n"));

        return TRUE;
}

BOOLEAN
Dac960ResetBus(
        IN PVOID HwDeviceExtension,
        IN ULONG PathId
)

/*++

Routine Description:

        Reset Dac960 SCSI adapter and SCSI bus.
        NOTE: Command ID is ignored as this command will be completed
        before reset interrupt occurs and all active slots are zeroed.

Arguments:

        HwDeviceExtension - HBA miniport driver's adapter data storage
        PathId - not used.

Return Value:

        TRUE if resets issued to all channels.

--*/

{
        PDEVICE_EXTENSION deviceExtension = HwDeviceExtension;
        PSCSI_REQUEST_BLOCK srb;
        PSCSI_REQUEST_BLOCK restartList = deviceExtension->SubmissionQueueHead;

        if (deviceExtension->CurrentAdapterRequests) {
            DebugPrint((dac960nt_dbg, "RB: de 0x%p, cmds 0x%x P 0x%x\n",
                            deviceExtension, deviceExtension->CurrentAdapterRequests,
                            PathId));
        }

        deviceExtension->SubmissionQueueHead = NULL;
                
        while (restartList) {

                // Get next pending request.

                srb = restartList;

                // Remove request from pending queue.

                restartList = srb->NextSrb;
                srb->NextSrb = NULL;
                srb->SrbStatus = SRB_STATUS_BUS_RESET;

                ScsiPortNotification(RequestComplete,
                                     deviceExtension,
                                     srb);

                DebugPrint((dac960nt_dbg, "RB: de 0x%p, P 0x%x srb 0x%p\n",
                                deviceExtension, PathId, srb));
        }

        ScsiPortNotification(NextRequest,
                             deviceExtension);

        return TRUE;

} // end Dac960ResetBus()


VOID
Dac960SystemDriveRequest(
        PDEVICE_EXTENSION DeviceExtension,
        PSCSI_REQUEST_BLOCK Srb
)

/*++

Routine Description:

        Fill in Inquiry information for the system drive.
        If the system drive doesn't exist, indicate error.

Arguments:

        DeviceExtension - HBA miniport driver's adapter data storage
        Srb - SCSI request block.

--*/

{

        ULONG lastBlock;

        switch (Srb->Cdb[0]) { 

        case SCSIOP_INQUIRY:
        case SCSIOP_READ_CAPACITY:
        case SCSIOP_TEST_UNIT_READY:
        {
                ULONG sd;
                ULONG i, j;
                PSDINFOL sdInfo;
                UCHAR   buffer[128];
                
                //
                // Find System Drive Number.
                //

                sd = Srb->TargetId;

                sdInfo = (PSDINFOL) DeviceExtension->NoncachedExtension;

                for (i = 0; i < 32; i++)
                {
                    if (sdInfo->SystemDrive[i].Size == 0xFFFFFFFF)
                        break;
                }

                if (i <= sd) {
                    Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;

                    return;
                }

                if (Srb->Cdb[0] == SCSIOP_TEST_UNIT_READY)
                    break;

                lastBlock = sdInfo->SystemDrive[sd].Size - 1;

#ifdef IBM_SUPPORT

                if (Srb->Cdb[0] == SCSIOP_INQUIRY) {

                        //
                        // Fill in inquiry buffer.
                        //

                        ((PUCHAR)Srb->DataBuffer)[0]  = 0;
                        ((PUCHAR)Srb->DataBuffer)[1]  = 0;
                        ((PUCHAR)Srb->DataBuffer)[2]  = 1;
                        ((PUCHAR)Srb->DataBuffer)[3]  = 0;
                        ((PUCHAR)Srb->DataBuffer)[4]  = 0x20;
                        ((PUCHAR)Srb->DataBuffer)[5]  = 0;
                        ((PUCHAR)Srb->DataBuffer)[6]  = 0;
                        ((PUCHAR)Srb->DataBuffer)[7]  = 0x02;
                        ((PUCHAR)Srb->DataBuffer)[8]  = 'M';
                        ((PUCHAR)Srb->DataBuffer)[9]  = 'Y';
                        ((PUCHAR)Srb->DataBuffer)[10] = 'L';
                        ((PUCHAR)Srb->DataBuffer)[11] = 'E';
                        ((PUCHAR)Srb->DataBuffer)[12] = 'X';
                        ((PUCHAR)Srb->DataBuffer)[13] = ' ';
                        ((PUCHAR)Srb->DataBuffer)[14] = ' ';
                        ((PUCHAR)Srb->DataBuffer)[15] = ' ';
                        ((PUCHAR)Srb->DataBuffer)[16] = 'D';
                        ((PUCHAR)Srb->DataBuffer)[17] = 'A';
                        ((PUCHAR)Srb->DataBuffer)[18] = 'C';
                        ((PUCHAR)Srb->DataBuffer)[19] = '9';
                        ((PUCHAR)Srb->DataBuffer)[20] = '6';
                        ((PUCHAR)Srb->DataBuffer)[21] = '0';

                        for (i = 22; i < Srb->DataTransferLength; i++) {
                                ((PUCHAR)Srb->DataBuffer)[i] = ' ';
                        }
                }
                else {

                        //
                        // Fill in read capacity data.
                        //

                        REVERSE_BYTES(&((PREAD_CAPACITY_DATA)Srb->DataBuffer)->LogicalBlockAddress,
                                                &lastBlock);

                        ((PUCHAR)Srb->DataBuffer)[4] = 0;
                        ((PUCHAR)Srb->DataBuffer)[5] = 0;
                        ((PUCHAR)Srb->DataBuffer)[6] = 2;
                        ((PUCHAR)Srb->DataBuffer)[7] = 0;
                }
#else
                //
                // Wait for Input MBOX to be free, so that we don't overwite
                // the Mail Box contents with heavy I/O - Refer to NEC Problem
                //
                // It should not loop here indefinitely. It will only if
                // controller is hung for some reason!!!. We can not do
                // anything else since we have to give the INQUIRY data back.
                //
                while(1)
                    if(IsAdapterReady(DeviceExtension)) break;

                //
                // Write Inquiry String to DAC960 Mail Box Register 0 and use
                // ScsiPortReadPortBufferUchar to read back the string into
                // Srb->DataBuffer.
                //

                if (Srb->Cdb[0] == SCSIOP_INQUIRY) 
                {
                        //
                        // Fill in inquiry buffer.
                        //

                        buffer[0]  = 0;
                        buffer[1]  = 0;
                        buffer[2]  = 1;
                        buffer[3]  = 0;
                        buffer[4]  = 0x20;
                        buffer[5]  = 0;
                        buffer[6]  = 0;
                        buffer[7]  = 0x02;
                        buffer[8]  = 'M';
                        buffer[9]  = 'Y';
                        buffer[10] = 'L';
                        buffer[11] = 'E';
                        buffer[12] = 'X';
                        buffer[13] = ' ';
                        buffer[14] = ' ';
                        buffer[15] = ' ';
                        buffer[16] = 'D';
                        buffer[17] = 'A';
                        buffer[18] = 'C';
                        buffer[19] = '9';
                        buffer[20] = '6';
                        buffer[21] = '0';

                        for (i = 22; i < Srb->DataTransferLength; i++) 
                        {
                                buffer[i] = ' ';
                        }

                        j = Srb->DataTransferLength / 4;

                        for (i = 0; i < j; i++)
                        {
                                ScsiPortWritePortUlong((PULONG) (&DeviceExtension->PmailBox->OperationCode),
                                                                           *((PULONG) &buffer[i*4]));
                                                                          
                                ScsiPortReadPortBufferUlong((PULONG)(&DeviceExtension->PmailBox->OperationCode),
                                                                                        (PULONG)(&(((PUCHAR)Srb->DataBuffer)[i*4])),
                                                                                        1);
                        }

                        for (i = (i*4); i < Srb->DataTransferLength; i++)
                        {
                                 ScsiPortWritePortUchar(&DeviceExtension->PmailBox->OperationCode,
                                                                                buffer[i]);
                                                                          
                                 ScsiPortReadPortBufferUchar(&DeviceExtension->PmailBox->OperationCode,
                                                                                         &(((PUCHAR)Srb->DataBuffer)[i]),
                                                                                         1);
                        }
                }
                else {

                        //
                        // Fill in read capacity data.
                        //

                        REVERSE_BYTES(&((PREAD_CAPACITY_DATA)buffer)->LogicalBlockAddress,
                                                &lastBlock);

                        buffer[4] = 0;
                        buffer[5] = 0;
                        buffer[6] = 2;
                        buffer[7] = 0;

                        for (i = 0; i < 2; i++)
                        {
                                ScsiPortWritePortUlong((PULONG) (&DeviceExtension->PmailBox->OperationCode),
                                                                           *((PULONG) &buffer[i*4]));

                                ScsiPortReadPortBufferUlong((PULONG)(&DeviceExtension->PmailBox->OperationCode),
                                                                                        (PULONG) (&(((PUCHAR)Srb->DataBuffer)[i*4])),
                                                                                        1);
                        }
                }
#endif

        }
        break;

        default:
        
                break;
        }

        Srb->SrbStatus = SRB_STATUS_SUCCESS;
}


VOID
Dac960PGSystemDriveRequest(
        PDEVICE_EXTENSION DeviceExtension,
        PSCSI_REQUEST_BLOCK Srb
)

/*++

Routine Description:

        Fill in Inquiry information for the system drive.
        If the system drive doesn't exist, indicate error.

Arguments:

        DeviceExtension - HBA miniport driver's adapter data storage
        Srb - SCSI request block.

--*/

{

        ULONG lastBlock;

        switch (Srb->Cdb[0]) { 

        case SCSIOP_INQUIRY:
        case SCSIOP_READ_CAPACITY:
        {
                ULONG sd;
                ULONG i, j;
                PSDINFOL sdInfo;
                UCHAR   buffer[128];
                
                //
                // Find System Drive Number.
                //

                sd = Srb->TargetId;

                sdInfo = (PSDINFOL) DeviceExtension->NoncachedExtension;

                for (i = 0; i < 32; i++)
                {
                        if (sdInfo->SystemDrive[i].Size == 0xFFFFFFFF)
                                break;
                }

                if (i <= sd) {
                        Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;

                        return;
                }

                lastBlock = sdInfo->SystemDrive[sd].Size - 1;

#ifdef IBM_SUPPORT

                if (Srb->Cdb[0] == SCSIOP_INQUIRY) {

                        //
                        // Fill in inquiry buffer.
                        //

                        ((PUCHAR)Srb->DataBuffer)[0]  = 0;
                        ((PUCHAR)Srb->DataBuffer)[1]  = 0;
                        ((PUCHAR)Srb->DataBuffer)[2]  = 1;
                        ((PUCHAR)Srb->DataBuffer)[3]  = 0;
                        ((PUCHAR)Srb->DataBuffer)[4]  = 0x20;
                        ((PUCHAR)Srb->DataBuffer)[5]  = 0;
                        ((PUCHAR)Srb->DataBuffer)[6]  = 0;
                        ((PUCHAR)Srb->DataBuffer)[7]  = 0x02;
                        ((PUCHAR)Srb->DataBuffer)[8]  = 'M';
                        ((PUCHAR)Srb->DataBuffer)[9]  = 'Y';
                        ((PUCHAR)Srb->DataBuffer)[10] = 'L';
                        ((PUCHAR)Srb->DataBuffer)[11] = 'E';
                        ((PUCHAR)Srb->DataBuffer)[12] = 'X';
                        ((PUCHAR)Srb->DataBuffer)[13] = ' ';
                        ((PUCHAR)Srb->DataBuffer)[14] = ' ';
                        ((PUCHAR)Srb->DataBuffer)[15] = ' ';
                        ((PUCHAR)Srb->DataBuffer)[16] = 'D';
                        ((PUCHAR)Srb->DataBuffer)[17] = 'A';
                        ((PUCHAR)Srb->DataBuffer)[18] = 'C';
                        ((PUCHAR)Srb->DataBuffer)[19] = '9';
                        ((PUCHAR)Srb->DataBuffer)[20] = '6';
                        ((PUCHAR)Srb->DataBuffer)[21] = '0';

                        for (i = 22; i < Srb->DataTransferLength; i++) {
                                ((PUCHAR)Srb->DataBuffer)[i] = ' ';
                        }
                }
                else {

                        //
                        // Fill in read capacity data.
                        //

                        REVERSE_BYTES(&((PREAD_CAPACITY_DATA)Srb->DataBuffer)->LogicalBlockAddress,
                                                &lastBlock);

                        ((PUCHAR)Srb->DataBuffer)[4] = 0;
                        ((PUCHAR)Srb->DataBuffer)[5] = 0;
                        ((PUCHAR)Srb->DataBuffer)[6] = 2;
                        ((PUCHAR)Srb->DataBuffer)[7] = 0;
                }
#else

                //
                // Wait for Input MBOX to be free, so that we don't overwite
                // the Mail Box contents with heavy I/O - Refer to NEC Problem
                //
                // It should not loop here indefinitely. It will only if
                // controller is hung for some reason!!!. We can not do
                // anything else since we have to give the INQUIRY data back.
                //
                while(1)
                    if(IsAdapterReady(DeviceExtension)) break;

                //
                // Write Inquiry String to DAC960 Mail Box Register 0 and use
                // ScsiPortReadPortBufferUchar to read back the string into
                // Srb->DataBuffer.
                //

                if (Srb->Cdb[0] == SCSIOP_INQUIRY) 
                {
                        //
                        // Fill in inquiry buffer.
                        //

                        buffer[0]  = 0;
                        buffer[1]  = 0;
                        buffer[2]  = 1;
                        buffer[3]  = 0;
                        buffer[4]  = 0x20;
                        buffer[5]  = 0;
                        buffer[6]  = 0;
                        buffer[7]  = 0x02;
                        buffer[8]  = 'M';
                        buffer[9]  = 'Y';
                        buffer[10] = 'L';
                        buffer[11] = 'E';
                        buffer[12] = 'X';
                        buffer[13] = ' ';
                        buffer[14] = ' ';
                        buffer[15] = ' ';
                        buffer[16] = 'D';
                        buffer[17] = 'A';
                        buffer[18] = 'C';
                        buffer[19] = '9';
                        buffer[20] = '6';
                        buffer[21] = '0';

                        for (i = 22; i < Srb->DataTransferLength; i++) 
                        {
                                buffer[i] = ' ';
                        }

                        j = Srb->DataTransferLength / 4;

                        for (i = 0; i < j; i++)
                        {
                                ScsiPortWriteRegisterUlong((PULONG) (&DeviceExtension->PmailBox->OperationCode),
                                                                           *((PULONG) &buffer[i*4]));
                                                                          
                                ScsiPortReadRegisterBufferUlong((PULONG)(&DeviceExtension->PmailBox->OperationCode),
                                                                                        (PULONG)(&(((PUCHAR)Srb->DataBuffer)[i*4])),
                                                                                        1);
                        }

                        for (i = (i*4); i < Srb->DataTransferLength; i++)
                        {
                                 ScsiPortWriteRegisterUchar(&DeviceExtension->PmailBox->OperationCode,
                                                                                buffer[i]);
                                                                          
                                 ScsiPortReadRegisterBufferUchar(&DeviceExtension->PmailBox->OperationCode,
                                                                                         &(((PUCHAR)Srb->DataBuffer)[i]),
                                                                                         1);
                        }
                }
                else {

                        //
                        // Fill in read capacity data.
                        //

                        REVERSE_BYTES(&((PREAD_CAPACITY_DATA)buffer)->LogicalBlockAddress,
                                                &lastBlock);

                        buffer[4] = 0;
                        buffer[5] = 0;
                        buffer[6] = 2;
                        buffer[7] = 0;

                        for (i = 0; i < 2; i++)
                        {
                                ScsiPortWriteRegisterUlong((PULONG) (&DeviceExtension->PmailBox->OperationCode),
                                                                           *((PULONG) &buffer[i*4]));

                                ScsiPortReadRegisterBufferUlong((PULONG)(&DeviceExtension->PmailBox->OperationCode),
                                                                                        (PULONG) (&(((PUCHAR)Srb->DataBuffer)[i*4])),
                                                                                        1);
                        }
                }
#endif

        }
        break;

        default:
        
                break;
        }

        Srb->SrbStatus = SRB_STATUS_SUCCESS;
}

BOOLEAN
StartIo(
        IN PVOID HwDeviceExtension,
        IN PSCSI_REQUEST_BLOCK Srb,
        IN BOOLEAN NextRequest
)

/*++

Routine Description:

        This routine is called from the SCSI port driver synchronized
        with the kernel to start a request.

Arguments:

        HwDeviceExtension - HBA miniport driver's adapter data storage
        Srb - IO request packet
        NextRequest - indicates that the routine should ask for the next request
                      using the appropriate API.

Return Value:

        TRUE

--*/

{
        PDEVICE_EXTENSION deviceExtension = HwDeviceExtension;
        ULONG             i;
        UCHAR             status;
        UCHAR             PathId,TargetId,LunId;

        switch (Srb->Function) {

        case SRB_FUNCTION_EXECUTE_SCSI:

                if (Srb->PathId == DAC960_SYSTEM_DRIVE_CHANNEL) {

                //
                // Logical Drives mapped to 
                // SCSI PathId DAC960_SYSTEM_DRIVE_CHANNEL TargetId 0-32, Lun 0
                //

                //
                // Determine command from CDB operation code.
                //

                switch (Srb->Cdb[0]) {

                case SCSIOP_READ:
                case SCSIOP_WRITE:

                //
                // Check if number of outstanding adapter requests
                // equals or exceeds maximum. If not, submit SRB.
                //

                if (deviceExtension->CurrentAdapterRequests <
                        deviceExtension->MaximumAdapterRequests) {

                        //
                        // Send request to controller.
                        //

                        if (SubmitRequest(deviceExtension, Srb)) {

                                status = SRB_STATUS_PENDING;
        
                        } else {
                                status = SRB_STATUS_BUSY;
                        }

                } else {

                        status = SRB_STATUS_BUSY;
                }

                break;

                case SCSIOP_INQUIRY:
                case SCSIOP_READ_CAPACITY:
                case SCSIOP_TEST_UNIT_READY:

                if (Srb->Lun != 0) {
                        status = SRB_STATUS_SELECTION_TIMEOUT;
                        break;
                }

                //
                // Check if number of outstanding adapter requests
                // equals or exceeds maximum. If not, submit SRB.
                //

                if (deviceExtension->CurrentAdapterRequests <
                        deviceExtension->MaximumAdapterRequests) {

                        //
                        // Send request to controller.
                        //

                        if (SubmitSystemDriveInfoRequest(deviceExtension, Srb)) {

                                status = SRB_STATUS_PENDING;
        
                        } else {

                                status = SRB_STATUS_BUSY;
                        }

                } else {

                        status = SRB_STATUS_BUSY;
                }

                break;

                case SCSIOP_VERIFY:

                //
                // Complete this request.
                //

                status = SRB_STATUS_SUCCESS;
                break;

                default:

                //
                // Fail this request.
                //

                DebugPrint((dac960nt_dbg,
                               "Dac960StartIo: SCSI CDB opcode %x not handled\n",
                               Srb->Cdb[0]));

                status = SRB_STATUS_INVALID_REQUEST;
                break;

                } // end switch (Srb->Cdb[0])

                break;

        } else {

                //
                // These are passthrough requests.  Only accept request to LUN 0.
                // This is because the DAC960 direct CDB interface does not include
                // a field for LUN.
                //

                if (Srb->Lun != 0 || Srb->TargetId >= MAXIMUM_TARGETS_PER_CHANNEL) {
                        DebugPrint((dac960nt_dbg, "sel timeout for c %x t %x l %x, oc %x\n",
                                        Srb->PathId,
                                        Srb->TargetId,
                                        Srb->Lun,
                                        Srb->Cdb[0]));

                        status = SRB_STATUS_SELECTION_TIMEOUT;
                        break;
                }

#ifdef GAM_SUPPORT

                if (Srb->PathId == GAM_DEVICE_PATH_ID) 
                {
                        if (Srb->TargetId != GAM_DEVICE_TARGET_ID) {
                                DebugPrint((dac960nt_dbg, "sel timeout for GAM c %x t %x l %x, oc %x\n",
                                                Srb->PathId,
                                                Srb->TargetId,
                                                Srb->Lun,
                                                Srb->Cdb[0]));

                                status = SRB_STATUS_SELECTION_TIMEOUT;
                                break;
                        }
                
                        switch (Srb->Cdb[0]) {

                        case SCSIOP_INQUIRY:
                        {
#ifdef IBM_SUPPORT

                                //
                                // Fill in inquiry buffer for the GAM device.
                                //

                                DebugPrint((dac960nt_dbg, "Inquiry For GAM device\n"));

                                ((PUCHAR)Srb->DataBuffer)[0]  = PROCESSOR_DEVICE; // Processor device
                                ((PUCHAR)Srb->DataBuffer)[1]  = 0;
                                ((PUCHAR)Srb->DataBuffer)[2]  = 1;
                                ((PUCHAR)Srb->DataBuffer)[3]  = 0;
                                ((PUCHAR)Srb->DataBuffer)[4]  = 0x20;
                                ((PUCHAR)Srb->DataBuffer)[5]  = 0;
                                ((PUCHAR)Srb->DataBuffer)[6]  = 0;
                                ((PUCHAR)Srb->DataBuffer)[7]  = 0;
                                ((PUCHAR)Srb->DataBuffer)[8]  = 'M';
                                ((PUCHAR)Srb->DataBuffer)[9]  = 'Y';
                                ((PUCHAR)Srb->DataBuffer)[10] = 'L';
                                ((PUCHAR)Srb->DataBuffer)[11] = 'E';
                                ((PUCHAR)Srb->DataBuffer)[12] = 'X';
                                ((PUCHAR)Srb->DataBuffer)[13] = ' ';
                                ((PUCHAR)Srb->DataBuffer)[14] = ' ';
                                ((PUCHAR)Srb->DataBuffer)[15] = ' ';
                                ((PUCHAR)Srb->DataBuffer)[16] = 'G';
                                ((PUCHAR)Srb->DataBuffer)[17] = 'A';
                                ((PUCHAR)Srb->DataBuffer)[18] = 'M';
                                ((PUCHAR)Srb->DataBuffer)[19] = ' ';
                                ((PUCHAR)Srb->DataBuffer)[20] = 'D';
                                ((PUCHAR)Srb->DataBuffer)[21] = 'E';
                                ((PUCHAR)Srb->DataBuffer)[22] = 'V';
                                ((PUCHAR)Srb->DataBuffer)[23] = 'I';
                                ((PUCHAR)Srb->DataBuffer)[24] = 'C';
                                ((PUCHAR)Srb->DataBuffer)[25] = 'E';
                                
                                for (i = 26; i < Srb->DataTransferLength; i++) {
                                        ((PUCHAR)Srb->DataBuffer)[i] = ' ';
                                }
#else
                                UCHAR   buffer[128];
                                ULONG   j;

                                //
                                // Wait for Input MBOX to be free, so that we don't overwite
                                // the Mail Box contents with heavy I/O - Refer to NEC Problem
                                //
                                // It should not loop here indefinitely. It will only if
                                // controller is hung for some reason!!!. We can not do
                                // anything else since we have to give the INQUIRY data back.
                                //
                                while(1)
                                    if(IsAdapterReady(deviceExtension)) break;

                                //
                                // Fill in inquiry buffer for the GAM device.
                                //

                                DebugPrint((dac960nt_dbg, "Inquiry For GAM device\n"));

                                buffer[0]  = PROCESSOR_DEVICE; // Processor device
                                buffer[1]  = 0;
                                buffer[2]  = 1;
                                buffer[3]  = 0;
                                buffer[4]  = 0x20;
                                buffer[5]  = 0;
                                buffer[6]  = 0;
                                buffer[7]  = 0;
                                buffer[8]  = 'M';
                                buffer[9]  = 'Y';
                                buffer[10] = 'L';
                                buffer[11] = 'E';
                                buffer[12] = 'X';
                                buffer[13] = ' ';
                                buffer[14] = ' ';
                                buffer[15] = ' ';
                                buffer[16] = 'G';
                                buffer[17] = 'A';
                                buffer[18] = 'M';
                                buffer[19] = ' ';
                                buffer[20] = 'D';
                                buffer[21] = 'E';
                                buffer[22] = 'V';
                                buffer[23] = 'I';
                                buffer[24] = 'C';
                                buffer[25] = 'E';

                                for (i = 26; i < Srb->DataTransferLength; i++) {
                                        buffer[i] = ' ';
                                }

                                j = Srb->DataTransferLength / 4;

                                if ( (deviceExtension->AdapterType == DAC960_OLD_ADAPTER) ||
                                     (deviceExtension->AdapterType == DAC960_NEW_ADAPTER)){
                                if ( deviceExtension->MemoryMapEnabled ){
                                for (i = 0; i < j; i++)
                                {
                                        ScsiPortWriteRegisterUlong((PULONG) (&deviceExtension->PmailBox->OperationCode),
                                                                                   *((PULONG) &buffer[i*4]));
                                                                          
                                        ScsiPortReadRegisterBufferUlong((PULONG)(&deviceExtension->PmailBox->OperationCode),
                                                                                                (PULONG)(&(((PUCHAR)Srb->DataBuffer)[i*4])),
                                                                                                1);
                                }

                                for (i = (i*4); i < Srb->DataTransferLength; i++)
                                {
                                        ScsiPortWriteRegisterUchar(&deviceExtension->PmailBox->OperationCode,
                                                                                   buffer[i]);
                                                                          
                                        ScsiPortReadRegisterBufferUchar(&deviceExtension->PmailBox->OperationCode,
                                                                                                &(((PUCHAR)Srb->DataBuffer)[i]),
                                                                                                1);
                                }
                                }
                                else{
                                for (i = 0; i < j; i++)
                                {
                                        ScsiPortWritePortUlong((PULONG) (&deviceExtension->PmailBox->OperationCode),
                                                                                   *((PULONG) &buffer[i*4]));
                                                                          
                                        ScsiPortReadPortBufferUlong((PULONG)(&deviceExtension->PmailBox->OperationCode),
                                                                                                (PULONG)(&(((PUCHAR)Srb->DataBuffer)[i*4])),
                                                                                                1);
                                }

                                for (i = (i*4); i < Srb->DataTransferLength; i++)
                                {
                                        ScsiPortWritePortUchar(&deviceExtension->PmailBox->OperationCode,
                                                                                   buffer[i]);
                                                                          
                                        ScsiPortReadPortBufferUchar(&deviceExtension->PmailBox->OperationCode,
                                                                                                &(((PUCHAR)Srb->DataBuffer)[i]),
                                                                                                1);
                                }
                                }
                                }
                                else if ( deviceExtension->AdapterType == DAC960_PG_ADAPTER){
                                for (i = 0; i < j; i++)
                                {
                                        ScsiPortWriteRegisterUlong((PULONG) (&deviceExtension->PmailBox->OperationCode),
                                                                                   *((PULONG) &buffer[i*4]));
                                                                          
                                        ScsiPortReadRegisterBufferUlong((PULONG)(&deviceExtension->PmailBox->OperationCode),
                                                                                                (PULONG)(&(((PUCHAR)Srb->DataBuffer)[i*4])),
                                                                                                1);
                                }

                                for (i = (i*4); i < Srb->DataTransferLength; i++)
                                {
                                        ScsiPortWriteRegisterUchar(&deviceExtension->PmailBox->OperationCode,
                                                                                   buffer[i]);
                                                                          
                                        ScsiPortReadRegisterBufferUchar(&deviceExtension->PmailBox->OperationCode,
                                                                                                &(((PUCHAR)Srb->DataBuffer)[i]),
                                                                                                1);
                                }

                                }
#endif
                        }
                        status = SRB_STATUS_SUCCESS;

                        break;
                        default:
                                DebugPrint((dac960nt_dbg, "GAM req not handled, Oc %x\n", Srb->Cdb[0]));
                                status = SRB_STATUS_SELECTION_TIMEOUT;
                                break;
                        }

                        break;
                }       
#endif

                if ((deviceExtension->DeviceList[Srb->PathId][Srb->TargetId] & DAC960_DEVICE_ACCESSIBLE) != DAC960_DEVICE_ACCESSIBLE) {
                        status = SRB_STATUS_SELECTION_TIMEOUT;
                        break;
                }

                //
                // Check if number of outstanding adapter requests
                // equals or exceeds maximum. If not, submit SRB.
                //

                if (deviceExtension->CurrentAdapterRequests <
                deviceExtension->MaximumAdapterRequests) {

                //
                // Send request to controller.
                //

                if (SubmitCdbDirect(deviceExtension, Srb)) {

                        status = SRB_STATUS_PENDING;

                } else {

                        status = SRB_STATUS_BUSY;
                }

                } else {

                status = SRB_STATUS_BUSY;
                }

                break;
        }

        case SRB_FUNCTION_FLUSH:

        status = SRB_STATUS_SUCCESS;

        break;

        case SRB_FUNCTION_SHUTDOWN:

        //
        // Issue flush command to controller.
        //

        if (!SubmitRequest(deviceExtension, Srb)) {

                status = SRB_STATUS_BUSY;

        } else {

                status = SRB_STATUS_PENDING;
        }

        break;

        case SRB_FUNCTION_ABORT_COMMAND:

        //
        // If the request is for Non-Disk device, do soft reset.
        //

        if ((Srb->PathId != DAC960_SYSTEM_DRIVE_CHANNEL) && 
                (Srb->PathId != GAM_DEVICE_PATH_ID)) {

                //
                // Issue request to soft reset Non-Disk device.
                //

                if (Dac960ResetChannel(deviceExtension,
                                   Srb->NextSrb->PathId)) {

                //
                // Set the flag to indicate that we are handling abort
                // Request, so do not ask for new requests.
                //

                status = SRB_STATUS_PENDING;

                } else {

                status = SRB_STATUS_ABORT_FAILED;
                }
        }
        else {

                //
                // There is nothing the miniport can do, if logical drive
                // requests are timing out. Resetting the channel does not help.
                // It only makes the situation worse.
                //

                //
                // Indicate that the abort failed.
                //

                status = SRB_STATUS_ABORT_FAILED;
        }

        break;

        case SRB_FUNCTION_RESET_BUS:
        case SRB_FUNCTION_RESET_DEVICE:

        //
        // There is nothing the miniport can do by issuing Hard Resets on
        // Dac960 SCSI channels.
        //

        status = SRB_STATUS_SUCCESS;

        break;

        case SRB_FUNCTION_IO_CONTROL:

        DebugPrint((dac960nt_dbg, "DAC960: Ioctl, out-cmds %d\n",deviceExtension->CurrentAdapterRequests));

        //
        // Check if number of outstanding adapter requests
        // equals or exceeds maximum. If not, submit SRB.
        //

        if (deviceExtension->CurrentAdapterRequests <
                deviceExtension->MaximumAdapterRequests) {

                PIOCTL_REQ_HEADER  ioctlReqHeader =
                (PIOCTL_REQ_HEADER)Srb->DataBuffer;

                if (Dac960StringCompare(ioctlReqHeader->SrbIoctl.Signature, 
                                        MYLEX_IOCTL_SIGNATURE,
                                        8))
                {
                    status = SRB_STATUS_INVALID_REQUEST;
                    break;
                }

                //
                // Send request to controller.
                //

                switch (ioctlReqHeader->GenMailBox.Reg0) {
                case MIOC_ADP_INFO:

                SetupAdapterInfo(deviceExtension, Srb);

                status = SRB_STATUS_SUCCESS;
                break;

                case MIOC_DRIVER_VERSION:

                SetupDriverVersionInfo(deviceExtension, Srb);

                status = SRB_STATUS_SUCCESS;
                break;

                case DAC960_COMMAND_DIRECT:

                status = SendIoctlCdbDirect(deviceExtension, Srb);
                if (status == 0)
                        status = SRB_STATUS_PENDING;
                else if (status == 2){
                        ioctlReqHeader->DriverErrorCode =
                        DAC_IOCTL_RESOURCE_ALLOC_FAILURE;

                        status = SRB_STATUS_SUCCESS;
                }
                else
                        status = SRB_STATUS_BUSY;

                break;

                default:

                status = SendIoctlDcmdRequest(deviceExtension, Srb);
                if (status == 0)
                        status = SRB_STATUS_PENDING;
                else if (status == 2){
                        ioctlReqHeader->DriverErrorCode =
                        DAC_IOCTL_RESOURCE_ALLOC_FAILURE;

                        status = SRB_STATUS_SUCCESS;
                }
                else
                        status = SRB_STATUS_BUSY;

                break;
                }

        } else {

                status = SRB_STATUS_BUSY;
        }

        break;

        default:

        //
        // Fail this request.
        //

        DebugPrint((dac960nt_dbg,
                   "Dac960StartIo: SRB fucntion %x not handled\n",
                   Srb->Function));

        status = SRB_STATUS_INVALID_REQUEST;
        break;

        } // end switch

        PathId = Srb->PathId;
        TargetId = Srb->TargetId;
        LunId = Srb->Lun;

        //
        // Check if this request is complete.
        //

        if (status == SRB_STATUS_PENDING) {
    
            //
            // Record SRB in active request array.
            //
    
            deviceExtension->ActiveRequests[deviceExtension->CurrentIndex] = Srb;
    
            //
            // Bump the count of outstanding adapter requests.
            //
    
            deviceExtension->CurrentAdapterRequests++;
    
            //
            // Advance active request index array.
            //
    
            deviceExtension->CurrentIndex++;

        } else if (status == SRB_STATUS_BUSY) {

            //
            // Check that there are outstanding requests to thump
            // the queue.
            //
    
            if (deviceExtension->CurrentAdapterRequests) {
    
                    //
                    // Queue SRB for resubmission.
                    //
    
                    if (!deviceExtension->SubmissionQueueHead) {
                        deviceExtension->SubmissionQueueHead = Srb;
                        deviceExtension->SubmissionQueueTail = Srb;
                    } else {
                        deviceExtension->SubmissionQueueTail->NextSrb = Srb;
                        deviceExtension->SubmissionQueueTail = Srb;
                    }
            }
            else {

                //
                // Request Port driver to resubmit this request at a later time.
                //

                Srb->SrbStatus = status;
                ScsiPortNotification(RequestComplete,
                                     deviceExtension,
                                     Srb);

            }
        } else {

            //
            // Notify system of request completion.
            //
    
            Srb->SrbStatus = status;
            ScsiPortNotification(RequestComplete,
                                 deviceExtension,
                                 Srb);
        }

        //
        // Check if this is a request to a system drive. Indicating
        // ready for next logical unit request causes the system to
        // send overlapped requests to this device (tag queuing).
        //
        // The DAC960 only supports a single outstanding direct CDB
        // request per device, so indicate ready for next adapter request.
        //

        if (NextRequest) {

            if (PathId == DAC960_SYSTEM_DRIVE_CHANNEL) {
    
                    //
                    // Indicate ready for next logical unit request.
                    //
    
                    ScsiPortNotification(NextLuRequest,
                                         deviceExtension,
                                         PathId,
                                         TargetId,
                                         LunId);
            } else {
    
                    //
                    // Indicate ready for next adapter request.
                    //
    
                    ScsiPortNotification(NextRequest,
                                         deviceExtension,
                                         PathId,
                                         TargetId,
                                         LunId);
            }
        }
        else
        {
                DebugPrint((dac960nt_dbg, "Did not ask for next request\n"));
        }

        return TRUE;

} // end Dac960StartIo()


BOOLEAN
Dac960StartIo(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    return StartIo(HwDeviceExtension, Srb, TRUE);
}


BOOLEAN
Dac960CheckInterrupt(
        IN PDEVICE_EXTENSION DeviceExtension,
        OUT PUSHORT Status,
        OUT PUCHAR Index,
        OUT PUCHAR IntrStatus
)

/*++

Routine Description:

        This routine reads interrupt register to determine if the adapter is
        indeed the source of the interrupt, and if so clears interrupt and 
        returns command completion status and command index.

Arguments:

        DeviceExtension - HBA miniport driver's adapter data storage
        Status - DAC960 Command completion status.
        Index - DAC960 Command index.

Return Value:

        TRUE  if the adapter is interrupting.
        FALSE if the adapter is not the source of the interrupt.

--*/

{
        *IntrStatus = 0;

        if (DeviceExtension->AdapterInterfaceType == MicroChannel)
        {

            if (ScsiPortReadPortUchar(DeviceExtension->SystemDoorBell) & 
                    DMC960_INTERRUPT_VALID) {
                    //
                    // The adapter is indeed the source of the interrupt.
                    // Set 'Clear Interrupt Valid Bit on read' in subsystem
                    // control port. 
                    //
    
                    ScsiPortWritePortUchar(DeviceExtension->BaseIoAddress + 
                                       DMC960_SUBSYSTEM_CONTROL_PORT,
                                       (DMC960_ENABLE_INTERRUPT | DMC960_CLEAR_INTERRUPT_ON_READ));
    
                    //
                    // Read index, status and error of completing command.
                    //
    
                    *Index = ScsiPortReadRegisterUchar(&DeviceExtension->PmailBox->CommandIdComplete);
                    *Status = ScsiPortReadRegisterUshort(&DeviceExtension->PmailBox->Status);
    
                    //
                    // Dismiss interrupt and tell host mailbox is free.
                    //
    
                    ScsiPortReadPortUchar(DeviceExtension->SystemDoorBell);
    
                    //
                    // status accepted acknowledgement.
                    //
    
                    ScsiPortWritePortUchar(DeviceExtension->LocalDoorBell,
                                               DMC960_ACKNOWLEDGE_STATUS);
    
                    //
                    // Set 'Not to Clear Interrupt Valid Bit on read' bits in subsystem
                    // control port. 
                    //
    
                    ScsiPortWritePortUchar(DeviceExtension->BaseIoAddress + 
                                       DMC960_SUBSYSTEM_CONTROL_PORT, 
                                       DMC960_ENABLE_INTERRUPT);
            }
            else {
                     return FALSE;
            }
        
        }
        else {
            switch (DeviceExtension->AdapterType)
            {
                case DAC960_OLD_ADAPTER:
                case DAC960_NEW_ADAPTER:

                    if (! DeviceExtension->MemoryMapEnabled)
                    {
                        //
                        // Check for command complete.
                        //
        
                        if (!(ScsiPortReadPortUchar(DeviceExtension->SystemDoorBell) &
                                DAC960_SYSTEM_DOORBELL_COMMAND_COMPLETE)) {
                            return FALSE;
                        }
        
                        //
                        // Read index, status and error of completing command.
                        //
        
                        *Index = ScsiPortReadPortUchar(&DeviceExtension->PmailBox->CommandIdComplete);
                        *Status = ScsiPortReadPortUshort(&DeviceExtension->PmailBox->Status);
        
                        //
                        // Dismiss interrupt and tell host mailbox is free.
                        //
        
                        Dac960EisaPciAckInterrupt(DeviceExtension);
                    }
                    else 
                    {
                        //
                        // Check for command complete.
                        //
        
                        if (!(ScsiPortReadRegisterUchar(DeviceExtension->SystemDoorBell) &
                                DAC960_SYSTEM_DOORBELL_COMMAND_COMPLETE)) {
                            return FALSE;
                        }
        
                        //
                        // Read index, status and error of completing command.
                        //
        
                        *Index = ScsiPortReadRegisterUchar(&DeviceExtension->PmailBox->CommandIdComplete);
                        *Status = ScsiPortReadRegisterUshort((PUSHORT)&DeviceExtension->PmailBox->Status);
        
                        //
                        // Dismiss interrupt and tell host mailbox is free.
                        //
        
                        Dac960EisaPciAckInterrupt(DeviceExtension);
                    }

                    break;

                case DAC960_PG_ADAPTER:
                case DAC1164_PV_ADAPTER:

                    //
                    // Check for Command Complete
                    //

                    *IntrStatus = ScsiPortReadRegisterUchar(DeviceExtension->SystemDoorBell);
              
                    //
                    // Read index, status and error of completing command.
                    //
        
                    *Index = ScsiPortReadRegisterUchar(DeviceExtension->CommandIdComplete);
                    *Status = ScsiPortReadRegisterUshort((PUSHORT)DeviceExtension->StatusBase);
        
                    if (!((*IntrStatus) & DAC960_SYSTEM_DOORBELL_COMMAND_COMPLETE))
                    {
                        return FALSE;
                    }

                    Dac960EisaPciAckInterrupt(DeviceExtension);

                    break;
            }
        }

        return TRUE;
}

BOOLEAN
Dac960Interrupt(
        IN PVOID HwDeviceExtension
)

/*++

Routine Description:

        This is the interrupt service routine for the DAC960 SCSI adapter.
        It reads the interrupt register to determine if the adapter is indeed
        the source of the interrupt and clears the interrupt at the device.

Arguments:

        HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

        TRUE if we handled the interrupt

--*/

{
        PDEVICE_EXTENSION deviceExtension = HwDeviceExtension;
        PSCSI_REQUEST_BLOCK srb, tmpsrb;
        PSCSI_REQUEST_BLOCK restartList;
        USHORT status;
        UCHAR index;
        UCHAR IntrStatus;

        //
        // Determine if the adapter is indeed the source of interrupt.
        //

        if(! Dac960CheckInterrupt(deviceExtension,
                                  &status,
                                  &index,&IntrStatus)) {

                if ((deviceExtension->AdapterType == DAC960_PG_ADAPTER) ||
                    (deviceExtension->AdapterType == DAC1164_PV_ADAPTER))
                {
                    if (IntrStatus & 0x02) {
                        DebugPrint((dac960nt_dbg, "PG/PV Spurious interrupt. bit 2 set.\n"));
                        ScsiPortWriteRegisterUchar(deviceExtension->SystemDoorBell,0x02);

                        return TRUE;
                    }
                }
                return FALSE;
        }

        //
        // Get SRB.
        //

        srb = deviceExtension->ActiveRequests[index];

        if (!srb) {
                DebugPrint((dac960nt_dbg, "Dac960Interrupt: No active SRB for index %x\n",
                                index));
                return TRUE;
        }

        if (status != 0) {

                //
                // Map DAC960 error to SRB status.
                //

                switch (status) {

                case DAC960_STATUS_CHECK_CONDITION:

                        if (srb->PathId == DAC960_SYSTEM_DRIVE_CHANNEL) {

                                //
                                // This request was to a system drive.
                                //

                                srb->SrbStatus = SRB_STATUS_NO_DEVICE;

                        } else {

                                PDIRECT_CDB directCdb;
                                ULONG requestSenseLength;
                                ULONG i;

                                //
                                // Get address of direct CDB packet.
                                //

                                directCdb =
                                        (PDIRECT_CDB)((PUCHAR)srb->SrbExtension +
                                        deviceExtension->MaximumSgElements * sizeof(SG_DESCRIPTOR));

                                //
                                // This request was a pass-through.
                                // Copy request sense buffer to SRB.
                                //

                                requestSenseLength =
                                        srb->SenseInfoBufferLength <
                                        directCdb->RequestSenseLength ?
                                        srb->SenseInfoBufferLength:
                                        directCdb->RequestSenseLength;

                                for (i = 0;
                                         i < requestSenseLength;
                                         i++) {

                                        ((PUCHAR)srb->SenseInfoBuffer)[i] =
                                                directCdb->RequestSenseData[i];
                                }

                                //
                                // Set statuses to indicate check condition and valid
                                // request sense information.
                                //

                                srb->SrbStatus = SRB_STATUS_ERROR | SRB_STATUS_AUTOSENSE_VALID;
                                srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
                        }

                        break;

                case DAC960_STATUS_BUSY:
                        srb->SrbStatus = SRB_STATUS_BUSY;
                        break;

                case DAC960_STATUS_SELECT_TIMEOUT:
                case DAC960_STATUS_DEVICE_TIMEOUT:
                        srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
                        break;

                case DAC960_STATUS_NOT_IMPLEMENTED:
                case DAC960_STATUS_BOUNDS_ERROR:
                        srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
                        break;

                case DAC960_STATUS_ERROR:
                case DAC960_STATUS_BAD_DATA:
                        if (srb->PathId == DAC960_SYSTEM_DRIVE_CHANNEL) 
                        {
                                if(srb->SenseInfoBufferLength) 
                                {
                                        ULONG i;
                                
                                        for (i = 0; i < srb->SenseInfoBufferLength; i++)
                                                ((PUCHAR)srb->SenseInfoBuffer)[i] = 0;
                                
                                        ((PSENSE_DATA) srb->SenseInfoBuffer)->ErrorCode = 0x70;
                                        ((PSENSE_DATA) srb->SenseInfoBuffer)->SenseKey = SCSI_SENSE_MEDIUM_ERROR;

                                        if (srb->SrbFlags & SRB_FLAGS_DATA_IN)
                                                ((PSENSE_DATA) srb->SenseInfoBuffer)->AdditionalSenseCode = 0x11;
                                
                                        srb->SrbStatus = SRB_STATUS_ERROR | SRB_STATUS_AUTOSENSE_VALID;

                                        DebugPrint((dac960nt_dbg,
                                                "DAC960: System Drive %d, cmd sts = 1, sense info returned\n",
                                                srb->TargetId));

                                } 
                                else
                                {
                                        DebugPrint((dac960nt_dbg,
                                                "DAC960: System Drive %d, cmd sts = 1, sense info length 0\n",
                                                srb->TargetId));
                                        

                                        srb->SrbStatus = SRB_STATUS_ERROR;
                                }
                        }
                        else {
                                DebugPrint((dac960nt_dbg,
                                            "DAC960: SCSI Target Id %x, cmd sts = 1\n",
                                            srb->TargetId));
                                                
                                srb->SrbStatus = SRB_STATUS_ERROR;
                        }

                        break;

                default:

                        DebugPrint((dac960nt_dbg,
                                    "DAC960: Unrecognized status %x\n",
                                    status));

                        srb->SrbStatus = SRB_STATUS_ERROR;
                
                        break;
                }

                //
                // Check for IOCTL request.
                //

                if (srb->Function == SRB_FUNCTION_IO_CONTROL) {

                        //
                        // Update status in IOCTL header.
                        //

                        ((PIOCTL_REQ_HEADER)srb->DataBuffer)->CompletionCode = status;
                        srb->SrbStatus = SRB_STATUS_SUCCESS;
                }

        } else {
                if (srb->PathId == DAC960_SYSTEM_DRIVE_CHANNEL)
                {

                    switch (deviceExtension->AdapterType)
                    {
                        case DAC960_OLD_ADAPTER:
                        case DAC960_NEW_ADAPTER:

                             if (! deviceExtension->MemoryMapEnabled)
                             {
                                Dac960SystemDriveRequest(deviceExtension, srb);
                                break;
                             }

                        case DAC960_PG_ADAPTER:
                        case DAC1164_PV_ADAPTER:

                             Dac960PGSystemDriveRequest(deviceExtension, srb);
                             break;
                    }
                }
                else
                        srb->SrbStatus = SRB_STATUS_SUCCESS;
        }

        if (srb->Function == SRB_FUNCTION_IO_CONTROL)
        {
                if (((PIOCTL_REQ_HEADER)srb->DataBuffer)->GenMailBox.Reg0 == DAC960_COMMAND_DIRECT)
                {
                        PDIRECT_CDB directCdb = (PDIRECT_CDB)
                                ((PUCHAR)srb->DataBuffer + sizeof(IOCTL_REQ_HEADER));

                        deviceExtension->DeviceList[directCdb->Channel][directCdb->TargetId] &= ~DAC960_DEVICE_BUSY;
                        DebugPrint((dac960nt_dbg, "Dac960Interrupt,IOCTL: device at ch 0x%x, tgt 0x%x, state set to 0x%x\n",
                                    directCdb->Channel, directCdb->TargetId,
                                    deviceExtension->DeviceList[directCdb->Channel][directCdb->TargetId]));
                }
        }
        else if (srb->PathId != DAC960_SYSTEM_DRIVE_CHANNEL) 
        {
                deviceExtension->DeviceList[srb->PathId][srb->TargetId] &= ~DAC960_DEVICE_BUSY;
                DebugPrint((dac960nt_dbg, "Dac960Interrupt: device at ch 0x%x, tgt 0x%x, state set to 0x%x\n",
                            srb->PathId, srb->TargetId,
                            deviceExtension->DeviceList[srb->PathId][srb->TargetId]));
        }

        //
        // Indicate this index is free.
        //

        deviceExtension->ActiveRequests[index] = NULL;

        //
        // Decrement count of outstanding adapter requests.
        //

        deviceExtension->CurrentAdapterRequests--;

        //
        // Complete request.
        //

        ScsiPortNotification(RequestComplete,
                             deviceExtension,
                             srb);

        //
        // Check to see if a new request can be sent to controller.
        //

        //
        // Start requests that timed out waiting for controller to become ready.
        //

        restartList = deviceExtension->SubmissionQueueHead;

        if (restartList != NULL)
            DebugPrint((dac960nt_dbg, "Intr: reqs in de 0x%p queue\n", deviceExtension));

        deviceExtension->SubmissionQueueHead = NULL;
        
        while (restartList) {

            //
            // Get next pending request.
            //

            tmpsrb = restartList;

            //
            // Remove request from pending queue.
            //

            restartList = tmpsrb->NextSrb;
            tmpsrb->NextSrb = NULL;

            //
            // Start request over again.
            //

            StartIo(deviceExtension, tmpsrb, FALSE);
        }

        return TRUE;

} // end Dac960Interrupt()


#ifdef WINNT_50

SCSI_ADAPTER_CONTROL_STATUS
Dac960AdapterControl(
        IN PVOID HwDeviceExtension,
        IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
        IN PVOID Parameters
)

/*++

Routine Description:

        This is the Hardware Adapter Control routine for the DAC960 SCSI adapter.

Arguments:

        HwDeviceExtension - HBA miniport driver's adapter data storage
        ControlType - control code - stop/restart codes etc.,
        Parameters - relevant i/o data buffer

Return Value:

        SUCCESS, if operation successful.

--*/

{
    PDEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_SUPPORTED_CONTROL_TYPE_LIST querySupportedControlTypes;
    ULONG control;
    BOOLEAN status;

    if (ControlType == ScsiQuerySupportedControlTypes)
    {
        querySupportedControlTypes = (PSCSI_SUPPORTED_CONTROL_TYPE_LIST) Parameters;

        DebugPrint((dac960nt_dbg, "Dac960AdapterControl: QuerySupportedControlTypes, MaxControlType 0x%x devExt 0x%p\n",
                        querySupportedControlTypes->MaxControlType, deviceExtension));

        for (control = 0; control < querySupportedControlTypes->MaxControlType; control++)
        {
            switch (control) {
                case ScsiQuerySupportedControlTypes:
                case ScsiStopAdapter:
                    querySupportedControlTypes->SupportedTypeList[control] = TRUE;
                    break;

                default:
                    querySupportedControlTypes->SupportedTypeList[control] = FALSE;
                    break;
            }
        }

        return (ScsiAdapterControlSuccess);
    }

    if (ControlType != ScsiStopAdapter)
    {
        DebugPrint((dac960nt_dbg, "Dac960AdapterControl: control type 0x%x not supported. devExt 0x%p\n",
                        ControlType, deviceExtension));

        return (ScsiAdapterControlUnsuccessful);
    }

    DebugPrint((dac960nt_dbg, "Dac960AdapterControl: #cmds outstanding 0x%x for devExt 0x%p\n",
                    deviceExtension->CurrentAdapterRequests, deviceExtension));

    //
    // ControlType is ScsiStopAdapter. Prepare controller for shutdown.
    //

    //
    // Set up Mail Box registers with FLUSH command information.
    //    

    deviceExtension->MailBox.OperationCode = DAC960_COMMAND_FLUSH;

    //
    // Disable Interrupts and issue flush command.
    //

    if (deviceExtension->AdapterInterfaceType == MicroChannel) 
    {
        //
        // Disable DMC960 Interrupts.
        //

        ScsiPortWritePortUchar(deviceExtension->BaseIoAddress + 
                               DMC960_SUBSYSTEM_CONTROL_PORT,
                               DMC960_DISABLE_INTERRUPT);
        //
        // All command IDS should be free and no data xfer.
        //
    
        //
        // Issue FLUSH command
        //
    
        status = Dac960McaSendRequestPolled(deviceExtension, 10000);
    
        DebugPrint((dac960nt_dbg,"Dac960AdapterControl: Flush Command ret status 0x%x\n", status));
    
        return (ScsiAdapterControlSuccess);
    }
    else if (deviceExtension->AdapterInterfaceType == Eisa)
    {
        //
        // Disable DAC960-EISA Interupts.
        //

        ScsiPortWritePortUchar(&((PEISA_REGISTERS)deviceExtension->BaseIoAddress)->InterruptEnable, 0);
        ScsiPortWritePortUchar(&((PEISA_REGISTERS)deviceExtension->BaseIoAddress)->SystemDoorBellEnable, 0);
    }
    else
    {
        //
        // Disable DAC960-PCI Interupts.
        //

        Dac960PciDisableInterrupt(deviceExtension);
    }

    //
    // All command IDS should be free and no data xfer.
    //

    //
    // Issue FLUSH command
    //

    status = Dac960EisaPciSendRequestPolled(deviceExtension, 10000);

    DebugPrint((dac960nt_dbg,"Dac960AdapterControl: Flush Command ret status 0x%x\n", status));

    return (ScsiAdapterControlSuccess);
}

#endif

ULONG
DriverEntry (
        IN PVOID DriverObject,
        IN PVOID Argument2
)

/*++

Routine Description:

        Installable driver initialization entry point for system.
        - It looks for DAC960P (PCI RAID Controllers) in the following order:
          DAC960P with Device ID 0x0001 ( FW 2.xx )
          DAC960P With Device ID 0x0002 ( FW 3.xx )
          DAC960PG with device ID 0x0010
        - It scans the EISA slots looking for DAC960 host adapters.
        - It scans the MCA slots looking for DAC960 Host adapters.

Arguments:

        Driver Object

Return Value:

        Status from ScsiPortInitialize()

--*/

{
        HW_INITIALIZATION_DATA hwInitializationData;
        ULONG i;
        ULONG Status1, Status2;

        //
        // Vendor ID 0x1069
        //
        UCHAR vendorId[4] = {'1', '0', '6', '9'};
        //
        // Device IDs: 0x0001 - FW 2.xx PCI Controllers
        //             0x0002 - FW 3.xx PCI Controllers
        //             0x0010 - DAC960PG PCI Controllers
        //
        UCHAR deviceId[4] = {'0', '0', '0', '1'};

        DebugPrint((dac960nt_dbg,"\nDAC960 SCSI Miniport Driver\n"));

        // Zero out structure.

        for (i=0; i<sizeof(HW_INITIALIZATION_DATA); i++)
                ((PUCHAR)&hwInitializationData)[i] = 0;

        // Set size of hwInitializationData.

        hwInitializationData.HwInitializationDataSize = sizeof(HW_INITIALIZATION_DATA);

        // Set entry points.

        hwInitializationData.HwInitialize  = Dac960Initialize;
        hwInitializationData.HwStartIo     = Dac960StartIo;
        hwInitializationData.HwInterrupt   = Dac960Interrupt;
        hwInitializationData.HwResetBus    = Dac960ResetBus;

#ifdef WINNT_50
        hwInitializationData.HwAdapterControl = Dac960AdapterControl;
#endif
        //
        // Show two access ranges - adapter registers and BIOS.
        //

        hwInitializationData.NumberOfAccessRanges = 2;

        //
        // Indicate will need physical addresses.
        //

        hwInitializationData.NeedPhysicalAddresses = TRUE;
        
#ifdef IBM_SUPPORT
        hwInitializationData.MapBuffers = TRUE;
#endif

        //
        // Indicate auto request sense is supported.
        //

        hwInitializationData.AutoRequestSense     = TRUE;
        hwInitializationData.MultipleRequestPerLu = TRUE;

        //
        // Simulate tagged queueing support to workaround problems with 
        // MultipleRequestPerLu.
        //

        hwInitializationData.TaggedQueuing = TRUE;

        //
        // Specify size of extensions.
        //

        hwInitializationData.DeviceExtensionSize = sizeof(DEVICE_EXTENSION);
        hwInitializationData.SrbExtensionSize =
        sizeof(SG_DESCRIPTOR) * MAXIMUM_SGL_DESCRIPTORS + sizeof(DIRECT_CDB);

        //
        // Set PCI ids.
        //

        hwInitializationData.DeviceId = deviceId;
        hwInitializationData.DeviceIdLength = 4;
        hwInitializationData.VendorId = vendorId;
        hwInitializationData.VendorIdLength = 4;

        //
        // Attempt PCI initialization for old DAC960 PCI (Device Id - 0001)
        // Controllers.
        //

        hwInitializationData.AdapterInterfaceType = PCIBus;
        hwInitializationData.HwFindAdapter = Dac960PciFindAdapter;

        Status1 = ScsiPortInitialize(DriverObject,
                                   Argument2,
                                   &hwInitializationData,
                                   NULL);

        DebugPrint((dac960nt_dbg, "After NT FW2x Scan, Status1 = 0x%x\n", Status1));
        //
        // Attempt PCI initialization for new DAC960 PCI (Device Id - 0002)
        // Controllers.
        //

        deviceId[3] ='2';

        Status2 = ScsiPortInitialize(DriverObject,
                                   Argument2,
                                   &hwInitializationData,
                                   NULL);

        Status1 = Status2 < Status1 ? Status2 : Status1;

        DebugPrint((dac960nt_dbg, "After NT FW3x Scan, Status1 = 0x%x\n", Status1));

        //
        // Attempt PCI initialization for DAC960PG PCI (Device Id - 0010)
        // Controllers.
        //

        deviceId[2] = '1';
        deviceId[3] = '0';

        hwInitializationData.SrbExtensionSize =
            sizeof(SG_DESCRIPTOR) * MAXIMUM_SGL_DESCRIPTORS_PG + sizeof(DIRECT_CDB);

        Status2 = ScsiPortInitialize(DriverObject,
                                   Argument2,
                                   &hwInitializationData,
                                   NULL);

        Status1 = Status2 < Status1 ? Status2 : Status1;

        DebugPrint((dac960nt_dbg, "After NT PG Scan, Status1 = 0x%x\n", Status1));

        //
        // Attempt PCI initialization for DAC1164 PVX controllers.
        //

        vendorId[0] = '1';
        vendorId[1] = '0';
        vendorId[2] = '1';
        vendorId[3] = '1';

        deviceId[0] = '1';
        deviceId[1] = '0';
        deviceId[2] = '6';
        deviceId[3] = '5';

        //
        // Set PCI ids.
        //

        hwInitializationData.DeviceId = deviceId;
        hwInitializationData.DeviceIdLength = 4;
        hwInitializationData.VendorId = vendorId;
        hwInitializationData.VendorIdLength = 4;

        hwInitializationData.HwFindAdapter = Dac960PciFindAdapter;
        hwInitializationData.SrbExtensionSize =
            sizeof(SG_DESCRIPTOR) * MAXIMUM_SGL_DESCRIPTORS_PV + sizeof(DIRECT_CDB);

        Status2 = ScsiPortInitialize(DriverObject,
                                   Argument2,
                                   &hwInitializationData,
                                   NULL);

        Status1 = Status2 < Status1 ? Status2 : Status1;

        DebugPrint((dac960nt_dbg, "After NT PVX Scan, Status1 = 0x%x\n", Status1));

        //
        // Attempt EISA initialization.
        //

        DebugPrint((dac960nt_dbg, "Scan for EISA controllers\n"));

        hwInitializationData.NumberOfAccessRanges = 2;
        slotNumber = 0;
        hwInitializationData.AdapterInterfaceType = Eisa;
        hwInitializationData.HwFindAdapter = Dac960EisaFindAdapter;

        Status2 = ScsiPortInitialize(DriverObject,
                                    Argument2,
                                    &hwInitializationData,
                                    NULL);

        DebugPrint((dac960nt_dbg, "Scan for EISA controllers status 0x%x\n", Status2));

        Status1 = Status2 < Status1 ? Status2 : Status1;

        //
        // Attempt MCA initialization.
        //

        slotNumber = 0;
        hwInitializationData.AdapterInterfaceType = MicroChannel;
        hwInitializationData.HwFindAdapter = Dac960McaFindAdapter;

        Status2 = ScsiPortInitialize(DriverObject,
                                    Argument2,
                                    &hwInitializationData,
                                    NULL);

        //
        // Return the smaller status.
        //

        return (Status2 < Status1 ? Status2 : Status1);

} // end DriverEntry()

//
// Dac960EisaPciAckInterrupt - Ack the Interrupt
// Dismiss interrupt and tell host mailbox is free.
//

void Dac960EisaPciAckInterrupt(IN PDEVICE_EXTENSION DeviceExtension)
{
    switch (DeviceExtension->AdapterType)
    {
        case DAC960_OLD_ADAPTER:
        case DAC960_NEW_ADAPTER:

            if (DeviceExtension->MemoryMapEnabled)
            {
                ScsiPortWriteRegisterUchar(DeviceExtension->SystemDoorBell,
                    ScsiPortReadRegisterUchar(DeviceExtension->SystemDoorBell));

                ScsiPortWriteRegisterUchar(DeviceExtension->LocalDoorBell,
                               DAC960_LOCAL_DOORBELL_MAILBOX_FREE);
            }
            else{
                ScsiPortWritePortUchar(DeviceExtension->SystemDoorBell,
                    ScsiPortReadPortUchar(DeviceExtension->SystemDoorBell));

                ScsiPortWritePortUchar(DeviceExtension->LocalDoorBell,
                                       DAC960_LOCAL_DOORBELL_MAILBOX_FREE);
            }

            break;

        case DAC960_PG_ADAPTER:
        case DAC1164_PV_ADAPTER:

            ScsiPortWriteRegisterUchar(DeviceExtension->SystemDoorBell,0x03);
            ScsiPortWriteRegisterUchar(DeviceExtension->LocalDoorBell,
                                       DAC960_LOCAL_DOORBELL_MAILBOX_FREE);

            break;
    }
}

//
// Dac960PciDisableInterrupt - Disables the Interrupt from the controller
//
// Description - This function disables the Interrupt from the controller,
//               which causes the controller not to Interrupt the CPU.
//               Other routines call this routine if they want to
//               poll for the command completion interrupt,without causing
//               the system Interrupt handler called. 
// Assumptions -
//      This routine is called only for PCI Controllers.
//      AdapterType field in DeviceExtension is set appropriately.
//

void
Dac960PciDisableInterrupt(IN PDEVICE_EXTENSION DeviceExtension)
{
    switch (DeviceExtension->AdapterType)
    {
        case DAC960_OLD_ADAPTER:
        case DAC960_NEW_ADAPTER:
            if (DeviceExtension->MemoryMapEnabled)
                ScsiPortWriteRegisterUchar(DeviceExtension->InterruptControl, 0);
            else
                ScsiPortWritePortUchar(DeviceExtension->InterruptControl, 0);

            return;

        case DAC960_PG_ADAPTER:
            ScsiPortWriteRegisterUchar(DeviceExtension->InterruptControl,DAC960PG_INTDISABLE);

            return;

        case DAC1164_PV_ADAPTER:
            ScsiPortWriteRegisterUchar(DeviceExtension->InterruptControl,DAC1164PV_INTDISABLE);

            return;

        default:
            return;
    }
}

//
// Dac960PciEnableInterrupt - Enables the Interrupt from the controller
//
// Description - This function enables the Interrupt from the controller,
//               which causes the controller to Interrupt the CPU.This
//               is called only for PCI Controllers.
// Assumptions -
//      AdapterType field in DeviceExtension is set appropriately.
//
//

void
Dac960PciEnableInterrupt(IN PDEVICE_EXTENSION DeviceExtension)
{
    switch (DeviceExtension->AdapterType)
    {
        case DAC960_OLD_ADAPTER:
        case DAC960_NEW_ADAPTER:
            if (DeviceExtension->MemoryMapEnabled)
                ScsiPortWriteRegisterUchar(DeviceExtension->InterruptControl, 1);
            else
                ScsiPortWritePortUchar(DeviceExtension->InterruptControl, 1);

            return;

        case DAC960_PG_ADAPTER:
            ScsiPortWriteRegisterUchar(DeviceExtension->InterruptControl,DAC960PG_INTENABLE);

            return;

        case DAC1164_PV_ADAPTER:
            ScsiPortWriteRegisterUchar(DeviceExtension->InterruptControl,DAC1164PV_INTENABLE);

            return;

        default:
            return;
    }
}

//
// DacCheckForAdapterReady - This function checks whether given adapter
//                           described by DeviceExtension parameter is
//                           initialized and ready to accept commands.
// Assumptions -
//      AdapterType Field in DeviceExtension is set appropriately
// Arguments -
//              DeviceExtension - Adapter state information.
// Return Value -
//      TRUE - Adapter is initialized and ready to accept commands
//      FALSE - Adapter is in installation abort state.
//

BOOLEAN DacCheckForAdapterReady(IN PDEVICE_EXTENSION DeviceExtension)
{
    BOOLEAN status;

    switch (DeviceExtension->AdapterType)
    {
        case DAC960_OLD_ADAPTER:
        case DAC960_NEW_ADAPTER:

            if (! DeviceExtension->MemoryMapEnabled)
            {
                status = DacEisaPciAdapterReady(DeviceExtension);
                return status;
            }

        case DAC960_PG_ADAPTER:
        case DAC1164_PV_ADAPTER:

            status = DacPciPGAdapterReady(DeviceExtension);
            break;

        default: // This case should not occur

            status = FALSE;
            break;
    }

    return status;
}


//
// DacEisaPciAdapterReady - checks whether controller is initialized and
//                          ready to accept commands or not.
// Description - This function checks for the Installation abort. This
//               is called for adapters which use I/O space for mailbox
//               access.
// Arguments:
//              DeviceExtension - Adapter state information.
// Return Value:
//      TRUE if Adapter is initialized and ready to accept commands.
//      FALSE if Adapter is in Installation Abort state.

BOOLEAN DacEisaPciAdapterReady(IN PDEVICE_EXTENSION DeviceExtension)
{
    //
    // claim submission semaphore
    //

    if (ScsiPortReadPortUchar(DeviceExtension->LocalDoorBell) &
        DAC960_LOCAL_DOORBELL_SUBMIT_BUSY){
        //
        // Clear any bits set in system doorbell and tell controller
        // that the mailbox is free.
        //

        Dac960EisaPciAckInterrupt(DeviceExtension);

        //
        // check semaphore again
        //

        if (ScsiPortReadPortUchar(DeviceExtension->LocalDoorBell) &
                DAC960_LOCAL_DOORBELL_SUBMIT_BUSY){
            return FALSE;
        }
    }

    return TRUE;
}

//
// DacPciPGAdapterReady - checks whether controller is initialized and
//                          ready to accept commands or not.
// Description - This function checks for the Installation abort. This
//               is called for adapters which use Memory space for mailbox
//               access.
//
// Arguments:
//              DeviceExtension - Adapter state information.
// Return Value:
//      TRUE if Adapter is initialized and ready to accept commands.
//      FALSE if Adapter is in Installation Abort state.
//

BOOLEAN DacPciPGAdapterReady(IN PDEVICE_EXTENSION DeviceExtension)
{
    //
    // claim submission semaphore
    //

    if (DeviceExtension->AdapterType == DAC1164_PV_ADAPTER)
    {
        if (!(ScsiPortReadRegisterUchar(DeviceExtension->LocalDoorBell) &
                DAC960_LOCAL_DOORBELL_SUBMIT_BUSY))
        {
    
            //
            // Clear any bits set in system doorbell and tell controller
            // that the mailbox is free.
            //
    
            Dac960EisaPciAckInterrupt(DeviceExtension);
    
            //
            // check semaphore again
            //
    
            if (!(ScsiPortReadRegisterUchar(DeviceExtension->LocalDoorBell) &
                    DAC960_LOCAL_DOORBELL_SUBMIT_BUSY))
            {
                return FALSE;
            }
        }
    }
    else
    {
        if (ScsiPortReadRegisterUchar(DeviceExtension->LocalDoorBell) &
                DAC960_LOCAL_DOORBELL_SUBMIT_BUSY)
        {
    
            //
            // Clear any bits set in system doorbell and tell controller
            // that the mailbox is free.
            //
    
            Dac960EisaPciAckInterrupt(DeviceExtension);
    
            //
            // check semaphore again
            //
    
            if (ScsiPortReadRegisterUchar(DeviceExtension->LocalDoorBell) &
                    DAC960_LOCAL_DOORBELL_SUBMIT_BUSY){
    
                return FALSE;
            }
        }
    }

    return TRUE;
}

//
// DacPollForCompletion - This function waits for the Command to be
//                        completed by polling on system door bell register.
// Assumptions:
//      Controller Interrupts are turned off
// Arguments -
//      DeviceExtension - Adapter State Information
//
// Return Value -
//      TRUE - Received the Command Completion Interrupt.
//      FALSE - Timed Out on polling for interrupt.
//

BOOLEAN DacPollForCompletion(
        IN PDEVICE_EXTENSION DeviceExtension,
        IN ULONG TimeOutValue
)
{
    BOOLEAN status;

    switch (DeviceExtension->AdapterType)
    {
        case DAC960_OLD_ADAPTER:
        case DAC960_NEW_ADAPTER:

            if (! DeviceExtension->MemoryMapEnabled)
            {
                status = Dac960EisaPciPollForCompletion(DeviceExtension,TimeOutValue);

                break;
            }

        case DAC960_PG_ADAPTER:
        case DAC1164_PV_ADAPTER:

            status = Dac960PciPGPollForCompletion(DeviceExtension,TimeOutValue);

            break;

        default: // This case should not occur
            status = FALSE;

            break;
    }

    return status;
}

//
// Dac960EisaPciPollForCompletion - Routine for Polling for Interrupts
//                                  for Controllers using I/O Base.
// Description -
//      This routine waits for the command completion interrupt from
//      a controller which uses I/O Base for mailbox access.
//
// Assumption - This is called during Init Time after sending a command
//              to the controller.
//
// Arguments -
//      DeviceExtension - Adapter State information
//      TimeOutValue    - how long to wait.
//

BOOLEAN Dac960EisaPciPollForCompletion(
        IN PDEVICE_EXTENSION DeviceExtension,
        IN ULONG TimeOutValue)
{
    ULONG i;

    for (i = 0; i < TimeOutValue; i++)
    {
        if (ScsiPortReadPortUchar(DeviceExtension->SystemDoorBell) &
                                  DAC960_SYSTEM_DOORBELL_COMMAND_COMPLETE) {
             //
             // Update Status field
             //

             DeviceExtension->MailBox.Status = 
                 ScsiPortReadPortUshort(&DeviceExtension->PmailBox->Status);
                       
             break;
        } else {

            ScsiPortStallExecution(50);
        }
    }
        
    //
    // Check for timeout.
    //

    if (i == TimeOutValue) {
        DebugPrint((dac960nt_dbg,
                   "DAC960: Request: %x timed out\n", 
                   DeviceExtension->MailBox.OperationCode));

        return FALSE;
    }

    return TRUE;
}

//
// Dac960PciPGPollForCompletion - Routine for Polling for Interrupts
//                                  for Controllers using Memory Base.
// Description -
//      This routine waits for the command completion interrupt from
//      a controller which uses Memory Base for mailbox access.
//
// Assumption - This is called during Init Time after sending a command
//              to the controller.
//
// Arguments -
//      DeviceExtension - Adapter State information
//      TimeOutValue    - how long to wait.
//
BOOLEAN Dac960PciPGPollForCompletion(
        IN PDEVICE_EXTENSION DeviceExtension,
        IN ULONG TimeOutValue)
{
    ULONG i;

    for (i = 0; i < TimeOutValue; i++)
    {
        if (ScsiPortReadRegisterUchar(DeviceExtension->SystemDoorBell) &
                                  DAC960_SYSTEM_DOORBELL_COMMAND_COMPLETE) {
             //
             // Update Status field
             //

             DeviceExtension->MailBox.Status = 
                 ScsiPortReadRegisterUshort((PUSHORT)DeviceExtension->StatusBase);
                       
             break;
        } else {

             ScsiPortStallExecution(50);
        }
    }
        
    //
    // Check for timeout.
    //

    if (i == TimeOutValue) {
        DebugPrint((dac960nt_dbg, "PGPollForCompletion: Request: %x timed out\n",
               DeviceExtension->MailBox.OperationCode));

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac960\dmc960nt.h ===
/*++

Copyright (c) 1994 Mylex Corporation

Module Name:

    dmc960nt.h

Abstract:

    The module defines the structures, defines for DMC960 Adapter.

Author:

    Mouli (mouli@mylex.com)

Environment:

    Kernel mode Only

Revision History:

--*/


#define MAXIMUM_MCA_SLOTS  0x08

//
// DMC960 Adapter IDs
//

#define MAGPIE_ADAPTER_ID       0x8f6c		// Mylex Version
#define HUMMINGBIRD_ADAPTER_ID  0x8f82		// Pass Play Option
#define PASSPLAY_ADAPTER_ID     0x8fbb		// Pass Play

//
// DMC960 Control Registers definitions.
//

#define DMC960_ATTENTION_PORT           0x04
#define DMC960_SUBSYSTEM_CONTROL_PORT   0x05
#define DMC960_COMMAND_STATUS_BUSY_PORT 0x07 

//
// DMC960 Interrupt Valid bit (Bit 1 in Command Status Busy Port).
//
#define DMC960_INTERRUPT_VALID          0x02

//
// DMC960 Interrupt Control bit definitions (Set in Subsytem Control Port).
//

#define DMC960_DISABLE_INTERRUPT        0x02
#define DMC960_ENABLE_INTERRUPT         0x03
#define DMC960_CLEAR_INTERRUPT_ON_READ  0x40

//
// DMC960 Command/status Handshaking register values.
//

#define DMC960_SUBMIT_COMMAND           0xd0
#define DMC960_ACKNOWLEDGE_STATUS       0xd1

//
// Define Option Select Register Structures.
//

typedef struct _POS_DATA {
    USHORT AdapterId;
    UCHAR OptionData1;
    UCHAR OptionData2;
    UCHAR OptionData3;
    UCHAR OptionData4;
} POS_DATA, *PPOS_DATA;

//
// DAC960 MCA register definition
//

typedef struct _MCA_REGISTERS {
    UCHAR NotUsed1[4];              // IoBase + 0x00
    UCHAR AttentionPort;            // IoBase + 0x04
    UCHAR SubsystemControlPort;     // IoBase + 0x05
    UCHAR NotUsed2;                 // IoBase + 0x06
    UCHAR CommandStatusBusyPort;    // IoBase + 0x07
} MCA_REGISTERS, *PMCA_REGISTERS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac960\raidapi.h ===
/*****************************************************************************
*									     *
*	          COPYRIGHT (C) Mylex Corporation 1992-1994		     *
*                                                                            *
*    This software is furnished under a license and may be used and copied   *
*    only in accordance with the terms and conditions of such license        *
*    and with inclusion of the above copyright notice. This software or nay  *
*    other copies thereof may not be provided or otherwise made available to *
*    any other person. No title to and ownership of the software is hereby   *
*    transferred. 						             *
* 								             *
*    The information in this software is subject to change without notices   *
*    and should not be construed as a commitment by Mylex Corporation        *
*****************************************************************************/

/****************************************************************************
*                                                                           *
*    Name: RAIDAPI.H							    *
*                                                                           *
*    Description: Structure Definitions Used by Driver and Utils            *
*                                                                           *
*    Envrionment:  							    *
*                                                                           *
*    Operating System: Netware 3.x and 4.x,OS/2 2.x,Win NT 3.5,Unixware 2.0 *
*                                                                           *
*   ---------------    Revision History  ------------------------           *
*                                                                           *
*    Date    Author                   Change                                *
*    ----    -----        -------------------------------------             *
*   11/04/94 Subra.Hegde      Added few more BUS Definitions                *
*   01/06/95 Subra.Hegde      Reserved1 field in SYS_RESOURCES changed to   *
*                             Slot.                                         *
*   05/10/95 Mouli            Re-defined DRV_IOCTL structure                *
*                             Removed IO_MBOX, HBA_MBOX structure defs      *
*   05/18/95 Subra            Added DRIVER_VERSION structure                *
****************************************************************************/

#ifndef _RAIDAPI_H
#define _RAIDAPI_H


#ifndef UCHAR
#define UCHAR   unsigned  char
#endif

#ifndef USHORT
#define USHORT   unsigned  short
#endif

#ifndef ULONG
#define ULONG   unsigned  long
#endif

#ifndef VOID
#define VOID    void
#endif

/*
 * Adapter Interface Type
 */

#define	AI_INTERNAL	 0x00
#define	AI_ISA_BUS	 0x01	/* ISA Bus Type           */
#define	AI_EISA_BUS	 0x02	/* EISA Bus Type          */
#define	AI_uCHNL_BUS	 0x03	/* MicroChannel Bus Type  */
#define	AI_TURBO_BUS	 0x04	/* Turbo Channel Bus Type */
#define	AI_PCI_BUS	 0x05	/* PCI Bus Type           */
#define AI_VME_BUS	 0x06	/* VME Bus Type           */
#define AI_NU_BUS	 0x07	/* NuBus Type             */
#define AI_PCMCIA_BUS    0x08	/* PCMCIA Bus Type        */
#define	AI_C_BUS	 0x09	/* C Bus                  */
#define AI_MPI_BUS	 0x0A	/* MPI Bus                */
#define AI_MPSA_BUS	 0x0B	/* MPSA Bus               */
#define AI_SCSI2SCSI_BUS 0x0C   /* SCSI to SCSI Bus       */

/*
 * Interrupt Type
 */

#define IRQ_TYPE_EDGE   0x00    /* Irq is Edge Type  */
#define IRQ_TYPE_LEVEL  0x01    /* Irq is Level Type */

/*
 * definitions to identify new/old DAC960 adapters
 */

#define DAC960_OLD_ADAPTER 0x00 /* DAC960 with Fw Ver < 3.x  */
#define DAC960_NEW_ADAPTER 0x01 /* DAC960 with Fw Ver >= 3.x */

/* 
 *  All structure definitions are packed on 1-byte boundary.
 */

#pragma pack(1)

/* 
 *  Generic Mail Box Registers Structure Format
 */

typedef struct _HBA_GENERIC_MBOX {

    UCHAR   Reg0;                /* HBA Mail Box Register 0 */
    UCHAR   Reg1;                /* HBA Mail Box Register 1 */
    UCHAR   Reg2;                /* HBA Mail Box Register 2 */
    UCHAR   Reg3;                /* HBA Mail Box Register 3 */
    UCHAR   Reg4;                /* HBA Mail Box Register 4 */
    UCHAR   Reg5;                /* HBA Mail Box Register 5 */
    UCHAR   Reg6;                /* HBA Mail Box Register 6 */
    UCHAR   Reg7;                /* HBA Mail Box Register 7 */
    UCHAR   Reg8;                /* HBA Mail Box Register 8 */
    UCHAR   Reg9;                /* HBA Mail Box Register 9 */
    UCHAR   RegA;                /* HBA Mail Box Register A */
    UCHAR   RegB;                /* HBA Mail Box Register B */
    UCHAR   RegC;                /* HBA Mail Box Register C */
    UCHAR   RegD;                /* HBA Mail Box Register D */
    UCHAR   RegE;                /* HBA Mail Box Register E */
    UCHAR   RegF;                /* HBA Mail Box Register F */

} HBA_GENERIC_MBOX, *PHBA_GENERIC_MBOX;

/*
 * Host Bus Adapter Embedded Software Version Control Information
 */

typedef struct _VERSION_CONTROL {

    UCHAR    MinorFirmwareRevision;      /* HBA Firmware Minor Version No */ 
    UCHAR    MajorFirmwareRevision;      /* HBA Firmware Major Version No */ 
    UCHAR    MinorBIOSRevision;          /* HBA BIOS Minor Version No     */
    UCHAR    MajorBIOSRevision;          /* HBA BIOS Major Version No     */
    ULONG    Reserved;                   /* Reserved                      */

} VERSION_CONTROL, *PVERSION_CONTROL;

/*
 * System Resources used by Host Bus Adapter
 */

typedef struct _SYSTEM_RESOURCES {

    UCHAR  BusInterface;      /* HBA System Bus Interface Type    */
    UCHAR  BusNumber;         /* System Bus No, HBA is sitting on */
    UCHAR  IrqVector;         /* HBA Interrupt Vector No          */
    UCHAR  IrqType;           /* HBA Irq Type : Edge/Level        */
    UCHAR  Slot;              /* HBA Slot Number                  */
    UCHAR  Reserved2;         /* Reserved                         */
    ULONG  IoAddress;         /* HBA IO Base Address              */
                              /* EISA : 0xzC80                    */
                              /* PCI: Read_Config_word(Register 0x10) & 0xff80*/
    ULONG  MemAddress;        /* HBA Memory Base Address          */
    ULONG_PTR  BiosAddress;   /* HBA BIOS Address (if enabled)    */ 
    ULONG  Reserved3;         /* Reserved                         */

} SYSTEM_RESOURCES, *PSYSTEM_RESOURCES;

/*
 * Host Bus Adapter Features
 */

typedef struct _ADAPTER_FEATURES {

    UCHAR  Model;             /* HBA Family Model                */
    UCHAR  SubModel;          /* HBA Sub Model                   */
    UCHAR  MaxSysDrv;         /* Maximum System Drives           */
    UCHAR  MaxTgt;            /* Maximum Targets per Channel     */
    UCHAR  MaxChn;            /* Maximum Channels per Adapter    */
    UCHAR  Reserved1;         /* Reserved                        */ 
    UCHAR  Reserved2;         /* Reserved                        */
    UCHAR  AdapterType;       /* Controller type(0,1)            */
    UCHAR  PktFormat;         /* IOCTL packet format(0)          */
    ULONG  CacheSize;         /* HBA Cache Size In  Mega Bytes   */
    ULONG  OemCode;           /* HBA OEM Identifier Code         */
    ULONG  Reserved3;         /* Reserved                        */

} ADAPTER_FEATURES, *PADAPTER_FEATUTRES;

typedef struct _ADAPTER_INFO {

    UCHAR               AdapterIndex;  /* Logical Adapter Index  */
    ADAPTER_FEATURES    AdpFeatures;    
    SYSTEM_RESOURCES    SysResources;
    VERSION_CONTROL     VerControl;
    UCHAR               Reserved[12];

} ADAPTER_INFO, *PADAPTER_INFO;

/*
 *   Driver IOCTL Support Stuff.
 */

/*
 *  The DAC960 controller specific IOCTL commands
 */
#define DACDIO			0x44414300	/* DAC960 ioctls       */
#define DAC_DIODCDB      	(DACDIO|2)	/* DAC960 direct cdb   */
#define DAC_DIODCMD      	(DACDIO|3)	/* DAC960 direct cmd   */

/*
 * DAC960 driver signature
 */

#define DRV_SIGNATURE  0x4D594C58    /* MYLX */

/*
 * Data Direction control defs
 */

#define DATA_XFER_NONE 0 
#define DATA_XFER_IN   1
#define DATA_XFER_OUT  2

/*
 * Driver IoControl Request Format
 */

typedef struct _DRV_IOCTL {

    ULONG     Signature;        /* Driver would look for this     */
    ULONG     ControlCode;      /* IOCTL Control Code             */     
    VOID      *IoctlBuffer;     /* IOCTL Specific input buffer    */
    ULONG     IoctlBufferLen;   /* ioctl buffer length            */
    VOID      *DataBufferAddr;  /* User Virtual Buffer Address    */
    ULONG     DataBufferLen;    /* Data Buffer Length             */
    ULONG     Reserved1;        /* Reserved for future use        */
    ULONG     Reserved2;        /* Reserved for future use        */
    UCHAR     AdapterIndex;     /* Logical Adapter Index          */
    UCHAR     DataDirection;    /* Bytes xferred out by driver    */ 
    UCHAR     TimeOutValue;     /* Time out value - not used      */
    UCHAR     Reserved3;        /* Reserved for future use        */
    USHORT    DriverErrorCode;  /* Driver Returned Error Code     */
    USHORT    CompletionCode;   /* DAC960 command completion code */

} DRV_IOCTL, *PDRV_IOCTL;

/*
 * Driver Version Number format - all fields in hex 
 */
typedef struct _DRIVER_VERSION{

    UCHAR    DriverMajorVersion; /* Major version number */
    UCHAR    DriverMinorVersion; /* Minor version number */
    UCHAR    Month;              /* Driver Build - Month */
    UCHAR    Date;               /* Driver Build - Date  */
    UCHAR    Year;               /* Driver Build - Year  */
    UCHAR    Reserved[3];

} DRIVER_VERSION,*PDRIVER_VERSION;

#pragma pack()

/*
 * IOCTL Codes for internal driver requests
 */ 

#define MIOC_ADP_INFO	    0xA0  /* Get Adapter information */
#define MIOC_DRIVER_VERSION 0xA1  /* Get Driver Version      */

/*
 * Error Codes returned by Driver
 */

#define	NOMORE_ADAPTERS		0x0001    /* wiil be made obsolete */
#define INVALID_COMMANDCODE     0x0201    /* will be made obsolete */
#define INVALID_ARGUMENT        0x0202    /* wiil be made obsolete */

/*
 * Driver Error Code Values
 */

#define DAC_IOCTL_SUCCESS                  0x0000
#define DAC_IOCTL_INVALID_ADAPTER_NUMBER   0x0001
#define DAC_IOCTL_INVALID_ARGUMENT         0x0002
#define DAC_IOCTL_UNSUPPORTED_REQUEST      0x0003
#define DAC_IOCTL_RESOURCE_ALLOC_FAILURE   0x0004
#define DAC_IOCTL_INTERNAL_XFER_ERROR      0x0005

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac960\d960api.h ===
#include "ntddscsi.h"
#include "raidapi.h"

//
// Function prototype declarations
//

VOID
SendCdbDirectMemoryMapped(
    IN PDEVICE_EXTENSION DeviceExtension
);

BOOLEAN
MarkNonDiskDeviceBusy(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN UCHAR ChannelId,
    IN UCHAR TargetId
);

BOOLEAN
SubmitRequest(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
);

BOOLEAN
SubmitCdbDirect(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
);

UCHAR
SendIoctlDcmdRequest(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
);

UCHAR
SendIoctlCdbDirect(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
);

VOID
SetupAdapterInfo(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
);

VOID
SetupDriverVersionInfo(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
);

#define DRIVER_REVISION   0x0417
#define DRIVER_BUILD_DATE 0x00113098

typedef struct _IOCTL_REQ_HEADER {

	SRB_IO_CONTROL   SrbIoctl;
	UCHAR            Unused1[2];
	USHORT           DriverErrorCode;
	USHORT           CompletionCode;
	UCHAR            Unused2[10];
	HBA_GENERIC_MBOX GenMailBox;

} IOCTL_REQ_HEADER, *PIOCTL_REQ_HEADER;

#define MYLEX_IOCTL_SIGNATURE	"MYLEXIOC"

ULONG Dac960PciPGFindAdapter(
	IN PVOID HwDeviceExtension,
	IN PVOID Context,
	IN PVOID BusInformation,
	IN PCHAR ArgumentString,
	IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
	OUT PBOOLEAN Again
);

ULONG
Dac960PciFindAdapterScanMethod(
	IN PVOID HwDeviceExtension,
	IN PVOID Context,
	IN PVOID BusInformation,
	IN PCHAR ArgumentString,
	IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
	OUT PBOOLEAN Again
);

BOOLEAN
FindPciControllerScanMethod(
    IN PVOID  DeviceExtension,
    IN USHORT VendorID,
    IN USHORT DeviceID,
    IN USHORT SubVendorID,
    IN USHORT SubSystemID,
    IN OUT PULONG FunctionNumber,
    IN OUT PULONG DeviceNumber,
    IN ULONG  BusNumber,
    OUT PBOOLEAN LastSlot,
    OUT PULONG MemoryAddress,
    OUT PUCHAR IrqNumber
);

void Dac960EisaPciAckInterrupt(
	IN PDEVICE_EXTENSION DeviceExtension
);

void Dac960PciDisableInterrupt(
	IN PDEVICE_EXTENSION DeviceExtension
);

void Dac960PciEnableInterrupt(
	IN PDEVICE_EXTENSION DeviceExtension
);


BOOLEAN DacCheckForAdapterReady(
	IN PDEVICE_EXTENSION DeviceExtension
);

BOOLEAN DacEisaPciAdapterReady(
	IN PDEVICE_EXTENSION DeviceExtension
);


BOOLEAN DacPciPGAdapterReady(
	IN PDEVICE_EXTENSION DeviceExtension
);

BOOLEAN DacPollForCompletion(
	IN PDEVICE_EXTENSION DeviceExtension,
	IN ULONG TimeOutValue
);

BOOLEAN Dac960PciPGPollForCompletion(
	IN PDEVICE_EXTENSION DeviceExtension,
	IN ULONG TimeOutValue
);

BOOLEAN Dac960EisaPciPollForCompletion(
	IN PDEVICE_EXTENSION DeviceExtension,
	IN ULONG TimeOutValue
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac960\dacioctl.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Dacioctl.c

Abstract:

    This module provides support for DAC960 configuration IOCTls.

Author:

    Mouli (mouli@mylex.com)

Environment:

    kernel mode only

Revision History:

--*/

#include "miniport.h"
#include "Dmc960Nt.h"
#include "Dac960Nt.h"
#include "d960api.h"

BOOLEAN
SubmitRequest(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
);

BOOLEAN
SubmitCdbDirect(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
);

BOOLEAN
IsAdapterReady(
    IN PDEVICE_EXTENSION DeviceExtension
);

VOID
SendRequest(
    IN PDEVICE_EXTENSION DeviceExtension
);

VOID
SendCdbDirect(
    IN PDEVICE_EXTENSION DeviceExtension
);

UCHAR
SendIoctlDcmdRequest(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
)

/*++

Routine Description:

        Build and submit IOCTL Request-DAC960(Non-DCDB) command to DAC960.

Arguments:

        DeviceExtension - Adapter state.
        SRB - System request.

Return Value:

        0 if command was started
        1 if host adapter/device is busy
        2 if driver could not map request buffer

--*/

{
    ULONG physicalAddress;
    PIOCTL_REQ_HEADER IoctlReqHeader;
    ULONG i;
    UCHAR busyCurrentIndex;

    //
    // Determine if adapter can accept new request.
    //

    if(!IsAdapterReady(DeviceExtension)) {
        return (1);
    }

    //
    // Check that next slot is vacant.
    //

    if (DeviceExtension->ActiveRequests[DeviceExtension->CurrentIndex]) {

        //
        // Collision occurred.
        //

        busyCurrentIndex = DeviceExtension->CurrentIndex++;

        do {
            if (! DeviceExtension->ActiveRequests[DeviceExtension->CurrentIndex]) {
                 break;
            }
        } while (++DeviceExtension->CurrentIndex != busyCurrentIndex) ;

        if (DeviceExtension->CurrentIndex == busyCurrentIndex) {

            //
            // We should never encounter this condition.
            //

            DebugPrint((0,
                       "DAC960: SendIoctlDcmdRequest-Collision in active request array\n"));

            return (1);
        }
    }

    IoctlReqHeader = (PIOCTL_REQ_HEADER) Srb->DataBuffer;

    physicalAddress =
            ScsiPortConvertPhysicalAddressToUlong(
            ScsiPortGetPhysicalAddress(DeviceExtension,
                                       Srb,
                                       ((PUCHAR)Srb->DataBuffer +
                                       sizeof(IOCTL_REQ_HEADER)),
                                       &i));

    //
    // The buffer passed in may not be physically contiguous.
    //

    if (i < Srb->DataTransferLength - sizeof(IOCTL_REQ_HEADER)) {
        DebugPrint((0,
                   "Dac960: DCMD IOCTL buffer is not contiguous\n"));
        return (2);
    }

    //
    // Write physical address in mailbox.
    //

    DeviceExtension->MailBox.PhysicalAddress = physicalAddress;

    //
    // Write command in mailbox.
    //

    DeviceExtension->MailBox.OperationCode = 
                           IoctlReqHeader->GenMailBox.Reg0;

    //
    // Write request in mailbox.
    //

    DeviceExtension->MailBox.CommandIdSubmit = 
                           DeviceExtension->CurrentIndex;

    //
    // Write Mail Box Registers 2 and 3.
    //

    DeviceExtension->MailBox.BlockCount = (USHORT)
                            (IoctlReqHeader->GenMailBox.Reg2 |
                            (IoctlReqHeader->GenMailBox.Reg3 << 8));

    //
    // Write Mail Box Registers 4, 5 and 6.
    //

    DeviceExtension->MailBox.BlockNumber[0] = 
                           IoctlReqHeader->GenMailBox.Reg4;

    DeviceExtension->MailBox.BlockNumber[1] = 
                           IoctlReqHeader->GenMailBox.Reg5;

    DeviceExtension->MailBox.BlockNumber[2] = 
                           IoctlReqHeader->GenMailBox.Reg6;

    //
    // Write Mail Box Register 7.
    //

    DeviceExtension->MailBox.DriveNumber = 
                           IoctlReqHeader->GenMailBox.Reg7;

    //
    // Write Mail Box Register C.
    //

    DeviceExtension->MailBox.ScatterGatherCount =
                           IoctlReqHeader->GenMailBox.RegC;

    //
    // Start writing mailbox to controller.
    //

    SendRequest(DeviceExtension);

    return (0);

} // SendIoctlDcmdRequest()


UCHAR
SendIoctlCdbDirect(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
)

/*++

Routine Description:

        Send IOCTL Request-CDB directly to device.

Arguments:

        DeviceExtension - Adapter state.
        SRB - System request.

Return Value:

        0 if command was started
        1 if host adapter/device is busy
        2 if driver could not map request buffer

--*/

{
    ULONG physicalAddress;
    PDIRECT_CDB directCdb;
    PIOCTL_REQ_HEADER IoctlReqHeader;
    ULONG i;
    UCHAR busyCurrentIndex;

    //
    // Determine if adapter can accept new request.
    //

    if(!IsAdapterReady(DeviceExtension)) {
        return (1);
    }

    //
    // Check that next slot is vacant.
    //

    if (DeviceExtension->ActiveRequests[DeviceExtension->CurrentIndex]) {

        //
        // Collision occurred.
        //

        busyCurrentIndex = DeviceExtension->CurrentIndex++;

        do {
            if (! DeviceExtension->ActiveRequests[DeviceExtension->CurrentIndex]) {
                 break;
            }
        } while (++DeviceExtension->CurrentIndex != busyCurrentIndex) ;

        if (DeviceExtension->CurrentIndex == busyCurrentIndex) {

            //
            // We should never encounter this condition.
            //

            DebugPrint((0,
                       "DAC960: SendIoctlCdbDirect-Collision in active request array\n"));

            return (1);
        }
    }

    IoctlReqHeader = (PIOCTL_REQ_HEADER) Srb->DataBuffer;

    directCdb =
        (PDIRECT_CDB)((PUCHAR)Srb->DataBuffer + sizeof(IOCTL_REQ_HEADER));

    //
    // Get address of data buffer offset.
    //

    physicalAddress =
            ScsiPortConvertPhysicalAddressToUlong(
            ScsiPortGetPhysicalAddress(DeviceExtension,
                                       Srb,
                                       ((PUCHAR)Srb->DataBuffer +
                                       sizeof(IOCTL_REQ_HEADER) +
                                       sizeof(DIRECT_CDB)),
                                       &i));

    //
    // The buffer passed in may not be physically contiguous.
    //

    if (i < Srb->DataTransferLength -
          (sizeof(IOCTL_REQ_HEADER) + sizeof(DIRECT_CDB))) {
        DebugPrint((0,
                   "Dac960: DCDB IOCTL buffer is not contiguous\n"));
        return (2);
    }

    //
    // Check if this device is busy
    //

    if (! MarkNonDiskDeviceBusy(DeviceExtension, directCdb->Channel, directCdb->TargetId))
    	return (1);

    directCdb->DataBufferAddress = physicalAddress;

    if (directCdb->DataTransferLength == 0) {
    
        //
        // mask off data xfer in/out bits
        //

        directCdb->CommandControl &= ~(DAC960_CONTROL_DATA_IN |
                                       DAC960_CONTROL_DATA_OUT);
    }

    //
    // Disable Early-status on command bit
    //

    directCdb->CommandControl &= 0xfb;

    //
    // Get physical address of direct CDB packet.
    //

    physicalAddress =
        ScsiPortConvertPhysicalAddressToUlong(
            ScsiPortGetPhysicalAddress(DeviceExtension,
                                       Srb,
                                       directCdb,
                                       &i));

    //
    // Write physical address in mailbox.
    //

    DeviceExtension->MailBox.PhysicalAddress = physicalAddress;

    //
    // Write command in mailbox.
    //

    DeviceExtension->MailBox.OperationCode = 
                           IoctlReqHeader->GenMailBox.Reg0;

    //
    // Write request id in mailbox.
    //

    DeviceExtension->MailBox.CommandIdSubmit = 
                           DeviceExtension->CurrentIndex;

    //
    // Start writing mailbox to controller.
    //

    SendCdbDirect(DeviceExtension);

    DebugPrint((0, "SendIoctlCdbDirect: sent cmd to Device at ch 0x%x, tgt 0x%x\n", directCdb->Channel, directCdb->TargetId));

    return(0);

} // SendIoctlCdbDirect()

VOID
SetupAdapterInfo(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
)

/*++

Routine Description:

        Copy Adapter Information  to Application Buffer.

Arguments:

        DeviceExtension - Adapter state.
        SRB - System request.

Return Value:

        None.

--*/

{
    PADAPTER_INFO   AdpInfo;

    AdpInfo = (PADAPTER_INFO)((PUCHAR) Srb->DataBuffer +
                               sizeof(IOCTL_REQ_HEADER));

    //
    // Fill in Adapter Features Information.
    //

    if (DeviceExtension->AdapterInterfaceType == MicroChannel) {

        AdpInfo->AdpFeatures.Model = (UCHAR) DeviceExtension->PosData.AdapterId;
        AdpInfo->AdpFeatures.SubModel = DeviceExtension->PosData.OptionData3;
    }
    else {

        AdpInfo->AdpFeatures.Model = 0;
        AdpInfo->AdpFeatures.SubModel = 0;
    }

    if (DeviceExtension->AdapterType == DAC960_OLD_ADAPTER)
    {
        AdpInfo->AdpFeatures.MaxSysDrv = 8;

        if (AdpInfo->AdpFeatures.MaxChn == 5)
            AdpInfo->AdpFeatures.MaxTgt = 4;
        else
            AdpInfo->AdpFeatures.MaxTgt = 7;
    }
    else
    {
        AdpInfo->AdpFeatures.MaxSysDrv = 32;
        AdpInfo->AdpFeatures.MaxTgt = 16;
    }

    AdpInfo->AdpFeatures.MaxChn = (UCHAR) DeviceExtension->NumberOfChannels;

    if ( DeviceExtension->AdapterType != DAC960_OLD_ADAPTER)
    {
        AdpInfo->AdpFeatures.AdapterType = DAC960_NEW_ADAPTER;
    }

    AdpInfo->AdpFeatures.PktFormat = 0;


    AdpInfo->AdpFeatures.Reserved1 = 0;
    AdpInfo->AdpFeatures.Reserved2 = 0;
    AdpInfo->AdpFeatures.CacheSize = 0;
    AdpInfo->AdpFeatures.OemCode   = 0;
    AdpInfo->AdpFeatures.Reserved3 = 0;

    //
    // Fill in the System Resources information.
    //

    AdpInfo->SysResources.BusInterface =
                           (UCHAR) DeviceExtension->AdapterInterfaceType;

    AdpInfo->SysResources.BusNumber =
                           (UCHAR) DeviceExtension->SystemIoBusNumber;


    AdpInfo->SysResources.IrqVector =
                           (UCHAR) DeviceExtension->BusInterruptLevel;

    AdpInfo->SysResources.IrqType =
                           (UCHAR) DeviceExtension->InterruptMode;


    AdpInfo->SysResources.Slot = DeviceExtension->Slot;
    AdpInfo->SysResources.Reserved2 = 0;

    AdpInfo->SysResources.IoAddress = DeviceExtension->PhysicalAddress;

    AdpInfo->SysResources.MemAddress = 0;

    AdpInfo->SysResources.BiosAddress = (ULONG_PTR) DeviceExtension->BaseBiosAddress;
    AdpInfo->SysResources.Reserved3 = 0;

#if 0
    //
    // Fill in the Firmware & BIOS version information.
    //

    if (DeviceExtension->AdapterType == DAC960_NEW_ADAPTER) {

        AdpInfo->VerControl.MinorFirmwareRevision =
        ((PDAC960_ENQUIRY_3X)DeviceExtension->NoncachedExtension)->MinorFirmwareRevision;

        AdpInfo->VerControl.MajorFirmwareRevision =
        ((PDAC960_ENQUIRY_3X)DeviceExtension->NoncachedExtension)->MajorFirmwareRevision;

    }
    else {

        AdpInfo->VerControl.MinorFirmwareRevision =
        ((PDAC960_ENQUIRY)DeviceExtension->NoncachedExtension)->MinorFirmwareRevision;


        AdpInfo->VerControl.MajorFirmwareRevision =
        ((PDAC960_ENQUIRY)DeviceExtension->NoncachedExtension)->MajorFirmwareRevision;
    }
#else
    AdpInfo->VerControl.MinorFirmwareRevision = 0;
    AdpInfo->VerControl.MajorFirmwareRevision = 0;
#endif

    AdpInfo->VerControl.MinorBIOSRevision = 0;
    AdpInfo->VerControl.MajorBIOSRevision = 0;
    AdpInfo->VerControl.Reserved = 0;
}

VOID
SetupDriverVersionInfo(
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
)

/*++

Routine Description:

        Copy Driver Version Information to Application Buffer.

Arguments:

        DeviceExtension - Adapter state.
        SRB - System request.

Return Value:

        None.

--*/

{
    PDRIVER_VERSION driverVersion;

    driverVersion = (PDRIVER_VERSION)((PUCHAR) Srb->DataBuffer +
                                       sizeof(IOCTL_REQ_HEADER));

    driverVersion->DriverMajorVersion = (UCHAR) (DRIVER_REVISION >> 8);
    driverVersion->DriverMinorVersion = (UCHAR) DRIVER_REVISION;
    driverVersion->Month              = (UCHAR) (DRIVER_BUILD_DATE >> 16);
    driverVersion->Date               = (UCHAR) (DRIVER_BUILD_DATE >> 8);
    driverVersion->Year               = (UCHAR) DRIVER_BUILD_DATE; 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dce376\dce376nt.h ===
/*
** Mylex DCE376 miniport driver for Windows NT
**
** File: dce376nt.h
**		 Equates for DCE376 adapter
**
** (c) Copyright 1992 Deutsch-Amerikanische Freundschaft, Inc.
** Written by Jochen Roth
*/


#include "scsi.h"



/*
** Firmware related stuff
*/
#define	DCE_MAX_IOCMDS	1
#define	DCE_MAX_XFERLEN	0x4000	// SCSI only. This must be 16 kBytes or less
								// because we use the other half of the SCSI
								// IO buffer for s/g breakdown...
#define	DCE_THUNK		512
#define	DCE_MAXRQS		64
#define	DCE_BUFLOC		0x79000	// 0x75000 + 16kBytes



/*
** EISA specific stuff
*/
#define	EISA_IO_SLOT1	0x1000
#define	EISA_IO_STEP	0x1000
#define	MAXIMUM_EISA_SLOTS 6		// Leave out non-bus master slots
#define	EISA_ID_START	0x0c80		/* Offset from IO base to ID	*/
#define	EISA_ID_COUNT	4

#define	DCE_EISA_MASK	{ 0xff, 0xff, 0xff, 0xf0 }	/* 4 bytes EISA ID mask	*/
#define	DCE_EISA_ID		{ 0x35, 0x98, 0, 0x20 }		/* 4 bytes EISA ID		*/



/*
** EISA side of BMIC chip
*/
#define	BMIC_GLBLCFG			0xc88
#define	BMIC_SYSINTCTRL			0xc89		// System interrupt enable/status
#define	BMIC_SIC_ENABLE			0x01		// read-write interrupt enable
#define	BMIC_SIC_PENDING		0x02		// read-only interrupt(s) pending
#define	BMIC_LOCAL_DB_ENABLE	0xc8c		// Read-only from EISA side
#define	BMIC_LOCAL_DB			0xc8d		// EISA to local notification
#define	BMIC_EISA_DB_ENABLE		0xc8e		// Read-write from EISA side
#define	BMIC_EISA_DB			0xc8f		// Local to EISA notification

#define	BMIC_MBOX				0xc90		// BMIC mailbox registers



/*
** More defines
*/
#define	DCE_PRIMARY_IRQ		15
#define	DCE_SECONDARY_IRQ	10
#define	DCE_SCSI_IRQ		14



/*
** Various DCE mailbox formats
*/
typedef struct {			// I/O mailbox
	UCHAR	Command;
	UCHAR	Reserved1;
	UCHAR	Status;			// Also drive unit (target)
	UCHAR	Error;			// Also error
	USHORT	SectorCount;
	USHORT	Reserved2;
	ULONG	PhysAddr;
	ULONG	Block;
	} DCE_IOMBOX;

typedef struct {			// Request Drive Parameters
	UCHAR	Command;
	UCHAR	Reserved1;
	UCHAR	Status;
	UCHAR	DriveType;		// Also error
	USHORT	Reserved2;
	USHORT	Reserved3;
	ULONG	PhysAddr;		// Address of DCE_DPT
	ULONG	Reserved4;
	} DCE_DPMBOX;

typedef struct {			// Change EOC IRQ
	UCHAR	Command;
	UCHAR	Reserved1;
	UCHAR	Status;
	UCHAR	IRQSelect;		// 0:IRQ15,1:IRQ10 ; Also error
	ULONG	Unused1;
	ULONG	Unused2;
	ULONG	Unused3;
	} DCE_EIMBOX;

typedef struct {			// Recalibrate drive
	UCHAR	Command;
	UCHAR	Reserved1;
	UCHAR	Status;			// also drive
	UCHAR	Error;
	ULONG	Unused1;
	ULONG	Unused2;
	ULONG	Unused3;
	} DCE_RDMBOX;

typedef struct {			// Transfer memory DCE <-> Host
	UCHAR	Command;
	UCHAR	Reserved1;
	UCHAR	Status;
	UCHAR	Error;
	ULONG	AdapterAddress;
	ULONG	HostAddress;
	UCHAR	Direction;
	UCHAR	Unused;
	USHORT	TransferCount;
	} DCE_MTMBOX;
#define	DCE_DCE2HOST	2
#define	DCE_HOST2DCE	3

typedef struct {			// Flush data
	UCHAR	Command;
	UCHAR	Reserved1;
	UCHAR	Status;
	UCHAR	Error;
	ULONG	Unused1;
	ULONG	Unused2;
	ULONG	Unused3;
	} DCE_FLMBOX;

typedef struct {			// Invalidate data
	UCHAR	Command;
	UCHAR	Reserved1;
	UCHAR	Status;			// also drive
	UCHAR	Error;
	ULONG	Unused1;
	ULONG	Unused2;
	ULONG	Unused3;
	} DCE_IVMBOX;

typedef struct {			// Execute SCSI cmd
	UCHAR	Command;
	UCHAR	Reserved1;
	UCHAR	Status;			// also drive
	UCHAR	Error;			// also cdb length
	ULONG	CdbAddress;		// Must be dword aligned
	ULONG	HostAddress;	// data transfer
	UCHAR	Direction;
	UCHAR	Unused;
	USHORT	TransferCount;
	} DCE_XSMBOX;
#define	DCE_DEV2HOST	2
#define	DCE_HOST2DEV	3


//
// The DCE Command codes
//
#define	DCE_RECAL				0x0b
#define	DCE_LREAD				0x11
#define	DCE_LWRITE				0x12
#define	DCE_DEVPARMS			0x09
#define	DCE_EOCIRQ				0x0e
#define	DCE_MEMXFER				0x13
#define	DCE_FLUSH				0x06
#define	DCE_INVALIDATE			0x0f
#define	DCE_HOSTSCSI			0x0d

//
// These command codes are used to mark special states
// the device driver gets into, like flush-after-write
//
#define	DCX_UNCACHEDREAD		0xf0
#define	DCX_UNCACHEDWRITE		0xf1


typedef union {
	DCE_IOMBOX	iombox;
	DCE_DPMBOX	dpmbox;
	DCE_EIMBOX	eimbox;
	DCE_RDMBOX	rdmbox;
	DCE_MTMBOX	mtmbox;
	DCE_FLMBOX	flmbox;
	DCE_IVMBOX	ivmbox;
	DCE_XSMBOX	xsmbox;
	} DCE_MBOX;
typedef DCE_MBOX *PDCE_MBOX;



/*
** Device parameters as returned from DCE firmware
*/
typedef struct {
	USHORT	DriveID;
	USHORT	Heads;
	USHORT	Cylinders;
	USHORT	SectorsPerTrack;
	USHORT	BytesPerSector;
	USHORT	Reserved[3];
	} DCE_DPT;

typedef DCE_DPT *PDCE_DPT;
#define	DPT_NUMENTS		10




/*
** SCSI stuff
*/
typedef struct {
	UCHAR	TargetID;		// 0
	UCHAR	cdbSize;		// 1
	UCHAR	cdb[12];		// 2-13
	ULONG	ppXferAddr;		// 14
	UCHAR	Opcode;			// 18
	USHORT	XferCount;		// 19
	UCHAR	Reserved;		// 21
	UCHAR	SenseLen;		// 22
	ULONG	ppSenseBuf;		// 23
	UCHAR	StuffIt;		// 27
	} DCE_SCSI_REQ, *PDCE_SCSI_REQ;

#define	DCE_SCSIREQLEN	28
#define	DCE_SCSI_NONE	0
#define	DCE_SCSI_READ	2
#define	DCE_SCSI_WRITE	3		// was 1


#define	DCES_ERR_REG		0x1f6
#define	DCES_MBOX_REG		0x1f2
#define	DCES_KICK_REG		0x1f7
#define	DCES_TSTAT_REG		0x1f7
#define	DCES_TRIGGER		0x98
#define	DCES_ACK			0x99

//
// 1f2 (err_reg) seems to hold the sense key
//



//
// Context structure for board scanning
//
typedef struct {
	ULONG	Slot;
	ULONG	AdapterCount;
	} SCANCONTEXT, *PSCANCONTEXT;


//
// The following structure is allocated
// from noncached memory as data will be DMA'd to
// and from it.
//
typedef struct _NONCACHED_EXTENSION {

	//
	// Device Parameter Table for the
	// Get Device Parameters request
	//
	DCE_DPT			DevParms[DPT_NUMENTS];

	ULONG			PhysicalBufferAddress;
	UCHAR			Buffer[DCE_THUNK];

	ULONG			PhysicalScsiReqAddress;
	UCHAR			ScsiReq[DCE_SCSIREQLEN+10];

	ULONG			PhysicalReqSenseAddress;
	UCHAR			ReqSense[DCE_MAXRQS];

} NONCACHED_EXTENSION, *PNONCACHED_EXTENSION;



//
// Request Control Block (SRB Extension)
// All information required to break down and execute
// a disk request is stored here
//
typedef struct _RCB {
	PUCHAR		VirtualTransferAddress;
	ULONG		BlockAddress;
	ULONG		BytesToGo;
	ULONG		BytesThisReq;
	UCHAR		DceCommand;
	UCHAR		RcbFlags;
	UCHAR		WaitInt;
	UCHAR		DceStatus;
	UCHAR		DceErrcode;
	} RCB, *PRCB;

#define	RCB_NEEDCOPY	1
#define	RCB_PREFLUSH	2
#define	RCB_POSTFLUSH	4


//
// SCSI Command Control Block
// We use this block to break down a non-disk scsi request
//
typedef struct _SCCB {
	PUCHAR		VirtualTransferAddress;
	ULONG		DeviceAddress;
	ULONG		BytesPerBlock;
	ULONG		BlocksToGo;
	ULONG		BlocksThisReq;
	ULONG		BytesThisReq;
	UCHAR		Started;
	UCHAR		Opcode;
	UCHAR		DevType;
	} SCCB, *PSCCB;




//
// Device extension
//

typedef struct _HW_DEVICE_EXTENSION {

	//
	// NonCached extension
	//
	PNONCACHED_EXTENSION NoncachedExtension;


	//
	// Adapter parameters and variables
	//
	PVOID	EisaAddress;				// base address for slot (X000h)
	PUSHORT	printAddr;
	ULONG	AdapterIndex;				// 0:first DCE, 1:first DCE SCSI,
										// 2:second DCE
	UCHAR	HostTargetId;
	BOOLEAN	ShutDown;					// We received a shutdown request


	// SCSI device management
	UCHAR	DiskDev[8];					// Flag: TRUE if disk, FLASE otherwise
	UCHAR	ScsiDevType[8];				// Device type: 1:tape, 5:cd-rom,...
	ULONG	Capacity[8];				// Device size if disk device


	//
	// Pending request.
	// This request has not been sent to the adapter yet
	// because the adapter was busy
	//
	PSCSI_REQUEST_BLOCK PendingSrb;


	//
	// Pointers to disk IO requests sent to adapter
	// and their statuses
	//
	ULONG				ActiveCmds;
	PSCSI_REQUEST_BLOCK	ActiveSrb[DCE_MAX_IOCMDS];
	RCB					ActiveRcb[DCE_MAX_IOCMDS];


	//
	// Pointer to non-disk SCSI requests sent to adapter
	//
	PSCSI_REQUEST_BLOCK	ActiveScsiSrb;
	SCCB				Sccb;
	ULONG				Kicked;
	ULONG				ScsiInterruptCount;

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dac960\raiddefs.h ===
/*****************************************************************************
*									     *
*	          COPYRIGHT (C) Mylex Corporation 1992-1994		     *
*                                                                            *
*    This software is furnished under a license and may be used and copied   *
*    only in accordance with the terms and conditions of such license        *
*    and with inclusion of the above copyright notice. This software or nay  *
*    other copies thereof may not be provided or otherwise made available to *
*    any other person. No title to and ownership of the software is hereby   *
*    transferred. 						             *
* 								             *
*    The information in this software is subject to change without notices   *
*    and should not be construed as a commitment by Mylex Corporation        *
*****************************************************************************/
/****************************************************************************
*                                                                           *
*    Name: RAIDDEFS.H							    *
*                                                                           *
*    Description: Commands to Driver, Issued by Utils                       *
*                                                                           *
*    Envrionment:  							    *
*                                                                           *
*    Operating System: Netware 3.x and 4.x,OS/2 2.x,Win NT 3.5,Unixware 2.0 *
*                                                                           *
*   ---------------    Revision History  ------------------------           *
*                                                                           *
*    Date       Author                Change                                *
*    ----       -----     -------------------------------------             *
*    05/10/95   Mouli     Definitions for driver error codes                *
****************************************************************************/

#ifndef _RAIDDEFS_H
#define _RAIDDEFS_H


/* IOCTL Codes For Driver */ 

#define MIOC_ADP_INFO	    0xA0  /* Get Interface Type */
#define MIOC_DRIVER_VERSION 0xA1  /* Get Driver Version */

/* Error Codes returned by Driver */

#define	NOMORE_ADAPTERS		0x0001
#define INVALID_COMMANDCODE     0x0201    /* will be made obsolete */
#define INVALID_ARGUMENT        0x0202

/*
 * Driver Error Code Values
 */

#define IOCTL_SUCCESS                  0x0000
#define IOCTL_INVALID_ADAPTER_NUMBER   0x0001
#define IOCTL_INVALID_ARGUMENT         0x0002
#define IOCTL_UNSUPPORTED_REQUEST      0x0003
#define IOCTL_RESOURCE_ALLOC_FAILURE   0x0004

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dmc960\dac960nt.h ===
/************************************************************************
*									*
*		COPYRIGHT (C) Mylex Corporation 1994			*
*									*
*	This software is furnished under a license and may be used	*
*	and copied only in accordance with the terms and conditions	*
*	of such license and with inclusion of the the above copyright	*
*	notice.  This software or any other copies therof may not be	*
*	provided or otherwise made available to any other person.  No	*
*	title to and ownership of the software is hereby transfered.	*
*									*
*	The information in this software is subject to change without	*
*	notices and should not be construed as a committmet by Mylex	*
*	Corporation.							*
*									*
************************************************************************/

/*
** Mylex DAC960 miniport driver for Windows NT
**
** File: dac960nt.h
**       Equates for DAC960 adapter
**
*/


#include "scsi.h"



/*
** Firmware related stuff
*/

#define MAX_DRVS          8
#define DAC_MAX_IOCMDS  0x40
#define DAC_MAXRQS      0x40
#define DAC_THUNK         512


#define MAX_WAIT_SECS     360

#define ERR 2
#define ABRT 4
#define FWCHK 2
#define HERR 1
#define INSTL_ABRT 0x54524241
#define INSTL_FWCK 0x4b434746
#define INSTL_HERR 0x52524548
#define INSTL_WEIRD 0x3f3f3f3f

#define BIOS_PORT  0x0CC1
#define BIOS_EN    0x40
#define BASE_MASK  0x07
#define BIOS_SIZE  16384

/*
** EISA specific stuff
*/
#define EISA_ADDRESS_BASE   0x0C80
#define EISA_IO_SLOT1       0x1000
#define EISA_IO_STEP        0x1000
#define MAXIMUM_EISA_SLOTS  0x10           // Leave out non-bus master slots
#define EISA_ID_START       0x0c80         /* Offset from IO base to ID    */
#define EISA_INTR	    0xcc3
#define EISA_ID_COUNT       4

#define DAC_EISA_MASK   { 0xff, 0xff, 0xff, 0xf0 }  /* 4 bytes EISA ID mask */
#define DAC_EISA_ID     { 0x35, 0x98, 0, 0x70 }     /* 4 bytes EISA ID     */



/*
** EISA side of BMIC chip
*/
#define BMIC_GLBLCFG                    0xc88
#define BMIC_SYSINTCTRL                 0xc89           // System interrupt enable/status
#define BMIC_SIC_ENABLE                 0x01            // read-write interrupt enable
#define BMIC_SIC_PENDING                0x02            // read-only interrupt(s) pending
#define BMIC_LOCAL_DB_ENABLE    0xc8c           // Read-only from EISA side
#define BMIC_LOCAL_DB                   0xc8d           // EISA to local notification
#define BMIC_EISA_DB_ENABLE             0xc8e           // Read-write from EISA side
#define BMIC_EISA_DB                    0xc8f           // Local to EISA notification

#define BMIC_MBOX                               0xc90           // BMIC mailbox registers



/*
** More defines
*/

//
// The DAC Command codes
//
#define DAC_LREAD    0x02
#define DAC_LWRITE   0x03
#define DAC_ENQUIRE  0x05
#define DAC_ENQ2     0x1c
#define DAC_FLUSH    0x0a
#define DAC_DCDB     0x04
#define DAC_DCMD     0x99
#define DAC_GETDEVST 0x14

#define ILFLAG 8
#define BIT0 1

#define ILFLAG 8

#define MAXCHANNEL     5
#define MAXTARGET      7
#define DAC_DISCONNECT 0x80
#define DATA_OFFSET    100
#define NON_DISK       2           /* Bus ID for NonDisk Devices */
#define DAC_NONE       0
#define DAC_IN         1
#define DAC_OUT        2
#define DAC_NO_AUTOSENSE 0x40

#define MAXIMUM_SGL_DESCRIPTORS         0x11

#define RCB_NEEDCOPY    1
#define RCB_PREFLUSH    2
#define RCB_POSTFLUSH   4


/*
 * Various DAC mailbox formats
 */

#pragma pack(1)

typedef struct {                        // I/O mailbox
    UCHAR   Byte0;
    UCHAR   Byte1;
    UCHAR   Byte2;
    UCHAR   Byte3;
    UCHAR   Byte4;
    UCHAR   Byte5;
    UCHAR   Byte6;
    UCHAR   Byte7;
    UCHAR   Byte8;
    UCHAR   Byte9;
    UCHAR   Bytea;
    UCHAR   Byteb;
    UCHAR   Bytec;
    UCHAR   Byted;
    UCHAR   Bytee;
    UCHAR   Bytef;

} DAC_GENERAL;

typedef struct {                        // I/O mailbox
    UCHAR   Command;
    UCHAR   Id;
    USHORT  SectorCount;
    ULONG   Block;
    ULONG   PhysAddr;
    UCHAR   Reserved1;
    UCHAR   RetId;
    UCHAR   Status;
    UCHAR   Error;

} DAC_IOMBOX;

typedef struct {                    // Request Drive Parameters
    UCHAR   Command;
    UCHAR   Id;
    USHORT  Reserved2;
    ULONG   Reserved3;
    ULONG   PhysAddr;               // Address of DAC_DPT
    UCHAR   RetId;
    UCHAR   Status;
    UCHAR   Error;

} DAC_DPMBOX;


// IOCTL STUFFS

typedef  struct _SRB_IO_CONTROL
{
    ULONG    HeaderLength;
    UCHAR    Signature[8];
    ULONG    Timeout;
    ULONG    ControlCode;
    ULONG    ReturnCode;
    ULONG    Length;

} SRB_IO_CONTROL, * PSRB_IO_CONTROL;

typedef struct{
    SRB_IO_CONTROL  srbioctl;
    UCHAR           DataBuf[512];

}PASS_THROUGH_STRUCT,  *PPT;



typedef union {
    DAC_IOMBOX   iombox;
    DAC_DPMBOX   dpmbox;
    DAC_GENERAL  generalmbox;

} DAC_MBOX;
typedef DAC_MBOX *PDAC_MBOX;



/*
** Device parameters as returned from DAC firmware
*/

typedef struct {
    ULONG   No_Drives;
    ULONG   Size[MAX_DRVS];
    UCHAR   Filler0[7];
    UCHAR   max_io_cmds;       /* Maxm No Of Concurrent commands */
    UCHAR   Filler[150];

} DAC_DPT;

typedef DAC_DPT *PDAC_DPT;


/*
** SCSI stuff
*/
/* 88-bytes */

typedef struct {
    UCHAR    device;     /* device -> chn(4):dev(4) */
    UCHAR    dir;        /* direction-> 0=>no xfr, 1=>IN, 2=>OUT, MSB =1 => 
					disconnecting,=0=> non-disconnecting */
    USHORT   byte_cnt;   /* 64K max data xfr */
    ULONG    ptr;        /* pointer to the data (in system memory) */
    UCHAR    cdb_len;    /* length of cdb */
    UCHAR    sense_len;  /* length of valid sense information */
    UCHAR    cdb[12];
    UCHAR    sense[64];
    UCHAR    status;
    UCHAR    fill;

} DIRECT_CDB, *PDIRECT_CDB;



//
// Context structure for board scanning
//
typedef struct {
    ULONG   Slot;
    ULONG   AdapterCount;

} SCANCONTEXT, *PSCANCONTEXT;


//
// The following structure is allocated
// from noncached memory as data will be DMA'd to
// and from it.
//
typedef struct _NONCACHED_EXTENSION {

    // Device Parameter Table for the Get_Device_Parameters request

    DAC_DPT   DevParms;
    UCHAR     Buffer[DAC_THUNK];
    ULONG     PhysicalScsiReqAddress;
    ULONG     PhysicalReqSenseAddress;
    UCHAR     ReqSense[DAC_MAXRQS];

} NONCACHED_EXTENSION, *PNONCACHED_EXTENSION;



//
// Request Control Block (SRB Extension)
// All information required to break down and execute
// a disk request is stored here
//
typedef struct _RCB {
    PUCHAR   VirtualTransferAddress;
    ULONG    BlockAddress;
    ULONG    BytesToGo;
    UCHAR    DacCommand;
    UCHAR    DacStatus;
    UCHAR    DacErrcode;

} RCB, *PRCB;


//
// SCSI Command Control Block
// We use this block to break down a non-disk scsi request
//

typedef struct _SCCB {
    PUCHAR   VirtualTransferAddress;
    ULONG    DeviceAddress;
    ULONG    BytesPerBlock;
    ULONG    BlocksToGo;
    ULONG    BlocksThisReq;
    ULONG    BytesThisReq;
    UCHAR    Started;
    UCHAR    Opcode;
    UCHAR    DevType;

} SCCB, *PSCCB;


//
// Device extension
//

typedef struct _HW_DEVICE_EXTENSION {

    // NonCached extension
    
    PNONCACHED_EXTENSION   NoncachedExtension;
    ULONG                  NCE_PhyAddr;
    PVOID                  EisaAddress;   // base address for slot (X000h)
    PUSHORT                printAddr;
    ULONG                  AdapterIndex;           
    UCHAR                  HostTargetId;
    UCHAR                  MaxChannels;
    UCHAR                  No_SysDrives;
    UCHAR                  ND_DevMap[MAXTARGET];

    // Pending request.
    // This request has not been sent to the adapter yet
    // because the adapter was busy

    PSCSI_REQUEST_BLOCK    PendingSrb;
    PSCSI_REQUEST_BLOCK    PendingNDSrb;
    ULONG                  NDPending;
    
    // Pointers to disk IO requests sent to adapter
    // and their statuses

    ULONG                  ActiveCmds;
    USHORT                 MaxCmds;
    PSCSI_REQUEST_BLOCK    ActiveSrb[DAC_MAX_IOCMDS];
    RCB                    ActiveRcb[DAC_MAX_IOCMDS];


    // Pointer to non-disk SCSI requests sent to adapter

    PSCSI_REQUEST_BLOCK    ActiveScsiSrb;
    SCCB                   Sccb;
    ULONG                  Kicked;
    ULONG                  ScsiInterruptCount;
    
} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;


// Scatter Gather List *

typedef struct _SG_DESCRIPTOR {
    ULONG     Address;
    ULONG     Length;

} SG_DESCRIPTOR, *PSG_DESCRIPTOR;

typedef struct _SGL {
    SG_DESCRIPTOR     Descriptor[MAXIMUM_SGL_DESCRIPTORS];
} SGL, *PSGL;

#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dce376\dce376nt.c ===
/*
** Mylex DCE376 miniport driver for Windows NT
**
** File: dce376nt.c
**		 The driver
**
** (c) Copyright 1992 Deutsch-Amerikanische Freundschaft, Inc.
** Written by Jochen Roth
**
** Contacts:
**     Paresh @MYLEX (510)796-6050 x222 (hardware, firmware)
**     Jochen @DAF (415)826-7934 (software)
**
**
** Look for $$$ marking code that might need some attention
**
**
** In ARCMODE, the NoncachedExtension sometimes is physically non-
** continuous. Throwing out the error check on that solves the
** problem in a very straight forward way.
**
**
** Tape requests will not work if the data buffer is not
** physically continuous. (We need MapBuffers=TRUE to update
** the SenseInfo->Information field)
**
**
** When multi-command firmware becomes available for the DCE, some
** of the buffers in the NoncachedExtension need to be allocated
** per request slot!
**
**
** Ask Paresh for list of DCE error status codes to provide an error
** mapping from DCE error codes to SCSI target status / request sense
** keys.
**
**
** Bus/adapter Reset for DCE ? nope!
**
** IOCTL only if MapBuffers is possible !
**
**
*/


#include "miniport.h"

#include "dce376nt.h"



#define	MYPRINT				0
#define	NODEVICESCAN		0
#define	REPORTSPURIOUS		0		// Somewhat overwhelming in ARCMODE
#define	MAXLOGICALADAPTERS	3		// Set to 1: One DCE, disk only
									//        2: One DCE, disk & scsi
									//        3: Two DCEs, scsi only on 1st



//
// The DCE EISA id and mask
//
CONST UCHAR	eisa_id[] = DCE_EISA_ID;
CONST UCHAR	eisa_mask[] = DCE_EISA_MASK;




#if MYPRINT
#define	PRINT(f, a, b, c, d) dcehlpPrintf(deviceExtension, f, a, b, c, d)
#define	DELAY(x) ScsiPortStallExecution( (x) * 1000 )
#else
#define	PRINT(f, a, b, c, d)
#define	DELAY(x)
#endif



//
// Function declarations
//
// Functions that start with 'Dce376Nt' are entry points
// for the OS port driver.
// Functions that start with 'dcehlp' are helper functions.
//

ULONG
DriverEntry(
	IN PVOID DriverObject,
	IN PVOID Argument2
	);

ULONG
Dce376NtEntry(
	IN PVOID DriverObject,
	IN PVOID Argument2
	);

ULONG
Dce376NtConfiguration(
	IN PVOID DeviceExtension,
	IN PVOID Context,
	IN PVOID BusInformation,
	IN PCHAR ArgumentString,
	IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
	OUT PBOOLEAN Again
	);

BOOLEAN
Dce376NtInitialize(
	IN PVOID DeviceExtension
	);

BOOLEAN
Dce376NtStartIo(
	IN PVOID DeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
	);

BOOLEAN
Dce376NtInterrupt(
	IN PVOID DeviceExtension
	);

BOOLEAN
Dce376NtResetBus(
	IN PVOID HwDeviceExtension,
	IN ULONG PathId
	);


BOOLEAN
dcehlpDiskRequest(
	IN PHW_DEVICE_EXTENSION deviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
	);

BOOLEAN
dcehlpScsiRequest(
	IN PHW_DEVICE_EXTENSION deviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
	);

VOID
dcehlpSendMBOX(
	IN PUCHAR EisaAddress,
	IN PDCE_MBOX mbox
	);

BOOLEAN
dcehlpTransferMemory(
	IN PHW_DEVICE_EXTENSION deviceExtension,
	IN ULONG HostAddress,
	IN ULONG AdapterAddress,
	IN USHORT Count,
	IN UCHAR Direction
	);

VOID
dcehlpCheckTarget(
	IN PHW_DEVICE_EXTENSION deviceExtension,
	IN UCHAR TargetId
	);

BOOLEAN
dcehlpContinueScsiRequest(
	IN PHW_DEVICE_EXTENSION deviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
	);

BOOLEAN
dcehlpContinueDiskRequest(
	IN PHW_DEVICE_EXTENSION deviceExtension,
	IN ULONG index,
	IN BOOLEAN Start
	);

BOOLEAN
dcehlpDiskRequestDone(
	IN PHW_DEVICE_EXTENSION deviceExtension,
	IN ULONG index,
	IN UCHAR Status
	);

BOOLEAN
dcehlpSplitCopy(
	IN PHW_DEVICE_EXTENSION deviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb,
	IN ULONG PhysicalBufferAddress,
	IN PUCHAR VirtualUserAddress,
	IN USHORT Count,
	IN BOOLEAN ToUser
	);


USHORT		dcehlpGetM16(PUCHAR p);
ULONG		dcehlpGetM24(PUCHAR p);
ULONG		dcehlpGetM32(PUCHAR p);
void		dcehlpPutM16(PUCHAR p, USHORT s);
void		dcehlpPutM24(PUCHAR p, ULONG l);
void		dcehlpPutM32(PUCHAR p, ULONG l);
void		dcehlpPutI16(PUCHAR p, USHORT s);
void		dcehlpPutI32(PUCHAR p, ULONG l);
ULONG		dcehlpSwapM32(ULONG l);



#if MYPRINT
ULONG		dcehlpColumn = 0;
UCHAR		dcehlpHex[] = "0123456789ABCDEF";
VOID		dcehlpPutchar(PUSHORT BaseAddr, UCHAR c);
VOID		dcehlpPrintHex(PUSHORT BaseAddr, ULONG v, ULONG len);
VOID		dcehlpPrintf(PHW_DEVICE_EXTENSION deviceExtension,
						PUCHAR fmt,
						ULONG a1,
						ULONG a2,
						ULONG a3,
						ULONG a4);
#endif



ULONG
DriverEntry (
	IN PVOID DriverObject,
	IN PVOID Argument2
	)

/*++

Routine Description:

	Installable driver initialization entry point for system.

Arguments:

	Driver Object

Return Value:

	Status from ScsiPortInitialize()

--*/

{
	return Dce376NtEntry(DriverObject, Argument2);

} // end DriverEntry()





ULONG
Dce376NtEntry(
	IN PVOID DriverObject,
	IN PVOID Argument2
	)

/*++

Routine Description:

	This routine is called from DriverEntry if this driver is installable
	or directly from the system if the driver is built into the kernel.
	It scans the EISA slots looking for DCE376 host adapters.

Arguments:

	Driver Object

Return Value:

	Status from ScsiPortInitialize()

--*/

{
	HW_INITIALIZATION_DATA hwInitializationData;
	ULONG i;
	SCANCONTEXT	context;



	//
	// Zero out structure.
	//
	for (i=0; i<sizeof(HW_INITIALIZATION_DATA); i++)
		((PUCHAR)&hwInitializationData)[i] = 0;

	context.Slot = 0;
	context.AdapterCount = 0;

	//
	// Set size of hwInitializationData.
	//
	hwInitializationData.HwInitializationDataSize = sizeof(HW_INITIALIZATION_DATA);

	//
	// Set entry points.
	//
	hwInitializationData.HwInitialize = Dce376NtInitialize;
	hwInitializationData.HwFindAdapter = Dce376NtConfiguration;
	hwInitializationData.HwStartIo = Dce376NtStartIo;
	hwInitializationData.HwInterrupt = Dce376NtInterrupt;
	hwInitializationData.HwResetBus = Dce376NtResetBus;

	//
	// Set number of access ranges and bus type.
	//
#if MYPRINT
	hwInitializationData.NumberOfAccessRanges = 2;
#else
	hwInitializationData.NumberOfAccessRanges = 1;
#endif
	hwInitializationData.AdapterInterfaceType = Eisa;

	//
	// Indicate no buffer mapping.
	// Indicate will need physical addresses.
	//
    hwInitializationData.MapBuffers            = FALSE;
	hwInitializationData.NeedPhysicalAddresses = TRUE;

	//
	// Indicate auto request sense is supported.
	//
	hwInitializationData.AutoRequestSense = TRUE;
	hwInitializationData.MultipleRequestPerLu = FALSE;

	//
	// Specify size of extensions.
	//
	hwInitializationData.DeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

	//
	// Ask for SRB extensions.
	// $$$ Note: If we set SrbExtensionSize=0 NT crashes!
	//
	hwInitializationData.SrbExtensionSize = 4; // this works


	return(ScsiPortInitialize(DriverObject, Argument2, &hwInitializationData, &context));

} // end Dce376NtEntry()




ULONG
Dce376NtConfiguration(
	IN PVOID HwDeviceExtension,
	IN PVOID Context,
	IN PVOID BusInformation,
	IN PCHAR ArgumentString,
	IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
	OUT PBOOLEAN Again
	)

/*++

Routine Description:

	This function is called by the OS-specific port driver after
	the necessary storage has been allocated, to gather information
	about the adapter's configuration.

Arguments:

	HwDeviceExtension - HBA miniport driver's adapter data storage
	ConfigInfo - Configuration information structure describing HBA

Return Value:

	TRUE if adapter present in system

--*/

{
	PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
	ULONG eisaSlotNumber;
	PUCHAR eisaAddress;
	PSCANCONTEXT context = Context;
	ULONG	i;
	ULONG	length;
	UCHAR	abyte;
	BOOLEAN	found=FALSE;
	BOOLEAN	scsiThing=FALSE;
	ULONG	IrqLevel;
	ULONG	RangeStart, RangeLength;


	//
	// Check to see if adapter present in system.
	//
	if(context->AdapterCount==1) {
		//
		// Found first dce last time, so this is the scsi extension...
		//
		eisaAddress = ScsiPortGetDeviceBase(deviceExtension,
							ConfigInfo->AdapterInterfaceType,
							ConfigInfo->SystemIoBusNumber,
							ScsiPortConvertUlongToPhysicalAddress(0),
							0x200,
							TRUE);

		scsiThing = TRUE;
		eisaSlotNumber = context->Slot;
		IrqLevel = DCE_SCSI_IRQ;
		RangeStart = 0x1f0;
		RangeLength = 8;
		}
	else {
		//
		// Scan for DCE EISA id
		//
		for(eisaSlotNumber=context->Slot + 1; eisaSlotNumber<MAXIMUM_EISA_SLOTS; eisaSlotNumber++) {

			// Update the slot count to indicate this slot has been checked.
			context->Slot++;

			//
			// Get the system address for this card.
			// The card uses I/O space.
			//
			eisaAddress = ScsiPortGetDeviceBase(deviceExtension,
								ConfigInfo->AdapterInterfaceType,
								ConfigInfo->SystemIoBusNumber,
								ScsiPortConvertUlongToPhysicalAddress(0x1000 * eisaSlotNumber),
								0x1000,
								TRUE);

			// Look at EISA id
			for(found=TRUE, i=0; i<EISA_ID_COUNT; i++) {
				abyte = ScsiPortReadPortUchar(eisaAddress+EISA_ID_START+i);
				if( ((UCHAR)(abyte & eisa_mask[i])) != eisa_id[i] ) {
					found = FALSE;
					break;
					}
				}

			if(found) {
				break;
				}

			//
			// If an adapter was not found unmap it.
			//

			ScsiPortFreeDeviceBase(deviceExtension, eisaAddress);
			} // end for (eisaSlotNumber ...


		if(!found) {
			// No adapter was found.  Indicate that we are done and there are no
			// more adapters here.

			*Again = FALSE;
			return SP_RETURN_NOT_FOUND;
			}

		IrqLevel = context->AdapterCount ? DCE_SECONDARY_IRQ : DCE_PRIMARY_IRQ;
		RangeStart = 0x1000 * eisaSlotNumber;
		RangeLength = 0x1000;

		} // end if(not next after first dce)



#if MYPRINT
	deviceExtension->printAddr =
            ScsiPortGetDeviceBase(
                deviceExtension,
                ConfigInfo->AdapterInterfaceType,
                ConfigInfo->SystemIoBusNumber,
                ScsiPortConvertUlongToPhysicalAddress((ULONG)0xb0000),
				0x1000,
                (BOOLEAN) FALSE);         // InIoSpace

	PRINT("\nHello, world!    ", 0, 0, 0, 0);
	PRINT("Version: " __DATE__ " " __TIME__ "\n", 0, 0, 0, 0);
	PRINT("   slot=%b count=%b irq=%b io=%w\n",
				eisaSlotNumber, context->AdapterCount, IrqLevel, RangeStart);

	if(sizeof(DCE_MBOX)!=16) {
		PRINT("\n MBOX SIZE FAILURE %b !!!!!!!\n", sizeof(DCE_MBOX), 0,0,0);
		return(SP_RETURN_ERROR);
		}

#endif


	deviceExtension->AdapterIndex = context->AdapterCount;
	context->AdapterCount++;

	if(context->AdapterCount < MAXLOGICALADAPTERS)
		*Again = TRUE;
	else
		*Again = FALSE;


	//
	// There is still more to look at.
	//


	// Get the system interrupt vector and IRQL.
	ConfigInfo->BusInterruptLevel = IrqLevel;

	// Indicate maximum transfer length in bytes.
	ConfigInfo->MaximumTransferLength = 0x20000;

	// Maximum number of physical segments is 32.
	ConfigInfo->NumberOfPhysicalBreaks = 17;

	//
	// Fill in the access array information.
	//
	(*ConfigInfo->AccessRanges)[0].RangeStart =
		ScsiPortConvertUlongToPhysicalAddress(RangeStart);
	(*ConfigInfo->AccessRanges)[0].RangeLength = RangeLength;
	(*ConfigInfo->AccessRanges)[0].RangeInMemory = FALSE;
#if MYPRINT
	(*ConfigInfo->AccessRanges)[1].RangeStart =
					ScsiPortConvertUlongToPhysicalAddress(0xb0000);
	(*ConfigInfo->AccessRanges)[1].RangeLength = 0x2000;
	(*ConfigInfo->AccessRanges)[1].RangeInMemory = TRUE;
#endif


	// Store host adapter SCSI id
	ConfigInfo->NumberOfBuses = 1;
	ConfigInfo->InitiatorBusId[0] = 7;

	// Bob Rinne: since we say Busmaster & NeedPhysicalAddresses
	// this is not even being looked at !
	ConfigInfo->ScatterGather = TRUE;

	ConfigInfo->Master = TRUE;
	ConfigInfo->CachesData = TRUE;
	ConfigInfo->AtdiskPrimaryClaimed = scsiThing;
	ConfigInfo->Dma32BitAddresses = TRUE;	// $$$ Find out whether this costs


	//
	// Allocate a Noncached Extension to use for mail boxes.
	//
	deviceExtension->NoncachedExtension = ScsiPortGetUncachedExtension(
								deviceExtension,
								ConfigInfo,
								sizeof(NONCACHED_EXTENSION));

	if (deviceExtension->NoncachedExtension == NULL) {
		// Sorry !
		PRINT("Could not get uncached extension\n", 0, 0, 0, 0);
		return(SP_RETURN_ERROR);
		}



	//
	// Convert virtual to physical buffer addresses.
	//
	deviceExtension->NoncachedExtension->PhysicalBufferAddress =
		   ScsiPortConvertPhysicalAddressToUlong(
			ScsiPortGetPhysicalAddress(deviceExtension,
								 NULL,
								 deviceExtension->NoncachedExtension->Buffer,
								 &length));
	if(length < DCE_THUNK) {
		PRINT("Noncached size too small %w/%w\n", length, DCE_THUNK, 0, 0);
//$$$	return(SP_RETURN_ERROR);
		}


	if(scsiThing) {

		//
		// The SCSI routines need more:
		//

		deviceExtension->NoncachedExtension->PhysicalScsiReqAddress =
			   ScsiPortConvertPhysicalAddressToUlong(
				ScsiPortGetPhysicalAddress(deviceExtension,
									 NULL,
									 deviceExtension->NoncachedExtension->ScsiReq,
									 &length));
		if(length < DCE_SCSIREQLEN) {
			PRINT("Noncached size dce scsireq too small %w/%w\n", length, DCE_SCSIREQLEN, 0, 0);
//$$$		return(SP_RETURN_ERROR);
			}

		deviceExtension->NoncachedExtension->PhysicalReqSenseAddress =
			   ScsiPortConvertPhysicalAddressToUlong(
				ScsiPortGetPhysicalAddress(deviceExtension,
									 NULL,
									 deviceExtension->NoncachedExtension->ReqSense,
									 &length));
		if(length < DCE_MAXRQS) {
			PRINT("Noncached size rqs buffer too small %w/%w\n", length, DCE_MAXRQS, 0, 0);
//$$$		return(SP_RETURN_ERROR);
			}

		} // end if(scsiThing)



	// Store EISA slot base address
	deviceExtension->EisaAddress = eisaAddress;

	deviceExtension->HostTargetId = ConfigInfo->InitiatorBusId[0];

	deviceExtension->ShutDown = FALSE;


	//
	// Setup our private control structures
	//
	for(i=0; i<8; i++)
		deviceExtension->DiskDev[i] = 0;

	deviceExtension->PendingSrb = NULL;

	deviceExtension->ActiveCmds = 0;
	for(i=0; i<DCE_MAX_IOCMDS; i++) {
		deviceExtension->ActiveSrb[i] = NULL;
		deviceExtension->ActiveRcb[i].WaitInt = FALSE;
		}

	deviceExtension->Kicked = FALSE;
	deviceExtension->ActiveScsiSrb = NULL;

	return SP_RETURN_FOUND;

} // end Dce376NtConfiguration()




BOOLEAN
Dce376NtInitialize(
	IN PVOID HwDeviceExtension
	)

/*++

Routine Description:

	Inititialize adapter.

Arguments:

	HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

	TRUE - if initialization successful.
	FALSE - if initialization unsuccessful.

--*/

{
	PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
	PNONCACHED_EXTENSION NoncachedExtension;
	PUCHAR EisaAddress;
	DCE_MBOX	mbox;
	PDCE_DPT	dpt;
	ULONG		i, cnt, length, unit, target, cyls, hds, spt;
	UCHAR		dbell, status, errcode;



	NoncachedExtension = deviceExtension->NoncachedExtension;
	EisaAddress = deviceExtension->EisaAddress;

	PRINT("Initializing adapter %b ...\n", deviceExtension->AdapterIndex, 0, 0, 0);


	if(deviceExtension->AdapterIndex==1) {
		// scsiThing

#if NODEVICESCAN

		// Preset for disk on scsi(0), all others non-cached
		deviceExtension->ScsiDevType[0] = 0;
		deviceExtension->DiskDev[0] = 1;
		for(i=1; i<7; i++)
			deviceExtension->DiskDev[i] = 0;

#else

		// Check all devices
		for(i=0; i<7; i++) {
			dcehlpCheckTarget(deviceExtension, (UCHAR)i);
			if(deviceExtension->ScsiDevType[i]==0)
				// Hard drive
				deviceExtension->DiskDev[i]=1;
			}
		DELAY(1000);

		// Once again after possible bus reset Unit Attention
		for(i=0; i<7; i++) {
			dcehlpCheckTarget(deviceExtension, (UCHAR)i);
			if(deviceExtension->ScsiDevType[i]==0)
				// Hard drive
				deviceExtension->DiskDev[i]=1;
			}
		DELAY(1000);

#endif

		return(TRUE);
		}



	// Disable DCE interrupts
	PRINT("disable DCE interrupts\n", 0, 0, 0, 0);
	ScsiPortWritePortUchar(EisaAddress+BMIC_EISA_DB_ENABLE, 0);
	ScsiPortWritePortUchar(EisaAddress+BMIC_SYSINTCTRL, 0);



	//
	// If second DCE, set EOI interrupt vector
	// AdapterIndex 1 (SCSI) is handled above
	//
	if(deviceExtension->AdapterIndex) {

		PRINT("Set IRQ10 ", 0, 0, 0, 0);
		mbox.eimbox.Command = DCE_EOCIRQ;
		mbox.eimbox.Reserved1 = 0;
		mbox.eimbox.Status = 0;
		mbox.eimbox.IRQSelect = 1;
		mbox.eimbox.Unused1 = 0;
		mbox.eimbox.Unused2 = 0;
		mbox.eimbox.Unused3 = 0;

		dcehlpSendMBOX(EisaAddress, &mbox);

		// Poll the complete bit
		for(cnt=0; cnt<0x3FFFFFFL; cnt++) {
			dbell = ScsiPortReadPortUchar(EisaAddress+BMIC_EISA_DB);
			if(dbell & 1)
				break;
			ScsiPortStallExecution(100);
			}

		ScsiPortStallExecution(500);

		status = ScsiPortReadPortUchar(EisaAddress+BMIC_MBOX+2);
		errcode = ScsiPortReadPortUchar(EisaAddress+BMIC_MBOX+3);

		ScsiPortWritePortUchar(EisaAddress+BMIC_EISA_DB, dbell);

		PRINT("done db=%b s=%b e=%b\n", dbell, status, errcode, 0);
		}



#if NODEVICESCAN

	// Preset for Maxtor 120 MB as target 0
	PRINT("setting diskdev[0]=%d\n", 0x106 * 0xF * 0x3F, 0, 0, 0);
	deviceExtension->DiskDev[0] = 1;
	deviceExtension->Capacity[0] = 0x106 * 0xF * 0x3F;

#else

	// Scan for devices
	PRINT("scanning for devices... ",0,0,0,0);
	dpt = NoncachedExtension->DevParms;
	mbox.dpmbox.PhysAddr =
		ScsiPortConvertPhysicalAddressToUlong(
			ScsiPortGetPhysicalAddress(deviceExtension, NULL, dpt, &length));

	if(length < sizeof(DCE_DPT)*DPT_NUMENTS) {
		PRINT("DPT table too small\n", 0, 0, 0, 0);
		return(FALSE);
		}

	// Preset end mark in case DCE does not respond
	dpt[0].DriveID = 0xffff;

	// Setup mailbox
	mbox.dpmbox.Command = DCE_DEVPARMS;
	mbox.dpmbox.Reserved1 = 0;
	mbox.dpmbox.Status = 0;
	mbox.dpmbox.DriveType = 0;
	mbox.dpmbox.Reserved2 = 0;
	mbox.dpmbox.Reserved3 = 0;
	mbox.dpmbox.Reserved4 = 0;

	dcehlpSendMBOX(EisaAddress, &mbox);

	// Poll the complete bit
	for(cnt=0; cnt < 0x10000; cnt++) {
		dbell = ScsiPortReadPortUchar(EisaAddress+BMIC_EISA_DB);
		if(dbell & 1)
			break;
		ScsiPortStallExecution(100);
		}

	status = ScsiPortReadPortUchar(EisaAddress+BMIC_MBOX+2);
	errcode = ScsiPortReadPortUchar(EisaAddress+BMIC_MBOX+3);

	ScsiPortWritePortUchar(EisaAddress+BMIC_EISA_DB, dbell);

	PRINT("done db=%b s=%b e=%b\n", dbell, status, errcode, 0);

	for(unit=0; unit<8; unit++) {
		if((target=dpt[unit].DriveID)==0xffff)
			break;
		cyls = (ULONG)dpt[unit].Cylinders;
		hds = (ULONG)dpt[unit].Heads;
		spt = (ULONG)dpt[unit].SectorsPerTrack;
		PRINT("dev %b: %w cyls  %b hds  %b spt\n",
			target, cyls, hds, spt);
		deviceExtension->DiskDev[target] = 1;
		deviceExtension->Capacity[target] = cyls*hds*spt;
		}

	DELAY(1000);

#endif

	// Enable DCE interrupts
	PRINT("enable DCE interrupts\n", 0, 0, 0, 0);
	ScsiPortWritePortUchar(EisaAddress+BMIC_EISA_DB_ENABLE, 1);
	ScsiPortWritePortUchar(EisaAddress+BMIC_SYSINTCTRL, BMIC_SIC_ENABLE);


	PRINT("Get going!\n", 0, 0, 0, 0);


	return(TRUE);
} // end Dce376NtInitialize()





BOOLEAN
Dce376NtStartIo(
	IN PVOID HwDeviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
	)

/*++

Routine Description:

	This routine is called from the SCSI port driver synchronized
	with the kernel to start a request

Arguments:

	HwDeviceExtension - HBA miniport driver's adapter data storage
	Srb - IO request packet

Return Value:

	TRUE

--*/

{
	PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
	PSCSI_REQUEST_BLOCK abortedSrb;
	ULONG i = 0;
	BOOLEAN status;



	PRINT("IO %b T%b F=%w ", Srb->Function, Srb->TargetId, Srb->SrbFlags, 0);



	switch(Srb->Function) {

		case SRB_FUNCTION_SHUTDOWN:
			deviceExtension->ShutDown = TRUE;

		case SRB_FUNCTION_FLUSH:
			PRINT("FLUSH/SHUTDOWN\n",0,0,0,0);
			DELAY(1000);

		case SRB_FUNCTION_EXECUTE_SCSI:

			// Determine type of request needed
			if(deviceExtension->DiskDev[Srb->TargetId])
				status = dcehlpDiskRequest(deviceExtension, Srb);
			else
				status = dcehlpScsiRequest(deviceExtension, Srb);

			if(status==FALSE) {
					PRINT("StartIo: DCE is busy\n",0,0,0,0);

					// Save the request until a pending one completes.
					if(deviceExtension->PendingSrb != NULL) {
						//
						// This should never happen:
						PRINT("StartIo: Queue already full\n",0,0,0,0);
						// Already one queued, abort the newer one
						//
						Srb->SrbStatus = SRB_STATUS_BUSY;
						ScsiPortNotification(RequestComplete,
											 deviceExtension,
											 Srb);
						}
					else {
						// Put this request on queue
						deviceExtension->PendingSrb = Srb;
						}
					return(TRUE);
					}

			//
			// Adapter ready for next request.
			//
			ScsiPortNotification(NextRequest,
						 deviceExtension,
						 NULL);
			return(TRUE);


		case SRB_FUNCTION_ABORT_COMMAND:
			PRINT("ABORT ",0,0,0,0);
			abortedSrb = NULL;

			//
			// Verify that SRB to abort is still outstanding.
			//
			if(Srb->NextSrb == deviceExtension->PendingSrb ) {
				// Was pending
				abortedSrb = Srb->NextSrb;
				deviceExtension->PendingSrb = NULL;
				}
			else {
				// TAGTAG add tagging support here
				if(Srb->NextSrb == deviceExtension->ActiveSrb[0] ) {
					PRINT("StartIo: SRB to abort already running\n",0,0,0,0);
					abortedSrb = deviceExtension->ActiveSrb[0];
					deviceExtension->ActiveSrb[0] = NULL;
					deviceExtension->ActiveCmds--;
					//
					// Reset DCE
					//
						//$$$ we need something here to wake up the
						// DCE if it really hangs.
					}
				else {
					PRINT("StartIo: SRB to abort not found\n",0,0,0,0);
					// Complete abort SRB.
					Srb->SrbStatus = SRB_STATUS_ABORT_FAILED;
					}
				}

			if(abortedSrb==NULL) {
				// Nope !
				Srb->SrbStatus = SRB_STATUS_ABORT_FAILED;
				}
			else {
				// Process the aborted request
				abortedSrb->SrbStatus = SRB_STATUS_ABORTED;
				ScsiPortNotification(RequestComplete,
									 deviceExtension,
									 abortedSrb);

				Srb->SrbStatus = SRB_STATUS_SUCCESS;
				}

			// Abort request completed
			ScsiPortNotification(RequestComplete,
								 deviceExtension,
								 Srb);

			// Adapter ready for next request.
			ScsiPortNotification(NextRequest,
								 deviceExtension,
								 NULL);

			return(TRUE);


		case SRB_FUNCTION_IO_CONTROL:
		case SRB_FUNCTION_RESET_BUS:
		default:

			//
			// Set error, complete request
			// and signal ready for next request.
			//
			PRINT("invalid request\n",0,0,0,0);

			Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;

			ScsiPortNotification(RequestComplete,
						 deviceExtension,
						 Srb);

			ScsiPortNotification(NextRequest,
						 deviceExtension,
						 NULL);

			return(TRUE);

		} // end switch

} // end Dce376NtStartIo()




BOOLEAN
Dce376NtInterrupt(
	IN PVOID HwDeviceExtension
	)

/*++

Routine Description:

	This is the interrupt service routine for the DCE376 SCSI adapter.
	It reads the interrupt register to determine if the adapter is indeed
	the source of the interrupt and clears the interrupt at the device.

Arguments:

	HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

	TRUE if we handled the interrupt

--*/

{
	PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
	PUCHAR EisaAddress;
	ULONG index;
	UCHAR interruptStatus;
	UCHAR status;
	UCHAR errcode;



	EisaAddress = deviceExtension->EisaAddress;
#if REPORTSPURIOUS
	PRINT("!",0,0,0,0);
#endif

	switch(deviceExtension->AdapterIndex) {

	case 1:		// First DCE SCSI part

		// Check for pending request
		if(deviceExtension->ActiveScsiSrb==NULL) {
			// Nothing to do
#if REPORTSPURIOUS
			PRINT("}",0,0,0,0);
#endif
			deviceExtension->ScsiInterruptCount++;	// If in init part
			return(TRUE);
			}


		// Check if a command was started
		if(deviceExtension->Kicked) {
			// There's something waiting
			errcode = ScsiPortReadPortUchar(EisaAddress+0x1f6);
			if(errcode!=0xff) {
				// No spurious interrupt
				PRINT(">", 0, 0, 0, 0);
				deviceExtension->Kicked=0;
				if(dcehlpContinueScsiRequest(deviceExtension,
								deviceExtension->ActiveScsiSrb)==FALSE) {
					// Request no longer active
					deviceExtension->ActiveScsiSrb = NULL;
					}
				}
			}

		// Check for pending requests.	If there is one then start it now.
		if(deviceExtension->ActiveScsiSrb==NULL)
		if(deviceExtension->PendingSrb != NULL) {
			PSCSI_REQUEST_BLOCK anotherSrb;

			PRINT("pending-> \n",0,0,0,0);
			anotherSrb = deviceExtension->PendingSrb;
			deviceExtension->PendingSrb = NULL;
			Dce376NtStartIo(deviceExtension, anotherSrb);
			}

		return(TRUE);

	default:	// Disk parts

		//
		// Check interrupt pending.
		//
		interruptStatus = ScsiPortReadPortUchar(EisaAddress+BMIC_SYSINTCTRL);
		if(!(interruptStatus & BMIC_SIC_PENDING)) {
#if REPORTSPURIOUS
			PRINT("Spurious interrupt\n", 0, 0, 0, 0);
#endif
			return FALSE;
			}


		//
		// Read interrupt status from BMIC and acknowledge
		//
		// $$$ For setupapp, this needs some change:
		// sometimes the SIC_PENDING is set, but
		// EISA_DB is not. In that case we need to loop
		// a couple times.
		// $$$ We need not, because we get called again...
		//
		interruptStatus = ScsiPortReadPortUchar(EisaAddress+BMIC_EISA_DB);

		status = ScsiPortReadPortUchar(EisaAddress+BMIC_MBOX+2);
		errcode = ScsiPortReadPortUchar(EisaAddress+BMIC_MBOX+3);

		ScsiPortWritePortUchar(EisaAddress+BMIC_EISA_DB, interruptStatus);

		if(!(interruptStatus&1)) {
			// From DCE, but unknown source
#if REPORTSPURIOUS
			PRINT("Dce376NtInterrupt: Unknown source\n", 0, 0, 0, 0);
#endif
			return(TRUE);
			}


		// Check...
		if(deviceExtension->ActiveCmds<=0) {
			// No one there interrupting us
			PRINT("ActiveCmds==0!\n",0,0,0,0);
			return(TRUE);
			}


		//
		// TAGTAG Add tagging support here: find
		// index of RCB for interrupting request
		//
		index = 0;


		//
		// Check whether this SRB is actually running
		//
		if(deviceExtension->ActiveSrb[index] == NULL) {
			// No one there interrupting us, again
			PRINT("ActiveSrb[%b]==0!\n",index,0,0,0);
			return(TRUE);
			}

		if(deviceExtension->ActiveRcb[index].WaitInt == 0) {
			// No one there interrupting us, again
			PRINT("ActiveRcb[%b].WaitInt==0!\n",index,0,0,0);
			return(TRUE);
			}

		// Update DCE status fields in RCB
		deviceExtension->ActiveRcb[index].WaitInt = 0;
		deviceExtension->ActiveRcb[index].DceStatus = status;
		deviceExtension->ActiveRcb[index].DceErrcode = errcode;


		// Continue or finish the interrupting SRB request
		dcehlpContinueDiskRequest(deviceExtension, index, FALSE);


		if(deviceExtension->ActiveCmds < DCE_MAX_IOCMDS) {
			// A request slot is free now
			// Check for pending requests.
			// If there is one then start it now.

			if(deviceExtension->PendingSrb != NULL) {
				PSCSI_REQUEST_BLOCK anotherSrb;

				PRINT("pending-> \n",0,0,0,0);
				anotherSrb = deviceExtension->PendingSrb;
				deviceExtension->PendingSrb = NULL;
				Dce376NtStartIo(deviceExtension, anotherSrb);
				}
			}

		// Definitively was our interrupt...
		return TRUE;
		}

} // end Dce376NtInterrupt()




BOOLEAN
dcehlpDiskRequest(
	IN PHW_DEVICE_EXTENSION deviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
	)

/*++

Routine Description:

	Build disk request from SRB and send it to the DCE

Arguments:

	DeviceExtension
	SRB

Return Value:

	TRUE if command was started
	FALSE if host adapter is busy

--*/
{
	ULONG					index;
	PRCB					rcb;
	ULONG					blocks=0, blockAddr=0;
	UCHAR					Target;
	UCHAR					DceCommand;



	Target = Srb->TargetId;

	if(Srb->Lun!=0) {
		// LUN not supported
		Srb->SrbStatus = SRB_STATUS_INVALID_LUN;
		ScsiPortNotification(RequestComplete, deviceExtension, Srb);
		PRINT("diskio dce%b T%b: cmd=%b LUN=%b not supported\n",
				deviceExtension->AdapterIndex, Target, Srb->Cdb[0], Srb->Lun);
		return(TRUE);
		}

	if(deviceExtension->AdapterIndex==1)  {
		// Disk devices on SCSI part not supported
		Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
		ScsiPortNotification(RequestComplete, deviceExtension, Srb);
		PRINT("diskio dce%b T%b: cmd=%b not supported\n",
				deviceExtension->AdapterIndex, Target, Srb->Cdb[0], 0);
		return(TRUE);
		}


	if(Srb->Function == SRB_FUNCTION_EXECUTE_SCSI) {

		switch(Srb->Cdb[0]) {

			case SCSIOP_READ:
				DceCommand = DCE_LREAD;
				blocks = (ULONG)dcehlpGetM16(&Srb->Cdb[7]);
				blockAddr = dcehlpGetM32(&Srb->Cdb[2]);
				break;

			case SCSIOP_WRITE:
			case SCSIOP_WRITE_VERIFY:
				DceCommand = DCE_LWRITE;
				blocks = (ULONG)dcehlpGetM16(&Srb->Cdb[7]);
				blockAddr = dcehlpGetM32(&Srb->Cdb[2]);
				break;

			case SCSIOP_READ6:
				DceCommand = DCE_LREAD;
				blocks = (ULONG)Srb->Cdb[4];
				blockAddr = dcehlpGetM24(&Srb->Cdb[1]) & 0x1fffff;
				break;

			case SCSIOP_WRITE6:
				DceCommand = DCE_LWRITE;
				blocks = (ULONG)Srb->Cdb[4];
				blockAddr = dcehlpGetM24(&Srb->Cdb[1]) & 0x1fffff;
				break;

			case SCSIOP_REQUEST_SENSE:
			case SCSIOP_INQUIRY:
			case SCSIOP_READ_CAPACITY:

				PRINT("T%b: cmd=%b len=%b \n",
					Target, Srb->Cdb[0], Srb->DataTransferLength, 0);

				DceCommand = DCE_HOSTSCSI;
				blocks = 0;
				break;

			case SCSIOP_TEST_UNIT_READY:
			case SCSIOP_REZERO_UNIT:
			case SCSIOP_SEEK6:
			case SCSIOP_VERIFY6:
			case SCSIOP_RESERVE_UNIT:
			case SCSIOP_RELEASE_UNIT:
			case SCSIOP_SEEK:
			case SCSIOP_VERIFY:
				PRINT("target %b: cmd=%b ignored\n",
					Target, Srb->Cdb[0], 0, 0);

				// Complete
				Srb->ScsiStatus = SCSISTAT_GOOD;
				Srb->SrbStatus = SRB_STATUS_SUCCESS;
				ScsiPortNotification(RequestComplete, deviceExtension, Srb);
				return(TRUE);

			case SCSIOP_FORMAT_UNIT:
			default:
				// Unknown request
				PRINT("target %b: cmd=%b unknown\n",
					Target, Srb->Cdb[0], 0, 0);
				Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
				ScsiPortNotification(RequestComplete,
						 deviceExtension,
						 Srb);
				return(TRUE);
			}
		}
	else {
		// can only be flush
		PRINT("T%b: FLUSH \n", Target, 0, 0, 0);
		DceCommand = DCE_FLUSH;
		blocks = 0;
		}


	// PRINT("T%b: cmd=%b @%d, %w ", Target, Srb->Cdb[0], blockAddr, blocks);


	// Check for request slot availability
	if(deviceExtension->ActiveCmds >= DCE_MAX_IOCMDS) {
		// dce is busy
		PRINT("dce is busy\n",0,0,0,0);
		return(FALSE);
		}

	//
	// Put this SRB on queue
	// TAGTAG Add tag support here
	//
	index = 0;

	deviceExtension->ActiveCmds++;
	deviceExtension->ActiveSrb[index] = Srb;

	rcb = &deviceExtension->ActiveRcb[index];
	rcb->DceCommand = DceCommand;
	if(Srb->SrbFlags & SRB_FLAGS_ADAPTER_CACHE_ENABLE)
		rcb->RcbFlags = 0;
	else {
		if(DceCommand==DCE_LREAD)
			rcb->RcbFlags = RCB_PREFLUSH;
		else
			rcb->RcbFlags = RCB_POSTFLUSH;
		}


	rcb->VirtualTransferAddress = (PUCHAR)(Srb->DataBuffer);
	rcb->BlockAddress = blockAddr;
	if(blocks!=0)
		rcb->BytesToGo = blocks*512;
	else
		rcb->BytesToGo = Srb->DataTransferLength;

	// Start command
	dcehlpContinueDiskRequest(deviceExtension, index, TRUE);

	return(TRUE);
}




BOOLEAN
dcehlpScsiRequest(
	IN PHW_DEVICE_EXTENSION deviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
	)

/*++

Routine Description:

	Build SCSI request from SRB and send it to the DCE

Arguments:

	DeviceExtenson
	SRB

Return Value:

	TRUE if command was started
	FALSE if host adapter is busy and request need be queued

--*/

{
	PSCCB	sccb;
	ULONG	length;



	sccb = &deviceExtension->Sccb;

	if(deviceExtension->AdapterIndex!=1)  {
		// Non-disk devices on disk part not supported
		Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
		ScsiPortNotification(RequestComplete, deviceExtension, Srb);
		PRINT("scsiio dce%b T%b: cmd=%b not supported\n",
				deviceExtension->AdapterIndex,
				Srb->TargetId, Srb->Cdb[0], 0);
		return(TRUE);
		}

	if(Srb->Function != SRB_FUNCTION_EXECUTE_SCSI) {
		//
		// Not SCSI, must be flush
		// Say ack
		//
		Srb->SrbStatus = SRB_STATUS_SUCCESS;
		ScsiPortNotification(RequestComplete, deviceExtension, Srb);
		return(TRUE);
		}

	// Check for request slot availability
	if(deviceExtension->ActiveScsiSrb) {
		// dce is busy
		PRINT("scsi is busy\n",0,0,0,0);
		return(FALSE);
		}

	// This SRB is being run now
	deviceExtension->ActiveScsiSrb = Srb;


	// Set flag for first request
	sccb->Started = 0;


	// Call the breakdown routine
	if(dcehlpContinueScsiRequest(deviceExtension, Srb)==FALSE) {
		// Trouble starting this request
		deviceExtension->ActiveScsiSrb = NULL;
		}

	// Don't put request on queue
	return(TRUE);
}




VOID
dcehlpSendMBOX(
	IN PUCHAR EisaAddress,
	IN PDCE_MBOX mbox
	)

/*++

Routine Description:

	Start up conventional DCE command

Arguments:

	Eisa base IO address
	DCE mailbox

Return Value:

	none

--*/

{
	PUCHAR	ptr;
	ULONG	i;


	ptr = (PUCHAR)mbox;
	for(i=0; i<16; i++)
		ScsiPortWritePortUchar(EisaAddress+BMIC_MBOX+i, ptr[i]);

	// Kick butt
	ScsiPortWritePortUchar(EisaAddress+BMIC_LOCAL_DB, 1);
}




BOOLEAN
Dce376NtResetBus(
	IN PVOID HwDeviceExtension,
	IN ULONG PathId
)

/*++

Routine Description:

	Reset Dce376Nt SCSI adapter and SCSI bus.

Arguments:

	HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

	Nothing.

--*/

{
	PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;


	PRINT("Reset Bus\n",0,0,0,0);
	//
	// Complete all outstanding requests.
	//
	ScsiPortCompleteRequest(deviceExtension,
							0,
							(UCHAR)-1,
							(UCHAR)-1,
							SRB_STATUS_BUS_RESET);

	return TRUE;

} // end Dce376NtResetBus()



//
// Transfer memory to/from DCE
// Return FALSE if an error occured
// TRUE otherwise
//
BOOLEAN
dcehlpTransferMemory(
	IN PHW_DEVICE_EXTENSION deviceExtension,
	IN ULONG HostAddress,
	IN ULONG AdapterAddress,
	IN USHORT Count,
	IN UCHAR Direction
	)
{
	PUCHAR		EisaAddress;
	DCE_MBOX	mbox;
	ULONG		cnt;
	UCHAR		dbell, status, errcode;



	EisaAddress = deviceExtension->EisaAddress;


	// Disable DCE interrupts
	ScsiPortWritePortUchar(EisaAddress+BMIC_EISA_DB_ENABLE, 0);
	ScsiPortWritePortUchar(EisaAddress+BMIC_SYSINTCTRL, 0);


	// Setup mailbox
	mbox.mtmbox.Command = DCE_MEMXFER;
	mbox.mtmbox.Reserved1 = 0;
	mbox.mtmbox.Status = 0;
	mbox.mtmbox.Error = 0;
	mbox.mtmbox.AdapterAddress = AdapterAddress;
	mbox.mtmbox.HostAddress = HostAddress;
	mbox.mtmbox.Direction = Direction;
	mbox.mtmbox.Unused = 0;
	mbox.mtmbox.TransferCount = Count;


	dcehlpSendMBOX(EisaAddress, &mbox);

	//
	// Poll the complete bit
	// Magic here: if called from ContinueScsiRequest,
	// the dbell sticks to 0xff !!!???
	//
	for(cnt=0; cnt<0x1000; cnt++) {
		ScsiPortStallExecution(100);
		dbell = ScsiPortReadPortUchar(EisaAddress+BMIC_EISA_DB);
		if(dbell==0xff && cnt<1000)
			continue;
		if(dbell & 1)
			break;
		}

	ScsiPortStallExecution(100);	// To be sure ! ???

	status = ScsiPortReadPortUchar(EisaAddress+BMIC_MBOX+2);
	errcode = ScsiPortReadPortUchar(EisaAddress+BMIC_MBOX+3);

	ScsiPortWritePortUchar(EisaAddress+BMIC_EISA_DB, dbell);

	ScsiPortStallExecution(100);

	// Enable DCE interrupts
	ScsiPortWritePortUchar(EisaAddress+BMIC_EISA_DB_ENABLE, 1);
	ScsiPortWritePortUchar(EisaAddress+BMIC_SYSINTCTRL, BMIC_SIC_ENABLE);

	if( (cnt>0x4000) || (errcode&1) ) {
		PRINT("MT cnt=%w db=%b s=%b e=%b\n", cnt, dbell, status, errcode);
		DELAY(1000);
		return(FALSE);
		}

	return(TRUE);
}



VOID
dcehlpCheckTarget(
	IN PHW_DEVICE_EXTENSION deviceExtension,
	IN UCHAR TargetId
	)
{
	PNONCACHED_EXTENSION NoncachedExtension;
	PUCHAR			EisaAddress;
	PUCHAR			scsiReq;
	ULONG			i, cnt, tstat_reg, to_reg, err_reg;
	PUCHAR			pppScsiReq;



	NoncachedExtension = deviceExtension->NoncachedExtension;
	EisaAddress = deviceExtension->EisaAddress;
	scsiReq = NoncachedExtension->ScsiReq;

	PRINT("T%b : ", TargetId, 0, 0, 0);

	// Clear scsi request block
	for(i=0; i<DCE_SCSIREQLEN; i++)
		scsiReq[i] = 0;


	// Setup scsi request block
#if 0
	scsiReq->TargetID = TargetId;
	scsiReq->cdbSize = 6;
	scsiReq->cdb[0] = 0x12;		// Inquiry command
	scsiReq->cdb[4] = 36;			// Response length
	scsiReq->Opcode = DCE_SCSI_READ;
	scsiReq->ppXferAddr = NoncachedExtension->PhysicalBufferAddress;
	scsiReq->XferCount = 36;
	scsiReq->ppSenseBuf = NoncachedExtension->PhysicalReqSenseAddress;
	scsiReq->SenseLen = 14;
#endif
	scsiReq[0] = TargetId;
	scsiReq[1] = 6;
	scsiReq[2+0] = 0x12;		// Inquiry command
	scsiReq[2+4] = 36;			// Response length
	scsiReq[18] = DCE_SCSI_READ;
	dcehlpPutI32(scsiReq+14, NoncachedExtension->PhysicalBufferAddress);
	dcehlpPutI16(scsiReq+19, 36);
	dcehlpPutI32(scsiReq+23, NoncachedExtension->PhysicalReqSenseAddress);
	scsiReq[22] = 14;


	// Program four bytes of physical address into dce
	pppScsiReq = (PUCHAR)(&NoncachedExtension->PhysicalScsiReqAddress);
	for(i=0; i<4; i++)
		ScsiPortWritePortUchar(EisaAddress+0x1f2+i, pppScsiReq[i]);
	deviceExtension->ScsiInterruptCount = 0;

	//
	// Set marker
	// setupapp calls the interrupt handler continuosly,
	// so we need this to determine if the
	// DCE is actually through with the request
	//
	ScsiPortWritePortUchar(EisaAddress+0x1f6, 0xff);
	NoncachedExtension->Buffer[0] = 0xff;

	// Kick the dce
	ScsiPortWritePortUchar(EisaAddress+0x1f7, 0x98);

#if 0
	// Output register values before execution finishes
	tstat_reg = ScsiPortReadPortUchar(EisaAddress+0x1f5);
	to_reg = ScsiPortReadPortUchar(EisaAddress+0x1f6);
	err_reg = ScsiPortReadPortUchar(EisaAddress+0x1f2);
	PRINT("ts=%b to=%b err=%b   ", tstat_reg, to_reg, err_reg, 0);
#endif

	// Wait for command to finish
	for(cnt=0; cnt<10000; cnt++) {
		// Check if interrupt occured
		if(deviceExtension->ScsiInterruptCount)
			break;
		// Check if interrupt got lost
		if(ScsiPortReadPortUchar(EisaAddress+0x1f6) != (UCHAR)0xff)
			break;
		ScsiPortStallExecution(100);
		}

	// Wait another 100 ms to be sure
	ScsiPortStallExecution(100 * 1000);

	// Read execution status registers and ack the interrupt
	tstat_reg = ScsiPortReadPortUchar(EisaAddress+0x1f5);
	to_reg = ScsiPortReadPortUchar(EisaAddress+0x1f6);
	err_reg = ScsiPortReadPortUchar(EisaAddress+0x1f2);
	ScsiPortWritePortUchar(EisaAddress+0x1f2, 0x99);
	PRINT("ts=%b to=%b err=%b\n", tstat_reg, to_reg, err_reg, 0);

	deviceExtension->ScsiDevType[TargetId] = (UCHAR)0xff;
	if(to_reg!=0x2d) {
		if(tstat_reg!=2 && err_reg==0) {
			PINQUIRYDATA inq = (PINQUIRYDATA)(NoncachedExtension->Buffer);

			deviceExtension->ScsiDevType[TargetId] = inq->DeviceType;

			#if MYPRINT
			PRINT("target %b : type=%b/%b len=%b '",
						TargetId, inq->DeviceType, inq->DeviceTypeModifier,
						inq->AdditionalLength);
			inq->VendorSpecific[0]=0;
			PRINT(inq->VendorId, 0, 0, 0, 0);
			PRINT("'\n", 0, 0, 0, 0);
			#endif
			}
		}
}



/*
** Continue scsi request
** Return TRUE if request is active
**        FALSE if request has completed (or was never started)
*/
BOOLEAN
dcehlpContinueScsiRequest(
	IN PHW_DEVICE_EXTENSION deviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb
	)
{
	PSCCB					sccb;
	ULONG					bytes;
	BOOLEAN					nobreaks = FALSE;
	PNONCACHED_EXTENSION	NoncachedExtension;
	PUCHAR					EisaAddress;
	PUCHAR					scsiReq;
	ULONG					physDataPtr;
	ULONG					physRqsPtr;
	ULONG					maxBytesThisReq;
	ULONG					maxBlocksPerReq;
	ULONG					i, cnt, length;
	UCHAR					tstat_reg, to_reg, err_reg;
	PUCHAR					pppScsiReq;



	NoncachedExtension = deviceExtension->NoncachedExtension;
	EisaAddress = deviceExtension->EisaAddress;
	scsiReq = NoncachedExtension->ScsiReq;
	sccb = &deviceExtension->Sccb;


	// Check if this is the first call
	if(sccb->Started==0) {
		//
		// New kid on the control block. Get things started.
		//
		sccb->Started = 1;

		PRINT("C%b L=%w ", Srb->Cdb[0], Srb->DataTransferLength, 0, 0);

		// Check data transfer length
		bytes = Srb->DataTransferLength;
		if(!(Srb->SrbFlags & (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT)))
			bytes = 0;

		if(bytes==0)
			sccb->Opcode = DCE_SCSI_NONE;
		else if(Srb->SrbFlags & SRB_FLAGS_DATA_IN)
			sccb->Opcode = DCE_SCSI_READ;
		else
			sccb->Opcode = DCE_SCSI_WRITE;

		// Store virtual data transfer address
		sccb->VirtualTransferAddress = (PUCHAR)Srb->DataBuffer;

		// Store SCSI device type
		sccb->DevType = deviceExtension->ScsiDevType[Srb->TargetId];

		//
		// Determine data transfer parameters
		//
		switch(Srb->Cdb[0]) {
			case SCSIOP_READ6:
			case SCSIOP_WRITE6:
				// Short CDB, determine device type
				if(sccb->DevType == 1) {
					// Sequential device (SCSI tape)
					sccb->DeviceAddress = 0;
					sccb->BlocksToGo = dcehlpGetM24(&Srb->Cdb[2]);
					sccb->BytesPerBlock = bytes / sccb->BlocksToGo;
					}
				else {
					// Non-sequential device (disk, cd-rom, etc)
					// Note: we take the LUN bits into the device
					// address; that makes the PutM() easier, too.
					sccb->DeviceAddress = dcehlpGetM24(&Srb->Cdb[1]);
					sccb->BlocksToGo = (ULONG)Srb->Cdb[4];
					if(sccb->BlocksToGo==0)
						sccb->BlocksToGo = 256;
					sccb->BytesPerBlock = bytes / sccb->BlocksToGo;
					}
				break;

			case SCSIOP_READ:
			case SCSIOP_WRITE:
			case SCSIOP_WRITE_VERIFY:
				// Long CDB
				sccb->DeviceAddress = dcehlpGetM32(&Srb->Cdb[2]);
				sccb->BlocksToGo = (ULONG)dcehlpGetM16(&Srb->Cdb[7]);

				if(sccb->BlocksToGo==0)
				    sccb->BlocksToGo=65536;
				sccb->BytesPerBlock = bytes / sccb->BlocksToGo;
				break;

			default:
				sccb->BytesPerBlock = 0;
				nobreaks = TRUE;
				break;
			}

		if(sccb->BytesPerBlock==0)
			// Can't break this down
			nobreaks = TRUE;

		} // end if(sccb->Started==0)
	else {
		//
		// We started before, so this is interrupt time
		//

		//
		// Read execution status registers and ack the interrupt
		//
		tstat_reg = ScsiPortReadPortUchar(EisaAddress+0x1f5);
		to_reg = ScsiPortReadPortUchar(EisaAddress+0x1f6);
		err_reg = ScsiPortReadPortUchar(EisaAddress+0x1f2);
		ScsiPortWritePortUchar(EisaAddress+0x1f2, 0x99);
#if MYPRINT
		if(tstat_reg || to_reg || err_reg) {
			PRINT("ts=%b to=%b e=%b ", tstat_reg, to_reg, err_reg, 0);
			}
#endif

		//
		// Adjust pointers
		//
		sccb->DeviceAddress += sccb->BlocksThisReq;
		sccb->BlocksToGo -= sccb->BlocksThisReq;
		sccb->VirtualTransferAddress += sccb->BytesThisReq;

		//
		// Check for selection timeout
		//
		if(to_reg==0x2d) {
			// Timeout on selection
			PRINT("TOUT\n", 0, 0, 0, 0);
			Srb->SrbStatus = SRB_STATUS_SELECTION_TIMEOUT;
			ScsiPortNotification(RequestComplete,
								 deviceExtension,
								 Srb);
			return(FALSE);
			}

		//
		// Check for other errors
		//
		if(err_reg) {
			// Some error
			Srb->ScsiStatus = tstat_reg;
			if(tstat_reg==8)
				Srb->SrbStatus = SRB_STATUS_BUSY;
			else {
				if(Srb->SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE) {
					PRINT("AutoSense DIS ",0,0,0,0);
					Srb->SrbStatus = SRB_STATUS_ERROR;
					}
				else {
					PRINT("AutoSense ",0,0,0,0);
					Srb->SrbStatus = SRB_STATUS_ERROR | SRB_STATUS_AUTOSENSE_VALID;
					// $$$ If tape request, change the Information[] field
					// in SenseInfoBuffer. It represents the number of tape
					// blocks/bytes not read or written.
					// We cannot use dcehlpTransferMemory(), because we would
					// have to syncronize this with disk requests running on
					// a different logical adapter (As of now, the DCE runs
					// only one request at a time).    What a mess!
					// Using MapBuffers would come in handy here...
					}
				}
			PRINT("ERR\n", 0, 0, 0, 0);
			ScsiPortNotification(RequestComplete,
								 deviceExtension,
								 Srb);
			return(FALSE);
			}

		//
		// See if we're done
		//
		if(sccb->BlocksToGo==0) {
			// We're done
			PRINT("OK\n", 0, 0, 0, 0);
			Srb->ScsiStatus = 0;
			Srb->SrbStatus = SRB_STATUS_SUCCESS;
			ScsiPortNotification(RequestComplete,
								 deviceExtension,
								 Srb);
			return(FALSE);
			}

		// Otherwise start next part of request
		PRINT("Cont:\n", 0, 0, 0, 0);
		}


	//
	// If we get here, there's something left to do
	//


	if(sccb->Opcode != DCE_SCSI_NONE) {
		//
		// Data to transfer
		// Get physical data buffer address
		//
		physDataPtr = ScsiPortConvertPhysicalAddressToUlong(
						ScsiPortGetPhysicalAddress(deviceExtension,
								   Srb,
								   sccb->VirtualTransferAddress,
								   &length));
		}
	else
		physDataPtr = 0;

	// Setup common part of scsi request block
	scsiReq[0] = Srb->TargetId;
	scsiReq[1] = Srb->CdbLength;
	for(i=0; i<Srb->CdbLength; i++)
		scsiReq[2+i] = Srb->Cdb[i];
	dcehlpPutI32(scsiReq+14, physDataPtr);
	scsiReq[18] = sccb->Opcode;
	scsiReq[21] = 0;


	if(nobreaks) {
		//
		// Request may not be broken up
		// We got here on first pass, so 'bytes' is valid
		//
		if(length < bytes) {
			// The data area is not physically continuous
			// $$$ might use better error code here
			PRINT("NOBREAKS SCSI S/G\n",0,0,0,0);
			Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
			ScsiPortNotification(RequestComplete,
								 deviceExtension,
								 Srb);
			return(FALSE);
			}
		PRINT("ONCE ", 0, 0, 0, 0);
		sccb->BlocksToGo = sccb->BlocksThisReq = 1;
		sccb->BytesThisReq = sccb->BytesPerBlock = bytes;

		// Leave CDB as is
		}
	else {
		//
		// Request can be broken down
		// Determine number of blocks for this request
		//
		maxBytesThisReq = length < DCE_MAX_XFERLEN ? length : DCE_MAX_XFERLEN;
		maxBlocksPerReq = maxBytesThisReq / sccb->BytesPerBlock;
		if(maxBlocksPerReq == 0) {
			// Out of luck!
			PRINT("SCSI S/G ACROSS BLOCK (%w)\n", maxBytesThisReq, 0, 0, 0);
			Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
			ScsiPortNotification(RequestComplete,
								 deviceExtension,
								 Srb);
			return(FALSE);
			}

		if(sccb->BlocksToGo > maxBlocksPerReq)
			sccb->BlocksThisReq = maxBlocksPerReq;
		else
			sccb->BlocksThisReq = sccb->BlocksToGo;
		sccb->BytesThisReq = sccb->BlocksThisReq * sccb->BytesPerBlock;

		PRINT("mbr=%b btg=%b btr=%b ", maxBlocksPerReq, sccb->BlocksToGo, sccb->BlocksThisReq, 0);

		// We have to modify the CDB
		switch(scsiReq[2+0]) {
			case SCSIOP_READ6:
			case SCSIOP_WRITE6:
				// Short CDB
				if(sccb->DevType == 1) {
					// Sequential device (SCSI tape)
					dcehlpPutM24(&scsiReq[2+2], sccb->BlocksThisReq);
					}
				else {
					// Non-sequential device (disk, cd-rom, etc)
					// Note: we had the LUN bits in the device address!
					dcehlpPutM24(&scsiReq[2+1], sccb->DeviceAddress);
					scsiReq[2+4] = (UCHAR)(sccb->BlocksThisReq);
					}
				break;

			case SCSIOP_READ:
			case SCSIOP_WRITE:
			case SCSIOP_WRITE_VERIFY:
				// Long CDB
				dcehlpPutM32(&scsiReq[2+2], sccb->DeviceAddress);
				dcehlpPutM16(&scsiReq[2+7], (USHORT)sccb->BlocksThisReq);
				break;

			default:
				PRINT("WEIRD!!! \n", 0, 0, 0, 0);
				break;
			}
		}

	// Update transfer length field
	dcehlpPutI16(scsiReq+19, (USHORT)sccb->BytesThisReq);


	//
	// Set auto request sense fields
	//
	if(Srb->SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE) {
		// Stuff the request sense info elsewhere
		physRqsPtr = NoncachedExtension->PhysicalReqSenseAddress;
		scsiReq[22] = 14;
		}
	else {
		// Get physical address of SenseInfoBuffer
		physRqsPtr = ScsiPortConvertPhysicalAddressToUlong(
						ScsiPortGetPhysicalAddress(deviceExtension,
								   NULL,
								   Srb->SenseInfoBuffer,
								   &length));
		// $$$ should verify length >= SenseInfoBufferLength here
		scsiReq[22] = Srb->SenseInfoBufferLength;
		}
	dcehlpPutI32(scsiReq+23, physRqsPtr);


	//
	// Program four bytes of physical address into DCE
	//
	PRINT("* ",0,0,0,0);
	pppScsiReq = (PUCHAR)(&NoncachedExtension->PhysicalScsiReqAddress);
	for(i=0; i<4; i++)
		ScsiPortWritePortUchar(EisaAddress+0x1f2+i, pppScsiReq[i]);
	deviceExtension->ScsiInterruptCount = 0;
	deviceExtension->Kicked = 1;


	// Set marker (see explanation at CheckTarget)
	ScsiPortWritePortUchar(EisaAddress+0x1f6, 0xff);


	// Kick the dce
	ScsiPortWritePortUchar(EisaAddress+0x1f7, 0x98);


	// Wait for interrupt
	return(TRUE);
}




/*
** Continue disk request
** Return TRUE if a request slot became available
**        FALSE if not
*/
BOOLEAN
dcehlpContinueDiskRequest(
	IN PHW_DEVICE_EXTENSION deviceExtension,
	IN ULONG index,
	IN BOOLEAN Start
	)
{
	PRCB					rcb;
	PSCSI_REQUEST_BLOCK		srb;
	PNONCACHED_EXTENSION	nce;
	DCE_MBOX				mbox;
	ULONG					physAddr;
	ULONG					length, blocks, bytes;
	PUCHAR					EisaAddress;
	ULONG					i;



	EisaAddress = deviceExtension->EisaAddress;
	rcb = &deviceExtension->ActiveRcb[index];
	srb = deviceExtension->ActiveSrb[index];
	nce = deviceExtension->NoncachedExtension;



	if(Start==FALSE) {
		//
		// DCE interrupt time call
		// Determine status of last DCE request
		//

		if(rcb->DceErrcode & 1) {
			// The DCE detected an error
			PRINT("error=%b status=%b\n",rcb->DceErrcode,rcb->DceStatus,0,0);

			// $$$ Add error code mapping here
			dcehlpDiskRequestDone(deviceExtension, index,
						SRB_STATUS_TIMEOUT);

			// Slot free
			return(TRUE);
			}

		// Status was okay, check post-read copy flag
		if(rcb->RcbFlags & RCB_NEEDCOPY) {
			// Last block was a scattered single block read
			if(!dcehlpSplitCopy(deviceExtension, srb,
								nce->PhysicalBufferAddress,
								rcb->VirtualTransferAddress, 512, TRUE)) {
				// Error breaking up the s/g mess
				PRINT("SG ERROR !\n",0,0,0,0);
				dcehlpDiskRequestDone(deviceExtension, index,
											SRB_STATUS_PARITY_ERROR);
				return(TRUE);
				}

			// Reset flag
			rcb->RcbFlags &= (~RCB_NEEDCOPY);
			}

		// Advance pointers
		rcb->BytesToGo -= rcb->BytesThisReq;
		rcb->VirtualTransferAddress += rcb->BytesThisReq;

		// Check if more to do
		if(rcb->BytesToGo==0) {
			//
			// This SRB's data transfer is done
			//
			if(rcb->RcbFlags & RCB_POSTFLUSH) {
				//
				// Need to flush buffers before we're through
				//
				rcb->RcbFlags &= (~RCB_POSTFLUSH);
				//PRINT("POSTFLUSH\n",0,0,0,0);
				rcb->DceCommand = DCE_FLUSH;
				}
			else {
				//
				// We're actually done here !
				//
				PRINT("OK   \r",0,0,0,0);

				// Update SCSI status.
				// $$$ can we manipulate this for non SCSI requests ?
				srb->ScsiStatus = SCSISTAT_GOOD;

				// Finish
				dcehlpDiskRequestDone(deviceExtension, index,
										SRB_STATUS_SUCCESS);
				return TRUE;
				}
			}

		//
		// No error but SRB not completely done.
		//
		PRINT("MORE:\r",0,0,0,0);
		}
	else {
		//
		// We start an SRB here, initialize
		// RCB control block variables
		//
		rcb->RcbFlags &= (~RCB_NEEDCOPY);	// be safe

		// $$$ Double check if flags indicate any data transfer at all !
		}


	if(rcb->BytesToGo) {
		//
		// We want to transfer some data, get the physical address
		//
		physAddr = ScsiPortConvertPhysicalAddressToUlong(
				ScsiPortGetPhysicalAddress(deviceExtension,
									   srb,
									   rcb->VirtualTransferAddress,
									   &length));

		// Get maximum length for this request
		if(length < rcb->BytesToGo)
			bytes = length;
		else
			bytes = rcb->BytesToGo;

		if(rcb->DceCommand==DCE_LREAD || rcb->DceCommand==DCE_LWRITE) {
			//
			// Disk read/write: get number of blocks
			//
			if( (blocks = bytes/512) == 0 ) {
				//
				// Here we have a scatter gather break within the next block !
				// Set I/O to one block to/from our buffer
				//
				blocks = 1;
				physAddr = nce->PhysicalBufferAddress;

				if(rcb->DceCommand==DCE_LWRITE) {
					// Write command, fill buffer first
					if(!dcehlpSplitCopy(deviceExtension, srb, physAddr,
								rcb->VirtualTransferAddress, 512, FALSE)) {
						// Error breaking up the s/g mess
						PRINT("SG ERROR !\n",0,0,0,0);
						dcehlpDiskRequestDone(deviceExtension, index,
												SRB_STATUS_PARITY_ERROR);
						return(TRUE);
						}
					}
				else {
					// Read command, need copy later
					rcb->RcbFlags |= RCB_NEEDCOPY;
					}
				}

			//
			// Important: in case of scatter/gather over block
			// boundaries, round bytes down to full multiple of 512
			// This will leave us with less than 512 bytes next time
			// in case of a s/g across block boundaries
			//
			bytes = blocks*512;
			}
		else {
			//
			// Not a disk read/write
			//
			if(bytes != rcb->BytesToGo) {
				//
				// Scatter Gather within a non read/write command
				// This would need a SplitCopy() :-|
				// Stuff like this makes programmers happy and
				// should cost h/w developers their job.
				//
				PRINT("S/G within non-rw, len=%w/%w\n",
								length, rcb->BytesToGo, 0, 0);
				dcehlpDiskRequestDone(deviceExtension, index,
								SRB_STATUS_PARITY_ERROR);
				return(TRUE);
				}
			}
		}
	else {
		//
		// We don't have data to transfer
		//
		bytes = 0;
		blocks = 0;
		}


	//
	// Now look at the specific DCE command
	//
	switch(rcb->DceCommand) {

		case DCE_LREAD:
		case DCE_LWRITE:
			// Disk read/write
			if(blocks==0) {
				PRINT("LIO: blocks==0! ",0,0,0,0);
				// Cancel this command with some garbage error code
				dcehlpDiskRequestDone(deviceExtension, index,
													SRB_STATUS_PARITY_ERROR);
				return(TRUE);
				}
			//
			// Check if we need to flush first (non-cached read)
			//
			if(rcb->RcbFlags & RCB_PREFLUSH) {
				// Reset flush and copy flags, if set
				rcb->RcbFlags &= (~(RCB_NEEDCOPY|RCB_PREFLUSH));
				//PRINT("PREFLUSH\n",0,0,0,0);

				// Flush buffers, invalidate cache
				mbox.ivmbox.Command = DCE_INVALIDATE;
				mbox.ivmbox.Reserved1 = 0;
				mbox.ivmbox.Status = srb->TargetId;
				mbox.ivmbox.Error = 0;
				mbox.ivmbox.Unused1 = 0;
				mbox.ivmbox.Unused2 = 0;
				mbox.ivmbox.Unused3 = 0;
				// Don't advance pointers this pass !
				bytes = 0;
				blocks = 0;
				break;
				}
			else {
				// Transfer data
				mbox.iombox.Command = rcb->DceCommand;
				mbox.iombox.Reserved1 = 0;
				mbox.iombox.Status = srb->TargetId;
				mbox.iombox.Error = 0;
				mbox.iombox.SectorCount = (USHORT)blocks;
				mbox.iombox.Reserved2 = 0;
				mbox.iombox.PhysAddr = physAddr;
				mbox.iombox.Block = rcb->BlockAddress;
				// PRINT(" %d-%d,%w ", physAddr, rcb->BlockAddress, blocks, 0);
				}
			break;

		default:
			PRINT("DR: unknown DceCommand=%b\n", rcb->DceCommand, 0, 0, 0);

			// Cancel this command with some garbage error code
			dcehlpDiskRequestDone(deviceExtension, index,
												SRB_STATUS_PARITY_ERROR);
			return(TRUE);

		case DCE_RECAL:
			// Recalibrate
			mbox.rdmbox.Command = DCE_RECAL;
			mbox.rdmbox.Reserved1 = 0;
			mbox.rdmbox.Status = (UCHAR)srb->TargetId;
			mbox.rdmbox.Error = 0;
			mbox.rdmbox.Unused1 = 0;
			mbox.rdmbox.Unused2 = 0;
			mbox.rdmbox.Unused3 = 0;
			rcb->BytesToGo = 0;			// Just to be safe
			bytes = 0;
			break;

		case DCE_FLUSH:
			// Flush buffers
			mbox.flmbox.Command = DCE_FLUSH;
			mbox.flmbox.Reserved1 = 0;
			mbox.flmbox.Status = 0;
			mbox.flmbox.Error = 0;
			mbox.flmbox.Unused1 = 0;
			mbox.flmbox.Unused2 = 0;
			mbox.flmbox.Unused3 = 0;

			// In case we get here for a post-flush,
			// set variables so we're done next time
			rcb->BytesToGo = 0;
			bytes = 0;
			blocks = 0;
			break;

		case DCE_HOSTSCSI:
			// SCSI commands like inquiry, read capacity
			{
			PUCHAR VirtualCdbPtr = nce->Buffer;
			ULONG PhysicalCdbPtr = nce->PhysicalBufferAddress;

			// Make the CDB storage dword aligned
			while( PhysicalCdbPtr & 3 ) {
				PhysicalCdbPtr++;
				VirtualCdbPtr++;
				}

			// Copy CDB
			for(i=0; i<(ULONG)srb->CdbLength; i++)
				VirtualCdbPtr[i] = srb->Cdb[i];

			// Setup mailbox
			mbox.xsmbox.Command = rcb->DceCommand;
			mbox.xsmbox.Reserved1 = 0;
			mbox.xsmbox.Status = (UCHAR)srb->TargetId;
			mbox.xsmbox.Error = srb->CdbLength;
			mbox.xsmbox.CdbAddress = PhysicalCdbPtr;
			mbox.xsmbox.HostAddress = physAddr;
			mbox.xsmbox.Direction = DCE_DEV2HOST;
			mbox.xsmbox.Unused = 0;
			mbox.xsmbox.TransferCount = (USHORT)bytes;
			}
			break;
		}


	// Advance pointers
	rcb->BytesThisReq = bytes;
	rcb->BlockAddress += blocks;


	// Fire up command
	rcb->WaitInt = 1;
	dcehlpSendMBOX(EisaAddress, &mbox);


	// No SRB slot freed
	return(FALSE);
}



//
// Disk Request Done
// Dequeue, set status, notify Miniport layer
// Always returns TRUE (slot freed)
//
BOOLEAN
dcehlpDiskRequestDone(
	IN PHW_DEVICE_EXTENSION deviceExtension,
	IN ULONG index,
	IN UCHAR Status
	)
{
	PSCSI_REQUEST_BLOCK		srb;



	srb = deviceExtension->ActiveSrb[index];

	// Set status
	srb->SrbStatus = Status;

	// This SRB is through
	deviceExtension->ActiveSrb[index] = NULL;
	deviceExtension->ActiveCmds--;

	// Call notification routine for the SRB.
	ScsiPortNotification(RequestComplete,
					(PVOID)deviceExtension,
					srb);

	return(TRUE);
}



//
// Return TRUE if successfull, FALSE otherwise
//
// The 'Srb' parameter is only used for the
// ScsiPortGetPhysicalAddress() call and must
// be NULL if we're dealing with e.g the
// SenseInfoBuffer
//
BOOLEAN
dcehlpSplitCopy(
	IN PHW_DEVICE_EXTENSION deviceExtension,
	IN PSCSI_REQUEST_BLOCK Srb,
	IN ULONG PhysicalBufferAddress,
	IN PUCHAR VirtualUserAddress,
	IN USHORT Count,
	IN BOOLEAN ToUser
	)
{
	ULONG					physUserAddress;
	ULONG					length;
	USHORT					chunk;



	PRINT("# ",0,0,0,0);
	while(Count) {

		// Prepare for check
		length = 0;

		// Get physical user address
		physUserAddress = ScsiPortConvertPhysicalAddressToUlong(
				ScsiPortGetPhysicalAddress(deviceExtension,
									   Srb,
									   VirtualUserAddress,
									   &length));

		// Check length
		if(length==0) {
			// Something went wrong here
			PRINT("SplitCopy: length==0!\n", 0, 0, 0, 0);
			return(FALSE);
			}

		// Determine maximum transfer length this time
		if(length > ((ULONG)Count))
			chunk = Count;
		else
			chunk = (USHORT)length;

		// Copy
		if(ToUser) {
			// Copy to user:
			// Buffer -> DCE -> User
		//	PRINT("%p>%w>%p ", PhysicalBufferAddress, chunk, physUserAddress, 0);
			if(!dcehlpTransferMemory(deviceExtension, PhysicalBufferAddress, DCE_BUFLOC, chunk, DCE_HOST2DCE))
				// Error
				return(FALSE);
			if(!dcehlpTransferMemory(deviceExtension, physUserAddress, DCE_BUFLOC, chunk, DCE_DCE2HOST))
				// Error
				return(FALSE);
			}
		else {
			// Copy from user:
			// User -> DCE -> Buffer
		//	PRINT("%p<%w<%p ", PhysicalBufferAddress, chunk, physUserAddress, 0);
			if(!dcehlpTransferMemory(deviceExtension, physUserAddress, DCE_BUFLOC, chunk, DCE_HOST2DCE))
				// Error
				return(FALSE);
			if(!dcehlpTransferMemory(deviceExtension, PhysicalBufferAddress, DCE_BUFLOC, chunk, DCE_DCE2HOST))
				// Error
				return(FALSE);
			}

		// Advance pointers
		VirtualUserAddress += chunk;
		PhysicalBufferAddress += chunk;
		Count -= chunk;
		}

	// PRINT("SC \n",0,0,0,0);

	return(TRUE);
}





// Word order functions

USHORT	dcehlpGetM16(PUCHAR p)
{
	USHORT	s;
	PUCHAR	sp=(PUCHAR)&s;

	sp[0] = p[1];
	sp[1] = p[0];
	return(s);
}

ULONG	dcehlpGetM24(PUCHAR p)
{
	ULONG	l;
	PUCHAR	lp=(PUCHAR)&l;

	lp[0] = p[2];
	lp[1] = p[1];
	lp[2] = p[0];
	lp[3] = 0;
	return(l);
}

ULONG	dcehlpGetM32(PUCHAR p)
{
	ULONG	l;
	PUCHAR	lp=(PUCHAR)&l;

	lp[0] = p[3];
	lp[1] = p[2];
	lp[2] = p[1];
	lp[3] = p[0];
	return(l);
}

void	dcehlpPutM16(PUCHAR p, USHORT s)
{
	PUCHAR	sp=(PUCHAR)&s;

	p[0] = sp[1];
	p[1] = sp[0];
}

void	dcehlpPutM24(PUCHAR p, ULONG l)
{
	PUCHAR	lp=(PUCHAR)&l;

	p[0] = lp[2];
	p[1] = lp[1];
	p[2] = lp[0];
}

void	dcehlpPutM32(PUCHAR p, ULONG l)
{
	PUCHAR	lp=(PUCHAR)&l;

	p[0] = lp[3];
	p[1] = lp[2];
	p[2] = lp[1];
	p[3] = lp[0];
}

void	dcehlpPutI16(PUCHAR p, USHORT s)
{
	PUCHAR	sp=(PUCHAR)&s;

	p[0] = sp[0];
	p[1] = sp[1];
}

void	dcehlpPutI32(PUCHAR p, ULONG l)
{
	PUCHAR	lp=(PUCHAR)&l;

	p[0] = lp[0];
	p[1] = lp[1];
	p[2] = lp[2];
	p[3] = lp[3];
}

ULONG		dcehlpSwapM32(ULONG l)
{
	ULONG	lres;
	PUCHAR	lp=(PUCHAR)&l;
	PUCHAR	lpres=(PUCHAR)&lres;

	lpres[0] = lp[3];
	lpres[1] = lp[2];
	lpres[2] = lp[1];
	lpres[3] = lp[0];

	return(lres);
}



#if MYPRINT
//
// The monochrome screen printf() helpers start here
//
VOID		dcehlpPutchar(PUSHORT BaseAddr, UCHAR c)
{
	BOOLEAN newline=FALSE;
	USHORT	s;
	ULONG	i;


	if(c=='\r')
		dcehlpColumn = 0;
	else if(c=='\n')
		newline=TRUE;
	else {
		if(c==9) c==' ';
		ScsiPortWriteRegisterUshort(
			BaseAddr+80*24+dcehlpColumn, (USHORT)(((USHORT)c)|0xF00));
		if(++dcehlpColumn >= 80)
			newline=TRUE;
		}

	if(newline) {
		for(i=0; i<80*24; i++) {
			s = ScsiPortReadRegisterUshort(BaseAddr+80+i);
			ScsiPortWriteRegisterUshort(BaseAddr+i, s);
			}
		for(i=0; i<80; i++)
			ScsiPortWriteRegisterUshort(BaseAddr+80*24+i, 0x720);
		dcehlpColumn = 0;
		}
}



VOID		dcehlpPrintHex(PUSHORT BaseAddr, ULONG v, ULONG len)
{
	ULONG	shift;
	ULONG	nibble;

	len *= 2;
	shift = len*4;
	while(len--) {
		shift -= 4;
		nibble = (v>>shift) & 0xF;
		dcehlpPutchar(BaseAddr, dcehlpHex[nibble]);
		}
}



VOID		dcehlpPrintf(PHW_DEVICE_EXTENSION deviceExtension,
						PUCHAR fmt,
						ULONG a1,
						ULONG a2,
						ULONG a3,
						ULONG a4)
{

	if(deviceExtension->printAddr == 0)
		return;

	while(*fmt) {

		if(*fmt=='%') {
			fmt++;
			switch(*fmt) {
				case 0:
					fmt--;
					break;
				case 'b':
					dcehlpPrintHex(deviceExtension->printAddr, a1, 1);
					break;
				case 'w':
					dcehlpPrintHex(deviceExtension->printAddr, a1, 2);
					break;
				case 'p':
					dcehlpPrintHex(deviceExtension->printAddr, a1, 3);
					break;
				case 'd':
					dcehlpPrintHex(deviceExtension->printAddr, a1, 4);
					break;
				default:
					dcehlpPutchar(deviceExtension->printAddr, '?');
					break;
				}
			fmt++;
			a1 = a2;
			a2 = a3;
			a3 = a4;
			}
		else {
			dcehlpPutchar(deviceExtension->printAddr, *fmt);
			fmt++;
			}
		}
}
#endif // MYPRINT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\proppage\diskprop.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name :

    diskprop.c

Abstract :

    Implementation of the Disk Class Installer and its Policies Tab

Revision History :

--*/


#include "propp.h"
#include "diskprop.h"
#include "volprop.h"


BOOL
IsUserAdmin(VOID)

/*++

Routine Description:

    This routine returns TRUE if the caller's process is a
    member of the Administrators local group.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrators local group.

    FALSE - Caller does not have Administrators local group.

--*/

{
    HANDLE Token;
    DWORD BytesRequired;
    PTOKEN_GROUPS Groups;
    BOOL b;
    DWORD i;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;

    //
    // Open the process token.
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&Token)) {
        return(FALSE);
    }

    b = FALSE;
    Groups = NULL;

    //
    // Get group information.
    //
    if(!GetTokenInformation(Token,TokenGroups,NULL,0,&BytesRequired)
    && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    && (Groups = (PTOKEN_GROUPS)LocalAlloc(LMEM_FIXED,BytesRequired))
    && GetTokenInformation(Token,TokenGroups,Groups,BytesRequired,&BytesRequired)) {

        b = AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &AdministratorsGroup
                );

        if(b) {

            //
            // See if the user has the administrator group.
            //
            b = FALSE;
            for(i=0; i<Groups->GroupCount; i++) {
                if(EqualSid(Groups->Groups[i].Sid,AdministratorsGroup)) {
                    b = TRUE;
                    break;
                }
            }

            FreeSid(AdministratorsGroup);
        }
    }

    //
    // Clean up and return.
    //

    if(Groups) {
        LocalFree(Groups);
    }

    CloseHandle(Token);

    return(b);
}


BOOL CALLBACK
VolumePropPageProvider(PSP_PROPSHEETPAGE_REQUEST Request, LPFNADDPROPSHEETPAGE AddPageRoutine, LPARAM AddPageContext)
{
    //
    // Since there is nothing to be displayed simply fail this call
    //
    return FALSE;
}


VOID
AttemptToSuppressDiskInstallReboot(IN HDEVINFO DeviceInfoSet, IN PSP_DEVINFO_DATA DeviceInfoData)

/*++

Routine Description:

    Because disks are listed as "critical devices" (i.e., they're in the
    critical device database), they get bootstrapped by PnP during boot.  Thus,
    by the time we're installing a disk in user-mode, it's most likely already
    on-line (unless the disk has some problem).  Unfortunately, if the disk is
    the boot device, we won't be able to dynamically affect the changes (if
    any) to tear the stack down and bring it back up with any new settings,
    drivers, etc.  This causes problems for OEM Preinstall scenarios where the
    target machines have different disks than the source machine used to create
    the preinstall image.  If we simply perform our default behavior, then
    the user's experience would be to unbox their brand new machine, boot for
    the first time and go through OOBE, and then be greeted upon login with a
    reboot prompt!

    To fix this, we've defined a private [DDInstall] section INF flag (specific
    to INFs of class "DiskDrive") that indicates we can forego the reboot if
    certain criteria are met.  Those criteria are:

    1.  No files were modified as a result of this device's installation
        (determined by checking the devinfo element's
        DI_FLAGSEX_RESTART_DEVICE_ONLY flag, which the device installer uses to
        track whether such file modifications have occurred).

    2.  The INF used to install this device is signed.

    3.  The INF driver node has a DiskCiPrivateData = <int> entry in its
        [DDInstall] section that has bit 2 (0x4) set.  Note that this setting
        is intentionally obfuscated because we don't want third parties trying
        to use this, as they won't understand the ramifications or
        requirements, and will more than likely get this wrong (trading an
        annoying but harmless reboot requirement into a much more severe
        stability issue).

    This routine makes the above checks, and if it is found that the reboot can
    be suppressed, it clears the DI_NEEDRESTART and DI_NEEDREBOOT flags from
    the devinfo element's device install parameters.

Arguments:

    DeviceInfoSet   - Supplies the device information set.

    DeviceInfoData  - Supplies the device information element that has just
                      been successfully installed (via SetupDiInstallDevice).

Return Value:

    None.

--*/

{
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    PSP_DRVINFO_DATA DriverInfoData = NULL;
    PSP_DRVINFO_DETAIL_DATA DriverInfoDetailData = NULL;
    PSP_INF_SIGNER_INFO InfSignerInfo = NULL;
    HINF hInf;
    TCHAR InfSectionWithExt[255]; // max section name length is 255 chars
    INFCONTEXT InfContext;
    INT Flags;

    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    if(!SetupDiGetDeviceInstallParams(DeviceInfoSet,
                                      DeviceInfoData,
                                      &DeviceInstallParams)) {
        //
        // Couldn't retrieve the device install params--this should never
        // happen.
        //
        goto clean0;
    }

    if(!(DeviceInstallParams.Flags & (DI_NEEDRESTART | DI_NEEDREBOOT))) {
        //
        // The device doesn't require a reboot (must not be the boot device!)
        //
        goto clean0;
    }

    if(!(DeviceInstallParams.FlagsEx & DI_FLAGSEX_RESTART_DEVICE_ONLY)) {
        //
        // Since this flag isn't set, this indicates that the device installer
        // modified one or more files as part of this device's installation.
        // Thus, it isn't safe for us to suppress the reboot request.
        //
        goto clean0;
    }

    //
    // OK, we have a device that needs a reboot, and no files were modified
    // during its installation.  Now check the INF to see if it's signed.
    // (Note: the SP_DRVINFO_DATA, SP_DRVINFO_DETAIL_DATA, and
    // SP_INF_SIGNER_INFO structures are rather large, so we allocate them
    // instead of using lots of stack space.)
    //
    DriverInfoData = LocalAlloc(0, sizeof(SP_DRVINFO_DATA));
    if(DriverInfoData) {
        DriverInfoData->cbSize = sizeof(SP_DRVINFO_DATA);
    } else {
        goto clean0;
    }

    if(!SetupDiGetSelectedDriver(DeviceInfoSet,
                                 DeviceInfoData,
                                 DriverInfoData)) {
        //
        // We must be installing the NULL driver (which is unlikely)...
        //
        goto clean0;
    }

    DriverInfoDetailData = LocalAlloc(0, sizeof(SP_DRVINFO_DETAIL_DATA));

    if(DriverInfoDetailData) {
        DriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    } else {
        goto clean0;
    }

    if(!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                   DeviceInfoData,
                                   DriverInfoData,
                                   DriverInfoDetailData,
                                   sizeof(SP_DRVINFO_DETAIL_DATA),
                                   NULL)
       && (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {

        //
        // Failed to retrieve driver info details--should never happen.
        //
        goto clean0;
    }

    InfSignerInfo = LocalAlloc(0, sizeof(SP_INF_SIGNER_INFO));
    if(InfSignerInfo) {
        InfSignerInfo->cbSize = sizeof(SP_INF_SIGNER_INFO);
    } else {
        goto clean0;
    }

    if(!SetupVerifyInfFile(DriverInfoDetailData->InfFileName,
                           NULL,
                           InfSignerInfo)) {
        //
        // INF isn't signed--we wouldn't trust its "no reboot required" flag,
        // even if it had one.
        //
        goto clean0;
    }

    //
    // INF is signed--let's open it up and see if it specifes the "no reboot
    // required" flag in it's (decorated) DDInstall section...
    //
    hInf = SetupOpenInfFile(DriverInfoDetailData->InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL
                           );

    if(hInf == INVALID_HANDLE_VALUE) {
        //
        // Failed to open the INF.  This is incredibly odd, since we just got
        // through validating the INF's digital signature...
        //
        goto clean0;
    }

    if(!SetupDiGetActualSectionToInstall(hInf,
                                         DriverInfoDetailData->SectionName,
                                         InfSectionWithExt,
                                         sizeof(InfSectionWithExt) / sizeof(TCHAR),
                                         NULL,
                                         NULL)
       || !SetupFindFirstLine(hInf,
                              InfSectionWithExt,
                              TEXT("DiskCiPrivateData"),
                              &InfContext)
       || !SetupGetIntField(&InfContext, 1, &Flags)) {

        Flags = 0;
    }

    SetupCloseInfFile(hInf);

    if(Flags & DISKCIPRIVATEDATA_NO_REBOOT_REQUIRED) {
        //
        // This signed INF is vouching for the fact that no reboot is
        // required for full functionality of this disk.  Thus, we'll
        // clear the DI_NEEDRESTART and DI_NEEDREBOOT flags, so that
        // the user won't be prompted to reboot.  Note that during the
        // default handling routine (SetupDiInstallDevice), a non-fatal
        // problem was set on the devnode indicating that a reboot is
        // needed.  This will not result in a yellow-bang in DevMgr,
        // but you would see text in the device status field indicating
        // a reboot is needed if you go into the General tab of the
        // device's property sheet.
        //
        CLEAR_FLAG(DeviceInstallParams.Flags, DI_NEEDRESTART);
        CLEAR_FLAG(DeviceInstallParams.Flags, DI_NEEDREBOOT);

        SetupDiSetDeviceInstallParams(DeviceInfoSet,
                                      DeviceInfoData,
                                      &DeviceInstallParams
                                     );
    }

clean0:

    if(DriverInfoData) {
        LocalFree(DriverInfoData);
    }
    if(DriverInfoDetailData) {
        LocalFree(DriverInfoDetailData);
    }
    if(InfSignerInfo) {
        LocalFree(InfSignerInfo);
    }
}


DWORD
DiskClassInstaller(IN DI_FUNCTION InstallFunction, IN HDEVINFO DeviceInfoSet, IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL)

/*++

Routine Description:

    This routine is the class installer function for disk drive.

Arguments:

    InstallFunction - Supplies the install function.

    DeviceInfoSet   - Supplies the device info set.

    DeviceInfoData  - Supplies the device info data.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/

{
    switch (InstallFunction)
    {
        case DIF_INSTALLDEVICE:
        {
            //
            // Let the default action occur to get the device installed.
            //
            if (!SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData))
            {
                //
                // Failed to install the device--just return the error reported
                //
                return GetLastError();
            }

            //
            // Default device install action succeeded, now check for reboot
            // requirement and suppress it, if possible.
            //
            AttemptToSuppressDiskInstallReboot(DeviceInfoSet, DeviceInfoData);

            //
            // Regardless of whether we successfully suppressed the reboot, we
            // still report success, because the install went fine.
            //
            return NO_ERROR;
        }

        case DIF_ADDPROPERTYPAGE_ADVANCED:
        case DIF_ADDREMOTEPROPERTYPAGE_ADVANCED:
        {
            SP_ADDPROPERTYPAGE_DATA AddPropertyPageData = { 0 };

            //
            // These property sheets are not for the entire class
            //
            if (DeviceInfoData == NULL)
            {
                break;
            }

            AddPropertyPageData.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);

            if (SetupDiGetClassInstallParams(DeviceInfoSet,
                                             DeviceInfoData,
                                             (PSP_CLASSINSTALL_HEADER)&AddPropertyPageData,
                                             sizeof(SP_ADDPROPERTYPAGE_DATA),
                                             NULL))
            {
                //
                // Ensure that the maximum number of dynamic pages has not yet been met
                //
                if (AddPropertyPageData.NumDynamicPages >= MAX_INSTALLWIZARD_DYNAPAGES)
                {
                    return NO_ERROR;
                }

                if (InstallFunction == DIF_ADDPROPERTYPAGE_ADVANCED)
                {
                    //
                    // Create the Disk Policies Tab
                    //
                    PDISK_PAGE_DATA pData = HeapAlloc(GetProcessHeap(), 0, sizeof(DISK_PAGE_DATA));

                    if (pData)
                    {
                        HPROPSHEETPAGE hPage = NULL;
                        PROPSHEETPAGE  page = { 0 };

                        pData->DeviceInfoSet  = DeviceInfoSet;
                        pData->DeviceInfoData = DeviceInfoData;

                        page.dwSize      = sizeof(PROPSHEETPAGE);
                        page.dwFlags     = PSP_USECALLBACK;
                        page.hInstance   = ModuleInstance;
                        page.pszTemplate = MAKEINTRESOURCE(ID_DISK_PROPPAGE);
                        page.pfnDlgProc  = DiskDialogProc;
                        page.pfnCallback = DiskDialogCallback;
                        page.lParam      = (LPARAM) pData;

                        hPage = CreatePropertySheetPage(&page);

                        if (hPage)
                        {
                            AddPropertyPageData.DynamicPages[AddPropertyPageData.NumDynamicPages++] = hPage;
                        }
                        else
                        {
                            HeapFree(GetProcessHeap(), 0, pData);
                        }
                    }
                }

                //
                // The Volumes Tab is limited to Administrators
                //
                if (IsUserAdmin() && AddPropertyPageData.NumDynamicPages < MAX_INSTALLWIZARD_DYNAPAGES)
                {
                    //
                    // Create the Volumes Tab
                    //
                    PVOLUME_PAGE_DATA pData = HeapAlloc(GetProcessHeap(), 0, sizeof(VOLUME_PAGE_DATA));

                    if (pData)
                    {
                        HPROPSHEETPAGE hPage = NULL;
                        PROPSHEETPAGE  page = { 0 };

                        pData->DeviceInfoSet  = DeviceInfoSet;
                        pData->DeviceInfoData = DeviceInfoData;

                        page.dwSize      = sizeof(PROPSHEETPAGE);
                        page.dwFlags     = PSP_USECALLBACK;
                        page.hInstance   = ModuleInstance;
                        page.pszTemplate = MAKEINTRESOURCE(ID_VOLUME_PROPPAGE);
                        page.pfnDlgProc  = VolumeDialogProc;
                        page.pfnCallback = VolumeDialogCallback;
                        page.lParam      = (LPARAM) pData;

                        hPage = CreatePropertySheetPage(&page);

                        if (hPage)
                        {
                            //
                            // Look to see if we were launched by Disk Management
                            //
                            HMODULE LdmModule = NULL;

                            pData->bInvokedByDiskmgr = FALSE;

                            LdmModule = GetModuleHandle(TEXT("dmdskmgr"));

                            if (LdmModule)
                            {
                                IS_REQUEST_PENDING pfnIsRequestPending = (IS_REQUEST_PENDING) GetProcAddress(LdmModule, "IsRequestPending");

                                if (pfnIsRequestPending)
                                {
                                    if ((*pfnIsRequestPending)())
                                    {
                                        pData->bInvokedByDiskmgr = TRUE;
                                    }
                                }
                            }

                            AddPropertyPageData.DynamicPages[AddPropertyPageData.NumDynamicPages++] = hPage;
                        }
                        else
                        {
                            HeapFree(GetProcessHeap(), 0, pData);
                        }
                    }
                }

                SetupDiSetClassInstallParams(DeviceInfoSet,
                                             DeviceInfoData,
                                             (PSP_CLASSINSTALL_HEADER)&AddPropertyPageData,
                                             sizeof(SP_ADDPROPERTYPAGE_DATA));
            }

            return NO_ERROR;
        }
    }

    return ERROR_DI_DO_DEFAULT;
}


HANDLE
GetHandleForDisk(LPTSTR DeviceName)
{
    HANDLE h = INVALID_HANDLE_VALUE;
    int i = 0;
    BOOL success = FALSE;
    TCHAR buf[MAX_PATH] = { 0 };
    TCHAR fakeDeviceName[MAX_PATH] = { 0 };

    h = CreateFile(DeviceName,
                    GENERIC_WRITE | GENERIC_READ,
                    FILE_SHARE_WRITE | FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (h != INVALID_HANDLE_VALUE)
        return h;

    while (!success && i < 10) {

        _sntprintf(buf, sizeof(buf) / sizeof(buf[0]) - 1, _T("DISK_FAKE_DEVICE_%d_"), i++);
        success = DefineDosDevice(DDD_RAW_TARGET_PATH,
                                  buf,
                                  DeviceName);
        if (success) {

            _sntprintf(fakeDeviceName, sizeof(fakeDeviceName) / sizeof(fakeDeviceName[0]) - 1, _T("\\\\.\\%s"), buf);
            h = CreateFile(fakeDeviceName,
                            GENERIC_WRITE | GENERIC_READ,
                            FILE_SHARE_WRITE | FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL);
            DefineDosDevice(DDD_REMOVE_DEFINITION,
                            buf,
                            NULL);
        }

    }

    return h;
}


UINT
GetCachingPolicy(PDISK_PAGE_DATA data)
{
    HANDLE hDisk;
    DISK_CACHE_INFORMATION cacheInfo;
    TCHAR buf[MAX_PATH] = { 0 };
    DWORD len;

    if (!SetupDiGetDeviceRegistryProperty(data->DeviceInfoSet,
                                          data->DeviceInfoData,
                                          SPDRP_PHYSICAL_DEVICE_OBJECT_NAME,
                                          NULL,
                                          (PBYTE)buf,
                                          sizeof(buf) - sizeof(TCHAR),
                                          NULL))
    {
        return GetLastError();
    }

    if (INVALID_HANDLE_VALUE == (hDisk = GetHandleForDisk(buf))) {

        return ERROR_INVALID_HANDLE;
    }

    //
    // Get cache info - IOCTL_DISK_GET_CACHE_INFORMATION
    //
    if (!DeviceIoControl(hDisk,
                         IOCTL_DISK_GET_CACHE_INFORMATION,
                         NULL,
                         0,
                         &cacheInfo,
                         sizeof(DISK_CACHE_INFORMATION),
                         &len,
                         NULL)) {

        CloseHandle(hDisk);
        return GetLastError();
    }

    data->OrigWriteCacheSetting = cacheInfo.WriteCacheEnabled;
    data->CurrWriteCacheSetting = cacheInfo.WriteCacheEnabled;

    //
    // Get the cache setting - IOCTL_DISK_GET_CACHE_SETTING
    //
    if (!DeviceIoControl(hDisk,
                         IOCTL_DISK_GET_CACHE_SETTING,
                         NULL,
                         0,
                         &data->CacheSetting,
                         sizeof(DISK_CACHE_SETTING),
                         &len,
                         NULL)) {

        CloseHandle(hDisk);
        return GetLastError();
    }

    data->CurrentIsPowerProtected = data->CacheSetting.IsPowerProtected;

    CloseHandle(hDisk);
    return ERROR_SUCCESS;
}


VOID
UpdateCachingPolicy(HWND HWnd, PDISK_PAGE_DATA data)
{
    if (data->IsCachingPolicy)
    {
        if (data->CurrentRemovalPolicy == CM_REMOVAL_POLICY_EXPECT_SURPRISE_REMOVAL)
        {
            //
            // This policy requires that no caching be done at any
            // level. Uncheck and gray out the write cache setting
            //
            CheckDlgButton(HWnd, IDC_DISK_POLICY_WRITE_CACHE, 0);

            EnableWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_WRITE_CACHE), FALSE);
            EnableWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_WRITE_CACHE_MESG), FALSE);

            data->CurrWriteCacheSetting = FALSE;
        }
        else
        {
            EnableWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_WRITE_CACHE), TRUE);
            EnableWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_WRITE_CACHE_MESG), TRUE);
        }

        if (data->CurrWriteCacheSetting == FALSE)
        {
            //
            // The power-protected mode option does not apply if
            // caching is off. Uncheck and gray out this setting
            //
            CheckDlgButton(HWnd, IDC_DISK_POLICY_PP_CACHE, 0);

            EnableWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_PP_CACHE), FALSE);
            EnableWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_PP_CACHE_MESG), FALSE);

            data->CurrentIsPowerProtected = FALSE;
        }
        else
        {
            EnableWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_PP_CACHE), TRUE);
            EnableWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_PP_CACHE_MESG), TRUE);
        }
    }
    else
    {
        //
        // The caching policy cannot be modified
        //
    }
}


UINT
SetCachingPolicy(PDISK_PAGE_DATA data)
{
    HANDLE hDisk;
    DISK_CACHE_INFORMATION cacheInfo;
    TCHAR buf[MAX_PATH] = { 0 };
    DWORD len;

    if (!SetupDiGetDeviceRegistryProperty(data->DeviceInfoSet,
                                          data->DeviceInfoData,
                                          SPDRP_PHYSICAL_DEVICE_OBJECT_NAME,
                                          NULL,
                                          (PBYTE)buf,
                                          sizeof(buf) - sizeof(TCHAR),
                                          NULL))
    {
        return GetLastError();
    }

    if (INVALID_HANDLE_VALUE == (hDisk = GetHandleForDisk(buf))) {

        return ERROR_INVALID_HANDLE;
    }

    data->CacheSetting.IsPowerProtected = (BOOLEAN)data->CurrentIsPowerProtected;

    //
    // Set the cache setting - IOCTL_DISK_SET_CACHE_SETTING
    //
    if (!DeviceIoControl(hDisk,
                         IOCTL_DISK_SET_CACHE_SETTING,
                         &data->CacheSetting,
                         sizeof(DISK_CACHE_SETTING),
                         NULL,
                         0,
                         &len,
                         NULL)) {

        CloseHandle(hDisk);
        return GetLastError();
    }

    //
    // Get cache info - IOCTL_DISK_GET_CACHE_INFORMATION
    //
    if (!DeviceIoControl(hDisk,
                         IOCTL_DISK_GET_CACHE_INFORMATION,
                         NULL,
                         0,
                         &cacheInfo,
                         sizeof(DISK_CACHE_INFORMATION),
                         &len,
                         NULL)) {

        CloseHandle(hDisk);
        return GetLastError();
    }

    cacheInfo.WriteCacheEnabled = (BOOLEAN)data->CurrWriteCacheSetting;

    //
    // Set cache info - IOCTL_DISK_SET_CACHE_INFORMATION
    //
    if (!DeviceIoControl(hDisk,
                         IOCTL_DISK_SET_CACHE_INFORMATION,
                         &cacheInfo,
                         sizeof(DISK_CACHE_INFORMATION),
                         NULL,
                         0,
                         &len,
                         NULL)) {

        CloseHandle(hDisk);
        return GetLastError();
    }

    data->OrigWriteCacheSetting = data->CurrWriteCacheSetting;

    CloseHandle(hDisk);
    return ERROR_SUCCESS;
}


UINT
GetRemovalPolicy(PDISK_PAGE_DATA data)
{
    HANDLE hDisk;
    TCHAR buf[MAX_PATH] = { 0 };
    DWORD len;

    if (!SetupDiGetDeviceRegistryProperty(data->DeviceInfoSet,
                                          data->DeviceInfoData,
                                          SPDRP_REMOVAL_POLICY,
                                          NULL,
                                          (PBYTE)&data->DefaultRemovalPolicy,
                                          sizeof(DWORD),
                                          NULL))
    {
        return GetLastError();
    }

    if (!SetupDiGetDeviceRegistryProperty(data->DeviceInfoSet,
                                          data->DeviceInfoData,
                                          SPDRP_PHYSICAL_DEVICE_OBJECT_NAME,
                                          NULL,
                                          (PBYTE)buf,
                                          sizeof(buf) - sizeof(TCHAR),
                                          NULL))
    {
        return GetLastError();
    }

    if (INVALID_HANDLE_VALUE == (hDisk = GetHandleForDisk(buf))) {

        return ERROR_INVALID_HANDLE;
    }

    //
    // Get hotplug info - IOCTL_STORAGE_GET_HOTPLUG_INFO
    //
    if (!DeviceIoControl(hDisk,
                         IOCTL_STORAGE_GET_HOTPLUG_INFO,
                         NULL,
                         0,
                         &data->HotplugInfo,
                         sizeof(STORAGE_HOTPLUG_INFO),
                         &len,
                         NULL)) {

        CloseHandle(hDisk);
        return GetLastError();
    }

    data->CurrentRemovalPolicy = (data->HotplugInfo.DeviceHotplug) ? CM_REMOVAL_POLICY_EXPECT_SURPRISE_REMOVAL : CM_REMOVAL_POLICY_EXPECT_ORDERLY_REMOVAL;

    CloseHandle(hDisk);
    return ERROR_SUCCESS;
}


DWORD WINAPI
UtilpRestartDeviceWr(PDISK_PAGE_DATA data)
{
    UtilpRestartDevice(data->DeviceInfoSet, data->DeviceInfoData);

    return ERROR_SUCCESS;
}


VOID
UtilpRestartDeviceEx(HWND HWnd, PDISK_PAGE_DATA data)
{
    HANDLE hThread = NULL;
    MSG msg;

    //
    // Temporary workaround to prevent the user from
    // making any more changes and giving the effect
    // that something is happening
    //
    EnableWindow(GetDlgItem(GetParent(HWnd), IDOK), FALSE);
    EnableWindow(GetDlgItem(GetParent(HWnd), IDCANCEL), FALSE);

    data->IsBusy = TRUE;

    //
    // Call this utility on a seperate thread
    //
    hThread = CreateThread(NULL, 0, UtilpRestartDeviceWr, (LPVOID)data, 0, NULL);

    if (hThread)
    {
        while (1)
        {
            if (MsgWaitForMultipleObjects(1, &hThread, FALSE, INFINITE, QS_ALLINPUT) != (WAIT_OBJECT_0 + 1))
            {
                break;
            }

            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                if (!PropSheet_IsDialogMessage(HWnd, &msg))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }

        CloseHandle(hThread);
    }

    data->IsBusy = FALSE;

    EnableWindow(GetDlgItem(GetParent(HWnd), IDOK), TRUE);
    EnableWindow(GetDlgItem(GetParent(HWnd), IDCANCEL), TRUE);
}


UINT
SetRemovalPolicy(HWND HWnd, PDISK_PAGE_DATA data)
{
    HANDLE hDisk;
    TCHAR buf[MAX_PATH] = { 0 };
    DWORD len;

    if (!SetupDiGetDeviceRegistryProperty(data->DeviceInfoSet,
                                          data->DeviceInfoData,
                                          SPDRP_PHYSICAL_DEVICE_OBJECT_NAME,
                                          NULL,
                                          (PBYTE)buf,
                                          sizeof(buf) - sizeof(TCHAR),
                                          NULL))
    {
        return GetLastError();
    }

    if (INVALID_HANDLE_VALUE == (hDisk = GetHandleForDisk(buf))) {

        return ERROR_INVALID_HANDLE;
    }

    data->HotplugInfo.DeviceHotplug = (data->CurrentRemovalPolicy == CM_REMOVAL_POLICY_EXPECT_SURPRISE_REMOVAL) ? TRUE : FALSE;

    //
    // Set hotplug info - IOCTL_STORAGE_SET_HOTPLUG_INFO
    //

    if (!DeviceIoControl(hDisk,
                         IOCTL_STORAGE_SET_HOTPLUG_INFO,
                         &data->HotplugInfo,
                         sizeof(STORAGE_HOTPLUG_INFO),
                         NULL,
                         0,
                         &len,
                         NULL)) {

        CloseHandle(hDisk);
        return GetLastError();
    }

    CloseHandle(hDisk);

    UtilpRestartDeviceEx(HWnd, data);
    return ERROR_SUCCESS;
}


BOOL
DiskOnInitDialog(HWND HWnd, HWND HWndFocus, LPARAM LParam)
{
    LPPROPSHEETPAGE page     = (LPPROPSHEETPAGE) LParam;
    PDISK_PAGE_DATA diskData = (PDISK_PAGE_DATA) page->lParam;
    UINT status;

    //
    // Initially assume that the device does not have a surprise removal policy
    //
    CheckRadioButton(HWnd, IDC_DISK_POLICY_SURPRISE, IDC_DISK_POLICY_ORDERLY, IDC_DISK_POLICY_ORDERLY);

    diskData->IsBusy = FALSE;

    //
    // Obtain the Caching Policy
    //
    status = GetCachingPolicy(diskData);

    if (status == ERROR_SUCCESS)
    {
        diskData->IsCachingPolicy = TRUE;

        CheckDlgButton(HWnd, IDC_DISK_POLICY_WRITE_CACHE, diskData->OrigWriteCacheSetting);

        //
        // Determine the most appropriate message to display under this setting
        //
        if (diskData->CacheSetting.State != DiskCacheNormal)
        {
            TCHAR szMesg[MAX_PATH] = { 0 };

            //
            // The write caching option on  this device  should either be
            // disabled (to protect data integrity) or cannot be modified
            //
            if (diskData->CacheSetting.State == DiskCacheWriteThroughNotSupported)
            {
                LoadString(ModuleInstance, IDS_DISK_POLICY_WRITE_CACHE_MSG1, szMesg, MAX_PATH);
            }
            else if (diskData->CacheSetting.State == DiskCacheModifyUnsuccessful)
            {
                LoadString(ModuleInstance, IDS_DISK_POLICY_WRITE_CACHE_MSG2, szMesg, MAX_PATH);
            }

            SetDlgItemText(HWnd, IDC_DISK_POLICY_WRITE_CACHE_MESG, szMesg);
        }

        //
        // The power-protected mode option does not apply if
        // caching is off. Uncheck and gray out this setting
        //
        if (diskData->OrigWriteCacheSetting == FALSE)
        {
            EnableWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_PP_CACHE), FALSE);
            EnableWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_PP_CACHE_MESG), FALSE);

            diskData->CurrentIsPowerProtected = FALSE;
        }

        CheckDlgButton(HWnd, IDC_DISK_POLICY_PP_CACHE, diskData->CurrentIsPowerProtected);
    }
    else
    {
        //
        // Either we could not open a handle to the device
        // or this  device does  not support write caching
        //
        diskData->IsCachingPolicy = FALSE;

        ShowWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_WRITE_CACHE), SW_HIDE);
        ShowWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_WRITE_CACHE_MESG), SW_HIDE);

        ShowWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_PP_CACHE), SW_HIDE);
        ShowWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_PP_CACHE_MESG), SW_HIDE);
    }

    //
    // Obtain the Removal Policy
    //
    status = GetRemovalPolicy(diskData);

    if (status == ERROR_SUCCESS)
    {
        //
        // Check to see if the drive is removable
        //
        if ((diskData->DefaultRemovalPolicy == CM_REMOVAL_POLICY_EXPECT_ORDERLY_REMOVAL) ||
            (diskData->DefaultRemovalPolicy == CM_REMOVAL_POLICY_EXPECT_SURPRISE_REMOVAL))
        {
            if (diskData->CurrentRemovalPolicy == CM_REMOVAL_POLICY_EXPECT_SURPRISE_REMOVAL)
            {
                CheckRadioButton(HWnd, IDC_DISK_POLICY_SURPRISE, IDC_DISK_POLICY_ORDERLY, IDC_DISK_POLICY_SURPRISE);

                UpdateCachingPolicy(HWnd, diskData);
            }

            ShowWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_DEFAULT), SW_SHOW);
        }
        else
        {
            //
            // The removal policy on fixed disks cannot be modified
            //
            EnableWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_SURPRISE), FALSE);
            EnableWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_SURPRISE_MESG), FALSE);

            //
            // Replace the SysLink with static text
            //
            ShowWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_ORDERLY_MESG), SW_HIDE);
            ShowWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_ORDERLY_MSGD), SW_SHOW);

            EnableWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_ORDERLY), FALSE);
            EnableWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_ORDERLY_MSGD), FALSE);
        }
    }
    else
    {
        //
        // We could not obtain a removal policy
        //
        EnableWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_SURPRISE), FALSE);
        EnableWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_SURPRISE_MESG), FALSE);

        //
        // Replace the SysLink with static text
        //
        ShowWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_ORDERLY_MESG), SW_HIDE);
        ShowWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_ORDERLY_MSGD), SW_SHOW);

        EnableWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_ORDERLY), FALSE);
        EnableWindow(GetDlgItem(HWnd, IDC_DISK_POLICY_ORDERLY_MSGD), FALSE);
    }

    SetWindowLongPtr(HWnd, DWLP_USER, (LONG_PTR) diskData);

    return TRUE;
}


VOID
DiskOnCommand(HWND HWnd, INT id, HWND HWndCtl, UINT codeNotify)
{
    PDISK_PAGE_DATA diskData = (PDISK_PAGE_DATA) GetWindowLongPtr(HWnd, DWLP_USER);

    switch (id)
    {
        case IDC_DISK_POLICY_SURPRISE:
        {
            diskData->CurrentRemovalPolicy = CM_REMOVAL_POLICY_EXPECT_SURPRISE_REMOVAL;

            UpdateCachingPolicy(HWnd, diskData);
            PropSheet_Changed(GetParent(HWnd), HWnd);
            break;
        }

        case IDC_DISK_POLICY_ORDERLY:
        {
            diskData->CurrentRemovalPolicy = CM_REMOVAL_POLICY_EXPECT_ORDERLY_REMOVAL;

            UpdateCachingPolicy(HWnd, diskData);
            PropSheet_Changed(GetParent(HWnd), HWnd);
            break;
        }

        case IDC_DISK_POLICY_WRITE_CACHE:
        {
            diskData->CurrWriteCacheSetting = !diskData->CurrWriteCacheSetting;

            UpdateCachingPolicy(HWnd, diskData);
            PropSheet_Changed(GetParent(HWnd), HWnd);
            break;
        }

        case IDC_DISK_POLICY_PP_CACHE:
        {
            diskData->CurrentIsPowerProtected = !diskData->CurrentIsPowerProtected;

            PropSheet_Changed(GetParent(HWnd), HWnd);
            break;
        }

        case IDC_DISK_POLICY_DEFAULT:
        {
            if (diskData->CurrentRemovalPolicy != diskData->DefaultRemovalPolicy)
            {
                diskData->CurrentRemovalPolicy = diskData->DefaultRemovalPolicy;

                if (diskData->CurrentRemovalPolicy == CM_REMOVAL_POLICY_EXPECT_ORDERLY_REMOVAL)
                {
                    CheckRadioButton(HWnd, IDC_DISK_POLICY_SURPRISE, IDC_DISK_POLICY_ORDERLY, IDC_DISK_POLICY_ORDERLY);
                }
                else
                {
                    CheckRadioButton(HWnd, IDC_DISK_POLICY_SURPRISE, IDC_DISK_POLICY_ORDERLY, IDC_DISK_POLICY_SURPRISE);
                }

                UpdateCachingPolicy(HWnd, diskData);
                PropSheet_Changed(GetParent(HWnd), HWnd);
            }

            break;
        }
    }
}


LRESULT
DiskOnNotify(HWND HWnd, INT HWndFocus, LPNMHDR lpNMHdr)
{
    PDISK_PAGE_DATA diskData = (PDISK_PAGE_DATA) GetWindowLongPtr(HWnd, DWLP_USER);

    switch (lpNMHdr->code)
    {
        case PSN_APPLY:
        {
            if (diskData->IsCachingPolicy)
            {
                if ((diskData->CurrWriteCacheSetting != diskData->OrigWriteCacheSetting) ||
                    (diskData->CacheSetting.IsPowerProtected != diskData->CurrentIsPowerProtected))
                {
                    SetCachingPolicy(diskData);
                }
            }

            if (((diskData->CurrentRemovalPolicy == CM_REMOVAL_POLICY_EXPECT_ORDERLY_REMOVAL) && (diskData->HotplugInfo.DeviceHotplug == TRUE)) ||
                ((diskData->CurrentRemovalPolicy == CM_REMOVAL_POLICY_EXPECT_SURPRISE_REMOVAL) && (diskData->HotplugInfo.DeviceHotplug == FALSE)))
            {
                SetRemovalPolicy(HWnd, diskData);
            }

            break;
        }

        case NM_RETURN:
        case NM_CLICK:
        {
            TCHAR szPath[MAX_PATH] = { 0 };

            LoadString(ModuleInstance, IDS_DISK_POLICY_HOTPLUG, szPath, MAX_PATH);

            ShellExecute(NULL, _T("open"), _T("RUNDLL32.EXE"), szPath, NULL, SW_SHOWNORMAL);

            break;
        }

    }

    return 0;
}


VOID
DiskContextMenu(HWND HwndControl, WORD Xpos, WORD Ypos)
{
    WinHelp(HwndControl, _T("devmgr.hlp"), HELP_CONTEXTMENU, (ULONG_PTR) DiskHelpIDs);
}


VOID
DiskHelp(HWND ParentHwnd, LPHELPINFO HelpInfo)
{
    if (HelpInfo->iContextType == HELPINFO_WINDOW)
    {
        WinHelp((HWND) HelpInfo->hItemHandle, _T("devmgr.hlp"), HELP_WM_HELP, (ULONG_PTR) DiskHelpIDs);
    }
}


INT_PTR
DiskDialogProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam)
{
    switch(Message)
    {
        HANDLE_MSG(hWnd, WM_INITDIALOG, DiskOnInitDialog);
        HANDLE_MSG(hWnd, WM_COMMAND,    DiskOnCommand);
        HANDLE_MSG(hWnd, WM_NOTIFY,     DiskOnNotify);

        case WM_SETCURSOR:
        {
            //
            // Temporary workaround to prevent the user from
            // making any more changes and giving the effect
            // that something is happening
            //
            PDISK_PAGE_DATA diskData = (PDISK_PAGE_DATA) GetWindowLongPtr(hWnd, DWLP_USER);

            if (diskData->IsBusy)
            {
                SetCursor(LoadCursor(NULL, IDC_WAIT));
                SetWindowLongPtr(hWnd, DWLP_MSGRESULT, TRUE);
                return TRUE;
            }

            break;
        }

        case WM_CONTEXTMENU:
            DiskContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_HELP:
            DiskHelp(hWnd, (LPHELPINFO)lParam);
            break;
    }

    return FALSE;
}


BOOL
DiskDialogCallback(HWND HWnd, UINT Message, LPPROPSHEETPAGE Page)
{
    switch (Message)
    {
        case PSPCB_CREATE:
        {
            break;
        }

        case PSPCB_RELEASE:
        {
            PDISK_PAGE_DATA pData = (PDISK_PAGE_DATA) Page->lParam;

            HeapFree(GetProcessHeap(), 0, pData);
            break;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\port\scsi\miniport\mylex\dmc960\dac960nt.c ===
/************************************************************************
*									*
*		COPYRIGHT (C) Mylex Corporation 1994			*
*									*
*	This software is furnished under a license and may be used	*
*	and copied only in accordance with the terms and conditions	*
*	of such license and with inclusion of the the above copyright	*
*	notice.  This software or any other copies therof may not be	*
*	provided or otherwise made available to any other person.  No	*
*	title to and ownership of the software is hereby transfered.	*
*									*
*	The information in this software is subject to change without	*
*	notices and should not be construed as a committmet by Mylex	*
*	Corporation.							*
*									*
************************************************************************/

/*
   File       : dac960nt.c
   Description: Mylex DAC960 SCSI miniport driver - for Windows NT

   Version    : 1.12

   Revision   :

   Ver 1.10   : First Release
   Ver 1.11   : Added 32GB Support 
   Ver 1.12   : Driver was not getting loaded in Windows NT (Daytona)
              : Physical Addresses can be obtained only for certain
              : Virtual Addresses.
              : Added code to determine No.Of Channels supported by Adaptor.

*/

#include "miniport.h"

#include "dac960nt.h"


#define NODEVICESCAN            0
#define REPORTSPURIOUS          0     // Somewhat overwhelming in ARCMODE
#define MAXLOGICALADAPTERS      4
#define MYPRINT                 0

#define DELAY(x)                ScsiPortStallExecution( (x) * 1000 )

#if MYPRINT

#define PRINT(f, a, b, c, d) dachlpPrintf(deviceExtension, f, a, b, c, d)

ULONG   dachlpColumn = 0;
UCHAR   dachlpHex[] = "0123456789ABCDEF";
VOID    dachlpPutchar(PUSHORT BaseAddr, UCHAR c);
VOID    dachlpPrintHex(PUSHORT BaseAddr, ULONG v, ULONG len);
VOID    dachlpPrintf(PHW_DEVICE_EXTENSION deviceExtension,
                     PUCHAR fmt,
                     ULONG a1,
                     ULONG a2,
                     ULONG a3,
                     ULONG a4);
#else
#define PRINT(f, a, b, c, d)
#endif


// The DAC EISA id and mask

CONST UCHAR     eisa_id[]   = DAC_EISA_ID;
CONST UCHAR     eisa_mask[] = DAC_EISA_MASK;


// Function declarations
//
// Functions that start with 'Dac960Nt' are entry points
// for the OS port driver.
// Functions that start with 'dachlp' are helper functions.
//

ULONG
DriverEntry(
    IN PVOID DriverObject,
    IN PVOID Argument2
);

ULONG
Dac960NtEntry(
    IN PVOID DriverObject,
    IN PVOID Argument2
);

ULONG
Dac960NtConfiguration(
    IN PVOID DeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
);

BOOLEAN
Dac960NtInitialize(
    IN PVOID DeviceExtension
);

BOOLEAN
Dac960NtStartIo(
    IN PVOID DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
);

BOOLEAN
Dac960NtInterrupt(
    IN PVOID DeviceExtension
);

BOOLEAN
Dac960NtResetBus(
    IN PVOID HwDeviceExtension,
    IN ULONG PathId
);


BOOLEAN
dachlpDiskRequest(
    IN PHW_DEVICE_EXTENSION deviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
);

VOID
dachlpSendMBOX(
    IN PUCHAR EisaAddress,
    IN PDAC_MBOX mbox
);


BOOLEAN
dachlpContinueDiskRequest(
    IN PHW_DEVICE_EXTENSION deviceExtension,
    IN ULONG index,
    IN BOOLEAN Start
);

BOOLEAN
dachlpDiskRequestDone(
    IN PHW_DEVICE_EXTENSION deviceExtension,
    IN ULONG index,
    IN UCHAR Status
);


USHORT dachlpGetM16(PUCHAR p);
ULONG  dachlpGetM24(PUCHAR p);
ULONG  dachlpGetM32(PUCHAR p);
void   dachlpPutM16(PUCHAR p, USHORT s);
void   dachlpPutM24(PUCHAR p, ULONG l);
void   dachlpPutM32(PUCHAR p, ULONG l);
void   dachlpPutI16(PUCHAR p, USHORT s);
void   dachlpPutI32(PUCHAR p, ULONG l);
ULONG  dachlpSwapM32(ULONG l);

ULONG
DriverEntry (
    IN PVOID DriverObject,
    IN PVOID Argument2
)

/*++

Routine Description:

	Installable driver initialization entry point for system.

Arguments:

	Driver Object

Return Value:

	Status from ScsiPortInitialize()

--*/

{
	return Dac960NtEntry(DriverObject, Argument2);

} // end DriverEntry()



ULONG
Dac960NtEntry(
	IN PVOID DriverObject,
	IN PVOID Argument2
	)

/*++

Routine Description:

	This routine is called from DriverEntry if this driver is installable
	or directly from the system if the driver is built into the kernel.
	It scans the EISA slots looking for DAC960 host adapters.

Arguments:

	Driver Object

Return Value:

	Status from ScsiPortInitialize()

--*/

{
	HW_INITIALIZATION_DATA hwInitializationData;
	ULONG i;
	SCANCONTEXT     context;



	// Zero out structure.

	for (i=0; i<sizeof(HW_INITIALIZATION_DATA); i++)
		((PUCHAR)&hwInitializationData)[i] = 0;

	context.Slot         = 0;
	context.AdapterCount = 0;

	// Set size of hwInitializationData.

	hwInitializationData.HwInitializationDataSize = sizeof(HW_INITIALIZATION_DATA);

	// Set entry points.

	hwInitializationData.HwInitialize  = Dac960NtInitialize;
	hwInitializationData.HwFindAdapter = Dac960NtConfiguration;
	hwInitializationData.HwStartIo     = Dac960NtStartIo;
	hwInitializationData.HwInterrupt   = Dac960NtInterrupt;
	hwInitializationData.HwResetBus    = Dac960NtResetBus;

	// Set number of access ranges and bus type.

	hwInitializationData.NumberOfAccessRanges = 1;
	hwInitializationData.AdapterInterfaceType = Eisa;

	// Indicate no buffer mapping.
	// Indicate will need physical addresses.

        hwInitializationData.MapBuffers            = TRUE; //FALSE;
	hwInitializationData.NeedPhysicalAddresses = TRUE;


	// Indicate auto request sense is supported.

	hwInitializationData.AutoRequestSense     = TRUE;
	hwInitializationData.MultipleRequestPerLu = TRUE;

	// Specify size of extensions.

	hwInitializationData.DeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

	// Ask for SRB extensions.

        hwInitializationData.SrbExtensionSize = 17*8 + 90;


	return(ScsiPortInitialize(DriverObject, Argument2, &hwInitializationData, &context));

} // end Dac960NtEntry()



ULONG
Dac960NtConfiguration(
    IN PVOID HwDeviceExtension,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
)

/*++

Routine Description:

	This function is called by the OS-specific port driver after
	the necessary storage has been allocated, to gather information
	about the adapter's configuration.

Arguments:

	HwDeviceExtension - HBA miniport driver's adapter data storage
	ConfigInfo - Configuration information structure describing HBA

Return Value:

	TRUE if adapter present in system

--*/

{
	PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
	ULONG        eisaSlotNumber;
	PUCHAR       eisaAddress;
	PSCANCONTEXT context = Context;
	ULONG        uniqueID;
	ULONG        length;
	UCHAR        abyte;
	BOOLEAN      found=FALSE;
	BOOLEAN      scsiThing=FALSE;
	ULONG        IrqLevel;
	ULONG        RangeStart, RangeLength;
	DAC_MBOX     mbox;
	ULONG        cnt;
	UCHAR        dbell, status, errcode;
        PUCHAR       charptr;
        UCHAR        i, j;
        ULONG        Bios_Base;


        // Scan for DAC EISA id

        for(eisaSlotNumber=context->Slot + 1; eisaSlotNumber<MAXIMUM_EISA_SLOTS; eisaSlotNumber++) {

        // Update the slot count to indicate this slot has been checked.

        context->Slot++;

#if MYPRINT
	deviceExtension->printAddr =
	    ScsiPortGetDeviceBase(
		deviceExtension,
		ConfigInfo->AdapterInterfaceType,
		ConfigInfo->SystemIoBusNumber,
		ScsiPortConvertUlongToPhysicalAddress((ULONG)0xb8000),
				0x1000,
		(BOOLEAN) FALSE);         // InIoSpace
#endif

        DebugPrint((1,"\n\nDAC960 Adaptor MiniPort Driver\n"));

	// Get the system address for this card. The card uses I/O space.

        eisaAddress = ScsiPortGetDeviceBase(deviceExtension,
                                ConfigInfo->AdapterInterfaceType,
                                ConfigInfo->SystemIoBusNumber,
                                ScsiPortConvertUlongToPhysicalAddress(0x1000 * eisaSlotNumber),
                                0x100,
                                TRUE);

        // Look at EISA id

        for(found=TRUE, i=0; i<EISA_ID_COUNT; i++) {
           abyte = ScsiPortReadPortUchar(eisaAddress+EISA_ID_START+i);
           if(((UCHAR)(abyte & eisa_mask[i])) != eisa_id[i] ) {
               found = FALSE;
               break;
           }
        }
		   
        if(found) {
             break;
        }

        // If an adapter was not found unmap it.

        ScsiPortFreeDeviceBase(deviceExtension, eisaAddress);

	} // end for (eisaSlotNumber ...


        if(!found) {

            // No adapter was found.  Indicate that we are done and there 
            // are no more adaptors.

            *Again = FALSE;
            return SP_RETURN_NOT_FOUND;
        }

        ScsiPortWritePortUchar(eisaAddress+BMIC_LOCAL_DB, 2);

        for(i=0;i<MAX_WAIT_SECS;i++) {
           if((ScsiPortReadPortUchar(eisaAddress+BMIC_LOCAL_DB) & 2) == 0)
               break;

           DELAY(1000);
        }

        status = ScsiPortReadPortUchar(eisaAddress+BMIC_MBOX+0x0e);
        errcode = ScsiPortReadPortUchar(eisaAddress+BMIC_MBOX+0x0f);
			
        if(i == MAX_WAIT_SECS) {

            // Adapter timed out, so register error 

            status = HERR;
            errcode = ERR;
        }

        // Log the error.

        if((status == ABRT) && (errcode == ERR)) {
             uniqueID = INSTL_ABRT;
        }
        else if((status == FWCHK) && (errcode == ERR)) {
             uniqueID = INSTL_FWCK;
        }
        else if((status == HERR) && (errcode == ERR)) {
             uniqueID = INSTL_HERR;
        }
        else
             uniqueID = 0; 

        if(uniqueID) {

            ScsiPortLogError(
                HwDeviceExtension,
                NULL,
                0,
                0,
                0,
                SP_INTERNAL_ADAPTER_ERROR,
                uniqueID
            );

            *Again = FALSE;
            return SP_RETURN_NOT_FOUND;
        }



	deviceExtension->AdapterIndex = context->AdapterCount;
	context->AdapterCount++;

	if(context->AdapterCount < MAXLOGICALADAPTERS)
		*Again = TRUE;
	else
		*Again = FALSE;


	// There is still more to look at.
	// Get the system interrupt vector and IRQL.

	abyte = ScsiPortReadPortUchar(eisaAddress+EISA_INTR);
	abyte &= 0x60;

	switch(abyte) {

        case 0:
             IrqLevel=15;
             break;

        case 0x20:
             IrqLevel=11;
             break;

        case 0x40:
             IrqLevel=12;
             break;

        case 0x60:
             IrqLevel=14;
             break;
        }


	ConfigInfo->BusInterruptLevel = IrqLevel;


	// Disable DAC interrupts

	ScsiPortWritePortUchar(eisaAddress+BMIC_EISA_DB_ENABLE, 0);
	ScsiPortWritePortUchar(eisaAddress+BMIC_SYSINTCTRL, 0);

	// Indicate maximum transfer length in bytes.

	ConfigInfo->MaximumTransferLength = 0xf000;

	// Maximum number of physical segments is 16.

        ConfigInfo->NumberOfPhysicalBreaks = 16;

	// Fill in the access array information.

        RangeStart  = (0x1000 * eisaSlotNumber) + EISA_ADDRESS_BASE;
        RangeLength = 0x100;

	(*ConfigInfo->AccessRanges)[0].RangeStart =
		ScsiPortConvertUlongToPhysicalAddress(RangeStart);
	(*ConfigInfo->AccessRanges)[0].RangeLength = RangeLength;
	(*ConfigInfo->AccessRanges)[0].RangeInMemory = FALSE;

	ConfigInfo->ScatterGather     = TRUE;
	ConfigInfo->Master            = TRUE;
	ConfigInfo->CachesData        = TRUE;
	ConfigInfo->Dma32BitAddresses = TRUE;   // Find out whether this costs


	// Allocate a Noncached Extension to use for mail boxes.

	deviceExtension->NoncachedExtension = ScsiPortGetUncachedExtension(
						deviceExtension,
						ConfigInfo,
						sizeof(NONCACHED_EXTENSION));

	if (deviceExtension->NoncachedExtension == NULL) {
             return(SP_RETURN_ERROR);
        }


	// Get Physical Address of NoncachedExtension.

	deviceExtension->NCE_PhyAddr =
		   ScsiPortConvertPhysicalAddressToUlong(
			ScsiPortGetPhysicalAddress(deviceExtension,
				 NULL,
				 deviceExtension->NoncachedExtension,
				 &length));

	deviceExtension->EisaAddress = eisaAddress;

        // Determine No of SCSI Channels supported by this adaptor


	for(i = 0; i < MAXCHANNEL; i++) {

	    mbox.generalmbox.Byte0 = DAC_GETDEVST;
	    mbox.generalmbox.Byte1 = 0;
	    mbox.generalmbox.Byte2 = i;
	    mbox.generalmbox.Byte3 = 0;


	    (*((ULONG *) &mbox.generalmbox.Byte8)) = deviceExtension->NCE_PhyAddr + (PUCHAR)(& deviceExtension->NoncachedExtension->DevParms) - (PUCHAR)deviceExtension->NoncachedExtension;

	    dachlpSendMBOX(eisaAddress, &mbox);

	    for(cnt = 0; cnt < 0x10000; cnt++) {
		dbell = ScsiPortReadPortUchar(eisaAddress+BMIC_EISA_DB);

		if(dbell & 1) break;

		ScsiPortStallExecution(100);
	    }

	    status = ScsiPortReadPortUchar(eisaAddress+BMIC_MBOX+0x0e);
	    errcode = ScsiPortReadPortUchar(eisaAddress+BMIC_MBOX+0x0f);

	    ScsiPortWritePortUchar(eisaAddress+BMIC_EISA_DB, dbell);
	    ScsiPortWritePortUchar(eisaAddress+BMIC_LOCAL_DB, 2);


	    if( (errcode << 8 | status) == 0x105) break;
	 }

	 // Store host adapter SCSI id

	 ConfigInfo->NumberOfBuses    = i;
	 deviceExtension->MaxChannels = i;

	 for(j = 0; j < i; j++)
	    ConfigInfo->InitiatorBusId[j] = 7;

  

	// Check for edge/level interrupt

	mbox.dpmbox.Command  = DAC_ENQ2;
	mbox.dpmbox.Id       = 0;
	mbox.dpmbox.PhysAddr = deviceExtension->NCE_PhyAddr + (PUCHAR)(& deviceExtension->NoncachedExtension->DevParms) - (PUCHAR)deviceExtension->NoncachedExtension;

	DebugPrint((1,"DAC: Sending ENQ2\n"));

	dachlpSendMBOX(eisaAddress, &mbox);

	// Poll the complete bit

	for(cnt=0; cnt < 0x10000; cnt++) {
           dbell = ScsiPortReadPortUchar(eisaAddress+BMIC_EISA_DB);

           if(dbell & 1)   break;

           ScsiPortStallExecution(100);
        }

	DebugPrint((1,"DAC: ENQ2 Done\n"));

	status = ScsiPortReadPortUchar(eisaAddress+BMIC_MBOX+0x0e);
	errcode = ScsiPortReadPortUchar(eisaAddress+BMIC_MBOX+0x0f);

	ScsiPortWritePortUchar(eisaAddress+BMIC_EISA_DB, dbell);
	ScsiPortWritePortUchar(eisaAddress+BMIC_LOCAL_DB, 2);


	if(status || errcode)
            ConfigInfo->InterruptMode =  LevelSensitive;
	else {
            charptr = (PUCHAR) &deviceExtension->NoncachedExtension;

            if(charptr[ILFLAG] & BIT0)
                ConfigInfo->InterruptMode =  LevelSensitive;
            else
                ConfigInfo->InterruptMode =  Latched;
        }


	deviceExtension->HostTargetId = ConfigInfo->InitiatorBusId[0];

//      deviceExtension->ShutDown = FALSE;


	// Setup our private control structures

	deviceExtension->PendingSrb   = NULL;
	deviceExtension->PendingNDSrb = NULL;
	deviceExtension->NDPending    = 0;
	deviceExtension->ActiveCmds   = 0;

	for(i = 0; i < DAC_MAX_IOCMDS; i++) {
           deviceExtension->ActiveSrb[i] = NULL;
        }

	deviceExtension->Kicked        = FALSE;
	deviceExtension->ActiveScsiSrb = NULL;

	return SP_RETURN_FOUND;

} // end Dac960NtConfiguration()




BOOLEAN
Dac960NtInitialize(
	IN PVOID HwDeviceExtension
	)

/*++

Routine Description:

	Inititialize adapter.

Arguments:

	HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

	TRUE - if initialization successful.
	FALSE - if initialization unsuccessful.

--*/

{
	PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
	PNONCACHED_EXTENSION NoncachedExtension;
	PUCHAR               EisaAddress;
	DAC_MBOX             mbox;
	PDAC_DPT             dpt;
	ULONG                i, cnt, length, unit, target, cyls, hds, spt;
	UCHAR                dbell, status, errcode;
        PDIRECT_CDB          dacdcdb;
	int                  channel;
        


	NoncachedExtension = deviceExtension->NoncachedExtension;
	EisaAddress = deviceExtension->EisaAddress;


	// Disable DAC interrupts

	ScsiPortWritePortUchar(EisaAddress+BMIC_EISA_DB_ENABLE, 0);
	ScsiPortWritePortUchar(EisaAddress+BMIC_SYSINTCTRL, 0);


	// Scan for devices
	// Preset end mark in case DAC does not respond

        dpt = & NoncachedExtension->DevParms;
	dpt->No_Drives = 0;

	// Setup mailbox

	mbox.dpmbox.Command  = DAC_ENQUIRE;
	mbox.dpmbox.Id       = 0;
	mbox.dpmbox.PhysAddr = deviceExtension->NCE_PhyAddr;

	DebugPrint((1,"DAC: Sending ENQUIRE\n"));

	dachlpSendMBOX(EisaAddress, &mbox);

	// Poll the complete bit

	for(cnt=0; cnt < 0x10000; cnt++) {

            dbell = ScsiPortReadPortUchar(EisaAddress+BMIC_EISA_DB);
            if(dbell & 1)  break;

            ScsiPortStallExecution(100);
        }

	DebugPrint((1,"DAC: ENQUIRE Done\n"));

	status = ScsiPortReadPortUchar(EisaAddress+BMIC_MBOX+0x0e);
	errcode = ScsiPortReadPortUchar(EisaAddress+BMIC_MBOX+0x0f);

	ScsiPortWritePortUchar(EisaAddress+BMIC_EISA_DB, dbell);
	ScsiPortWritePortUchar(EisaAddress+BMIC_LOCAL_DB, 2);


        deviceExtension->MaxCmds = dpt->max_io_cmds;
        deviceExtension->No_SysDrives = dpt->No_Drives;


        // Now check for Non-Disk devices

	dacdcdb = (PDIRECT_CDB)NoncachedExtension->Buffer;


	mbox.dpmbox.PhysAddr = deviceExtension->NCE_PhyAddr + (NoncachedExtension->Buffer - (PUCHAR)NoncachedExtension);

	dacdcdb->ptr = mbox.dpmbox.PhysAddr + DATA_OFFSET;

	mbox.dpmbox.Command = DAC_DCDB;
	dacdcdb->cdb_len    = 6;
	dacdcdb->sense_len  = 0;
	dacdcdb->dir        = 0x80 + DAC_IN;
	dacdcdb->cdb[0]     = 0x12;
	dacdcdb->cdb[1]     = 0;
	dacdcdb->cdb[2]     = 0;
	dacdcdb->cdb[3]     = 0;
	dacdcdb->cdb[4]     = 0x30;
	dacdcdb->cdb[5]     = 0;

        for(target = 0; target < MAXTARGET; target++) {
                deviceExtension->ND_DevMap[target] = 0xff;
        }

        for(channel = 0; channel < deviceExtension->MaxChannels; channel++)
           for(target = 1; target < MAXTARGET; target++) {

               if(deviceExtension->ND_DevMap[target] != 0xff) continue;

               NoncachedExtension->Buffer[DATA_OFFSET]=0; //Just in case

               dacdcdb->byte_cnt = 0x30;
               dacdcdb->device   = (channel << 4) | target;

               dachlpSendMBOX(EisaAddress, &mbox);

               // Poll the complete bit

               for(cnt=0; cnt < 0x10000; cnt++) {
                  dbell = ScsiPortReadPortUchar(EisaAddress+BMIC_EISA_DB);

                  if(dbell & 1) break;

                  ScsiPortStallExecution(100);
               }

               status = ScsiPortReadPortUchar(EisaAddress+BMIC_MBOX+0x0e);
               errcode = ScsiPortReadPortUchar(EisaAddress+BMIC_MBOX+0x0f);

               if((status == 0) && (errcode == 0) && NoncachedExtension->Buffer[DATA_OFFSET])   {
                    deviceExtension->ND_DevMap[target] = channel;
               }
		
               ScsiPortWritePortUchar(EisaAddress+BMIC_EISA_DB, dbell);
               ScsiPortWritePortUchar(EisaAddress+BMIC_LOCAL_DB, 2);
          }


	// Enable DAC interrupts

	ScsiPortWritePortUchar(EisaAddress+BMIC_EISA_DB_ENABLE, 1);
	ScsiPortWritePortUchar(EisaAddress+BMIC_SYSINTCTRL, BMIC_SIC_ENABLE);


	return(TRUE);

} // end Dac960NtInitialize()


BOOLEAN
Dac960NtStartIo(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
)

/*++

Routine Description:

	This routine is called from the SCSI port driver synchronized
	with the kernel to start a request

Arguments:

	HwDeviceExtension - HBA miniport driver's adapter data storage
	Srb - IO request packet

Return Value:

	TRUE

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_REQUEST_BLOCK  abortedSrb;
    ULONG                i = 0;
    BOOLEAN              status;
    PUCHAR               dptr;

    switch(Srb->Function) {

    case SRB_FUNCTION_SHUTDOWN:
         //    deviceExtension->ShutDown = TRUE;
    
    case SRB_FUNCTION_FLUSH:

         //    DELAY(1000);

    case SRB_FUNCTION_IO_CONTROL:
    case SRB_FUNCTION_EXECUTE_SCSI:

         status = dachlpDiskRequest(deviceExtension, Srb);

         if(status == FALSE) {

             PSCSI_REQUEST_BLOCK pnextsrb, *ptr;

             // Queue it up in t he right queue.

             if(Srb->Function != SRB_FUNCTION_IO_CONTROL) {
                 if(Srb->TargetId)
                 {
                     // Save the request until a pending one completes.

                     if(deviceExtension->PendingNDSrb != NULL) {
                         pnextsrb = deviceExtension->PendingNDSrb;
                         deviceExtension->PendingNDSrb = Srb;
                         ptr=(PSCSI_REQUEST_BLOCK *)Srb->SrbExtension;
                         *ptr=pnextsrb;
                     }
                     else {
                         // Put this request on queue

                         deviceExtension->PendingNDSrb = Srb;
                         ptr=(PSCSI_REQUEST_BLOCK *)Srb->SrbExtension;
                         *ptr=(PSCSI_REQUEST_BLOCK)0l;
                     }
                 }
                 else
                 {
                        // Save the request until a pending one completes.
                        if(deviceExtension->PendingSrb != NULL) {
                            pnextsrb=deviceExtension->PendingSrb;
                            deviceExtension->PendingSrb=Srb;
                            ptr=(PSCSI_REQUEST_BLOCK *)Srb->SrbExtension;
                            *ptr=pnextsrb;
                        }
                        else {
                            // Put this request on queue
                            deviceExtension->PendingSrb = Srb;
                            ptr=(PSCSI_REQUEST_BLOCK *)Srb->SrbExtension;
                            *ptr=(PSCSI_REQUEST_BLOCK)0l;
                        }
                  }
              }
              else {
                  Srb->SrbStatus = SRB_STATUS_BUSY;
                  ScsiPortNotification(RequestComplete, deviceExtension, Srb);
              }

              return(TRUE);
          }

          // Adapter ready for next request.

          if(Srb->Function != SRB_FUNCTION_IO_CONTROL)
          {
               ScsiPortNotification(NextLuRequest,
                                    deviceExtension,
                                    Srb->PathId,
                                    Srb->TargetId,
                                    Srb->Lun);
          }
          else
          {
               ScsiPortNotification(NextRequest,
			            deviceExtension);

          }

          return(TRUE);


     case SRB_FUNCTION_ABORT_COMMAND:

          Srb->SrbStatus = SRB_STATUS_ABORT_FAILED;

          // Abort request completed with error

          ScsiPortNotification(RequestComplete, deviceExtension, Srb);

          // Adapter ready for next request.

          ScsiPortNotification(NextLuRequest,
                               deviceExtension,
                               Srb->PathId,
                               Srb->TargetId,
                               Srb->Lun);

          return(TRUE);


     case SRB_FUNCTION_RESET_BUS:
     default:

          // Set error, complete request
          // and signal ready for next request.

          Srb->SrbStatus = SRB_STATUS_SUCCESS;  

          ScsiPortNotification(RequestComplete, deviceExtension, Srb);

          ScsiPortNotification(NextLuRequest,
                               deviceExtension,
                               Srb->PathId,
                               Srb->TargetId,
                               Srb->Lun);

          return(TRUE);

     }    // end switch

}    // end Dac960NtStartIo()




BOOLEAN
Dac960NtInterrupt(
    IN PVOID HwDeviceExtension
)

/*++

Routine Description:

	This is the interrupt service routine for the DAC960 SCSI adapter.
	It reads the interrupt register to determine if the adapter is indeed
	the source of the interrupt and clears the interrupt at the device.

Arguments:

	HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

	TRUE if we handled the interrupt

--*/

{
	PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
	PUCHAR EisaAddress;
	ULONG index;
	UCHAR interruptStatus;
	UCHAR status;
	UCHAR errcode;

	PSCSI_REQUEST_BLOCK Srb;


	EisaAddress = deviceExtension->EisaAddress;



		//
		// Check interrupt pending.
		//
		ScsiPortWritePortUchar(EisaAddress+BMIC_EISA_DB_ENABLE, 0);
		interruptStatus = ScsiPortReadPortUchar(EisaAddress+BMIC_EISA_DB);
		ScsiPortWritePortUchar(EisaAddress+BMIC_EISA_DB, interruptStatus);
		ScsiPortWritePortUchar(EisaAddress+BMIC_EISA_DB_ENABLE, 1);
		if(!(interruptStatus & 1)) {
			return FALSE;
			}


		//
		// Read interrupt status from BMIC and acknowledge
		//
		//
//              interruptStatus = ScsiPortReadPortUchar(EisaAddress+BMIC_EISA_DB);

		status = ScsiPortReadPortUchar(EisaAddress+BMIC_MBOX+0x0e);
		errcode = ScsiPortReadPortUchar(EisaAddress+BMIC_MBOX+0x0f);


		//
		// TAGTAG Add tagging support here: find
		// index of RCB for interrupting request
		//
		index = ScsiPortReadPortUchar(EisaAddress+BMIC_MBOX+0x0d);
		ScsiPortWritePortUchar(EisaAddress+BMIC_LOCAL_DB, 2);


/*
		// Check...
		if(deviceExtension->ActiveCmds<=0) {
			// No one there interrupting us
			return(TRUE);
			}
*/




		//
		// Check whether this SRB is actually running
		//
		if(deviceExtension->ActiveSrb[index] == NULL) {
			// No one there interrupting us, again
			return(TRUE);
			}
		Srb=deviceExtension->ActiveSrb[index];


		// Update DAC status fields in RCB
		deviceExtension->ActiveRcb[index].DacStatus = status;
		deviceExtension->ActiveRcb[index].DacErrcode = errcode;


		// Continue or finish the interrupting SRB request
		dachlpContinueDiskRequest(deviceExtension, index, FALSE);


		if(deviceExtension->ActiveCmds < deviceExtension->MaxCmds) {
			// A request slot is free now
			// Check for pending non_disk requests.
			// If there is one then start it now.

			if((deviceExtension->NDPending==0) && (deviceExtension->PendingNDSrb != NULL)) {
				PSCSI_REQUEST_BLOCK anotherSrb,*ptr;

				anotherSrb = deviceExtension->PendingNDSrb;
				ptr=(PSCSI_REQUEST_BLOCK *)anotherSrb->SrbExtension;
				deviceExtension->PendingNDSrb = *ptr;
				Dac960NtStartIo(deviceExtension, anotherSrb);
				}
			}
		if(deviceExtension->ActiveCmds < deviceExtension->MaxCmds) {
			// A request slot is free now
			// Check for pending requests.
			// If there is one then start it now.

			if(deviceExtension->PendingSrb != NULL) {
				PSCSI_REQUEST_BLOCK anotherSrb,*ptr;

				anotherSrb = deviceExtension->PendingSrb;
				ptr=(PSCSI_REQUEST_BLOCK *)anotherSrb->SrbExtension;
				deviceExtension->PendingSrb = *ptr;
				Dac960NtStartIo(deviceExtension, anotherSrb);
				}
			}

		// Definitely was our interrupt...
		return TRUE;

} // end Dac960NtInterrupt()




BOOLEAN
dachlpDiskRequest(
    IN PHW_DEVICE_EXTENSION deviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
)

/*++

Routine Description:

	Build disk request from SRB and send it to the DAC

Arguments:

	DeviceExtension
	SRB

Return Value:

	TRUE if command was started
	FALSE if host adapter is busy

--*/
{
    ULONG    index;
    PRCB     rcb;
    ULONG    blocks=0, blockAddr=0;
    UCHAR    Target;
    UCHAR    DacCommand;
    ULONG    lsize;
    PUCHAR   pbyte;
    int      i;

    if(Srb->Function == SRB_FUNCTION_IO_CONTROL)
    {
        pbyte = (PUCHAR) Srb->DataBuffer;

        if(pbyte[sizeof(SRB_IO_CONTROL) + 0x10] == 0x99) // INP function.
        {
            USHORT port;
            PUCHAR lport;

            pbyte[sizeof(SRB_IO_CONTROL) + 4] = 0;
            pbyte[sizeof(SRB_IO_CONTROL) + 5] = 0;

            port=((USHORT)(pbyte[sizeof(SRB_IO_CONTROL)+0x12]) << 8) +\
                            (pbyte[sizeof(SRB_IO_CONTROL)+0x13]& 0xff);

            lport=(PUCHAR)deviceExtension->EisaAddress + (port & 0x0fff);

            pbyte[sizeof(SRB_IO_CONTROL) + 0x10]=ScsiPortReadPortUchar(lport);

            Srb->ScsiStatus = SCSISTAT_GOOD;
            Srb->SrbStatus = SRB_STATUS_SUCCESS;

            ScsiPortNotification(RequestComplete, deviceExtension, Srb);

            return(TRUE);
        }

        DacCommand = DAC_DCMD;
        blocks     = 0;  // Actual length filled in later.

        goto give_command;
    }


    if(Srb->TargetId) {

       if(Srb->Lun != 0) {

            // For Non-Disk Devices, LUN is not supported

            // Srb->SrbStatus = SRB_STATUS_INVALID_LUN;
            Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
            ScsiPortNotification(RequestComplete, deviceExtension, Srb);

            return(TRUE);
       }

       if(deviceExtension->ND_DevMap[Srb->TargetId] == 0xff) {

            // We didn't see this Target Device.

            // Srb->SrbStatus = SRB_STATUS_INVALID_TARGET_ID;
            Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
            ScsiPortNotification(RequestComplete, deviceExtension, Srb);

            return(TRUE);
       }

       if(Srb->PathId != deviceExtension->ND_DevMap[Srb->TargetId]) {
            // Target is not present on this channel.

            // Srb->SrbStatus = SRB_STATUS_INVALID_TARGET_ID;
            Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
            ScsiPortNotification(RequestComplete, deviceExtension, Srb);

            return(TRUE);
       }
    }
    else if(Srb->PathId != 0) {
            // System Drives are Mapped to 
            // Channel: 0, Target Id: 0, Lun: 0-7


            // Srb->SrbStatus = SRB_STATUS_INVALID_LUN;
            Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
            ScsiPortNotification(RequestComplete, deviceExtension, Srb);

            return(TRUE);
    }
    else if(Srb->Lun >= deviceExtension->No_SysDrives)     {
            // Srb->SrbStatus = SRB_STATUS_INVALID_LUN;
            Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
            ScsiPortNotification(RequestComplete, deviceExtension, Srb);

            return(TRUE);
    }

    if(Srb->Function == SRB_FUNCTION_EXECUTE_SCSI) {

        PUCHAR dptr;

        DebugPrint((2,"DAC: command= %x\n",Srb->Cdb[0]));

        if(Srb->TargetId)
        {
            DacCommand = DAC_DCDB;
            blocks     = 0;         // Actual length filled in later.

            goto give_command;
        }

        switch(Srb->Cdb[0]) {

        case SCSIOP_READ:

             DacCommand = DAC_LREAD;
             blocks     = (ULONG)dachlpGetM16(&Srb->Cdb[7]);
             blockAddr  = dachlpGetM32(&Srb->Cdb[2]);

             break;

        case SCSIOP_WRITE:
        case SCSIOP_WRITE_VERIFY:

             DacCommand = DAC_LWRITE;
             blocks     = (ULONG)dachlpGetM16(&Srb->Cdb[7]);
             blockAddr  = dachlpGetM32(&Srb->Cdb[2]);

             break;

        case SCSIOP_READ6:

             DacCommand = DAC_LREAD;
             blocks     = (ULONG)Srb->Cdb[4];
             blockAddr  = dachlpGetM24(&Srb->Cdb[1]) & 0x1fffff;

             break;

        case SCSIOP_WRITE6:

             DacCommand = DAC_LWRITE;
             blocks     = (ULONG)Srb->Cdb[4];
             blockAddr  = dachlpGetM24(&Srb->Cdb[1]) & 0x1fffff;

             break;

        case SCSIOP_REQUEST_SENSE:
             break;

        case SCSIOP_READ_CAPACITY:

             if(Srb->Lun < deviceExtension->No_SysDrives) {

                 dptr  = Srb->DataBuffer;
                 lsize = deviceExtension->NoncachedExtension->DevParms.Size[Srb->Lun];

                 lsize--;
                 pbyte=(UCHAR *)&lsize;

                 dptr[0] = pbyte[3];
                 dptr[1] = pbyte[2];
                 dptr[2] = pbyte[1];
                 dptr[3] = pbyte[0];
                 dptr[4] = 0;
                 dptr[5] = 0;
                 dptr[6] = 2;
                 dptr[7] = 0;

                 DebugPrint((1,"DAC RDCAP: %x,%x,%x,%x\n",dptr[0],dptr[1],dptr[2],dptr[3]));

                 // Complete
                 Srb->ScsiStatus = SCSISTAT_GOOD;
                 Srb->SrbStatus = SRB_STATUS_SUCCESS;

                 ScsiPortNotification(RequestComplete, deviceExtension, Srb);

                 return(TRUE);
             }
             else
             {
                 Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
                 // Srb->SrbStatus = SRB_STATUS_INVALID_LUN;
                 ScsiPortNotification(RequestComplete, deviceExtension, Srb);

                 return(TRUE);
             }
		       
        case SCSIOP_INQUIRY:

             if(Srb->Lun < deviceExtension->No_SysDrives) {
                 if(Srb->DataTransferLength > 35)   
                 {
                     dptr     = Srb->DataBuffer;
                     dptr[0]  = 0;
                     dptr[1]  = 0;
                     dptr[2]  = 1; 
                     dptr[3]  = 0;
                     dptr[4]  = 0x20;
                     dptr[5]  = 0;
                     dptr[6]  = 0;
                     dptr[7]  = 0;
                     dptr[8]  = 'M';
                     dptr[9]  = 'Y';
                     dptr[10] = 'L';
                     dptr[11] = 'E';
                     dptr[12] = 'X';

                     for(i = 13; i < 36; i++)
                         dptr[i] = ' ';

                  }
                  else ;
             }
             else
             {
/*
                  Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
*/
                  // Srb->SrbStatus = SRB_STATUS_INVALID_LUN;
                  Srb->SrbStatus = SRB_STATUS_NO_DEVICE;
                  ScsiPortNotification(RequestComplete, deviceExtension, Srb);

                  return(TRUE);
             }

        case SCSIOP_TEST_UNIT_READY:
        case SCSIOP_REZERO_UNIT:
        case SCSIOP_SEEK6:
        case SCSIOP_VERIFY6:
        case SCSIOP_RESERVE_UNIT:
        case SCSIOP_RELEASE_UNIT:
        case SCSIOP_SEEK:
        case SCSIOP_VERIFY:

             // Complete

             Srb->ScsiStatus = SCSISTAT_GOOD;
             Srb->SrbStatus = SRB_STATUS_SUCCESS;
             ScsiPortNotification(RequestComplete, deviceExtension, Srb);

             return(TRUE);

        case SCSIOP_FORMAT_UNIT:
        default:

             // Unknown request

             Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
             ScsiPortNotification(RequestComplete, deviceExtension, Srb);

             return(TRUE);
        }

    }
    else {
        // can only be flush

        DacCommand = DAC_FLUSH;
        blocks = 0;
    }

give_command:

    // Check for request slot availability

    if(deviceExtension->ActiveCmds >= deviceExtension->MaxCmds) {
        return(FALSE);
    }

    // If Non_Disk fire it only if no Non_Disk is pending.

    if(Srb->Function != SRB_FUNCTION_IO_CONTROL)
       if(Srb->TargetId)
       {
           if(deviceExtension->NDPending) return (FALSE);

           deviceExtension->NDPending++;
       }

    // Put this SRB on queue
    // TAGTAG Add tag support here

    for(index = 0; index < DAC_MAX_IOCMDS; index++)
        if(deviceExtension->ActiveSrb[index] == NULL) break;

    
    deviceExtension->ActiveCmds++;
    deviceExtension->ActiveSrb[index] = Srb;

    rcb = &deviceExtension->ActiveRcb[index];
    rcb->DacCommand = DacCommand;

    rcb->VirtualTransferAddress = (PUCHAR)(Srb->DataBuffer);
    rcb->BlockAddress = blockAddr;

    if(blocks !=0 )
        rcb->BytesToGo = blocks*512;
    else
        rcb->BytesToGo = Srb->DataTransferLength;

    // Start command
    dachlpContinueDiskRequest(deviceExtension, index, TRUE);

    return(TRUE);
}


VOID
dachlpSendMBOX(
	IN PUCHAR EisaAddress,
	IN PDAC_MBOX mbox
	)

/*++

Routine Description:

	Start up conventional DAC command

Arguments:

	Eisa base IO address
	DAC mailbox

Return Value:

	none

--*/

{
	PUCHAR  ptr;
	ULONG   i;


	ptr = (PUCHAR)mbox;
 //       DebugPrint((1,"DAC: cmdwait .... "));
	while(ScsiPortReadPortUchar(EisaAddress+BMIC_LOCAL_DB) & 1)
		ScsiPortStallExecution(100);
 //       DebugPrint((1,"DAC: cmddone\n"));
	for(i=0; i<13; i++)
		ScsiPortWritePortUchar(EisaAddress+BMIC_MBOX+i, ptr[i]);

	// Kick butt
	ScsiPortWritePortUchar(EisaAddress+BMIC_LOCAL_DB, 1);
}




BOOLEAN
Dac960NtResetBus(
    IN PVOID HwDeviceExtension,
    IN ULONG PathId
)

/*++

Routine Description:

	Reset Dac960Nt SCSI adapter and SCSI bus.

Arguments:

	HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

	Nothing.

--*/

{
	PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;


	//
	// Complete all outstanding requests.
	//
	ScsiPortCompleteRequest(deviceExtension,
							0,
							(UCHAR)-1,
							(UCHAR)-1,
							SRB_STATUS_BUS_RESET);

	return TRUE;

} // end Dac960NtResetBus()



//
// Disk Request Done
// Dequeue, set status, notify Miniport layer
// Always returns TRUE (slot freed)
//
BOOLEAN
dachlpDiskRequestDone(
	IN PHW_DEVICE_EXTENSION deviceExtension,
	IN ULONG index,
	IN UCHAR Status
	)
{
	PSCSI_REQUEST_BLOCK             srb;



	srb = deviceExtension->ActiveSrb[index];

	// Set status
	srb->SrbStatus = Status;

	// This SRB is through
	deviceExtension->ActiveSrb[index] = NULL;
	deviceExtension->ActiveCmds--;

	// Call notification routine for the SRB.
	ScsiPortNotification(RequestComplete,
					(PVOID)deviceExtension,
					srb);

	return(TRUE);
}



// Word order functions

USHORT  dachlpGetM16(PUCHAR p)
{
	USHORT  s;
	PUCHAR  sp=(PUCHAR)&s;

	sp[0] = p[1];
	sp[1] = p[0];
	return(s);
}

ULONG   dachlpGetM24(PUCHAR p)
{
	ULONG   l;
	PUCHAR  lp=(PUCHAR)&l;

	lp[0] = p[2];
	lp[1] = p[1];
	lp[2] = p[0];
	lp[3] = 0;
	return(l);
}

ULONG   dachlpGetM32(PUCHAR p)
{
	ULONG   l;
	PUCHAR  lp=(PUCHAR)&l;

	lp[0] = p[3];
	lp[1] = p[2];
	lp[2] = p[1];
	lp[3] = p[0];
	return(l);
}

void    dachlpPutM16(PUCHAR p, USHORT s)
{
	PUCHAR  sp=(PUCHAR)&s;

	p[0] = sp[1];
	p[1] = sp[0];
}

void    dachlpPutM24(PUCHAR p, ULONG l)
{
	PUCHAR  lp=(PUCHAR)&l;

	p[0] = lp[2];
	p[1] = lp[1];
	p[2] = lp[0];
}

void    dachlpPutM32(PUCHAR p, ULONG l)
{
	PUCHAR  lp=(PUCHAR)&l;

	p[0] = lp[3];
	p[1] = lp[2];
	p[2] = lp[1];
	p[3] = lp[0];
}

void    dachlpPutI16(PUCHAR p, USHORT s)
{
	PUCHAR  sp=(PUCHAR)&s;

	p[0] = sp[0];
	p[1] = sp[1];
}

void    dachlpPutI32(PUCHAR p, ULONG l)
{
	PUCHAR  lp=(PUCHAR)&l;

	p[0] = lp[0];
	p[1] = lp[1];
	p[2] = lp[2];
	p[3] = lp[3];
}

ULONG           dachlpSwapM32(ULONG l)
{
	ULONG   lres;
	PUCHAR  lp=(PUCHAR)&l;
	PUCHAR  lpres=(PUCHAR)&lres;

	lpres[0] = lp[3];
	lpres[1] = lp[2];
	lpres[2] = lp[1];
	lpres[3] = lp[0];

	return(lres);
}
/*
** Continue disk request
** Return TRUE if a request slot became available
**        FALSE if not
*/
BOOLEAN
dachlpContinueDiskRequest(
    IN PHW_DEVICE_EXTENSION deviceExtension,
    IN ULONG index,
    IN BOOLEAN Start
)

{
    PVOID                 dataPointer;
    ULONG                 bytesLeft;
    PSGL                  sgl;
    ULONG                 descriptorCount = 0;
    PDIRECT_CDB           dacdcdb;
    PUCHAR                sptr;
    PRCB                  rcb;
    PSCSI_REQUEST_BLOCK   srb;
    PNONCACHED_EXTENSION  nce;
    DAC_MBOX              mbox;
    ULONG                 physAddr;
    ULONG                 length, blocks, bytes;
    PUCHAR                EisaAddress;
    ULONG                 i;

    EisaAddress = deviceExtension->EisaAddress;
    rcb = &deviceExtension->ActiveRcb[index];
    srb = deviceExtension->ActiveSrb[index];
    nce = deviceExtension->NoncachedExtension;
    bytes = 0;

    dacdcdb=(PDIRECT_CDB)nce->Buffer;

    sgl = srb->SrbExtension;

    if(Start == FALSE) {
        // DAC interrupt time call. Determine status of last DAC request

	DebugPrint((2,"DAC: Contreq;Start=False"));


	if(srb->Function == SRB_FUNCTION_IO_CONTROL)
	{
            UCHAR * dptr;

            dptr=(UCHAR *)srb->DataBuffer;
            dptr[sizeof (SRB_IO_CONTROL) + 4] = rcb->DacStatus;
            dptr[sizeof (SRB_IO_CONTROL) + 5] = rcb->DacErrcode;

            // We're actually done here !
            // Update SCSI status.

            srb->ScsiStatus = SCSISTAT_GOOD;

            // Finish
            dachlpDiskRequestDone(deviceExtension, index,
                                    SRB_STATUS_SUCCESS);
            return TRUE;

	 }

         if(srb->TargetId) {
            deviceExtension->NDPending--;
         }

         if(rcb->DacErrcode | rcb->DacStatus)
         {
            if(srb->Function != SRB_FUNCTION_IO_CONTROL)
                if(srb->TargetId == 0)
                {
                     // The DAC detected an error
                     dachlpDiskRequestDone(deviceExtension, index,
                                           SRB_STATUS_TIMEOUT);
	
                     // Slot free
                     return(TRUE);
                }
                else
                {
                     // Set target SCSI status in SRB.

                     if(rcb->DacStatus == 0x02)
                          srb->ScsiStatus = 0x02;          // CheckCondition
                     else
                          srb->ScsiStatus = dacdcdb->status;

                     if (dacdcdb->sense_len) {
                          int     i;
                          char    *senseptr;

                          senseptr=(char *)srb->SenseInfoBuffer;

	                  // Indicate the sense information is valid and 
                          // update the length.

                          for(i = 0; i < dacdcdb->sense_len; i++)
                               senseptr[i] = dacdcdb->sense[i];

                          srb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;
                          srb->SenseInfoBufferLength = dacdcdb->sense_len;
                     }

                     // The DAC detected an error
                     dachlpDiskRequestDone(deviceExtension, index,
                                           SRB_STATUS_ERROR);

                     // Slot free
                     return(TRUE);
                 }
            }

            // We're actually done here !
            // Update SCSI status.
            // $$$ can we manipulate this for non SCSI requests ?

            srb->ScsiStatus = SCSISTAT_GOOD;

            // Finish
            DebugPrint((2,"DAC: Success\n"));

            dachlpDiskRequestDone(deviceExtension, index,
                                  SRB_STATUS_SUCCESS);

            return TRUE;
      }
      else {
           DebugPrint((2,"DAC:Cont;Start=TRUE\n"));

           if((rcb->BytesToGo) && ((rcb->DacCommand == DAC_LREAD) || (rcb->DacCommand == DAC_LWRITE) || (rcb->DacCommand == DAC_DCDB))) {

           // We want to transfer some data, get the physical address

           dataPointer=rcb->VirtualTransferAddress,
           bytesLeft = rcb->BytesToGo;

           if(bytesLeft > 0xf000)
               DebugPrint((1,"DAC: bytesleft = %ld\n",bytesLeft));

           do {

	      // Get physical address and length of contiguous physical buffer.

              physAddr =
                 ScsiPortConvertPhysicalAddressToUlong(
                   ScsiPortGetPhysicalAddress(deviceExtension,
                                              srb,
                                              dataPointer,
                                              &length));

	      DebugPrint((2, "DAC960: SGL Physical address %lx\n", physAddr));
	      DebugPrint((2, "DAC960: SGL Data length %lx\n", length));
	      DebugPrint((2, "DAC960: SGL Bytes left %lx\n", bytesLeft));

	      // If length of physical memory is more
              // than bytes left in transfer, use bytes
              // left as final length.

              if(length > bytesLeft) {
                     length = bytesLeft;
              }   

              if(length > 0xf000)
                   DebugPrint((1,"DAC: length=%ld\n",length));

              sgl->Descriptor[descriptorCount].Address = physAddr;
              sgl->Descriptor[descriptorCount].Length = length;

	      // Adjust counts.

              dataPointer = (PUCHAR)dataPointer + length;
              bytesLeft -= length;
              descriptorCount++;

          } while (bytesLeft);

          // Get physical SGL address.

          physAddr = ScsiPortConvertPhysicalAddressToUlong(
	       ScsiPortGetPhysicalAddress(deviceExtension, NULL,
	                                  sgl, &length));

          // Assume physical memory contiguous for sizeof(SGL) bytes.

          ASSERT(length >= sizeof(SGL));

          // Create SGL segment descriptors.


          if(rcb->DacCommand==DAC_LREAD || rcb->DacCommand==DAC_LWRITE || rcb->DacCommand == DAC_DCDB) {

               // Disk read/write: get number of blocks

               bytes=rcb->BytesToGo;
               blocks=bytes/512;
               bytes = blocks*512;
          }
          else {
               // Not a scatter-gather type operation

               if(bytes != rcb->BytesToGo) {
                     dachlpDiskRequestDone(deviceExtension, index,
                                             SRB_STATUS_PARITY_ERROR);
                     return(TRUE);
               }
          }
	}
	else {
            // We don't have data to transfer
            bytes = 0;
            blocks = 0;
        }


	// Now look at the specific DAC command

	switch(rcb->DacCommand) {

        case DAC_LREAD:
        case DAC_LWRITE:
             if(blocks==0) {
                // Cancel this command with some garbage error code
                dachlpDiskRequestDone(deviceExtension, index,
                                      SRB_STATUS_PARITY_ERROR);
                return(TRUE);
             }

             // Transfer data

             mbox.iombox.Command     = rcb->DacCommand | 0x80;
             mbox.iombox.Id          = index;
             mbox.iombox.Reserved1   = 0;
             mbox.iombox.SectorCount = (USHORT)blocks;
             mbox.iombox.PhysAddr    = physAddr;
             mbox.iombox.Block       = rcb->BlockAddress;
      
             /* Support for 32G  */

             mbox.generalmbox.Byte3 = ((rcb->BlockAddress) >> (24-6)) & 0xc0;
             mbox.generalmbox.Byte7 = srb->Lun;

             mbox.generalmbox.Bytec = descriptorCount;

             if(descriptorCount > 17)                        
                  DebugPrint((1,"DAC: SGcount =%d\n",descriptorCount));

             break;

        case DAC_DCDB:

             dacdcdb->device = (deviceExtension->ND_DevMap[srb->TargetId] << 4) + srb->TargetId;

             dacdcdb->dir = 0x80;

             if(srb->SrbFlags & SRB_FLAGS_DATA_IN)
                  dacdcdb->dir |= DAC_IN;
             else if(srb->SrbFlags & SRB_FLAGS_DATA_OUT)
                  dacdcdb->dir |= DAC_OUT;

             dacdcdb->sense_len= srb->SenseInfoBufferLength;
             dacdcdb->cdb_len  = srb->CdbLength;
             dacdcdb->byte_cnt = (USHORT)(srb->DataTransferLength);

             for(i = 0; i < srb->CdbLength; i++)
                  dacdcdb->cdb[i]=srb->Cdb[i];

             if (srb->SenseInfoBufferLength != 0 &&
                !(srb->SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE)) {
                   dacdcdb->dir |= DAC_NO_AUTOSENSE;
                   dacdcdb->sense_len=0;
             }

             if(dacdcdb->dir & 0x03)  /* if data xfer involved */
                   mbox.iombox.Command = rcb->DacCommand | 0x80;
             else
                   mbox.iombox.Command = rcb->DacCommand;

             mbox.iombox.Id        = index;
             mbox.iombox.Reserved1 = 0;

             dacdcdb->ptr           = physAddr;
	     mbox.iombox.PhysAddr   = deviceExtension->NCE_PhyAddr + (nce->Buffer - (PUCHAR) nce);
             mbox.generalmbox.Bytec = descriptorCount;

             if(descriptorCount > 17)                        
                   DebugPrint((1,"DAC: SGcount =%d\n",descriptorCount));

             break;

        default:

             // Cancel this command with some garbage error code
             dachlpDiskRequestDone(deviceExtension, index,
                                   SRB_STATUS_PARITY_ERROR);

             return(TRUE);

        case DAC_DCMD:

             sptr = (PUCHAR)srb->DataBuffer+ sizeof(SRB_IO_CONTROL)+ 0x10;

             if(sptr[0] != 0x04) // Not a Direct CDB via IOCTL
             {
                 mbox.iombox.Command = sptr[0];
                 mbox.iombox.Id = index;
                 mbox.generalmbox.Byte2 = sptr[2];
                 mbox.generalmbox.Byte3 = sptr[3];
                 mbox.generalmbox.Byte4 = sptr[4];
                 mbox.generalmbox.Byte5 = sptr[5];
                 mbox.generalmbox.Byte6 = sptr[6];
                 mbox.generalmbox.Byte7 = sptr[7];
                 sptr += 0x10;

                 physAddr = ScsiPortConvertPhysicalAddressToUlong(
                               ScsiPortGetPhysicalAddress(deviceExtension, 
                                srb, srb->DataBuffer, &length));

                 mbox.iombox.PhysAddr = physAddr + sizeof(SRB_IO_CONTROL) \
                                        + 0x10 + 0x10;
            }
            else
            {
                 mbox.iombox.Command = sptr[0];
                 mbox.iombox.Id = index;
                 sptr += 0x10;

                 physAddr = ScsiPortConvertPhysicalAddressToUlong(
                             ScsiPortGetPhysicalAddress(deviceExtension, srb,
                                  srb->DataBuffer, &length));

                 mbox.iombox.PhysAddr = physAddr + 0x10;

                 dacdcdb = (PDIRECT_CDB)sptr;
                 dacdcdb->ptr = physAddr + 0x10 + 100;
            }
            break;

       case DAC_FLUSH:
            // Flush buffers
            mbox.iombox.Command = DAC_FLUSH;
            mbox.iombox.Id = index;

            // In case we get here for a post-flush,
            // set variables so we're done next time
            rcb->BytesToGo = 0;
            bytes = 0;
            blocks = 0;
            break;

        }

	// Fire command

	dachlpSendMBOX(EisaAddress, &mbox);


	// No SRB slot freed

	return(FALSE);
     }
}

#if MYPRINT
//
// The monochrome screen printf() helpers start here
//
VOID dachlpPutchar(PUSHORT BaseAddr, UCHAR c)
{
	BOOLEAN newline=FALSE;
	USHORT  s;
	ULONG   i;


	if(c=='\r') {
		dachlpColumn = 0;
		}
	else if(c=='\n') {
		newline=TRUE;
		}
	else if(c=='\b') {
		if(dachlpColumn)
			dachlpColumn--;
			return;
		}
	else {
		if(c==9) c==' ';
		ScsiPortWriteRegisterUshort(
			BaseAddr+80*24+dachlpColumn, (USHORT)(((USHORT)c)|0xF00));
		if(++dachlpColumn >= 80)
			newline=TRUE;
		}

	if(newline) {
		for(i=0; i<80*24; i++) {
			s = ScsiPortReadRegisterUshort(BaseAddr+80+i);
			ScsiPortWriteRegisterUshort(BaseAddr+i, s);
			}
		for(i=0; i<80; i++)
			ScsiPortWriteRegisterUshort(BaseAddr+80*24+i, 0x720);
		dachlpColumn = 0;
		}
}


VOID  dachlpPrintHex(PUSHORT BaseAddr, ULONG v, ULONG len)
{
	ULONG   shift;
	ULONG   nibble;

	len *= 2;
	shift = len*4;
	while(len--) {
		shift -= 4;
		nibble = (v>>shift) & 0xF;
		dachlpPutchar(BaseAddr, dachlpHex[nibble]);
		}
}


VOID dachlpPrintf(PHW_DEVICE_EXTENSION deviceExtension,
						PUCHAR fmt,
						ULONG a1,
						ULONG a2,
						ULONG a3,
						ULONG a4)
{

	if(deviceExtension->printAddr == 0)
		return;

	while(*fmt) {

		if(*fmt=='%') {
			fmt++;
			switch(*fmt) {
				case 0:
					fmt--;
					break;
				case 'b':
					dachlpPrintHex(deviceExtension->printAddr, a1, 1);
					break;
				case 'w':
					dachlpPrintHex(deviceExtension->printAddr, a1, 2);
					break;
				case 'p':
					dachlpPrintHex(deviceExtension->printAddr, a1, 3);
					break;
				case 'd':
					dachlpPrintHex(deviceExtension->printAddr, a1, 4);
					break;
				default:
					dachlpPutchar(deviceExtension->printAddr, '?');
					break;
				}
			fmt++;
			a1 = a2;
			a2 = a3;
			a3 = a4;
			}
		else {
			dachlpPutchar(deviceExtension->printAddr, *fmt);
			fmt++;
			}
		}
}
#endif // MYPRINT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\proppage\diskprop.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name :

    diskprop.h

Abstract :

    Definition file for the Disk Class Installer and its Policies Tab

Revision History :

--*/


#ifndef __STORPROP_DISKPROP_H_
#define __STORPROP_DISKPROP_H_


#define DISKCIPRIVATEDATA_NO_REBOOT_REQUIRED      0x4

const DWORD DiskHelpIDs[]=
{
    IDC_DISK_POLICY_WRITE_CACHE, 400900,
    0, 0
};

typedef struct _DISK_PAGE_DATA
{
    HDEVINFO DeviceInfoSet;
    PSP_DEVINFO_DATA DeviceInfoData;

    //
    // This field represents whether  disk
    // level write caching may be modified
    //
    BOOL IsCachingPolicy;

    BOOL OrigWriteCacheSetting;
    BOOL CurrWriteCacheSetting;

    DISK_CACHE_SETTING CacheSetting;
    BOOL CurrentIsPowerProtected;

    DWORD DefaultRemovalPolicy;
    DWORD CurrentRemovalPolicy;
    STORAGE_HOTPLUG_INFO HotplugInfo;

    //
    // This field is set when the device stack
    // is being torn down which happens during
    // a removal policy change
    //
    BOOL IsBusy;

} DISK_PAGE_DATA, *PDISK_PAGE_DATA;



INT_PTR
DiskDialogProc(HWND Dialog, UINT Message, WPARAM WParam, LPARAM LParam);

BOOL
DiskDialogCallback(HWND Dialog, UINT Message, LPPROPSHEETPAGE Page);


#endif // __STORPROP_DISKPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\proppage\dvdprop.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dvdprop.c
//
//--------------------------------------------------------------------------

#include "propp.h"
#include "ntddcdvd.h"
#include "dvdprop.h"
#include "volprop.h"
#include "resource.h"


//
// Help ID mapping for context sensitive help
//
const DWORD DvdHelpIDs[]=
{
        IDC_CURRENT_REGION,         IDH_DEVMGR_DVD_CURRENT,             //Current region box
        IDC_NEW_REGION,             IDH_DEVMGR_DVD_NEW,         //New region box
        IDC_DVD_COUNTRY_LIST,   IDH_DEVMGR_DVD_LIST,            //List box
        IDC_DVD_HELP,           IDH_DEVMGR_DVD_NOHELP,
        IDC_CHANGE_TEXT,            IDH_DEVMGR_DVD_NOHELP,
        0, 0
};

ULONG RegionIndexTable[MAX_REGIONS] = {
    DVD_REGION1_00,
    DVD_REGION2_00,
    DVD_REGION3_00,
    DVD_REGION4_00,
    DVD_REGION5_00,
    DVD_REGION6_00
};

ULONG RegionSizeTable[MAX_REGIONS] = {
    DVD_MAX_REGION1,
    DVD_MAX_REGION2,
    DVD_MAX_REGION3,
    DVD_MAX_REGION4,
    DVD_MAX_REGION5,
    DVD_MAX_REGION6
};

BOOL
IsUserAdmin(
    VOID
    );

PPAGE_INFO DvdCreatePageInfo(IN HDEVINFO         deviceInfoSet,
                             IN PSP_DEVINFO_DATA deviceInfoData)
{
    PPAGE_INFO  tmp = NULL;

    if (!(tmp = LocalAlloc(LPTR, sizeof(PAGE_INFO)))) {
        return NULL;
    }

    memset (tmp, 0, sizeof(PAGE_INFO));
    tmp->deviceInfoSet = deviceInfoSet;
    tmp->deviceInfoData = deviceInfoData;

    return tmp;
}

void
DvdDestroyPageInfo(PPAGE_INFO * ppPageInfo)
{
    PPAGE_INFO ppi = *ppPageInfo;

    LocalFree(ppi);
    *ppPageInfo = NULL;
}

HPROPSHEETPAGE
DvdCreatePropertyPage(PROPSHEETPAGE *  ppsp,
                      PPAGE_INFO       ppi)
{
    //
    // Add the Port Settings property page
    //
    ppsp->dwSize      = sizeof(PROPSHEETPAGE);
    ppsp->dwFlags     = PSP_USECALLBACK; // | PSP_HASHELP;
    ppsp->hInstance   = ModuleInstance;
    ppsp->pszTemplate = MAKEINTRESOURCE(ID_DVD_PROPPAGE);

    //
    // following points to the dlg window proc
    //
    ppsp->pfnDlgProc = DvdDlgProc;
    ppsp->lParam     = (LPARAM) ppi;

    //
    // Following points to the control callback of the dlg window proc.
    // The callback gets called before creation/after destruction of the page
    //
    ppsp->pfnCallback = DvdDlgCallback;

    //
    // Allocate the actual page
    //
    return CreatePropertySheetPage(ppsp);
}


BOOL APIENTRY
DvdPropPageProvider(LPVOID               pinfo,
                    LPFNADDPROPSHEETPAGE pfnAdd,
                    LPARAM               lParam)
{
    PSP_PROPSHEETPAGE_REQUEST ppr;
    PROPSHEETPAGE    psp;
    HPROPSHEETPAGE   hpsp;
    PPAGE_INFO       ppi = NULL;

    ppr = (PSP_PROPSHEETPAGE_REQUEST) pinfo;

    if (ppr->PageRequested == SPPSR_ENUM_ADV_DEVICE_PROPERTIES) {

        ppi = DvdCreatePageInfo(ppr->DeviceInfoSet,
                                ppr->DeviceInfoData);

        if (!ppi) {
            return FALSE;
        }

        if (!GetCurrentRpcData(ppi, &ppi->regionData)) {

            //
            // not a DVD-ROM with RPC2 support
            //
            DvdDestroyPageInfo(&ppi);
            return FALSE;
        }

        memset(&psp, 0, sizeof(PROPSHEETPAGE));

        hpsp = DvdCreatePropertyPage(&psp, ppi);

        if (!hpsp) {

            DvdDestroyPageInfo(&ppi);
            return FALSE;
        }

        if (!pfnAdd(hpsp, lParam)) {
            DestroyPropertySheetPage(hpsp);
            return FALSE;
        }
   }

   return TRUE;
}


UINT CALLBACK
DvdDlgCallback(HWND            hwnd,
               UINT            uMsg,
               LPPROPSHEETPAGE ppsp)
{
    PPAGE_INFO ppi;

    switch (uMsg) {
    case PSPCB_CREATE:
        return TRUE;    // return TRUE to continue with creation of page

    case PSPCB_RELEASE:
        ppi = (PPAGE_INFO) ppsp->lParam;
        DvdDestroyPageInfo(&ppi);

        return 0;       // return value ignored

    default:
        break;
    }

    return TRUE;
}

void
DvdInitializeControls(PPAGE_INFO   ppi,
                      HWND         hDlg)
{
    DWORD   dwError;
    DWORD   dwType;
    DWORD   dwSize;
    BOOL    disableControls = FALSE;
    HWND    hwnd;
    ULONG   i;
    ULONG   j;
    TCHAR   buffer[1000];

    hwnd = GetDlgItem(hDlg, IDC_DVD_COUNTRY_LIST);
    for (i=0; i<MAX_REGIONS; i++) {

        for (j=0; j<RegionSizeTable[i]; j++) {

            if (LoadString(ModuleInstance,
                           RegionIndexTable[i] + j,
                           buffer,
                           100)) {

                SendMessage(hwnd,
                            LB_ADDSTRING,
                            0,
                            (LPARAM) buffer);
            }
        }
    }

    hwnd = GetDlgItem(hDlg, IDC_DVD_HELP);
    if (LoadString(ModuleInstance,
                   DVD_HELP,
                   buffer,
                   1000)) {

        SendMessage(hwnd,
                    WM_SETTEXT,
                    0,
                    (LPARAM) buffer);
    }

    hwnd = GetDlgItem(hDlg, IDC_DVD_CAUTION);
    if (LoadString(ModuleInstance,
                   DVD_CAUTION,
                   buffer,
                   1000)) {

        SendMessage(hwnd,
                    WM_SETTEXT,
                    0,
                    (LPARAM) buffer);
    }

    hwnd = GetDlgItem(hDlg, IDC_DVD_CHANGE_HELP);
    if (LoadString(ModuleInstance,
                   DVD_CHANGE_HELP,
                   buffer,
                   1000)) {

        SendMessage(hwnd,
                    WM_SETTEXT,
                    0,
                    (LPARAM) buffer);
    }

    DvdUpdateCurrentSettings (ppi, hDlg);
}


BOOL
DvdApplyChanges(PPAGE_INFO ppi,
                HWND       hDlg)
{
    UCHAR keyBuffer[DVD_SET_RPC_KEY_LENGTH];
    PDVD_COPY_PROTECT_KEY copyProtectKey;
    PDVD_SET_RPC_KEY rpcKey;
    ULONG i;
    BOOL popupError = FALSE;
    BOOL status;
    ULONG returned;
    TCHAR bufferFormat[500];
    TCHAR buffer[500];
    TCHAR titleBuffer[500];
    BOOL okToProceed;
    HANDLE writeHandle = INVALID_HANDLE_VALUE;

    if ((ppi->newRegion == 0) ||
        (ppi->currentRegion == ppi->newRegion)) {

        //
        // nothing to do
        //
        return TRUE;
    }

    //
    // confirm with the user
    //

    okToProceed = FALSE;

    if (ppi->regionData.ResetCount == 1) {

        if (LoadString(ModuleInstance,
                       DVD_SET_RPC_CONFIRM_LAST_CHANCE,
                       buffer,
                       500) &&
            LoadString(ModuleInstance,
                       DVD_SET_RPC_CONFIRM_TITLE,
                       titleBuffer,
                       500)) {

            if (MessageBox(hDlg,
                           buffer,
                           titleBuffer,
                           MB_ICONEXCLAMATION | MB_OKCANCEL |
                           MB_DEFBUTTON2 | MB_APPLMODAL) == IDOK) {

                okToProceed = TRUE;
            }
        }
    } else {
        if (LoadString(ModuleInstance,
                       DVD_SET_RPC_CONFIRM,
                       bufferFormat,
                       500) &&
            LoadString(ModuleInstance,
                       DVD_SET_RPC_CONFIRM_TITLE,
                       titleBuffer,
                       500)) {

            wsprintf (buffer, bufferFormat, ppi->newRegion);

            if (MessageBox(hDlg,
                           buffer,
                           titleBuffer,
                           MB_ICONEXCLAMATION | MB_OKCANCEL |
                           MB_DEFBUTTON2 | MB_APPLMODAL) == IDOK) {

                okToProceed = TRUE;
            }
        }
    }

    if (okToProceed == FALSE) {

        return FALSE;
    }

    //
    // make sure the drive has a dvd with the same region
    // call GetCurrentRpcData
    //

    writeHandle = UtilpGetDeviceHandle(ppi->deviceInfoSet,
                                       ppi->deviceInfoData,
                                       (LPGUID)&CdRomClassGuid,
                                       GENERIC_READ | GENERIC_WRITE);

    if (writeHandle != INVALID_HANDLE_VALUE) {

        copyProtectKey = (PDVD_COPY_PROTECT_KEY) keyBuffer;

        memset(copyProtectKey, 0, DVD_SET_RPC_KEY_LENGTH);

        copyProtectKey->KeyLength = DVD_SET_RPC_KEY_LENGTH;
        copyProtectKey->KeyType = DvdSetRpcKey;

        rpcKey = (PDVD_SET_RPC_KEY) copyProtectKey->KeyData;
        rpcKey->PreferredDriveRegionCode = ~(1 << (ppi->newRegion - 1));

        status = DeviceIoControl(writeHandle,
                                 IOCTL_DVD_SEND_KEY2,
                                 copyProtectKey,
                                 DVD_SET_RPC_KEY_LENGTH,
                                 NULL,
                                 0,
                                 &returned,
                                 FALSE);

        CloseHandle (writeHandle);

    } else {

        status = 0;

    }

    if (!status) {


        if (LoadString(ModuleInstance,
                       DVD_SET_RPC_ERROR,
                       bufferFormat,
                       500) &&
            LoadString(ModuleInstance,
                       DVD_SET_RPC_ERROR_TITLE,
                       titleBuffer,
                       500)) {

            wsprintf (buffer, bufferFormat, ppi->newRegion);

            MessageBox(hDlg,
                       buffer,
                       titleBuffer,
                       MB_ICONERROR | MB_OK);
        }

        return FALSE;

    } else {

        GetCurrentRpcData(ppi, &ppi->regionData);

        return TRUE;
    }
}


INT_PTR APIENTRY
DvdDlgProc(IN HWND   hDlg,
           IN UINT   uMessage,
           IN WPARAM wParam,
           IN LPARAM lParam)
{
    PPAGE_INFO ppi;

    ppi = (PPAGE_INFO) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMessage) {
    case WM_INITDIALOG:

        //
        // on WM_INITDIALOG call, lParam points to the property
        // sheet page.
        //
        // The lParam field in the property sheet page struct is set by the
        // caller. When I created the property sheet, I passed in a pointer
        // to a struct containing information about the device. Save this in
        // the user window long so I can access it on later messages.
        //
        ppi = (PPAGE_INFO) ((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) ppi);

        //
        // Initialize dlg controls
        //
        DvdInitializeControls(ppi, hDlg);

        //
        // Didn't set the focus to a particular control.  If we wanted to,
        // then return FALSE
        //
        return TRUE;

    case WM_COMMAND:

        switch (HIWORD(wParam)) {
        case CBN_SELCHANGE:
           PropSheet_Changed(GetParent(hDlg), hDlg);
           DvdUpdateNewRegionBox (ppi, hDlg);
           SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LONG_PTR) PSNRET_NOERROR);
           return TRUE;

        default:
           break;
        }

        switch(LOWORD(wParam)) {

        default:
            break;
        }

        break;

    case WM_CONTEXTMENU:
        return DvdContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP:
        DvdHelp(hDlg, (LPHELPINFO) lParam);
        break;

    case WM_NOTIFY:

        switch (((NMHDR *)lParam)->code) {

        //
        // Sent when the user clicks on Apply OR OK !!
        //
        case PSN_APPLY:
            //
            // Do what ever action is necessary
            //
            if (DvdApplyChanges(ppi, hDlg)) {

                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                ppi->changesFailed = FALSE;

                DvdUpdateCurrentSettings(ppi, hDlg);

            } else {

                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                ppi->changesFailed = TRUE;
            }
            return TRUE;

        default:
            break;
        }

        break;
   }

   SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
   return FALSE;
}

void
DvdUpdateNewRegionBox (PPAGE_INFO ppi,
                       HWND       hDlg)
{
    HWND    hwnd;
    ULONG selectionIndex;
    WCHAR buffer[100];
    ULONG currentRegion;
    BOOL status;

    //
    // new region code
    //
    hwnd = GetDlgItem(hDlg, IDC_DVD_COUNTRY_LIST);
    //
    // NOTE: SendMessage() will return 64-bit result in Sundown
    //
    selectionIndex = (ULONG) SendMessage(hwnd,
                                         LB_GETCURSEL,
                                         (WPARAM) 0,
                                         (LPARAM) 0);

    if (selectionIndex != LB_ERR) {

        if (LB_ERR != SendMessage(hwnd,
                                  LB_GETTEXT,
                                  selectionIndex,
                                  (LPARAM) buffer)) {

            ppi->newRegion = DvdCountryToRegion (buffer);
            if (ppi->newRegion != -1) {

                if (LoadString(ModuleInstance,
                               DVD_REGION1_NAME + ppi->newRegion - 1,
                               buffer,
                               100)) {

                    hwnd = GetDlgItem(hDlg, IDC_NEW_REGION);
                    SendMessage(hwnd,
                                WM_SETTEXT,
                                0,
                                (LPARAM) buffer);
                }
            }
        }
    }
}

ULONG
DvdCountryToRegion (LPCTSTR Country)
{
    ULONG i;
    ULONG j;
    WCHAR buffer[100];

    for (i=0; i<MAX_REGIONS; i++) {

        for (j=0; j<RegionSizeTable[i]; j++) {

            if (LoadString(ModuleInstance,
                           RegionIndexTable[i] + j,
                           buffer,
                           100)) {

                if (!wcscmp(buffer, Country)) {

                    return i + 1;
                }
            }
        }
    }

    return -1;
}

BOOL
GetCurrentRpcData(
    PPAGE_INFO ppi,
    PDVD_REGION regionData
    )
{
    BOOL status;
    ULONG returned;
    UCHAR regionMask;
    UCHAR userResetsAvailable;
    HANDLE deviceHandle;
    PDVD_COPY_PROTECT_KEY copyProtectKey;
    PDVD_RPC_KEY rpcKey;
    ULONG rpcScheme;

    deviceHandle = UtilpGetDeviceHandle(ppi->deviceInfoSet,
                                        ppi->deviceInfoData,
                                        (LPGUID)&CdRomClassGuid,
                                        GENERIC_READ);

    if (deviceHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    copyProtectKey = LocalAlloc(LPTR, DVD_RPC_KEY_LENGTH);

    if (copyProtectKey == NULL) {
        CloseHandle(deviceHandle);
        return FALSE;
    }

    copyProtectKey->KeyLength = DVD_RPC_KEY_LENGTH;
    copyProtectKey->KeyType = DvdGetRpcKey;

    returned = 0;
    status = DeviceIoControl(deviceHandle,
                             IOCTL_DVD_READ_KEY,
                             copyProtectKey,
                             DVD_RPC_KEY_LENGTH,
                             copyProtectKey,
                             DVD_RPC_KEY_LENGTH,
                             &returned,
                             FALSE);

    //
    // this will default to not showing the property page
    //

    rpcScheme = 0;

    if (status && (returned == DVD_RPC_KEY_LENGTH)) {

        rpcKey = (PDVD_RPC_KEY) copyProtectKey->KeyData;
        rpcScheme = rpcKey->RpcScheme;
        regionMask = ~rpcKey->RegionMask;
        userResetsAvailable = rpcKey->UserResetsAvailable;
        DebugPrint((1, "Got %x user resets available\n", userResetsAvailable));

    } else {

        DebugPrint((1, "Maybe not a DVD drive?\n", status, returned));

    }

    LocalFree(copyProtectKey);

    if (rpcScheme == 0) {

        //
        // all region drive.  no need to show the property sheet
        //

        DebugPrint((1, "All Region DVD-ROM Drive -- no property sheet\n"));
        CloseHandle(deviceHandle);
        return FALSE;

    }

    //
    // get region status
    //

    memset(regionData, 0, sizeof(DVD_REGION));
    status = DeviceIoControl(deviceHandle,
                             IOCTL_DVD_GET_REGION,
                             NULL,
                             0,
                             regionData,
                             sizeof(DVD_REGION),
                             &returned,
                             FALSE);

    if (!(status && (returned == sizeof(DVD_REGION)))) {

        //
        // no media in the drive
        //
        DebugPrint((1, "No media in drive? making up info\n"));
        regionData->CopySystem = 1;
        regionData->RegionData = 0xff;
        regionData->SystemRegion = regionMask;
        regionData->ResetCount = userResetsAvailable;

    }

    CloseHandle(deviceHandle);
    return TRUE;
}

ULONG
DvdRegionMaskToRegionNumber (
    UCHAR PlayMask
    )
{
    ULONG i;
    ULONG mask;

    if (!PlayMask) {

        return 0;
    }

    for (i=0, mask=1; i<8; i++, mask <<= 1) {

        if (PlayMask & mask) {

            return i + 1;
        }
    }

    return 0;
}


void
DvdUpdateCurrentSettings (PPAGE_INFO ppi,
                          HWND       hDlg)
{
    HWND  hwnd;
    ULONG selectionIndex;
    WCHAR buffer[100];
    WCHAR formatBuffer[100];
    BOOL status;

    ppi->currentRegion = DvdRegionMaskToRegionNumber (
                            ppi->regionData.SystemRegion
                            );

    //
    // current region
    //
    if (ppi->currentRegion) {

        status = LoadString(ModuleInstance,
                            DVD_REGION1_NAME + ppi->currentRegion - 1,
                            buffer,
                            100);
    } else {

        status = LoadString(ModuleInstance,
                            DVD_NOREGION_NAME,
                            buffer,
                            100);
    }

    if (status) {

        hwnd = GetDlgItem(hDlg, IDC_CURRENT_REGION);
        SendMessage(hwnd,
                    WM_SETTEXT,
                    0,
                    (LPARAM) buffer);
    }

    //
    // region change limit
    //
    if (LoadString(ModuleInstance,
                   DVD_CHANGE_TEXT,
                   formatBuffer,
                   100)) {

        wsprintf (buffer, formatBuffer, (ULONG) ppi->regionData.ResetCount);

        hwnd = GetDlgItem(hDlg, IDC_CHANGE_TEXT);
        SendMessage(hwnd,
                    WM_SETTEXT,
                    0,
                    (LPARAM) buffer);
    }

    if (ppi->regionData.ResetCount == 0) {

        EnableWindow(GetDlgItem(hDlg, IDC_DVD_COUNTRY_LIST), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_NEW_REGION), FALSE);
    }

    return;
}

//
// SystemLocale2DvdRegion expects
// this list to be sorted by LCID numbers
//
// Note: Due to PoliCheck, comments with
//   approximated region/country names
//   had to be removed.
//
LCID_2_DVD_TABLE Lcid2DvdTable[] = {
    {0x0401, 2},
    {0x0402, 2},
    {0x0403, 2},
    {0x0404, 3},
    {0x0405, 2},
    {0x0406, 2},
    {0x0407, 2},
    {0x0408, 2},
    {0x0409, 1},
    {0x040a, 2},
    {0x040b, 2},
    {0x040c, 2},
    {0x040d, 2},
    {0x040e, 2},
    {0x040f, 2},
    {0x0410, 2},
    {0x0411, 2},
    {0x0412, 3},
    {0x0413, 2},
    {0x0414, 2},
    {0x0415, 2},
    {0x0416, 4},
    {0x0418, 2},
    {0x0419, 5},
    {0x041a, 2},
    {0x041b, 2},
    {0x041c, 2},
    {0x041d, 2},
    {0x041e, 3},
    {0x041f, 2},
    {0x0420, 5},
    {0x0421, 3},
    {0x0422, 5},
    {0x0423, 5},
    {0x0424, 2},
    {0x0425, 5},
    {0x0426, 5},
    {0x0427, 5},
    {0x0429, 2},
    {0x042a, 3},
    {0x042b, 5},
    {0x042c, 5},
    {0x042d, 2},
    {0x042f, 2},
    {0x0436, 2},
    {0x0437, 5},
    {0x0438, 2},
    {0x0439, 5},
    {0x043e, 3},
    {0x043f, 5},
    {0x0441, 5},
    {0x0443, 5},
    {0x0444, 5},
    {0x0445, 5},
    {0x0446, 5},
    {0x0447, 5},
    {0x0448, 5},
    {0x0449, 5},
    {0x044a, 5},
    {0x044b, 5},
    {0x044c, 5},
    {0x044d, 5},
    {0x044e, 5},
    {0x044f, 5},
    {0x0457, 5},
    {0x0801, 2},
    {0x0804, 6},
    {0x0807, 2},
    {0x0809, 2},
    {0x080a, 4},
    {0x080c, 2},
    {0x0810, 2},
    {0x0813, 2},
    {0x0814, 2},
    {0x0816, 2},
    {0x081a, 2},
    {0x081d, 2},
    {0x0827, 5},
    {0x082c, 5},
    {0x083e, 3},
    {0x0843, 5},
    {0x0861, 5},
    {0x0c01, 2},
    {0x0c04, 3},
    {0x0c07, 2},
    {0x0c09, 4},
    {0x0c0a, 2},
    {0x0c0c, 1},
    {0x0c1a, 2},
    {0x1001, 5},
    {0x1004, 3},
    {0x1007, 2},
    {0x1009, 1},
    {0x100a, 4},
    {0x100c, 2},
    {0x1401, 5},
    {0x1404, 3},
    {0x1407, 2},
    {0x1409, 4},
    {0x140a, 4},
    {0x140c, 2},
    {0x1801, 5},
    {0x1809, 2},
    {0x180a, 4},
    {0x180c, 2},
    {0x1c01, 5},
    {0x1c09, 2},
    {0x1c0a, 4},
    {0x2001, 2},
    {0x2009, 4},
    {0x200a, 4},
    {0x2401, 2},
    {0x2409, 4},
    {0x240a, 4},
    {0x2801, 2},
    {0x2809, 4},
    {0x280a, 4},
    {0x2c01, 2},
    {0x2c09, 4},
    {0x2c0a, 4},
    {0x3001, 2},
    {0x3009, 5},
    {0x300a, 4},
    {0x3401, 2},
    {0x3409, 3},
    {0x340a, 4},
    {0x3801, 2},
    {0x380a, 4},
    {0x3c01, 2},
    {0x3c0a, 4},
    {0x4001, 2},
    {0x400a, 4},
    {0x440a, 4},
    {0x480a, 4},
    {0x4c0a, 4},
    {0x500a, 1}
};
#define NUM_LCID_ENTRIES (sizeof(Lcid2DvdTable)/sizeof(LCID_2_DVD_TABLE))


DWORD
SystemLocale2DvdRegion (
    LCID Lcid
    )
{
#define MID_INDEX(x,y)      (((y-x)/2) + x)

    DWORD i;
    DWORD j;
    DWORD k;


    i=0;
    j=NUM_LCID_ENTRIES;

    while (1) {

        k = MID_INDEX(i,j);

        if (Lcid2DvdTable[k].Lcid != Lcid) {

            if (i == j) {

                //
                // not in the table,
                // return a default region of ZERO!!!
                //
                return 0;
            }

            if (Lcid2DvdTable[k].Lcid < Lcid) {

                i = k;

            } else { // Lcid2DvdTable[k].Lcid > Lcid

                j = k;
            }

        } else {

            return Lcid2DvdTable[k].DvdRegion;
        }
    }
}

DWORD
DvdClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )

/*++

Routine Description:

    This routine acts as the class installer for hard disk controllers
    (IDE controllers/channels).  It provides special handling for the
    following DeviceInstaller function codes:

    DIF_INSTALLDEVICE - get the system locale and write it to the driver key

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/

{
    switch (InstallFunction)
    {
        case DIF_ADDPROPERTYPAGE_ADVANCED:
        case DIF_ADDREMOTEPROPERTYPAGE_ADVANCED:
        {
            SP_ADDPROPERTYPAGE_DATA AddPropertyPageData = { 0 };

            //
            // These property sheets are not for the entire class
            //
            if (DeviceInfoData == NULL)
            {
                break;
            }

            AddPropertyPageData.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);

            if (SetupDiGetClassInstallParams(DeviceInfoSet,
                                             DeviceInfoData,
                                             (PSP_CLASSINSTALL_HEADER)&AddPropertyPageData,
                                             sizeof(SP_ADDPROPERTYPAGE_DATA),
                                             NULL))
            {
                //
                // The Volumes Tab is limited to Administrators
                //
                if (IsUserAdmin() && AddPropertyPageData.NumDynamicPages < MAX_INSTALLWIZARD_DYNAPAGES)
                {
                    //
                    // Create the Volumes Tab
                    //
                    PVOLUME_PAGE_DATA pData = HeapAlloc(GetProcessHeap(), 0, sizeof(VOLUME_PAGE_DATA));

                    if (pData)
                    {
                        HPROPSHEETPAGE hPage = NULL;
                        PROPSHEETPAGE  page = { 0 };

                        pData->DeviceInfoSet  = DeviceInfoSet;
                        pData->DeviceInfoData = DeviceInfoData;

                        page.dwSize      = sizeof(PROPSHEETPAGE);
                        page.dwFlags     = PSP_USECALLBACK;
                        page.hInstance   = ModuleInstance;
                        page.pszTemplate = MAKEINTRESOURCE(ID_VOLUME_PROPPAGE);
                        page.pfnDlgProc  = VolumeDialogProc;
                        page.pfnCallback = VolumeDialogCallback;
                        page.lParam      = (LPARAM) pData;

                        hPage = CreatePropertySheetPage(&page);

                        if (hPage)
                        {
                            //
                            // Look to see if we were launched by Disk Management
                            //
                            HMODULE LdmModule = NULL;

                            pData->bInvokedByDiskmgr = FALSE;

                            LdmModule = GetModuleHandle(TEXT("dmdskmgr"));

                            if (LdmModule)
                            {
                                IS_REQUEST_PENDING pfnIsRequestPending = (IS_REQUEST_PENDING) GetProcAddress(LdmModule, "IsRequestPending");

                                if (pfnIsRequestPending)
                                {
                                    if ((*pfnIsRequestPending)())
                                    {
                                        pData->bInvokedByDiskmgr = TRUE;
                                    }
                                }
                            }

                            AddPropertyPageData.DynamicPages[AddPropertyPageData.NumDynamicPages++] = hPage;

                            SetupDiSetClassInstallParams(DeviceInfoSet,
                                                         DeviceInfoData,
                                                         (PSP_CLASSINSTALL_HEADER)&AddPropertyPageData,
                                                         sizeof(SP_ADDPROPERTYPAGE_DATA));
                        }
                        else
                        {
                            HeapFree(GetProcessHeap(), 0, pData);
                        }
                    }
                }
            }

            return NO_ERROR;
        }

        case DIF_INSTALLDEVICE:
        {
            HKEY hKey;
            DWORD dvdRegion;

            hKey = SetupDiOpenDevRegKey(DeviceInfoSet, DeviceInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DEV, KEY_READ | KEY_WRITE);

            if (hKey != INVALID_HANDLE_VALUE)
            {
                dvdRegion = SystemLocale2DvdRegion (GetSystemDefaultLCID());

                RegSetValueEx (hKey,
                               TEXT("DefaultDvdRegion"),
                               0,
                               REG_DWORD,
                               (PUCHAR) &dvdRegion,
                               sizeof(dvdRegion)
                               );

                RegCloseKey (hKey);
            }

            break;
        }
    }

    return ERROR_DI_DO_DEFAULT;
}

BOOL
DvdContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    )
{
    WinHelp(HwndControl,
            _T("devmgr.hlp"),
            HELP_CONTEXTMENU,
            (ULONG_PTR) DvdHelpIDs);

    return FALSE;
}

void
DvdHelp(
    HWND       ParentHwnd,
    LPHELPINFO HelpInfo
    )
{
    if (HelpInfo->iContextType == HELPINFO_WINDOW) {
        WinHelp((HWND) HelpInfo->hItemHandle,
                _T("devmgr.hlp"),
                HELP_WM_HELP,
                (ULONG_PTR) DvdHelpIDs);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\proppage\ideprop.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ideprop.h
//
//--------------------------------------------------------------------------

#ifndef ___ideprop_h___
#define ___ideprop_h___

#include "..\ide\inc\ideuser.h"

//
// Defines for context sensitive help
//
#define IDH_DEVMGR_IDE_NOHELP (DWORD)-1

#define IDH_DEVMGR_IDE_MASTER_DEVICE_TYPE       2003130
#define IDH_DEVMGR_IDE_MASTER_XFER_MODE         2003140
#define IDH_DEVMGR_IDE_SLAVE_DEVICE_TYPE        2003150
#define IDH_DEVMGR_IDE_SLAVE_XFER_MODE          2003160
#define IDH_DEVMGR_IDE_MASTER_CURRENT_XFER_MODE 2003161
#define IDH_DEVMGR_IDE_SLAVE_CURRENT_XFER_MODE  2003162

#define UDMA_MODE6          (1 << 17)

//
// PageInfo and Prototypes
//

typedef struct _PAGE_INFO {
    HDEVINFO         deviceInfoSet;
    PSP_DEVINFO_DATA deviceInfoData;

    HKEY             hKeyDev;

    IDE_DEVICETYPE      deviceType[2];
    IDE_DEVICETYPE      currentDeviceType[2];
    ULONG               currentTransferMode[2];
    ULONG               transferModeAllowed[2];
    ULONG               transferModeAllowedForAtapiDevice[2];
} PAGE_INFO, * PPAGE_INFO;


PPAGE_INFO
IdeCreatePageInfo(IN HDEVINFO         deviceInfoSet,
                  IN PSP_DEVINFO_DATA deviceInfoData);

void
IdeDestroyPageInfo(PPAGE_INFO * ppPageInfo);

//
// Function Prototypes
//
BOOL APIENTRY
IdePropPageProvider(LPVOID               pinfo,
                    LPFNADDPROPSHEETPAGE pfnAdd,
                    LPARAM               lParam);

HPROPSHEETPAGE
IdeCreatePropertyPage(PROPSHEETPAGE *  ppsp,
                      PPAGE_INFO       ppi);

UINT CALLBACK
IdeDlgCallback(HWND            hwnd,
               UINT            uMsg,
               LPPROPSHEETPAGE ppsp);

INT_PTR APIENTRY
IdeDlgProc(IN HWND   hDlg,
           IN UINT   uMessage,
           IN WPARAM wParam,
           IN LPARAM lParam);

void
IdeApplyChanges(PPAGE_INFO ppi,
                HWND       hDlg);

void
IdeUpdate (PPAGE_INFO ppi,
           HWND       hDlg);

BOOL
IdeContextMenu(HWND HwndControl,
                           WORD Xpos,
                           WORD Ypos);

void
IdeHelp(HWND       ParentHwnd,
                LPHELPINFO HelpInfo);

#endif // ___ideprop_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\proppage\dvdprop.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dvdprop.h
//
//--------------------------------------------------------------------------

#ifndef ___dvdprop_h___
#define ___dvdprop_h___

//
// Defines for context sensitive help
//
#define IDH_DEVMGR_DVD_NOHELP ((DWORD)-1)

#define IDH_DEVMGR_DVD_CURRENT  2003100
#define IDH_DEVMGR_DVD_NEW      2003110
#define IDH_DEVMGR_DVD_LIST     2003120

//
// PageInfo and Prototypes
//

typedef struct _PAGE_INFO {
    HDEVINFO         deviceInfoSet;
    PSP_DEVINFO_DATA deviceInfoData;

    DVD_REGION  regionData;
    ULONG       newRegion;

    ULONG       currentRegion;

    BOOL        changesFailed;

} PAGE_INFO, * PPAGE_INFO;


PPAGE_INFO
DvdCreatePageInfo(IN HDEVINFO         deviceInfoSet,
                  IN PSP_DEVINFO_DATA deviceInfoData);

void
DvdDestroyPageInfo(PPAGE_INFO * ppPageInfo);

//
// Function Prototypes
//
BOOL APIENTRY
DvdPropPageProvider(LPVOID               pinfo,
                    LPFNADDPROPSHEETPAGE pfnAdd,
                    LPARAM               lParam);

HPROPSHEETPAGE
DvdCreatePropertyPage(PROPSHEETPAGE *  ppsp,
                      PPAGE_INFO       ppi);

UINT CALLBACK
DvdDlgCallback(HWND            hwnd,
               UINT            uMsg,
               LPPROPSHEETPAGE ppsp);

INT_PTR APIENTRY
DvdDlgProc(IN HWND   hDlg,
           IN UINT   uMessage,
           IN WPARAM wParam,
           IN LPARAM lParam);

BOOL
DvdApplyChanges(PPAGE_INFO ppi,
                HWND       hDlg);

void
DvdUpdateNewRegionBox (PPAGE_INFO ppi,
                       HWND       hDlg);

ULONG
DvdCountryToRegion (LPCTSTR Country);

BOOL
GetCurrentRpcData(
    PPAGE_INFO ppi,
    PDVD_REGION regionData
    );

ULONG
DvdRegionMaskToRegionNumber(
    UCHAR PlayMask
    );

void
DvdUpdateCurrentSettings (PPAGE_INFO ppi,
                          HWND       hDlg);

HANDLE
GetDeviceHandle (
    PPAGE_INFO ppi,
    DWORD desiredAccess
    );


typedef struct _LCID_2_DVD_TABLE {

    DWORD Lcid;
    DWORD DvdRegion;

} LCID_2_DVD_TABLE, *PLCID_2_DVD_TABLE;

DWORD
SystemLocale2DvdRegion (
    LCID Lcid
    );

DWORD
DvdClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    );

BOOL
DvdContextMenu(HWND HwndControl,
                           WORD Xpos,
                           WORD Ypos);
void
DvdHelp(HWND       ParentHwnd,
                LPHELPINFO HelpInfo
                );

#endif // ___dvdprop_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\proppage\prop.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name :

    prop.c

Abstract :

    Implementation of DllMain

Revision History :

--*/


#include "propp.h"

HMODULE ModuleInstance = NULL;


BOOL WINAPI
DllMain(HINSTANCE DllInstance, DWORD Reason, PVOID Reserved)
{
    switch (Reason)
    {
        case DLL_PROCESS_ATTACH:
        {
            ModuleInstance = DllInstance;
            DisableThreadLibraryCalls(DllInstance);
            break;
        }

        case DLL_PROCESS_DETACH:
        {
            ModuleInstance = NULL;
            break;
        }
    }

    return TRUE;
}


#if DBG

ULONG StorPropDebug = 0;

VOID
StorPropDebugPrint(ULONG DebugPrintLevel, PCHAR DebugMessage, ...)
{
    va_list ap;

    va_start(ap, DebugMessage);

    if ((DebugPrintLevel <= (StorPropDebug & 0x0000ffff)) || ((1 << (DebugPrintLevel + 15)) & StorPropDebug))
    {
        DbgPrint(DebugMessage, ap);
    }

    va_end(ap);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\proppage\godvd.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       godvd.c
//
//--------------------------------------------------------------------------

#include "propp.h"
#include <windows.h>
#include <devioctl.h>
#include <ntdddisk.h>
#include <ntddscsi.h>
#include <ntddcdvd.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>

#include <objbase.h>
#include <initguid.h>
#include <mountdev.h>
#include <setupapi.h>
#include <string.h>


INT
DeviceAdvancedPropertiesW(HWND hwndParent, LPCTSTR MachineName, LPCTSTR DeviceId);


BOOL
APIENTRY
DvdLauncher(HWND HWnd, CHAR DriveLetter)
{
    BOOL status;
    HANDLE fileHandle;
    ULONG length,
          errorCode,
          returned;
    WCHAR string[16] = { 0 };

    HINSTANCE devmgrInstance;
    FARPROC deviceAdvancedPropertiesProc;

    ULONG i;
    PMOUNTDEV_UNIQUE_ID targetInterfaceName;
    ULONG targetInterfaceNameSize;
    HDEVINFO devInfoWithInterface;
    SP_DEVICE_INTERFACE_DATA deviceInterfaceData;
    SP_DEVINFO_DATA devInfoWithInterfaceData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA deviceInterfaceDetailData;
    ULONG deviceInterfaceDetailDataSize;
    ULONG interfaceIndex;
    ULONG deviceInstanceIdSize;
    PTSTR deviceInstanceId;
    BOOL er;

    _snwprintf(string, sizeof(string) / sizeof(string[0]) - 1, L"\\\\.\\%c:", DriveLetter);

    fileHandle = CreateFile(string,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL);

    devmgrInstance = LoadLibrary (L"devmgr.dll");
    if (devmgrInstance == NULL) {
        er = 1;
        goto GetOut1;
    }

    deviceAdvancedPropertiesProc = GetProcAddress(
                                       devmgrInstance,
                                       "DeviceAdvancedPropertiesW");

    if (deviceAdvancedPropertiesProc == NULL) {
        er = 2;
        goto GetOut2;
    }

    er = 3;
    if (fileHandle != INVALID_HANDLE_VALUE) {

        for (i=0, targetInterfaceName=NULL, targetInterfaceNameSize=sizeof(MOUNTDEV_UNIQUE_ID); i<2; i++) {

            targetInterfaceName = LocalAlloc(LPTR, targetInterfaceNameSize);

            status = DeviceIoControl(fileHandle,
                                     IOCTL_MOUNTDEV_QUERY_UNIQUE_ID,
                                     NULL,
                                     0,
                                     targetInterfaceName,
                                     targetInterfaceNameSize,
                                     &returned,
                                     NULL);
            if (!status) {

                GetLastError();

                if (returned >= sizeof(MOUNTDEV_UNIQUE_ID)) {

                    targetInterfaceNameSize = targetInterfaceName->UniqueIdLength + sizeof(MOUNTDEV_UNIQUE_ID);
                }

                LocalFree(targetInterfaceName);
                targetInterfaceName = NULL;
            }
        }

        devInfoWithInterface = SetupDiGetClassDevs(
                                   (LPGUID) &MOUNTDEV_MOUNTED_DEVICE_GUID,
                                   NULL,
                                   NULL,
                                   DIGCF_DEVICEINTERFACE
                                   );
        if (devInfoWithInterface) {

            memset(&deviceInterfaceData, 0, sizeof(SP_DEVICE_INTERFACE_DATA));
            deviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
            interfaceIndex = 0;
            deviceInterfaceDetailData = NULL;
            while (SetupDiEnumDeviceInterfaces(
                   devInfoWithInterface,
                   NULL,
                   (LPGUID) &MOUNTDEV_MOUNTED_DEVICE_GUID,
                   interfaceIndex++,
                   &deviceInterfaceData)) {

                for (i=deviceInterfaceDetailDataSize=0; i<2; i++) {

                    if (deviceInterfaceDetailDataSize) {

                        deviceInterfaceDetailData = LocalAlloc (LPTR, deviceInterfaceDetailDataSize);
                        deviceInterfaceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

                    } else {

                        deviceInterfaceDetailData = NULL;
                    }

                    memset(&devInfoWithInterfaceData, 0, sizeof(SP_DEVINFO_DATA));
                    devInfoWithInterfaceData.cbSize = sizeof(SP_DEVINFO_DATA);
                    if (!SetupDiGetDeviceInterfaceDetail(
                            devInfoWithInterface,
                            &deviceInterfaceData,
                            deviceInterfaceDetailData,
                            deviceInterfaceDetailDataSize,
                            &deviceInterfaceDetailDataSize,
                            &devInfoWithInterfaceData)) {

                        GetLastError();

                        if (deviceInterfaceDetailData) {

                            LocalFree(deviceInterfaceDetailData);
                            deviceInterfaceDetailData = NULL;
                        }
                    }
                }

                if (deviceInterfaceDetailData) {

                    PMOUNTDEV_UNIQUE_ID interfaceName;
                    ULONG interfaceNameSize;
                    HANDLE fileHandle;


                    fileHandle = CreateFile(deviceInterfaceDetailData->DevicePath,
                                     GENERIC_READ,
                                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                                     NULL,
                                     OPEN_EXISTING,
                                     0,
                                     NULL);

                    if (fileHandle != INVALID_HANDLE_VALUE) {

                        for (i=0, interfaceName=NULL, interfaceNameSize=sizeof(MOUNTDEV_UNIQUE_ID); i<2; i++) {

                            interfaceName = LocalAlloc (LPTR, interfaceNameSize);

                            if (!DeviceIoControl(fileHandle,
                                                 IOCTL_MOUNTDEV_QUERY_UNIQUE_ID,
                                                 NULL,
                                                 0,
                                                 interfaceName,
                                                 interfaceNameSize,
                                                 &returned,
                                                 FALSE)) {

                                GetLastError();

                                if (returned >= sizeof(MOUNTDEV_UNIQUE_ID)) {

                                    interfaceNameSize = interfaceName->UniqueIdLength + sizeof(MOUNTDEV_UNIQUE_ID);
                                }

                                LocalFree(interfaceName);
                                interfaceName = NULL;
                            }
                        }

                        if (interfaceName) {

                            if (!wcscmp((PTSTR)targetInterfaceName->UniqueId,
                                        (PTSTR)interfaceName->UniqueId)) {

                                LocalFree(interfaceName);
                                break;
                            }
                            LocalFree(interfaceName);
                        }
                    }

                    LocalFree (deviceInterfaceDetailData);
                    deviceInterfaceDetailData = NULL;
                }

                memset(&deviceInterfaceData, 0, sizeof(SP_DEVICE_INTERFACE_DATA));
                deviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
            }

            if (deviceInterfaceDetailData) {

                for (i=deviceInstanceIdSize=0; i<2; i++) {


                    if (deviceInstanceIdSize) {

                        deviceInstanceId = LocalAlloc (LPTR, deviceInstanceIdSize * sizeof(WCHAR));

                    } else {

                        deviceInstanceId = NULL;
                    }

                    if (!SetupDiGetDeviceInstanceId(
                             devInfoWithInterface,
                             &devInfoWithInterfaceData,
                             deviceInstanceId,
                             deviceInstanceIdSize,
                             &deviceInstanceIdSize
                             )) {

                        GetLastError();

                        if (deviceInstanceId) {

                            LocalFree (deviceInstanceId);
                            deviceInstanceId = NULL;
                        }
                    }
                }

                if (deviceInstanceId) {

                    DVD_REGION regionData;

                    status = (BOOL) deviceAdvancedPropertiesProc(
                                HWnd,
                                NULL,
                                deviceInstanceId
                                );

                    memset(&regionData, 0, sizeof(DVD_REGION));

                    status = DeviceIoControl(fileHandle,
                                             IOCTL_DVD_GET_REGION,
                                             NULL,
                                             0,
                                             &regionData,
                                             sizeof(DVD_REGION),
                                             &returned,
                                             NULL);

                    if (status && (returned == sizeof(DVD_REGION))) {

                        if (~regionData.RegionData & regionData.SystemRegion) {

                            //
                            // region codes agree
                            //
                            er = 0;
                        }
                    }
                }
            }

            SetupDiDestroyDeviceInfoList(
                devInfoWithInterface
                );
        }
    }

GetOut2:

    FreeLibrary(devmgrInstance);

GetOut1:

    return er == 0? TRUE: FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\proppage\propp.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name :

    propp.h

Abstract :

    Common definition file for the Storage Class Installers and their Property Sheets

Revision History :

--*/


#ifndef __STORPROP_PROPP_H_
#define __STORPROP_PROPP_H_

#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

#include <windowsx.h>
#include <objbase.h>
#include <setupapi.h>
#include <shellapi.h>
#include <wmium.h>

#include <devioctl.h>
#include <ntddstor.h>
#include <ntdddisk.h>
#include <ntddscsi.h>
#include <cfgmgr32.h>
#include <assert.h>

#include <initguid.h>
#include <ntddredb.h>

#include "resource.h"


#define SET_FLAG(Flags, Bit)    ( (Flags) |=  (Bit))
#define CLEAR_FLAG(Flags, Bit)  ( (Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   (((Flags) &   (Bit)) != 0)


extern HMODULE ModuleInstance;


BOOLEAN
UtilpRestartDevice(IN HDEVINFO HDevInfo, IN PSP_DEVINFO_DATA DevInfoData);


HANDLE
UtilpGetDeviceHandle(HDEVINFO DevInfo, PSP_DEVINFO_DATA DevInfoData, LPGUID ClassGuid, DWORD DesiredAccess);


#ifdef DebugPrint
#undef DebugPrint
#endif


#if DBG

ULONG
_cdecl DbgPrint(PCH Format, ...);

VOID
StorPropDebugPrint(ULONG DebugPrintLevel, PCHAR DebugMessage, ...);

#define DebugPrint(x) StorPropDebugPrint x

#else

#define DebugPrint(x)

#endif


#endif // __STORPROP_PROPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\proppage\ideprop.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ideprop.c
//
//--------------------------------------------------------------------------

#include "propp.h"
#include "ideprop.h"
#include "resource.h"

const TCHAR *szDeviceType[] = {
    MASTER_DEVICE_TYPE_REG_KEY,
    SLAVE_DEVICE_TYPE_REG_KEY
    };
const TCHAR *szUserDeviceType[] = {
    USER_MASTER_DEVICE_TYPE_REG_KEY,
    USER_SLAVE_DEVICE_TYPE_REG_KEY
    };
const TCHAR *szCurrentTransferMode[] = {
    MASTER_DEVICE_TIMING_MODE,
    SLAVE_DEVICE_TIMING_MODE
    };
const TCHAR *szTransferModeAllowed[] = {
    USER_MASTER_DEVICE_TIMING_MODE_ALLOWED,
    USER_SLAVE_DEVICE_TIMING_MODE_ALLOWED
    };

//
// Help ID mapping for context sensitive help
//
const DWORD IdeHelpIDs[]=
{
        IDC_MASTER_DEVICE_TYPE,         IDH_DEVMGR_IDE_MASTER_DEVICE_TYPE,
        IDC_MASTER_XFER_MODE,           IDH_DEVMGR_IDE_MASTER_XFER_MODE,
        IDC_MASTER_CURRENT_XFER_MODE,   IDH_DEVMGR_IDE_MASTER_CURRENT_XFER_MODE,
        IDC_SLAVE_DEVICE_TYPE,          IDH_DEVMGR_IDE_SLAVE_DEVICE_TYPE,
        IDC_SLAVE_XFER_MODE,            IDH_DEVMGR_IDE_SLAVE_XFER_MODE,
        IDC_SLAVE_CURRENT_XFER_MODE,    IDH_DEVMGR_IDE_SLAVE_CURRENT_XFER_MODE,
        0,0
};

PPAGE_INFO IdeCreatePageInfo(IN HDEVINFO         deviceInfoSet,
                             IN PSP_DEVINFO_DATA deviceInfoData)
{
    PPAGE_INFO  tmp = NULL;

    if (!(tmp = LocalAlloc(LPTR, sizeof(PAGE_INFO)))) {
        return NULL;
    }

    tmp->deviceInfoSet = deviceInfoSet;
    tmp->deviceInfoData = deviceInfoData;

    tmp->hKeyDev =
        SetupDiCreateDevRegKey(deviceInfoSet,
                               deviceInfoData,
                               DICS_FLAG_GLOBAL,
                               0,
                               DIREG_DRV,
                               NULL,
                               NULL);

    return tmp;
}

void
IdeDestroyPageInfo(PPAGE_INFO * ppPageInfo)
{
    PPAGE_INFO ppi = *ppPageInfo;

    if (ppi->hKeyDev != (HKEY) INVALID_HANDLE_VALUE) {
        RegCloseKey(ppi->hKeyDev);
    }

    LocalFree(ppi);

    *ppPageInfo = NULL;
}

HPROPSHEETPAGE
IdeCreatePropertyPage(PROPSHEETPAGE *  ppsp,
                      PPAGE_INFO       ppi)
{
    //
    // Add the Port Settings property page
    //
    ppsp->dwSize      = sizeof(PROPSHEETPAGE);
    ppsp->dwFlags     = PSP_USECALLBACK; // | PSP_HASHELP;
    ppsp->hInstance   = ModuleInstance;
    ppsp->pszTemplate = MAKEINTRESOURCE(ID_IDE_PROPPAGE);

    //
    // following points to the dlg window proc
    //
    ppsp->pfnDlgProc = IdeDlgProc;
    ppsp->lParam     = (LPARAM) ppi;

    //
    // Following points to the control callback of the dlg window proc.
    // The callback gets called before creation/after destruction of the page
    //
    ppsp->pfnCallback = IdeDlgCallback;

    //
    // Allocate the actual page
    //
    return CreatePropertySheetPage(ppsp);
}


BOOL APIENTRY
IdePropPageProvider(LPVOID               pinfo,
                    LPFNADDPROPSHEETPAGE pfnAdd,
                    LPARAM               lParam)
{
    PSP_PROPSHEETPAGE_REQUEST ppr;
    PROPSHEETPAGE    psp;
    HPROPSHEETPAGE   hpsp;
    PPAGE_INFO       ppi = NULL;

    ppr = (PSP_PROPSHEETPAGE_REQUEST) pinfo;

    if (ppr->PageRequested == SPPSR_ENUM_ADV_DEVICE_PROPERTIES) {
        ppi = IdeCreatePageInfo(ppr->DeviceInfoSet,
                                ppr->DeviceInfoData);

        if (!ppi) {
            return FALSE;
        }

        //
        // If this fails, it is most likely that the user does not have
        //  write access to the devices key/subkeys in the registry.
        //  If you only want to read the settings, then change KEY_ALL_ACCESS
        //  to KEY_READ in CreatePageInfo.
        //
        // Administrators usually have access to these reg keys....
        //
#if 0
        if (ppi->hKeyDev == (HKEY) INVALID_HANDLE_VALUE) {
            DWORD error = GetLastError();
            IdeDestroyPageInfo(&ppi);
            return FALSE;
        }
#endif

        hpsp = IdeCreatePropertyPage(&psp,
                                     ppi);

        if (!hpsp) {
            IdeDestroyPageInfo(&ppi);
            return FALSE;
        }

        if (!pfnAdd(hpsp, lParam)) {
            DestroyPropertySheetPage(hpsp);
            return FALSE;
        }
   }

   return TRUE;
}

UINT CALLBACK
IdeDlgCallback(HWND            hwnd,
               UINT            uMsg,
               LPPROPSHEETPAGE ppsp)
{
    PPAGE_INFO ppi;

    switch (uMsg) {
    case PSPCB_CREATE:
        return TRUE;    // return TRUE to continue with creation of page

    case PSPCB_RELEASE:
        ppi = (PPAGE_INFO) ppsp->lParam;
        IdeDestroyPageInfo(&ppi);

        return 0;       // return value ignored

    default:
        break;
    }

    return TRUE;
}

void
IdeInitializeControls(PPAGE_INFO   ppi,
                      HWND         hDlg)
{
    DWORD   dwError,
            dwType,
            dwSize;
    BOOL    disableControls = FALSE;
    HWND    hwnd;
    ULONG   i;
    ULONG   j;
    TCHAR   buffer[50];

    //
    // defaults
    for (i=0; i<2; i++) {
        ppi->deviceType[i] = DeviceUnknown;
    }

    if (ppi->hKeyDev == (HKEY) INVALID_HANDLE_VALUE) {
        //
        // We weren't given write access, try to read the key and translate
        // its value, but disable all of the controls
        disableControls = TRUE;
        ppi->hKeyDev =
            SetupDiOpenDevRegKey(ppi->deviceInfoSet,
                                 ppi->deviceInfoData,
                                 DICS_FLAG_GLOBAL,
                                 0,             // current
                                 DIREG_DRV,
                                 KEY_READ);
    }

    if (ppi->hKeyDev != (HKEY) INVALID_HANDLE_VALUE) {

        //
        // get user choice device types
        //
        for (i=0; i<2; i++) {

            //
            // current device type
            //
            dwSize = sizeof(DWORD);
            dwError = RegQueryValueEx(ppi->hKeyDev,
                                      szDeviceType[i],
                                      NULL,
                                      &dwType,
                                      (PBYTE) (ppi->currentDeviceType + i),
                                      &dwSize);

            if ((dwType != REG_DWORD) ||
                (dwSize != sizeof(DWORD)) ||
                (dwError != ERROR_SUCCESS)) {
                ppi->currentDeviceType[i] = DeviceUnknown;
            }

            if (ppi->currentDeviceType[i] == DeviceNotExist) {
                ppi->currentDeviceType[i] = DeviceUnknown;
            }

            //
            // user choice device type
            //
            dwSize = sizeof(DWORD);
            dwError = RegQueryValueEx(ppi->hKeyDev,
                                      szUserDeviceType[i],
                                      NULL,
                                      &dwType,
                                      (PBYTE) (ppi->deviceType + i),
                                      &dwSize);

            if ((dwType != REG_DWORD) ||
                (dwSize != sizeof(DWORD)) ||
                (dwError != ERROR_SUCCESS)) {
                ppi->deviceType[i] = DeviceUnknown;
            }

            if (ppi->deviceType[i] != DeviceNotExist) {
                ppi->deviceType[i] = DeviceUnknown;
            }

            //
            // transfer mode allowed
            //
            dwSize = sizeof(DWORD);
            ppi->transferModeAllowed[i] = 0xffffffff;
            dwError = RegQueryValueEx(ppi->hKeyDev,
                                      szTransferModeAllowed[i],
                                      NULL,
                                      &dwType,
                                      (PBYTE) (ppi->transferModeAllowed + i),
                                      &dwSize);

            if ((dwType != REG_DWORD) ||
                (dwSize != sizeof(DWORD)) ||
                (dwError != ERROR_SUCCESS)) {

                //
                // default
                //
                ppi->transferModeAllowed[i] = 0xffffffff;
                ppi->transferModeAllowedForAtapiDevice[i] = PIO_SUPPORT;

            } else {

                //
                // user actually picked the xfer mode to use.
                // set this atapi override value to -1 so
                // that it won't affect the user selection
                //
                ppi->transferModeAllowedForAtapiDevice[i] = 0xffffffff;
            }

            //
            // current transfer mode
            //
            dwSize = sizeof(DWORD);
            dwError = RegQueryValueEx(ppi->hKeyDev,
                                      szCurrentTransferMode[i],
                                      NULL,
                                      &dwType,
                                      (PBYTE) (ppi->currentTransferMode + i),
                                      &dwSize);

            if ((dwType != REG_DWORD) ||
                (dwSize != sizeof(DWORD)) ||
                (dwError != ERROR_SUCCESS)) {
                ppi->currentTransferMode[i] = 0;
            }

            if (ppi->deviceType[i] == DeviceNotExist) {
                ppi->currentTransferMode[i] = 0;
            }
        }

        //
        // init drop lists
        //
        if (LoadString(ModuleInstance,
                       IDS_IDE_PIO_ONLY,
                       buffer,
                       50)) {

            for (i=0; i<2; i++) {

                hwnd = GetDlgItem(hDlg, IDC_MASTER_XFER_MODE + i);
                SendMessage(hwnd,
                            CB_ADDSTRING,
                            0,
                            (LPARAM) buffer);
            }
        }

        if (LoadString(ModuleInstance,
                       IDS_IDE_DMA,
                       buffer,
                       50)) {

            for (i=0; i<2; i++) {

                hwnd = GetDlgItem(hDlg, IDC_MASTER_XFER_MODE + i);
                SendMessage(hwnd,
                            CB_ADDSTRING,
                            0,
                            (LPARAM) buffer);
            }
        }

        if (LoadString(ModuleInstance,
                       IDS_IDE_AUTO_DETECT,
                       buffer,
                       50)) {

            for (i=0; i<2; i++) {

                hwnd = GetDlgItem(hDlg, IDC_MASTER_DEVICE_TYPE + i);
                SendMessage(hwnd,
                            CB_ADDSTRING,
                            0,
                            (LPARAM) buffer);
            }
        }

        if (LoadString(ModuleInstance,
                       IDS_IDE_NONE,
                       buffer,
                       50)) {

            for (i=0; i<2; i++) {

                hwnd = GetDlgItem(hDlg, IDC_MASTER_DEVICE_TYPE + i);
                SendMessage(hwnd,
                            CB_ADDSTRING,
                            0,
                            (LPARAM) buffer);
            }
        }

        IdeUpdate(ppi, hDlg);
    }

    if (disableControls) {

        for (i=0; i<2; i++) {

            EnableWindow(GetDlgItem(hDlg, IDC_MASTER_DEVICE_TYPE + i), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_MASTER_XFER_MODE + i), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_MASTER_CURRENT_XFER_MODE + i), FALSE);
        }

        if (ppi->hKeyDev != (HKEY) INVALID_HANDLE_VALUE) {
            RegCloseKey(ppi->hKeyDev);
            ppi->hKeyDev = INVALID_HANDLE_VALUE;
        }
    }
}

void
IdeApplyChanges(PPAGE_INFO ppi,
                HWND       hDlg)
{
    DMADETECTIONLEVEL newDmaDetectionLevel;
    IDE_DEVICETYPE newDeviceType;
    ULONG i;
    BOOLEAN popupError = FALSE;
    BOOLEAN changesMade = FALSE;
    ULONG newXferMode;

    if (ppi->hKeyDev == (HKEY) INVALID_HANDLE_VALUE) {
        return;
    }

    //
    // device type
    //
    for (i=0; i<2; i++) {

        newDeviceType = (IDE_DEVICETYPE) SendDlgItemMessage(hDlg,
                             IDC_MASTER_DEVICE_TYPE + i,
                             CB_GETCURSEL,
                             (WPARAM) 0,
                             (LPARAM) 0);
        if (newDeviceType == 1) {

            newDeviceType = DeviceNotExist;
        } else {

            newDeviceType = DeviceUnknown;
        }

        if (ppi->deviceType[i] != newDeviceType) {

            ppi->deviceType[i] = newDeviceType;

            if (RegSetValueEx(ppi->hKeyDev,
                              szUserDeviceType[i],
                              0,
                              REG_DWORD,
                              (PBYTE) (ppi->deviceType + i),
                              sizeof(DWORD)) != ERROR_SUCCESS) {

                popupError = TRUE;
            } else {

                changesMade = TRUE;
            }
        }
    }

    //
    // transfer mode
    //
    for (i=0; i<2; i++) {

        ULONG xferModeAllowed;

        //
        // NOTE: SendDlgItemMessage will send back 64-bit result in Sundown
        //
        newXferMode = (ULONG) SendDlgItemMessage(hDlg,
                          IDC_MASTER_XFER_MODE + i,
                          CB_GETCURSEL,
                          (WPARAM) 0,
                          (LPARAM) 0);

        if (newXferMode == 0) {

            newXferMode = PIO_SUPPORT;

        } else {

            newXferMode = 0xffffffff;
        }

        xferModeAllowed = ppi->transferModeAllowed[i];
        if ((ppi->currentDeviceType[i] == DeviceIsAtapi) &&
			(!(ppi->currentTransferMode[i] & ~PIO_SUPPORT))) {

            //
            // atapi override only if the current transfer mode is not DMA
			// this is to take care of dvds and cdrws where we enable DMA
			// by default.
            //
            xferModeAllowed &= ppi->transferModeAllowedForAtapiDevice[i];

        }

        if (newXferMode != xferModeAllowed) {

            ppi->transferModeAllowed[i] = newXferMode;

            if (RegSetValueEx(ppi->hKeyDev,
                              szTransferModeAllowed[i],
                              0,
                              REG_DWORD,
                              (PBYTE) (ppi->transferModeAllowed + i),
                              sizeof(DWORD)) != ERROR_SUCCESS) {

                popupError = TRUE;

            } else {

                changesMade = TRUE;
            }
        }
    }



    if (popupError) {
        TCHAR buf1[MAX_PATH+1];
        TCHAR buf2[MAX_PATH+1];

        RtlZeroMemory(buf1, sizeof(buf1));
        RtlZeroMemory(buf2, sizeof(buf2));

        LoadString(ModuleInstance, IDS_IDE_SAVE_ERROR, buf1, MAX_PATH);
        LoadString(ModuleInstance, IDS_IDE_SAVE_ERROR, buf2, MAX_PATH);

        MessageBox(hDlg, buf1, buf2, MB_OK);
    }

    if (changesMade) {

        SP_DEVINSTALL_PARAMS devInstallParams;

        devInstallParams.cbSize = sizeof (devInstallParams);

        SetupDiGetDeviceInstallParams(ppi->deviceInfoSet,
                                      ppi->deviceInfoData,
                                      &devInstallParams
                                      );

        devInstallParams.Flags |= (DI_PROPERTIES_CHANGE);

        SetupDiSetDeviceInstallParams(ppi->deviceInfoSet,
                                      ppi->deviceInfoData,
                                      &devInstallParams
                                      );
        CM_Reenumerate_DevNode_Ex( ppi->deviceInfoData->DevInst,
                                   0,
                                   NULL);
    }
}

INT_PTR APIENTRY
IdeDlgProc(IN HWND   hDlg,
           IN UINT   uMessage,
           IN WPARAM wParam,
           IN LPARAM lParam)
{
    PPAGE_INFO ppi;

    ppi = (PPAGE_INFO) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMessage) {
    case WM_INITDIALOG:

        //
        // on WM_INITDIALOG call, lParam points to the property
        // sheet page.
        //
        // The lParam field in the property sheet page struct is set by the
        // caller. When I created the property sheet, I passed in a pointer
        // to a struct containing information about the device. Save this in
        // the user window long so I can access it on later messages.
        //
        ppi = (PPAGE_INFO) ((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) ppi);

        //
        // Initialize dlg controls
        //
        IdeInitializeControls(ppi,
                              hDlg);

        //
        // Didn't set the focus to a particular control.  If we wanted to,
        // then return FALSE
        //
        return TRUE;

    case WM_COMMAND:

        switch (HIWORD(wParam)) {
        case CBN_SELCHANGE:
           PropSheet_Changed(GetParent(hDlg), hDlg);
           return TRUE;

        default:
           break;
        }

        switch(LOWORD(wParam)) {

        default:
            break;
        }

        break;

    case WM_CONTEXTMENU:
        return IdeContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP:
        IdeHelp(hDlg, (LPHELPINFO) lParam);
        break;

    case WM_NOTIFY:

        switch (((NMHDR *)lParam)->code) {

        //
        // Sent when the user clicks on Apply OR OK !!
        //
        case PSN_APPLY:
            //
            // Do what ever action is necessary
            //
            IdeApplyChanges(ppi,
                            hDlg);

            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            return TRUE;

        default:
            break;
        }

        break;
   }

   SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
   return FALSE;
}

void
IdeUpdate (PPAGE_INFO ppi,
           HWND       hDlg)
{
    ULONG   i;
    DWORD   dwError,
            dwType,
            dwSize;
    TCHAR   buffer[50];

    //
    // set current values
    //
    for (i=0; i<2; i++) {

        ULONG xferModeString;
        ULONG xferModeAllowed;

        //
        // current device type
        //
        SendDlgItemMessage(hDlg,
                           IDC_MASTER_DEVICE_TYPE + i,
                           CB_SETCURSEL,
                           ppi->deviceType[i] == DeviceNotExist? 1 : 0,
                           0L);

        if (ppi->currentDeviceType[i] != DeviceUnknown) {

            EnableWindow(GetDlgItem(hDlg, IDC_MASTER_DEVICE_TYPE + i), FALSE);

        } else {

            EnableWindow(GetDlgItem(hDlg, IDC_MASTER_DEVICE_TYPE + i), TRUE);
        }

        //
        // select transfer mode
        //
        xferModeAllowed = ppi->transferModeAllowed[i];
        if ((ppi->currentDeviceType[i] == DeviceIsAtapi) &&
			(!(ppi->currentTransferMode[i] & ~PIO_SUPPORT))) {

            //
            // atapi override only if the current transfer mode is not DMA
			// this is to take care of dvds and cdrws where we enable DMA
			// by default.
            //
            xferModeAllowed &= ppi->transferModeAllowedForAtapiDevice[i];
        }

        if (xferModeAllowed & ~PIO_SUPPORT) {

            SendDlgItemMessage(hDlg,
                               IDC_MASTER_XFER_MODE + i,
                               CB_SETCURSEL,
                               1,
                               0L);
        } else {

            SendDlgItemMessage(hDlg,
                               IDC_MASTER_XFER_MODE + i,
                               CB_SETCURSEL,
                               0,
                               0L);
        }

        //
        // current transfer mode
        //
        if (ppi->currentTransferMode[i] & UDMA_SUPPORT) {

            if (ppi->currentTransferMode[i] & UDMA_MODE6) {

                xferModeString = IDC_UDMA_MODE6_STRING;

            } else if (ppi->currentTransferMode[i] & UDMA_MODE5) {

                xferModeString = IDC_UDMA_MODE5_STRING;

            } else if (ppi->currentTransferMode[i] & UDMA_MODE4) {

                xferModeString = IDC_UDMA_MODE4_STRING;

            } else if (ppi->currentTransferMode[i] & UDMA_MODE3) {

                xferModeString = IDC_UDMA_MODE3_STRING;

            } else if (ppi->currentTransferMode[i] & UDMA_MODE2) {

                xferModeString = IDC_UDMA_MODE2_STRING;

            } else if (ppi->currentTransferMode[i] & UDMA_MODE1) {

                xferModeString = IDC_UDMA_MODE1_STRING;

            } else if (ppi->currentTransferMode[i] & UDMA_MODE0) {

                xferModeString = IDC_UDMA_MODE0_STRING;

            } else {

                xferModeString = IDC_UDMA_MODE_STRING;
            }

        } else if (ppi->currentTransferMode[i] & (MWDMA_SUPPORT | SWDMA_SUPPORT)) {

            if (ppi->currentTransferMode[i] & MWDMA_MODE2) {

                xferModeString = IDC_MWDMA_MODE2_STRING;

            } else if (ppi->currentTransferMode[i] & MWDMA_MODE1) {

                xferModeString = IDC_MWDMA_MODE1_STRING;

            } else if (ppi->currentTransferMode[i] & SWDMA_MODE2) {

                xferModeString = IDC_SWDMA_MODE2_STRING;

            } else {

                xferModeString = IDC_DMA_MODE_STRING;
            }


        } else if (ppi->currentTransferMode[i] & PIO_SUPPORT) {

            xferModeString = IDC_PIO_MODE_STRING;

        } else {

            xferModeString = IDC_NO_MODE_STRING;
        }

        if (LoadString(ModuleInstance,
                       xferModeString,
                       buffer,
                       50)) {

            SendDlgItemMessage(hDlg,
                               IDC_MASTER_CURRENT_XFER_MODE + i,
                               WM_SETTEXT,
                               0,
                               (LPARAM) buffer);
        }
    }
}

BOOL
IdeContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    )
{
    WinHelp(HwndControl,
            _T("devmgr.hlp"),
            HELP_CONTEXTMENU,
            (ULONG_PTR) IdeHelpIDs);

    return FALSE;
}

void
IdeHelp(
    HWND       ParentHwnd,
    LPHELPINFO HelpInfo
    )
{
    if (HelpInfo->iContextType == HELPINFO_WINDOW) {
        WinHelp((HWND) HelpInfo->hItemHandle,
                                _T("devmgr.hlp"),
                HELP_WM_HELP,
                (ULONG_PTR) IdeHelpIDs);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\proppage\resource.h ===
/*++

Copyright (c) Microsoft Corporation, 2000

Module Name :

    resource.h

Abstract :

    Include file to be used by proppage.rc

Revision History :

--*/

#define IDS_IDE_PIO_ONLY                1
#define IDS_IDE_DMA                     2
#define IDS_IDE_AUTO_DETECT             3
#define IDS_IDE_NONE                    4
#define IDS_ADVANCED                    6
#define IDS_IDE_SAVE_ERROR              7
#define IDS_IDE_SAVE_ERROR_TITLE        8
#define IDS_VOLUME_VOLUME               9
#define IDS_VOLUME_CAPACITY             10
#define IDS_DISK_INFO_NOT_FOUND         12
#define IDS_DISK_INFO_NOT_FOUND_TITLE   13
#define ID_IDE_PROPPAGE                 104
#define ID_DISK_PROPPAGE                106
#define ID_SCSI_PROPPAGE                107
#define ID_STORAGE_PROPPAGE             108
#define ID_DVD_PROPPAGE                 109
#define ID_VOLUME_PROPPAGE              110
#define IDB_DISK                        113
#define ID_CDROM_PROPPAGE               114
#define IDD_VOLUME                      115
#define IDC_CAPACITY                    290
#define IDC_VOLUME_LIST                 306
#define IDC_DRV_PIE                     1001
#define IDC_MASTER_XFER_MODE            1003
#define IDC_SLAVE_XFER_MODE             1004
#define IDC_MASTER_DEVICE_TYPE          1007
#define IDC_SLAVE_DEVICE_TYPE           1008
#define IDC_DVD_COUNTRY_LIST            1009
#define IDC_NEW_REGION                  1011
#define IDC_CURRENT_REGION              1013
#define IDC_CHANGE_TEXT                 1014
#define IDC_DVD_HELP                    1015
#define IDC_MASTER_CURRENT_XFER_MODE    1016
#define IDC_SLAVE_CURRENT_XFER_MODE     1017
#define IDC_SCSI_TAGGED_QUEUING         1022
#define IDC_SCSI_SYNCHONOUS_TX          1023
#define IDC_SCSI_LUN                    1026
#define IDC_SCSI_LUN2                   1027
#define IDC_SCSI_LUN3                   1028
#define IDC_CDROM_REDBOOK_ENABLE        1033
#define IDC_CDROM_REDBOOK_DISABLE       1034
#define IDC_CDROM_IS_DRIVE_GOOD         1035
#define IDC_VOLUME_DISKPERF_ENABLE      1036
#define IDC_DVD_CAUTION                 1037
#define IDC_DVD_CHANGE_HELP             1038
#define IDC_PIO_MODE_STRING             1050
#define IDC_DMA_MODE_STRING             1051
#define IDC_UDMA_MODE_STRING            1052
#define IDC_NO_MODE_STRING              1053
#define IDC_DISK                        1071
#define IDC_TYPE                        1072
#define IDC_SPACE                       1073
#define IDC_STATUS                      1074
#define IDC_RESERVED                    1075
#define IDC_PARTSTYLE                   1076
#define IDC_VOLUME_PROPERTY             1090
#define IDC_VOLUME_POPULATE             1091
#define IDC_DISK_STATIC                 1139
#define IDC_TYPE_STATIC                 1140
#define IDC_STATUS_STATIC               1141
#define IDC_SPACE_STATIC                1142
#define IDC_CAPACITY_STATIC             1143
#define IDC_RESERVED_STATIC             1144
#define IDC_PARTSTYLE_STATIC            1145
#define IDC_VOLUMELIST_STATIC           1147
#define IDC_DIV1_STATIC                 1186
#define DVD_REGION1_NAME                2000
#define DVD_REGION2_NAME                2001
#define DVD_REGION3_NAME                2002
#define DVD_REGION4_NAME                2003
#define DVD_REGION5_NAME                2004
#define DVD_REGION6_NAME                2005
#define DVD_REGION7_NAME                2006
#define DVD_REGION8_NAME                2007
#define DVD_NOREGION_NAME               2008
#define DVD_SET_RPC_CONFIRM_TITLE       2010
#define DVD_SET_RPC_CONFIRM             2011
#define DVD_SET_RPC_CONFIRM_LAST_CHANCE 2012
#define DVD_SET_RPC_ERROR_TITLE         2013
#define DVD_SET_RPC_ERROR               2014
#define DVD_HELP                        2015
#define DVD_CHANGE_TEXT                 2016
#define DVD_CAUTION                     2017
#define DVD_CHANGE_HELP                 2018

#define REDBOOK_UNKNOWN_DRIVE_CONFIRM   3000
#define REDBOOK_UNKNOWN_DRIVE_CONFIRM_TITLE 3001
#define IDC_MWDMA_MODE2_STRING          3002
#define IDC_MWDMA_MODE1_STRING          3003
#define IDC_SWDMA_MODE2_STRING          3004
#define IDC_UDMA_MODE0_STRING           3005
#define IDC_UDMA_MODE1_STRING           3006
#define IDC_UDMA_MODE2_STRING           3007
#define IDC_UDMA_MODE3_STRING           3008
#define IDC_UDMA_MODE4_STRING           3009
#define IDC_UDMA_MODE5_STRING           3010
#define IDC_UDMA_MODE6_STRING           3011

//
// Recoding region numbers to the 5000 block.
// (2000 == win2k, 3000 = sp1. )

//
// numbers 2100 - 2600 and 4100 - 4600 are reserved due
// to previous use and MUI's inability to update resouces
// for service packs:
// Region numbers had to be recoded to avoid MUI.dll mixup
//
// This is being done to make it very obvious to the MUI folks
// that the region names have been changed (again).
//

#define DVD_REGION1_00                  3100
#define DVD_REGION1_01                  3101
#define DVD_REGION1_02                  3102
#define DVD_REGION1_03                  3103
#define DVD_REGION1_04                  3104
#define DVD_REGION1_05                  3105
#define DVD_REGION1_06                  3106
#define DVD_REGION1_07                  3107
#define DVD_MAX_REGION1                    8

#define DVD_REGION2_00                  3200
#define DVD_REGION2_01                  3201
#define DVD_REGION2_02                  3202
#define DVD_REGION2_03                  3203
#define DVD_REGION2_04                  3204
#define DVD_REGION2_05                  3205
#define DVD_REGION2_06                  3206
#define DVD_REGION2_07                  3207
#define DVD_REGION2_08                  3208
#define DVD_REGION2_09                  3209
#define DVD_REGION2_10                  3210
#define DVD_REGION2_11                  3211
#define DVD_REGION2_12                  3212
#define DVD_REGION2_13                  3213
#define DVD_REGION2_14                  3214
#define DVD_REGION2_15                  3215
#define DVD_REGION2_16                  3216
#define DVD_REGION2_17                  3217
#define DVD_REGION2_18                  3218
#define DVD_REGION2_19                  3219
#define DVD_REGION2_20                  3220
#define DVD_REGION2_21                  3221
#define DVD_REGION2_22                  3222
#define DVD_REGION2_23                  3223
#define DVD_REGION2_24                  3224
#define DVD_REGION2_25                  3225
#define DVD_REGION2_26                  3226
#define DVD_REGION2_27                  3227
#define DVD_REGION2_28                  3228
#define DVD_REGION2_29                  3229
#define DVD_REGION2_30                  3230
#define DVD_REGION2_31                  3231
#define DVD_REGION2_32                  3232
#define DVD_REGION2_33                  3233
#define DVD_REGION2_34                  3234
#define DVD_REGION2_35                  3235
#define DVD_REGION2_36                  3236
#define DVD_REGION2_37                  3237
#define DVD_REGION2_38                  3238
#define DVD_REGION2_39                  3239
#define DVD_REGION2_40                  3240
#define DVD_REGION2_41                  3241
#define DVD_REGION2_42                  3242
#define DVD_REGION2_43                  3243
#define DVD_REGION2_44                  3244
#define DVD_REGION2_45                  3245
#define DVD_REGION2_46                  3246
#define DVD_REGION2_47                  3247
#define DVD_REGION2_48                  3248
#define DVD_REGION2_49                  3249
#define DVD_REGION2_50                  3250
#define DVD_REGION2_51                  3251
#define DVD_REGION2_52                  3252
#define DVD_REGION2_53                  3253
#define DVD_REGION2_54                  3254
#define DVD_REGION2_55                  3255
#define DVD_REGION2_56                  3256
#define DVD_REGION2_57                  3257
#define DVD_REGION2_58                  3258
#define DVD_REGION2_59                  3259
#define DVD_REGION2_60                  3260
#define DVD_REGION2_61                  3261
#define DVD_REGION2_62                  3262
#define DVD_REGION2_63                  3263
#define DVD_MAX_REGION2                   64

#define DVD_REGION3_00                  3400
#define DVD_REGION3_01                  3401
#define DVD_REGION3_02                  3402
#define DVD_REGION3_03                  3403
#define DVD_REGION3_04                  3404
#define DVD_REGION3_05                  3405
#define DVD_REGION3_06                  3406
#define DVD_REGION3_07                  3407
#define DVD_REGION3_08                  3408
#define DVD_REGION3_09                  3409
#define DVD_REGION3_10                  3410
#define DVD_REGION3_11                  3411
#define DVD_REGION3_12                  3412
#define DVD_REGION3_13                  3413
#define DVD_REGION3_14                  3414
#define DVD_MAX_REGION3                   15

#define DVD_REGION4_00                  3500
#define DVD_REGION4_01                  3501
#define DVD_REGION4_02                  3502
#define DVD_REGION4_03                  3503
#define DVD_REGION4_04                  3504
#define DVD_REGION4_05                  3505
#define DVD_REGION4_06                  3506
#define DVD_REGION4_07                  3507
#define DVD_REGION4_08                  3508
#define DVD_REGION4_09                  3509
#define DVD_REGION4_10                  3510
#define DVD_REGION4_11                  3511
#define DVD_REGION4_12                  3512
#define DVD_REGION4_13                  3513
#define DVD_REGION4_14                  3514
#define DVD_REGION4_15                  3515
#define DVD_REGION4_16                  3516
#define DVD_REGION4_17                  3517
#define DVD_REGION4_18                  3518
#define DVD_REGION4_19                  3519
#define DVD_REGION4_20                  3520
#define DVD_REGION4_21                  3521
#define DVD_REGION4_22                  3522
#define DVD_REGION4_23                  3523
#define DVD_REGION4_24                  3524
#define DVD_REGION4_25                  3525
#define DVD_REGION4_26                  3526
#define DVD_REGION4_27                  3527
#define DVD_REGION4_28                  3528
#define DVD_REGION4_29                  3529
#define DVD_REGION4_30                  3530
#define DVD_REGION4_31                  3531
#define DVD_REGION4_32                  3532
#define DVD_REGION4_33                  3533
#define DVD_REGION4_34                  3534
#define DVD_REGION4_35                  3535
#define DVD_REGION4_36                  3536
#define DVD_REGION4_37                  3537
#define DVD_REGION4_38                  3538
#define DVD_REGION4_39                  3539
#define DVD_REGION4_40                  3540
#define DVD_REGION4_41                  3541
#define DVD_REGION4_42                  3542
#define DVD_REGION4_43                  3543
#define DVD_REGION4_44                  3544
#define DVD_REGION4_45                  3545
#define DVD_REGION4_46                  3546
#define DVD_REGION4_47                  3547
#define DVD_REGION4_48                  3548
#define DVD_REGION4_49                  3549
#define DVD_REGION4_50                  3550
#define DVD_REGION4_51                  3551
#define DVD_REGION4_52                  3552
#define DVD_REGION4_53                  3553
#define DVD_REGION4_54                  3554
#define DVD_REGION4_55                  3555
#define DVD_REGION4_56                  3556
#define DVD_REGION4_57                  3557
#define DVD_REGION4_58                  3558
#define DVD_REGION4_59                  3559
#define DVD_REGION4_60                  3560
#define DVD_REGION4_61                  3561
#define DVD_REGION4_62                  3562
#define DVD_REGION4_63                  3563
#define DVD_REGION4_64                  3564
#define DVD_REGION4_65                  3565
#define DVD_REGION4_66                  3566
#define DVD_REGION4_67                  3567
#define DVD_REGION4_68                  3568
#define DVD_REGION4_69                  3569
#define DVD_REGION4_70                  3570
#define DVD_REGION4_71                  3571
#define DVD_REGION4_72                  3572
#define DVD_MAX_REGION4                   73


#define DVD_REGION5_00                  3700
#define DVD_REGION5_01                  3701
#define DVD_REGION5_02                  3702
#define DVD_REGION5_03                  3703
#define DVD_REGION5_04                  3704
#define DVD_REGION5_05                  3705
#define DVD_REGION5_06                  3706
#define DVD_REGION5_07                  3707
#define DVD_REGION5_08                  3708
#define DVD_REGION5_09                  3709
#define DVD_REGION5_10                  3710
#define DVD_REGION5_11                  3711
#define DVD_REGION5_12                  3712
#define DVD_REGION5_13                  3713
#define DVD_REGION5_14                  3714
#define DVD_REGION5_15                  3715
#define DVD_REGION5_16                  3716
#define DVD_REGION5_17                  3717
#define DVD_REGION5_18                  3718
#define DVD_REGION5_19                  3719
#define DVD_REGION5_20                  3720
#define DVD_REGION5_21                  3721
#define DVD_REGION5_22                  3722
#define DVD_REGION5_23                  3723
#define DVD_REGION5_24                  3724
#define DVD_REGION5_25                  3725
#define DVD_REGION5_26                  3726
#define DVD_REGION5_27                  3727
#define DVD_REGION5_28                  3728
#define DVD_REGION5_29                  3729
#define DVD_REGION5_30                  3730
#define DVD_REGION5_31                  3731
#define DVD_REGION5_32                  3732
#define DVD_REGION5_33                  3733
#define DVD_REGION5_34                  3734
#define DVD_REGION5_35                  3735
#define DVD_REGION5_36                  3736
#define DVD_REGION5_37                  3737
#define DVD_REGION5_38                  3738
#define DVD_REGION5_39                  3739
#define DVD_REGION5_40                  3740
#define DVD_REGION5_41                  3741
#define DVD_REGION5_42                  3742
#define DVD_REGION5_43                  3743
#define DVD_REGION5_44                  3744
#define DVD_REGION5_45                  3745
#define DVD_REGION5_46                  3746
#define DVD_REGION5_47                  3747
#define DVD_REGION5_48                  3748
#define DVD_REGION5_49                  3749
#define DVD_REGION5_50                  3750
#define DVD_REGION5_51                  3751
#define DVD_REGION5_52                  3752
#define DVD_REGION5_53                  3753
#define DVD_REGION5_54                  3754
#define DVD_REGION5_55                  3755
#define DVD_REGION5_56                  3756
#define DVD_REGION5_57                  3757
#define DVD_REGION5_58                  3758
#define DVD_REGION5_59                  3759
#define DVD_REGION5_60                  3760
#define DVD_REGION5_61                  3761
#define DVD_REGION5_62                  3762
#define DVD_REGION5_63                  3763
#define DVD_REGION5_64                  3764
#define DVD_REGION5_65                  3765
#define DVD_REGION5_66                  3766
#define DVD_REGION5_67                  3767
#define DVD_REGION5_68                  3768
#define DVD_REGION5_69                  3769
#define DVD_REGION5_70                  3770
#define DVD_REGION5_71                  3771
#define DVD_REGION5_72                  3772
#define DVD_REGION5_73                  3773
#define DVD_REGION5_74                  3774
#define DVD_REGION5_75                  3775
#define DVD_REGION5_76                  3776
#define DVD_REGION5_77                  3777
#define DVD_MAX_REGION5                   78

#define DVD_REGION6_00                  3900
#define DVD_MAX_REGION6                    1

#define MAX_REGIONS                        6

#define IDC_DISK_POLICY_GROUP               5400
#define IDC_DISK_POLICY_SURPRISE            5401
#define IDC_DISK_POLICY_SURPRISE_MESG       5402
#define IDC_DISK_POLICY_ORDERLY             5403
#define IDC_DISK_POLICY_ORDERLY_MESG        5404
#define IDC_DISK_POLICY_ORDERLY_MSGD        5405
#define IDC_DISK_POLICY_WRITE_CACHE         5406
#define IDC_DISK_POLICY_WRITE_CACHE_MESG    5407
#define IDS_DISK_POLICY_WRITE_CACHE_MSG1    5408
#define IDS_DISK_POLICY_WRITE_CACHE_MSG2    5409
#define IDC_DISK_POLICY_PP_CACHE            5410
#define IDC_DISK_POLICY_PP_CACHE_MESG       5411
#define IDC_DISK_POLICY_DEFAULT             5412

#define IDS_DISK_POLICY_HOTPLUG             5601
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ramdisk\debug.h ===
#ifndef _DEBUG_H_
#define _DEBUG_H_

#if DBG

#define DBG_NONE        0x00000000
#define DBG_INIT        0x00000001
#define DBG_READWRITE   0x00000002
#define DBG_POOL        0x00000004
#define DBG_IOCTL       0x00000008
#define DBG_PNP         0x00000010
#define DBG_POWER       0x00000020
#define DBG_SRB         0x00000040
#define DBG_THREAD      0x00000080
#define DBG_WINDOW      0x00000100
#define DBG_ALL         0x7FFFFFFF

#define DBG_BREAK_ON_UNRECOGNIZED_IOCTL 0x80000000

#define DBG_ERROR       0x00000001
#define DBG_NOTIFY      0x00000002
#define DBG_WARN        0x00000003
#define DBG_INFO        0x00000004
#define DBG_VERBOSE     0x00000005
#define DBG_PAINFUL     0x00000006

extern ULONG BreakOnEntry;
extern ULONG DebugComponents;
extern ULONG DebugLevel;

#define DEFAULT_BREAK_ON_ENTRY FALSE
#define DEFAULT_DEBUG_LEVEL DBG_ERROR
#define DEFAULT_DEBUG_COMPONENTS DBG_ALL

#ifndef DBG_HEADER
#define DBG_HEADER  "RAMDISK: "
#endif

#define DBGPRINT( _component, _level, _fmt ) {                                      \
    if ( ((DebugComponents & (_component)) != 0) && ((_level) <= DebugLevel) ) {    \
        KdPrint(( "%s", DBG_HEADER ));                                              \
        KdPrint( _fmt );                                                            \
    }                                                                               \
}

#define UNRECOGNIZED_IOCTL_BREAK {                                      \
    if ( (DebugComponents & DBG_BREAK_ON_UNRECOGNIZED_IOCTL) != 0 ) {   \
        ASSERT( FALSE );                                                \
    }                                                                   \
}

#else

#define DBGPRINT( _component, _level, _fmt )

#define UNRECOGNIZED_IOCTL_BREAK

#endif // DBG

#if DBG
#define POOL_DBG 1
#endif

#if !defined(POOL_DBG)

#define ALLOCATE_POOL( _type, _size, _private ) ExAllocatePoolWithTag( (_type), (_size), RAMDISK_TAG_GENERAL )
#define FREE_POOL( _addr, _private ) ExFreePool( (_addr) )

#else

VOID
RamdiskInitializePoolDebug (
    VOID
    );

PVOID
RamdiskAllocatePoolWithTag (
    POOL_TYPE PoolType,
    SIZE_T Size,
    ULONG Tag,
    LOGICAL Private,
    PCHAR File,
    ULONG Line
    );

VOID
RamdiskFreePool (
    PVOID Address,
    LOGICAL Private,
    PCHAR File,
    ULONG Line
    );

#define ALLOCATE_POOL( _type, _size, _private ) \
    RamdiskAllocatePoolWithTag(                 \
        (_type),                                \
        (_size),                                \
        RAMDISK_TAG_GENERAL,                    \
        (_private),                             \
        __FILE__,                               \
        __LINE__ )

#define FREE_POOL( _addr, _private ) RamdiskFreePool( (_addr), (_private), __FILE__, __LINE__ )

#endif

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\proppage\redbook.c ===
/*++
Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    RedBook.c

Abstract:

    This command line utility adds and removes redbook
    for a given drive.

Author:

    Henry Gabryjelski (henrygab)

Environment:

    user mode only

Notes:


Revision History:

    07-30-98 : Created

--*/

#include "propp.h"
#include "storprop.h"

//
// redefine these to do what i want them to.
// allows the appearance of structured c++ with
// the performance of c.
//

#ifdef TRY
#undef TRY
#endif

#ifdef LEAVE
#undef LEAVE
#endif

#ifdef FINALLY
#undef FINALLY
#endif

#define TRY
#define LEAVE   goto __label;
#define FINALLY __label:

//
// just to give out unique errors
//

#define ERROR_REDBOOK_FILTER        0x80ff00f0L
#define ERROR_REDBOOK_PASS_THROUGH  0x80ff00f1L


#if DBG

#ifdef UNICODE
#define DbgPrintAllMultiSz DbgPrintAllMultiSzW
#else
#define DbgPrintAllMultiSz DbgPrintAllMultiSzA
#endif // UNICODE

VOID DbgPrintAllMultiSzW(WCHAR *String)
{
    ULONG i = 0;
    while(*String != UNICODE_NULL) {
        DebugPrint((1, "StorProp => MultiSz %3d: %ws\n", i++, String));
        while (*String != UNICODE_NULL) {
            String++;
        }
        String++; // go past the first NULL
    }
}

VOID DbgPrintAllMultiSzA(CHAR *String)
{
    ULONG i = 0;
    while(*String != ANSI_NULL) {
        DebugPrint((1, "StorProp => MultiSz %3d: %ws\n", i++, String));
        while (*String != ANSI_NULL) {
            String++;
        }
        String++; // go past the first NULL
    }
}

#else // !DBG

#define DbgPrintAllMultiSz
#define DbgPrintAllMultiSz

#endif // DBG


////////////////////////////////////////////////////////////////////////////////
// Local prototypes, not exported anywhere

BOOL
IsUserAdmin();

LONG
RedbookpUpperFilterRegDelete(IN HDEVINFO HDevInfo, IN PSP_DEVINFO_DATA DevInfoData);

LONG
RedbookpUpperFilterRegInstall(IN HDEVINFO HDevInfo, IN PSP_DEVINFO_DATA DevInfoData);

BOOLEAN
UtilpIsSingleSzOfMultiSzInMultiSz(
    IN LPTSTR FindOneOfThese,
    IN LPTSTR WithinThese
    );
DWORD
UtilpMultiSzSearchAndDeleteCaseInsensitive(
    LPTSTR  FindThis,
    LPTSTR  FindWithin,
    DWORD  *NewStringLength
    );

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// the actual callbacks should do very little, codewise
//
////////////////////////////////////////////////////////////////////////////////
DWORD
CdromCddaInfo(
    IN     HDEVINFO HDevInfo,
    IN     PSP_DEVINFO_DATA DevInfoData,
       OUT PREDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO CddaInfo,
    IN OUT PULONG BufferSize
    )
/*++

Routine Description:

    Returns whether the drive is a 'known good' drive.
    Returns whether the drive supports CDDA at all.
    Returns whether the drive supports accurate CDDA for only some read sizes.
    ...

Arguments:

    CDDAInfo must point to a pre-allocated buffer for this info
    BufferSize will give size of this buffer, to allow for more fields
    to be added later in a safe manner.

Return Value:

    will return ERROR_SUCCESS/STATUS_SUCCESS (both zero)

Notes:

    If cannot open these registry keys, will default to FALSE,
    since the caller will most likely not have the ability to enable
    redbook anyways.

--*/
{
    HKEY enumHandle = INVALID_HANDLE_VALUE;
    HKEY subkeyHandle = INVALID_HANDLE_VALUE;
    REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO info;
    ULONG i;
    DWORD dataType;
    DWORD dataSize;
    LONG error;

    error = ERROR_SUCCESS;

    if ((*BufferSize == 0)  ||  (CddaInfo == NULL)) {

        *BufferSize = sizeof(REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO);
        return ERROR_INSUFFICIENT_BUFFER;

    }


    RtlZeroMemory(CddaInfo, *BufferSize);
    RtlZeroMemory(&info, sizeof(REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO));

    info.Version = REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO_VERSION;

    TRY {

        enumHandle = SetupDiOpenDevRegKey(HDevInfo,
                                          DevInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DEV,
                                          KEY_READ);

        if (enumHandle == INVALID_HANDLE_VALUE) {
            DebugPrint((1, "StorProp.CddaInfo => unable to open dev key\n"));
            error = ERROR_OUT_OF_PAPER;
            LEAVE;
        }

        error = RegOpenKey(enumHandle, TEXT("DigitalAudio"), &subkeyHandle);
        if (error != ERROR_SUCCESS) {
            DebugPrint((1, "StorProp.CddaInfo => unable to open subkey\n"));
            LEAVE;
        }

        for (i=0; i<3; i++) {

            PBYTE buffer;
            TCHAR * keyName;

            if (i == 0) {
                keyName = TEXT("CDDAAccurate");
                buffer = (PBYTE)(&info.Accurate);
            } else if (i == 1) {
                keyName = TEXT("CDDASupported");
                buffer = (PBYTE)(&info.Supported);
            } else if (i == 2) {
                keyName = TEXT("ReadSizesSupported");
                buffer = (PBYTE)(&info.AccurateMask0);

#if DBG
            } else {
                DebugPrint((0, "StorProp.CddaInfo => Looping w/o handling\n"));
                DebugBreak();
#endif

            }


            dataSize = sizeof(DWORD);
            error = RegQueryValueEx(subkeyHandle,
                                    keyName,
                                    NULL,
                                    &dataType,
                                    buffer,
                                    &dataSize);

            if (error != ERROR_SUCCESS) {
                DebugPrint((1, "StorProp.CddaInfo => unable to query %ws %x\n",
                            keyName, error));
                LEAVE;
            }
            if (dataType != REG_DWORD) {
                DebugPrint((1, "StorProp.CddaInfo => %ws wrong data type (%x)\n",
                            keyName, dataType));
                error = ERROR_INVALID_DATA;
                LEAVE;
            }

            DebugPrint((1, "StorProp.CddaInfo => %ws == %x\n",
                        keyName, *buffer));

        }

    } FINALLY {

        if (subkeyHandle != INVALID_HANDLE_VALUE) {
            RegCloseKey(subkeyHandle);
        }
        if (enumHandle != INVALID_HANDLE_VALUE) {
            RegCloseKey(enumHandle);
        }

        if (error == ERROR_SUCCESS) {

            //
            // everything succeeded -- copy only the amount they requested
            // and don't care about it being aligned on any particular buffer size.
            // this is the only other place the user buffer should be modified
            //
            if (*BufferSize > sizeof(REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO)) {
                *BufferSize = sizeof(REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO);
            }

            DebugPrint((2, "StorProp.CddaInfo => everything worked\n"));
            RtlCopyMemory(CddaInfo, &info, *BufferSize);

        } else {

            DebugPrint((2, "StorProp.CddaInfo => something failed\n"));
            *BufferSize = 0;

        }

    }

    return error;
}


BOOL
CdromKnownGoodDigitalPlayback(
    IN HDEVINFO HDevInfo,
    IN PSP_DEVINFO_DATA DevInfoData
    )
/*++

Routine Description:

    Returns whether this drive is a 'known good' drive.

Arguments:

Return Value:

Notes:

    default to FALSE, since if fails, caller probably does not
    have ability to enable redbook anyways.
    this routine is outdated -- callers should call CdromCddaInfo()
    directly for more exact information.

--*/
{
    REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO CddaInfo;
    ULONG bufferSize;
    DWORD error;

    bufferSize = sizeof(REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO);

#if DBG
    DbgPrint("\n\nOutdated call to CdromKnownGoodDigitalPlayback(), "
             "should be calling CdromCddaInfo()\n\n");
#endif // DBG

    error = CdromCddaInfo(HDevInfo, DevInfoData, &CddaInfo, &bufferSize);

    if (error != ERROR_SUCCESS) {
        return FALSE;
    }

    if (bufferSize <= sizeof(REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO)) {
        return FALSE;
    }

    if (CddaInfo.Accurate) {
        return TRUE;
    }

    if (CddaInfo.Supported && CddaInfo.AccurateMask0) {
        return TRUE;
    }

    return FALSE;

}


LONG
CdromEnableDigitalPlayback(
    IN HDEVINFO HDevInfo,
    IN PSP_DEVINFO_DATA DevInfoData,
    IN BOOLEAN ForceUnknown
)
/*++

Routine Description:

    Enables redbook
        1) add redbook to filter list (if not there)
        2) if not on stack (via test of guid) re-start stack
        3) if still not on stack, error
        4) set wmi guid item enabled

Arguments:

    DevInfo      - the device to enable it on
    DevInfoData  -
    ForceUnknown - will set a popup if not a known good drive and this is false

Return Value:

    ERROR_XXX value

--*/
{
    LONG status;
    SP_DEVINSTALL_PARAMS devInstallParameters;
    REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO digitalInfo;
    ULONG digitalInfoSize;
    BOOLEAN enableIt;

    //
    // restrict to administrator ???
    //

    if (!IsUserAdmin()) {
        DebugPrint((1, "StorProp.Enable => you need to be administrator to "
                    "enable redbook\n"));
        return ERROR_ACCESS_DENIED;
    }

    digitalInfoSize = sizeof(REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO);
    RtlZeroMemory(&digitalInfo, digitalInfoSize);

    status = CdromCddaInfo(HDevInfo, DevInfoData,
                           &digitalInfo, &digitalInfoSize);

    if (status != ERROR_SUCCESS) {

        DebugPrint((1, "StorProp.Enable => not success getting info %x\n",
                    status));

        //
        // fake some info
        //

        digitalInfo.Version = REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO_VERSION;
        digitalInfo.Accurate = 0;
        digitalInfo.Supported = 1;
        digitalInfo.AccurateMask0 = -1;
        digitalInfoSize = sizeof(REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO);

    }

    if (digitalInfoSize < sizeof(REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO)) {
        DebugPrint((3, "StorProp.Enable => returned %x bytes? (not %x)\n",
                    digitalInfoSize,
                    sizeof(REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO)
                    ));
        return ERROR_ACCESS_DENIED;
    }

    if (!digitalInfo.Supported) {
        DebugPrint((1, "StorProp.Enable => This drive will never "
                    "support redbook\n"));
    //    return ERROR_INVALID_FUNCTION; // log an error here?
    }

    //
    // if it's not accurate AND we don't have the compensating info AND
    // they didn't force it to install, then popup a dialog.
    //

    if (!(digitalInfo.Accurate) &&
        !(digitalInfo.AccurateMask0) &&
        !(ForceUnknown)
        ) {

        BOOLEAN okToProceed = FALSE;
        TCHAR buffer[MAX_PATH+1];
        TCHAR bufferTitle[MAX_PATH+1];

        buffer[0] = '\0';
        bufferTitle[0] = '\0';
        buffer[MAX_PATH] = '\0';
        bufferTitle[MAX_PATH] = '\0';

        //
        // not forced, and not known good.  pop up a box asking permission
        //
        LoadString(ModuleInstance,
                   REDBOOK_UNKNOWN_DRIVE_CONFIRM,
                   buffer,
                   MAX_PATH);
        LoadString(ModuleInstance,
                   REDBOOK_UNKNOWN_DRIVE_CONFIRM_TITLE,
                   bufferTitle,
                   MAX_PATH);
        if (MessageBox(GetDesktopWindow(),
                       buffer,
                       bufferTitle,
                       MB_YESNO          |  // ok and cancel buttons
                       MB_ICONQUESTION   |  // question icon
                       MB_DEFBUTTON2     |  // cancel is default
                       MB_SYSTEMMODAL       // must respond to this box
                       ) == IDYES) {
            okToProceed = TRUE;
        }

        if (!okToProceed) {
            DebugPrint((3, "StorProp.Enable => User did not force installation "
                        "on unknown drive\n"));
            return ERROR_REDBOOK_FILTER;
        }
    }

    //
    // ensure it is in the filter list
    //

    RedbookpUpperFilterRegInstall(HDevInfo, DevInfoData);

    //
    // restart the device to load redbook
    //

    if (!UtilpRestartDevice(HDevInfo, DevInfoData)) {

        DebugPrint((1, "StorProp.Enable => Restart failed\n"));

    } else {

        DebugPrint((1, "StorProp.Enable => Restart succeeded\n"));

    }
    return ERROR_SUCCESS;

}


LONG
CdromDisableDigitalPlayback(IN HDEVINFO HDevInfo, IN PSP_DEVINFO_DATA DevInfoData)
{
    DWORD status = ERROR_SUCCESS;

    //
    // This API is restrict to admins only
    //

    if (!IsUserAdmin())
    {
        DebugPrint((1, "StorProp.Disable => User is not administrator\n"));
        return ERROR_ACCESS_DENIED;
    }

    //
    // Delete redbook from the upper filters list regardless
    //

    status = RedbookpUpperFilterRegDelete(HDevInfo, DevInfoData);

    if (status == ERROR_SUCCESS)
    {
        //
        // Restart the device to remove redbook from the stack
        //

        UtilpRestartDevice(HDevInfo, DevInfoData);
    }

    return status;
}


LONG
CdromIsDigitalPlaybackEnabled(IN HDEVINFO HDevInfo, IN PSP_DEVINFO_DATA DevInfoData, OUT PBOOLEAN Enabled)
{
    DWORD status = ERROR_SUCCESS;
    DWORD dwSize = 0;

    *Enabled = FALSE;

    status = SetupDiGetDeviceRegistryProperty(HDevInfo,
                                              DevInfoData,
                                              SPDRP_UPPERFILTERS,
                                              NULL,
                                              NULL,
                                              0,
                                              &dwSize) ? ERROR_SUCCESS : GetLastError();
    if (status == ERROR_INSUFFICIENT_BUFFER)
    {
        TCHAR* szBuffer = LocalAlloc(LPTR, dwSize);

        if (szBuffer)
        {
            if (SetupDiGetDeviceRegistryProperty(HDevInfo,
                                                 DevInfoData,
                                                 SPDRP_UPPERFILTERS,
                                                 NULL,
                                                 (PBYTE)szBuffer,
                                                 dwSize,
                                                 NULL))
            {
                if (UtilpIsSingleSzOfMultiSzInMultiSz(_T("redbook\0"), szBuffer))
                {
                    //
                    // Digital playback is indeed enabled
                    //

                    *Enabled = TRUE;
                }

                status = ERROR_SUCCESS;
            }
            else
            {
                status = GetLastError();
            }

            LocalFree(szBuffer);
        }
        else
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else if (status == ERROR_INVALID_DATA)
    {
        //
        // There probably isn't any upper filter installed
        //

        status = ERROR_SUCCESS;
    }

    return status;
}


////////////////////////////////////////////////////////////////////////////////
//
// The support routines do all the work....
//
////////////////////////////////////////////////////////////////////////////////


HANDLE
UtilpGetDeviceHandle(
    HDEVINFO DevInfo,
    PSP_DEVINFO_DATA DevInfoData,
    LPGUID ClassGuid,
    DWORD DesiredAccess
    )
/*++

Routine Description:

    gets a handle for a device

Arguments:

    the name of the device to open

Return Value:

    handle to the device opened, which must be later closed by the caller.

Notes:

    this function is also in the class installer (syssetup.dll)
    so please propogate fixes there as well

--*/
{
    BOOL status;
    ULONG i;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;


    SP_DEVICE_INTERFACE_DATA deviceInterfaceData;

    HDEVINFO devInfoWithInterface = NULL;
    PSP_DEVICE_INTERFACE_DETAIL_DATA deviceInterfaceDetailData = NULL;
    PTSTR deviceInstanceId = NULL;

    ULONG deviceInterfaceDetailDataSize;
    ULONG deviceInstanceIdSize;



    TRY {

        //
        // get the ID for this device
        //

        for (i=deviceInstanceIdSize=0; i<2; i++) {

            if (deviceInstanceIdSize != 0) {

                //
                // deviceInstanceIdSize is returned in CHARACTERS
                // by SetupDiGetDeviceInstanceId(), so must allocate
                // returned size * sizeof(TCHAR)
                //

                deviceInstanceId =
                    LocalAlloc(LPTR, deviceInstanceIdSize * sizeof(TCHAR));

                if (deviceInstanceId == NULL) {
                    DebugPrint((1, "StorProp.GetDeviceHandle => Unable to "
                                "allocate for deviceInstanceId\n"));
                    LEAVE;
                }


            }

            status = SetupDiGetDeviceInstanceId(DevInfo,
                                                DevInfoData,
                                                deviceInstanceId,
                                                deviceInstanceIdSize,
                                                &deviceInstanceIdSize
                                                );
        }

        if (!status) {
            DebugPrint((1, "StorProp.GetDeviceHandle => Unable to get "
                        "Device IDs\n"));
            LEAVE;
        }

        //
        // Get all the cdroms in the system
        //

        devInfoWithInterface = SetupDiGetClassDevs(ClassGuid,
                                                   deviceInstanceId,
                                                   NULL,
                                                   DIGCF_DEVICEINTERFACE
                                                   );

        if (devInfoWithInterface == NULL) {
            DebugPrint((1, "StorProp.GetDeviceHandle => Unable to get "
                        "list of CdRom's in system\n"));
            LEAVE;
        }


        memset(&deviceInterfaceData, 0, sizeof(SP_DEVICE_INTERFACE_DATA));
        deviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

        status = SetupDiEnumDeviceInterfaces(devInfoWithInterface,
                                             NULL,
                                             ClassGuid,
                                             0,
                                             &deviceInterfaceData
                                             );

        if (!status) {
            DebugPrint((1, "StorProp.GetDeviceHandle => Unable to get "
                        "SP_DEVICE_INTERFACE_DATA\n"));
            LEAVE;
        }


        for (i=deviceInterfaceDetailDataSize=0; i<2; i++) {

            if (deviceInterfaceDetailDataSize != 0) {

                //
                // deviceInterfaceDetailDataSize is returned in BYTES
                // by SetupDiGetDeviceInstanceId(), so must allocate
                // returned size only
                //

                deviceInterfaceDetailData =
                    LocalAlloc (LPTR, deviceInterfaceDetailDataSize);

                if (deviceInterfaceDetailData == NULL) {
                    DebugPrint((1, "StorProp.GetDeviceHandle => Unable to "
                                "allocate for deviceInterfaceDetailData\n"));
                    LEAVE;
                }

                deviceInterfaceDetailData->cbSize =
                    sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

            }

            status = SetupDiGetDeviceInterfaceDetail(devInfoWithInterface,
                                                     &deviceInterfaceData,
                                                     deviceInterfaceDetailData,
                                                     deviceInterfaceDetailDataSize,
                                                     &deviceInterfaceDetailDataSize,
                                                     NULL);
        }

        if (!status) {
            DebugPrint((1, "StorProp.GetDeviceHandle => Unable to get "
                        "DeviceInterfaceDetail\n"));
            LEAVE;
        }

        if (deviceInterfaceDetailDataSize <=
            FIELD_OFFSET(SP_DEVICE_INTERFACE_DETAIL_DATA, DevicePath)) {
            DebugPrint((1, "StorProp.GetDeviceHandle => No device path\n"));
            status = ERROR_PATH_NOT_FOUND;
            LEAVE;
        }

        //
        // no need to memcpy it, just use the path returned to us.
        //

        fileHandle = CreateFile(deviceInterfaceDetailData->DevicePath,
                                DesiredAccess,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL);

        if (fileHandle == INVALID_HANDLE_VALUE) {
            DebugPrint((1, "StorProp.GetDeviceHandle => Final CreateFile() "
                        "failed\n"));
            LEAVE;
        }

        DebugPrint((3, "StorProp.GetDeviceHandle => handle %x opened\n",
                    fileHandle));


    } FINALLY {

        if (devInfoWithInterface != NULL) {
            SetupDiDestroyDeviceInfoList(devInfoWithInterface);
        }

        if (deviceInterfaceDetailData != NULL) {
            LocalFree (deviceInterfaceDetailData);
        }

    }

    return fileHandle;
}


BOOLEAN
UtilpRestartDevice(
    IN HDEVINFO HDevInfo,
    IN PSP_DEVINFO_DATA DevInfoData
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    SP_PROPCHANGE_PARAMS parameters;
    SP_DEVINSTALL_PARAMS installParameters;
    BOOLEAN succeeded = FALSE;

    RtlZeroMemory(&parameters,        sizeof(SP_PROPCHANGE_PARAMS));
    RtlZeroMemory(&installParameters, sizeof(SP_DEVINSTALL_PARAMS));

    //
    // Initialize the SP_CLASSINSTALL_HEADER struct at the beginning of the
    // SP_PROPCHANGE_PARAMS struct.  this allows SetupDiSetClassInstallParams
    // to work.
    //

    parameters.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    parameters.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;

    //
    // Initialize SP_PROPCHANGE_PARAMS such that the device will be STOPPED
    //

    parameters.Scope       = DICS_FLAG_CONFIGSPECIFIC;
    parameters.HwProfile   = 0; // current profile

    //
    // prepare for the call to SetupDiCallClassInstaller (to stop the device)
    //

    parameters.StateChange = DICS_STOP;

    if (!SetupDiSetClassInstallParams(HDevInfo,
                                      DevInfoData,
                                      (PSP_CLASSINSTALL_HEADER)&parameters,
                                      sizeof(SP_PROPCHANGE_PARAMS))) {
        DebugPrint((1, "UtilpRestartDevice => Couldn't stop the device (%x)\n",
                    GetLastError()));
        goto FinishRestart;
    }

    //
    // actually stop the device
    //

    if (!SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,
                                   HDevInfo,
                                   DevInfoData)) {
        DebugPrint((1, "UtilpRestartDevice => call to class installer "
                    "(STOP) failed (%x)\n", GetLastError()));
        goto FinishRestart;
    }



    //
    // prepare for the call to SetupDiCallClassInstaller (to start the device)
    //

    parameters.StateChange = DICS_START;


    if (!SetupDiSetClassInstallParams(HDevInfo,
                                      DevInfoData,
                                      (PSP_CLASSINSTALL_HEADER)&parameters,
                                      sizeof(SP_PROPCHANGE_PARAMS))) {
        DebugPrint((1, "UtilpRestartDevice => Couldn't stop the device (%x)\n",
                    GetLastError()));
        goto FinishRestart;
    }

    //
    // actually start the device
    //

    if (!SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,
                                   HDevInfo,
                                   DevInfoData)) {
        DebugPrint((1, "UtilpRestartDevice => call to class installer "
                    "(STOP) failed (%x)\n", GetLastError()));
        goto FinishRestart;
    }

    succeeded = TRUE;

FinishRestart:

    //
    // this call will succeed, but we should still check the status
    //

    if (!SetupDiGetDeviceInstallParams(HDevInfo,
                                       DevInfoData,
                                       &installParameters)) {
        DebugPrint((1, "UtilpRestartDevice => Couldn't get the device install "
                    "paramters (%x)\n", GetLastError()));
        return FALSE;
    }

    if (TEST_FLAG(installParameters.Flags, DI_NEEDREBOOT)) {
        DebugPrint((1, "UtilpRestartDevice => Device needs a reboot.\n"));
        return FALSE;
    }
    if (TEST_FLAG(installParameters.Flags, DI_NEEDRESTART)) {
        DebugPrint((1, "UtilpRestartDevice => Device needs a restart(!).\n"));
        return FALSE;
    }

    if (succeeded) {
        DebugPrint((1, "UtilpRestartDevice => Device successfully stopped and "
                    "restarted.\n"));
        return TRUE;
    }

    SET_FLAG(installParameters.Flags, DI_NEEDRESTART);

    DebugPrint((1, "UtilpRestartDevice => Device needs to be restarted.\n"));
    SetupDiSetDeviceInstallParams(HDevInfo, DevInfoData, &installParameters);

    return FALSE;


}


LONG
RedbookpUpperFilterRegDelete(IN HDEVINFO HDevInfo, IN PSP_DEVINFO_DATA DevInfoData)
{
    DWORD status = ERROR_SUCCESS;
    DWORD dwSize = 0;

    status = SetupDiGetDeviceRegistryProperty(HDevInfo,
                                              DevInfoData,
                                              SPDRP_UPPERFILTERS,
                                              NULL,
                                              NULL,
                                              0,
                                              &dwSize) ? ERROR_SUCCESS : GetLastError();
    if (status == ERROR_INSUFFICIENT_BUFFER)
    {
        TCHAR* szBuffer = LocalAlloc(LPTR, dwSize);

        if (szBuffer)
        {
            if (SetupDiGetDeviceRegistryProperty(HDevInfo,
                                                 DevInfoData,
                                                 SPDRP_UPPERFILTERS,
                                                 NULL,
                                                 (PBYTE)szBuffer,
                                                 dwSize,
                                                 NULL))
            {
                if (UtilpMultiSzSearchAndDeleteCaseInsensitive(_T("redbook"), szBuffer, &dwSize))
                {
                    status = SetupDiSetDeviceRegistryProperty(HDevInfo,
                                                              DevInfoData,
                                                              SPDRP_UPPERFILTERS,
                                                              (dwSize == 0) ? NULL : (PBYTE)szBuffer,
                                                              dwSize) ? ERROR_SUCCESS : GetLastError();
                }
                else
                {
                    //
                    // Redbook isn't loaded for this device
                    //

                    status = ERROR_SUCCESS;
                }
            }
            else
            {
                status = GetLastError();
            }

            LocalFree(szBuffer);
        }
        else
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else if (status == ERROR_INVALID_DATA)
    {
        //
        // There probably isn't any upper filter installed
        //

        status = ERROR_SUCCESS;
    }

    return status;
}


LONG
RedbookpUpperFilterRegInstall(IN HDEVINFO HDevInfo, IN PSP_DEVINFO_DATA DevInfoData)
{
    DWORD status = ERROR_SUCCESS;
    DWORD dwSize = 0;

    status = SetupDiGetDeviceRegistryProperty(HDevInfo,
                                              DevInfoData,
                                              SPDRP_UPPERFILTERS,
                                              NULL,
                                              NULL,
                                              0,
                                              &dwSize) ? ERROR_SUCCESS : GetLastError();
    if (status == ERROR_INSUFFICIENT_BUFFER)
    {
        TCHAR* szBuffer = LocalAlloc(LPTR, dwSize);

        if (szBuffer)
        {
            if (SetupDiGetDeviceRegistryProperty(HDevInfo,
                                                 DevInfoData,
                                                 SPDRP_UPPERFILTERS,
                                                 NULL,
                                                 (PBYTE)szBuffer,
                                                 dwSize,
                                                 NULL))
            {
                if (!UtilpIsSingleSzOfMultiSzInMultiSz(_T("redbook\0"), szBuffer))
                {
                    //
                    // Add Redbook to the beginning of the list
                    //

                    DWORD  dwNewSize   = dwSize + sizeof(_T("redbook"));
                    TCHAR* szNewBuffer = LocalAlloc(LPTR, dwNewSize);

                    if (szNewBuffer)
                    {
                        _tcscpy(szNewBuffer, _T("redbook"));

                        RtlCopyMemory(szNewBuffer + _tcslen(_T("redbook")) + 1, szBuffer, dwSize);

                        status = SetupDiSetDeviceRegistryProperty(HDevInfo,
                                                                  DevInfoData,
                                                                  SPDRP_UPPERFILTERS,
                                                                  (PBYTE)szNewBuffer,
                                                                  dwNewSize) ? ERROR_SUCCESS : GetLastError();

                        LocalFree(szNewBuffer);
                    }
                    else
                    {
                        status = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
                else
                {
                    //
                    // Redbook is already loaded for this device
                    //

                    status = ERROR_SUCCESS;
                }
            }
            else
            {
                status = GetLastError();
            }

            LocalFree(szBuffer);
        }
        else
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else if (status == ERROR_INVALID_DATA)
    {
        //
        // There probably isn't any upper filter installed
        //

        TCHAR szBuffer[] = _T("redbook\0");

        dwSize = sizeof(szBuffer);

        status = SetupDiSetDeviceRegistryProperty(HDevInfo,
                                                  DevInfoData,
                                                  SPDRP_UPPERFILTERS,
                                                  (PBYTE)szBuffer,
                                                  dwSize) ? ERROR_SUCCESS : GetLastError();
    }

    return status;
}


BOOLEAN
UtilpIsSingleSzOfMultiSzInMultiSz(
    IN LPTSTR FindOneOfThese,
    IN LPTSTR WithinThese
    )
/*++

Routine Description:

    Deletes all instances of a string from within a multi-sz.
    automagically operates on either unicode or ansi or ??

Arguments:

    FindOneOfThese - multisz to search with
    WithinThese    - multisz to search in

Return Value:

    1/20 of one cent, or the number of strings deleted, rounded down.

Notes:

    expect small inputs, so n*m is acceptable run time.

--*/
{
    LPTSTR searchFor;
    LPTSTR within;


    //
    // loop through all strings in FindOneOfThese
    //

    searchFor = FindOneOfThese;
    while ( _tcscmp(searchFor, TEXT("\0")) ) {

        //
        // loop through all strings in WithinThese
        //

        within = WithinThese;
        while ( _tcscmp(within, TEXT("\0"))) {

            //
            // if the are equal, return TRUE
            //

            if ( !_tcscmp(searchFor, within) ) {
                return TRUE;
            }

            within += _tcslen(within) + 1;
        } // end of WithinThese loop

        searchFor += _tcslen(searchFor) + 1;
    } // end of FindOneOfThese loop

    return FALSE;
}


DWORD
UtilpMultiSzSearchAndDeleteCaseInsensitive(
    LPTSTR  FindThis,
    LPTSTR  FindWithin,
    DWORD  *NewStringLength
    )
/*++

Routine Description:

    Deletes all instances of a string from within a multi-sz.
    automagically operates on either unicode or ansi or ??

Arguments:

    NewStringLength is in BYTES, not number of chars

Return Value:

    1/20 of one cent, or the number of strings deleted, rounded down.

--*/
{
    LPTSTR search;
    DWORD  charOffset;
    DWORD  instancesDeleted;

    if ((*NewStringLength) % sizeof(TCHAR)) {
        assert(!"String must be in bytes, does not divide by sizeof(TCHAR)\n");
        return 0;
    }

    if ((*NewStringLength) < sizeof(TCHAR)*2) {
        assert(!"String must be multi-sz, which requires at least two chars\n");
        return 0;
    }

    charOffset = 0;
    instancesDeleted = 0;
    search = FindWithin;

    //
    // loop while there string length is not zero
    // couldn't find a TNULL, or i'd just compare.
    //

    while (_tcsicmp(search, TEXT("\0")) != 0) {

        //
        // if this string matches...
        //

        if (_tcsicmp(search, FindThis) == 0) {

            //
            // the new length is smaller
            // remove the string (and terminating null)
            //

            instancesDeleted++;
            *NewStringLength -= (_tcslen(search) + 1) * sizeof(TCHAR);

            RtlMoveMemory(search,
                          search + _tcslen(search) + 1,
                          *NewStringLength - (charOffset * sizeof(TCHAR))
                          );

        } else {

            //
            // move current search pointer
            // increment current offset (in CHARS)
            //

            charOffset += _tcslen(search) + 1;
            search     += _tcslen(search) + 1;

        }

        //
        // it's that simple
        //
    }

    //
    // if deleted all strings, set to double-null
    //

    if (*NewStringLength == sizeof(TCHAR)) {
        FindWithin = TEXT("\0");
        *NewStringLength = 0;
    }

    return instancesDeleted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ramdisk\precomp.h ===
#define _NTDRIVER_

#include <ntosp.h>
#include <zwapi.h>
#include <mountdev.h>

#include <stdio.h>
#include <string.h>

#include <ntdddisk.h>
#include <ntddscsi.h>
#include <ntddvol.h>
#include <ntddft.h>
#include <ntddsnap.h>
#include <scsi.h>

#include <ntddramd.h>
//#include <xip.h>

#include "ramdisk.h"
#include "debug.h"

#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ramdisk\ioctl.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    This file contains RAM disk driver code for processing IOCTLs.

Author:

    Chuck Lenzmeier (ChuckL) 2001

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntverp.h>

#if !DBG

#define PRINT_CODE( _code )

#else

#define PRINT_CODE( _code )                                             \
    if ( print ) {                                                      \
        DBGPRINT( DBG_IOCTL, DBG_VERBOSE, ("%s", "  " #_code "\n") );    \
    }                                                                   \
    print = FALSE;

#endif

//
// Local functions.
//

NTSTATUS
RamdiskQueryProperty (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

//
// Declare pageable routines.
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, RamdiskDeviceControl )
#pragma alloc_text( PAGE, RamdiskCreateRamDisk )
#pragma alloc_text( PAGE, RamdiskCreateDiskDevice )
#pragma alloc_text( PAGE, RamdiskGetDriveLayout )
#pragma alloc_text( PAGE, RamdiskGetPartitionInfo )
#pragma alloc_text( PAGE, RamdiskSetPartitionInfo )
#pragma alloc_text( PAGE, RamdiskQueryProperty )

#endif // ALLOC_PRAGMA

NTSTATUS
RamdiskDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to perform a device I/O
    control function.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    //PBIOS_PARAMETER_BLOCK bios;
    PCOMMON_EXTENSION commonExtension;
    PBUS_EXTENSION busExtension;
    PDISK_EXTENSION diskExtension;
    PIO_STACK_LOCATION irpSp;
    PRAMDISK_QUERY_INPUT queryInput;
    PRAMDISK_QUERY_OUTPUT queryOutput;
    PRAMDISK_MARK_FOR_DELETION_INPUT markInput;
    PLIST_ENTRY listEntry;
    NTSTATUS status;
    ULONG_PTR info;
    BOOLEAN lockHeld = FALSE;
    BOOLEAN calleeWillComplete = FALSE;

#if DBG
    BOOLEAN print = TRUE;
#endif

    PAGED_CODE();

    //
    // Set up device extension and IRP pointers.
    //

    commonExtension = DeviceObject->DeviceExtension;
    busExtension = DeviceObject->DeviceExtension;
    diskExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // ISSUE: what about BiosParameters?
    //
    //bios = &diskExtension->BiosParameters;

    //
    // Acquire the remove lock. If this fails, fail the I/O.
    //

    status = IoAcquireRemoveLock( &commonExtension->RemoveLock, Irp );

    if ( !NT_SUCCESS(status) ) {

        COMPLETE_REQUEST( status, 0, Irp );
        return status;
    }

    //
    // Indicate that the remove lock is held.
    //

    lockHeld = TRUE;

    //
    // Assume failure.
    //

    status = STATUS_INVALID_DEVICE_REQUEST;
    info = 0;

    //
    // Dispatch based on the device type (bus or disk).
    //

    switch ( commonExtension->DeviceType ) {
    
    case RamdiskDeviceTypeBusFdo:

        //
        // The target is the bus FDO.
        //
        // Dispatch based on the IOCTL code.
        //

        switch ( irpSp->Parameters.DeviceIoControl.IoControlCode ) {
        
        case FSCTL_CREATE_RAM_DISK:

            PRINT_CODE( FSCTL_DISK_CREATE_RAM_DISK );

            //
            // Creation of a RAM disk must be handled in thread context. But
            // before sending it off to the thread, we need to verify that
            // the caller has access to the backing file.
            //

            status = RamdiskCreateRamDisk( DeviceObject, Irp, TRUE );

            if ( NT_SUCCESS(status) ) {

                status = SendIrpToThread( DeviceObject, Irp );
            }

            break;

        case FSCTL_QUERY_RAM_DISK:

            PRINT_CODE( FSCTL_QUERY_RAM_DISK );

            //
            // Lock the disk PDO list and look for a disk with the specified
            // disk GUID.
            //
            // Verify that the input parameter buffer is big enough.
            //
        
            if ( irpSp->Parameters.DeviceIoControl.InputBufferLength <
                                                    sizeof(RAMDISK_QUERY_INPUT) ) {
        
                status = STATUS_INVALID_PARAMETER;

                break;
            }
        
            queryInput = (PRAMDISK_QUERY_INPUT)Irp->AssociatedIrp.SystemBuffer;

            if ( queryInput->Version != sizeof(RAMDISK_QUERY_INPUT) ) {
        
                status = STATUS_INVALID_PARAMETER;

                break;
            }
        
            KeEnterCriticalRegion();
            ExAcquireFastMutex( &busExtension->Mutex );

            diskExtension = NULL;

            for ( listEntry = busExtension->DiskPdoList.Flink;
                  listEntry != &busExtension->DiskPdoList;
                  listEntry = listEntry->Flink ) {

                diskExtension = CONTAINING_RECORD( listEntry, DISK_EXTENSION, DiskPdoListEntry );

                if ( memcmp(
                        &diskExtension->DiskGuid,
                        &queryInput->DiskGuid,
                        sizeof(diskExtension->DiskGuid)
                        ) == 0 ) {

                    break;
                }

                diskExtension = NULL;
            }

            if ( diskExtension == NULL ) {

                //
                // Couldn't find a matching device.
                //

                status = STATUS_NO_SUCH_DEVICE;

            } else {

                //
                // Found a matching device. Return the requested information.
                //

                status = STATUS_SUCCESS;
                info = sizeof(RAMDISK_QUERY_OUTPUT);
                if ( RAMDISK_IS_FILE_BACKED(diskExtension->DiskType) ) {
                    // NB: struct size already includes space for one wchar.
                    info += wcslen(diskExtension->FileName) * sizeof(WCHAR);
                }

                if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength < info ) {
            
                    status = STATUS_BUFFER_TOO_SMALL;
                    info = 0;

                } else {

                    queryOutput = (PRAMDISK_QUERY_OUTPUT)Irp->AssociatedIrp.SystemBuffer;

                    queryOutput->Version = sizeof(RAMDISK_QUERY_OUTPUT);
                    queryOutput->DiskGuid = diskExtension->DiskGuid;
                    queryOutput->DiskType = diskExtension->DiskType;
                    queryOutput->Options = diskExtension->Options;
                    queryOutput->DiskLength = diskExtension->DiskLength;
                    queryOutput->DiskOffset = diskExtension->DiskOffset;
                    queryOutput->ViewCount = diskExtension->ViewCount;
                    queryOutput->ViewLength = diskExtension->ViewLength;

                    if ( diskExtension->DiskType == RAMDISK_TYPE_BOOT_DISK ) {

                        queryOutput->BasePage = diskExtension->BasePage;
                        queryOutput->DriveLetter = diskExtension->DriveLetter;

                    } else if ( diskExtension->DiskType == RAMDISK_TYPE_VIRTUAL_FLOPPY ) {

                        queryOutput->BaseAddress = diskExtension->BaseAddress;

                    } else {

                        size_t remainingLength;
                        HRESULT result;

                        remainingLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
                        remainingLength -= FIELD_OFFSET( RAMDISK_QUERY_OUTPUT, FileName );

                        result = StringCbCopyW(
                                    queryOutput->FileName,
                                    remainingLength,
                                    diskExtension->FileName
                                    );
                        ASSERT( result == S_OK );
                    }
                }
            }
            
            ExReleaseFastMutex( &commonExtension->Mutex );
            KeLeaveCriticalRegion();

            break;

        case FSCTL_MARK_RAM_DISK_FOR_DELETION:

            PRINT_CODE( FSCTL_MARK_RAM_DISK_FOR_DELETION );

            //
            // Lock the disk PDO list and look for a disk with the specified
            // disk GUID.
            //
            // Verify that the input parameter buffer is big enough.
            //
        
            if ( irpSp->Parameters.DeviceIoControl.InputBufferLength <
                                                    sizeof(RAMDISK_MARK_FOR_DELETION_INPUT) ) {
        
                status = STATUS_INVALID_PARAMETER;

                break;
            }
        
            markInput = (PRAMDISK_MARK_FOR_DELETION_INPUT)Irp->AssociatedIrp.SystemBuffer;

            if ( markInput->Version != sizeof(RAMDISK_MARK_FOR_DELETION_INPUT) ) {
        
                status = STATUS_INVALID_PARAMETER;

                break;
            }
        
            KeEnterCriticalRegion();
            ExAcquireFastMutex( &busExtension->Mutex );

            diskExtension = NULL;

            for ( listEntry = busExtension->DiskPdoList.Flink;
                  listEntry != &busExtension->DiskPdoList;
                  listEntry = listEntry->Flink ) {

                diskExtension = CONTAINING_RECORD( listEntry, DISK_EXTENSION, DiskPdoListEntry );

                if ( memcmp(
                        &diskExtension->DiskGuid,
                        &markInput->DiskGuid,
                        sizeof(diskExtension->DiskGuid)
                        ) == 0 ) {

                    break;
                }

                diskExtension = NULL;
            }

            if ( diskExtension == NULL ) {

                //
                // Couldn't find a matching device.
                //

                status = STATUS_NO_SUCH_DEVICE;

            } else {

                //
                // Found a matching device. Mark it for deletion.
                //

                diskExtension->MarkedForDeletion = TRUE;

                status = STATUS_SUCCESS;
            }
            
            ExReleaseFastMutex( &commonExtension->Mutex );
            KeLeaveCriticalRegion();

            break;

        case IOCTL_STORAGE_QUERY_PROPERTY:

            PRINT_CODE( IOCTL_STORAGE_QUERY_PROPERTY );

            //
            // Call RamdiskQueryProperty() to handle the request. This routine
            // releases the lock. It also takes care of IRP completion.
            //

            status = RamdiskQueryProperty( DeviceObject, Irp );

            lockHeld = FALSE;
            calleeWillComplete = TRUE;

            break;

        default:

            //
            // The specified I/O control code is unrecognized by this driver.
            // The I/O status field in the IRP has already been set, so just
            // terminate the switch.
            //
    
            DBGPRINT( DBG_IOCTL, DBG_ERROR, ("Ramdisk:  ERROR:  unrecognized IOCTL %x\n",
                        irpSp->Parameters.DeviceIoControl.IoControlCode) );

            UNRECOGNIZED_IOCTL_BREAK;

            break;
        }

        break;
    
    case RamdiskDeviceTypeDiskPdo:

        //
        // The target is a disk PDO.
        //
        // Dispatch based on the IOCTL code.
        //

        switch ( irpSp->Parameters.DeviceIoControl.IoControlCode ) {
        
        case IOCTL_MOUNTDEV_QUERY_DEVICE_NAME:

            PRINT_CODE( IOCTL_MOUNTDEV_QUERY_DEVICE_NAME );

            {
                PMOUNTDEV_NAME mountName;
                ULONG outputLength;

                outputLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

                //
                // The output buffer must be at least big enough to hold the
                // length of the device name.
                //

                if ( outputLength < sizeof(mountName->NameLength) ) {

                    status = STATUS_INVALID_PARAMETER;

                    break;
                }

                //
                // Write the length of the device name into the output buffer.
                // If the buffer is big enough, write the name, too.
                //

                mountName = Irp->AssociatedIrp.SystemBuffer;
                mountName->NameLength = diskExtension->DeviceName.Length;
    
                if ( outputLength < (sizeof(mountName->NameLength) + mountName->NameLength) ) {

                    status = STATUS_BUFFER_OVERFLOW;
                    info = sizeof(mountName->NameLength);

                    break;
                }
    
                RtlCopyMemory(
                    mountName->Name,
                    diskExtension->DeviceName.Buffer,
                    mountName->NameLength
                    );
    
                status = STATUS_SUCCESS;
                info = sizeof(mountName->NameLength) + mountName->NameLength;
            }

            break;

        case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID:

            PRINT_CODE( IOCTL_MOUNTDEV_QUERY_UNIQUE_ID );

            {
                PMOUNTDEV_UNIQUE_ID uniqueId;
                ULONG outputLength;
    
                outputLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
    
                //
                // The output buffer must be at least big enough to hold the
                // length of the unique ID.
                //

                if ( outputLength < sizeof(uniqueId->UniqueIdLength) ) {

                    status = STATUS_INVALID_PARAMETER;

                    break;
                }
    
                //
                // Write the length of the unique ID into the output buffer.
                // If the buffer is big enough, write the unique ID, too.
                //

                uniqueId = Irp->AssociatedIrp.SystemBuffer;
                uniqueId->UniqueIdLength = sizeof(diskExtension->DiskGuid);
    
                if ( outputLength <
                        (sizeof(uniqueId->UniqueIdLength) + uniqueId->UniqueIdLength) ) {

                    status = STATUS_BUFFER_OVERFLOW;
                    info = sizeof(uniqueId->UniqueIdLength);

                    break;
                }
    
                RtlCopyMemory(
                    uniqueId->UniqueId,
                    &diskExtension->DiskGuid,
                    uniqueId->UniqueIdLength
                    );
    
                status = STATUS_SUCCESS;
                info = sizeof(uniqueId->UniqueIdLength) + uniqueId->UniqueIdLength;
            }

            break;
    
        case IOCTL_MOUNTDEV_QUERY_STABLE_GUID:

            PRINT_CODE( IOCTL_MOUNTDEV_QUERY_STABLE_GUID );
    
            {
                PMOUNTDEV_STABLE_GUID stableGuid;
                ULONG outputLength;
    
                outputLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
    
                //
                // The output buffer must be at big enough to hold the GUID.
                //

                if ( outputLength < sizeof(MOUNTDEV_STABLE_GUID) ) {

                    status = STATUS_INVALID_PARAMETER;

                    break;
                }
    
                //
                // Write the GUID to the output buffer;
                //

                stableGuid = Irp->AssociatedIrp.SystemBuffer;
                stableGuid->StableGuid = diskExtension->DiskGuid;
    
                status = STATUS_SUCCESS;
                info = sizeof(MOUNTDEV_STABLE_GUID);
            }
            break;
    
        case IOCTL_DISK_GET_MEDIA_TYPES:

            PRINT_CODE( IOCTL_DISK_GET_MEDIA_TYPES );

            // Fall through.

        case IOCTL_STORAGE_GET_MEDIA_TYPES:

            PRINT_CODE( IOCTL_STORAGE_GET_MEDIA_TYPES );

            // Fall through.

        case IOCTL_DISK_GET_DRIVE_GEOMETRY:

            PRINT_CODE( IOCTL_DISK_GET_DRIVE_GEOMETRY );

            //
            // Return the drive geometry for the virtual disk.  Note that
            // we return values which were made up to suit the disk size.
            //
    
            if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(DISK_GEOMETRY) ) {
    
                status = STATUS_INVALID_PARAMETER;
                
            } else {
    
                PDISK_GEOMETRY outputBuffer;

                outputBuffer = (PDISK_GEOMETRY)Irp->AssociatedIrp.SystemBuffer;
    
                outputBuffer->MediaType = diskExtension->Options.Fixed ?
                                                    FixedMedia : RemovableMedia;
                outputBuffer->Cylinders.QuadPart = diskExtension->NumberOfCylinders;
                outputBuffer->TracksPerCylinder = diskExtension->TracksPerCylinder;
                outputBuffer->SectorsPerTrack = diskExtension->SectorsPerTrack;
                outputBuffer->BytesPerSector = diskExtension->BytesPerSector;

                DBGPRINT( DBG_IOCTL, DBG_PAINFUL,
                            ("    MediaType    = %x\n", outputBuffer->MediaType) );
                DBGPRINT( DBG_IOCTL, DBG_VERBOSE,
                            ("    Cylinders    = %x\n", outputBuffer->Cylinders) );
                DBGPRINT( DBG_IOCTL, DBG_VERBOSE,
                            ("    Tracks/cyl   = %x\n", outputBuffer->TracksPerCylinder) );
                DBGPRINT( DBG_IOCTL, DBG_VERBOSE,
                            ("    Sector/track = %x\n", outputBuffer->SectorsPerTrack) );
                DBGPRINT( DBG_IOCTL, DBG_VERBOSE,
                            ("    Bytes/sector = %x\n", outputBuffer->BytesPerSector) );
    
                status = STATUS_SUCCESS;
                info = sizeof( DISK_GEOMETRY );
            }

            break;
    
        case IOCTL_DISK_IS_WRITABLE:

            PRINT_CODE( IOCTL_DISK_IS_WRITABLE );

            //
            // Indicate whether the disk is write protected.
            //

            status = diskExtension->Options.Readonly ?
                        STATUS_MEDIA_WRITE_PROTECTED : STATUS_SUCCESS;

            break;
    
        case IOCTL_DISK_VERIFY:

            PRINT_CODE( IOCTL_DISK_VERIFY );

            {
                PVERIFY_INFORMATION	verifyInformation;
                ULONG inputLength;
                ULONGLONG ioOffset;
                ULONG ioLength;
    
                inputLength = irpSp->Parameters.DeviceIoControl.InputBufferLength;
    
                if ( inputLength < sizeof(VERIFY_INFORMATION) ) {

                    status = STATUS_INVALID_PARAMETER;

                    break;
                }
    
                verifyInformation = Irp->AssociatedIrp.SystemBuffer;
    
                ioOffset = verifyInformation->StartingOffset.QuadPart;
                ioLength = verifyInformation->Length;

                //
                // If the requested length is 0, we have nothing to do.
                // Otherwise, verify that the request is sector aligned,
                // doesn't wrap, and doesn't extend beyond the length of
                // the disk. If the request is valid, just return success.
                //

                if ( ioLength == 0 ) {

                    status = STATUS_SUCCESS;
    
                } else if ( ((ioOffset + ioLength) < ioOffset) ||
                            ((ioOffset | ioLength) & (diskExtension->BytesPerSector - 1)) != 0 ) {

                    status = STATUS_INVALID_PARAMETER;
    
                } else if ( (ioOffset + ioLength) > diskExtension->DiskLength ) {

                    status = STATUS_NONEXISTENT_SECTOR;
    
                } else {

                    status = STATUS_SUCCESS;
                }
            }

            break;
    
        case IOCTL_DISK_GET_DRIVE_LAYOUT:

            PRINT_CODE( IOCTL_DISK_GET_DRIVE_LAYOUT );
    
            if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(DRIVE_LAYOUT_INFORMATION) ) {
    
                status = STATUS_INVALID_PARAMETER;
    
            } else {

                //
                // If the RAM disk is file-backed, we must send this off to
                // the thread for processing, because it requires reading
                // from the disk image.
                //

                if ( !RAMDISK_IS_FILE_BACKED(diskExtension->DiskType) ) {
    
                    status = RamdiskGetDriveLayout( Irp, diskExtension );
                    info = Irp->IoStatus.Information;
    
                } else {
    
                    status = SendIrpToThread( DeviceObject, Irp );
                }
            }

            break;
    
        case IOCTL_DISK_GET_PARTITION_INFO:

            PRINT_CODE( IOCTL_DISK_GET_PARTITION_INFO );

            if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(PARTITION_INFORMATION) ) {
    
                status = STATUS_INVALID_PARAMETER;
    
            } else {
    
                //
                // If the RAM disk is file-backed, we must send this off to
                // the thread for processing, because it requires reading
                // from the disk image.
                //

                if ( !RAMDISK_IS_FILE_BACKED(diskExtension->DiskType) ) {
    
                    status = RamdiskGetPartitionInfo( Irp, diskExtension );
                    info = Irp->IoStatus.Information;
    
                } else {
    
                    status = SendIrpToThread( DeviceObject, Irp );
                }
            }

            break;
    
        case IOCTL_DISK_GET_LENGTH_INFO:

            PRINT_CODE( IOCTL_DISK_GET_LENGTH_INFO );

            if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(GET_LENGTH_INFORMATION) ) {
    
                status = STATUS_INVALID_PARAMETER;
                
            } else {
    
                PGET_LENGTH_INFORMATION outputBuffer;
    
                outputBuffer = (PGET_LENGTH_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

                outputBuffer->Length.QuadPart = 
                    diskExtension->NumberOfCylinders *
                    diskExtension->TracksPerCylinder *
                    diskExtension->SectorsPerTrack *
                    diskExtension->BytesPerSector;
    
                status = STATUS_SUCCESS;
                info = sizeof(GET_LENGTH_INFORMATION);
            }

            break;
    
        case IOCTL_STORAGE_GET_DEVICE_NUMBER:

            PRINT_CODE( IOCTL_STORAGE_GET_DEVICE_NUMBER );

#if SUPPORT_DISK_NUMBERS

            if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(STORAGE_DEVICE_NUMBER) ) {
    
                status = STATUS_INVALID_PARAMETER;
                
            } else {
    
                PSTORAGE_DEVICE_NUMBER outputBuffer;
    
                outputBuffer = (PSTORAGE_DEVICE_NUMBER)Irp->AssociatedIrp.SystemBuffer;
    
                //outputBuffer->DeviceType = FILE_DEVICE_VIRTUAL_DISK;
                outputBuffer->DeviceType = FILE_DEVICE_DISK;
                outputBuffer->DeviceNumber = diskExtension->DiskNumber;
                outputBuffer->PartitionNumber = -1;
    
                status = STATUS_SUCCESS;
                info = sizeof(STORAGE_DEVICE_NUMBER);
            }

#endif // SUPPORT_DISK_NUMBERS

            break;

        case IOCTL_DISK_SET_PARTITION_INFO:

            PRINT_CODE( IOCTL_DISK_SET_PARTITION_INFO );
    
            //
            // Set information about the partition.
            //
    
            if ( irpSp->Parameters.DeviceIoControl.InputBufferLength <
                    sizeof(SET_PARTITION_INFORMATION) ) {
    
                status = STATUS_INVALID_PARAMETER;
    
            } else {
    
                //
                // If the RAM disk is file-backed, we must send this off to
                // the thread for processing, because it requires writing
                // to the disk image.
                //

                if ( !RAMDISK_IS_FILE_BACKED(diskExtension->DiskType) ) {
    
                    status = RamdiskSetPartitionInfo( Irp, diskExtension );
                    info = Irp->IoStatus.Information;
    
                } else {
    
                    status = SendIrpToThread( DeviceObject, Irp );
                }
            }

            break;
    
        case IOCTL_DISK_SET_DRIVE_LAYOUT:

            PRINT_CODE( IOCTL_DISK_SET_DRIVE_LAYOUT );

            //
            // Haven't seen this one come down yet. Set a breakpoint so that
            // if it does come down, we can verify that this code works.
            //

            UNRECOGNIZED_IOCTL_BREAK;

            //
            // Return the default error.
            //

            break;

        case IOCTL_STORAGE_QUERY_PROPERTY:

            PRINT_CODE( IOCTL_STORAGE_QUERY_PROPERTY );

            //
            // Call RamdiskQueryProperty() to handle the request. This routine
            // releases the lock. It also takes care of IRP completion.
            //

            status = RamdiskQueryProperty( DeviceObject, Irp );

            lockHeld = FALSE;
            calleeWillComplete = TRUE;

            break;

        case IOCTL_VOLUME_GET_GPT_ATTRIBUTES:

            PRINT_CODE( IOCTL_VOLUME_GET_GPT_ATTRIBUTES );

            //
            // Return disk attributes.
            //
    
            if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(VOLUME_GET_GPT_ATTRIBUTES_INFORMATION) ) {
    
                status = STATUS_INVALID_PARAMETER;
    
            } else {
    
                PVOLUME_GET_GPT_ATTRIBUTES_INFORMATION outputBuffer;

                outputBuffer = (PVOLUME_GET_GPT_ATTRIBUTES_INFORMATION)
                                                Irp->AssociatedIrp.SystemBuffer;
    
                outputBuffer->GptAttributes = 0;
                if ( diskExtension->Options.Readonly ) {
                    outputBuffer->GptAttributes |= GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY;
                }
                if ( diskExtension->Options.NoDriveLetter ) {
                    outputBuffer->GptAttributes |= GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER;
                }
                if ( diskExtension->Options.Hidden ) {
                    outputBuffer->GptAttributes |= GPT_BASIC_DATA_ATTRIBUTE_HIDDEN;
                }
    
                status = STATUS_SUCCESS;
                info = sizeof(VOLUME_GET_GPT_ATTRIBUTES_INFORMATION);
            }

            break;

        case IOCTL_VOLUME_SET_GPT_ATTRIBUTES:

            PRINT_CODE( IOCTL_VOLUME_SET_GPT_ATTRIBUTES );

            //
            // Set disk attributes.
            //
    
            if ( irpSp->Parameters.DeviceIoControl.InputBufferLength <
                    sizeof(VOLUME_SET_GPT_ATTRIBUTES_INFORMATION) ) {
    
                status = STATUS_INVALID_PARAMETER;
    
            } else {
    
                PVOLUME_SET_GPT_ATTRIBUTES_INFORMATION inputBuffer;

                inputBuffer = (PVOLUME_SET_GPT_ATTRIBUTES_INFORMATION)
                                                Irp->AssociatedIrp.SystemBuffer;
    
                if ( diskExtension->Options.Hidden ) {

                    if ( (inputBuffer->GptAttributes & GPT_BASIC_DATA_ATTRIBUTE_HIDDEN) == 0 ) {

                        diskExtension->Options.Hidden = FALSE;
                        status = IoSetDeviceInterfaceState(
                                    &diskExtension->InterfaceString,
                                    TRUE
                                    );
                    }

                } else {

                    if ( (inputBuffer->GptAttributes & GPT_BASIC_DATA_ATTRIBUTE_HIDDEN) != 0 ) {

                        diskExtension->Options.Hidden = TRUE;
                        status = IoSetDeviceInterfaceState(
                                    &diskExtension->InterfaceString,
                                    FALSE
                                    );
                    }
                }
    
                status = STATUS_SUCCESS;
            }

            break;

        case IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS:

            PRINT_CODE( IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS );

            //
            // We only support this for volume-emulating RAM disks. For
            // disk-emulating RAM disks, this IOCTL should be handled by
            // higher layers.
            //

            if ( diskExtension->DiskType == RAMDISK_TYPE_FILE_BACKED_DISK ) {

                status = STATUS_INVALID_PARAMETER;
            
            } else if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength < 
                    sizeof(VOLUME_DISK_EXTENTS) ) {
    
                status = STATUS_BUFFER_TOO_SMALL;
    
            } else {
    
                PVOLUME_DISK_EXTENTS inputBuffer;

                inputBuffer = (PVOLUME_DISK_EXTENTS)Irp->AssociatedIrp.SystemBuffer;

                inputBuffer->NumberOfDiskExtents = 1;
                inputBuffer->Extents[0].DiskNumber = (ULONG)-1;
                inputBuffer->Extents[0].StartingOffset.QuadPart = 0;
                inputBuffer->Extents[0].ExtentLength.QuadPart = diskExtension->DiskLength;

                status = STATUS_SUCCESS;
                info = sizeof(VOLUME_DISK_EXTENTS);
            }

            break;

        //
        // The following codes return success without doing anything.
        //

        case IOCTL_DISK_CHECK_VERIFY:

            PRINT_CODE( IOCTL_DISK_CHECK_VERIFY );

            // Fall through.

        case IOCTL_STORAGE_CHECK_VERIFY:

            PRINT_CODE( IOCTL_STORAGE_CHECK_VERIFY );

            // Fall through.

        case IOCTL_STORAGE_CHECK_VERIFY2:

            PRINT_CODE( IOCTL_STORAGE_CHECK_VERIFY2 );

            // Fall through.

        case IOCTL_VOLUME_ONLINE:

            PRINT_CODE( IOCTL_VOLUME_ONLINE );

            //
            // Return STATUS_SUCCESS without actually doing anything.
            //

            status = STATUS_SUCCESS;

            break;
    
        //
        // The following codes return the default error.
        //

        case FT_BALANCED_READ_MODE:

            PRINT_CODE( FT_BALANCED_READ_MODE );
    
            // Fall through.
    
        case FT_PRIMARY_READ:

            PRINT_CODE( FT_PRIMARY_READ );
    
            // Fall through.
    
        case IOCTL_DISK_GET_DRIVE_LAYOUT_EX:

            PRINT_CODE( IOCTL_DISK_GET_DRIVE_LAYOUT_EX );

            // Fall through.
    
        case IOCTL_DISK_GET_PARTITION_INFO_EX:

            PRINT_CODE( IOCTL_DISK_GET_PARTITION_INFO_EX );
    
            // Fall through.
    
        case IOCTL_DISK_MEDIA_REMOVAL:

            PRINT_CODE( IOCTL_DISK_MEDIA_REMOVAL );
    
            // Fall through.
    
        case IOCTL_MOUNTDEV_LINK_CREATED:

            PRINT_CODE( IOCTL_MOUNTDEV_LINK_CREATED );

            // Fall through.
            
        case IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME:

            PRINT_CODE( IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME );

            // Fall through.
            
        case IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY:

            PRINT_CODE( IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY );
            
            // Fall through.
            
        case IOCTL_SCSI_GET_ADDRESS:

            PRINT_CODE( IOCTL_SCSI_GET_ADDRESS );

            // Fall through.
    
        case IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS:

            PRINT_CODE( IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS );

            // Fall through.
    
        case IOCTL_STORAGE_GET_HOTPLUG_INFO:

            PRINT_CODE( IOCTL_STORAGE_GET_HOTPLUG_INFO );
    
            //
            // Return the default error.
            //

            break;

        default:

            //
            // The specified I/O control code is unrecognized by this driver.
            // The I/O status field in the IRP has already been set, so just
            // terminate the switch.
            //
    
            DBGPRINT( DBG_IOCTL, DBG_ERROR, ("Ramdisk:  ERROR:  unrecognized IOCTL %x\n",
                        irpSp->Parameters.DeviceIoControl.IoControlCode) );

            UNRECOGNIZED_IOCTL_BREAK;

            break;
    
        }

        break;

    default:

        //
        // Can't get here. Return the default error if the impossible occurs.
        //

        break;
    }

    //
    // Release the remove lock, if it's still held.
    //

    if ( lockHeld ) {
        IoReleaseRemoveLock( &commonExtension->RemoveLock, Irp );
    }

    //
    // If we didn't call another routine that owns completing the IRP, and
    // we didn't send the IRP off to the thread for processing, complete the
    // IRP now.
    //

    if ( !calleeWillComplete && (status != STATUS_PENDING) ) {

        COMPLETE_REQUEST( status, info, Irp );
    }

    return status;

} // RamdiskDeviceControl

NTSTATUS
RamdiskCreateRamDisk (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN BOOLEAN AccessCheckOnly
    )

/*++

Routine Description:

    This routine is called to handle an FSCTL_CREATE_RAM_DISK IRP. It is called
    in thread context.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

    AccessCheckOnly - If FALSE, create the RAM disk. Otherwise, just check
        whether the caller has the necessary access rights to create the disk.

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    ULONG status;
    PBUS_EXTENSION busExtension;
    PDISK_EXTENSION diskExtension;
    PIO_STACK_LOCATION irpSp;
    PRAMDISK_CREATE_INPUT createInput;
    ULONG inputLength;
    PWCHAR p;
    PWCHAR pMax;
    PLOADER_PARAMETER_BLOCK loaderBlock;

    PAGED_CODE();

    //
    // The target device object for the I/O is our bus FDO.
    //

    busExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Verify that the input parameter buffer is big enough.
    //

    inputLength = irpSp->Parameters.DeviceIoControl.InputBufferLength;
    createInput = (PRAMDISK_CREATE_INPUT)Irp->AssociatedIrp.SystemBuffer;

    if ( inputLength < sizeof(RAMDISK_CREATE_INPUT) ) {

        return STATUS_INVALID_PARAMETER;
    }

    if ( createInput->Version != sizeof(RAMDISK_CREATE_INPUT) ) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Verify that the disk type is valid. VIRTUAL_FLOPPY disks can only be
    // created via the registry, and then only during textmode setup.
    // A BOOT_DISK can only be created by the kernel early in the boot
    // process -- when the loader block still exists.
    //
    // ISSUE: If the kernel/driver interface for creating the boot disk is
    // changed, change this test to disallow RAMDISK_TYPE_BOOT_DISK.
    //

    if ( createInput->DiskType == RAMDISK_TYPE_VIRTUAL_FLOPPY ) {

        return STATUS_INVALID_PARAMETER;

    } else if ( createInput->DiskType == RAMDISK_TYPE_BOOT_DISK ) {

        loaderBlock = *(PLOADER_PARAMETER_BLOCK *)KeLoaderBlock;

        if ( loaderBlock == NULL ) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Verify that file name string (if present) is properly terminated.
    //

    if ( RAMDISK_IS_FILE_BACKED(createInput->DiskType) ) {

        pMax = (PWCHAR)((PUCHAR)createInput + inputLength);
        p = createInput->FileName;

        while ( p < pMax ) {

            if ( *p == 0 ) {
                break;
            }

            p++;
        }

        if ( p == pMax ) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Call RamdiskCreateDiskDevice to create the device. If successful, this
    // returns a pointer to the new disk PDO's device extension.
    //

    status = RamdiskCreateDiskDevice( busExtension, createInput, AccessCheckOnly, &diskExtension );

    if ( NT_SUCCESS(status) ) {

        //
        // Tell PnP that we need to reenumerate our bus.
        //

        IoInvalidateDeviceRelations( busExtension->Pdo, BusRelations );

        Irp->IoStatus.Information = 0;
    }

    return status;

} // RamdiskCreateRamDisk

NTSTATUS
RamdiskCreateDiskDevice (
    IN PBUS_EXTENSION BusExtension,
    IN PRAMDISK_CREATE_INPUT CreateInput,
    IN BOOLEAN AccessCheckOnly,
    OUT PDISK_EXTENSION *DiskExtension
    )

/*++

Routine Description:

    This routine does the work to create a new RAM disk device. It is called
    in thread context.

Arguments:

    BusExtension - a pointer to the device extension for the bus FDO

    CreateInput - a pointer to the desired parameters for the new RAM disk

    AccessCheckOnly - If FALSE, create the RAM disk. Otherwise, just check
        whether the caller has the necessary access rights to create the disk.

    DiskExtension - returns a pointer to the new disk PDO's device extension

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    ULONG status;
    ULONG_PTR basePage;
    PVOID baseAddress;
    ULONG i;
    ULONG deviceExtensionSize;
    PDEVICE_OBJECT newDeviceObject;
    WCHAR buffer[15];
    UNICODE_STRING guidString;
    UNICODE_STRING realDeviceName;
    PDISK_EXTENSION diskExtension;
    HANDLE fileHandle;
    HANDLE sectionHandle;
    PVOID sectionObject;
    NTSTATUS ntStatus;
    PVOID viewBase;
    SIZE_T viewSize;
    LARGE_INTEGER sectionOffset;
    UNICODE_STRING string;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    UNICODE_STRING dosSymLink;
    FILE_STANDARD_INFORMATION fileInfo;
    PVIEW viewDescriptors = NULL;
    HRESULT result;

#if SUPPORT_DISK_NUMBERS
    ULONG diskNumber;
#endif // SUPPORT_DISK_NUMBERS

    PAGED_CODE();

    //
    // Initialize local variables to prepare for exit cleanup.
    //

#if SUPPORT_DISK_NUMBERS
    diskNumber = 0xffffffff;
#endif // SUPPORT_DISK_NUMBERS

    fileHandle = NULL;
    sectionHandle = NULL;
    sectionObject = NULL;
    viewDescriptors = NULL;
    guidString.Buffer = NULL;
    realDeviceName.Buffer = NULL;
    dosSymLink.Buffer = NULL;

#if SUPPORT_DISK_NUMBERS

    if ( !AccessCheckOnly ) {
    
        //
        // Allocate a disk number.
        //
    
        KeEnterCriticalRegion();
        ExAcquireFastMutex( &BusExtension->Mutex );
    
        diskNumber = RtlFindClearBitsAndSet( &BusExtension->DiskNumbersBitmap, 1, 0 );
    
        ExReleaseFastMutex( &BusExtension->Mutex );
        KeLeaveCriticalRegion();
    
        if ( diskNumber == 0xffffffff ) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;
        }
    
        //
        // Convert the zero-based bit number to a one-based disk number.
        //
    
        diskNumber++;
    }

#endif // SUPPORT_DISK_NUMBERS

    //
    // Initialize based on the disk type (file-backed or in-memory).
    //

    DBGPRINT( DBG_IOCTL, DBG_INFO,
                ("RamdiskCreateDiskDevice: Creating disk with length 0x%08x\n",
                CreateInput->DiskLength) );

    sectionObject = NULL;
    basePage = 0;
    baseAddress = NULL;

    if ( RAMDISK_IS_FILE_BACKED(CreateInput->DiskType) ) {

        //
        // This is a file-backed RAM disk. Open the backing file. Note that
        // we do NOT create the file here if it doesn't exist. It is up to
        // the caller to handle that.
        //

        RtlInitUnicodeString( &string, CreateInput->FileName );
        InitializeObjectAttributes( &obja, &string, OBJ_CASE_INSENSITIVE, NULL, NULL );

        status = IoCreateFile(
                    &fileHandle,
                    SYNCHRONIZE | FILE_READ_DATA | FILE_READ_ATTRIBUTES |
                        (CreateInput->Options.Readonly ? 0 : FILE_WRITE_DATA),
                    &obja,
                    &iosb,
                    NULL,
                    0,
                    FILE_SHARE_READ,
                    FILE_OPEN,
                    0,
                    NULL,
                    0,
                    CreateFileTypeNone,
                    NULL,
                    (AccessCheckOnly ? IO_FORCE_ACCESS_CHECK | IO_NO_PARAMETER_CHECKING : 0)
                    );

        if ( !NT_SUCCESS(status) ) {

            DBGPRINT( DBG_IOCTL, DBG_ERROR,
                        ("RamdiskCreateDiskDevice: Can't open target file %ws: %x\n",
                        CreateInput->FileName, status) );

            goto exit;
        }

        if ( AccessCheckOnly ) {

            goto exit;
        }

        //
        // Get the size of the file.
        //

        status = ZwQueryInformationFile(
                    fileHandle,
                    &iosb,
                    &fileInfo,
                    sizeof(fileInfo),
                    FileStandardInformation
                    );

        if ( !NT_SUCCESS(status) ) {

            DBGPRINT( DBG_IOCTL, DBG_ERROR,
                        ("RamdiskCreateDiskDevice: Can't query info for file %ws: %x\n",
                        CreateInput->FileName, status) );

            goto exit;
        }

        //
        // Verify that the file is long enough for the specified DiskOffset
        // and DiskLength.
        //

        DBGPRINT( DBG_IOCTL, DBG_INFO, ("RamdiskCreateDiskDevice: file size = %I64x\n",
                                            fileInfo.EndOfFile.QuadPart) );

        if ( (CreateInput->DiskOffset + CreateInput->DiskLength) >
                (ULONGLONG)fileInfo.EndOfFile.QuadPart ) {

            DBGPRINT( DBG_IOCTL, DBG_ERROR,
                        ("RamdiskCreateDiskDevice: specified offset and length too big for file:"
                         " 0x%x + 0x%I64x > 0x%I64x\n",
                         CreateInput->DiskOffset, CreateInput->DiskLength,
                         fileInfo.EndOfFile.QuadPart) );

            status = STATUS_INVALID_PARAMETER;
            goto exit;
        }

        //
        // Create a section for the file. Close the file handle.
        //

        status = ZwCreateSection(
                    &sectionHandle,
                    SECTION_ALL_ACCESS,
                    NULL,
                    0,
                    (CreateInput->Options.Readonly ? PAGE_READONLY : PAGE_READWRITE),
                    SEC_COMMIT,
                    fileHandle
                    );

        if ( !NT_SUCCESS(status) ) {

            DBGPRINT( DBG_IOCTL, DBG_ERROR,
                        ("RamdiskCreateDiskDevice: Can't create section for %ws: %x\n",
                        CreateInput->FileName, status) );

            goto exit;
        }

        NtClose( fileHandle );
        fileHandle = NULL;

        //
        // Get a referenced pointer to the section object. Close the section.
        //

        status = ObReferenceObjectByHandle(
                    sectionHandle,
                    SECTION_ALL_ACCESS,
                    *(POBJECT_TYPE *)MmSectionObjectType,
                    KernelMode,
                    &sectionObject,
                    NULL
                    );

        if ( !NT_SUCCESS(status) ) {

            DBGPRINT( DBG_IOCTL, DBG_ERROR,
                        ("RamdiskCreateDiskDevice: Can't reference section for %ws: %x\n",
                        CreateInput->FileName, status) );

            goto exit;
        }

        NtClose( sectionHandle );
        sectionHandle = NULL;
            
        //
        // Allocate space for view descriptors. First, get the number of views
        // to use and the size of each view.
        //

        if ( CreateInput->ViewCount == 0  ) {
            CreateInput->ViewCount = DefaultViewCount;
        } else if ( CreateInput->ViewCount < MinimumViewCount ) {
            CreateInput->ViewCount = MinimumViewCount;
        } else if ( CreateInput->ViewCount > MaximumViewCount ) {
            CreateInput->ViewCount = MaximumViewCount;
        }
            
        if ( CreateInput->ViewLength == 0 ) {
            CreateInput->ViewLength = DefaultViewLength;
        } else if ( CreateInput->ViewLength < MinimumViewLength ) {
            CreateInput->ViewLength = MinimumViewLength;
        } else if ( CreateInput->ViewLength > MaximumViewLength ) {
            CreateInput->ViewLength = MaximumViewLength;
        }

        //
        // Ensure that the total view length is not greater than the maximum
        // per-disk view length. If necessary, decrease the view count until
        // the total view length is low enough. If the view count reaches the
        // configured minimum, reduce the length of each view until the total
        // view length is low enough.
        //
        // It is possible for the administrator to configure the minimum view
        // count, minimum view length, and maximum per-disk view length such
        // that it's impossible for the minimum total view length to be less
        // than the maximum per-disk view length. (That is, the miinimum view
        // count and minimum view length are configured to high relative to
        // the configured maximum per-disk view length.) If this occurs, we
        // create the disk with the compile-time defaults instead.
        //
        
        while ( ((ULONGLONG)CreateInput->ViewCount * CreateInput->ViewLength) >
                                                        MaximumPerDiskViewLength ) {

            //
            // The total view length is too big. If possible, cut the number of
            // views in half.
            //

            if ( CreateInput->ViewCount > MinimumViewCount ) {

                //
                // The view count isn't at the minimum. Cut in half, but don't
                // go below the minimum.
                //

                CreateInput->ViewCount /= 2;
                if ( CreateInput->ViewCount < MinimumViewCount ) {
                    CreateInput->ViewCount = MinimumViewCount;
                }

            } else {

                //
                // The view count is already at the minimum. If possible,
                // cut the view length in half.
                //

                if ( CreateInput->ViewLength > MinimumViewLength ) {
    
                    //
                    // The view length isn't at the minimum. Cut in half, but
                    // don't go below the minimum.
                    //
    
                    CreateInput->ViewLength /= 2;
                    if ( CreateInput->ViewLength < MinimumViewLength ) {
                        CreateInput->ViewLength = MinimumViewLength;
                    }

                } else {
                
                    //
                    // At this point, the view count and the view length are
                    // both at the minimum allowed values, but the total view
                    // length is beyond the maximum per-disk value. Use the
                    // compile-time default values instead. Note that this will
                    // result in a total view length that is equal to the
                    // minimum allowed maximum per-disk view length, at least
                    // given the compile-time values as of this writing.
                    //

                    CreateInput->ViewCount = DEFAULT_DEFAULT_VIEW_COUNT;
                    CreateInput->ViewLength = DEFAULT_DEFAULT_VIEW_LENGTH;
                    ASSERT( ((ULONGLONG)CreateInput->ViewCount * CreateInput->ViewLength) <=
                                                        MaximumPerDiskViewLength );

                    break;
                }
            }
        }
            
        viewDescriptors = ALLOCATE_POOL(
                            PagedPool,
                            CreateInput->ViewCount * sizeof(VIEW),
                            TRUE );

        if ( viewDescriptors == NULL ) {

            DBGPRINT( DBG_IOCTL, DBG_ERROR,
                        ("%s", "RamdiskCreateDiskDevice: Can't allocate pool for view descriptors\n") );

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;
        }

        RtlZeroMemory( viewDescriptors, CreateInput->ViewCount * sizeof(VIEW) );

    } else if ( CreateInput->DiskType == RAMDISK_TYPE_BOOT_DISK ) {

        //
        // For a boot disk, the input parameter buffer tells us where the
        // image is in physical memory, and how big the image is.
        //

        basePage = CreateInput->BasePage;

        if ( basePage == 0 ) {
    
            DBGPRINT( DBG_IOCTL, DBG_ERROR,
                        ("%s", "RamdiskCreateDiskDevice: Base page for boot disk is 0?!?\n") );

            ASSERT( FALSE );
    
            status = STATUS_INVALID_PARAMETER;
            goto exit;
        }

        //
        // Force options to the appropriate values for a boot disk.
        //

        CreateInput->Options.Fixed = TRUE;
        CreateInput->Options.Readonly = FALSE;
        CreateInput->Options.NoDriveLetter = FALSE;
        CreateInput->Options.NoDosDevice = FALSE;
        CreateInput->Options.Hidden = FALSE;

    } else if ( CreateInput->DiskType == RAMDISK_TYPE_VIRTUAL_FLOPPY ) {

        //
        // For a virtual floppy, the input parameter buffer tells us where the
        // image is in virtual memory, and how big the image is.
        //
        
        baseAddress = CreateInput->BaseAddress;

        ASSERT( baseAddress != NULL );

        //
        // Force options to the appropriate values for a virtual floppy.
        //

        CreateInput->Options.Fixed = TRUE;
        CreateInput->Options.Readonly = FALSE;
        CreateInput->Options.NoDriveLetter = TRUE;
        CreateInput->Options.NoDosDevice = FALSE;
        CreateInput->Options.Hidden = FALSE;

    } else {

        DBGPRINT( DBG_IOCTL, DBG_ERROR,
                    ("RamdiskCreateDiskDevice: Bad disk type %d\n", CreateInput->DiskType) );

        status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    if ( AccessCheckOnly ) {

        status = STATUS_SUCCESS;
        goto exit;
    }

    ASSERT( (basePage != 0) || (sectionObject != NULL) || (baseAddress != NULL) );

    //
    // Create a name for the disk, based on the disk GUID. For all disk types
    // except VIRTUAL_FLOPPY, the name is of the form \Device\Ramdisk{guid}.
    // For VIRTUAL_FLOPPY, the name is of the form \Device\RamdiskN, when N is
    // specified by the Data1 field of the GUID.
    //

    if ( CreateInput->DiskType != RAMDISK_TYPE_VIRTUAL_FLOPPY ) {
    
        status = RtlStringFromGUID( &CreateInput->DiskGuid, &guidString );

    } else {

        // This variable is here to keep PREfast quiet (PREfast warning 209).
        size_t size = sizeof(buffer);

        result = StringCbPrintfW( buffer, size, L"%u", CreateInput->DiskGuid.Data1 );
        ASSERT( result == S_OK );

        status = RtlCreateUnicodeString( &guidString, buffer );
    }

    if ( !NT_SUCCESS(status) || (guidString.Buffer == NULL) ) {

        DBGPRINT( DBG_IOCTL, DBG_ERROR,
                    ("%s", "RamdiskCreateDiskDevice: can't allocate pool for pretty GUID\n") );

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    i = sizeof(RAMDISK_DEVICENAME) + guidString.Length;

    realDeviceName.Buffer = ALLOCATE_POOL( NonPagedPool, i, TRUE );

    if ( (realDeviceName.Buffer == NULL) ) {

        DBGPRINT( DBG_IOCTL, DBG_ERROR,
                    ("%s", "RamdiskCreateDiskDevice: can't allocate pool for device name\n") );

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    realDeviceName.MaximumLength = (USHORT)i;
    realDeviceName.Length = realDeviceName.MaximumLength - sizeof(WCHAR);

    result = StringCbCopyW( realDeviceName.Buffer, i, RAMDISK_DEVICENAME );
    ASSERT( result == S_OK );
    result = StringCbCatW( realDeviceName.Buffer, i, guidString.Buffer );
    ASSERT( result == S_OK );
    ASSERT( (wcslen(realDeviceName.Buffer) * sizeof(WCHAR)) == realDeviceName.Length );

    DBGPRINT( DBG_IOCTL, DBG_INFO,
                ("RamdiskCreateDiskDevice: Device name is %wZ\n", &realDeviceName) );

    //
    // Create the RAM disk device.
    //
    // ISSUE: Apply an ACL to the disk device object. (Or does the next issue obviate this?)
    // ISSUE: Should we use an autogenerated name for the PDO? This would mean
    //          that we'd have to return the device name as the IOCTL output,
    //          not just the disk number.
    //

    deviceExtensionSize = sizeof(DISK_EXTENSION);
    if ( RAMDISK_IS_FILE_BACKED(CreateInput->DiskType) ) {
        deviceExtensionSize += wcslen( CreateInput->FileName ) * sizeof(WCHAR);
    }

    status = IoCreateDevice(
                BusExtension->Fdo->DriverObject,
                deviceExtensionSize,
                &realDeviceName,
                FILE_DEVICE_DISK,
                CreateInput->Options.Fixed ? 0 : FILE_REMOVABLE_MEDIA, // | FILE_VIRTUAL_VOLUME,
                FALSE,
                &newDeviceObject
                );

    if ( !NT_SUCCESS(status) ) {

        DBGPRINT( DBG_IOCTL, DBG_ERROR,
                    ("RamdiskCreateDiskDevice: IoCreateDevice failed: %x\n", status) );

        goto exit;
    }

    diskExtension = newDeviceObject->DeviceExtension;

    //
    // Create a DosDevices link for the device.
    //

    if ( !CreateInput->Options.NoDosDevice ) {
    
        //
        // Create a DosDevices symbolic link. Ignore errors.
        //
    
        i = sizeof(RAMDISK_FULL_DOSNAME) + guidString.Length;

        dosSymLink.MaximumLength = (USHORT)i;
        dosSymLink.Length = dosSymLink.MaximumLength - sizeof(WCHAR);

        dosSymLink.Buffer = ALLOCATE_POOL( NonPagedPool, i, TRUE );

        if ( dosSymLink.Buffer == NULL ) {

            DBGPRINT( DBG_IOCTL, DBG_ERROR,
                        ("%s", "RamdiskCreateDiskDevice: can't allocate pool for DosDevices name\n") );

            CreateInput->Options.NoDosDevice = TRUE;

        } else {
        
            result = StringCbCopyW( dosSymLink.Buffer, i, RAMDISK_FULL_DOSNAME );
            ASSERT( result == S_OK );
            result = StringCbCatW( dosSymLink.Buffer, i, guidString.Buffer );
            ASSERT( result == S_OK );
            ASSERT( (wcslen(dosSymLink.Buffer) * sizeof(WCHAR)) == dosSymLink.Length );

            status = IoCreateSymbolicLink( &dosSymLink, &realDeviceName );

            if ( !NT_SUCCESS(status) ) {
    
                DBGPRINT( DBG_IOCTL, DBG_ERROR,
                            ("RamdiskCreateDiskDevice: IoCreateSymbolicLink failed: %x\n", status) );
    
                CreateInput->Options.NoDosDevice = TRUE;

                FREE_POOL( dosSymLink.Buffer, TRUE );
                dosSymLink.Buffer = NULL;
            }
        }

        //
        // If creating the boot disk, create a drive letter.
        //

        if ( CreateInput->DiskType == RAMDISK_TYPE_BOOT_DISK ) {

            // This variable is here to keep PREfast quiet (PREfast warning 209).
            size_t size = sizeof(buffer);

            result = StringCbPrintfW(
                        buffer,
                        size,
                        L"\\DosDevices\\%wc:",
                        CreateInput->DriveLetter
                        );
            ASSERT( result == S_OK );
            RtlInitUnicodeString( &string, buffer );
            IoDeleteSymbolicLink( &string );
            IoCreateSymbolicLink( &string, &realDeviceName );

            diskExtension->DriveLetter = CreateInput->DriveLetter;
        }
    }
                
    //
    // Initialize device object and extension.
    //

    //
    // Our device does direct I/O, is XIP-capable, and is power pageable.
    // We require word alignment for I/O.
    //

    newDeviceObject->Flags |= DO_DIRECT_IO | DO_XIP | DO_POWER_PAGABLE;
    newDeviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;

    //
    // Return a pointer to the device extension to the caller.
    //

    *DiskExtension = diskExtension;

    //
    // Set the device type and state in the device extension. Initialize the
    // fast mutex and the remove lock. Save the device name string.
    //

    diskExtension->DeviceType = RamdiskDeviceTypeDiskPdo;
    diskExtension->DeviceState = RamdiskDeviceStateStopped;

    ExInitializeFastMutex( &diskExtension->Mutex );
    IoInitializeRemoveLock( &diskExtension->RemoveLock, 'dmaR', 1, 0 );

    diskExtension->DeviceName = realDeviceName;
    realDeviceName.Buffer = NULL;
    diskExtension->DosSymLink = dosSymLink;
    dosSymLink.Buffer = NULL;

    diskExtension->DiskGuid = CreateInput->DiskGuid;
    diskExtension->DiskGuidFormatted = guidString;
    guidString.Buffer = NULL;

#if SUPPORT_DISK_NUMBERS

    //
    // Save the disk number.
    //

    diskExtension->DiskNumber = diskNumber;
    diskNumber = 0xffffffff;

#endif // SUPPORT_DISK_NUMBERS

    //
    // Save object pointers. The PDO for this extension is the device
    // extension is the device object that we just created. The FDO and
    // the lower device object are the bus FDO.
    //
    
    diskExtension->Pdo = newDeviceObject;
    diskExtension->Fdo = RamdiskBusFdo;
    diskExtension->LowerDeviceObject = RamdiskBusFdo;

    //
    // ISSUE: What about BiosParameters?
    //
    //bios = &diskExtension->BiosParameters;
    //
    //diskExtension->BootParameters = xipbootparameters;
    //status = RamdDispatch(XIPCMD_GETBIOSPARAMETERS, bios, sizeof(*bios));


    //
    // Save pointers to the disk image.
    //

    diskExtension->BasePage = basePage;
    diskExtension->SectionObject = sectionObject;
    sectionObject = NULL;
    diskExtension->BaseAddress = baseAddress;
	
    if ( RAMDISK_IS_FILE_BACKED(CreateInput->DiskType) ) {

        result = StringCbCopyW(
                    diskExtension->FileName,
                    deviceExtensionSize,
                    CreateInput->FileName
                    );
        ASSERT( result == S_OK );
    }

    //
    // Save the disk type (disk or volume) and disk options.
    //

    diskExtension->DiskType = CreateInput->DiskType;
    diskExtension->Options = CreateInput->Options;

    //
    // For a file-backed disk image, set up the view descriptors.
    //
    // ISSUE: Need to consider whether to permanently map the first few pages
    // of the image. The first sector on the disk is accessed frequently, so
    // there is some value in keeping it mapped. But it might not be worth it
    // to waste a view descriptor on this. And the LRU nature of the view
    // replacement algorithm will keep the first sector mapped when necessary.
    //

    if ( viewDescriptors != NULL ) {

        PVIEW view;

        //
        // Initialize windowing fields in the disk extension.
        //

        diskExtension->ViewCount = CreateInput->ViewCount;
        diskExtension->ViewLength = CreateInput->ViewLength;
        diskExtension->ViewDescriptors = viewDescriptors;
        KeInitializeSemaphore( &diskExtension->ViewSemaphore, 0, MAXLONG );
        diskExtension->ViewWaiterCount = 0;

        //
        // Initialize the view lists, then insert in each view descriptor
        // in order. The result is a list of descriptors, each unmapped
        // (offset and length both 0).
        //

        InitializeListHead( &diskExtension->ViewsByOffset );
        InitializeListHead( &diskExtension->ViewsByMru );

        view = viewDescriptors;

        for ( i = 0; i < diskExtension->ViewCount; i++ ) {

            InsertTailList( &diskExtension->ViewsByOffset, &view->ByOffsetListEntry );
            InsertTailList( &diskExtension->ViewsByMru, &view->ByMruListEntry );

            view++;
        }

        viewDescriptors = NULL;
    }


    diskExtension->DiskLength = CreateInput->DiskLength;
    diskExtension->DiskOffset = CreateInput->DiskOffset;
    diskExtension->FileRelativeEndOfDisk = diskExtension->DiskOffset + diskExtension->DiskLength;

    //
    // Set the disk geometry. The basic geometry is constant for new disks.
    // For RAMDISK_TYPE_BOOT_DISK type volume geometry can be obtained from the partition boot sector.
    //
    
    if ( RAMDISK_TYPE_BOOT_DISK  != CreateInput->DiskType ) {
    	
		diskExtension->BytesPerSector = 0x200;
		diskExtension->SectorsPerTrack = 0x80;
		diskExtension->TracksPerCylinder = 0x10;
    }
    else {

    	//
    	//	2002/04/19-SaadSyed (Saad Syed)
    	//	Added generic geometry support to support SDI files
    	//
    	PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK BootSector = NULL;
	    ULONG mappedLength;
       BIOS_PARAMETER_BLOCK Bpb;	    
    
		//
		//	Map boot sector of boot ramdisk
		//

	    BootSector = ( PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK ) RamdiskMapPages( diskExtension, 0, PAGE_SIZE, &mappedLength );
		
	    if ( NULL != BootSector )  	{

	    	ASSERT( mappedLength == PAGE_SIZE );

            UnpackBios( &Bpb, &BootSector->Bpb );
	    	
	    	//
	    	// Extract geometry from boot sector bios parameter block
	    	//


			diskExtension->BytesPerSector = Bpb.BytesPerSector;
	    	diskExtension->SectorsPerTrack = Bpb.SectorsPerTrack;
	    	diskExtension->TracksPerCylinder = Bpb.Heads;

	      	RamdiskUnmapPages(diskExtension, (PUCHAR) BootSector, 0, mappedLength);
	      	
		   	BootSector = NULL;
	    }
	    else  {
	    	
	    	status = STATUS_INSUFFICIENT_RESOURCES;
	    	goto exit;

	    }
    }

    diskExtension->BytesPerCylinder  = diskExtension->BytesPerSector *
                                        diskExtension->SectorsPerTrack *
                                        diskExtension->TracksPerCylinder;

    diskExtension->NumberOfCylinders =   	
        (ULONG)(CreateInput->DiskLength / diskExtension->BytesPerCylinder);

	//
	//	A partition/volume does not often map to a geometry completely, the file system driver limits the
	//	volume to a capacity determined by the NumberOfSectors (in the Boot Sector) * BytesPerSector (in BPB).
	//	The FS driver uses the this geometry to determine if the NumberOfSectors is less than or
	//	equal to the total number of sectors reported by the geometry, otherwise it fails to mount the volume.
	//	Here we check if the length of disk as obtained from the ramdisk image is less than or equal to the length 
	//	obtained by the geometry. We increment the number of cylinders if this check fails. This keeps the FS driver 
	//	happy. A simple ceil operation would yield the same results.
	//

    if ( ( diskExtension->BytesPerCylinder *
           diskExtension->NumberOfCylinders ) <  CreateInput->DiskLength) {
           
		diskExtension->NumberOfCylinders++;
			
    }
           

    //
    // Link the new disk into the bus FDO's list of disks.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutex( &BusExtension->Mutex );

    InsertTailList( &BusExtension->DiskPdoList, &diskExtension->DiskPdoListEntry );

    ExReleaseFastMutex( &BusExtension->Mutex );
    KeLeaveCriticalRegion();

    //
    // Indicate that we're done initializing the device.
    //

    newDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    status = STATUS_SUCCESS;

    goto exit_exit;

exit:

    if ( dosSymLink.Buffer != NULL ) {
        FREE_POOL( dosSymLink.Buffer, TRUE );
        dosSymLink.Buffer = NULL;
    }

    if ( realDeviceName.Buffer != NULL ) {
        FREE_POOL( realDeviceName.Buffer, TRUE );
        realDeviceName.Buffer = NULL;
    }

    if ( guidString.Buffer != NULL ) {
        FREE_POOL( guidString.Buffer, FALSE );
        guidString.Buffer = NULL;
    }

    if ( viewDescriptors != NULL ) {
        FREE_POOL( viewDescriptors, TRUE );
        viewDescriptors = NULL;
    }

    if ( sectionObject != NULL ) {
        ObDereferenceObject( sectionObject );
        sectionObject = NULL;
    }

    if ( sectionHandle != NULL ) {
        NtClose( sectionHandle );
        sectionHandle = NULL;
    }

    if ( fileHandle != NULL ) {
        NtClose( fileHandle );
        fileHandle = NULL;
    }

#if SUPPORT_DISK_NUMBERS

    if ( diskNumber != 0xffffffff ) {

        KeEnterCriticalRegion();
        ExAcquireFastMutex( &BusExtension->Mutex );

        RtlClearBit( &BusExtension->DiskNumbersBitmap, diskNumber - 1 );

        ExReleaseFastMutex( &BusExtension->Mutex );
        KeLeaveCriticalRegion();

        diskNumber = 0xffffffff;
    }

#endif // SUPPORT_DISK_NUMBERS

exit_exit:

    ASSERT( fileHandle == NULL );
    ASSERT( sectionHandle == NULL );
    ASSERT( sectionObject == NULL );
    ASSERT( viewDescriptors == NULL );
    ASSERT( guidString.Buffer == NULL );
    ASSERT( realDeviceName.Buffer == NULL );
    ASSERT( dosSymLink.Buffer == NULL );

    return status;

} // RamdiskCreateDiskDevice

NTSTATUS
RamdiskGetDriveLayout (
    PIRP Irp,
    PDISK_EXTENSION DiskExtension
    )

/*++

Routine Description:

    This routine is called to handle an IOCTL_GET_DRIVE_LAYOUT IRP. It is
    called in thread context iff the disk is file-backed.

Arguments:

    Irp - a pointer to the I/O Request Packet for this request

    DiskExtension - a pointer to the device extension for the target disk

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    PIO_STACK_LOCATION irpSp;
    PDRIVE_LAYOUT_INFORMATION driveLayout;
    PPARTITION_INFORMATION partInfo;
    PPARTITION_DESCRIPTOR partitionTableEntry;
    PUCHAR va;
    ULONG mappedLength;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(DRIVE_LAYOUT_INFORMATION) ) {

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Map the first page of the image.
    //

    va = RamdiskMapPages( DiskExtension, 0, PAGE_SIZE, &mappedLength );

    if ( va == NULL ) {

        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        Irp->IoStatus.Information = 0;

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT( mappedLength == PAGE_SIZE );

    //
    // Get a pointer to the output buffer. Fill in the header.
    //

    driveLayout = (PDRIVE_LAYOUT_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

    //
    // ISSUE: Is this right for an emulated disk? Or is this routine never
    // called for emulated disks?
    //

    driveLayout->PartitionCount = 1;
    driveLayout->Signature = 0;

    partInfo = driveLayout->PartitionEntry;

    //
    // Point to the partition table in the disk image.
    //

    partitionTableEntry = (PPARTITION_DESCRIPTOR)&((PUSHORT)va)[PARTITION_TABLE_OFFSET];

    //
    // Return information about the partition.
    //

    partInfo->StartingOffset.QuadPart = DiskExtension->BytesPerSector;

    partInfo->PartitionLength.QuadPart = 
                DiskExtension->NumberOfCylinders *
                DiskExtension->TracksPerCylinder *
                DiskExtension->SectorsPerTrack *
                DiskExtension->BytesPerSector;

    // ISSUE: Currently, HiddenSectors is always 0. Is this right?
    partInfo->HiddenSectors =  DiskExtension->HiddenSectors;

    partInfo->PartitionNumber = 0;
    partInfo->PartitionType = partitionTableEntry->PartitionType;
    partInfo->BootIndicator = (BOOLEAN)(DiskExtension->DiskType == RAMDISK_TYPE_BOOT_DISK);
    partInfo->RecognizedPartition = IsRecognizedPartition(partInfo->PartitionType);
    partInfo->RewritePartition = FALSE;

    //
    // Unmap the mapped page.
    //

    RamdiskUnmapPages( DiskExtension, va, 0, mappedLength );

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = sizeof(DRIVE_LAYOUT_INFORMATION);

    return STATUS_SUCCESS;

} // RamdiskGetDriveLayout

NTSTATUS
RamdiskGetPartitionInfo (
    PIRP Irp,
    PDISK_EXTENSION DiskExtension
    )

/*++

Routine Description:

    This routine is called to handle an IOCTL_GET_PARTITION_INFO IRP. It is
    called in thread context iff the disk is file-backed.

Arguments:

    Irp - a pointer to the I/O Request Packet for this request

    DiskExtension - a pointer to the device extension for the target disk

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    PIO_STACK_LOCATION irpSp;
    PPARTITION_INFORMATION partInfo;
    PPARTITION_DESCRIPTOR partitionTableEntry;
    PUCHAR va;
    ULONG mappedLength;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PARTITION_INFORMATION) ) {

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Map the first page of the image.
    //

    va = RamdiskMapPages( DiskExtension, 0, PAGE_SIZE, &mappedLength );

    if ( va == NULL ) {

        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        Irp->IoStatus.Information = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT( mappedLength == PAGE_SIZE );

    //
    // Get a pointer to the output buffer.
    //

    partInfo = (PPARTITION_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

    //
    // Point to the partition table in the disk image.
    //

    partitionTableEntry = (PPARTITION_DESCRIPTOR)&((PUSHORT)va)[PARTITION_TABLE_OFFSET];

    //
    // Return information about the partition.
    //

    partInfo->StartingOffset.QuadPart = DiskExtension->BytesPerSector;

    partInfo->PartitionLength.QuadPart = 
                DiskExtension->NumberOfCylinders *
                DiskExtension->TracksPerCylinder *
                DiskExtension->SectorsPerTrack *
                DiskExtension->BytesPerSector;

    // ISSUE: Currently, HiddenSectors is always 0. Is this right?
    partInfo->HiddenSectors =  DiskExtension->HiddenSectors;

    partInfo->PartitionNumber = 0;
    partInfo->PartitionType = partitionTableEntry->PartitionType;
    partInfo->BootIndicator = (BOOLEAN)(DiskExtension->DiskType == RAMDISK_TYPE_BOOT_DISK);
    partInfo->RecognizedPartition = IsRecognizedPartition(partInfo->PartitionType);
    partInfo->RewritePartition = FALSE;

    //
    // Unmap the mapped page.
    //

    RamdiskUnmapPages( DiskExtension, va, 0, mappedLength );

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = sizeof(PARTITION_INFORMATION);

    return STATUS_SUCCESS;

} // RamdiskGetPartitionInfo


NTSTATUS
RamdiskSetPartitionInfo (
    PIRP Irp,
    PDISK_EXTENSION DiskExtension
    )

/*++

Routine Description:

    This routine is called to handle an IOCTL_SET_PARTITION_INFO IRP. It is
    called in thread context iff the disk is file-backed.

Arguments:

    Irp - a pointer to the I/O Request Packet for this request

    DiskExtension - a pointer to the device extension for the target disk

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    PIO_STACK_LOCATION irpSp;
    PSET_PARTITION_INFORMATION partInfo;
    PPARTITION_DESCRIPTOR partitionTableEntry;
    PUCHAR va;
    ULONG mappedLength;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    if ( irpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(SET_PARTITION_INFORMATION) ) {

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Map the first page of the image.
    //

    va = RamdiskMapPages( DiskExtension, 0, PAGE_SIZE, &mappedLength );

    if ( va == NULL ) {

        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        Irp->IoStatus.Information = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT( mappedLength == PAGE_SIZE );

    //
    // Get a pointer to the output buffer.
    //

    partInfo = (PSET_PARTITION_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

    //
    // Point to the partition table in the disk image.
    //

    partitionTableEntry = (PPARTITION_DESCRIPTOR)&((PUSHORT)va)[PARTITION_TABLE_OFFSET];

    //
    // Write the new partition type.
    //

    partitionTableEntry->PartitionType = partInfo->PartitionType;

    //
    // Unmap the mapped page.
    //

    RamdiskUnmapPages( DiskExtension, va, 0, mappedLength );

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    return STATUS_SUCCESS;

} // RamdiskGetPartitionInfo

NTSTATUS
RamdiskQueryProperty (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles a property query request.  It builds the descriptor
    on its own if possible, otherwise it forwards the request down to lower
    level drivers.

    Since this routine may forward the request downwards the caller should
    not complete the IRP.

    This routine must be called with the remove lock held. The lock is
    released when this routine returns.

Arguments:

    DeviceObject - a pointer to the device object being queried

    Irp - a pointer to the IRP for the query

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PSTORAGE_PROPERTY_QUERY query;
    ULONG queryLength;
    PSTORAGE_DEVICE_DESCRIPTOR storageDeviceDescriptor;
    PSTORAGE_ADAPTER_DESCRIPTOR storageAdapterDescriptor;
    ULONG offset;
    ULONG length;
    PUCHAR p;

    PCOMMON_EXTENSION commonExtension;
    PBUS_EXTENSION busExtension;
    PDISK_EXTENSION diskExtension;

    STORAGE_DEVICE_DESCRIPTOR sdd;
    STORAGE_ADAPTER_DESCRIPTOR sad;

    PAGED_CODE();

    //
    // Assume success.
    //

    status = STATUS_SUCCESS;

    //
    // Get parameters from the IRP.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    query = (PSTORAGE_PROPERTY_QUERY)Irp->AssociatedIrp.SystemBuffer;
    queryLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Get the device extension pointer.
    //

    commonExtension = DeviceObject->DeviceExtension;
    busExtension = DeviceObject->DeviceExtension;
    diskExtension = DeviceObject->DeviceExtension;

    //
    // We don't support mask queries.
    //

    if ( query->QueryType >= PropertyMaskQuery ) {

        status = STATUS_INVALID_PARAMETER_1;
        Irp->IoStatus.Information = 0;

    } else {

        //
        // Dispatch based on the property ID.
        //

        switch ( query->PropertyId ) {
        
        case StorageDeviceProperty: 
        
            //
            // Make sure this is a target device.
            //
    
            if ( commonExtension->DeviceType != RamdiskDeviceTypeDiskPdo ) {

                status = STATUS_INVALID_DEVICE_REQUEST;
                Irp->IoStatus.Information = 0;

                break;
            }

            //
            // If it's a just query for whether the property exists, the
            // answer is yes.
            //

            if ( query->QueryType == PropertyExistsQuery ) {

                break;
            }

            //
            // Build a full return buffer. The output buffer might not be
            // big enough to hold the whole thing.
            //

            RtlZeroMemory( &sdd, sizeof(sdd) );

            sdd.Version = sizeof(sdd);
            sdd.DeviceType = DIRECT_ACCESS_DEVICE;
            sdd.RemovableMedia = (diskExtension->Options.Fixed ? FALSE : TRUE);
            sdd.CommandQueueing = FALSE;
            sdd.BusType = BusTypeUnknown;

            length = sizeof(sdd) +
                        ((strlen(VER_COMPANYNAME_STR) + 1 +
                          strlen(RAMDISK_DISK_DEVICE_TEXT_ANSI) + 1) * sizeof(CHAR));
            sdd.Size = length;

            //
            // Zero the output buffer.
            //

            storageDeviceDescriptor = Irp->AssociatedIrp.SystemBuffer;
            RtlZeroMemory( storageDeviceDescriptor, queryLength );

            //
            // Copy the base part of the return descriptor to the output
            // buffer.
            //

            RtlCopyMemory(
                storageDeviceDescriptor,
                &sdd,
                min( queryLength, sizeof(sdd) )
                );

            //
            // If there's no room for the rest of the data, we're done.
            //

            if ( queryLength <= sizeof(sdd) ) {

                Irp->IoStatus.Information = queryLength;

                break;
            }

            //
            // Copy as much of the rest of the data as will fit.
            //

            offset = sizeof(sdd);
            p = (PUCHAR)storageDeviceDescriptor + offset;

            length = (strlen(VER_COMPANYNAME_STR) + 1) * sizeof(CHAR);

            if ( (offset + length) > queryLength ) {

                Irp->IoStatus.Information = offset;

                break;
            }

            storageDeviceDescriptor->VendorIdOffset = offset;
            memcpy( p, VER_COMPANYNAME_STR, length );
            offset += length;
            p += length;

            length = (strlen(RAMDISK_DISK_DEVICE_TEXT_ANSI) + 1) * sizeof(CHAR);

            if ( (offset + length) > queryLength ) {

                Irp->IoStatus.Information = offset;

                break;
            }

            storageDeviceDescriptor->ProductIdOffset = offset;
            memcpy( p, RAMDISK_DISK_DEVICE_TEXT_ANSI, length );
            offset += length;
            p += length;

            storageDeviceDescriptor->ProductRevisionOffset = 0;
            storageDeviceDescriptor->SerialNumberOffset = 0;

            storageDeviceDescriptor->Size = offset;

            Irp->IoStatus.Information = offset;

            break;
    
        case StorageAdapterProperty:
    
            //
            // If this is a target device then forward it down to the
            // underlying device object.  This lets filters do their magic.
            //
    
            if ( commonExtension->DeviceType == RamdiskDeviceTypeDiskPdo ) {

                //
                // Call the lower device.
                //
    
                IoReleaseRemoveLock( &commonExtension->RemoveLock, Irp );

                IoSkipCurrentIrpStackLocation( Irp );

                return IoCallDriver( commonExtension->LowerDeviceObject, Irp );
            }
    
            //
            // If it's a just query for whether the property exists, the
            // answer is yes.
            //

            if ( query->QueryType == PropertyExistsQuery ) {

                break;
            } 
            
            //
            // Build a full return buffer. The output buffer might not be
            // big enough to hold the whole thing.
            //

            RtlZeroMemory( &sad, sizeof(sad) );

            sad.Version = sizeof(sad);
            sad.Size = sizeof(sad);
            sad.MaximumTransferLength = 0xFFFFFFFF;
            sad.MaximumPhysicalPages = 0xFFFFFFFF;
            sad.AlignmentMask = 1;
            sad.AdapterUsesPio = FALSE;
            sad.AdapterScansDown = FALSE;
            sad.CommandQueueing = FALSE;
            sad.AcceleratedTransfer = TRUE;
            sad.BusType = BusTypeUnknown;
            sad.BusMajorVersion = VER_PRODUCTMAJORVERSION;
            sad.BusMinorVersion = VER_PRODUCTMINORVERSION;

            //
            // Zero the output buffer.
            //

            storageAdapterDescriptor = Irp->AssociatedIrp.SystemBuffer;
            RtlZeroMemory( storageAdapterDescriptor, queryLength );

            //
            // Copy the base part of the return descriptor to the output
            // buffer.
            //

            RtlCopyMemory(
                storageAdapterDescriptor,
                &sad,
                min( queryLength, sizeof(sad) )
                );
            
            Irp->IoStatus.Information = min( queryLength, sizeof(sad) );

            break;
    
        case StorageDeviceIdProperty: 

            //
            // Make sure this is a target device.
            //

            if ( commonExtension->DeviceType != RamdiskDeviceTypeDiskPdo ) {

                status = STATUS_INVALID_DEVICE_REQUEST;
                Irp->IoStatus.Information = 0;

                break;
            }

            //
            // We don't support this property.
            //

            status = STATUS_NOT_SUPPORTED;
            Irp->IoStatus.Information = 0;

            break;
        
        default: 
        
            //
            // If this is a target device, then some filter beneath us may
            // handle this property.
            //

            if ( commonExtension->DeviceType == RamdiskDeviceTypeDiskPdo ) {

                //
                // Call the lower device.
                //
    
                IoReleaseRemoveLock( &commonExtension->RemoveLock, Irp );

                IoSkipCurrentIrpStackLocation( Irp );

                return IoCallDriver( commonExtension->LowerDeviceObject, Irp );
            }
    
            //
            // Nope, this property really doesn't exist.
            //
    
            status = STATUS_INVALID_PARAMETER_1;
            Irp->IoStatus.Information = 0;

            break;
        }    
    }

    //
    // At this point, we have not sent the IRP down to a lower device, so
    // we need to complete it now.
    //

    ASSERT( status != STATUS_PENDING );

    IoReleaseRemoveLock( &commonExtension->RemoveLock, Irp );

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_DISK_INCREMENT );

    return status;

} // RamdiskQueryProperty
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ramdisk\ramdisk.c ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    ramdisk.c

Abstract:

    This is the RAM disk driver for Windows.

Author:

    Chuck Lenzmeier (ChuckL) 2001
        based on prototype XIP driver by DavePr
            based on NT4 DDK ramdisk by RobertN

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <initguid.h>
#include <ntddstor.h>
#include <ntddramd.h>

//
// ISSUE: 2000/10/11-DavePr -- haven't decided how to define DO_XIP appropriately.
//
#ifndef DO_XIP
#define DO_XIP 0x00020000
#endif

//
// Data declarations.
//

PDEVICE_OBJECT RamdiskBusFdo = NULL;

BOOLEAN ReportDetectedDevice;

ULONG MinimumViewCount;
ULONG DefaultViewCount;
ULONG MaximumViewCount;
ULONG MinimumViewLength;
ULONG DefaultViewLength;
ULONG MaximumViewLength;

ULONG MaximumPerDiskViewLength;

UNICODE_STRING DriverRegistryPath;
BOOLEAN MarkRamdisksAsRemovable;

#if SUPPORT_DISK_NUMBERS

ULONG DiskNumbersBitmapSize;

#endif // SUPPORT_DISK_NUMBERS

#if DBG

ULONG BreakOnEntry = DEFAULT_BREAK_ON_ENTRY;
ULONG DebugComponents = DEFAULT_DEBUG_COMPONENTS;
ULONG DebugLevel = DEFAULT_DEBUG_LEVEL;

BOOLEAN DontLoad = FALSE;

#endif

//
// Local functions.
//

NTSTATUS
DriverEntry (
    IN OUT PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
RamdiskCreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RamdiskFlushBuffers (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RamdiskFlushBuffersReal (
    IN PDISK_EXTENSION DiskExtension
    );

NTSTATUS
RamdiskSystemControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
RamdiskUnload (
    IN PDRIVER_OBJECT DriverObject
    );

VOID
QueryParameters (
    IN PUNICODE_STRING RegistryPath
    );

#if DBG

NTSTATUS
RamdiskInvalidDeviceRequest (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
QueryDebugParameters (
    IN PUNICODE_STRING RegistryPath
    );

#endif

//
// Declare pageable routines.
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( INIT, QueryParameters )

#pragma alloc_text( PAGE, RamdiskCreateClose )
#pragma alloc_text( PAGE, RamdiskFlushBuffers )
#pragma alloc_text( PAGE, RamdiskFlushBuffersReal )
#pragma alloc_text( PAGE, RamdiskSystemControl )
#pragma alloc_text( PAGE, RamdiskUnload )
#pragma alloc_text( PAGE, RamdiskWorkerThread )

#if DBG
#pragma alloc_text( INIT, QueryDebugParameters )
#endif // DBG

#endif // ALLOC_PRAGMA

NTSTATUS
DriverEntry (
    IN OUT PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is called by the operating system to initialize the driver.

Arguments:

    DriverObject - a pointer to a driver object for the driver

    RegistryPath - a pointer to our Services key in the registry

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS status;
    HANDLE handle;
    ULONG i;
    PDEVICE_OBJECT pdo = NULL;
    PLOADER_PARAMETER_BLOCK loaderBlock;

    //
    // Initialize pool debugging, if enabled.
    //

#if defined(POOL_DBG)
    RamdiskInitializePoolDebug();
#endif

    //
    // Get debugging parameters from the registry.
    //

#if DBG
    QueryDebugParameters( RegistryPath );
#endif

    DBGPRINT( DBG_INIT, DBG_VERBOSE,
                ("DriverEntry: DriverObject = %x, RegistryPath = %ws\n",
                DriverObject, RegistryPath->Buffer) );

    //
    // If requested, break into the debugger.
    //

#if DBG
    if ( BreakOnEntry ) {
        KdBreakPoint();
	}
#endif

    //
    // If requested, fail the driver load.
    //

#if DBG
    if ( DontLoad ) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }
#endif

    //
    // Get non-debug parameters from the registry.
    //

    QueryParameters( RegistryPath );

    //
    // Save the path to the driver's registry key.
    //

    DriverRegistryPath.Length = RegistryPath->Length;
    DriverRegistryPath.MaximumLength = (USHORT)(RegistryPath->Length + sizeof(WCHAR));
    DriverRegistryPath.Buffer = ALLOCATE_POOL( PagedPool, DriverRegistryPath.MaximumLength, TRUE );

    if ( DriverRegistryPath.Buffer == NULL ) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyUnicodeString( &DriverRegistryPath, RegistryPath );
    ASSERT( DriverRegistryPath.Length == RegistryPath->Length );

    //
    // Initialize the driver object with this driver's entry points.
    //

#if DBG
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = RamdiskInvalidDeviceRequest;
    }
#endif

    DriverObject->MajorFunction[IRP_MJ_CREATE] = RamdiskCreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = RamdiskCreateClose;
    DriverObject->MajorFunction[IRP_MJ_READ] = RamdiskReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = RamdiskReadWrite;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS] = RamdiskFlushBuffers;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = RamdiskDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP] = RamdiskPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = RamdiskPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = RamdiskSystemControl;
    DriverObject->MajorFunction[IRP_MJ_SCSI] = RamdiskScsi;

    DriverObject->DriverUnload = RamdiskUnload;
    DriverObject->DriverExtension->AddDevice = RamdiskAddDevice;

    //
    // If the registry tells us to do so, or if textmode setup is running and
    // virtual floppy RAM disks are specified in the registry, call
    // IoReportDetectedDevice to hook us up to PnP, then call RamdiskAddDevice
    // directly. This is necessary during textmode in order to get any virtual
    // floppy RAM disks created -- our AddDevice routine is not normally called
    // during textmode. Calling IoReportDetectedDevice is also necessary during
    // a boot from a RAM disk in order to get the device plumbed early enough.
    //
    // We don't want to call IoReportDetectedDevice during textmode setup if
    // no virtual floppies exist, because calling IoReportDetectedDevice
    // causes a devnode for the controller device to be written to the
    // registry, and textmode setup only deletes the devnode if virtual
    // floppies exist. If we leave the devnode in the registry, then GUI setup
    // installs ramdisk.sys on the machine, even though we don't really want
    // it to.
    //

    loaderBlock = *(PLOADER_PARAMETER_BLOCK *)KeLoaderBlock;

    if ( ReportDetectedDevice ||
         ( (loaderBlock != NULL) &&
           (loaderBlock->SetupLoaderBlock != NULL) &&
           CreateRegistryDisks( TRUE ) ) ) {
    
        //
        // Inform PnP that we have detected the bus enumerator device and will be
        // doing the AddDevice ourselves.
        //
       
        status = IoReportDetectedDevice(
                     DriverObject,
                     InterfaceTypeUndefined,
                     -1,
                     -1,
                     NULL, //allocatedResources,
                     NULL, //ioResourceReq,
                     FALSE,
                     &pdo
                 );
    
        if (!NT_SUCCESS(status)) {
            DBGPRINT( DBG_ALL, DBG_ERROR,
                        ("RamdiskDriverEntry: IoReportDetectedDevice failed: %x\n", status) );
           return status;
        }

        //
        // Attach a device object to the pdo
        //   

        status = RamdiskAddDevice(DriverObject, pdo);
        if ( !NT_SUCCESS(status) ) {
            DBGPRINT( DBG_ALL, DBG_ERROR,
                        ("RamdiskDriverEntry: RamdiskAddDevice failed: %x\n", status) );
            return status;
        }

        //
        // Indicate that the device is done initializing.
        //

        pdo->Flags &= ~DO_DEVICE_INITIALIZING;

    }

    //
    // Indicate that the driver has loaded successfully.
    //

    DBGPRINT( DBG_INIT, DBG_VERBOSE, ("%s", "DriverEntry: succeeded\n") );

    return STATUS_SUCCESS;

} // DriverEntry

NTSTATUS
RamdiskCreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system when a device owned by the driver
    is opened or closed.

    No action is performed other than completing the request successfully.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - STATUS_SUCCESS

--*/

{
    PAGED_CODE();

    COMPLETE_REQUEST( STATUS_SUCCESS, FILE_OPENED, Irp );

    return STATUS_SUCCESS;

} // RamdiskCreateClose

NTSTATUS
RamdiskFlushBuffers (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system when a FLUSH_BUFFERS IRP is
    issued.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PDISK_EXTENSION diskExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    //
    // If the target RAM disk is not file-backed, there's nothing to do. If it
    // is file-backed, we need to do the work in a thread.
    //

    if ( (diskExtension->DeviceType != RamdiskDeviceTypeDiskPdo) ||
         !RAMDISK_IS_FILE_BACKED(diskExtension->DiskType) ) {

        COMPLETE_REQUEST( STATUS_SUCCESS, 0, Irp );

        return STATUS_SUCCESS;
    }

    status = SendIrpToThread( DeviceObject, Irp );

    if ( status != STATUS_PENDING ) {

        COMPLETE_REQUEST( status, 0, Irp );
    }

    return status;

} // RamdiskFlushBuffers

NTSTATUS
RamdiskFlushBuffersReal (
    IN PDISK_EXTENSION DiskExtension
    )

/*++

Routine Description:

    This routine is called in a thread in the system process to handle a
    FLUSH_BUFFERS IRP.

Arguments:

    DiskExtension - a pointer to the device object extension for the target
        device

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    PAGED_CODE();

    //
    // Flush the virtual memory associated with the RAM disk.
    //

    return RamdiskFlushViews( DiskExtension );

} // RamdiskFlushBuffersReal

NTSTATUS
RamdiskSystemControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system when a SYSTEM_CONTROL IRP is
    issued.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    PCOMMON_EXTENSION commonExtension;
    NTSTATUS status;

	PAGED_CODE();

    //
    // If the target device is a bus FDO, pass the IRP down to the next
    // device in the stack. Otherwise, the target is a disk PDO, in which
    // case we just complete the IRP with the current status.
    //

    commonExtension = DeviceObject->DeviceExtension;

    if ( commonExtension->DeviceType == RamdiskDeviceTypeBusFdo ) {

        IoSkipCurrentIrpStackLocation( Irp );
        return IoCallDriver( commonExtension->LowerDeviceObject, Irp );
    }

    status = Irp->IoStatus.Status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;

} // RamdiskSystemControl


VOID
RamdiskUnload (
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is called by the I/O system to unload the driver.

    Any resources previously allocated must be freed.

Arguments:

    DriverObject - a pointer to the object that represents our driver

Return Value:

    None.

--*/

{
    PAGED_CODE();

    if ( DriverRegistryPath.Buffer != NULL ) {

        FREE_POOL( DriverRegistryPath.Buffer, TRUE );
    }

    //
    // ISSUE: What other cleanup is needed here?
    //

    return;

} // RamdiskUnload

VOID
RamdiskWorkerThread (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine executes thread-based operations for the RAM disk driver.
    It runs in the context of the system process.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Context - a pointer to the IRP for the I/O operation

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PLIST_ENTRY listEntry;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PCOMMON_EXTENSION commonExtension;
    PBUS_EXTENSION busExtension;
    PDISK_EXTENSION diskExtension;
    PSCSI_REQUEST_BLOCK srb;
    ULONG controlCode;
    PUCHAR originalDataBuffer;
    PUCHAR mappedDataBuffer;
    PUCHAR inputDataBuffer;
    PUCHAR systemAddress;
    ULONG originalDataBufferOffset;
    
    PAGED_CODE();

    //
    // Get a pointer to the IRP.
    //

    irp = Context;
    irpSp = IoGetCurrentIrpStackLocation( irp );

    //
    // Free the work item.
    //

    IoFreeWorkItem( irp->Tail.Overlay.DriverContext[0] );

    //
    // Get pointers to the device extension.
    //

    commonExtension = DeviceObject->DeviceExtension;
    busExtension = DeviceObject->DeviceExtension;
    diskExtension = DeviceObject->DeviceExtension;

    //
    // Acquire the remove lock for the device. If this fails, bail out.
    //

    status = IoAcquireRemoveLock( &commonExtension->RemoveLock, irp );

    if ( !NT_SUCCESS(status) ) {
        COMPLETE_REQUEST( status, 0, irp );
        return;
    }

    //
    // Dispatch based on the IRP function.
    //

    switch ( irpSp->MajorFunction ) {
    
    case IRP_MJ_READ:
    case IRP_MJ_WRITE:
    
        status = RamdiskReadWriteReal( irp, diskExtension );

        break;

    case IRP_MJ_FLUSH_BUFFERS:
    
        status = RamdiskFlushBuffersReal( diskExtension );
        irp->IoStatus.Information = 0;

        break;

    case IRP_MJ_DEVICE_CONTROL:

        switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
        
        case IOCTL_DISK_GET_DRIVE_LAYOUT:

            status = RamdiskGetDriveLayout( irp, diskExtension );

            break;

        case IOCTL_DISK_GET_PARTITION_INFO:

            status = RamdiskGetPartitionInfo( irp, diskExtension );

            break;

        case IOCTL_DISK_SET_PARTITION_INFO:

            status = RamdiskSetPartitionInfo( irp, diskExtension );

            break;

        case FSCTL_CREATE_RAM_DISK:

            status = RamdiskCreateRamDisk( DeviceObject, irp, FALSE );

            break;

        default:

            DBGPRINT( DBG_IOCTL, DBG_ERROR,
                        ("RamdiskThread: bogus IOCTL IRP with code %x received\n",
                        irpSp->Parameters.DeviceIoControl.IoControlCode) );
            ASSERT( FALSE );

            status = STATUS_INVALID_DEVICE_REQUEST;

            break;

        }

        break;

    case IRP_MJ_SCSI:

        srb = irpSp->Parameters.Scsi.Srb;
        controlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;

        //
        // Remember the original data buffer pointer. We might have to
        // change the pointer.
        //

        originalDataBuffer = srb->DataBuffer;

        status = STATUS_SUCCESS;

        if ( irp->MdlAddress != NULL ) {

            //
            // There is an MDL in the IRP. Get a usable system address for
            // the data buffer based on the MDL.
            //

            systemAddress = MmGetSystemAddressForMdlSafe(
                                irp->MdlAddress,
                                NormalPagePriority
                                );

            if ( systemAddress != NULL ) {

                //
                // The SRB data buffer might be at an offset from the
                // start of the MDL. Calculate that offset and add it
                // to the system address just obtained. This is the
                // data buffer address that we will use.
                //

                originalDataBufferOffset = (ULONG)(originalDataBuffer -
                                            (PCHAR)MmGetMdlVirtualAddress( irp->MdlAddress ));
                mappedDataBuffer = systemAddress + originalDataBufferOffset;
                srb->DataBuffer = mappedDataBuffer;

            } else {

                //
                // Couldn't get a system address. Abort.
                //

                srb->SrbStatus = SRB_STATUS_ABORTED;
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if ( NT_SUCCESS(status) ) {

            //
            // Remember the data buffer address that we're sending down.
            // If it doesn't change, we'll need to reset the address to
            // that which was passed in to us.
            //

            inputDataBuffer = srb->DataBuffer;

            //
            // Dispatch based on the I/O type in the SRB.
            //

            if ( controlCode == IOCTL_SCSI_EXECUTE_NONE ) {

                status = RamdiskScsiExecuteNone(
                            diskExtension->Pdo,
                            irp,
                            srb,
                            controlCode
                            );
            } else {

                status = RamdiskScsiExecuteIo(
                            diskExtension->Pdo,
                            irp,
                            srb,
                            controlCode
                            );
            }

            //
            // If the data buffer address didn't change, put the original
            // address back in the SRB.
            //

            if ( srb->DataBuffer == inputDataBuffer ) {
                srb->DataBuffer = originalDataBuffer;
            }
        }

        //
        // If the I/O worked, write the transfer length into the IRP.
        //

        if ( NT_SUCCESS(status) ) {
            irp->IoStatus.Information = srb->DataTransferLength;
        } else {
            irp->IoStatus.Information = 0;
        }

        break;

    default:

        DBGPRINT( DBG_IOCTL, DBG_ERROR,
                    ("RamdiskThread: bogus IRP with major function %x received\n",
                    irpSp->MajorFunction) );
        ASSERT( FALSE );

        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Release the remove lock and complete the request.
    //

    IoReleaseRemoveLock( &commonExtension->RemoveLock, irp );

    ASSERT( status != STATUS_PENDING );

    irp->IoStatus.Status = status;
    IoCompleteRequest( irp, IO_DISK_INCREMENT );

    return;

} // RamdiskWorkerThread

VOID
QueryParameters (
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is called from DriverEntry() to get driver parameters from
    the registry. If the registry query fails, then default values are used.

Arguments:

    RegistryPath - a pointer to the service path for the registry parameters

Return Value:

    None.

--*/

{
    NTSTATUS status;
    RTL_QUERY_REGISTRY_TABLE queryTable[12];
    PRTL_QUERY_REGISTRY_TABLE queryEntry;

    PAGED_CODE();

    DBGPRINT( DBG_INIT, DBG_VERBOSE, ("%s", "QueryParameters\n") );

    ASSERT( RegistryPath->Buffer != NULL );

    //
    // Set the default values.
    //

    ReportDetectedDevice = FALSE;
    MarkRamdisksAsRemovable = FALSE;

    MinimumViewCount = MINIMUM_MINIMUM_VIEW_COUNT;
    DefaultViewCount = DEFAULT_DEFAULT_VIEW_COUNT;
    MaximumViewCount = DEFAULT_MAXIMUM_VIEW_COUNT;
    MinimumViewLength = MINIMUM_MINIMUM_VIEW_LENGTH;
    DefaultViewLength = DEFAULT_DEFAULT_VIEW_LENGTH;
    MaximumViewLength = DEFAULT_MAXIMUM_VIEW_LENGTH;

    MaximumPerDiskViewLength = DEFAULT_MAXIMUM_PER_DISK_VIEW_LENGTH;

#if SUPPORT_DISK_NUMBERS
    DiskNumbersBitmapSize = DEFAULT_DISK_NUMBERS_BITMAP_SIZE;
#endif // SUPPORT_DISK_NUMBERS

    //
    // Set up the query table.
    //

    RtlZeroMemory( queryTable, sizeof(queryTable) );

    //
    // We're looking for subkey "Parameters" under the given registry key.
    //

    queryEntry = &queryTable[0];
    queryEntry->Flags = RTL_QUERY_REGISTRY_SUBKEY;
    queryEntry->Name = L"Parameters";
    queryEntry->EntryContext = NULL;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    //
    // These are the values we want to read.
    //

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"ReportDetectedDevice";
    queryEntry->EntryContext = &ReportDetectedDevice;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"MarkRamdisksAsRemovable";
    queryEntry->EntryContext = &MarkRamdisksAsRemovable;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"MinimumViewCount";
    queryEntry->EntryContext = &MinimumViewCount;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"DefaultViewCount";
    queryEntry->EntryContext = &DefaultViewCount;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"MaximumViewCount";
    queryEntry->EntryContext = &MaximumViewCount;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"MinimumViewLength";
    queryEntry->EntryContext = &MinimumViewLength;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"DefaultViewLength";
    queryEntry->EntryContext = &DefaultViewLength;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"MaximumViewLength";
    queryEntry->EntryContext = &MaximumViewLength;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"MaximumPerDiskViewLength";
    queryEntry->EntryContext = &MaximumPerDiskViewLength;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

#if SUPPORT_DISK_NUMBERS
    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"DiskNumbersBitmapSize";
    queryEntry->EntryContext = &DiskNumbersBitmapSize;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;
#endif // SUPPORT_DISK_NUMBERS

    //
    // Do the query.
    //

    status = RtlQueryRegistryValues(
                RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,    
                RegistryPath->Buffer,
                queryTable,
                NULL,
                NULL
                );

    //
    // Check the validity of the parameters.
    //

    if ( MinimumViewCount < MINIMUM_MINIMUM_VIEW_COUNT ) {
        MinimumViewCount = MINIMUM_MINIMUM_VIEW_COUNT;
    } else if ( MinimumViewCount > MAXIMUM_MINIMUM_VIEW_COUNT ) {
        MinimumViewCount = MAXIMUM_MINIMUM_VIEW_COUNT;
    }
        
    if ( DefaultViewCount < MinimumViewCount ) {
        DefaultViewCount = MinimumViewCount;
    } else if ( DefaultViewCount > MAXIMUM_DEFAULT_VIEW_COUNT ) {
        DefaultViewCount = MAXIMUM_DEFAULT_VIEW_COUNT;
    }
        
    if ( MaximumViewCount < DefaultViewCount ) {
        MaximumViewCount = DefaultViewCount;
    } else if ( MaximumViewCount > MAXIMUM_MAXIMUM_VIEW_COUNT ) {
        MaximumViewCount = MAXIMUM_MAXIMUM_VIEW_COUNT;
    }
        
    if ( MinimumViewLength < MINIMUM_MINIMUM_VIEW_LENGTH ) {
        MinimumViewLength = MINIMUM_MINIMUM_VIEW_LENGTH;
    } else if ( MinimumViewLength > MAXIMUM_MINIMUM_VIEW_LENGTH ) {
        MinimumViewLength = MAXIMUM_MINIMUM_VIEW_LENGTH;
    }
        
    if ( DefaultViewLength < MinimumViewLength ) {
        DefaultViewLength = MinimumViewLength;
    } else if ( DefaultViewLength > MAXIMUM_DEFAULT_VIEW_LENGTH ) {
        DefaultViewLength = MAXIMUM_DEFAULT_VIEW_LENGTH;
    }
        
    if ( MaximumViewLength < DefaultViewLength ) {
        MaximumViewLength = DefaultViewLength;
    } else if ( MaximumViewLength > MAXIMUM_MAXIMUM_VIEW_LENGTH ) {
        MaximumViewLength = MAXIMUM_MAXIMUM_VIEW_LENGTH;
    }
        
    if ( MaximumPerDiskViewLength < MINIMUM_MAXIMUM_PER_DISK_VIEW_LENGTH ) {
        MaximumPerDiskViewLength = MINIMUM_MAXIMUM_PER_DISK_VIEW_LENGTH;
    } else if ( MaximumViewLength > MAXIMUM_MAXIMUM_PER_DISK_VIEW_LENGTH ) {
        MaximumPerDiskViewLength = MAXIMUM_MAXIMUM_PER_DISK_VIEW_LENGTH;
    }

#if SUPPORT_DISK_NUMBERS
    if ( DiskNumbersBitmapSize < MINIMUM_DISK_NUMBERS_BITMAP_SIZE ) {
        DiskNumbersBitmapSize = MINIMUM_DISK_NUMBERS_BITMAP_SIZE;
    } else if ( DiskNumbersBitmapSize > MAXIMUM_DISK_NUMBERS_BITMAP_SIZE ) {
        DiskNumbersBitmapSize = MAXIMUM_DISK_NUMBERS_BITMAP_SIZE;
    }
#endif // SUPPORT_DISK_NUMBERS

    DBGPRINT( DBG_INIT, DBG_INFO, ("DefaultViewCount = 0x%x\n", DefaultViewCount) );
    DBGPRINT( DBG_INIT, DBG_INFO, ("MaximumViewCount = 0x%x\n", MaximumViewCount) );
    DBGPRINT( DBG_INIT, DBG_INFO, ("DefaultViewLength = 0x%x\n", DefaultViewLength) );
    DBGPRINT( DBG_INIT, DBG_INFO, ("MaximumViewLength = 0x%x\n", MaximumViewLength) );
    DBGPRINT( DBG_INIT, DBG_INFO, ("MaximumPerDiskViewLength = 0x%x\n", MaximumPerDiskViewLength) );

#if SUPPORT_DISK_NUMBERS
    DBGPRINT( DBG_INIT, DBG_INFO, ("DiskNumbersBitmapSize = 0x%x\n", DiskNumbersBitmapSize) );
#endif // SUPPORT_DISK_NUMBERS

    return;

} // QueryParameters

#if DBG

NTSTATUS
RamdiskInvalidDeviceRequest (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system when an IRP that we don't
    process is issued.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - STATUS_INVALID_DEVICE_REQUEST

--*/

{
    //
    // We really do recognize CLEANUP and SHUTDOWN IRPs. For any other IRP,
    // print a message and break into the debugger.
    //

    switch ( IoGetCurrentIrpStackLocation(Irp)->MajorFunction ) {
    
    case IRP_MJ_CLEANUP:
    case IRP_MJ_SHUTDOWN:
        break;

    default:

        DBGPRINT( DBG_IOCTL, DBG_ERROR,
                    ("Ramdisk: Unrecognized IRP: major/minor = %x/%x\n",
                    IoGetCurrentIrpStackLocation(Irp)->MajorFunction,
                    IoGetCurrentIrpStackLocation(Irp)->MinorFunction) );
        ASSERT( FALSE );

    }

    //
    // If this is a power IRP, we need to start the next one.
    //

    if ( IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_POWER ) {
        PoStartNextPowerIrp( Irp );
    }

    //
    // Tell the I/O system that we don't recognize this IRP.
    //

    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return STATUS_INVALID_DEVICE_REQUEST;

} // RamdiskInvalidDeviceRequest

VOID
QueryDebugParameters (
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is called from DriverEntry() to get the debug parameters
    from the registry. If the registry query fails, then default values are
    used.

Arguments:

    RegistryPath - a pointer to the service path for the registry parameters

Return Value:

    None.

--*/

{
    NTSTATUS status;
    RTL_QUERY_REGISTRY_TABLE queryTable[5];
    PRTL_QUERY_REGISTRY_TABLE queryEntry;

    PAGED_CODE();

    DBGPRINT( DBG_INIT, DBG_VERBOSE, ("%s", "QueryDebugParameters\n") );

    ASSERT( RegistryPath->Buffer != NULL );

    //
    // Set the default values.
    //

    BreakOnEntry = DEFAULT_BREAK_ON_ENTRY;
    DebugComponents = DEFAULT_DEBUG_COMPONENTS;
    DebugLevel = DEFAULT_DEBUG_LEVEL;

    //
    // Set up the query table.
    //

    RtlZeroMemory( queryTable, sizeof(queryTable) );

    //
    // We're looking for subkey "Debug" under the given registry key.
    //

    queryEntry = &queryTable[0];
    queryEntry->Flags = RTL_QUERY_REGISTRY_SUBKEY;
    queryEntry->Name = L"Debug";
    queryEntry->EntryContext = NULL;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    //
    // These are the values we want to read.
    //

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"BreakOnEntry";
    queryEntry->EntryContext = &BreakOnEntry;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"DebugComponents";
    queryEntry->EntryContext = &DebugComponents;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    queryEntry++;
    queryEntry->Flags = RTL_QUERY_REGISTRY_DIRECT;
    queryEntry->Name = L"DebugLevel";
    queryEntry->EntryContext = &DebugLevel;
    queryEntry->DefaultType = REG_NONE;
    queryEntry->DefaultData = NULL;
    queryEntry->DefaultLength = 0;

    //
    // Do the query.
    //

    status = RtlQueryRegistryValues(
                RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,    
                RegistryPath->Buffer,
                queryTable,
                NULL,
                NULL
                );

    DBGPRINT( DBG_INIT, DBG_INFO, ("BreakOnEntry = 0x%x\n", BreakOnEntry) );
    DBGPRINT( DBG_INIT, DBG_INFO, ("DebugComponents = 0x%x\n", DebugComponents) );
    DBGPRINT( DBG_INIT, DBG_INFO, ("DebugLevel = 0x%x\n", DebugLevel) );

    return;

} // QueryDebugParameters

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\proppage\volprop.c ===
/** FILE: volprop.cpp ********** Module Header ********************************
 *
 *  Property page for volume info on disk.
 *
 * History:
 *  30-Jan-1998     HLiu             Initial coding
 *
 *  Copyright (C) Microsoft Corporation, 1998 - 1999
 *
 *************************************************************************/
#include "propp.h"
#include "volprop.h"

// next 2 are shell headers
#include "shlobj.h"
#include "shlobjp.h"

// context identifier 
#define HIDC_DISK                       0x815c042f
#define HIDC_TYPE                       0x815c0430
#define HIDC_STATUS                     0x815c0432
#define HIDC_PARTSTYLE                  0x815c0434
#define HIDC_SPACE                      0x815c0431
#define HIDC_CAPACITY                   0x815c0122
#define HIDC_RESERVED                   0x815c0435
#define HIDC_VOLUME_LIST                0x815c0132
#define HIDC_VOLUME_PROPERTY            0x815c0442
#define HIDC_VOLUME_POPULATE            0x815c0444

// context help map
static const DWORD VolumeHelpIDs[]=
{
    IDC_DISK, HIDC_DISK,
    IDC_TYPE, HIDC_TYPE,
    IDC_STATUS, HIDC_STATUS,
    IDC_PARTSTYLE, HIDC_PARTSTYLE,
    IDC_SPACE, HIDC_SPACE,
    IDC_CAPACITY, HIDC_CAPACITY,
    IDC_RESERVED, HIDC_RESERVED,
    IDC_VOLUME_LIST, HIDC_VOLUME_LIST,
    IDC_VOLUME_PROPERTY, HIDC_VOLUME_PROPERTY,
    IDC_DISK_STATIC, HIDC_DISK,
    IDC_TYPE_STATIC, HIDC_TYPE,
    IDC_STATUS_STATIC, HIDC_STATUS,
    IDC_PARTSTYLE_STATIC, HIDC_PARTSTYLE,
    IDC_SPACE_STATIC, HIDC_SPACE,
    IDC_CAPACITY_STATIC, HIDC_CAPACITY,
    IDC_RESERVED_STATIC, HIDC_RESERVED,
    IDC_VOLUMELIST_STATIC, HIDC_VOLUME_LIST,
    IDC_VOLUME_POPULATE, HIDC_VOLUME_POPULATE,
    IDC_DIV1_STATIC, ((DWORD) -1),
    0, 0
};

// Volume property page functions
//

int CALLBACK SortVolumeList(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    LV_FINDINFO findInfo1 = {LVFI_PARAM,NULL,lParam1};
    LV_FINDINFO findInfo2 = {LVFI_PARAM,NULL,lParam2};
    HWND hwndVolumeList = (HWND)lParamSort;

    int index1 = ListView_FindItem(hwndVolumeList, -1, &findInfo1);
    int index2 = ListView_FindItem(hwndVolumeList, -1, &findInfo2);

    TCHAR ItemText1[ITEM_LENGTH];
    TCHAR ItemText2[ITEM_LENGTH];

    ListView_GetItemText(hwndVolumeList,index1,0,ItemText1,ITEM_LENGTH);
    ListView_GetItemText(hwndVolumeList,index2,0,ItemText2,ITEM_LENGTH);

    if (lstrcmp(ItemText1,ItemText2)>0)
        return 1;
    else
        return -1;
}

BOOL
VolumeOnPopulate(HWND HWnd,
                 PVOLUME_PAGE_DATA volumeData )
{
    HMODULE           LdmModule;
    PPROPERTY_PAGE_DATA pPropertyPageData = NULL;
    HWND              hwndVolumeList=GetDlgItem(HWnd, IDC_VOLUME_LIST);
    int               iCount, i;
    LVITEM            lvitem;
    BOOL              bLoadedDmdskmgr=FALSE;
    BOOL              bResult=FALSE;
    TCHAR             bufferError[800];  // big enough for localization
    TCHAR             bufferTitle[100];

    //
    // Check if LDM is loaded in the same process. If yes, check to see if 
    // volume information is already available from it.
    //
    LdmModule = GetModuleHandle(TEXT("dmdskmgr"));
    if ( LdmModule )
    {
        GET_PROPERTY_PAGE_DATA pfnGetPropertyPageData;
        pfnGetPropertyPageData = (GET_PROPERTY_PAGE_DATA) 
            GetProcAddress(LdmModule, "GetPropertyPageData");
        if (pfnGetPropertyPageData)
            pPropertyPageData = (*pfnGetPropertyPageData)(
                                        volumeData->MachineName,
                                        volumeData->DeviceInstanceId);
    }

    //
    // Try to load the data through dmadmin otherwise.
    //
    if (!pPropertyPageData)
    {
        LOAD_PROPERTY_PAGE_DATA pfnLoadPropertyPageData;
        
        if (!LdmModule)
        {
            LdmModule = LoadLibrary(TEXT("dmdskmgr"));
            if (!LdmModule)
                goto _out;

            bLoadedDmdskmgr = TRUE;
        }

        pfnLoadPropertyPageData = (LOAD_PROPERTY_PAGE_DATA) 
            GetProcAddress(LdmModule, "LoadPropertyPageData");
        if (pfnLoadPropertyPageData)
            pPropertyPageData = (*pfnLoadPropertyPageData)(
                                        volumeData->MachineName,
                                        volumeData->DeviceInfoSet,
                                        volumeData->DeviceInfoData );
    }
    
    if (!pPropertyPageData)
    {
        if ( LoadString( ModuleInstance, IDS_DISK_INFO_NOT_FOUND, bufferError,
                800 ) &&
             LoadString( ModuleInstance, IDS_DISK_INFO_NOT_FOUND_TITLE, bufferTitle,
                100 ) )
        {
            MessageBox( HWnd,
                        bufferError,
                        bufferTitle,
                        MB_OK | MB_ICONERROR );
        }
        goto _out;
    }

    volumeData->pPropertyPageData = pPropertyPageData;

    //
    // Initialize property page items.
    //
    SendDlgItemMessage( HWnd, IDC_DISK, WM_SETTEXT, (WPARAM)NULL,
                        (LPARAM)pPropertyPageData->DiskName );
    SendDlgItemMessage( HWnd, IDC_STATUS, WM_SETTEXT, (WPARAM)NULL,
                        (LPARAM)pPropertyPageData->DiskStatus );
    SendDlgItemMessage( HWnd, IDC_TYPE, WM_SETTEXT, (WPARAM)NULL,
                        (LPARAM)pPropertyPageData->DiskType );
    SendDlgItemMessage( HWnd, IDC_PARTSTYLE, WM_SETTEXT, (WPARAM)NULL,
                        (LPARAM)pPropertyPageData->DiskPartitionStyle );
    SendDlgItemMessage( HWnd, IDC_CAPACITY, WM_SETTEXT, (WPARAM)NULL,
                        (LPARAM)pPropertyPageData->DiskCapacity );
    SendDlgItemMessage( HWnd, IDC_SPACE, WM_SETTEXT, (WPARAM)NULL,
                        (LPARAM)pPropertyPageData->DiskFreeSpace );
    SendDlgItemMessage( HWnd, IDC_RESERVED, WM_SETTEXT, (WPARAM)NULL,
                        (LPARAM)pPropertyPageData->DiskReservedSpace );

    // Set image list
    ListView_SetImageList( hwndVolumeList,
                           pPropertyPageData->ImageList,
                           LVSIL_SMALL);

    //
    // Fill in volume list.
    //
    iCount = 0;
    lvitem.state = 0;
    lvitem.stateMask = 0;
    lvitem.iImage = 1;
    for (i=0; i<pPropertyPageData->VolumeCount; i++)
    {
        int iIndex;

        lvitem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
        lvitem.pszText = pPropertyPageData->VolumeArray[i].Label;
        lvitem.iItem = i;
        lvitem.iSubItem = 0;
        lvitem.lParam = (LPARAM)(pPropertyPageData->VolumeArray[i].MountName);
        lvitem.iImage = 1;
        iIndex = ListView_InsertItem( hwndVolumeList, &lvitem );

        ListView_SetItemText( hwndVolumeList, iIndex, 1, 
                              pPropertyPageData->VolumeArray[i].Size );
    }

    ListView_SortItems( hwndVolumeList, SortVolumeList, hwndVolumeList );

    EnableWindow( GetDlgItem(HWnd,IDC_VOLUME_POPULATE), FALSE );

    bResult = TRUE;
_out:
    if ( bLoadedDmdskmgr )
        FreeLibrary( LdmModule );
    return bResult;
}


BOOL
VolumeOnInitDialog(HWND    HWnd,
                   HWND    HWndFocus,
                   LPARAM  LParam)
{
    SP_DEVINFO_LIST_DETAIL_DATA  DeviceInfoSetDetailData;
    HWND              hwndVolumeList;
    LPPROPSHEETPAGE   page = (LPPROPSHEETPAGE) LParam;
    PVOLUME_PAGE_DATA volumeData = (PVOLUME_PAGE_DATA)page->lParam;
    TCHAR             HeadingColumn[ITEM_LENGTH], *pstrTemp;
    LVCOLUMN          lvcolumn;
    RECT              rect;

    volumeData->pPropertyPageData = NULL;

    //
    // Display volume list headings.
    //
    hwndVolumeList = GetDlgItem( HWnd, IDC_VOLUME_LIST );

    HeadingColumn[0] = TEXT('\0');
    LoadString( ModuleInstance, IDS_VOLUME_VOLUME, HeadingColumn, 
                ITEM_LENGTH );
    lvcolumn.mask    = LVCF_TEXT | LVCF_FMT;
    lvcolumn.pszText = HeadingColumn;
    lvcolumn.fmt     = LVCFMT_LEFT;
    lvcolumn.iSubItem= 0;
    ListView_InsertColumn( hwndVolumeList, 0, &lvcolumn );

    HeadingColumn[0] = TEXT('\0');
    LoadString( ModuleInstance, IDS_VOLUME_CAPACITY, HeadingColumn,
                ITEM_LENGTH );
    lvcolumn.mask    = LVCF_TEXT | LVCF_FMT | LVCF_SUBITEM;
    lvcolumn.pszText = HeadingColumn;
    lvcolumn.fmt     = LVCFMT_LEFT;
    lvcolumn.iSubItem= 1;
    ListView_InsertColumn( hwndVolumeList, 1, &lvcolumn );

    //
    // Set column widths.
    //
    GetClientRect( hwndVolumeList, &rect );
    ListView_SetColumnWidth( hwndVolumeList, 0, (int)rect.right*2/3 );
    ListView_SetColumnWidth( hwndVolumeList, 1, (int)rect.right/3 );

    EnableWindow( GetDlgItem(HWnd, IDC_VOLUME_PROPERTY), FALSE );

    //
    // Get machine name.
    //
    DeviceInfoSetDetailData.cbSize = sizeof(SP_DEVINFO_LIST_DETAIL_DATA);
    if ( !SetupDiGetDeviceInfoListDetail( volumeData->DeviceInfoSet,
                                          &DeviceInfoSetDetailData) )
        return FALSE;
    if (DeviceInfoSetDetailData.RemoteMachineHandle)
    {
        volumeData->bIsLocalMachine = FALSE;
        pstrTemp = DeviceInfoSetDetailData.RemoteMachineName;
        while (*pstrTemp==_T('\\')) pstrTemp++;
        lstrcpy( volumeData->MachineName, pstrTemp );
    }
    else
    {
        volumeData->bIsLocalMachine = TRUE;
        volumeData->MachineName[0] = _T('\0');
    }

    //
    // Get physical device instance Id.
    //
    if ( !SetupDiGetDeviceInstanceId( volumeData->DeviceInfoSet,
                                      volumeData->DeviceInfoData,
                                      volumeData->DeviceInstanceId,
                                      sizeof(volumeData->DeviceInstanceId), 
                                      NULL
                                    ) )
        return FALSE;

    SetWindowLongPtr( HWnd, DWLP_USER, (LONG_PTR)volumeData );

    //
    // Hide "Populate" button and populate volume page if this page is 
    // brought up from Disk Management snapin. 
    //
    if (volumeData->bInvokedByDiskmgr)
    {
        ShowWindow(GetDlgItem(HWnd,IDC_VOLUME_POPULATE), SW_HIDE);
        VolumeOnPopulate( HWnd, volumeData );
    }
    
    return TRUE;
}

VOID VolumeOnProperty(HWND HWnd)
{
    HWND hwndVolumeList = GetDlgItem(HWnd, IDC_VOLUME_LIST);
    LVITEM lvitem;
    int iSelItem;
    WCHAR *MountName;

    //
    // Find selected item.
    //
    iSelItem = ListView_GetNextItem(hwndVolumeList, -1, LVNI_SELECTED);
    if (iSelItem==LB_ERR)
        return;

    //
    // Get mount name.
    //
    lvitem.mask = LVIF_PARAM;
    lvitem.iItem = iSelItem;
    lvitem.iSubItem = 0;
    lvitem.lParam = 0;
    ListView_GetItem(hwndVolumeList, &lvitem);

    MountName = (WCHAR *)lvitem.lParam;

    SetFocus(hwndVolumeList);
    ListView_SetItemState( hwndVolumeList, 
                           iSelItem, 
                           LVIS_FOCUSED | LVIS_SELECTED, 
                           LVIS_FOCUSED | LVIS_SELECTED);
    // EnableWindow(GetDlgItem(HWnd,IDC_VOLUME_PROPERTY), TRUE);

    if ( MountName[1]==L':' )
        SHObjectProperties(NULL, SHOP_FILEPATH, MountName, NULL);
    else
        SHObjectProperties(NULL, SHOP_VOLUMEGUID, MountName, NULL);
}

VOID
VolumeOnCommand(HWND    HWnd,
                int     id,
                HWND    HWndCtl,
                UINT    codeNotify)
{
    HCURSOR hOldCursor;
    PVOLUME_PAGE_DATA volumeData = (PVOLUME_PAGE_DATA) GetWindowLongPtr(HWnd,
                                                                  DWLP_USER);
    switch (id) {
    case IDC_VOLUME_POPULATE:
        hOldCursor = SetCursor( LoadCursor(NULL, IDC_WAIT) );
        VolumeOnPopulate(HWnd, volumeData);
        SetCursor( hOldCursor );
        break;

    case IDC_VOLUME_PROPERTY:
        VolumeOnProperty(HWnd);
        break;

    }
}

LRESULT
VolumeOnNotify (HWND    HWnd,
                int     HWndFocus,
                LPNMHDR lpNMHdr)
{
    PVOLUME_PAGE_DATA volumeData = (PVOLUME_PAGE_DATA) GetWindowLongPtr(HWnd,
                                                                   DWLP_USER);
    int iSelItem;
    WCHAR *MountName;

    switch(lpNMHdr->code) {

        case NM_CLICK:
            //
            // Sanity check.
            //
            if (lpNMHdr->idFrom!=IDC_VOLUME_LIST)
                break;

            //
            // Don't do volume property on remote machine.
            //
            if (!volumeData->bIsLocalMachine)
                break;

            iSelItem = ListView_GetNextItem(lpNMHdr->hwndFrom, 
                                            -1, LVNI_SELECTED);
            if (iSelItem == LB_ERR)
                EnableWindow(GetDlgItem(HWnd, IDC_VOLUME_PROPERTY), FALSE);
            else {
                // enable only if item has a mount name
                LVITEM lvitem;
                lvitem.mask = LVIF_PARAM;
                lvitem.iItem = iSelItem;
                lvitem.iSubItem = 0;
                lvitem.lParam = 0;

                ListView_GetItem(GetDlgItem(HWnd, IDC_VOLUME_LIST), &lvitem);
                MountName = (WCHAR *)lvitem.lParam;

                if (MountName)
                    EnableWindow(GetDlgItem(HWnd, IDC_VOLUME_PROPERTY), TRUE);
                else
                    EnableWindow(GetDlgItem(HWnd, IDC_VOLUME_PROPERTY), FALSE);
            }
            break;
    }
    return 0;
}

BOOL
VolumeContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    )
{
    WinHelp(HwndControl,
            _T("diskmgmt.hlp"),
            HELP_CONTEXTMENU,
            (ULONG_PTR) VolumeHelpIDs);

    return FALSE;
}

void
VolumeHelp(
    HWND       ParentHwnd,
    LPHELPINFO HelpInfo
    )
{
    if (HelpInfo->iContextType == HELPINFO_WINDOW) {
        WinHelp((HWND) HelpInfo->hItemHandle,
                _T("diskmgmt.hlp"),
                HELP_WM_HELP,
                (ULONG_PTR) VolumeHelpIDs);
    }
}

void 
VolumeOnDestroy(HWND HWnd)
{
    PVOLUME_PAGE_DATA volumeData = (PVOLUME_PAGE_DATA) GetWindowLongPtr(HWnd,
                                                                   DWLP_USER);
    PPROPERTY_PAGE_DATA pPropertyPageData = NULL;
    int  i;

    //
    // release data memory
    //
    if (volumeData->pPropertyPageData)
    {
        pPropertyPageData = volumeData->pPropertyPageData;
        for (i=0; i<pPropertyPageData->VolumeCount; i++ )
        {
            if (pPropertyPageData->VolumeArray[i].MountName)
                HeapFree( GetProcessHeap(), 0, 
                    pPropertyPageData->VolumeArray[i].MountName);
        }

        HeapFree( GetProcessHeap(), 0, pPropertyPageData );
    }
}

INT_PTR
VolumeDialogProc(HWND hWnd,
                 UINT Message,
                 WPARAM wParam,
                 LPARAM lParam)
{
    switch(Message)
    {
        HANDLE_MSG(hWnd, WM_INITDIALOG,     VolumeOnInitDialog);
        HANDLE_MSG(hWnd, WM_COMMAND,        VolumeOnCommand);
        HANDLE_MSG(hWnd, WM_NOTIFY,         VolumeOnNotify);

    case WM_CONTEXTMENU:
        return VolumeContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP:
        VolumeHelp(hWnd, (LPHELPINFO) lParam);
        break;

    case WM_DESTROY:
        VolumeOnDestroy(hWnd);
        break;
    }
    return FALSE;
}

BOOL
VolumeDialogCallback(
    HWND HWnd,
    UINT Message,
    LPPROPSHEETPAGE Page
    )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ramdisk\pnp.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This file contains RAM disk driver code for processing PnP IRPs.

Author:

    Chuck Lenzmeier (ChuckL) 2001

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Registry value format for virtual floppy disks created by textmode setup.
// Should be in a header file, but that's not the way it was done for the
// original virtual floppy driver.
//

typedef struct _VIRTUAL_FLOPPY_DESCRIPTOR {

    //
    // The structure starts with a system virtual address. On 32-bit systems,
    // this is padded to 64 bits.
    //

    union {
        PVOID VirtualAddress;
        ULONGLONG Reserved;     // align to 64 bits
    } ;

    //
    // The length of the virtual floppy comes next.
    //

    ULONG Length;

    //
    // Textmode writes the registry value with 12 bytes of data. In order
    // to get the right size for our check, we use of the field offset of
    // the following field. We can't use sizeof a struct that just has the
    // above fields, because that comes out as 16 bytes due to alignment.
    //

    ULONG StructSizer;

} VIRTUAL_FLOPPY_DESCRIPTOR, *PVIRTUAL_FLOPPY_DESCRIPTOR;

#if !DBG

#define PRINT_CODE( _code )

#else

#define PRINT_CODE( _code )                                             \
    if ( print ) {                                                      \
        DBGPRINT( DBG_PNP, DBG_VERBOSE, ("%s", "  " #_code "\n") );     \
    }                                                                   \
    print = FALSE;

#endif

#if DBG

PSTR StateTable[] = {
    "STOPPED",
    "WORKING",
    "PENDINGSTOP",
    "PENDINGREMOVE",
    "SURPRISEREMOVED",
    "REMOVED",
    "UNKNOWN"
};

#endif // DBG

//
// Local functions.
//

NTSTATUS
RamdiskDeleteDiskDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp OPTIONAL
    );

NTSTATUS
RamdiskIoCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

NTSTATUS
RamdiskQueryBusInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RamdiskQueryCapabilities (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RamdiskQueryId (
    IN PDISK_EXTENSION DiskExtension,
    IN PIRP Irp
    );

NTSTATUS
RamdiskQueryDeviceRelations (
    IN DEVICE_RELATION_TYPE RelationsType,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RamdiskQueryDeviceText (
    IN PDISK_EXTENSION DiskExtension,
    IN PIRP Irp
    );

NTSTATUS
RamdiskRemoveBusDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#if DBG

PSTR
GetPnpIrpName (
    IN UCHAR PnpMinorFunction
    );

PCHAR
GetDeviceRelationString (
    IN DEVICE_RELATION_TYPE Type
    );

#endif // DBG

//
// Declare pageable routines.
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, RamdiskPnp )
#pragma alloc_text( PAGE, RamdiskPower )
#pragma alloc_text( PAGE, RamdiskAddDevice )
#pragma alloc_text( PAGE, CreateRegistryDisks )
#pragma alloc_text( PAGE, RamdiskDeleteDiskDevice )
#pragma alloc_text( PAGE, RamdiskQueryBusInformation )
#pragma alloc_text( PAGE, RamdiskQueryCapabilities )
#pragma alloc_text( PAGE, RamdiskQueryId )
#pragma alloc_text( PAGE, RamdiskQueryDeviceRelations )
#pragma alloc_text( PAGE, RamdiskQueryDeviceText )
#pragma alloc_text( PAGE, RamdiskRemoveBusDevice )

#if DBG
#pragma alloc_text( PAGE, GetPnpIrpName )
#pragma alloc_text( PAGE, GetDeviceRelationString )
#endif // DBG

#endif // ALLOC_PRAGMA

NTSTATUS
RamdiskPnp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to perform a PnP function.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PCOMMON_EXTENSION commonExtension;
    PBUS_EXTENSION busExtension;
    PDISK_EXTENSION diskExtension;
    KEVENT event;
    BOOLEAN lockHeld = FALSE;

#if DBG
    BOOLEAN print = TRUE;
#endif

    PAGED_CODE();

    //
    // Get pointers the IRP stack location and the device extension.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    commonExtension = DeviceObject->DeviceExtension;
    busExtension = DeviceObject->DeviceExtension;
    diskExtension = DeviceObject->DeviceExtension;

    ASSERT( commonExtension->DeviceState < RamdiskDeviceStateMaximum );


    DBGPRINT( DBG_PNP, DBG_INFO, ("RamdiskPnp: DO=(%p [Type=%d]) Irp=(%p %s) Device State=%s\n",
                DeviceObject, commonExtension->DeviceType, Irp,
                GetPnpIrpName(irpSp->MinorFunction), StateTable[commonExtension->DeviceState]) );


    //
    // If the device has been removed, only pass IRP_REMOVE down for cleanup.
    //

    if ( (commonExtension->DeviceState >= RamdiskDeviceStateRemoved) &&
         !( (irpSp->MinorFunction == IRP_MN_REMOVE_DEVICE) ||
            (irpSp->MinorFunction == IRP_MN_QUERY_ID)  ) ) {

        DBGPRINT( DBG_PNP, DBG_VERBOSE, ("RamdiskPnp: rejecting IRP %d for Removed Device\n",
                    irpSp->MinorFunction) );

        status = STATUS_NO_SUCH_DEVICE;
        COMPLETE_REQUEST( status, Irp->IoStatus.Information, Irp );

        return status;
    }

    //
    // Acquire the remove lock. If this fails, fail the I/O.
    //

    status = IoAcquireRemoveLock( &commonExtension->RemoveLock, Irp );

    if ( !NT_SUCCESS(status) ) {

        DBGPRINT( DBG_PNP, DBG_ERROR, ("RamdiskPnp: IoAcquireRemoveLock failed: %x\n", status) );

        COMPLETE_REQUEST( status, 0, Irp );

        return status;
    }

    //
    // Indicate that the remove lock is held.
    //

    lockHeld = TRUE;

    //
    // Dispatch based on the minor function.
    //

    switch ( irpSp->MinorFunction ) {

    case IRP_MN_START_DEVICE:

        PRINT_CODE( IRP_MN_START_DEVICE );

        if ( commonExtension->DeviceType == RamdiskDeviceTypeBusFdo ) {

            //
            // Starting the bus device.
            //
            // Send the IRP down and wait for it to come back.
            //

            IoCopyCurrentIrpStackLocationToNext( Irp );

            KeInitializeEvent( &event, NotificationEvent, FALSE );

            IoSetCompletionRoutine(
                Irp,
                RamdiskIoCompletionRoutine,
                &event,
                TRUE,
                TRUE,
                TRUE
                );

            status = IoCallDriver( commonExtension->LowerDeviceObject, Irp );

            if ( status == STATUS_PENDING ) {

                KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );
                status = Irp->IoStatus.Status;
            }

            if ( NT_SUCCESS(status) ) {

                //
                // Lower drivers didn't fail the IRP. Start the interface.
                //

                status = IoSetDeviceInterfaceState( &commonExtension->InterfaceString, TRUE );

                if ( !NT_SUCCESS(status) ) {

                    DBGPRINT( DBG_PNP, DBG_ERROR,
                                ("IoSetDeviceInterfaceState FAILED Status = 0x%x\n", status) );
                }

                //
                // Device started successfully.
                //

                commonExtension->DeviceState = RamdiskDeviceStateWorking;
            }

        } else {

            //
            // Starting a RAM disk.
            //
            // Register the device interface. If it's an emulated disk, use the
            // private RAM disk interface GUID. If it's an emulated volume, use
            // the systemwide volume GUID.
            //

            if ( commonExtension->InterfaceString.Buffer != NULL ) {
                FREE_POOL( commonExtension->InterfaceString.Buffer, FALSE );
            }

            status = IoRegisterDeviceInterface(
                        DeviceObject,
                        diskExtension->DiskType == RAMDISK_TYPE_FILE_BACKED_DISK ?
                            &RamdiskDiskInterface :
                            &VolumeClassGuid,
                        NULL,
                        &commonExtension->InterfaceString
                        );

            if ( !NT_SUCCESS(status) ) {

                DBGPRINT( DBG_PNP, DBG_ERROR,
                            ("IoRegisterDeviceInterface FAILED Status = 0x%x\n", status) );
            }

            //
            // Start the interface.
            //

            if ( !diskExtension->Options.Hidden &&
                 (commonExtension->InterfaceString.Buffer != NULL) ) {

                ULONG installState;
                ULONG resultLength;

                status = IoGetDeviceProperty(
                            DeviceObject,
                            DevicePropertyInstallState,
                            sizeof(installState),
                            &installState,
                            &resultLength
                            );

                if ( !NT_SUCCESS(status) ) {

                    DBGPRINT( DBG_PNP, DBG_ERROR,
                                ("IoGetDeviceProperty FAILED Status = 0x%x\n", status) );

                    //
                    // If we can't get the install state, we set the interface
                    // state to TRUE anyway, just to be safe.
                    //

                    installState = InstallStateInstalled;
                }

                if ( installState == InstallStateInstalled ) {

                    DBGPRINT( DBG_PNP, DBG_INFO,
                            ("%s", "Calling IoSetDeviceInterfaceState(TRUE)\n") );
                    status = IoSetDeviceInterfaceState( &commonExtension->InterfaceString, TRUE );

                    if ( !NT_SUCCESS(status) ) {

                        DBGPRINT( DBG_PNP, DBG_ERROR,
                                    ("IoSetDeviceInterfaceState FAILED Status = 0x%x\n", status) );
                    }

                } else {

                    DBGPRINT( DBG_PNP, DBG_INFO,
                            ("Skipping IoSetDeviceInterfaceState; state = 0x%x\n", installState) );
                }
            }

            //
            // Device started successfully.
            //

            commonExtension->DeviceState = RamdiskDeviceStateWorking;
        }

        //
        // Complete the I/O request.
        //

        COMPLETE_REQUEST( status, Irp->IoStatus.Information, Irp );

        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        PRINT_CODE( IRP_MN_QUERY_STOP_DEVICE );

        //
        // Mark that a stop is pending.
        //

        commonExtension->DeviceState = RamdiskDeviceStatePendingStop;

        //
        // Indicate success. Send the IRP on down the stack.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;

        goto send_irp_down;

    case IRP_MN_CANCEL_STOP_DEVICE:

        PRINT_CODE( IRP_MN_CANCEL_STOP_DEVICE );

        //
        // Before sending the IRP down make sure we have received
        // a IRP_MN_QUERY_STOP_DEVICE. We may get Cancel Stop
        // without receiving a Query Stop earlier, if the
        // driver on top fails a Query Stop and passes down the
        // Cancel Stop.
        //

        if ( commonExtension->DeviceState == RamdiskDeviceStatePendingStop ) {

            //
            // Mark that the device is back in the working state, and
            // pass the IRP down.
            //

            commonExtension->DeviceState = RamdiskDeviceStateWorking;

            Irp->IoStatus.Status = STATUS_SUCCESS;

            goto send_irp_down;

        } else {

            //
            // A spurious Cancel Stop request. Just complete it.
            //

            status = STATUS_SUCCESS;
            COMPLETE_REQUEST( status, Irp->IoStatus.Information, Irp );
        }

        break;

    case IRP_MN_STOP_DEVICE:

        PRINT_CODE( IRP_MN_STOP_DEVICE );

        //
        // Mark that the device is now stopped. Send the IRP on down the stack.
        //

        commonExtension->DeviceState = RamdiskDeviceStateStopped;

        Irp->IoStatus.Status = STATUS_SUCCESS;

        goto send_irp_down;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        PRINT_CODE( IRP_MN_QUERY_REMOVE_DEVICE );

        //
        // Mark that the device is pending removal. Send the IRP on down the
        // stack.
        //

        commonExtension->DeviceState = RamdiskDeviceStatePendingRemove;

        Irp->IoStatus.Status = STATUS_SUCCESS;

        goto send_irp_down;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        PRINT_CODE( IRP_MN_CANCEL_REMOVE_DEVICE );

        //
        // Before sending the IRP down make sure we have received
        // a IRP_MN_QUERY_REMOVE_DEVICE. We may get Cancel Remove
        // without receiving a Query Remove earlier, if the
        // driver on top fails a Query Remove and passes down the
        // Cancel Remove.
        //

        if ( commonExtension->DeviceState == RamdiskDeviceStatePendingRemove ) {

            //
            // Mark that the device is back in the working state. Send the
            // IRP on down the stack.
            //

            commonExtension->DeviceState = RamdiskDeviceStateWorking;

            Irp->IoStatus.Status = STATUS_SUCCESS;

            goto send_irp_down;

        } else {

            //
            // A spurious Cancel Remove request. Just complete it.
            //

            status = STATUS_SUCCESS;
            COMPLETE_REQUEST( status, Irp->IoStatus.Information, Irp );
        }

        break;

    case IRP_MN_SURPRISE_REMOVAL:

        PRINT_CODE( IRP_MN_SURPRISE_REMOVAL );

        if ( commonExtension->DeviceType == RamdiskDeviceTypeBusFdo ) {

            //
            // Mark that the device has been removed, and
            // pass the IRP down.
            //

            commonExtension->DeviceState = RamdiskDeviceStateSurpriseRemoved;

            Irp->IoStatus.Status = STATUS_SUCCESS;

            goto send_irp_down;

        } else {

            //
            // Ignore surprise removal for disk PDOs.
            //

            ASSERT( FALSE );

            status = STATUS_SUCCESS;
            COMPLETE_REQUEST( status, Irp->IoStatus.Information, Irp );
        }

        break;

    case IRP_MN_REMOVE_DEVICE:

        PRINT_CODE( IRP_MN_REMOVE_DEVICE );

        if ( commonExtension->DeviceType == RamdiskDeviceTypeBusFdo ) {

            //
            // Remove the bus FDO.
            //
            // Note that RamdiskRemoveBusDevice() sends the IRP down the
            // device stack, so we don't complete the IRP here.
            //

            status = RamdiskRemoveBusDevice( DeviceObject, Irp );

        } else {

            //
            // Remove a disk PDO.
            //

            status = RamdiskDeleteDiskDevice( DeviceObject, Irp );

            COMPLETE_REQUEST( status, Irp->IoStatus.Information, Irp );
        }

        //
        // The remove lock was released by RamdiskRemoveBusDevice or
        // RamdiskDeleteDiskDevice.
        //

        lockHeld = FALSE;

        break;

    case IRP_MN_EJECT:

        PRINT_CODE( IRP_MN_EJECT );

        if ( commonExtension->DeviceType == RamdiskDeviceTypeBusFdo ) {

            //
            // Ignore eject for the bus FDO. Just send the IRP down.
            //

            Irp->IoStatus.Status = STATUS_SUCCESS;

            goto send_irp_down;

        } else {

            //
            // Ignore eject for a disk PDO, too. Don't send the IRP down.
            //

            status = STATUS_SUCCESS;
            COMPLETE_REQUEST( status, 0, Irp );
        }

        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        //
        // Let RamdiskQueryDeviceRelations() do the work. Note that it
        // completes the IRP.
        //

        status = RamdiskQueryDeviceRelations(
                    irpSp->Parameters.QueryDeviceRelations.Type,
                    DeviceObject,
                    Irp
                    );

        break;

    case IRP_MN_QUERY_DEVICE_TEXT:

        //
        // For the bus FDO, just pass the IRP down. For a disk PDO, let
        // RamdiskQueryDeviceText() do the work and complete the IRP.
        //

        if ( commonExtension->DeviceType == RamdiskDeviceTypeBusFdo ) {

            goto send_irp_down;

        } else {

            status = RamdiskQueryDeviceText( diskExtension, Irp );
        }

        break;

    case IRP_MN_QUERY_BUS_INFORMATION:

        //
        // Let RamdiskQueryBusInformation() do the work. Note that it
        // completes the IRP.
        //

        status = RamdiskQueryBusInformation( DeviceObject, Irp );

        break;

    case IRP_MN_QUERY_CAPABILITIES:

        //
        // For the bus FDO, just pass the IRP down. For a disk PDO, let
        // RamdiskQueryCapabilities() do the work and complete the IRP.
        //

        if ( commonExtension->DeviceType == RamdiskDeviceTypeBusFdo ) {

            goto send_irp_down;

        } else {

            status = RamdiskQueryCapabilities( DeviceObject, Irp );
        }

        break;

    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:

        //
        // We don't have any resources to add to whatever might already be
        // there, so just complete the IRP.
        //

        status = Irp->IoStatus.Status;
        COMPLETE_REQUEST( Irp->IoStatus.Status, Irp->IoStatus.Information, Irp );

        break;

    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:

        //
        // For the bus FDO, just pass the IRP down. For a disk PDO, just
        // complete the IRP.
        //

        if ( commonExtension->DeviceType == RamdiskDeviceTypeBusFdo ) {

            goto send_irp_down;

        } else {

            status = Irp->IoStatus.Status;
            COMPLETE_REQUEST( Irp->IoStatus.Status, Irp->IoStatus.Information, Irp );
        }

        break;

    case IRP_MN_QUERY_ID:

        //
        // For the bus FDO, just pass the IRP down. For a disk PDO, let
        // RamdiskQueryId() do the work and complete the IRP.
        //

        if ( commonExtension->DeviceType == RamdiskDeviceTypeBusFdo ) {

            goto send_irp_down;

        } else {

            status = RamdiskQueryId( diskExtension, Irp );
        }

        break;

    case IRP_MN_QUERY_PNP_DEVICE_STATE:
    case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
    default:

send_irp_down:

        //
        // If this is the bus FDO, and there is a lower device object,
        // send the IRP down to the next device. If this is a disk PDO,
        // just complete the IRP.
        //

        if ( (commonExtension->DeviceType == RamdiskDeviceTypeBusFdo) &&
             (commonExtension->LowerDeviceObject != NULL) ) {

            IoSkipCurrentIrpStackLocation( Irp );
            status = IoCallDriver( commonExtension->LowerDeviceObject, Irp );

        } else {

            status = Irp->IoStatus.Status;
            COMPLETE_REQUEST( Irp->IoStatus.Status, Irp->IoStatus.Information, Irp );
        }

        break;

    } // switch

    //
    // If the lock is still held, release it now.
    //

    if ( lockHeld ) {

        DBGPRINT( DBG_PNP, DBG_VERBOSE,
                    ("RamdiskPnp: done; Device State=%s\n",
                    StateTable[commonExtension->DeviceState]) );

        IoReleaseRemoveLock( &commonExtension->RemoveLock, Irp );
    }

    return status;

} // RamdiskPnp

NTSTATUS
RamdiskPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to perform a power function.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PCOMMON_EXTENSION commonExtension;

    PAGED_CODE();

    DBGPRINT( DBG_POWER, DBG_VERBOSE,
                ("RamdiskPower: DO=(%p) Irp=(%p)\n", DeviceObject, Irp) );

    commonExtension = DeviceObject->DeviceExtension;

    if ( commonExtension->DeviceType == RamdiskDeviceTypeBusFdo ) {

        //
        // This is the bus FDO. There's not much for us to do here.
        //
        // Start the next power IRP.
        //

        PoStartNextPowerIrp( Irp );

        //
        // If the device has been removed, the driver should not pass
        // the IRP down to the next lower driver.
        //

        if ( commonExtension->DeviceState >= RamdiskDeviceStateRemoved ) {

            status = STATUS_DELETE_PENDING;
            COMPLETE_REQUEST( status, Irp->IoStatus.Information, Irp );

            return status;
        }

        //
        // Send the IRP on down the stack.
        //

        IoSkipCurrentIrpStackLocation( Irp );
        status = PoCallDriver( commonExtension->LowerDeviceObject, Irp );

    } else {

        PIO_STACK_LOCATION irpSp;
        POWER_STATE powerState;
        POWER_STATE_TYPE powerType;

        //
        // This is a request for a disk PDO.
        //
        // Get parameters from the IRP.
        //

        irpSp = IoGetCurrentIrpStackLocation( Irp );

        powerType = irpSp->Parameters.Power.Type;
        powerState = irpSp->Parameters.Power.State;

        //
        // Dispatch based on the minor function.
        //

        switch ( irpSp->MinorFunction ) {

        case IRP_MN_SET_POWER:

            //
            // For SET_POWER, we don't have to do anything but return success.
            //

            switch ( powerType ) {

            case DevicePowerState:
            case SystemPowerState:

                status = STATUS_SUCCESS;

                break;

            default:

                status = STATUS_NOT_SUPPORTED;

                break;
            }

            break;

        case IRP_MN_QUERY_POWER:

            //
            // For QUERY_POWER, we don't have to do anything but return
            // success.
            //

            status = STATUS_SUCCESS;

            break;

        case IRP_MN_WAIT_WAKE:
        case IRP_MN_POWER_SEQUENCE:
        default:

            status = STATUS_NOT_SUPPORTED;

            break;
        }

        if ( status != STATUS_NOT_SUPPORTED ) {

            Irp->IoStatus.Status = status;
        }

        PoStartNextPowerIrp( Irp );

        status = Irp->IoStatus.Status;
        COMPLETE_REQUEST( status, Irp->IoStatus.Information, Irp );
    }

    DBGPRINT( DBG_POWER, DBG_VERBOSE, ("RamdiskPower: status = 0x%x\n", status) );

    return status;

} // RamdiskPower

NTSTATUS
RamdiskAddDevice (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    )

/*++

Routine Description:

    This routine is called by the PnP system to add a device.

    We expect to get this call exactly once, to add our bus PDO.

Arguments:

    DriverObject - a pointer to our driver object

    Pdo - a pointer to the PDO for the FDO that we create

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    UNICODE_STRING deviceName;
    PDEVICE_OBJECT fdo;
    PBUS_EXTENSION busExtension;
    PULONG bitmap;
    PLOADER_PARAMETER_BLOCK loaderBlock;

    PAGED_CODE();

    DBGPRINT( DBG_PNP, DBG_VERBOSE, ("%s", "RamdiskAddDevice: entered\n") );

    //
    // If we've already done this once, fail this call.
    //

    if ( RamdiskBusFdo != NULL ) {

        return STATUS_DEVICE_ALREADY_ATTACHED;
    }

#if SUPPORT_DISK_NUMBERS

    //
    // Allocate space for the disk numbers bitmap.
    //

    bitmap  = ALLOCATE_POOL( PagedPool, DiskNumbersBitmapSize, TRUE );

    if ( bitmap == NULL ) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

#endif // SUPPORT_DISK_NUMBERS

    //
    // Create the bus device object.
    //
    // ISSUE: Apply an ACL to the bus device object. (Or does the next issue obviate this?)
    // ISSUE: We're supposed to use autogenerated names for FDOs. What is the
    //          harm in using our own name? (Benefit is that it's easier to
    //          find the device when creating/deleting disks.)
    //

    RtlInitUnicodeString( &deviceName, L"\\Device\\Ramdisk" );

    status = IoCreateDevice(
                 DriverObject,              // DriverObject
                 sizeof(BUS_EXTENSION),     // DeviceExtension
                 &deviceName,               // DeviceName
                 FILE_DEVICE_BUS_EXTENDER,  // DeviceType
                 FILE_DEVICE_SECURE_OPEN,   // DeviceCharacteristics
                 FALSE,                     // Exclusive
                 &fdo                       // DeviceObject
                 );

    if ( !NT_SUCCESS(status) ) {

        DBGPRINT( DBG_PNP, DBG_ERROR, ("RamdiskAddDevice: error %x creating bus FDO\n", status) );

#if SUPPORT_DISK_NUMBERS
        FREE_POOL( bitmap, TRUE );
#endif // SUPPORT_DISK_NUMBERS

        return status;
    }

    busExtension = fdo->DeviceExtension;
    RtlZeroMemory( busExtension, sizeof(BUS_EXTENSION) );

    //
    // Initialize device object and extension.
    //

    //
    // Our device does direct I/O and is power pageable.
    //

    fdo->Flags |= DO_DIRECT_IO | DO_POWER_PAGABLE;

    //
    // Set the device type and state in the device extension. Initialize the
    // fast mutex and the remove lock. Initialize the disk PDO list.
    //

    busExtension->DeviceType = RamdiskDeviceTypeBusFdo;
    busExtension->DeviceState = RamdiskDeviceStateStopped;

    ExInitializeFastMutex( &busExtension->Mutex );
    IoInitializeRemoveLock( &busExtension->RemoveLock, 'dmaR', 1, 0 );

    InitializeListHead( &busExtension->DiskPdoList );

    //
    // Save object pointers. The PDO for this extension is the PDO that
    // was passed in. The FDO is the device object that we just created. The
    // lower device object will be set later.
    //

    busExtension->Pdo = Pdo;
    busExtension->Fdo = fdo;

    //
    // Register the device interface.
    //

    status = IoRegisterDeviceInterface(
                Pdo,
                &RamdiskBusInterface,
                NULL,
                &busExtension->InterfaceString
                );

    if ( !NT_SUCCESS(status) ) {

        DBGPRINT( DBG_PNP, DBG_ERROR,
                    ("RamdiskAddDevice: error %x registering device interface for bus FDO\n",
                    status) );

        IoDeleteDevice( fdo );

#if SUPPORT_DISK_NUMBERS
        FREE_POOL( bitmap, TRUE );
#endif // SUPPORT_DISK_NUMBERS

        return status;
    }

    //
    // Attach the FDO to the PDO's device stack. Remember the lower device
    // object to which we are to forward PnP IRPs.
    //

    busExtension->LowerDeviceObject = IoAttachDeviceToDeviceStack( fdo, Pdo );

    if ( busExtension->LowerDeviceObject == NULL ) {

        DBGPRINT( DBG_PNP, DBG_ERROR,
                    ("%s", "RamdiskAddDevice: error attaching bus FDO to PDO stack\n") );

        //
        // Tell PnP that we're not going to be activating the interface that
        // we just registered. Free the symbolic link string associated with
        // the interface. Delete the device object.
        //

        IoSetDeviceInterfaceState( &busExtension->InterfaceString, FALSE );

        RtlFreeUnicodeString( &busExtension->InterfaceString );

        IoDeleteDevice( fdo );

#if SUPPORT_DISK_NUMBERS
        FREE_POOL( bitmap, TRUE );
#endif // SUPPORT_DISK_NUMBERS

        return STATUS_NO_SUCH_DEVICE;
    }

#if SUPPORT_DISK_NUMBERS

    //
    // Initialize the disk numbers bitmap.
    //

    busExtension->DiskNumbersBitmapBuffer = bitmap;
    RtlInitializeBitMap( &busExtension->DiskNumbersBitmap, bitmap, DiskNumbersBitmapSize );
    RtlClearAllBits( &busExtension->DiskNumbersBitmap );

#endif // SUPPORT_DISK_NUMBERS

    RamdiskBusFdo = fdo;

    //
    // If textmode setup is running, create any RAM disks specified in the
    // registry.
    //

    loaderBlock = *(PLOADER_PARAMETER_BLOCK *)KeLoaderBlock;

    if ( (loaderBlock != NULL) && (loaderBlock->SetupLoaderBlock != NULL) ) {

        CreateRegistryDisks( FALSE );
    }

    //
    // Indicate that we're done initializing the device.
    //

    fdo->Flags &= ~DO_DEVICE_INITIALIZING;

    return STATUS_SUCCESS;

} // RamdiskAddDevice

BOOLEAN
CreateRegistryDisks (
    IN BOOLEAN CheckPresenceOnly
    )

/*++

Routine Description:

    This routine creates virtual floppy disks specified in the registry.
    It is called only during textmode setup.

Arguments:

    CheckPresenceOnly - indicates whether this routine should just check for
        the presence of at least one disk in the registry

Return Value:

    BOOLEAN - indicates whether any disks were specified in the registry

--*/

{
    NTSTATUS status;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING string;
    HANDLE serviceHandle;
    HANDLE parametersHandle;
    ULONG diskNumber;
    WCHAR valueNameBuffer[15];
    UNICODE_STRING valueName;
    UCHAR valueBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(VIRTUAL_FLOPPY_DESCRIPTOR)];
    PKEY_VALUE_PARTIAL_INFORMATION value;
    PVIRTUAL_FLOPPY_DESCRIPTOR descriptor;
    ULONG valueLength;
    RAMDISK_CREATE_INPUT createInput;
    PDISK_EXTENSION diskExtension;
    BOOLEAN disksPresent = FALSE;
    HRESULT result;

    value = (PKEY_VALUE_PARTIAL_INFORMATION)valueBuffer;
    descriptor = (PVIRTUAL_FLOPPY_DESCRIPTOR)value->Data;

    //
    // Open the driver's key under Services.
    //

    InitializeObjectAttributes( &obja, &DriverRegistryPath, OBJ_CASE_INSENSITIVE, NULL, NULL );

    status = ZwOpenKey( &serviceHandle, KEY_READ, &obja );

    if ( !NT_SUCCESS(status) ) {

        DBGPRINT( DBG_INIT, DBG_ERROR, ("CreateRegistryDisks: ZwOpenKey(1) failed: %x\n", status) );

        return FALSE;
    }

    //
    // Open the Parameters subkey.
    //

    RtlInitUnicodeString( &string, L"Parameters" );
    InitializeObjectAttributes( &obja, &string, OBJ_CASE_INSENSITIVE, serviceHandle, NULL );

    status = ZwOpenKey( &parametersHandle, KEY_READ, &obja );

    NtClose( serviceHandle );

    if ( !NT_SUCCESS(status) ) {

        DBGPRINT( DBG_INIT, DBG_ERROR, ("CreateRegistryDisks: ZwOpenKey(2) failed: %x\n", status) );

        return FALSE;
    }

    //
    // Initialize static fields in the CREATE_INPUT structure that we'll pass
    // to RamdiskCreateDiskDevice.
    //

    RtlZeroMemory( &createInput, sizeof(createInput) );
    createInput.DiskType = RAMDISK_TYPE_VIRTUAL_FLOPPY;
    createInput.Options.Fixed = TRUE;
    createInput.Options.NoDriveLetter = TRUE;

    //
    // Look for values named DISKn, where n starts at 0 and increases by 1
    // each loop. Break out as soon as the expected DISKn is not found.
    // (If values named DISK0 and DISK2 are present, only DISK0 will be
    // created -- DISK2 will not be found.)
    //

    diskNumber = 0;

    while ( TRUE ) {

        // This variable is here to keep PREfast quiet (PREfast warning 209).
        size_t size = sizeof(valueNameBuffer);

        result = StringCbPrintfW(
                    valueNameBuffer,
                    size,
                    L"DISK%u",
                    diskNumber
                    );
        ASSERT( result == S_OK );

        RtlInitUnicodeString( &valueName, valueNameBuffer );

        status = ZwQueryValueKey(
                    parametersHandle,
                    &valueName,
                    KeyValuePartialInformation,
                    value,
                    sizeof(valueBuffer),
                    &valueLength
                    );

        if ( !NT_SUCCESS(status) ) {

            if ( status != STATUS_OBJECT_NAME_NOT_FOUND ) {

                DBGPRINT( DBG_INIT, DBG_ERROR,
                            ("CreateRegistryDisks: ZwQueryValueKey failed: %x\n", status) );
            }

            break;
        }

        //
        // We've found a DISKn value in the registry. For the purposes of
        // the CheckPresenceOnly flag, this is enough to know that at least
        // one virtual floppy disk is present. We don't care whether the
        // data is valid -- we just need to know that it's there.
        //

        disksPresent = TRUE;

        //
        // If we're just checking for the presence of at least one disk, we
        // can leave now.
        //

        if ( CheckPresenceOnly ) {

            break;
        }

        //
        // We expect the value to be a REG_BINARY with the correct length.
        // We don't explicitly check the value type; we assume that the
        // length check is sufficient. We also expect the base address
        // (which is a system virtual address -- either in KSEG0 or in
        // nonpaged pool) and the length to be nonzero.
        //

        if ( value->DataLength != FIELD_OFFSET(VIRTUAL_FLOPPY_DESCRIPTOR, StructSizer) ) {

            DBGPRINT( DBG_INIT, DBG_ERROR,
                        ("CreateRegistryDisks: key length wrong, wanted 0x%x, got 0x%x\n",
                            sizeof(VIRTUAL_FLOPPY_DESCRIPTOR), valueLength) );

        } else if ( (descriptor->VirtualAddress == NULL) || (descriptor->Length == 0) ) {

            DBGPRINT( DBG_INIT, DBG_ERROR,
                        ("CreateRegistryDisks: address (%x) or length (0x%x) invalid\n",
                            descriptor->VirtualAddress, descriptor->Length) );

        } else {

            //
            // Create a virtual floppy RAM disk at the specified address and
            // with the specified length. Pass the disk number in the GUID.
            //

            createInput.DiskGuid.Data1 = diskNumber;
            createInput.DiskLength = descriptor->Length;
            createInput.BaseAddress = descriptor->VirtualAddress;

            DBGPRINT( DBG_INIT, DBG_INFO,
                        ("CreateRegistryDisks: creating virtual floppy #%d at %p for %x\n",
                            diskNumber, descriptor->VirtualAddress, descriptor->Length) );

            ASSERT( RamdiskBusFdo != NULL );
            ASSERT( RamdiskBusFdo->DeviceExtension != NULL );

            status = RamdiskCreateDiskDevice(
                        RamdiskBusFdo->DeviceExtension,
                        &createInput,
                        FALSE,
                        &diskExtension
                        );

            if ( !NT_SUCCESS(status) ) {

                DBGPRINT( DBG_INIT, DBG_ERROR,
                            ("CreateRegistryDisks: RamdiskCreateDiskDevice failed: %x\n", status) );
            }
        }

        diskNumber++;
    }

    //
    // Close the Parameters key and return.
    //

    NtClose( parametersHandle );

    return disksPresent;

} // CreateRegistryDisks

NTSTATUS
RamdiskDeleteDiskDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp OPTIONAL
    )

/*++

Routine Description:

    This routine is called to delete a RAM disk device.

    NOTE: The remove lock is held on entry to this routine. It is released on
    exit. If Irp == NULL, the bus mutex is held on entry and released on exit.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        the operation is to be performed

    Irp - a pointer to the I/O Request Packet for this request. If NULL, this
        is a call from RamdiskRemoveBusDevice().

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PDISK_EXTENSION diskExtension;
    PDISK_EXTENSION tempDiskExtension;
    PBUS_EXTENSION busExtension;
    PLIST_ENTRY listEntry;

    PAGED_CODE();

    DBGPRINT( DBG_PNP, DBG_VERBOSE, ("%s", "RamdiskDeleteDiskDevice\n") );

    diskExtension = DeviceObject->DeviceExtension;
    busExtension = diskExtension->Fdo->DeviceExtension;

    DBGPRINT( DBG_PNP, DBG_INFO,
                ("RamdiskDeleteDiskDevice: Deleting device %wZ\n", &diskExtension->DeviceName) );

    //
    // If no IRP was specified, then we delete the disk device unconditionally.
    // (It's a call from RamdiskRemoveBusDevice().) Otherwise, we need to check
    // whether we really want to delete the device now.
    //

    if ( Irp != NULL ) {

        Irp->IoStatus.Information = 0;

        //
        // Check to see if the device has been marked for removal. If not,
        // ignore this IRP. We do this because user-mode PnP likes to remove
        // and immmediately recreate the devices that we materialize, but we
        // don't want to remove the device and lose the information about the
        // disk image.
        //

        if ( !diskExtension->MarkedForDeletion ) {

            //
            // This device has not really been removed, so ignore this IRP.
            // But do mark that the device is no longer claimed.
            //

            diskExtension->Status &= ~RAMDISK_STATUS_CLAIMED;

            IoReleaseRemoveLock( &diskExtension->RemoveLock, Irp );

            return STATUS_SUCCESS;
        }

        //
        // The device has been marked for deletion, so it's OK for PnP to be
        // trying to remove it. If this is PnP's first attempt at removing the
        // device, just mark it as removed and tell PnP to reenumerate the
        // bus. During reenumeration, we will skip this device, and PnP will
        // come back with another remove IRP.
        //

        if ( diskExtension->DeviceState < RamdiskDeviceStateRemoved ) {

            diskExtension->DeviceState = RamdiskDeviceStateRemoved;

            busExtension = diskExtension->Fdo->DeviceExtension;
            IoInvalidateDeviceRelations( busExtension->Pdo, BusRelations );

            IoReleaseRemoveLock( &diskExtension->RemoveLock, Irp );

            return STATUS_SUCCESS;
        }

        //
        // If the device is marked as removed, but it hasn't yet been skipped
        // in a bus enumeration, don't do anything now.
        //

        if ( diskExtension->DeviceState == RamdiskDeviceStateRemoved ) {

            IoReleaseRemoveLock( &diskExtension->RemoveLock, Irp );

            return STATUS_SUCCESS;
        }

        //
        // If we get here, we have already skipped this device in a bus
        // enumeration, so it's time to delete it. Acquire the bus mutex
        // so that we can do this.
        //

        KeEnterCriticalRegion();
        ExAcquireFastMutex( &busExtension->Mutex );
    }

    //
    // If we get here, we really do want to delete this device. If we've
    // already deleted it, don't do it again.
    //

    if ( diskExtension->DeviceState >= RamdiskDeviceStateDeleted ) {

        DBGPRINT( DBG_PNP, DBG_INFO,
                    ("RamdiskDeleteDiskDevice: device %wZ has already been deleted\n",
                    &diskExtension->DeviceName) );

        //
        // Release the bus mutex and the remove lock.
        //

        ExReleaseFastMutex( &busExtension->Mutex );
        KeLeaveCriticalRegion();

        IoReleaseRemoveLock( &diskExtension->RemoveLock, Irp );

        return STATUS_SUCCESS;
    }

    //
    // Indicate that the device has been deleted.
    //

    diskExtension->DeviceState = RamdiskDeviceStateDeleted;

    //
    // Remove the disk PDO from the bus FDO's list.
    //

    for ( listEntry = busExtension->DiskPdoList.Flink;
          listEntry != &busExtension->DiskPdoList;
          listEntry = listEntry->Flink ) {

        tempDiskExtension = CONTAINING_RECORD( listEntry, DISK_EXTENSION, DiskPdoListEntry );

        if ( tempDiskExtension == diskExtension ) {

            RemoveEntryList( listEntry );

#if SUPPORT_DISK_NUMBERS
            RtlClearBit( &busExtension->DiskNumbersBitmap, diskExtension->DiskNumber - 1 );
#endif // SUPPORT_DISK_NUMBERS

            break;
        }
    }

    //
    // We no longer need to hold the bus mutex and the remove lock.
    //

    ExReleaseFastMutex( &busExtension->Mutex );
    KeLeaveCriticalRegion();

    IoReleaseRemoveLockAndWait( &diskExtension->RemoveLock, Irp );

    //
    // If the interface has been started, stop it now.
    //

    if ( diskExtension->InterfaceString.Buffer != NULL ) {

        if ( !diskExtension->Options.Hidden ) {
            status = IoSetDeviceInterfaceState( &diskExtension->InterfaceString, FALSE );
        }

        RtlFreeUnicodeString( &diskExtension->InterfaceString );
    }

    //
    // Close the file backing the RAM disk, if any.
    //

    if ( diskExtension->SectionObject != NULL ) {

        if ( diskExtension->ViewDescriptors != NULL ) {

            //
            // Clean up the mapped views.
            //

            PVIEW view;

            ASSERT( diskExtension->ViewWaiterCount == 0 );

            while ( !IsListEmpty( &diskExtension->ViewsByOffset ) ) {

                listEntry = RemoveHeadList( &diskExtension->ViewsByOffset );
                view = CONTAINING_RECORD( listEntry, VIEW, ByOffsetListEntry );

                RemoveEntryList( &view->ByMruListEntry );

                ASSERT( view->ReferenceCount == 0 );

                if ( view->Address != NULL ) {

                    DBGPRINT( DBG_WINDOW, DBG_VERBOSE,
                                ("RamdiskDeleteDiskDevice: unmapping view %p; addr %p\n",
                                    view, view->Address) );

                    MmUnmapViewOfSection( PsGetCurrentProcess(), view->Address );
                }
            }

            ASSERT( IsListEmpty( &diskExtension->ViewsByMru ) );

            FREE_POOL( diskExtension->ViewDescriptors, TRUE );
        }

        ObDereferenceObject( diskExtension->SectionObject );
    }

    if ( !diskExtension->Options.NoDosDevice ) {

        //
        // Delete the DosDevices symbolic link.
        //

        ASSERT( diskExtension->DosSymLink.Buffer != NULL );

        status = IoDeleteSymbolicLink( &diskExtension->DosSymLink );

        if ( !NT_SUCCESS(status) ) {

            DBGPRINT( DBG_PNP, DBG_ERROR,
                        ("RamdiskDeleteDiskDevice: IoDeleteSymbolicLink failed: %x\n", status) );
        }

        FREE_POOL( diskExtension->DosSymLink.Buffer, TRUE );
    }

    //
    // Delete the device name string and the GUID string.
    //

    if ( diskExtension->DeviceName.Buffer != NULL ) {

        FREE_POOL( diskExtension->DeviceName.Buffer, TRUE );
    }

    if ( diskExtension->DiskGuidFormatted.Buffer != NULL ) {

        FREE_POOL( diskExtension->DiskGuidFormatted.Buffer, FALSE );
    }

    //
    // Delete the device object.
    //

    IoDeleteDevice( DeviceObject );

    return STATUS_SUCCESS;

} // RamdiskDeleteDiskDevice

NTSTATUS
RamdiskIoCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )

/*++

Routine Description:

    This internal routine is used as the I/O completion routine when we send
    an IRP down the device stack and want to short-circuit IRP completion so
    that we can do more work.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        the operation is to be performed

    Irp - a pointer to the I/O Request Packet for this request

    Event - a pointer to an event that is to be set to signal the calling code
        that the lower layers have completed the IRP

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    //
    // Set the event to signal the IRP issuer that it's time to continue.
    //

    KeSetEvent( Event, 0, FALSE );

    //
    // Tell the I/O system to stop completing the IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // RamdiskIoCompletionRoutine

NTSTATUS
RamdiskQueryBusInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine processes the IRP_MN_QUERY_BUS_INFORMATION IRP.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        the operation is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PPNP_BUS_INFORMATION busInformation;

    PAGED_CODE();

    DBGPRINT( DBG_PNP, DBG_VERBOSE,
                ("RamdiskQueryBusInformation: DO (0x%p) Type 0x%x\n",
                DeviceObject, ((PCOMMON_EXTENSION)DeviceObject->DeviceExtension)->DeviceType) );

    //
    // Allocate a buffer to use for returning the requested information.
    //

    busInformation = ALLOCATE_POOL( PagedPool, sizeof(PNP_BUS_INFORMATION), FALSE );

    if ( busInformation == NULL ) {

        //
        // Fail the IRP.
        //

        status = STATUS_INSUFFICIENT_RESOURCES;
        COMPLETE_REQUEST( status, 0, Irp );

        return status;
    }

    //
    // Fill in the requested information.
    //

    busInformation->BusTypeGuid = GUID_BUS_TYPE_RAMDISK;
    busInformation->LegacyBusType = PNPBus;
    busInformation->BusNumber = 0x00;

    //
    // Complete the IRP.
    //

    status = STATUS_SUCCESS;
    COMPLETE_REQUEST( status, (ULONG_PTR)busInformation, Irp );

    return status;

} // RamdiskQueryBusInformation

NTSTATUS
RamdiskQueryCapabilities (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine processes the IRP_MN_QUERY_CAPABILITIES IRP.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        the operation is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_CAPABILITIES deviceCapabilities;
    PDISK_EXTENSION diskExtension;

    PAGED_CODE();

    DBGPRINT( DBG_PNP, DBG_VERBOSE, ("%s", "RamdiskQueryCapabilities\n") );

    //
    // Get a pointer to the device extension and get parameters from the IRP.
    //

    diskExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    deviceCapabilities = irpSp->Parameters.DeviceCapabilities.Capabilities;

    if ( (deviceCapabilities->Version != 1) ||
         (deviceCapabilities->Size < sizeof(DEVICE_CAPABILITIES)) ) {

        //
        // We don't support this version. Fail the request.
        //

        status = STATUS_UNSUCCESSFUL;

    } else {

        status = STATUS_SUCCESS;

        //
        // If this is an emulated volume, we want to allow access to the raw
        // device. (Otherwise PnP won't start the device.)
        //
        // Note that a RAM disk boot disk is an emulated volume.
        //

        deviceCapabilities->RawDeviceOK =
            (BOOLEAN)(diskExtension->DiskType != RAMDISK_TYPE_FILE_BACKED_DISK);

        //
        // Indicate that ejection is not supported.
        //

        deviceCapabilities->EjectSupported = FALSE;

        //
        // This flag specifies whether the device's hardware is disabled.
        // The PnP Manager only checks this bit right after the device is
        // enumerated. Once the device is started, this bit is ignored.
        //

        deviceCapabilities->HardwareDisabled = FALSE;

        //
        // Indicate that the emulated device cannot be physically removed.
        // (Unless the right registry key was specified...)
        //

        deviceCapabilities->Removable = MarkRamdisksAsRemovable;

        //
        // Setting SurpriseRemovalOK to TRUE prevents the warning dialog from
        // appearing whenever the device is surprise removed. Setting it FALSE
        // allows the Hot unplug applet to stop the device.
        //
        // We don't want our disks to show up in the systray, so we set
        // SurpriseRemovalOK to TRUE. There is never really any surprise
        // removal anyway -- removal comes from the user mode control app
        // calling CM_Query_And_Remove_SubTree_Ex().
        //

        deviceCapabilities->SurpriseRemovalOK = TRUE;

        //
        // We support system-wide unique IDs.
        //

        deviceCapabilities->UniqueID = TRUE;

        //
        // Indicate that the Device Manager should suppress all
        // installation pop-ups except required pop-ups such as
        // "no compatible drivers found."
        //

        deviceCapabilities->SilentInstall = TRUE;

        //
        // Indicate that we do not want this device displayed in
        // Device Manager.
        //

        deviceCapabilities->NoDisplayInUI = TRUE;
    }

    //
    // Complete the request.
    //

    COMPLETE_REQUEST( status, Irp->IoStatus.Information, Irp );

    return status;

} // RamdiskQueryCapabilities

NTSTATUS
RamdiskQueryId (
    IN PDISK_EXTENSION DiskExtension,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine processes the IRP_MN_QUERY_ID IRP for disk devices.

Arguments:

    DiskExtension - a pointer to the device extension for the device object on
        which the operation is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
#define MAX_LOCAL_STRING 50

    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PWCHAR buffer;
    PWCHAR p;
    ULONG length;
    PWCHAR deviceType;
    HRESULT result;

    PAGED_CODE();

    DBGPRINT( DBG_PNP, DBG_VERBOSE, ("%s", "RamdiskQueryId\n") );

    //
    // Assume success.
    //

    status = STATUS_SUCCESS;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Dispatch based on the query type.
    //

    switch ( irpSp->Parameters.QueryId.IdType ) {

    case BusQueryDeviceID:

        //
        // DeviceID is a string to identify a device. We return the string
        // "Ramdisk\RamVolume" or "Ramdisk\RamDisk".
        //
        // Allocate pool to hold the string.
        //

        length = sizeof(RAMDISK_ENUMERATOR_TEXT) - sizeof(WCHAR) +
                    ((DiskExtension->DiskType == RAMDISK_TYPE_FILE_BACKED_DISK) ?
                        sizeof(RAMDISK_DISK_DEVICE_TEXT) : sizeof(RAMDISK_VOLUME_DEVICE_TEXT));

        buffer = ALLOCATE_POOL( PagedPool, length, FALSE );

        if ( buffer == NULL ) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        // Copy the string into the destination buffer.
        //

        result = StringCbCopyW( buffer, length, RAMDISK_ENUMERATOR_TEXT );
        ASSERT( result == S_OK );
        result = StringCbCatW(
                    buffer,
                    length,
                    (DiskExtension->DiskType == RAMDISK_TYPE_FILE_BACKED_DISK) ?
                        RAMDISK_DISK_DEVICE_TEXT : RAMDISK_VOLUME_DEVICE_TEXT
                    );
        ASSERT( result == S_OK );
        ASSERT( ((wcslen(buffer) + 1) * sizeof(WCHAR)) == length );

        DBGPRINT( DBG_PNP, DBG_VERBOSE, ("BusQueryDeviceID=%S\n", buffer) );

        break;

    case BusQueryInstanceID:

        //
        // InstanceID is a string to identify the device instance. We return
        // the disk GUID in string form.
        //
        // Allocate pool to hold the string.
        //

        buffer = ALLOCATE_POOL( PagedPool, DiskExtension->DiskGuidFormatted.MaximumLength, FALSE );

        if ( buffer == NULL ) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        // Copy the string into the destination buffer.
        //

        result = StringCbCopyW(
                    buffer,
                    DiskExtension->DiskGuidFormatted.MaximumLength,
                    DiskExtension->DiskGuidFormatted.Buffer
                    );
        ASSERT( result == S_OK );
        ASSERT( ((wcslen(buffer) + 1) * sizeof(WCHAR)) == DiskExtension->DiskGuidFormatted.MaximumLength );

        DBGPRINT( DBG_PNP, DBG_VERBOSE, ("BusQueryInstanceID=%S\n", buffer) );

        break;

    case BusQueryHardwareIDs:

        //
        // HardwareIDs is a multi-sz string to identify a device's hardware
        // type. We return the string "Ramdisk\RamVolume\0" or
        // "Ramdisk\RamDisk\0".
        //
        // Allocate pool to hold the string. Note that we allocate space
        // for two null terminators.
        //

        length = sizeof(RAMDISK_ENUMERATOR_TEXT) - sizeof(WCHAR) +
                 ((DiskExtension->DiskType == RAMDISK_TYPE_FILE_BACKED_DISK) ?
                     sizeof(RAMDISK_DISK_DEVICE_TEXT) : sizeof(RAMDISK_VOLUME_DEVICE_TEXT)) +
                 sizeof(WCHAR);

        buffer = ALLOCATE_POOL( PagedPool, length, FALSE );

        if ( buffer == NULL ) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        // Copy the string into the destination buffer.
        //

        result = StringCbCopyW( buffer, length, RAMDISK_ENUMERATOR_TEXT );
        ASSERT( result == S_OK );
        result = StringCbCatW(
                    buffer,
                    length,
                    (DiskExtension->DiskType == RAMDISK_TYPE_FILE_BACKED_DISK) ?
                        RAMDISK_DISK_DEVICE_TEXT : RAMDISK_VOLUME_DEVICE_TEXT
                    );
        ASSERT( result == S_OK );
        ASSERT( ((wcslen(buffer) + 2) * sizeof(WCHAR)) == length );

        buffer[length/sizeof(WCHAR) - 1] = 0;

        DBGPRINT( DBG_PNP, DBG_VERBOSE, ("BusQueryHardwareIDs=%S\n", buffer) );

        break;

    case BusQueryCompatibleIDs:

        //
        // HardwareIDs is a multi-sz string to identify device classes that
        // are compatible with a device. For volume-emulating RAM disks, we
        // return no compatible IDs, so that the device stands on its own at
        // the volume level. For disk-emulating RAM disks, we return the
        // string "Gendisk\0", so that the device gets hooked in below disk.sys.
        //

        if ( DiskExtension->DiskType == RAMDISK_TYPE_FILE_BACKED_DISK ) {

            //
            // Disk emulation. Allocate pool to hold the string.
            //

            length = sizeof(L"GenDisk") + sizeof(WCHAR);

            buffer = ALLOCATE_POOL( PagedPool, length, FALSE );

            if ( buffer == NULL ) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            //
            // Copy the string into the destination buffer.
            //

            result = StringCbCopyW( buffer, length, L"GenDisk" );
            ASSERT( result == S_OK );
            ASSERT( ((wcslen(buffer) + 2) * sizeof(WCHAR)) == length );

            buffer[length/sizeof(WCHAR) - 1] = 0;

        } else {

            //
            // Volume emulation. Do not return any compatible IDs.
            //

            buffer = NULL;

            status = STATUS_INVALID_DEVICE_REQUEST;
        }

        DBGPRINT( DBG_PNP, DBG_VERBOSE, ("BusQueryCompatibleIDs=%S\n", buffer) );

        break;

    default:

        //
        // Unknown query type. Just leave whatever's already in the IRP there.
        //

        status = Irp->IoStatus.Status;
        buffer = (PWCHAR)Irp->IoStatus.Information;
    }

    //
    // Complete the request.
    //

    COMPLETE_REQUEST( status, (ULONG_PTR)buffer, Irp );

    return status;

} // RamdiskQueryId

NTSTATUS
RamdiskQueryDeviceRelations (
    IN DEVICE_RELATION_TYPE RelationsType,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine processes the IRP_MN_QUERY_DEVICE_RELATIONS IRP.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        the operation is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PCOMMON_EXTENSION commonExtension;
    PBUS_EXTENSION busExtension;
    PDISK_EXTENSION diskExtension;
    RAMDISK_DEVICE_TYPE deviceType;
    PLIST_ENTRY listEntry;
    PDEVICE_RELATIONS deviceRelations;
    PDEVICE_RELATIONS oldRelations;
    ULONG prevCount = 0;
    ULONG length = 0;
    ULONG numPdosPresent = 0;

    PAGED_CODE();

    //
    // Assume success.
    //

    status = STATUS_SUCCESS;

    //
    // Get the device extension pointer and save the device type.
    //

    commonExtension = (PCOMMON_EXTENSION)DeviceObject->DeviceExtension;
    deviceType = commonExtension->DeviceType;

    DBGPRINT( DBG_PNP, DBG_VERBOSE,
                ("RamdiskQueryDeviceRelations: QueryDeviceRelation Type: %s, DeviceType 0x%x\n",
                GetDeviceRelationString(RelationsType), deviceType) );

    //
    // Dispatch based on the device type.
    //

    if ( deviceType == RamdiskDeviceTypeDiskPdo ) {

        //
        // It's a disk PDO. We only handle TargetDeviceRelation for PDOs.
        //

        diskExtension = (PDISK_EXTENSION)commonExtension;

        if ( RelationsType == TargetDeviceRelation ) {

            //
            // Allocate pool to hold the return information. (DEVICE_RELATIONS
            // has space for one entry built-in).
            //

            deviceRelations = ALLOCATE_POOL( PagedPool, sizeof(DEVICE_RELATIONS), FALSE );

            if ( deviceRelations != NULL ) {

                //
                // Return a referenced pointer to the device object for this
                // device.
                //

                ObReferenceObject( DeviceObject );

                deviceRelations->Count = 1;
                deviceRelations->Objects[0] = DeviceObject;

                status = STATUS_SUCCESS;

            } else {

                //
                // Couldn't allocate pool.
                //

                status = STATUS_INSUFFICIENT_RESOURCES;
            }

            //
            // Complete the request.
            //

            COMPLETE_REQUEST( status, (ULONG_PTR)deviceRelations, Irp );

        } else {

            //
            // PDOs just complete enumeration requests without altering
            // the status.
            //

            status = Irp->IoStatus.Status;
            COMPLETE_REQUEST( status, Irp->IoStatus.Information, Irp );
        }

        return status;

    } else {

        //
        // It's the bus FDO. We only handle BusRelations for the FDO.
        //

        busExtension = (PBUS_EXTENSION)commonExtension;

        if ( RelationsType == BusRelations ) {

            //
            // Re-enumerate the device.
            //
            // Lock the disk PDO list.
            //

            KeEnterCriticalRegion();
            ExAcquireFastMutex( &busExtension->Mutex );

            //
            // There might also be device relations below and above this FDO,
            // so propagate the relations from the upper drivers.
            //

            oldRelations = (PDEVICE_RELATIONS)Irp->IoStatus.Information;

            if (oldRelations != NULL) {
                prevCount = oldRelations->Count;
            } else {
                prevCount = 0;
            }

            //
            // Calculate the number of PDOs actually present on the bus.
            //

            numPdosPresent = 0;

            for ( listEntry = busExtension->DiskPdoList.Flink;
                  listEntry != &busExtension->DiskPdoList;
                  listEntry = listEntry->Flink ) {

                diskExtension = CONTAINING_RECORD( listEntry, DISK_EXTENSION, DiskPdoListEntry );

                if ( diskExtension->DeviceState < RamdiskDeviceStateRemoved ) {
                    numPdosPresent++;
                }
            }

            //
            // Allocate a new relations structure and add our PDOs to it.
            //

            length = sizeof(DEVICE_RELATIONS) +
                     ((numPdosPresent + prevCount - 1) * sizeof(PDEVICE_OBJECT));

            deviceRelations = ALLOCATE_POOL( PagedPool, length, FALSE );

            if ( deviceRelations == NULL ) {

                //
                // Fail the IRP.
                //

                ExReleaseFastMutex( &busExtension->Mutex );
                KeLeaveCriticalRegion();

                status = STATUS_INSUFFICIENT_RESOURCES;
                COMPLETE_REQUEST( status, Irp->IoStatus.Information, Irp );

                return status;
            }

            //
            // Copy in the device objects so far.
            //

            if ( prevCount != 0 ) {

                RtlCopyMemory(
                    deviceRelations->Objects,
                    oldRelations->Objects,
                    prevCount * sizeof(PDEVICE_OBJECT)
                    );
            }

            deviceRelations->Count = prevCount + numPdosPresent;

            //
            // For each PDO present on this bus, add a pointer to the device
            // relations buffer, being sure to take out a reference to that
            // object. PnP will dereference the object when it is done with it
            // and free the device relations buffer.
            //

            for ( listEntry = busExtension->DiskPdoList.Flink;
                  listEntry != &busExtension->DiskPdoList;
                  listEntry = listEntry->Flink ) {

                diskExtension = CONTAINING_RECORD( listEntry, DISK_EXTENSION, DiskPdoListEntry );

                if ( diskExtension->DeviceState < RamdiskDeviceStateRemoved ) {

                    ObReferenceObject( diskExtension->Pdo );

                    deviceRelations->Objects[prevCount] = diskExtension->Pdo;

                    DBGPRINT( DBG_PNP, DBG_VERBOSE,
                                ("QueryDeviceRelations(BusRelations) PDO = 0x%p\n",
                                deviceRelations->Objects[prevCount]) );

                    prevCount++;

                } else {

                    if ( diskExtension->DeviceState == RamdiskDeviceStateRemoved ) {

                        diskExtension->DeviceState = RamdiskDeviceStateRemovedAndNotReported;
                    }

                    DBGPRINT( DBG_PNP, DBG_VERBOSE,
                                ("QueryDeviceRelations(BusRelations) PDO = 0x%p -- SKIPPED\n",
                                diskExtension->Pdo) );
                }
            }

            //
            // Release the lock.
            //

            ExReleaseFastMutex( &busExtension->Mutex );
            KeLeaveCriticalRegion();

            DBGPRINT( DBG_PNP, DBG_VERBOSE,
                        ("QueryDeviceRelations(BusRelations) Total #PDOs reported = %d, "
                        "%d were new\n",
                        deviceRelations->Count, numPdosPresent) );

            //
            // Replace the relations structure in the IRP with the new
            // one.
            //

            if ( oldRelations != NULL ) {
                FREE_POOL( oldRelations, FALSE );
            }

            Irp->IoStatus.Information = (ULONG_PTR)deviceRelations;
            Irp->IoStatus.Status = STATUS_SUCCESS;
        }

        //
        // Send the IRP down the device stack.
        //

        IoCopyCurrentIrpStackLocationToNext( Irp );
        status = IoCallDriver( busExtension->LowerDeviceObject, Irp );
    }

    return status;

} // RamdiskQueryDeviceRelations

NTSTATUS
RamdiskQueryDeviceText (
    IN PDISK_EXTENSION DiskExtension,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine processes the IRP_MN_QUERY_DEVICE_TEXT IRP.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        the operation is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    ULONG length;
    PWCHAR buffer;
    UNICODE_STRING tempString;
    HRESULT result;

    PAGED_CODE();

    DBGPRINT( DBG_PNP, DBG_VERBOSE, ("%s", "RamdiskQueryDeviceText\n") );

    //
    // Assume success.
    //

    status = STATUS_SUCCESS;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Dispatch based on the query type.
    //

    switch ( irpSp->Parameters.QueryDeviceText.DeviceTextType ) {

    case DeviceTextDescription:

        //
        // Description is just "RamDisk".
        //
        // Allocate pool to hold the string.
        //

        length = sizeof( RAMDISK_DISK_DEVICE_TEXT );

        buffer = ALLOCATE_POOL( PagedPool, length, FALSE );

        if ( buffer == NULL ) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        // Copy the string into the destination buffer.
        //

        result = StringCbCopyW( buffer, length, RAMDISK_DISK_DEVICE_TEXT );
        ASSERT( result == S_OK );
        ASSERT( ((wcslen(buffer) + 1) * sizeof(WCHAR)) == length );

        break;

    case DeviceTextLocationInformation:

        //
        // LocationInformation is just "Ramdisk\\0".
        //
        // Allocate pool to hold the string.
        //

        length = sizeof( RAMDISK_ENUMERATOR_BUS_TEXT );

        buffer = ALLOCATE_POOL( PagedPool, length, FALSE );

        if ( buffer == NULL ) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        // Copy the string into the destination buffer.
        //

        result = StringCbCopyW( buffer, length, RAMDISK_ENUMERATOR_BUS_TEXT );
        ASSERT( result == S_OK );
        ASSERT( ((wcslen(buffer) + 1) * sizeof(WCHAR)) == length );

        break;

    default:

        //
        // Unknown query type. Just leave whatever's already in the IRP there.
        //

        status = Irp->IoStatus.Status;
        buffer = (PWCHAR)Irp->IoStatus.Information;
    }

    //
    // Complete the request.
    //

    COMPLETE_REQUEST( status, (ULONG_PTR)buffer, Irp );

    return status;

} // RamdiskQueryDeviceText

NTSTATUS
RamdiskRemoveBusDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine removes the bus device.

    The remove lock must be held on entry.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        the operation is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PBUS_EXTENSION busExtension;
    PLIST_ENTRY listEntry;
    PDISK_EXTENSION diskExtension;

    PAGED_CODE();

    DBGPRINT( DBG_PNP, DBG_VERBOSE, ("%s", "RamdiskRemoveBusDevice\n" ) );

    //
    // Get a pointer to the device extension.
    //

    busExtension = DeviceObject->DeviceExtension;


    //
    // Lock the disk PDO list. Walk the list, deleting all remaining devices.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutex( &busExtension->Mutex );

    while ( !IsListEmpty( &busExtension->DiskPdoList ) ) {

        listEntry = busExtension->DiskPdoList.Flink;

        //
        // Delete the device and clean it up. Acquire the remove lock first.
        // RamdiskDeleteDiskDevice releases it.
        //

        diskExtension = CONTAINING_RECORD( listEntry, DISK_EXTENSION, DiskPdoListEntry );

        status = IoAcquireRemoveLock( &diskExtension->RemoveLock, NULL );
        ASSERT( NT_SUCCESS(status) );

        RamdiskDeleteDiskDevice( diskExtension->Pdo, NULL );

        KeEnterCriticalRegion();
        ExAcquireFastMutex( &busExtension->Mutex );
    }

    //
    // Release the lock.
    //

    ExReleaseFastMutex( &busExtension->Mutex );
    KeLeaveCriticalRegion();

    //
    // Pass the IRP on down to lower levels.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoSkipCurrentIrpStackLocation( Irp );
    status = IoCallDriver( busExtension->LowerDeviceObject, Irp );

    //
    // Set the device status to Removed and wait for other drivers
    // to release the lock, then delete the device object.
    //

    busExtension->DeviceState = RamdiskDeviceStateRemoved;
    IoReleaseRemoveLockAndWait( &busExtension->RemoveLock, Irp );

    //
    // Stop the interface and free the interface string.
    //

    if ( busExtension->InterfaceString.Buffer != NULL ) {

        IoSetDeviceInterfaceState( &busExtension->InterfaceString, FALSE );

        RtlFreeUnicodeString( &busExtension->InterfaceString );
    }

    //
    // If attached to a lower device, detach now.
    //

    if ( busExtension->LowerDeviceObject != NULL ) {

        IoDetachDevice( busExtension->LowerDeviceObject );
    }

#if SUPPORT_DISK_NUMBERS

    //
    // Free the disk numbers bitmap.
    //

    ASSERT( !RtlAreBitsSet( &busExtension->DiskNumbersBitmap, 0, DiskNumbersBitmapSize ) );

    FREE_POOL( busExtension->DiskNumbersBitmapBuffer, TRUE );

#endif // SUPPORT_DISK_NUMBERS

    //
    // Indicate that we no longer have a bus FDO, and delete the device object.
    //

    RamdiskBusFdo = NULL;

    IoDeleteDevice( DeviceObject );

    DBGPRINT( DBG_PNP, DBG_NOTIFY, ("%s", "Device removed succesfully\n") );

    return status;

} // RamdiskRemoveBusDevice

#if DBG

PSTR
GetPnpIrpName (
    IN UCHAR PnpMinorFunction
    )
{
    static char functionName[25];
    HRESULT result;

    PAGED_CODE();

    switch ( PnpMinorFunction ) {

    case IRP_MN_START_DEVICE:

        return "IRP_MN_START_DEVICE";

    case IRP_MN_QUERY_REMOVE_DEVICE:

        return "IRP_MN_QUERY_REMOVE_DEVICE";

    case IRP_MN_REMOVE_DEVICE:

        return "IRP_MN_REMOVE_DEVICE";

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        return "IRP_MN_CANCEL_REMOVE_DEVICE";

    case IRP_MN_STOP_DEVICE:

        return "IRP_MN_STOP_DEVICE";

    case IRP_MN_QUERY_STOP_DEVICE:

        return "IRP_MN_QUERY_STOP_DEVICE";

    case IRP_MN_CANCEL_STOP_DEVICE:

        return "IRP_MN_CANCEL_STOP_DEVICE";

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        return "IRP_MN_QUERY_DEVICE_RELATIONS";

    case IRP_MN_QUERY_INTERFACE:

        return "IRP_MN_QUERY_INTERFACE";

    case IRP_MN_QUERY_CAPABILITIES:

        return "IRP_MN_QUERY_CAPABILITIES";

    case IRP_MN_QUERY_RESOURCES:

        return "IRP_MN_QUERY_RESOURCES";

    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:

        return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";

    case IRP_MN_QUERY_DEVICE_TEXT:

        return "IRP_MN_QUERY_DEVICE_TEXT";

    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:

        return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";

    case IRP_MN_READ_CONFIG:

        return "IRP_MN_READ_CONFIG";

    case IRP_MN_WRITE_CONFIG:

        return "IRP_MN_WRITE_CONFIG";

    case IRP_MN_EJECT:

        return "IRP_MN_EJECT";

    case IRP_MN_SET_LOCK:

        return "IRP_MN_SET_LOCK";

    case IRP_MN_QUERY_ID:

        return "IRP_MN_QUERY_ID";

    case IRP_MN_QUERY_PNP_DEVICE_STATE:

        return "IRP_MN_QUERY_PNP_DEVICE_STATE";

    case IRP_MN_QUERY_BUS_INFORMATION:

        return "IRP_MN_QUERY_BUS_INFORMATION";

    case IRP_MN_DEVICE_USAGE_NOTIFICATION:

        return "IRP_MN_DEVICE_USAGE_NOTIFICATION";

    case IRP_MN_SURPRISE_REMOVAL:

        return "IRP_MN_SURPRISE_REMOVAL";

    case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:

        return "IRP_MN_QUERY_LEGACY_BUS_INFORMATION";

    default:

        result = StringCbPrintfA(
                    functionName,
                    sizeof( functionName ),
                    "Unknown PnP IRP 0x%02x",
                    PnpMinorFunction
                    );
        ASSERT( result == S_OK );

        return functionName;
    }

} // GetPnpIrpName

PCHAR
GetDeviceRelationString (
    IN DEVICE_RELATION_TYPE Type
    )
{
    static char relationName[30];
    HRESULT result;

    PAGED_CODE();

    switch ( Type ) {

    case BusRelations:

        return "BusRelations";

    case EjectionRelations:

        return "EjectionRelations";

    case RemovalRelations:

        return "RemovalRelations";

    case TargetDeviceRelation:

        return "TargetDeviceRelation";

    default:

        result = StringCbPrintfA(
                    relationName,
                    sizeof( relationName ),
                    "Unknown relation 0x%02x",
                    Type
                    );
        ASSERT( result == S_OK );

        return relationName;
    }

} // GetDeviceRelationString

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ramdisk\ramdisk.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ramdisk.h

Abstract:

    This file includes extension declaration for
    the RAM Disk driver for Whistler.

Author:

    Chuck Lenzmeier (chuckl) 2001

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

//
// Pool allocation tag.
//
// ISSUE: Add this to pooltags.txt.
//

#define RAMDISK_TAG_GENERAL 'dmaR'

//
// I/O completion macro. Set the IoStatus field of the IRP and complete it.
//
// Note: IO_NO_INCREMENT is used to complete the IRP. If you want an
// increment (such as IO_DISK_INCREMENT), do it manually.
//

#define COMPLETE_REQUEST( _status, _information, _irp ) {   \
    ASSERT( (_irp) != NULL );                               \
    ASSERT( KeGetCurrentIrql() <= DISPATCH_LEVEL );         \
    _irp->IoStatus.Status = (_status);                      \
    _irp->IoStatus.Information = (_information);            \
    IoCompleteRequest( (_irp), IO_NO_INCREMENT );           \
}

//
// Types of devices serviced by this driver. BusFdo is the bus enumeration
// FDO. DiskPdo is a RAM disk device PDO.
//

typedef enum {
    RamdiskDeviceTypeBusFdo,
    RamdiskDeviceTypeDiskPdo
} RAMDISK_DEVICE_TYPE;

//
// States that a device can be in.
//

typedef enum {
    RamdiskDeviceStateStopped,
    RamdiskDeviceStateWorking,
    RamdiskDeviceStatePendingStop,
    RamdiskDeviceStatePendingRemove,
    RamdiskDeviceStateSurpriseRemoved,
    RamdiskDeviceStateRemoved,
    RamdiskDeviceStateRemovedAndNotReported,
    RamdiskDeviceStateDeleted,
    RamdiskDeviceStateMaximum
} RAMDISK_DEVICE_STATE;

//
// Bits for the DISK_EXTENSION.Status field.
//

#define RAMDISK_STATUS_PREVENT_REMOVE   0x00000001
#define RAMDISK_STATUS_CLAIMED          0x00000002

//
// Saved path to the driver's registry key.
//

extern UNICODE_STRING DriverRegistryPath;

//
// Should RAM disks be marked as removable? TRUE makes the hotplug applet play
// a sound when RAM disks appear and disappear. FALSE (the default) keeps it
// quiet.
//

extern BOOLEAN MarkRamdisksAsRemovable;

#if SUPPORT_DISK_NUMBERS

//
// Disk numbering. The disk number is only maintained so that it can be
// returned from IOCTL_STORAGE_GET_DEVICE_NUMBER.
//

#define MINIMUM_DISK_NUMBERS_BITMAP_SIZE  64
#define DEFAULT_DISK_NUMBERS_BITMAP_SIZE 256
#define MAXIMUM_DISK_NUMBERS_BITMAP_SIZE (64 * 1024)

extern ULONG DiskNumbersBitmapSize;

#endif // SUPPORT_DISK_NUMBERS

//
// Disk image windowing.
//

#define MINIMUM_MINIMUM_VIEW_COUNT   2
#define MAXIMUM_MINIMUM_VIEW_COUNT MAXIMUM_MAXIMUM_VIEW_COUNT

#define DEFAULT_DEFAULT_VIEW_COUNT  16
#define MAXIMUM_DEFAULT_VIEW_COUNT MAXIMUM_MAXIMUM_VIEW_COUNT

#define DEFAULT_MAXIMUM_VIEW_COUNT  64
#define MAXIMUM_MAXIMUM_VIEW_COUNT 256

#define MINIMUM_MINIMUM_VIEW_LENGTH (64 * 1024)
#define MAXIMUM_MINIMUM_VIEW_LENGTH MAXIMUM_MAXIMUM_VIEW_LENGTH

#define DEFAULT_DEFAULT_VIEW_LENGTH (  1 * 1024 * 1024)
#define MAXIMUM_DEFAULT_VIEW_LENGTH MAXIMUM_MAXIMUM_VIEW_LENGTH

#define DEFAULT_MAXIMUM_VIEW_LENGTH (256 * 1024 * 1024)
#define MAXIMUM_MAXIMUM_VIEW_LENGTH (  1 * 1024 * 1024 * 1024)

#define MINIMUM_MAXIMUM_PER_DISK_VIEW_LENGTH ( 16 * 1024 * 1024)
#define DEFAULT_MAXIMUM_PER_DISK_VIEW_LENGTH (256 * 1024 * 1024)
#define MAXIMUM_MAXIMUM_PER_DISK_VIEW_LENGTH MAXULONG

extern ULONG MinimumViewCount;
extern ULONG DefaultViewCount;
extern ULONG MaximumViewCount;
extern ULONG MinimumViewLength;
extern ULONG DefaultViewLength;
extern ULONG MaximumViewLength;
extern ULONG MaximumPerDiskViewLength;

typedef struct _VIEW {

    //
    // Views are kept in two lists.
    //
    // The by-offset list is sorted in ascending order by the base offset of
    // the view. (Unmapped views have offset and length both 0 and are always
    // at the front of the by-offset list.)
    //
    // The MRU list is sorted with the most recently used views at the front.
    // When we need to unmap a view and remap a new view, we take a free view
    // from the back of the MRU list.
    //

    LIST_ENTRY ByOffsetListEntry;
    LIST_ENTRY ByMruListEntry;

    //
    // Address is the virtual address at which the view is mapped.
    //
    // Offset is the offset from the start of the file that backs the RAM disk.
    //
    // Length if the length of the view. Normally this is the same as the
    // ViewLength field in the disk extension, but it can be less for the
    // view at the end of the disk image. (If we permanently map the first
    // few pages of the disk image [to keep the boot sector mapped], then the
    // first view will also be "short".
    //

    PUCHAR Address;

    ULONGLONG Offset;
    ULONG Length;

    //
    // ReferenceCount indicates how many active operations are using the view.
    // When ReferenceCount is 0, the view is a candidate for replacement.
    //
    // Permanent indicates whether the view is to remain mapped permanently.
    // If Permanent is TRUE, the ReferenceCount field is not used. (Permanent
    // is intended to be used to keep a view permanently mapped to the boot
    // sector. Currently we don't implement any permanent views.)
    //

    ULONG ReferenceCount;

    BOOLEAN Permanent;

} VIEW, *PVIEW;

//
// The device extensions for BusFdo and DiskPdo devices have a common header.
//

typedef struct  _COMMON_EXTENSION {

    //
    // Device type and state.
    //

    RAMDISK_DEVICE_TYPE DeviceType;
    RAMDISK_DEVICE_STATE DeviceState;

    //
    // Fdo points to the FDO for the device. For the BusFdo, Fdo is the device
    // that we created for the BusFdo (see RamdiskAddDevice()). For a DiskPdo,
    // Fdo is the BusFdo.
    //
    // Pdo points to the PDO for the device. For the BusFdo, Pdo is the PDO
    // that was passed in to RamdiskAddDevice(). For a DiskPdo, Pdo is the
    // device that we created for the DiskPdo (see RamdiskCreateDiskDevice()).
    //
    // LowerDeviceObject points to the device object below this device in the
    // device stack. For the BusFdo, LowerDeviceObject is returned by the call
    // to IoAttachDeviceToDeviceStack() in RamdiskAddDevice(). For a DiskPdo,
    // LowerDeviceObject is the BusFdo.
    //

    PDEVICE_OBJECT Fdo;
    PDEVICE_OBJECT Pdo;
    PDEVICE_OBJECT LowerDeviceObject;

    //
    // RemoveLock prevents removal of a device while it is busy.
    //

    IO_REMOVE_LOCK RemoveLock;

    //
    // InterfaceString is returned by IoRegisterDeviceInterface().
    //

    UNICODE_STRING InterfaceString;

    //
    // DeviceName is the name of the device.
    //

    UNICODE_STRING DeviceName;

    //
    // Mutex controls access to various fields in the device extension.
    //

    FAST_MUTEX Mutex;

} COMMON_EXTENSION, *PCOMMON_EXTENSION;

//
// The BusFdo has the following device extension. (Must start with a
// COMMON_EXTENSION!)
//

typedef struct  _BUS_EXTENSION {

    COMMON_EXTENSION ;

#if SUPPORT_DISK_NUMBERS

    //
    // DiskNumbersBitmap is a bitmap indicating which disk numbers are in
    // use by active RAM disks. Bit number 0 of the bitmap corresponds to
    // disk number 1.
    //

    RTL_BITMAP DiskNumbersBitmap;
    PULONG DiskNumbersBitmapBuffer;

#endif // SUPPORT_DISK_NUMBERS

    //
    // DiskPdoList is a list of all existing RAM disk devices.
    //

    LIST_ENTRY DiskPdoList;

} BUS_EXTENSION, *PBUS_EXTENSION;

//
// Each DiskPdo has the following device extension. (Must start with a
// COMMON_EXTENSION!)
//

typedef struct  _DISK_EXTENSION {

    COMMON_EXTENSION ;

    //
    // DiskPdoListEntry links the DiskPdo into the BusFdo's DiskPdoList.
    //

    LIST_ENTRY DiskPdoListEntry;

    //
    // DiskGuid is the GUID assigned to the disk by the creator.
    // DiskGuidFormatted is the GUID in printable format.
    //

    GUID DiskGuid;
    UNICODE_STRING DiskGuidFormatted;

    //
    // DosSymLink is the DosDevices name associated with the device. This is
    // only valid if Options.NoDosDevice is FALSE.
    //

    UNICODE_STRING DosSymLink;

#if SUPPORT_DISK_NUMBERS

    //
    // DiskNumber is the number of the disk.
    //

    ULONG DiskNumber;

#endif // SUPPORT_DISK_NUMBERS

    //
    // DiskType indicates what type of disk is being emulated. (See
    // RAMDISK_TYPE_xxx in ramdisku.h.)
    //

    ULONG DiskType;

    //
    // Status indicates whether the disk has been claimed and whether removal
    // is prevented. (See RAMDISK_STATUS_xxx above.)
    //

    ULONG Status;

    //
    // Options specifies various create options for the disk: is it readonly;
    // is it fixed or removable; does it have a drive letter; etc.
    //

    RAMDISK_CREATE_OPTIONS Options;

    //
    // DiskLength is the length of the disk image. DiskOffset is the offset
    // from the start of the backing file or memory block to the actual start
    // of the disk image. (DiskLength does NOT include DiskOffset.)
    //
    // FileRelativeEndOfDisk is the sum of DiskOffset + DiskLength. It is
    // calculated once to avoid recalculating it every time a view is mapped.
    //

    ULONGLONG DiskLength;
    ULONG DiskOffset;

    ULONGLONG FileRelativeEndOfDisk;

    //
    // BasePage indicates the base physical page when DiskType is
    // RAMDISK_TYPE_BOOT_DISK. For file-backed RAM disks, SectionObject
    // is a referenced pointer to the section. For virtual floppies,
    // BaseAddress indicates the base virtual address.
    //

    ULONG_PTR BasePage;
    PVOID SectionObject;
    PVOID BaseAddress;

    //
    // DriveLetter is the drive letter assigned to the boot disk.
    //

    WCHAR DriveLetter;

    //
    // MarkedForDeletion indicates whether user mode has informed us
    // that it is about to delete the device.
    //

    BOOLEAN MarkedForDeletion;

    //
    // Mapped image windowing.
    //
    // ViewCount is the number of views that are available. ViewLength is
    // length of each view.
    //

    ULONG ViewCount;
    ULONG ViewLength;

    //
    // ViewDescriptors points to an array of view descriptors allocated when
    // the disk was created.
    //

    PVIEW ViewDescriptors;

    //
    // ViewsByOffset and ViewsByMru are lists of view descriptors (see the
    // description of the VIEW struct).
    //

    LIST_ENTRY ViewsByOffset;
    LIST_ENTRY ViewsByMru;

    //
    // ViewSemaphore is used to wake up threads that are waiting for a free
    // view (so they can remap a new view). ViewWaiterCount is the number of
    // threads that are currently waiting for a free view. The semaphore is
    // "kicked" by this amount when a view is freed.
    //

    KSEMAPHORE ViewSemaphore;
    ULONG ViewWaiterCount;

    //
    // ISSUE: Do we really need XIP_BOOT_PARAMETERS?
    //

    //XIP_BOOT_PARAMETERS BootParameters;

    //
    // ViewSemaphore is used to wake up threads that are waiting for a free
    // view (so they can remap a new view). ViewWaiterCount is the number of
    //BIOS_PARAMETER_BLOCK BiosParameters;

    //
    // Disk geometry.
    //

    ULONG BytesPerSector;
    ULONG SectorsPerTrack;

    ULONG NumberOfCylinders;
    ULONG TracksPerCylinder;
    ULONG BytesPerCylinder;

    ULONG HiddenSectors;

    //
    // For file-backed RAM disks, FileName is the NT name of the backing file.
    //
        
    WCHAR FileName[1];

} DISK_EXTENSION, *PDISK_EXTENSION;

#if !defined( _UCHAR_DEFINED_ )

#define _UCHAR_DEFINED_

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//
typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src));       \
}

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src));       \
}

#define CopyU2char(Dst,Src) {                                \
    *((UNALIGNED UCHAR2 *)(Dst)) = *((UCHAR2 *)(Src));       \
}

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)((ULONG_PTR)(Src)));       \
}

#define CopyU4char(Dst, Src) {                               \
    *((UNALIGNED UCHAR4 *)(Dst)) = *((UCHAR4 *)(Src));       \
}

#endif // _UCHAR_DEFINED_

#define cOEM    8
#define cLABEL    11
#define cSYSID    8

//
//  Defines the packet and unpacked BPB structs used for extraction of geometry
//  from the boot sector of the ramdisk image
//

typedef struct _PACKED_BIOS_PARAMETER_BLOCK {
    UCHAR  BytesPerSector[2];                       //  offset = 0x000
    UCHAR  SectorsPerCluster[1];                    //  offset = 0x002
    UCHAR  ReservedSectors[2];                      //  offset = 0x003
    UCHAR  Fats[1];                                 //  offset = 0x005
    UCHAR  RootEntries[2];                          //  offset = 0x006
    UCHAR  Sectors[2];                              //  offset = 0x008
    UCHAR  Media[1];                                //  offset = 0x00A
    UCHAR  SectorsPerFat[2];                        //  offset = 0x00B
    UCHAR  SectorsPerTrack[2];                      //  offset = 0x00D
    UCHAR  Heads[2];                                //  offset = 0x00F
    UCHAR  HiddenSectors[4];                        //  offset = 0x011
    UCHAR  LargeSectors[4];                         //  offset = 0x015
    UCHAR  BigSectorsPerFat[4];                     //  offset = 0x019 25
    UCHAR  ExtFlags[2];                             //  offset = 0x01D 29
    UCHAR  FS_Version[2];                           //  offset = 0x01F 31
    UCHAR  RootDirStrtClus[4];                      //  offset = 0x021 33
    UCHAR  FSInfoSec[2];                            //  offset = 0x025 37
    UCHAR  BkUpBootSec[2];                          //  offset = 0x027 39
    UCHAR  Reserved[12];                            //  offset = 0x029 41
} PACKED_BIOS_PARAMETER_BLOCK;                      //  sizeof = 0x035 53

typedef PACKED_BIOS_PARAMETER_BLOCK *PPACKED_BIOS_PARAMETER_BLOCK;

typedef struct BIOS_PARAMETER_BLOCK {
    USHORT BytesPerSector;
    UCHAR  SectorsPerCluster;
    USHORT ReservedSectors;
    UCHAR  Fats;
    USHORT RootEntries;
    USHORT Sectors;
    UCHAR  Media;
    USHORT SectorsPerFat;
    USHORT SectorsPerTrack;
    USHORT Heads;
    ULONG  HiddenSectors;
    ULONG  LargeSectors;
    ULONG  BigSectorsPerFat;
    USHORT ExtFlags;                            
    USHORT FS_Version;                          
    ULONG  RootDirStrtClus;                     
    USHORT FSInfoSec;                           
    USHORT BkUpBootSec;  
} BIOS_PARAMETER_BLOCK;
typedef BIOS_PARAMETER_BLOCK *PBIOS_PARAMETER_BLOCK;


//
//	Macro to unpack packed bpb
//
#define UnpackBios(Bios,Pbios) {                                          \
    CopyUchar2(&((Bios)->BytesPerSector),    (Pbios)->BytesPerSector   ); \
    CopyUchar1(&((Bios)->SectorsPerCluster), (Pbios)->SectorsPerCluster); \
    CopyUchar2(&((Bios)->ReservedSectors),   (Pbios)->ReservedSectors  ); \
    CopyUchar1(&((Bios)->Fats),              (Pbios)->Fats             ); \
    CopyUchar2(&((Bios)->RootEntries),       (Pbios)->RootEntries      ); \
    CopyUchar2(&((Bios)->Sectors),           (Pbios)->Sectors          ); \
    CopyUchar1(&((Bios)->Media),             (Pbios)->Media            ); \
    CopyUchar2(&((Bios)->SectorsPerFat),     (Pbios)->SectorsPerFat    ); \
    CopyUchar2(&((Bios)->SectorsPerTrack),   (Pbios)->SectorsPerTrack  ); \
    CopyUchar2(&((Bios)->Heads),             (Pbios)->Heads            ); \
    CopyUchar4(&((Bios)->HiddenSectors),     (Pbios)->HiddenSectors    ); \
    CopyUchar4(&((Bios)->LargeSectors),      (Pbios)->LargeSectors     ); \
}

typedef struct _PACKED_EXTENDED_BIOS_PARAMETER_BLOCK {
    UCHAR  IntelNearJumpCommand[1];
    UCHAR  BootStrapJumpOffset[2];
    UCHAR  OemData[cOEM];
    PACKED_BIOS_PARAMETER_BLOCK Bpb;
    UCHAR   PhysicalDrive[1];           // 0 = removable, 80h = fixed
    UCHAR   CurrentHead[1];             // used for dirty partition info
    UCHAR   Signature[1];               // boot signature
    UCHAR   SerialNumber[4];            // volume serial number
    UCHAR   Label[cLABEL];              // volume label, padded with spaces
    UCHAR   SystemIdText[cSYSID];       // system ID, (e.g. FAT or HPFS)
    UCHAR   StartBootCode;              // first byte of boot code

} PACKED_EXTENDED_BIOS_PARAMETER_BLOCK, *PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK;

//
// Global variables.
//

extern PDEVICE_OBJECT RamdiskBusFdo;

//
// External functions implemented in ioctl.c.
//

NTSTATUS
RamdiskDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RamdiskCreateRamDisk (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN BOOLEAN AccessCheckOnly
    );

NTSTATUS
RamdiskCreateDiskDevice (
    IN PBUS_EXTENSION BusExtension,
    IN PRAMDISK_CREATE_INPUT CreateInput,
    IN BOOLEAN AccessCheckOnly,
    OUT PDISK_EXTENSION *DiskExtension
    );

NTSTATUS
RamdiskGetDriveLayout (
    PIRP Irp,
    PDISK_EXTENSION DiskExtension
    );

NTSTATUS
RamdiskGetPartitionInfo (
    PIRP Irp,
    PDISK_EXTENSION DiskExtension
    );

NTSTATUS
RamdiskSetPartitionInfo (
    PIRP Irp,
    PDISK_EXTENSION DiskExtension
    );

//
// External functions implemented in pnp.c.
//

NTSTATUS
RamdiskPnp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RamdiskPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RamdiskAddDevice (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );

BOOLEAN
CreateRegistryDisks (
    IN BOOLEAN CheckPresenceOnly
    );

//
// External functions implemented in ramdisk.c.
//

VOID
RamdiskWorkerThread (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

NTSTATUS
RamdiskFlushBuffersReal (
    IN PDISK_EXTENSION DiskExtension
    );

//
// External functions implemented in readwrite.c.
//

NTSTATUS
RamdiskReadWrite (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RamdiskReadWriteReal (
    IN PIRP Irp,
    IN PDISK_EXTENSION DiskExtension
    );

//
// External functions implemented in scsi.c.
//

NTSTATUS
RamdiskScsi (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RamdiskScsiExecuteNone (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PSCSI_REQUEST_BLOCK Srb,
    ULONG ControlCode
    );

NTSTATUS
RamdiskScsiExecuteIo (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PSCSI_REQUEST_BLOCK Srb,
    ULONG ControlCode
    );

//
// External functions implemented in utils.c.
//

NTSTATUS
SendIrpToThread (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PUCHAR
RamdiskMapPages (
    IN PDISK_EXTENSION DiskExtension,
    IN ULONGLONG Offset,
    IN ULONG RequestedLength,
    OUT PULONG ActualLength
    );

VOID
RamdiskUnmapPages (
    IN PDISK_EXTENSION DiskExtension,
    IN PUCHAR Va,
    IN ULONGLONG Offset,
    IN ULONG Length
    );

NTSTATUS
RamdiskFlushViews (
    IN PDISK_EXTENSION DiskExtension
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ramdisk\readwrite.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    readwrite.c

Abstract:

    This file contains RAM disk driver code for reading from and writing to
    a RAM disk.

Author:

    Chuck Lenzmeier (ChuckL) 2001

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

NTSTATUS
RamdiskReadWrite (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to read from or write to a
    device that we control.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PDISK_EXTENSION diskExtension;
    PIO_STACK_LOCATION irpSp;
    ULONGLONG ioOffset;
    ULONG ioLength;

    //
    // Get the device extension pointer. Get parameters from the IRP.
    //


    diskExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    ioOffset = irpSp->Parameters.Read.ByteOffset.QuadPart;
    ioLength = irpSp->Parameters.Read.Length;

    //
    // If this is not a disk PDO, we can't handle this IRP.
    //

    if ( diskExtension->DeviceType != RamdiskDeviceTypeDiskPdo ) {

        status = STATUS_INVALID_DEVICE_REQUEST;
        goto complete_irp;
    }

    DBGPRINT( DBG_READWRITE, DBG_PAINFUL,
                ("RamdiskReadWrite: offset %I64x, length %x\n", ioOffset, ioLength) );

    //
    // If it's a zero-length operation, we don't have to do anything.
    //

    if ( ioLength == 0 ) {

        status = STATUS_SUCCESS;
        goto complete_irp;
    }

    //
    // Check for invalid parameters:
    //  The transfer must be sector aligned.
    //  The length cannot cause the offset to wrap.
    //  The transfer cannot go beyond the end of the disk.
    //  Writes cannot be performed on a readonly disk.
    //

    if ( ((ioOffset | ioLength) & (diskExtension->BytesPerSector - 1)) != 0 ) {

        status = STATUS_INVALID_PARAMETER;
        goto complete_irp;
    }

    if ( (ioOffset + ioLength) < ioOffset ) {

        status = STATUS_INVALID_PARAMETER;
        goto complete_irp;
    }

    if ( (ioOffset + ioLength) > diskExtension->DiskLength ) {

        status = STATUS_NONEXISTENT_SECTOR;
        goto complete_irp;
    }

    if ( (irpSp->MajorFunction == IRP_MJ_WRITE) && diskExtension->Options.Readonly ) {

        status = STATUS_MEDIA_WRITE_PROTECTED;
        goto complete_irp;
    }

    //
    // If the RAM disk is not file-backed, then the disk image is in memory,
    // and we can do the operation regardless of what context we're in. If the
    // RAM disk is file-backed, we need to be in thread context to do the
    // operation.
    //

    if ( RAMDISK_IS_FILE_BACKED(diskExtension->DiskType) ) {

        status = SendIrpToThread( DeviceObject, Irp );
        if ( status != STATUS_PENDING ) {
            goto complete_irp;
        }
        return status;
    }

    status = RamdiskReadWriteReal(
                Irp,
                diskExtension
                 );

complete_irp:

    //
    // Complete the IRP.
    //

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_DISK_INCREMENT );

    return status;

} // RamdiskReadWrite

NTSTATUS
RamdiskReadWriteReal (
    IN PIRP Irp,
    IN PDISK_EXTENSION DiskExtension
    )

/*++

Routine Description:

    This routine is called in thread context to perform a read or a write.

Arguments:

    Irp - a pointer to the I/O Request Packet for this request

    DiskExtension - a pointer to the device extension for the target device

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PUCHAR bufferAddress;
    PUCHAR diskByteAddress;
    ULONGLONG ioOffset;
    ULONG ioLength;
    ULONG mappedLength;

    //
    // Get a system-space pointer to the user's buffer.  A system address must
    // be used because we may already have left the original caller's address
    // space.
    //

    ASSERT( Irp->MdlAddress != NULL );

    bufferAddress = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );

    if ( bufferAddress == NULL ) {

        //
        // Unable to get a pointer to the user's buffer.
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Get parameters from the IRP.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    ioOffset = irpSp->Parameters.Read.ByteOffset.QuadPart;
    ioLength = irpSp->Parameters.Read.Length;

    Irp->IoStatus.Information = 0;

    while ( ioLength != 0 ) {
    
        //
        // Map the appropriate RAM disk pages.
        //
    
        diskByteAddress = RamdiskMapPages( DiskExtension, ioOffset, ioLength, &mappedLength );
    
        if ( diskByteAddress == NULL ) {
    
            //
            // Unable to map the RAM disk.
            //
    
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        ASSERT( mappedLength <= ioLength );

        Irp->IoStatus.Information += mappedLength;
    
        //
        // Copy the data in the appropriate direction.
        //

        status = STATUS_SUCCESS;
    
        switch ( irpSp->MajorFunction ) {
        
        case IRP_MJ_READ:

            RtlCopyMemory( bufferAddress, diskByteAddress, mappedLength );
            break;
    
        case IRP_MJ_WRITE:

            RtlCopyMemory( diskByteAddress, bufferAddress, mappedLength );
            break;
    
        default:

            ASSERT( FALSE );
            status = STATUS_INVALID_PARAMETER;
            ioLength = mappedLength;
        }
    
        //
        // Unmap the previously mapped pages.
        //
    
        RamdiskUnmapPages( DiskExtension, diskByteAddress, ioOffset, mappedLength );

        ioLength -= mappedLength;
        ioOffset += mappedLength;
        bufferAddress += mappedLength;
    }

    return status;

} // RamdiskReadWriteReal
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ramdisk\utils.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This file contains utility code for the RAM disk driver.

Author:

    Chuck Lenzmeier (ChuckL) 2001

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA

#if defined(POOL_DBG)
#pragma alloc_text( INIT, RamdiskInitializePoolDebug )
#endif // POOL_DBG

#endif // ALLOC_PRAGMA

NTSTATUS
SendIrpToThread (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sends an IRP off to the worker thread so that it can be
    processed in thread context.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    None.

--*/

{
    PIO_WORKITEM workItem;

    //
    // Mark the IRP pending. Queue the IRP to a worker thread.
    //

    IoMarkIrpPending( Irp );

    workItem = IoAllocateWorkItem( DeviceObject );

    if ( workItem != NULL ) {

        //
        // Save the work item pointer so the worker thread can find it.
        //

        Irp->Tail.Overlay.DriverContext[0] = workItem;

        IoQueueWorkItem( workItem, RamdiskWorkerThread, DelayedWorkQueue, Irp );

        return STATUS_PENDING;
    }

    return STATUS_INSUFFICIENT_RESOURCES;

} // SendIrpToThread

PUCHAR
RamdiskMapPages (
    IN PDISK_EXTENSION DiskExtension,
    IN ULONGLONG Offset,
    IN ULONG RequestedLength,
    OUT PULONG ActualLength
    )

/*++

Routine Description:

    This routine maps pages of a RAM disk image into the system process.

Arguments:

    DiskExtension - a pointer to the device extension for the target device
        object

    Offset - the offset into the RAM disk image at which the mapping is to
        start

    RequestedLength - the desired length of the mapping

    ActualLength - returns the actual length of the mapping. This will be less
        than or equal to RequestedLength. If less than, the caller will need
        to call again to get the remainder of the desired range mapped.
        Because the number of available ranges may be limited, the caller
        should execute the required operation on one segment of the range and
        unmap it before mapping the next segment.

Return Value:

    PUCHAR - a pointer to the mapped space; NULL if the mapping failed

--*/

{
    NTSTATUS status;
    PUCHAR va;
    ULONGLONG diskRelativeOffset;
    ULONGLONG fileRelativeOffset;
    ULONG viewRelativeOffset;

    DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                ("RamdiskMapPages: offset %I64x, length %x\n", Offset, RequestedLength) );

    //
    // The input Offset is relative to the start of the disk image, which
    // may not be the same as the start of the file or memory block. Capture
    // Offset into diskRelativeOffset, then calculate fileRelativeOffset as
    // the offset from the start of the file or memory block.
    //

    diskRelativeOffset = Offset;
    fileRelativeOffset = DiskExtension->DiskOffset + diskRelativeOffset;

    if ( RAMDISK_IS_FILE_BACKED(DiskExtension->DiskType) ) {

        //
        // For a file-backed RAM disk, we need to map the range into memory.
        //

        while ( TRUE ) {
        
            PLIST_ENTRY listEntry;
            PVIEW view;
    
            //
            // Lock the list of view descriptors.
            //
    
            KeEnterCriticalRegion();
            ExAcquireFastMutex( &DiskExtension->Mutex );
    
            //
            // Walk the list of view descriptors. Look for one that includes the
            // start of the range we're mapping.
            //
    
            DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                        ("RamdiskMapPages: looking for matching view; file offset %I64x\n",
                        fileRelativeOffset) );

            listEntry = DiskExtension->ViewsByOffset.Flink;
    
            while ( listEntry != &DiskExtension->ViewsByOffset ) {
    
                view = CONTAINING_RECORD( listEntry, VIEW, ByOffsetListEntry );
    
                DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                            ("RamdiskMapPages: view %p; offset %I64x, length %x\n",
                                view, view->Offset, view->Length) );

                ASSERT( (view->Offset + view->Length) >= view->Offset );

                if ( (view->Offset <= fileRelativeOffset) &&
                     (view->Offset + view->Length) > fileRelativeOffset ) {
    
                    //
                    // This view includes the start of our range. Reference it.
                    //
    
                    DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                                ("RamdiskMapPages: choosing existing view %p; offset %I64x, length %x\n",
                                    view, view->Offset, view->Length) );
    
                    if ( !view->Permanent ) {
                    
                        view->ReferenceCount++;

                        DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                                    ("RamdiskMapPages: view %p; new refcount %x\n",
                                        view, view->ReferenceCount) );
        
                    } else {

                        DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                                    ("RamdiskMapPages: view %p is permanent\n", view) );
                    }

                    //
                    // Move the view to the front of the MRU list.
                    //
    
                    RemoveEntryList( &view->ByMruListEntry );
                    InsertHeadList( &DiskExtension->ViewsByMru, &view->ByMruListEntry );
    
                    ExReleaseFastMutex( &DiskExtension->Mutex );
                    KeLeaveCriticalRegion();

                    //
                    // Calculate the amount of data that the caller can look
                    // at in this range. Usually this will be the requested
                    // amount, but if the caller's offset is close to the end
                    // of a view, the caller will only be able to look at data
                    // up to the end of the view.
                    //

                    viewRelativeOffset = (ULONG)(fileRelativeOffset - view->Offset);

                    *ActualLength = view->Length - viewRelativeOffset;
                    if ( *ActualLength > RequestedLength ) {
                        *ActualLength = RequestedLength;
                    }

                    DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                                ("RamdiskMapPages: requested length %x; mapped length %x\n",
                                    RequestedLength, *ActualLength) );
                    DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                                ("RamdiskMapPages: view base %p; returned VA %p\n",
                                    view->Address,
                                    view->Address + viewRelativeOffset) );

                    //
                    // Return the virtual address corresponding to the caller's
                    // specified offset, which will usually be offset from the
                    // base of the view.
                    //

                    return view->Address + viewRelativeOffset;
                }
    
                //
                // This view does not include the start of our range. If the view
                // starts above the start of our range, then our range is not
                // currently mapped.
                //
    
                if ( view->Offset > fileRelativeOffset ) {
    
                    DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                                ("%s", "RamdiskMapPages: view too high; our range not mapped\n") );

                    break;
                }
    
                //
                // Check the next view in the list.
                //
    
                listEntry = listEntry->Flink;
            }
    
            //
            // We didn't find a view that maps the start of our range. Look for a
            // free view descriptor.
            //

            DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                        ("%s", "RamdiskMapPages: looking for free view\n") );

            listEntry = DiskExtension->ViewsByMru.Blink;
      
            while ( listEntry != &DiskExtension->ViewsByMru ) {
      
                view = CONTAINING_RECORD( listEntry, VIEW, ByMruListEntry );
      
                DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                            ("RamdiskMapPages: view %p; permanent %x, refcount %x\n",
                                view, view->Permanent, view->ReferenceCount) );

                if ( !view->Permanent && (view->ReferenceCount == 0) ) {
      
                    //
                    // This view descriptor is free. If it's currently mapped,
                    // unmap it.
                    //
      
                    PVOID mappedAddress;
                    ULONGLONG mappedOffset;
                    SIZE_T mappedLength;
      
                    DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                                ("RamdiskMapPages: view %p is free\n", view) );

                    if ( view->Address != NULL ) {
      
                        DBGPRINT( DBG_WINDOW, DBG_VERBOSE,
                                    ("RamdiskMapPages: unmapping view %p; offset %I64x, "
                                     "length %x, addr %p\n", view, view->Offset,
                                     view->Length, view->Address) );

                        MmUnmapViewOfSection( PsGetCurrentProcess(), view->Address );

                        //
                        // Reset the view descriptor and move it to the tail of
                        // the MRU list and the head of the by-offset list. We
                        // do this here in case we have to bail later (because
                        // mapping a new view fails).
                        //

                        view->Offset = 0;
                        view->Length = 0;
                        view->Address = NULL;
      
                        RemoveEntryList( listEntry );
                        InsertTailList( &DiskExtension->ViewsByMru, listEntry );

                        RemoveEntryList( &view->ByOffsetListEntry );
                        InsertHeadList( &DiskExtension->ViewsByOffset, &view->ByOffsetListEntry );
                    }
      
                    //
                    // Map a view to include the start of our range. Round the
                    // caller's offset down to the start of a view range.
                    //
      
                    mappedOffset = fileRelativeOffset & ~(ULONGLONG)(DiskExtension->ViewLength - 1);
                    mappedLength = DiskExtension->ViewLength;
                    if ( (mappedOffset + mappedLength) > DiskExtension->FileRelativeEndOfDisk) {
                        mappedLength = (SIZE_T)(DiskExtension->FileRelativeEndOfDisk - mappedOffset);
                    }
                    mappedAddress = NULL;
      
                    DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                                ("RamdiskMapPages: remapping view %p; offset %I64x, "
                                 "length %x\n", view, mappedOffset, mappedLength) );

                    status = MmMapViewOfSection(
                                DiskExtension->SectionObject,
                                PsGetCurrentProcess(),
                                &mappedAddress,
                                0,
                                0,
                                (PLARGE_INTEGER)&mappedOffset,
                                &mappedLength,
                                ViewUnmap,
                                0,
                                PAGE_READWRITE
                                );
      
                    if ( !NT_SUCCESS(status) ) {
      
                        //
                        // Unable to map the range. Inform the caller by returning
                        // NULL.
                        //
                        // ISSUE: Think about unmapping another region to see if
                        // mapping will then succeed.
                        //
      
                        DBGPRINT( DBG_WINDOW, DBG_ERROR,
                                    ("RamdiskMapPages: unable to map view: %x\n", status) );
    
                        ExReleaseFastMutex( &DiskExtension->Mutex );
                        KeLeaveCriticalRegion();
        
                        return NULL;
                    }
      
                    DBGPRINT( DBG_WINDOW, DBG_VERBOSE,
                                ("RamdiskMapPages: remapped view %p; offset %I64x, "
                                 "length %x, addr %p\n", view, mappedOffset, mappedLength,
                                 mappedAddress) );

                    //
                    // Capture the mapped range information into the view
                    // descriptor. Set the reference count to 1. Insert the
                    // view at the front of the MRU list, and at the
                    // appropriate point in the by-offset list.
                    //

                    view->Offset = mappedOffset;
                    view->Length = (ULONG)mappedLength;
                    view->Address = mappedAddress;
      
                    ASSERT( (view->Offset + view->Length) >= view->Offset );

                    view->ReferenceCount = 1;
      
                    RemoveEntryList( &view->ByMruListEntry );
                    InsertHeadList( &DiskExtension->ViewsByMru, &view->ByMruListEntry );

                    //
                    // Remove the view descriptor from its current point in
                    // the by-offset list (at or near the front, because it's
                    // currently unmapped). Scan from the tail of the by-offset
                    // list (highest offset down), looking for the first view
                    // that has an offset less than or equal to the new view.
                    // Insert the new view after that view. (If there are no
                    // views with an offset <= this one, it goes at the front
                    // of the list.)
                    //

                    RemoveEntryList( &view->ByOffsetListEntry );

                    listEntry = DiskExtension->ViewsByOffset.Blink;
            
                    while ( listEntry != &DiskExtension->ViewsByOffset ) {
            
                        PVIEW view2 = CONTAINING_RECORD( listEntry, VIEW, ByOffsetListEntry );
            
                        if ( view2->Offset <= view->Offset ) {

                            break;
                        }
            
                        listEntry = listEntry->Blink;
                    }

                    InsertHeadList( listEntry, &view->ByOffsetListEntry );

                    ExReleaseFastMutex( &DiskExtension->Mutex );
                    KeLeaveCriticalRegion();
      
                    //
                    // Calculate the amount of data that the caller can look
                    // at in this range. Usually this will be the requested
                    // amount, but if the caller's offset is close to the end
                    // of a view, the caller will only be able to look at data
                    // up to the end of the view.
                    //

                    viewRelativeOffset = (ULONG)(fileRelativeOffset - view->Offset);

                    *ActualLength = view->Length - viewRelativeOffset;
                    if ( *ActualLength > RequestedLength ) {
                        *ActualLength = RequestedLength;
                    }
      
                    DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                                ("RamdiskMapPages: requested length %x; mapped length %x\n",
                                    RequestedLength, *ActualLength) );
                    DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                                ("RamdiskMapPages: view base %p; returned VA %p\n",
                                    view->Address,
                                    view->Address + viewRelativeOffset) );
    
                    //
                    // Return the virtual address corresponding to the caller's
                    // specified offset, which will usually be offset from the
                    // base of the view.
                    //

                    return view->Address + viewRelativeOffset;
                }
      
                //
                // This view is not free. Try the previous view in the MRU list.
                //
      
                listEntry = listEntry->Blink;
            }
      
            //
            // We were unable to find a free view descriptor. Wait for one to
            // become available and start over.
            //
            // Before leaving the critical section, increment the count of
            // waiters. Then leave the critical section and wait on the
            // semaphore. The unmap code uses the waiter count to determine
            // how many times to release the semaphore. In this way, all
            // threads that are waiting or have decided to wait when the
            // unmap code runs will be awakened.
            //
      
            DiskExtension->ViewWaiterCount++;
      
            DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                        ("RamdiskMapPages: can't find free view, so waiting; new waiter count %x\n",
                            DiskExtension->ViewWaiterCount) );

            ExReleaseFastMutex( &DiskExtension->Mutex );
            KeLeaveCriticalRegion();
            
            status = KeWaitForSingleObject(
                        &DiskExtension->ViewSemaphore,
                        Executive,
                        KernelMode,
                        FALSE,
                        NULL );

            DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                        ("%s", "RamdiskMapPages: done waiting for free view\n") );
        }

    } else if ( DiskExtension->DiskType == RAMDISK_TYPE_BOOT_DISK ) {

        //
        // For a boot disk RAM disk, the image is contained in contiguous
        // reserved physical pages. Use MmMapIoSpace to get a virtual
        // address that corresponds to the physical address.
        //

        ULONG mappingSize;
        PHYSICAL_ADDRESS physicalAddress;
        PUCHAR mappedAddress;

        //
        // Determine how many pages must be mapped. Determine the base
        // physical address of the desired range. Map the range.
        //

        mappingSize = ADDRESS_AND_SIZE_TO_SPAN_PAGES(fileRelativeOffset, RequestedLength) * PAGE_SIZE;
    
        physicalAddress.QuadPart = (DiskExtension->BasePage +
                                    (fileRelativeOffset / PAGE_SIZE)) * PAGE_SIZE;
    
        mappedAddress = MmMapIoSpace( physicalAddress, mappingSize, MmCached );

        if ( mappedAddress == NULL ) {

            //
            // Unable to map the physical pages. Return NULL.
            //

            va = NULL;

        } else {

            //
            // Add the offset in the page to the returned virtual address.
            //

            va = mappedAddress + (fileRelativeOffset & (PAGE_SIZE - 1));
        }

        *ActualLength = RequestedLength;

    } else {

        //
        // For a virtual floppy RAM disk, the image is contained in contiguous
        // virtual memory. 
        //

        ASSERT( DiskExtension->DiskType == RAMDISK_TYPE_VIRTUAL_FLOPPY );

        va = (PUCHAR)DiskExtension->BaseAddress + fileRelativeOffset;

        *ActualLength = RequestedLength;
    }

    return va;

} // RamdiskMapPages

VOID
RamdiskUnmapPages (
    IN PDISK_EXTENSION DiskExtension,
    IN PUCHAR Va,
    IN ULONGLONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine unmaps previously mapped pages of a RAM disk image.

Arguments:

    DiskExtension - a pointer to the device extension for the target device
        object

    Va - the virtual address assigned to the mapping. This is unused for
        file-backed RAM disks.

    Offset - the offset into the RAM disk image at which the mapping starts

    Length - the length of the mapping

Return Value:

    None.

--*/

{
    ULONGLONG diskRelativeOffset;
    ULONGLONG fileRelativeOffset;
    ULONG viewRelativeOffset;

    //
    // The input Offset is relative to the start of the disk image, which
    // may not be the same as the start of the file or memory block. Capture
    // Offset into diskRelativeOffset, then calculate fileRelativeOffset as
    // the offset from the start of the file or memory block.
    //

    diskRelativeOffset = Offset;
    fileRelativeOffset = DiskExtension->DiskOffset + diskRelativeOffset;

    if ( RAMDISK_IS_FILE_BACKED(DiskExtension->DiskType) ) {

        //
        // For a file-backed RAM disk, we need to decrement the reference
        // count on all views that cover the specified range.
        //
        // Note: In the current implementation, no caller ever maps more
        // than one range at a time, and therefore no call to this routine
        // will need to dereference more than one view. But this routine
        // is written to allow for ranges that cover multiple views.
        //

        PLIST_ENTRY listEntry;
        PVIEW view;
        ULONGLONG rangeStart = fileRelativeOffset;
        ULONGLONG rangeEnd = fileRelativeOffset + Length;
        BOOLEAN wakeWaiters = FALSE;

        //
        // Lock the list of view descriptors.
        //

        KeEnterCriticalRegion();
        ExAcquireFastMutex( &DiskExtension->Mutex );

        //
        // Walk the list of view descriptors. For each one that includes the
        // range that we're unmapping, decrement the reference count.
        //

        listEntry = DiskExtension->ViewsByOffset.Flink;

        while ( Length != 0 ) {

            ASSERT( listEntry != &DiskExtension->ViewsByOffset );

            view = CONTAINING_RECORD( listEntry, VIEW, ByOffsetListEntry );

            DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                        ("RamdiskUnmapPages: view %p; offset %I64x, length %x\n",
                            view, view->Offset, view->Length) );

            if ( (view->Offset + view->Length) <= rangeStart ) {

                //
                // This view lies entirely below our range. Move on.
                //

                DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                            ("%s", "RamdiskMapPages: view too low; skipping\n") );

                listEntry = listEntry->Flink;

                ASSERT( listEntry != &DiskExtension->ViewsByOffset );

                continue;
            }

            //
            // This view does not lie below our range. Since the view list
            // is ordered by offset, and we have length left to unmap, this
            // view must NOT lie entirely ABOVE our range.
            //

            ASSERT( view->Offset < rangeEnd );

            //
            // Decrement the reference count for this view. If the count goes
            // to zero, we need to inform any waiters that at least one free
            // view is available.
            //
            // ISSUE: Note that unreferenced views remain mapped indefinitely.
            // We only unmap a view when we need to map a different view. If
            // a RAM disk goes idle, its views remain mapped, using up virtual
            // address space in the system process. With the current default
            // view count and length, this is 8 MB of VA. This is probably
            // not enough to make it worthwhile to implement a timer to unmap
            // idle views.
            //

            DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                        ("RamdiskUnmapPages: dereferencing view %p; offset %I64x, length %x\n",
                            view, view->Offset, view->Length) );

            if ( !view->Permanent ) {

                view->ReferenceCount--;

                if ( view->ReferenceCount == 0 ) {
                    wakeWaiters = TRUE;
                }

                DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                            ("RamdiskUnmapPages: view %p; new refcount %x\n",
                                view, view->ReferenceCount) );

            } else {

                DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                            ("RamdiskUnmapPages: view %p is permanent\n", view) );
            }

            //
            // Subtract the length of this view from the amount we're
            // unmapping. If the view fully encompasses our range, we're done.
            //

            if ( (view->Offset + view->Length) >= rangeEnd ) {

                Length = 0;

            } else {

                viewRelativeOffset = (ULONG)(fileRelativeOffset - view->Offset);
                Length -= view->Length - viewRelativeOffset;
                Offset = view->Offset + view->Length;

                ASSERT( Length != 0 );

                //
                // Move to the next view.
                //

                listEntry = listEntry->Flink;
            }
        }

        //
        // If one or more views are now free, and there are threads waiting,
        // wake them up now.
        //

        if ( wakeWaiters && (DiskExtension->ViewWaiterCount != 0) ) {

            DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                        ("RamdiskUnmapPages: waking %x waiters\n",
                            DiskExtension->ViewWaiterCount) );

            KeReleaseSemaphore(
                &DiskExtension->ViewSemaphore,
                0,
                DiskExtension->ViewWaiterCount,
                FALSE
                );

            DiskExtension->ViewWaiterCount = 0;
        }

        ExReleaseFastMutex( &DiskExtension->Mutex );
        KeLeaveCriticalRegion();

    } else if ( DiskExtension->DiskType == RAMDISK_TYPE_BOOT_DISK ) {

        //
        // For a boot disk RAM disk, use MmUnmapIoSpace to undo what
        // RamdiskMapPages did.
        //

        PUCHAR mappedAddress;
        ULONG mappingSize;

        //
        // The actual mapped address is at the base of the page given by Va.
        // The actual length of the mapping is based on the number of pages
        // covered by the range specified by Offset and Length.
        //

        mappedAddress = Va - (fileRelativeOffset & (PAGE_SIZE - 1));
        mappingSize = ADDRESS_AND_SIZE_TO_SPAN_PAGES(fileRelativeOffset, Length) * PAGE_SIZE;

        MmUnmapIoSpace( mappedAddress, mappingSize );
    }

    return;

} // RamdiskUnmapPages

NTSTATUS
RamdiskFlushViews (
    IN PDISK_EXTENSION DiskExtension
    )
{
    NTSTATUS status;
    NTSTATUS returnStatus;
    IO_STATUS_BLOCK iosb;
    PLIST_ENTRY listEntry;
    PVIEW view;
    SIZE_T viewLength;

    PAGED_CODE();

    DBGPRINT( DBG_WINDOW, DBG_PAINFUL, ("%s", "RamdiskFlushViews\n") );

    ASSERT( RAMDISK_IS_FILE_BACKED(DiskExtension->DiskType) );

    //
    // Lock the list of view descriptors.
    //

    //
    // Walk the list of view descriptors. For each one that is currently
    // mapped, flush its virtual memory to the backing file.
    //

    returnStatus = STATUS_SUCCESS;

    KeEnterCriticalRegion();
    ExAcquireFastMutex( &DiskExtension->Mutex );

    listEntry = DiskExtension->ViewsByOffset.Flink;

    while ( listEntry != &DiskExtension->ViewsByOffset ) {

        view = CONTAINING_RECORD( listEntry, VIEW, ByOffsetListEntry );

        DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                    ("RamdiskFlushViews: view %p; addr %p, offset %I64x, length %x\n",
                        view, view->Address, view->Offset, view->Length) );

        if ( view->Address != NULL ) {

            //
            // This view is mapped. Flush it.
            //

            DBGPRINT( DBG_WINDOW, DBG_PAINFUL,
                        ("%s", "RamdiskMapPages: view mapped; flushing\n") );

            viewLength = view->Length;

            status = ZwFlushVirtualMemory(
                        NtCurrentProcess(),
                        &view->Address,
                        &viewLength,
                        &iosb
                        );

            if ( NT_SUCCESS(status) ) {
                status = iosb.Status;
            }

            if ( !NT_SUCCESS(status) ) {

                DBGPRINT( DBG_WINDOW, DBG_ERROR,
                            ("RamdiskFlushViews: ZwFlushVirtualMemory failed: %x\n", status) );

                if ( returnStatus == STATUS_SUCCESS ) {
                    returnStatus = status;
                }
            }
        }

        //
        // Move to the next view.
        //

        listEntry = listEntry->Flink;
    }

    ExReleaseFastMutex( &DiskExtension->Mutex );
    KeLeaveCriticalRegion();

    return returnStatus;

} // RamdiskFlushViews

//
// Pool allocation debugging code.
//

#if defined(POOL_DBG)

//
// Allocations owned by the driver (both allocated by and deallocated by the
// driver) have the following header.
//

typedef struct _MY_POOL {
    union {
        CHAR Signature[8];
        ULONG SigLong[2];
    } ;
    LIST_ENTRY ListEntry;
    PVOID File;
    ULONG Line;
    POOL_TYPE Type;
} MY_POOL, *PMY_POOL;

#define MY_SIGNATURE "RaMdIsK"

LIST_ENTRY RamdiskNonpagedPoolList;
LIST_ENTRY RamdiskPagedPoolList;
FAST_MUTEX RamdiskPoolMutex;
KSPIN_LOCK RamdiskPoolSpinLock;

VOID
RamdiskInitializePoolDebug (
    VOID
    )
{
    InitializeListHead( &RamdiskNonpagedPoolList );
    InitializeListHead( &RamdiskPagedPoolList );
    ExInitializeFastMutex( &RamdiskPoolMutex );
    KeInitializeSpinLock( &RamdiskPoolSpinLock );

    return;

} // RamdiskInitializePoolDebug

PVOID
RamdiskAllocatePoolWithTag (
    POOL_TYPE PoolType,
    SIZE_T Size,
    ULONG Tag,
    LOGICAL Private,
    PCHAR File,
    ULONG Line
    )
{
    PMY_POOL myPool;
    KIRQL oldIrql;
    HRESULT result;

    if ( !Private ) {

        //
        // This is not a private allocation (it will be deallocated by some
        // other piece of code). We can't put a header on it.
        //

        myPool = ExAllocatePoolWithTag( PoolType, Size, Tag );

        DBGPRINT( DBG_POOL, DBG_PAINFUL,
                    ("Allocated %d bytes at %p for %s/%d\n", Size, myPool + 1, File, Line) );

        return myPool;
    }

    //
    // Allocate the requested space plus room for our header.
    //

    myPool = ExAllocatePoolWithTag( PoolType, sizeof(MY_POOL) + Size, Tag );

    if ( myPool == NULL ) {
        return NULL;
    }

    //
    // Fill in the header.
    //

    result = StringCbCopyA( myPool->Signature, sizeof( myPool->Signature ), MY_SIGNATURE );
    ASSERT( result == S_OK );

    myPool->File = File;
    myPool->Line = Line;
    myPool->Type = PoolType;

    //
    // Link the block into the appropriate list. If nonpaged pool, we must use
    // a spin lock to guard the list, because deallocation might happen at
    // raised IRQL. The paged pool list can be guarded by a mutex.
    //
    // NB: BASE_POOL_TYPE_MASK is defined in ntos\inc\pool.h.
    //

#define BASE_POOL_TYPE_MASK 1

    if ( (PoolType & BASE_POOL_TYPE_MASK) == NonPagedPool ) {

        KeAcquireSpinLock( &RamdiskPoolSpinLock, &oldIrql );

        InsertTailList( &RamdiskNonpagedPoolList, &myPool->ListEntry );

        KeReleaseSpinLock( &RamdiskPoolSpinLock, oldIrql );

    } else {

        KeEnterCriticalRegion();
        ExAcquireFastMutex( &RamdiskPoolMutex );

        InsertTailList( &RamdiskPagedPoolList, &myPool->ListEntry );

        ExReleaseFastMutex( &RamdiskPoolMutex );
        KeLeaveCriticalRegion();
    }

    //
    // Return a pointer to the caller's area, not to our header.
    //

    DBGPRINT( DBG_POOL, DBG_PAINFUL,
                ("Allocated %d bytes at %p for %s/%d\n", Size, myPool + 1, File, Line) );

    return myPool + 1;

} // RamdiskAllocatePoolWithTag

VOID
RamdiskFreePool (
    PVOID Address,
    LOGICAL Private,
    PCHAR File,
    ULONG Line
    )
{
    PMY_POOL myPool;
    PLIST_ENTRY list;
    PLIST_ENTRY listEntry;
    LOGICAL found;
    KIRQL oldIrql;

    //
    // The following line is here to get PREfast to stop complaining about the
    // call to KeReleaseSpinLock using an uninitialized variable.
    //

    oldIrql = 0;

    DBGPRINT( DBG_POOL, DBG_PAINFUL,
                ("Freeing pool at %p for %s/%d\n", Address, File, Line) );

    if ( !Private ) {

        //
        // This is not a private allocation (it was allocated by some other
        // piece of code). It doesn't have our header.
        //

        ExFreePool( Address );
        return;
    }

    //
    // Get the address of our header. Check that the header has our signature.
    //

    myPool = (PMY_POOL)Address - 1;

    if ( strcmp( myPool->Signature, MY_SIGNATURE ) != 0 ) {

        DbgPrint( "%s", "RAMDISK: Attempt to free pool block not owned by ramdisk.sys!!!\n" );
        DbgPrint( "  address: %p, freeing file: %s, line: %d\n", Address, File, Line );
        ASSERT( FALSE );

        //
        // Since it doesn't look like our header, assume that it wasn't
        // really a private allocation.
        //

        ExFreePool( Address );
        return;

    }

    //
    // Remove the block from the allocation list. First, acquire the
    // appropriate lock.
    //

    if ( (myPool->Type & BASE_POOL_TYPE_MASK) == NonPagedPool ) {

        list = &RamdiskNonpagedPoolList;

        KeAcquireSpinLock( &RamdiskPoolSpinLock, &oldIrql );

    } else {

        list = &RamdiskPagedPoolList;

        KeEnterCriticalRegion();
        ExAcquireFastMutex( &RamdiskPoolMutex );
    }

    //
    // Search the list for this block.
    //

    found = FALSE;

    for ( listEntry = list->Flink;
          listEntry != list;
          listEntry = listEntry->Flink ) {

        if ( listEntry == &myPool->ListEntry ) {

            //
            // Found this block. Remove it from the list and leave the loop.
            //

            RemoveEntryList( listEntry );
            found = TRUE;
            break;
        }
    }

    //
    // Release the lock.
    //

    if ( (myPool->Type & BASE_POOL_TYPE_MASK) == NonPagedPool ) {
    
        KeReleaseSpinLock( &RamdiskPoolSpinLock, oldIrql );

    } else {

        ExReleaseFastMutex( &RamdiskPoolMutex );
        KeLeaveCriticalRegion();
    }

    if ( !found ) {

        //
        // Didn't find the block in the list. Complain.
        //

        DbgPrint( "%s", "RAMDISK: Attempt to free pool block not in allocation list!!!\n" );
        DbgPrint( "  address: %p, freeing file: %s, line: %d\n", myPool, File, Line );
        DbgPrint( "  allocating file: %s, line: %d\n", myPool->File, myPool->Line );
        ASSERT( FALSE );
    }

    //
    // Free the pool block.
    //

    ExFreePool( myPool );

    return;

} // RamdiskFreePool

#endif // defined(POOL_DBG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rbclib\rbc.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       rbc.c
//
//--------------------------------------------------------------------------

#include "wdm.h"
#include "ntddstor.h"
#include "rbc.h"


NTSTATUS
Rbc_Scsi_Conversion(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PSCSI_REQUEST_BLOCK *OriginalSrb,
    IN PMODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE RbcHeaderAndPage,
    IN BOOLEAN OutgoingRequest,
    IN BOOLEAN RemovableMedia
    )
/*++

Routine Description:

    It translates scsi commands to their RBC equivalents, ONLY if they differ in each spec
    The translation is done before request is issued and in some cases, after the request is
    completed.
    On requests that have been completed it will check the Original Cdb (must be passed in)
    and try to use information from the RBC device parameters page, the caller retrieved
    prior to this call, from the device, and make up SCSI_MODE pages requested in the original
    request
    On request that are outgoing, the function will determine if it needs to save the original
    cdb and completely replace it with an RBC equivalent. In that case it will return a pointer
    to pool, allocated as aplaceholder for the original cdb, that the caller must free, after
    the request is complete..

Arguments:

    DeviceExtension - Sbp2 extension
    Srb - Pointer To scsi request block.
    DeviceParamsPage - Used only on completed requests. Contains device RBC single mode page
    OutgoingRequest - IF set to TRUE, this srb has not been issued yet

Return Value:

--*/


{
    BOOLEAN wcd;
    UCHAR pageCode;
    PCDB_RBC cdbRbc;
    PCDB cdb;

    PMODE_PARAMETER_HEADER modeHeader=NULL;
    PMODE_PARAMETER_BLOCK blockDescriptor;

    PMODE_CACHING_PAGE cachePage;
    ULONG modeHeaderLength ;
    ULONG availLength;

    NTSTATUS status = STATUS_PENDING;

    if (!OutgoingRequest) {

        //
        // completed request translation
        //
        
        if (*OriginalSrb) {

            cdb = (PCDB) &(*OriginalSrb)->Cdb[0];

        } else {

            cdb = (PCDB) &Srb->Cdb[0];
        }

        //
        // If there was an error then unwind any MODE_SENSE hacks
        //

        if (Srb->SrbStatus != SRB_STATUS_SUCCESS) {

            if (*OriginalSrb != NULL  &&

                cdb->CDB10.OperationCode == SCSIOP_MODE_SENSE) {

                if ((*OriginalSrb)->OriginalRequest !=
                        ((PIRP) Srb->OriginalRequest)->MdlAddress) {

                    IoFreeMdl (((PIRP) Srb->OriginalRequest)->MdlAddress);

                    ((PIRP) Srb->OriginalRequest)->MdlAddress =
                        (*OriginalSrb)->OriginalRequest;

                    Srb->DataBuffer = (*OriginalSrb)->DataBuffer;

                    Srb->DataTransferLength =
                        cdb->MODE_SENSE.AllocationLength;
                }

                // NOTE: *OriginalSrb will be freed by caller
            }

            return STATUS_UNSUCCESSFUL;
        }


        modeHeaderLength = sizeof(MODE_PARAMETER_HEADER)+sizeof(MODE_PARAMETER_BLOCK);

        switch (cdb->CDB10.OperationCode) {

        case SCSIOP_MODE_SENSE:

            if (cdb->MODE_SENSE.PageCode != MODE_PAGE_RBC_DEVICE_PARAMETERS) {

                if (*OriginalSrb == NULL) {

                    return STATUS_UNSUCCESSFUL;
                }

                //
                // If we used the RbcHeaderAndPage buffer then free the
                // mdl we alloc'd & restore the original mdl & data buf addrs
                //
                // Else copy the data returned in the original buffer to
                // the RbcHeaderandPage buffer so we can safely reference
                // it while munging
                //

                if (((PIRP) Srb->OriginalRequest)->MdlAddress !=
                        (*OriginalSrb)->OriginalRequest) {

                    IoFreeMdl (((PIRP) Srb->OriginalRequest)->MdlAddress);

                    ((PIRP) Srb->OriginalRequest)->MdlAddress =
                        (*OriginalSrb)->OriginalRequest;

                    Srb->DataBuffer = (*OriginalSrb)->DataBuffer;

                } else {

                    RtlCopyMemory(
                         RbcHeaderAndPage,
                         Srb->DataBuffer,
                         sizeof (*RbcHeaderAndPage)
                         );
                }

                availLength = cdb->MODE_SENSE.AllocationLength;
                Srb->DataTransferLength = availLength;

                //
                // Put back together the data the class driver expects to get
                // from the RBC device. IF it requested for 0x3f all pages,
                // we need to make block descriptors...
                //

                if (cdb->MODE_SENSE.Dbd == 0) {

                    //
                    // make mode header and block...
                    //

                    if (availLength >= modeHeaderLength) {

                        modeHeader = (PMODE_PARAMETER_HEADER) Srb->DataBuffer;
                        modeHeader->BlockDescriptorLength = sizeof(MODE_PARAMETER_BLOCK);
                        modeHeader->MediumType = 0x00;
                        modeHeader->ModeDataLength = 0 ;

                        //
                        // This means we have a removable medium otherwise
                        // all bits are 0
                        //

                        modeHeader->DeviceSpecificParameter =
                            (RbcHeaderAndPage->Page.WriteDisabled) << 7;
                        
                        modeHeader->DeviceSpecificParameter |=
                            (!RbcHeaderAndPage->Page.WriteCacheDisable) << 4;

                        //
                        // make the parameter block
                        //

                        blockDescriptor = (PMODE_PARAMETER_BLOCK)modeHeader;
                        (ULONG_PTR)blockDescriptor += sizeof(MODE_PARAMETER_HEADER);

                        blockDescriptor->DensityCode    = 0x00;
                        blockDescriptor->BlockLength[2] =
                            RbcHeaderAndPage->Page.LogicalBlockSize[1]; //LSB
                        blockDescriptor->BlockLength[1] =
                            RbcHeaderAndPage->Page.LogicalBlockSize[0]; //MSB
                        blockDescriptor->BlockLength[0] = 0;

                        RtlCopyMemory(
                            &blockDescriptor->NumberOfBlocks[0],
                            &RbcHeaderAndPage->Page.NumberOfLogicalBlocks[2],
                            3
                            ); //LSB

                        //
                        // put in the returned data a bunch of mode pages...
                        //

                        availLength -= modeHeaderLength;
                    }
                }

                //
                // right now i only support cache page.
                // add here support for more pages...
                //

                if ((availLength >= sizeof(MODE_CACHING_PAGE)) && ((cdb->MODE_SENSE.PageCode == 0x3f) ||
                    (cdb->MODE_SENSE.PageCode == MODE_PAGE_CACHING))){

                    availLength -= sizeof(MODE_CACHING_PAGE);

                    //
                    // create cache page..
                    //

                    if (modeHeader) {

                        modeHeader->ModeDataLength += sizeof(MODE_CACHING_PAGE);
                        cachePage = (PMODE_CACHING_PAGE)blockDescriptor;
                        (ULONG_PTR)cachePage += sizeof(MODE_PARAMETER_BLOCK);

                    } else {

                        cachePage = (PMODE_CACHING_PAGE)Srb->DataBuffer;
                    }

                    RtlZeroMemory(&cachePage->DisablePrefetchTransfer[0],sizeof(MODE_CACHING_PAGE));

                    cachePage->PageCode = MODE_PAGE_CACHING;
                    cachePage->PageLength = sizeof(MODE_CACHING_PAGE);

                    cachePage->WriteCacheEnable = (!RbcHeaderAndPage->Page.WriteCacheDisable);
                    cachePage->PageSavable = 1;
                    cachePage->WriteRetensionPriority = 0;
                    cachePage->ReadRetensionPriority = 0;
                    cachePage->MultiplicationFactor = 0;
                    cachePage->ReadDisableCache = 0;
                }
            }

            break;

        case SCSIOP_MODE_SELECT:

            if (Srb->DataTransferLength ==
                    sizeof(MODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE)) {

                RbcHeaderAndPage->Page.WriteCacheDisable =
                    ((PMODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE)
                        Srb->DataBuffer)->Page.WriteCacheDisable;
            }

            break;
        }

    } else {

        //
        // outgoing request translation
        //

        modeHeaderLength = sizeof(MODE_PARAMETER_HEADER)+sizeof(MODE_PARAMETER_BLOCK);
        cdbRbc = (PCDB_RBC)Srb->Cdb;
        cdb = (PCDB)Srb->Cdb;

        switch (cdb->CDB10.OperationCode) {

        case SCSIOP_START_STOP_UNIT:

            if (cdbRbc->START_STOP_RBC.Start) {

                //
                // power on
                //

                cdbRbc->START_STOP_RBC.PowerConditions = START_STOP_RBC_POWER_CND_ACTIVE;

            } else {

                cdbRbc->START_STOP_RBC.PowerConditions = START_STOP_RBC_POWER_CND_STANDBY;

            }

            if (cdbRbc->START_STOP_RBC.LoadEject) {

                cdbRbc->START_STOP_RBC.PowerConditions = 0;

            }

            break;

        case SCSIOP_MODE_SELECT:

            cdb->MODE_SELECT.PFBit = 1;
            cdb->MODE_SELECT.SPBit = 1;

            //
            // we need to ficure out what page is the driver trying to write, check if that page
            // has relevant bits that need to be changed in the single RBC page, the change this
            // mode select to actually write the RBC mode page..
            //

            cachePage = (PMODE_CACHING_PAGE) Srb->DataBuffer;
            (ULONG_PTR)cachePage += modeHeaderLength;

            //
            // the length of the request has to change also, however the RBC page
            // is always less than the size of the header blocks + any scsi mode page..
            //

            if (Srb->DataTransferLength >=
                    sizeof(MODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE)) {

                pageCode = cachePage->PageCode;

                if (pageCode == MODE_PAGE_CACHING) {

                    wcd = !cachePage->WriteCacheEnable;
                }

                cdb->MODE_SELECT.ParameterListLength = (UCHAR)
                    (Srb->DataTransferLength =
                        sizeof(MODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE));

                RtlCopyMemory(
                    Srb->DataBuffer,
                    RbcHeaderAndPage,
                    sizeof(MODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE)
                    );

                modeHeader = (PMODE_PARAMETER_HEADER) Srb->DataBuffer;

                modeHeader->ModeDataLength          =       // per SPC-2
                modeHeader->MediumType              =       // per RBC
                modeHeader->DeviceSpecificParameter =       // per RBC
                modeHeader->BlockDescriptorLength   = 0;    // per RBC

                if (pageCode == MODE_PAGE_CACHING) {

                    ((PMODE_RBC_DEVICE_PARAMETERS_HEADER_AND_PAGE) modeHeader)
                        ->Page.WriteCacheDisable = wcd;
                }
            }

            break;

        case SCSIOP_MODE_SENSE:

            //
            // mode senses are complicated since RBC differs ALOT from scsi.
            // We have to save the original cdb, requst fromt he device the RBC mode page
            // then upon succesful completion, re-create the data, the class drivers expect.
            //

            if (cdb->MODE_SENSE.PageCode != MODE_PAGE_RBC_DEVICE_PARAMETERS) {

                //
                // RBC devices only support requests for the RBC dev params
                // page, so we need to convert any other page requests
                //

                if (!RemovableMedia &&
                    Srb->DataTransferLength == (sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_PARAMETER_BLOCK))) {

                    //
                    // They just want the mode header and mode block, so
                    // fill it in here from our cached RBC page
                    //

                    modeHeader = (PMODE_PARAMETER_HEADER) Srb->DataBuffer;
                    modeHeader->BlockDescriptorLength = sizeof(MODE_PARAMETER_BLOCK);
                    modeHeader->MediumType = 0x00;
                    modeHeader->ModeDataLength = 0 ;

                    //
                    // this means we have a removable medium otherwise all bits are 0
                    //

                    modeHeader->DeviceSpecificParameter =
                        RbcHeaderAndPage->Page.WriteDisabled << 7;
                    
                    modeHeader->DeviceSpecificParameter |=
                        (!RbcHeaderAndPage->Page.WriteCacheDisable) << 4;

                    //
                    // make the parameter block
                    //

                    blockDescriptor = (PMODE_PARAMETER_BLOCK)modeHeader;
                    (ULONG_PTR)blockDescriptor += sizeof(MODE_PARAMETER_HEADER);

                    blockDescriptor->DensityCode = 0x00;
                    blockDescriptor->BlockLength[2] =
                        RbcHeaderAndPage->Page.LogicalBlockSize[1]; //LSB
                    blockDescriptor->BlockLength[1] =
                        RbcHeaderAndPage->Page.LogicalBlockSize[0]; //MSB
                    blockDescriptor->BlockLength[0] = 0;

                    RtlCopyMemory(
                        &blockDescriptor->NumberOfBlocks[0],
                        &RbcHeaderAndPage->Page.NumberOfLogicalBlocks[2],
                        3
                        ); //LSB

                    status = STATUS_SUCCESS;

                } else {

                    //
                    // Allocate an intermediate srb that we can store some
                    // of the original request info in
                    //

                    *OriginalSrb = ExAllocatePoolWithTag(
                        NonPagedPool,
                        sizeof (**OriginalSrb),
                        '2pbs'
                        );
        
                    if (*OriginalSrb == NULL) {

                        return STATUS_INSUFFICIENT_RESOURCES;
                    }

                    //
                    // If the data buffer isn't large enough to contain the
                    // rbc header & page then we'll use the passed-in
                    // RbcHeaderAndPage buffer to retreive the data
                    //

                    (*OriginalSrb)->OriginalRequest =
                        ((PIRP) Srb->OriginalRequest)->MdlAddress;

                    if (Srb->DataTransferLength < sizeof (*RbcHeaderAndPage)) {

                        ((PIRP) Srb->OriginalRequest)->MdlAddress =
                            IoAllocateMdl(
                                RbcHeaderAndPage,
                                sizeof (*RbcHeaderAndPage),
                                FALSE,
                                FALSE,
                                NULL
                                );

                        if (((PIRP) Srb->OriginalRequest)->MdlAddress ==NULL) {

                            ExFreePool (*OriginalSrb);
                            *OriginalSrb = NULL;

                            return STATUS_INSUFFICIENT_RESOURCES;
                        }

                        MmBuildMdlForNonPagedPool(
                            ((PIRP) Srb->OriginalRequest)->MdlAddress
                            );

                        (*OriginalSrb)->DataBuffer = Srb->DataBuffer;

                        Srb->DataBuffer = RbcHeaderAndPage;
                    }

                    //
                    // Save the original cdb values
                    //

                    RtlCopyMemory ((*OriginalSrb)->Cdb, cdb, Srb->CdbLength);

                    //
                    // Now munge the cdb as needed to get the rbc header & page
                    //

                    cdb->MODE_SENSE.Dbd = 1;
                    cdb->MODE_SENSE.PageCode = MODE_PAGE_RBC_DEVICE_PARAMETERS;

                    cdb->MODE_SENSE.AllocationLength = (UCHAR)
                    (Srb->DataTransferLength = sizeof(*RbcHeaderAndPage));
                }
            }

            break;
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ramdisk\scsi.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    scsi.c

Abstract:

    This file contains RAM disk driver code for processing SCSI commands.

Author:

    Chuck Lenzmeier (ChuckL) 2001

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Local functions.
//

NTSTATUS
Do6ByteCdbCommand (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PSCSI_REQUEST_BLOCK Srb
    );

NTSTATUS
Do10ByteCdbCommand (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN OUT PSCSI_REQUEST_BLOCK Srb
    );

NTSTATUS
Do12ByteCdbCommand (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PSCSI_REQUEST_BLOCK Srb
    );

NTSTATUS
BuildInquiryData (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PSCSI_REQUEST_BLOCK Srb
    );

NTSTATUS
BuildModeSenseInfo (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PSCSI_REQUEST_BLOCK Srb
    );

//
// Declare pageable routines.
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, RamdiskScsiExecuteNone )
#pragma alloc_text( PAGE, RamdiskScsiExecuteIo )
#pragma alloc_text( PAGE, Do6ByteCdbCommand )
#pragma alloc_text( PAGE, Do10ByteCdbCommand )
#pragma alloc_text( PAGE, Do12ByteCdbCommand )
#pragma alloc_text( PAGE, BuildInquiryData )
#pragma alloc_text( PAGE, BuildModeSenseInfo )

#endif // ALLOC_PRAGMA

NTSTATUS
RamdiskScsi (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to process a SCSI IRP.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PDISK_EXTENSION diskExtension;

    diskExtension = DeviceObject->DeviceExtension;

    //
    // ISSUE: Can't be paged because ClassCheckMediaState calls it from timer
    // routine. (For removable disks.) Therefore we can't acquire the device
    // mutex here.
    //

    //
    // Check to see if the device is being removed.
    //

    if ( diskExtension->DeviceState > RamdiskDeviceStatePendingRemove ) {

        status = STATUS_DEVICE_DOES_NOT_EXIST;
        COMPLETE_REQUEST( status, 0, Irp );
        return status;
    }

    //
    // Acquire the remove lock for the device.
    //

    status = IoAcquireRemoveLock( &diskExtension->RemoveLock, Irp );

    if ( !NT_SUCCESS(status) ) {

        DBGPRINT( DBG_PNP, DBG_ERROR, ("%s", "RamdiskScsi: acquire RemoveLock failed\n") );

        COMPLETE_REQUEST( status, 0, Irp );
        return status;
    }

    //
    // This IRP must be processed in thread context.
    //

    status = SendIrpToThread( DeviceObject, Irp );

    if ( status != STATUS_PENDING ) {

        DBGPRINT( DBG_PNP, DBG_ERROR, ("%s", "RamdiskScsi: SendIrpToThread failed\n") );

        COMPLETE_REQUEST( status, 0, Irp );
        return status;
    }

    //
    // Release the remove lock.
    //

    IoReleaseRemoveLock(&diskExtension->RemoveLock, Irp );

    return STATUS_PENDING;

} // RamdiskScsi

NTSTATUS
RamdiskScsiExecuteNone (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PSCSI_REQUEST_BLOCK Srb,
    ULONG ControlCode
    )

/*++

Routine Description:

    This routine is called by the I/O system to process a SCSI IRP that
    does not involve I/O.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

    Srb - the SRB associated with the IRP

    ControlCode - the control code from the SRB

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    UCHAR function;
    PDISK_EXTENSION diskExtension;
    
    PAGED_CODE();

    diskExtension = DeviceObject->DeviceExtension;

    //
    // Dispatch based on the SRB function.
    //

    function = Srb->Function;

    switch( function ) {
    
    case SRB_FUNCTION_ATTACH_DEVICE:
    case SRB_FUNCTION_CLAIM_DEVICE:

        DBGPRINT( DBG_SRB, DBG_VERBOSE, ("%s", "SRB_FUNCTION_CLAIM_DEVICE\n") );

        //
        // If the device has not already been claimed, mark it so now.
        // Otherwise, indicate to the caller that the device is busy.
        //

        if ( (diskExtension->Status & RAMDISK_STATUS_CLAIMED) == 0 ) {

            diskExtension->DeviceState = RamdiskDeviceStateWorking;
            diskExtension->Status |= RAMDISK_STATUS_CLAIMED;

            Srb->DataBuffer = DeviceObject;

            status = STATUS_SUCCESS;
            Srb->ScsiStatus = SCSISTAT_GOOD;
            Srb->SrbStatus = SRB_STATUS_SUCCESS;

        } else {

            status  = STATUS_DEVICE_BUSY;
            Srb->ScsiStatus = SCSISTAT_BUSY;
            Srb->SrbStatus = SRB_STATUS_BUSY;
        }

        break;

    case SRB_FUNCTION_RELEASE_DEVICE:
    case SRB_FUNCTION_REMOVE_DEVICE:

        DBGPRINT( DBG_SRB, DBG_VERBOSE, ("%s", "SRB_FUNCTION_RELEASE_DEVICE\n") );

        //
        // Indicate that the device is no longer claimed.
        //

        diskExtension->Status &= ~RAMDISK_STATUS_CLAIMED;

        status = STATUS_SUCCESS;
        Srb->ScsiStatus = SCSISTAT_GOOD;
        Srb->SrbStatus = SRB_STATUS_SUCCESS;

        break;

    default:

        //
        // Unrecognized non-I/O function. Try the I/O path.
        //

        status = RamdiskScsiExecuteIo( DeviceObject, Irp, Srb, ControlCode );

        break;
    }

    return status;

} // RamdiskScsiExecuteNone

NTSTATUS
RamdiskScsiExecuteIo (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PSCSI_REQUEST_BLOCK Srb,
    ULONG ControlCode
    )

/*++

Routine Description:

    This routine is called by the I/O system to process a SCSI IRP that
    involves I/O.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

    Srb - the SRB associated with the IRP

    ControlCode - the control code from the SRB

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    UCHAR function;
    PDISK_EXTENSION diskExtension;
    
    PAGED_CODE();

    diskExtension = DeviceObject->DeviceExtension;

    //
    // Dispatch based on the SRB function.
    //

    function = Srb->Function;

    switch( function ) {
    
    case SRB_FUNCTION_EXECUTE_SCSI:

        Srb->SrbStatus = SRB_STATUS_SUCCESS;

        //
        // Dispatch based on the CDB length.
        //
    
        switch( Srb->CdbLength ) {
        
        case 6:

            status = Do6ByteCdbCommand( DeviceObject, Srb );

            break;

        case 10:

            status = Do10ByteCdbCommand( DeviceObject, Irp, Srb );

            break;

        case 12:

            status = Do12ByteCdbCommand( DeviceObject, Srb );

            break;

        default:

            DBGPRINT( DBG_SRB, DBG_ERROR,
                        ("Unknown CDB length 0x%x for function 0x%x, IOCTL 0x%x\n",
                        Srb->CdbLength, function, ControlCode) );
            UNRECOGNIZED_IOCTL_BREAK;

            status = STATUS_INVALID_DEVICE_REQUEST;
            Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;

            break;
        }

        break;

    case SRB_FUNCTION_FLUSH:
    case SRB_FUNCTION_SHUTDOWN:

        //
        // For flush and shutdown on a file-backed RAM disk, we need to flush
        // the mapped data back to the file.
        //

        status = RamdiskFlushBuffersReal( diskExtension );
        Srb->SrbStatus = SRB_STATUS_SUCCESS;

        break;

    case SRB_FUNCTION_IO_CONTROL:

        //
        // We don't handle this function, but we don't want to complain
        // when we get it.
        //

        status = STATUS_INVALID_DEVICE_REQUEST;
        Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;

        break;

    default:

        DBGPRINT( DBG_SRB, DBG_ERROR,
                    ("Unknown SRB Function 0x%x for IOCTL 0x%x\n", function, ControlCode) );
        UNRECOGNIZED_IOCTL_BREAK;
        status = STATUS_INTERNAL_ERROR;
    }

    
    return status;

} // RamdiskScsiExecuteIo

NTSTATUS
Do6ByteCdbCommand (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine handles 6-byte CDBs.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Srb - the SRB associated with the I/O request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PDISK_EXTENSION diskExtension;
    PCDB cdb;

    PAGED_CODE();

    //
    // Get pointers to the device extension and to the CDB.
    //

    diskExtension = DeviceObject->DeviceExtension;
    cdb = (PCDB)Srb->Cdb;

    //
    // Assume success.
    //

    status = STATUS_SUCCESS;
    Srb->SrbStatus = SRB_STATUS_SUCCESS;
    Srb->ScsiStatus = SCSISTAT_GOOD;

    ASSERT( Srb->CdbLength == 6 );
    ASSERT( cdb != NULL );

    DBGPRINT( DBG_SRB, DBG_VERBOSE,
                ("Do6ByteCdbCommand Called OpCode 0x%x\n", cdb->CDB6GENERIC.OperationCode) );

    //
    // Dispatch based on the operation code.
    //

    switch ( cdb->CDB6GENERIC.OperationCode ) {
    
    case SCSIOP_TEST_UNIT_READY:

        //
        // RAM disks are always ready.
        //

        break;

    case SCSIOP_REQUEST_SENSE:

        //
        // We don't handle request sense.
        //

        Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        status = STATUS_INVALID_DEVICE_REQUEST;
        
        break;

    case SCSIOP_FORMAT_UNIT:

        // ISSUE: Need to do something here, like zero the image?

        break;

    case SCSIOP_INQUIRY:

        //
        // If the buffer is big enough, build the inquiry data.
        //

        if ( Srb->DataTransferLength >= INQUIRYDATABUFFERSIZE ) {

            status = BuildInquiryData( DeviceObject, Srb );

        } else {

            Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
            status = STATUS_INVALID_DEVICE_REQUEST;
        }

        break;

    case SCSIOP_MODE_SENSE:

        //
        // Build the mode sense information.
        //

        status = BuildModeSenseInfo( DeviceObject, Srb );
        
        break;

    case SCSIOP_MEDIUM_REMOVAL:

        //
        // Remember whether media removal is allowed.
        //

        if (cdb->MEDIA_REMOVAL.Prevent == TRUE) {
            diskExtension->Status |= RAMDISK_STATUS_PREVENT_REMOVE;
        } else {
            diskExtension->Status &= ~RAMDISK_STATUS_PREVENT_REMOVE;
        }

        break;

    //case SCSIOP_READ6:
    //case SCSIOP_WRITE6:
    //case SCSIOP_REZERO_UNIT:
    //case SCSIOP_REQUEST_BLOCK_ADDR:
    //case SCSIOP_READ_BLOCK_LIMITS:
    //case SCSIOP_REASSIGN_BLOCKS:
    //case SCSIOP_SEEK6:
    //case SCSIOP_SEEK_BLOCK:
    //case SCSIOP_PARTITION:
    //case SCSIOP_READ_REVERSE:
    //case SCSIOP_WRITE_FILEMARKS:
    //case SCSIOP_SPACE:
    //case SCSIOP_VERIFY6:
    //case SCSIOP_RECOVER_BUF_DATA:
    //case SCSIOP_MODE_SELECT:
    //case SCSIOP_RESERVE_UNIT:
    //case SCSIOP_RELEASE_UNIT:
    //case SCSIOP_COPY:
    //case SCSIOP_ERASE:
    //case SCSIOP_START_STOP_UNIT:
    //case SCSIOP_RECEIVE_DIAGNOSTIC:
    //case SCSIOP_SEND_DIAGNOSTIC:

    default:

        DBGPRINT( DBG_SRB, DBG_ERROR,
                    ("Unknown CDB Function 0x%x\n", cdb->CDB6GENERIC.OperationCode) );
        UNRECOGNIZED_IOCTL_BREAK;

        status = STATUS_INVALID_DEVICE_REQUEST;
        Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
    }

    DBGPRINT( DBG_SRB, DBG_VERBOSE, ("Do6ByteCdbCommand Done status 0x%x\n", status) );

    return status;

} // Do6ByteCdbCommand

NTSTATUS
Do10ByteCdbCommand (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp,
    IN OUT PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine handles 10-byte CDBs.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Irp - a pointer to the I/O Request Packet for this request

    Srb - the SRB associated with the IRP

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PDISK_EXTENSION diskExtension;
    PCDB cdb;
    PREAD_CAPACITY_DATA readCapacityData;
    ULONGLONG diskSize;
    ULONG lastBlock;
    FOUR_BYTE startingBlockNumber;
    TWO_BYTE count;
    ULONG_PTR offset;
    ULONG dataSize;
    PUCHAR diskByteAddress;
    PUCHAR dataBuffer;
    ULONG mappedLength;

    PAGED_CODE();

    //
    // Get pointers to the device extension and to the CDB.
    //

    diskExtension = DeviceObject->DeviceExtension;
    cdb = (PCDB)Srb->Cdb;

    //
    // Assume success.
    //

    status = STATUS_SUCCESS;
    Srb->SrbStatus = SRB_STATUS_SUCCESS;
    Srb->ScsiStatus = SCSISTAT_GOOD;

    ASSERT( Srb->CdbLength == 10 );
    ASSERT( cdb != NULL );
    
    DBGPRINT( DBG_SRB, DBG_VERBOSE,
                ("Do10ByteCdbCommand Called OpCode 0x%x\n", cdb->CDB10.OperationCode) );

    //
    // Dispatch based on the operation code.
    //

    switch ( cdb->CDB10.OperationCode ) {
    
    case SCSIOP_READ_CAPACITY:

        //
        // Return the disk's block size and last block number (big-endian).
        //

        readCapacityData = Srb->DataBuffer;

        diskSize = diskExtension->DiskLength;
        lastBlock = (ULONG)(diskSize / diskExtension->BytesPerSector) - 1;

        readCapacityData->BytesPerBlock = _byteswap_ulong( diskExtension->BytesPerSector );
        readCapacityData->LogicalBlockAddress = _byteswap_ulong( lastBlock );

        break;

    case SCSIOP_READ:
    case SCSIOP_WRITE:

        //
        // Read from or write to the disk.
        //

        //
        // Convert the transfer length, in blocks, from big-endian. Convert
        // that to bytes.
        //

        count.Byte0 = cdb->CDB10.TransferBlocksLsb;
        count.Byte1 = cdb->CDB10.TransferBlocksMsb;

        dataSize = count.AsUShort * diskExtension->BytesPerSector;

        //
        // If the CDB length is greater than the SRB length, use the SRB
        // length.
        //

        if ( dataSize > Srb->DataTransferLength ) {
            dataSize = Srb->DataTransferLength;
        }

        //
        // Convert the starting block number from big-endian. 
        //

        startingBlockNumber.Byte0 = cdb->CDB10.LogicalBlockByte3;
        startingBlockNumber.Byte1 = cdb->CDB10.LogicalBlockByte2;
        startingBlockNumber.Byte2 = cdb->CDB10.LogicalBlockByte1;
        startingBlockNumber.Byte3 = cdb->CDB10.LogicalBlockByte0;

        //
        // We don't handle RelativeAddress requests.
        //

        if ( cdb->CDB10.RelativeAddress ) {

            Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
            status = STATUS_INVALID_DEVICE_REQUEST;

            break;
        }

        //
        // Get the offset within the disk to the start of the operation.
        //

        offset = (startingBlockNumber.AsULong * diskExtension->BytesPerSector);

        //
        // If the transfer length causes the offset to wrap, or if the request
        // goes beyond the end of the disk, reject the request.
        //

        if ( ((offset + dataSize) < offset) ||
             ((offset + dataSize) > diskExtension->DiskLength) ) {

            Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
            status = STATUS_INVALID_DEVICE_REQUEST;

            break;
        }

        //
        // For a zero-length transfer, we don't have to do anything.
        //

        DBGPRINT( DBG_READWRITE, DBG_VERBOSE, 
            ("%s: Starting Block 0x%x, Length 0x%x at Offset 0x%I64x SrbBuffer=0x%p "
            "SrbLength=0x%x, MdlLength=0x%x\n",
            cdb->CDB10.OperationCode == SCSIOP_READ ? "Read" : "Write",
            startingBlockNumber.AsULong, count.AsUShort, offset, 
            Srb->DataBuffer,
            Srb->DataTransferLength,
            Irp->MdlAddress->ByteCount) );

        dataBuffer = Srb->DataBuffer;

        while ( dataSize != 0 ) {

            //
            // Map the target section of the disk into memory. Then copy the
            // data in the appropriate direction.
            //

            diskByteAddress = RamdiskMapPages( diskExtension, offset, dataSize, &mappedLength );

            if ( diskByteAddress != NULL ) {

                if ( cdb->CDB10.OperationCode == SCSIOP_READ ) {
    
                    memcpy( dataBuffer, diskByteAddress, mappedLength );
    
                } else {
    
                    memcpy( diskByteAddress, dataBuffer, mappedLength );
                }

                RamdiskUnmapPages( diskExtension, diskByteAddress, offset, mappedLength );

                dataSize -= mappedLength;
                offset += mappedLength;
                dataBuffer += mappedLength;

            } else {

                dataSize = 0;
                Srb->SrbStatus = SRB_STATUS_ERROR;
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

        }

        break;

    case SCSIOP_VERIFY:

        //
        // Verify always succeeds.
        //

        break;

    case SCSIOP_MODE_SENSE10:

        //
        // Build the mode sense information.
        //

        status = BuildModeSenseInfo( DeviceObject, Srb );

        break;

    //case SCSIOP_SEEK:
    //case SCSIOP_WRITE_VERIFY:
    //case SCSIOP_READ_FORMATTED_CAPACITY:
    //case SCSIOP_SEARCH_DATA_HIGH:
    //case SCSIOP_SEARCH_DATA_EQUAL:
    //case SCSIOP_SEARCH_DATA_LOW:
    //case SCSIOP_SET_LIMITS:
    //case SCSIOP_READ_POSITION:
    //case SCSIOP_SYNCHRONIZE_CACHE:
    //case SCSIOP_COMPARE:
    //case SCSIOP_COPY_COMPARE:
    //case SCSIOP_WRITE_DATA_BUFF:
    //case SCSIOP_READ_DATA_BUFF:
    //case SCSIOP_CHANGE_DEFINITION:
    //case SCSIOP_READ_SUB_CHANNEL:
    //case SCSIOP_READ_TOC:
    //case SCSIOP_READ_HEADER:
    //case SCSIOP_PLAY_AUDIO:
    //case SCSIOP_GET_CONFIGURATION:
    //case SCSIOP_PLAY_AUDIO_MSF:
    //case SCSIOP_PLAY_TRACK_INDEX:
    //case SCSIOP_PLAY_TRACK_RELATIVE:
    //case SCSIOP_GET_EVENT_STATUS:
    //case SCSIOP_PAUSE_RESUME:
    //case SCSIOP_LOG_SELECT:
    //case SCSIOP_LOG_SENSE:
    //case SCSIOP_STOP_PLAY_SCAN:
    //case SCSIOP_READ_DISK_INFORMATION:
    //case SCSIOP_READ_TRACK_INFORMATION:
    //case SCSIOP_RESERVE_TRACK_RZONE:
    //case SCSIOP_SEND_OPC_INFORMATION:
    //case SCSIOP_MODE_SELECT10:
    //case SCSIOP_CLOSE_TRACK_SESSION:
    //case SCSIOP_READ_BUFFER_CAPACITY:
    //case SCSIOP_SEND_CUE_SHEET:
    //case SCSIOP_PERSISTENT_RESERVE_IN:
    //case SCSIOP_PERSISTENT_RESERVE_OUT:

    default:

        DBGPRINT( DBG_SRB, DBG_ERROR,
                    ("Unknown CDB Function 0x%x\n", cdb->CDB10.OperationCode) );
        UNRECOGNIZED_IOCTL_BREAK;

        status = STATUS_INVALID_DEVICE_REQUEST;
        Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
    }

    DBGPRINT( DBG_SRB, DBG_VERBOSE, ("Do10ByteCdbCommand Done status 0x%x\n", status) );

    return status;

} // Do10ByteCdbCommand

NTSTATUS
Do12ByteCdbCommand (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine handles 12-byte CDBs.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Srb - the SRB associated with the IRP

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    NTSTATUS status;
    PDISK_EXTENSION diskExtension;
    PCDB cdb;

    PAGED_CODE();

    //
    // Get pointers to the device extension and to the CDB.
    //

    diskExtension = DeviceObject->DeviceExtension;
    cdb = (PCDB)Srb->Cdb;

    //
    // Assume success.
    //

    status = STATUS_SUCCESS;
    Srb->SrbStatus = SRB_STATUS_SUCCESS;
    Srb->ScsiStatus = SCSISTAT_GOOD;

    ASSERT( Srb->CdbLength == 12 );
    ASSERT( cdb != NULL );
    
    DBGPRINT( DBG_SRB, DBG_VERBOSE,
                ("Do12ByteCdbCommand Called OpCode 0x%x\n", cdb->CDB12.OperationCode) );

    //
    // Dispatch based on the operation code.
    //

    switch ( cdb->CDB12.OperationCode ) {
    
    //case SCSIOP_REPORT_LUNS:
    //case SCSIOP_BLANK:
    //case SCSIOP_SEND_KEY:
    //case SCSIOP_REPORT_KEY:
    //case SCSIOP_MOVE_MEDIUM:
    //case SCSIOP_LOAD_UNLOAD_SLOT:
    //case SCSIOP_SET_READ_AHEAD:
    //case SCSIOP_READ_DVD_STRUCTURE:
    //case SCSIOP_REQUEST_VOL_ELEMENT:
    //case SCSIOP_SEND_VOLUME_TAG:
    //case SCSIOP_READ_ELEMENT_STATUS:
    //case SCSIOP_READ_CD_MSF:
    //case SCSIOP_SCAN_CD:
    //case SCSIOP_SET_CD_SPEED:
    //case SCSIOP_PLAY_CD:
    //case SCSIOP_MECHANISM_STATUS:
    //case SCSIOP_READ_CD:
    //case SCSIOP_SEND_DVD_STRUCTURE:
    //case SCSIOP_INIT_ELEMENT_RANGE:

    default:

        DBGPRINT( DBG_SRB, DBG_ERROR,
                    ("Unknown CDB Function 0x%x\n", cdb->CDB12.OperationCode) );
        UNRECOGNIZED_IOCTL_BREAK;

        status = STATUS_INVALID_DEVICE_REQUEST;
        Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
    }

    DBGPRINT( DBG_SRB, DBG_VERBOSE, ("Do12ByteCdbCommand Done status 0x%x\n", status) );

    return status;

} // Do12ByteCdbCommand

NTSTATUS
BuildInquiryData (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine builds inquiry data.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Srb - the SRB associated with the I/O request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    PDISK_EXTENSION diskExtension;
    PINQUIRYDATA inquiryData;
    STRING vendor;
    STRING product;
    STRING revLevel;

    PAGED_CODE();

    //
    // Get pointers to the device extension and to the inquiry data buffer.
    //

    diskExtension = DeviceObject->DeviceExtension;
    inquiryData = (PINQUIRYDATA)Srb->DataBuffer;

    //
    // Build the inquiry data.
    //

    RtlInitString( &vendor, "Microsoft" );
    RtlInitString( &product, "Ramdisk" );
    RtlInitString( &revLevel, "1.0" );

    RtlZeroMemory( inquiryData, INQUIRYDATABUFFERSIZE );
    inquiryData->DeviceType = DIRECT_ACCESS_DEVICE;
    inquiryData->RemovableMedia = (diskExtension->Options.Fixed ? FALSE : TRUE);
    inquiryData->ANSIVersion = 2;
    inquiryData->ResponseDataFormat = 2;
    inquiryData->AdditionalLength = INQUIRYDATABUFFERSIZE - 4;

    RtlCopyMemory(
        inquiryData->VendorId,
        vendor.Buffer,
        min( vendor.Length, sizeof(inquiryData->VendorId) )
        );
    RtlCopyMemory(
        inquiryData->ProductId,
        product.Buffer,
        min( product.Length, sizeof(inquiryData->ProductId) )
        );
    RtlCopyMemory(
        inquiryData->ProductRevisionLevel,
        revLevel.Buffer,
        min( revLevel.Length, sizeof(inquiryData->ProductRevisionLevel) )
        );

    return STATUS_SUCCESS;

} // BuildInquiryData

NTSTATUS
BuildModeSenseInfo (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This routine builds mode sense information.

Arguments:

    DeviceObject - a pointer to the object that represents the device on which
        I/O is to be performed

    Srb - the SRB associated with the I/O request

Return Value:

    NTSTATUS - the status of the operation

--*/

{
    PDISK_EXTENSION diskExtension;
    MODE_PARAMETER_HEADER  modeHeader = {0};
    MODE_PARAMETER_HEADER10 modeHeader10 = {0};
    PVOID header = NULL;
    PVOID data = NULL;
    unsigned char headerSize;
    unsigned dataSize = 0;
    PCDB cdb;
    unsigned cdbLength;
    unsigned dataBufferLength;
    unsigned char valueType;    
    unsigned dataLength;

    PAGED_CODE();

    //
    // Get pointers to the device extension and to the inquiry data buffer.
    //

    diskExtension = DeviceObject->DeviceExtension;
    cdb = (PCDB)Srb->Cdb;
    cdbLength = Srb->CdbLength;

    //
    // Dispatch based on the CDB length.
    //

    switch ( cdbLength ) {
    
    case 6:

        dataBufferLength = cdb->MODE_SENSE.AllocationLength;
        valueType = cdb->MODE_SENSE.Pc;
        headerSize = sizeof(MODE_PARAMETER_HEADER);

        if ( valueType != 0 ) {

            //
            // We only support current value retrieval.
            //

            Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
            return STATUS_INVALID_DEVICE_REQUEST;
        }

        if ( dataBufferLength > headerSize ) {

            header = &modeHeader;
            data = (char*)header + headerSize;
            dataLength = headerSize - FIELD_OFFSET( MODE_PARAMETER_HEADER, MediumType );
            modeHeader.ModeDataLength = (UCHAR)dataLength;
            modeHeader.MediumType = 0x00;
            modeHeader.DeviceSpecificParameter = 0x00;
            modeHeader.BlockDescriptorLength = 0x00;
        }

        break;

    case 10:

        dataBufferLength = *(USHORT *)cdb->MODE_SENSE10.AllocationLength;
        valueType = cdb->MODE_SENSE10.Pc;
        headerSize = sizeof(MODE_PARAMETER_HEADER10);

        if ( dataBufferLength > headerSize ) {

            header = &modeHeader10;
            data = (char*)header + headerSize;
            dataLength = headerSize - FIELD_OFFSET( MODE_PARAMETER_HEADER10, MediumType );
            RtlCopyMemory(
                modeHeader10.ModeDataLength,
                &dataLength,
                sizeof(modeHeader10.ModeDataLength)
                );
            modeHeader10.MediumType = 0x00;
            modeHeader10.DeviceSpecificParameter = 0x00;
            modeHeader10.BlockDescriptorLength[0] = 0;
            modeHeader10.BlockDescriptorLength[1] = 0;
        }

        break;

    default:

        //
        // Can't get here.
        //

        ASSERT( FALSE );

        Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if ( header != NULL ) {

        RtlCopyMemory( Srb->DataBuffer, header, headerSize );
        dataBufferLength -= headerSize;
    }

    if ( (data != NULL) && (dataBufferLength != 0) ) {

        RtlCopyMemory(
            (PUCHAR)Srb->DataBuffer + headerSize,
            data,
            min( dataBufferLength, dataSize )
            );
    }

    return STATUS_SUCCESS;

} // BuildModeSenseInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\redbook\guids.c ===
/*++
Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    guids.c

Abstract:

    this file instantiates any and all GUIDs used by redbook.

Author:

    Henry Gabryjelski (henrygab)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include <objbase.h>
#include <initguid.h>
#include <ntddredb.h>
#include <wdmguid.h>

// that's all folks...
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\redbook\ioctl.c ===
/*++
Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    RedBook.c

Abstract:

Author:


Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "redbook.h"
#include "ntddredb.h"
#include "proto.h"
#include <scsi.h>      // for SetKnownGoodDrive()
#include <stdio.h>     // vsprintf()

#ifdef _USE_ETW
#include "ioctl.tmh"
#endif // _USE_ETW

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE,   RedBookCheckForDiscChangeAndFreeResources )
    #pragma alloc_text(PAGE,   RedBookCompleteIoctl                      )
    #pragma alloc_text(PAGE,   RedBookDCCheckVerify                      )
    #pragma alloc_text(PAGE,   RedBookDCDefault                          )
    #pragma alloc_text(PAGE,   RedBookDCGetVolume                        )
    #pragma alloc_text(PAGE,   RedBookDCPause                            )
    #pragma alloc_text(PAGE,   RedBookDCPlay                             )
    #pragma alloc_text(PAGE,   RedBookDCReadQ                            )
    #pragma alloc_text(PAGE,   RedBookDCResume                           )
    #pragma alloc_text(PAGE,   RedBookDCSeek                             )
    #pragma alloc_text(PAGE,   RedBookDCSetVolume                        )
    #pragma alloc_text(PAGE,   RedBookDCStop                             )
    #pragma alloc_text(PAGE,   RedBookThreadIoctlCompletionHandler       )
    #pragma alloc_text(PAGE,   RedBookThreadIoctlHandler                 )
    #pragma alloc_text(PAGE,   WhichTrackContainsThisLBA                 )
#endif // ALLOC_PRAGMA

////////////////////////////////////////////////////////////////////////////////


NTSTATUS
RedBookDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O subsystem for device controls.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{

    PREDBOOK_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation( Irp );
    ULONG cdromState;
    NTSTATUS status;

    BOOLEAN putOnQueue = FALSE;
    BOOLEAN completeRequest = FALSE;

    //
    // ioctls not guaranteed at passive, making this whole
    // section non-paged
    //

    //
    // Prevent a remove from occuring while IO pending
    //

    status = IoAcquireRemoveLock( &deviceExtension->RemoveLock, Irp );

    if ( !NT_SUCCESS(status) ) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DeviceControl !! Unable to acquire remove lock %lx\n",
                   status));
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_CD_ROM_INCREMENT );
        return status;
    }

#if DBG
    //
    // save some info for the last N device ioctls that came through
    //
    {
        ULONG index;
        ULONG sizeToCopy;
        ULONG stacksToCopy;
        PSAVED_IO savedIo;

        index = InterlockedIncrement(&deviceExtension->SavedIoCurrentIndex);
        index %= SAVED_IO_MAX;

        savedIo = &(deviceExtension->SavedIo[index]);

        //
        // copy as much of the irp as we can....
        //

        savedIo->OriginalIrp = Irp;
        if (Irp->StackCount > 7) {

            sizeToCopy = IoSizeOfIrp(8);
            RtlFillMemory(savedIo, sizeToCopy, 0xff);
            sizeToCopy -= sizeof(IO_STACK_LOCATION);
            RtlCopyMemory(savedIo, Irp, sizeToCopy);

        } else {

            sizeToCopy = IoSizeOfIrp(Irp->StackCount);
            RtlZeroMemory(savedIo, sizeof(SAVED_IO));
            RtlCopyMemory(savedIo, Irp, sizeToCopy);

        }
    } // end of saved io
#endif // DBG

    //
    // if handled, just verify the paramters in this routine.
    //

    status = STATUS_UNSUCCESSFUL;
    cdromState = GetCdromState(deviceExtension);

    switch ( currentIrpStack->Parameters.DeviceIoControl.IoControlCode ) {

        case IOCTL_CDROM_PAUSE_AUDIO: {
            if (TEST_FLAG(cdromState, CD_STOPPED)) {
                Irp->IoStatus.Information = 0;
                status = STATUS_INVALID_DEVICE_REQUEST;
                completeRequest = TRUE;
            } else {
                putOnQueue = TRUE;
            }

            break;
        }

        case IOCTL_CDROM_STOP_AUDIO: {
            if (TEST_FLAG(cdromState, CD_STOPPED)) {
                Irp->IoStatus.Information = 0;
                status = STATUS_SUCCESS;
                completeRequest = TRUE;
            } else {
                putOnQueue = TRUE;
            }
            break;
        }

        case IOCTL_CDROM_RESUME_AUDIO: {
            if (TEST_FLAG(cdromState, CD_STOPPED)) {
                Irp->IoStatus.Information = 0;
                status = STATUS_INVALID_DEVICE_REQUEST;
                completeRequest = TRUE;
            } else {
                putOnQueue = TRUE;
            }

            break;
        }

        case IOCTL_CDROM_PLAY_AUDIO_MSF: {
            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CDROM_PLAY_AUDIO_MSF)) {
                Irp->IoStatus.Information = sizeof(CDROM_PLAY_AUDIO_MSF);
                status = STATUS_BUFFER_TOO_SMALL;
                completeRequest = TRUE;
            } else {
                putOnQueue = TRUE;
            }
            break;
        }

        case IOCTL_CDROM_SEEK_AUDIO_MSF: {
            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CDROM_SEEK_AUDIO_MSF)) {
                Irp->IoStatus.Information = sizeof(CDROM_SEEK_AUDIO_MSF);
                status = STATUS_BUFFER_TOO_SMALL;
                completeRequest = TRUE;
            } else if (TEST_FLAG(cdromState, CD_STOPPED)) {
                // default -- passthrough
                // REQUIRED to reduce latency for some drives.
                // drives may still fail the request
            } else {
                putOnQueue = TRUE;
            }
            break;
        }

        case IOCTL_CDROM_READ_Q_CHANNEL: {

            PCDROM_SUB_Q_DATA_FORMAT inputBuffer;

            inputBuffer = Irp->AssociatedIrp.SystemBuffer;

            if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SUB_Q_CHANNEL_DATA)) {
                Irp->IoStatus.Information = sizeof(SUB_Q_CHANNEL_DATA);
                status = STATUS_BUFFER_TOO_SMALL;
                completeRequest = TRUE;
            } else if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength < 
                           sizeof(CDROM_SUB_Q_DATA_FORMAT)){
                Irp->IoStatus.Information = sizeof(CDROM_SUB_Q_DATA_FORMAT);
                status = STATUS_INFO_LENGTH_MISMATCH;
                completeRequest = TRUE;            
            } else if (inputBuffer->Format != IOCTL_CDROM_CURRENT_POSITION &&
                       inputBuffer->Format != IOCTL_CDROM_MEDIA_CATALOG &&
                       inputBuffer->Format != IOCTL_CDROM_TRACK_ISRC ) {
                Irp->IoStatus.Information = 0;
                status = STATUS_INVALID_PARAMETER;
                completeRequest = TRUE;
            } else if (TEST_FLAG(cdromState, CD_STOPPED)) {
                // default -- passthrough
            } else {
                putOnQueue = TRUE;
            }
            break;
        }

        case IOCTL_CDROM_SET_VOLUME: {

            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(VOLUME_CONTROL)) {
                Irp->IoStatus.Information = sizeof(VOLUME_CONTROL);
                status = STATUS_BUFFER_TOO_SMALL;
                completeRequest = TRUE;
            } else if (TEST_FLAG(cdromState, CD_STOPPED)) {
                // default -- passthrough
                // BUGBUG -- this should set our internal volume
            } else {
                putOnQueue = TRUE;
            }
            break;
        }

        case IOCTL_CDROM_GET_VOLUME: {

            if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(VOLUME_CONTROL)) {
                Irp->IoStatus.Information = sizeof(VOLUME_CONTROL);
                status = STATUS_BUFFER_TOO_SMALL;
                completeRequest = TRUE;
            } else if (TEST_FLAG(cdromState, CD_STOPPED)) {
                // default -- passthrough
                // BUGBUG -- this should return our internal volume
            } else {
                putOnQueue = TRUE;
            }
            break;
        }

        case IOCTL_STORAGE_CHECK_VERIFY2:
        case IOCTL_STORAGE_CHECK_VERIFY:
        case IOCTL_CDROM_CHECK_VERIFY:
        case IOCTL_DISK_CHECK_VERIFY: {

            if ((currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength) &&
                (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(ULONG))) {
                Irp->IoStatus.Information = sizeof(ULONG);
                status = STATUS_BUFFER_TOO_SMALL;
                completeRequest = TRUE;
            } else if (TEST_FLAG(cdromState, CD_STOPPED)) {
                // default -- passthrough
            } else {
                putOnQueue = TRUE;
            }
            break;
        }

        default: {

            if (TEST_FLAG(cdromState, CD_STOPPED)) {
                // default -- passthrough
            } else {
                putOnQueue = TRUE;
            }
            break;
        }
    }

    if (putOnQueue) {

        PREDBOOK_THREAD_IOCTL_DATA ioctlData;

        ASSERT(completeRequest == FALSE);

        //
        // need to allocate some info for each ioctl we handle
        //

        ioctlData =
            (PREDBOOK_THREAD_IOCTL_DATA)ExAllocatePoolWithTag(
                NonPagedPool,
                sizeof(REDBOOK_THREAD_IOCTL_DATA),
                TAG_T_IOCTL);
        if (ioctlData == NULL) {
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = STATUS_NO_MEMORY;
            IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
            IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            return STATUS_NO_MEMORY;
        }

        RtlZeroMemory(ioctlData, sizeof(REDBOOK_THREAD_IOCTL_DATA));
        ioctlData->Irp = Irp;
        ioctlData->Irp->IoStatus.Status = STATUS_PENDING;
        IoMarkIrpPending(ioctlData->Irp);

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DeviceControl => Queue Ioctl Irp %p (%p)\n",
                   ioctlData->Irp, ioctlData));

        //
        // queue them, allow thread to handle request
        //

        ExInterlockedInsertTailList(&deviceExtension->Thread.IoctlList,
                                    &ioctlData->ListEntry,
                                    &deviceExtension->Thread.IoctlLock);
        KeSetEvent(deviceExtension->Thread.Events[EVENT_IOCTL],
                   IO_NO_INCREMENT, FALSE);


        status = STATUS_PENDING;

    } else if (completeRequest) {

        ASSERT(putOnQueue == FALSE);

        //
        // some error, ie. invalid buffer length
        //
        if (!NT_SUCCESS(status)) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                       "DeviceControl => Completing Irp %p with error %x\n",
                       Irp, status));
        } else {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                       "DeviceControl => Completing Irp %p early?\n",
                       Irp));
        }
        Irp->IoStatus.Status = status;

        IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

    } else {

        //
        // pass it through
        //

        status = RedBookSendToNextDriver(DeviceObject, Irp);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

    }


    return status;
}
////////////////////////////////////////////////////////////////////////////////


VOID
RedBookThreadIoctlCompletionHandler(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
{
    PIO_STACK_LOCATION irpStack;
    PREDBOOK_THREAD_IOCTL_DATA ioctlData;
    ULONG state;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    ioctlData = CONTAINING_RECORD(DeviceExtension->Thread.IoctlCurrent,
                                  REDBOOK_THREAD_IOCTL_DATA,
                                  ListEntry);

    state = GetCdromState(DeviceExtension);
    irpStack = IoGetCurrentIrpStackLocation(ioctlData->Irp);

    //
    // final state should be set by the digital handler
    //

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_CDROM_PAUSE_AUDIO: {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                       "IoctlComp => Finishing pause %p\n", ioctlData->Irp));

            ASSERT(state == CD_PAUSED);

            ioctlData->Irp->IoStatus.Information = 0;
            ioctlData->Irp->IoStatus.Status = STATUS_SUCCESS;
            RedBookCompleteIoctl(DeviceExtension, ioctlData, FALSE);
            break;
        }

        case IOCTL_CDROM_SEEK_AUDIO_MSF: {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                       "IoctlComp => Finishing seek %p\n", ioctlData->Irp));

            ASSERT(state == CD_PLAYING);

            DeviceExtension->Buffer.FirstPause = 1;
            KeSetEvent(DeviceExtension->Thread.Events[EVENT_DIGITAL],
                       IO_CD_ROM_INCREMENT, FALSE);
            ioctlData->Irp->IoStatus.Information = 0;
            ioctlData->Irp->IoStatus.Status = STATUS_SUCCESS;
            RedBookCompleteIoctl(DeviceExtension, ioctlData, FALSE);
            break;
        }

        case IOCTL_CDROM_STOP_AUDIO: {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                       "IoctlComp => Finishing stop %p\n", ioctlData->Irp));

            ASSERT(TEST_FLAG(state, CD_STOPPED));

            ioctlData->Irp->IoStatus.Information = 0;
            ioctlData->Irp->IoStatus.Status = STATUS_SUCCESS;
            RedBookCompleteIoctl(DeviceExtension, ioctlData, FALSE);
            break;
        }

        default: {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                       "IoctlComp => Unhandled Irp %p\n", ioctlData->Irp));
            ASSERT(FALSE);

            ioctlData->Irp->IoStatus.Information = 0;
            ioctlData->Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
            RedBookCompleteIoctl(DeviceExtension, ioctlData, FALSE);
            break;

        }
    }

    return;
}


NTSTATUS
RedBookCompleteIoctl(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    IN PREDBOOK_THREAD_IOCTL_DATA Context,
    IN BOOLEAN SendToLowerDriver
    )
{
    PIRP irp = Context->Irp;

    //
    // only to be called from the thread
    //

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    //
    // should be properly setup for completion
    //

    if (DeviceExtension->Thread.IoctlCurrent == &Context->ListEntry) {

        //
        // an ioctl that required post-processing is finished.
        // allow the next one to occur
        //
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "CompleteIoctl => state-changing Irp %p completed\n",
                   irp));
        DeviceExtension->Thread.IoctlCurrent = NULL;

    }

    ExFreePool(Context);
    Context = NULL;

    if (SendToLowerDriver) {
        NTSTATUS status;
        status = RedBookSendToNextDriver(DeviceExtension->SelfDeviceObject, irp);
        IoReleaseRemoveLock(&DeviceExtension->RemoveLock, irp);
        return status;


    } else {
        IoCompleteRequest(irp, IO_CD_ROM_INCREMENT);
        IoReleaseRemoveLock(&DeviceExtension->RemoveLock, irp);
        return STATUS_SUCCESS;
    }
}


VOID
RedBookThreadIoctlHandler(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    IN PLIST_ENTRY ListEntry
    )
{
    PREDBOOK_THREAD_IOCTL_DATA data;
    PIO_STACK_LOCATION currentIrpStack;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    //
    // should never happen if a state-changing ioctl is in progress
    //

    ASSERT(DeviceExtension->Thread.IoctlCurrent == NULL);

    //
    // don't use stale info
    //

    RedBookCheckForDiscChangeAndFreeResources(DeviceExtension);

    //
    // get the ioctl that set this event and
    // start working on state changes neccessary
    //

    data = CONTAINING_RECORD(ListEntry, REDBOOK_THREAD_IOCTL_DATA, ListEntry);

    currentIrpStack = IoGetCurrentIrpStackLocation(data->Irp);

    //
    // now guaranteed it's ok to run this ioctl
    // it's the responsibility of these routines to call RedBookCompleteIoctl()
    // *** OR *** to set DeviceExtension->Thread.IoctlCurrent to
    // Context->ListEntry if it requires post-processing, as this
    // is the mechanism used to determine the ioctl is still inprogress
    //

    switch (currentIrpStack->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_CDROM_PLAY_AUDIO_MSF: {
            RedBookDCPlay(DeviceExtension, data);
            break;
        }

        case IOCTL_CDROM_PAUSE_AUDIO: {
            RedBookDCPause(DeviceExtension, data);
            break;
        }

        case IOCTL_CDROM_RESUME_AUDIO: {
            RedBookDCResume(DeviceExtension, data);
            break;
        }

        case IOCTL_CDROM_STOP_AUDIO: {
            RedBookDCStop(DeviceExtension, data);
            break;
        }

        case IOCTL_CDROM_SEEK_AUDIO_MSF: {
            RedBookDCSeek(DeviceExtension, data);
            break;
        }

        case IOCTL_CDROM_READ_Q_CHANNEL: {
            RedBookDCReadQ(DeviceExtension, data);
            break;
        }

        case IOCTL_CDROM_SET_VOLUME: {
            RedBookDCSetVolume(DeviceExtension, data);
            break;
        }

        case IOCTL_CDROM_GET_VOLUME: {
            RedBookDCGetVolume(DeviceExtension, data);
            break;
        }

        case IOCTL_CDROM_CHECK_VERIFY:
        case IOCTL_DISK_CHECK_VERIFY:
        case IOCTL_STORAGE_CHECK_VERIFY:
        case IOCTL_STORAGE_CHECK_VERIFY2: {
            RedBookDCCheckVerify(DeviceExtension, data);
            break;
        }

        default: {
            data->Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
            data->Irp->IoStatus.Information = 0;
            RedBookCompleteIoctl(DeviceExtension, data, TRUE);
            break;
        }
    }
    return;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


VOID
RedBookDCCheckVerify(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PIO_STACK_LOCATION currentIrpStack;
    ULONG state;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    state = GetCdromState(DeviceExtension);

    currentIrpStack = IoGetCurrentIrpStackLocation(Context->Irp);

    if (!TEST_FLAG(state, CD_PLAYING) && !TEST_FLAG(state, CD_PAUSED)) { // !handling ioctls

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCCheckVerify => not playing\n"));
        RedBookCompleteIoctl(DeviceExtension, Context, TRUE);
        return;
    }

    //
    // data buffer is optional for this ioctl
    //

    if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength) {

        *((PULONG)Context->Irp->AssociatedIrp.SystemBuffer) =
            DeviceExtension->CDRom.CheckVerify;
        Context->Irp->IoStatus.Information = sizeof(ULONG);

    } else {

        Context->Irp->IoStatus.Information = 0;

    }

    Context->Irp->IoStatus.Status = STATUS_SUCCESS;

    RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
    return;

}


VOID
RedBookDCDefault(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG state;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    state = GetCdromState(DeviceExtension);

    //
    // IOCTLs are not all guaranteed to be called at passive irql,
    // so this can never be paged code.
    // there is a window of opportunity to send an ioctl while playing
    // audio digitally, but it can be ignored.  this allows much more
    // pagable code.
    //

    if (!TEST_FLAG(state, CD_PLAYING) && !TEST_FLAG(state, CD_PAUSED)) { // !handling ioctls

        RedBookCompleteIoctl(DeviceExtension, Context, TRUE);

    } else {

        //
        // Complete the Irp
        //

        Context->Irp->IoStatus.Information = 0;
        Context->Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
        RedBookCompleteIoctl(DeviceExtension, Context, FALSE);

    }
    return;

}


VOID
RedBookDCGetVolume(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PIO_STACK_LOCATION currentIrpStack;
    NTSTATUS status;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCGetVolume => Entering %p\n", Context->Irp));

    //
    // guaranteed the volume info will not change
    //

    RtlCopyMemory(Context->Irp->AssociatedIrp.SystemBuffer, // to
                  &DeviceExtension->CDRom.Volume,  // from
                  sizeof(VOLUME_CONTROL));

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCGetVolume => volume was:"
               " (hex) %2x %2x %2x %2x\n",
               DeviceExtension->CDRom.Volume.PortVolume[0],
               DeviceExtension->CDRom.Volume.PortVolume[1],
               DeviceExtension->CDRom.Volume.PortVolume[2],
               DeviceExtension->CDRom.Volume.PortVolume[3]));

    //
    // Complete the Irp (IoStatus.Information set above)
    //

    Context->Irp->IoStatus.Information = sizeof(VOLUME_CONTROL);
    Context->Irp->IoStatus.Status = STATUS_SUCCESS;

    RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
    return;
}


VOID
RedBookDCPause(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG state;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    state = GetCdromState(DeviceExtension);

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCPause => Entering %p\n", Context->Irp));

    if (!TEST_FLAG(state, CD_PLAYING)) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCPause => Not playing\n"));
        Context->Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        Context->Irp->IoStatus.Information = 0;
        RedBookCompleteIoctl(DeviceExtension, Context, TRUE);
        return;

    }

    if (TEST_FLAG(state, CD_PAUSED)) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCPause => Already paused %p\n", Context->Irp));
        Context->Irp->IoStatus.Status = STATUS_SUCCESS;
        Context->Irp->IoStatus.Information = 0;
        RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
        return;

    } else {

        //
        // since setting to a temp state, it is not appropriate to
        // complete the irp until the operation itself completes.
        //

        ASSERT(!TEST_FLAG(state, CD_PAUSING));
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCPause => Starting pause %p\n", Context->Irp));
        DeviceExtension->Thread.IoctlCurrent = &Context->ListEntry;
        state = SetCdromState(DeviceExtension, state, state | CD_PAUSING);
        return;
    }
}


VOID
RedBookDCPlay(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PCDROM_PLAY_AUDIO_MSF     inputBuffer;
    PIO_STACK_LOCATION        thisIrpStack;
    PIO_STACK_LOCATION        nextIrpStack;
    PREVENT_MEDIA_REMOVAL     mediaRemoval;
    ULONG                     sector;
    ULONG                     i;
    ULONG                     state;
    NTSTATUS                  status;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    inputBuffer  = Context->Irp->AssociatedIrp.SystemBuffer;
    thisIrpStack = IoGetCurrentIrpStackLocation(Context->Irp);
    nextIrpStack = IoGetNextIrpStackLocation(Context->Irp);


    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCPlay => Entering %p\n", Context->Irp));

    status = RedBookCacheToc(DeviceExtension);

    if (!NT_SUCCESS(status)) {
        Context->Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        Context->Irp->IoStatus.Information = 0;
        RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
        return;
    }

    sector = MSF_TO_LBA(inputBuffer->EndingM,
                        inputBuffer->EndingS,
                        inputBuffer->EndingF);

    DeviceExtension->CDRom.EndPlay = sector;

    sector = MSF_TO_LBA(inputBuffer->StartingM,
                        inputBuffer->StartingS,
                        inputBuffer->StartingF);

    DeviceExtension->CDRom.NextToRead   = sector;
    DeviceExtension->CDRom.NextToStream = sector;
    DeviceExtension->CDRom.FinishedStreaming = sector;

    //
    // Make sure the ending sector is within disc
    // bounds or return STATUS_INVALID_DEVICE_REQUEST?
    // this will prevent success on play, followed by an
    // immediate stop.
    //

    if (0) {
        PCDROM_TOC toc = DeviceExtension->CDRom.Toc;
        LONG track;
        LONG endTrack;

        //
        // ensure end has an lba greater than start
        //

        if (DeviceExtension->CDRom.EndPlay <=
            DeviceExtension->CDRom.NextToRead) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                       "Play => End sector (%x) must be more than start "
                       "sector (%x)\n",
                       DeviceExtension->CDRom.EndPlay,
                       DeviceExtension->CDRom.NextToRead
                       ));
            Context->Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
            Context->Irp->IoStatus.Information = 0;
            RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
            return;
        }

        //
        // what track(s) are we playing?
        //

        track    = WhichTrackContainsThisLBA(toc, DeviceExtension->CDRom.NextToRead);
        endTrack = WhichTrackContainsThisLBA(toc, DeviceExtension->CDRom.EndPlay);

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "Play => Playing sector %x to %x (track %x to %x)\n",
                   DeviceExtension->CDRom.NextToRead,
                   DeviceExtension->CDRom.EndPlay,
                   track,
                   endTrack));

        //
        // make sure the tracks are actually valid
        //

        if (track    < 0   ||
            endTrack < 0   ||
            endTrack <= (toc->LastTrack - toc->FirstTrack)
            ) {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                       "Play => Track %x is invalid\n", track));
            Context->Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
            Context->Irp->IoStatus.Information = 0;
            RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
            return;

        }

        for (;track <= endTrack;track++) {
            if (toc->TrackData[track].Adr & AUDIO_DATA_TRACK) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                           "Play => Track %x is not audio\n", track));
                Context->Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
                Context->Irp->IoStatus.Information = 0;
                RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
                return;
            }
        }
    }

    //
    // if not paused, then state must equal stopped, which means we need
    // to allocate the resources.
    //

    state = GetCdromState(DeviceExtension);

    if (TEST_FLAG(state, CD_PAUSED)) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCPlay => Resuming playback?\n"));

    } else {

        //
        // this function will allocate them iff they are not
        // already allocated.
        //

        status = RedBookAllocatePlayResources(DeviceExtension);
        if (!NT_SUCCESS(status)) {
            Context->Irp->IoStatus.Status = STATUS_NO_MEMORY;
            Context->Irp->IoStatus.Information = 0;
            RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
            return;
        }

    }

    //
    // Set the new device state (thread will begin playing)
    //

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCPlay => Setting state to CD_PLAYING\n"));
    state = SetCdromState(DeviceExtension, state, CD_PLAYING);
    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCPlay => Exiting successfully\n"));

    //
    // finish the request if it's a user
    // request for a new play operation
    //

    Context->Irp->IoStatus.Status = STATUS_SUCCESS;
    Context->Irp->IoStatus.Information = 0;
    RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
    return;

}


VOID
RedBookDCReadQ(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PCDROM_SUB_Q_DATA_FORMAT inputBuffer;
    PIO_STACK_LOCATION currentIrpStack;
    UCHAR              formatCode;
    ULONG              state;
    NTSTATUS           status;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    inputBuffer = Context->Irp->AssociatedIrp.SystemBuffer;
    currentIrpStack = IoGetCurrentIrpStackLocation(Context->Irp);
    state = GetCdromState(DeviceExtension);

    if (!TEST_FLAG(state, CD_PLAYING) && !TEST_FLAG(state, CD_PAUSED)) { // !handling ioctls

        //
        // no need to handle this irp
        //

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCReadQ => Not playing\n"));
        RedBookCompleteIoctl(DeviceExtension, Context, TRUE);
        return;
    }

    if (inputBuffer->Format != IOCTL_CDROM_CURRENT_POSITION) {
        Context->Irp->IoStatus.Information = 0;
        Context->Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCReadQ => Bad Format %x\n", inputBuffer->Format));
        RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
        return;
    }

    //
    // we are in the midst of playback or pause.  fake the information
    // a real cdrom would have returned if it was playing audio at the
    // same location that we are currently at.
    //

    {
        PSUB_Q_CURRENT_POSITION outputBuffer;
        PCDROM_TOC toc;
        ULONG lbaTrack;
        ULONG lbaRelative;
        ULONG instantLba;
        UCHAR timeAbsolute[3] = {0};
        UCHAR timeRelative[3] = {0};
        LONG trackNumber;

        outputBuffer = Context->Irp->AssociatedIrp.SystemBuffer;
        RtlZeroMemory(outputBuffer,
                      currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength);

        //
        // Still playing audio
        //

        outputBuffer->Header.Reserved      = 0;
        if (TEST_FLAG(state, CD_PAUSED)) {
            outputBuffer->Header.AudioStatus = AUDIO_STATUS_PAUSED;
        } else if (TEST_FLAG(state, CD_PLAYING)) {
            outputBuffer->Header.AudioStatus = AUDIO_STATUS_IN_PROGRESS;
        } else {
            ASSERT(!"State was invalid?");
            outputBuffer->Header.AudioStatus = AUDIO_STATUS_IN_PROGRESS;
        }
        outputBuffer->Header.DataLength[0] =
            (sizeof(SUB_Q_CURRENT_POSITION) - sizeof(SUB_Q_HEADER)) >> 8;
        outputBuffer->Header.DataLength[1] =
            (sizeof(SUB_Q_CURRENT_POSITION) - sizeof(SUB_Q_HEADER)) & 0xFF;


        //
        // we are in the thread, which alloc's/dealloc's the toc
        //

        toc = DeviceExtension->CDRom.Toc;
        ASSERT(toc);

        //
        // we return the last played sector as a result per the spec
        //

        instantLba = DeviceExtension->CDRom.FinishedStreaming;

        trackNumber = WhichTrackContainsThisLBA(toc, instantLba);


        ASSERT(trackNumber >= 0);

        outputBuffer->FormatCode  = IOCTL_CDROM_CURRENT_POSITION;
        outputBuffer->Control     = toc->TrackData[trackNumber].Control;
        outputBuffer->ADR         = toc->TrackData[trackNumber].Adr;
        outputBuffer->TrackNumber = toc->TrackData[trackNumber].TrackNumber;

        //
        // Get the track's LBA
        //

        lbaTrack = MSF_TO_LBA(toc->TrackData[trackNumber].Address[1],
                              toc->TrackData[trackNumber].Address[2],
                              toc->TrackData[trackNumber].Address[3]);

        //
        // Get the current play LBA
        //

        lbaRelative = instantLba;

        //
        // Subtract the track's LBA to get the relative LBA
        //

        lbaRelative -= lbaTrack;

        //
        // Finally convert it back to MSF
        //

        LBA_TO_MSF(instantLba,
                   timeAbsolute[0],
                   timeAbsolute[1],
                   timeAbsolute[2]);
        LBA_TO_RELATIVE_MSF(lbaRelative,
                            timeRelative[0],
                            timeRelative[1],
                            timeRelative[2]);

        outputBuffer->IndexNumber             = (UCHAR)trackNumber;
        outputBuffer->AbsoluteAddress[0]      = 0;
        outputBuffer->AbsoluteAddress[1]      = timeAbsolute[0];
        outputBuffer->AbsoluteAddress[2]      = timeAbsolute[1];
        outputBuffer->AbsoluteAddress[3]      = timeAbsolute[2];

        outputBuffer->TrackRelativeAddress[0] = 0;
        outputBuffer->TrackRelativeAddress[1] = timeRelative[0];
        outputBuffer->TrackRelativeAddress[2] = timeRelative[1];
        outputBuffer->TrackRelativeAddress[3] = timeRelative[2];

        //
        // The one line debug info...
        //
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctlV, "[redbook] "
                   "ReadQ => "
                   "Trk [%#02x] Indx [%#02x] "
                   "Abs [%#02d:%#02d.%#02d] Rel [%#02d:%#02d.%#02d]\n",
                   outputBuffer->TrackNumber,
                   trackNumber,
                   timeAbsolute[0], timeAbsolute[1], timeAbsolute[2],
                   timeRelative[0], timeRelative[1], timeRelative[2]));

    }
    //
    // Complete the Irp
    //

    Context->Irp->IoStatus.Information = sizeof(SUB_Q_CURRENT_POSITION);
    Context->Irp->IoStatus.Status      = STATUS_SUCCESS;
    RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
    return;
}


VOID
RedBookDCResume(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG state;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    state = GetCdromState(DeviceExtension);

    if (!TEST_FLAG(state, CD_PLAYING) && !TEST_FLAG(state, CD_PAUSED)) { // !handling ioctls
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCResume => Not Playing\n"));
        RedBookCompleteIoctl(DeviceExtension, Context, TRUE);
        return;
    }

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCResume => Entering\n"));

    if (TEST_FLAG(state, CD_PAUSED)) {

        //
        // we need to start the resume operation
        //

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCResume => Resuming playback\n"));
        state = SetCdromState(DeviceExtension, state, CD_PLAYING);
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCResume => Resume succeeded\n"));

    } else {

        //
        // if not paused, return success
        //

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCResume => Not paused -- succeeded\n"));

    }

    //
    // always complete the Irp
    //

    Context->Irp->IoStatus.Information = 0;
    Context->Irp->IoStatus.Status = STATUS_SUCCESS;
    RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
    return;

}


VOID
RedBookDCSeek(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    )
/*++

Routine Description:

    same as a IOCTL_CDROM_STOP

Arguments:

Return Value:

--*/
{
    NTSTATUS                  status;
    ULONG                     state;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCSeek => Entering\n"));
    state = GetCdromState(DeviceExtension);

    if (!TEST_FLAG(state, CD_PLAYING) && !TEST_FLAG(state, CD_PAUSED)) { // !handling ioctls
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCSeek => Not Playing\n"));
        Context->Irp->IoStatus.Information = 0;
        Context->Irp->IoStatus.Status = STATUS_SUCCESS;
        RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
        return;
    }

    //
    // stop the stream if currently playing
    //

    if (TEST_FLAG(state, CD_PAUSED)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCSeek => Paused, setting to stopped\n"));
        state = SetCdromState(DeviceExtension, state, CD_STOPPED);
        Context->Irp->IoStatus.Information = 0;
        Context->Irp->IoStatus.Status = STATUS_SUCCESS;
        RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
        return;
    }

    //
    // since setting to a temp state, it is not appropriate to
    // complete the irp until the operation itself completes.
    //
    
    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCSeek => stopping the stream\n"));
    DeviceExtension->Thread.IoctlCurrent = &Context->ListEntry;
    state = SetCdromState(DeviceExtension, state, state | CD_STOPPING);
    return;
}


VOID
RedBookDCSetVolume(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PIO_STACK_LOCATION currentIrpStack;
    ULONG state;
    NTSTATUS status;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCSetVolume => Entering\n"));

    //
    // guaranteed the volume info will not change right now
    //

    RtlCopyMemory(&DeviceExtension->CDRom.Volume,  // to
                  Context->Irp->AssociatedIrp.SystemBuffer, // from
                  sizeof(VOLUME_CONTROL));

    state = GetCdromState(DeviceExtension);

    if (!TEST_FLAG(state, CD_PLAYING) && !TEST_FLAG(state, CD_PAUSED)) { // !handling ioctls
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCSetVolume => Not Playing\n"));
        RedBookCompleteIoctl(DeviceExtension, Context, TRUE);
        return;
    }

    //
    // not set above since don't have volume control
    //

    RedBookKsSetVolume(DeviceExtension);

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctlV, "[redbook] "
                 "DCSetVolume => volume set to:"
                 " (hex) %2x %2x %2x %2x\n",
                 DeviceExtension->CDRom.Volume.PortVolume[0],
                 DeviceExtension->CDRom.Volume.PortVolume[1],
                 DeviceExtension->CDRom.Volume.PortVolume[2],
                 DeviceExtension->CDRom.Volume.PortVolume[3]));

    //
    // Complete the Irp (IoStatus.Information set above)
    //

    Context->Irp->IoStatus.Information = 0;
    Context->Irp->IoStatus.Status = STATUS_SUCCESS;
    RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
    return;
}


VOID
RedBookDCStop(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS status;
    ULONG state;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCStop => Entering %p\n", Context->Irp));
    state = GetCdromState(DeviceExtension);

    if (!TEST_FLAG(state, CD_PLAYING) && !TEST_FLAG(state, CD_PAUSED)) { // !handling ioctls
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCStop => Stop when already stopped\n"));
        Context->Irp->IoStatus.Information = 0;
        Context->Irp->IoStatus.Status = STATUS_SUCCESS;
        RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
        return;
    }

    //
    // Still playing audio. if paused, just call the stop finish routine
    //

    if (TEST_FLAG(state, CD_PAUSED)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
                   "DCStop => Stop when paused\n"));
        state = SetCdromState(DeviceExtension, state, CD_STOPPED);
        Context->Irp->IoStatus.Information = 0;
        Context->Irp->IoStatus.Status = STATUS_SUCCESS;
        RedBookCompleteIoctl(DeviceExtension, Context, FALSE);
        return;
    }

    //
    // since setting to a temp state, it is not appropriate to
    // complete the irp until the operation itself completes.
    //

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugIoctl, "[redbook] "
               "DCStop => stopping the stream\n"));
    DeviceExtension->Thread.IoctlCurrent = &Context->ListEntry;
    state = SetCdromState(DeviceExtension, state, state | CD_STOPPING);
    return;

}
////////////////////////////////////////////////////////////////////////////////


VOID
RedBookCheckForDiscChangeAndFreeResources(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )

//
// if we've paused, and the disc has changed, don't
// want to be returning stale toc info when the player
// resumes playback.
//

{
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    PULONG count;
    ULONG state;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    //
    // only do this if we are in a PAUSED or STOPPED state
    //

    state = GetCdromState(DeviceExtension);
    if ((!TEST_FLAG(state, CD_STOPPED))  &&
        (!TEST_FLAG(state, CD_PAUSED))) {
        return;
    }

    //
    // resources might already be deallocated.
    //

    irp = DeviceExtension->Thread.CheckVerifyIrp;
    if (irp == NULL) {
        return;
    }

    irpStack = IoGetCurrentIrpStackLocation(irp);

#if DBG
    {
        //
        // the irp must be setup when it's allocated.  we rely on this.
        //

        ASSERT(irpStack->Parameters.DeviceIoControl.InputBufferLength == 0);
        ASSERT(irpStack->Parameters.DeviceIoControl.OutputBufferLength ==
               sizeof(ULONG));
        ASSERT(irpStack->Parameters.DeviceIoControl.IoControlCode ==
               IOCTL_CDROM_CHECK_VERIFY);
        ASSERT(irpStack->Parameters.DeviceIoControl.Type3InputBuffer == NULL);
        ASSERT(irp->AssociatedIrp.SystemBuffer != NULL);
    }
#endif

    count = (PULONG)(irp->AssociatedIrp.SystemBuffer);
    *count = 0;

    RedBookForwardIrpSynchronous(DeviceExtension, irp);

    if (!NT_SUCCESS(irp->IoStatus.Status) ||
        ((*count) != DeviceExtension->CDRom.CheckVerify)
        ) {

        //
        // if the count has changed set the state to STOPPED.
        // (old state is either STOPPED or PAUSED, so either one can
        //  seemlessly transition to the STOPPED state without any
        //  trouble.)
        //
        // also free currently held play resources
        //

        state = SetCdromState(DeviceExtension, state, CD_STOPPED);
        RedBookDeallocatePlayResources(DeviceExtension);

    }
    return;
}


ULONG
WhichTrackContainsThisLBA(
    PCDROM_TOC Toc,
    ULONG Lba
    )
//
// returns -1 if not found
//
{
    LONG trackNumber;
    UCHAR msf[3] = {0};

    PAGED_CODE();

    LBA_TO_MSF(Lba, msf[0], msf[1], msf[2]);

    for (trackNumber = Toc->LastTrack - Toc->FirstTrack;
         trackNumber >= 0;
         trackNumber-- ) {

        //
        // we have found the track if
        // Minutes is less or
        // Minutes is equal and Seconds is less or
        // Minutes and Seconds are equal Frame is less or
        // Minutes, Seconds, and Frame are equal
        //
        // the compiler optimizes this nicely.
        //

        if (Toc->TrackData[trackNumber].Address[1] < msf[0] ) {
            break;
        } else
        if (Toc->TrackData[trackNumber].Address[1] == msf[0] &&
            Toc->TrackData[trackNumber].Address[2] <  msf[1] ) {
            break;
        } else
        if (Toc->TrackData[trackNumber].Address[1] == msf[0] &&
            Toc->TrackData[trackNumber].Address[2] == msf[1] &&
            Toc->TrackData[trackNumber].Address[3] <  msf[2] ) {
            break;
        } else
        if (Toc->TrackData[trackNumber].Address[1] == msf[0] &&
            Toc->TrackData[trackNumber].Address[2] == msf[1] &&
            Toc->TrackData[trackNumber].Address[3] == msf[2] ) {
            break;
        }
    }

    return trackNumber;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\redbook\errlog.c ===
/*++

Copyright (C) 1991-8  Microsoft Corporation

Module Name:

    errlog.c

Abstract:

    this module provides error logging capabilities for
    the redbook driver

Author:

    Henry Gabryjelski (henrygab) 1-Oct-1998

Environment:

    kernel mode only

Notes:

Revision History:

--*/


#include "redbook.h"
#include "proto.h"

#ifdef _USE_ETW
#include "errlog.tmh"
#endif // _USE_ETW


VOID
RedBookLogError(
   IN  PREDBOOK_DEVICE_EXTENSION  DeviceExtension,
   IN  NTSTATUS                   IoErrorCode,
   IN  NTSTATUS                   FinalStatus
   )
/*++

Routine Description:

    This routine performs error logging for the redbook driver.

Arguments:

    Extension        - Extension.
    UniqueErrorValue - Values defined to uniquely identify error location.

Return Value:

    None

--*/

{
    PIO_ERROR_LOG_PACKET    errorLogPacket;
    ULONG                   count;
    ULONG                   rCount;
    USHORT                  simpleCode;
    ULONG                   packetSize;

    count  = InterlockedIncrement(&DeviceExtension->ErrorLog.Count);
    simpleCode = (USHORT)(IoErrorCode & REDBOOK_ERR_MASK);

    ASSERT(simpleCode < REDBOOK_ERR_MAXIMUM);

    switch (IoErrorCode) {
        case REDBOOK_ERR_TOO_MANY_READ_ERRORS:
        case REDBOOK_ERR_TOO_MANY_STREAM_ERRORS:
        case REDBOOK_ERR_CANNOT_OPEN_SYSAUDIO_MIXER:
        case REDBOOK_ERR_CANNOT_CREATE_VIRTUAL_SOURCE:
        case REDBOOK_ERR_CANNOT_OPEN_PREFERRED_WAVEOUT_DEVICE:
        case REDBOOK_ERR_CANNOT_GET_NUMBER_OF_PINS:
        case REDBOOK_ERR_CANNOT_CONNECT_TO_PLAYBACK_PINS:
        case REDBOOK_ERR_WMI_INIT_FAILED:
        case REDBOOK_ERR_CANNOT_CREATE_THREAD:
        case REDBOOK_ERR_INSUFFICIENT_DATA_STREAM_PAUSED:
        case REDBOOK_ERR_UNSUPPORTED_DRIVE:
            NOTHING;
            break;

        default:
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                       "LogErr !! Invalid error code %lx\n", IoErrorCode));
            return;
    }



    //
    // Use an exponential backoff algorithm to log events.
    //

    rCount = InterlockedIncrement(&DeviceExtension->ErrorLog.RCount[simpleCode]);

    if (CountOfSetBits(rCount) != 1) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugErrlog, "[redbook] "
                   "LogError => IoErrorCode %lx Occurance %d\n",
                   IoErrorCode, rCount));
        return;
    }

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugErrlog, "[redbook] "
               "LogError => IoErrorCode %lx Occurance %d\n",
               IoErrorCode, rCount));

    packetSize  = sizeof(IO_ERROR_LOG_PACKET) + sizeof(ULONG);

    errorLogPacket = (PIO_ERROR_LOG_PACKET)
                     IoAllocateErrorLogEntry(DeviceExtension->SelfDeviceObject,
                                             (UCHAR)packetSize);

    if (errorLogPacket==NULL) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugErrlog, "[redbook] "
                   "LogError => unable to allocate error log packet\n"));
        return;
    }

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugErrlog, "[redbook] "
               "LogError => allocated error log at %p, size %x\n",
               errorLogPacket, packetSize));

    //
    // this function relies upon IoAllocateErrorLogEntry() zero'ing the packet
    //


    errorLogPacket->MajorFunctionCode = -1;
    errorLogPacket->IoControlCode     = -1;
    errorLogPacket->ErrorCode         =  IoErrorCode;
    errorLogPacket->FinalStatus       =  FinalStatus;
    errorLogPacket->SequenceNumber    =  count;
    errorLogPacket->DumpDataSize      =  4; // bytes
    errorLogPacket->DumpData[0]       =  rCount;


    IoWriteErrorLogEntry(errorLogPacket);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\redbook\proto.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       proto.h
//
//--------------------------------------------------------------------------

#ifndef ___REDBOOK_PROTOTYPES_H
#define ___REDBOOK_PROTOTYPES_H

//////////////////////////////////////////////////////////////////////
//
// From redbook\pnp.c
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );
NTSTATUS
RedBookAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );
NTSTATUS
RedBookPnp(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP            Irp
    );
NTSTATUS
RedBookPnpRemoveDevice(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP            Irp
    );
NTSTATUS
RedBookPnpStopDevice(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP            Irp
    );
NTSTATUS
RedBookPnpStartDevice(
    IN PDEVICE_OBJECT  DeviceObject
    );
VOID
RedBookUnload(
    IN PDRIVER_OBJECT DriverObject
    );


//////////////////////////////////////////////////////////

#if DBG

        #define VerifyCalledByThread(D) \
            ASSERT(PsGetCurrentThread() == (D)->Thread.SelfPointer)

#else // !DBG

        #define VerifyCalledByThread(D)            // Nop

#endif // !DBG

//////////////////////////////////////////////////////////////////////
//
// From redbook\errlog.c
//

VOID
RedBookLogError(
    IN  PREDBOOK_DEVICE_EXTENSION  DeviceExtension,
    IN  NTSTATUS                   IoErrorCode,
    IN  NTSTATUS                   FinalStatus
    );


//////////////////////////////////////////////////////////////////////
//
// From redbook\wmi.c
//

NTSTATUS
RedBookWmiUninit(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
RedBookWmiInit(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
RedBookWmiQueryDataBlock (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          InstanceCount,
    IN OUT PULONG     InstanceLengthArray,
    IN ULONG          OutBufferSize,
    OUT PUCHAR        Buffer
    );

NTSTATUS
RedBookWmiSetDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    );

NTSTATUS
RedBookWmiSetDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          DataItemId,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    );

NTSTATUS
RedBookWmiSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
RedBookThreadWmiHandler(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PLIST_ENTRY ListEntry
    );

NTSTATUS
RedBookWmiQueryRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *PhysicalDeviceObject
    );

VOID
RedBookWmiCopyPerfInfo(
    IN  PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    OUT PREDBOOK_WMI_PERF_DATA Out
    );

//////////////////////////////////////////////////////////////////////
//
// From redbook\sysaudio.c
//

NTSTATUS
OpenSysAudio(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
CloseSysAudio(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
GetPinProperty(
    IN  PFILE_OBJECT FileObject,
    IN  ULONG        PropertyId,
    IN  ULONG        PinId,
    IN  ULONG        PropertySize,
    OUT PVOID        Property
    );

NTSTATUS
GetVolumeNodeId(
    IN  PFILE_OBJECT FileObject,
    OUT PULONG       VolumeNodeId
    );

NTSTATUS
UninitializeVirtualSource(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
InitializeVirtualSource(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
AttachVirtualSource(
    IN  PFILE_OBJECT FileObject,
    IN  ULONG        MixerPinId
    );

VOID
SetNextDeviceState(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    KSSTATE      State
    );

VOID
RedBookKsSetVolume(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
OpenInterfaceByGuid(
    IN  CONST GUID * InterfaceClassGuid,
    OUT HANDLE       * Handle,
    OUT PFILE_OBJECT * FileObject
    );

//////////////////////////////////////////////////////////////////////
//
// From redbook\redbook.c
//

NTSTATUS
RedBookRegistryRead(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
RedBookRegistryWrite(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
RedBookReadWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
RedBookSignalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

NTSTATUS
RedBookSetTransferLength(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
RedBookPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RedBookDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
RedBookForwardIrpSynchronous(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

NTSTATUS
RedBookGetDescriptor(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    IN PSTORAGE_PROPERTY_ID PropertyId,
    OUT PSTORAGE_DESCRIPTOR_HEADER *Descriptor
    );

//////////////////////////////////////////////////////////
//
// from redbook\ioctl.c
//

VOID
RedBookDCPause(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    );

VOID
RedBookDCStop(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    );

VOID
RedBookDCResume(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    );

VOID
RedBookDCPlay(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    );

VOID
RedBookDCSeek(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    );

VOID
RedBookDCReadQ(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    );

VOID
RedBookDCCheckVerify(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    );

VOID
RedBookDCSetVolume(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    );

VOID
RedBookDCGetVolume(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    );

VOID
RedBookDCDefault(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_THREAD_IOCTL_DATA Context
    );

VOID
RedBookThreadIoctlHandler(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PLIST_ENTRY ListEntry
    );

NTSTATUS
RedBookCompleteIoctl(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    IN PREDBOOK_THREAD_IOCTL_DATA Context,
    IN BOOLEAN SendToLowerDriver
    );

VOID
RedBookThreadIoctlCompletionHandler(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );


//////////////////////////////////////////////////////////////////////
//
// From redbook\thread.c
//

VOID
RedBookSystemThread(
    PVOID Context
    );

VOID
RedBookReadRaw(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_COMPLETION_CONTEXT Context
    );

NTSTATUS
RedBookReadRawCompletion(
    PVOID UnusableParameter,
    PIRP Irp,
    PREDBOOK_COMPLETION_CONTEXT Context
    );

VOID
RedBookStream(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_COMPLETION_CONTEXT Context
    );

NTSTATUS
RedBookStreamCompletion(
    PVOID UnusableParameter,
    PIRP Irp,
    PREDBOOK_COMPLETION_CONTEXT Context
    );


ULONG
GetCdromState(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

LONG
SetCdromState(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    IN LONG ExpectedOldState,
    IN LONG NewState
    );

VOID
RedBookDeallocatePlayResources(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
RedBookAllocatePlayResources(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

BOOLEAN
RedBookArePlayResourcesAllocated(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
RedBookCacheToc(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

ULONG
WhichTrackContainsThisLBA(
    PCDROM_TOC Toc,
    ULONG Lba
    );

VOID
RedBookThreadDigitalHandler(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PLIST_ENTRY ListEntry
    );

VOID
AddWmiStats(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_COMPLETION_CONTEXT Context
    );

VOID
RedBookCheckForDiscChangeAndFreeResources(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SysAudioPnpNotification(
    PDEVICE_INTERFACE_CHANGE_NOTIFICATION Notification,
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

VOID
RedBookCheckForAudioDeviceRemoval(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    );

//////////////////////////////////////////////////////////////////////

__inline
ULONG
SafeMod(
    IN ULONG Value,
    IN ULONG ModBy
    )
{
    return ((Value+ModBy)%ModBy);
}

__inline
NTSTATUS
RedBookSendToNextDriver(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is sends the Irp to the next driver in line
    when the Irp is not processed by this driver.
    This happens quite often, so should not have any debug statements.
    Request this as an inline operation for speed.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(((PREDBOOK_DEVICE_EXTENSION)DeviceObject->DeviceExtension)->TargetDeviceObject,Irp);
}

//////////////////////////////////////////////////////////////////////


#endif // ___REDBOOK_PROTOTYPES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\redbook\redbook.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       redbook.h
//
//--------------------------------------------------------------------------

//////////////////////////////////////////////////////////

#ifndef __REDBOOK_H__
#define __REDBOOK_H__

//
// these two includes required for stuctures
// used in device extension for kernel streaming
//

#include <ntddk.h>
#include <ntddscsi.h>
#include <ntddcdrm.h>
#include <ntdddisk.h>  // IOCTL_DISK_CHECK_VERIFY
#include <ntddredb.h>  // wmi structure and ids

#include <stdio.h>     // vsprintf()
#include <wmistr.h>    // WMIREG_FLAG_INSTANCE_PDO
#include <wmilib.h>    // WMILIB_CONTEXT
#include <windef.h>    // for ks.h
#include <ks.h>        // for mmsystem.h
#include <mmsystem.h>  // for ksmedia.h
#include <ksmediap.h>  // required.
#include "errlog.h"

#include "trace.h"   // ETW enabling

#ifndef POOL_TAGGING
    #ifdef ExAllocatePoolWithTag
        #undef ExAllocatePoolWithTag
    #endif
    #define ExAllocatePoolWithTag(a,b,c) ExAllocatePool(a,b)

    #ifdef ExAllocatePoolWithTagPriority
        #undef ExAllocatePoolWithTagPriority
    #endif
    #define ExAllocatePoolWithTagPriority(a,b,c,d) ExAllocatePool(a,b)
#endif // endif POOL_TAGGING

#define MOFRESOURCENAME L"Redbook"

// static alloc's
#define TAG_GET_DESC   'edBR' // storage descriptor (returned to caller)
#define TAG_GET_DESC1  '1dBR' // getting storage descriptor
#define TAG_GET_DESC2  '2dBR' // getting storage descriptor
#define TAG_MODE_PAGE  'apBR' // mode pages (returned to caller)
#define TAG_MODE_PAGE1 '1pBR' // getting mode pages
#define TAG_MODE_PAGE2 '2pBR' // getting mode pages

#define TAG_EVENTS     'veBR' // extension->Thread.Events[]
#define TAG_REGPATH    'grBR' // driverExtensionObject->RegistryPath
#define TAG_REMLOCK    'lrBR' // Remove lock

#define TAG_T_IOCTL    'itBR' // THREAD_IOCTL   struct
#define TAG_T_WMI      'wtBR' // THREAD_WMI     struct
#define TAG_T_DIGITAL  'dtBR' // THREAD_DIGITAL struct

// allocs when playing
#define TAG_BUFFER     'uBBR' // Buffer->SkipBuffer
#define TAG_CC         'cCBR' // Buffer->StreamContext
#define TAG_READX      'xRBR' // Buffer->ReadOk_X
#define TAG_STREAMX    'xSBR' // Buffer->StreamOk_X

#define TAG_TOC        'oTBR' // deviceExtension->Cached.Toc
#define TAG_CV_BUFFER  'vCBR' // deviceExtension->Thread.CheckVerifyIrp->AssociatedIrp.SystemBuffer

#define CD_STOPPED         0x00000001
#define CD_PAUSED          0x00000002
#define CD_PLAYING         0x00000004
#define CD_STOPPING        0x00000010 // temp states
#define CD_PAUSING         0x00000020 // temp states

// NOTE: CD_MASK_STATE must have exactly one bit set.
// NOTE: CD_MASK_TEMP  may have zero or one bit set.
#define CD_MASK_TEMP       0x00000030 // mask of bits for transition states
#define CD_MASK_STATE      0x00000007 // mask of bits for non-temp state
#define CD_MASK_ALL        0x00000037 // mask of currently used bits

#define REMOVE_LOCK_MAX_MINUTES 10    // ten minutes max time per io
#define REMOVE_LOCK_HIGH_MARK   10000 // ten thousand concurrent ios?

#define REDBOOK_REG_SUBKEY_NAME             (L"DigitalAudio")
#define REDBOOK_REG_CDDA_ACCURATE_KEY_NAME  (L"CDDAAccurate")
#define REDBOOK_REG_CDDA_SUPPORTED_KEY_NAME (L"CDDASupported")
#define REDBOOK_REG_SECTORS_MASK_KEY_NAME   (L"SectorsPerReadMask")
#define REDBOOK_REG_SECTORS_KEY_NAME        (L"SectorsPerRead")
#define REDBOOK_REG_BUFFERS_KEY_NAME        (L"NumberOfBuffers")
#define REDBOOK_REG_VERSION_KEY_NAME        (L"RegistryVersion")

#define REDBOOK_MAX_CONSECUTIVE_ERRORS 10

#define REDBOOK_WMI_BUFFERS_MAX        30 // must be at least 3 due to
#define REDBOOK_WMI_BUFFERS_MIN         4 // method used to reduce stuttering

#define REDBOOK_WMI_SECTORS_MAX        27 // 64k per read -- 1/3 sec.
#define REDBOOK_WMI_SECTORS_MIN         1 // most processor-intensive

#define REDBOOK_REG_VERSION             1

//
// A single sector from a CD is 2352 bytes
//

#define RAW_SECTOR_SIZE            2352
#define COOKED_SECTOR_SIZE         2048

//
// these events are initialized to false, and are waited
// upon by the system thread. synchronization events all
//
// order is important, as the thread will wait on either
// events 0-3  _OR_  1-4 to allow easy processing of
// ioctls that require multiple state changes.
//

#define EVENT_IOCTL        0  // an ioctl, possibly state change
#define EVENT_WMI          1  // a wmi request, possibly buffer size changes
#define EVENT_DIGITAL      2  // digital reads/digital play
#define EVENT_KILL_THREAD  3  // thread is about to die
#define EVENT_COMPLETE     4  // complete processing of an ioctl
#define EVENT_MAXIMUM      5  // how many events we have



typedef struct _REDBOOK_STREAM_DATA
    *PREDBOOK_STREAM_DATA;
typedef struct _REDBOOK_BUFFER_DATA
    *PREDBOOK_BUFFER_DATA;
typedef struct _REDBOOK_CDROM_INFO
    *PREDBOOK_CDROM_INFO;
typedef struct _REDBOOK_DEVICE_EXTENSION
    *PREDBOOK_DEVICE_EXTENSION;
typedef struct _REDBOOK_COMPLETION_CONTEXT
    *PREDBOOK_COMPLETION_CONTEXT;

//
// Device Extension
//

typedef struct _REDBOOK_ERROR_LOG_DATA {
    LONG  Count;                       // how many errors messages sent
    ULONG RCount[REDBOOK_ERR_MAXIMUM]; // count of each error
} REDBOOK_ERROR_LOG_DATA, *PREDBOOK_ERROR_LOG_DATA;

typedef struct _REDBOOK_STREAM_DATA {

    PFILE_OBJECT    PinFileObject;  // FileObject for pin
    PDEVICE_OBJECT  PinDeviceObject;// DeviceObject for pin
    ULONG           VolumeNodeId;   // where is the device for this though?
    ULONG           MixerPinId;     // Pin of the mixer in sysaudio
    PFILE_OBJECT    MixerFileObject;// keeps a reference to the object

    ULONG           UpdateMixerPin; // PnpNotification arrived
    PVOID           SysAudioReg;    // For SysAudio PnpNotification

    //
    // the next two are win98's 'MY_PIN'
    // THESE TWO STRUCTS MUST BE KEPT CONTIGUOUS
    //
    struct {
        KSPIN_CONNECT  Connect;
        KSDATAFORMAT_WAVEFORMATEX Format;
    };

} REDBOOK_STREAM_DATA, *PREDBOOK_STREAM_DATA;

//
// move this struct's parts into REDBOOK_THREAD_DATA,
// since nothing here should be accessed outside the thread
//

typedef struct _REDBOOK_CDROM_INFO {

    //
    // cache both Table of Contents and
    // number of times disc was changed
    // (CheckVerifyStatus)
    //

    PCDROM_TOC Toc;
    ULONG StateNow;          // interlocked state, support routines to access
    ULONG CheckVerify;

    ULONG NextToRead;        // next sector to read upon getting a free buffer
    ULONG NextToStream;      // next sector to play when KS ready
    ULONG FinishedStreaming; // last to go through ks

    ULONG EndPlay;           // last sector to read/play
    ULONG ReadErrors;        // stop on errors
    ULONG StreamErrors;      // stop on errors

    //
    // CDRom State
    //

    VOLUME_CONTROL Volume;   // sizeof(char)*4

} REDBOOK_CDROM_INFO, *PREDBOOK_CDROM_INFO;

typedef struct _REDBOOK_BUFFER_DATA {

    PUCHAR  SkipBuffer;             // circular buffer
    PREDBOOK_COMPLETION_CONTEXT Contexts;
    PULONG  ReadOk_X;               //  + inuse flag for completion routines
    PULONG  StreamOk_X;             //  + to guarantee data integrity

    PUCHAR  SilentBuffer;           // when need to send silence
    PMDL    SilentMdl;              // when need to send silence

    ULONG   IndexToRead;
    ULONG   IndexToStream;

    union {
        struct {
            UCHAR   MaxIrpStack;    // allows cleaner IoInitializeIrp
            UCHAR   Paused;         // essentially a boolean
            UCHAR   FirstPause;     // so don't log pauses too often
        };
        ULONG   Reserved1;          // force alignment to ulong
    };

} REDBOOK_BUFFER_DATA, *PREDBOOK_BUFFER_DATA;

//
// Read/Stream completion routine context(s)
//

#define REDBOOK_CC_READ              1
#define REDBOOK_CC_STREAM            2
#define REDBOOK_CC_READ_COMPLETE     3
#define REDBOOK_CC_STREAM_COMPLETE   4

typedef struct _REDBOOK_COMPLETION_CONTEXT {
    LIST_ENTRY ListEntry;          // for queueing
    PREDBOOK_DEVICE_EXTENSION DeviceExtension;
    ULONG  Reason;                 // REDBOOK_CC_*

    ULONG  Index;                   // buffer index
    PUCHAR Buffer;                 // Buffer
    PMDL   Mdl;                    // Mdl for buffer
    PIRP   Irp;                    // Irp for buffer

    LARGE_INTEGER TimeReadReady;   // time the buffer was ready to read into
    LARGE_INTEGER TimeReadSent;    // time buffer was sent to read
    LARGE_INTEGER TimeStreamReady; // time the buffer was ready to stream
    LARGE_INTEGER TimeStreamSent;  // time buffer was sent to stream

    KSSTREAM_HEADER Header;        // have to be allocated, keep w/buffer
} REDBOOK_COMPLETION_CONTEXT, *PREDBOOK_COMPLETION_CONTEXT;

typedef struct _REDBOOK_THREAD_DATA {

    //
    // Handle to the thread
    //

    HANDLE SelfHandle;

    //
    // pointer to thread
    //

    PETHREAD SelfPointer;

    //
    // object pointer we referenced so we can safely wait for thread to exit
    //

    PKTHREAD ThreadReference;

    //
    // irp used to verify media hasn't changed
    //

    PIRP CheckVerifyIrp;

    //
    // Three queues: Ioctl, Wmi, Kill
    // Currently Processing is LIST_ENTRY pointer
    //

    LIST_ENTRY IoctlList;   // dump ioctls here
    LIST_ENTRY WmiList;     // dump wmi requests here
    LIST_ENTRY DigitalList; // dump rawread/stream requests here

    //
    // Three spinlocks: one for each queue
    //

    KSPIN_LOCK IoctlLock;
    KSPIN_LOCK WmiLock;
    KSPIN_LOCK DigitalLock;

    //
    // may need to wait for digital to complete for this
    //

    PLIST_ENTRY IoctlCurrent;

    //
    // keep count of pending io
    //
    ULONG PendingRead;
    ULONG PendingStream;

    //
    // Events for the thread
    //

    PKEVENT Events[EVENT_MAXIMUM];
    KWAIT_BLOCK EventBlock[EVENT_MAXIMUM];


} REDBOOK_THREAD_DATA, *PREDBOOK_THREAD_DATA;

// the kill event is just a list_entry

typedef struct _REDBOOK_THREAD_IOCTL_DATA {
    LIST_ENTRY ListEntry;
    PIRP Irp;
} REDBOOK_THREAD_IOCTL_DATA, *PREDBOOK_THREAD_IOCTL_DATA;

typedef struct _REDBOOK_THREAD_WMI_DATA {
    LIST_ENTRY ListEntry;
    PIRP Irp;
} REDBOOK_THREAD_WMI_DATA, *PREDBOOK_THREAD_WMI_DATA;

#define SAVED_IO_MAX (1)        // increase this for thread ioctl history
typedef struct _SAVED_IO {
    union {
        struct {
            PIRP              OriginalIrp;     // see where it finished
            IRP               IrpWithoutStack;
            IO_STACK_LOCATION Stack[8];
        };
        UCHAR Reserved[0x200];  // to make my tracing easier (real size: 0x194)
    };
} SAVED_IO, *PSAVED_IO;



//
// Device Extension
//

typedef struct _REDBOOK_DEVICE_EXTENSION {

    //
    // Driver Object
    //

    PDRIVER_OBJECT DriverObject;

    //
    // Target Device Object
    //

    PDEVICE_OBJECT TargetDeviceObject;

    //
    // Target Physical Device Object
    //

    PDEVICE_OBJECT TargetPdo;

    //
    // Back pointer to device object
    //

    PDEVICE_OBJECT SelfDeviceObject;

    //
    // PagingPath Count
    //

    ULONG PagingPathCount;
    KEVENT PagingPathEvent;

    //
    // Pnp State
    //

    struct {
        UCHAR CurrentState;
        UCHAR PreviousState;
        BOOLEAN RemovePending;
        BOOLEAN Initialized;
    } Pnp;

    REDBOOK_ERROR_LOG_DATA ErrorLog;
    REDBOOK_CDROM_INFO  CDRom;
    REDBOOK_BUFFER_DATA Buffer;
    REDBOOK_STREAM_DATA Stream;
    REDBOOK_THREAD_DATA Thread;

    //
    // WMI Information
    //

    REDBOOK_WMI_STD_DATA WmiData;
    REDBOOK_WMI_PERF_DATA WmiPerf;
    KSPIN_LOCK WmiPerfLock;
    WMILIB_CONTEXT WmiLibInfo;
    BOOLEAN WmiLibInitialized;

    //
    // Remove Lock -- Important while playing audio
    //

    IO_REMOVE_LOCK RemoveLock;

    /*
     *  The WmiData.NumberOfBuffers and WmiData.SectorsPerRead fields can be changed during play,
     *  which would throw off our buffers and could cause an exception.
     *  So we save new WMI settings here and only apply them on the next play.
     */
    ULONG NextWmiSectorsPerRead;
    ULONG NextWmiNumberOfBuffers;
    
    #if DBG
        ULONG    SavedIoCurrentIndex;
        SAVED_IO SavedIo[SAVED_IO_MAX];
    #endif
    
} REDBOOK_DEVICE_EXTENSION, *PREDBOOK_DEVICE_EXTENSION;


//
// Driver Extension
//

typedef struct _REDBOOK_DRIVER_EXTENSION {
    UNICODE_STRING RegistryPath;
} REDBOOK_DRIVER_EXTENSION, *PREDBOOK_DRIVER_EXTENSION;

#define REDBOOK_DRIVER_EXTENSION_ID DriverEntry

//
// Macros to make life easy
//

#define LBA_TO_RELATIVE_MSF(Lba,Minutes,Seconds,Frames)      \
{                                                            \
    (Minutes) = (UCHAR)( ((Lba)+  0) / (60 * 75)      );     \
    (Seconds) = (UCHAR)((((Lba)+  0) % (60 * 75)) / 75);     \
    (Frames)  = (UCHAR)((((Lba)+  0) % (60 * 75)) % 75);     \
}

#define LBA_TO_MSF(Lba,Minutes,Seconds,Frames)               \
{                                                            \
    (Minutes) = (UCHAR)( ((Lba)+150) / (60 * 75)      );     \
    (Seconds) = (UCHAR)((((Lba)+150) % (60 * 75)) / 75);     \
    (Frames)  = (UCHAR)((((Lba)+150) % (60 * 75)) % 75);     \
}

#define MSF_TO_LBA(Minutes,Seconds,Frames)                   \
    (ULONG)(75*((60*(Minutes))+(Seconds))+(Frames) - 150)

//
// Algebraically equal to:
//      75*60*Minutes +
//      75*Seconds    +
//      Frames        - 150
//


#define MIN(_a,_b) (((_a) <= (_b)) ? (_a) : (_b))
#define MAX(_a,_b) (((_a) >= (_b)) ? (_a) : (_b))

//
// neat little hacks to count number of bits set
//
__inline ULONG CountOfSetBits(ULONG _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }
__inline ULONG CountOfSetBits32(ULONG32 _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }
__inline ULONG CountOfSetBits64(ULONG64 _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   (((Flags) & (Bit)) != 0)

#ifdef TRY
    #undef TRY
#endif
#ifdef LEAVE
    #undef LEAVE
#endif
#ifdef FINALLY
    #undef FINALLY
#endif

#define TRY
#define LEAVE   goto __label;
#define FINALLY __label:


#endif // __REDBOOK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\redbook\pnp.c ===
/*++
Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    pnp.c

Abstract:

    This file handles the plug and play portions of redbook.sys
    This also handles the AddDevice, DriverEntry, and Unload routines,
    as they are part of initialization.

Author:

    Henry Gabryjelski (henrygab)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "redbook.h"
#include "ntddredb.h"
#include "proto.h"

#ifdef _USE_ETW
#include "pnp.tmh"
#endif // _USE_ETW

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE,   DriverEntry                  )
    #pragma alloc_text(PAGE,   RedBookAddDevice             )
    #pragma alloc_text(PAGE,   RedBookPnp                   )
    #pragma alloc_text(PAGE,   RedBookPnpRemoveDevice       )
    #pragma alloc_text(PAGE,   RedBookPnpStartDevice        )
    #pragma alloc_text(PAGE,   RedBookPnpStopDevice         )
    #pragma alloc_text(PAGE,   RedBookUnload                )
#endif // ALLOC_PRAGMA


////////////////////////////////////////////////////////////////////////////////

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Initialize RedBook driver.
    This is the system initialization entry point
    when the driver is linked into the kernel.

Arguments:

    DriverObject

Return Value:

    NTSTATUS

--*/

{
    ULONG i;
    NTSTATUS status;
    PREDBOOK_DRIVER_EXTENSION driverExtension;

    PAGED_CODE();

#ifdef _USE_ETW
    WPP_INIT_TRACING(DriverObject, RegistryPath);
#endif // _USE_ETW

    //
    // WMI requires registry path
    //

    status = IoAllocateDriverObjectExtension(DriverObject,
                                             REDBOOK_DRIVER_EXTENSION_ID,
                                             sizeof(REDBOOK_DRIVER_EXTENSION),
                                             &driverExtension);

    if (status == STATUS_OBJECT_NAME_COLLISION) {

        //
        // The extension already exists - get a pointer to it
        //

        driverExtension = IoGetDriverObjectExtension(DriverObject,
                                                     REDBOOK_DRIVER_EXTENSION_ID);

        if (driverExtension != NULL)
        {
            status = STATUS_SUCCESS;
        }
    }

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                   "DriverEntry !! no drvObjExt %lx\n", status));
        return status;
    }

    //
    // Copy the RegistryPath to our newly acquired driverExtension
    //

    driverExtension->RegistryPath.Buffer =
        ExAllocatePoolWithTag(NonPagedPool,
                              RegistryPath->Length + 2,
                              TAG_REGPATH);

    if (driverExtension->RegistryPath.Buffer == NULL) {

        status = STATUS_NO_MEMORY;
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                   "DriverEntry !! unable to alloc regPath %lx\n", status));
        return status;

    } else {

        driverExtension->RegistryPath.Length = RegistryPath->Length;
        driverExtension->RegistryPath.MaximumLength = RegistryPath->Length + 2;
        RtlCopyUnicodeString(&driverExtension->RegistryPath, RegistryPath);

    }

    //
    // Send everything down unless specifically handled.
    //

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {

        DriverObject->MajorFunction[i] = RedBookSendToNextDriver;

    }

    //
    // These are the only IRP_MJ types that are handled
    //

    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = RedBookWmiSystemControl;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = RedBookDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_READ]           = RedBookReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE]          = RedBookReadWrite;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = RedBookPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = RedBookPower;
    DriverObject->DriverExtension->AddDevice           = RedBookAddDevice;
    DriverObject->DriverUnload                         = RedBookUnload;

    return STATUS_SUCCESS;
}


NTSTATUS
RedBookAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    This routine creates and initializes a new FDO for the
    corresponding PDO.  It may perform property queries on
    the FDO but cannot do any media access operations.

Arguments:

    DriverObject - CDROM class driver object or lower level filter

    Pdo - the physical device object we are being added to

Return Value:

    status

--*/

{

    NTSTATUS                   status;
    PDEVICE_OBJECT             deviceObject;
    PREDBOOK_DEVICE_EXTENSION  extension = NULL;
    ULONG                      i;

    PAGED_CODE();

    TRY {

        //
        // Create the devObj so system doesn't unload us
        //

        status = IoCreateDevice(DriverObject,
                                sizeof(REDBOOK_DEVICE_EXTENSION),
                                NULL,
                                FILE_DEVICE_CD_ROM,
                                0,
                                FALSE,
                                &deviceObject
                                );

        if (!NT_SUCCESS(status)) {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                       "AddDevice !! Couldn't create device %lx\n",
                       status));
            LEAVE;

        }

        extension = deviceObject->DeviceExtension;
        RtlZeroMemory(extension, sizeof(REDBOOK_DEVICE_EXTENSION));

        //
        // Attach to the stack
        //

        extension->TargetDeviceObject =
            IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

        if (extension->TargetDeviceObject == NULL) {

            status = STATUS_UNSUCCESSFUL;
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                       "AddDevice != Couldn't attach to stack %lx\n",
                       status));
            LEAVE;

        }

        extension->DriverObject     = DriverObject;
        extension->TargetPdo        = PhysicalDeviceObject;
        extension->SelfDeviceObject = deviceObject;

        //
        // prepare the paging path additions
        //

        extension->PagingPathCount = 0;
        KeInitializeEvent(&extension->PagingPathEvent,
                          SynchronizationEvent,
                          TRUE);

        //
        // Create and acquire a remove lock for this device
        //

        IoInitializeRemoveLock(&extension->RemoveLock,
                               TAG_REMLOCK,
                               REMOVE_LOCK_MAX_MINUTES,
                               REMOVE_LOCK_HIGH_MARK);

        //
        // Initialize the Pnp states
        //

        extension->Pnp.CurrentState  = 0xff;
        extension->Pnp.PreviousState = 0xff;
        extension->Pnp.RemovePending = FALSE;

        //
        // Create thread -- PUT INTO SEPERATE ROUTINE
        //

        {
            HANDLE handle;
            PKTHREAD thread;

            //
            // have to setup a minimum amount of stuff for the thread
            // here....
            //

            extension->CDRom.StateNow = CD_STOPPED;

            //
            // Allocate memory for the numerous events all at once
            //

            extension->Thread.Events[0] =
                ExAllocatePoolWithTag(NonPagedPool,
                                      sizeof(KEVENT) * EVENT_MAXIMUM,
                                      TAG_EVENTS);

            if (extension->Thread.Events[0] == NULL) {
                status = STATUS_NO_MEMORY;
                LEAVE;
            }

            //
            // Set the pointers appropriately
            // ps - i love pointer math
            //

            for (i = 1; i < EVENT_MAXIMUM; i++) {
                extension->Thread.Events[i] = extension->Thread.Events[0] + i;
            }

            InitializeListHead(  &extension->Thread.IoctlList);
            KeInitializeSpinLock(&extension->Thread.IoctlLock);
            InitializeListHead(  &extension->Thread.WmiList);
            KeInitializeSpinLock(&extension->Thread.WmiLock);
            InitializeListHead(  &extension->Thread.DigitalList);
            KeInitializeSpinLock(&extension->Thread.DigitalLock);


            extension->Thread.IoctlCurrent = NULL;

            for ( i = 0; i < EVENT_MAXIMUM; i++) {
                KeInitializeEvent(extension->Thread.Events[i],
                                  SynchronizationEvent,
                                  FALSE);
            }

            ASSERT(extension->Thread.SelfPointer == NULL);
            ASSERT(extension->Thread.SelfHandle == 0);

            //
            // create the thread that will do most of the work
            //

            status = PsCreateSystemThread(&handle,
                                          (ACCESS_MASK) 0L,
                                          NULL, NULL, NULL,
                                          RedBookSystemThread,
                                          extension);

            if (!NT_SUCCESS(status)) {

                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                           "StartDevice !! Unable to create thread %lx\n",
                           status));
                RedBookLogError(extension,
                                REDBOOK_ERR_CANNOT_CREATE_THREAD,
                                status);
                LEAVE;

            }
            ASSERT(extension->Thread.SelfHandle == 0); // shouldn't be set yet
            extension->Thread.SelfHandle = handle;

            //
            // Reference the thread so we can properly wait on it in
            // the remove device routine.
            //
            status = ObReferenceObjectByHandle(handle,
                                               THREAD_ALL_ACCESS,
                                               NULL,
                                               KernelMode,
                                               &thread,
                                               NULL);
            if (!NT_SUCCESS(status)) {

                //
                // NOTE: we would leak a thread here, but don't
                // know a way to handle this error case?
                //

                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                           "StartDevice !! Unable to reference thread %lx\n",
                           status));
                RedBookLogError(extension,
                                REDBOOK_ERR_CANNOT_CREATE_THREAD,
                                status);
                LEAVE;
            }
            extension->Thread.ThreadReference = thread;
        }

    } FINALLY {

        if (!NT_SUCCESS(status)) {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                       "AddDevice !! Failed with status %lx\n",
                       status));

            if (!deviceObject) {

                //
                // same as no device extension
                //

                return status;

            }

            if (extension &&
                extension->Thread.Events[0]) {
                ExFreePool(extension->Thread.Events[0]);
            }

            if (extension &&
                extension->TargetDeviceObject) {
                IoDetachDevice(extension->TargetDeviceObject);
            }

            IoDeleteDevice( deviceObject );

            return status;
        }
    }

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
               "AddDevice => DevExt at %p\n", extension));

    //
    // propogate only some flags from the lower devobj.
    //

    {
        ULONG flagsToPropogate;

        flagsToPropogate = DO_BUFFERED_IO | DO_DIRECT_IO;
        flagsToPropogate &= extension->TargetDeviceObject->Flags;

        SET_FLAG(deviceObject->Flags, flagsToPropogate);

    }

    SET_FLAG(deviceObject->Flags, DO_POWER_PAGABLE);

    //
    // No longer initializing
    //

    CLEAR_FLAG(deviceObject->Flags, DO_DEVICE_INITIALIZING);

    return STATUS_SUCCESS;
}


NTSTATUS
RedBookPnp(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP            Irp
    )

/*++

Routine Description:

    Dispatch for PNP

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;
    PREDBOOK_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PDEVICE_OBJECT targetDO = deviceExtension->TargetDeviceObject;
    ULONG cdromState;
    BOOLEAN completeRequest;
    BOOLEAN lockReleased;

    PAGED_CODE();

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                   "Pnp !! Remove lock failed PNP Irp type [%#02x]\n",
                   irpSp->MinorFunction));
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
        return status;
    }

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                   "Pnp (%p,%p,%x) => Entering previous %x  current %x\n",
                   DeviceObject, Irp, irpSp->MinorFunction,
                   deviceExtension->Pnp.PreviousState,
                   deviceExtension->Pnp.CurrentState));

    lockReleased = FALSE;
    completeRequest = TRUE;

    switch (irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE:
        {
            //
            // first forward this down
            //

            status = RedBookForwardIrpSynchronous(deviceExtension, Irp);

            //
            // check status from new sent Start Irp
            //

            if (!NT_SUCCESS(status)) {

                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                           "Pnp (%p,%p,%x) => failed start status = %x\n",
                           DeviceObject, Irp, irpSp->MinorFunction, status));
                break;

            }

            //
            // cannot pass this one down either, since it's already
            // done that in the startdevice routine.
            //

            status = RedBookPnpStartDevice(DeviceObject);

            if (NT_SUCCESS(status)) {

                deviceExtension->Pnp.PreviousState =
                    deviceExtension->Pnp.CurrentState;
                deviceExtension->Pnp.CurrentState =
                    irpSp->MinorFunction;

            }
            break;

        }

        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_QUERY_STOP_DEVICE:
        {

            //
            // if this device is in use for some reason (paging, etc...)
            // then we need to fail the request.
            //

            if (deviceExtension->PagingPathCount != 0) {

                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                           "Device %p is in the paging path and cannot "
                           "be removed\n",
                           DeviceObject));
                status = STATUS_DEVICE_BUSY;
                break;
            }

            //
            // see if the query operation can succeed
            //

            if (irpSp->MinorFunction == IRP_MN_QUERY_STOP_DEVICE) {
                status = RedBookPnpStopDevice(DeviceObject, Irp);
            } else {
                status = RedBookPnpRemoveDevice(DeviceObject, Irp);
            }

            if (NT_SUCCESS(status)) {

                ASSERT(deviceExtension->Pnp.CurrentState != irpSp->MinorFunction);

                deviceExtension->Pnp.PreviousState =
                    deviceExtension->Pnp.CurrentState;
                deviceExtension->Pnp.CurrentState =
                    irpSp->MinorFunction;

                status = RedBookForwardIrpSynchronous(deviceExtension, Irp);

            }
            break;
        }

        case IRP_MN_CANCEL_REMOVE_DEVICE:
        case IRP_MN_CANCEL_STOP_DEVICE: {

            //
            // check if the cancel can succeed
            //

            if (irpSp->MinorFunction == IRP_MN_CANCEL_STOP_DEVICE) {

                status = RedBookPnpStopDevice(DeviceObject, Irp);
                ASSERTMSG("Pnp !! CANCEL_STOP_DEVICE should never be "
                          " failed!\n", NT_SUCCESS(status));

            } else {

                status = RedBookPnpRemoveDevice(DeviceObject, Irp);
                ASSERTMSG("Pnp !! CANCEL_REMOVE_DEVICE should never be "
                          "failed!\n", NT_SUCCESS(status));
            }

            Irp->IoStatus.Status = status;

            //
            // we got a CANCEL -- roll back to the previous state only if
            // the current state is the respective QUERY state.
            //

            if ((irpSp->MinorFunction == IRP_MN_CANCEL_STOP_DEVICE &&
                 deviceExtension->Pnp.CurrentState == IRP_MN_QUERY_STOP_DEVICE)
                ||
                (irpSp->MinorFunction == IRP_MN_CANCEL_REMOVE_DEVICE &&
                 deviceExtension->Pnp.CurrentState == IRP_MN_QUERY_REMOVE_DEVICE)
                ) {

                deviceExtension->Pnp.CurrentState =
                    deviceExtension->Pnp.PreviousState;
                deviceExtension->Pnp.PreviousState = 0xff;

            }

            status = RedBookForwardIrpSynchronous(deviceExtension, Irp);

            break;
        }

        case IRP_MN_STOP_DEVICE: {

            ASSERT(deviceExtension->PagingPathCount == 0);

            //
            // call into the stop device routine.
            //

            status = RedBookPnpStopDevice(DeviceObject, Irp);

            ASSERTMSG("[redbook] Pnp !! STOP_DEVICE should never be failed\n",
                      NT_SUCCESS(status));

            status = RedBookForwardIrpSynchronous(deviceExtension, Irp);

            if (NT_SUCCESS(status)) {

                deviceExtension->Pnp.CurrentState  = irpSp->MinorFunction;
                deviceExtension->Pnp.PreviousState = 0xff;

            }

            break;
        }

        case IRP_MN_REMOVE_DEVICE:
        case IRP_MN_SURPRISE_REMOVAL: {

            //
            // forward the irp (to close pending io)
            //

            status = RedBookForwardIrpSynchronous(deviceExtension, Irp);

            ASSERT(NT_SUCCESS(status));

            //
            // move this here so i know that i am removing....
            //

            deviceExtension->Pnp.PreviousState =
                deviceExtension->Pnp.CurrentState;
            deviceExtension->Pnp.CurrentState =
                irpSp->MinorFunction;

            //
            // the remove lock is released by the remove device routine
            //

            lockReleased = TRUE;
            status = RedBookPnpRemoveDevice(DeviceObject, Irp);

            ASSERTMSG("Pnp !! REMOVE_DEVICE should never fail!\n",
                      NT_SUCCESS(status));


            status = STATUS_SUCCESS;
            break;
        }

        case IRP_MN_DEVICE_USAGE_NOTIFICATION: {
            KEVENT event;
            BOOLEAN setPagable;

            if (irpSp->Parameters.UsageNotification.Type != DeviceUsageTypePaging) {
                status = RedBookForwardIrpSynchronous(deviceExtension, Irp);
                break; // out of case statement
            }

            KeWaitForSingleObject(&deviceExtension->PagingPathEvent,
                                  Executive, KernelMode,
                                  FALSE, NULL);

            //
            // if removing last paging device, need to set DO_POWER_PAGABLE
            // bit here, and possible re-set it below on failure.
            //

            setPagable = FALSE;
            if (!irpSp->Parameters.UsageNotification.InPath &&
                deviceExtension->PagingPathCount == 1) {

                //
                // removing last paging file.  must have
                // DO_POWER_PAGABLE bits set prior to forwarding
                //

                if (TEST_FLAG(DeviceObject->Flags, DO_POWER_INRUSH)) {
                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                               "Pnp (%p,%p,%x) => Last paging file"
                               " removed, but DO_POWER_INRUSH set, so "
                               "not setting DO_POWER_PAGABLE\n",
                               DeviceObject, Irp, irpSp->MinorFunction));
                } else {
                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                               "Pnp (%p,%p,%x) => Setting PAGABLE "
                               "bit\n", DeviceObject, Irp,
                               irpSp->MinorFunction));
                    SET_FLAG(DeviceObject->Flags, DO_POWER_PAGABLE);
                    setPagable = TRUE;
                }

            }

            //
            // send the irp synchronously
            //

            status = RedBookForwardIrpSynchronous(deviceExtension, Irp);

            //
            // now deal with the failure and success cases.
            // note that we are not allowed to fail the irp
            // once it is sent to the lower drivers.
            //

            if (NT_SUCCESS(status)) {

                IoAdjustPagingPathCount(
                    &deviceExtension->PagingPathCount,
                    irpSp->Parameters.UsageNotification.InPath);

                if (irpSp->Parameters.UsageNotification.InPath) {
                    if (deviceExtension->PagingPathCount == 1) {
                        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                                   "Pnp (%p,%p,%x) => Clearing PAGABLE "
                                   "bit\n", DeviceObject, Irp,
                                   irpSp->MinorFunction));
                        CLEAR_FLAG(DeviceObject->Flags, DO_POWER_PAGABLE);
                    }
                }

            } else {

                //
                // cleanup the changes done above
                //

                if (setPagable == TRUE) {
                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                               "Pnp (%p,%p,%x) => Clearing PAGABLE bit "
                               "due to irp failiing (%x)\n",
                               DeviceObject, Irp, irpSp->MinorFunction,
                               status));
                    CLEAR_FLAG(DeviceObject->Flags, DO_POWER_PAGABLE);
                    setPagable = FALSE;
                }

            }
            KeSetEvent(&deviceExtension->PagingPathEvent,
                       IO_NO_INCREMENT, FALSE);

            break;

        }

        default: {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "Pnp (%p,%p,%x) => Leaving  previous %x  "
                       "current %x (unhandled)\n",
                       DeviceObject, Irp, irpSp->MinorFunction,
                       deviceExtension->Pnp.PreviousState,
                       deviceExtension->Pnp.CurrentState));
            status = RedBookSendToNextDriver(DeviceObject, Irp);
            IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            completeRequest = FALSE;
            lockReleased = TRUE;
            break;
        }
    }

    if (completeRequest) {

        if (!lockReleased) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "Pnp (%p,%p,%x) => Leaving  previous %x  "
                       "current %x  status %x\n",
                       DeviceObject, Irp, irpSp->MinorFunction,
                       deviceExtension->Pnp.PreviousState,
                       deviceExtension->Pnp.CurrentState,
                       status));
        } else {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "Pnp (%p,%p,%x) => Leaving with released lock (unsafe "
                       "to use device extension for states) status %x\n",
                       DeviceObject, Irp, irpSp->MinorFunction, status));
        }


        Irp->IoStatus.Status = status;

        IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);

        if (!lockReleased) {
            IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        }

    }

    return status;

}

NTSTATUS
RedBookPnpRemoveDevice(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP            Irp
    )
/*++

Routine Description:

    Dispatch for PNP

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/
{
    PREDBOOK_DEVICE_EXTENSION deviceExtension;
    UCHAR type;
    NTSTATUS status;
    ULONG i;

    PAGED_CODE();

    type = IoGetCurrentIrpStackLocation(Irp)->MinorFunction;

    if (type == IRP_MN_QUERY_REMOVE_DEVICE ||
        type == IRP_MN_CANCEL_REMOVE_DEVICE) {
        return STATUS_SUCCESS;
    }

    //
    // Type is now either SURPRISE_REMOVAL or REMOVE_DEVICE
    //
    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
               "PnpRemove => starting %s\n",
               (type == IRP_MN_REMOVE_DEVICE ?
                "remove device" : "surprise removal")));

    deviceExtension = DeviceObject->DeviceExtension;

    deviceExtension->Pnp.RemovePending = TRUE;

    if (type == IRP_MN_REMOVE_DEVICE) {

        //
        // prevent any new io
        //

        IoReleaseRemoveLockAndWait(&deviceExtension->RemoveLock, Irp);

        //
        // cleanup the thread, if one exists
        // NOTE: a new one won't start due to the remove lock
        //

        if (deviceExtension->Thread.SelfHandle != NULL) {

            ASSERT(deviceExtension->Thread.ThreadReference);

            //
            // there is no API to wait on a handle, so we must wait on
            // the object.
            //


            KeSetEvent(deviceExtension->Thread.Events[EVENT_KILL_THREAD],
                       IO_CD_ROM_INCREMENT, FALSE);
            KeWaitForSingleObject(deviceExtension->Thread.ThreadReference,
                                  Executive, KernelMode,
                                  FALSE, NULL);
            ObDereferenceObject(deviceExtension->Thread.ThreadReference);
            deviceExtension->Thread.ThreadReference = NULL;

            ZwClose(deviceExtension->Thread.SelfHandle);
            deviceExtension->Thread.SelfHandle = 0;

            deviceExtension->Thread.SelfPointer = NULL;

        }

        //
        // un-register pnp notification
        //

        if (deviceExtension->Stream.SysAudioReg != NULL) {
            IoUnregisterPlugPlayNotification(deviceExtension->Stream.SysAudioReg);
            deviceExtension->Stream.SysAudioReg = NULL;
        }

        //
        // free any cached toc
        //

        if (deviceExtension->CDRom.Toc != NULL) {
            ExFreePool(deviceExtension->CDRom.Toc);
            deviceExtension->CDRom.Toc = NULL;
        }

        //
        // de-register from wmi
        //

        if (deviceExtension->WmiLibInitialized) {
            status = RedBookWmiUninit(deviceExtension);
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "PnpRemove => WMI Uninit returned %x\n", status));
            deviceExtension->WmiLibInitialized = FALSE;
        }

        //
        // Detach from the device stack
        //

        IoDetachDevice(deviceExtension->TargetDeviceObject);
        deviceExtension->TargetDeviceObject = NULL;

        //
        // free the events
        //

        if (deviceExtension->Thread.Events[0]) {
            ExFreePool(deviceExtension->Thread.Events[0]);
        }

        for (i=0;i<EVENT_MAXIMUM;i++) {
            deviceExtension->Thread.Events[i] = NULL;
        }

        //
        // make sure we aren't leaking anywhere...
        //

        ASSERT(deviceExtension->Buffer.Contexts    == NULL);
        ASSERT(deviceExtension->Buffer.ReadOk_X    == NULL);
        ASSERT(deviceExtension->Buffer.StreamOk_X  == NULL);

        //
        // Now can safely (without leaks) delete our device object
        //

        IoDeleteDevice(deviceExtension->SelfDeviceObject);
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                   "PnpRemove => REMOVE_DEVICE finished.\n"));

    } else {

        //
        // do nothing for a SURPRISE_REMOVAL, since a REMOVE_DEVICE
        // will soon follow.
        //

        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                   "PnpRemove => SURPRISE_REMOVAL finished.\n"));

    }

    return STATUS_SUCCESS;

}


NTSTATUS
RedBookPnpStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PAGED_CODE();
    return STATUS_SUCCESS;

}

NTSTATUS
RedBookPnpStartDevice(
    IN PDEVICE_OBJECT  DeviceObject
    )

/*++

Routine Description:

    Dispatch for START DEVICE.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PREDBOOK_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;
    ULONG i;

    PAGED_CODE();

    //
    // Never start my driver portion twice
    // system guarantees one Pnp Irp at a time,
    // so state will not change within this routine
    //

    switch ( deviceExtension->Pnp.CurrentState ) {

        case 0xff:
        case IRP_MN_STOP_DEVICE: {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "StartDevice => starting driver for devobj %p\n",
                       DeviceObject));
            break;
        }
        case IRP_MN_START_DEVICE: {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "StartDevice => already started for devobj %p\n",
                       DeviceObject));
            return STATUS_SUCCESS;
        }

        case IRP_MN_QUERY_REMOVE_DEVICE: {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "StartDevice !! remove pending for devobj %p\n",
                       DeviceObject));
            return STATUS_UNSUCCESSFUL;
        }

        case IRP_MN_QUERY_STOP_DEVICE: {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "StartDevice !! stop pending for devobj %p\n",
                       DeviceObject));
            return STATUS_UNSUCCESSFUL;
        }

        default: {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                       "StartDevice !! unknown DeviceState for devobj %p\n",
                       DeviceObject));
            ASSERT(!"[RedBook] Pnp !! Unkown Device State");
            return STATUS_UNSUCCESSFUL;
        }
    }

    if (deviceExtension->Pnp.Initialized) {
        return STATUS_SUCCESS;
    }

    //
    // the following code will only successfully run once for each AddDevice()
    // must still ensure that we check if something is already allocated
    // if we allocate it here.  also note that everything allocated here must
    // explicitly be checked for in the RemoveDevice() routine, even if we
    // never finished a start successfully.
    //

    deviceExtension->WmiData.MaximumSectorsPerRead = -1;
    deviceExtension->WmiData.PlayEnabled = 1;
    ASSERT(deviceExtension->CDRom.Toc == NULL);
    if (deviceExtension->CDRom.Toc != NULL) {
        ExFreePool(deviceExtension->CDRom.Toc);
    }
    ASSERT(deviceExtension->Buffer.ReadOk_X     == NULL);
    ASSERT(deviceExtension->Buffer.StreamOk_X   == NULL);
    ASSERT(deviceExtension->Buffer.Contexts     == NULL);

    RtlZeroMemory(&deviceExtension->Stream, sizeof(REDBOOK_STREAM_DATA));
    deviceExtension->Stream.MixerPinId   = -1;
    deviceExtension->Stream.VolumeNodeId = -1;
    deviceExtension->Stream.Connect.Interface.Set   = KSINTERFACESETID_Standard;
    deviceExtension->Stream.Connect.Interface.Id    = KSINTERFACE_STANDARD_STREAMING;
    deviceExtension->Stream.Connect.Interface.Flags = 0;
    deviceExtension->Stream.Connect.Medium.Set   = KSMEDIUMSETID_Standard;
    deviceExtension->Stream.Connect.Medium.Id    = KSMEDIUM_STANDARD_DEVIO;
    deviceExtension->Stream.Connect.Medium.Flags = 0;
    deviceExtension->Stream.Connect.Priority.PriorityClass    = KSPRIORITY_NORMAL;
    deviceExtension->Stream.Connect.Priority.PrioritySubClass = 1;
    deviceExtension->Stream.Format.DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
    deviceExtension->Stream.Format.DataFormat.SubFormat   = KSDATAFORMAT_SUBTYPE_PCM;
    deviceExtension->Stream.Format.DataFormat.Specifier   = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;
    deviceExtension->Stream.Format.DataFormat.FormatSize  = sizeof( KSDATAFORMAT_WAVEFORMATEX );
    deviceExtension->Stream.Format.DataFormat.Reserved    = 0;
    deviceExtension->Stream.Format.DataFormat.Flags       = 0;
    deviceExtension->Stream.Format.DataFormat.SampleSize  = 0;
    deviceExtension->Stream.Format.WaveFormatEx.wFormatTag      = WAVE_FORMAT_PCM;
    deviceExtension->Stream.Format.WaveFormatEx.nChannels       = 2;
    deviceExtension->Stream.Format.WaveFormatEx.nSamplesPerSec  = 44100;
    deviceExtension->Stream.Format.WaveFormatEx.wBitsPerSample  = 16;
    deviceExtension->Stream.Format.WaveFormatEx.nAvgBytesPerSec = 44100*4;
    deviceExtension->Stream.Format.WaveFormatEx.nBlockAlign     = 4;
    deviceExtension->Stream.Format.WaveFormatEx.cbSize          = 0;

    //
    // set the volume, verify we're stopped
    //
    ASSERT(deviceExtension->CDRom.StateNow == CD_STOPPED);
    deviceExtension->CDRom.Volume.PortVolume[0] = 0xff;
    deviceExtension->CDRom.Volume.PortVolume[1] = 0xff;
    deviceExtension->CDRom.Volume.PortVolume[2] = 0xff;
    deviceExtension->CDRom.Volume.PortVolume[3] = 0xff;

    //
    // Register for Pnp Notifications for SysAudio
    //

    ASSERT(deviceExtension->Stream.SysAudioReg == NULL);

    //
    // read the defaults from the registry
    //

    RedBookRegistryRead(deviceExtension);

    //
    // get max transfer of adapter
    //
    status = RedBookSetTransferLength(deviceExtension);
    if (!NT_SUCCESS(status)){
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] RedBookSetTransferLength failed with %x\n", status));
        return status;
    }

    //
    // and write the new values (just in case)
    //

    RedBookRegistryWrite(deviceExtension);

    //
    // also init the WmiPerf structure
    //

    KeInitializeSpinLock(&deviceExtension->WmiPerfLock);
    RtlZeroMemory(&deviceExtension->WmiPerf, sizeof(REDBOOK_WMI_PERF_DATA));


    //
    // Note dependency in OpenSysAudio() in sysaudio.c
    //

    if (deviceExtension->Stream.SysAudioReg == NULL) {
        status = IoRegisterPlugPlayNotification(
                    EventCategoryDeviceInterfaceChange,
                    PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES,
                    (GUID*)&KSCATEGORY_PREFERRED_WAVEOUT_DEVICE,
                    deviceExtension->DriverObject,
                    SysAudioPnpNotification,
                    deviceExtension,
                    &deviceExtension->Stream.SysAudioReg
                    );

        if (!NT_SUCCESS(status)) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                       "StartDevice !! Unable to register for sysaudio pnp "
                       "notifications %x\n", status));
            deviceExtension->Stream.SysAudioReg = NULL;
            return status;
        }
    }

    //
    // initialize WMI now that wmi settings are initialized
    //
    status = RedBookWmiInit(deviceExtension);

    if (!NT_SUCCESS(status)) {
        RedBookLogError(deviceExtension,
                        REDBOOK_ERR_WMI_INIT_FAILED,
                        status);
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                   "AddDevice !! WMI Init failed %lx\n",
                   status));
        return status;
    }

    //
    // log an error if drive doesn't support accurate reads
    //

    if (!deviceExtension->WmiData.CDDAAccurate) {
        RedBookLogError(deviceExtension,
                        REDBOOK_ERR_UNSUPPORTED_DRIVE,
                        STATUS_SUCCESS);
    }

    #if DBG
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                   "StartDevice => DO %p SavedIoIndex @ %p  Starts @ %p  "
                   "Each is %x bytes in size\n",
                   DeviceObject,
                   &deviceExtension->SavedIoCurrentIndex,
                   &(deviceExtension->SavedIo[0]),
                   sizeof(SAVED_IO)));
    #endif

    deviceExtension->Pnp.Initialized = TRUE;

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
               "StartDevice => Finished Initialization\n"));
    return STATUS_SUCCESS;
}


VOID
RedBookUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is called when the control panel "Unloads"
    the CDROM device.

Arguments:

    DeviceObject

Return Value:

    void

--*/

{
    PREDBOOK_DRIVER_EXTENSION driverExtension;

    PAGED_CODE();
    ASSERT( DriverObject->DeviceObject == NULL );

    driverExtension = IoGetDriverObjectExtension(DriverObject,
                                                 REDBOOK_DRIVER_EXTENSION_ID);

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
               "Unload => Unloading for DriverObject %p, ext %p\n",
               DriverObject, driverExtension));

    if (driverExtension != NULL &&
        driverExtension->RegistryPath.Buffer != NULL ) {
        ExFreePool( driverExtension->RegistryPath.Buffer );
    }

#ifdef _USE_ETW
    WPP_CLEANUP(DriverObject);
#endif // _USE_ETW

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\redbook\sysaudio.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       sysaudio.c
//
//--------------------------------------------------------------------------


#include "redbook.h"
#include "proto.h"
#include <wdmguid.h>
#include <ksmedia.h>

#ifdef _USE_ETW
#include "sysaudio.tmh"
#endif // _USE_ETW

//////////////////////////////////////////////////////////////////////


#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, AttachVirtualSource)
    #pragma alloc_text(PAGE, CloseSysAudio)
    #pragma alloc_text(PAGE, GetPinProperty)
    #pragma alloc_text(PAGE, GetVolumeNodeId)
    #pragma alloc_text(PAGE, InitializeVirtualSource)
    #pragma alloc_text(PAGE, OpenInterfaceByGuid)
    #pragma alloc_text(PAGE, OpenSysAudio)
    #pragma alloc_text(PAGE, RedBookKsSetVolume)
    #pragma alloc_text(PAGE, SetNextDeviceState)
    #pragma alloc_text(PAGE, SysAudioPnpNotification)
    #pragma alloc_text(PAGE, UninitializeVirtualSource)
#endif // ALLOC_PRAGMA


//////////////////////////////////////////////////////////////////////

NTSTATUS
OpenSysAudio(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    This routine is a wrapper around all the work that must be done
    just to open sysaudio for playback.  the code was swiped from
    Win98, and then translated into CSN (Cutler Standard Notation)

Arguments:

    DeviceExtensionPinConnect - if successful, this will be the pin to send data to

    PinFileObject - if successful, the file object this pin is associated
        with is returned in this structure

    PinDeviceObject - if successful, the device object this pin is
        associated with is returned in this structure

    VolumeNodeId - ?? No idea what this is... yet.

Return Value:

    status

--*/


{
    PFILE_OBJECT guidFileObject;
    PFILE_OBJECT pinFileObject;
    HANDLE deviceHandle;
    NTSTATUS status;
    HANDLE pinHandle;
    ULONG volumeNodeId;
    ULONG mixerPinId;

    ULONG pins, pinId;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    guidFileObject = NULL;
    pinFileObject = NULL;
    deviceHandle = NULL;
    status = STATUS_SUCCESS;
    pinHandle = NULL;
    volumeNodeId = -1;
    mixerPinId = DeviceExtension->Stream.MixerPinId;


    TRY {
        ASSERT( mixerPinId != MAXULONG );

        //
        // Note dependency on IoRegisterPlugPlayNotification() in pnp.c
        //

        status = OpenInterfaceByGuid(
                                     //&KSCATEGORY_SYSAUDIO,
                                     &KSCATEGORY_PREFERRED_WAVEOUT_DEVICE,
                                     &deviceHandle,
                                     &guidFileObject);

        if (!NT_SUCCESS(status)) {
            LEAVE;
        }

        //
        // Get the number of pins
        //
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                   "SysAudio => Getting Pin Property PIN_CTYPES\n"));

        status = GetPinProperty(guidFileObject,
                                KSPROPERTY_PIN_CTYPES,
                                0, // doesn't matter for ctypes
                                sizeof(pins),
                                &pins);

        if (!NT_SUCCESS(status)) {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                       "SysAudio !! Unable to get number of pins %lx\n",
                       status));
            RedBookLogError(DeviceExtension,
                            REDBOOK_ERR_CANNOT_GET_NUMBER_OF_PINS,
                            status);
            LEAVE;
        }

        //
        // Try to get a matching pin -- brute force method
        //

        for( pinId = 0; pinId < pins; pinId++) {

            KSPIN_COMMUNICATION communication;
            KSPIN_DATAFLOW dataFlow;

            //
            // check communication of the pin. accept either
            // a sink or a pin that is both a source and sink
            //

            status = GetPinProperty(guidFileObject,
                                    KSPROPERTY_PIN_COMMUNICATION,
                                    pinId,
                                    sizeof(communication),
                                    &communication);

            if (!NT_SUCCESS(status)) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                           "SysAudio !! Pin %d communication query "
                           "failed %lx\n", pinId, status ));
                continue;
            }

            if ( communication != KSPIN_COMMUNICATION_SINK &&
                 communication != KSPIN_COMMUNICATION_BOTH ) continue;

            //
            // only use this pin if it accepts incoming data
            //

            status = GetPinProperty(guidFileObject,
                                    KSPROPERTY_PIN_DATAFLOW,
                                    pinId,
                                    sizeof(dataFlow),
                                    &dataFlow);

            if (!NT_SUCCESS(status)) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                           "SysAudio !! Pin %d dataflow query failed %lx\n",
                           pinId, status));
                continue;
            }

            if (dataFlow != KSPIN_DATAFLOW_IN) continue;

            //
            // we have found a matching pin, so attempt to connect
            //

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                       "SysAudio => Attempt to connect to pin %d\n", pinId));

            DeviceExtension->Stream.Connect.PinId       = pinId;
            DeviceExtension->Stream.Connect.PinToHandle = NULL;

            status = KsCreatePin(deviceHandle,
                                 &DeviceExtension->Stream.Connect,
                                 GENERIC_WRITE, // FILE_WRITE_ACCESS
                                 &pinHandle);

            if (!NT_SUCCESS(status)) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                           "SysAudio => Cannot create a writable pin %d\n",
                           pinId));
                continue;
            }

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                       "SysAudio => Connected to pin %d\n", pinId ));

            //
            // get the object associated with the pinHandle just created
            // so we can then get other information about the pin
            //

            status = ObReferenceObjectByHandle(pinHandle,
                                               GENERIC_READ | GENERIC_WRITE,
                                               NULL,
                                               KernelMode,
                                               &pinFileObject,
                                               NULL);

            if (!NT_SUCCESS(status)) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                             "SysAudio !! Object from handle for pin "
                             "failed %lx\n", status));
                LEAVE;
            }

            //
            // this allows us to change our output volume
            // this just sends a ks ioctl, no referencing done here
            //

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                       "SysAudio => Getting VolumeNodeId\n"));

            status = GetVolumeNodeId(pinFileObject,
                                     &volumeNodeId);

            if (!NT_SUCCESS(status)) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                           "SysAudio !! Unable to get volume node "
                           "id %lx\n", status));
                LEAVE;
            }

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                       "SysAudio => Attaching PinFileObject %p "
                       "to MixerPinId %d\n", pinFileObject,
                       mixerPinId));

            //
            // this just sends a ks ioctl, no referencing done here
            //

            status = AttachVirtualSource(pinFileObject, mixerPinId);

            if (!NT_SUCCESS(status)) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                           "SysAudio !! Unable to attach virtual "
                           "source %lx\n", status));
                LEAVE;
            }

            //
            // successful completion
            //

            status = STATUS_SUCCESS;

            LEAVE;
        }

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                   "Sysaudio !! Unable to connect to any pins\n"));
        RedBookLogError(DeviceExtension,
                        REDBOOK_ERR_CANNOT_CONNECT_TO_PLAYBACK_PINS,
                        status);

        //
        // no pin succeeded, so set status to failure
        //
        status = STATUS_INVALID_DEVICE_REQUEST;
        LEAVE;


    } FINALLY {

        //
        // the pin handle is not required, as we've referenced
        // the pin in pinFileObject.  close it here.
        //

        if (pinHandle != NULL) {
            ZwClose(pinHandle);
            pinHandle = NULL;
        }

        //
        // the device handle is only required to create
        // the actual pin.  close it here.
        //

        if (deviceHandle != NULL) {
            ZwClose(deviceHandle);
            deviceHandle = NULL;
        }

        //
        // the guidFileObject is also only required to query
        // and create the pins.  close it here.
        //
        // (pinFileObject is still important)
        //

        if (guidFileObject != NULL) {
            ObDereferenceObject(guidFileObject);
            guidFileObject = NULL;
        }

        if (!NT_SUCCESS(status)) {

            if (pinFileObject != NULL) {
                ObDereferenceObject(pinFileObject);
                pinFileObject = NULL;
            }

        }

    }

    //
    // the MixerPinId should not have changed in this function
    //

    ASSERT(mixerPinId == DeviceExtension->Stream.MixerPinId);

    if (NT_SUCCESS(status)) {

        DeviceExtension->Stream.PinFileObject   = pinFileObject;
        DeviceExtension->Stream.PinDeviceObject =
            IoGetRelatedDeviceObject(pinFileObject);
        DeviceExtension->Stream.VolumeNodeId = volumeNodeId;

    } else {

        DeviceExtension->Stream.PinFileObject   = NULL;
        DeviceExtension->Stream.PinDeviceObject = NULL;
        DeviceExtension->Stream.VolumeNodeId = -1;

    }

    return status;

}

NTSTATUS
    CloseSysAudio(
        PREDBOOK_DEVICE_EXTENSION DeviceExtension
        )
{
    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    ASSERT(DeviceExtension->Stream.PinFileObject);
    ASSERT(DeviceExtension->Stream.PinDeviceObject);

    ObDereferenceObject(DeviceExtension->Stream.PinFileObject);
    DeviceExtension->Stream.PinDeviceObject = NULL;
    DeviceExtension->Stream.PinFileObject = NULL;

    return STATUS_SUCCESS;
}

NTSTATUS
GetPinProperty(
    IN  PFILE_OBJECT FileObject,
    IN  ULONG        PropertyId,
    IN  ULONG        PinId,
    IN  ULONG        PropertySize,
    OUT PVOID        Property
    )
/*++

Routine Description:

    another wrapper to hide getting pin properties

Arguments:

    FileObject - file object to query

    PropertyId - what property to query

    PinId - which pin to query

    PropertySize - size of output buffer

    Property - output buffer for property

Return Value:

    status

--*/
{
    ULONG    bytesReturned;
    KSP_PIN  prop = {0};
    NTSTATUS status;

    PAGED_CODE();

    prop.Property.Set       = KSPROPSETID_Pin;
    prop.Property.Id        = PropertyId;
    prop.Property.Flags     = KSPROPERTY_TYPE_GET;
    prop.PinId              = PinId;
    prop.Reserved           = 0;

    status = KsSynchronousIoControlDevice( FileObject,
                                           KernelMode,
                                           IOCTL_KS_PROPERTY,
                                           &prop,
                                           sizeof(prop),
                                           Property,
                                           PropertySize,
                                           &bytesReturned
                                           );

    if ( !NT_SUCCESS(status) ) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                   "GetPinProperty !! fileobj %p  property %p  "
                   "pin %d  status %lx\n",
                   FileObject, Property, PinId, status));
        return status;
    }

    ASSERT( bytesReturned == PropertySize );
    return status;
}

NTSTATUS
GetVolumeNodeId(
    IN  PFILE_OBJECT FileObject,
    OUT PULONG       VolumeNodeId
    )
/*++

Routine Description:

    Gets the pin to set the volume for playback

Arguments:

    FileObject - The fileobject which contains the pin

    VolumeNodeId - id of the volume node

Return Value:

    status

--*/
{
    KSPROPERTY property = {0};
    ULONG      bytesReturned;
    NTSTATUS   status;

    PAGED_CODE();

    property.Set   = KSPROPSETID_Sysaudio_Pin;
    property.Id    = KSPROPERTY_SYSAUDIO_PIN_VOLUME_NODE;
    property.Flags = KSPROPERTY_TYPE_GET;

    status = KsSynchronousIoControlDevice( FileObject,
                                           KernelMode,
                                           IOCTL_KS_PROPERTY,
                                           &property,
                                           sizeof(property),
                                           VolumeNodeId,
                                           sizeof(ULONG),
                                           &bytesReturned
                                           );

    if ( !NT_SUCCESS(status) ) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                   "GetVolumeNodeId !! fileobj %p status %lx\n",
                   FileObject, status));
        return status;
    }

    ASSERT(bytesReturned == sizeof(ULONG));
    return(status);
}


NTSTATUS
UninitializeVirtualSource(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
{
    ULONG state;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    ASSERT(DeviceExtension->Stream.MixerPinId != -1);
    ASSERT(DeviceExtension->Stream.MixerFileObject != NULL);

    state = GetCdromState(DeviceExtension);
    ASSERT(state == CD_STOPPED);

    DeviceExtension->Stream.MixerPinId = -1;
    ObDereferenceObject(DeviceExtension->Stream.MixerFileObject);
    DeviceExtension->Stream.MixerFileObject = NULL;

    return STATUS_SUCCESS;
}


NTSTATUS
InitializeVirtualSource(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

Arguments:

    MixerPinId - initialized to the correct pin id of mixer

Return Value:

    status

--*/
{
    SYSAUDIO_CREATE_VIRTUAL_SOURCE createVirtualSource = {0};
    PFILE_OBJECT                   fileObject;
    NTSTATUS                       status;
    HANDLE                         deviceHandle;
    ULONG                          bytesReturned;
    ULONG                          mixerPinId;
    ULONG                          state;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    ASSERT(DeviceExtension->Stream.MixerPinId == -1);
    ASSERT(DeviceExtension->Stream.MixerFileObject == NULL);

    state = GetCdromState(DeviceExtension);
    ASSERT(state == CD_STOPPED);

    fileObject = NULL;
    status = STATUS_SUCCESS;
    deviceHandle = NULL;
    mixerPinId = -1;

    //
    // use IoGetDeviceInterfaces()
    //
    status = OpenInterfaceByGuid(&KSCATEGORY_SYSAUDIO,
                                 &deviceHandle,
                                 &fileObject);

    if ( !NT_SUCCESS(status) ) {
        RedBookLogError(DeviceExtension,
                        REDBOOK_ERR_CANNOT_OPEN_SYSAUDIO_MIXER,
                        status);
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                   "CreateVirtSource !! Unable to open sysaudio\\mixer %lx\n",
                   status));
        goto exit;
    }

    createVirtualSource.Property.Set   = KSPROPSETID_Sysaudio;
    createVirtualSource.Property.Id    = KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE;
    createVirtualSource.Property.Flags = KSPROPERTY_TYPE_GET;
    createVirtualSource.PinCategory    = KSNODETYPE_CD_PLAYER;
    createVirtualSource.PinName        = KSNODETYPE_CD_PLAYER;

    status = KsSynchronousIoControlDevice(fileObject,
                                          KernelMode,
                                          IOCTL_KS_PROPERTY,
                                          &createVirtualSource,
                                          sizeof(createVirtualSource),
                                          &mixerPinId,
                                          sizeof(ULONG), // MixerPinId
                                          &bytesReturned
                                          );

    if ( !NT_SUCCESS(status) ) {
        RedBookLogError(DeviceExtension,
                        REDBOOK_ERR_CANNOT_CREATE_VIRTUAL_SOURCE,
                        status);
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                   "CreateVirtSource !! creating virtual source "
                   "failed %lx\n", status));
        goto exit;
    }

    ASSERT( bytesReturned == sizeof(ULONG) );

exit:

    if (NT_SUCCESS(status)) {

        DeviceExtension->Stream.MixerPinId = mixerPinId;
        DeviceExtension->Stream.MixerFileObject = fileObject;

    } else if (fileObject != NULL) {

        //
        // failed to open, so deref object if non-null
        //

        ObDereferenceObject(fileObject);
        fileObject = NULL;

    }

    if (deviceHandle != NULL) {
        ZwClose(deviceHandle);
        deviceHandle = NULL;
    }


    return status;
}

NTSTATUS
AttachVirtualSource(
    IN  PFILE_OBJECT PinFileObject,
    IN  ULONG        MixerPinId
    )
/*++

Routine Description:


Arguments:

    FileObject - ??

    MixerPinId - ??

Return Value:

    status

--*/
{
    SYSAUDIO_ATTACH_VIRTUAL_SOURCE attachVirtualSource = {0};
    NTSTATUS status;
    ULONG bytesReturned;

    PAGED_CODE();

    //
    // if the source hasn't been initialized, reject this
    // request as invalid
    //

    if(MixerPinId == MAXULONG) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                   "AttatchVirtSource !! Mixer Pin uninitialized\n"));
        ASSERT(!"Mixer Pin Uninitialized");
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    attachVirtualSource.Property.Set   = KSPROPSETID_Sysaudio_Pin;
    attachVirtualSource.Property.Id    = KSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE;
    attachVirtualSource.Property.Flags = KSPROPERTY_TYPE_SET;
    attachVirtualSource.MixerPinId     = MixerPinId;

    status = KsSynchronousIoControlDevice(PinFileObject,
                                          KernelMode,
                                          IOCTL_KS_PROPERTY,
                                          &attachVirtualSource,
                                          sizeof(attachVirtualSource),
                                          NULL,
                                          0,
                                          &bytesReturned
                                          );

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                   "AttachVirtSource !! Couldn't attatch %lx\n", status));
        return status;
    }
    return status;
}

VOID
SetNextDeviceState(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    KSSTATE State
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    KSIDENTIFIER stateProperty = {0};
    NTSTATUS     status;
    ULONG        bytesReturned;
    KSSTATE      acquireState;
    PFILE_OBJECT fileObject;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    fileObject = DeviceExtension->Stream.PinFileObject;

    acquireState = KSSTATE_ACQUIRE;

    stateProperty.Set   = KSPROPSETID_Connection;
    stateProperty.Id    = KSPROPERTY_CONNECTION_STATE;
    stateProperty.Flags = KSPROPERTY_TYPE_SET;

    ASSERT(fileObject);
    status = KsSynchronousIoControlDevice(fileObject,
                                          KernelMode,
                                          IOCTL_KS_PROPERTY,
                                          &stateProperty,
                                          sizeof(stateProperty),
                                          &acquireState,
                                          sizeof(acquireState),
                                          &bytesReturned
                                          );

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                   "SetDeviceState => (1) Audio device error %x.  need to "
                   "stop playback AND change audio devices\n", status));
    }

    //
    // now that it's acquired, set the new state
    //

    stateProperty.Set   = KSPROPSETID_Connection;
    stateProperty.Id    = KSPROPERTY_CONNECTION_STATE;
    stateProperty.Flags = KSPROPERTY_TYPE_SET;

    status = KsSynchronousIoControlDevice(fileObject,
                                          KernelMode,
                                          IOCTL_KS_PROPERTY,
                                          &stateProperty,
                                          sizeof(stateProperty),
                                          &State,
                                          sizeof(State),
                                          &bytesReturned
                                          );
    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                   "SetDeviceState => (2) Audio device error %x.  need to "
                   "stop playback AND change audio devices\n", status));
    }
    return;
}

//////////////////////////////////////////////////////////////////////
//                                                                  //
// this table is in 1/65536 decibles for a UCHAR setting:           //
//    20 * log10( Level / 256 ) * 65536                             //
//                                                                  //
//////////////////////////////////////////////////////////////////////

AttenuationTable[] = {
    0x7fffffff, 0xffcfd5d0, 0xffd5db16, 0xffd960ad, //  0- 3
    0xffdbe05c, 0xffddd08a, 0xffdf65f3, 0xffe0bcb7, //  4- 7
    0xffe1e5a2, 0xffe2eb89, 0xffe3d5d0, 0xffe4a9be, //  8- b
    0xffe56b39, 0xffe61d34, 0xffe6c1fd, 0xffe75b67, //  c- f
    0xffe7eae8, 0xffe871b6, 0xffe8f0cf, 0xffe96908, // 10-13
    0xffe9db16, 0xffea4793, 0xffeaaf04, 0xffeb11dc, // 14-17
    0xffeb707f, 0xffebcb44, 0xffec227a, 0xffec7665, // 18-1b
    0xffecc743, 0xffed154b, 0xffed60ad, 0xffeda996, // 1c-1f
    0xffedf02e, 0xffee349b, 0xffee76fc, 0xffeeb771, // 20-23
    0xffeef615, 0xffef3302, 0xffef6e4e, 0xffefa810, // 24-27
    0xffefe05c, 0xfff01744, 0xfff04cda, 0xfff0812c, // 28-2b
    0xfff0b44b, 0xfff0e643, 0xfff11722, 0xfff146f4, // 2c-2f
    0xfff175c5, 0xfff1a39e, 0xfff1d08a, 0xfff1fc93, // 30-33
    0xfff227c0, 0xfff2521b, 0xfff27bab, 0xfff2a478, // 34-37
    0xfff2cc89, 0xfff2f3e5, 0xfff31a91, 0xfff34093, // 38-3b
    0xfff365f3, 0xfff38ab4, 0xfff3aedc, 0xfff3d270, // 3c-3f
    0xfff3f574, 0xfff417ee, 0xfff439e1, 0xfff45b51, // 40-43
    0xfff47c42, 0xfff49cb8, 0xfff4bcb7, 0xfff4dc42, // 44-47
    0xfff4fb5b, 0xfff51a07, 0xfff53848, 0xfff55621, // 48-4b
    0xfff57394, 0xfff590a5, 0xfff5ad56, 0xfff5c9aa, // 4c-4f
    0xfff5e5a2, 0xfff60142, 0xfff61c8a, 0xfff6377e, // 50-53
    0xfff65220, 0xfff66c70, 0xfff68672, 0xfff6a027, // 54-57
    0xfff6b991, 0xfff6d2b1, 0xfff6eb89, 0xfff7041b, // 58-5b
    0xfff71c68, 0xfff73472, 0xfff74c3a, 0xfff763c2, // 5c-5f
    0xfff77b0b, 0xfff79216, 0xfff7a8e4, 0xfff7bf77, // 60-63
    0xfff7d5d0, 0xfff7ebf0, 0xfff801d9, 0xfff8178a, // 64-67
    0xfff82d06, 0xfff8424d, 0xfff85761, 0xfff86c42, // 68-6b
    0xfff880f1, 0xfff89570, 0xfff8a9be, 0xfff8bdde, // 6c-6f
    0xfff8d1cf, 0xfff8e593, 0xfff8f92b, 0xfff90c96, // 70-73
    0xfff91fd7, 0xfff932ed, 0xfff945d9, 0xfff9589d, // 74-77
    0xfff96b39, 0xfff97dad, 0xfff98ffa, 0xfff9a221, // 78-7b
    0xfff9b422, 0xfff9c5fe, 0xfff9d7b6, 0xfff9e94a, // 7c-7f
    0xfff9faba, 0xfffa0c08, 0xfffa1d34, 0xfffa2e3e, // 80-83
    0xfffa3f27, 0xfffa4fef, 0xfffa6097, 0xfffa711f, // 84-87
    0xfffa8188, 0xfffa91d3, 0xfffaa1ff, 0xfffab20d, // 88-8b
    0xfffac1fd, 0xfffad1d1, 0xfffae188, 0xfffaf122, // 8c-8f
    0xfffb00a1, 0xfffb1004, 0xfffb1f4d, 0xfffb2e7a, // 90-93
    0xfffb3d8e, 0xfffb4c87, 0xfffb5b67, 0xfffb6a2d, // 94-97
    0xfffb78da, 0xfffb876f, 0xfffb95eb, 0xfffba450, // 98-9b
    0xfffbb29c, 0xfffbc0d2, 0xfffbcef0, 0xfffbdcf7, // 9c-9f
    0xfffbeae8, 0xfffbf8c3, 0xfffc0688, 0xfffc1437, // a0-a3
    0xfffc21d0, 0xfffc2f55, 0xfffc3cc4, 0xfffc4a1f, // a4-a7
    0xfffc5766, 0xfffc6498, 0xfffc71b6, 0xfffc7ec1, // a8-ab
    0xfffc8bb8, 0xfffc989c, 0xfffca56d, 0xfffcb22b, // ac-af
    0xfffcbed7, 0xfffccb70, 0xfffcd7f7, 0xfffce46c, // b0-b3
    0xfffcf0cf, 0xfffcfd21, 0xfffd0961, 0xfffd1590, // b4-b7
    0xfffd21ae, 0xfffd2dbc, 0xfffd39b8, 0xfffd45a4, // b8-bb
    0xfffd5180, 0xfffd5d4c, 0xfffd6908, 0xfffd74b4, // bc-bf
    0xfffd8051, 0xfffd8bde, 0xfffd975c, 0xfffda2ca, // c0-c3
    0xfffdae2a, 0xfffdb97b, 0xfffdc4bd, 0xfffdcff1, // c4-c7
    0xfffddb16, 0xfffde62d, 0xfffdf136, 0xfffdfc31, // c8-cb
    0xfffe071f, 0xfffe11fe, 0xfffe1cd0, 0xfffe2795, // cc-cf
    0xfffe324c, 0xfffe3cf6, 0xfffe4793, 0xfffe5224, // d0-d3
    0xfffe5ca7, 0xfffe671e, 0xfffe7188, 0xfffe7be6, // d4-d7
    0xfffe8637, 0xfffe907d, 0xfffe9ab6, 0xfffea4e3, // d8-db
    0xfffeaf04, 0xfffeb91a, 0xfffec324, 0xfffecd22, // dc-df
    0xfffed715, 0xfffee0fd, 0xfffeead9, 0xfffef4aa, // e0-e3
    0xfffefe71, 0xffff082c, 0xffff11dc, 0xffff1b82, // e4-e7
    0xffff251d, 0xffff2ead, 0xffff3833, 0xffff41ae, // e8-eb
    0xffff4b1f, 0xffff5486, 0xffff5de3, 0xffff6736, // ec-ef
    0xffff707f, 0xffff79be, 0xffff82f3, 0xffff8c1e, // f0-f3
    0xffff9540, 0xffff9e58, 0xffffa767, 0xffffb06c, // f4-f7
    0xffffb968, 0xffffc25b, 0xffffcb44, 0xffffd425, // f8-fb
    0xffffdcfc, 0xffffe5ca, 0xffffee90, 0x00000000, // fc-ff
};

#define DA_CHANNEL_LEFT  0
#define DA_CHANNEL_RIGHT 1
#define DA_CHANNEL_MAX   2

VOID
RedBookKsSetVolume(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    KSNODEPROPERTY_AUDIO_CHANNEL volumeProperty = {0};
    VOLUME_CONTROL volume = {0};
    NTSTATUS status;
    ULONG32 channel;
    ULONG32 bytesReturned = 0;
    BOOLEAN mute;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    volume = DeviceExtension->CDRom.Volume;

    //
    // These settings are common for all the sets
    //

    volumeProperty.NodeProperty.Property.Set   = KSPROPSETID_Audio;
    volumeProperty.NodeProperty.Property.Flags = KSPROPERTY_TYPE_SET |
                                                 KSPROPERTY_TYPE_TOPOLOGY;
    volumeProperty.NodeProperty.NodeId = DeviceExtension->Stream.VolumeNodeId;

    //
    // Do both Left and right channels
    //

    for ( channel = 0; channel < DA_CHANNEL_MAX; channel++ ) {

        //
        // handle the correct channel
        //

        volumeProperty.Channel = channel;

        //
        // if not muting the channel, set the volume
        //

        if ( volume.PortVolume[channel] != 0 ) {
            ULONG32 level;
            ULONG32 index;

            volumeProperty.NodeProperty.Property.Id = KSPROPERTY_AUDIO_VOLUMELEVEL;

            level = AttenuationTable[ volume.PortVolume[channel] ];

            ASSERT(DeviceExtension->Stream.PinFileObject);

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                       "SetVolume => Setting channel %d to %lx\n",
                       channel, level ));
            status = KsSynchronousIoControlDevice(DeviceExtension->Stream.PinFileObject,
                                                  KernelMode,
                                                  IOCTL_KS_PROPERTY,
                                                  &volumeProperty,
                                                  sizeof(volumeProperty),
                                                  &level,
                                                  sizeof(level),
                                                  &bytesReturned
                                                  );
            // ASSERT( NT_SUCCESS(status) );
            mute = FALSE;
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                       "SetVolume => Un-Muting channel %d\n", channel));
        } else {
            mute = TRUE;
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                       "SetVolume => Muting channel %d\n", channel));
        }
        volumeProperty.NodeProperty.Property.Id    = KSPROPERTY_AUDIO_MUTE;

        status = KsSynchronousIoControlDevice(DeviceExtension->Stream.PinFileObject,
                                              KernelMode,
                                              IOCTL_KS_PROPERTY,
                                              &volumeProperty,
                                              sizeof(volumeProperty),
                                              &mute,
                                              sizeof(mute),
                                              &bytesReturned
                                              );
        // ASSERT( NT_SUCCESS(status) );

    }

    //
    // End of all channels
    //

    return;

}


NTSTATUS
OpenInterfaceByGuid(
    IN  CONST GUID   * InterfaceClassGuid,
    OUT HANDLE       * Handle,
    OUT PFILE_OBJECT * FileObject
    )
{
    PWSTR tempString;
    PWSTR symbolicLinkList;
    HANDLE localHandle;
    PFILE_OBJECT localFileObject;
    NTSTATUS status;

    PAGED_CODE();

    localHandle = NULL;
    tempString = NULL;
    symbolicLinkList = NULL;
    *Handle = NULL;
    *FileObject = NULL;

    status = IoGetDeviceInterfaces(InterfaceClassGuid,
                                   // currently, the GUID is one of
                                   //  KSCATEGORY_PREFERRED_WAVEOUT_DEVICE
                                   //  or KSCATEGORY_SYSAUDIO
                                   NULL, // no preferred device object
                                   0,
                                   &symbolicLinkList);
    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                   "OpenDevice !! IoGetDeviceInterfaces failed %x\n",
                   status));
        return status;
    }

#if DBG
    tempString = symbolicLinkList;
    while (*tempString != UNICODE_NULL) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                   "OpenDevice => Possible Device: %ws\n", tempString));

        //
        // get the next symbolic link
        //

        while(*tempString++ != UNICODE_NULL) {
            NOTHING;
        }
    }
#endif

    //
    // this code is proudly propogated from wdmaud.sys
    //

    tempString = symbolicLinkList;
    while (*tempString != UNICODE_NULL) {

        IO_STATUS_BLOCK   ioStatusBlock;
        UNICODE_STRING    deviceString;
        OBJECT_ATTRIBUTES objectAttributes;

        RtlInitUnicodeString( &deviceString, tempString);

        InitializeObjectAttributes(&objectAttributes,
                                   &deviceString,
                                   OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                   NULL,
                                   NULL
                                   );

        //
        // could use IoCreateFile(), based on
        // ntos\dd\wdm\audio\legacy\wdmaud.sys\sysaudio.c:OpenDevice()
        //

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                   "OpenDevice => Opening %ws\n", tempString));
        status = ZwCreateFile(&localHandle,
                              GENERIC_READ | GENERIC_WRITE,
                              &objectAttributes,
                              &ioStatusBlock,
                              NULL,       // ignored on non-create
                              FILE_ATTRIBUTE_NORMAL,
                              0,          // no share access
                              FILE_OPEN,  // open the existing file
                              0, NULL, 0  // options
                              );

        if (NT_SUCCESS(status)) {

            ASSERT(localHandle != NULL);
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                       "OpenDevice => Opened %ws\n", tempString));
            break; // out of the while loop

        }

        ASSERT(localHandle == NULL);

        //
        // get the next symbolic link
        //

        while(*tempString++ != UNICODE_NULL) {
            NOTHING;
        }

    }

    if (symbolicLinkList != NULL) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                   "OpenDevice => Freeing list from IoGetDevInt...\n"));
        ExFreePool(symbolicLinkList);
        symbolicLinkList = NULL;
        tempString = NULL;
    }


    //
    // if succeeded to open the file, try to get
    // the FileObject that is related to this handle.
    //

    if (localHandle != NULL) {

        status = ObReferenceObjectByHandle(localHandle,
                                           GENERIC_READ | GENERIC_WRITE,
                                           NULL,
                                           KernelMode,
                                           &localFileObject, // double pointer
                                           NULL);

        if (NT_SUCCESS(status)) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                       "OpenDevice => Succeeded\n"));

            *Handle = localHandle;
            *FileObject = localFileObject;

            return status; // Exit point for success
        }

        ZwClose(localHandle);
        localHandle = NULL;

    }

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
               "OpenDevice => unable to open any audio devices\n"));
    status = STATUS_NO_SUCH_DEVICE;
    return status;


}


NTSTATUS
SysAudioPnpNotification(
    PDEVICE_INTERFACE_CHANGE_NOTIFICATION Notification,
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    InterlockedExchange(&DeviceExtension->Stream.UpdateMixerPin, 1);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\redbook\thread.c ===
/*++
Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    thread.c

Abstract:


Author:


Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "redbook.h"
#include "ntddredb.h"
#include "proto.h"
#include <scsi.h>      // for SetKnownGoodDrive()
#include <stdio.h>     // vsprintf()

#ifdef _USE_ETW
#include "thread.tmh"
#endif // _USE_ETW

//
// this is how many seconds until resources are free'd from
// a play, and also how long (in seconds) before a frozen state
// is detected (and a fix attempted).
//

#define REDBOOK_THREAD_FIXUP_SECONDS          10
#define REDBOOK_THREAD_SYSAUDIO_CACHE_SECONDS  2
#define REDBOOK_PERFORM_STUTTER_CONTROL        0

#if DBG

    //
    // allows me to send silence to ks as needed
    //

    ULONG RedBookForceSilence = FALSE;

#endif

#ifdef ALLOC_PRAGMA

    #pragma alloc_text(PAGE,   RedBookAllocatePlayResources      )
    #pragma alloc_text(PAGE,   RedBookCacheToc                   )
    #pragma alloc_text(PAGE,   RedBookDeallocatePlayResources    )
    #pragma alloc_text(PAGERW, RedBookReadRaw                    )
    #pragma alloc_text(PAGERW, RedBookStream                     )
    #pragma alloc_text(PAGE,   RedBookSystemThread               )
    #pragma alloc_text(PAGE,   RedBookCheckForAudioDeviceRemoval )
    #pragma alloc_text(PAGE,   RedBookThreadDigitalHandler       )

/*
    but last two CANNOT be unlocked when playing,
    so they are (temporarily) commented out.
    eventually will only have them locked when playing

    #pragma alloc_text(PAGERW, RedBookReadRawCompletion          )
    #pragma alloc_text(PAGERW, RedBookStreamCompletion           )

*/

#endif ALLOC_PRAGMA


VOID
RedBookSystemThread(
    PVOID Context
    )
/*++

Routine Description:

    This system thread will wait on events,
    sending buffers to Kernel Streaming as they
    become available.

Arguments:

    Context - deviceExtension

Return Value:

    status

--*/
{
    PREDBOOK_DEVICE_EXTENSION deviceExtension = Context;
    LARGE_INTEGER timeout;
    NTSTATUS waitStatus;
    ULONG    i;
    ULONG    timeouts;
    LARGE_INTEGER stopTime;

    //
    // some per-thread state
    //

    BOOLEAN  killed = FALSE;

    PAGED_CODE();

    deviceExtension->Thread.SelfPointer = PsGetCurrentThread();

    //
    // perf fix -- run at low realtime priority
    //

    KeSetPriorityThread(KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

    timeouts = 0;
    stopTime.QuadPart = 0;

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
               "Thread => UpdateMixerPin at %p\n",
               &deviceExtension->Stream.UpdateMixerPin));

    //
    // Just loop waiting for events.
    //

    //waitForNextEvent:
    while ( 1 ) {

        //
        // if are killed, just wait on singular event--EVENT_DIGITAL until
        // can finish processing.  there should not be anything left in the
        // IOCTL_LIST (since the kill calls RemoveLockAndWait() first)
        //
        // this also implies that a kill will never occur while ioctls are
        // still being processed.  this does not guarantee the state will
        // be STOPPED, just that no IO will be occurring.
        //


        //
        // nanosecond is 10^-9, units is 100 nanoseconds
        // so seconds is 10,000,000 units
        // must wait in relative time, which requires negative numbers
        //

        timeout.QuadPart = (LONGLONG)(-1 * 10 * 1000 * (LONGLONG)1000);

        //
        // note: we are using a timeout mechanism mostly to catch bugs
        //       where the state would lock up.  we also "auto adjust"
        //       our internal state if things get too wierd, basically
        //       auto-fixing ourselves.  note that this does cause the
        //       thread's stack to be swapped in, so this shouldn't
        //       be done when we're 100% stopped.
        //

        if (deviceExtension->Thread.IoctlCurrent == NULL) {

            //
            // wait on an ioctl, but not the ioctl completion event
            //

            ULONG state = GetCdromState(deviceExtension);
            if ((state == CD_STOPPED) &&
                (!RedBookArePlayResourcesAllocated(deviceExtension))
                ) {

                //
                // if we've got no current ioctl and we haven't allocated
                // any resources, there're no need to timeout.
                // this will prevent this stack from getting swapped in
                // needlessly, reducing effective footprint a bit
                //

                stopTime.QuadPart = 0;
                waitStatus = KeWaitForMultipleObjects(EVENT_MAXIMUM - 1,
                                                      (PVOID)(&deviceExtension->Thread.Events[0]),
                                                      WaitAny,
                                                      Executive,
                                                      UserMode,
                                                      FALSE, // Alertable
                                                      NULL,
                                                      deviceExtension->Thread.EventBlock
                                                      );

            } else {

                //
                // we've got no current ioctl, but we're also not stopped.
                // it is also possible to be waiting to cleanup resources here.
                // even if we're paused, we want to keep track of what's
                // going on, since it's possible for the state to get
                // messed up here.
                //

                waitStatus = KeWaitForMultipleObjects(EVENT_MAXIMUM - 1,
                                                      (PVOID)(&deviceExtension->Thread.Events[0]),
                                                      WaitAny,
                                                      Executive,
                                                      UserMode,
                                                      FALSE, // Alertable
                                                      &timeout,
                                                      deviceExtension->Thread.EventBlock
                                                      );

            }


        } else {

            //
            // wait on the ioctl completion, but not the ioctl event
            //

            waitStatus = KeWaitForMultipleObjects(EVENT_MAXIMUM - 1,
                                                  (PVOID)(&deviceExtension->Thread.Events[1]),
                                                  WaitAny,
                                                  Executive,
                                                  UserMode,
                                                  FALSE, // Alertable
                                                  &timeout,
                                                  deviceExtension->Thread.EventBlock
                                                  );
            if (waitStatus != STATUS_TIMEOUT) {
                waitStatus ++; // to account for offset
            }

        }

        //
        // need to check if we are stopped for too long -- if so, free
        // the resources.
        //
        {
            ULONG state = GetCdromState(deviceExtension);

            if (!TEST_FLAG(state, CD_PLAYING) && !TEST_FLAG(state, CD_PAUSED)) {

                LARGE_INTEGER now;

                // not playing,
                if (stopTime.QuadPart == 0) {

                    LONGLONG offset;

                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                               "StopTime => Determining when to dealloc\n"));

                    // query the time
                    KeQueryTickCount( &stopTime );

                    // add appropriate offset
                    // nanosecond is 10^-9, units is 100 nanoseconds
                    // so seconds is 10,000,000 units
                    //
                    offset = REDBOOK_THREAD_SYSAUDIO_CACHE_SECONDS;
                    offset *= (LONGLONG)(10 * 1000 * (LONGLONG)1000);

                    // divide offset by time increment
                    offset /= (LONGLONG)KeQueryTimeIncrement();

                    // add those ticks to store when we should release
                    // our resources
                    stopTime.QuadPart += offset;

                }

                KeQueryTickCount(&now);

                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                           "StopTime => Is %I64x >= %I64x?\n",
                           now.QuadPart,
                           stopTime.QuadPart
                           ));

                if (now.QuadPart >= stopTime.QuadPart) {
                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                               "StopTime => Deallocating resources\n"));
                    RedBookDeallocatePlayResources(deviceExtension);
                }

            } else {

                stopTime.QuadPart = 0;

            }
        }


        RedBookCheckForAudioDeviceRemoval(deviceExtension);

        //
        // To enable a single thread for multiple cdroms, just set events
        // at offset of (DEVICE_ID * EVENT_MAX) + EVENT_TO_SET
        // set deviceExtension = waitStatus / EVENT_MAX
        // switch ( waitStatus % EVENT_MAX )
        //
        if (waitStatus == EVENT_DIGITAL) {
            timeouts = 0;
        }

        switch ( waitStatus ) {

            case EVENT_IOCTL: {

                PLIST_ENTRY listEntry;
                while ((listEntry = ExInterlockedRemoveHeadList(
                            &deviceExtension->Thread.IoctlList,
                            &deviceExtension->Thread.IoctlLock)) != NULL) {

                    RedBookThreadIoctlHandler(deviceExtension, listEntry);

                    if (deviceExtension->Thread.IoctlCurrent) {
                        // special case
                        break;
                    }

                }

                break;
            }
            case EVENT_COMPLETE: {
                RedBookThreadIoctlCompletionHandler(deviceExtension);
                break;
            }

            case EVENT_WMI: {

                PLIST_ENTRY listEntry;
                while ((listEntry = ExInterlockedRemoveHeadList(
                            &deviceExtension->Thread.WmiList,
                            &deviceExtension->Thread.WmiLock)) != NULL) {

                    RedBookThreadWmiHandler(deviceExtension, listEntry);

                }
                break;
            }

            case EVENT_DIGITAL: {

                PLIST_ENTRY listEntry;
                while ((listEntry = ExInterlockedRemoveHeadList(
                            &deviceExtension->Thread.DigitalList,
                            &deviceExtension->Thread.DigitalLock)) != NULL) {

                    RedBookThreadDigitalHandler(deviceExtension, listEntry);

                }
                break;
            }

            case EVENT_KILL_THREAD: {

                ULONG state = GetCdromState(deviceExtension);

                killed = TRUE;

                //
                // If audio had been paused, clean up appropriately
                //

                if (TEST_FLAG(state, CD_PAUSED) && !TEST_FLAG(state, CD_MASK_TEMP))
                {
                    state = SetCdromState(deviceExtension, state, CD_STOPPING);
                    state = SetCdromState(deviceExtension, state, CD_STOPPED);
                }

                if (!TEST_FLAG(state, CD_STOPPED))
                {
                    //
                    // We are either in  a transcient state or still playing
                    // This should not happen as we wait for the remove lock
                    // count to drop to zero before signaling  the thread to
                    // exit
                    //

                    ASSERT(!"[redbook] ST !! Thread has been requested to shutdown while in an inconsistent state");

                    state = SetCdromState(deviceExtension, state, CD_STOPPING);
                    break;
                }

                RedBookDeallocatePlayResources(deviceExtension);

                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                           "STExit => Thread was killed\n"));
                ASSERT(deviceExtension->Thread.PendingRead   == 0);
                ASSERT(deviceExtension->Thread.PendingStream == 0);
                PsTerminateSystemThread(STATUS_SUCCESS);
                ASSERT(!"[redbook] Thread should never reach past self-terminate code");
                break;
            }

            case STATUS_TIMEOUT: {

                ULONG state = GetCdromState(deviceExtension);

                timeouts++;

                if (timeouts < REDBOOK_THREAD_FIXUP_SECONDS) {
                    break;
                } else {
                    timeouts = 0;
                }

                //
                // these tests all occur once every ten seconds.
                // the most basic case is where we want to deallocate
                // our cached TOC, but we also perform lots of
                // sanity testing here -- ASSERTing on CHK builds and
                // trying to fix ourselves up when possible.
                //

                if (!TEST_FLAG(state, CD_PLAYING) && !TEST_FLAG(state, CD_PAUSED)) { // !handling ioctls

                    // not playing, so free resources
                    RedBookDeallocatePlayResources(deviceExtension);

                } else if (TEST_FLAG(state, CD_STOPPING)) {

                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                               "STTime !! %x seconds inactivity\n",
                               REDBOOK_THREAD_FIXUP_SECONDS));

                    if (IsListEmpty(&deviceExtension->Thread.DigitalList)) {

                        if ((deviceExtension->Thread.PendingRead == 0) &&
                            (deviceExtension->Thread.PendingStream == 0) &&
                            (deviceExtension->Thread.IoctlCurrent != NULL)) {

                             KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError,
                                        "[redbook] "
                                        "STTime !! No Reads, No Streams, In a temp "
                                        "state (%x) and have STOP irp %p "
                                        "pending?!\n",
                                        state,
                                        ((PREDBOOK_THREAD_IOCTL_DATA)deviceExtension->Thread.IoctlCurrent)->Irp
                                        ));
                             ASSERT(!"STTime !! CD_STOPPING Fixup with no reads nor streams but STOP pending\n");
                             SetCdromState(deviceExtension, state, CD_STOPPED);
                             KeSetEvent(deviceExtension->Thread.Events[EVENT_COMPLETE],
                                        IO_NO_INCREMENT, FALSE);

                        } else {

                            ASSERT(!"STTime !! CD_STOPPING Fixup with empty list and no pending ioctl?\n");

                        }

                    } else {

                        ASSERT(!"STTime !! CD_STOPPING Fixup with list items\n");
                        KeSetEvent(deviceExtension->Thread.Events[EVENT_DIGITAL],
                                   IO_NO_INCREMENT, FALSE);

                    }

                } else if (TEST_FLAG(state, CD_PAUSING)) {

                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                               "STTime !! %x seconds inactivity\n",
                               REDBOOK_THREAD_FIXUP_SECONDS));

                    if (IsListEmpty(&deviceExtension->Thread.DigitalList)) {

                        if ((deviceExtension->Thread.PendingRead == 0) &&
                            (deviceExtension->Thread.PendingStream == 0) &&
                            (deviceExtension->Thread.IoctlCurrent != NULL)) {

                             KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError,
                                        "[redbook] "
                                        "STTime !! No Reads, No Streams, In a temp "
                                        "state (%x) and have PAUSE irp %p "
                                        "pending?!\n",
                                        state,
                                        ((PREDBOOK_THREAD_IOCTL_DATA)deviceExtension->Thread.IoctlCurrent)->Irp
                                        ));
                             ASSERT(!"STTime !! CD_PAUSING Fixup with no reads nor streams but PAUSE pending\n");
                             SetCdromState(deviceExtension, state, CD_PAUSED);
                             KeSetEvent(deviceExtension->Thread.Events[EVENT_COMPLETE],
                                        IO_NO_INCREMENT, FALSE);

                        } else {

                            ASSERT(!"STTime !! CD_PAUSING Fixup with empty list and no pending ioctl?\n");

                        }

                    } else {

                        ASSERT(!"STTime !! CD_PAUSING Fixup with list items\n");
                        KeSetEvent(deviceExtension->Thread.Events[EVENT_DIGITAL],
                                   IO_NO_INCREMENT, FALSE);

                    }

                } else if (TEST_FLAG(state, CD_PAUSED)) {

                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                               "STTime => Still paused\n"));

                } else {

                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                               "STTime !! %x seconds inactivity\n",
                               REDBOOK_THREAD_FIXUP_SECONDS));

                    if (IsListEmpty(&deviceExtension->Thread.DigitalList)) {

                        //
                        // We can get into this state if we received play requests while
                        // playing.  For now, a reasonable solution is to heal ourselves
                        //
                        state = SetCdromState(deviceExtension, state, CD_STOPPING);
                        state = SetCdromState(deviceExtension, state, CD_STOPPED);

                    } else {
                        ASSERT(!"STTime !! CD_PLAYING Fixup with list items\n");
                        KeSetEvent(deviceExtension->Thread.Events[EVENT_DIGITAL],
                                   IO_NO_INCREMENT, FALSE);
                    }

                }
                break;

            }

            default: {

                if (waitStatus > 0 && waitStatus < EVENT_MAXIMUM) {
                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                               "ST     !! Unhandled event: %lx\n",
                               waitStatus));
                } else {
                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                               "ST     !! event too large/small: %lx\n",
                               waitStatus));
                }

                ASSERT(!"[redbook] ST !! Unhandled event");
                break;
            }

        } // end of the huge case statement.

        if (killed)
        {
            if (deviceExtension->Thread.PendingRead   == 0 &&
                deviceExtension->Thread.PendingStream == 0)
            {
                ULONG state = GetCdromState(deviceExtension);

                //
                // We had been asked to shutdown earlier but couldn't as we were in
                // an inconsistent state. Now that there are no more outstanding Io
                // we can safely terminate
                //

                ASSERT(state == CD_STOPPED);
                SetCdromState(deviceExtension, state, CD_STOPPED);

                KeSetEvent(deviceExtension->Thread.Events[EVENT_KILL_THREAD], IO_NO_INCREMENT, FALSE);
            }
            else
            {
                //
                // We should not have any outstanding Io
                //

                ASSERT(!"[redbook] ST !! Thread has been requested to shutdown while there is outstanding Io");
            }
        }

        continue;
    } // while(1) loop
    ASSERT(!"[redbook] ST !! somehow broke out of while(1) loop?");
}


VOID
RedBookReadRaw(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_COMPLETION_CONTEXT Context
    )

/*++

Routine Description:

    Reads raw audio data off the cdrom.
    Must either reinsert Context into queue and set an event
    or set a completion routine which will do so.

Arguments:

    DeviceObject - CDROM class driver object or lower level filter

Return Value:

    status

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION nextIrpStack;
    PRAW_READ_INFO readInfo;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugDigitalR, "[redbook] "
               "ReadRaw => Entering\n"));

    status = IoAcquireRemoveLock(&DeviceExtension->RemoveLock, Context->Irp);

    if (!NT_SUCCESS(status)) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugDigitalR, "[redbook] "
                   "ReadRaw !! RemoveLock failed %lx\n", status));

        // end of thread loop will check for no outstanding io
        // and on too many errors set stopping
        // don't forget perf info

        Context->TimeReadSent.QuadPart = 0; // special value
        Context->Irp->IoStatus.Status = status;
        Context->Reason = REDBOOK_CC_READ_COMPLETE;

        //
        // put it on the queue and set the event
        //

        ExInterlockedInsertTailList(&DeviceExtension->Thread.DigitalList,
                                    &Context->ListEntry,
                                    &DeviceExtension->Thread.DigitalLock);
        KeSetEvent(DeviceExtension->Thread.Events[EVENT_DIGITAL],
                   IO_CD_ROM_INCREMENT, FALSE);
        return;
    }

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugDigitalR, "[redbook] "
               "ReadRaw => Index %x sending Irp %p\n",
               Context->Index, Context->Irp));

    //
    // (no failure from this point forward)
    //

    IoReuseIrp(Context->Irp, STATUS_UNSUCCESSFUL);

    Context->Irp->MdlAddress = Context->Mdl;

    //
    // irp is from kernel mode
    //

    Context->Irp->AssociatedIrp.SystemBuffer = NULL;

    //
    // fill in the completion context
    //

    ASSERT(Context->DeviceExtension == DeviceExtension);

    //
    // setup the irpstack for the raw read
    //

    nextIrpStack = IoGetNextIrpStackLocation(Context->Irp);

    SET_FLAG(nextIrpStack->Flags, SL_OVERRIDE_VERIFY_VOLUME);

    nextIrpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    nextIrpStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_CDROM_RAW_READ;
    nextIrpStack->Parameters.DeviceIoControl.Type3InputBuffer =
        Context->Buffer;
    nextIrpStack->Parameters.DeviceIoControl.InputBufferLength =
        sizeof(RAW_READ_INFO);
    nextIrpStack->Parameters.DeviceIoControl.OutputBufferLength =
        (RAW_SECTOR_SIZE * DeviceExtension->WmiData.SectorsPerRead);

    //
    // setup the read info (uses same buffer)
    //

    readInfo                      = (PRAW_READ_INFO)(Context->Buffer);
    readInfo->DiskOffset.QuadPart =
        (ULONGLONG)(DeviceExtension->CDRom.NextToRead)*COOKED_SECTOR_SIZE;
    readInfo->SectorCount         = DeviceExtension->WmiData.SectorsPerRead;
    readInfo->TrackMode           = CDDA;

    //
    // send it.
    //

    IoSetCompletionRoutine(Context->Irp, RedBookReadRawCompletion, Context,
                           TRUE, TRUE, TRUE);
    KeQueryTickCount(&Context->TimeReadSent);
    IoCallDriver(DeviceExtension->TargetDeviceObject, Context->Irp);

    return;
}


NTSTATUS
RedBookReadRawCompletion(
    PVOID UnusableParameter,
    PIRP Irp,
    PREDBOOK_COMPLETION_CONTEXT Context
    )
/*++

Routine Description:

    When a read completes, use zero'd buffer if error occurred.
    Make buffer available to ks, then set ks event.

Arguments:

    DeviceObject - NULL, due to being originator of IRP

    Irp - pointer to buffer to send to KS
          must check error to increment/clear error count

    Context - REDBOOK_COMPLETION_CONTEXT

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/
{
    PREDBOOK_DEVICE_EXTENSION deviceExtension = Context->DeviceExtension;

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugDigitalR, "[redbook] "
               "ReadRaw => Completed Irp %p\n", Irp));

    KeQueryTickCount(&Context->TimeStreamReady);
    Context->Reason = REDBOOK_CC_READ_COMPLETE;

    ExInterlockedInsertTailList(&deviceExtension->Thread.DigitalList,
                                &Context->ListEntry,
                                &deviceExtension->Thread.DigitalLock);

    KeSetEvent(deviceExtension->Thread.Events[EVENT_DIGITAL],
               IO_CD_ROM_INCREMENT, FALSE);

    //
    // safe to release it since we wait for thread termination
    //

    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Context->Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


VOID
RedBookStream(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_COMPLETION_CONTEXT Context
    )
/*++

Routine Description:

    Send buffer to KS.
    Must either reinsert Context into queue and set an event
    or set a completion routine which will do so.

Arguments:

    Context - DeviceExtension

Return Value:

    status

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION nextIrpStack;

    PUCHAR buffer;
    PKSSTREAM_HEADER header;

    ULONG bufferSize;

    PULONG streamOk;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugDigitalS, "[redbook] "
               "Stream => Entering\n"));

    bufferSize = DeviceExtension->WmiData.SectorsPerRead * RAW_SECTOR_SIZE;

    status = IoAcquireRemoveLock(&DeviceExtension->RemoveLock, Context->Irp);

    if (!NT_SUCCESS(status)) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugDigitalS, "[redbook] "
                   "Stream !! RemoveLock failed %lx\n", status));

        // end of thread loop will check for no outstanding io
        // and on too many errors set CD_STOPPING
        // don't forget perf info

        Context->TimeReadSent.QuadPart = 0; // special value
        Context->Irp->IoStatus.Status = status;
        Context->Reason = REDBOOK_CC_STREAM_COMPLETE;

        //
        // put it on the queue and set the event
        //

        ExInterlockedInsertTailList(&DeviceExtension->Thread.DigitalList,
                                    &Context->ListEntry,
                                    &DeviceExtension->Thread.DigitalLock);
        KeSetEvent(DeviceExtension->Thread.Events[EVENT_DIGITAL],
                   IO_CD_ROM_INCREMENT, FALSE);
        return;
    }

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugDigitalS, "[redbook] "
               "Stream => Index %x sending Irp %p\n",
               Context->Index, Context->Irp));

    //
    // CONSIDER - how does STOPPED occur?
    // SUGGEST - out of loop, if no error and none pending, set to STOPPED?
    //

    //
    // (no failure from this point forward)
    //

    //
    // use a zero'd buffer if an error occurred during the read
    //

    if (NT_SUCCESS(Context->Irp->IoStatus.Status)) {
        IoReuseIrp(Context->Irp, STATUS_SUCCESS);
        buffer = Context->Buffer; // good data
        Context->Irp->MdlAddress = Context->Mdl;
    } else {
        IoReuseIrp(Context->Irp, STATUS_SUCCESS);
        buffer = DeviceExtension->Buffer.SilentBuffer; // zero'd data
        Context->Irp->MdlAddress = DeviceExtension->Buffer.SilentMdl;
    }

#if DBG
    if (RedBookForceSilence) {
        buffer = DeviceExtension->Buffer.SilentBuffer; // zero'd data
        Context->Irp->MdlAddress = DeviceExtension->Buffer.SilentMdl;
    }
#endif // RedBookUseSilence


    nextIrpStack = IoGetNextIrpStackLocation(Context->Irp);

    //
    // get and fill in the context
    //

    ASSERT(Context->DeviceExtension == DeviceExtension);

    //
    // setup the irpstack for streaming the buffer
    //

    nextIrpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    nextIrpStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_KS_WRITE_STREAM;
    nextIrpStack->Parameters.DeviceIoControl.OutputBufferLength =
        sizeof(KSSTREAM_HEADER);
    nextIrpStack->Parameters.DeviceIoControl.InputBufferLength =
        sizeof(KSSTREAM_HEADER);
    nextIrpStack->FileObject = DeviceExtension->Stream.PinFileObject;

    Context->Header.FrameExtent       = bufferSize;
    Context->Header.DataUsed          = bufferSize;
    Context->Header.Size              = sizeof(KSSTREAM_HEADER);
    Context->Header.TypeSpecificFlags = 0;
    Context->Header.Data              = buffer;
    Context->Header.OptionsFlags      = 0;

    Context->Irp->AssociatedIrp.SystemBuffer = &Context->Header;



#if REDBOOK_PERFORM_STUTTER_CONTROL

#if REDBOOK_WMI_BUFFERS_MIN < 3
    #error "The minimum number of buffers must be at least three due to the method used to prevent stuttering"
#endif // REDBOOK_WMI_BUFFERS_MIN < 3

    //
    // perform my own pausing to prevent stuttering
    //

    if (DeviceExtension->Thread.PendingStream <= 3 &&
        DeviceExtension->Buffer.Paused == 0) {

        //
        // only one buffer (or less) was pending play,
        // so pause the output to prevent horrible
        // stuttering.
        // since this is serialized from a thread,
        // can set a simple boolean in the extension
        //

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugDigitalS, "[redbook] "
                   "Stream => Pausing, few buffers pending\n"));

        if (DeviceExtension->Buffer.FirstPause == 0) {
            RedBookLogError(DeviceExtension,
                            REDBOOK_ERR_INSUFFICIENT_DATA_STREAM_PAUSED,
                            STATUS_SUCCESS
                            );
            InterlockedIncrement(&DeviceExtension->WmiPerf.StreamPausedCount);
        } else {
            DeviceExtension->Buffer.FirstPause = 0;
        }

        DeviceExtension->Buffer.Paused = 1;
        SetNextDeviceState(DeviceExtension, KSSTATE_PAUSE);

    } else if (DeviceExtension->Buffer.Paused == 1 &&
               DeviceExtension->Thread.PendingStream ==
               DeviceExtension->WmiData.NumberOfBuffers ) {

        ULONG i;

        //
        // are now using the maximum number of buffers,
        // all pending stream.  this allows smooth play again.
        //

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugDigitalS, "[redbook] "
                   "Stream => Resuming, %d buffers pending\n",
                   DeviceExtension->WmiData.NumberOfBuffers));
        DeviceExtension->Buffer.Paused = 0;

        //
        // prevent these statistics from being added.
        //

        for (i=0;i<DeviceExtension->WmiData.NumberOfBuffers;i++) {
            (DeviceExtension->Buffer.Contexts + i)->TimeReadSent.QuadPart = 0;
        }

        //
        // let the irps go!
        //

        SetNextDeviceState(DeviceExtension, KSSTATE_RUN);

    } // end of stutter prevention
#endif // REDBOOK_PERFORM_STUTTER_CONTROL

    //
    // get perf counters at last possible second
    //

    KeQueryTickCount(&Context->TimeStreamSent);
    IoSetCompletionRoutine(Context->Irp, RedBookStreamCompletion, Context,
                           TRUE, TRUE, TRUE);
    IoCallDriver(DeviceExtension->Stream.PinDeviceObject, Context->Irp);

    return;
}


NTSTATUS
RedBookStreamCompletion(
    PVOID UnusableParameter,
    PIRP Irp,
    PREDBOOK_COMPLETION_CONTEXT Context
    )
/*++

Routine Description:

Arguments:

    DeviceObject - CDROM class driver object or lower level filter

    Irp - pointer to buffer to send to KS
          must check error to increment/clear error count

    Context - sector of disk (ordered number)

Return Value:

    status

--*/
{
    PREDBOOK_DEVICE_EXTENSION deviceExtension = Context->DeviceExtension;

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugDigitalS, "[redbook] "
               "Stream => Completed Irp %p\n", Irp));

    KeQueryTickCount(&Context->TimeReadReady);
    Context->Reason = REDBOOK_CC_STREAM_COMPLETE;

    ExInterlockedInsertTailList(&deviceExtension->Thread.DigitalList,
                                &Context->ListEntry,
                                &deviceExtension->Thread.DigitalLock);

    KeSetEvent(deviceExtension->Thread.Events[EVENT_DIGITAL],
               IO_CD_ROM_INCREMENT, FALSE);

    //
    // safe to release it since we wait for thread termination
    //

    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Context->Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


#if DBG
VOID
ValidateCdromState(ULONG State)
{
    ULONG temp;

    if (State == 0) {
        ASSERT(!"Invalid Cdrom State");
    } else
    if (TEST_FLAG(State, ~CD_MASK_ALL)) {
        ASSERT(!"Invalid Cdrom State");
    }

    temp = State & CD_MASK_TEMP;
    if (temp  & (temp - 1)) {  // see if zero or one bits are set
        ASSERT(!"Invalid Cdrom State");
    }

    temp = State & CD_MASK_STATE;
    if (temp == 0) {           // dis-allow zero bits for STATE
        ASSERT(!"Invalid Cdrom State");
    } else
    if (temp  & (temp - 1)) {  // see if zero or one bits are set
        ASSERT(!"Invalid Cdrom State");
    }

    return;
}

#else
VOID ValidateCdromState(ULONG State) {return;}
#endif


ULONG
GetCdromState(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
{
    //
    // this routine may be called by anyone, whether in the thread's
    // context or not.  setting the state is restricted, however.
    //
    ULONG state;
    state = InterlockedCompareExchange(&DeviceExtension->CDRom.StateNow,0,0);
    ValidateCdromState(state);
    return state;
}


LONG
SetCdromState(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    IN LONG ExpectedOldState,
    IN LONG NewState
    )
{
    LONG trueOldState;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    // ensure when set to:     also setting:
    // CD_PAUSING              CD_PLAYING
    // CD_STOPPING             CD_PLAYING

    if (TEST_FLAG(NewState, CD_PAUSING)) {
        SET_FLAG(NewState, CD_PLAYING);
    }

    if (TEST_FLAG(NewState, CD_STOPPING)) {
        SET_FLAG(NewState, CD_PLAYING);
    }

    ValidateCdromState(ExpectedOldState);
    ValidateCdromState(NewState);

    //attempt to change it
    trueOldState = InterlockedCompareExchange(
        &DeviceExtension->CDRom.StateNow,
        NewState,
        ExpectedOldState
        );

    ASSERTMSG("State set outside of thread",
              trueOldState == ExpectedOldState);

    //
    // see if an event should be fired, volume set, and/or
    // stream state set
    //
    if (ExpectedOldState == NewState) {

        //
        // if state is not changing, don't do anything
        //

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                   "Setting state to same as expected?! %x == %x\n",
                   ExpectedOldState, NewState));

    } else if (TEST_FLAG(ExpectedOldState, CD_MASK_TEMP)) {

        //
        // should not go from temp state to temp state
        //

        ASSERT(!TEST_FLAG(NewState, CD_MASK_TEMP));

        //
        // ioctl is being processed, and state is no longer
        // in a temp state, so should process the ioctl again
        //

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                   "SetState => EVENT_COMPLETE should be set soon "
                   "for %p\n", DeviceExtension->Thread.IoctlCurrent));

    } else if (TEST_FLAG(NewState, CD_MASK_TEMP)) {

        //
        // going to either pausing or stopping, both of which must
        // be specially handled by stopping the KS stream also.
        //

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                   "SetState => %s, setting device state "
                   "to KSSTATE_STOP\n",
                   (TEST_FLAG(NewState, CD_STOPPING) ? "STOP" : "PAUSE")));

        SetNextDeviceState(DeviceExtension, KSSTATE_STOP);

    } else if (TEST_FLAG(NewState, CD_PAUSED)) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                   "SetState => Finishing a PAUSE operation\n"));

    } else if (TEST_FLAG(NewState, CD_PLAYING)) {

        ULONG i;
        PREDBOOK_COMPLETION_CONTEXT context;

        ASSERT(NewState == CD_PLAYING);

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                   "SetState => Starting a PLAY operation\n"));

        //
        // not same state, not from temp state,
        // so must either be paused or stopped.
        //

        ASSERT(TEST_FLAG(ExpectedOldState,CD_STOPPED) ||
               TEST_FLAG(ExpectedOldState,CD_PAUSED));

        //
        // set some deviceextension stuff
        //


        RtlZeroMemory(&DeviceExtension->WmiPerf,
                      sizeof(REDBOOK_WMI_PERF_DATA));
        DeviceExtension->CDRom.ReadErrors     = 0;
        DeviceExtension->CDRom.StreamErrors   = 0;
        DeviceExtension->Buffer.Paused        = 0;
        DeviceExtension->Buffer.FirstPause    = 1;
        DeviceExtension->Buffer.IndexToRead   = 0;
        DeviceExtension->Buffer.IndexToStream = 0;

        //
        // reset the buffer state
        //

        ASSERT(DeviceExtension->Buffer.Contexts);
        context = DeviceExtension->Buffer.Contexts;

        for (i=0; i<DeviceExtension->WmiData.NumberOfBuffers;i++) {

            *(DeviceExtension->Buffer.ReadOk_X   + i) = 0;
            *(DeviceExtension->Buffer.StreamOk_X + i) = 0;

            context->Reason = REDBOOK_CC_READ;
            context->Irp->IoStatus.Status = STATUS_SUCCESS;

            ExInterlockedInsertTailList(&DeviceExtension->Thread.DigitalList,
                                        &context->ListEntry,
                                        &DeviceExtension->Thread.DigitalLock);

            context++; // pointer arithmetic
        }
        context = NULL;

        //
        // start the digital playback
        //

        SetNextDeviceState(DeviceExtension, KSSTATE_RUN);
        RedBookKsSetVolume(DeviceExtension);
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                   "SetState => Setting DIGITAL event\n"));
        KeSetEvent(DeviceExtension->Thread.Events[EVENT_DIGITAL],
                   IO_CD_ROM_INCREMENT, FALSE);


    } else {

        //
        // ReadQ Channel or some such nonsense
        //

    }


    return GetCdromState(DeviceExtension);
}


VOID
RedBookDeallocatePlayResources(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
{
    PREDBOOK_COMPLETION_CONTEXT context;
    ULONG i;
    BOOLEAN freedSomething = FALSE;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);
#if DBG
    {
        ULONG state = GetCdromState(DeviceExtension);
        ASSERT(!TEST_FLAG(state, CD_PLAYING) && !TEST_FLAG(state, CD_PAUSED));
    }
#endif


    //
    // free all resources
    //

    if (DeviceExtension->Buffer.StreamOk_X) {
        freedSomething = TRUE;
        ExFreePool(DeviceExtension->Buffer.StreamOk_X);
        DeviceExtension->Buffer.StreamOk_X = NULL;
    }

    if (DeviceExtension->Buffer.ReadOk_X) {
        freedSomething = TRUE;
        ExFreePool(DeviceExtension->Buffer.ReadOk_X);
        DeviceExtension->Buffer.ReadOk_X = NULL;
    }

    if (DeviceExtension->Buffer.Contexts) {

        context = DeviceExtension->Buffer.Contexts;
        for (i=0; i<DeviceExtension->WmiData.NumberOfBuffers; i++){
            if (context->Irp) {
                IoFreeIrp(context->Irp);
            }
            if (context->Mdl) {
                IoFreeMdl(context->Mdl);
            }
            context++; // pointer arithmetic
        }
        context = NULL;

        freedSomething = TRUE;
        ExFreePool(DeviceExtension->Buffer.Contexts);
        DeviceExtension->Buffer.Contexts = NULL;
    }

    if (DeviceExtension->Buffer.SilentMdl) {
        freedSomething = TRUE;
        IoFreeMdl(DeviceExtension->Buffer.SilentMdl);
        DeviceExtension->Buffer.SilentMdl = NULL;
    }

    if (DeviceExtension->Buffer.SkipBuffer) {
        freedSomething = TRUE;
        ExFreePool(DeviceExtension->Buffer.SkipBuffer);
        DeviceExtension->Buffer.SkipBuffer = NULL;
    }

    if (DeviceExtension->Thread.CheckVerifyIrp) {
        PIRP irp = DeviceExtension->Thread.CheckVerifyIrp;
        freedSomething = TRUE;
        if (irp->MdlAddress) {
            IoFreeMdl(irp->MdlAddress);
        }
        if (irp->AssociatedIrp.SystemBuffer) {
            ExFreePool(irp->AssociatedIrp.SystemBuffer);
        }

        IoFreeIrp(DeviceExtension->Thread.CheckVerifyIrp);
        DeviceExtension->Thread.CheckVerifyIrp = NULL;
    }

    if (DeviceExtension->Stream.PinFileObject) {
        freedSomething = TRUE;
        CloseSysAudio(DeviceExtension);
    }

    if (DeviceExtension->CDRom.Toc) {
        freedSomething = TRUE;
        ExFreePool(DeviceExtension->CDRom.Toc);
        DeviceExtension->CDRom.Toc = NULL;
    }

    if (freedSomething) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                   "DeallocatePlay => Deallocated play resources\n"));
    }

    return;
}

BOOLEAN
RedBookArePlayResourcesAllocated(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
//
// just choose one, since it's all done in a batch in
// one thread context it's always safe.
//
{
    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);
    return (DeviceExtension->Stream.PinFileObject != NULL);
}



NTSTATUS
RedBookAllocatePlayResources(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
//
// allocate resources if they are not already allocated
//
{
    PREDBOOK_COMPLETION_CONTEXT context;
    NTSTATUS status;
    KEVENT event;
    ULONG numBufs;
    ULONG numSectors;
    ULONG bufSize;
    ULONG i;
    CCHAR maxStack;
    BOOLEAN sysAudioOpened = FALSE;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    //
    // NOTE:
    // The call to update the mixer Id may de-allocate all play
    // resources, since the stack sizes may change.  it must
    // therefore be the first call within this routine.
    //

    if (DeviceExtension->Stream.MixerPinId == -1) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                   "AllocatePlay => No mixer set?\n"));
        return STATUS_UNSUCCESSFUL;
    }

    if (DeviceExtension->Buffer.Contexts != NULL) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                   "AllocatePlay => Using existing resources\n"));
        return STATUS_SUCCESS;
    }

#if DBG
    {
        ULONG state = GetCdromState(DeviceExtension);
        ASSERT(!TEST_FLAG(state, CD_PLAYING) && !TEST_FLAG(state, CD_PAUSED));
    }
#endif

    ASSERT(DeviceExtension->Buffer.Contexts == NULL);
    ASSERT(DeviceExtension->Buffer.SkipBuffer == NULL);

    DeviceExtension->WmiData.NumberOfBuffers = DeviceExtension->NextWmiNumberOfBuffers;
    numBufs = DeviceExtension->NextWmiNumberOfBuffers;
    DeviceExtension->WmiData.SectorsPerRead = DeviceExtension->NextWmiSectorsPerRead;
    numSectors = DeviceExtension->NextWmiSectorsPerRead;

    bufSize =  RAW_SECTOR_SIZE * numSectors;

    TRY {

        ASSERT(DeviceExtension->Stream.MixerPinId != -1);

        //
        // may need to allocate the CheckVerifyIrp
        //

        {
            PIO_STACK_LOCATION irpStack;
            PIRP irp;
            irp = DeviceExtension->Thread.CheckVerifyIrp;

            if (irp == NULL) {
                irp = IoAllocateIrp(
                    (CCHAR)(DeviceExtension->SelfDeviceObject->StackSize+1),
                    FALSE);
            }
            if (irp == NULL) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                           "AllocatePlay => No CheckVerifyIrp\n"));
                status = STATUS_NO_MEMORY;
                LEAVE;
            }

            irp->MdlAddress = NULL;

            irp->AssociatedIrp.SystemBuffer =
                ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                      sizeof(ULONG),
                                      TAG_CV_BUFFER);
            if (irp->AssociatedIrp.SystemBuffer == NULL) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                           "AllocatePlay => No CheckVerify Buffer\n"));
                status = STATUS_NO_MEMORY;
                LEAVE;
            }

            irp->MdlAddress = IoAllocateMdl(irp->AssociatedIrp.SystemBuffer,
                                            sizeof(ULONG),
                                            FALSE, FALSE, NULL);
            if (irp->MdlAddress == NULL) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                           "AllocatePlay => No CheckVerify Mdl\n"));
                status = STATUS_NO_MEMORY;
                LEAVE;
            }

            MmBuildMdlForNonPagedPool(irp->MdlAddress);

            IoSetNextIrpStackLocation(irp);
            irpStack = IoGetCurrentIrpStackLocation(irp);

            irpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;

            irpStack->Parameters.DeviceIoControl.InputBufferLength =
                0;
            irpStack->Parameters.DeviceIoControl.OutputBufferLength =
                sizeof(ULONG);
            irpStack->Parameters.DeviceIoControl.IoControlCode =
                IOCTL_CDROM_CHECK_VERIFY;

            DeviceExtension->Thread.CheckVerifyIrp = irp;
        }


        //
        // connect to sysaudio
        //

        {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                       "AllocatePlay => Preparing to open sysaudio\n"));

            ASSERT(DeviceExtension->Stream.MixerPinId != MAXULONG);

            status = OpenSysAudio(DeviceExtension);

            if ( !NT_SUCCESS(status) ) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                           "AllocatePlay !! Unable to open sysaudio %lx\n",
                           status));
                LEAVE;
            }

            // else the pin is open
            sysAudioOpened = TRUE;
        }

        maxStack = MAX(DeviceExtension->TargetDeviceObject->StackSize,
                       DeviceExtension->Stream.PinDeviceObject->StackSize);
        DeviceExtension->Buffer.MaxIrpStack = maxStack;

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                   "AllocateePlay => Stacks: Cdrom %x  Stream %x\n",
                   DeviceExtension->TargetDeviceObject->StackSize,
                   DeviceExtension->Stream.PinDeviceObject->StackSize));
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                   "AllocateePlay => Allocating %x stacks per irp\n",
                   maxStack));


        DeviceExtension->Buffer.SkipBuffer =
            ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                  bufSize * (numBufs + 1),
                                  TAG_BUFFER);

        if (DeviceExtension->Buffer.SkipBuffer == NULL) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                   "AllocatePlay => No Skipbuffer\n"));
            status = STATUS_NO_MEMORY;
            LEAVE;
        }
        RtlZeroMemory(DeviceExtension->Buffer.SkipBuffer,
                      bufSize * (numBufs + 1));

        DeviceExtension->Buffer.Contexts =
            ExAllocatePoolWithTag(NonPagedPool,
                                  sizeof(REDBOOK_COMPLETION_CONTEXT) * numBufs,
                                  TAG_CC);

        if (DeviceExtension->Buffer.Contexts   == NULL) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                       "AllocatePlay => No Contexts\n"));
            status = STATUS_NO_MEMORY;
            LEAVE;
        }

        RtlZeroMemory(DeviceExtension->Buffer.Contexts,
                      sizeof(REDBOOK_COMPLETION_CONTEXT) * numBufs);

        context = DeviceExtension->Buffer.Contexts;
        for (i=0; i<numBufs; i++) {

            context->DeviceExtension = DeviceExtension;
            context->Reason = REDBOOK_CC_READ;
            context->Index = i;
            context->Buffer = DeviceExtension->Buffer.SkipBuffer +
                (bufSize * i); // pointer arithmetic of UCHARS

            //
            // allocate irp, mdl
            //

            context->Irp = IoAllocateIrp(maxStack, FALSE);
            context->Mdl = IoAllocateMdl(context->Buffer, bufSize,
                                         FALSE, FALSE, NULL);
            if (context->Irp == NULL ||
                context->Mdl == NULL) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                           "AllocatePlay => Irp/Mdl %x failed\n", i));
                status = STATUS_NO_MEMORY;
                LEAVE;
            }

            MmBuildMdlForNonPagedPool(context->Mdl);

            context++; // pointer arithmetic of CONTEXTS
        }
        context = NULL; // safety

        //
        // allocated above as part of SkipBuffer
        //

        DeviceExtension->Buffer.SilentBuffer =
            DeviceExtension->Buffer.SkipBuffer + (bufSize * numBufs);


        DeviceExtension->Buffer.SilentMdl =
            IoAllocateMdl(DeviceExtension->Buffer.SkipBuffer, bufSize,
                          FALSE, FALSE, NULL);
        if (DeviceExtension->Buffer.SilentMdl == NULL) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                       "AllocatePlay => Silent Mdl failed\n"));
            status = STATUS_NO_MEMORY;
            LEAVE;
        }

        DeviceExtension->Buffer.ReadOk_X =
            ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                  sizeof(ULONG) * numBufs,
                                  TAG_READX);
        if (DeviceExtension->Buffer.ReadOk_X == NULL) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                       "AllocatePlay => ReadOk_X failed\n"));
            status = STATUS_NO_MEMORY;
            LEAVE;
        }
        RtlZeroMemory(DeviceExtension->Buffer.ReadOk_X,
                      sizeof(ULONG) * numBufs);

        DeviceExtension->Buffer.StreamOk_X =
            ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                  sizeof(ULONG) * numBufs,
                                  TAG_STREAMX);
        if (DeviceExtension->Buffer.StreamOk_X == NULL) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                       "AllocatePlay => ReadOk_X failed\n"));
            status = STATUS_NO_MEMORY;
            LEAVE;
        }
        RtlZeroMemory(DeviceExtension->Buffer.StreamOk_X,
                      sizeof(ULONG) * numBufs);

        MmBuildMdlForNonPagedPool(DeviceExtension->Buffer.SilentMdl);

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                   "AllocatePlay => Allocated All Resources\n"));

        status = STATUS_SUCCESS;

    } FINALLY {

        if (!NT_SUCCESS(status)) {

            RedBookDeallocatePlayResources(DeviceExtension);
            return status;
        }
    }

    //
    // else all resources allocated
    //

    return STATUS_SUCCESS;

}


NTSTATUS
RedBookCacheToc(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
{
    PCDROM_TOC newToc;
    PIRP irp;
    ULONG mediaChangeCount;
    IO_STATUS_BLOCK ioStatus;
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    //
    // cache the number of times the media has changed
    // use this to prevent redundant reads of the toc
    // and to return Q channel info during playback
    //

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    //
    // first get the mediaChangeCount to see if we've already
    // cached this toc
    //

    irp = IoBuildDeviceIoControlRequest(IOCTL_CDROM_CHECK_VERIFY,
                                        DeviceExtension->TargetDeviceObject,
                                        NULL, 0,
                                        &mediaChangeCount, sizeof(ULONG),
                                        FALSE,
                                        &event, &ioStatus);
    if (irp == NULL) {
        return STATUS_NO_MEMORY;
    }

    SET_FLAG(IoGetNextIrpStackLocation(irp)->Flags, SL_OVERRIDE_VERIFY_VOLUME);

    status = IoCallDriver(DeviceExtension->TargetDeviceObject, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                   "CacheToc !! CheckVerify failed %lx\n", status));
        return status;
    }

    //
    // read TOC only we don't have the correct copy cached
    //

    if (DeviceExtension->CDRom.Toc         != NULL &&
        DeviceExtension->CDRom.CheckVerify == mediaChangeCount) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                   "CacheToc => Using cached toc\n"));
        return STATUS_SUCCESS;

    }

    //
    // Allocate for the cached TOC
    //

    newToc = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                   sizeof(CDROM_TOC),
                                   TAG_TOC);

    if (newToc == NULL) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                   "CacheToc !! Unable to allocate new TOC\n"));
        return STATUS_NO_MEMORY;
    }

    KeClearEvent(&event);

    irp = IoBuildDeviceIoControlRequest(IOCTL_CDROM_READ_TOC,
                                        DeviceExtension->TargetDeviceObject,
                                        NULL, 0,
                                        newToc, sizeof(CDROM_TOC),
                                        FALSE,
                                        &event, &ioStatus);
    if (irp == NULL) {
        ExFreePool(newToc);
        newToc = NULL;
        return STATUS_NO_MEMORY;
    }

    SET_FLAG(IoGetNextIrpStackLocation(irp)->Flags, SL_OVERRIDE_VERIFY_VOLUME);

    status = IoCallDriver(DeviceExtension->TargetDeviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    //
    // set the new toc, or if error free it
    // return the status
    //

    if (!NT_SUCCESS(status)) {

        ExFreePool(newToc);
        newToc = NULL;
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                   "CacheToc !! Failed to get TOC %lx\n", status));

    } else {

        if (DeviceExtension->CDRom.Toc) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugAllocPlay, "[redbook] "
                       "CacheToc => Freeing old toc %p\n",
                       DeviceExtension->CDRom.Toc));
            ExFreePool(DeviceExtension->CDRom.Toc);
        }
        DeviceExtension->CDRom.Toc = newToc;
        DeviceExtension->CDRom.CheckVerify = mediaChangeCount;

    }
    return status;
}


VOID
RedBookThreadDigitalHandler(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    IN PLIST_ENTRY ListEntry
    )
//
//  DECREMENT StreamPending/ReadPending if it's a completion
//  SET stopped, error, etc. states
//  INCREMENT StreamPending/ReadPending if it's to be sent again
//
{
    PREDBOOK_COMPLETION_CONTEXT Context;
    ULONG index;
    ULONG mod;
    ULONG state;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);
    ASSERT(DeviceExtension->WmiData.NumberOfBuffers);
    ASSERT(DeviceExtension->Buffer.SkipBuffer);

    //
    // Increment/Decrement PendingRead/PendingStream
    //

    Context = CONTAINING_RECORD(ListEntry, REDBOOK_COMPLETION_CONTEXT, ListEntry);

    index = Context->Index;
    mod = DeviceExtension->WmiData.NumberOfBuffers;

    state = GetCdromState(DeviceExtension);

    //
    // decrement the number reading/streaming if needed
    //

    if (Context->Reason == REDBOOK_CC_READ_COMPLETE) {

        if (!NT_SUCCESS(Context->Irp->IoStatus.Status)) {

            if (IoIsErrorUserInduced(Context->Irp->IoStatus.Status)) {

                DeviceExtension->CDRom.ReadErrors = REDBOOK_MAX_CONSECUTIVE_ERRORS;

            } else {

                DeviceExtension->CDRom.ReadErrors++;
            }

        } else {
            DeviceExtension->CDRom.ReadErrors = 0;
        }

        DeviceExtension->Thread.PendingRead--;
        Context->Reason = REDBOOK_CC_STREAM;

    } else if (Context->Reason == REDBOOK_CC_STREAM_COMPLETE) {

        if (!NT_SUCCESS(Context->Irp->IoStatus.Status)) {
            DeviceExtension->CDRom.StreamErrors++;
        } else {
            DeviceExtension->CDRom.StreamErrors = 0;
        }


        //
        // if stream succeeded OR we are _NOT_ stopping audio,
        // increment FinishedStreaming and save wmi stats
        //

        if (NT_SUCCESS(Context->Irp->IoStatus.Status) ||
            !TEST_FLAG(state, CD_MASK_TEMP)) {

            DeviceExtension->CDRom.FinishedStreaming +=
                DeviceExtension->WmiData.SectorsPerRead;

            AddWmiStats(DeviceExtension, Context);

        }

        DeviceExtension->Thread.PendingStream--;
        Context->Reason = REDBOOK_CC_READ;

    }

    if (DeviceExtension->CDRom.StreamErrors >= REDBOOK_MAX_CONSECUTIVE_ERRORS &&
        !TEST_FLAG(state, CD_MASK_TEMP)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                   "Digital => Too many stream errors, beginning STOP\n"));
        ASSERT(!TEST_FLAG(state, CD_STOPPED));
        ASSERT(!TEST_FLAG(state, CD_PAUSED));
        state = SetCdromState(DeviceExtension, state, CD_STOPPING);
    }

    if (DeviceExtension->CDRom.ReadErrors >= REDBOOK_MAX_CONSECUTIVE_ERRORS &&
        !TEST_FLAG(state, CD_MASK_TEMP)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                   "Digital => Too many read errors, beginning STOP\n"));

        state = SetCdromState(DeviceExtension, state, CD_STOPPING);
    }

    //
    // if stopping/pausing/etc, and no reads/streams are pending,
    // set the new state and return.
    // the while() loop in the thread will do the right thing
    // when there is no more outstanding io--it will call the ioctl
    // completion handler to do whatever post-processing is needed.
    //

    if (TEST_FLAG(state, CD_MASK_TEMP)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                   "Digital => Temp state %x, not continuing (%d, %d)\n",
                   state,
                   DeviceExtension->Thread.PendingRead,
                   DeviceExtension->Thread.PendingStream
                   ));

        if (DeviceExtension->Thread.PendingRead   == 0 &&
            DeviceExtension->Thread.PendingStream == 0) {

            //
            // Set NextToRead and NextToStream to FinishedStreaming
            //

            DeviceExtension->CDRom.NextToRead =
                DeviceExtension->CDRom.NextToStream =
                DeviceExtension->CDRom.FinishedStreaming;

            if (TEST_FLAG(state, CD_PAUSING)) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                           "Digital => completing PAUSED\n"));
                state = SetCdromState(DeviceExtension, state, CD_PAUSED);
            } else if (TEST_FLAG(state, CD_STOPPING)) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                           "Digital => completing STOPPED\n"));
                state = SetCdromState(DeviceExtension, state, CD_STOPPED);
            } else {
                ASSERT(!"Unknown state?");
            }

            if (DeviceExtension->Thread.IoctlCurrent) {
                KeSetEvent(DeviceExtension->Thread.Events[EVENT_COMPLETE],
                           IO_CD_ROM_INCREMENT, FALSE);
            }
        }
        return;
    }

    if (DeviceExtension->CDRom.NextToRead >= DeviceExtension->CDRom.EndPlay &&
        Context->Reason == REDBOOK_CC_READ) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                   "Digital => End play, ignoring READ\n"));
        if (DeviceExtension->Thread.PendingRead   == 0 &&
            DeviceExtension->Thread.PendingStream == 0) {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                       "Digital => All IO done, setting STOPPED\n"));
            state = SetCdromState(DeviceExtension, state, CD_STOPPED);
        }
        return;
    }

    if (DeviceExtension->CDRom.NextToStream >= DeviceExtension->CDRom.EndPlay &&
        Context->Reason == REDBOOK_CC_STREAM) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                   "Digital => End play, ignoring STREAM\n"));
        if (DeviceExtension->Thread.PendingRead   == 0 &&
            DeviceExtension->Thread.PendingStream == 0) {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                       "Digital => All IO done, setting STOPPED\n"));
            state = SetCdromState(DeviceExtension, state, CD_STOPPED);

        }
        return;
    }

    switch(Context->Reason) {

        case REDBOOK_CC_READ: {

            // mark this buffer as off the queue/usable
            ASSERT(DeviceExtension->Buffer.ReadOk_X[index] == 0);
            DeviceExtension->Buffer.ReadOk_X[index] = 1;

            if (index != DeviceExtension->Buffer.IndexToRead) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                           "Digital => Delaying read, index %x\n", index));
                return;
            }

            if (DeviceExtension->CDRom.NextToRead >
                DeviceExtension->CDRom.EndPlay) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                           "Digital => End of Play\n"));
                return;
            }

            for (index = Context->Index;
                 DeviceExtension->Buffer.ReadOk_X[index] != 0;
                 index = (index + 1) % mod) {

                // mark this buffer as in use BEFORE attempting to read
                DeviceExtension->Buffer.ReadOk_X[index] = 0;
                DeviceExtension->Thread.PendingRead++;

                RedBookReadRaw(DeviceExtension,
                               &DeviceExtension->Buffer.Contexts[index]);

                // increment where reading from AFTER attempting to read
                DeviceExtension->CDRom.NextToRead +=
                    DeviceExtension->WmiData.SectorsPerRead;

                // inc/mod the index AFTER attempting to read
                DeviceExtension->Buffer.IndexToRead++;
                DeviceExtension->Buffer.IndexToRead %= mod;
            }

            break;
        }

        case REDBOOK_CC_STREAM: {

            // mark this buffer as off the queue/usable
            ASSERT(DeviceExtension->Buffer.StreamOk_X[index] == 0);
            DeviceExtension->Buffer.StreamOk_X[index] = 1;

            if (index != DeviceExtension->Buffer.IndexToStream) {
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugThread, "[redbook] "
                           "Delaying stream of index %x\n", index));
                return;
            }

            for (index = Context->Index;
                 DeviceExtension->Buffer.StreamOk_X[index] != 0;
                 index = (index + 1) % mod) {

                // mark this buffer as in use BEFORE attempting to read
                DeviceExtension->Buffer.StreamOk_X[index] = 0;
                DeviceExtension->Thread.PendingStream++;

                RedBookStream(DeviceExtension,
                              &DeviceExtension->Buffer.Contexts[index]);

                // increment where reading from AFTER attempting to read
                DeviceExtension->CDRom.NextToStream +=
                    DeviceExtension->WmiData.SectorsPerRead;

                // inc/mod the index AFTER attempting to read
                DeviceExtension->Buffer.IndexToStream++;
                DeviceExtension->Buffer.IndexToStream %= mod;
            }

            break;
        }

        default: {
            ASSERT(!"Unhandled Context->Reason\n");
            break;
        }

    } // end switch (Context->Reason)
    return;
}


VOID
AddWmiStats(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PREDBOOK_COMPLETION_CONTEXT Context
    )
{
    KIRQL oldIrql;
    ULONG timeIncrement;

    if (Context->TimeReadSent.QuadPart == 0) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                   "Not Saving WMI Stats for REASON:\n"));
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                   "(ReadError, StreamError, Paused?)\n"));
        return;
    }

    timeIncrement = KeQueryTimeIncrement(); // amount of time for each tick

    KeAcquireSpinLock(&DeviceExtension->WmiPerfLock, &oldIrql);

    DeviceExtension->WmiPerf.TimeReadDelay    +=
        (Context->TimeReadSent.QuadPart      -
         Context->TimeReadReady.QuadPart     ) *
        timeIncrement;
    DeviceExtension->WmiPerf.TimeReading      +=
        (Context->TimeStreamReady.QuadPart   -
         Context->TimeReadSent.QuadPart      ) *
        timeIncrement;
    DeviceExtension->WmiPerf.TimeStreamDelay  +=
        (Context->TimeStreamSent.QuadPart    -
         Context->TimeStreamReady.QuadPart   ) *
        timeIncrement;
    DeviceExtension->WmiPerf.TimeStreaming    +=
        (Context->TimeReadReady.QuadPart     -
         Context->TimeStreamSent.QuadPart    ) *
        timeIncrement;

    DeviceExtension->WmiPerf.DataProcessed    +=
        DeviceExtension->WmiData.SectorsPerRead * RAW_SECTOR_SIZE;

    KeReleaseSpinLock( &DeviceExtension->WmiPerfLock, oldIrql );
    return;
}
////////////////////////////////////////////////////////////////////////////////


VOID
RedBookCheckForAudioDeviceRemoval(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
{
    ULONG state = GetCdromState(DeviceExtension);

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
               "STCheckForRemoval => Checking if audio device changed\n"));

    if (TEST_FLAG(state, CD_MASK_TEMP)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                   "STCheckForRemoval => delaying -- temp state\n"));
        return;
    }

    if (DeviceExtension->Stream.UpdateMixerPin == 0) {
        return;
    }

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
               "STCheckForRemoval => Audio Device may have changed\n"));

    if (TEST_FLAG(state, CD_PLAYING)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                   "STCheckForRemoval => playing, so stopping\n"));
        state = SetCdromState(DeviceExtension, state, CD_STOPPING);
        return;
    }

    if (TEST_FLAG(state, CD_STOPPED)) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                   "STCheckForRemoval => stopped, updating\n"));

    } else if (TEST_FLAG(state, CD_PAUSED)) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                   "STCheckForRemoval => paused, updating\n"));

        //
        // ISSUE-2000/5/24-henrygab - may not need to stop
        //                            unless mixer becomes -1,
        //                            since we could then send
        //                            to the new audio device.
        //
        state = SetCdromState(DeviceExtension, state, CD_STOPPED);

    }

    ASSERT(TEST_FLAG(GetCdromState(DeviceExtension), CD_STOPPED));

    //
    // set the value to zero (iff the value was one)
    // check if the value was one, and if so, update the mixerpin
    //

    if (InterlockedCompareExchange(&DeviceExtension->Stream.UpdateMixerPin,
                                   0, 1) == 1) {

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                   "STCheckForRemoval => Updating MixerPin\n"));

        //
        // free any in-use play resources
        //

        RedBookDeallocatePlayResources(DeviceExtension);

        if (DeviceExtension->Stream.MixerPinId != -1) {
            UninitializeVirtualSource(DeviceExtension);
        }

        InitializeVirtualSource(DeviceExtension);

        if (DeviceExtension->Stream.MixerPinId == -1) {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugSysaudio, "[redbook] "
                       "STCheckForRemoval => Update of mixerpin "
                       "failed -- will retry later\n"));
            InterlockedExchange(&DeviceExtension->Stream.UpdateMixerPin, 1);
            return;
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\redbook\redbook.c ===
/*++
Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    RedBook.c

Abstract:

    This driver translates audio IOCTLs into raw reads from audio
    tracks on compliant cdrom drives.  These reads are then passed
    to Kernel Streaming (KS) to reduce switching into/out of kernel
    mode.
    This driver also emulates most hardware functions, such as
    current head position, during play operation.  This is done to
    prevent audio stuttering or because the drive would not understand
    the request while it is not playing audio (since it is only reading).

    At initialization, the driver reads the registry to determine
    if it should attach itself to the stack and the number of
    buffers to allocate.

    The WmiData (including enable/disable) may be changed while the
    drive is not playing audio.

    Read errors cause the buffer to be zero'd out and passed
    along, much like a CD player skipping.   Too many consecutive
    errors will cause the play operation to abort.

Author:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "redbook.h"
#include "ntddredb.h"
#include "proto.h"
#include <scsi.h>      // for SetKnownGoodDrive()
#include <stdio.h>     // vsprintf()

#ifdef _USE_ETW
#include "redbook.tmh"
#endif // _USE_ETW


//////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
//
// Define the sections that allow for paging some of
// the code.
//


#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE,   RedBookForwardIrpSynchronous  )
    #pragma alloc_text(PAGE,   RedBookGetDescriptor          )
    #pragma alloc_text(PAGE,   RedBookRegistryRead           )
    #pragma alloc_text(PAGE,   RedBookRegistryWrite          )
    #pragma alloc_text(PAGE,   RedBookSetTransferLength      )
#endif // ALLOC_PRAGMA

//
// use this to get mode pages
//

typedef struct _PASS_THROUGH_REQUEST {
    SCSI_PASS_THROUGH Srb;
    SENSE_DATA SenseInfoBuffer;
    UCHAR DataBuffer[0];
} PASS_THROUGH_REQUEST, *PPASS_THROUGH_REQUEST;



//////////////////////////////////////////////////////////////////
///                       END PROTOTYPES                       ///
//////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////


NTSTATUS
RedBookRegistryRead(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    This routine queries the registry for values for the
    corresponding PDO.  The values are then saved in the
    given DeviceExtension.

Arguments:

    PhysicalDeviceObject - the physical device object we are being added to

    DeviceExtension - the redbook device extension used

Return Value:

    status

--*/


{
    //
    // Use registry to hold key information
    //

    HANDLE                   deviceParameterHandle; // cdrom instance key
    HANDLE                   driverParameterHandle; // digital audio subkey
    OBJECT_ATTRIBUTES        objectAttributes = {0};
    UNICODE_STRING           subkeyName;
    NTSTATUS                 status;

    // seeded in the ENUM tree by ClassInstaller
    ULONG32 regCDDAAccurate;
    ULONG32 regCDDASupported;
    ULONG32 regSectorsPerReadMask;
    // seeded first time booting, set by wmi/control panel
    ULONG32 regSectorsPerRead;
    ULONG32 regNumberOfBuffers;
    ULONG32 regVersion;
    // table for above registry entries
    RTL_QUERY_REGISTRY_TABLE queryTable[7] = {0};         // null-terminated array


    PAGED_CODE();

    deviceParameterHandle = NULL;
    driverParameterHandle = NULL;

     // CDDAAccurate and Supported set from SetKnownGoodDrive()
    regCDDAAccurate = DeviceExtension->WmiData.CDDAAccurate;
    regCDDASupported = DeviceExtension->WmiData.CDDASupported;
    regSectorsPerReadMask = -1;

    regSectorsPerRead = REDBOOK_WMI_SECTORS_DEFAULT;
    regNumberOfBuffers = REDBOOK_WMI_BUFFERS_DEFAULT;
    regVersion = 0;


    TRY {
        status = IoOpenDeviceRegistryKey(DeviceExtension->TargetPdo,
                                         PLUGPLAY_REGKEY_DEVICE,
                                         KEY_WRITE,
                                         &deviceParameterHandle
                                         );

        if (!NT_SUCCESS(status)) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                       "RegistryRead !! CDROM PnP Instance DNE? %lx\n",
                       status));
            LEAVE;
        }

        RtlInitUnicodeString(&subkeyName, REDBOOK_REG_SUBKEY_NAME);
        InitializeObjectAttributes(&objectAttributes,
                                   &subkeyName,
                                   OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                   deviceParameterHandle,
                                   NULL
                                   );

        status = ZwOpenKey( &driverParameterHandle,
                            KEY_READ,
                            &objectAttributes
                            );

        if (!NT_SUCCESS(status)) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                       "RegistryRead !! Subkey not opened, using "
                       "defaults %lx\n", status));
            LEAVE;
        }


        //
        // Setup the structure to read
        //

        queryTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        queryTable[0].Name          = REDBOOK_REG_CDDA_ACCURATE_KEY_NAME;
        queryTable[0].EntryContext  = &regCDDAAccurate;
        queryTable[0].DefaultType   = REG_DWORD;
        queryTable[0].DefaultData   = &regCDDAAccurate;
        queryTable[0].DefaultLength = 0;

        queryTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        queryTable[1].Name          = REDBOOK_REG_CDDA_SUPPORTED_KEY_NAME;
        queryTable[1].EntryContext  = &regCDDASupported;
        queryTable[1].DefaultType   = REG_DWORD;
        queryTable[1].DefaultData   = &regCDDASupported;
        queryTable[1].DefaultLength = 0;

        queryTable[2].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        queryTable[2].Name          = REDBOOK_REG_SECTORS_MASK_KEY_NAME;
        queryTable[2].EntryContext  = &regSectorsPerReadMask;
        queryTable[2].DefaultType   = REG_DWORD;
        queryTable[2].DefaultData   = &regSectorsPerReadMask;
        queryTable[2].DefaultLength = 0;

        queryTable[3].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        queryTable[3].Name          = REDBOOK_REG_SECTORS_KEY_NAME;
        queryTable[3].EntryContext  = &regSectorsPerRead;
        queryTable[3].DefaultType   = REG_DWORD;
        queryTable[3].DefaultData   = &regSectorsPerRead;
        queryTable[3].DefaultLength = 0;

        queryTable[4].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        queryTable[4].Name          = REDBOOK_REG_BUFFERS_KEY_NAME;
        queryTable[4].EntryContext  = &regNumberOfBuffers;
        queryTable[4].DefaultType   = REG_DWORD;
        queryTable[4].DefaultData   = &regNumberOfBuffers;
        queryTable[4].DefaultLength = 0;

        queryTable[5].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        queryTable[5].Name          = REDBOOK_REG_VERSION_KEY_NAME;
        queryTable[5].EntryContext  = &regVersion;
        queryTable[5].DefaultType   = REG_DWORD;
        queryTable[5].DefaultData   = &regVersion;
        queryTable[5].DefaultLength = 0;

        //
        // queryTable[6] is null-filled to terminate reading
        //

        //
        // read values
        //

        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        (PWSTR)driverParameterHandle,
                                        &queryTable[0],
                                        NULL,
                                        NULL
                                        );

        //
        // Check for failure...
        //

        if (!NT_SUCCESS(status)) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                       "RegistryRead !! default values (read "
                       "failed) %lx\n", status));
            LEAVE;
        }
        status = STATUS_SUCCESS;

    } FINALLY {

        if (deviceParameterHandle) {
            ZwClose(deviceParameterHandle);
        }

        if (driverParameterHandle) {
            ZwClose(driverParameterHandle);
        }

        if (!NT_SUCCESS(status)) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                       "RegistryRead !! Using Defaults\n"));
        }

    }

    if (regVersion > REDBOOK_REG_VERSION) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                       "RegistryRead !! Version %x in registry newer than %x\n",
                       regVersion, REDBOOK_REG_VERSION));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // successfully read from the registry, but make sure data is valid.
    //

    if (regSectorsPerReadMask == 0) {
        if (regCDDAAccurate) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                       "RegistryRead !! SectorMask==0 && CDDAAccurate?\n"));
        }
        if (regCDDASupported) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                       "RegistryRead !! SectorMask==0 && CDDASupported?\n"));
        }
        regCDDAAccurate = 0;
        regCDDASupported = 0;
    }

    if (regSectorsPerRead < REDBOOK_WMI_SECTORS_MIN) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryRead !! SectorsPerRead too small\n"));
        regSectorsPerRead = REDBOOK_WMI_SECTORS_MIN;
    }
    if (regSectorsPerRead > REDBOOK_WMI_SECTORS_MAX) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryRead !! SectorsPerRead too large\n"));
        regSectorsPerRead = REDBOOK_WMI_SECTORS_MAX;
    }

    if (regNumberOfBuffers < REDBOOK_WMI_BUFFERS_MIN) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryRead !! NumberOfBuffers too small\n"));
        regNumberOfBuffers = REDBOOK_WMI_BUFFERS_MIN;
    }
    if (regNumberOfBuffers > REDBOOK_WMI_BUFFERS_MAX) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryRead !! NumberOfBuffers too large\n"));
        regNumberOfBuffers = REDBOOK_WMI_BUFFERS_MAX;
    }

    if (regSectorsPerRead > DeviceExtension->WmiData.MaximumSectorsPerRead) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryRead !! SectorsPerRead too big for adapter\n"));
        regSectorsPerRead = DeviceExtension->WmiData.MaximumSectorsPerRead;
    }

    DeviceExtension->WmiData.CDDAAccurate = regCDDAAccurate ? 1 : 0;
    DeviceExtension->WmiData.CDDASupported = regCDDASupported ? 1: 0;

    DeviceExtension->WmiData.SectorsPerReadMask = regSectorsPerReadMask;

    /*
     *  Don't update WmiData.SectorsPerRead and WmiData.NumberOfBuffers yet, 
     *  because doing so while we're playing can disrupt our play buffers 
     *  (and we could have been stopped and restarted in the middle of playing).
     *  So just save these values until the beginning of the next play.
     */
    DeviceExtension->NextWmiSectorsPerRead = regSectorsPerRead;
    DeviceExtension->NextWmiNumberOfBuffers = regNumberOfBuffers;

    return STATUS_SUCCESS;
}


NTSTATUS
RedBookRegistryWrite(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    This routine queries the registry for values for the
    corresponding PDO.  The values are then saved in the
    given DeviceExtension.

Arguments:

    PhysicalDeviceObject - the physical device object we are being added to

    DeviceExtension - the redbook device extension used

Return Value:

    status

--*/


{
    OBJECT_ATTRIBUTES objectAttributes = {0};
    UNICODE_STRING    subkeyName;
    HANDLE            deviceParameterHandle; // cdrom instance key
    HANDLE            driverParameterHandle; // redbook subkey

    // seeded in the ENUM tree by ClassInstaller
    ULONG32 regCDDAAccurate;
    ULONG32 regCDDASupported;
    ULONG32 regSectorsPerReadMask;
    // seeded first time booting, set by wmi/control panel
    ULONG32 regSectorsPerRead;
    ULONG32 regNumberOfBuffers;
    ULONG32 regVersion;

    NTSTATUS          status;

    PAGED_CODE();

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
               "RegistryWrite => Opening key\n"));

    status = IoOpenDeviceRegistryKey(DeviceExtension->TargetPdo,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     KEY_ALL_ACCESS,
                                     &deviceParameterHandle);

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryWrite !! CDROM PnP Instance DNE? %lx\n",
                   status));
        return status;
    }

    RtlInitUnicodeString(&subkeyName, REDBOOK_REG_SUBKEY_NAME);
    InitializeObjectAttributes(&objectAttributes,
                               &subkeyName,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               deviceParameterHandle,
                               (PSECURITY_DESCRIPTOR) NULL);

    //
    // Create the key or open it if it already exists
    //

    status = ZwCreateKey(&driverParameterHandle,
                         KEY_WRITE | KEY_READ,
                         &objectAttributes,
                         0,
                         (PUNICODE_STRING) NULL,
                         REG_OPTION_NON_VOLATILE,
                         NULL);

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryWrite !! Subkey not created? %lx\n", status));
        ZwClose(deviceParameterHandle);
        return status;
    }

    regCDDAAccurate       = DeviceExtension->WmiData.CDDAAccurate;
    regCDDASupported      = DeviceExtension->WmiData.CDDASupported;
    regSectorsPerReadMask = DeviceExtension->WmiData.SectorsPerReadMask;
    regVersion            = REDBOOK_REG_VERSION;

    /*
     *  Don't write the actual WmiData.SectorsPerRead and WmiData.NumberOfBuffers.
     *  Write the last values that were set, which is the ones that we will use on the next play.
     */
    regSectorsPerRead     = DeviceExtension->NextWmiSectorsPerRead;
    regNumberOfBuffers    = DeviceExtension->NextWmiNumberOfBuffers;

    status = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
                                   (PWSTR)driverParameterHandle,
                                   REDBOOK_REG_VERSION_KEY_NAME,
                                   REG_DWORD,
                                   &regVersion,
                                   sizeof(regVersion));

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryWrite !! Failed write version %lx\n", status));
    }

    status = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
                                   (PWSTR)driverParameterHandle,
                                   REDBOOK_REG_BUFFERS_KEY_NAME,
                                   REG_DWORD,
                                   &regNumberOfBuffers,
                                   sizeof(regNumberOfBuffers));

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryWrite !! Failed write buffers %lx\n", status));
    }

    status = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
                                   (PWSTR)driverParameterHandle,
                                   REDBOOK_REG_SECTORS_KEY_NAME,
                                   REG_DWORD,
                                   &regSectorsPerRead,
                                   sizeof(regSectorsPerRead));

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryWrite !! Failed write sectors %lx\n", status));
    }

    status = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
                                   (PWSTR) driverParameterHandle,
                                   REDBOOK_REG_SECTORS_MASK_KEY_NAME,
                                   REG_DWORD,
                                   &regSectorsPerReadMask,
                                   sizeof(regSectorsPerReadMask));

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryWrite !! Failed write SectorsMask %lx\n",
                   status));
    }

    status = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
                                   (PWSTR)driverParameterHandle,
                                   REDBOOK_REG_CDDA_SUPPORTED_KEY_NAME,
                                   REG_DWORD,
                                   &regCDDASupported,
                                   sizeof(regCDDASupported));

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryWrite !! Failed write Supported %lx\n", status));
    }

    status = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
                                   (PWSTR)driverParameterHandle,
                                   REDBOOK_REG_CDDA_ACCURATE_KEY_NAME,
                                   REG_DWORD,
                                   &regCDDAAccurate,
                                   sizeof(regCDDAAccurate));

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugRegistry, "[redbook] "
                   "RegistryWrite !! Failed write Accurate %lx\n", status));
    }


    //
    // close the handles
    //

    ZwClose(driverParameterHandle);
    ZwClose(deviceParameterHandle);

    return STATUS_SUCCESS;
}


NTSTATUS
RedBookReadWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    This routine simply rejects read/write irps if currently
    playing audio.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/
{
    PREDBOOK_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;
    ULONG state;

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS(status)) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
        return status;
    }

    if (!deviceExtension->WmiData.PlayEnabled) {
        status = RedBookSendToNextDriver(DeviceObject, Irp);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        return status;
    }

    state = GetCdromState(deviceExtension);

    //
    // it doesn't really matter if we allow a few reads down during
    // the start of a play, since io is not guaranteed to occur in
    // order.
    //

    if (!TEST_FLAG(state, CD_PLAYING)) {
        status = RedBookSendToNextDriver(DeviceObject, Irp);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        return status;
    }

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugTrace, "[redbook] "
               "ReadWrite => Rejecting a request\n"));

    Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
    return STATUS_DEVICE_BUSY;


}


NTSTATUS
RedBookSignalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )

/*++

Routine Description:

    This completion routine will signal the event given as context and then
    return STATUS_MORE_PROCESSING_REQUIRED to stop event completion.  It is
    the responsibility of the routine waiting on the event to complete the
    request and free the event.

Arguments:

    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp

    Event - a pointer to the event to signal

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    KeSetEvent(Event, IO_CD_ROM_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
RedBookSetTransferLength(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    calls ClassGetDescriptor()
    set the maxSectorsPerRead based on storage properties
    checks for knownGood drives using the extension

Arguments:

    DeviceExtension

Return Value:

    NTSTATUS

--*/
{
    PSTORAGE_DESCRIPTOR_HEADER storageDescriptor;
    PSTORAGE_ADAPTER_DESCRIPTOR adapterDescriptor;
    STORAGE_PROPERTY_ID storageProperty;
    ULONGLONG maxPageLength;
    ULONGLONG maxPhysLength;
    ULONGLONG sectorLength;
    ULONG sectors;
    NTSTATUS status;

    PAGED_CODE();

    storageDescriptor = NULL;
    storageProperty = StorageAdapterProperty;
    status = RedBookGetDescriptor( DeviceExtension,
                                   &storageProperty,
                                   &storageDescriptor
                                   );

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                   "SetTranLen => failed to get descriptor\n"));
        ASSERT( storageDescriptor == NULL );
        NOTHING;
    } else {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                   "SetTranLen => got descriptor\n"));
        ASSERT( storageDescriptor != NULL );
        adapterDescriptor = (PVOID)storageDescriptor;

        maxPhysLength  = (ULONGLONG) adapterDescriptor->MaximumTransferLength;

        maxPageLength  = (ULONGLONG) adapterDescriptor->MaximumPhysicalPages;
        maxPageLength *= PAGE_SIZE;

        sectors = -1;
        sectorLength = sectors * (ULONGLONG)PAGE_SIZE;

        if (maxPhysLength == 0 || maxPageLength == 0) {

            //
            // what to do in this case?  disable redbook?
            //

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                       "SetTranLen !! The adapter cannot support transfers?!\n"));
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                       "SetTranLen !! maxPhysLength = %I64x\n", maxPhysLength));
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugError, "[redbook] "
                       "SetTranLen !! maxPageLength = %I64x\n", maxPageLength));
            ASSERT(!"[redbook] SetTranLen !! Got bogus adapter properties");

            maxPhysLength = 1;
            maxPageLength = 1;

        }


        if (maxPhysLength > sectorLength &&
            maxPageLength > sectorLength) {  // more than ulong can store?

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "SetTranLen => both Max's more than a ulong?\n" ));

        } else if ( (ULONGLONG)maxPhysLength > (ULONGLONG)maxPageLength) {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "SetTranLen => restricted due to page length\n" ));
            sectorLength = maxPageLength;

        } else {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "SetTranLen => restricted due to phys length\n" ));
            sectorLength = maxPhysLength;

        }

        sectorLength -= PAGE_SIZE; // to handle non-page-aligned allocations

        if (sectorLength < RAW_SECTOR_SIZE) {
            sectorLength = RAW_SECTOR_SIZE;
        }

        //
        // took the smaller of physical transfer and page transfer,
        // therefore will never overflow sectors
        //

        sectors = (ULONG)(sectorLength / (ULONGLONG)RAW_SECTOR_SIZE);



        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                   "SetTranLen => MaxTransferLength      = %lx\n",
                   adapterDescriptor->MaximumTransferLength));
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                   "SetTranLen => MaxPhysicalPages       = %lx\n",
                   adapterDescriptor->MaximumPhysicalPages));
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                   "SetTranLen => Setting max sectors to = %lx\n",
                   sectors));

        DeviceExtension->WmiData.MaximumSectorsPerRead = min(sectors, REDBOOK_WMI_SECTORS_MAX);

        if (DeviceExtension->NextWmiSectorsPerRead > sectors) {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "SetTranLen => Current sectors per read (%lx) too "
                       "large. Setting to max sectors per read\n",
                       DeviceExtension->NextWmiSectorsPerRead));
            DeviceExtension->NextWmiSectorsPerRead = sectors;

        } else if (DeviceExtension->NextWmiSectorsPerRead == 0) {

            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "SetTranLen => Current sectors per read (%lx) zero. "
                       "Setting to max sectors per read\n",
                       DeviceExtension->NextWmiSectorsPerRead));
            DeviceExtension->NextWmiSectorsPerRead = sectors;

        }


    }

    if (storageDescriptor !=NULL) {
        ExFreePool(storageDescriptor);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RedBookPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PREDBOOK_DEVICE_EXTENSION deviceExtension;
    NTSTATUS status;

    deviceExtension = (PREDBOOK_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                   "Power request after removal -- failing %x\n",
                   status));
        return status;
    }

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    
    status = PoCallDriver(deviceExtension->TargetDeviceObject, Irp);
    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
    return status;
}


NTSTATUS
RedBookForwardIrpSynchronous(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
{
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, RedBookSignalCompletion, &event,
                           TRUE, TRUE, TRUE);

    status = IoCallDriver(DeviceExtension->TargetDeviceObject, Irp);

    if(status == STATUS_PENDING) {
        KeWaitForSingleObject(&event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        status = Irp->IoStatus.Status;
    }

    return status;
}


NTSTATUS
RedBookGetDescriptor(
    IN PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    IN PSTORAGE_PROPERTY_ID PropertyId,
    OUT PSTORAGE_DESCRIPTOR_HEADER *Descriptor
    )
/*++

Routine Description:

    This routine will perform a query for the specified property id and will
    allocate a non-paged buffer to store the data in.  It is the responsibility
    of the caller to ensure that this buffer is freed.

    This routine must be run at IRQL_PASSIVE_LEVEL

Arguments:

    DeviceObject - the device to query
    DeviceInfo - a location to store a pointer to the buffer we allocate

Return Value:

    status
    if status is unsuccessful *DeviceInfo will be set to 0

--*/

{
    PDEVICE_OBJECT selfDeviceObject = DeviceExtension->SelfDeviceObject;
    PSTORAGE_DESCRIPTOR_HEADER descriptor;
    PSTORAGE_PROPERTY_QUERY query;
    PIO_STACK_LOCATION irpStack;
    PIRP irp;
    NTSTATUS status;
    ULONG length;
    UCHAR pass;

    PAGED_CODE();

    descriptor = NULL;
    irp = NULL;
    irpStack = NULL;
    query = NULL;
    pass = 0;


    //
    // Set the descriptor pointer to NULL
    //

    *Descriptor = NULL;

    TRY {

        // NOTE: should probably just use IoAllocateIrp() and
        // IoReuseIrp() when this gets updated.
        // Historical note: IoReuseIrp() was not available when
        // this was written, and verifier was just beginning and
        // complained loudly about reused irps.

        irp = ExAllocatePoolWithTag(NonPagedPool,
                                    IoSizeOfIrp(selfDeviceObject->StackSize+1),
                                    TAG_GET_DESC1);
        if (irp   == NULL) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                       "GetDescriptor: Unable to allocate irp\n"));
            status = STATUS_NO_MEMORY;
            LEAVE;
        }

        //
        // initialize the irp
        //

        IoInitializeIrp(irp,
                        IoSizeOfIrp(selfDeviceObject->StackSize+1),
                        (CCHAR)(selfDeviceObject->StackSize+1));
        irp->UserBuffer = NULL;

        IoSetNextIrpStackLocation(irp);

        //
        // Retrieve the property page
        //

        do {

            switch(pass) {

                case 0: {

                    //
                    // On the first pass we just want to get the first few
                    // bytes of the descriptor so we can read it's size
                    //

                    length = sizeof(STORAGE_DESCRIPTOR_HEADER);

                    descriptor = NULL;
                    descriptor = ExAllocatePoolWithTag(NonPagedPool,
                                                       MAX(sizeof(STORAGE_PROPERTY_QUERY),length),
                                                       TAG_GET_DESC2);

                    if (descriptor == NULL) {
                        status = STATUS_NO_MEMORY;
                        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                                   "GetDescriptor: unable to alloc"
                                   "memory for descriptor (%d bytes)\n",
                                   length));
                        LEAVE;
                    }

                    break;
                }

                case 1: {

                    //
                    // This time we know how much data there is so we can
                    // allocate a buffer of the correct size
                    //

                    length = descriptor->Size;
                    ExFreePool(descriptor);
                    descriptor = NULL;

                    //
                    // Note: this allocation is returned to the caller
                    //

                    descriptor = ExAllocatePoolWithTag(NonPagedPool,
                                                       MAX(sizeof(STORAGE_PROPERTY_QUERY),length),
                                                       TAG_GET_DESC);

                    if(descriptor == NULL) {
                        status = STATUS_NO_MEMORY;
                        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                                   "GetDescriptor: unable to alloc"
                                   "memory for descriptor (%d bytes)\n",
                                   length));
                        LEAVE;
                    }

                    break;
                }
            }

            irpStack = IoGetCurrentIrpStackLocation(irp);

            SET_FLAG(irpStack->Flags, SL_OVERRIDE_VERIFY_VOLUME);

            irpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
            irpStack->Parameters.DeviceIoControl.IoControlCode =
                IOCTL_STORAGE_QUERY_PROPERTY;
            irpStack->Parameters.DeviceIoControl.InputBufferLength =
                sizeof(STORAGE_PROPERTY_QUERY);
            irpStack->Parameters.DeviceIoControl.OutputBufferLength = length;

            irp->UserBuffer = descriptor;
            irp->AssociatedIrp.SystemBuffer = descriptor;


            query = (PVOID)descriptor;
            query->PropertyId = *PropertyId;
            query->QueryType = PropertyStandardQuery;


            //
            // send the irp
            //
            status = RedBookForwardIrpSynchronous(DeviceExtension, irp);

            if(!NT_SUCCESS(status)) {

                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugPnp, "[redbook] "
                           "GetDescriptor: error %lx trying to "
                           "query properties\n", status));
                LEAVE;
            }

        } while(pass++ < 1);

    } FINALLY {

        if (irp != NULL) {
            ExFreePool(irp);
        }

        if(!NT_SUCCESS(status)) {

            if (descriptor != NULL) {
                ExFreePool(descriptor);
                descriptor = NULL;
            }

        }
        *Descriptor = descriptor;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\redbook\trace.h ===
/*

    WPP_DEFINE_CONTROL_GUID specifies the GUID used for this filter.
    *** REPLACE THE GUID WITH YOUR OWN UNIQUE ID ***
    WPP_DEFINE_BIT allows setting debug bit masks to selectively print.
    
    everything else can revert to the default?

*/
#ifdef _USE_ETW

#define WPP_CONTROL_GUIDS \
    WPP_DEFINE_CONTROL_GUID(Redbook,(58db8e03,0537,45cb,b29b,597f6cbebbfe), \
        WPP_DEFINE_BIT(RedbookDebugError)         /* bit  0 = 0x00000001 */ \
        WPP_DEFINE_BIT(RedbookDebugWarning)       /* bit  1 = 0x00000002 */ \
        WPP_DEFINE_BIT(RedbookDebugTrace)         /* bit  2 = 0x00000004 */ \
        WPP_DEFINE_BIT(RedbookDebugInfo)          /* bit  3 = 0x00000008 */ \
        WPP_DEFINE_BIT(RedbookDebugD04)           /* bit  4 = 0x00000010 */ \
        WPP_DEFINE_BIT(RedbookDebugErrlog)        /* bit  5 = 0x00000020 */ \
        WPP_DEFINE_BIT(RedbookDebugRegistry)      /* bit  6 = 0x00000040 */ \
        WPP_DEFINE_BIT(RedbookDebugAllocPlay)     /* bit  7 = 0x00000080 */ \
        WPP_DEFINE_BIT(RedbookDebugPnp)           /* bit  8 = 0x00000100 */ \
        WPP_DEFINE_BIT(RedbookDebugThread)        /* bit  9 = 0x00000200 */ \
        WPP_DEFINE_BIT(RedbookDebugWmi)           /* bit 10 = 0x00000400 */ \
        WPP_DEFINE_BIT(RedbookDebugIoctl)         /* bit 11 = 0x00000800 */ \
        WPP_DEFINE_BIT(RedbookDebugIoctlV)        /* bit 12 = 0x00001000 */ \
        WPP_DEFINE_BIT(RedbookDebugSysaudio)      /* bit 13 = 0x00002000 */ \
        WPP_DEFINE_BIT(RedbookDebugDigitalR)      /* bit 14 = 0x00004000 */ \
        WPP_DEFINE_BIT(RedbookDebugDigitalS)      /* bit 15 = 0x00008000 */ \
        WPP_DEFINE_BIT(FilterDebugD16)            /* bit 16 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD17)            /* bit 17 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD18)            /* bit 18 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD19)            /* bit 19 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD20)            /* bit 20 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD21)            /* bit 21 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD22)            /* bit 22 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD23)            /* bit 23 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD24)            /* bit 24 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD25)            /* bit 25 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD26)            /* bit 26 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD27)            /* bit 27 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD28)            /* bit 28 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD29)            /* bit 29 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD30)            /* bit 30 = 0x00000000 */ \
        WPP_DEFINE_BIT(FilterDebugD31)            /* bit 31 = 0x00000000 */ \
        )
#else

typedef enum {
    RedbookDebugError = 0,
    RedbookDebugWarning = 1,
    RedbookDebugTrace = 2,
    RedbookDebugInfo = 3,
    RedbookDebugD04 = 4,
    RedbookDebugErrlog = 5,
    RedbookDebugRegistry = 6,
    RedbookDebugAllocPlay = 7,
    RedbookDebugPnp = 8,
    RedbookDebugThread = 9,
    RedbookDebugWmi = 10,
    RedbookDebugIoctl = 11,
    RedbookDebugIoctlV = 12,
    RedbookDebugSysaudio = 13,
    RedbookDebugDigitalR = 14,
    RedbookDebugDigitalS = 15,
    FilterDebugD16 = 16,
    FilterDebugD17 = 17,
    FilterDebugD18 = 18,
    FilterDebugD19 = 19,
    FilterDebugD20 = 20,
    FilterDebugD21 = 21,
    FilterDebugD22 = 22,
    FilterDebugD23 = 23,
    FilterDebugD24 = 24,
    FilterDebugD25 = 25,
    FilterDebugD26 = 26,
    FilterDebugD27 = 27,
    FilterDebugD28 = 28,
    FilterDebugD29 = 29,
    FilterDebugD30 = 30,
    FilterDebugD31 = 31
};

#endif // _USE_ETW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\database.c ===
/*
 *  DATABASE.C
 *
 *      RSM Service :  Database management
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\debug.c ===
/*
 *  DEBUG.C
 *
 *      RSM Service :  Debug code
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\redbook\wmi.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       wmi.c
//
//--------------------------------------------------------------------------


#include "redbook.h"
#include "ntddredb.h"
#include "proto.h"

#ifdef _USE_ETW
#include "wmi.tmh"
#endif // _USE_ETW

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE,   RedBookThreadWmiHandler)
    #pragma alloc_text(PAGE,   RedBookWmiInit)
    #pragma alloc_text(PAGE,   RedBookWmiQueryDataBlock)
    #pragma alloc_text(PAGE,   RedBookWmiQueryRegInfo)
    #pragma alloc_text(PAGE,   RedBookWmiSetDataBlock)
    #pragma alloc_text(PAGE,   RedBookWmiSetDataItem)
    #pragma alloc_text(PAGE,   RedBookWmiSystemControl)
    #pragma alloc_text(PAGE,   RedBookWmiUninit)
#endif // ALLOC_PRAGMA


#define REDBOOK_STD_INDEX      0   // index into WMIGUIDREGINFO
#define REDBOOK_PERF_INDEX     1   // index into WMIGUIDREGINFO

WMIGUIDREGINFO RedBookWmiGuidList[] =
{
    // GUID,  # of data blocks,  flags
    { &MSRedbook_DriverInformationGuid, 1, 0 },  // RedBook driver info
    { &MSRedbook_PerformanceGuid, 1, 0 }  // some perf stuff also
};
/////////////////////////////////////////////////////////

NTSTATUS
RedBookWmiUninit(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PAGED_CODE();

    if (DeviceExtension->WmiLibInitialized) {
        status = IoWMIRegistrationControl(DeviceExtension->SelfDeviceObject,
                                          WMIREG_ACTION_DEREGISTER);
        ASSERT(NT_SUCCESS(status)); // can not fail?
        DeviceExtension->WmiLibInitialized = 0;
    }
    return status;

}


NTSTATUS
RedBookWmiInit(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    if (DeviceExtension->WmiLibInitialized) {
        return STATUS_SUCCESS;
    }

    DeviceExtension->WmiLibInfo.GuidCount = sizeof(RedBookWmiGuidList) /
                                            sizeof(WMIGUIDREGINFO);

    ASSERT(DeviceExtension->WmiLibInfo.GuidCount > 0);
    DeviceExtension->WmiLibInfo.GuidList           = RedBookWmiGuidList;
    DeviceExtension->WmiLibInfo.QueryWmiDataBlock  = RedBookWmiQueryDataBlock;
    DeviceExtension->WmiLibInfo.QueryWmiRegInfo    = RedBookWmiQueryRegInfo;
    DeviceExtension->WmiLibInfo.SetWmiDataBlock    = RedBookWmiSetDataBlock;
    DeviceExtension->WmiLibInfo.SetWmiDataItem     = RedBookWmiSetDataItem;
    DeviceExtension->WmiLibInfo.ExecuteWmiMethod   = NULL;
    DeviceExtension->WmiLibInfo.WmiFunctionControl = NULL;

    status = IoWMIRegistrationControl(DeviceExtension->SelfDeviceObject,
                                      WMIREG_ACTION_REGISTER);

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWarning, "[redbook] "
                   "WmiInit !! Failed [%#010lx]\n", status));
    } else {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                   "WmiInit => Successfully registered\n"));
        DeviceExtension->WmiLibInitialized = 1;
    }

    return status;

}


NTSTATUS
RedBookWmiQueryDataBlock (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          InstanceCount,
    IN OUT PULONG     InstanceLengthArray,
    IN ULONG          OutBufferSize,
    OUT PUCHAR        Buffer
    )

/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call RedBookWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the instance within the GuidIndex to query

    InstanceCount is ???

    InstanceLengthArray is a pointer to an array of ULONG that returns
        the lengths of each instance of the data block.  If this is NULL
        then there was not enough space in the output buffer to fulfill
        the request so the irp should be completed with the buffer needed.

    OutputBufferSize has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block

Return Value:

    status

--*/

{
    PREDBOOK_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;
    ULONG size = 0;

    PAGED_CODE();

    //
    // Only one instance per GUID
    //

    ASSERT( InstanceIndex == 0 );
    ASSERT( InstanceCount == 1 );

    switch (GuidIndex) {
    case REDBOOK_STD_INDEX: {

        if (InstanceIndex != 0) {
            status = STATUS_WMI_INSTANCE_NOT_FOUND;
            break;
        }

        //
        // Reject the request if not enough space alloc'd
        //

        if (OutBufferSize < sizeof(REDBOOK_WMI_STD_DATA)) {
            size   = sizeof(REDBOOK_WMI_STD_DATA);
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // requests for wmi information can occur while
        // the system is playing audio.  just copy the info
        //

        RtlCopyMemory( Buffer,
                       &deviceExtension->WmiData,
                       sizeof(REDBOOK_WMI_STD_DATA)
                       );

        /*
         *  BUT overwrite these two values with the last-set ones.
         *  They apply to the next play, but constitute the current state from WMI's point of view.
         */
        ((PREDBOOK_WMI_STD_DATA)Buffer)->NumberOfBuffers = deviceExtension->NextWmiNumberOfBuffers;
        ((PREDBOOK_WMI_STD_DATA)Buffer)->SectorsPerRead = deviceExtension->NextWmiSectorsPerRead;

        //
        // Set the size for each instance
        //

        InstanceLengthArray[InstanceIndex] = sizeof(REDBOOK_WMI_STD_DATA);
        size += sizeof(REDBOOK_WMI_STD_DATA);

        status = STATUS_SUCCESS;
        break;
    }
    case REDBOOK_PERF_INDEX: {

        if (InstanceIndex != 0) {
            status = STATUS_WMI_INSTANCE_NOT_FOUND;
            break;
        }

        //
        // reject the request if not enough space alloc'd
        //

        if (OutBufferSize < sizeof(REDBOOK_WMI_PERF_DATA)) {
            size = sizeof(REDBOOK_WMI_PERF_DATA);
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // Requests for wmi information can occur while
        // the system is playing audio. just copy the info
        //

        RedBookWmiCopyPerfInfo(deviceExtension, (PVOID)Buffer);

        //
        // set the size for each instance
        //

        InstanceLengthArray[InstanceIndex] = sizeof(REDBOOK_WMI_PERF_DATA);
        size += sizeof(REDBOOK_WMI_PERF_DATA);
        status = STATUS_SUCCESS;
        break;
    }

    default: {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                   "WmiQueryDataBlock !! Invalid GUID [%#010lx]\n",
                   GuidIndex));
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }
    }

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
               "WmiQueryDataBlock => internal status [%#010lx]\n",
               status));

    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
    status = WmiCompleteRequest(DeviceObject,
                                Irp,
                                status,
                                size,
                                IO_CD_ROM_INCREMENT);

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                   "WmiQueryDataBlock => IoWMICompleteRequest failed [%#010lx]\n",
                   status));
    }
    return status;
}


NTSTATUS
RedBookWmiSetDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    )

/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block.
    When the driver has finished filling the data block it must call
    IoWMICompleteRequest(???) to complete the irp.
    The driver can return STATUS_PENDING if the irp cannot be
    completed immediately.

Arguments:

    DeviceObject - the device whose data block is being queried

    Irp - Irp that makes this request

    GuidIndex - index into the list of guids provided
        when the device registered

    InstanceIndex - the index that denotes which index of the
        data block is being set

    BufferSize - the size of the data block passed

    Buffer - the new values for the data block

Return Value:

    status

--*/
{
    PREDBOOK_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    ULONG size = 0;
    NTSTATUS status;

    PAGED_CODE();

    switch( GuidIndex ) {
    case REDBOOK_STD_INDEX: {

        REDBOOK_WMI_STD_DATA wmiData;
        ULONG state;

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                   "WmiSetDataBlock => Instance: [%#010lx]  BuffSize: [%#010lx]\n",
                   InstanceIndex, BufferSize));

        state = GetCdromState(deviceExtension);

        if (InstanceIndex != 0) {
            status = STATUS_WMI_INSTANCE_NOT_FOUND;
            break;
        }

        if ( BufferSize != sizeof(REDBOOK_WMI_STD_DATA) ) {
            status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        wmiData = *(PREDBOOK_WMI_STD_DATA)Buffer;

        //
        // verify the buffer contains valid information
        //

        if ( wmiData.NumberOfBuffers > REDBOOK_WMI_BUFFERS_MAX ||
             wmiData.NumberOfBuffers < REDBOOK_WMI_BUFFERS_MIN ) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                       "WmiSetDataBlock !! Invalid number of bufers [%#010lx]\n",
                       wmiData.NumberOfBuffers));
            status = STATUS_WMI_SET_FAILURE;
            break;
        }
        if ( wmiData.SectorsPerRead > REDBOOK_WMI_SECTORS_MAX   ||
             wmiData.SectorsPerRead < REDBOOK_WMI_SECTORS_MIN   ||
             wmiData.SectorsPerRead > wmiData.MaximumSectorsPerRead ) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                       "WmiSetDataBlock !! Invalid number of sectors per read [%#010lx]\n",
                       wmiData.SectorsPerRead));
            status = STATUS_WMI_SET_FAILURE;
            break;
        }
        if ( wmiData.PlayEnabled != TRUE &&
             wmiData.PlayEnabled != FALSE
             ) {
            KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                       "WmiSetDataBlock !! Invalid setting for play enabled [%#010lx]\n",
                       wmiData.PlayEnabled));
            status = STATUS_WMI_SET_FAILURE;
            break;
        }

        /*
         *  Changing WmiData.SectorsPerRead and WmiData.NumberOfBuffers in the middle of playing
         *  could disrupt our buffers.  So just save these new values and update them at the beginning
         *  of the next play.
         */
        deviceExtension->NextWmiNumberOfBuffers = wmiData.NumberOfBuffers;
        deviceExtension->NextWmiSectorsPerRead  = wmiData.SectorsPerRead;

        deviceExtension->WmiData.PlayEnabled     = wmiData.PlayEnabled;
        RedBookRegistryWrite(deviceExtension);

        status = STATUS_SUCCESS;
        break;
    }
    case REDBOOK_PERF_INDEX: {
        status = STATUS_WMI_READ_ONLY;
        break;
    }
    default: {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                   "WmiSetDataBlock !! Invalid GuidIndex [%#010lx]\n",
                   GuidIndex));
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }
    }

    IoReleaseRemoveLock( &deviceExtension->RemoveLock, Irp );
    status = WmiCompleteRequest( DeviceObject,
                                 Irp,
                                 status,
                                 sizeof(REDBOOK_WMI_STD_DATA),
                                 IO_CD_ROM_INCREMENT);
    return status;

}

NTSTATUS
RedBookWmiSetDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          DataItemId,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block.
    ??? When the driver has finished filling the data block it
        must call ClassWmiCompleteRequest(???) to complete the irp.
    The driver can return STATUS_PENDING if the irp cannot be
    completed immediately.

Arguments:

    DeviceObject - the device whose data block is being queried

    Irp - Irp that makes this request

    GuidIndex - index into the list of guids provided
        when the device registered

    DataItemId - Id of the data item being set

    BufferSize - the size of the data block passed

    Buffer - the new values for the data block

Return Value:

    status

--*/
{
    PREDBOOK_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    ULONG size = 0;
    ULONG newVal;
    NTSTATUS status;

    PAGED_CODE();

    switch( GuidIndex ) {
    case REDBOOK_STD_INDEX: {

        ULONG state;

        if (InstanceIndex != 0) {
            status = STATUS_WMI_INSTANCE_NOT_FOUND;
            break;
        }

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                     "WmiSetDataItem => Id: [%#010lx]  Size: [%#010lx]\n",
                     DataItemId, BufferSize));

        state = GetCdromState(deviceExtension);

        if (!TEST_FLAG(state, CD_STOPPED)) {
            status = STATUS_DEVICE_BUSY;
            break;
        }

        switch (DataItemId) {

            //
            // These are the only four settable items
            //

            case REDBOOK_WMI_NUMBER_OF_BUFFERS_ID:

                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                           "WmiSetDataItem => Setting NumberOfBuffers\n"));

                if (BufferSize != REDBOOK_WMI_NUMBER_OF_BUFFERS_SIZE) {
                    status = STATUS_WMI_SET_FAILURE;
                    break;
                }

                /*
                 *  Save the new value and update WmiData.NumberOfBuffers at the beginning of the next play.
                 */
                newVal = *(PULONG32)Buffer;
                newVal = max(newVal, REDBOOK_WMI_BUFFERS_MIN);
                newVal = min(newVal, REDBOOK_WMI_BUFFERS_MAX);
                deviceExtension->NextWmiNumberOfBuffers = newVal;

                RedBookRegistryWrite(deviceExtension);
                status = STATUS_SUCCESS;
                break;

            case REDBOOK_WMI_SECTORS_PER_READ_ID:

                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                           "WmiSetDataItem => Setting SectorsPerRead\n"));
                if (BufferSize != REDBOOK_WMI_SECTORS_PER_READ_SIZE) {
                    status = STATUS_WMI_SET_FAILURE;
                    break;
                }

                if (*(PULONG32)Buffer >
                    deviceExtension->WmiData.MaximumSectorsPerRead) {
                    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                               "WmiSetDataBlock => Interface Card / "
                               "CDROM combo does not support this size\n"));
                    status = STATUS_DEVICE_BUSY;
                    break;
                }

                /*
                 *  Save the new value and update WmiData.SectorsPerRead at the beginning of the next play.
                 */
                newVal = *(PULONG32)Buffer;
                newVal = max(newVal, REDBOOK_WMI_SECTORS_MIN);
                newVal = min(newVal, REDBOOK_WMI_SECTORS_MAX);
                deviceExtension->NextWmiSectorsPerRead = newVal;

                RedBookRegistryWrite(deviceExtension);
                status = STATUS_SUCCESS;
                break;

            case REDBOOK_WMI_PLAY_ENABLED_ID:

                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                           "WmiSetDataItem => Setting PlayEnabled\n"));
                if ( BufferSize != REDBOOK_WMI_PLAY_ENABLED_SIZE ) {
                    status = STATUS_WMI_SET_FAILURE;
                    break;
                }

                deviceExtension->WmiData.PlayEnabled = *(PBOOLEAN)Buffer;
                status = STATUS_SUCCESS;
                break;

                //
                // The remaining are invalid sets, as they are Read-Only values
                //
            case REDBOOK_WMI_SECTORS_PER_READ_MASK_ID:
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                           "WmiSetDataItem => Cannot set SectorsPerReadMask\n"));
                status = STATUS_WMI_READ_ONLY;
                break;

            case REDBOOK_WMI_CDDA_SUPPORTED_ID:
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                           "WmiSetDataItem => Cannot set Supported\n"));
                status = STATUS_WMI_READ_ONLY;
                break;

            case REDBOOK_WMI_CDDA_ACCURATE_ID:
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                           "WmiSetDataItem => Cannot set KnownGood\n"));
                status = STATUS_WMI_READ_ONLY;
                break;

            default:
                KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                           "WmiSetDataItem => Cannot set unknown "
                           "id %#010lx\n", DataItemId));
                status = STATUS_WMI_ITEMID_NOT_FOUND;
                break;
        }

        //
        // the status is now correctly set.
        // what should size be?
        //
        size = 0;
        break;
    }

    case REDBOOK_PERF_INDEX: {

        if (InstanceIndex != 0) {
            status = STATUS_WMI_INSTANCE_NOT_FOUND;
            break;
        }

        status = STATUS_WMI_READ_ONLY;
        size = 0;
        break;

    }
    default: {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                   "WmiSetDataItem !! Invalid GuidIndex: %#010lx\n",
                   GuidIndex));
        status = STATUS_WMI_GUID_NOT_FOUND;
        size = 0;
        break;
    }
    }

    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
    status = WmiCompleteRequest( DeviceObject,
                                 Irp,
                                 status,
                                 size,
                                 IO_CD_ROM_INCREMENT
                                 );
    return status;

}


NTSTATUS
RedBookWmiSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    System Control Irp
    Presume it is a WMI Irp and call into the WMI system to
    handle this IRP for us.

--*/
{
    PREDBOOK_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PREDBOOK_THREAD_WMI_DATA wmiData;
    PIO_STACK_LOCATION irpStack;
    NTSTATUS status;

    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    if (irpStack->Parameters.WMI.ProviderId != (ULONG_PTR)DeviceObject) {
        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);
    }

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, Irp);

    if ( !NT_SUCCESS(status) ) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_CD_ROM_INCREMENT );
        return status;
    }

    wmiData = ExAllocatePoolWithTag(NonPagedPool,
                                    sizeof(REDBOOK_THREAD_WMI_DATA),
                                    TAG_T_WMI);
    if (wmiData == NULL) {
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_NO_MEMORY;
        IoCompleteRequest( Irp, IO_CD_ROM_INCREMENT );
        return STATUS_NO_MEMORY;
    }

    wmiData->Irp = Irp;

    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
               "DispatchWmi => Queueing Irp %p\n", wmiData->Irp));

    //
    // queue them, allow thread to handle the request.
    //

    IoMarkIrpPending(Irp);

    ExInterlockedInsertTailList(&deviceExtension->Thread.WmiList,
                                &wmiData->ListEntry,
                                &deviceExtension->Thread.WmiLock);
    KeSetEvent(deviceExtension->Thread.Events[EVENT_WMI],
               IO_NO_INCREMENT, FALSE);

    return STATUS_PENDING;
}

VOID
RedBookThreadWmiHandler(
    PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    PLIST_ENTRY ListEntry
    )
{
    SYSCTL_IRP_DISPOSITION disposition = {0};
    PREDBOOK_THREAD_WMI_DATA wmiData;
    PIRP irp;
    NTSTATUS status;

    PAGED_CODE();
    VerifyCalledByThread(DeviceExtension);

    wmiData = CONTAINING_RECORD(ListEntry, REDBOOK_THREAD_WMI_DATA, ListEntry);

    irp = wmiData->Irp;
    KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
               "HandleWmi => Processing Irp %p\n", irp));

    ExFreePool(wmiData);
    wmiData = NULL;

    //
    // just process the irp now.
    //

    status = WmiSystemControl( &DeviceExtension->WmiLibInfo,
                               DeviceExtension->SelfDeviceObject,
                               irp,
                               &disposition);

    switch ( disposition ) {
        case IrpProcessed: {
            //
            // this irp has been processed and may be completed or pending
            //
            break;
        }
        case IrpNotCompleted: {
            //
            // this irp has not been completed, but has been fully processed.
            // we will complete it now.
            //
            IoReleaseRemoveLock(&DeviceExtension->RemoveLock, irp);
            IoCompleteRequest(irp, IO_CD_ROM_INCREMENT);
            break;
        }
        case IrpNotWmi:
        case IrpForward: {
            //
            // this irp is either not a wmi irp or is a wmi irp targetted
            // at a device lower in the stack.
            //
            IoReleaseRemoveLock(&DeviceExtension->RemoveLock, irp);
            IoSkipCurrentIrpStackLocation(irp);
            IoCallDriver(DeviceExtension->TargetDeviceObject, irp);
            break;
        }
        default: {
            //
            // we should never really get here, but if we do, just forward...
            //
            ASSERT(!"[redbook] WmiSystemControl (unhandled case)");
            IoReleaseRemoveLock(&DeviceExtension->RemoveLock, irp);
            IoSkipCurrentIrpStackLocation(irp);
            IoCallDriver(DeviceExtension->TargetDeviceObject, irp);
            break;
        }
    }

    return;
}



NTSTATUS
RedBookWmiQueryRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine is a callback into the driver to retrieve the
    list of guids or data blocks that the driver wants to register
    with WMI.  This routine may not pend or block.

Arguments:

    DeviceObject - the device whose data block is being queried

    RegFlags - Returns with a set of flags that describe the guids
        registered for this device. If the device wants to enable
        and disable collection callbacks before receiving queries
        for the registered guids then it should return the
        WMIREG_FLAG_EXPENSIVE flag. Also the returned flags may
        specify WMIREG_FLAG_INSTANCE_PDO in which case the instance
        name is determined from the PDO associated with the device
        object. Note that the PDO must have an associated devnode.
        If WMIREG_FLAG_INSTANCE_PDO is not set then Name must return
        a unique name for the device.

    InstanceName - Returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned RegFlags.
        The caller will call ExFreePool with the buffer returned.

    RegistryPath - Returns with the registry path of the driver

    MofResourceName - Returns with the name of the MOF resource attached
        to the binary file.  If the driver does not have a mof resource
        attached then this can be returned as NULL.

    PhysicalDeviceObject - Returns with the device object for the PDO
        associated with this device if the WMI_REG_FLAG_INSTANCE_PDO
        flag is returned in RegFlags

Return Value:

    status

--*/
{
    PREDBOOK_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PREDBOOK_DRIVER_EXTENSION driverExtension;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(InstanceName);

    driverExtension = IoGetDriverObjectExtension(deviceExtension->DriverObject,
                                                 REDBOOK_DRIVER_EXTENSION_ID);

    if (driverExtension)
    {
        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                   "WmiQueryRegInfo => driverExtension is [%p]\n",
                   driverExtension));

        KdPrintEx((DPFLTR_REDBOOK_ID, RedbookDebugWmi, "[redbook] "
                   "WmiQueryRegInfo => Registry Path = %ws\n",
                   driverExtension->RegistryPath.Buffer));

        *RegFlags             = WMIREG_FLAG_INSTANCE_PDO;
        *RegistryPath         = &(driverExtension->RegistryPath);
        *PhysicalDeviceObject = deviceExtension->TargetPdo;
    }
    else
    {
        status = STATUS_INTERNAL_ERROR;
    }

    return status;
}


VOID
RedBookWmiCopyPerfInfo(
    IN  PREDBOOK_DEVICE_EXTENSION DeviceExtension,
    OUT PREDBOOK_WMI_PERF_DATA Out
    )
{
    KIRQL irql;

    //
    // cannot be paged due to spinlock, which allows copy of
    // the LARGE_INTEGERS without problems.
    //

    KeAcquireSpinLock( &DeviceExtension->WmiPerfLock, &irql );
    RtlCopyMemory( Out,
                   &DeviceExtension->WmiPerf,
                   sizeof(REDBOOK_WMI_PERF_DATA)
                   );
    KeReleaseSpinLock( &DeviceExtension->WmiPerfLock, irql );

    //
    // now add InterlockedXxx() calls to safely get a couple of the items.
    //

    Out->StreamPausedCount =
        InterlockedCompareExchange(&DeviceExtension->WmiPerf.StreamPausedCount,0,0);

    //
    // finished.
    //
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\debug.h ===
/*
 *  DEBUG.H
 *
 *      RSM Service : Debug code
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */





#if DEBUG
    #define ASSERT(fact) { if (!(fact)) MessageBox(NULL, (LPSTR)#fact, (LPSTR)"NTMSSVC assertion failed", MB_OK); }
    #define DBGERR(args_in_parens)     // BUGBUG FINISH
    #define DBGWARN(args_in_parens)     // BUGBUG FINISH
#else
    #define ASSERT(fact)
    #define DBGERR(args_in_parens)     
    #define DBGWARN(args_in_parens)     
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\internal.h ===
/*
 *  INTERNAL.H
 *
 *      Internal header for RSM Service
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


typedef struct _SESSION SESSION;
typedef struct _WORKITEM WORKITEM;
typedef struct _WORKGROUP WORKGROUP;

typedef struct _LIBRARY LIBRARY;
typedef struct _TRANSPORT TRANSPORT;
typedef struct _PICKER PICKER;
typedef struct _SLOT SLOT;
typedef struct _DRIVE DRIVE;

typedef struct _MEDIA_POOL MEDIA_POOL;
typedef struct _PHYSICAL_MEDIA PHYSICAL_MEDIA;
typedef struct _MEDIA_PARTITION MEDIA_PARTITION;

typedef struct _OPERATOR_REQUEST OPERATOR_REQUEST;
typedef struct _MEDIA_TYPE_OBJECT MEDIA_TYPE_OBJECT;
    
typedef struct _OBJECT_HEADER OBJECT_HEADER;


/*
 *  RSM Object Types
 *
 *      The media hierarchy is as follows:
 *      ------------------------------
 *
 *      Library
 *          Media Pool
 *              Media Sub-Pool - a subset (child pool) of a media pool
 *                  ...
 *
 *                  Physical Media 
 *                      - a connected set of partitions that have to move together
 *                        e.g. a cartridge or both sides of a disk
 *
 *                      Media Partition
 *                          - e.g. a side of a disk or catridge tape
 *
 *
 *      Other library elements:
 *      --------------------
 *
 *          Drives - for reading/writing data on media
 *
 *          Slots - for passively storing media
 *
 *          Changers - for moving media between and amongst slots and drives. 
 *                     A changer consists of a moving transport with 
 *                     one or more pickers.
 *                      
 *      
 *          Logical media ID - a persistent GUID which identifies a media partition.
 *
 *          Media type object - represents a recognized media type
 *
 */
enum objectType {
                    OBJECTTYPE_NONE = 0,

                    OBJECTTYPE_LIBRARY,
                    OBJECTTYPE_MEDIAPOOL,
                    OBJECTTYPE_PHYSICALMEDIA,
                    OBJECTTYPE_MEDIAPARTITION,

                    OBJECTTYPE_DRIVE,
                    OBJECTTYPE_SLOT,
                    OBJECTTYPE_TRANSPORT,
                    OBJECTTYPE_PICKER,

                    OBJECTTYPE_MEDIATYPEOBJECT,
                    
                    // OBJECTTYPE_OPERATORREQUEST, // BUGBUG - keep in session queue
};


/*
 *  This is a common header for all RSM objects that have GUIDs.
 *  It is used to sort guid-identified objects in our hash table.
 */
struct _OBJECT_HEADER {
                    LIST_ENTRY hashListEntry;
                    enum objectType objType;
                    NTMS_GUID guid;
                    
                    ULONG refCount;
                    BOOL isDeleted;
};


enum libraryTypes {
                    LIBTYPE_NONE = 0,

                    LIBTYPE_UNKNOWN,
                    
                    LIBTYPE_STANDALONE,
                    LIBTYPE_AUTOMATED,
};

enum libraryStates {

                    LIBSTATE_NONE = 0,

                    LIBSTATE_INITIALIZING,
                    LIBSTATE_ONLINE,
                    LIBSTATE_OFFLINE,

                    LIBSTATE_ERROR,
};


struct _LIBRARY {
                    OBJECT_HEADER objHeader;

                    enum libraryStates state;

                    enum libraryTypes type;
                    
                    LIST_ENTRY allLibrariesListEntry;   // entry in g_allLibrariesList

                    ULONG numMediaPools;
                    LIST_ENTRY mediaPoolsList;

                    ULONG numDrives;
                    DRIVE *drives;

                    ULONG numSlots;
                    SLOT *slots;

                    /*
                     *  One (and only one) slot may be designated as a cleaner
                     *  slot.  That slot may receive a cleaner cartridge (via InjectNtmsCleaner).
                     *  A cleaner cartridge has a limited number of cleans that it is good for.
                     */
                    #define NO_SLOT_INDEX (ULONG)(-1)
                    ULONG cleanerSlotIndex; // index of cleaner slot or -1.
                    ULONG numCleansLeftInCartridge;
                    
                    ULONG numTransports;
                    TRANSPORT *transports;

                    ULONG numTotalWorkItems;
                    LIST_ENTRY freeWorkItemsList;
                    LIST_ENTRY pendingWorkItemsList;
                    LIST_ENTRY completeWorkItemsList;

                    HANDLE somethingToDoEvent;

                    /*
                     *  There is one thread per library.  This is its handle.
                     */
                    HANDLE hThread;

                    CRITICAL_SECTION lock;
};


enum mediaPoolTypes {

                    MEDIAPOOLTYPE_NONE = 0, 

                    /*
                     *  These are the 3 standard pool types.
                     */
                    MEDIAPOOLTYPE_FREE,
                    MEDIAPOOLTYPE_IMPORT,
                    MEDIAPOOLTYPE_UNRECOGNIZED,
                    
                    MEDIAPOOLTYPE_OTHER,
                    
};


struct _MEDIA_POOL {
                    OBJECT_HEADER objHeader;

                    /*
                     *  Entry in library's mediaPoolsList or
                     *  parent pool's childPoolsList.
                     */
                    LIST_ENTRY mediaPoolsListEntry;  

                    LIBRARY *owningLibrary;

                    /*
                     *  A media pool has a (default?) media type.
                     */
                    MEDIA_TYPE_OBJECT *mediaTypeObj;

                    /*
                     *  Media pools can be divided heirarchically into sub-pools.
                     *  If a pool is top-level, its parentPool pointer is NULL.
                     */
                    MEDIA_POOL *parentPool;
                    ULONG numChildPools;
                    LIST_ENTRY childPoolsList;

                    ULONG numPhysMedia;
                    LIST_ENTRY physMediaList;

                    HANDLE newMediaEvent;

                    WCHAR name[NTMS_OBJECTNAME_LENGTH];
                    
                    CRITICAL_SECTION lock;
};




// BUGBUG - should this be in physical media or mediaTypeObj ?
enum physicalMediaTypes {
                    PHYSICALMEDIATYPE_NONE = 0,

                    PHYSICALMEDIATYPE_SINGLEPARTITION, // e.g. 1 disk,tape
                    PHYSICALMEDIATYPE_CARTRIDGE,
};

enum physicalMediaStates {
                    PHYSICALMEDIASTATE_NONE = 0,

                    PHYSICALMEDIASTATE_INITIALIZING,
                    PHYSICALMEDIASTATE_AVAILABLE,   // i.e. in a slot
                    PHYSICALMEDIASTATE_INUSE,       // i.e. in a drive
                    PHYSICALMEDIASTATE_RESERVED,
};

struct _PHYSICAL_MEDIA {
                    OBJECT_HEADER objHeader;

                    LIST_ENTRY physMediaListEntry;  // entry in pool partition's physMediaList
                    
                    enum physicalMediaStates state;


                    /*
                     *  Pointer to application-defined media type object.
                     */
                    MEDIA_TYPE_OBJECT *mediaTypeObj;
                    
                    MEDIA_POOL *owningMediaPool;

                    SLOT *currentSlot;
                    DRIVE *currentDrive;

                    ULONG numPartitions;
                    MEDIA_PARTITION *partitions;

                    /*
                     *  The owning session of a physicalMedia also holds
                     *  the exclusive right to allocate partitions on it.
                     */
                    SESSION *owningSession;
                    ULONG numPartitionsOwnedBySession;
                    
                    HANDLE mediaFreeEvent;
                    
                    CRITICAL_SECTION lock;
};


enum mediaPartitionTypes {
                    MEDIAPARTITIONTYPE_NONE = 0,

                    /*
                     *  Major types
                     */
                    MEDIAPARTITIONTYPE_TAPE,
                    MEDIAPARTITIONTYPE_DISK,

                    /*
                     *  Subtypes
                     */
                    // BUGBUG FINISH
};


enum mediaPartitionStates {

                    MEDIAPARTITIONSTATE_NONE = 0,

                    MEDIAPARTITIONSTATE_AVAILABLE,
                    MEDIAPARTITIONSTATE_ALLOCATED,
                    MEDIAPARTITIONSTATE_MOUNTED,
                    MEDIAPARTITIONSTATE_INUSE,
                    MEDIAPARTITIONSTATE_DECOMMISSIONED,
};


struct _MEDIA_PARTITION {
                    OBJECT_HEADER objHeader;

                    enum mediaPartitionTypes type;
                    enum mediaPartitionTypes subType;

                    enum mediaPartitionStates state;

                    /*
                     *  When a media partition is 'complete', 
                     *  it is no longer writeable.
                     */
                    BOOLEAN isComplete;

                    /*
                     *  Can the owning physical medium be moved
                     *  into a new media pool ?
                     */
                    BOOLEAN allowImport;    

                    
                    PHYSICAL_MEDIA *owningPhysicalMedia;

                    /*
                     *  The logical media id is the persistent identifier
                     *  of a media partition that apps use to find it.
                     */
                    GUID logicalMediaGuid;

                    SESSION *owningSession;
};





enum driveStates {
                    DRIVESTATE_NONE = 0,

                    DRIVESTATE_INITIALIZING,
                    DRIVESTATE_AVAILABLE,
                    DRIVESTATE_INUSE,
                    DRIVESTATE_RESERVED,
};


struct _DRIVE {
                    OBJECT_HEADER objHeader;

                    enum driveStates state;        
                    ULONG driveIndex;     // index into library's drives array

                    PHYSICAL_MEDIA *insertedMedia;

                    WCHAR path[MAX_PATH+1];

                    LIBRARY *lib;
};


enum slotStates {

                    SLOTSTATE_NONE = 0,

                    SLOTSTATE_EMPTY,
                    SLOTSTATE_OCCUPIED,
};

struct _SLOT {
                    OBJECT_HEADER objHeader;

                    enum slotStates state;
                    UINT slotIndex;         // index into library's slots array

                    PHYSICAL_MEDIA *insertedMedia;

                    /*
                     *  Is this the unique slot designated to hold the
                     *  library's cleaner cartridge ?
                     */
                    BOOLEAN isCleanerSlot;
                    
                    GUID slotId;

                    LIBRARY *lib;
};


enum transportStates {

                    TRANSPORTSTATE_NONE = 0,

                    TRANSPORTSTATE_AVAILABLE,
                    TRANSPORTSTATE_INUSE,

};

struct _TRANSPORT {
                    OBJECT_HEADER objHeader;
    
                    enum transportStates state;
                    ULONG transportIndex;     // index into library's transports array

                    ULONG numPickers;
                    PICKER *pickers;

                    LIBRARY *lib;
};

struct _PICKER {
                    OBJECT_HEADER objHeader;

                    TRANSPORT *owningTransport;
};


struct _SESSION {
                    #define SESSION_SIG 'SmsR'
                    ULONG sig;

                    LIST_ENTRY allSessionsListEntry;   // entry in g_allSessionsList

                    LIST_ENTRY operatorRequestList; 

                   
                    CRITICAL_SECTION lock;
                    
                    WCHAR serverName[NTMS_COMPUTERNAME_LENGTH];
                    WCHAR applicationName[NTMS_APPLICATIONNAME_LENGTH];
                    WCHAR clientName[NTMS_COMPUTERNAME_LENGTH];
                    WCHAR userName[NTMS_USERNAME_LENGTH];
};


struct _MEDIA_TYPE_OBJECT {
                    OBJECT_HEADER objHeader;

                    LIBRARY *lib;
                    
                    /*
                     *  The number of physical media pointing to this type
                     *  as their media type.
                     */
                    ULONG numPhysMediaReferences;

                    // BUGBUG FINISH - media type characteristics

                    CRITICAL_SECTION lock;
};

enum workItemStates {
                    WORKITEMSTATE_NONE,

                    /*
                     *  WorkItem is in one of the library queues:
                     *  free, pending, or complete.
                     */
                    WORKITEMSTATE_FREE,
                    WORKITEMSTATE_PENDING,
                    WORKITEMSTATE_COMPLETE,
            
                    /*
                     *  WorkItem is not in any library queue.
                     *  It is in transit or being staged in a workGroup.
                     */
                    WORKITEMSTATE_STAGING,
};

struct _WORKITEM {    
                    enum workItemStates state;

                    LIST_ENTRY libListEntry;   // entry in one of a libraries workItem lists
                    LIST_ENTRY workGroupListEntry;  // entry in work group workItemList
                    
                    LIBRARY *owningLib;

                    /*
                     *  The current work group with which this 
                     *  work item is associated.
                     */
                    WORKGROUP *workGroup;
                    
                    // BUGBUG - ok to have a handle for each event ?
                    HANDLE workItemCompleteEvent;

                    /*
                     *  Fields describing the workItem's current operation.
                     */
                    struct { 

                        ULONG opcode;
                        ULONG options;

                        HRESULT resultStatus;

                        DRIVE *drive;
                        PHYSICAL_MEDIA *physMedia;
                        MEDIA_PARTITION *mediaPartition;

                        ULONG lParam;
                        NTMS_GUID guidArg;  // in/out guid used by some ops
                        PVOID buf;
                        ULONG bufLen;
                        
                        SYSTEMTIME timeQueued;
                        SYSTEMTIME timeCompleted;

                        /*
                         *  Request identifier, used to cancel a pending workItem.
                         */
                        NTMS_GUID requestGuid;

                        //
                        // BUGBUG - unscrubbed fields from NtmsDbWorkItem 
                        //          clean this up.
                        //
                        // NtmsDbGuid m_PartitionId; 
                        // NtmsDbGuid m_AssocWorkItem;
                        // short m_protected;
                        // unsigned long m_Priority;

                    } currentOp;
};


/*
 *  A WORKGROUP is a collection of WORKITEMs, 
 *  not necessarily all on the same library.
 */
struct _WORKGROUP {

                LIST_ENTRY  workItemsList;

                ULONG numTotalWorkItems;
                ULONG numPendingWorkItems;

                HANDLE allWorkItemsCompleteEvent;

                HRESULT resultStatus;
                
                CRITICAL_SECTION lock;
};


struct _OPERATOR_REQUEST {

                        LIST_ENTRY sessionOpReqsListEntry;    // entry in session's operatorRequestList

                        SESSION *invokingSession;

                        ULONG numWaitingThreads;    // num threads waiting for completion

                        // BUGBUG - I don't think we need an op request thread
                        HANDLE hThread; // thread spawned for op request

                        enum NtmsOpreqCommand opRequestCommand;
                        enum NtmsOpreqState state;
                        NTMS_GUID arg1Guid;
                        NTMS_GUID arg2Guid;

                        WCHAR appMessage[NTMS_MESSAGE_LENGTH];
                        WCHAR rsmMessage[NTMS_MESSAGE_LENGTH];
                        // NOTIFYICONDATA notifyData; // BUGBUG - use this in RSM Monitor app ?

                        NTMS_GUID opReqGuid;


                        SYSTEMTIME timeSubmitted;
                        HANDLE completedEvent;
};


/*
 *  The number of free workItems with which we initialize a library.
 */
#define MIN_LIBRARY_WORKITEMS   0

/*
 *  The maximum total number of workItems that we allow in a library pool.
 *  We will allocate new workItems as needed up to this number.
 */
#define MAX_LIBRARY_WORKITEMS   10000       // BUGBUG ?



/*
 *  List macros -- not defined in winnt.h for some reason.
 */
#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))
#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))
#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}
#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}
#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }
#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }
#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }


#define MIN(a, b)   ((a) < (b) ? (a) : (b))
#define MAX(a, b)   ((a) > (b) ? (a) : (b))

/*
 *  Internal function prototypes
 */
BOOLEAN RSMServiceGlobalInit();
VOID RSMServiceGlobalShutdown();
DWORD RSMServiceHandler(IN DWORD dwOpcode, IN DWORD dwEventType, IN PVOID pEventData, IN PVOID pData);
BOOL InitializeRSMService();
VOID ShutdownRSMService();
VOID RSMServiceLoop();
VOID StartLibraryManager();
LIBRARY *NewRSMLibrary(ULONG numDrives, ULONG numSlots, ULONG numTransports);
VOID FreeRSMLibrary(LIBRARY *lib);
LIBRARY *FindLibrary(LPNTMS_GUID libId);
SLOT *FindLibrarySlot(LIBRARY *lib, LPNTMS_GUID slotId);
BOOL ValidateSessionHandle(HANDLE hSession);
BOOL ValidateWStr(LPCWSTR str);
BOOL ValidateAStr(LPCSTR s);
BOOL ValidateBuffer(PVOID buf, ULONG len);
WORKITEM *NewWorkItem(LIBRARY *lib);
VOID FreeWorkItem(WORKITEM *workItem);
VOID EnqueueFreeWorkItem(LIBRARY *lib, WORKITEM *workItem);
WORKITEM *DequeueFreeWorkItem(LIBRARY *lib, BOOL allocOrYieldIfNeeded);
VOID EnqueuePendingWorkItem(LIBRARY *lib, WORKITEM *workItem);
WORKITEM *DequeuePendingWorkItem(LIBRARY *lib, WORKITEM *specificWorkItem);
WORKITEM *DequeuePendingWorkItemByGuid(LIBRARY *lib, LPNTMS_GUID lpRequestId);
VOID EnqueueCompleteWorkItem(LIBRARY *lib, WORKITEM *workItem);
WORKITEM *DequeueCompleteWorkItem(LIBRARY *lib, WORKITEM *specificWorkItem);
BOOL StartLibrary(LIBRARY *lib);
VOID HaltLibrary(LIBRARY *lib);
DWORD __stdcall LibraryThread(void *context);
VOID Library_DoWork(LIBRARY *lib);
OPERATOR_REQUEST *NewOperatorRequest(DWORD dwRequest, LPCWSTR lpMessage, LPNTMS_GUID lpArg1Id, LPNTMS_GUID lpArg2Id);
VOID FreeOperatorRequest(OPERATOR_REQUEST *opReq);
BOOL EnqueueOperatorRequest(SESSION *thisSession, OPERATOR_REQUEST *opReq);
OPERATOR_REQUEST *DequeueOperatorRequest(SESSION *thisSession, OPERATOR_REQUEST *specificOpReq, LPNTMS_GUID specificOpReqGuid);
OPERATOR_REQUEST *FindOperatorRequest(SESSION *thisSession, LPNTMS_GUID opReqGuid);
HRESULT CompleteOperatorRequest(SESSION *thisSession, LPNTMS_GUID lpRequestId, enum NtmsOpreqState completeState);
DWORD __stdcall OperatorRequestThread(void *context);
SESSION *NewSession(LPCWSTR lpServer, LPCWSTR lpApplication, LPCWSTR lpClientName, LPCWSTR lpUserName);
VOID FreeSession(SESSION *thisSession);
ULONG WStrNCpy(WCHAR *dest, const WCHAR *src, ULONG maxWChars);
ULONG AsciiToWChar(WCHAR *dest, const char *src, ULONG maxChars);
ULONG WCharToAscii(char *dest, WCHAR *src, ULONG maxChars);
BOOL WStringsEqualN(PWCHAR s, PWCHAR p, BOOL caseSensitive, ULONG maxLen);
VOID ConvertObjectInfoAToWChar(LPNTMS_OBJECTINFORMATIONW wObjInfo, LPNTMS_OBJECTINFORMATIONA aObjInfo);
VOID InitGuidHash();
VOID InsertObjectInGuidHash(OBJECT_HEADER *obj);
VOID RemoveObjectFromGuidHash(OBJECT_HEADER *obj);
OBJECT_HEADER *FindObjectInGuidHash(NTMS_GUID *guid);
MEDIA_POOL *NewMediaPool(LPCWSTR name, LPNTMS_GUID mediaType, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
MEDIA_POOL *FindMediaPool(LPNTMS_GUID mediaPoolId);
MEDIA_POOL *FindMediaPoolByName(PWSTR poolName);
PHYSICAL_MEDIA *FindPhysicalMedia(LPNTMS_GUID physMediaId);
VOID RefObject(PVOID objectPtr);
VOID DerefObject(PVOID objectPtr);
PHYSICAL_MEDIA *NewPhysicalMedia();
HRESULT AllocatePhysicalMediaExclusive(SESSION *thisSession, PHYSICAL_MEDIA *physMedia, LPNTMS_GUID lpPartitionId, DWORD dwTimeoutMsec);
HRESULT AllocateNextPartitionOnExclusiveMedia(SESSION *thisSession, PHYSICAL_MEDIA *physMedia, MEDIA_PARTITION **ppNextPartition);
HRESULT AllocateMediaFromPool(SESSION *thisSession, MEDIA_POOL *mediaPool, DWORD dwTimeoutMsec, PHYSICAL_MEDIA **ppPhysMedia, BOOL opReqIfNeeded);
MEDIA_PARTITION *FindMediaPartition(LPNTMS_GUID lpLogicalMediaId);
HRESULT ReleaseMediaPartition(SESSION *thisSession, MEDIA_PARTITION *thisMediaPartition);
MEDIA_POOL *FindMediaPoolByName(PWSTR poolName);
MEDIA_POOL *FindMediaPoolByNameInLibrary(LIBRARY *lib, PWSTR poolName);
HRESULT SetMediaPartitionState(MEDIA_PARTITION *mediaPart, enum mediaPartitionStates newState);
HRESULT SetMediaPartitionComplete(MEDIA_PARTITION *mediaPart);
HRESULT DeletePhysicalMedia(PHYSICAL_MEDIA *physMedia);
VOID InsertPhysicalMediaInPool(MEDIA_POOL *mediaPool, PHYSICAL_MEDIA *physMedia);
VOID RemovePhysicalMediaFromPool(PHYSICAL_MEDIA *physMedia);
HRESULT MovePhysicalMediaToPool(MEDIA_POOL *destMediaPool, PHYSICAL_MEDIA *physMedia, BOOLEAN setMediaTypeToPoolType);
BOOLEAN LockPhysicalMediaWithPool(PHYSICAL_MEDIA *physMedia);
VOID UnlockPhysicalMediaWithPool(PHYSICAL_MEDIA *physMedia);
BOOLEAN LockPhysicalMediaWithLibrary(PHYSICAL_MEDIA *physMedia);
VOID UnlockPhysicalMediaWithLibrary(PHYSICAL_MEDIA *physMedia);
HRESULT DeleteMediaPool(MEDIA_POOL *mediaPool);
MEDIA_TYPE_OBJECT *NewMediaTypeObject();
VOID DestroyMediaTypeObject(MEDIA_TYPE_OBJECT *mediaTypeObj);
MEDIA_TYPE_OBJECT *FindMediaTypeObject(LPNTMS_GUID lpMediaTypeId);
HRESULT DeleteMediaTypeObject(MEDIA_TYPE_OBJECT *mediaTypeObj);
VOID SetMediaType(PHYSICAL_MEDIA *physMedia, MEDIA_TYPE_OBJECT *mediaTypeObj);
WORKGROUP *NewWorkGroup();
VOID FreeWorkGroup(WORKGROUP *workGroup);
VOID FlushWorkGroup(WORKGROUP *workGroup);
VOID FlushWorkItem(WORKITEM *workItem);
HRESULT BuildMountWorkGroup(WORKGROUP *workGroup, LPNTMS_GUID lpMediaOrPartitionIds, LPNTMS_GUID lpDriveIds, DWORD dwCount, DWORD dwOptions, DWORD dwPriority);
VOID BuildSingleMountWorkItem(WORKITEM *workItem, DRIVE *drive OPTIONAL, OBJECT_HEADER *mediaOrPartObj, ULONG dwOptions, int dwPriority);
HRESULT BuildDismountWorkGroup(WORKGROUP *workGroup, LPNTMS_GUID lpMediaOrPartitionIds, DWORD dwCount, DWORD dwOptions);
VOID BuildSingleDismountWorkItem(WORKITEM *workItem, OBJECT_HEADER *mediaOrPartObj, DWORD dwOptions);
HRESULT ScheduleWorkGroup(WORKGROUP *workGroup);
DRIVE *NewDrive(LIBRARY *lib, PWCHAR path);
VOID FreeDrive(DRIVE *drive);
DRIVE *FindDrive(LPNTMS_GUID driveId);
VOID BuildEjectWorkItem(WORKITEM *workItem, PHYSICAL_MEDIA *physMedia, LPNTMS_GUID lpEjectOperation, ULONG dwAction);
VOID BuildInjectWorkItem(WORKITEM *workItem, LPNTMS_GUID lpInjectOperation, ULONG dwAction);
HRESULT StopCleanerInjection(LIBRARY *lib, LPNTMS_GUID lpInjectOperation);
HRESULT StopCleanerEjection(LIBRARY *lib, LPNTMS_GUID lpEjectOperation);
HRESULT DeleteLibrary(LIBRARY *lib);
HRESULT DeleteDrive(DRIVE *drive);
BOOL ServiceOneWorkItem(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceRemove(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceDisableChanger(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceDisableLibrary(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceEnableChanger(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceEnableLibrary(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceDisableDrive(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceEnableDrive(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceDisableMedia(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceEnableMedia(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceUpdateOmid(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceInventory(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceDoorAccess(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceEject(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceEjectCleaner(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceInject(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceInjectCleaner(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceProcessOmid(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceCleanDrive(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceDismount(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceMount(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceWriteScratch(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceClassify(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceReserveCleaner(LIBRARY *lib, WORKITEM *workItem);
BOOL ServiceReleaseCleaner(LIBRARY *lib, WORKITEM *workItem);

/*
 *  Externs for internal global data.
 */
extern CRITICAL_SECTION g_globalServiceLock;
extern LIST_ENTRY g_allLibrariesList;
extern LIST_ENTRY g_allSessionsList;
extern HANDLE g_terminateServiceEvent;
extern HINSTANCE g_hInstance;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\libmgr.c ===
/*
 *  LIBMGR.C
 *
 *      RSM Service :  Library Manager 
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


VOID StartLibraryManager()
{
    // LmInitConfigNewDevices();    


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\globals.c ===
/*
 *  GLOBALS.C
 *
 *      Global data for RSM Service 
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


CRITICAL_SECTION g_globalServiceLock;
LIST_ENTRY g_allLibrariesList;
LIST_ENTRY g_allSessionsList;
HANDLE g_terminateServiceEvent = NULL;
HINSTANCE g_hInstance = NULL;



BOOLEAN RSMServiceGlobalInit()
{
    BOOLEAN result = FALSE;

    InitializeCriticalSection(&g_globalServiceLock);

    InitializeListHead(&g_allLibrariesList);
    InitializeListHead(&g_allSessionsList);

    g_terminateServiceEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (g_terminateServiceEvent){
        result = TRUE;
    }

    ASSERT(result);
    return result;
}


VOID RSMServiceGlobalShutdown()
{
    /*
     *  This may be called on a failed startup,
     *  so check each handle before freeing.
     */

    if (g_terminateServiceEvent){
        CloseHandle(g_terminateServiceEvent);
        g_terminateServiceEvent = NULL;
    }

    DeleteCriticalSection(&g_globalServiceLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\drive.c ===
/*
 *  DRIVES.C
 *
 *      RSM Service :  Drives
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


DRIVE *NewDrive(LIBRARY *lib, PWCHAR path)
{
    DRIVE *drive;

    drive = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(DRIVE));
    if (drive){
        drive->lib = lib;
        WStrNCpy(drive->path, path, MAX_PATH);

        drive->objHeader.objType = OBJECTTYPE_DRIVE;
        drive->objHeader.refCount = 1;   
    }

    ASSERT(drive);
    return drive;
}


VOID FreeDrive(DRIVE *drive)
{
    GlobalFree(drive);
}


DRIVE *FindDrive(LPNTMS_GUID driveId)
{
    DRIVE *drive = NULL;

    if (driveId){
        OBJECT_HEADER *objHdr;
        
        objHdr = FindObjectInGuidHash(driveId);
        if (objHdr){
            if (objHdr->objType == OBJECTTYPE_DRIVE){
                drive = (DRIVE *)objHdr;
            }
            else {
                DerefObject(objHdr);
            }
        }
    }
    
    return drive;
}


HRESULT DeleteDrive(DRIVE *drive)
{
    HRESULT result;

    // BUGBUG FINISH
    ASSERT(0);
    result = ERROR_CALL_NOT_IMPLEMENTED;

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\library.c ===
/*
 *  LIBRARY.C
 *
 *      RSM Service :  Library management
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


LIBRARY *NewRSMLibrary(ULONG numDrives, ULONG numSlots, ULONG numTransports)
{
    LIBRARY *lib;

    lib = (LIBRARY *)GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(LIBRARY));
    if (lib){
        BOOL success = FALSE;

        lib->state = LIBSTATE_INITIALIZING;

        InitializeCriticalSection(&lib->lock);

        InitializeListHead(&lib->allLibrariesListEntry);
        InitializeListHead(&lib->mediaPoolsList);
        InitializeListHead(&lib->freeWorkItemsList);
        InitializeListHead(&lib->pendingWorkItemsList);
        InitializeListHead(&lib->completeWorkItemsList);
        
        /*
         *  Enqueue the new library
         */
        EnterCriticalSection(&g_globalServiceLock);
        InsertTailList(&g_allLibrariesList, &lib->allLibrariesListEntry);
        LeaveCriticalSection(&g_globalServiceLock);


        lib->somethingToDoEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        /*
         *  Allocate arrays for drives, slots, and transports.
         *  If the library has zero of any of these,
         *  go ahead and allocate a zero-length array for consistency.
         */
        lib->drives = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, numDrives*sizeof(DRIVE));
        lib->slots = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, numSlots*sizeof(SLOT));
        lib->transports = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, numTransports*sizeof(TRANSPORT));
        
        if (lib->somethingToDoEvent && 
            lib->drives && lib->slots && lib->transports){

            lib->numDrives = numDrives;
            lib->numSlots = numSlots;
            lib->numTransports = numTransports;

            lib->objHeader.objType = OBJECTTYPE_LIBRARY;
            lib->objHeader.refCount = 1;
            
            success = TRUE;
        }
        else {
            ASSERT(0);
        }

        if (!success){
            FreeRSMLibrary(lib);
            lib = NULL;
        }
    }
    else {
        ASSERT(lib);
    }

    return lib;
}


VOID FreeRSMLibrary(LIBRARY *lib)
{
    WORKITEM *workItem;
    LIST_ENTRY *listEntry;

    ASSERT(lib->state == LIBSTATE_HALTED);
 
    /*
     *  Dequeue library
     */
    EnterCriticalSection(&g_globalServiceLock);
    ASSERT(!IsEmptyList(&lib->allLibrariesListEntry));
    ASSERT(!IsEmptyList(&g_allLibrariesList));
    RemoveEntryList(&lib->allLibrariesListEntry);
    InitializeListHead(&lib->allLibrariesListEntry);
    LeaveCriticalSection(&g_globalServiceLock);

    /*
     *  Free all the workItems
     */
    while (workItem = DequeueCompleteWorkItem(lib, NULL)){
        DBGERR(("there shouldn't be any completed workItems left"));
        FreeWorkItem(workItem);
    }
    while (workItem = DequeuePendingWorkItem(lib, NULL)){
        DBGERR(("there shouldn't be any pending workItems left"));
        FreeWorkItem(workItem);
    }
    while (workItem = DequeueFreeWorkItem(lib, FALSE)){
        FreeWorkItem(workItem);
    }
    ASSERT(lib->numTotalWorkItems == 0);    

    /*
     *  Free other internal resources.  
     *  Note that this is also called from a failed NewRSMLibrary() call,
     *  so check each resource before freeing.
     */
    if (lib->somethingToDoEvent) CloseHandle(lib->somethingToDoEvent);
    if (lib->drives) GlobalFree(lib->drives);
    if (lib->slots) GlobalFree(lib->slots);
    if (lib->transports) GlobalFree(lib->transports);

    DeleteCriticalSection(&lib->lock);

    GlobalFree(lib);
}


LIBRARY *FindLibrary(LPNTMS_GUID libId)
{
    LIBRARY *lib = NULL;

    if (libId){
        OBJECT_HEADER *objHdr;
        
        objHdr = FindObjectInGuidHash(libId);
        if (objHdr){
            if (objHdr->objType == OBJECTTYPE_LIBRARY){
                lib = (LIBRARY *)objHdr;
            }
            else {
                DerefObject(objHdr);
            }
        }
    }
    
    return lib;
}


BOOL StartLibrary(LIBRARY *lib)
{
    DWORD threadId;
    BOOL result;

    lib->hThread = CreateThread(NULL, 0, LibraryThread, lib, 0, &threadId);
    if (lib->hThread){

        result = TRUE;
    }
    else {
        ASSERT(lib->hThread);
        lib->state = LIBSTATE_ERROR;
        result = FALSE;
    }

    ASSERT(result);
    return result;
}


/*
 *  HaltLibrary
 *
 *      Take a library offline.
 */
VOID HaltLibrary(LIBRARY *lib)
{
    
    // BUGBUG - deal with multiple threads trying to halt at the same time
    //          (e.g. can't use PulseEvent)

    EnterCriticalSection(&lib->lock);
    lib->state = LIBSTATE_OFFLINE;
    PulseEvent(lib->somethingToDoEvent);
    LeaveCriticalSection(&lib->lock);

    /*
     *  The library thread may be doing some work.
     *  Wait here until it has exited its loop.
     *  (a thread handle gets signalled when the thread terminates).
     */
    WaitForSingleObject(lib->hThread, INFINITE);
    CloseHandle(lib->hThread);
}


DWORD __stdcall LibraryThread(void *context)
{
    LIBRARY *lib = (LIBRARY *)context;
    enum libraryStates libState;

    ASSERT(lib);

    EnterCriticalSection(&lib->lock);
    ASSERT((lib->state == LIBSTATE_INITIALIZING) || (lib->state == LIBSTATE_OFFLINE));
    libState = lib->state = LIBSTATE_ONLINE;
    LeaveCriticalSection(&lib->lock);

    while (libState == LIBSTATE_ONLINE){

        Library_DoWork(lib);

        EnterCriticalSection(&lib->lock);
        libState = lib->state;
        LeaveCriticalSection(&lib->lock);

        WaitForSingleObject(lib->somethingToDoEvent, INFINITE);
        
    } 

    ASSERT(libState == LIBSTATE_OFFLINE);

    return NO_ERROR;
}


VOID Library_DoWork(LIBRARY *lib)
{
    WORKITEM *workItem;

    while (workItem = DequeuePendingWorkItem(lib, NULL)){
        BOOL complete;

        /*
         *  Service the work item.  
         *  The workItem is 'complete' if we are done with it,
         *  regardless of whether or not there was an error.
         */
        complete = ServiceOneWorkItem(lib, workItem);
        if (complete){
            /*
             *  All done.  
             *  Put the workItem in the complete queue and signal
             *  the originating thread.
             */
            EnqueueCompleteWorkItem(lib, workItem);
        }
    }
}


HRESULT DeleteLibrary(LIBRARY *lib)
{
    HRESULT result;
    
    EnterCriticalSection(&lib->lock);

    /*
     *  Take the library offline.
     */
    lib->state = LIBSTATE_OFFLINE;   

    // BUGBUG FINISH - move any media to the offline library

    // BUGBUG FINISH - delete all media pools, etc.

    // BUGBUG FINISH - wait for all workItems, opReqs, etc to complete

    ASSERT(0);
    result = ERROR_CALL_NOT_IMPLEMENTED; // BUGBUG ?
    
    /*
     *  Mark the library as deleted.  
     *  This will cause it not to get any new references.
     */
    ASSERT(!lib->objHeader.isDeleted);
    lib->objHeader.isDeleted = TRUE;
    
    /*
     *  This dereference will cause the library's refcount to eventually go
     *  to zero, upon which it will get deleted.  We can still use our pointer
     *  though because the caller added a refcount to get his lib pointer.
     */
    DerefObject(lib);
    
    LeaveCriticalSection(&lib->lock);


    return result;
}


SLOT *FindLibrarySlot(LIBRARY *lib, LPNTMS_GUID slotId)
{
    SLOT *slot = NULL;

    if (slotId){
        ULONG i;

        EnterCriticalSection(&lib->lock);
        
        for (i = 0; i < lib->numSlots; i++){
            SLOT *thisSlot = &lib->slots[i];
            if (RtlEqualMemory(&thisSlot->objHeader.guid, slotId, sizeof(NTMS_GUID))){
                /*
                 *  Found the slot.  Reference it since we're returning a pointer to it.
                 */
                ASSERT(thisSlot->slotIndex == i);
                slot = thisSlot;
                RefObject(slot);
                break;
            }
        }

        LeaveCriticalSection(&lib->lock);
    }
    
    return slot;
}


HRESULT StopCleanerInjection(LIBRARY *lib, LPNTMS_GUID lpInjectOperation)
{
    HRESULT result;

    // BUGBUG FINISH
    ASSERT(0);
    result = ERROR_CALL_NOT_IMPLEMENTED;
    
    return result;
}


HRESULT StopCleanerEjection(LIBRARY *lib, LPNTMS_GUID lpEjectOperation)
{
    HRESULT result;

    // BUGBUG FINISH
    ASSERT(0);
    result = ERROR_CALL_NOT_IMPLEMENTED;
    
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\guidhash.c ===
/*
 *  GUIDHASH.C
 *
 *      RSM Service :  RSM Object Hash (by GUID)
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


/*
 *  Our HASH is indexed by a function on an object's GUID.
 *  There is a linked list at each hash table entry to resolve collisions.
 */
#define HASH_SIZE   256
#define HASH_FUNC(lpGuid) (UINT)(UCHAR)(*(PUCHAR)(lpGuid) + *((PUCHAR)(lpGuid)+sizeof(NTMS_GUID)-1))
LIST_ENTRY guidHashTable[HASH_SIZE];


VOID InitGuidHash()
{
     int i;

     for (i = 0; i < HASH_SIZE; i++){
        InitializeListHead(&guidHashTable[i]);
     }
}


VOID InsertObjectInGuidHash(OBJECT_HEADER *obj)
{
    UINT index = HASH_FUNC(&obj->guid);

    /*
     *  Unfortunately, have to use a global spinlock for the hash table.
     */
    EnterCriticalSection(&g_globalServiceLock);
    ASSERT(IsEmptyList(&obj->hashListEntry));
    ASSERT(!obj->isDeleted);
    InsertTailList(&guidHashTable[index], &obj->hashListEntry);
    LeaveCriticalSection(&g_globalServiceLock);
}


VOID RemoveObjectFromGuidHash(OBJECT_HEADER *obj)
{

    /*
     *  Unfortunately, have to use a global spinlock for the hash table.
     */
    EnterCriticalSection(&g_globalServiceLock);
    ASSERT(!IsEmptyList(&obj->hashListEntry));
    ASSERT(!IsEmptyList(&guidHashTable[HASH_FUNC(obj->guid)]));
    RemoveEntryList(&obj->hashListEntry);
    InitializeListHead(&obj->hashListEntry);
    LeaveCriticalSection(&g_globalServiceLock);
}


OBJECT_HEADER *FindObjectInGuidHash(NTMS_GUID *guid)
{
    UINT index = HASH_FUNC(guid);
    OBJECT_HEADER *foundObj = NULL;
    LIST_ENTRY *listEntry;

    /*
     *  Unfortunately, have to use a global spinlock for the hash table.
     */
    EnterCriticalSection(&g_globalServiceLock);
    listEntry = &guidHashTable[index];
    while ((listEntry = listEntry->Flink) != &guidHashTable[index]){
        OBJECT_HEADER *thisObj = CONTAINING_RECORD(listEntry, OBJECT_HEADER, hashListEntry);
        if (RtlEqualMemory(&thisObj->guid, guid, sizeof(NTMS_GUID))){
            if (!foundObj->isDeleted){
                foundObj = thisObj;
                RefObject(thisObj);
            }
            break;
        }
    }
    LeaveCriticalSection(&g_globalServiceLock);

    return foundObj;
}


/*
 *  RefObject
 *
 *      Add a reference to the object.
 *      An object's refCount is incremented when:
 *          1.  a pointer to it is returned from a guid hash lookup
 *                  or
 *          2.  its handle or GUID is returned to an RSM client app
 *
 */
VOID RefObject(PVOID objectPtr)
{
    OBJECT_HEADER *objHdr = (OBJECT_HEADER *)objectPtr;
    InterlockedIncrement(&objHdr->refCount);
}


VOID DerefObject(PVOID objectPtr)
{
    OBJECT_HEADER *objHdr = (OBJECT_HEADER *)objectPtr;
    LONG newRefCount;

    newRefCount = InterlockedDecrement(&objHdr->refCount);
    ASSERT(newRefCount >= 0);
    if (newRefCount == 0){
        ASSERT(objHdr->isDeleted);
        
        // BUGBUG FINISH
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\mediaprt.c ===
/*
 *  MEDIAPRT.C
 *
 *      RSM Service :  Media Partitions (i.e. "sides")
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"



MEDIA_PARTITION *FindMediaPartition(LPNTMS_GUID lpLogicalMediaId)
{
    MEDIA_PARTITION *foundMediaPartition = NULL;
    
    if (lpLogicalMediaId){
        OBJECT_HEADER *objHdr;
        
        objHdr = FindObjectInGuidHash(lpLogicalMediaId);
        if (objHdr){
            if (objHdr->objType == OBJECTTYPE_MEDIAPARTITION){
                foundMediaPartition = (MEDIA_PARTITION *)objHdr;
            }
            else {
                DerefObject(objHdr);
            }
        }

    }

    return foundMediaPartition;
}


HRESULT ReleaseMediaPartition(SESSION *thisSession, MEDIA_PARTITION *thisMediaPartition)
{
    PHYSICAL_MEDIA *physMedia = thisMediaPartition->owningPhysicalMedia;
    HRESULT result;
    
    EnterCriticalSection(&physMedia->lock);

    if (thisMediaPartition->owningSession == thisSession){
        thisMediaPartition->owningSession = NULL;
        if (physMedia->owningSession == thisSession){
            ASSERT(physMedia->numPartitionsOwnedBySession > 0);
            physMedia->numPartitionsOwnedBySession--;
            if (physMedia->numPartitionsOwnedBySession == 0){
                physMedia->owningSession = NULL;

                // BUGBUG FINISH - move to scratch pool ?
            }
        }
        else {
            ASSERT(!physMedia->owningSession);
        }
        result = ERROR_SUCCESS;
    }
    else {
        ASSERT(thisMediaPartition->owningSession == thisSession);
        result = ERROR_INVALID_MEDIA;
    }
    
    LeaveCriticalSection(&physMedia->lock);

    return result;
}


HRESULT SetMediaPartitionState( MEDIA_PARTITION *mediaPart,
                                    enum mediaPartitionStates newState)
{
    PHYSICAL_MEDIA *physMedia = mediaPart->owningPhysicalMedia;
    HRESULT result;
    
    EnterCriticalSection(&physMedia->lock);

    switch (newState){
        
        case MEDIAPARTITIONSTATE_AVAILABLE:
            // BUGBUG FINISH
            result = ERROR_CALL_NOT_IMPLEMENTED;
            break;

        case MEDIAPARTITIONSTATE_ALLOCATED:
            // BUGBUG FINISH
            result = ERROR_CALL_NOT_IMPLEMENTED;
            break;
            
        case MEDIAPARTITIONSTATE_MOUNTED:
            // BUGBUG FINISH
            result = ERROR_CALL_NOT_IMPLEMENTED;
            break;
            
        case MEDIAPARTITIONSTATE_INUSE:
            // BUGBUG FINISH
            result = ERROR_CALL_NOT_IMPLEMENTED;
            break;
            
        case MEDIAPARTITIONSTATE_DECOMMISSIONED:
            if (mediaPart->state == MEDIAPARTITIONSTATE_AVAILABLE){
                mediaPart->state = MEDIAPARTITIONSTATE_DECOMMISSIONED;
                result = ERROR_SUCCESS;
            }
            else {
                result = ERROR_INVALID_STATE;
            }
            break;
            
        default:
            DBGERR(("illegal state (%xh) in SetMediaPartitionState", newState));
            result = ERROR_INVALID_STATE;
            break;
    }

    LeaveCriticalSection(&physMedia->lock);

    return result;
}


HRESULT SetMediaPartitionComplete(MEDIA_PARTITION *mediaPart)
{
    PHYSICAL_MEDIA *physMedia = mediaPart->owningPhysicalMedia;
    HRESULT result;
    
    EnterCriticalSection(&physMedia->lock);

    switch (mediaPart->state){
        
        case MEDIAPARTITIONSTATE_ALLOCATED:
            if (mediaPart->isComplete){
                DBGWARN(("SetMediaPartitionComplete: media partition is already complete."));
            }
            else {
                mediaPart->isComplete = TRUE;
            }
            result = ERROR_SUCCESS;
            break;
            
        case MEDIAPARTITIONSTATE_AVAILABLE:
        case MEDIAPARTITIONSTATE_MOUNTED:
        case MEDIAPARTITIONSTATE_INUSE:
        case MEDIAPARTITIONSTATE_DECOMMISSIONED:
            result = ERROR_INVALID_STATE;
            break;
             
        default:
            DBGERR(("illegal state (%xh) in SetMediaPartitionComplete", mediaPart->state));
            result = ERROR_INVALID_STATE;
            break;
    }

    LeaveCriticalSection(&physMedia->lock);

    return result;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\mediatyp.c ===
/*
 *  MEDIATYP.C
 *
 *      RSM Service :  Media Type Objects
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


MEDIA_TYPE_OBJECT *NewMediaTypeObject(LIBRARY *lib)
{
    MEDIA_TYPE_OBJECT *mediaTypeObj;
    
    mediaTypeObj = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(MEDIA_TYPE_OBJECT));
    if (mediaTypeObj){
        mediaTypeObj->lib = lib;
        mediaTypeObj->numPhysMediaReferences = 0;
        InitializeCriticalSection(&mediaTypeObj->lock);
    }
    else {
        ASSERT(mediaTypeObj);
    }

    return mediaTypeObj;
}


VOID DestroyMediaTypeObject(MEDIA_TYPE_OBJECT *mediaTypeObj)
{
    // BUGBUG FINISH
    DeleteCriticalSection(&mediaTypeObj->lock);
    GlobalFree(mediaTypeObj);
}


MEDIA_TYPE_OBJECT *FindMediaTypeObject(LPNTMS_GUID lpMediaTypeId)
{
    MEDIA_TYPE_OBJECT *mediaTypeObj = NULL;

    if (lpMediaTypeId){
        OBJECT_HEADER *objHdr;
        
        objHdr = FindObjectInGuidHash(lpMediaTypeId);
        if (objHdr){
            if (objHdr->objType == OBJECTTYPE_MEDIATYPEOBJECT){
                mediaTypeObj = (MEDIA_TYPE_OBJECT *)objHdr;
            }
            else {
                DerefObject(objHdr);
            }
        }
    }
    
    return mediaTypeObj;
}


HRESULT DeleteMediaTypeObject(MEDIA_TYPE_OBJECT *mediaTypeObj)
{
    HRESULT result;

    EnterCriticalSection(&mediaTypeObj->lock);

    if (mediaTypeObj->numPhysMediaReferences == 0){
        /*
         *  Dereference the media type object.
         *  This will cause it to get deleted once its reference
         *  count goes to zero.  We can still use our pointer
         *  since the caller has a reference.
         */
        mediaTypeObj->objHeader.isDeleted = TRUE;
        DerefObject(mediaTypeObj);
        result = ERROR_SUCCESS;
    }
    else {
        /*
         *  There are physical media referencing this media type object
         *  as their type.  So we can't delete this type object.
         */
        result = ERROR_BUSY;
    }
    
    LeaveCriticalSection(&mediaTypeObj->lock);

    return result;
}


/*
 *  SetMediaType
 *
 *      Must be called with physical media lock held.
 *      MEDIA_TYPE_OBJECT lock should NOT be held as we may have
 *      to grab another MEDIA_TYPE_OBJECT's lock 
 *      (acquiring both simulataneously might lead to deadlock).
 */
VOID SetMediaType(PHYSICAL_MEDIA *physMedia, MEDIA_TYPE_OBJECT *mediaTypeObj)
{
    /*
     *  Remove the current type, if any.
     */
    if (physMedia->mediaTypeObj){
        EnterCriticalSection(&physMedia->mediaTypeObj->lock);
        
        ASSERT(physMedia->mediaTypeObj->numPhysMediaReferences > 0);
        physMedia->mediaTypeObj->numPhysMediaReferences--;

        /*
         *  Dereference both objects since they no longer point to each other.
         */
        DerefObject(physMedia);
        DerefObject(physMedia->mediaTypeObj);
        
        LeaveCriticalSection(&physMedia->mediaTypeObj->lock);
        
        physMedia->mediaTypeObj = NULL;
    }

    /*
     *  Now set the new media type.
     */
    EnterCriticalSection(&mediaTypeObj->lock);
    mediaTypeObj->numPhysMediaReferences++;
    physMedia->mediaTypeObj = mediaTypeObj;
    RefObject(physMedia);
    RefObject(mediaTypeObj);
    LeaveCriticalSection(&mediaTypeObj->lock);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\media.c ===
/*
 *  MEDIA.C
 *
 *      RSM Service :  Physical Media
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


PHYSICAL_MEDIA *NewPhysicalMedia()
{
    PHYSICAL_MEDIA *physMedia;

    physMedia = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(PHYSICAL_MEDIA));
    if (physMedia){
        physMedia->mediaFreeEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (physMedia->mediaFreeEvent){
            InitializeCriticalSection(&physMedia->lock);
            InitializeListHead(&physMedia->physMediaListEntry);

            physMedia->objHeader.objType = OBJECTTYPE_PHYSICALMEDIA;
            physMedia->objHeader.refCount = 1;
            
            // BUGBUG FINISH
        }
        else {
            GlobalFree(physMedia);
            physMedia = NULL;
        }
    }

    ASSERT(physMedia);
    return physMedia;
}


VOID DestroyPhysicalMedia(PHYSICAL_MEDIA *physMedia)
{
        // BUGBUG FINISH

    CloseHandle(physMedia->mediaFreeEvent);    
    DeleteCriticalSection(&physMedia->lock);

    GlobalFree(physMedia);
}


PHYSICAL_MEDIA *FindPhysicalMedia(LPNTMS_GUID physMediaId)
{
    PHYSICAL_MEDIA *foundPhysMedia = NULL;

    if (physMediaId){
        OBJECT_HEADER *objHdr;
        
        objHdr = FindObjectInGuidHash(physMediaId);
        if (objHdr){
            if (objHdr->objType == OBJECTTYPE_PHYSICALMEDIA){
                foundPhysMedia = (PHYSICAL_MEDIA *)objHdr;
            }
            else {
                DerefObject(objHdr);
            }
        }
    }
    
    return foundPhysMedia;
}


/*
 *  AllocatePhysicalMediaExclusive
 *
 *      Allocate a partition on the specified physicalMedia with an exclusive
 *      hold on the other partitions.
 */
HRESULT AllocatePhysicalMediaExclusive(SESSION *thisSession, 
                                            PHYSICAL_MEDIA *physMedia, 
                                            LPNTMS_GUID lpPartitionId, 
                                            DWORD dwTimeoutMsec)
{
    DWORD startTime = GetTickCount();
    HRESULT result;

    ASSERT(lpPartitionId);
    
    while (TRUE){
        BOOL gotMedia;
        MEDIA_PARTITION *reservedMediaPartition = NULL;
        ULONG i;
        
        EnterCriticalSection(&physMedia->lock);

        /*
         *  Check that the media is not held.
         */
        if (physMedia->owningSession){
            ASSERT(physMedia->owningSession != thisSession);
            gotMedia = FALSE;
        }
        else {
            /*
             *  Check that none of the partitions are held.
             */
            gotMedia = TRUE;
            for (i = 0; i < physMedia->numPartitions; i++){
                MEDIA_PARTITION *thisPartition = &physMedia->partitions[i];
                if (thisPartition->owningSession){
                    gotMedia = FALSE;
                    break;
                }
                else if (RtlEqualMemory(&thisPartition->objHeader.guid, lpPartitionId, sizeof(NTMS_GUID))){
                    ASSERT(!reservedMediaPartition);
                    reservedMediaPartition = thisPartition;
                }
            }
             
        }

        if (gotMedia){
            if (reservedMediaPartition){
                physMedia->owningSession = thisSession;
                reservedMediaPartition->owningSession = thisSession;
                physMedia->numPartitionsOwnedBySession = 1;
                RefObject(physMedia);
                RefObject(reservedMediaPartition);
                result = ERROR_SUCCESS;
            }
            else {
                result = ERROR_INVALID_MEDIA;
            }
        }
        else {
            result = ERROR_MEDIA_UNAVAILABLE;
        }
        
        LeaveCriticalSection(&physMedia->lock);

        /*
         *  If appropriate, wait for the media to become free.
         */
        if ((result == ERROR_MEDIA_UNAVAILABLE) && (dwTimeoutMsec > 0)){
            /*
             *  Wait for the media to become available.
             */
            DWORD waitRes = WaitForSingleObject(physMedia->mediaFreeEvent, dwTimeoutMsec); 
            if (waitRes == WAIT_TIMEOUT){
                result = ERROR_TIMEOUT;
                break;
            }
            else {
                /*
                 *  Loop around and try again.
                 */
                DWORD timeNow = GetTickCount();
                ASSERT(timeNow >= startTime);
                dwTimeoutMsec -= MIN(dwTimeoutMsec, timeNow-startTime);
            }
        }
        else {
            break;
        }
    }

    // BUGBUG FINISH - need to move media to different media pool ?
    
    return result;
}


/*
 *  AllocateNextPartitionOnExclusiveMedia
 *
 *      The calling session should already hold exclusive access to the media.
 *      This call simply reserves another partition for the caller.
 */
HRESULT AllocateNextPartitionOnExclusiveMedia(SESSION *thisSession, 
                                                    PHYSICAL_MEDIA *physMedia,
                                                    MEDIA_PARTITION **ppNextPartition)
{
    MEDIA_PARTITION *reservedMediaPartition = NULL;
    HRESULT result;

    ASSERT(physMedia->numPartitionsOwnedBySession >= 1);
    
    EnterCriticalSection(&physMedia->lock);

    if (physMedia->owningSession == thisSession){
        ULONG i;

        /*
         *  Just reserve the next available partition
         */
        result = ERROR_MEDIA_UNAVAILABLE;
        for (i = 0; i < physMedia->numPartitions; i++){
            MEDIA_PARTITION *thisPartition = &physMedia->partitions[i];
            if (thisPartition->owningSession){
                ASSERT(thisPartition->owningSession == thisSession);
            }
            else {
                reservedMediaPartition = thisPartition;
                reservedMediaPartition->owningSession = thisSession;
                RefObject(reservedMediaPartition);
                physMedia->numPartitionsOwnedBySession++;
                result = ERROR_SUCCESS;
                break;
            }
        }
    }
    else {
        ASSERT(physMedia->owningSession == thisSession);
        result = ERROR_INVALID_MEDIA;
    }
    
    LeaveCriticalSection(&physMedia->lock);

    *ppNextPartition = reservedMediaPartition;
    return result;
}


HRESULT AllocateMediaFromPool(  SESSION *thisSession, 
                                    MEDIA_POOL *mediaPool, 
                                    DWORD dwTimeoutMsec,
                                    PHYSICAL_MEDIA **ppPhysMedia,
                                    BOOL opReqIfNeeded)
{
    DWORD startTime = GetTickCount();
    HRESULT result;

    while (TRUE){
        PHYSICAL_MEDIA *physMedia = NULL;
        LIST_ENTRY *listEntry;
        ULONG i;
        
        EnterCriticalSection(&mediaPool->lock);

        if (!IsListEmpty(&mediaPool->physMediaList)){
            /*
             *  Remove the media.  
             *  Deref both the pool and the media since they no longer
             *  point to each other.
             */
            PLIST_ENTRY listEntry = RemoveHeadList(&mediaPool->physMediaList);
            physMedia = CONTAINING_RECORD(listEntry, PHYSICAL_MEDIA, physMediaListEntry);    
            DerefObject(mediaPool);
            DerefObject(physMedia);
        }    
        
        LeaveCriticalSection(&mediaPool->lock);

        if (physMedia){
            
            // BUGBUG FINISH - enqueue it in a 'inUse' queue, change state ?
            
            *ppPhysMedia = physMedia;

            /*
             *  Reference the media since we're returning a pointer to it.
             */
            RefObject(physMedia);
            result = ERROR_SUCCESS;
            break;
        }
        else {
            
            // BUGBUG FINISH - based on policy, try free/scratch pool

            if (opReqIfNeeded){
                // BUGBUG FINISH - do op request and try again ...
            }
            
            result = ERROR_MEDIA_UNAVAILABLE;
        }

        /*
         *  If appropriate, wait for media to become free.
         */
        if ((result == ERROR_MEDIA_UNAVAILABLE) && (dwTimeoutMsec > 0)){
            /*
             *  Wait on the designated media pool to receive new media.
             *  The media pool's event will get signalled when either it
             *  OR THE SCRATCH POOL receives new media.
             */
            DWORD waitRes = WaitForSingleObject(mediaPool->newMediaEvent, dwTimeoutMsec); 
            if (waitRes == WAIT_TIMEOUT){
                result = ERROR_TIMEOUT;
                break;
            }
            else {
                /*
                 *  Loop around and try again.
                 */
                DWORD timeNow = GetTickCount();
                dwTimeoutMsec -= MIN(dwTimeoutMsec, timeNow-startTime);
            }
        }
        else {
            break;
        }
        
    }
    
    return result;
}


HRESULT DeletePhysicalMedia(PHYSICAL_MEDIA *physMedia)
{
    HRESULT result;
    
    // BUGBUG FINISH
    DBGERR(("not implemented"));
    result = ERROR_CALL_NOT_IMPLEMENTED;
    
    return result;
}



/*
 *  InsertPhysicalMediaInPool
 *
 *      Insert the physical media (which may not currently be in any pool)
 *      into the designated media pool.
 */
VOID InsertPhysicalMediaInPool( MEDIA_POOL *mediaPool,
                                    PHYSICAL_MEDIA *physMedia)
{

    ASSERT(!physMedia->owningMediaPool);
    
    EnterCriticalSection(&mediaPool->lock);
    EnterCriticalSection(&physMedia->lock);

    InsertTailList(&mediaPool->physMediaList, &physMedia->physMediaListEntry); 
    mediaPool->numPhysMedia++;
    physMedia->owningMediaPool = mediaPool;

    /*
     *  Reference both objects since they now point to each other.
     */
    RefObject(mediaPool);
    RefObject(physMedia);
    
    LeaveCriticalSection(&physMedia->lock);
    LeaveCriticalSection(&mediaPool->lock);
    
}


/*
 *  RemovePhysicalMediaFromPool
 *
 *      Remove the physical media from containing media pool (if any).
 *
 *      Must be called with physical media lock held.
 *      If the media is indeed in a pool, pool lock must be held as well
 *      (use LockPhysicalMediaWithPool).
 */
VOID RemovePhysicalMediaFromPool(PHYSICAL_MEDIA *physMedia)
{
    MEDIA_POOL *mediaPool = physMedia->owningMediaPool;
    HRESULT result;   

    if (mediaPool){
        ASSERT(!IsListEmpty(&mediaPool->physMediaList));
        ASSERT(!IsListEmpty(&physMedia->physMediaListEntry));
        ASSERT(mediaPool->numPhysMedia > 0);
        
        RemoveEntryList(&physMedia->physMediaListEntry); 
        InitializeListHead(&physMedia->physMediaListEntry);
        mediaPool->numPhysMedia--;
        physMedia->owningMediaPool = NULL; 

        /*
         *  Dereference both objects since they no longer point to each other.
         */
        DerefObject(mediaPool);
        DerefObject(physMedia);
    }
    else {
        /*
         *  The media is not in any pool.  So succeed.
         */
    }

}


/*
 *  MovePhysicalMediaToPool
 *
 *      Remove the physical media from whatever pool it is currently in
 *      and move it to destMediaPool.  
 */
HRESULT MovePhysicalMediaToPool(    MEDIA_POOL *destMediaPool, 
                                            PHYSICAL_MEDIA *physMedia,
                                            BOOLEAN setMediaTypeToPoolType)
{
    HRESULT result;
    BOOLEAN allowImport;
    ULONG i;
    
    if (LockPhysicalMediaWithPool(physMedia)){
    
        /*
         *  We can only move the media if all media partitions are 
         *  in an importable state.
         */
        allowImport = TRUE;
        for (i = 0; i < physMedia->numPartitions; i++){
            MEDIA_PARTITION *thisMediaPart = &physMedia->partitions[i];
            if (!thisMediaPart->allowImport){
                allowImport = FALSE;
                break;
            }
        }

        if (allowImport){

            // BUGBUG FINISH - also check that media types match, etc.
            
            RemovePhysicalMediaFromPool(physMedia);
            result = ERROR_SUCCESS;
        }
        else {
            result = ERROR_ACCESS_DENIED;
        }

        /*
         *  Drop the lock before touching the destination media pool.
         *  We cannot hold locks on two pools at once (may cause deadlock).
         */
        UnlockPhysicalMediaWithPool(physMedia);
        
        if (result == ERROR_SUCCESS){
            InsertPhysicalMediaInPool(destMediaPool, physMedia);

            if (setMediaTypeToPoolType){
                /*
                 *  Set the media's type to the media pool's type.
                 *
                 *  This part is failable.  BUGBUG ?
                 */
                if (LockPhysicalMediaWithPool(physMedia)){
                    /*
                     *  Make sure that the media didn't move while
                     *  we dropped the lock.  If it did, that's ok;
                     *  we can just leave it alone and let the new pool
                     *  take over.
                     */
                    if (physMedia->owningMediaPool == destMediaPool){
                        SetMediaType(physMedia, destMediaPool->mediaTypeObj);
                    }
                    
                    UnlockPhysicalMediaWithPool(physMedia);
                }
            }
        }
    }
    else {
        result = ERROR_BUSY;
    }
    
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\lock.c ===
/*
 *  LOCK.C
 *
 *      RSM Service :  Locking functions for Physical Media and Media Pools
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"

BOOLEAN LockPhysicalMediaWithPool_Iter(PHYSICAL_MEDIA *physMedia, ULONG numTries);
BOOLEAN LockPhysicalMediaWithLibrary_Iter(PHYSICAL_MEDIA *physMedia, ULONG numTries);

/*
 *  LockPhysicalMediaWithPool
 *
 *      Warning:  ugly function
 *
 *      We frequently need to lock a piece of media as well as
 *      its media pool.  
 *      To avoid deadlock, we have to acquire the locks top-down
 *      (starting with the pool).  But that's difficult since we're starting
 *      with the physical media pointer.
 *      This function enters the media pool and physical media
 *      critical sections in the right order.  
 *      Subsequently, the caller can safely call subroutines that re-enter 
 *      these critical sections in any order.
 */
BOOLEAN LockPhysicalMediaWithPool(PHYSICAL_MEDIA *physMedia)
{
    return LockPhysicalMediaWithPool_Iter(physMedia, 10);
}
BOOLEAN LockPhysicalMediaWithPool_Iter(PHYSICAL_MEDIA *physMedia, ULONG numTries){
    MEDIA_POOL *mediaPool;
    BOOLEAN success = FALSE;

    /*
     *  1.  Get an (unreliable) snapshot of the heirarchy without grabbing
     *      more than one lock at a time.  If the media is in a pool,
     *      reference it temporarily so that it doesn't go away while
     *      we drop the media lock (which can then lose its ref on the pool).
     */
    EnterCriticalSection(&physMedia->lock);
    mediaPool = physMedia->owningMediaPool;
    if (mediaPool){
        RefObject(mediaPool);
    }
    LeaveCriticalSection(&physMedia->lock);

    /*
     *  2.  Now grab the locks for the pool and media in the right order.
     *      Then check the hierarchy again.  
     *      If its the same, we're done; otherwise, try again.
     *      
     */
    if (mediaPool){
        /*
         *  We referenced the media pool, so its guaranteed to still exist.
         *  But the media may have been moved out of it while we
         *  let go of the lock.  If the hierarchy is still the same, then
         *  we've got both the media and pool locked in the right order.
         *  Otherwise, we have to back off and try again.
         */
        EnterCriticalSection(&mediaPool->lock);
        EnterCriticalSection(&physMedia->lock);
        if (physMedia->owningMediaPool == mediaPool){
            success = TRUE;
        }
        else {
            LeaveCriticalSection(&physMedia->lock);
            LeaveCriticalSection(&mediaPool->lock);
        }
        
        DerefObject(mediaPool);
    }
    else {
        /*
         *  If after locking the media again it is still not in any pool,
         *  we are set to go.
         */
        EnterCriticalSection(&physMedia->lock);
        if (physMedia->owningMediaPool){
            LeaveCriticalSection(&physMedia->lock);
        }
        else {
            success = TRUE;
        }
    }

    if (!success && (numTries > 0)){
        /*
         *  Try again by calling ourselves RECURSIVELY.
         */
        Sleep(1);
        success = LockPhysicalMediaWithPool_Iter(physMedia, numTries-1);                
    }

    return success;
}


/*
 *  UnlockPhysicalMediaWithPool
 *
 *      Undo LockPhysicalMediaWithPool.
 */
VOID UnlockPhysicalMediaWithPool(PHYSICAL_MEDIA *physMedia)
{
    if (physMedia->owningMediaPool){
        LeaveCriticalSection(&physMedia->owningMediaPool->lock);
    }
    LeaveCriticalSection(&physMedia->lock);
}


/*
 *  LockPhysicalMediaWithLibrary
 *
 *      Warning:  ugly function
 *
 *      Like LockPhysicalMediaWithPool, but locks the  media pool
 *  and the library.  Acquires locks in the right
 *  order (top to down) despite the fact that we're starting 
 *  from the bottom with the media.
 *      Note that we don't have to actually grab locks for all
 *  the media sub-pools in the hierarchy.  The media pool configuration
 *  does not change while the library lock is held.
 */
BOOLEAN LockPhysicalMediaWithLibrary(PHYSICAL_MEDIA *physMedia)
{
    return LockPhysicalMediaWithLibrary_Iter(physMedia, 10);
}
BOOLEAN LockPhysicalMediaWithLibrary_Iter(PHYSICAL_MEDIA *physMedia, ULONG numTries)
{
    LIBRARY *lib = NULL;
    MEDIA_POOL *mediaPool = NULL;
    BOOLEAN success = FALSE;
    
    success = LockPhysicalMediaWithPool(physMedia);
    if (success){
        /*
         *  Reference the library so it doesn't go away while
         *  we drop the locks.
         */
        mediaPool = physMedia->owningMediaPool;
        if (mediaPool){
            RefObject(mediaPool);
            lib = mediaPool->owningLibrary;
            if (lib){
                RefObject(lib);
            }
        }
        UnlockPhysicalMediaWithPool(physMedia);

        /*
         *  Now grab the locks in the right order and check if 
         *  the configuration hasn't changed while we dropped the lock.
         */
        if (lib){
            EnterCriticalSection(&lib->lock);
            success = LockPhysicalMediaWithPool(physMedia);
            if (success){
                if (physMedia->owningMediaPool &&
                    (physMedia->owningMediaPool->owningLibrary == lib)){

                }
                else {
                    UnlockPhysicalMediaWithPool(physMedia);
                    success = FALSE;
                }
            }

            if (!success){
                LeaveCriticalSection(&lib->lock);
            }
            DerefObject(lib);
        }
        else {
            /*
             *  Media is not in any pool or lib ?  
             *  Just make sure nothing's changed while we dropped the lock.
             */           
            success = LockPhysicalMediaWithPool(physMedia);
            if (mediaPool){
                if ((physMedia->owningMediaPool == mediaPool) &&
                    (mediaPool->owningLibrary == lib)){
                }
                else {
                    UnlockPhysicalMediaWithPool(physMedia);
                    success = FALSE;
                }
            }
        }
        
    }

    if (!success && (numTries > 0)){
        success = LockPhysicalMediaWithLibrary_Iter(physMedia, numTries-1);
    }
    return success;
}


VOID UnlockPhysicalMediaWithLibrary(PHYSICAL_MEDIA *physMedia)
{
    if (physMedia->owningMediaPool && 
        physMedia->owningMediaPool->owningLibrary){

        LeaveCriticalSection(&physMedia->owningMediaPool->owningLibrary->lock);
    }
    UnlockPhysicalMediaWithPool(physMedia);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\opreq.c ===
/*
 *  OPREQ.C
 * 
 *      RSM Service :  Operator Requests
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>
#include <objbase.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


OPERATOR_REQUEST *NewOperatorRequest(    DWORD dwRequest,
                                        LPCWSTR lpMessage,
                                        LPNTMS_GUID lpArg1Id,
                                        LPNTMS_GUID lpArg2Id)
{
    OPERATOR_REQUEST *newOpReq;

    newOpReq = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(OPERATOR_REQUEST));
    if (newOpReq){

        newOpReq->completedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (newOpReq->completedEvent){    

            InitializeListHead(&newOpReq->sessionOpReqsListEntry);

            newOpReq->opRequestCommand = dwRequest;
            newOpReq->state = NTMS_OPSTATE_UNKNOWN;
		    WStrNCpy((WCHAR *)newOpReq->appMessage, (WCHAR *)lpMessage, sizeof(newOpReq->appMessage)/sizeof(WCHAR));
		    memcpy(&newOpReq->arg1Guid, lpArg1Id, sizeof(NTMS_GUID));
		    memcpy(&newOpReq->arg2Guid, lpArg2Id, sizeof(NTMS_GUID));

            #if 0   // BUGBUG - do this in RSM Monitor app ?
                /*
                 *  Initialize the NOTIFYICONDATA structure 
                 *  for the message display (used in the Shell_NotifyIcon call).
                 *  Make it hidden initially.
                 *  BUGBUG - make this work with RSM monitor (need hWnd and callback msg id)
                 */
                newOpReq->notifyData.cbSize = sizeof(NOTIFYICONDATA);
                newOpReq->notifyData.hWnd = NULL;
                newOpReq->notifyData.uID = (ULONG_PTR)newOpReq;
                newOpReq->notifyData.uFlags = NIF_ICON | NIF_TIP | NIF_STATE;
                newOpReq->notifyData.uCallbackMessage = 0;
                newOpReq->notifyData.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_OPREQ_ICON));
                LoadString(g_hInstanceMonitor, IDS_OPTIP, newOpReq->notifyData.szTip, sizeof(newOpReq->notifyData.szTip)/sizeof(TCHAR));
                newOpReq->notifyData.dwState = NIS_HIDDEN;
                newOpReq->notifyData.dwStateMask = NIS_HIDDEN;
                LoadString(g_hInstanceMonitor, IDS_OPINFO, newOpReq->notifyData.szInfo, sizeof(newOpReq->notifyData.szInfo)/sizeof(TCHAR));
                newOpReq->notifyData.uTimeout = 60000;  // 1 minute
                LoadString(g_hInstanceMonitor, IDS_OPTIP, newOpReq->notifyData.szInfoTitle, sizeof(newOpReq->notifyData.szInfoTitle)/sizeof(TCHAR));
                newOpReq->notifyData.dwInfoFlags = NIIF_INFO;
                Shell_NotifyIcon(NIM_ADD, &newOpReq->notifyData);
            #endif

            /*
             *  Create a unique identifier for this op request
             */
            CoCreateGuid(&newOpReq->opReqGuid);
        }
        else {
            FreeOperatorRequest(newOpReq);
            newOpReq = NULL;
        }
    }

    ASSERT(newOpReq);
    return newOpReq;
}


VOID FreeOperatorRequest(OPERATOR_REQUEST *opReq)
{
    ASSERT(IsListEmpty(&opReq->sessionOpReqsListEntry));

    if (opReq->completedEvent) CloseHandle(opReq->completedEvent);

    // BUGBUG ? if (opReq->notifyData.hIcon) DestroyIcon(opReq->notifyData.hIcon);

    GlobalFree(opReq);
}


BOOL EnqueueOperatorRequest(SESSION *thisSession, OPERATOR_REQUEST *opReq)
{
    DWORD threadId;
    BOOL ok = FALSE;

    #if 0   // BUGBUG - do this in RSM Monitor app ?
        /*
         *  Make the notification display visible on the tray
         */
        newOpReq->notifyData.uFlags = NIF_MESSAGE | NIF_INFO | NIF_STATE;
        newOpReq->notifyData.dwState = 0;
        newOpReq->notifyData.uTimeout = 60000;  // 1 minute
        Shell_NotifyIcon(NIM_MODIFY, &newOpReq->notifyData);
    #endif

    // BUGBUG FINISH - make rsm monitor put up dialog UI for op req msg

    opReq->invokingSession = thisSession;
    GetSystemTime(&opReq->timeSubmitted);

    EnterCriticalSection(&thisSession->lock);

            // BUGBUG - I don't think we need an op request thread
    opReq->hThread = CreateThread(NULL, 0, OperatorRequestThread, opReq, 0, &threadId);
    if (opReq->hThread){    
        InsertTailList(&thisSession->operatorRequestList, &opReq->sessionOpReqsListEntry);
        opReq->state = NTMS_OPSTATE_SUBMITTED;
        ok = TRUE;
    }
    else {
        ASSERT(opReq->hThread);
    }

    LeaveCriticalSection(&thisSession->lock);

    return ok;
}


/*
 *  DequeueOperatorRequest
 *
 *      Callable 3 ways:
 *          dequeue given op request (specificOpReq non-null)
 *          dequeue op request with given GUID (specificOpReqGuid non-null)
 *          dequeue first op request (both NULL)
 */
OPERATOR_REQUEST *DequeueOperatorRequest(    SESSION *thisSession, 
                                            OPERATOR_REQUEST *specificOpReq,
                                            LPNTMS_GUID specificOpReqGuid)
{
    OPERATOR_REQUEST *opReq;
    LIST_ENTRY *listEntry;

    /*
     *  If an op request is passed in, dequeue that one.
     *  Else, dequeue the first.
     */
    EnterCriticalSection(&thisSession->lock);
    if (specificOpReq){
        ASSERT(!IsListEmpty(&specificOpReq->sessionOpReqsListEntry));
        ASSERT(!IsListEmpty(&thisSession->operatorRequestList));
        RemoveEntryList(&specificOpReq->sessionOpReqsListEntry);
        InitializeListHead(&specificOpReq->sessionOpReqsListEntry);
        opReq = specificOpReq;
    }
    else if (specificOpReqGuid){
        opReq = FindOperatorRequest(thisSession, specificOpReqGuid);
        if (opReq){
           RemoveEntryList(&opReq->sessionOpReqsListEntry);
        }
    }
    else {
        if (IsListEmpty(&thisSession->operatorRequestList)){
            opReq = NULL;
        }
        else {
            listEntry = RemoveHeadList(&thisSession->operatorRequestList);
            opReq = CONTAINING_RECORD(listEntry, OPERATOR_REQUEST, sessionOpReqsListEntry);
        }
    }
    LeaveCriticalSection(&thisSession->lock);

    return opReq;
}


/*
 *  FindOperatorRequest
 *
 *      ** Must be called with session lock held
 */
OPERATOR_REQUEST *FindOperatorRequest(SESSION *thisSession, LPNTMS_GUID opReqGuid)
{
    OPERATOR_REQUEST *opReq = NULL;
    LIST_ENTRY *listEntry;

    listEntry = &thisSession->operatorRequestList;
    while ((listEntry = listEntry->Flink) != &thisSession->operatorRequestList){
        OPERATOR_REQUEST *thisOpReq = CONTAINING_RECORD(listEntry, OPERATOR_REQUEST, sessionOpReqsListEntry);
        if (RtlEqualMemory(&thisOpReq->opReqGuid, opReqGuid, sizeof(NTMS_GUID))){
            opReq = thisOpReq;
            break;
        }
    }

    return opReq;
}


/*
 *  CompleteOperatorRequest
 *
 *      Complete and free the op request, synchronizing with any threads
 *      waiting on its completion.
 */
HRESULT CompleteOperatorRequest(    SESSION *thisSession, 
                                    LPNTMS_GUID lpRequestId,
                                    enum NtmsOpreqState completeState)
{
    HRESULT result;

    if (lpRequestId){
        OPERATOR_REQUEST *opReq;
    
        opReq = DequeueOperatorRequest(thisSession, NULL, lpRequestId);
        if (opReq){

            /*
             *  Remove the notification display from the tray
             */
            // BUGBUG - do this in RSM Monitor app ?
            // Shell_NotifyIcon(NIM_DELETE, &opReq->notifyData);

            /*
             *  Make sure there are no threads waiting on the
             *  operator request before freeing it.
             */
            EnterCriticalSection(&thisSession->lock);

            /*
             *  Kill the op request thread
             */
            TerminateThread(opReq->hThread, ERROR_SUCCESS);
            CloseHandle(opReq->hThread);
 
            /*
             *  There may be some threads waiting in WaitForNtmsOperatorRequest
             *  for this op request to complete.  Need to flush them
             *  before freeing the op request.
             */
            opReq->state = completeState;
            SetEvent(opReq->completedEvent);

            /*
             *  Drop the lock and wait for the waiting threads to exit.
             */
            while (opReq->numWaitingThreads > 0){
                LeaveCriticalSection(&thisSession->lock);
                Sleep(1);
                EnterCriticalSection(&thisSession->lock);
            }

            LeaveCriticalSection(&thisSession->lock);

            FreeOperatorRequest(opReq);
            result = ERROR_SUCCESS;
        }
        else {
            result = ERROR_OBJECT_NOT_FOUND;
        }
    }
    else {
        ASSERT(lpRequestId);
        result = ERROR_INVALID_PARAMETER;
    }

    return result;
}

            // BUGBUG - I don't think we need an op request thread
DWORD __stdcall OperatorRequestThread(void *context)
{
    OPERATOR_REQUEST *opReq = (OPERATOR_REQUEST *)context;



    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\pool.c ===
/*
 *  POOL.C
 *
 *      RSM Service :  Media Pools
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"



MEDIA_POOL *NewMediaPool(LPCWSTR name, LPNTMS_GUID mediaType, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    MEDIA_POOL *newMediaPool;
    
    newMediaPool = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(MEDIA_POOL));
    if (newMediaPool){
        
        newMediaPool->newMediaEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (newMediaPool->newMediaEvent){
            
            WStrNCpy(newMediaPool->name, name, NTMS_OBJECTNAME_LENGTH);
            InitializeCriticalSection(&newMediaPool->lock);

            newMediaPool->objHeader.objType = OBJECTTYPE_MEDIAPOOL;
            newMediaPool->objHeader.refCount = 1;
            
            // BUGBUG FINISH
        }
        else {
            GlobalFree(newMediaPool);
            newMediaPool = NULL;
        }
    }

    ASSERT(newMediaPool);
    return newMediaPool;
}


/*
 *  DestroyMediaPool
 *
 *      Actually delete a media pool.
 *      Assumes that there are no remaining references on the pool, etc.
 */
VOID DestroyMediaPool(MEDIA_POOL *mediaPool)
{

    // BUGBUG FINISH
    DeleteCriticalSection(&mediaPool->lock);
    GlobalFree(mediaPool);
}


MEDIA_POOL *FindMediaPool(LPNTMS_GUID mediaPoolId)
{
    MEDIA_POOL *foundMediaPool = NULL;

    if (mediaPoolId){
        OBJECT_HEADER *objHdr;
        
        objHdr = FindObjectInGuidHash(mediaPoolId);
        if (objHdr){
            if (objHdr->objType == OBJECTTYPE_MEDIAPOOL){
                foundMediaPool = (MEDIA_POOL *)objHdr;
            }
            else {
                DerefObject(objHdr);
            }
        }
    }
    
    return foundMediaPool;
}


MEDIA_POOL *FindMediaPoolByName(PWSTR poolName)
{
    MEDIA_POOL *mediaPool = NULL;
    LIST_ENTRY *listEntry;

    EnterCriticalSection(&g_globalServiceLock);

    listEntry = &g_allLibrariesList;
    while ((listEntry = listEntry->Flink) != &g_allLibrariesList){
        LIBRARY *lib = CONTAINING_RECORD(listEntry, LIBRARY, allLibrariesListEntry);
        mediaPool = FindMediaPoolByNameInLibrary(lib, poolName);
        if (mediaPool){
            break;
        }
    }

    LeaveCriticalSection(&g_globalServiceLock);

    return mediaPool;
}


MEDIA_POOL *FindMediaPoolByNameInLibrary(LIBRARY *lib, PWSTR poolName)
{
    MEDIA_POOL *mediaPool = NULL;
    LIST_ENTRY *listEntry;

    EnterCriticalSection(&lib->lock);

    listEntry = &lib->mediaPoolsList;
    while ((listEntry = listEntry->Flink) != &lib->mediaPoolsList){
        MEDIA_POOL *thisMediaPool = CONTAINING_RECORD(listEntry, MEDIA_POOL, mediaPoolsListEntry);
        if (WStringsEqualN(thisMediaPool->name, poolName, FALSE, NTMS_OBJECTNAME_LENGTH)){
            mediaPool = thisMediaPool;
            RefObject(mediaPool);
            break;
        }
    }
    
    LeaveCriticalSection(&lib->lock);
    
    return mediaPool;
}


HRESULT DeleteMediaPool(MEDIA_POOL *mediaPool)
{
    HRESULT result;
    
    EnterCriticalSection(&mediaPool->lock);

    /*
     *  The pool can only be deleted if it is empty and has no
     *  child pools.
     */
    if (mediaPool->numPhysMedia || mediaPool->numChildPools){
        result = ERROR_NOT_EMPTY;
    }
    else if (mediaPool->objHeader.isDeleted){
        /*
         *  Already deleted.  Do nothing.
         */
        result = ERROR_SUCCESS;
    }
    else {
        /*
         *  If the mediaPool can be deleted, mark it as deleted and
         *  dereference it.
         *  This will cause no new references to be opened on it
         *  and will cause it to actually get deleted once all existing
         *  references go away.
         *  We can still use our mediaPool pointer because the caller 
         *  has a reference on it (by virtue of having a pointer).
         */
        mediaPool->objHeader.isDeleted = TRUE;
        DerefObject(mediaPool);
        result = ERROR_SUCCESS;
    }

    LeaveCriticalSection(&mediaPool->lock);
    
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\resource.h ===
/*
 *  RESOURCE.H
 *
 *      RSM Service :  Resources header
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


/*
 *  Identifiers for icons
 */
#define IDI_MOUNT_ICON      1                          
#define IDI_OPREQ_ICON      2


/*
 *  Identifiers for localizable string resources
 */
#define IDS_LMPROCFAILED__FORMAT						101
#define IDS_LMCLASSIFY                                  102
#define IDS_LMCLEANDRIVE                                103
#define IDS_LMDISABLECHANGER							104
#define IDS_LMENABLECHANGER                             105
#define IDS_LMDISABLEMEDIA                              106
#define IDS_LMENABLEMEDIA                               107
#define IDS_LMDISABLEDRIVE                              108
#define IDS_LMENABLEDRIVE                               109
#define IDS_LMEJECT                                     110
#define IDS_LMINJECT                                    111
#define IDS_LMDOORACCESS                                112
#define IDS_LMMOUNT                                     113
#define IDS_LMDISMOUNT                                  114
#define IDS_LMINVENTORY                                 115
#define IDS_LMSTOPINVENTORY                             116
#define IDS_LMREMOVE                                    117
#define IDS_LMUPDATEOMID                                120
#define IDS_LMWRITESCRATCH                              121
#define IDS_LMRESERVECLEANER                            122
#define IDS_LMRELEASECLEANER                            123
#define IDS_LMINJECTCLEANER                             124
#define IDS_LMEJECTCLEANER                              125

#define IDS_OPREQUESTNEWMEDIA                           200
#define IDS_OPREQUESTCLEANER                            201
#define IDS_OPREQ_DRIVE_NEEDS_CLEANING__FORMAT          202
#define IDS_OPREQ_DRIVE_DIRTY                           203
#define IDS_OPREQ_NEEDS_NEW_CLEANER__FORMAT             204
#define IDS_OPREQ_REPLACE_CLEANER                       205
#define IDS_OPREQUESTDEVICESVC                          206
#define IDS_OPREQUESTMOVEMEDIA                          207
#define IDS_OPREQUESTMESSAGE                            208

#define IDS_SERVICE_STOPPED                             301
#define IDS_SERVICE_RUNNING                             302
#define IDS_SERVICE_START_PENDING                       303
#define IDS_SERVICE_STOP_PENDING                        304
#define IDS_SERVICE_CONTINUE_PENDING                    305
#define IDS_SERVICE_PAUSE_PENDING                       306
#define IDS_SERVICE_PAUSED                              307
#define IDS_SERVICE_UNKNOWN                             308
#define IDS_OPREQ_CFGFAIL_NAME                          309
#define IDS_OPREQ_CFGFAIL__FORMAT                       310

#define IDS_OPREQ_MANUALCFG_ALERT__FORMAT               401
#define IDS_OPREQ_MANUALCFG_ALERT_NAME                  402
#define IDS_OPREQ_NO_DEVICE_NUMBER__FORMAT              403

#define IDS_DATABASE                                    501
#define IDS_DATABASE_PROBLEM                            502
#define IDS_SCSI_PORT                                   503
#define IDS_SCSI_BUS                                    504
#define IDS_TARGET_ID                                   505
#define IDS_LUID                                        506
#define IDS_UNIT                                        507

#define IDS_WRITESCRATCH_FAILED__FORMAT                 601
#define IDS_WRITESCRATCH_FAILED_NAME                    602
#define IDS_OPENDOOR_MSG__FORMAT                        603
#define IDS_OPENDOOR                                    604
#define IDS_CLOSEDOOR_MSG__FORMAT                       605
#define IDS_CLOSEDOOR                                   606
#define IDS_INSERT_CLEANER                              607
#define IDS_INSERT_CLEANER_MSG__FORMAT                  608
#define IDS_PROCESS_OMID                                609
#define IDS_BACK_BACK_DOT_BACK                          610
#define IDS_MOUNTMESSAGE__FORMAT                        611
#define IDS_ADDMEDIAMESSAGE__FORMAT                     612
#define IDS_ADDFREEMEDIAMESSAGE__FORMAT                 613
#define IDS_NEW_CLEANER_NEEDED_MSG__FORMAT              614
#define IDS_NEW_CLEANER_NEEDED                          615
#define IDS_CLOSE_PORT_MSG__FORMAT                      616
#define IDS_CLOSE_PORT                                  617    


#define IDS_INJECTMEDIAMESSAGE__FORMAT                  801
#define IDS_INJECTMULTISIDEDMEDIA_MSG__FORMAT           802
#define IDS_OVERFILLED_LIB_MSG__FORMAT                  803
#define IDS_OVERFILLED_LIB                              804
#define IDS_INVALID_MEDIA_MSG__FORMAT                   805
#define IDS_INVALID_MEDIA                               806
#define IDS_CHANGER_INOPERABLE                          807
#define IDS_CHANGER_INOPERABLE_MSG__FORMAT              808
#define IDS_OVERFILLED_EJECT                            809
#define IDS_OVERFILLED_EJECT_MSG__FORMAT                810
#define IDS_INJECT_CLEANER_MSG__FORMAT                  811
#define IDS_INJECT_CLEANER                              812

#define IDS_LIBTIP                                      901
#define IDS_LIBINFO                                     902
#define IDS_OPTIP                                       903
#define IDS_OPINFO                                      904
#define IDS_STATIC_USER                                 905
#define IDS_MESG_BUSY                                   906
#define IDS_MESG_NOT_AVAILABLE                          907
#define IDS_MESG_UNABLE_TO_UNLOAD                       908
#define IDS_MESG_UNEXPECTED_OMID                        909
#define IDS_MESG_UNKNOWN                                910
#define IDS_INFO_BUSY__FORMAT                           911
#define IDS_INFO_NOT_AVAILABLE__FORMAT                  912
#define IDS_INFO_UNABLE_TO_UNLOAD__FORMAT               913    
#define IDS_INFO_UNEXPECTED_OMID__FORMAT                914
#define IDS_INFO_UNKNOWN__FORMAT                        915
#define IDS_STATIC_SUGGESTION__FORMAT                   916
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\rsm2\service\dll\ntmsapi.c ===
/*
 *  NTMSAPI.C
 *
 *      RSM Service :  Service API
 *
 *      Author:  ErvinP
 *
 *      (c) 2001 Microsoft Corporation
 *
 */


#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <ntmsapi.h>
#include "internal.h"
#include "resource.h"
#include "debug.h"


     // BUGBUG - these need to be exposed as a COM interface w/ RPC


HANDLE WINAPI OpenNtmsServerSessionW(   LPCWSTR lpServer,
                                        LPCWSTR lpApplication,
                                        LPCWSTR lpClientName,
                                        LPCWSTR lpUserName,
                                        DWORD   dwOptions,
                                        LPVOID  lpConnectionContext)
{
    SESSION *newSession;

    newSession = NewSession(lpServer, lpApplication, lpClientName, lpUserName);
    if (newSession){
    }
    else {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return (HANDLE)newSession;
}


HANDLE WINAPI OpenNtmsServerSessionA( LPCSTR lpServer,
                                LPCSTR lpApplication,
                                LPCSTR lpClientName,
                                LPCSTR lpUserName,
                                DWORD  dwOptions,
                                LPVOID  lpConnectionContext)
{
    SESSION *newSession;
    WCHAR wServerName[NTMS_COMPUTERNAME_LENGTH];
    WCHAR wAppName[NTMS_APPLICATIONNAME_LENGTH];
    WCHAR wClientName[NTMS_COMPUTERNAME_LENGTH];
    WCHAR wUserName[NTMS_USERNAME_LENGTH];

    AsciiToWChar(wServerName, lpServer, NTMS_COMPUTERNAME_LENGTH);
    AsciiToWChar(wAppName, lpApplication, NTMS_APPLICATIONNAME_LENGTH);
    AsciiToWChar(wClientName, lpClientName, NTMS_COMPUTERNAME_LENGTH);
    AsciiToWChar(wUserName, lpUserName, NTMS_USERNAME_LENGTH);

    newSession = OpenNtmsServerSessionW(    wServerName, 
                                            wAppName,
                                            wClientName,
                                            wUserName,
                                            dwOptions,
                                            lpConnectionContext);

    return newSession;

}


DWORD WINAPI CloseNtmsSession(HANDLE hSession)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

        FreeSession(thisSession);

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI SubmitNtmsOperatorRequestW(    HANDLE hSession,
                                            DWORD dwRequest,
                                            LPCWSTR lpMessage,
                                            LPNTMS_GUID lpArg1Id,
                                            LPNTMS_GUID lpArg2Id,
                                            LPNTMS_GUID lpRequestId)
{   
    HRESULT result = ERROR_SUCCESS;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

        switch (dwRequest){

            case NTMS_OPREQ_DEVICESERVICE:
            case NTMS_OPREQ_MOVEMEDIA:
            case NTMS_OPREQ_NEWMEDIA:
                if (!lpArg1Id){
                    result = ERROR_INVALID_PARAMETER;
                }
                break;

            case NTMS_OPREQ_CLEANER:
            case NTMS_OPREQ_MESSAGE:
                break;

            default:
                DBGERR(("SubmitNtmsOperatorRequestW: unrecognized request"));
                result = ERROR_NOT_SUPPORTED;
                break;

        }
    
        if (result == ERROR_SUCCESS){
            OPERATOR_REQUEST *opReq;

            opReq = NewOperatorRequest(dwRequest, lpMessage, lpArg1Id, lpArg2Id);
            if (opReq){

                /*
                 *  Retrieve the localized RSM message for this op request.
                 */
                switch (dwRequest){
                    case NTMS_OPREQ_DEVICESERVICE:
                        LoadStringW(g_hInstance, IDS_OPREQUESTDEVICESVC, opReq->rsmMessage, sizeof(opReq->rsmMessage)/sizeof(WCHAR));
                        break;
                    case NTMS_OPREQ_MOVEMEDIA:
                        LoadStringW(g_hInstance, IDS_OPREQUESTMOVEMEDIA, opReq->rsmMessage, sizeof(opReq->rsmMessage)/sizeof(WCHAR));
                        break;
                    case NTMS_OPREQ_NEWMEDIA:
                        LoadStringW(g_hInstance, IDS_OPREQUESTNEWMEDIA, opReq->rsmMessage, sizeof(opReq->rsmMessage)/sizeof(WCHAR));
                        break;
                    case NTMS_OPREQ_CLEANER:
                        LoadStringW(g_hInstance, IDS_OPREQUESTCLEANER, opReq->rsmMessage, sizeof(opReq->rsmMessage)/sizeof(WCHAR));
                        break;
                    case NTMS_OPREQ_MESSAGE:
                        LoadStringW(g_hInstance, IDS_OPREQUESTMESSAGE, opReq->rsmMessage, sizeof(opReq->rsmMessage)/sizeof(WCHAR));
                        break;
                }

                *lpRequestId = opReq->opReqGuid;

                if (EnqueueOperatorRequest(thisSession, opReq)){
                    result = ERROR_SUCCESS;
                }
                else {
                    FreeOperatorRequest(opReq);
                    result = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            else {
                result = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI SubmitNtmsOperatorRequestA(    HANDLE hSession,
                                            DWORD dwRequest,
                                            LPCSTR lpMessage,
                                            LPNTMS_GUID lpArg1Id,
                                            LPNTMS_GUID lpArg2Id,
                                            LPNTMS_GUID lpRequestId)
{
    WCHAR wMessage[NTMS_MESSAGE_LENGTH];
    HRESULT result;

    AsciiToWChar(wMessage, lpMessage, NTMS_MESSAGE_LENGTH);
    result = SubmitNtmsOperatorRequestW(hSession,
                                        dwRequest,
                                        wMessage,
                                        lpArg1Id,
                                        lpArg2Id,
                                        lpRequestId);
    return result;
}


DWORD WINAPI WaitForNtmsOperatorRequest(    HANDLE hSession, 
                                            LPNTMS_GUID lpRequestId,
                                            DWORD dwTimeout)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        OPERATOR_REQUEST *opReq;

        EnterCriticalSection(&thisSession->lock);

        opReq = FindOperatorRequest(thisSession, lpRequestId);
        if (opReq){
            
            if ((opReq->state == NTMS_OPSTATE_COMPLETE) ||
                (opReq->state == NTMS_OPSTATE_REFUSED)){

                result = ERROR_SUCCESS;
            }
            else {
                opReq->numWaitingThreads++;

                /*
                 *  Drop the lock and wait for the op request to complete.
                 *  No race here: the opReq won't get deleted while
                 *  numWaitingThreads > 0.
                 */
                LeaveCriticalSection(&thisSession->lock);
                WaitForSingleObject(opReq->completedEvent, dwTimeout);
                EnterCriticalSection(&thisSession->lock);

                result = (opReq->state == NTMS_OPSTATE_COMPLETE) ? ERROR_SUCCESS :
                         (opReq->state == NTMS_OPSTATE_REFUSED) ? ERROR_CANCELLED :
                         ERROR_TIMEOUT;   

                ASSERT(opReq->numWaitingThreads > 0);
                opReq->numWaitingThreads--;
            }

        }
        else {
            result = ERROR_OBJECT_NOT_FOUND;
        }

        LeaveCriticalSection(&thisSession->lock);
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI CancelNtmsOperatorRequest(HANDLE hSession, LPNTMS_GUID lpRequestId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

        result = CompleteOperatorRequest(thisSession, lpRequestId, NTMS_OPSTATE_REFUSED);
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}

        
DWORD WINAPI SatisfyNtmsOperatorRequest(HANDLE hSession, LPNTMS_GUID lpRequestId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

        result = CompleteOperatorRequest(thisSession, lpRequestId, NTMS_OPSTATE_COMPLETE);
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI ImportNtmsDatabase(HANDLE hSession)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}

        
DWORD WINAPI ExportNtmsDatabase(HANDLE hSession)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}

        
        // BUGBUG - this API not documented and I don't understand it
HRESULT WINAPI GetNtmsMountDrives(  HANDLE hSession,
                                    LPNTMS_MOUNT_INFORMATION lpMountInfo,
                                    LPNTMS_GUID lpDriveId,
                                    DWORD dwCount)        
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

        if (lpMountInfo && lpMountInfo->lpReserved && lpDriveId && dwCount){

            // BUGBUG FINISH

            result = ERROR_SUCCESS;
        }
        else {
            result = ERROR_INVALID_PARAMETER;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
        SetLastError(result);
    }
    return result;
}


DWORD WINAPI AllocateNtmsMedia( HANDLE hSession,
                                LPNTMS_GUID lpMediaPoolId,
                                LPNTMS_GUID lpPartitionId,    // optional
                                LPNTMS_GUID lpMediaId,      // in/out
                                DWORD dwOptions,
                                DWORD dwTimeout,
                                LPNTMS_ALLOCATION_INFORMATION lpAllocateInfo)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        MEDIA_POOL *mediaPool;
        
        mediaPool = FindMediaPool(lpMediaPoolId);
        if (mediaPool){
            PHYSICAL_MEDIA *physMedia;

            if (dwOptions & NTMS_ALLOCATE_NEW){
                /*
                 *  Allocate the first partition (side) of the specified media
                 *  with a reservation on all other partitions.
                 */
                if (lpPartitionId){
                    physMedia = FindPhysicalMedia(lpMediaId);
                    if (physMedia){
                        result = AllocatePhysicalMediaExclusive(thisSession, physMedia, lpPartitionId, dwTimeout);
                        DerefObject(physMedia);
                    }
                    else {
                        result = ERROR_INVALID_PARAMETER;
                    }
                }
                else {
                    ASSERT(lpPartitionId);
                    result = ERROR_INVALID_PARAMETER;
                }
            }
            else if (dwOptions & NTMS_ALLOCATE_NEXT){
                /*
                 *  The specified media is (ostensibly) owned by the caller.  
                 *  Allocate the next available partition for him.
                 */
                physMedia = FindPhysicalMedia(lpMediaId);
                if (physMedia){
                    MEDIA_PARTITION *nextMediaPartition;
                    ASSERT(!lpPartitionId);
                    result = AllocateNextPartitionOnExclusiveMedia(thisSession, physMedia, &nextMediaPartition);
                    if (result == ERROR_SUCCESS){
                        *lpMediaId = nextMediaPartition->logicalMediaGuid;
                    }
                    DerefObject(physMedia);
                }
                else {
                    result = ERROR_INVALID_PARAMETER;
                }            
            }
            else {
                // BUGBUG - are we reserving a physMedia or just 
                //           a partition here ?
                
                BOOL opReqIfNeeded = (dwOptions & NTMS_ALLOCATE_ERROR_IF_UNAVAILABLE) ? FALSE : TRUE;
                result = AllocateMediaFromPool(thisSession, mediaPool, dwTimeout, &physMedia, opReqIfNeeded);
                if (result == ERROR_SUCCESS){
                    // BUGBUG - return logicalMediaId ??
                    *lpMediaId = physMedia->objHeader.guid;
                }
            }

            DerefObject(mediaPool);
        }
        else {
            result = ERROR_INVALID_MEDIA_POOL;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI DeallocateNtmsMedia(   HANDLE hSession,
                                    LPNTMS_GUID lpLogicalMediaId,
                                    DWORD dwOptions)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        MEDIA_PARTITION *thisMediaPartition;

        thisMediaPartition = FindMediaPartition(lpLogicalMediaId);
        if (thisMediaPartition){
            result = ReleaseMediaPartition(thisSession, thisMediaPartition);
        }
        else {
            result = ERROR_INVALID_MEDIA;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}        


DWORD WINAPI SwapNtmsMedia(   HANDLE hSession,
                                LPNTMS_GUID lpMediaId1,
                                LPNTMS_GUID lpMediaId2)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

            // BUGBUG FINISH

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI DecommissionNtmsMedia(   HANDLE hSession,
                                        LPNTMS_GUID lpMediaPartId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        MEDIA_PARTITION *mediaPart;

        mediaPart = FindMediaPartition(lpMediaPartId);
        if (mediaPart){
            result = SetMediaPartitionState( mediaPart, 
                                        MEDIAPARTITIONSTATE_DECOMMISSIONED);
            DerefObject(mediaPart);
        }
        else {
            result = ERROR_INVALID_HANDLE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}
        


DWORD WINAPI SetNtmsMediaComplete(    HANDLE hSession,
                                        LPNTMS_GUID lpMediaPartId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        MEDIA_PARTITION *mediaPart;

        mediaPart = FindMediaPartition(lpMediaPartId);
        if (mediaPart){
            result = SetMediaPartitionComplete(mediaPart);
            DerefObject(mediaPart);
        }
        else {
            result = ERROR_INVALID_HANDLE;
        }

        result = ERROR_SUCCESS;
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI DeleteNtmsMedia( HANDLE hSession,
                                LPNTMS_GUID lpPhysMediaId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        PHYSICAL_MEDIA *physMedia;

        physMedia = FindPhysicalMedia(lpPhysMediaId);
        if (physMedia){
            result = DeletePhysicalMedia(physMedia);
            DerefObject(physMedia);           
        }
        else {
            result = ERROR_INVALID_HANDLE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}
    
    
DWORD WINAPI CreateNtmsMediaPoolW(    HANDLE hSession,
                                        LPCWSTR lpPoolName,
                                        LPNTMS_GUID lpMediaType,
                                        DWORD dwAction,
                                        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                        OUT LPNTMS_GUID lpPoolId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        MEDIA_POOL *mediaPool;

        mediaPool = FindMediaPoolByName((PWSTR)lpPoolName);

        if (dwAction == NTMS_OPEN_EXISTING){
            if (mediaPool){
                *lpPoolId = mediaPool->objHeader.guid;
                result = ERROR_SUCCESS;
            }
            else {
                result = ERROR_OBJECT_NOT_FOUND;
            }
        }
        else if (dwAction == NTMS_OPEN_ALWAYS){
            if (mediaPool){
                *lpPoolId = mediaPool->objHeader.guid;
                result = ERROR_SUCCESS;
            }
            else {
                mediaPool = NewMediaPool(lpPoolName, lpMediaType, lpSecurityAttributes);
                if (mediaPool){
                    // BUGBUG FINISH
                    *lpPoolId = mediaPool->objHeader.guid;
                    result = ERROR_SUCCESS;
                }
                else {
                    result = ERROR_DATABASE_FAILURE;
                }
            }
        }
        else if (dwAction == NTMS_CREATE_NEW){
            /*
             *  Caller is trying to open a new media pool.
             *  So if one by that name already exists, fail.
             */
            if (mediaPool){
                DerefObject(mediaPool);
                result = ERROR_ALREADY_EXISTS;
            }
            else {
                mediaPool = NewMediaPool(lpPoolName, lpMediaType, lpSecurityAttributes);
                if (mediaPool){
                    // BUGBUG FINISH
                    *lpPoolId = mediaPool->objHeader.guid;
                    result = ERROR_SUCCESS;
                }
                else {
                    result = ERROR_DATABASE_FAILURE;
                }
            }
        
        }
        else {
            result = ERROR_INVALID_PARAMETER;
        }
        
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}

        
DWORD WINAPI CreateNtmsMediaPoolA(  HANDLE hSession,
                                    LPCSTR lpPoolName,
                                    LPNTMS_GUID lpMediaType,
                                    DWORD dwAction,
                                    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                    OUT LPNTMS_GUID lpPoolId)
{
    HRESULT result;
    WCHAR wPoolName[NTMS_OBJECTNAME_LENGTH];

    AsciiToWChar(wPoolName, lpPoolName, NTMS_OBJECTNAME_LENGTH);

    result = CreateNtmsMediaPoolW(  hSession,
                                    wPoolName,
                                    lpMediaType,
                                    dwAction,
                                    lpSecurityAttributes,
                                    lpPoolId);
    return result;
}


DWORD WINAPI GetNtmsMediaPoolNameW(   HANDLE hSession,
                                        LPNTMS_GUID lpPoolId,
                                        LPWSTR lpBufName,
                                        LPDWORD lpdwNameSize)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        MEDIA_POOL *mediaPool;

        mediaPool = FindMediaPool(lpPoolId);
        if (mediaPool){
            ULONG numChars;

            EnterCriticalSection(&mediaPool->lock);
            
            numChars = wcslen(mediaPool->name)+1;
            ASSERT(numChars < NTMS_OBJECTNAME_LENGTH);
            
            if (*lpdwNameSize >= numChars){
                numChars = WStrNCpy(lpBufName, mediaPool->name, *lpdwNameSize);
                result = ERROR_SUCCESS;
            }
            else {
                result = ERROR_INSUFFICIENT_BUFFER;
            }
            
            *lpdwNameSize = numChars;

            LeaveCriticalSection(&mediaPool->lock);
            
            DerefObject(mediaPool);
        }
        else {
            result = ERROR_INVALID_HANDLE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI GetNtmsMediaPoolNameA( HANDLE hSession,
                                    LPNTMS_GUID lpPoolId,
                                    LPSTR lpBufName,
                                    LPDWORD lpdwNameSize)
{
    HRESULT result;

    if (*lpdwNameSize > NTMS_OBJECTNAME_LENGTH){
        ASSERT(*lpdwNameSize <= NTMS_OBJECTNAME_LENGTH);
        result = ERROR_INVALID_PARAMETER;
    }
    else {    
        WCHAR wBufName[NTMS_OBJECTNAME_LENGTH];
        
        result = GetNtmsMediaPoolNameW(hSession, lpPoolId, wBufName, lpdwNameSize);
        if (result == ERROR_SUCCESS){
            WCharToAscii(lpBufName, wBufName, *lpdwNameSize);
        }
    }
    return result;
}

        
DWORD WINAPI MoveToNtmsMediaPool(   HANDLE hSession, 
                                    LPNTMS_GUID lpPhysMediaId, 
                                    LPNTMS_GUID lpPoolId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        PHYSICAL_MEDIA *physMedia;

        physMedia = FindPhysicalMedia(lpPhysMediaId);
        if (physMedia){
            MEDIA_POOL *destMediaPool;
            
            destMediaPool = FindMediaPool(lpPoolId);
            if (destMediaPool){

                result = MovePhysicalMediaToPool(destMediaPool, physMedia, FALSE);
               
                DerefObject(destMediaPool);
            }
            else {
                result = ERROR_INVALID_HANDLE;
            }

            DerefObject(physMedia);
        }
        else {
            result = ERROR_INVALID_HANDLE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI DeleteNtmsMediaPool(HANDLE hSession, LPNTMS_GUID lpPoolId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        MEDIA_POOL *mediaPool;

        mediaPool = FindMediaPool(lpPoolId);
        if (mediaPool){
            result = DeleteMediaPool(mediaPool);
            DerefObject(mediaPool);
        }
        else {
            result = ERROR_INVALID_MEDIA_POOL;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}

        
DWORD WINAPI AddNtmsMediaType(  HANDLE hSession,
                                LPNTMS_GUID lpMediaTypeId,
                                LPNTMS_GUID lpLibId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        LIBRARY *lib;

        lib = FindLibrary(lpLibId);
        if (lib){
            MEDIA_TYPE_OBJECT *mediaTypeObj;

            mediaTypeObj = FindMediaTypeObject(lpMediaTypeId);
            if (mediaTypeObj){
                /*
                 *  The media type is already defined.  Succeed.
                 */
                DerefObject(mediaTypeObj);
                result = ERROR_SUCCESS;
            }
            else {
                mediaTypeObj = NewMediaTypeObject(lib);
                if (mediaTypeObj){

                    // BUGBUG FINISH - create new standard media pools

                    result = ERROR_SUCCESS;
                }
                else {
                    result = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            
            DerefObject(lib);
        }
        else {
            result = ERROR_INVALID_LIBRARY;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI DeleteNtmsMediaType(   HANDLE hSession,
                                    LPNTMS_GUID lpMediaTypeId,
                                    LPNTMS_GUID lpLibId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        LIBRARY *lib;

        lib = FindLibrary(lpLibId);
        if (lib){
            MEDIA_TYPE_OBJECT *mediaTypeObj;

            mediaTypeObj = FindMediaTypeObject(lpMediaTypeId);
            if (mediaTypeObj){
                result = DeleteMediaTypeObject(mediaTypeObj);
                DerefObject(mediaTypeObj);
            }
            else {
                result = ERROR_INVALID_PARAMETER;
            }

            DerefObject(lib);
        }
        else {
            result = ERROR_INVALID_LIBRARY;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


/*
 *  ChangeNtmsMediaType
 *
 *      Move the media to the media pool and change the media's
 *      type to the pool's media type.
 */
DWORD WINAPI ChangeNtmsMediaType(   HANDLE hSession,
                                    LPNTMS_GUID lpMediaId,
                                    LPNTMS_GUID lpPoolId)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;
        PHYSICAL_MEDIA *physMedia;

        physMedia = FindPhysicalMedia(lpMediaId);
        if (physMedia){
            MEDIA_POOL *destMediaPool;
            
            destMediaPool = FindMediaPool(lpPoolId);
            if (destMediaPool){

                result = MovePhysicalMediaToPool(destMediaPool, physMedia, TRUE);
               
                DerefObject(destMediaPool);
            }
            else {
                result = ERROR_INVALID_HANDLE;
            }

            DerefObject(physMedia);
        }
        else {
            result = ERROR_INVALID_HANDLE;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI MountNtmsMedia(HANDLE hSession,
                            LPNTMS_GUID lpMediaOrPartitionIds,
                            IN OUT LPNTMS_GUID lpDriveIds,
                            DWORD dwCount,
                            DWORD dwOptions,
                            int dwPriority,
                            DWORD dwTimeout,
                            LPNTMS_MOUNT_INFORMATION lpMountInfo)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

        /*
         *  Validate that we can safely read the media and drive GUIDs
         *  that were passed in by the caller (this just verifies that the
         *  buffers are readable; it doesn't verify the GUIDs themselves).
         */
        if (ValidateBuffer(lpMediaOrPartitionIds, dwCount*sizeof(NTMS_GUID))){
            if (ValidateBuffer(lpDriveIds, dwCount*sizeof(NTMS_GUID))){
                WORKGROUP *workGroup;

                /*
                 *  Create a work group, which is a group of workItems,
                 *  to service each component of the mount.
                 */
                workGroup = NewWorkGroup();
                if (workGroup){
                    result = BuildMountWorkGroup( workGroup,
                                                lpMediaOrPartitionIds,
                                                lpDriveIds,
                                                dwCount,
                                                dwOptions,
                                                dwPriority);
                    if (result == ERROR_SUCCESS){

                        /*
                         *  Give the mount workItems to the library thread.
                         */
                        result = ScheduleWorkGroup(workGroup);
                        if (result == ERROR_SUCCESS){
                            DWORD waitRes;

                            /*
                             *  Wait for all the mounts to complete.
                             */
                            waitRes = WaitForSingleObject(workGroup->allWorkItemsCompleteEvent, dwTimeout);
                            if (waitRes == WAIT_TIMEOUT){
                                result = ERROR_TIMEOUT;
                            }
                            else {
                                result = workGroup->resultStatus;
                            }
                        }
                        
                        FreeWorkGroup(workGroup);
                    }
                }
                else {
                    result = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            else {
                result = ERROR_INVALID_DRIVE;
            }
        }
        else {
            result = ERROR_INVALID_MEDIA;
        }
    }
    else {
        result = ERROR_INVALID_HANDLE;
    }

    if (result != ERROR_SUCCESS){
       SetLastError(result);
    }
    return result;
}


DWORD WINAPI DismountNtmsMedia( HANDLE hSession,
                                LPNTMS_GUID lpMediaOrPartitionIds,
                                DWORD dwCount,
                                DWORD dwOptions)
{
    HRESULT result;

    if (ValidateSessionHandle(hSession)){
        SESSION *thisSession = (SESSION *)hSession;

        if (ValidateBuffer(lpMediaOrPartitionIds, dwCount*sizeof(NTMS_GUID))){
            WORKGROUP *workGroup;

            /*
             *  Create a work group, which is a group of workItems,
             *  to service each component of the mount.
             */
            workGroup = NewWorkGroup();
            if (workGroup){
                result = BuildDismountWorkGroup(  workGroup,
                                                lpMediaOrPartitionIds,
                                                dwCount,
                                                dwOptions);
                if (result == ERROR_SUCCESS){

                    /*
                     *  Give the mount workItems to the library thread.
                     */
                    result = ScheduleWorkGroup(workGroup);
                    if (result == ERROR_SUCCESS){
                        /*
                         *  Wait for all the mounts to complete.
                         */
                        WaitForSingleObject(workGroup->allWorkItemsCompleteEvent, INFINITE);
                        
                        result = workGroup->resultStatus;
                    }
                      