s because of endianness
#define HTTP_11_VERSION 0x312e312f50545448ui64
#define HTTP_10_VERSION 0x302e312f50545448ui64

//
// These are backwards because of little endian.
//

#define HTTP_PREFIX         'PTTH'
#define HTTP_PREFIX_SIZE    4
#define HTTP_PREFIX_MASK    0xdfdfdfdf

C_ASSERT((HTTP_PREFIX & HTTP_PREFIX_MASK) == HTTP_PREFIX);

#define HTTP_PREFIX1        '\0//:'
#define HTTP_PREFIX1_SIZE   3
#define HTTP_PREFIX1_MASK   0x00ffffff

C_ASSERT((HTTP_PREFIX1 & HTTP_PREFIX1_MASK) == HTTP_PREFIX1);

#define HTTP_PREFIX2        '//:S'
#define HTTP_PREFIX2_SIZE   4
#define HTTP_PREFIX2_MASK   0xffffffdf

C_ASSERT((HTTP_PREFIX2 & HTTP_PREFIX2_MASK) == HTTP_PREFIX2);

#define MAX_HEADER_LONG_COUNT           (3)
#define MAX_HEADER_LENGTH               (MAX_HEADER_LONG_COUNT * sizeof(ULONGLONG))

#define NUMBER_HEADER_INDICES           (26)

#define NUMBER_HEADER_HINT_INDICES      (9)

//
// Default Server: header if none provided by the application.
//

#define DEFAULT_SERVER_HDR          "Microsoft-HTTPAPI/1.0"
#define DEFAULT_SERVER_HDR_LENGTH   STRLEN_LIT(DEFAULT_SERVER_HDR)

//
// One second in 100ns system time units. Used for generating
// Date: headers.
//

#define ONE_SECOND                  (10000000)


//
// Structure of the fast verb lookup table. The table consists of a series of
// entries where each entry contains an HTTP verb represented as a ulonglong,
// a mask to use for comparing that verb, the length of the verb, and the
// translated id. This is used for all known verbs that are 7 characters
// or less.
//

typedef struct _FAST_VERB_ENTRY
{
    ULONGLONG   RawVerbMask;
    union
    {
        UCHAR       Char[sizeof(ULONGLONG)+1];
        ULONGLONG   LongLong;
    }           RawVerb;
    ULONG       RawVerbLength;
    HTTP_VERB   TranslatedVerb;

} FAST_VERB_ENTRY, *PFAST_VERB_ENTRY;

//
// Macro for defining fast verb table entries. Note that we don't subtract 1
// from the various sizeof occurences because we'd just have to add it back
// in to account for the separating space.
//

#define CREATE_FAST_VERB_ENTRY(verb)                                \
    {                                                               \
        (0xffffffffffffffffui64 >> ((8 - (sizeof(#verb))) * 8)),    \
        {#verb " "},                                                \
        (sizeof(#verb)),                                            \
        HttpVerb##verb                                              \
    }

//
// Stucture of the all verb lookup table. This table holds all verbs
// that are too long to fit in the fast verb table.
//

typedef struct _LONG_VERB_ENTRY
{
    ULONG       RawVerbLength;
    UCHAR       RawVerb[MAX_KNOWN_VERB_LENGTH];
    HTTP_VERB   TranslatedVerb;

} LONG_VERB_ENTRY, *PLONG_VERB_ENTRY;

//
// Macro for defining all long verb table entries.
//

#define CREATE_LONG_VERB_ENTRY(verb)                                \
    { sizeof(#verb) - 1,   #verb,  HttpVerb##verb }

//
// Header handler callback functions
//

typedef NTSTATUS (*PFN_SERVER_HEADER_HANDLER)(
                        PUL_INTERNAL_REQUEST    pRequest,
                        PUCHAR                  pHeader,
                        USHORT                  HeaderLength,
                        HTTP_HEADER_ID          HeaderID,
                        ULONG *                 pBytesTaken
                        );

typedef NTSTATUS (*PFN_CLIENT_HEADER_HANDLER)(
                    PUC_HTTP_REQUEST    pRequest,
                    PUCHAR              pHeader,
                    ULONG               HeaderLength,
                    HTTP_HEADER_ID      HeaderID
                    );


//
// Structure for a header map entry. Each header map entry contains a
// verb and a series of masks to use in checking that verb.
//

typedef struct _HEADER_MAP_ENTRY
{
    ULONG                      HeaderLength;
    ULONG                      ArrayCount;
    ULONG                      MinBytesNeeded;
    union
    {
        UCHAR                  HeaderChar[MAX_HEADER_LENGTH];
        ULONGLONG              HeaderLong[MAX_HEADER_LONG_COUNT];
    }                          Header;
    ULONGLONG                  HeaderMask[MAX_HEADER_LONG_COUNT];
    UCHAR                      MixedCaseHeader[MAX_HEADER_LENGTH];

    HTTP_HEADER_ID             HeaderID;
    BOOLEAN                    AutoGenerate;
    PFN_SERVER_HEADER_HANDLER  pServerHandler;
    PFN_CLIENT_HEADER_HANDLER  pClientHandler;
    LONG                       HintIndex;

}  HEADER_MAP_ENTRY, *PHEADER_MAP_ENTRY;


//
// Structure for a header index table entry.
//

typedef struct _HEADER_INDEX_ENTRY
{
    PHEADER_MAP_ENTRY   pHeaderMap;
    ULONG               Count;

} HEADER_INDEX_ENTRY, *PHEADER_INDEX_ENTRY;


//
// Structure for a header hint index table entry.
//

typedef struct _HEADER_HINT_INDEX_ENTRY
{
    PHEADER_MAP_ENTRY   pHeaderMap;
    UCHAR               c;

} HEADER_HINT_INDEX_ENTRY, *PHEADER_HINT_INDEX_ENTRY, **PPHEADER_HINT_INDEX_ENTRY;


//
// A (complex) macro to create a mask for a header map entry,
// given the header length and the mask offset (in bytes). This
// mask will need to be touched up for non-alphabetic characters.
//

#define UPCASE_MASK 0xDFDFDFDFDFDFDFDFui64

#define CREATE_HEADER_MASK(hlength, maskoffset) \
    ((hlength) > (maskoffset) ? UPCASE_MASK : \
        (((maskoffset) - (hlength)) >= 8 ? 0 : \
        (UPCASE_MASK >> ( ((maskoffset) - (hlength)) * 8ui64))))


//
// Macro for creating header map entries. The mask entries are created
// by the init code.
//

#define CREATE_HEADER_MAP_ENTRY(header, ID, auto, serverhandler, clienthandler, HintIndex)\
{                                                        \
    sizeof(#header) - 1,                                 \
    ((sizeof(#header) - 1) / 8) +                        \
        (((sizeof(#header) - 1) % 8) == 0 ? 0 : 1),      \
    (((sizeof(#header) - 1) / 8) +                       \
        (((sizeof(#header) - 1) % 8) == 0 ? 0 : 1)) * 8, \
    { #header },                                         \
    { 0, 0, 0},                                          \
    { #header },                                         \
    ID,                                                  \
    auto,                                                \
    serverhandler,                                       \
    clienthandler,                                       \
    HintIndex                                            \
}

//
// Parser states for parsing a chunk header extension.
//
typedef enum
{
    CHStart,
    CHSeenCR,
    CHInChunkExtName,
    CHSeenChunkExtNameAndEquals,
    CHInChunkExtValToken,
    CHInChunkExtValQuotedString,
    CHSeenChunkExtValQuotedStringTerminator,
    CHSuccess,
    CHError
} CH_PARSER_STATE, *PCH_PARSER_STATE;

//
// Parser states for parsing message header field content.
//
typedef enum
{
    HFCStart,
    HFCSeenCR,
    HFCSeenLF,
    HFCSeenCRLF,
    HFCFolding,
    HFCInQuotedString
} HFC_PARSER_STATE, *PHFC_PARSER_STATE;

//
// Parser states for parsing a quoted string.
//
typedef enum
{
    QSInString,
    QSSeenBackSlash,
    QSSeenCR,
    QSSeenLF,
    QSSeenCRLF,
    QSFolding
} QS_PARSER_STATE, *PQS_PARSER_STATE;

//
// External variables.
//

extern ULONG g_RequestHeaderMap[HttpHeaderMaximum];
extern ULONG g_ResponseHeaderMap[HttpHeaderMaximum];

extern HEADER_MAP_ENTRY g_RequestHeaderMapTable[];
extern HEADER_MAP_ENTRY g_ResponseHeaderMapTable[];

extern HEADER_INDEX_ENTRY g_RequestHeaderIndexTable[];
extern HEADER_INDEX_ENTRY g_ResponseHeaderIndexTable[];

extern HEADER_HINT_INDEX_ENTRY g_RequestHeaderHintIndexTable[];

//
// Function prototypes.
// 

PUCHAR
FindHexToken(
    IN  PUCHAR pBuffer,
    IN  ULONG  BufferLength,
    OUT ULONG  *TokenLength
    );

NTSTATUS 
InitializeParser(
        VOID
        );

ULONG
UlpParseHttpVersion(
    PUCHAR pString,
    ULONG  StringLength,
    PHTTP_VERSION pVersion
    );

NTSTATUS
FindHeaderEndReadOnly(
    IN  PUCHAR                  pHeader,
    IN  ULONG                   HeaderLength,
    OUT PULONG                  pBytesTaken
    );

NTSTATUS
FindHeaderEnd(
    IN  PUCHAR                  pHeader,
    IN  ULONG                   HeaderLength,
    OUT PULONG                  pBytesTaken
    );

NTSTATUS
FindRequestHeaderEnd(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHeader,
    IN  ULONG                   HeaderLength,
    OUT PULONG                  pBytesTaken
    );

NTSTATUS
FindChunkHeaderEnd(
    IN  PUCHAR                  pHeader,
    IN  ULONG                   HeaderLength,
    OUT PULONG                  pBytesTaken
    );

NTSTATUS
ParseChunkLength(
    IN  ULONG       FirstChunkParsed,
    IN  PUCHAR      pBuffer,
    IN  ULONG       BufferLength,
    OUT PULONG      pBytesTaken,
    OUT PULONGLONG  pChunkLength
    );

NTSTATUS
ParseQuotedString(
    IN  PUCHAR   pInput,
    IN  ULONG    InputLength,
    IN  PUCHAR   pOutput,
    OUT PULONG   pBytesTaken
    );

#endif // _PARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\proc.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    proc.h

Abstract:

    This module contains routine prototypes for UL.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _PROC_H_
#define _PROC_H_


//
// Device driver entry routine from INIT.C.
//

EXTERN_C
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );


//
// IRP handlers from various modules.
//

NTSTATUS
UlCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UlClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UlCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UlDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UlEtwDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// Fast IO handler from DEVCTRL.C.
//

BOOLEAN
UlFastDeviceControl(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );


//
// Global data initialization/termination from DATA.C.
//

NTSTATUS
UlInitializeData(
    PUL_CONFIG pConfig
    );

VOID
UlTerminateData(
    VOID
    );


//
// Utility functions from MISC.C.
//

NTSTATUS
UlOpenRegistry(
    IN PUNICODE_STRING BaseName,
    OUT PHANDLE ParametersHandle,
    IN PWSTR OptionalParameterString    
    );

LONG
UlReadLongParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    );

LONGLONG
UlReadLongLongParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONGLONG DefaultValue
    );

NTSTATUS
UlReadGenericParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION * Value
    );

VOID
UlBuildDeviceControlIrp(
    IN OUT PIRP Irp,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN PMDL MdlAddress,
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID CompletionContext,
    IN PETHREAD TargetThread OPTIONAL
    );

PSTR
UlULongLongToAscii(
    IN PSTR String,
    IN ULONGLONG Value
    );

NTSTATUS
_RtlIntegerToUnicode(
    IN ULONG Integer,
    IN ULONG Base OPTIONAL,
    IN LONG BufferLength,
    OUT PWSTR pBuffer
    );

__inline
NTSTATUS
UlAnsiToULongLong(
    PUCHAR      pString,
    USHORT      StringLength,
    ULONG       Base,
    PULONGLONG  pValue
    )
{
    ASSERT(StringLength > 0);

    return HttpAnsiStringToULongLong(
                pString,
                StringLength,
                TRUE,   // LeadingZerosAllowed
                Base,
                NULL,   // ppTerminator
                pValue
                );
}

__inline
NTSTATUS
UlUnicodeToULongLong(
    PWCHAR      pString,
    USHORT      StringLength,
    ULONG       Base,
    PULONGLONG  pValue
    )
{
    ASSERT(StringLength > 0);

    return HttpWideStringToULongLong(
                pString,
                StringLength,
                TRUE,   // LeadingZerosAllowed
                Base,
                NULL,   // ppTerminator
                pValue
                );
}

NTSTATUS
UlIssueDeviceControl(
    IN PUX_TDI_OBJECT pTdiObject,
    IN PVOID pIrpParameters,
    IN ULONG IrpParametersLength,
    IN PVOID pMdlBuffer OPTIONAL,
    IN ULONG MdlBufferLength OPTIONAL,
    IN UCHAR MinorFunction
    );

/***************************************************************************++

Routine Description:

    Invokes the completion routine (if specified) and determines the
    appropriate return code. This routine ensures that, if the completion
    routine is invoked, the caller always returns STATUS_PENDING.

Arguments:

    Status - Supplies the completion status.

    Information - Optionally supplies additional information about
        the completed operation, such as the number of bytes
        transferred.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the listening endpoint is fully closed.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

Return Value:

    NTSTATUS - Completion status. Will always be STATUS_PENDING if the
        completion routine is invoked.

--***************************************************************************/
__inline
NTSTATUS
UlInvokeCompletionRoutine(
    IN NTSTATUS Status,
    IN ULONG_PTR Information,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    )
{
    if (pCompletionRoutine != NULL)
    {
        (pCompletionRoutine)(
            pCompletionContext,
            Status,
            Information
            );

        Status = STATUS_PENDING;
    }

    return Status;

}   // UlInvokeCompletionRoutine


//
// Initialize a TA_IP_ADDRESS[6] structure.
//

#define UlInitializeIpTransportAddress( ta, inaddr, port )              \
    do {                                                                \
        RtlZeroMemory( (ta), sizeof(*(ta)) );                           \
        (ta)->TAAddressCount = 1;                                       \
        (ta)->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;         \
        (ta)->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;             \
        (ta)->Address[0].Address[0].in_addr = (inaddr);                 \
        (ta)->Address[0].Address[0].sin_port = (USHORT) (port);         \
    } while (0, 0)

#define UlInitializeIp6TransportAddress( ta, in6addr, port, scope_id)   \
    do {                                                                \
        RtlZeroMemory( (ta), sizeof(*(ta)) );                           \
        (ta)->TAAddressCount = 1;                                       \
        (ta)->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP6;        \
        (ta)->Address[0].AddressType = TDI_ADDRESS_TYPE_IP6;            \
        RtlCopyMemory((ta)->Address[0].Address[0].sin6_addr,            \
                      (in6addr),                                        \
                      sizeof(in6addr));                                 \
        (ta)->Address[0].Address[0].sin6_port = (USHORT) (port);        \
        (ta)->Address[0].Address[0].sin6_flowinfo = 0;                  \
        (ta)->Address[0].Address[0].sin6_scope_id = (scope_id);         \
    } while (0, 0)


//
// IRP context manipulators.
//

__inline
PUL_IRP_CONTEXT
UlPplAllocateIrpContext(
    VOID
    )
{
    PUL_IRP_CONTEXT pContext;

    pContext = (PUL_IRP_CONTEXT)
        PplAllocate(g_pUlNonpagedData->IrpContextLookaside);

    if (pContext)
    {
        ASSERT(pContext->Signature == UL_IRP_CONTEXT_SIGNATURE_X);
        pContext->Signature = UL_IRP_CONTEXT_SIGNATURE;
    }

    return pContext;
}

__inline
VOID
UlPplFreeIrpContext(
    PUL_IRP_CONTEXT pContext
    )
{
    ASSERT(HAS_VALID_SIGNATURE(pContext, UL_IRP_CONTEXT_SIGNATURE));

    pContext->Signature = UL_IRP_CONTEXT_SIGNATURE_X;
    PplFree(g_pUlNonpagedData->IrpContextLookaside, pContext);
}

PVOID
UlAllocateIrpContextPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    );

VOID
UlFreeIrpContextPool(
    IN PVOID pBuffer
    );


//
// Buffer allocators.
//

__inline
PUL_RECEIVE_BUFFER
UlPplAllocateReceiveBuffer(
    VOID
    )
{
    PUL_RECEIVE_BUFFER pBuffer;

    pBuffer = (PUL_RECEIVE_BUFFER)
        PplAllocate(g_pUlNonpagedData->ReceiveBufferLookaside);

    if (pBuffer)
    {
        ASSERT(pBuffer->Signature == UL_RECEIVE_BUFFER_SIGNATURE_X);
        pBuffer->Signature = UL_RECEIVE_BUFFER_SIGNATURE;
    }

    return pBuffer;
}

__inline
VOID
UlPplFreeReceiveBuffer(
    PUL_RECEIVE_BUFFER pBuffer
    )
{
    ASSERT(HAS_VALID_SIGNATURE(pBuffer, UL_RECEIVE_BUFFER_SIGNATURE));

    pBuffer->Signature = UL_RECEIVE_BUFFER_SIGNATURE_X;
    PplFree(g_pUlNonpagedData->ReceiveBufferLookaside, pBuffer);
}

PVOID
UlAllocateReceiveBuffer(
    IN CCHAR IrpStackSize
    );

PVOID
UlAllocateReceiveBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    );

VOID
UlFreeReceiveBufferPool(
    IN PVOID pBuffer
    );


//
// Request buffer allocators.
//

__inline
PUL_REQUEST_BUFFER
UlPplAllocateRequestBuffer(
    VOID
    )
{
    PUL_REQUEST_BUFFER pBuffer;

    pBuffer = (PUL_REQUEST_BUFFER)
        PplAllocate(g_pUlNonpagedData->RequestBufferLookaside);

    if (pBuffer)
    {
        ASSERT(pBuffer->Signature == MAKE_FREE_TAG(UL_REQUEST_BUFFER_POOL_TAG));
        pBuffer->Signature = UL_REQUEST_BUFFER_POOL_TAG;
    }

    return pBuffer;
}

__inline
VOID
UlPplFreeRequestBuffer(
    PUL_REQUEST_BUFFER pBuffer
    )
{
    ASSERT(HAS_VALID_SIGNATURE(pBuffer, UL_REQUEST_BUFFER_POOL_TAG));

    pBuffer->Signature = MAKE_FREE_TAG(UL_REQUEST_BUFFER_POOL_TAG);
    PplFree(g_pUlNonpagedData->RequestBufferLookaside, pBuffer);
}

PVOID
UlAllocateRequestBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    );

VOID
UlFreeRequestBufferPool(
    IN PVOID pBuffer
    );


//
// Internal request buffer allocators.
//

__inline
PUL_INTERNAL_REQUEST
UlPplAllocateInternalRequest(
    VOID
    )
{
    PUL_INTERNAL_REQUEST pRequest;

    pRequest = (PUL_INTERNAL_REQUEST)
        PplAllocate(g_pUlNonpagedData->InternalRequestLookaside);

    if (pRequest)
    {
        ASSERT(pRequest->Signature ==
            MAKE_FREE_TAG(UL_INTERNAL_REQUEST_POOL_TAG));
        pRequest->Signature = UL_INTERNAL_REQUEST_POOL_TAG;
    }

    return pRequest;
}

__inline
VOID
UlPplFreeInternalRequest(
    PUL_INTERNAL_REQUEST pRequest
    )
{
    ASSERT(HAS_VALID_SIGNATURE(pRequest, UL_INTERNAL_REQUEST_POOL_TAG));

    pRequest->Signature = MAKE_FREE_TAG(UL_INTERNAL_REQUEST_POOL_TAG);
    PplFree(g_pUlNonpagedData->InternalRequestLookaside, pRequest);
}

PVOID
UlAllocateInternalRequestPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    );

VOID
UlFreeInternalRequestPool(
    IN PVOID pBuffer
    );


//
// Chunk tracker allocators.
//

__inline
PUL_CHUNK_TRACKER
UlPplAllocateChunkTracker(
    VOID
    )
{
    PUL_CHUNK_TRACKER pTracker;

    pTracker = (PUL_CHUNK_TRACKER)
        PplAllocate(g_pUlNonpagedData->ChunkTrackerLookaside);

    if (pTracker)
    {
        ASSERT(pTracker->Signature == MAKE_FREE_TAG(UL_CHUNK_TRACKER_POOL_TAG));
        pTracker->Signature = UL_CHUNK_TRACKER_POOL_TAG;
    }

    return pTracker;
}

__inline
VOID
UlPplFreeChunkTracker(
    PUL_CHUNK_TRACKER pTracker
    )
{
    ASSERT(HAS_VALID_SIGNATURE(pTracker, UL_CHUNK_TRACKER_POOL_TAG));

    pTracker->Signature = MAKE_FREE_TAG(UL_CHUNK_TRACKER_POOL_TAG);
    PplFree(g_pUlNonpagedData->ChunkTrackerLookaside, pTracker);
}

PVOID
UlAllocateChunkTrackerPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    );

VOID
UlFreeChunkTrackerPool(
    IN PVOID pBuffer
    );


//
// Full tracker allocators.
//

__inline
PUL_FULL_TRACKER
UlPplAllocateFullTracker(
    VOID
    )
{
    PUL_FULL_TRACKER pTracker;

    pTracker = (PUL_FULL_TRACKER)
        PplAllocate(g_pUlNonpagedData->FullTrackerLookaside);

    if (pTracker)
    {
        ASSERT(pTracker->Signature == MAKE_FREE_TAG(UL_FULL_TRACKER_POOL_TAG));
        pTracker->Signature = UL_FULL_TRACKER_POOL_TAG;
    }

    return pTracker;
}

__inline
VOID
UlPplFreeFullTracker(
    PUL_FULL_TRACKER pTracker
    )
{
    ASSERT(HAS_VALID_SIGNATURE(pTracker, UL_FULL_TRACKER_POOL_TAG));

    pTracker->Signature = MAKE_FREE_TAG(UL_FULL_TRACKER_POOL_TAG);
    PplFree(g_pUlNonpagedData->FullTrackerLookaside, pTracker);
}

PVOID
UlAllocateFullTrackerPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    );

VOID
UlFreeFullTrackerPool(
    IN PVOID pBuffer
    );


//
// Internal response buffer allocators.
//

__inline
PUL_INTERNAL_RESPONSE
UlPplAllocateResponseBuffer(
    VOID
    )
{
    PUL_INTERNAL_RESPONSE pResponse;

    pResponse = (PUL_INTERNAL_RESPONSE)
        PplAllocate(g_pUlNonpagedData->ResponseBufferLookaside);

    if (pResponse)
    {
        ASSERT(pResponse->Signature ==
            MAKE_FREE_TAG(UL_INTERNAL_RESPONSE_POOL_TAG));
        pResponse->Signature = UL_INTERNAL_RESPONSE_POOL_TAG;
    }

    return pResponse;
}

__inline
VOID
UlPplFreeResponseBuffer(
    PUL_INTERNAL_RESPONSE pResponse
    )
{
    ASSERT(HAS_VALID_SIGNATURE(pResponse, UL_INTERNAL_RESPONSE_POOL_TAG));

    pResponse->Signature = MAKE_FREE_TAG(UL_INTERNAL_RESPONSE_POOL_TAG);
    PplFree(g_pUlNonpagedData->ResponseBufferLookaside, pResponse);
}

PVOID
UlAllocateResponseBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    );

VOID
UlFreeResponseBufferPool(
    IN PVOID pBuffer
    );


//
// Log file buffer allocators.
//

__inline
PUL_LOG_FILE_BUFFER
UlPplAllocateLogFileBuffer(
    VOID
    )
{
    PUL_LOG_FILE_BUFFER pBuffer;

    PAGED_CODE();

    pBuffer = (PUL_LOG_FILE_BUFFER)
        PplAllocate(g_pUlNonpagedData->LogFileBufferLookaside);

    if (pBuffer)
    {
        ASSERT(pBuffer->Signature ==
            MAKE_FREE_TAG(UL_LOG_FILE_BUFFER_POOL_TAG));
        pBuffer->Signature = UL_LOG_FILE_BUFFER_POOL_TAG;
    }

    return pBuffer;
}

__inline
VOID
UlPplFreeLogFileBuffer(
    IN PUL_LOG_FILE_BUFFER pBuffer
    )
{
    PAGED_CODE();
    ASSERT(IS_VALID_LOG_FILE_BUFFER(pBuffer));

    pBuffer->BufferUsed = 0;
    pBuffer->Signature = MAKE_FREE_TAG(UL_LOG_FILE_BUFFER_POOL_TAG);

    PplFree(g_pUlNonpagedData->LogFileBufferLookaside, pBuffer);
}

PVOID
UlAllocateLogFileBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    );

VOID
UlFreeLogFileBufferPool(
    IN PVOID pBuffer
    );

//
// Log data buffer allocators 
//

__inline
PUL_LOG_DATA_BUFFER
UlPplAllocateLogDataBuffer(
    BOOLEAN Binary
    )
{
    PUL_LOG_DATA_BUFFER pBuffer;
    HANDLE Lookaside;
    ULONG Tag;

    PAGED_CODE();

    if (Binary)
    {
        Tag = UL_BINARY_LOG_DATA_BUFFER_POOL_TAG;
        Lookaside = g_pUlNonpagedData->BinaryLogDataBufferLookaside;
    }
    else
    {
        Tag = UL_ANSI_LOG_DATA_BUFFER_POOL_TAG;
        Lookaside = g_pUlNonpagedData->AnsiLogDataBufferLookaside;
    }

    pBuffer = (PUL_LOG_DATA_BUFFER) PplAllocate(Lookaside);

    if (pBuffer)
    {
        ASSERT(pBuffer->Signature == MAKE_FREE_TAG(Tag));
        pBuffer->Signature = Tag;
        pBuffer->Used = 0;
    }

    return pBuffer;
}

__inline
VOID
UlPplFreeLogDataBuffer(
    IN PUL_LOG_DATA_BUFFER pBuffer
    )
{
    HANDLE Lookaside;
    ULONG Tag;

    PAGED_CODE();
    ASSERT(IS_VALID_LOG_DATA_BUFFER(pBuffer));

    if (pBuffer->Flags.Binary)
    {
        Tag = UL_BINARY_LOG_DATA_BUFFER_POOL_TAG;
        Lookaside = g_pUlNonpagedData->BinaryLogDataBufferLookaside;
    }
    else
    {
        Tag = UL_ANSI_LOG_DATA_BUFFER_POOL_TAG;
        Lookaside = g_pUlNonpagedData->AnsiLogDataBufferLookaside;
    }

    pBuffer->Used = 0;
    pBuffer->Signature = MAKE_FREE_TAG(Tag);

    PplFree(Lookaside, pBuffer);    
}

PVOID
UlAllocateLogDataBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    );

VOID
UlFreeLogDataBufferPool(
    IN PVOID pBuffer
    );

//
// Error logging buffer allocaters and de-allocators
//

__inline
PUL_ERROR_LOG_BUFFER
UlPplAllocateErrorLogBuffer(
    VOID
    )
{
    PUL_ERROR_LOG_BUFFER pBuffer;
    HANDLE Lookaside = g_pUlNonpagedData->ErrorLogBufferLookaside;

    PAGED_CODE();

    UlTrace(ERROR_LOGGING,("Http!UlPplAllocateErrorLogBuffer:  <LOOKASIDE>\n"));

    pBuffer = (PUL_ERROR_LOG_BUFFER) PplAllocate(Lookaside);

    if (pBuffer)
    {
        ASSERT(pBuffer->Signature == 
                MAKE_FREE_TAG(UL_ERROR_LOG_BUFFER_POOL_TAG));
        
        pBuffer->Signature = UL_ERROR_LOG_BUFFER_POOL_TAG;
        pBuffer->Used      = 0;
    }

    return pBuffer;
}

__inline
VOID
UlPplFreeErrorLogBuffer(
    IN PUL_ERROR_LOG_BUFFER pBuffer
    )
{
    HANDLE Lookaside = g_pUlNonpagedData->ErrorLogBufferLookaside;

    PAGED_CODE();
    ASSERT(IS_VALID_ERROR_LOG_BUFFER(pBuffer));

    pBuffer->Used = 0;
    pBuffer->Signature = MAKE_FREE_TAG(UL_ERROR_LOG_BUFFER_POOL_TAG);

    PplFree(Lookaside, pBuffer);    
}


PVOID
UlAllocateErrorLogBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    );

VOID
UlFreeErrorLogBufferPool(
    IN PVOID pBuffer
    );


//
// Trivial macro that should probably be in ntos\inc\io.h.
//

#define UlUnmarkIrpPending( Irp ) ( \
    IoGetCurrentIrpStackLocation( (Irp) )->Control &= ~SL_PENDING_RETURNED )


#endif  // _PROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\precomp.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This is the local header file for HTTP.SYS. It includes all other
    necessary header files for HTTP.SYS.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#define __HTTP_SYS__


//
// We are willing to ignore the following warnings, as we need the DDK to 
// compile.
//

#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4214)   // bit field types other than int

// 
// We'll also ignore the following for now - to work around the do/while 
// problem with macros.
//
#pragma warning(disable:4127)   // condition expression is constant



//
// System include files.
//


// Need this hack until somebody expose
// the QoS Guids in a kernel lib.
#ifndef INITGUID
#define INITGUID
#endif

#define PsThreadType _PsThreadType_
#include <ntosp.h>
#undef PsThreadType
extern POBJECT_TYPE *PsThreadType;

#include <seopaque.h>
#include <sertlp.h>

#include <zwapi.h>

#include <ntddtcp.h>
#include <ipexport.h>
#include <tdikrnl.h>
#include <tdiinfo.h>
#include <tcpinfo.h>
#include <ntddip6.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sspi.h>
#include <secint.h>
#include <winerror.h>

//
// NT QoS Stuff Related Include files
//
#include <wmistr.h>
#include <ntddndis.h>
#include <qos.h>
#include <traffic.h>
#include <Ipinfo.h>
#include <Llinfo.h>

#include <ntddtc.h>
#include <gpcifc.h>
#include <gpcstruc.h>

#include <netevent.h>

#include <iiscnfg.h>


//
// Force the memxxx() functions to be intrinsics so we can build
// the driver even if MSC_OPTIMIZATION=/Od is specified. This is
// necessary because the memxxx() functions are not exported by
// NTOSKRNL.
//

#pragma intrinsic( memcmp, memcpy, memset )

#include <SockDecl.h>

//
// Project include files.
//


#include "config.h"
#include "strlog.h"
#include "debug.h"

#include <HttpCmn.h>
#include <Utf8.h>
#include <C14n.h>

#include <httpkrnl.h>
#include <httppkrnl.h>
#include <httpioctl.h>

// Local include files.
//

#pragma warning( disable: 4200 )    //  zero-length arrays


#include "hashfn.h"
#include "notify.h"
#include "rwlock.h"
#include "type.h"
#include "tracelog.h"
#include "reftrace.h"
#include "irptrace.h"
#include "timetrace.h"
#include "largemem.h"
#include "mdlutil.h"
#include "opaqueid.h"
#include "httptdi.h"
#include "thrdpool.h"
#include "filterp.h"
#include "filter.h"
#include "ioctl.h"
#include "cgroup.h"
#include "misc.h"
#include "cache.h"
#include "data.h"
#include "logutil.h"
#include "ullog.h"
#include "rawlog.h"
#include "errlog.h"
#include "pplasl.h"
#include "httptypes.h"
#include "ultdi.h"
#include "ultdip.h"
#include "httprcv.h"
#include "engine.h"
#include "ucauth.h"
#include "sendrequest.h"
#include "parse.h"
#include "ulparse.h"
#include "ucparse.h"
#include "apool.h"
#include "httpconn.h"
#include "filecache.h"
#include "sendresponse.h"
#include "proc.h"
#include "opaqueidp.h"
#include "control.h"
#include "ultci.h"
#include "counters.h"
#include "seutil.h"
#include "ultcip.h"
#include "fastio.h"
#include "uletw.h"
#include "timeouts.h"
#include "hash.h"
#include "bugcheck.h"
#include "clientconn.h"
#include "servinfo.h"
#include "uctdi.h"
#include "ucrcv.h"
#include "uctrace.h"
#include "ucaction.h"
#include "devctrl.h"
#include "scavenger.h"
#include "ulnamesp.h"

// BUGBUG: should not need to declare these

NTKERNELAPI
VOID
SeOpenObjectAuditAlarm (
    IN PUNICODE_STRING ObjectTypeName,
    IN PVOID Object OPTIONAL,
    IN PUNICODE_STRING AbsoluteObjectName OPTIONAL,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PACCESS_STATE AccessState,
    IN BOOLEAN ObjectCreated,
    IN BOOLEAN AccessGranted,
    IN KPROCESSOR_MODE AccessMode,
    OUT PBOOLEAN GenerateOnClose
    );


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\rawlog.c ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    rawlog.c (HTTP.SYS Binary Logging)

Abstract:

    This module implements the centralized raw logging 
    format. Internet Binary Logs (file format).

Author:

    Ali E. Turkoglu (aliTu)       04-Oct-2001

Revision History:

    --- 

--*/

#include "precomp.h"
#include "rawlogp.h"

//
// Generic Private globals.
//

UL_BINARY_LOG_FILE_ENTRY g_BinaryLogEntry;

ULONG g_BinaryLogEntryCount = 0;

BOOLEAN g_InitBinaryLogCalled = FALSE;


#ifdef ALLOC_PRAGMA

#pragma alloc_text( INIT, UlInitializeBinaryLog )
#pragma alloc_text( PAGE, UlpCreateBinaryLogFile )
#pragma alloc_text( PAGE, UlpDisableBinaryEntry )
#pragma alloc_text( PAGE, UlpRecycleBinaryLogFile )
#pragma alloc_text( PAGE, UlCaptureRawLogData )
#pragma alloc_text( PAGE, UlpRawCopyLogHeader )
#pragma alloc_text( PAGE, UlpRawCopyLogFooter )
#pragma alloc_text( PAGE, UlpRawCopyForLogCacheMiss )
#pragma alloc_text( PAGE, UlRawLogHttpHit )
#pragma alloc_text( PAGE, UlpRawCopyForLogCacheHit )
#pragma alloc_text( PAGE, UlRawLogHttpCacheHit )
#pragma alloc_text( PAGE, UlpWriteToRawLogFileShared )
#pragma alloc_text( PAGE, UlpWriteToRawLogFileExclusive )
#pragma alloc_text( PAGE, UlpWriteToRawLogFile )
#pragma alloc_text( PAGE, UlpBinaryBufferTimerHandler )
#pragma alloc_text( PAGE, UlHandleCacheFlushedNotification )
#pragma alloc_text( PAGE, UlpEventLogRawWriteFailure )
#pragma alloc_text( PAGE, UlpWriteToRawLogFileDebug )

#endif // ALLOC_PRAGMA

#if 0

NOT PAGEABLE -- UlpBinaryLogTimerDpcRoutine
NOT PAGEABLE -- UlpBinaryLogBufferTimerDpcRoutine
NOT PAGEABLE -- UlpBinaryLogTimerHandler
NOT PAGEABLE -- UlCreateBinaryLogEntry
NOT PAGEABLE -- UlTerminateBinaryLog

#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Init the global binary logging entry and its fields.
    
--***************************************************************************/

NTSTATUS
UlInitializeBinaryLog (
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(!g_InitBinaryLogCalled);

    if (!g_InitBinaryLogCalled)
    {
        //
        // Init the global binary logging entry.
        //

        RtlZeroMemory(
            (PCHAR)&g_BinaryLogEntry, sizeof(UL_BINARY_LOG_FILE_ENTRY));
        
        g_BinaryLogEntry.Signature = UL_BINARY_LOG_FILE_ENTRY_POOL_TAG;        

        UlInitializePushLock(
            &g_BinaryLogEntry.PushLock,
            "BinaryLogEntryPushLock",
            0,
            UL_BINARY_LOG_FILE_ENTRY_POOL_TAG
            );
        
        // Initialize the Recycle timer

        g_BinaryLogEntry.Timer.Initialized = TRUE;
        g_BinaryLogEntry.Timer.Started     = FALSE;        
        g_BinaryLogEntry.Timer.Period      = -1;
        g_BinaryLogEntry.Timer.PeriodType  = UlLogTimerPeriodNone;

        UlInitializeSpinLock(
            &g_BinaryLogEntry.Timer.SpinLock, "BinaryLogEntryTimerSpinlock");
        
        KeInitializeDpc(
            &g_BinaryLogEntry.Timer.DpcObject,
            &UlpBinaryLogTimerDpcRoutine,
            NULL
            );

        KeInitializeTimer(&g_BinaryLogEntry.Timer.Timer);

        // Initialize the buffer flush timer
        
        g_BinaryLogEntry.BufferTimer.Initialized = TRUE;
        g_BinaryLogEntry.BufferTimer.Started    = FALSE;        
        g_BinaryLogEntry.BufferTimer.Period    = -1;
        g_BinaryLogEntry.BufferTimer.PeriodType  = UlLogTimerPeriodNone;

        UlInitializeSpinLock(
            &g_BinaryLogEntry.BufferTimer.SpinLock, 
            "BinaryLogEntryBufferTimerSpinLock" );
        
        KeInitializeDpc(
            &g_BinaryLogEntry.BufferTimer.DpcObject,    // DPC object
            &UlpBinaryBufferTimerDpcRoutine,          // DPC routine
            NULL                         // context
            );

        KeInitializeTimer(&g_BinaryLogEntry.BufferTimer.Timer);
        
        UlInitializeWorkItem(&g_BinaryLogEntry.WorkItem);

        g_InitBinaryLogCalled = TRUE;
                    
        UlTrace(BINARY_LOGGING,
              ("Http!UlInitializeBinaryLog: g_BinaryLogEntry @ (%p) .\n",
                &g_BinaryLogEntry
                ));
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    Terminates the binary logging entry and its fields.
    
--***************************************************************************/

VOID
UlTerminateBinaryLog(
    VOID
    )
{
    KIRQL OldIrql;    

    if (g_InitBinaryLogCalled)
    {
        PUL_LOG_TIMER pTimer = &g_BinaryLogEntry.Timer;
        PUL_LOG_TIMER pBufferTimer = &g_BinaryLogEntry.BufferTimer;

        //
        // Terminate the recycle timer 
        //
        UlAcquireSpinLock(&pTimer->SpinLock, &OldIrql);

        pTimer->Initialized = FALSE;

        KeCancelTimer(&pTimer->Timer);
        
        UlReleaseSpinLock(&pTimer->SpinLock, OldIrql);

        UlAcquireSpinLock(&pBufferTimer->SpinLock, &OldIrql);

        pBufferTimer->Initialized = FALSE;

        KeCancelTimer(&pBufferTimer->Timer);
        
        UlReleaseSpinLock(&pBufferTimer->SpinLock, OldIrql);

        //
        // Delete the push lock
        //
        UlDeletePushLock(&g_BinaryLogEntry.PushLock);
        
        g_InitBinaryLogCalled = FALSE;
    }
}

/***************************************************************************++

Routine Description:

    Queues a passive worker for the lowered irql.

Arguments:

    Ignored

--***************************************************************************/

VOID
UlpBinaryBufferTimerDpcRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )
{
    PUL_LOG_TIMER pTimer = &g_BinaryLogEntry.BufferTimer;
    PUL_WORK_ITEM pWorkItem = NULL;

    //
    // Parameters are ignored.
    //
    
    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(DeferredContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);
        
    UlAcquireSpinLockAtDpcLevel(&pTimer->SpinLock);

    if (pTimer->Initialized == TRUE)
    {
        //
        // It's not possible to acquire the resource which protects
        // the binary entry at DISPATCH_LEVEL therefore we will queue
        // a work item for this.
        //

        pWorkItem = (PUL_WORK_ITEM) UL_ALLOCATE_POOL(
            NonPagedPool,
            sizeof(*pWorkItem),
            UL_WORK_ITEM_POOL_TAG
            );
        if (pWorkItem)
        {
            UlInitializeWorkItem(pWorkItem);
            UL_QUEUE_WORK_ITEM(pWorkItem, &UlpBinaryBufferTimerHandler);
        }
        else
        {
            UlTrace(BINARY_LOGGING,
            ("Http!UlBinaryLogBufferTimerDpcRoutine: Not enough memory.\n"));
        }
    }

    UlReleaseSpinLockFromDpcLevel(&pTimer->SpinLock);   
}

/***************************************************************************++

Routine Description:

    Flushes or recycles the binary log file.

Arguments:

    PUL_WORK_ITEM - Ignored but cleaned up at the end

--***************************************************************************/

VOID
UlpBinaryBufferTimerHandler(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUL_BINARY_LOG_FILE_ENTRY pEntry = &g_BinaryLogEntry;

    PAGED_CODE();

    UlTrace(BINARY_LOGGING,
       ("Http!UlpBinaryBufferTimerHandler: Checking the BinaryLogEntry. \n"));

    UlAcquirePushLockExclusive(&pEntry->PushLock);
    
    if (pEntry->Flags.Active)
    {    
        if (pEntry->Flags.RecyclePending)
        {                
            //
            // Try to resurrect it back.
            //
            
            Status = UlpRecycleBinaryLogFile(pEntry);
        }
        else
        {
            //
            // Everything is fine simply flush.
            //

            if (NULL != pEntry->LogBuffer && 0 != pEntry->LogBuffer->BufferUsed)
            {
                Status = UlpFlushRawLogFile(pEntry);
            }            
            else
            {
                //
                // Inactivity management. Update the counter. 
                // If entry was inactive over 15 minutes, close it.
                //

                ASSERT( pEntry->TimeToClose > 0 );
                
                if (pEntry->TimeToClose == 1)
                {                    
                    if (pEntry->Period == HttpLoggingPeriodMaxSize)
                    {
                        pEntry->Flags.StaleSequenceNumber = 1;
                    }
                    else
                    {
                        pEntry->Flags.StaleTimeToExpire = 1;    
                    }

                    Status = UlpDisableBinaryEntry(pEntry);
                }
                else
                {
                    pEntry->TimeToClose -= 1;
                }                    
            }            
        }
    }

    UlReleasePushLockExclusive(&pEntry->PushLock);

    //
    // Free the memory allocated (ByDpcRoutine above) for
    // this work item.
    //

    UL_FREE_POOL(pWorkItem, UL_WORK_ITEM_POOL_TAG);
}

/***************************************************************************++

Routine Description:

    Allocates and queues a work item to do the the actual work at lowered irql

Arguments:

    Ignored

--***************************************************************************/

VOID
UlpBinaryLogTimerDpcRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )
{
    PUL_LOG_TIMER pTimer = &g_BinaryLogEntry.Timer;
    PUL_WORK_ITEM pWorkItem = &g_BinaryLogEntry.WorkItem;

    //
    // Parameters are ignored.
    //
    
    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(DeferredContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    UlAcquireSpinLockAtDpcLevel(&pTimer->SpinLock);

    if (pTimer->Initialized == TRUE)
    {
        UL_QUEUE_WORK_ITEM(pWorkItem, &UlpBinaryLogTimerHandler);
    }

    UlReleaseSpinLockFromDpcLevel(&pTimer->SpinLock);   
}

/***************************************************************************++

Routine Description:

    Passive worker for the BinaryLog recycling.

Arguments:

    PUL_WORK_ITEM  -  Ignored.

--***************************************************************************/

VOID
UlpBinaryLogTimerHandler(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    NTSTATUS Status;
    KIRQL    OldIrql;
    BOOLEAN  Picked = FALSE;
    PUL_BINARY_LOG_FILE_ENTRY pEntry = &g_BinaryLogEntry;

    UNREFERENCED_PARAMETER(pWorkItem);

    UlTrace(BINARY_LOGGING,
        ("\nHttp!UlpBinaryLogTimerHandler: Recycling ...\n\n"));

    UlAcquirePushLockExclusive(&pEntry->PushLock);

    switch(pEntry->Timer.PeriodType)
    {
        case UlLogTimerPeriodGMT:            
        Picked = TRUE; // TODO: (pEntry->Flags.LocaltimeRollover == 0);
        break;

        case UlLogTimerPeriodLocal:
        Picked = FALSE;
        break;

        case UlLogTimerPeriodBoth:
        Picked = TRUE;
        break;

        default:
        ASSERT(!"Unexpected timer period type !\n");
        break;
    }

    if (Picked == TRUE &&
        pEntry->Flags.Active &&
        pEntry->Period != HttpLoggingPeriodMaxSize
        )
    {            
        if (pEntry->TimeToExpire == 1)
        {
            //
            // Disable the entry and postpone the recycle to the next
            // incoming request. Lazy file creation.
            //
            
            pEntry->Flags.StaleTimeToExpire = 1;

            Status = UlpDisableBinaryEntry(pEntry);            
        }
        else
        {
            //
            // Decrement the hourly counter.
            //
            
            pEntry->TimeToExpire -= 1; 
        }            
    }

    //
    // CODEWORK:
    // When we start handling multiple binary log file  entries and the 
    // pEntry is no longer pointing to a global static , following  set 
    // needs to be moved to the inside the lock.See ullog.c for similar 
    // usage.
    //
    
    UlReleasePushLockExclusive(&pEntry->PushLock);    

    //
    // Now reset the timer for the next hour.
    //

    UlAcquireSpinLock(&pEntry->Timer.SpinLock, &OldIrql);

    if (pEntry->Timer.Initialized == TRUE)
    {
        UlSetLogTimer(&pEntry->Timer);
    }
    
    UlReleaseSpinLock(&pEntry->Timer.SpinLock, OldIrql);

}

/***************************************************************************++

Routine Description:

    When logging configuration happens we init the entry but do not create the
    binary log file itself yet. That will be created when the first request 
    comes in. Please look at UlpCreateBinaryLogFile.
    
Arguments:

    pControlChannel - Supplies the necessary information for constructing the
                   log file entry.
                   
    pUserConfig  - Binary Logging config from the user.

--***************************************************************************/

NTSTATUS
UlCreateBinaryLogEntry(
    IN OUT PUL_CONTROL_CHANNEL pControlChannel,
    IN     PHTTP_CONTROL_CHANNEL_BINARY_LOGGING pUserConfig
    )
{
    KIRQL OldIrql;
    NTSTATUS Status = STATUS_SUCCESS;
    PUL_BINARY_LOG_FILE_ENTRY  pEntry = &g_BinaryLogEntry;
    PHTTP_CONTROL_CHANNEL_BINARY_LOGGING pConfig;
        
    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(IS_VALID_CONTROL_CHANNEL(pControlChannel));
    
    // TODO: We have to handle multiple binary log files.

    if (0 != InterlockedExchange((PLONG)&g_BinaryLogEntryCount, 1))
    {
        return STATUS_NOT_SUPPORTED;
    }

    UlAcquirePushLockExclusive(&pEntry->PushLock);

    ASSERT(pControlChannel->pBinaryLogEntry == NULL);

    //
    // Save the user logging info to the control channel.
    // Mark the state of the control channel binary logging.
    //

    pControlChannel->BinaryLoggingConfig = *pUserConfig;
    pConfig = &pControlChannel->BinaryLoggingConfig;
        
    pConfig->LogFileDir.Buffer =
            (PWSTR) UL_ALLOCATE_ARRAY(
                PagedPool,
                UCHAR,
                pConfig->LogFileDir.MaximumLength,
                UL_CG_LOGDIR_POOL_TAG
                );
    if (pConfig->LogFileDir.Buffer == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    RtlCopyMemory(
        pConfig->LogFileDir.Buffer,
        pUserConfig->LogFileDir.Buffer,
        pUserConfig->LogFileDir.MaximumLength
        );

    pConfig->Flags.Present  = 1;
    pConfig->LoggingEnabled = TRUE;

    //
    // Now set the fields on the binary log entry accordingly.
    //

    pEntry->Period       = (HTTP_LOGGING_PERIOD) pConfig->LogPeriod;
    pEntry->TruncateSize = pConfig->LogFileTruncateSize;

    pEntry->TimeToExpire   = 0;
    pEntry->TimeToClose    = DEFAULT_MAX_FILE_IDLE_TIME;    
    pEntry->SequenceNumber = 1;
    pEntry->TotalWritten.QuadPart = (ULONGLONG) 0;

    //
    // Start the recycle timer as soon as the binary logging 
    // settings get configured. And buffer flush timer as well
    //
    
    UlAcquireSpinLock(&pEntry->Timer.SpinLock,&OldIrql);
    if (pEntry->Timer.Started == FALSE)
    {
        UlSetLogTimer(&pEntry->Timer);
        pEntry->Timer.Started = TRUE;
    }
    UlReleaseSpinLock(&pEntry->Timer.SpinLock,OldIrql);

    UlAcquireSpinLock(&pEntry->BufferTimer.SpinLock, &OldIrql);
    if (pEntry->BufferTimer.Started == FALSE)
    {
        UlSetBufferTimer(&pEntry->BufferTimer);
        pEntry->BufferTimer.Started = TRUE;
    }
    UlReleaseSpinLock(&pEntry->BufferTimer.SpinLock, OldIrql);

    //
    // Now remember the binary log entry in the control channel.
    //

    pControlChannel->pBinaryLogEntry = pEntry;

    UlTrace(BINARY_LOGGING,("Http!UlCreateBinaryLogEntry: pEntry %p for %S\n",
             pEntry,
             pConfig->LogFileDir.Buffer
             ));
    
end:
    if (!NT_SUCCESS(Status))
    {
        UlTrace(BINARY_LOGGING,
               ("Http!UlCreateBinaryLogEntry: dir %S failure %08lx\n",
                 pConfig->LogFileDir.Buffer,
                 Status
                 ));

        //
        // Restore the logging disabled state on the control channel, 
        // free the memory which was allocated for the dir.
        //
        
        if (pConfig->LogFileDir.Buffer)
        {
            UL_FREE_POOL(pConfig->LogFileDir.Buffer,
                          UL_CG_LOGDIR_POOL_TAG
                          );
        }
        pConfig->LogFileDir.Buffer = NULL;

        ASSERT(pControlChannel->pBinaryLogEntry == NULL);

        pConfig->Flags.Present  = 0;
        pConfig->LoggingEnabled = FALSE;        
    }

    UlReleasePushLockExclusive(&pEntry->PushLock);

    return Status;
}

/***************************************************************************++

Routine Description:

    Create a new binary log file or open an existing one. The fully qualified
    file name should be in the binary log entry.
    
Arguments:

    pEntry : Corresponding entry that we are closing and opening 
             the log files for.

    pDirectory : User passed directory which is stored in the control channel
              
--***************************************************************************/

NTSTATUS
UlpCreateBinaryLogFile(
    IN OUT PUL_BINARY_LOG_FILE_ENTRY pEntry,
    IN     PUNICODE_STRING           pDirectory
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_BINARY_LOG_FILE_ENTRY(pEntry));
    ASSERT(pDirectory);

    UlTrace(BINARY_LOGGING,
            ("Http!UlpCreateBinaryLogFile: pEntry %p\n", pEntry));

    //
    // Build the fully qualified file name.
    //
    
    Status = UlRefreshFileName(pDirectory, 
                                 &pEntry->FileName,
                                 &pEntry->pShortName
                                 );
    if (!NT_SUCCESS(Status))
    {
        return Status;  
    }

    //
    // SequenceNumber is stale because we have to scan the existing  directory 
    // the first time we open a file. TimeToExpire is stale because we need to
    // calculate the it for the first time.
    //
    
    pEntry->Flags.StaleSequenceNumber = 1;    
    pEntry->Flags.StaleTimeToExpire   = 1;

    //
    // After that Recycle does the whole job for us.
    //
    
    Status = UlpRecycleBinaryLogFile(pEntry);

    if (!NT_SUCCESS(Status))
    {        
        UlTrace(BINARY_LOGGING,
               ("Http!UlpCreateBinaryLogFile: Filename: %S Failure %08lx\n",
                pEntry->FileName.Buffer,
                Status
                ));
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    Writes an event log to system log for log file write failure.

    Entry pushlock should be acquired exclusive prior to calling this function.
    
Arguments:

    pEntry  - Log file entry
    Status  - Result of last write

--***************************************************************************/

VOID
UlpEventLogRawWriteFailure(
    IN PUL_BINARY_LOG_FILE_ENTRY pEntry,
    IN NTSTATUS Status
    )
{
    NTSTATUS TempStatus = STATUS_SUCCESS;
    PWSTR    StringList[1];

    //
    // Sanity Check.
    //

    PAGED_CODE();
    
    ASSERT(IS_VALID_BINARY_LOG_FILE_ENTRY(pEntry));

    //
    // There should better be a failure.
    //
    
    ASSERT(!NT_SUCCESS(Status));

    //
    // Bail out if we have already logged the event failure.
    //

    if (pEntry->Flags.WriteFailureLogged)
    {
        return;
    }

    //
    // Report the centralized binary log file name.
    //

    ASSERT(pEntry->pShortName);
    ASSERT(pEntry->pShortName[0] == L'\\');
    
    StringList[0] = (PWSTR) (pEntry->pShortName + 1); // Skip the L'\'

    TempStatus = UlWriteEventLogEntry(
                  (NTSTATUS)EVENT_HTTP_LOGGING_BINARY_FILE_WRITE_FAILED,
                   0,
                   1,
                   StringList,
                   sizeof(NTSTATUS),
                   (PVOID) &Status
                   );

    ASSERT(TempStatus != STATUS_BUFFER_OVERFLOW);
        
    if (TempStatus == STATUS_SUCCESS)
    {            
        pEntry->Flags.WriteFailureLogged = 1;
    }            
    
    UlTrace(LOGGING,(
            "Http!UlpEventLogRawWriteFailure: Event Logging Status %08lx\n",
            TempStatus
            ));
}

/***************************************************************************++

Routine Description:

    Simple wrapper function around global buffer flush.
    
Arguments:

    pEntry - Binary Log file entry

--***************************************************************************/

NTSTATUS
UlpFlushRawLogFile(
    IN PUL_BINARY_LOG_FILE_ENTRY  pEntry
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    ASSERT(IS_VALID_BINARY_LOG_FILE_ENTRY(pEntry));

    if (NULL != pEntry->LogBuffer  && 0 != pEntry->LogBuffer->BufferUsed)
    {
        Status = UlFlushLogFileBuffer(
                   &pEntry->LogBuffer,
                    pEntry->pLogFile,
                    (BOOLEAN)pEntry->Flags.HeaderFlushPending,
                   &pEntry->TotalWritten.QuadPart                    
                    );

        if (!NT_SUCCESS(Status))
        {
            UlpEventLogRawWriteFailure(pEntry, Status); 
        }
        else
        {
            //
            // If we successfully flushed. Reset the event log indication.
            //
            
            pEntry->Flags.WriteFailureLogged = 0;
        }    

        if (pEntry->Flags.HeaderFlushPending)
        {
            pEntry->Flags.HeaderFlushPending = 0;

            if (!NT_SUCCESS(Status))
            {
                //
                // We need to recopy the header, it couldn't make it
                // to the log file yet.
                //
                pEntry->Flags.HeaderWritten = 0;
            }
        }

        //
        // Buffer flush means activity, Reset the TimeToClose counter.
        //

        pEntry->TimeToClose = DEFAULT_MAX_FILE_IDLE_TIME;        
    }
    
    return Status;
}

/***************************************************************************++

Routine Description:

    Marks the entry inactive, closes the existing file.
    Caller should hold the log list eresource exclusive.
    
Arguments:

    pEntry - The log file entry which we will mark inactive.

--***************************************************************************/

NTSTATUS
UlpDisableBinaryEntry(
    IN OUT PUL_BINARY_LOG_FILE_ENTRY pEntry
    )
{
    //
    // Sanity checks
    //
    
    PAGED_CODE();

    ASSERT(IS_VALID_BINARY_LOG_FILE_ENTRY(pEntry));

    UlTrace(BINARY_LOGGING,
        ("Http!UlpDisableBinaryEntry: pEntry %p disabled.\n",
          pEntry
          ));    
    
    //
    // Flush and close the old file until the next recycle.
    //

    if (pEntry->pLogFile)
    {    
        UlpFlushRawLogFile(pEntry);
    
        UlCloseLogFile(
            &pEntry->pLogFile
            );
    }

    //
    // Mark this inactive so that the next http hit awakens the entry.
    //
    
    pEntry->Flags.Active = 0;

    //
    // Init served cache for a new file.
    //

    InterlockedExchange((PLONG) &pEntry->ServedCacheHit, 0);

    //
    // Once we closed the old file, we have to traverse through
    // the Uri Cache and UNMARK all the IndexWritten flags. 
    //

    UlClearCentralizedLogged(pEntry);    

    return STATUS_SUCCESS;    
}

/***************************************************************************++

Routine Description:

    Small wrapper around handle recycle to ensure it happens under the system
    process context. 

Arguments:

    pEntry  - Points to the existing entry.

--***************************************************************************/

NTSTATUS
UlpRecycleBinaryLogFile(
    IN OUT PUL_BINARY_LOG_FILE_ENTRY pEntry
    )
{
    NTSTATUS Status;

    PAGED_CODE();

    ASSERT(IS_VALID_BINARY_LOG_FILE_ENTRY(pEntry));
    
    Status = UlQueueLoggingRoutine(
                (PVOID) pEntry,
                &UlpHandleBinaryLogFileRecycle
                );
    
    return Status;
}

/***************************************************************************++

Routine Description:

    This function requires to have the entry resource to be acquired.

    Sometimes it may be necessary to scan the new directory to figure out
    the correct sequence number and the file name. Especially after a dir
    name reconfig.

Arguments:

    pEntry  - Points to the binary log file entry

--***************************************************************************/

NTSTATUS
UlpHandleBinaryLogFileRecycle(
    IN OUT PVOID            pContext
    )
{
    NTSTATUS                Status;
    PUL_BINARY_LOG_FILE_ENTRY pEntry;
    TIME_FIELDS             TimeFields;
    LARGE_INTEGER           TimeStamp;
    PUL_LOG_FILE_HANDLE     pLogFile;
    WCHAR                   _FileName[UL_MAX_FILE_NAME_SUFFIX_LENGTH + 1];
    UNICODE_STRING          FileName;
    BOOLEAN                 UncShare;
    BOOLEAN                 ACLSupport;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pEntry = (PUL_BINARY_LOG_FILE_ENTRY) pContext;
    ASSERT(IS_VALID_BINARY_LOG_FILE_ENTRY(pEntry));

    Status   = STATUS_SUCCESS;
    pLogFile = NULL;

    FileName.Buffer        = _FileName;
    FileName.Length        = 0;
    FileName.MaximumLength = sizeof(_FileName);
        
    //
    // We have two criterions for the log file name
    // its LogFormat and its LogPeriod
    //

    ASSERT(pEntry->Period < HttpLoggingPeriodMaximum);
    ASSERT(pEntry->FileName.Length !=0 );

    UlTrace( BINARY_LOGGING, 
        ("Http!UlpHandleBinaryLogFileRecycle: pEntry %p \n", pEntry ));

    //
    // This value is computed for the GMT time zone.
    //

    KeQuerySystemTime(&TimeStamp);
    RtlTimeToTimeFields(&TimeStamp, &TimeFields);

    //
    // If we need to scan the directory. Sequence number should start
    // from 1 again. Set this before constructing the log file name.
    //
    
    if (pEntry->Flags.StaleSequenceNumber &&
        pEntry->Period==HttpLoggingPeriodMaxSize)
    {
        //
        // Init otherwise if QueryDirectory doesn't find any files
        // in the provided directory, this will not get properly 
        // initialized.
        //
        pEntry->SequenceNumber = 1;
    }

    //
    // Use binary logging settings when constructing the filename.
    //

    UlConstructFileName(
        pEntry->Period,
        BINARY_LOG_FILE_NAME_PREFIX,
        BINARY_LOG_FILE_NAME_EXTENSION,
        &FileName,
        &TimeFields,
        FALSE,
        &pEntry->SequenceNumber
        );

    if (pEntry->FileName.MaximumLength <= FileName.Length)
    {
        ASSERT(!"FileName buffer is not sufficient.");
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // Do the magic and renew the filename. Replace the old file
    // name with the new one.
    //

    ASSERT(pEntry->pShortName != NULL);
    
    //
    // Get rid of the old filename before scanning the
    // directories.
    //

    *((PWCHAR)pEntry->pShortName) = UNICODE_NULL;
    pEntry->FileName.Length =
        (USHORT) wcslen(pEntry->FileName.Buffer) * sizeof(WCHAR);

    //
    // Create/Open the director(ies) first. This might be
    // necessary if we get called after an entry reconfiguration
    // and directory name change or for the first time we 
    // try to create/open the binary log file.
    //

    Status = UlCreateSafeDirectory(&pEntry->FileName, 
                                      &UncShare,
                                      &ACLSupport
                                      );
    if (!NT_SUCCESS(Status))
        goto eventlog;

    //
    // Now Restore the short file name pointer back
    //

    pEntry->pShortName = (PWSTR)
        &(pEntry->FileName.Buffer[pEntry->FileName.Length/sizeof(WCHAR)]);

    //
    // Append the new file name ( based on the updated current time )
    // to the end.
    //

    Status = RtlAppendUnicodeStringToString( &pEntry->FileName, &FileName );
    if (!NT_SUCCESS(Status))
        goto end;

    //
    // Time to close the old file and reopen a new one
    //

    if (pEntry->pLogFile != NULL)
    {
        //
        // Flush,close and mark the entry inactive.
        //

        UlpDisableBinaryEntry(pEntry);        
    }

    ASSERT(pEntry->pLogFile == NULL);

    //
    // If the sequence is stale because of the nature of the recycle.
    // And if our period is size based then rescan the new directory
    // to figure out the proper file to open.
    // 

    pEntry->TotalWritten.QuadPart = (ULONGLONG) 0;

    if (pEntry->Flags.StaleSequenceNumber &&
        pEntry->Period==HttpLoggingPeriodMaxSize)
    {
        // This call may update the filename, the file size and the
        // sequence number if there is an old file in the new dir.

        Status = UlQueryDirectory(
                   &pEntry->FileName,
                    pEntry->pShortName,
                    BINARY_LOG_FILE_NAME_PREFIX,
                    BINARY_LOG_FILE_NAME_EXTENSION_PLUS_DOT,
                   &pEntry->SequenceNumber,
                   &pEntry->TotalWritten.QuadPart
                    );
        if (!NT_SUCCESS(Status))
        {
            if (Status == STATUS_ACCESS_DENIED)
            {
                Status = STATUS_INVALID_OWNER;
                goto eventlog;
            }
            else
            {
                goto end;
            }
        }
    }

    //
    // Allocate a new log file structure for the new log file we are
    // about to open or create.
    //
    
    pLogFile = pEntry->pLogFile = 
        UL_ALLOCATE_STRUCT(
                NonPagedPool,
                UL_LOG_FILE_HANDLE,
                UL_LOG_FILE_HANDLE_POOL_TAG
                );
    if (pLogFile == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    pLogFile->Signature = UL_LOG_FILE_HANDLE_POOL_TAG;
    pLogFile->hFile = NULL;
    UlInitializeWorkItem(&pLogFile->WorkItem);

    //
    // Create the new log file.
    //
    
    Status = UlCreateLogFile(&pEntry->FileName,
                               UncShare,
                               ACLSupport,
                               &pLogFile->hFile
                               );    
    if (!NT_SUCCESS(Status))
    {
        goto eventlog;
    }

    ASSERT(pLogFile->hFile);    
    pEntry->TotalWritten.QuadPart = UlGetLogFileLength(pLogFile->hFile);

    //
    // Recalculate the time to expire.
    //
    
    if (pEntry->Flags.StaleTimeToExpire &&
        pEntry->Period != HttpLoggingPeriodMaxSize)
    {
        UlCalculateTimeToExpire(
            &TimeFields,
             pEntry->Period,
            &pEntry->TimeToExpire
             );
    }

    //
    // Set the time to close to default for a new file. The value is in
    // buffer flushup periods. Basically 15 minutes.
    //

    pEntry->TimeToClose = DEFAULT_MAX_FILE_IDLE_TIME;

    //
    // File is successfully opened and the entry is no longer inactive.
    // Update our state flags accordingly.
    //

    pEntry->Flags.Active = 1;
    pEntry->Flags.RecyclePending = 0;    
    pEntry->Flags.StaleSequenceNumber = 0;
    pEntry->Flags.StaleTimeToExpire = 0;
    pEntry->Flags.HeaderWritten = 0;
    pEntry->Flags.CreateFileFailureLogged = 0;
    pEntry->Flags.WriteFailureLogged = 0;
    pEntry->Flags.HeaderFlushPending = 0;
                
    UlTrace(BINARY_LOGGING,  
             ("Http!UlpHandleBinaryLogFileRecycle: entry %p, file %S, handle %lx\n",
               pEntry,
               pEntry->FileName.Buffer,
               pLogFile->hFile
               ));
    
eventlog:    
    if (!NT_SUCCESS(Status))
    {
        if (!pEntry->Flags.CreateFileFailureLogged)
        {
            NTSTATUS TempStatus;

            TempStatus = UlEventLogCreateFailure(
                            Status,
                            UlEventLogBinary,
                            &pEntry->FileName,
                            0
                            );
                                                        
            if (TempStatus == STATUS_SUCCESS)
            {
                //
                // Avoid filling up the event log with error entries. This code 
                // path might get hit every time a request arrives.
                //
                
                pEntry->Flags.CreateFileFailureLogged = 1;
            }            
            
            UlTrace(LOGGING,(
                    "Http!UlpHandleBinaryLogFileRecycle: Event Logging Status %08lx\n",
                    TempStatus
                    ));   
       }
   }
    
end:
    if (!NT_SUCCESS(Status))
    {
        UlTrace(BINARY_LOGGING, 
            ("Http!UlpHandleBinaryLogFileRecycle: entry %p, failure %08lx\n",
              pEntry,
              Status
              ));

        if (pLogFile != NULL)
        {
            //
            // This means we have alread closed the old file but failed
            // when we try to create or open the new one.
            //
            
            ASSERT(pLogFile->hFile == NULL);
            
            UL_FREE_POOL_WITH_SIG(pLogFile,UL_LOG_FILE_HANDLE_POOL_TAG);
            pEntry->pLogFile = NULL;
            pEntry->Flags.Active = 0;
        }
        else
        {
            //
            // We were about to recyle the old one but something failed
            // lets try to flush and close the existing file if it's still
            // around.
            //

            if (pEntry->pLogFile)
            {
                UlpDisableBinaryEntry(pEntry);        
            }
        }

        //
        // Mark this entry RecyclePending so that buffer timer can try to
        // resurrect this back every minute.
        //
        
        pEntry->Flags.RecyclePending = 1;        
    }
    
    return Status;
}

/***************************************************************************++

Routine Description:

    Allocates a new log data buffer and captures the user log data into this
    buffer in a format suitable for binary logging.

    WARNING:
    Even though the pLogFields is already captured to the kernel buffer, it
    still holds pointers to user-mode memory for individual log fields,
    therefore this function should be called inside a try/except block and
    if exception happens, caller should cleanup the possibly allocated pLogData
    structure (*ppLogData is always set when we allocate one)
    
Arguments:

    pLogFields  - User provided logging information, it will be used to build
                some part of the binary logging record. It is already captured
                to kernel buffer.

    pRequest    - Pointer to the currently logged request.

    ppLogData   - Returning the allocated pLogData.
        
--***************************************************************************/

NTSTATUS
UlCaptureRawLogData(
    IN  PHTTP_LOG_FIELDS_DATA pLogFields,
    IN  PUL_INTERNAL_REQUEST  pRequest,
    OUT PUL_LOG_DATA_BUFFER   *ppLogData
    )
{
    PUL_LOG_DATA_BUFFER pLogData = NULL;
    PUL_BINARY_LOG_DATA pBinaryData = NULL;    
    ULONG   RawDataSize  = 0;
    USHORT  UriStemSize  = 0;
    USHORT  UriQuerySize = 0;
    USHORT  UserNameSize = 0;
    PUCHAR  pByte;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
       
    *ppLogData = NULL;

    //
    // Calculate the required buffer size for the variable size strings.
    // And either allocate from the lookaside list or from pool.
    //

    /* UriStem */

    if (pLogFields->UriStemLength)
    {
        UriStemSize  = MIN(pLogFields->UriStemLength,MAX_LOG_EXTEND_FIELD_LEN);
        RawDataSize += UriStemSize;    
    }        
    
    /* UriQuery */
    
    if (pLogFields->UriQueryLength)
    {            
        UriQuerySize = MIN(pLogFields->UriQueryLength,MAX_LOG_EXTEND_FIELD_LEN);        
        RawDataSize += UriQuerySize;
    }

    /* UserName */
    
    if (pLogFields->UserNameLength)
    {
        UserNameSize = MIN(pLogFields->UserNameLength,MAX_LOG_USERNAME_FIELD_LEN);        
        RawDataSize += UserNameSize;
    }
    
    if (RawDataSize > UL_BINARY_LOG_LINE_BUFFER_SIZE)
    {
        ASSERT(RawDataSize <= 
            (2 * MAX_LOG_EXTEND_FIELD_LEN + MAX_LOG_USERNAME_FIELD_LEN));
    
        //
        // Provided buffer is not big enough to hold the user data.        
        //

        pLogData = UlReallocLogDataBuffer(RawDataSize,TRUE);
    }
    else
    {        
        //
        // Default id enough, try to pop it from the lookaside list.
        //
        
        pLogData = UlPplAllocateLogDataBuffer(TRUE);
    }

    //
    // If failed to allocate then bail out. We won't be logging this request.
    //

    if (!pLogData)
    {
        return STATUS_INSUFFICIENT_RESOURCES;        
    }

    ASSERT(pLogData->Flags.Binary == 1);
    ASSERT(pLogData->Size > 0);

    ASSERT(IS_VALID_LOG_DATA_BUFFER(pLogData));
    pBinaryData = &pLogData->Data.Binary;
    
    //
    // Initialize necessary log fields in the Log Buffer
    //

    UL_REFERENCE_INTERNAL_REQUEST(pRequest);
    pLogData->pRequest  = pRequest;
    *ppLogData = pLogData;
    
    pLogData->Flags.CacheAndSendResponse = 0;
    pLogData->BytesTransferred = 0;

    UlInitializeWorkItem(&pLogData->WorkItem);
    
    pLogData->Used = (USHORT) RawDataSize;
        
    //
    // Capture the fields from the user data.
    //
    
    pBinaryData->Method  = pLogFields->MethodNum;
    
    pBinaryData->Version = 
        (UCHAR) UlpHttpVersionToBinaryLogVersion(pRequest->Version);
    
    pLogData->Win32Status    = pLogFields->Win32Status;
    pLogData->ProtocolStatus = pLogFields->ProtocolStatus;
    pLogData->SubStatus      = pLogFields->SubStatus;
    pLogData->ServerPort     = pLogFields->ServerPort;

    //
    // No indexing for cache-miss case.
    //
    
    pBinaryData->pUriStemID  = NULL;

    //
    // Copy string fields to the kernel buffer.
    //
    
    pByte = pLogData->Line;

    if (UriStemSize)
    {
        pBinaryData->pUriStem = pByte;
        pBinaryData->UriStemSize = UriStemSize;

        RtlCopyMemory(
            pByte,
            pLogFields->UriStem,
            UriStemSize
            );
        
        pByte += UriStemSize;        
    }
    else
    {
        pBinaryData->pUriStem = NULL;
        pBinaryData->UriStemSize = 0;        
    }    

    if (UriQuerySize)
    {
        pBinaryData->pUriQuery = pByte;
        pBinaryData->UriQuerySize = UriQuerySize;        
    
        RtlCopyMemory(
            pByte,
            pLogFields->UriQuery,
            UriQuerySize
            );
        
        pByte += UriQuerySize;
    }
    else
    {
        pBinaryData->pUriQuery = NULL;
        pBinaryData->UriQuerySize = 0;
    }

    if (UserNameSize)
    {
        pBinaryData->pUserName = pByte;
        pBinaryData->UserNameSize = UserNameSize;        
    
        RtlCopyMemory(
            pByte,
            pLogFields->UserName,
            UserNameSize
            );
        
        pByte += UserNameSize;
    }    
    else
    {
        pBinaryData->pUserName = NULL;
        pBinaryData->UserNameSize = 0;
    }
        
    UlTrace(BINARY_LOGGING,
        ("Http!UlInitAndCaptureRawLogData: pLogData %p \n",pLogData));
    
    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    Copies the header to the binary log file.

Arguments:

    pBuffer - Pointer to the file buffer. PVOID aligned.    
        
--***************************************************************************/

ULONG
UlpRawCopyLogHeader(
    IN PUCHAR pBuffer
    )
{
    PHTTP_RAW_FILE_HEADER pHeader = NULL;
    PUCHAR pCurrentBufferPtr = NULL;
 
    PAGED_CODE();

    ASSERT(pBuffer);
    
    UlTrace(BINARY_LOGGING, 
        ("Http!UlpRawCopyLogHeader: pBuffer %p\n", pBuffer ));

    ASSERT(pBuffer == ALIGN_UP_POINTER(pBuffer,PVOID));
        
    pCurrentBufferPtr = pBuffer;
    
    pHeader = (PHTTP_RAW_FILE_HEADER) pBuffer;

    pHeader->RecordType   = HTTP_RAW_RECORD_HEADER_TYPE;
    
    pHeader->MinorVersion = MINOR_RAW_LOG_FILE_VERSION;
    pHeader->MajorVersion = MAJOR_RAW_LOG_FILE_VERSION;

    pHeader->AlignmentSize = sizeof(PVOID);

    KeQuerySystemTime( &pHeader->DateTime );

    // TODO: BUGBUG need a KErnel API to get this similar to GetComputerNameA.
    // TODO: Currently we read from registry.

    wcsncpy(
      pHeader->ComputerName,g_UlComputerName, (MAX_COMPUTER_NAME_LEN - 1));

    pHeader->ComputerName[MAX_COMPUTER_NAME_LEN - 1] = UNICODE_NULL;

    pCurrentBufferPtr += sizeof(HTTP_RAW_FILE_HEADER);

    ASSERT(pCurrentBufferPtr == 
            (PUCHAR) ALIGN_UP_POINTER(pCurrentBufferPtr, PVOID));
    
    return DIFF(pCurrentBufferPtr-pBuffer);
}


/***************************************************************************++

Routine Description:

    Copies the footer to the binary log file.

Arguments:

    pBuffer - Pointer to the file buffer. PVOID aligned.    
        
--***************************************************************************/

ULONG
UlpRawCopyLogFooter(
    IN PUCHAR pBuffer
    )
{
    PHTTP_RAW_FILE_FOOTER pFooter = NULL;
    PUCHAR pCurrentBufferPtr = NULL;
        
    PAGED_CODE();

    ASSERT(pBuffer);
    
    UlTrace(BINARY_LOGGING, 
        ("Http!UlpRawCopyLogFooter: pBuffer %p\n", pBuffer ));

    ASSERT(pBuffer == ALIGN_UP_POINTER(pBuffer,PVOID));
        
    pCurrentBufferPtr = pBuffer;
    
    pFooter = (PHTTP_RAW_FILE_FOOTER) pBuffer;

    pFooter->RecordType = HTTP_RAW_RECORD_FOOTER_TYPE;    

    KeQuerySystemTime( &pFooter->DateTime );
    
    pCurrentBufferPtr += sizeof(HTTP_RAW_FILE_HEADER);

    ASSERT(pCurrentBufferPtr == 
            (PUCHAR) ALIGN_UP_POINTER(pCurrentBufferPtr, PVOID));
    
    return DIFF(pCurrentBufferPtr-pBuffer);
}

/***************************************************************************++

Routine Description:

    Receives a pointer to the file buffer. ( IT MUST BE PVOID ALIGNED )

    And copies the index records and the data record.

    When copying the index records, string size is aligned up to PVOID. As a
    result there MAY be padding characters between the index records and the
    data record.
    
Arguments:

    pContext  - It should be a LogData pointer for cache-miss hits.
    
    pBuffer   - Pointer to the file buffer. PVOID aligned.
    
    BytesRequired - Total number of bytes to be written.
        
        
--***************************************************************************/

VOID
UlpRawCopyForLogCacheMiss(
    IN PVOID   pContext,
    IN PUCHAR  pBuffer,
    IN ULONG   BytesRequired
    )
{
    PHTTP_RAW_FILE_MISS_LOG_DATA pRecord;
    PUL_BINARY_LOG_DATA pBinaryData;
    PUL_INTERNAL_REQUEST pRequest;  
    PUL_LOG_DATA_BUFFER pLogData;
    PUL_CONNECTION pConnection;
    PUCHAR pCurrentBufferPtr;
    LONGLONG LifeTime;
    LARGE_INTEGER CurrentTimeStamp;
    ULONG IPAddressSize;

    UNREFERENCED_PARAMETER(BytesRequired);

    //
    // Sanity Checks.
    //
    
    PAGED_CODE();

    ASSERT(pContext);
    ASSERT(pBuffer == (PUCHAR) ALIGN_UP_POINTER(pBuffer,PVOID));
    ASSERT(BytesRequired);

    pLogData = (PUL_LOG_DATA_BUFFER) pContext;    
    ASSERT(IS_VALID_LOG_DATA_BUFFER(pLogData));

    UlTrace(BINARY_LOGGING, 
        ("Http!UlpRawCopyForLogCacheMiss: pLogData %p\n", pLogData ));
    
    pBinaryData = &pLogData->Data.Binary;

    pRequest = pLogData->pRequest;
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    
    //
    // Cast back the pointer to the file buffer to the record type 
    // pointer for cache-miss and fill in the fields in the record.
    //

    pCurrentBufferPtr = pBuffer;

    pRecord = (PHTTP_RAW_FILE_MISS_LOG_DATA) pCurrentBufferPtr;

    pRecord->RecordType  = HTTP_RAW_RECORD_MISS_LOG_DATA_TYPE;
    pRecord->Flags.Value = 0;
    
    pRecord->Flags.Method = pBinaryData->Method;    
    pRecord->Flags.ProtocolVersion = pBinaryData->Version;

    pRecord->SiteID = pRequest->ConfigInfo.SiteId;

    KeQuerySystemTime(&CurrentTimeStamp);
    pRecord->DateTime = CurrentTimeStamp;

    pRecord->ServerPort     = pLogData->ServerPort;
    pRecord->ProtocolStatus = pLogData->ProtocolStatus;
    pRecord->Win32Status    = pLogData->Win32Status;

    LifeTime  = CurrentTimeStamp.QuadPart - pRequest->TimeStamp.QuadPart;
    LifeTime  = MAX(LifeTime,0); // Just in case system clock went backward   
    LifeTime /= C_NS_TICKS_PER_MSEC;
    pRecord->TimeTaken = LifeTime;
    
    pRecord->BytesSent     = pRequest->BytesSent;
    pRecord->BytesReceived = pRequest->BytesReceived;

    pRecord->SubStatus     = pLogData->SubStatus;

    //
    // Init the variable size field sizes.
    //

    pRecord->UriStemSize  = pBinaryData->UriStemSize;
    pRecord->UriQuerySize = pBinaryData->UriQuerySize;
    pRecord->UserNameSize = pBinaryData->UserNameSize;
    
    //
    // Move forward to the end of the structure. It's better be PVOID
    // aligned.
    //
    
    pCurrentBufferPtr += sizeof(HTTP_RAW_FILE_MISS_LOG_DATA);

    ASSERT(pCurrentBufferPtr == 
            (PUCHAR) ALIGN_UP_POINTER(pCurrentBufferPtr, PVOID));
    
    //
    // Now append the IP Addresses of the client and server
    //

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pRequest->pHttpConn));    
    pConnection = pRequest->pHttpConn->pConnection;
    ASSERT(IS_VALID_CONNECTION(pConnection));
    
    if ( pConnection->AddressType == TDI_ADDRESS_TYPE_IP)
    {
        PTDI_ADDRESS_IP pIPv4Address = &pConnection->RemoteAddrIn;
    
        PHTTP_RAWLOG_IPV4_ADDRESSES pIPv4Buf = 
            (PHTTP_RAWLOG_IPV4_ADDRESSES) pCurrentBufferPtr;

        ASSERT(pRecord->Flags.IPv6 == FALSE);
        
        pIPv4Buf->Client = * (ULONG UNALIGNED *) &pIPv4Address->in_addr;      

        pIPv4Address = &pConnection->LocalAddrIn;

        pIPv4Buf->Server = * (ULONG UNALIGNED *) &pIPv4Address->in_addr;

        IPAddressSize = sizeof(HTTP_RAWLOG_IPV4_ADDRESSES);    
    }
    else
    {
        PHTTP_RAWLOG_IPV6_ADDRESSES pIPv6Buf = 
            (PHTTP_RAWLOG_IPV6_ADDRESSES) pCurrentBufferPtr;

        ASSERT(pConnection->AddressType == TDI_ADDRESS_TYPE_IP6);
        
        pRecord->Flags.IPv6 = TRUE;

        RtlCopyMemory(
            pIPv6Buf->Client, 
            &pConnection->RemoteAddrIn6.sin6_addr,
            sizeof(pIPv6Buf->Client)
            );    
            
        RtlCopyMemory(
            pIPv6Buf->Server, 
            &pConnection->LocalAddrIn6.sin6_addr,
            sizeof(pIPv6Buf->Server)
            );

        IPAddressSize = sizeof(HTTP_RAWLOG_IPV6_ADDRESSES);
    }
            
    pCurrentBufferPtr += IPAddressSize;

    ASSERT(pCurrentBufferPtr == 
            (PUCHAR) ALIGN_UP_POINTER(pCurrentBufferPtr, PVOID));

    //
    // Now append the variable size fields to the end.
    //
    
    if (pBinaryData->UriStemSize)
    {
        ASSERT(pBinaryData->pUriStem);
        ASSERT(!pBinaryData->pUriStemID);
        
        RtlCopyMemory( pCurrentBufferPtr,
                       pBinaryData->pUriStem,
                       pBinaryData->UriStemSize
                       );
 
        pCurrentBufferPtr += pBinaryData->UriStemSize;
    }

    if (pBinaryData->UriQuerySize)
    {
        ASSERT(pBinaryData->pUriQuery);
        
        RtlCopyMemory( pCurrentBufferPtr,
                       pBinaryData->pUriQuery,
                       pBinaryData->UriQuerySize
                       );

        pCurrentBufferPtr += pBinaryData->UriQuerySize;
    }

    if (pBinaryData->UserNameSize)
    {
        ASSERT(pBinaryData->pUserName);
        
        RtlCopyMemory( pCurrentBufferPtr,
                       pBinaryData->pUserName,
                       pBinaryData->UserNameSize
                       );

        pCurrentBufferPtr += pBinaryData->UserNameSize;
    }

    //
    // Ensure that we still have the PVOID alignment in place.
    //

    pCurrentBufferPtr = 
        (PUCHAR) ALIGN_UP_POINTER(pCurrentBufferPtr, PVOID);

    ASSERT(BytesRequired == DIFF(pCurrentBufferPtr-pBuffer));

    //
    // Well done. Good to go !
    //    

    return;
}

/***************************************************************************++

Routine Description:

    It does the binary logging for the cache-miss case.
    
Arguments:

    pLogData  - This should be a binary log data buffer.
        
--***************************************************************************/

NTSTATUS
UlRawLogHttpHit(
    IN PUL_LOG_DATA_BUFFER      pLogData
    )
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    PUL_CONTROL_CHANNEL         pControlChannel;
    PUL_INTERNAL_REQUEST        pRequest;
    PUL_BINARY_LOG_FILE_ENTRY   pEntry;
    ULONG                       BytesRequired = 0;
    PUL_BINARY_LOG_DATA         pBinaryData;        
    ULONG                       IPAddressSize;
    ULONG                       VarFieldSize;
    PUL_CONNECTION              pConnection;
        
    //
    // Sanity checks.
    //

    PAGED_CODE();

    UlTrace(BINARY_LOGGING, 
        ("Http!UlRawLogHttpHit: pLogData %p\n", pLogData ));

    ASSERT(IS_VALID_LOG_DATA_BUFFER(pLogData));
    pBinaryData = &pLogData->Data.Binary;
        
    pRequest = pLogData->pRequest;
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    ASSERT(UlBinaryLoggingEnabled(pRequest->ConfigInfo.pControlChannel));
    
    pControlChannel = pRequest->ConfigInfo.pControlChannel;
    ASSERT(IS_VALID_CONTROL_CHANNEL(pControlChannel));

    pEntry = pControlChannel->pBinaryLogEntry;
    ASSERT(IS_VALID_BINARY_LOG_FILE_ENTRY(pEntry));

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pRequest->pHttpConn));
    pConnection = pRequest->pHttpConn->pConnection;
    ASSERT(IS_VALID_CONNECTION(pConnection));

    //
    // See how much space we need first.
    //

    if(pConnection->AddressType == TDI_ADDRESS_TYPE_IP)
    {
        IPAddressSize = sizeof(HTTP_RAWLOG_IPV4_ADDRESSES);
    }
    else if(pConnection->AddressType == TDI_ADDRESS_TYPE_IP6)
    {
        IPAddressSize = sizeof(HTTP_RAWLOG_IPV6_ADDRESSES);
    }
    else
    {
        ASSERT(!"Unknown IP Address Type !");  
        return STATUS_NOT_SUPPORTED;
    }

    ASSERT(IPAddressSize == ALIGN_UP(IPAddressSize, PVOID));

    VarFieldSize = ALIGN_UP((pBinaryData->UriStemSize
                              + pBinaryData->UriQuerySize
                              + pBinaryData->UserNameSize), PVOID);
    
    BytesRequired = sizeof(HTTP_RAW_FILE_MISS_LOG_DATA) 
                    + IPAddressSize 
                    + VarFieldSize
                    ;

    ASSERT(BytesRequired == ALIGN_UP(BytesRequired, PVOID));
    
    //
    // Open the binary log file if necessary.
    //

    Status = UlpCheckRawFile( pEntry, pControlChannel );

    if (NT_SUCCESS(Status))
    {
        //
        // Now we know that the log file is there, 
        // it's time to write.
        //
        
        Status =
           UlpWriteToRawLogFile (
                pEntry,
                NULL,
                BytesRequired,
                &UlpRawCopyForLogCacheMiss,
                pLogData
                );    
    }    

    return Status;
}

/***************************************************************************++

Routine Description:

    Receives a pointer to the file buffer. ( IT MUST BE PVOID ALIGNED )

    And copies the index records and the data record.

    When copying the index records, string size is aligned up to PVOID. As a
    result there MAY be padding characters between the index records and the
    data record.

Arguments:

    pContext  - It should be a tracker pointer for cache hits.
    
    pBuffer   - Pointer to the file buffer. PVOID aligned.
    
    BytesRequired - Total number of bytes to be written.
        
--***************************************************************************/

VOID
UlpRawCopyForLogCacheHit(
    IN PVOID   pContext,
    IN PUCHAR  pBuffer,
    IN ULONG   BytesRequired
    )
{
    PHTTP_RAW_INDEX_FIELD_DATA pIndex;
    PHTTP_RAW_FILE_HIT_LOG_DATA pRecord;
    PUL_INTERNAL_REQUEST pRequest;
    PUCHAR pCurrentBufferPtr;
    LONGLONG LifeTime;
    LARGE_INTEGER CurrentTimeStamp;
    PUL_URI_CACHE_ENTRY pUriCacheEntry;
    PUL_FULL_TRACKER pTracker;
    PUL_CONNECTION pConnection;
    ULONG IPAddressSize;

    //
    // Sanity checks
    //
    
    PAGED_CODE();

    ASSERT(pContext);
    ASSERT(pBuffer == (PUCHAR) ALIGN_UP_POINTER(pBuffer,PVOID));
    ASSERT(BytesRequired);

    pTracker = (PUL_FULL_TRACKER) pContext;        
    ASSERT(IS_VALID_FULL_TRACKER(pTracker));

    UlTrace(BINARY_LOGGING, 
        ("Http!UlpRawCopyForLogCacheHit: pTracker %p\n", pTracker ));

    pRequest = pTracker->pRequest;
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    pUriCacheEntry = pTracker->pUriEntry;
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );

    ASSERT(pUriCacheEntry->pLogData);
    ASSERT(pUriCacheEntry->LogDataLength == sizeof(HTTP_RAWLOGID));

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pRequest->pHttpConn));
    pConnection = pRequest->pHttpConn->pConnection;
    ASSERT(IS_VALID_CONNECTION(pConnection));

    if(pConnection->AddressType == TDI_ADDRESS_TYPE_IP)
    {
        IPAddressSize = sizeof(HTTP_RAWLOG_IPV4_ADDRESSES);
    }
    else
    {
        ASSERT(pConnection->AddressType == TDI_ADDRESS_TYPE_IP6);
        IPAddressSize = sizeof(HTTP_RAWLOG_IPV6_ADDRESSES);
    }

    //
    // For cache hits, UriQuery & UserName will be NULL.
    // We will only be dealing with the UriStem field.
    //

    pCurrentBufferPtr = pBuffer;

    if (BytesRequired > (sizeof(HTTP_RAW_FILE_HIT_LOG_DATA) + IPAddressSize))
    {
        PWSTR pUri; 
        ULONG UriSize;

        //
        // First time, we have to write the index.
        //
        
        ASSERT(pUriCacheEntry->UriKey.pUri);
        ASSERT(pUriCacheEntry->UriKey.Length);

        pUri = URI_FROM_CACHE(pUriCacheEntry->UriKey);
        UriSize = URI_SIZE_FROM_CACHE(pUriCacheEntry->UriKey);

        UlTrace(BINARY_LOGGING, 
            ("Http!UlpRawCopyForLogCacheHit: pUri %S UriSize %d\n", 
              pUri,
              UriSize
              ));
        
        pIndex = (PHTTP_RAW_INDEX_FIELD_DATA) pCurrentBufferPtr;

        pIndex->RecordType = HTTP_RAW_RECORD_INDEX_DATA_TYPE;
        pIndex->Size = (USHORT) UriSize; // In Bytes
        
        RtlCopyMemory(pIndex->Str, pUri, UriSize);
        
        //
        // The Uri is cached. Will use the provided Id from entry.
        // Carefull with the pLogData in the cache entry, it could 
        // be unaligned.        
        //

        RtlCopyMemory(&pIndex->Id, 
                        pUriCacheEntry->pLogData, 
                        sizeof(HTTP_RAWLOGID)
                        );

        pCurrentBufferPtr += sizeof(HTTP_RAW_INDEX_FIELD_DATA);

        //
        // Carefully adjust the alignment. If the uri was smaller 
        // than 4 bytes it was inlined anyway.
        //
        
        if (UriSize > URI_BYTES_INLINED)
        {
            pCurrentBufferPtr += 
                ALIGN_UP((UriSize - URI_BYTES_INLINED),PVOID);
        }                
    }

    ASSERT(pCurrentBufferPtr == 
            (PUCHAR) ALIGN_UP_POINTER(pCurrentBufferPtr, PVOID));
    
    //
    // Now fill in the data record itself.
    //

    pRecord = (PHTTP_RAW_FILE_HIT_LOG_DATA) pCurrentBufferPtr;

    pRecord->RecordType = HTTP_RAW_RECORD_HIT_LOG_DATA_TYPE;
    pRecord->Flags.Value = 0;

    pRecord->Flags.Method = pUriCacheEntry->Verb;    
    pRecord->Flags.ProtocolVersion = 
        (UCHAR) UlpHttpVersionToBinaryLogVersion(pRequest->Version);

    pRecord->SiteID = pUriCacheEntry->ConfigInfo.SiteId; 

    KeQuerySystemTime(&CurrentTimeStamp);
    pRecord->DateTime = CurrentTimeStamp;

    // ServerPort will be copied later, down below.
    
    pRecord->ProtocolStatus = pUriCacheEntry->StatusCode;
    pRecord->Win32Status    = 
        HttpNtStatusToWin32Status(pTracker->IoStatus.Status);

    LifeTime  = CurrentTimeStamp.QuadPart - pRequest->TimeStamp.QuadPart;
    LifeTime  = MAX(LifeTime,0); // Just in case system clock went backward   
    LifeTime /= C_NS_TICKS_PER_MSEC;
    pRecord->TimeTaken = LifeTime;
        
    pRecord->BytesSent     = pTracker->IoStatus.Information;
    pRecord->BytesReceived = pRequest->BytesReceived;

    RtlCopyMemory(&pRecord->UriStemId, 
                    pUriCacheEntry->pLogData, 
                    sizeof(HTTP_RAWLOGID)
                    );

    //
    // Completed the fixed length portion of log record. Move to the
    // end.
    //

    pCurrentBufferPtr += sizeof(HTTP_RAW_FILE_HIT_LOG_DATA);

    ASSERT(pCurrentBufferPtr == 
            (PUCHAR) ALIGN_UP_POINTER(pCurrentBufferPtr, PVOID));

    //
    // Now append the IP Addresses of the client and server
    //
        
    if ( pConnection->AddressType == TDI_ADDRESS_TYPE_IP)
    {
        PTDI_ADDRESS_IP pIPv4Address = &pConnection->RemoteAddrIn;
    
        PHTTP_RAWLOG_IPV4_ADDRESSES pIPv4Buf = 
            (PHTTP_RAWLOG_IPV4_ADDRESSES) pCurrentBufferPtr;

        ASSERT(pRecord->Flags.IPv6 == FALSE);
        
        pIPv4Buf->Client = * (ULONG UNALIGNED *) &pIPv4Address->in_addr;      

        pIPv4Address = &pConnection->LocalAddrIn;

        pIPv4Buf->Server = * (ULONG UNALIGNED *) &pIPv4Address->in_addr;

        IPAddressSize = sizeof(HTTP_RAWLOG_IPV4_ADDRESSES);    

        //
        // Init the ServerPort frm LocalAddrIn.
        //
        
        pRecord->ServerPort = SWAP_SHORT(pConnection->LocalAddrIn.sin_port);
    }
    else
    {
        PHTTP_RAWLOG_IPV6_ADDRESSES pIPv6Buf = 
            (PHTTP_RAWLOG_IPV6_ADDRESSES) pCurrentBufferPtr;

        ASSERT(pConnection->AddressType == TDI_ADDRESS_TYPE_IP6);
        
        pRecord->Flags.IPv6 = TRUE;

        RtlCopyMemory(
            pIPv6Buf->Client, 
            &pConnection->RemoteAddrIn6.sin6_addr,
            sizeof(pIPv6Buf->Client)
            );    
            
        RtlCopyMemory(
            pIPv6Buf->Server, 
            &pConnection->LocalAddrIn6.sin6_addr,
            sizeof(pIPv6Buf->Server)
            );

        IPAddressSize = sizeof(HTTP_RAWLOG_IPV6_ADDRESSES);

        //
        // Init the ServerPort from LocalAddrIn.
        //
        
        pRecord->ServerPort = SWAP_SHORT(pConnection->LocalAddrIn6.sin6_port);        
    }

    //
    // Some post sanity check to ensure that we still have the
    // PVOID alignment in place.
    //
    
    pCurrentBufferPtr += IPAddressSize;

    ASSERT(pCurrentBufferPtr == 
            (PUCHAR) ALIGN_UP_POINTER(pCurrentBufferPtr, PVOID));

    ASSERT(BytesRequired == DIFF(pCurrentBufferPtr-pBuffer));

    //
    // Well done. Good to go !
    //    

    return;
}

/***************************************************************************++

Routine Description:

    Handles binary logging for the cache hits.

Arguments:

    pTracker - Supplies the full tracker.

--***************************************************************************/

NTSTATUS
UlRawLogHttpCacheHit(
    IN PUL_FULL_TRACKER         pTracker    
    )
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    PUL_CONTROL_CHANNEL         pControlChannel;
    PUL_BINARY_LOG_FILE_ENTRY   pEntry;
    PUL_URI_CACHE_ENTRY         pUriEntry;
    ULONG                       BytesRequired;
    PUL_CONNECTION              pConnection;
    ULONG                       IPAddressSize;        
        
    //
    // Sanity checks.
    //

    PAGED_CODE();

    ASSERT(pTracker);
    ASSERT(IS_VALID_FULL_TRACKER(pTracker));
    
    UlTrace(BINARY_LOGGING, 
        ("Http!UlRawLogHttpCacheHit: pTracker %p\n", 
          pTracker ));

    pUriEntry = pTracker->pUriEntry;
    ASSERT(IS_VALID_URI_CACHE_ENTRY(pUriEntry));
    
    pControlChannel = pUriEntry->ConfigInfo.pControlChannel;
    ASSERT(IS_VALID_CONTROL_CHANNEL(pControlChannel));

    pEntry = pControlChannel->pBinaryLogEntry;
    ASSERT(IS_VALID_BINARY_LOG_FILE_ENTRY(pEntry));

    ASSERT(UlBinaryLoggingEnabled(pControlChannel));

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pTracker->pRequest));
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pTracker->pRequest->pHttpConn));

    pConnection = pTracker->pRequest->pHttpConn->pConnection;
    ASSERT(IS_VALID_CONNECTION(pConnection));

    //
    // See how much space we need first. This will be incremented for 
    // a possible index record which me might add. However for that
    // calculation we need to be inside the entry pushlock, that's
    // why it is done by the function  UlpWriteToRawLogFile down below.
    //

    if(pConnection->AddressType == TDI_ADDRESS_TYPE_IP)
    {
        IPAddressSize = sizeof(HTTP_RAWLOG_IPV4_ADDRESSES);
    }
    else if(pConnection->AddressType == TDI_ADDRESS_TYPE_IP6)
    {
        IPAddressSize = sizeof(HTTP_RAWLOG_IPV6_ADDRESSES);
    }
    else
    {
        ASSERT(!"Unknown IP Address Type !");  
        Status = STATUS_NOT_SUPPORTED;
        goto end;
    }

    ASSERT(IPAddressSize == ALIGN_UP(IPAddressSize, PVOID));
    
    BytesRequired = sizeof(HTTP_RAW_FILE_HIT_LOG_DATA) + IPAddressSize;
    
    ASSERT(BytesRequired == ALIGN_UP(BytesRequired, PVOID));
         
    //
    // Open the binary log file if necessary.
    //

    Status = UlpCheckRawFile(pEntry, pControlChannel);

    if (NT_SUCCESS(Status))
    {
        //
        // Now we know that the log file is there, 
        // it's time to write.
        //
        
        Status =
           UlpWriteToRawLogFile (
                pEntry,
                pUriEntry,
                BytesRequired,
                &UlpRawCopyForLogCacheHit,
                pTracker
                );

        if (NT_SUCCESS(Status))
        {
            //
            // Mark that we have successfully served a cache entry.
            //
            
            InterlockedExchange((PLONG) &pEntry->ServedCacheHit, 1);
        }
    }    

end:
    //
    // If this was a build&send cache hit, then the tracker  will 
    // still have the originally allocated pLogData. We don't use 
    // it here, nevertheless we will do the cleanup.
    //

    if (pTracker->pLogData)
    {    
        ASSERT(IS_VALID_LOG_DATA_BUFFER(pTracker->pLogData));
        UlDestroyLogDataBuffer(pTracker->pLogData);
        pTracker->pLogData = NULL;
    }
    
    return Status;
}

/***************************************************************************++

Routine Description:

    Exclusive (Debug) writer function.

    REQUIRES you to hold the binary entry lock EXCLUSIVE.

Arguments:

    pEntry          - The binary log file entry we are working on.
    BytesRequired   - The amount (in bytes) of data will be written.
    pBufferWritter  - Caller provided writer function.
    pContext        - Necessary context for the writer function.

--***************************************************************************/

NTSTATUS
UlpWriteToRawLogFileDebug(
    IN  PUL_BINARY_LOG_FILE_ENTRY pEntry,
    IN  ULONG                     BytesRequired,
    IN  PUL_RAW_LOG_COPIER        pBufferWritter,
    IN  PVOID                     pContext,
    OUT PLONG                     pBinaryIndexWritten     
    )
{
    PUL_LOG_FILE_BUFFER pLogBuffer;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG BytesRequiredPlusHeader = BytesRequired;

    PAGED_CODE();

    ASSERT(pContext);
    ASSERT(pBufferWritter);    
    ASSERT(BytesRequired);
    
    ASSERT(IS_VALID_BINARY_LOG_FILE_ENTRY(pEntry));

    UlTrace(BINARY_LOGGING,
        ("Http!UlpWriteToRawLogFileDebug: pEntry %p\n", pEntry));

    ASSERT(UlDbgPushLockOwnedExclusive(&pEntry->PushLock));
    ASSERT(g_UlDisableLogBuffering != 0);    

    //
    // First append title to the temp buffer to calculate the size of 
    // the title if we need to write the title as well.
    //
    
    if (!pEntry->Flags.HeaderWritten) 
    {
        BytesRequiredPlusHeader += sizeof(HTTP_RAW_FILE_HEADER);
    }

    if (BytesRequiredPlusHeader > g_UlLogBufferSize)
    {
        ASSERT(!"Record Size is too big !");
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Now check the log file for overflow.
    //
    
    if (UlpIsRawLogFileOverFlow(pEntry, BytesRequiredPlusHeader))
    { 
        Status = UlpRecycleBinaryLogFile(pEntry);
    }
    
    if (pEntry->pLogFile == NULL || !NT_SUCCESS(Status))
    {
        //
        // If somehow the logging ceased and handle released,
        // It happens when the recycle isn't able to write to 
        // the log drive.
        //

        return Status;
    }
    
    //
    // The pLogBuffer may not be null, if previously a cache 
    // flush entry has been written.
    //
    
    pLogBuffer = pEntry->LogBuffer;
    
    if (pLogBuffer == NULL)
    {
        pLogBuffer = pEntry->LogBuffer = UlPplAllocateLogFileBuffer();
        if (!pLogBuffer)
        {
            return STATUS_NO_MEMORY;
        }
    }
    
    //
    // Very first hit needs to write the title, as well as a hit
    // which causes the log file recycling.
    //
    
    if (!pEntry->Flags.HeaderWritten)
    {
        ULONG BytesCopied =       
            UlpRawCopyLogHeader(
                pLogBuffer->Buffer + pLogBuffer->BufferUsed
                );

        pLogBuffer->BufferUsed += BytesCopied;

        ASSERT(BytesCopied == sizeof(HTTP_RAW_FILE_HEADER));
        
        pEntry->Flags.HeaderWritten = 1;
        pEntry->Flags.HeaderFlushPending = 1;
    }

    pBufferWritter( 
        pContext, 
        pLogBuffer->Buffer + pLogBuffer->BufferUsed,
        BytesRequired
        );
    
    pLogBuffer->BufferUsed += BytesRequired;

    if (pBinaryIndexWritten && 
        0 == pEntry->Flags.CacheFlushInProgress)
    {
        InterlockedExchange(pBinaryIndexWritten, 1);
    }    

    //
    // Now flush what we have.
    //
    
    Status = UlpFlushRawLogFile(pEntry);
    if (!NT_SUCCESS(Status))
    {            
        return Status;
    }

    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    It tries to write to the file buffer with shared lock.

    Exits and returns STATUS_MORE_PROCESSING_REQUIRED for exclusive access 
    for the following conditions;
    
        1. No log buffer available.
        2. Logging ceased. (NULL file handle)
        3. Header needs to be written.
        4. Recycle is necessary because of a size overflow.
        5. No available space left in the current buffer.
           Need to allocate a new one.

    Otherwise reserves a space in the current buffer, copies the data by
    calling the provided writer function.
    
Arguments:

    pEntry          - The binary log file entry we are working on.
    BytesRequired   - The amount (in bytes) of data will be written.
    pBufferWritter  - Caller provided writer function.
    pContext        - Necessary context for the writer function.

--***************************************************************************/

NTSTATUS
UlpWriteToRawLogFileShared(
    IN PUL_BINARY_LOG_FILE_ENTRY pEntry,
    IN ULONG                     BytesRequired,
    IN PUL_RAW_LOG_COPIER        pBufferWritter,
    IN PVOID                     pContext,
    OUT PLONG                    pBinaryIndexWritten         
    )
{
    PUL_LOG_FILE_BUFFER     pLogBuffer;
    LONG                    BufferUsed;

    PAGED_CODE();
    
    ASSERT(pContext);
    ASSERT(pBufferWritter);    
    ASSERT(BytesRequired);
    ASSERT(IS_VALID_BINARY_LOG_FILE_ENTRY(pEntry));

    pLogBuffer = pEntry->LogBuffer;

    UlTrace(BINARY_LOGGING,
        ("Http!UlpWriteToLogRawFileShared: pEntry %p\n", pEntry));

    //
    // Bail out and try the exclusive writer.
    //
    
    if ( pLogBuffer == NULL ||
         pEntry->pLogFile == NULL ||
         !pEntry->Flags.HeaderWritten ||
         UlpIsRawLogFileOverFlow(pEntry,BytesRequired)
       )
    {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    //
    // Reserve space in pLogBuffer by InterlockedCompareExchange add
    // RecordSize. If we exceed the limit, bail out and take the
    // exclusive lock to flush the buffer.
    //

    do
    {
        BufferUsed = *((volatile LONG *) &pLogBuffer->BufferUsed);

        if ( BytesRequired + BufferUsed > g_UlLogBufferSize )
        {
            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        PAUSE_PROCESSOR;
        
    } while (BufferUsed != InterlockedCompareExchange(
                                &pLogBuffer->BufferUsed,
                                BytesRequired + BufferUsed,
                                BufferUsed
                                ));

    //
    // Now we have a reserved space lets proceed with the copying.
    //

    pBufferWritter( 
        pContext, 
        pLogBuffer->Buffer + BufferUsed,
        BytesRequired
        );

    if (pBinaryIndexWritten && 
        0 == pEntry->Flags.CacheFlushInProgress)
    {
        InterlockedExchange(pBinaryIndexWritten, 1);
    }    

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Exclusive writer counterpart of the above function..

Arguments:

    pEntry          - The binary log file entry we are working on.
    BytesRequired   - The amount (in bytes) of data will be written.
    pBufferWritter  - Caller provided writer function.
    pContext        - Necessary context for the writer function.

--***************************************************************************/

NTSTATUS
UlpWriteToRawLogFileExclusive(
    IN PUL_BINARY_LOG_FILE_ENTRY pEntry,
    IN ULONG                     BytesRequired,
    IN PUL_RAW_LOG_COPIER        pBufferWritter,
    IN PVOID                     pContext,
    OUT PLONG                    pBinaryIndexWritten    
    )
{
    PUL_LOG_FILE_BUFFER pLogBuffer;
    NTSTATUS            Status = STATUS_SUCCESS;
    ULONG               BytesRequiredPlusHeader = BytesRequired;

    PAGED_CODE();

    ASSERT(pContext);
    ASSERT(pBufferWritter);    
    ASSERT(BytesRequired);
    ASSERT(IS_VALID_BINARY_LOG_FILE_ENTRY(pEntry));

    UlTrace(BINARY_LOGGING,
        ("Http!UlpWriteToRawLogFileExclusive: pEntry %p\n", pEntry));

    ASSERT(UlDbgPushLockOwnedExclusive(&pEntry->PushLock));

    //
    // First append title to the temp buffer to calculate the size of 
    // the title if we need to write the title as well.
    //
    
    if (!pEntry->Flags.HeaderWritten) 
    {
        BytesRequiredPlusHeader += sizeof(HTTP_RAW_FILE_HEADER);
    }

    if (BytesRequiredPlusHeader > g_UlLogBufferSize)
    {
        ASSERT(!"Record Size is too big !");
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Now check the log file for overflow.
    //
    
    if (UlpIsRawLogFileOverFlow(pEntry,BytesRequiredPlusHeader))
    { 
        Status = UlpRecycleBinaryLogFile(pEntry);
    }

    // TODO: We should perhaps try to awaken the entry if it the entry state is
    // TODO: Inactive. This might happen if log hits happen just about the 
    // TODO: same time (race condition in UlpCheckRawFile) with our closing 
    // TODO: the existing file ( but not recycling though ) .
    
    if (pEntry->pLogFile==NULL || !NT_SUCCESS(Status))
    {
        //
        // If somehow the logging ceased and handle released,
        // it happens when the recycle isn't able to write to 
        // the log drive.
        //

        return Status;
    }

    pLogBuffer = pEntry->LogBuffer;
    if (pLogBuffer)
    {
        //
        // There are two conditions we execute the following if block
        // 1. We were blocked on eresource exclusive and before us some 
        // other thread already take care of the buffer flush or recycling.
        // 2. Reconfiguration happened and log attempt needs to write the
        // title again.
        //
        
        if (BytesRequiredPlusHeader + pLogBuffer->BufferUsed <= g_UlLogBufferSize)
        {
            //
            // If this is the first log attempt after a reconfig, then we have
            // to write the title here. Reconfig doesn't immediately write the
            // title but rather depend on us by setting the HeaderWritten flag
            // to false.
            //
            
            if (!pEntry->Flags.HeaderWritten)
            {
                ULONG BytesCopied =                
                    UlpRawCopyLogHeader(
                        pLogBuffer->Buffer + pLogBuffer->BufferUsed
                        );

                pLogBuffer->BufferUsed += BytesCopied;

                ASSERT(BytesCopied == sizeof(HTTP_RAW_FILE_HEADER));
                
                pEntry->Flags.HeaderWritten = 1; 
                pEntry->Flags.HeaderFlushPending = 1;
            }

            pBufferWritter( 
                pContext, 
                pLogBuffer->Buffer + pLogBuffer->BufferUsed,
                BytesRequired
                );
            
            pLogBuffer->BufferUsed += BytesRequired;

            if (pBinaryIndexWritten && 
                0 == pEntry->Flags.CacheFlushInProgress)
            {
                InterlockedExchange(pBinaryIndexWritten, 1);
            }    

            return STATUS_SUCCESS;
        }

        //
        // Flush out the buffer first then proceed with allocating a new one.
        //

        Status = UlpFlushRawLogFile(pEntry);
        if (!NT_SUCCESS(Status))
        {            
            return Status;
        }
    }

    ASSERT(pEntry->LogBuffer == NULL);
    
    //
    // This can be the very first log attempt or the previous allocation
    // of LogBuffer failed, or the previous hit flushed and deallocated 
    // the old buffer. In either case, we allocate a new one,append the
    // (title plus) new record and return for more/shared processing.
    //

    pLogBuffer = pEntry->LogBuffer = UlPplAllocateLogFileBuffer();
    if (pLogBuffer == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    //
    // Very first attempt needs to write the title, as well as the attempt
    // which causes the log file recycling. Both cases comes down here
    //
    
    if (!pEntry->Flags.HeaderWritten)
    {
        ULONG BytesCopied =       
            UlpRawCopyLogHeader(
                pLogBuffer->Buffer + pLogBuffer->BufferUsed
                );

        pLogBuffer->BufferUsed += BytesCopied;

        ASSERT(BytesCopied == sizeof(HTTP_RAW_FILE_HEADER));
        
        pEntry->Flags.HeaderWritten = 1; 
        pEntry->Flags.HeaderFlushPending = 1;
    }

    pBufferWritter( 
        pContext, 
        pLogBuffer->Buffer + pLogBuffer->BufferUsed,
        BytesRequired
        );
    
    pLogBuffer->BufferUsed += BytesRequired;

    if (pBinaryIndexWritten && 
        0 == pEntry->Flags.CacheFlushInProgress)
    {
        InterlockedExchange(pBinaryIndexWritten, 1);
    }    

    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    Tries shared write first, if fails then it goes for exclusice lock and
    flushes and/or recycles the file.
    
Arguments:

    pEntry          - The binary log file entry we are working on.
    pUriEntry       - Uri cache entry if this was for a cache hit, or NULL. 
    BytesRequired   - The amount (in bytes) of data will be written.
    pBufferWritter  - Caller provided writer function.
    pContext        - Necessary context for the writer function.
    
--***************************************************************************/

NTSTATUS
UlpWriteToRawLogFile(
    IN PUL_BINARY_LOG_FILE_ENTRY pEntry,
    IN PUL_URI_CACHE_ENTRY       pUriEntry,    
    IN ULONG                     RecordSize, 
    IN PUL_RAW_LOG_COPIER        pBufferWritter,
    IN PVOID                     pContext
    )
{
    NTSTATUS Status;
    PLONG    pIndexWritten;     // Pointer to the cache entries index state
    ULONG    BytesRequired;     // Total record size (including the index)

    //
    // Small macro which will increment the total record size, only if the 
    // index is not written yet. This must be used inside the entry pushlock. 
    // This is only for the cache hits.
    //
    
#define UPDATE_FOR_INDEX_RECORD()                                       \
    if (NULL != pUriEntry &&                                            \
        0 == pUriEntry->BinaryIndexWritten)                             \
    {                                                                   \
        BytesRequired =                                                 \
            (RecordSize + UlpGetIndexRecordSize(pUriEntry));            \
                                                                        \
        pIndexWritten =                                                 \
            (PLONG) &pUriEntry->BinaryIndexWritten;                     \
    }                                                                   \
    else                                                                \
    {                                                                   \
        BytesRequired = RecordSize;                                     \
        pIndexWritten = NULL;                                           \
    }

    //
    // Sanity check
    //

    PAGED_CODE();

    ASSERT(IS_VALID_BINARY_LOG_FILE_ENTRY(pEntry));
    ASSERT(RecordSize);    
    ASSERT(pBufferWritter);
    ASSERT(pContext);
        
    UlTrace(BINARY_LOGGING,
        ("Http!UlpWriteToRawLogFile: pEntry %p\n", pEntry));

    if (g_UlDisableLogBuffering)
    {
        //
        // Above global variable is safe to look, it doesn't get changed
        // during the life-time of the driver. It's get initialized from
        // the registry and disables the log buffering.
        //
        
        UlAcquirePushLockExclusive(&pEntry->PushLock);

        UPDATE_FOR_INDEX_RECORD();

        Status = UlpWriteToRawLogFileDebug(
                    pEntry,
                    BytesRequired,
                    pBufferWritter,
                    pContext,
                    pIndexWritten
                    );

        UlReleasePushLockExclusive(&pEntry->PushLock);

        return Status;    
    }
    
    //
    // Try Shared write first which merely moves the BufferUsed forward
    // and copy the pContext to the file buffer.
    //

    UlAcquirePushLockShared(&pEntry->PushLock);

    UPDATE_FOR_INDEX_RECORD();

    Status = UlpWriteToRawLogFileShared(
                pEntry,
                BytesRequired,
                pBufferWritter,
                pContext,
                pIndexWritten
                );

    UlReleasePushLockShared(&pEntry->PushLock);

    if (Status == STATUS_MORE_PROCESSING_REQUIRED)
    {
        //
        // If shared write returns STATUS_MORE_PROCESSING_REQUIRED,
        // we need to flush/recycle the buffer and try to log again. 
        // This time, we need to take the entry eresource exclusive.
        //

        UlAcquirePushLockExclusive(&pEntry->PushLock);

        UPDATE_FOR_INDEX_RECORD();

        Status = UlpWriteToRawLogFileExclusive(
                    pEntry,
                    BytesRequired,
                    pBufferWritter,
                    pContext,
                    pIndexWritten
                    );

        UlReleasePushLockExclusive(&pEntry->PushLock);
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    Removes a binary log file entry, closes corresponding log file. Cleans
    up control channel's directory string.

Arguments:

    pControlChannel  - Control channel whose log file to be removed.

--***************************************************************************/

VOID
UlRemoveBinaryLogEntry(
    IN OUT PUL_CONTROL_CHANNEL pControlChannel
    )
{
    PUL_BINARY_LOG_FILE_ENTRY  pEntry;
    
    //
    // We can safely clean up here. Because there are no longer requests
    // holding an indirect pointer back to control channel. The refcount
    // on control channel reached zero. No cgroups & no requests. Way to
    // go.
    //

    PAGED_CODE();
        
    //
    // Clean up config group's directory string.
    //

    InterlockedExchange((PLONG)&g_BinaryLogEntryCount, 0);
    
    if (pControlChannel->BinaryLoggingConfig.LogFileDir.Buffer)
    {
        UL_FREE_POOL(
            pControlChannel->BinaryLoggingConfig.LogFileDir.Buffer,
            UL_CG_LOGDIR_POOL_TAG );
        
        pControlChannel->BinaryLoggingConfig.LogFileDir.Buffer = NULL;
        pControlChannel->BinaryLoggingConfig.LogFileDir.Length = 0;
    }

    pEntry = pControlChannel->pBinaryLogEntry;
    if (pEntry == NULL)
    {
        return;
    }

    UlAcquirePushLockExclusive(&pEntry->PushLock);
    
    ASSERT(IS_VALID_BINARY_LOG_FILE_ENTRY(pEntry));

    if (pEntry->pLogFile != NULL)
    {
        //
        // Flush the buffer, close the file and mark the entry
        // inactive.
        //

        UlpDisableBinaryEntry(pEntry); 
    }

    //
    // Free up the FileName (allocated when the entry becomes active
    // otherwise it's empty)
    //

    if (pEntry->FileName.Buffer)
    {
        UL_FREE_POOL(pEntry->FileName.Buffer,UL_CG_LOGDIR_POOL_TAG);
        pEntry->FileName.Buffer = NULL;
    }
    
    if (pEntry->LogBuffer)
    {
        UlPplFreeLogFileBuffer(pEntry->LogBuffer);
    }

    UlReleasePushLockExclusive(&pEntry->PushLock);    

    UlTrace(BINARY_LOGGING,
            ("Http!UlRemoveBinaryLogEntry: pEntry %p closed.\n",
             pEntry
             ));    
}

/***************************************************************************++

Routine Description:

    This function implements the logging reconfiguration per attribute.
    Everytime config changes happens we try to update the existing logging
    parameters here.

Arguments:

    pControlChannel - control channel that holds the binary log.

    pCfgCurrent - Current binary logging config on the control channel
    pCfgNew     - New binary logging config passed down by the user.

--***************************************************************************/

NTSTATUS
UlReConfigureBinaryLogEntry(
    IN OUT PUL_CONTROL_CHANNEL pControlChannel,
    IN PHTTP_CONTROL_CHANNEL_BINARY_LOGGING pCfgCurrent,
    IN PHTTP_CONTROL_CHANNEL_BINARY_LOGGING pCfgNew
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUL_BINARY_LOG_FILE_ENTRY pEntry;
    BOOLEAN  HaveToReCycle = FALSE;

    //
    // Sanity check first
    //

    PAGED_CODE();

    UlTrace(BINARY_LOGGING,("Http!UlReConfigureBinaryLogEntry: entry %p\n",
             pControlChannel->pBinaryLogEntry));

    //
    // Discard the configuration changes when logging stays disabled.
    //

    if (pCfgCurrent->LoggingEnabled==FALSE && pCfgNew->LoggingEnabled==FALSE)
    {
        return Status;
    }

    //
    // Note that we do not touch any of the params in the new config if it's
    // state is disabled. We don't actualy check them in this case.
    //

    pEntry = pControlChannel->pBinaryLogEntry;
    ASSERT(IS_VALID_BINARY_LOG_FILE_ENTRY(pEntry));

    UlAcquirePushLockExclusive(&pEntry->PushLock);

    if (pCfgCurrent->LoggingEnabled==TRUE   && pCfgNew->LoggingEnabled==FALSE)
    {
        //
        // Disable the entry if necessary.
        //

        if (pEntry->Flags.Active == 1)
        {
            //
            // Once the entry is disabled, it will be enabled when next 
            // hit happens. And that obviously cannot happen before the
            // control channel enables the binary logging back.
            //

            Status = UlpDisableBinaryEntry(pEntry);        
        }

        pCfgCurrent->LoggingEnabled = FALSE;
        goto end;
    }
    else
    {
        pCfgCurrent->LoggingEnabled = TRUE;
    }
    
    //
    // If LogEntry is Inactive (means no request served for this site yet and
    // the LogFile itself hasn't been created yet), all we have to do is flush
    // the settings on the LogEntry, the cgroup and then return.
    //

    if (!pEntry->Flags.Active)
    {
        ASSERT(pEntry->pLogFile == NULL);
        
        if (RtlCompareUnicodeString(&pCfgNew->LogFileDir, 
                                    &pCfgCurrent->LogFileDir, TRUE) 
                                    != 0)
        {
            //
            // Store the new directory in the cgroup even if the entry is
            // inactive. Discard the return value, if failure happens we 
            // keep the old directory.
            //
            
            UlCopyLogFileDir(
                &pCfgCurrent->LogFileDir,
                &pCfgNew->LogFileDir
                );

            //
            // If creation fails later, we should event log.
            //
            
            pEntry->Flags.CreateFileFailureLogged = 0;            
        }
                    
        pEntry->Period = (HTTP_LOGGING_PERIOD) pCfgNew->LogPeriod;
        pCfgCurrent->LogPeriod = pCfgNew->LogPeriod;
            
        pEntry->TruncateSize = pCfgNew->LogFileTruncateSize;
        pCfgCurrent->LogFileTruncateSize = pCfgNew->LogFileTruncateSize;

        pCfgCurrent->LocaltimeRollover = pCfgNew->LocaltimeRollover;
        pEntry->Flags.LocaltimeRollover = (pCfgNew->LocaltimeRollover ? 1 : 0);
                
        goto end;
    }
        
    //
    // If the entry was active then proceed down to do the reconfiguration
    // and recyle immediately if it's necessary.
    //

    Status = UlCheckLogDirectory(&pCfgNew->LogFileDir);
    if (!NT_SUCCESS(Status))
    {
        // Otherwise keep the old settings
        goto end;
    }    
                    
    if (RtlCompareUnicodeString(
           &pCfgNew->LogFileDir, &pCfgCurrent->LogFileDir, TRUE) != 0)
    {
        //
        // Store the new directory in the config group.
        //

        Status = UlCopyLogFileDir(&pCfgCurrent->LogFileDir,
                                    &pCfgNew->LogFileDir
                                    );
        if (!NT_SUCCESS(Status))
        {
            goto end;
        }
        
        //
        // Rebuild the fully qualified file name.
        //
        
        Status = UlRefreshFileName(&pCfgCurrent->LogFileDir, 
                                     &pEntry->FileName,
                                     &pEntry->pShortName
                                     );        
        if (!NT_SUCCESS(Status))
        {
            goto end;
        }        

        //
        // Set the sequence number stale so that the recylcler below can
        // obtain the proper number by scanning the directory.
        //
        
        pEntry->Flags.StaleSequenceNumber = 1;

        HaveToReCycle = TRUE;
    }

    if (pCfgNew->LogPeriod != pCfgCurrent->LogPeriod)
    {
        pCfgCurrent->LogPeriod = pCfgNew->LogPeriod;
        pEntry->Period = (HTTP_LOGGING_PERIOD) pCfgNew->LogPeriod;

        pEntry->Flags.StaleTimeToExpire   = 1;
        pEntry->Flags.StaleSequenceNumber = 1;

        HaveToReCycle = TRUE;        
    }

    if (pCfgNew->LogFileTruncateSize != pCfgCurrent->LogFileTruncateSize)
    {
        if (TRUE == UlUpdateLogTruncateSize(
                        pCfgNew->LogFileTruncateSize,
                        &pCfgCurrent->LogFileTruncateSize,
                        &pEntry->TruncateSize,
                        pEntry->TotalWritten
                        ))
        {
            HaveToReCycle = TRUE;
        }        
    }

    if (pCfgNew->LocaltimeRollover != pCfgCurrent->LocaltimeRollover)
    {
        //
        // Need to reclycle if the format is W3C.
        //

        pCfgCurrent->LocaltimeRollover = pCfgNew->LocaltimeRollover;
        pEntry->Flags.LocaltimeRollover = (pCfgNew->LocaltimeRollover ? 1 : 0);
            
        // TODO: HaveToReCycle = TRUE;
    }

    if (HaveToReCycle)
    {
        //
        // Mark the entry inactive and postpone the recycle until the next 
        // request arrives.
        //

        Status = UlpDisableBinaryEntry(pEntry);
    }

  end:

    if (!NT_SUCCESS(Status))
    {
        UlTrace(BINARY_LOGGING,
            ("Http!UlReConfigureBinaryLogEntry: entry %p, failure %08lx\n",
              pEntry,
              Status
              ));
    }

    UlReleasePushLockExclusive(&pEntry->PushLock);

    return Status;
    
} // UlReConfigureLogEntry

/***************************************************************************++

Routine Description:

    Get called by cache whenever the Uri cache is flushed.
    If we have a binary log file with cache index records.
    We write a notification record to warn the parser to reset
    its hash table.

    pControlChannel : which owns the binary log entry.
        
--***************************************************************************/

VOID
UlHandleCacheFlushedNotification(
    IN PUL_CONTROL_CHANNEL pControlChannel
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUL_BINARY_LOG_FILE_ENTRY pEntry = NULL;
    ULONG BytesRequired = sizeof(HTTP_RAW_FILE_CACHE_NOTIFICATION);
    HTTP_RAW_FILE_CACHE_NOTIFICATION NotificationRecord;

    //
    // Sanity checks.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_CONTROL_CHANNEL(pControlChannel));    
    
    //
    // Quickly return, if we don't need to do anything.
    //
    
    if (!UlBinaryLoggingEnabled(pControlChannel))
    {
        return;
    }

    pEntry = pControlChannel->pBinaryLogEntry;
    ASSERT(IS_VALID_BINARY_LOG_FILE_ENTRY(pEntry));
    
    UlAcquirePushLockExclusive(&pEntry->PushLock);

    //
    // If entry doesn't have any log file or inactive,
    // it should be due to recycling and it's not necessary 
    // to write a notification record since the parser 
    // should reset its hash table with every new file 
    // anyway.
    //

    if (pEntry->Flags.Active && pEntry->pLogFile &&
        !UlpIsRawLogFileOverFlow(pEntry,BytesRequired))
    {
        //
        // Write the record only if we have cache records
        // in this binary log file.
        //
        
        if (1 == InterlockedCompareExchange(
                     (PLONG) &pEntry->ServedCacheHit, 
                     0, 
                     1))
        {
            NotificationRecord.RecordType
                = HTTP_RAW_RECORD_CACHE_NOTIFICATION_DATA_TYPE;

            //
            // Call to the exclusive writer, 
            //
            
            Status = UlpWriteToRawLogFileExclusive(
                        pEntry,
                        BytesRequired,
                        UlpRawCopyCacheNotification,
                        &NotificationRecord,
                        NULL
                        );
            
            UlTrace(BINARY_LOGGING, 
             ("Http!UlHandleCacheFlushedNotification: pEntry %p Status %08lx\n", 
                     pEntry,
                     Status
                     ));        
        }        
    }

    //
    // Enable the indexing for the cache hits. Because we are done with
    // writing the flush record.
    //

    pEntry->Flags.CacheFlushInProgress = 0;
            
    UlReleasePushLockExclusive(&pEntry->PushLock);
    
    return;
}

/***************************************************************************++

Routine Description:

    Simple routine to copy the cache notification record to binary
    log file buffer.
    
--***************************************************************************/

VOID
UlpRawCopyCacheNotification(
    IN PVOID   pContext,
    IN PUCHAR  pBuffer,
    IN ULONG   BytesRequired
    )
{
    PHTTP_RAW_FILE_CACHE_NOTIFICATION pNotification;
    PUCHAR pCurrentBufferPtr;
        
    UNREFERENCED_PARAMETER(BytesRequired);

    PAGED_CODE();

    ASSERT(pContext);
    ASSERT(pBuffer);
    
    UlTrace(BINARY_LOGGING, 
        ("Http!UlpRawCopyCacheNotification: pBuffer %p\n", pBuffer ));

    ASSERT(pBuffer == ALIGN_UP_POINTER(pBuffer,PVOID));
        
    pCurrentBufferPtr = pBuffer;
    
    pNotification = (PHTTP_RAW_FILE_CACHE_NOTIFICATION) pBuffer;

    pNotification->RecordType = 
        ((PHTTP_RAW_FILE_CACHE_NOTIFICATION) pContext)->RecordType;

    ASSERT(pNotification->RecordType == 
                HTTP_RAW_RECORD_CACHE_NOTIFICATION_DATA_TYPE);
        
    pCurrentBufferPtr += sizeof(HTTP_RAW_FILE_CACHE_NOTIFICATION);

    ASSERT(pCurrentBufferPtr == 
            (PUCHAR) ALIGN_UP_POINTER(pCurrentBufferPtr, PVOID));
    
    ASSERT(BytesRequired == DIFF(pCurrentBufferPtr-pBuffer));

    return;
}


/***************************************************************************++

Routine Description:

    Get called by cache * just before * the Uri cache is flushed.

    At this time we set the CacheFlushInProgress flag to temporarly disable
    the indexing for the cache hits. Every cache hit will generate index
    records until this flag is cleared. 

    The flag will be cleared when the flush notification itself is written.

    pControlChannel : which owns the binary log entry.
        
--***************************************************************************/

VOID
UlDisableIndexingForCacheHits(
    IN PUL_CONTROL_CHANNEL pControlChannel
    )
{
    PUL_BINARY_LOG_FILE_ENTRY pEntry;

    //
    // Sanity checks.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_CONTROL_CHANNEL(pControlChannel));    
    
    //
    // Quickly return, if we don't need to do anything.
    //
    
    if (!UlBinaryLoggingEnabled(pControlChannel))
    {
        return;
    }

    //
    // Need to acquire the lock exclusive to block other cache hits
    // until we set the flag.
    //
    
    pEntry = pControlChannel->pBinaryLogEntry;
    ASSERT(IS_VALID_BINARY_LOG_FILE_ENTRY(pEntry));
    
    UlAcquirePushLockExclusive(&pEntry->PushLock);

    pEntry->Flags.CacheFlushInProgress = 1;
                
    UlReleasePushLockExclusive(&pEntry->PushLock);
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\rawlog.h ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    rawlog.h (Centralized Binary (Raw) Logging v1.0)

Abstract:

    This module implements the centralized raw logging 
    format. Internet Binary Logs (file format).

Author:

    Ali E. Turkoglu (aliTu)       02-Oct-2001

Revision History:

    ---

--*/

#ifndef _RAWLOG_H_
#define _RAWLOG_H_

//
// Forwarders
//

typedef struct _UL_INTERNAL_REQUEST *PUL_INTERNAL_REQUEST;

///////////////////////////////////////////////////////////////////////////////
//
// Global definitions
//
///////////////////////////////////////////////////////////////////////////////

//
// Version numbers for the original raw binary format.
//

#define MAJOR_RAW_LOG_FILE_VERSION      (1)
#define MINOR_RAW_LOG_FILE_VERSION      (0)

//
// Normally computer name is defined as 256 wchars. 
//

#define MAX_COMPUTER_NAME_LEN           (256)

//
// The rawfile record types. Add to the end. Do not change
// the existing values for types.
//

#define HTTP_RAW_RECORD_HEADER_TYPE                     (0)
#define HTTP_RAW_RECORD_FOOTER_TYPE                     (1)
#define HTTP_RAW_RECORD_INDEX_DATA_TYPE                 (2)
#define HTTP_RAW_RECORD_HIT_LOG_DATA_TYPE               (3)
#define HTTP_RAW_RECORD_MISS_LOG_DATA_TYPE              (4)
#define HTTP_RAW_RECORD_CACHE_NOTIFICATION_DATA_TYPE    (5)
#define HTTP_RAW_RECORD_MAX_TYPE                        (6)

//
// Every record type should be PVOID aligned.
//

//
// Header structure to identify the rawfile.
// Header record allows validation check for the file, and
// the movement of logs from one computer to another for post
// processing w/o loosing the source of the logs. 
//

typedef struct _HTTP_RAW_FILE_HEADER
{
    //
    // Must be HTTP_RAW_RECORD_HEADER_TYPE.
    //
    
    USHORT          RecordType;

    //
    // Identifies the version of the Internet Binary Log File.
    //
    
    union {
        struct {
            UCHAR MajorVersion; // MAJOR_RAW_LOG_FILE_VERSION
            UCHAR MinorVersion; // MINOR_RAW_LOG_FILE_VERSION
        };
        USHORT Version;
    };

    //
    // Shows the alignment padding size. sizeof(PVOID).
    //

    ULONG           AlignmentSize;

    //
    // Timestamp for the raw file creation/opening.
    //
    
    LARGE_INTEGER   DateTime;


    //
    // Name of the Server which created/opened the raw file.
    //
    
    WCHAR           ComputerName[MAX_COMPUTER_NAME_LEN];   
    
} HTTP_RAW_FILE_HEADER, *PHTTP_RAW_FILE_HEADER;

C_ASSERT( MAX_COMPUTER_NAME_LEN == 
                ALIGN_UP(MAX_COMPUTER_NAME_LEN,PVOID) );

C_ASSERT( sizeof(HTTP_RAW_FILE_HEADER) == 
                ALIGN_UP(sizeof(HTTP_RAW_FILE_HEADER), PVOID));
    
//
// The file footer exists as an integrity check for the 
// post processing utilities.
//

typedef struct _HTTP_RAW_FILE_FOOTER
{
    //
    // Must be HTTP_RAW_RECORD_FOOTER_TYPE.
    //
    
    USHORT          RecordType;

    //
    // Reserved for alignment
    //
    
    USHORT          Padding[3];
        
    //
    // Timestamp for the raw file close time.
    //
    
    LARGE_INTEGER   DateTime;
    
} HTTP_RAW_FILE_FOOTER, *PHTTP_RAW_FILE_FOOTER;

C_ASSERT( sizeof(HTTP_RAW_FILE_FOOTER) == 
                ALIGN_UP(sizeof(HTTP_RAW_FILE_FOOTER), PVOID));

//
// Whenever Internal URI Cache is flushed we notify 
// binary log file parser to drop its own cache by
// writing this record to the file.
//

typedef struct _HTTP_RAW_FILE_CACHE_NOTIFICATION
{
    //
    // Must be HTTP_RAW_RECORD_CACHE_NOTIFICATION_DATA_TYPE.
    //
    
    USHORT          RecordType;

    //
    // Reserved for alignment
    //
    
    USHORT          Reserved[3];
    
} HTTP_RAW_FILE_CACHE_NOTIFICATION, 
  *PHTTP_RAW_FILE_CACHE_NOTIFICATION;

C_ASSERT( sizeof(HTTP_RAW_FILE_CACHE_NOTIFICATION) == 
                ALIGN_UP(sizeof(HTTP_RAW_FILE_CACHE_NOTIFICATION), PVOID));

//
// Unique identifier for the url. 
//

typedef struct _HTTP_RAWLOGID
{
    //
    // The virtual address of the cache entry (from uri cache)
    //

    ULONG   AddressLowPart;
    
    ULONG   AddressHighPart;
 
} HTTP_RAWLOGID, *PHTTP_RAWLOGID;

//
// It's IPv6 only if the corresponding flag is set in the 
// options.
//

typedef struct _HTTP_RAWLOG_IPV4_ADDRESSES {

    ULONG Client;

    ULONG Server;

} HTTP_RAWLOG_IPV4_ADDRESSES, *PHTTP_RAWLOG_IPV4_ADDRESSES;

C_ASSERT( sizeof(HTTP_RAWLOG_IPV4_ADDRESSES) == 
                ALIGN_UP(sizeof(HTTP_RAWLOG_IPV4_ADDRESSES), PVOID));

typedef struct _HTTP_RAWLOG_IPV6_ADDRESSES {

    USHORT Client[8];

    USHORT Server[8];

} HTTP_RAWLOG_IPV6_ADDRESSES, *PHTTP_RAWLOG_IPV6_ADDRESSES;

C_ASSERT( sizeof(HTTP_RAWLOG_IPV6_ADDRESSES) == 
                ALIGN_UP(sizeof(HTTP_RAWLOG_IPV6_ADDRESSES), PVOID));

//
// Binary Log Protocol Version Field Values
//

#define BINARY_LOG_PROTOCOL_VERSION_UNKNWN      (0)
#define BINARY_LOG_PROTOCOL_VERSION_HTTP09      (1)
#define BINARY_LOG_PROTOCOL_VERSION_HTTP10      (2)
#define BINARY_LOG_PROTOCOL_VERSION_HTTP11      (3)

//
// Record type for the cache-hit case.
//

typedef struct _HTTP_RAW_FILE_HIT_LOG_DATA
{
    //
    // Type must be HTTP_RAW_RECORD_HIT_LOG_DATA_TYPE.
    //
    
    USHORT          RecordType;

    //
    // Optional flags.
    //

    union
    {
        struct 
        {
            USHORT IPv6:1;              // IPv6 or not
            USHORT ProtocolVersion:3;   // HTTP1.0 or HTTP1.1
            USHORT Method:6;            // HTTP_VERB          
            USHORT Reserved:6;
        };
        USHORT Value;
        
    } Flags;
    
    //
    // Site ID. Represents which site owns this log record.
    //

    ULONG           SiteID;
    
    //
    // Timestamp for the Log Hit.
    //
    
    LARGE_INTEGER   DateTime;
    

    USHORT          ServerPort;

    //
    // ProtocolStatus won't be bigger than 999.
    //

    USHORT          ProtocolStatus;
    
    //
    // Other send completion results...
    //

    ULONG           Win32Status;

    ULONGLONG       TimeTaken;

    ULONGLONG       BytesSent;

    ULONGLONG       BytesReceived;

    //
    // For cache hits there will always be a UriStem Index record
    // written prior to this record.
    //

    HTTP_RAWLOGID   UriStemId;
    
    //
    // Below variable Length Fields follows the structure.
    //

    // Client IP Address (v4 or v6) - 4 or 16 bytes
    // Server IP Address (v4 or v6) - 4 or 16 bytes
    
} HTTP_RAW_FILE_HIT_LOG_DATA, *PHTTP_RAW_FILE_HIT_LOG_DATA;

C_ASSERT( sizeof(HTTP_RAW_FILE_HIT_LOG_DATA) == 
                ALIGN_UP(sizeof(HTTP_RAW_FILE_HIT_LOG_DATA), PVOID));

//
// Record type for the cache-miss case.
//

typedef struct _HTTP_RAW_FILE_MISS_LOG_DATA 
{
    //
    // Type must be HTTP_RAW_RECORD_MISS_LOG_DATA_TYPE.
    //
    
    USHORT          RecordType;

    //
    // Optional IPv6 flag and the version and the method
    // fields are compacted inside a ushort.
    //

    union
    {
        struct 
        {
            USHORT IPv6:1;              // IPv6 or not
            USHORT ProtocolVersion:3;   // HTTP1.0 or HTTP1.1
            USHORT Method:6;            // HTTP_VERB    
            USHORT Reserved:6;
        };
        USHORT Value;
        
    } Flags;

    //
    // Site ID. Represents which site owns this log record.
    //

    ULONG           SiteID;
        
    LARGE_INTEGER   DateTime;
    
    USHORT          ServerPort;

    //
    // ProtocolStatus won't be bigger than 999.
    //

    USHORT          ProtocolStatus;
    
    //
    // Other send completion results...
    //

    ULONG           Win32Status;

    ULONGLONG       TimeTaken;

    ULONGLONG       BytesSent;

    ULONGLONG       BytesReceived;

    USHORT          SubStatus;
    
    //
    // Variable length fields follows the structure.
    //

    USHORT          UriStemSize;

    USHORT          UriQuerySize;

    USHORT          UserNameSize;
    
    // Client IP Address (v4 or v6) - 4 or 16 bytes
    // Server IP Address (v4 or v6) - 4 or 16 bytes
    // URI Stem  - UriStemSize bytes
    // URI Query - UriQuerySize bytes
    // UserName  - ALIGN_UP(UserNameSize,PVOID) bytes

} HTTP_RAW_FILE_MISS_LOG_DATA, *PHTTP_RAW_FILE_MISS_LOG_DATA;

C_ASSERT( sizeof(HTTP_RAW_FILE_MISS_LOG_DATA) == 
                ALIGN_UP(sizeof(HTTP_RAW_FILE_MISS_LOG_DATA), PVOID));
    
//
// For cache hits, the uri is logged as a variable string for the 
// first time. Later hits refers to this index's HTTP_RAWLOGID.
//

#define URI_BYTES_INLINED       (4)
#define URI_WCHARS_INLINED      (URI_BYTES_INLINED/sizeof(WCHAR))

typedef struct _HTTP_RAW_INDEX_FIELD_DATA
{
    //
    // HTTP_RAW_RECORD_INDEX_DATA_TYPE.
    //
    
    USHORT          RecordType;

    //
    // Size of the variable size string (in bytes).
    // When reading and writing need to align the DIFF(Size - 4) 
    // up to PVOID.
    //

    USHORT          Size;
    
    //
    // Unique Id for the uri.
    //

    HTTP_RAWLOGID   Id;

    //
    // Variable size string follows immediately after the structure.
    // Array of 4 bytes is defined to be able to make it PVOID aligned 
    // on ia64. Typically uris will be bigger than 4 byte.
    //

    WCHAR           Str[URI_WCHARS_INLINED];

} HTTP_RAW_INDEX_FIELD_DATA, *PHTTP_RAW_INDEX_FIELD_DATA;

C_ASSERT( sizeof(HTTP_RAW_INDEX_FIELD_DATA) == 
                ALIGN_UP(sizeof(HTTP_RAW_INDEX_FIELD_DATA), PVOID));

//
// Macro to check the sanity of the raw file records.
//

#define IS_VALID_RAW_FILE_RECORD( pRecord )  \
    ( (pRecord) != NULL &&                                             \
      (pRecord)->RecordType >= 0 &&                                    \
      (pRecord)->RecordType <= HTTP_RAW_RECORD_MAX_TYPE                \
    )

// 
// One and only one binary log file entry manages the one centralized
// binary log file for all sites. It is resident in the memory during
// the lifetime of the driver.
//

typedef struct _UL_BINARY_LOG_FILE_ENTRY
{
    //
    // Must be UL_BINARY_LOG_FILE_ENTRY_POOL_TAG.
    //

    ULONG               Signature;
    
    //
    // This lock protects the shared writes and exclusive flushes.
    // It has to be push lock since the ZwWrite operation
    // cannot run at APC_LEVEL.
    //

    UL_PUSH_LOCK        PushLock;

    //
    // The name of the file. Full path including the directory.
    //

    UNICODE_STRING      FileName;
    PWSTR               pShortName;

    //
    // Following will be NULL until a request comes in to the
    // site that this entry represents.
    //

    PUL_LOG_FILE_HANDLE pLogFile;

    //
    // Private config information.
    //
    
    HTTP_LOGGING_PERIOD Period;
    ULONG               TruncateSize;

    //
    // The following fields are used to determine when/how to 
    // recycle the log file.
    //

    ULONG               TimeToExpire;   // In Hours
    ULONG               SequenceNumber; // When entry has MAX_SIZE or UNLIMITED period.
    ULARGE_INTEGER      TotalWritten;   // In Bytes

    //
    // File for the entry is automatically closed every 15
    // minutes. This is to track the idle time. This value
    // is in number of buffer flush periods, which's 1 minute
    // by default.
    //

    ULONG               TimeToClose;

    //
    // For Log File ReCycling based on GMT time. 
    // And periodic buffer flushing.
    //

    UL_LOG_TIMER        BufferTimer;
    UL_LOG_TIMER        Timer;
    UL_WORK_ITEM        WorkItem; // For the pasive worker

    union
    {
        //
        // Flags to show the entry states mostly. Used by
        // recycling.
        //
        
        ULONG Value;
        struct
        {
            ULONG       StaleSequenceNumber:1;
            ULONG       StaleTimeToExpire:1;
            ULONG       HeaderWritten:1;
            ULONG       HeaderFlushPending:1;
            ULONG       RecyclePending:1;
            ULONG       Active:1;
            ULONG       LocaltimeRollover:1;

            ULONG       CreateFileFailureLogged:1;
            ULONG       WriteFailureLogged:1;
            
            ULONG       CacheFlushInProgress:1;
        };

    } Flags;

    ULONG               ServedCacheHit;
    
    //
    // The default buffer size is g_AllocationGranularity.
    // The operating system's allocation granularity.
    //

    PUL_LOG_FILE_BUFFER LogBuffer;

} UL_BINARY_LOG_FILE_ENTRY, *PUL_BINARY_LOG_FILE_ENTRY;

#define IS_VALID_BINARY_LOG_FILE_ENTRY( pEntry )                    \
    HAS_VALID_SIGNATURE(pEntry, UL_BINARY_LOG_FILE_ENTRY_POOL_TAG)

//
// Bitfields reserved for Method should be big enough to hold the max verb.
//

C_ASSERT(((USHORT)HttpVerbMaximum) < ((1 << 6) - 1));


///////////////////////////////////////////////////////////////////////////////
//
// Exported functions
//
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
UlInitializeBinaryLog(
    VOID
    );

VOID
UlTerminateBinaryLog(
    VOID
    );

NTSTATUS
UlCreateBinaryLogEntry(
    IN OUT PUL_CONTROL_CHANNEL pControlChannel,
    IN     PHTTP_CONTROL_CHANNEL_BINARY_LOGGING pUserConfig
    );
 
NTSTATUS
UlCaptureRawLogData(
    IN PHTTP_LOG_FIELDS_DATA pUserData,
    IN PUL_INTERNAL_REQUEST  pRequest,
    OUT PUL_LOG_DATA_BUFFER  *ppLogData
    );

NTSTATUS
UlRawLogHttpHit(
    IN PUL_LOG_DATA_BUFFER  pLogBuffer
    );

NTSTATUS
UlRawLogHttpCacheHit(
    IN PUL_FULL_TRACKER pTracker
    );

VOID
UlRemoveBinaryLogEntry(
    IN PUL_CONTROL_CHANNEL pControlChannel
    );

NTSTATUS
UlReConfigureBinaryLogEntry(
    IN OUT PUL_CONTROL_CHANNEL pControlChannel,
    IN PHTTP_CONTROL_CHANNEL_BINARY_LOGGING pCfgCurrent,
    IN PHTTP_CONTROL_CHANNEL_BINARY_LOGGING pCfgNew
    );

VOID
UlHandleCacheFlushedNotification(
    IN PUL_CONTROL_CHANNEL pControlChannel
    );

VOID
UlDisableIndexingForCacheHits(
    IN PUL_CONTROL_CHANNEL pControlChannel
    );

#endif  // _RAWLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\reftrace.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    reftrace.h

Abstract:

    This module contains public declarations and definitions for tracing
    and debugging reference count problems. This module uses the generic
    TRACE_LOG facility in tracelog.h.

    The REF_ACTION_* codes are declared separately in refaction.h

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _REFTRACE_H_
#define _REFTRACE_H_


//
// Pull in the action codes
//

#include "refaction.h"


#define REF_TRACE_PROCESSOR_BITS    6   // MAXIMUM_PROCESSORS == 64 on Win64
#define REF_TRACE_ACTION_BITS       (16 - REF_TRACE_PROCESSOR_BITS)

C_ASSERT((1 << REF_TRACE_PROCESSOR_BITS) >= MAXIMUM_PROCESSORS);
C_ASSERT((1 << REF_TRACE_ACTION_BITS) >= REF_ACTION_MAX);

#define REF_TRACE_CALL_STACK_DEPTH  3


//
// This defines the entry written to the trace log.
//

typedef struct _REF_TRACE_LOG_ENTRY
{
    PVOID     pContext;
    PCSTR     pFileName;
    PETHREAD  pThread;
    PVOID     CallStack[REF_TRACE_CALL_STACK_DEPTH];
    LONG      NewRefCount;
    USHORT    LineNumber;
    USHORT    Action    : REF_TRACE_ACTION_BITS;
    USHORT    Processor : REF_TRACE_PROCESSOR_BITS;

} REF_TRACE_LOG_ENTRY, *PREF_TRACE_LOG_ENTRY;

#define REF_TRACELOG_SIGNATURE MAKE_SIGNATURE('RfLg')


//
// Subtract REF_TRACE_OVERHEAD from a power of 2 when calculating the
// number of entries in a reftrace log, to ensure that overall size is
// a nice power of 2 and doesn't spill onto another page. This accounts
// for the size of the TRACE_LOG struct itself and the overhead
// imposed by the pool and the verifier. On x86, a REF_TRACE_LOG_ENTRY
// is currently 32 bytes. If you modify the struct, please recalculate
// REF_TRACE_OVERHEAD and *change the per-object* reftrace logs (in
// UL_CONNECTION, UL_HTTP_CONNECTION, UL_TCI_INTERFACE, 
// and UL_INTERNAL_REQUEST) accordingly.
//

#define REF_TRACE_OVERHEAD 2        // entries



//
// Manipulators.
//

PTRACE_LOG
CreateRefTraceLog(
    IN ULONG             LogSize,
    IN ULONG             ExtraBytesInHeader,
    IN TRACELOG_PRIORITY AllocationPriority,
    IN ULONG             PoolTag
    );

VOID
DestroyRefTraceLog(
    IN PTRACE_LOG pLog,
    IN ULONG      PoolTag
    );

VOID
ResetRefTraceLog(
    IN PTRACE_LOG pLog
    );

LONGLONG
WriteRefTraceLog(
    IN PTRACE_LOG pLog,
    IN PTRACE_LOG pLog2,
    IN USHORT     Action,
    IN LONG       NewRefCount,
    IN PVOID      pContext,
    IN PCSTR      pFileName,
    IN USHORT     LineNumber
    );


#if REFERENCE_DEBUG

#define CREATE_REF_TRACE_LOG( ptr, size, extra, pri, pooltag )              \
    (ptr) = CreateRefTraceLog( (size), (extra), (pri), (pooltag) )

#define DESTROY_REF_TRACE_LOG( ptr, pooltag )                               \
    do                                                                      \
    {                                                                       \
        DestroyRefTraceLog( ptr, pooltag );                                 \
        (ptr) = NULL;                                                       \
    } while (FALSE, FALSE)

#define RESET_REF_TRACE_LOG( ptr )                                          \
    ResetRefTraceLog( ptr )

#define WRITE_REF_TRACE_LOG( plog, act, ref, pctx, pfile, line )            \
    WriteRefTraceLog(                                                       \
        (plog),                                                             \
        NULL,                                                               \
        (act),                                                              \
        (ref),                                                              \
        (pctx),                                                             \
        (pfile),                                                            \
        (line)                                                              \
        )

#define WRITE_REF_TRACE_LOG2( plog1, plog2, act, ref, pctx, pfile, line )   \
    WriteRefTraceLog(                                                       \
        (plog1),                                                            \
        (plog2),                                                            \
        (act),                                                              \
        (ref),                                                              \
        (pctx),                                                             \
        (pfile),                                                            \
        (line)                                                              \
        )

#else // !REFERENCE_DEBUG

#define CREATE_REF_TRACE_LOG( ptr, size, extra, pri, pooltag )      NOP_FUNCTION
#define DESTROY_REF_TRACE_LOG( ptr, pooltag )                       NOP_FUNCTION
#define RESET_REF_TRACE_LOG( ptr )                                  NOP_FUNCTION
#define WRITE_REF_TRACE_LOG( plog, act, ref, pctx, pfile, line )    NOP_FUNCTION
#define WRITE_REF_TRACE_LOG2( plog1, plog2 , act, ref, pctx, pfile, line ) \
    NOP_FUNCTION

#endif // !REFERENCE_DEBUG


#endif  // _REFTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\rwlock.c ===
/*++

Copyright (c) 2001-2002 Microsoft Corporation

Module Name:

    rwlock.c

Abstract:

    Non-inline functions for custom locks
    
Author:

    George V. Reilly  Jul-2001

Revision History:

--*/


#include <precomp.h>


#ifdef ALLOC_PRAGMA
#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlpSwitchToThread
NOT PAGEABLE -- UlAcquireRWSpinLockSharedDoSpin
NOT PAGEABLE -- UlAcquireRWSpinLockExclusiveDoSpin
#endif


// ZwYieldExecution is the actual kernel-mode implementation of SwitchToThread.
NTSYSAPI
NTSTATUS
NTAPI
ZwYieldExecution (
    VOID
    );


/***************************************************************************++

Routine Description:

    Yield the processor to another thread

Arguments:

    None

Return Value:

    None

--***************************************************************************/
VOID
UlpSwitchToThread()
{
    //
    // If we're running at DISPATCH_LEVEL or higher, the scheduler won't
    // run, so other threads can't run on this processor, and the only
    // appropriate action is to keep on spinning.
    //

    if (KeGetCurrentIrql() >= DISPATCH_LEVEL)
        return;

    //
    // Use KeDelayExecutionThread instead? ZwYieldExecution returns
    // immediately if there are no runnable threads on this processor.
    //

    ZwYieldExecution();
}
    

/***************************************************************************++

Routine Description:

    Spin until we can successfully acquire the lock for shared access.

Arguments:

    pRWSpinLock - the lock to acquire

Return Value:

    None

--***************************************************************************/
VOID
UlAcquireRWSpinLockSharedDoSpin(
    PRWSPINLOCK pRWSpinLock
    )
{
    LONG OuterLoop;

    //
    // CODEWORK: add some global instrumentation to keep track of
    // how often we need to spin and how long we actually spin
    //
    
    for (OuterLoop = 1;  TRUE;  ++OuterLoop)
    {
        //
        // There's no point in spinning on a uniprocessor system because
        // we'll just spin and spin and spin until this thread's quantum is
        // exhausted. We should yield immediately after one test of the lock
        // so that the thread that holds the lock has a chance to proceed and
        // release the lock sooner. That's assuming we're running at passive
        // level. If we're running at dispatch level and the owning thread
        // isn't running, we have a biiiig problem.
        //
        // On a multiprocessor system, it's appropriate to spin for a while
        // before yielding the processor.
        //
        
        LONG Spins = (g_UlNumberOfProcessors == 1) ? 1 : 4000;

        while (--Spins >= 0)
        {
            volatile LONG CurrentState   = pRWSpinLock->CurrentState;
            volatile LONG WritersWaiting = pRWSpinLock->WritersWaiting;

            //
            // If either (1) write lock is acquired (CurrentState ==
            // RWSL_LOCKED) or (2) there is a writer waiting for the lock
            // then skip it this time and retry in a tight loop
            //
            
            if ((CurrentState != RWSL_LOCKED) && (WritersWaiting == 0))
            {
                //
                // if number of readers is unchanged, increase it by 1
                //

                if (CurrentState
                    == (LONG) InterlockedCompareExchange(
                                    (PLONG) &pRWSpinLock->CurrentState,
                                    CurrentState + 1,
                                    CurrentState)
                    )
                {
#if DBG
                    ASSERT(pRWSpinLock->pExclusiveOwner == NULL);
#endif
                    return;
                }
            }

            //
            // On Jackson technology Pentium 4s, this will give the lion's
            // share of the cycles to the other processor on the chip.
            //
                
            PAUSE_PROCESSOR;
        }

        //
        // Couldn't acquire the lock in the inner loop. Yield the CPU
        // for a while in the hopes that the owning thread will release
        // the lock in the meantime.
        //
        
        UlpSwitchToThread();
    }
} // UlAcquireRWSpinLockSharedDoSpin


/***************************************************************************++

Routine Description:

    Spin until we can successfully acquire the lock for exclusive access.

Arguments:

    pRWSpinLock - the lock to acquire

Return Value:

    None

--***************************************************************************/
VOID
UlAcquireRWSpinLockExclusiveDoSpin(
    PRWSPINLOCK pRWSpinLock
    )
{
    LONG OuterLoop;
    
    for (OuterLoop = 1;  TRUE;  ++OuterLoop)
    {
        LONG Spins = (g_UlNumberOfProcessors == 1) ? 1 : 4000;
        
        while (--Spins >= 0)
        {
            //
            // Is the lock currently free for the taking?
            //
            
            if (pRWSpinLock->CurrentState == RWSL_FREE)
            {
                if (RWSL_FREE == InterlockedCompareExchange(
                                        (PLONG) &pRWSpinLock->CurrentState,
                                        RWSL_LOCKED,
                                        RWSL_FREE)
                    )
                {
#if DBG
                    ASSERT(pRWSpinLock->pExclusiveOwner == NULL);
                    pRWSpinLock->pExclusiveOwner = PsGetCurrentThread();
#endif
                    return;
                }
            }

            PAUSE_PROCESSOR;
        }
        
        UlpSwitchToThread();
    }
} // UlAcquireRWSpinLockExclusiveDoSpin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\rwlock.h ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    rwlock.h

Abstract:

    This module contains public declarations for a
    multiple-reader/single-writer lock.

Author:

    Chun Ye (chunye)    20-Dec-2000

Revision History:

--*/


#ifndef _RWLOCK_H_
#define _RWLOCK_H_

//
// Reader-Writer Spinlock definitions.
// Runs at PASSIVE_LEVEL so it's suitable for both paged and non-paged data.
//

#define RWSL_LOCKED   ((ULONG) (-1))
#define RWSL_FREE     (0)

typedef struct _RWSPINLOCK
{
    union
    {
        struct
        {
            // 0 == RWSL_FREE       => unowned
            // >0                   => count of readers (shared)
            // <0 == RWSL_LOCKED    => exclusively owned
            volatile LONG CurrentState; 

            // all writers, including the one that holds the lock
            // exclusively, if at all
            volatile LONG WritersWaiting;

#if DBG
            PETHREAD      pExclusiveOwner;
#endif
        };

        ULONGLONG Alignment;
    };
} RWSPINLOCK, *PRWSPINLOCK;


VOID
UlAcquireRWSpinLockSharedDoSpin(
    PRWSPINLOCK pRWSpinLock
    );

VOID
UlAcquireRWSpinLockExclusiveDoSpin(
    PRWSPINLOCK pRWSpinLock
    );

/***************************************************************************++

Routine Description:

    Initialize the Reader-Writer lock.

Return Value:

--***************************************************************************/
__inline
VOID
UlInitializeRWSpinLock(
    PRWSPINLOCK pRWSpinLock
    )
{
    // pRWSpinLock->CurrentState: Number of Readers, RWSL_FREE: 0

    pRWSpinLock->CurrentState = RWSL_FREE;

    // pRWSpinLock->WritersWaiting: Number of Writers

    pRWSpinLock->WritersWaiting = 0;

#if DBG
    pRWSpinLock->pExclusiveOwner = NULL;
#endif
} // UlInitializeRWSpinLock



/***************************************************************************++

Routine Description:

    Acquire the Reader lock.

Return Value:

--***************************************************************************/
__inline
VOID
UlAcquireRWSpinLockShared(
    PRWSPINLOCK pRWSpinLock
    )
{
    LONG CurrentState, WritersWaiting;

    //
    // Prevent kernel APCs from being delivered. If we received a suspend
    // APC, while we held the lock, it would be disastrous. The thread would
    // hang until it was eventually resumed, and other threads would spin
    // until the lock was released.
    //

    KeEnterCriticalRegion();

    //
    // If either (1) lock is acquired exclusively (CurrentState ==
    // RWSL_LOCKED) or (2) there is a writer waiting for the lock, then
    // we'll take the slow path
    //

    CurrentState   = pRWSpinLock->CurrentState;
    WritersWaiting = pRWSpinLock->WritersWaiting;

    if ((CurrentState != RWSL_LOCKED) && (WritersWaiting == 0))
    {
        //
        // Check if number of readers is unchanged
        // Increase it by 1, if possible
        //

        if (CurrentState == (LONG) InterlockedCompareExchange(
                                        (PLONG) &pRWSpinLock->CurrentState,
                                        CurrentState + 1,
                                        CurrentState)
            )
        {
#if DBG
            ASSERT(pRWSpinLock->pExclusiveOwner == NULL);
#endif

            return;
        }
    }

    //
    // Take the slow path and spin until the lock can be acquired
    //

    UlAcquireRWSpinLockSharedDoSpin(pRWSpinLock);
    
} // UlAcquireRWSpinLockShared



/***************************************************************************++

Routine Description:

    Release the Reader lock.

Return Value:

--***************************************************************************/
__inline
VOID
UlReleaseRWSpinLockShared(
    PRWSPINLOCK pRWSpinLock
    )
{
    // decrease number of readers by 1

    LONG NewState = InterlockedDecrement((PLONG) &pRWSpinLock->CurrentState);

    ASSERT(NewState >= 0);
    UNREFERENCED_PARAMETER(NewState);

    KeLeaveCriticalRegion();

} // UlReleaseRWSpinLockShared



/***************************************************************************++

Routine Description:

    Acquire the Writer lock.

Return Value:

--***************************************************************************/
__inline
VOID
UlAcquireRWSpinLockExclusive(
    PRWSPINLOCK pRWSpinLock
    )
{
    LONG WritersWaiting;

    //
    // Prevent kernel APCs from being delivered.
    //

    KeEnterCriticalRegion();

    //
    // First, increment the number of writers by 1. This will block readers
    // from acquiring the lock, giving writers priority over readers.
    //

    WritersWaiting = InterlockedIncrement(
                            (PLONG) &pRWSpinLock->WritersWaiting);

    ASSERT(WritersWaiting > 0);
    
    //
    // Interlocked change the number of readers to -1 (RWSL_LOCKED)
    //

    if (pRWSpinLock->CurrentState == RWSL_FREE)
    {
        if (RWSL_FREE == InterlockedCompareExchange(
                                (PLONG) &pRWSpinLock->CurrentState,
                                RWSL_LOCKED,
                                RWSL_FREE)
            )
        {
#if DBG
            ASSERT(pRWSpinLock->pExclusiveOwner == NULL);
            pRWSpinLock->pExclusiveOwner = PsGetCurrentThread();
#endif
            return;
        }
    }

    //
    // Take the slow path and spin until the lock can be acquired
    //

    UlAcquireRWSpinLockExclusiveDoSpin(pRWSpinLock);

} // UlAcquireRWSpinLockExclusive



/***************************************************************************++

Routine Description:

    Release the Writer lock.

Return Value:

--***************************************************************************/
__inline
void
UlReleaseRWSpinLockExclusive(
    PRWSPINLOCK pRWSpinLock
    )
{
    LONG OldState, NewWaiting;
    
#if DBG
    ASSERT(pRWSpinLock->pExclusiveOwner == PsGetCurrentThread());
    pRWSpinLock->pExclusiveOwner = NULL;
#endif

    //
    // Update pRWSpinLock->CurrentState and pRWSpinLock->WritersWaiting back
    // in the reverse order of AcquireRWSpinLockExclusive()
    //

    OldState = InterlockedExchange(
                    (PLONG) &pRWSpinLock->CurrentState,
                    RWSL_FREE);

    ASSERT(OldState == RWSL_LOCKED);
    UNREFERENCED_PARAMETER(OldState);

    NewWaiting = InterlockedDecrement((PLONG) &pRWSpinLock->WritersWaiting);

    ASSERT(NewWaiting >= 0);
    UNREFERENCED_PARAMETER(NewWaiting);

    KeLeaveCriticalRegion();

} // UlReleaseRWSpinLockExclusive



/***************************************************************************++

Routine Description:

    Check if the Reader lock is acquired.

Return Value:

    TRUE    - Acquired
    FALSE   - NOT Acquired

--***************************************************************************/
__inline
BOOLEAN
UlRWSpinLockIsLockedShared(
    PRWSPINLOCK pRWSpinLock
    )
{
    // BUGBUG: this routine does not prove that THIS thread is one
    // of the shared holders of the lock, merely that at least one
    // thread holds the lock in a shared state. Perhaps some extra
    // instrumentation for debug builds?

    return (BOOLEAN) (pRWSpinLock->CurrentState > 0);
} // UlRWSpinLockIsLockedShared



/***************************************************************************++

Routine Description:

    Check if the Writer lock is acquired.

Return Value:

    TRUE    - Acquired
    FALSE   - NOT Acquired

--***************************************************************************/
__inline
BOOLEAN
UlRWSpinLockIsLockedExclusive(
    PRWSPINLOCK pRWSpinLock
    )
{
    BOOLEAN IsLocked = (BOOLEAN) (pRWSpinLock->CurrentState == RWSL_LOCKED);

    // If it's locked, then we must have added ourselves to WritersWaiting
    ASSERT(!IsLocked || pRWSpinLock->WritersWaiting > 0);

    ASSERT(IsLocked
            ? pRWSpinLock->pExclusiveOwner == PsGetCurrentThread()
            : pRWSpinLock->pExclusiveOwner == NULL);

    return IsLocked;
} // UlRWSpinLockIsLockedExclusive

#endif  // _RWLOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\reftrace.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    reftrace.c

Abstract:

    This module implements a reference count tracing facility.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include "precomp.h"


#if !REFERENCE_DEBUG

static int g_RefTraceDummyDeclarationToKeepW4WarningsQuiet;

#else

/***************************************************************************++

Routine Description:

    Creates a new (empty) ref count trace log buffer.

Arguments:

    LogSize - Supplies the number of entries in the log.

    ExtraBytesInHeader - Supplies the number of extra bytes to include
        in the log header. This is useful for adding application-
        specific data to the log.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--***************************************************************************/
PTRACE_LOG
CreateRefTraceLog(
    IN ULONG             LogSize,
    IN ULONG             ExtraBytesInHeader,
    IN TRACELOG_PRIORITY AllocationPriority,
    IN ULONG             PoolTag
    )
{
    return CreateTraceLog(
               REF_TRACELOG_SIGNATURE,
               LogSize,
               ExtraBytesInHeader,
               sizeof(REF_TRACE_LOG_ENTRY),
               AllocationPriority,
               PoolTag
               );

}   // CreateRefTraceLog


/***************************************************************************++

Routine Description:

    Destroys a ref count trace log buffer created with CreateRefTraceLog().

Arguments:

    pLog - Supplies the ref count trace log buffer to destroy.

--***************************************************************************/
VOID
DestroyRefTraceLog(
    IN PTRACE_LOG pLog,
    IN ULONG      PoolTag
    )
{
    DestroyTraceLog( pLog, PoolTag );

}   // DestroyRefTraceLog


/***************************************************************************++

Routine Description:

    W/O destroying the ref trace this function simply does reset and cleanup.

Arguments:

    pLog - Supplies the ref count trace log buffer to destroy.

--***************************************************************************/
VOID
ResetRefTraceLog(
    IN PTRACE_LOG pLog
    )
{
    ResetTraceLog( pLog );

}   // ResetTraceLog

/***************************************************************************++

Routine Description:

    Writes a new entry to the specified ref count trace log.

Arguments:

    pLog - Supplies the log to write to.

    pLog2 - Supplies a secondary log to write to.

    Action - Supplies an action code for the new log entry.

    NewRefCount - Supplies the updated reference count.

    pContext - Supplies an uninterpreted context to associate with
        the log entry.

    pFileName - Supplies the filename of the routine writing the log entry.

    LineNumber - Supplies he line number of the routine writing the log
        entry.

--***************************************************************************/
LONGLONG
WriteRefTraceLog(
    IN PTRACE_LOG pLog,
    IN PTRACE_LOG pLog2,
    IN USHORT     Action,
    IN LONG       NewRefCount,
    IN PVOID      pContext,
    IN PCSTR      pFileName,
    IN USHORT     LineNumber
    )
{
    REF_TRACE_LOG_ENTRY entry;
    LONGLONG index;
    ULONG hash;

    ASSERT(Action < (1 << REF_TRACE_ACTION_BITS));

    //
    // Initialize the entry.
    //

    RtlCaptureStackBackTrace(
        2,
        REF_TRACE_CALL_STACK_DEPTH,
        entry.CallStack,
        &hash
        );

    entry.NewRefCount = NewRefCount;
    entry.pContext = pContext;
    entry.pFileName = pFileName;
    entry.LineNumber = LineNumber;
    entry.Action = Action;
    entry.Processor = (UCHAR)KeGetCurrentProcessorNumber();
    entry.pThread = PsGetCurrentThread();

    //
    // Write it to the logs.
    //

    WriteTraceLog( g_pMondoGlobalTraceLog, &entry );
    index = WriteTraceLog( pLog, &entry );

    if (pLog2 != NULL)
        index = WriteTraceLog( pLog2, &entry );

    return index;

}   // WriteRefTraceLog

#endif  // REFERENCE_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\rawlogp.h ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    rawlogp.h (Centralized Binary (Raw) Logging v1.0)

Abstract:

    Private header file for the Binary (Raw) Logging.
    
Author:

    Ali E. Turkoglu (aliTu)       04-Oct-2001

Revision History:

    ---
    
--*/

#ifndef _RAWLOGP_H_
#define _RAWLOGP_H_

///////////////////////////////////////////////////////////////////////////////
//
// Private definitions for the HTTP Binary Logging Module
//
///////////////////////////////////////////////////////////////////////////////

//
// Only one binary log file allowed.
//

#define IS_BINARY_LOGGING_STARTED()  (g_BinaryLogEntryCount != 0)

#define INCREMENT_BINARY_LOGGING_STATE(Started)  \
    (InterlockedIncrement(&g_BinaryLogEntryCount))

//
// Binary file name related. IBL stands for internet binary log.
//

#define BINARY_LOG_FILE_NAME_PREFIX              L"\\raw"

#define BINARY_LOG_FILE_NAME_EXTENSION           L"ibl"
#define BINARY_LOG_FILE_NAME_EXTENSION_PLUS_DOT  L".ibl"

//
// Buffering related....
//

#define DEFAULT_BINARY_LOG_FILE_BUFFER_SIZE             (0x00010000)

//
// Buffer flush out period in minutes.
//

#define DEFAULT_BINARY_LOG_BUFFER_TIMER_PERIOD_IN_MIN   (1)

//
// To be able to limit the binary log index record size, we have 
// to enforce a certain limit to the length of the strings.
//

#define MAX_BINARY_LOG_INDEX_STRING_LEN                 (4096)

//
// UserName field has its own field limitation.
//

#define MAX_BINARY_LOG_URL_STRING_LEN                   (4096)
#define MAX_BINARY_LOG_USERNAME_STRING_LEN              (256)

//
// Two macros for getting abs path (and its size) from uri cache entry.
//

#define URI_SIZE_FROM_CACHE(UriKey)                             \
       ((UriKey).Length - ((UriKey).pPath ?                     \
                (DIFF((UriKey).pPath - (UriKey).pUri) * sizeof(WCHAR)) : 0))


#define URI_FROM_CACHE(UriKey)                                  \
       ((UriKey).pPath ? (UriKey).pPath : (UriKey).pUri)



///////////////////////////////////////////////////////////////////////////////
//
// Private function calls
//
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
UlpDisableBinaryEntry(
    IN OUT PUL_BINARY_LOG_FILE_ENTRY pEntry
    );

NTSTATUS
UlpRecycleBinaryLogFile(
    IN OUT PUL_BINARY_LOG_FILE_ENTRY pEntry
    );

NTSTATUS
UlpHandleBinaryLogFileRecycle(
    IN OUT PVOID pContext
    );

NTSTATUS
UlpCreateBinaryLogFile(
    IN OUT PUL_BINARY_LOG_FILE_ENTRY pEntry,
    IN     PUNICODE_STRING           pDirectory
    );

__inline
UCHAR
UlpHttpVersionToBinaryLogVersion(
    IN HTTP_VERSION version
    )
{
    if (HTTP_EQUAL_VERSION(version, 0, 9))
    {
        return BINARY_LOG_PROTOCOL_VERSION_HTTP09;
    }
    else if (HTTP_EQUAL_VERSION(version, 1, 0))
    {
        return BINARY_LOG_PROTOCOL_VERSION_HTTP10;
    }
    else if (HTTP_EQUAL_VERSION(version, 1, 1))
    {
        return BINARY_LOG_PROTOCOL_VERSION_HTTP11;
    }

    return BINARY_LOG_PROTOCOL_VERSION_UNKNWN;
}

ULONG
UlpRawCopyLogHeader(
    IN PUCHAR pBuffer
    );

ULONG
UlpRawCopyLogFooter(
    IN PUCHAR pBuffer
    );

VOID
UlpRawCopyCacheNotification(
    IN PVOID   pContext,
    IN PUCHAR  pBuffer,
    IN ULONG   BytesRequired
    );

VOID
UlpRawCopyForLogCacheMiss(
    IN PVOID   pContext,
    IN PUCHAR  pBuffer,
    IN ULONG   BytesRequired
    );

VOID
UlpRawCopyForLogCacheHit(
    IN PVOID   pContext,
    IN PUCHAR  pBuffer,
    IN ULONG   BytesRequired
    );

typedef
VOID
(*PUL_RAW_LOG_COPIER)(
    IN PVOID               pContext,  
    IN PUCHAR              pBuffer,
    IN ULONG               BytesRequired
    );

VOID
UlpEventLogRawWriteFailure(
    IN PUL_BINARY_LOG_FILE_ENTRY pEntry,
    IN NTSTATUS Status
    );

NTSTATUS
UlpFlushRawLogFile(
    IN PUL_BINARY_LOG_FILE_ENTRY  pEntry
    );

__inline
NTSTATUS
UlpCheckRawFile(
    IN OUT PUL_BINARY_LOG_FILE_ENTRY pEntry,
    IN     PUL_CONTROL_CHANNEL       pControlChannel
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING pDirectory = NULL;
    
    ASSERT(IS_VALID_CONTROL_CHANNEL(pControlChannel));
    ASSERT(IS_VALID_BINARY_LOG_FILE_ENTRY(pEntry));

    //
    // We can grap the file buffer and do our copy in place while holding the
    // entry lock shared. This will prevent the buffer flush and the extra copy.
    // But first let's see if we have to create/open the file.
    //
    
    if (!pEntry->Flags.Active)
    {    
        UlAcquirePushLockExclusive(&pEntry->PushLock);

        //
        // Ping again to see if we have been blocked on the lock, and
        // somebody else already took care of the creation.
        //
        
        if (!pEntry->Flags.Active)
        {
            //
            // It's possible that LogFileDir.Buffer could be NULL, 
            // if the allocation failed during the Set cgroup ioctl.
            //
            
            pDirectory = &pControlChannel->BinaryLoggingConfig.LogFileDir;

            if (pDirectory->Buffer)
            {
                Status = UlpCreateBinaryLogFile(pEntry, pDirectory);
            }
            else
            {
                Status = STATUS_INVALID_PARAMETER;
            }
        }
        
        UlReleasePushLockExclusive(&pEntry->PushLock);

        if (!NT_SUCCESS(Status))
        {
            return Status;
        }
    }
    
    return Status;    
}

/***************************************************************************++

Routine Description:

    When the log file is on size based recycling and if we write this new 
    record to the file, we have to recycle. This function returns TRUE.
    Otherwise it returns FALSE.

Arguments:

    pEntry: The log file entry.    
    NewRecordSize: The size of the new record going to the buffer. (Bytes)

--***************************************************************************/

__inline
BOOLEAN
UlpIsRawLogFileOverFlow(
        IN  PUL_BINARY_LOG_FILE_ENTRY  pEntry,
        IN  ULONG NewRecordSize
        )
{
    if (pEntry->Period != HttpLoggingPeriodMaxSize ||
        pEntry->TruncateSize == HTTP_LIMIT_INFINITE)
    {
        return FALSE;
    }
    else
    {
        //
        // BufferUsed: Amount of log buffer we are >currently< using.
        //
        
        ULONG BufferUsed = 0;
        
        if (pEntry->LogBuffer)
        {
            BufferUsed = pEntry->LogBuffer->BufferUsed;
        }
    
        //
        // TotalWritten get updated >only< with buffer flush. Therefore
        // we have to pay attention to the buffer used.
        //

        if ((pEntry->TotalWritten.QuadPart
             + (ULONGLONG) BufferUsed
             + (ULONGLONG) NewRecordSize
             ) >= (ULONGLONG) pEntry->TruncateSize)
        {
            UlTrace(BINARY_LOGGING, 
                ("Http!UlpIsRawLogFileOverFlow: pEntry %p FileBuffer %p "
                 "TW:%I64d B:%d R:%d T:%d\n", 
                  pEntry,
                  pEntry->LogBuffer,
                  pEntry->TotalWritten.QuadPart,
                  BufferUsed,
                  NewRecordSize,
                  pEntry->TruncateSize
                  ));
        
            return TRUE;
        }
        else
        {
            return FALSE;
        }
        
    }
}

/***************************************************************************++

Routine Description:

    This will calculate the index record size for a given cache entry.
    
Arguments:

    pUriEntry: The uri cache entry.    

Returns

    The index record size.
    
--***************************************************************************/

__inline
ULONG
UlpGetIndexRecordSize(
    IN PUL_URI_CACHE_ENTRY  pUriEntry
    )
{
    ULONG IndexBytes;    
    ULONG UriSize;

    ASSERT(IS_VALID_URI_CACHE_ENTRY(pUriEntry));

    UriSize = URI_SIZE_FROM_CACHE(pUriEntry->UriKey)   ;
    ASSERT(UriSize != 0); // We cannot write an index for nothing
        
    IndexBytes = sizeof(HTTP_RAW_INDEX_FIELD_DATA);

    //
    // Carefull with the inlined part, the 4 bytes  of
    // the uri will be inlined inside the index struct.
    //
    
    if (UriSize > URI_BYTES_INLINED)
    {
        IndexBytes += ALIGN_UP((UriSize - URI_BYTES_INLINED),PVOID);
    }

    ASSERT(IndexBytes == ALIGN_UP(IndexBytes, PVOID));

    return  IndexBytes;
}

NTSTATUS
UlpWriteToRawLogFileDebug(
    IN PUL_BINARY_LOG_FILE_ENTRY pEntry,
    IN ULONG                     BytesRequired,
    IN PUL_RAW_LOG_COPIER        pBufferWritter,
    IN PVOID                     pContext,
    OUT PLONG                    pBinaryIndexWritten        
    );

NTSTATUS
UlpWriteToRawLogFileShared(
    IN PUL_BINARY_LOG_FILE_ENTRY pEntry,
    IN ULONG                     BytesRequired,
    IN PUL_RAW_LOG_COPIER        pBufferWritter,
    IN PVOID                     pContext,
    OUT PLONG                    pBinaryIndexWritten        
    );

NTSTATUS
UlpWriteToRawLogFileExclusive(
    IN PUL_BINARY_LOG_FILE_ENTRY pEntry,
    IN ULONG                     BytesRequired,
    IN PUL_RAW_LOG_COPIER        pBufferWritter,
    IN PVOID                     pContext,
    OUT PLONG                    pBinaryIndexWritten        
    );

NTSTATUS
UlpWriteToRawLogFile(
    IN PUL_BINARY_LOG_FILE_ENTRY pEntry,
    IN PUL_URI_CACHE_ENTRY       pUriEntry,        
    IN ULONG                     RecordSize,
    IN PUL_RAW_LOG_COPIER        pBufferWritter,
    IN PVOID                     pContext
    );
 
VOID
UlpBinaryBufferTimerDpcRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );

VOID
UlpBinaryBufferTimerHandler(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpBinaryLogTimerDpcRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );

VOID
UlpBinaryLogTimerHandler(
    IN PUL_WORK_ITEM    pWorkItem
    );

#endif  // _RAWLOGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\refaction.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    refaction.h

Abstract:

    Action codes for reftracing http.sys. The !httpkd.ref debugger extension
    uses this file with a different definition of REF_ACTION() to
    print out symbolic information.

--*/

//
// Action codes.
//

#ifndef BEGIN_REF_ACTION
# define BEGIN_REF_ACTION()     typedef enum _REFTRACE_ACTION {
# define END_REF_ACTION()       } REFTRACE_ACTION, *PREFTRACE_ACTION;
# define REF_ACTION(x)          REF_ACTION_##x ,
#endif // !BEGIN_REF_ACTION

BEGIN_REF_ACTION()
    REF_ACTION( NO_OP )  // == 0
    
    REF_ACTION( REFERENCE_ENDPOINT )
    REF_ACTION( DEREFERENCE_ENDPOINT )

    REF_ACTION( REFERENCE_ENDPOINT_USAGE )
    REF_ACTION( DEREFERENCE_ENDPOINT_USAGE )

    REF_ACTION( REFERENCE_UL_CONNECTION )
    REF_ACTION( DEREFERENCE_UL_CONNECTION )
    REF_ACTION( ALLOC_UL_CONNECTION )
    REF_ACTION( FREE_UL_CONNECTION )
    REF_ACTION( ENQUEUE_UL_CONNECTION )
    REF_ACTION( DEQUEUE_UL_CONNECTION )

    REF_ACTION( SEND_AND_DISCONNECT )
    REF_ACTION( CLOSE_UL_CONN_GRACEFUL )
    REF_ACTION( CLOSE_UL_CONN_ABORTIVE )
    REF_ACTION( CLOSE_UL_CONN_RAW_CLOSE )
    REF_ACTION( CLOSE_UL_CONN_FORCE_ABORT )
    REF_ACTION( CLOSE_UL_CONN_ABORT_DISCONNECT )
    REF_ACTION( DRAIN_UL_CONN_START )
    REF_ACTION( DRAIN_UL_CONN_RESTART )
    REF_ACTION( DRAIN_UL_CONN_DISCONNECT_COMPLETE )
    REF_ACTION( ABORT_INDICATED )
    REF_ACTION( DISCONNECT_INDICATED )
    REF_ACTION( DISCONNECT_HANDLER )

    REF_ACTION( INIT )
    REF_ACTION( REPLENISH )
    REF_ACTION( CONNECT )
    REF_ACTION( RESTART_ACCEPT )
    REF_ACTION( DISCONN_ACTIVE )
    REF_ACTION( UNBIND_CONN )
    REF_ACTION( DISCONN_ALL )
    REF_ACTION( FINAL_DEREF )
    REF_ACTION( CONN_CLEANUP )
    REF_ACTION( CLEAN_BACKING_LIST )

    REF_ACTION( ADD_URI_ENTRY )
    REF_ACTION( CHECKIN_URI_ENTRY )
    REF_ACTION( CHECKOUT_URI_ENTRY )
    REF_ACTION( FLUSH_URI_ENTRY )
    REF_ACTION( FILTER_URI_ENTRY )
    REF_ACTION( CREATE_URI_ENTRY )
    REF_ACTION( ZOMBIFY_URI_ENTRY )
    REF_ACTION( UNZOMBIFY_URI_ENTRY )
    REF_ACTION( CLEAR_URI_ENTRY )

    REF_ACTION( ALLOCATE_MDL )
    REF_ACTION( FREE_MDL )
    REF_ACTION( SEND_MDL )
    REF_ACTION( SEND_MDL_COMPLETE )

    REF_ACTION( ACQUIRE_RESOURCE_EXCLUSIVE )
    REF_ACTION( ACQUIRE_RESOURCE_SHARED )
    REF_ACTION( RELEASE_RESOURCE )
    REF_ACTION( CONVERT_RESOURCE_EXCLUSIVE_TO_SHARED )
    REF_ACTION( TRY_ACQUIRE_RESOURCE_EXCLUSIVE )

    REF_ACTION( ACQUIRE_PUSH_LOCK_EXCLUSIVE )
    REF_ACTION( ACQUIRE_PUSH_LOCK_SHARED )
    REF_ACTION( RELEASE_PUSH_LOCK )

    REF_ACTION( REFERENCE_HTTP_CONNECTION )
    REF_ACTION( DEREFERENCE_HTTP_CONNECTION )
    REF_ACTION( DESTROY_HTTP_CONNECTION )
    REF_ACTION( EXPIRE_HTTP_CONNECTION )

    REF_ACTION( REFERENCE_HTTP_REQUEST )
    REF_ACTION( DEREFERENCE_HTTP_REQUEST )

    REF_ACTION( INSERT_BUFFER )
    REF_ACTION( INSERT_REQUEST )

    REF_ACTION( REFERENCE_BUFFER )
    REF_ACTION( DEREFERENCE_BUFFER )

    REF_ACTION( REFERENCE_APP_POOL )
    REF_ACTION( DEREFERENCE_APP_POOL )

    REF_ACTION( REFERENCE_APP_POOL_PROCESS )
    REF_ACTION( DEREFERENCE_APP_POOL_PROCESS )        

    REF_ACTION( REFERENCE_CONFIG_GROUP )
    REF_ACTION( DEREFERENCE_CONFIG_GROUP )

    REF_ACTION( REFERENCE_CONTROL_CHANNEL )
    REF_ACTION( DEREFERENCE_CONTROL_CHANNEL )
    REF_ACTION( CREATE_CONTROL_CHANNEL )
    REF_ACTION( CLEANUP_CONTROL_CHANNEL )
    REF_ACTION( CLOSE_CONTROL_CHANNEL )

    REF_ACTION( REFERENCE_HTTP_RESPONSE )
    REF_ACTION( DEREFERENCE_HTTP_RESPONSE )

    REF_ACTION( REFERENCE_FILTER )
    REF_ACTION( DEREFERENCE_FILTER )

    REF_ACTION( REFERENCE_SITE_COUNTER_ENTRY )
    REF_ACTION( DEREFERENCE_SITE_COUNTER_ENTRY )

    REF_ACTION( REFERENCE_CONFIG_GROUP_INFO )
    REF_ACTION( DEREFERENCE_CONFIG_GROUP_INFO )

    REF_ACTION( REFERENCE_CONNECTION_COUNT_ENTRY )
    REF_ACTION( DEREFERENCE_CONNECTION_COUNT_ENTRY )

    REF_ACTION( REFERENCE_CHUNK_TRACKER )
    REF_ACTION( DEREFERENCE_CHUNK_TRACKER )

    REF_ACTION( REFERENCE_THREAD )
    REF_ACTION( DEREFERENCE_THREAD )

    REF_ACTION( TC_ALLOC )    
    REF_ACTION( TC_UP )  
    REF_ACTION( TC_DOWN )  
    REF_ACTION( TC_CHANGE ) 
    REF_ACTION( TC_GFLOW_ADD ) 
    REF_ACTION( TC_GFLOW_REMOVE ) 
    REF_ACTION( TC_GFLOW_MODIFY ) 
    REF_ACTION( TC_FLOW_ADD ) 
    REF_ACTION( TC_FLOW_REMOVE ) 
    REF_ACTION( TC_FLOW_MODIFY )     
    REF_ACTION( TC_CLOSE )

    REF_ACTION( QUEUE_WORK_ITEM )
    REF_ACTION( QUEUE_SYNC_ITEM )
    REF_ACTION( QUEUE_WAIT_ITEM )
    REF_ACTION( QUEUE_HIGH_PRIORITY_ITEM )
    REF_ACTION( CALL_PASSIVE )
    REF_ACTION( FLUSH_WORK_ITEM )
    REF_ACTION( PROCESS_WORK_ITEM )
    REF_ACTION( PUSH_BACK_WORK_ITEM )
    
    REF_ACTION( POOL_ALLOC )
    REF_ACTION( POOL_ALLOC_FAIL_NO_MEM )
    REF_ACTION( POOL_ALLOC_FAIL_NO_QUOTA )
    REF_ACTION( POOL_FREE )

    REF_ACTION( ENDPOINT_USAGE_REFERENCE )
    REF_ACTION( ENDPOINT_USAGE_DEREFERENCE )

    REF_ACTION( ENDPOINT_EVENT_REFERENCE )
    REF_ACTION( ENDPOINT_EVENT_DEREFERENCE )


    REF_ACTION( REFERENCE_UC_REQUEST )
    REF_ACTION( DEREFERENCE_UC_REQUEST )

    REF_ACTION( MAX )   // *must* be last
END_REF_ACTION()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\scavenger.c ===
/*++

Copyright (c) 2002-2002 Microsoft Corporation

Module Name:

    scavenger.c

Abstract:

    The cache scavenger implementation

Author:

    Karthik Mahesh (KarthikM)    Feb-2002

Revision History:

--*/

#include "precomp.h"
#include "scavenger.h"
#include "scavengerp.h"

// MB to trim at a time
SIZE_T g_UlScavengerTrimMB = DEFAULT_SCAVENGER_TRIM_MB;

// Min Interval between 2 scavenger events
ULONG g_UlMinScavengerInterval = DEFAULT_MIN_SCAVENGER_INTERVAL;

// Pages to trim on a low memory event.
ULONG_PTR g_ScavengerTrimPages;

volatile BOOLEAN g_ScavengerThreadStarted;
HANDLE           g_ScavengerLowMemHandle;
HANDLE           g_ScavengerThreadHandle; 

KEVENT           g_ScavengerLimitExceededEvent;
KEVENT           g_ScavengerTerminateThreadEvent;
KEVENT           g_ScavengerTimerEvent;
KTIMER           g_ScavengerTimer;
KDPC             g_ScavengerTimerDpc;

// Event Array for Scavenger Thread
PKEVENT          g_ScavengerAllEvents[SCAVENGER_NUM_EVENTS];

// Number of scavenger calls since last timer event
ULONG            g_ScavengerAge = 0;

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeScavengerThread )
#pragma alloc_text( PAGE, UlTerminateScavengerThread )
#pragma alloc_text( PAGE, UlpSetScavengerTimer )
#pragma alloc_text( PAGE, UlpScavengerThread )
#pragma alloc_text( PAGE, UlpScavengerPeriodicEventHandler )
#pragma alloc_text( PAGE, UlpScavengerLowMemoryEventHandler )
#pragma alloc_text( PAGE, UlpScavengerLimitEventHandler )
#pragma alloc_text( PAGE, UlSetScavengerLimitEvent )
#endif // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlpScavengerDpcRoutine
#endif

/***************************************************************************++

Routine Description:

    Initialize the Memory Scavenger

--***************************************************************************/
NTSTATUS
UlInitializeScavengerThread(
    VOID
    )
{
    NTSTATUS          Status;
    UNICODE_STRING    LowMemoryEventName;
    OBJECT_ATTRIBUTES ObjAttr;
    PKEVENT           LowMemoryEventObject;

    PAGED_CODE();

    // Initialize Trim Size
    // If trim size is not set, trim 1M for every 256M

    if(g_UlScavengerTrimMB > g_UlTotalPhysicalMemMB) {
        g_UlScavengerTrimMB = g_UlTotalPhysicalMemMB;
    }

    if(g_UlScavengerTrimMB == DEFAULT_SCAVENGER_TRIM_MB) {
        g_UlScavengerTrimMB = (g_UlTotalPhysicalMemMB + 255)/256;
    }

    g_ScavengerTrimPages = MEGABYTES_TO_PAGES(g_UlScavengerTrimMB);

    // Open Low Memory Event Object

    RtlInitUnicodeString( &LowMemoryEventName, LOW_MEM_EVENT_NAME );

    InitializeObjectAttributes( &ObjAttr,
                                &LowMemoryEventName,
                                OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    Status = ZwOpenEvent ( &g_ScavengerLowMemHandle,
                           EVENT_QUERY_STATE,
                           &ObjAttr );

    if( !NT_SUCCESS(Status) ) {
        return Status;
    }

    Status = ObReferenceObjectByHandle( g_ScavengerLowMemHandle,
                                        EVENT_QUERY_STATE,
                                        NULL,
                                        KernelMode,
                                        (PVOID *) &LowMemoryEventObject,
                                        NULL );

    if( !NT_SUCCESS(Status) ) {
        ZwClose (g_ScavengerLowMemHandle);
        return Status;
    }

    // Initialize Scavenger Timer DPC object

    KeInitializeDpc(
        &g_ScavengerTimerDpc,
        &UlpScavengerTimerDpcRoutine,
        NULL
        );

    // Initialize Scavenger Timer

    KeInitializeTimer(
        &g_ScavengerTimer
        );

    // Initialize other Scavenger Events

    KeInitializeEvent ( &g_ScavengerTerminateThreadEvent,
                        NotificationEvent,
                        FALSE );

    KeInitializeEvent ( &g_ScavengerLimitExceededEvent,
                        NotificationEvent,
                        FALSE );
  
    KeInitializeEvent ( &g_ScavengerTimerEvent,
                        NotificationEvent,
                        FALSE );

    // Initialize Event Array for Scavenger Thread

    g_ScavengerAllEvents[SCAVENGER_LOW_MEM_EVENT]
        = LowMemoryEventObject;
    g_ScavengerAllEvents[SCAVENGER_TERMINATE_THREAD_EVENT]
        = &g_ScavengerTerminateThreadEvent;
    g_ScavengerAllEvents[SCAVENGER_LIMIT_EXCEEDED_EVENT]
        = &g_ScavengerLimitExceededEvent;
    g_ScavengerAllEvents[SCAVENGER_TIMER_EVENT]
        = &g_ScavengerTimerEvent;

    // Start Scavenger Thread

    g_ScavengerThreadStarted = TRUE;

    InitializeObjectAttributes(&ObjAttr, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

    Status = PsCreateSystemThread( &g_ScavengerThreadHandle,
                                   THREAD_ALL_ACCESS,
                                   &ObjAttr,
                                   NULL,
                                   NULL,
                                   UlpScavengerThread,
                                   NULL );

    if( !NT_SUCCESS(Status) ) {
        g_ScavengerThreadStarted = FALSE;
        ObDereferenceObject ( LowMemoryEventObject );
        ZwClose( g_ScavengerLowMemHandle );
        return Status;
    }

    UlTrace(URI_CACHE, ("UlInitializeScavengerThread: Started Scavenger Thread\n"));

    // Kick off periodic scavenger timer

    UlpSetScavengerTimer();

    return Status;
}


/***************************************************************************++

Routine Description:

    Terminate the Memory Scavenger

--***************************************************************************/
VOID
UlTerminateScavengerThread(
    VOID
    )
{
    PETHREAD ThreadObject;
    NTSTATUS Status;

    PAGED_CODE();

    UlTrace(URI_CACHE, ("UlTerminateScavengerThread: Terminating Scavenger Thread\n"));

    if(g_ScavengerThreadStarted) {

        ASSERT( g_ScavengerThreadHandle );

        Status = ObReferenceObjectByHandle( g_ScavengerThreadHandle,
                                            0,
                                            *PsThreadType,
                                            KernelMode,
                                            (PVOID *) &ThreadObject,
                                            NULL );

        ASSERT( NT_SUCCESS(Status) ); // g_ScavengerThreadHandle is a valid thread handle

        g_ScavengerThreadStarted = FALSE;

        // Set the terminate event

        KeSetEvent( &g_ScavengerTerminateThreadEvent, 0, FALSE );

        // Wait for thread to terminate

        KeWaitForSingleObject( ThreadObject,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        ObDereferenceObject( ThreadObject );
        ZwClose( g_ScavengerThreadHandle );

        // Close Low Mem Event handle

        ObDereferenceObject(g_ScavengerAllEvents[SCAVENGER_LOW_MEM_EVENT]);
        ZwClose( g_ScavengerLowMemHandle );

        // Cancel the timer, if it fails it means the Dpc may be running
        // In that case, wait for it to finish

        if ( !KeCancelTimer( &g_ScavengerTimer ) )
        {
            KeWaitForSingleObject(
                (PVOID)&g_ScavengerTimerEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );
        }

        // Clear out any remaining zombies

        UlPeriodicCacheScavenger(0);
    }

}

/***************************************************************************++

Routine Description:

    Figures out the scavenger interval in 100 ns ticks, and sets the timer.

--***************************************************************************/
VOID
UlpSetScavengerTimer(
    VOID
    )
{
    LARGE_INTEGER Interval;

    PAGED_CODE();

    //
    // convert seconds to 100 nanosecond intervals (x * 10^7)
    // negative numbers mean relative time
    //

    Interval.QuadPart= g_UriCacheConfig.ScavengerPeriod
                                  * -C_NS_TICKS_PER_SEC;

    UlTrace(URI_CACHE, (
                "Http!UlpSetScavengerTimer: %d seconds = %I64d 100ns ticks\n",
                g_UriCacheConfig.ScavengerPeriod,
                Interval.QuadPart
                ));

    KeSetTimer(
        &g_ScavengerTimer,
        Interval,
        &g_ScavengerTimerDpc
        );

} // UlpSetScavengerTimer


/***************************************************************************++

Routine Description:

    Dpc routine to set scavenger timeout event

Arguments:

    None.

--***************************************************************************/
VOID
UlpScavengerTimerDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(DeferredContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    ASSERT( DeferredContext == NULL );

    KeSetEvent( &g_ScavengerTimerEvent, 0, FALSE );
}


/***************************************************************************++

Routine Description:

    Wait for memory usage events and recycle when needed

Arguments:

    None.

--***************************************************************************/
VOID
UlpScavengerThread(
    IN PVOID Context
    )
{
    NTSTATUS Status;
    KWAIT_BLOCK WaitBlockArray[SCAVENGER_NUM_EVENTS];
    LARGE_INTEGER MinInterval;

    PAGED_CODE();

    ASSERT(Context == NULL);
    ASSERT(g_ScavengerAllEvents[SCAVENGER_TERMINATE_THREAD_EVENT] != NULL);
    ASSERT(g_ScavengerAllEvents[SCAVENGER_TIMER_EVENT] != NULL);
    ASSERT(g_ScavengerAllEvents[SCAVENGER_LOW_MEM_EVENT] != NULL);
    ASSERT(g_ScavengerAllEvents[SCAVENGER_LIMIT_EXCEEDED_EVENT] != NULL);

    UNREFERENCED_PARAMETER(Context);

    MinInterval.QuadPart = g_UlMinScavengerInterval * -C_NS_TICKS_PER_SEC;

    while(g_ScavengerThreadStarted) {

        //
        // Pause between successive scavenger calls
        //
        KeWaitForSingleObject( g_ScavengerAllEvents[SCAVENGER_TERMINATE_THREAD_EVENT],
                               Executive,
                               KernelMode,
                               FALSE,
                               &MinInterval );

        //
        // Wait for scavenger events
        //
        Status = KeWaitForMultipleObjects( SCAVENGER_NUM_EVENTS,
                                           g_ScavengerAllEvents,
                                           WaitAny,
                                           Executive,
                                           KernelMode,
                                           FALSE,
                                           NULL,
                                           WaitBlockArray );

        ASSERT( NT_SUCCESS(Status) );

        if(KeReadStateEvent( g_ScavengerAllEvents[SCAVENGER_TERMINATE_THREAD_EVENT] )) {
            //
            // Do Nothing, will exit while loop
            //
            UlTrace(URI_CACHE, ("UlpScavengerThread: Terminate Event Set\n"));
            break;
        }

        if(KeReadStateEvent( g_ScavengerAllEvents[SCAVENGER_TIMER_EVENT] )) {
            UlpScavengerPeriodicEventHandler();
        }

        if(KeReadStateEvent( g_ScavengerAllEvents[SCAVENGER_LOW_MEM_EVENT] )) {
            UlpScavengerLowMemoryEventHandler();
        }

        if(KeReadStateEvent(g_ScavengerAllEvents[SCAVENGER_LIMIT_EXCEEDED_EVENT] )) {
            UlpScavengerLimitEventHandler();
        }

    } // while(g_ScavengerThreadStarted)
    
    PsTerminateSystemThread( STATUS_SUCCESS );
}

/***************************************************************************++

Routine Description:

    Handle the "Cache Size Exceeded Limit" event

Arguments:

    None.

--***************************************************************************/
VOID
UlpScavengerPeriodicEventHandler(
    VOID
    )
{
    PAGED_CODE();

    KeClearEvent( g_ScavengerAllEvents[SCAVENGER_TIMER_EVENT] );

    UlTraceVerbose(URI_CACHE, ("UlpScavengerThread: Calling Periodic Scavenger. Age = %d\n", g_ScavengerAge));

    ASSERT(g_ScavengerAge <= SCAVENGER_MAX_AGE);

    UlPeriodicCacheScavenger(g_ScavengerAge);

    g_ScavengerAge = 0;

    //
    // Clear the pages exceeded event, hopefully enough memory
    // has been reclaimed by the scavenger
    // If not, this event will be set again immediately
    // on the next cache miss
    //
    KeClearEvent(g_ScavengerAllEvents[SCAVENGER_LIMIT_EXCEEDED_EVENT]);

    //
    // Schedule the next periodic scavenger call
    //
    UlpSetScavengerTimer();
}

/***************************************************************************++

Routine Description:

    Handle the "Cache Size Exceeded Limit" event

Arguments:

    None.

--***************************************************************************/
VOID
UlpScavengerLowMemoryEventHandler(
    VOID
    )
{
    ULONG_PTR PagesToRecycle;

    PAGED_CODE();

    UlDisableCache();

    ASSERT(g_ScavengerAge <= SCAVENGER_MAX_AGE);

    if(g_ScavengerAge < SCAVENGER_MAX_AGE) {
        g_ScavengerAge++;
    }

    UlTrace(URI_CACHE, ("UlpScavengerThread: Low Memory. Age = %d\n", g_ScavengerAge));
    
    do {
        //
        // Trim up to g_ScavengerTrimPages pages
        //
        PagesToRecycle = UlGetHashTablePages();
        if(PagesToRecycle > g_ScavengerTrimPages){
            PagesToRecycle = g_ScavengerTrimPages;
        }
        
        if(PagesToRecycle > 0) {
            UlTrimCache( PagesToRecycle, g_ScavengerAge );
        }
        
    } while(KeReadStateEvent(g_ScavengerAllEvents[SCAVENGER_LOW_MEM_EVENT]) && (PagesToRecycle > 0));
    
    UlEnableCache();
}

/***************************************************************************++

Routine Description:

    Handle the "Cache Size Exceeded Limit" event

Arguments:

    None.

--***************************************************************************/
VOID
UlpScavengerLimitEventHandler(
    VOID
    )
{
    ULONG_PTR PagesToRecycle;

    UlDisableCache();

    PagesToRecycle = UlGetHashTablePages() / 8;
    if( PagesToRecycle < 1 ) {
        PagesToRecycle = UlGetHashTablePages();
    }

    if(g_ScavengerAge < SCAVENGER_MAX_AGE) {
        g_ScavengerAge++;
    }

    ASSERT(g_ScavengerAge <= SCAVENGER_MAX_AGE);

    UlTrace(URI_CACHE, ("UlpScavengerThread: Cache Size Exceeded Limit. Age = %d, Freeing %d pages\n", g_ScavengerAge, PagesToRecycle));
    
    if(PagesToRecycle > 0) {
        UlTrimCache( PagesToRecycle, g_ScavengerAge );
    }
    
    KeClearEvent(g_ScavengerAllEvents[SCAVENGER_LIMIT_EXCEEDED_EVENT]);
    
    UlEnableCache();
}


/***************************************************************************++

Routine Description:

    Set the "Cache Size Exceeded Limit" event

Arguments:

    None.

--***************************************************************************/
VOID
UlSetScavengerLimitEvent(
    VOID
    )
{
    PAGED_CODE();

    KeSetEvent( g_ScavengerAllEvents[SCAVENGER_LIMIT_EXCEEDED_EVENT],
                0,
                FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\scavenger.h ===
/*++

Copyright (c) 2002-2002 Microsoft Corporation

Module Name:

    scavenger.h

Abstract:

    The cache scavenger interface

Author:

    Karthik Mahesh (KarthikM)           Feb-2002

Revision History:

--*/

#ifndef _SCAVENGER_H_
#define _SCAVENGER_H_


NTSTATUS
UlInitializeScavengerThread(
    VOID
    );

VOID
UlTerminateScavengerThread(
    VOID
    );

//
// Set the "cache size exceeded limit" event
//
VOID
UlSetScavengerLimitEvent(
    VOID
    );


extern SIZE_T g_UlScavengerTrimMB;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\scavengerp.h ===
/*++

Copyright (c) 2002-2002 Microsoft Corporation

Module Name:

    scavenger.h

Abstract:

    The cache scavenger private declarations

Author:

    Karthik Mahesh (KarthikM)           Feb-2002

Revision History:

--*/


#ifndef _SCAVENGERP_H_
#define _SCAVENGERP_H_

#define SCAVENGER_MAX_AGE 10

//
// Scavenger Thread Event Types. These are Indices in global array 
// of PKEVENTs g_ScavengerAllEvents
//
enum {
    SCAVENGER_TERMINATE_THREAD_EVENT = 0, // Set on Shutdown

    SCAVENGER_TIMER_EVENT,            // Set periodically by timer DPC

    SCAVENGER_LOW_MEM_EVENT,          // Set by system on low memory condition

    SCAVENGER_LIMIT_EXCEEDED_EVENT,   // Set by UlSetScavengerLimitEvent if cache size limit is exceeded

    SCAVENGER_NUM_EVENTS
};

#define LOW_MEM_EVENT_NAME L"\\KernelObjects\\LowMemoryCondition"

//
// Min interval (seconds) between successive
// scavenger calls
//
#define DEFAULT_MIN_SCAVENGER_INTERVAL          (4)

VOID
UlpSetScavengerTimer(
    VOID
    );

VOID
UlpScavengerTimerDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
UlpScavengerThread(
    IN PVOID Context
    );

VOID
UlpScavengerPeriodicEventHandler(
    VOID
    );

VOID
UlpScavengerLowMemoryEventHandler(
    VOID
    );

VOID
UlpScavengerLimitEventHandler(
    VOID
    );

#endif // _SCAVENGERP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\sendrequest.c ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    sendrequest.c

Abstract:

    This module implements the HttpSendRequest() API.

Author:

    Rajesh Sundaram (rajeshsu)  01-Aug-2000

Revision History:

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE , UcCaptureHttpRequest )
#pragma alloc_text( PAGE , UcpProbeConfigList )
#pragma alloc_text( PAGE , UcpProbeAndCopyHttpRequest ) 
#pragma alloc_text( PAGE , UcpComputeEntityBodyLength )
#pragma alloc_text( PAGE , UcpRetrieveContentLength )

#pragma alloc_text( PAGEUC, UcpFixAppBufferPointers)
#pragma alloc_text( PAGEUC, UcReferenceRequest)
#pragma alloc_text( PAGEUC, UcDereferenceRequest)
#pragma alloc_text( PAGEUC, UcPrepareRequestIrp)
#pragma alloc_text( PAGEUC, UcCompleteParsedRequest)
#pragma alloc_text( PAGEUC, UcSetRequestCancelRoutine)
#pragma alloc_text( PAGEUC, UcRemoveRequestCancelRoutine)
#pragma alloc_text( PAGEUC, UcRemoveRcvRespCancelRoutine)
#pragma alloc_text( PAGEUC, UcRemoveEntityCancelRoutine)
#pragma alloc_text( PAGEUC, UcFreeSendMdls)
#pragma alloc_text( PAGEUC, UcpFreeRequest)
#pragma alloc_text( PAGEUC, UcCaptureEntityBody)
#pragma alloc_text( PAGEUC, UcpBuildEntityMdls)
#pragma alloc_text( PAGEUC, UcAllocateAndChainHeaderMdl)
#pragma alloc_text( PAGEUC, UcBuildConnectVerbRequest)
#pragma alloc_text( PAGEUC, UcpRequestInitialize)
#pragma alloc_text( PAGEUC, UcpRequestCommonInitialize)
#pragma alloc_text( PAGEUC, UcSetEntityCancelRoutine)
#pragma alloc_text( PAGEUC, UcCopyResponseToIrp)
#pragma alloc_text( PAGEUC, UcReceiveHttpResponse)
#pragma alloc_text( PAGEUC, UcSetRecvResponseCancelRoutine)
#pragma alloc_text( PAGEUC, UcpCancelReceiveResponse)
#pragma alloc_text( PAGEUC, UcpProbeAndCopyEntityChunks )
#pragma alloc_text( PAGEUC, UcpCancelSendEntity)
#pragma alloc_text( PAGEUC, UcInitializeHttpRequests)
#pragma alloc_text( PAGEUC, UcTerminateHttpRequests)
#pragma alloc_text( PAGEUC, UcpAllocateAndChainEntityMdl)
#pragma alloc_text( PAGEUC, UcFailRequest)
#pragma alloc_text( PAGEUC, UcReIssueRequestWorker)
#pragma alloc_text( PAGEUC, UcpPreAuthWorker)
#pragma alloc_text( PAGEUC, UcpCheckForPreAuth)
#pragma alloc_text( PAGEUC, UcpCheckForProxyPreAuth)

#endif

static NPAGED_LOOKASIDE_LIST   g_ClientRequestLookaside;
static BOOLEAN                 g_ClientRequestLookasideInitialized;

#define FIX_ADDR(ptr, len) ((ptr) + (len))


/***************************************************************************++

Routine Description:

    Initializes the request for the very first time.

Arguments:
    pRequest               - the input request.
    RequestLength          - size of the request.
    RemainingContentLength - Remaining Content Length.
    pAuth                  - Internal auth structure.
    pProxyAuth             - Internal proxy auth structure.
    pConnection            - The connection.
    Irp                    - The IRP
    pIrpSp                 - Stack location
    pServerInfo            - Server Information structure.

Return Value:

    None.

--***************************************************************************/
_inline
VOID
UcpRequestInitialize(
    IN PUC_HTTP_REQUEST               pRequest,
    IN SIZE_T                         RequestLength,
    IN ULONGLONG                      RemainingContentLength,
    IN PUC_HTTP_AUTH                  pAuth,
    IN PUC_HTTP_AUTH                  pProxyAuth,
    IN PUC_CLIENT_CONNECTION          pConnection,   
    IN PIRP                           Irp,
    IN PIO_STACK_LOCATION             pIrpSp,
    IN PUC_PROCESS_SERVER_INFORMATION pServerInfo
    )
{
    HTTP_SET_NULL_ID(&pRequest->RequestId);

    pRequest->Signature                      = UC_REQUEST_SIGNATURE; 
    pRequest->RefCount                       = 2; // one for the IRP.
    pRequest->ResponseVersion11              = FALSE;
    pRequest->RequestStatus                  = 0;
    pRequest->BytesBuffered                  = 0;
    pRequest->RequestIRPBytesWritten         = 0;
    pRequest->pMdlHead                       = NULL;
    pRequest->pMdlLink                       = &pRequest->pMdlHead;

    pRequest->ReceiveBusy                    = UC_REQUEST_RECEIVE_READY;

    InitializeListHead(&pRequest->pBufferList);
    InitializeListHead(&pRequest->ReceiveResponseIrpList);
    InitializeListHead(&pRequest->PendingEntityList);
    InitializeListHead(&pRequest->SentEntityList);

    UlInitializeWorkItem(&pRequest->WorkItem);

    ExInitializeFastMutex(&pRequest->Mutex);

    pRequest->RequestSize                   = RequestLength;
    pRequest->RequestContentLengthRemaining = RemainingContentLength;
    pRequest->pProxyAuthInfo                = pProxyAuth;
    pRequest->pAuthInfo                     = pAuth;
    pRequest->pConnection                   = pConnection;

    if(Irp)
    {
        // 
        // Save the IRP parameters.
        //

        pRequest->AppRequestorMode              = Irp->RequestorMode;
        pRequest->AppMdl                        = Irp->MdlAddress;
        pRequest->RequestIRP                    = Irp;
        pRequest->RequestIRPSp                  = pIrpSp;
        pRequest->pFileObject                   = pIrpSp->FileObject;
    }
    else
    {
        pRequest->AppRequestorMode              = KernelMode;
        pRequest->AppMdl                        = NULL;
        pRequest->RequestIRP                    = NULL;
        pRequest->RequestIRPSp                  = NULL;
        pRequest->pFileObject                   = NULL;
    }

    pRequest->pServerInfo = pServerInfo;

}


/***************************************************************************++

Routine Description:

    Initializes the request - Called once by UcCaptureHttpRequest & everytime
    we re-issue the request (401 handshake).

Arguments:
    pRequest               - the input request.
    OutLength              - length of request.
    pBuffer                - Output Buffer

Return Value:

    None.

--***************************************************************************/
VOID
UcpRequestCommonInitialize(
    IN PUC_HTTP_REQUEST   pRequest,
    IN ULONG              OutLength,
    IN PUCHAR             pBuffer
    )
{
    pRequest->ParseState                     = UcParseStatusLineVersion;
    pRequest->RequestState                   = UcRequestStateCaptured;
    pRequest->ResponseContentLengthSpecified = FALSE;
    pRequest->ResponseEncodingChunked        = FALSE;
    pRequest->ResponseContentLength          = 0;
    pRequest->ResponseMultipartByteranges    = FALSE;
    pRequest->CurrentBuffer.pCurrentBuffer   = NULL;
    pRequest->DontFreeMdls                   = 0;
    pRequest->Renegotiate                    = 0;


    if(!OutLength)
    {
        if(pRequest->RequestFlags.RequestBuffered)
        {
            // If we have buffered the request and if the app has
            // posted 0 buffers, we can complete the IRP early.

            // No need to call UcSetFlag for this.

            pRequest->RequestFlags.CompleteIrpEarly = TRUE;
        }

        //
        // The app did not pass any buffers. We'll initialize everything
        // to NULL and will allocate them as required.
        //

        pRequest->CurrentBuffer.BytesAllocated  = 0;
        pRequest->CurrentBuffer.BytesAvailable  = 0;
        pRequest->CurrentBuffer.pOutBufferHead  = 0;
        pRequest->CurrentBuffer.pOutBufferTail  = 0;
        pRequest->CurrentBuffer.pResponse       = 0;

    }
    else
    {

        //
        // Since we have described our IOCTL as "OUT_DIRECT", the IO
        // manager has probed and locked the user's memory and created a
        // MDL for it.
        //
        // set up pointers to the buffer described by this MDL.
        //

        pRequest->CurrentBuffer.BytesAllocated = OutLength;

        pRequest->CurrentBuffer.BytesAvailable =
                        pRequest->CurrentBuffer.BytesAllocated -
                        sizeof(HTTP_RESPONSE);

        // Make sure pBuffer is 64-bit aligned
        ASSERT(pBuffer == (PUCHAR)ALIGN_UP_POINTER(pBuffer, PVOID));

        pRequest->CurrentBuffer.pResponse = pRequest->pInternalResponse;

        pRequest->CurrentBuffer.pOutBufferHead  =
                        (PUCHAR)pBuffer + sizeof(HTTP_RESPONSE);

        pRequest->CurrentBuffer.pOutBufferTail  =
                        (PUCHAR)pBuffer + OutLength;

        // No need to call UcSetFlag for this.
        pRequest->RequestFlags.ReceiveBufferSpecified = TRUE;

        //
        // We have to zero out at least the response structure, as it
        // could contain junk pointers.
        //
 
        RtlZeroMemory(pRequest->pInternalResponse, sizeof(HTTP_RESPONSE));
    }
}


/***************************************************************************++

Routine Description:

    Probes the user buffer for valid memory pointers. This function is called 
    within a try catch block. 

Arguments:

    pHttpRequest - The request that is passed by the user.

Return Value:

    None.

--***************************************************************************/
VOID
UcpProbeAndCopyHttpRequest(
    IN PHTTP_REQUEST    pHttpRequest,
    IN PHTTP_REQUEST    pLocalHttpRequest,
    IN KPROCESSOR_MODE  RequestorMode
    )
{
    ULONG                 i;
    PHTTP_KNOWN_HEADER    pKnownHeaders;
    PHTTP_UNKNOWN_HEADER  pUnknownHeaders;

    //
    // First, make sure that we can access the HTTP_REQUEST structure   
    // that's passed by the app. We make a copy & probe it for Read.
    //

    UlProbeForRead(
            pHttpRequest,
            sizeof(HTTP_REQUEST),
            sizeof(PVOID),
            RequestorMode
            );

    //
    // To prevent the app from modifying pointers in this structure, we 
    // make a local copy of it.
    //

    RtlCopyMemory(
        pLocalHttpRequest, 
        pHttpRequest, 
        sizeof(HTTP_REQUEST)
        );

    //
    // set this to point to local request, so if we accidently use it again 
    // we'll end up using our local copy.
    //

    pHttpRequest = pLocalHttpRequest;

    //
    // Check the Request Method
    //
    if(pHttpRequest->UnknownVerbLength)
    {
        UlProbeAnsiString(
                pHttpRequest->pUnknownVerb,
                pHttpRequest->UnknownVerbLength,
                RequestorMode
                );
    }

    //
    // Check the URI
    //

    UlProbeWideString(
        pHttpRequest->CookedUrl.pAbsPath,
        pHttpRequest->CookedUrl.AbsPathLength,
        RequestorMode
        );

    //
    // We don't support trailers.
    //

    if(pHttpRequest->Headers.TrailerCount != 0 ||
       pHttpRequest->Headers.pTrailers != NULL)
    {
        ExRaiseStatus(STATUS_INVALID_PARAMETER);
    }

    //                                        
    // Check the known headers
    //
    pKnownHeaders = pHttpRequest->Headers.KnownHeaders;
    for(i=0; i<HttpHeaderRequestMaximum; i++)
    {
        if(pKnownHeaders[i].RawValueLength)
        {
            UlProbeAnsiString(
                pKnownHeaders[i].pRawValue,
                pKnownHeaders[i].RawValueLength,
                RequestorMode
                );
        }
    }

    //
    // Now, the unknown headers.
    //

    pUnknownHeaders = pHttpRequest->Headers.pUnknownHeaders;
    if(pUnknownHeaders != 0)
    {
        if (pHttpRequest->Headers.UnknownHeaderCount >= UL_MAX_CHUNKS)
        {
            ExRaiseStatus(STATUS_INVALID_PARAMETER);
        }
                
        UlProbeForRead(
                pUnknownHeaders,
                sizeof(HTTP_UNKNOWN_HEADER) * 
                    pHttpRequest->Headers.UnknownHeaderCount,
                sizeof(PVOID),
                RequestorMode
                );

        for(i=0; i<pHttpRequest->Headers.UnknownHeaderCount; i++)
        {
            if(pUnknownHeaders[i].NameLength > 0)
            {
                UlProbeAnsiString(
                    pUnknownHeaders[i].pName,
                    pUnknownHeaders[i].NameLength,
                    RequestorMode
                    );

                UlProbeAnsiString(
                    pUnknownHeaders[i].pRawValue,
                    pUnknownHeaders[i].RawValueLength,
                    RequestorMode
                    );
            }
        }
    }
}


/***************************************************************************++

Routine Description:

    This routine determines if the request has specified Content-Length
    header.  If so, it computes the content length from the header value.

Arguments:

    pHttpRequest            - Pointer to Captured Request
    pbContentLengthSpcified - Set to TRUE if Content-Length header was present
    pContentLength          - Set to the content length value from the header
                              (0 if no header was present)

Return Value:

    VOID.  It throws exception if an error occurs.

--***************************************************************************/
VOID
UcpRetrieveContentLength(
    IN  PHTTP_REQUEST    pHttpRequest,
    OUT PBOOLEAN         pbContentLengthSpecified,
    OUT PULONGLONG       pContentLength
    )
{
    NTSTATUS           Status;
    PHTTP_KNOWN_HEADER pContentLengthHeader;
    ULONGLONG          ContentLength;


    //
    // By default, no content length is specified.
    //
    *pbContentLengthSpecified = FALSE;
    *pContentLength           = 0;

    //
    // Is Content-Length header present?
    //
    pContentLengthHeader =
        &pHttpRequest->Headers.KnownHeaders[HttpHeaderContentLength];

    if (pContentLengthHeader->RawValueLength)
    {
        //
        // Now, convert the header value to binary.
        //
        Status = UlAnsiToULongLong((PUCHAR) pContentLengthHeader->pRawValue,
                                   pContentLengthHeader->RawValueLength,
                                   10,              //Base
                                   &ContentLength);

        if (!NT_SUCCESS(Status))
        {
            ExRaiseStatus(Status);
        }

        //
        // Return the content length value to the caller.
        //
        *pbContentLengthSpecified = TRUE;
        *pContentLength           = ContentLength;
    }
}


/***************************************************************************++

Routine Description:

    Probes the user's config buffer for valid memory pointers. This function 
    is called from within a try catch block.

Arguments:

    pConfigList - The config info that is passed by the user.

Return Value:

    None.

--***************************************************************************/
VOID
UcpProbeConfigList(
    IN PHTTP_REQUEST_CONFIG           pRequestConfig,
    IN USHORT                         RequestConfigCount,
    IN KPROCESSOR_MODE                RequestorMode,
    IN PUC_PROCESS_SERVER_INFORMATION pServInfo,
    IN PUC_HTTP_AUTH                  *ppIAuth,
    IN PUC_HTTP_AUTH                  *ppIProxyAuth,
    IN PULONG                          pConnectionIndex
    )
{
    USHORT                 i;
    NTSTATUS               Status;
    HTTP_AUTH_CREDENTIALS  LocalAuth;
    PHTTP_AUTH_CREDENTIALS pAuth;
    PUC_HTTP_AUTH          pIAuth;
    PULONG                 pUlongPtr;
    ULONG                  AuthInternalLength;
    ULONG                  AuthHeaderLength;
    HTTP_AUTH_TYPE         AuthInternalType;
    HTTP_REQUEST_CONFIG_ID ObjectType;
    

    if(RequestConfigCount > HttpRequestConfigMaxConfigId)
    {
        ExRaiseStatus(STATUS_INVALID_PARAMETER);
    }

    ASSERT(*ppIAuth == NULL  && *ppIProxyAuth == NULL);

    for(i=0; i<RequestConfigCount; i++)
    {
        UlProbeForRead(
                &pRequestConfig[i],
                sizeof(HTTP_REQUEST_CONFIG), 
                sizeof(PVOID),
                RequestorMode
                );

        ObjectType = pRequestConfig[i].ObjectType;
        
        switch(ObjectType)
        {
            //
            // Validate all the entries that contain pointers.
            //

            case HttpRequestConfigAuthentication:
            case HttpRequestConfigProxyAuthentication:
            {
                if(pRequestConfig[i].ValueLength != 
                        sizeof(HTTP_AUTH_CREDENTIALS))
                {
                    ExRaiseStatus(STATUS_INVALID_PARAMETER);
                }

                pAuth = (PHTTP_AUTH_CREDENTIALS) pRequestConfig[i].pValue;

                UlProbeForRead(
                        pAuth,
                        sizeof(HTTP_AUTH_CREDENTIALS),
                        sizeof(PVOID),
                        RequestorMode
                        );

                //
                // Make a local copy of it.
                //
                RtlCopyMemory(&LocalAuth,
                              pAuth,
                              sizeof(HTTP_AUTH_CREDENTIALS)
                              );

                pAuth = &LocalAuth;

                //
                // If default credentials are to be used, no credentials
                // can be specified.
                //

                if (pAuth->AuthFlags & HTTP_AUTH_FLAGS_DEFAULT_CREDENTIALS)
                {
                    if (pAuth->pUserName || pAuth->UserNameLength ||
                        pAuth->pDomain   || pAuth->DomainLength   ||
                        pAuth->pPassword || pAuth->PasswordLength)
                    {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }
                }

                if(pAuth->HeaderValueLength)
                {
                    UlProbeAnsiString(
                        pAuth->pHeaderValue,
                        pAuth->HeaderValueLength,
                        RequestorMode
                        );
                }

                if(pAuth->UserNameLength)
                {
                    UlProbeWideString(
                           pAuth->pUserName, 
                           pAuth->UserNameLength, 
                           RequestorMode
                           );
                }

                if(pAuth->PasswordLength)
                {
                    UlProbeWideString(
                           pAuth->pPassword, 
                           pAuth->PasswordLength, 
                           RequestorMode
                           );
                }

                if(pAuth->DomainLength)
                {
                    UlProbeWideString(
                           pAuth->pDomain, 
                           pAuth->DomainLength, 
                           RequestorMode
                           );
                }
    
                //
                // Compute the size required for storing these credentials.
                //
                AuthHeaderLength = UcComputeAuthHeaderSize(
                                        pAuth,
                                        &AuthInternalLength,
                                        &AuthInternalType,
                                        ObjectType
                                        );

                ASSERT(AuthInternalLength != 0);

                pIAuth = (PUC_HTTP_AUTH)UL_ALLOCATE_POOL_WITH_QUOTA(
                                      NonPagedPool, 
                                      AuthInternalLength,
                                      UC_AUTH_CACHE_POOL_TAG,
                                      pServInfo->pProcess
                                      );

                if(!pIAuth)
                {
                    ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
                }

                //
                // After we allocate memory, we'll set the pointers that 
                // have been passed by UcCaptureHttpRequest. So, if we bail
                // out because of a bad pointer, UcCaptureHttpRequest will
                // free the allocated memory (after the _try _except).
                //

                if(ObjectType == HttpRequestConfigAuthentication)
                {
                    if(*ppIAuth != NULL)
                    {
                        // User has passed more than one version of the 
                        // HttpRequestConfigAuthentication object.

                        UL_FREE_POOL_WITH_QUOTA(
                                pIAuth, 
                                UC_AUTH_CACHE_POOL_TAG,
                                NonPagedPool,
                                AuthInternalLength,
                                pServInfo->pProcess
                                );

                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }
        
                    *ppIAuth = pIAuth;
                }
                else
                {
                    if(*ppIProxyAuth != NULL)
                    {
                        // User has passed more than one version of the 
                        // HttpRequestConfigProxyAuthentication object.

                        UL_FREE_POOL_WITH_QUOTA(
                                pIAuth, 
                                UC_AUTH_CACHE_POOL_TAG,
                                NonPagedPool,
                                AuthInternalLength,
                                pServInfo->pProcess
                                );

                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }

                    *ppIProxyAuth = pIAuth;
                }

                RtlZeroMemory(pIAuth, sizeof(UC_HTTP_AUTH));

                //
                // Copy auth struct
                //

                Status = UcCopyAuthCredentialsToInternal(
                             pIAuth,
                             AuthInternalLength,
                             AuthInternalType,
                             pAuth,
                             AuthHeaderLength
                             );
    
                if(!NT_SUCCESS(Status))
                {
                    ExRaiseStatus(STATUS_INVALID_PARAMETER);
                }

                break;
            }

            case HttpRequestConfigConnectionIndex:
            {
                pUlongPtr = pRequestConfig[i].pValue;

                if(pRequestConfig[i].ValueLength != sizeof(ULONG))
                {
                    ExRaiseStatus(STATUS_INVALID_PARAMETER);
                }

                UlProbeForRead(
                        pUlongPtr,
                        sizeof(ULONG),
                        sizeof(ULONG),
                        RequestorMode
                        );

                *pConnectionIndex  = *pUlongPtr;
                break;
            }
            
            //
            // No need to validate these!
            //
            default:
                ExRaiseStatus(STATUS_INVALID_PARAMETER);
                break;

        }
    }
}


/***************************************************************************++

Routine Description:

    Make a copy of the HTTP_DATA_CHUNK array & probe it.
   
Arguments:

Return Value

    None.

--***************************************************************************/
VOID
UcpProbeAndCopyEntityChunks(
    IN  KPROCESSOR_MODE                RequestorMode,
    IN  PHTTP_DATA_CHUNK               pEntityChunks,
    IN  ULONG                          EntityChunkCount,
    IN  PHTTP_DATA_CHUNK               pLocalEntityChunksArray,
    OUT PHTTP_DATA_CHUNK               *ppLocalEntityChunks
    )
{
    PHTTP_DATA_CHUNK pLocalEntityChunks;
    USHORT           i;

    ASSERT(*ppLocalEntityChunks == NULL);

    //
    // First make sure that we can read the pointer that's passed by user
    //

    if (EntityChunkCount >= UL_MAX_CHUNKS)
    {
        ExRaiseStatus(STATUS_INVALID_PARAMETER);
    }

    UlProbeForRead(
            pEntityChunks,
            EntityChunkCount * sizeof(HTTP_DATA_CHUNK),
            sizeof(PVOID),
            RequestorMode
            );

    //
    // Make a local copy of the data chunks and use it from now on. We try
    // to optimize for the common case by using a stack based array.
    //

    if(EntityChunkCount > UL_LOCAL_CHUNKS)
    {
        pLocalEntityChunks = (PHTTP_DATA_CHUNK)
            UL_ALLOCATE_POOL(
                PagedPool,
                sizeof(HTTP_DATA_CHUNK) * EntityChunkCount,
                UL_DATA_CHUNK_POOL_TAG
                );

        if(NULL == pLocalEntityChunks)
        {
            ExRaiseStatus(STATUS_NO_MEMORY);
        }

        //
        // Save the pointer - if there's an exception, this will be freed
        // in UcCaptureHttpRequest
        //

        *ppLocalEntityChunks    = pLocalEntityChunks;
    }
    else
    {
        pLocalEntityChunks   = pLocalEntityChunksArray;
        *ppLocalEntityChunks = pLocalEntityChunks;
    }

    //
    // Copy user's pointer locally 
    //

    RtlCopyMemory(
            pLocalEntityChunks,
            pEntityChunks,
            EntityChunkCount * sizeof(HTTP_DATA_CHUNK)
            );

    //
    // Now, probe the local copy.
    //

    for(i=0; i< EntityChunkCount; i++)
    {
        if(pLocalEntityChunks[i].DataChunkType != HttpDataChunkFromMemory ||
           pLocalEntityChunks[i].FromMemory.BufferLength == 0 ||
           pLocalEntityChunks[i].FromMemory.pBuffer == NULL)
        {
            ExRaiseStatus(STATUS_INVALID_PARAMETER);
            break;
        }
        else
        {
            UlProbeForRead(
                    pLocalEntityChunks[i].FromMemory.pBuffer, 
                    pLocalEntityChunks[i].FromMemory.BufferLength,
                    sizeof(CHAR),
                    RequestorMode
                    );
        }
    }
}


/*****************************************************************************

Routine Description:

   Captures a user mode HTTP request and morphs it into a form suitable for
   kernel-mode.

   NOTE: This is a OUT_DIRECT IOCTL.
   
Arguments:

    pServInfo         - The Server Information structure.
    pHttpIoctl        - The input HTTP IOCTL.
    pIrp              - The IRP.
    pIrpSp            - The IO_STACK_LOCATION for this request.
    ppInternalRequest - A pointer to the parsed request that is suitable for 
                        k-mode.

Return Value

*****************************************************************************/
NTSTATUS
UcCaptureHttpRequest(
    IN  PUC_PROCESS_SERVER_INFORMATION pServInfo,
    IN  PHTTP_SEND_REQUEST_INPUT_INFO  pHttpIoctl,
    IN  PIRP                           Irp,
    IN  PIO_STACK_LOCATION             pIrpSp,
    OUT PUC_HTTP_REQUEST              *ppInternalRequest,
    IN  PULONG                         pBytesTaken
    ) 
{
    ULONGLONG              UncopiedLength;
    ULONGLONG              IndicatedLength;
    ULONGLONG              DataLength;
    ULONG                  HeaderLength;

    PUC_HTTP_REQUEST       pKeRequest = NULL;
    PSTR                   pBuffer;
    NTSTATUS               Status = STATUS_SUCCESS;
    PHTTP_REQUEST_CONFIG   pRequestConfig;
    USHORT                 RequestConfigCount;
    ULONGLONG              ContentLength = 0;
    ULONG                  ConnectionIndex = HTTP_REQUEST_ON_CONNECTION_ANY;
    BOOLEAN                bChunked;
    BOOLEAN                bContentLengthSpecified = FALSE;
    BOOLEAN                bLast;
    BOOLEAN                bBuffered;
    BOOLEAN                bSSPIPost;
    BOOLEAN                bNoRequestEntityBodies;
    BOOLEAN                bPreAuth;
    BOOLEAN                bProxyPreAuth;
    BOOLEAN                bPipeLine;
    PUC_HTTP_AUTH          pIAuth = NULL;
    PUC_HTTP_AUTH          pIProxyAuth = NULL;
    USHORT                 UriLength, AlignUriLength;
    ULONG                  UTF8UriLength;
    ULONG                  AlignRequestSize;
    ULONGLONG              RequestLength;
    ULONG                  OutLength;

    PHTTP_DATA_CHUNK       pLocalEntityChunks = NULL;
    HTTP_DATA_CHUNK        LocalEntityChunks[UL_LOCAL_CHUNKS];
    USHORT                 EntityChunkCount = 0;

    HTTP_REQUEST           LocalHttpRequest;
    PHTTP_REQUEST          pLocalHttpRequest;

    //
    // Sanity Check
    //

    PAGED_CODE();

    __try
    {
        //
        // We just use one routine for kernel & user mode customers. We 
        // could optimize this further for kernel customers, but we don't 
        // have any (at least for now)
        //

        pLocalHttpRequest = &LocalHttpRequest;

        UcpProbeAndCopyHttpRequest(
            pHttpIoctl->pHttpRequest,
            &LocalHttpRequest,
            Irp->RequestorMode
            );

        //
        // Retrieve Content-Length if the header is present in the request.
        //
        UcpRetrieveContentLength(
            &LocalHttpRequest,
            &bContentLengthSpecified,
            &ContentLength
            );

        EntityChunkCount   = pLocalHttpRequest->EntityChunkCount;

        if(EntityChunkCount != 0)
        {
            UcpProbeAndCopyEntityChunks(
                Irp->RequestorMode,
                pLocalHttpRequest->pEntityChunks,
                EntityChunkCount,
                LocalEntityChunks,
                &pLocalEntityChunks
                );
        }

        RequestConfigCount = pHttpIoctl->RequestConfigCount;
        pRequestConfig     = pHttpIoctl->pRequestConfig;

        if(pRequestConfig)
        {
            UcpProbeConfigList(
                pRequestConfig,
                RequestConfigCount,
                Irp->RequestorMode,
                pServInfo,
                &pIAuth,
                &pIProxyAuth,
                &ConnectionIndex
                );
        }

        bLast = (BOOLEAN)((pHttpIoctl->HttpRequestFlags & 
                               HTTP_SEND_REQUEST_FLAG_MORE_DATA) == 0);

        //
        // URI : We have to canonicalize the URI & hex encode it. 
        // We'll not bother with canonicalization when we are computing length
        // requirements -- We will assume that the URI is canonicalized.
        //
        // If it happens that the URI is not canonicalized, we'll land
        // up using less buffer than what we allocated.
        // 

        UTF8UriLength = 
            HttpUnicodeToUTF8Count(
                pLocalHttpRequest->CookedUrl.pAbsPath,
                pLocalHttpRequest->CookedUrl.AbsPathLength / sizeof(WCHAR),
                TRUE);

        // Make sure UTF8 encoded uri is smaller than 64K.
        if (UTF8UriLength > ANSI_STRING_MAX_CHAR_LEN)
        {
            ExRaiseStatus(STATUS_INVALID_PARAMETER);
        }

        UriLength = (USHORT)UTF8UriLength;

        bBuffered     = FALSE;
        bChunked      = FALSE;
        bPreAuth      = FALSE;
        bProxyPreAuth = FALSE;
        bPipeLine     = FALSE;

        //
        // We will try to optimize the case when the app does not pass  
        // entity body.
        //

        if (bLast && 
            !EntityChunkCount && 
            !bContentLengthSpecified)
        {
            bNoRequestEntityBodies = TRUE;
            DataLength             = 0;
            IndicatedLength        = 0;

            //
            // NOTE: We don't pipeline requests that have NTLM/Kerberos/Nego
            // Authorization headers, because of the potential 401 handshake.
            //

            if(
                // User does not want to disable pipeling for this request
                !(pLocalHttpRequest->Flags & HTTP_REQUEST_FLAG_DONT_PIPELINE) 
                &&

                // We are not doing NTLM/Kerberos/Negotiate Auth
    
               !(pIAuth &&
                (pIAuth->Credentials.AuthType == HttpAuthTypeNTLM      || 
                 pIAuth->Credentials.AuthType == HttpAuthTypeKerberos  || 
                 pIAuth->Credentials.AuthType == HttpAuthTypeNegotiate) 
                )  

                && 
                // We are not doing NTLM/Kerberos/Negotiate ProxyAuth

               !(pIProxyAuth &&
                (pIProxyAuth->Credentials.AuthType == HttpAuthTypeNTLM      || 
                 pIProxyAuth->Credentials.AuthType == HttpAuthTypeKerberos  || 
                 pIProxyAuth->Credentials.AuthType == HttpAuthTypeNegotiate)
               )
            )
            {
                bPipeLine = TRUE;
            } 
        }
        else
        {
            if(pLocalHttpRequest->Verb == HttpVerbHEAD ||
               pLocalHttpRequest->Verb == HttpVerbGET)
            {
                // cant' pass entities for GETs or HEADs.
                ExRaiseStatus(STATUS_INVALID_PARAMETER);
            }

            bNoRequestEntityBodies = FALSE;

            //
            // If we are doing PUT or POST for NTLM/Kerberos/Negotiate auth, 
            // we have to buffer sends.
            //
            if(
               (pIAuth &&
                (pIAuth->Credentials.AuthType == HttpAuthTypeNTLM      || 
                 pIAuth->Credentials.AuthType == HttpAuthTypeKerberos  || 
                 pIAuth->Credentials.AuthType == HttpAuthTypeNegotiate) 
                )  
                || 
               (pIProxyAuth &&
                (pIProxyAuth->Credentials.AuthType == HttpAuthTypeNTLM      || 
                 pIProxyAuth->Credentials.AuthType == HttpAuthTypeKerberos  || 
                 pIProxyAuth->Credentials.AuthType == HttpAuthTypeNegotiate)
               )
            )
            {
                bSSPIPost = TRUE;
            } 
            else 
            {
                bSSPIPost = FALSE;
            }

            if (!bContentLengthSpecified)
            {
                if (!bLast)
                {
                    if (!pServInfo->pNextHopInfo->Version11 || bSSPIPost)
                    {
                        //
                        // The app has not passed a content-length and has not
                        // indicated all data in one call. We also don't know 
                        // if the server is 1.1. We cannot send chunked and are 
                        // forced to buffer the request till we see all of 
                        // data.
                        //

                        bBuffered = TRUE;
                    }
                    else
                    {
                        // 
                        // App has not indicated all data, and has not 
                        // indicated content length. But its a 1.1 or greater 
                        // server, so we can send chunked.
                        //
    
                        bChunked = TRUE;
                    }
                }
            }
            else if(!bLast && bSSPIPost)
            {
                bBuffered = TRUE;
            }
                
            //
            // Find out how much length we need for the entity body.
            //

            UcpComputeEntityBodyLength(EntityChunkCount,
                                       pLocalEntityChunks,
                                       bBuffered,
                                       bChunked,
                                       &UncopiedLength,
                                       &DataLength);

            //
            // Content Length checks.
            //

            IndicatedLength = DataLength + UncopiedLength;

            if (bContentLengthSpecified)
            {
                if (bLast)
                {
                    //
                    // If the app does not want to post more data, it should 
                    // post the amount that it specifed using the content
                    // length field.
                    //

                    if (IndicatedLength != ContentLength)
                    {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }
                }
                else
                {
                    //
                    // The app has indicated a content length, but has not 
                    // indicated all the data. Since we know the content length
                    // we can send.
                    //

                    if (IndicatedLength > ContentLength)
                    {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }
                }
            }
            else
            {
                //
                // The app has not specified a content length, but we have 
                // already computed the content length (if it was the only 
                // data chunk). So, let's treat this as the case where the app 
                // has passed a content length.
                //

                if (bLast)
                {
                    bContentLengthSpecified = TRUE;

                    ContentLength = IndicatedLength;
                }
            }
        }

        HeaderLength = UcComputeRequestHeaderSize(pServInfo,
                                                  pLocalHttpRequest, 
                                                  bChunked,
                                                  bContentLengthSpecified,
                                                  pIAuth,
                                                  pIProxyAuth,
                                                  &bPreAuth,
                                                  &bProxyPreAuth
                                                  );

        if(HeaderLength == 0)
        {
            // the app has passed a bad parameter, most likely a bad verb.
            ExRaiseStatus(STATUS_INVALID_PARAMETER);
        }
        
        HeaderLength += (UriLength + sizeof(CHAR));


        AlignRequestSize = ALIGN_UP(sizeof(UC_HTTP_REQUEST), PVOID);
        AlignUriLength   = (USHORT) ALIGN_UP((UriLength + sizeof(CHAR)), PVOID);

        OutLength = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

        RequestLength = (AlignRequestSize +
                         AlignUriLength +
                         HeaderLength + 
                         DataLength);

        if(OutLength != 0)
        {
            // If the app has passed a buffer, we allocate space for
            // the HTTP_RESPONSE structure. This is because the app can 
            // muck around with the output buffer before the IRP completes,
            // and we use this data structure to store pointers, fixup pointers
            // etc.

            RequestLength += sizeof(HTTP_RESPONSE);
        }

        if(RequestLength <= UC_REQUEST_LOOKASIDE_SIZE)
        {
            //
            // Yes, we can service this request from the lookaside.
            //

            pKeRequest = (PUC_HTTP_REQUEST)
                            ExAllocateFromNPagedLookasideList(
                                &g_ClientRequestLookaside
                                );

            if(!pKeRequest)
            {
                ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
            }
        }
        else
        {
            pKeRequest = NULL;

            //
            // If there is no truncation...
            //
            if (RequestLength == (SIZE_T)RequestLength)
            {
                pKeRequest = (PUC_HTTP_REQUEST) 
                             UL_ALLOCATE_POOL_WITH_QUOTA(
                                 NonPagedPool,
                                 (SIZE_T)RequestLength,
                                 UC_REQUEST_POOL_TAG,
                                 pServInfo->pProcess
                                 );
            }

            if(!pKeRequest)
            {
                ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
            }
        }


        //
        // Initialize.
        // 

        UcpRequestInitialize(
            pKeRequest,
            (SIZE_T)RequestLength,           // Length of this request
            ContentLength - IndicatedLength, // Remaining Content Length
            pIAuth,
            pIProxyAuth,
            NULL,
            Irp,
            pIrpSp,
            pServInfo
            );

        // On which connection this request goes out?
        pKeRequest->ConnectionIndex = ConnectionIndex;

        //
        // We don't have to call UcSetFlag for these - These are thread safe
        // since we are in the init code path
        //

        pKeRequest->RequestFlags.Value = 0;

        pKeRequest->RequestFlags.ContentLengthSpecified = 
                                        bContentLengthSpecified;

        pKeRequest->RequestFlags.RequestChunked        = bChunked;
        pKeRequest->RequestFlags.LastEntitySeen        = bLast;
        pKeRequest->RequestFlags.RequestBuffered       = bBuffered;
        pKeRequest->RequestFlags.NoRequestEntityBodies = bNoRequestEntityBodies;
        pKeRequest->RequestFlags.UsePreAuth            = bPreAuth;
        pKeRequest->RequestFlags.UseProxyPreAuth       = bProxyPreAuth;
        pKeRequest->RequestFlags.PipeliningAllowed     = bPipeLine;

        // 
        // No entity body for HEAD requests.
        //

        if(pLocalHttpRequest->Verb == HttpVerbHEAD)
        {
            pKeRequest->RequestFlags.NoResponseEntityBodies = TRUE;
        }

        pKeRequest->MaxHeaderLength    = HeaderLength;
        pKeRequest->HeaderLength       = HeaderLength;  
    
        pKeRequest->UriLength          = UriLength;
    
        pKeRequest->pUri               = (PSTR)((PUCHAR)pKeRequest + 
                                                AlignRequestSize);

        if(OutLength != 0)
        {
            pKeRequest->pInternalResponse = (PHTTP_RESPONSE)
                            ((PUCHAR)pKeRequest->pUri + AlignUriLength);

            pKeRequest->pHeaders = (PUCHAR)
                ((PUCHAR)pKeRequest->pInternalResponse + sizeof(HTTP_RESPONSE));
        }
        else
        {
            pKeRequest->pHeaders = (PUCHAR)((PUCHAR) pKeRequest->pUri + 
                                                    AlignUriLength);

            pKeRequest->pInternalResponse = NULL;
        }

        //
        // Initialize all the fields for the response parser
        //


        if(OutLength == 0)
        {
            UcpRequestCommonInitialize(
                pKeRequest, 
                0,
                NULL
                );
        }
        else if(OutLength < sizeof(HTTP_RESPONSE))
        {
            // Even though we are failing this request, we still have to call 
            // UcpRequestCommonInitialize as the free routine expects some of
            // these fields to be initialized.

            UcpRequestCommonInitialize(
                pKeRequest, 
                0,
                NULL
                );

            *pBytesTaken = sizeof(HTTP_RESPONSE);

            ExRaiseStatus(STATUS_BUFFER_TOO_SMALL);
        }
        else
        {

            pBuffer = (PSTR) MmGetSystemAddressForMdlSafe(
                                    pKeRequest->AppMdl,
                                    NormalPagePriority);
    
            if(!pBuffer)
            {
                // Even though we are failing this request, we still have to 
                // call UcpRequestCommonInitialize as the free routine expects 
                // some of these fields to be initialized.
    
                UcpRequestCommonInitialize(
                    pKeRequest, 
                    0,
                    NULL
                    );
    
                ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
            }

            // 
            // Make sure buffer is pointer aligned.
            //

            if(pBuffer != ALIGN_UP_POINTER(pBuffer, PVOID))
            {
                // Even though we are failing this request, we still have to 
                // call UcpRequestCommonInitialize as the free routine expects 
                // some of these fields to be initialized.

                UcpRequestCommonInitialize(
                    pKeRequest, 
                    0,
                    NULL
                    );
    
                ExRaiseStatus(STATUS_DATATYPE_MISALIGNMENT_ERROR);
            }


            UcpRequestCommonInitialize(
                pKeRequest, 
                OutLength,
                (PUCHAR)pBuffer
                );
        }

        //
        // Canonicalize and convert the URI into UTF-8. 
        //
        Status = UcCanonicalizeURI(
                     pLocalHttpRequest->CookedUrl.pAbsPath,
                     pLocalHttpRequest->CookedUrl.AbsPathLength/sizeof(WCHAR),
                     (PBYTE)pKeRequest->pUri,
                     &pKeRequest->UriLength,
                     TRUE);

        if (!NT_SUCCESS(Status))
            ExRaiseStatus(Status);

        // NULL termiante it.
        pKeRequest->pUri[pKeRequest->UriLength] = '\0';

        //
        // CurrentBuffer is a structure which will always contain pointers
        // to the output buffer - This can be the app's buffer or our   
        // allocated buffer. 
        // It contains info like BytesAllocated, BytesAvailable, Head Ptr,
        // Tail Ptr, etc.
        //

        pBuffer = (PSTR) (pKeRequest->pHeaders + pKeRequest->HeaderLength);

        if(EntityChunkCount)
        {
            //
            // Process the entity bodies and build MDLs as you go.  
            // We either copy the entity body or Probe & Lock it. The
            // AuxiliaryBuffer is a pointer
            // 

            Status = UcpBuildEntityMdls(
                                       EntityChunkCount,
                                       pLocalEntityChunks,
                                       bBuffered,
                                       bChunked,
                                       bLast,
                                       pBuffer,
                                       &pKeRequest->pMdlLink,
                                       &pKeRequest->BytesBuffered
                                       );

            if (!NT_SUCCESS(Status))
            {
                ExRaiseStatus(Status);
            }
        }

        //
        // Build the headers. 
        // 
        // We either send the request right away or we buffer it till we see 
        // the last data chunk. However, we have to build the header upfront. 
        // Even if we are buffering the request, we migth want to complete the 
        // applications' IRP. We cannot postpone the generation of request
        // headers, because we don't want to hold on to all the input buffers.
        //
        // If we are buffering the request, we'll tack on the Content-Length 
        // when we see the last chunk.
        //

        Status = UcGenerateRequestHeaders(pLocalHttpRequest, 
                                          pKeRequest,
                                          bChunked,
                                          ContentLength
                                          );
        if(!NT_SUCCESS(Status))
            ExRaiseStatus(Status);

        if(!bBuffered)
        {
            //
            // We are not buffering this request, so we can go ahead and 
            // generate the MDL for the headers. If we are buffering the 
            // request, we'll be generating the content length at the very 
            // end, and we'll also postpone the MDL generation till then.
            //
    
            //
            // First, add the header terminator.
            //
            *(UNALIGNED64 USHORT *)
                (pKeRequest->pHeaders + pKeRequest->HeaderLength) = CRLF;
            pKeRequest->HeaderLength += CRLF_SIZE;

            UcAllocateAndChainHeaderMdl(pKeRequest);
        }
        
        
        //
        // Everything went off well, allocate an ID for this request.
        //

        UlProbeForWrite(
                pHttpIoctl->pHttpRequestId,
                sizeof(HTTP_REQUEST_ID),
                sizeof(ULONG),
                Irp->RequestorMode);

        Status = UlAllocateOpaqueId(
                    &pKeRequest->RequestId,         // pOpaqueId
                    UlOpaqueIdTypeHttpRequest,      // OpaqueIdType
                    pKeRequest                      // pContext
                 );

        if(NT_SUCCESS(Status))
        {
            //
            // Take a ref for the opaque ID.
            //
            
            UC_REFERENCE_REQUEST(pKeRequest);

            *pHttpIoctl->pHttpRequestId = pKeRequest->RequestId;
        }

    } __except( UL_EXCEPTION_FILTER())
    {
        Status = GetExceptionCode();

        if(!pKeRequest)
        {   
            if(pIAuth)
            {
                UcDestroyInternalAuth(pIAuth,
                                      pServInfo->pProcess);
            }

            if(pIProxyAuth)
            {
                UcDestroyInternalAuth(pIProxyAuth, 
                                      pServInfo->pProcess);
            }
        }
    }

    if(pLocalEntityChunks && pLocalEntityChunks != LocalEntityChunks)
    {
        UL_FREE_POOL(pLocalEntityChunks, UL_DATA_CHUNK_POOL_TAG);
    }

    *ppInternalRequest = pKeRequest;

    return Status;
}


/***************************************************************************++

Routine Description:

    Destroys an internal HTTP request captured by HttpCaptureHttpRequest().
    This involves unlocking memory, and releasing any resources allocated to 
    the request.

Arguments:

    pRequest - Supplies the internal request to destroy.

--***************************************************************************/
VOID
UcFreeSendMdls(
    IN PMDL pMdl)
{

    PMDL pTemp;

    while(pMdl)
    {
        if (IS_MDL_LOCKED(pMdl) )
        {
            MmUnlockPages(pMdl);
        }
        
        pTemp = pMdl;
        pMdl  = pMdl->Next;

        UlFreeMdl(pTemp);
    }
}

/***************************************************************************++

Routine Description:

    Free a request structure after the reference count has gone to
    zero.

Arguments:

    pKeRequest         - Pointer to the connection structure to be freed.


Return Value:


--***************************************************************************/
VOID
UcpFreeRequest(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUC_HTTP_REQUEST      pKeRequest;
    PUC_CLIENT_CONNECTION pConnection;

    PAGED_CODE();

    pKeRequest = CONTAINING_RECORD(
                        pWorkItem,
                        UC_HTTP_REQUEST,
                        WorkItem
                        );

    ASSERT(UC_IS_VALID_HTTP_REQUEST(pKeRequest));

    pConnection = pKeRequest->pConnection;


    if(pKeRequest->pAuthInfo)
    {
        UcDestroyInternalAuth(pKeRequest->pAuthInfo, 
                              pKeRequest->pServerInfo->pProcess);
    }

    if(pKeRequest->pProxyAuthInfo)
    {
        UcDestroyInternalAuth(pKeRequest->pProxyAuthInfo, 
                              pKeRequest->pServerInfo->pProcess);
    }

    if(pKeRequest->ResponseMultipartByteranges)
    {
        ASSERT(pKeRequest->pMultipartStringSeparator != NULL);
        if(pKeRequest->pMultipartStringSeparator != 
           pKeRequest->MultipartStringSeparatorBuffer)
        {
            UL_FREE_POOL_WITH_QUOTA(
                pKeRequest->pMultipartStringSeparator,
                UC_MULTIPART_STRING_BUFFER_POOL_TAG,
                NonPagedPool,
                pKeRequest->MultipartStringSeparatorLength+1,
                pKeRequest->pServerInfo->pProcess
                );
        }
    }

    if(pKeRequest->RequestSize > UC_REQUEST_LOOKASIDE_SIZE)
    {
        UL_FREE_POOL_WITH_QUOTA(
            pKeRequest,
            UC_REQUEST_POOL_TAG, 
            NonPagedPool,
            pKeRequest->RequestSize,
            pKeRequest->pServerInfo->pProcess
            );
    }
    else
    {
        ExFreeToNPagedLookasideList(
            &g_ClientRequestLookaside,
            (PVOID) pKeRequest
            );
    }

    if(pConnection)
    {
        ASSERT( UC_IS_VALID_CLIENT_CONNECTION(pConnection) );
        DEREFERENCE_CLIENT_CONNECTION(pConnection);
    }
}

/***************************************************************************++

Routine Description:

    Reference a request structure.

Arguments:

    pKeRequest     - Pointer to the request structure to be referenced.


Return Value:

--***************************************************************************/
VOID
UcReferenceRequest(
    IN PVOID             pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG             RefCount;
    PUC_HTTP_REQUEST pKeRequest = (PUC_HTTP_REQUEST) pObject;

    ASSERT( UC_IS_VALID_HTTP_REQUEST(pKeRequest) );

    RefCount = InterlockedIncrement(&pKeRequest->RefCount);

    ASSERT( RefCount > 0 );

    WRITE_REF_TRACE_LOG2(
        g_pTdiTraceLog,
        pKeRequest->pConnection ? pKeRequest->pConnection->pTraceLog:NULL,
        REF_ACTION_REFERENCE_UC_REQUEST,
        RefCount,
        pKeRequest,
        pFileName,
        LineNumber
        );
}

/***************************************************************************++

Routine Description:

    Dereference a request structure. If the reference count goes
    to 0, we'll free the structure.

Arguments:

    pRequest         - Pointer to the request structure to be dereferenced.

Return Value:

--***************************************************************************/
VOID
UcDereferenceRequest(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG        RefCount;
    PUC_HTTP_REQUEST pRequest = (PUC_HTTP_REQUEST) pObject;

    ASSERT( UC_IS_VALID_HTTP_REQUEST(pRequest) );

    WRITE_REF_TRACE_LOG2(
        g_pTdiTraceLog,
        pRequest->pConnection ? pRequest->pConnection->pTraceLog:NULL,
        REF_ACTION_DEREFERENCE_UC_REQUEST,
        pRequest->RefCount,
        pRequest,
        pFileName,
        LineNumber);

    RefCount = InterlockedDecrement(&pRequest->RefCount);

    ASSERT(RefCount >= 0);

    if (RefCount == 0)
    {
        //
        // Do final cleanup & resource release at passive IRQL.
        //

        UL_CALL_PASSIVE(&pRequest->WorkItem, UcpFreeRequest);
    }
}


/****************************************************************************++

Routine Description:

    While building the HTTP response, we set up pointers in the App's buffer.
    For this, we used the System Address space. If the app wants to access 
    these buffers, it has to see the Virtual Address pointers. 

    So, we go an fix the pointers in the buffer to point to the corresponding 
    Virtual Address. 

    Note: We don't do this while building the response itself, because we 
    could be buiding the response in our own allocated buffer  (when the app 
    does not pass sufficient buffers). We don't want to use a conditional check
    every time we build pointers.

Arguments:

    pRequest         - Pointer to the request structure to be fixed

--****************************************************************************/
VOID
UcpFixAppBufferPointers(
    PUC_HTTP_REQUEST pRequest, 
    PIRP pIrp
    )
{
    PSTR                    pBuffer;
    PMDL                    pMdl = pIrp->MdlAddress;
    USHORT                  i;
    PHTTP_RESPONSE          pResponse;
    PHTTP_UNKNOWN_HEADER    pUnk;
    PHTTP_DATA_CHUNK        pEnt;
    PSTR                    pAppBaseAddr;

    ASSERT(NULL != pMdl);

    pAppBaseAddr = (PSTR) MmGetMdlVirtualAddress(pMdl);


    //
    // Fixes up the app's buffer
    //

    //
    // Get a pointer to the head of the system mapped space.
    // we'll do our pointer arithmetic off this buffer address.
    //
    pBuffer = (PSTR) MmGetSystemAddressForMdlSafe(pMdl, NormalPagePriority);

    // BUGBUG: must handle pBuffer == NULL.

    pResponse = pRequest->pInternalResponse;

    //
    // Fix up the Reason pointer
    //

    pResponse->pReason = FIX_ADDR(pAppBaseAddr, 
                                  (pResponse->pReason - pBuffer));

    //
    // Fix the pointers in the known header.
    //

    for(i=0; i<HttpHeaderResponseMaximum; i++)
    {
        if(pResponse->Headers.KnownHeaders[i].RawValueLength)
        {
            pResponse->Flags |= HTTP_RESPONSE_FLAG_HEADER;

            pResponse->Headers.KnownHeaders[i].pRawValue = 
                      FIX_ADDR(pAppBaseAddr, 
                              (pResponse->Headers.KnownHeaders[i].pRawValue - 
                               pBuffer));
        }
    }

    //
    // Fix the pointers in the unknown header
    //
    pUnk = pResponse->Headers.pUnknownHeaders;
    for(i=0; i<pResponse->Headers.UnknownHeaderCount; i++)
    {
        pResponse->Flags |= HTTP_RESPONSE_FLAG_HEADER;

        pUnk[i].pName     = FIX_ADDR(pAppBaseAddr, (pUnk[i].pName - pBuffer));
        pUnk[i].pRawValue = FIX_ADDR(pAppBaseAddr, 
                                     (pUnk[i].pRawValue - pBuffer));
    }

    //
    // Fix the pointer to the unknown array itself.
    //
    pResponse->Headers.pUnknownHeaders = (PHTTP_UNKNOWN_HEADER)
                       FIX_ADDR(pAppBaseAddr, 
                                ((PSTR)pResponse->Headers.pUnknownHeaders - 
                                 pBuffer));

    //
    // Fix the entity bodies
    //
    pEnt = pResponse->pEntityChunks;
    for(i=0; i<pResponse->EntityChunkCount; i++)
    {
        pEnt[i].DataChunkType = HttpDataChunkFromMemory;

        pEnt[i].FromMemory.pBuffer    =  (PVOID)
                       FIX_ADDR(pAppBaseAddr, 
                                ((PSTR)pEnt[i].FromMemory.pBuffer - pBuffer));

        pResponse->Flags |= HTTP_RESPONSE_FLAG_ENTITY;
    }

    //
    // Fix the pointer to the entity bodies itself.
    //
    pResponse->pEntityChunks = (PHTTP_DATA_CHUNK)
                       FIX_ADDR(pAppBaseAddr,    
                                ((PSTR)pResponse->pEntityChunks - pBuffer));

    //
    // Now, copy the internal response into the app's buffer.
    //
    RtlCopyMemory(pBuffer, pResponse, sizeof(HTTP_RESPONSE));
}


/****************************************************************************++

Routine Description:

    Complete the Request IRP of the app. We must call this routine if we pend 
    the IRP from the IOCTL handler. This routine takes care of all the cleanups

        1. If failure, clean all allocated buffers.
        2. If success, complete the IRP and put on the Processed List 
           (if there are any allocated buffers)
        3. DEREF the request - once for the IRP and once for every Buffer 
           off the IRP.
    
Arguments:

    pRequest - The matching HTTP request.
    Status   - The completion status of the IRP.

Return Value:
    NTSTATUS - completion status.

--****************************************************************************/
PIRP 
UcPrepareRequestIrp(
    PUC_HTTP_REQUEST pRequest,
    NTSTATUS         Status
    )
{
    PUC_CLIENT_CONNECTION           pConnection;
    PIRP                            pIrp;
    BOOLEAN                         bCancelRoutineCalled;

    pConnection = pRequest->pConnection;

    ASSERT( UC_IS_VALID_HTTP_REQUEST(pRequest) );
    ASSERT( UC_IS_VALID_CLIENT_CONNECTION(pConnection) );

    pIrp = pRequest->RequestIRP;

    if(!pIrp)
    {
        //
        // The Request already got completed, bail
        //

        return NULL;
    }

    UC_WRITE_TRACE_LOG(
        g_pUcTraceLog,
        UC_ACTION_REQUEST_COMPLETE_IRP,
        pConnection,
        pRequest,
        pRequest->RequestIRP,
        UlongToPtr(Status)
        );

    //
    // Get rid of the MDLs.
    //

    UcFreeSendMdls(pRequest->pMdlHead);

    pRequest->pMdlHead = NULL;

    //
    // Try to remove the cancel routine in the request.
    //

    bCancelRoutineCalled = UcRemoveRequestCancelRoutine(pRequest);

    if(bCancelRoutineCalled)
    {
        //
        // This IRP has already got cancelled, let's move on
        //

        return NULL;
    }

    pRequest->RequestIRP = NULL;

    //
    // Now, complete the original request.
    //
    pIrp->IoStatus.Status      = Status;
    pIrp->RequestorMode        = pRequest->AppRequestorMode;
    pIrp->MdlAddress           = pRequest->AppMdl;

    if(NT_SUCCESS(Status))
    {
        if(pRequest->RequestFlags.ReceiveBufferSpecified)
        {
            if(pRequest->RequestIRPBytesWritten)
            {
                // App has provided receive buffer which has been filled
                // completely & we've allocated new buffers.

                pIrp->IoStatus.Information = 
                    pRequest->RequestIRPBytesWritten;
            }   
            else
            {
                // We've filled a part of the app buffer, but have not 
                // yet written RequestIRPBytesWritten, because we never 
                // allocated any new buffers.

                pIrp->IoStatus.Information =
                        pRequest->CurrentBuffer.BytesAllocated -
                        pRequest->CurrentBuffer.BytesAvailable;
                
            }

            if(pIrp->IoStatus.Information)
            {
                UcpFixAppBufferPointers(pRequest, pIrp);
            }
        }
    
    }
    else 
    {
        pIrp->IoStatus.Information = 0;
    }

    // Deref for the IRP.

    UC_DEREFERENCE_REQUEST(pRequest);

    return pIrp;
}


/****************************************************************************++

Routine Description:

    This routine is called when we are done parsing the request. This is where
    we complete other IRPs that could have got posted for this request.

    Since we complete the SendRequest IRP early, most likely the send-request
    IRP will be completed when we get here.

Arguments:

    pRequest    - The matching HTTP request.
    Status      - The completion status of the IRP.
    NextRequest - If TRUE, we have to fire the connection state machine to kick
                  off the next request. This will be used to send the next
                  request (e.g. non pipelined requests). If FALSE, then we 
                  don't have to do this (e.g. cleaning the requests from the
                  connection cleanup routine).

Return Value:
    NTSTATUS - completion status.

--****************************************************************************/
NTSTATUS
UcCompleteParsedRequest(
    IN PUC_HTTP_REQUEST pRequest,
    IN NTSTATUS         Status,
    IN BOOLEAN          NextRequest,
    IN KIRQL            OldIrql
    )
{
    PUC_CLIENT_CONNECTION     pConnection;
    PLIST_ENTRY               pListEntry, pIrpList;
    PUC_RESPONSE_BUFFER       pResponseBuffer;
    PUC_HTTP_RECEIVE_RESPONSE pReceiveResponse;
    LIST_ENTRY                TempIrpList, TempEntityList;
    PIRP                      pIrp, pRequestIrp;
    PIO_STACK_LOCATION        pIrpSp;
    PUC_HTTP_SEND_ENTITY_BODY pEntity;
    ULONG                     OutBufferLen;
    ULONG                     BytesTaken;
    BOOLEAN                   bDone;


    pConnection =  pRequest->pConnection;

    UC_WRITE_TRACE_LOG(
        g_pUcTraceLog,
        UC_ACTION_REQUEST_PARSE_DONE,
        pConnection,
        pRequest,
        UlongToPtr(pRequest->RequestState),
        UlongToPtr(Status)
        );

    //
    // If our send has not completed, or if the entity sends are not complete,
    // we have to postpone cleanup of this request. It'll be resumed when
    // the sends actually complete.
    //

    if(pRequest->RequestState == UcRequestStateSent ||
       pRequest->RequestState == UcRequestStateNoSendCompletePartialData ||
       pRequest->RequestState == UcRequestStateNoSendCompleteFullData  ||
       (!pRequest->RequestFlags.RequestBuffered &&
        !IsListEmpty(&pRequest->SentEntityList)))
    {
        UcSetFlag(&pRequest->RequestFlags.Value, 
                  UcMakeRequestCleanPendedFlag());

        pRequest->RequestStatus = Status;

        UC_WRITE_TRACE_LOG(
            g_pUcTraceLog,
            UC_ACTION_REQUEST_CLEAN_PENDED,
            pConnection,
            pRequest,
            UlongToPtr(pRequest->RequestState),
            UlongToPtr(pRequest->RequestStatus)
            );

        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

        return STATUS_PENDING;
    }


    if(NT_SUCCESS(Status))
    {
        //
        // First, see if we got a Www-Authenticate header that had a NTLM or 
        // Kerberos or Negotiate auth scheme with a challenge blob. 
        //

        if((pRequest->ResponseStatusCode == 401 || 
            pRequest->ResponseStatusCode == 407) &&
            pRequest->Renegotiate == TRUE &&
            pRequest->DontFreeMdls == TRUE)
        {
            //
            // Fire a worker to re-negotite this request.
            //
    
            UC_REFERENCE_REQUEST(pRequest);
    
            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
    
            UL_CALL_PASSIVE(
                &pRequest->WorkItem,    
                &UcReIssueRequestWorker
                );

            return STATUS_PENDING;
        }

        if(UcpCheckForPreAuth(pRequest) || UcpCheckForProxyPreAuth(pRequest))
        {

            //
            // Fire a worker to re-negotite this request.
            //
            
            UC_REFERENCE_REQUEST(pRequest);
            
            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
            
            UL_CALL_PASSIVE(
                &pRequest->WorkItem,
                &UcpPreAuthWorker
                );

            return STATUS_PENDING;
        }
    }
    
    //
    // If a connection cleanup was pended, we should resume it. We'll do this
    // by re-setting the ConnectionState to UcConnectStateCleanup & by kicking
    // the connection state machine at the end of this routine
    //

    if(pConnection->Flags & CLIENT_CONN_FLAG_CLEANUP_PENDED)
    {
        ASSERT(pConnection->ConnectionState == 
            UcConnectStateConnectCleanupBegin);

        pConnection->ConnectionState = UcConnectStateConnectCleanup;

        pConnection->Flags &= ~CLIENT_CONN_FLAG_CLEANUP_PENDED;

        UC_WRITE_TRACE_LOG(
            g_pUcTraceLog,
            UC_ACTION_CONNECTION_CLEAN_RESUMED,
            pConnection,
            UlongToPtr(pConnection->ConnectionStatus),
            UlongToPtr(pConnection->ConnectionState),
            UlongToPtr(pConnection->Flags)
            );

        NextRequest = TRUE;
    }

    if(pConnection->ConnectionStatus == STATUS_CONNECTION_DISCONNECTED &&
       pRequest->RequestFlags.Cancelled == FALSE &&
       pRequest->ParseState   == UcParseEntityBody &&
       pRequest->RequestState == UcRequestStateSendCompletePartialData &&
       !pRequest->ResponseContentLengthSpecified  &&
       !pRequest->ResponseEncodingChunked)
    {
        if(pRequest->CurrentBuffer.pCurrentBuffer)
        {
            pRequest->CurrentBuffer.pCurrentBuffer->Flags |=
                UC_RESPONSE_BUFFER_FLAG_READY;

            pRequest->CurrentBuffer.pCurrentBuffer->BytesWritten =
                    pRequest->CurrentBuffer.BytesAllocated -
                        pRequest->CurrentBuffer.BytesAvailable;
        }

        Status                  = STATUS_SUCCESS;
        pRequest->ParseState    = UcParseDone;
        pRequest->RequestState  = UcRequestStateResponseParsed;
    }

    //
    // First, we complete the send-request IRP
    //

    pRequestIrp = UcPrepareRequestIrp(pRequest, Status);

    if(!pRequestIrp)
    {
        // If we are completing this request, we should free the MDL chain.
        // Ideally, the MDL chain would be freed by UcPrepareRequestIrp, but
        // there can be cases when we are done with the request & there is no
        // IRP around.
        //
        // e.g a RequestIRP that got completed early (buffered request) & then
        // we turned around & cancelled it.

        UcFreeSendMdls(pRequest->pMdlHead);

        pRequest->pMdlHead = NULL;
    }

    //
    // Take the Request from the list - This can either be 
    // a. pConnection->SentRequestList    - (if connect succeeded) 
    // b. pConnection->PendingRequestList - (if connect failed)
    // c. A stack variable 
    //

    InitializeListHead(&TempIrpList);
    InitializeListHead(&TempEntityList);

    RemoveEntryList(&pRequest->Linkage);

    //
    // Make sure we don't do it again.
    //

    InitializeListHead(&pRequest->Linkage);


    //
    // If the request was buffered, then all the send entity IRPs got completed
    // and the last one was used to send the request. The allocated memory for 
    // the SendEntity IRPs need to be freed.
    //

    if(pRequest->RequestFlags.RequestBuffered)
    {
        while(!IsListEmpty(&pRequest->SentEntityList))
        {
            pIrpList = RemoveHeadList(&pRequest->SentEntityList);

            pEntity = CONTAINING_RECORD(
                           pIrpList,
                           UC_HTTP_SEND_ENTITY_BODY,
                           Linkage
                           );

            UL_FREE_POOL_WITH_QUOTA(
                         pEntity, 
                         UC_ENTITY_POOL_TAG,
                         NonPagedPool,
                         pEntity->BytesAllocated,
                         pRequest->pServerInfo->pProcess
                         );

            UC_DEREFERENCE_REQUEST(pRequest);
        }
    }

    //
    // Complete all the SendEntity IRPs that might have got queued. We will
    // do this even if we are completing the IRP with SUCCESS, because we 
    // don't need it anymore as the Response has been fully parsed.
    //
    
    while(!IsListEmpty(&pRequest->PendingEntityList))
    {
        pIrpList = RemoveHeadList(&pRequest->PendingEntityList);

        pEntity = CONTAINING_RECORD(
                       pIrpList,
                       UC_HTTP_SEND_ENTITY_BODY,
                       Linkage
                       );
   
        if(!pEntity->pIrp)
        { 
            // We had already completed the IRP before, let's just
            // nuke the allocated memory.

            UL_FREE_POOL_WITH_QUOTA(
                pEntity, 
                UC_ENTITY_POOL_TAG,
                NonPagedPool,
                pEntity->BytesAllocated,
                pRequest->pServerInfo->pProcess
                );

            UC_DEREFERENCE_REQUEST(pRequest);

        }
        else 
        {
            //
            // Let's try to remove the cancel routine in the IRP.
            //
            if (UcRemoveEntityCancelRoutine(pEntity))
            {
                //
                // This IRP has already got cancelled, let's move on
                //
                continue;
            }

            InsertHeadList(&TempEntityList, &pEntity->Linkage);
        }
    }


    if(NT_SUCCESS(Status))
    {
        //
        // If we buffered the parsed response and if the app has posted 
        // additional IRPs, we can complete them now.
        //

        //
        // The IRP are stored on a TempIrpList so that they can be 
        // completed later (outside the connection spinlock).
        //

        while(!IsListEmpty(&pRequest->ReceiveResponseIrpList))
        {
            pIrpList = RemoveHeadList(&pRequest->ReceiveResponseIrpList);

            pReceiveResponse = CONTAINING_RECORD(pIrpList,
                                                 UC_HTTP_RECEIVE_RESPONSE,
                                                 Linkage);

            if (UcRemoveRcvRespCancelRoutine(pReceiveResponse))
            {
                //
                // This IRP has already got cancelled, let's move on
                //
                InitializeListHead(&pReceiveResponse->Linkage);
                continue;
            }

            pIrp = pReceiveResponse->pIrp;
            pIrpSp = IoGetCurrentIrpStackLocation( pIrp );
            OutBufferLen=pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

            //
            // Obtain parsed response buffers to copy to this IRP
            //

            Status = UcFindBuffersForReceiveResponseIrp(
                         pRequest,
                         OutBufferLen,
                         TRUE,
                         &pReceiveResponse->ResponseBufferList,
                         &BytesTaken);

            switch (Status)
            {
            case STATUS_INVALID_PARAMETER:
            case STATUS_BUFFER_TOO_SMALL:
                //
                // Either an extra ReceiveResponseIrp
                // Or     an IRP with small buffer
                // Fail the IRP with proper status code and Information.
                //
                pIrp->IoStatus.Status = Status;
                pIrp->IoStatus.Information = BytesTaken;
                InsertTailList(&TempIrpList, &pReceiveResponse->Linkage);
                break;

            case STATUS_PENDING:
                //
                // There must not be any yet to be parsed response buffer.
                //
                ASSERT(FALSE);
                break;

            case STATUS_SUCCESS:
                //
                // Store the pointer to respose buffer that can be freed
                // later.
                //
                ASSERT(!IsListEmpty(&pReceiveResponse->ResponseBufferList));
                InsertHeadList(&TempIrpList, &pReceiveResponse->Linkage);
                break;
            }
        }
    
        //
        // We did not find any IRPs to complete this request.   
        //
        ASSERT(IsListEmpty(&pRequest->ReceiveResponseIrpList));


        if(!IsListEmpty(&pRequest->pBufferList))
        {
            //
            // We ran out of output buffer space for the app and had to 
            // allocate our own. The app has not posted ReceiveResponse
            // IRPS to read all of this data, so we need to hold onto this
            // request. We'll insert in the ProcessedList
            //

            InsertTailList(&pConnection->ProcessedRequestList,
                           &pRequest->Linkage);
        }
        else
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Failure;
        }
    }
    else
    {
Failure:
        //
        // We are done with this request. We don't need the opaque ID anymore
        //

        pRequest->RequestState = UcRequestStateDone;

        if(!HTTP_IS_NULL_ID(&pRequest->RequestId))
        {
            UlFreeOpaqueId(pRequest->RequestId, UlOpaqueIdTypeHttpRequest);
            HTTP_SET_NULL_ID(&pRequest->RequestId);
            UC_DEREFERENCE_REQUEST(pRequest);
        }

        //
        // First, clean all the buffers that we allocated.
        //

        while(!IsListEmpty(&pRequest->pBufferList))
        {
            pListEntry = RemoveHeadList(&pRequest->pBufferList);

            pResponseBuffer = CONTAINING_RECORD(pListEntry,
                                                UC_RESPONSE_BUFFER,
                                                Linkage);

            ASSERT(IS_VALID_UC_RESPONSE_BUFFER(pResponseBuffer));

            UL_FREE_POOL_WITH_QUOTA(
                        pResponseBuffer,
                        UC_RESPONSE_APP_BUFFER_POOL_TAG,
                        NonPagedPool,
                        pResponseBuffer->BytesAllocated,
                        pRequest->pServerInfo->pProcess
                        );

            UC_DEREFERENCE_REQUEST(pRequest);
        }

        //
        // We can also fail any extra receive response IRPs.
        //

        while(!IsListEmpty(&pRequest->ReceiveResponseIrpList))
        {
            pIrpList = RemoveHeadList(&pRequest->ReceiveResponseIrpList);

            pReceiveResponse = CONTAINING_RECORD(pIrpList,
                                                 UC_HTTP_RECEIVE_RESPONSE,
                                                 Linkage);

            pIrp = pReceiveResponse->pIrp;

            if (UcRemoveRcvRespCancelRoutine(pReceiveResponse))
            {
                //
                // This IRP has already got cancelled, let's move on
                //
                InitializeListHead(&pReceiveResponse->Linkage);
                continue;
            }

            pIrp->IoStatus.Status      = Status;
            pIrp->IoStatus.Information = 0;

            InsertHeadList(&TempIrpList, &pReceiveResponse->Linkage);
        }

        UC_DEREFERENCE_REQUEST(pRequest);
    }

    if(NextRequest)
    {
        UcKickOffConnectionStateMachine(
            pConnection, 
            OldIrql, 
            UcConnectionWorkItem
            );
    }   
    else
    {
        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
    }

    //
    // Now complete these IRP's.  Copy parsed response buffers to IRP.
    //

    while(!IsListEmpty(&TempIrpList))
    {
        pIrpList = RemoveHeadList(&TempIrpList);

        pReceiveResponse = CONTAINING_RECORD(pIrpList,
                                             UC_HTTP_RECEIVE_RESPONSE,
                                             Linkage);

        pIrp = pReceiveResponse->pIrp;
        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

        //
        // If there are any parsed response buffers to copy, copy them now.
        //

        if (!IsListEmpty(&pReceiveResponse->ResponseBufferList))
        {
            Status = UcCopyResponseToIrp(
                         pIrp,
                         &pReceiveResponse->ResponseBufferList,
                         &bDone,
                         &BytesTaken);

            pIrp->IoStatus.Status      = Status;
            pIrp->IoStatus.Information = BytesTaken;

            //
            // Free parsed response buffer list.
            //
            while (!IsListEmpty(&pReceiveResponse->ResponseBufferList))
            {
                pListEntry = RemoveHeadList(
                                 &pReceiveResponse->ResponseBufferList);

                pResponseBuffer = CONTAINING_RECORD(pListEntry,
                                                    UC_RESPONSE_BUFFER,
                                                    Linkage);

                ASSERT(IS_VALID_UC_RESPONSE_BUFFER(pResponseBuffer));

                UL_FREE_POOL_WITH_QUOTA(pResponseBuffer,
                                        UC_RESPONSE_APP_BUFFER_POOL_TAG,
                                        NonPagedPool,
                                        pResponseBuffer->BytesAllocated,
                                        pRequest->pServerInfo->pProcess);
            }
        }

        UlCompleteRequest(pReceiveResponse->pIrp, IO_NETWORK_INCREMENT);

        UL_FREE_POOL_WITH_QUOTA(
            pReceiveResponse, 
            UC_HTTP_RECEIVE_RESPONSE_POOL_TAG,
            NonPagedPool,
            sizeof(UC_HTTP_RECEIVE_RESPONSE),
            pRequest->pServerInfo->pProcess
            );

        UC_DEREFERENCE_REQUEST(pRequest);
    }

    while(!IsListEmpty(&TempEntityList))
    {
        pIrpList = RemoveHeadList(&TempEntityList);

        pEntity = CONTAINING_RECORD(
                       pIrpList,
                       UC_HTTP_SEND_ENTITY_BODY,
                       Linkage
                       );

        UcFreeSendMdls(pEntity->pMdlHead);

        pEntity->pIrp->IoStatus.Status      = Status;
        pEntity->pIrp->IoStatus.Information = 0;

        UlCompleteRequest(pEntity->pIrp, IO_NO_INCREMENT);

        UL_FREE_POOL_WITH_QUOTA(
                pEntity, 
                UC_ENTITY_POOL_TAG,
                NonPagedPool,
                pEntity->BytesAllocated,
                pRequest->pServerInfo->pProcess
                );

        UC_DEREFERENCE_REQUEST(pRequest);

    }

    if(pRequestIrp)
    {
        UlCompleteRequest(pRequestIrp, IO_NETWORK_INCREMENT);
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    Set the cancel routine on a request, or actually the IRP. The
    request must be protected by the appropriate spin lock being held before 
    this routine is called. We'll return TRUE if the request was cancelled 
    while we were doing this, FALSE otherwise.
                            
Arguments:

    pRequest            - Pointer to the request for which we're setting the
                            routine.
                                                        
    pCancelRoutine      - Pointer to cancel routine to be set.
    
Return Value:
    
    TRUE if the request was canceled while we were doing this, FALSE otherwise.
    

--***************************************************************************/
BOOLEAN
UcSetRequestCancelRoutine(
    PUC_HTTP_REQUEST pRequest, 
    PDRIVER_CANCEL   pCancelRoutine
    )
{
    PDRIVER_CANCEL          OldCancelRoutine;
    PIRP                    Irp;

    
    Irp = pRequest->RequestIRP;
    Irp->Tail.Overlay.DriverContext[0] = pRequest;

    UlIoSetCancelRoutine(Irp, pCancelRoutine);


    // See if it's been canceled while we were doing this. If it has, we'll
    // need to take other action.

    if (Irp->Cancel)
    {
        // It's been canceled. Remove our cancel routine, and see if it's 
        // in the process of already being run. If it's already being run
        // it'll already be NULL.

        OldCancelRoutine = UlIoSetCancelRoutine(Irp, NULL);

        if (OldCancelRoutine != NULL)
        {
            // The request was cancelled before the cancel routine was set,
            // so the cancel routine won't be run. Return TRUE so the caller
            // knows to cancel this.

            return TRUE;

        }

        // If we get here, our cancel routine is in the process of being run
        // on another thread. Just return out of here, and when the lock
        // protecting us is free the cancel routine will run.
    }

    UcSetFlag(&pRequest->RequestFlags.Value, UcMakeRequestCancelSetFlag());

    return FALSE;

}

/***************************************************************************++

Routine Description:

    Remove the cancel routine on a request, or actually the IRP. The 
    request must be protected by the appropriate spin lock being held before 
    this routine is called. We'll return TRUE if the request was cancelled 
    while we were doing this, FALSE otherwise.
                            
Arguments:

    pRequest        - Pointer to the request for which we're removing
                      the cancel routine.
                                                        
Return Value:
    
    TRUE if the request was canceled while we were doing this, FALSE otherwise.
    

--***************************************************************************/
BOOLEAN
UcRemoveRequestCancelRoutine(
    PUC_HTTP_REQUEST pRequest
    )
{
    PDRIVER_CANCEL  OldCancelRoutine;
    PIRP            Irp;

    if(pRequest->RequestFlags.CancelSet)
    {
        Irp = pRequest->RequestIRP;

        if(!Irp)
        {
            // IRP has already been completed. We'll treat this as if the IRP
            // got cancelled. Note that if we were to re-set the CancelSet
            // flag in the IRP cancellation routine, we wouldn't know if the 
            // IRP got cancelled, or if the routine was never set.
    
            return TRUE;
        }

        OldCancelRoutine = UlIoSetCancelRoutine(Irp, NULL);
    
    
        // See if the cancel routine is running, or about to run. If the
        // OldCancelRoutine is NULL, the cancel routine is running, so return
        // TRUE so that the caller knows not to process the request further.
    
        if (OldCancelRoutine == NULL)
        {
            // The routine is running, return TRUE.
            return TRUE;
        }

        // The routine isn't running, we removed the cancel routine
        // successfully.
        // UC_BUGBUG : this is not thread safe.

        pRequest->RequestFlags.CancelSet = FALSE;
    }

    return FALSE;
}

/***************************************************************************++

Routine Description:

    Remove the cancel routine on a request, or actually the IRP. The 
    request must be protected by the appropriate spin lock being held before 
    this routine is called. We'll return TRUE if the request was cancelled 
    while we were doing this, FALSE otherwise.
                            
Arguments:

    pRequest        - Pointer to the request for which we're removing
                      the cancel routine.
                                                        
Return Value:
    
    TRUE if the request was canceled while we were doing this, FALSE otherwise.
    

--***************************************************************************/
BOOLEAN
UcRemoveEntityCancelRoutine(
    PUC_HTTP_SEND_ENTITY_BODY pEntity
    )
{
    PDRIVER_CANCEL  OldCancelRoutine;
    PIRP            Irp;


    if(pEntity->CancelSet)
    {
        Irp = pEntity->pIrp;
        
        if(!Irp)
        {   
            return TRUE;
        }

        OldCancelRoutine = UlIoSetCancelRoutine(Irp, NULL);
    
    
        // See if the cancel routine is running, or about to run. If the
        // OldCancelRoutine is NULL, the cancel routine is running, so return
        // TRUE so that the caller knows not to process the request further.
    
        if (OldCancelRoutine == NULL)
        {
            // The routine is running, return TRUE.
            return TRUE;
        }

        // The routine isn't running, we removed the cancel routine
        // successfully.

        pEntity->CancelSet = FALSE;
    }

    return FALSE;
}

/***************************************************************************++

Routine Description:

    Set the cancel routine on a entity-IRP, or actually the IRP. The
    request must be protected by the appropriate spin lock being held before 
    this routine is called. We'll return TRUE if the request was cancelled 
    while we were doing this, FALSE otherwise.
                            
Arguments:

    pRequest            - Pointer to the request for which we're setting the
                            routine.
                                                        
    pCancelRoutine      - Pointer to cancel routine to be set.
    
Return Value:
    
    TRUE if the request was canceled while we were doing this, FALSE otherwise.
    

--***************************************************************************/
BOOLEAN
UcSetEntityCancelRoutine(
    PUC_HTTP_SEND_ENTITY_BODY   pEntity, 
    PDRIVER_CANCEL              pCancelRoutine
    )
{
    PDRIVER_CANCEL          OldCancelRoutine;
    PIRP                    Irp;

    
    Irp = pEntity->pIrp;
    Irp->Tail.Overlay.DriverContext[0] = pEntity;

    UlIoSetCancelRoutine(Irp, pCancelRoutine);


    // See if it's been canceled while we were doing this. If it has, we'll
    // need to take other action.

    if (Irp->Cancel)
    {
        // It's been canceled. Remove our cancel routine, and see if it's 
        // in the process of already being run. If it's already being run
        // it'll already be NULL.

        OldCancelRoutine = UlIoSetCancelRoutine(Irp, NULL);

        if (OldCancelRoutine != NULL)
        {
            // The request was cancelled before the cancel routine was set,
            // so the cancel routine won't be run. Return TRUE so the caller
            // knows to cancel this.

            return TRUE;

        }

        // If we get here, our cancel routine is in the process of being run
        // on another thread. Just return out of here, and when the lock
        // protecting us is free the cancel routine will run.
    }

    pEntity->CancelSet = TRUE;

    return FALSE;

}

/******************************************************************************

Routine Description:

    This routine copies response into a free irp.

    It takes a list of UC_RESPONSE_BUFFER's and copies them to the IRP.
    Assumes that the IRP has enough buffer space to contain all the
    UC_RESPONSE_BUFFER's in the list.

Arguments:

    IN  pIrp            - Pointer to the App's IRP
    IN  pResponseBuffer - List of UC_RESPONSE_BUFFER's (there nust be at least
                          one Response buffer i.e. the list can NOT be empty)
    OUT pbLast          - Whether the last response buffer was copied
    OUT pBytesTaken     - Number of bytes copied to the IRP

Return Value:

    NTSTATUS

******************************************************************************/
#define COPY_AND_ADVANCE_POINTER(pDest, pSrc, len, pEnd)        \
do {                                                            \
    if ((pDest) + (len) > (pEnd) || (pDest) + (len) < (pDest))  \
    {                                                           \
        ASSERT(FALSE);                                          \
        return STATUS_BUFFER_TOO_SMALL;                         \
    }                                                           \
    if (pSrc)                                                   \
    {                                                           \
        RtlCopyMemory((pDest), (pSrc), (len));                  \
    }                                                           \
    (pDest) += (len);                                           \
} while (0)

#define ADVANCE_POINTER(ptr, len, pEnd) \
            COPY_AND_ADVANCE_POINTER(ptr, NULL, len, pEnd)

NTSTATUS
UcCopyResponseToIrp(
    IN  PIRP                 pIrp,
    IN  PLIST_ENTRY          pResponseBufferList,
    OUT PBOOLEAN             pbLast,
    OUT PULONG               pBytesTaken
    )
{
    PUC_RESPONSE_BUFFER  pCurrentBuffer;
    PUCHAR               pUOriginBuffer, pUBuffer, pUBufferEnd;
    PHTTP_RESPONSE       pUResponse, pHttpResponse;
    ULONG                i, TotalBytesWritten;
    ULONG                TotalEntityCount, TotalEntityLength;
    PUCHAR               pAppBaseAddr;
    PHTTP_UNKNOWN_HEADER pUUnk = NULL;
    PHTTP_DATA_CHUNK     pUEntityChunk = NULL;
    PLIST_ENTRY          pListEntry;
    ULONG                UBufferLength;

    //
    // Sanity checks.
    //

    ASSERT(pIrp && pIrp->MdlAddress);
    ASSERT(pResponseBufferList && !IsListEmpty(pResponseBufferList));
    ASSERT(pbLast && pBytesTaken);

    pAppBaseAddr = MmGetMdlVirtualAddress(pIrp->MdlAddress);

    UBufferLength = (IoGetCurrentIrpStackLocation(pIrp))->Parameters.
                        DeviceIoControl.OutputBufferLength;

    pUOriginBuffer = MmGetSystemAddressForMdlSafe(pIrp->MdlAddress,
                                                  NormalPagePriority);

    pUBuffer = pUOriginBuffer;
    pUBufferEnd = pUBuffer + UBufferLength;

    if (!pUBuffer || pUBufferEnd <= pUBuffer)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Make sure that the user buffer is pointer aligned.
    //

    if ((pUBuffer != ALIGN_UP_POINTER(pUBuffer, PVOID)))
    {
        return STATUS_DATATYPE_MISALIGNMENT_ERROR;
    }

    //
    // TotalEntityCount  = sum of entity counts of all buffers.
    // TotalBytesWritten = sum of BytesWritten of all buffers.
    //

    TotalEntityCount = 0;
    TotalBytesWritten = 0;

    for (pListEntry = pResponseBufferList->Flink;
         pListEntry != pResponseBufferList;
         pListEntry = pListEntry->Flink)
    {
        pCurrentBuffer = CONTAINING_RECORD(pListEntry,
                                           UC_RESPONSE_BUFFER,
                                           Linkage);

        //
        // All buffer must be valid and ready to be copied.
        // Except the first buffer, all buffers must also be meargable.
        //

        ASSERT(IS_VALID_UC_RESPONSE_BUFFER(pCurrentBuffer));
        ASSERT(pCurrentBuffer->Flags & UC_RESPONSE_BUFFER_FLAG_READY);
        ASSERT(pListEntry == pResponseBufferList->Flink ||
               !(pCurrentBuffer->Flags&UC_RESPONSE_BUFFER_FLAG_NOT_MERGEABLE));

        //
        // There must not be any arithmetic overflows.
        //

        ASSERT(TotalEntityCount <= TotalEntityCount +
               pCurrentBuffer->HttpResponse.EntityChunkCount);

        TotalEntityCount += pCurrentBuffer->HttpResponse.EntityChunkCount;

        //
        // TotalBytesWritten should not overflow.
        //

        ASSERT(TotalBytesWritten <= TotalBytesWritten + 
               pCurrentBuffer->BytesWritten);

        TotalBytesWritten += pCurrentBuffer->BytesWritten;
    }

    //
    // Initialize pCurrentBuffer to the first response buffer in the list.
    //

    pCurrentBuffer = CONTAINING_RECORD(pResponseBufferList->Flink,
                                       UC_RESPONSE_BUFFER,
                                       Linkage);

    ASSERT(IS_VALID_UC_RESPONSE_BUFFER(pCurrentBuffer));
    ASSERT(pCurrentBuffer->Flags & UC_RESPONSE_BUFFER_FLAG_READY);

    //
    // Create HTTP_RESPONSE structure in the user buffer.
    //

    pHttpResponse = &pCurrentBuffer->HttpResponse;

    pUResponse    = (PHTTP_RESPONSE)pUBuffer;

    ADVANCE_POINTER(pUBuffer, sizeof(HTTP_RESPONSE), pUBufferEnd);

    RtlZeroMemory(pUResponse, sizeof(HTTP_RESPONSE));

    //
    // Copy non-pointer members of HTTP_RESPONSE structure.
    //

    pUResponse->Flags                = pHttpResponse->Flags;
    pUResponse->Version.MajorVersion = pHttpResponse->Version.MajorVersion;
    pUResponse->Version.MinorVersion = pHttpResponse->Version.MinorVersion;
    pUResponse->StatusCode           = pHttpResponse->StatusCode;

    //
    // If unkown headers are present, make space for unknown header array.
    //

    if (pHttpResponse->Headers.UnknownHeaderCount)
    {
        ASSERT(pUBuffer == ALIGN_UP_POINTER(pUBuffer, PVOID));

        //
        // Remember unknown headers array address.
        //

        pUUnk = (PHTTP_UNKNOWN_HEADER)pUBuffer;

        //
        // Consume the array space from output buffer. 
        //

        ADVANCE_POINTER(pUBuffer,
                        (ULONG)sizeof(HTTP_UNKNOWN_HEADER) *
                        pHttpResponse->Headers.UnknownHeaderCount,
                        pUBufferEnd);

    }

    //
    // If there are any entities to be copied, make space for 
    // one HTTP_DATA_CHUNK now.
    //

    if (TotalEntityCount)
    {
        ASSERT(pUBuffer == ALIGN_UP_POINTER(pUBuffer, PVOID));

        pUEntityChunk = (PHTTP_DATA_CHUNK)pUBuffer;

        ADVANCE_POINTER(pUBuffer, sizeof(HTTP_DATA_CHUNK), pUBufferEnd);
    }

    //
    // Copy reason phrase.
    //

    if(pHttpResponse->ReasonLength)
    {
        pUResponse->pReason = (PSTR)FIX_ADDR(pAppBaseAddr,
                                             (pUBuffer - pUOriginBuffer));

        pUResponse->ReasonLength = pHttpResponse->ReasonLength;

        COPY_AND_ADVANCE_POINTER(pUBuffer,
                                 pHttpResponse->pReason,
                                 pHttpResponse->ReasonLength,
                                 pUBufferEnd);
    }

    //
    // Copy the unknown response headers.
    //

    if(pHttpResponse->Headers.UnknownHeaderCount)
    {
        ASSERT(pUUnk);

        //
        // Indicate to the user that response has one or more headers.
        //

        pUResponse->Flags |= HTTP_RESPONSE_FLAG_HEADER;

        pUResponse->Headers.pUnknownHeaders = (PHTTP_UNKNOWN_HEADER)
            FIX_ADDR(pAppBaseAddr, ((PUCHAR)pUUnk - pUOriginBuffer));

        pUResponse->Headers.UnknownHeaderCount =
            pHttpResponse->Headers.UnknownHeaderCount;

        for(i = 0; i < pHttpResponse->Headers.UnknownHeaderCount; i++)
        {
            //
            // Copy header name first.
            //

            pUUnk[i].NameLength =
                pHttpResponse->Headers.pUnknownHeaders[i].NameLength; 

            pUUnk[i].pName = (PSTR)FIX_ADDR(pAppBaseAddr,
                                           (pUBuffer - pUOriginBuffer));

            COPY_AND_ADVANCE_POINTER(
                pUBuffer,
                pHttpResponse->Headers.pUnknownHeaders[i].pName,
                pHttpResponse->Headers.pUnknownHeaders[i].NameLength,
                pUBufferEnd);

            //
            // Then copy header value.
            //

            pUUnk[i].RawValueLength =
                pHttpResponse->Headers.pUnknownHeaders[i].RawValueLength;

            pUUnk[i].pRawValue = (PSTR)FIX_ADDR(pAppBaseAddr,
                                               (pUBuffer - pUOriginBuffer));

            COPY_AND_ADVANCE_POINTER(
                pUBuffer,
                pHttpResponse->Headers.pUnknownHeaders[i].pRawValue,
                pHttpResponse->Headers.pUnknownHeaders[i].RawValueLength,
                pUBufferEnd);
        }
    }

    //
    // Copy known response headers.
    //

    for(i = 0; i < HttpHeaderResponseMaximum; i++)
    {
        if(pHttpResponse->Headers.KnownHeaders[i].RawValueLength)
        {
            pUResponse->Flags |= HTTP_RESPONSE_FLAG_HEADER;

            pUResponse->Headers.KnownHeaders[i].RawValueLength = 
                pHttpResponse->Headers.KnownHeaders[i].RawValueLength;

            pUResponse->Headers.KnownHeaders[i].pRawValue = 
                (PSTR)FIX_ADDR(pAppBaseAddr, (pUBuffer - pUOriginBuffer));

            COPY_AND_ADVANCE_POINTER(
                pUBuffer,
                pHttpResponse->Headers.KnownHeaders[i].pRawValue,
                pHttpResponse->Headers.KnownHeaders[i].RawValueLength,
                pUBufferEnd);
        }
    }

    //
    // If there are any entities, copy them now.
    //

    if (TotalEntityCount)
    {
        ASSERT(pUEntityChunk);

        //
        // Initialize user's response buffer.
        //

        pUResponse->Flags |= HTTP_RESPONSE_FLAG_ENTITY;

        pUResponse->EntityChunkCount = 1;

        pUResponse->pEntityChunks = (PHTTP_DATA_CHUNK)
            FIX_ADDR(pAppBaseAddr, ((PUCHAR)pUEntityChunk - pUOriginBuffer));

        //
        // pUEntityChunk is a pointer to (user mode) HTTP_DATA_CHUNK.
        //

        pUEntityChunk->DataChunkType = HttpDataChunkFromMemory;

        pUEntityChunk->FromMemory.BufferLength = TotalEntityLength = 0;

        pUEntityChunk->FromMemory.pBuffer =
            FIX_ADDR(pAppBaseAddr, (pUBuffer - pUOriginBuffer));

        //
        // Copy entities.
        //

        for (pListEntry = pResponseBufferList->Flink;
             pListEntry != pResponseBufferList;
             pListEntry = pListEntry->Flink)
        {
            pCurrentBuffer = CONTAINING_RECORD(pListEntry,
                                               UC_RESPONSE_BUFFER,
                                               Linkage);

            //
            // All buffer must be valid and ready to be copied.
            // Except the first buffer, all buffers must also be meargable.
            //

            ASSERT(IS_VALID_UC_RESPONSE_BUFFER(pCurrentBuffer));
            ASSERT(pCurrentBuffer->Flags & UC_RESPONSE_BUFFER_FLAG_READY);
            ASSERT(pListEntry == pResponseBufferList->Flink ||
                   !(pCurrentBuffer->Flags &
                     UC_RESPONSE_BUFFER_FLAG_NOT_MERGEABLE));

            pHttpResponse = &pCurrentBuffer->HttpResponse;

            for(i = 0; i < pHttpResponse->EntityChunkCount; i++)
            {
                ASSERT(TotalEntityLength +
                       pHttpResponse->pEntityChunks[i].FromMemory.BufferLength
                       >= TotalEntityLength);

                TotalEntityLength +=
                    pHttpResponse->pEntityChunks[i].FromMemory.BufferLength;

                COPY_AND_ADVANCE_POINTER(
                    pUBuffer,
                    pHttpResponse->pEntityChunks[i].FromMemory.pBuffer,
                    pHttpResponse->pEntityChunks[i].FromMemory.BufferLength,
                    pUBufferEnd);
            }
        }

        pUEntityChunk->FromMemory.BufferLength = TotalEntityLength;
    }

    //
    // Assert that we did not write more than user buffer can hold.
    //

    ASSERT(pUBuffer <= pUOriginBuffer + TotalBytesWritten);
    ASSERT(pUBuffer <= pUOriginBuffer + UBufferLength);

    *pBytesTaken = DIFF(pUBuffer - pUOriginBuffer);

    //
    // HTTP_RESPONSE_FLAG_MORE_DATA flag is taken from the last buffer
    // in the list.
    //

    pCurrentBuffer = CONTAINING_RECORD(pResponseBufferList->Blink,
                                       UC_RESPONSE_BUFFER,
                                       Linkage);

    ASSERT(IS_VALID_UC_RESPONSE_BUFFER(pCurrentBuffer));

    pHttpResponse  = &pCurrentBuffer->HttpResponse;

    *pbLast = (BOOLEAN)((pHttpResponse->Flags & 
                            HTTP_RESPONSE_FLAG_MORE_DATA) == 0);

    if (*pbLast)
    {
        pUResponse->Flags &= ~HTTP_RESPONSE_FLAG_MORE_DATA;
    }
    else
    {
        pUResponse->Flags |= HTTP_RESPONSE_FLAG_MORE_DATA;
    }

    return STATUS_SUCCESS;
}

/**************************************************************************++

Routine Description:

    This routine finds the parsed response buffers that can be merged and
    copied into a single user's buffer of OutBufferLen bytes.

Arguments:

    pRequest       - Request for which response is to be retrieved
    OutBufferLen   - Length of the output buffer
    bForceComplete - If true, this routine should return parsed response
                     buffers even if it could not find enough buffers to
                     consume OutBufferLen bytes

    pResponseBufferList - Output list of parsed response buffers
    pTotalBytes         - Total bytes (from OutBufferLen bytes) consumed

Return Value:

    STATUS_INVALID_PARAMETER - There are no parsed response buffers.
    STATUS_PENDING           - There are not enough parsed response buffers
                               to consume OutBufferLen bytes.
    STATUS_BUFFER_TOO_SMALL  - OutBufferLen is too small to hold any parsed
                               response buffers.
    STATUS_SUCCESS           - Successful.

--**************************************************************************/
NTSTATUS
UcFindBuffersForReceiveResponseIrp(
    IN     PUC_HTTP_REQUEST    pRequest,
    IN     ULONG               OutBufferLen,
    IN     BOOLEAN             bForceComplete,
    OUT    PLIST_ENTRY         pResponseBufferList,
    OUT    PULONG              pTotalBytes
    )
{
    PLIST_ENTRY            pListEntry;
    PUC_RESPONSE_BUFFER    pResponseBuffer = NULL;
    ULONG                  BufferCount;
    BOOLEAN                bNotReady;
    BOOLEAN                bNotMergeable;
    BOOLEAN                bOverFlow;


    //
    // Sanity check
    //
    ASSERT(UC_IS_VALID_HTTP_REQUEST(pRequest));
    ASSERT(UC_IS_VALID_CLIENT_CONNECTION(pRequest->pConnection));
    ASSERT(UlDbgSpinLockOwned(&pRequest->pConnection->SpinLock));

    //
    // Initialize output variables
    //
    InitializeListHead(pResponseBufferList);
    *pTotalBytes = 0;

    //
    // Did we run out of parsed response?
    //
    if (IsListEmpty(&pRequest->pBufferList))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // We have at least one buffer of parsed response...
    //

    //
    // Find out how many more buffers the IRP can hold.
    //

    BufferCount = 0;
    bNotReady = bNotMergeable = bOverFlow = FALSE;

    for (pListEntry = pRequest->pBufferList.Flink;
         pListEntry != &pRequest->pBufferList;
         pListEntry = pListEntry->Flink)
    {
        pResponseBuffer = CONTAINING_RECORD(pListEntry,
                                            UC_RESPONSE_BUFFER,
                                            Linkage);

        ASSERT(IS_VALID_UC_RESPONSE_BUFFER(pResponseBuffer));

        if (!(pResponseBuffer->Flags & UC_RESPONSE_BUFFER_FLAG_READY))
        {
            bNotReady = TRUE;
            break;
        }

        if (BufferCount != 0 &&
            pResponseBuffer->Flags & UC_RESPONSE_BUFFER_FLAG_NOT_MERGEABLE)
        {
            bNotMergeable = TRUE;
            break;
        }

        ASSERT(pResponseBuffer->BytesWritten > 0);

        if (OutBufferLen < pResponseBuffer->BytesWritten)
        {
            bOverFlow = TRUE;
            break;
        }

        OutBufferLen -= pResponseBuffer->BytesWritten;
        BufferCount++;
    }

    if (BufferCount == 0)
    {
        //
        // Could not find any parsed response buffers to copy.
        // Find out why.
        //

        ASSERT(bNotMergeable == FALSE);

        if (bNotReady)
        {
            //
            // The first buffer on the list is not yet ready for copy.
            //
            return STATUS_PENDING;
        }
        else if(bOverFlow)
        {
            //
            // This IRP is too small to hold the first response buffer.
            //
            *pTotalBytes = pResponseBuffer->BytesWritten;
            return STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            ASSERT(FALSE);
        }
    }

    ASSERT(BufferCount >= 1);

    if (pListEntry == &pRequest->pBufferList || bNotReady)
    {
        //
        // We ran out of parsed response buffers OR
        // encountered a buffer which is not yet ready.
        //

        ASSERT(bNotMergeable == FALSE && bOverFlow == FALSE);

        if (!bForceComplete)
        {
            //
            // Caller does not want to complete a ReceiveResponse IRP
            // without fully consuming its buffer.
            //
            return STATUS_PENDING;
        }
        //
        // else fall through...
        //
    }

    //
    // Lets attach BufferCount buffers to pResposenBufferList
    //

    InitializeListHead(pResponseBufferList);

    for ( ; BufferCount; BufferCount--)
    {
        pListEntry = RemoveHeadList(&pRequest->pBufferList);

        UC_DEREFERENCE_REQUEST(pRequest);

        pResponseBuffer = CONTAINING_RECORD(pListEntry,
                                            UC_RESPONSE_BUFFER,
                                            Linkage);

        ASSERT(IS_VALID_UC_RESPONSE_BUFFER(pResponseBuffer));

        InsertTailList(pResponseBufferList, &pResponseBuffer->Linkage);

        *pTotalBytes += pResponseBuffer->BytesWritten;
    }

    return STATUS_SUCCESS;
}


/******************************************************************************

Routine Description:

    This routine copies the parsed HTTP response into the application's buffer
    If the response is not parsed as yet, then the request is queued for later
    completion.

    NOTE: This is a OUT_DIRECT IOCTL.

Arguments:

    pRequest - the request to copy

    pIrp - the irp 

Return Value:


******************************************************************************/
NTSTATUS
UcReceiveHttpResponse(
    PUC_HTTP_REQUEST pRequest,
    PIRP             pIrp,
    PULONG           pBytesTaken
    )
{
    PIO_STACK_LOCATION          pIrpSp;
    ULONG                       OutBufferLen;
    PUC_HTTP_RECEIVE_RESPONSE   pResponse;
    PUC_CLIENT_CONNECTION       pConnection;
    KIRQL                       OldIrql;
    BOOLEAN                     bRequestDone, RequestCancelled;
    NTSTATUS                    Status;
    LIST_ENTRY                  BufferList;


    pConnection  = pRequest->pConnection;
    ASSERT(UC_IS_VALID_CLIENT_CONNECTION(pConnection));

    //
    // Get the IRP's output buffer length.
    //
    pIrpSp       = IoGetCurrentIrpStackLocation(pIrp);
    OutBufferLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Request is not yet complete.
    //
    bRequestDone = FALSE;

    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

    if(pRequest->RequestState == UcRequestStateDone ||
       pRequest->RequestFlags.Cancelled)
    {
        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

        return STATUS_INVALID_PARAMETER;
    }

    //
    // If we have received a partial (or full) response, and there is no
    // received response IRP already pending, we can try completing this
    // receive reponse IRP.
    //

    if(UC_IS_RESPONSE_RECEIVED(pRequest) &&
       IsListEmpty(&pRequest->ReceiveResponseIrpList))
    {
        //
        // Try acquire parsed response buffers to complete this IRP
        //

        Status = UcFindBuffersForReceiveResponseIrp(
                     pRequest,
                     OutBufferLen,
                     (BOOLEAN)(pRequest->RequestState ==
                                   UcRequestStateResponseParsed),
                     &BufferList,
                     pBytesTaken);

        switch (Status)
        {
        case STATUS_INVALID_PARAMETER:
            //
            // No parsed response available now.
            //
            if (pRequest->RequestState == UcRequestStateResponseParsed)
            {
                //
                // There will not be any more parsed response buffers to 
                // copy to App's IRP.  We'll have to fail the IRP.
                //
                UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
                return STATUS_INVALID_PARAMETER;
            }
            goto QueueIrp;

        case STATUS_PENDING:
            //
            // Not enough data available to copy to IRP
            //
            goto QueueIrp;

        case STATUS_BUFFER_TOO_SMALL:
            //
            // IRP buffer is small to contain a parsed response buffer.
            //

            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
            return STATUS_BUFFER_TOO_SMALL;

        case STATUS_SUCCESS:
            //
            // We found some parsed response buffers to copy to IRP
            //

            ASSERT(!IsListEmpty(&BufferList));
            break;

        default:
            //
            // Must not be here!
            //
            ASSERT(FALSE);
            break;
        }

        ASSERT(Status == STATUS_SUCCESS);

        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

        //
        // Copy parsed response buffers in BufferList to Irp buffer.
        //

        Status = UcCopyResponseToIrp(pIrp,
                                     &BufferList,
                                     &bRequestDone,
                                     pBytesTaken);

        pIrp->IoStatus.Status      = Status;
        pIrp->IoStatus.Information = *pBytesTaken;

        //
        // Free parsed response buffer.  Note: they no longer have a 
        // reference on the request, so do not deref request here.
        //

        while (!IsListEmpty(&BufferList))
        {
            PLIST_ENTRY         pListEntry;
            PUC_RESPONSE_BUFFER pTmpBuffer;

            pListEntry = RemoveHeadList(&BufferList);

            pTmpBuffer = CONTAINING_RECORD(pListEntry,
                                           UC_RESPONSE_BUFFER,
                                           Linkage);

            ASSERT(IS_VALID_UC_RESPONSE_BUFFER(pTmpBuffer));

            UL_FREE_POOL_WITH_QUOTA(pTmpBuffer,
                                    UC_RESPONSE_APP_BUFFER_POOL_TAG,
                                    NonPagedPool,
                                    pTmpBuffer->BytesAllocated,
                                    pRequest->pServerInfo->pProcess);
        }

        //
        // Fail the request if something went wrong.
        //

        if(!NT_SUCCESS(Status))
        {
            UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

            UcFailRequest(pRequest, Status, OldIrql);
        }
        else 
        {
            if(bRequestDone)
            {
                //
                // OK to call fail here, as the app has read all the buffers.
                //
                UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

                UcFailRequest(pRequest, Status, OldIrql);
            }

            //
            // Deref for the opaque ID
            //
            UC_DEREFERENCE_REQUEST(pRequest);
        }

        return Status;
    }

 QueueIrp:

    //
    // We got a ReceiveResponse IRP much sooner, let's queue it.
    //

    pResponse = (PUC_HTTP_RECEIVE_RESPONSE)
                    UL_ALLOCATE_POOL_WITH_QUOTA(
                        NonPagedPool,
                        sizeof(UC_HTTP_RECEIVE_RESPONSE),
                        UC_HTTP_RECEIVE_RESPONSE_POOL_TAG,
                        pRequest->pServerInfo->pProcess
                        );

    if(!pResponse)
    {
        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pResponse->CancelSet       = FALSE;
    pResponse->pIrp            = pIrp;
    pResponse->pRequest        = pRequest;
    InitializeListHead(&pResponse->ResponseBufferList);

    IoMarkIrpPending(pIrp);

    pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pResponse;

    RequestCancelled = UcSetRecvResponseCancelRoutine(
                           pResponse,
                           UcpCancelReceiveResponse);

    if(RequestCancelled)
    {
        // If the IRP got cancelled while we were setting the routine,
        // we have to return PENDING, as the Cancel routine will take
        // care of removing it from the list & completing the IRP.
        //

        UC_WRITE_TRACE_LOG(
            g_pUcTraceLog,
            UC_ACTION_RESPONSE_CANCELLED,
            pRequest,
            pResponse,
            pIrp,
            STATUS_CANCELLED
            );
    
        pResponse->pIrp = NULL;

        InitializeListHead(&pResponse->Linkage);
    }
    else
    {
        InsertTailList(&pRequest->ReceiveResponseIrpList, &pResponse->Linkage);
    }

    UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

    return STATUS_PENDING;
}


/***************************************************************************++

Routine Description:

    Remove the cancel routine on a request, or actually the IRP. The 
    request must be protected by the appropriate spin lock being held before 
    this routine is called. We'll return TRUE if the request was cancelled 
    while we were doing this, FALSE otherwise.
                            
Arguments:

    pRequest        - Pointer to the request for which we're removing
                      the cancel routine.
                                                        
Return Value:
    
    TRUE if the request was canceled while we were doing this, FALSE otherwise.
    

--***************************************************************************/
BOOLEAN
UcRemoveRcvRespCancelRoutine(
    PUC_HTTP_RECEIVE_RESPONSE pResponse
    )
{
    PDRIVER_CANCEL  OldCancelRoutine;
    PIRP            Irp;


    if(pResponse->CancelSet)
    {
        Irp = pResponse->pIrp;

        if(!Irp)
        {
            return TRUE;
        }

        OldCancelRoutine = UlIoSetCancelRoutine(Irp, NULL);
    
    
        // See if the cancel routine is running, or about to run. If the
        // OldCancelRoutine is NULL, the cancel routine is running, so return
        // TRUE so that the caller knows not to process the request further.
    
        if (OldCancelRoutine == NULL)
        {
            // The routine is running, return TRUE.
            return TRUE;
        }

        // The routine isn't running, we removed the cancel routine
        // successfully.

        pResponse->CancelSet = FALSE;
    }

    return FALSE;
}

/***************************************************************************++

Routine Description:

    Set the cancel routine on a receive-response IRP, or actually the IRP. The
    request must be protected by the appropriate spin lock being held before
    this routine is called. We'll return TRUE if the request was cancelled
    while we were doing this, FALSE otherwise.

Arguments:

    pRequest            - Pointer to the request for which we're setting the
                            routine.

    pCancelRoutine      - Pointer to cancel routine to be set.

Return Value:

    TRUE if the request was canceled while we were doing this, FALSE otherwise.


--***************************************************************************/
BOOLEAN
UcSetRecvResponseCancelRoutine(
    PUC_HTTP_RECEIVE_RESPONSE pResponse,
    PDRIVER_CANCEL            pCancelRoutine
    )
{
    PDRIVER_CANCEL          OldCancelRoutine;
    PIRP                    Irp;


    Irp = pResponse->pIrp;
    Irp->Tail.Overlay.DriverContext[0] = pResponse;

    UlIoSetCancelRoutine(Irp, pCancelRoutine);


    // See if it's been canceled while we were doing this. If it has, we'll
    // need to take other action.

    if (Irp->Cancel)
    {
        // It's been canceled. Remove our cancel routine, and see if it's
        // in the process of already being run. If it's already being run
        // it'll already be NULL.

        OldCancelRoutine = UlIoSetCancelRoutine(Irp, NULL);

        if (OldCancelRoutine != NULL)
        {
            // The request was cancelled before the cancel routine was set,
            // so the cancel routine won't be run. Return TRUE so the caller
            // knows to cancel this.

            return TRUE;

        }

        // If we get here, our cancel routine is in the process of being run
        // on another thread. Just return out of here, and when the lock
        // protecting us is free the cancel routine will run.
    }

    pResponse->CancelSet = TRUE;

    return FALSE;
}

/***************************************************************************++

Routine Description:

    Cancel a pending request. This routine is called when we're canceling
    a request that's on the pending list, hasn't been sent and hasn't caused
    a connect request.

Arguments:

    pDeviceObject           - Pointer to device object.
    Irp                     - Pointer to IRP being canceled.

Return Value:



--***************************************************************************/
VOID
UcpCancelReceiveResponse(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    Irp
    )
{
    PUC_HTTP_RECEIVE_RESPONSE     pResponse;
    PUC_HTTP_REQUEST              pRequest;
    PUC_CLIENT_CONNECTION         pConnection;
    KIRQL                         OldIrql;

    UNREFERENCED_PARAMETER(pDeviceObject);

    // Release the cancel spin lock, since we're not using it.

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    // Retrieve the pointers we need. The request pointer is stored inthe
    // driver context array, and a back pointer to the connection is stored
    // in the request. Whoever set the cancel routine is responsible for
    // referencing the connection for us.

    pResponse = (PUC_HTTP_RECEIVE_RESPONSE) Irp->Tail.Overlay.DriverContext[0];

    pConnection = pResponse->pRequest->pConnection;

    pRequest  = pResponse->pRequest;

    UC_WRITE_TRACE_LOG(
        g_pUcTraceLog,
        UC_ACTION_RESPONSE_CANCELLED,
        pRequest,
        pResponse,
        Irp,
        STATUS_CANCELLED
        );

    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

    RemoveEntryList(&pResponse->Linkage);


    UL_FREE_POOL_WITH_QUOTA(
        pResponse, 
        UC_HTTP_RECEIVE_RESPONSE_POOL_TAG,
        NonPagedPool,
        sizeof(UC_HTTP_RECEIVE_RESPONSE),
        pRequest->pServerInfo->pProcess
        );

    UcFailRequest(pRequest, STATUS_CANCELLED, OldIrql);

    UC_DEREFERENCE_REQUEST(pRequest);

    Irp->IoStatus.Status = STATUS_CANCELLED;

    UlCompleteRequest(Irp, IO_NO_INCREMENT);
}

/*****************************************************************************

Routine Description:

    Counts the number of bytes needed for the entity body. This is split into 
    two parts. If the size of an entity chunk is < 2K, we copy the buffer. If
    the size is > 2K, we Probe & Lock the page.

   
Arguments:

    EntityChunkCount  - Count of data chunks.
    pEntityChunks     - Pointer to the entity chunk.
    bBuffered         - Whether the request was buffered or not.
    bChunked          - Whether the request was chunked or not.
    Uncopied Length   - An OUT parameter to indicate no of Probe & Locked bytes
    Copied Length     - An OUT parameter to indicate no of copied bytes

Return Value
    None.

*****************************************************************************/
VOID
UcpComputeEntityBodyLength(
   IN   USHORT           EntityChunkCount,
   IN   PHTTP_DATA_CHUNK pEntityChunks,
   IN   BOOLEAN          bBuffered,
   IN   BOOLEAN          bChunked,
   OUT  PULONGLONG       UncopiedLength,
   OUT  PULONGLONG       CopiedLength
    )
{
    USHORT i;

    *CopiedLength = *UncopiedLength = 0;
    
    for(i=0; i < EntityChunkCount; i++)
    {
        if(
           (pEntityChunks[i].FromMemory.BufferLength <= 
            UC_REQUEST_COPY_THRESHOLD) || (bBuffered)
        )
        {
            //
            // We are going to copy the data 
            //
            
            *CopiedLength += 
                  pEntityChunks[i].FromMemory.BufferLength;
        }
        else
        {
            //
            // We are going to probe-lock the data, so we don't account 
            // for it's length.
            //

            *UncopiedLength += 
                  pEntityChunks[i].FromMemory.BufferLength;
            
        }
    }

    //
    // If we are using chunked encoding, we'll need buffer space to hold 
    // the chunk length and the two CRLFs. We'll optimize things here by 
    // making the following assumption -
    //
    // We don't have to compute the space for each of the entity bodies 
    // based on their length, we can just assume that they will all be of 
    // UC_MAX_CHUNK_SIZE.
    //

    if(bChunked)
    {
        *CopiedLength += (EntityChunkCount * UC_MAX_CHUNK_SIZE);
    }
}

/*****************************************************************************

Routine Description:

   Captures a user mode HTTP request and morphs it into a form suitable for
   kernel-mode.
   
   NOTE: This is a IN_DIRECT IOCTL.

Arguments:

   pHttpRequest      - The HTTP request.
   pIrp              - The IRP.
   ppInternalRequest - A pointer to the parsed request that is suitable for 
                       k-mode.


Return Value

*****************************************************************************/
NTSTATUS
UcCaptureEntityBody(
    PHTTP_SEND_REQUEST_ENTITY_BODY_INFO   pSendInfo,
    PIRP                                  Irp,
    PUC_HTTP_REQUEST                      pRequest,
    PUC_HTTP_SEND_ENTITY_BODY            *ppKeEntity,
    BOOLEAN                               bLast
    )
{
    ULONGLONG                    IndicatedLength, DataLength, UncopiedLength;
    PUC_HTTP_SEND_ENTITY_BODY    pKeEntity = NULL;
    NTSTATUS                     Status = STATUS_SUCCESS;
    PSTR                         pBuffer;
    KIRQL                        OldIrql;
    PMDL                         *pMdlLink;
    PMDL                         pHeadMdl;
    ULONG                        BytesWritten;

    USHORT                       EntityChunkCount;
    PHTTP_DATA_CHUNK             pEntityChunks;
    PHTTP_DATA_CHUNK             pLocalEntityChunks = NULL;
    HTTP_DATA_CHUNK              LocalEntityChunks[UL_LOCAL_CHUNKS];

    //
    // Sanity Check
    //

    PAGED_CODE();

    __try {


        EntityChunkCount   = pSendInfo->EntityChunkCount;
        pEntityChunks      = pSendInfo->pHttpEntityChunk;

        if(EntityChunkCount != 0)
        {
            UcpProbeAndCopyEntityChunks(
                pRequest->AppRequestorMode,
                pEntityChunks,
                EntityChunkCount,
                LocalEntityChunks,
                &pLocalEntityChunks
                );
        }
    

        UcpComputeEntityBodyLength(
                    EntityChunkCount,
                    pLocalEntityChunks,
                    pRequest->RequestFlags.RequestBuffered?1:0,
                    pRequest->RequestFlags.RequestChunked?1:0,
                    &UncopiedLength,
                    &DataLength
                    );


        IndicatedLength = DataLength + UncopiedLength;

        if(pRequest->RequestFlags.ContentLengthSpecified)
        {
            if(IndicatedLength > pRequest->RequestContentLengthRemaining)
            {
                //
                // app is trying to be smart here by posting more than it
                // indicated. Let's fail this IRP.
                //

                ExRaiseStatus(STATUS_INVALID_PARAMETER);
            }

            pRequest->RequestContentLengthRemaining -= IndicatedLength;

            //
            // If this is the last request, we have to make sure that the app
            // has posted all of the indicated data.
            //

            if(!(pSendInfo->Flags & HTTP_SEND_REQUEST_FLAG_MORE_DATA))
            {
                if(pRequest->RequestContentLengthRemaining)
                {
                    ExRaiseStatus(STATUS_INVALID_PARAMETER);
                }
            }

        }
        else
        {
            //
            // If we are using chunked encoding, we'll need buffer space to 
            // hold the chunk length. The chunk length is already computed
            // in UcpBuildEntityMdls, we just need to account for the last
            // one.
            //
    
            if(
                (pRequest->RequestFlags.RequestChunked) &&
                (!(pSendInfo->Flags & HTTP_SEND_REQUEST_FLAG_MORE_DATA))
              )
            {
                // space for the last chunk. 0 <CRLF>

                DataLength += LAST_CHUNK_SIZE + CRLF_SIZE;
            }
        }

        DataLength += sizeof(UC_HTTP_SEND_ENTITY_BODY);

        if (DataLength == (SIZE_T)DataLength)
        {
            pKeEntity = (PUC_HTTP_SEND_ENTITY_BODY)
                        UL_ALLOCATE_POOL_WITH_QUOTA(
                            NonPagedPool, 
                            (SIZE_T)DataLength,
                            UC_ENTITY_POOL_TAG,
                            pRequest->pServerInfo->pProcess
                            );
        }

        if(!pKeEntity)
        {
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        }
        
        //
        // Initialize.
        //
    
        pKeEntity->BytesAllocated      = (SIZE_T)DataLength;
        pKeEntity->pIrp                = Irp;
        pKeEntity->pRequest            = pRequest;
        pKeEntity->pMdlHead            = NULL;
        pKeEntity->pMdlLink            = &pKeEntity->pMdlHead;
        pKeEntity->BytesBuffered       = 0;
        pKeEntity->CancelSet           = FALSE;
        pKeEntity->Last                = (BOOLEAN)
            (!(pSendInfo->Flags & HTTP_SEND_REQUEST_FLAG_MORE_DATA));
        pKeEntity->Signature           = UC_ENTITY_SIGNATURE;

        pKeEntity->AppRequestorMode    = Irp->RequestorMode;
        pKeEntity->AppMdl              = Irp->MdlAddress;

        pBuffer = (PSTR) (pKeEntity + 1);

        if(pRequest->RequestFlags.RequestBuffered)
        {
            // 
            // If we are buffering the request, we will build the MDL chain
            // of a stack variable. After building the entire MDL chain, 
            // we'll acquire the connection spin lock, make sure that the 
            // request is still valid & then queue it at the tail of the
            // request's MDL chain. 
            //
            // We have to do this to protect from the Request-IRP cancellation
            // routine or the CancelRequest API, since we clean the MDL chain 
            // from these places.
            //

            // We need a try block, because if we raise an exception, we have
            // to clean-up our stack MDL chain.

            pHeadMdl  = NULL;
            pMdlLink  = &pHeadMdl;
    
            __try
            {
                //
                // Process the entity bodies and build MDLs as you go.  
                // 

                Status = UcpBuildEntityMdls(
                            EntityChunkCount,
                            pLocalEntityChunks,
                            TRUE,
                            pRequest->RequestFlags.RequestChunked ? 1:0,
                            bLast,
                            pBuffer,
                            &pMdlLink,
                            &pRequest->BytesBuffered
                           );

            } __except( UL_EXCEPTION_FILTER())
            {
                UcFreeSendMdls(pHeadMdl);

                Status = GetExceptionCode();
            }

            if(!NT_SUCCESS(Status))
            {
                ExRaiseStatus(Status);
            }

            UlAcquireSpinLock(&pRequest->pConnection->SpinLock, &OldIrql);

            if(pRequest->RequestState != UcRequestStateDone && 
               !pRequest->RequestFlags.Cancelled)
            {
                *pRequest->pMdlLink = pHeadMdl;
                pRequest->pMdlLink  = pMdlLink;
                UlReleaseSpinLock(&pRequest->pConnection->SpinLock, OldIrql);
            }
            else
            {
                UlReleaseSpinLock(&pRequest->pConnection->SpinLock, OldIrql);

                // Free the MDL chain.
                UcFreeSendMdls(pHeadMdl);

                ExRaiseStatus(STATUS_CANCELLED);
            }

            if(!(pSendInfo->Flags & HTTP_SEND_REQUEST_FLAG_MORE_DATA))
            {
                if(!pRequest->RequestFlags.ContentLengthSpecified)  
                {
                    //
                    // we have seen the last data, let's compute the content 
                    // length
                    // 

                    Status = UcGenerateContentLength(pRequest->BytesBuffered,
                                                     pRequest->pHeaders
                                                     + pRequest->HeaderLength,
                                                     pRequest->MaxHeaderLength
                                                     - pRequest->HeaderLength,
                                                     &BytesWritten);

                    ASSERT(Status == STATUS_SUCCESS);

                    pRequest->HeaderLength += BytesWritten;

                    UcSetFlag(&pRequest->RequestFlags.Value,
                              UcMakeRequestContentLengthLastFlag()); 
                }
    
                //
                // Terminate the headers with a CRLF
                //
                ((UNALIGNED64 USHORT *)(pRequest->pHeaders + 
                           pRequest->HeaderLength))[0] = CRLF;
                pRequest->HeaderLength += CRLF_SIZE;

                UcAllocateAndChainHeaderMdl(pRequest);
            }
        }
        else
        {
            Status = UcpBuildEntityMdls(
                        EntityChunkCount,
                        pLocalEntityChunks,
                        pRequest->RequestFlags.RequestBuffered ? 1:0,
                        pRequest->RequestFlags.RequestChunked ? 1:0,
                        bLast,
                        pBuffer,
                        &pKeEntity->pMdlLink,
                        &pKeEntity->BytesBuffered
                      );

            if(!NT_SUCCESS(Status))
            {
                ExRaiseStatus(Status);
            }
        }
        
    } __except( UL_EXCEPTION_FILTER())
    {
        Status = GetExceptionCode();
    }

    if(pLocalEntityChunks && pLocalEntityChunks != LocalEntityChunks)
    {
        UL_FREE_POOL(pLocalEntityChunks, UL_DATA_CHUNK_POOL_TAG);
    }

    *ppKeEntity = pKeEntity;

    return Status;
}

/*****************************************************************************

Routine Description:

   Builds a chain of MDLs from the buffers passed by the application.

Arguments:

   ChunkCount        - No of data chunks
   pHttpEntityBody   - A pointer to the first chunk
   bContentSpecified - A boolean indicating if content length was specified
   bBuffered         - A boolean indicating if we are buffering
   bChunked          - A boolean indicating if we are using chunked or unchunked
   bLastEntity       - A boolean indicating if we have seen all data.
   pBuffer           - A pointer to the buffer for writing out data.
   pMdlLink          - This points to the "last" MDL in the chain.
                       Used to quickly chain MDLs together.
   BytesBuffered     - The # of bytes that got written out.

Return Value
    STATUS_SUCCESS

*****************************************************************************/
NTSTATUS
UcpBuildEntityMdls(
    USHORT           ChunkCount,
    PHTTP_DATA_CHUNK pHttpEntityBody,
    BOOLEAN          bBuffered,
    BOOLEAN          bChunked,
    BOOLEAN          bLastEntity,
    PSTR             pBuffer,
    PMDL             **pMdlLink,
    PULONG           BytesBuffered
    )
{
    USHORT    i;
    ULONG     MdlLength;
    PMDL      pMdl = 0;
    PSTR      pMdlBuffer;

    ASSERT(*(*pMdlLink) == 0);

    for(i=0; i<ChunkCount; i++)
    {
        //
        // If the caller wants us to copy the data (or if its relatively 
        // small), then do it We allocate space for all of the copied data 
        // and any filename buffers. Otherwise (it's OK to just lock
        // down the data), then allocate a MDL describing the
        // user's buffer and lock it down. Note that
        // MmProbeAndLockPages() and MmLockPagesSpecifyCache()
        // will raise exceptions if they fail.
        //

        pMdlBuffer = pBuffer;

        if(
           (pHttpEntityBody[i].FromMemory.BufferLength <= 
            UC_REQUEST_COPY_THRESHOLD) ||
           (bBuffered)
        )
        {
            // Yes, we are going to copy the data.
        
            if(bChunked)
            {
                //
                // We are using chunked encoding, we need to indicate the 
                // chunk length. Since we are copying the user's data into
                // our own buffer, we'll just append the users buffer 
                // after the chunk length.
                //

                // Write the Chunk Length, this needs to be written in Hex.

                pBuffer = UlUlongToHexString(
                                   pHttpEntityBody[i].FromMemory.BufferLength,
                                   pBuffer 
                                   );

                // Terminate with a CRLF.

                *((UNALIGNED64 USHORT *)(pBuffer)) = CRLF;
                pBuffer += (CRLF_SIZE);


                // Now make a copy of the data 

                RtlCopyMemory(
                         pBuffer,
                         pHttpEntityBody[i].FromMemory.pBuffer,
                         pHttpEntityBody[i].FromMemory.BufferLength
                        );
            
                pBuffer += pHttpEntityBody[i].FromMemory.BufferLength;

                // Now, end the data chunk with a CRLF.

                *((UNALIGNED64 USHORT *)(pBuffer)) = CRLF;
                pBuffer += CRLF_SIZE;
    
                MdlLength = DIFF(pBuffer - pMdlBuffer);
            }
            else 
            {
                RtlCopyMemory(
                         pBuffer,
                         pHttpEntityBody[i].FromMemory.pBuffer,
                         pHttpEntityBody[i].FromMemory.BufferLength);

                pBuffer += pHttpEntityBody[i].FromMemory.BufferLength;

                MdlLength = pHttpEntityBody[i].FromMemory.BufferLength;
            }

            UcpAllocateAndChainEntityMdl(
                pMdlBuffer,
                MdlLength,
                pMdlLink,
                BytesBuffered
                );

        }
        else 
        {
            //
            // We are going to probe lock the data. 
            //

            if(bChunked)
            {
                //
                // UC_BUGBUG (PERF)
                //
                // If it's chunked encoding, we have to build two MDLs -
                // One for the chunk size & another one for the trailing CRLF. 
                // This is bad, because  this results in 2 calls to 
                // UlAllocateMdl. We can keep some of these small MDLs around
                // for perf.
                //

                pBuffer = UlUlongToHexString(
                                pHttpEntityBody[i].FromMemory.BufferLength,
                                pBuffer
                                );

                *((UNALIGNED64 USHORT *)(pBuffer)) = CRLF;
                pBuffer += CRLF_SIZE;

                MdlLength = DIFF(pBuffer - pMdlBuffer);

                UcpAllocateAndChainEntityMdl(
                    pMdlBuffer,
                    MdlLength,
                    pMdlLink,
                    BytesBuffered
                    );
            }

            //
            // Build an MDL describing the user's buffer.
            //

            pMdl =   UlAllocateMdl(
                                   pHttpEntityBody[i].FromMemory.pBuffer, 
                                   pHttpEntityBody[i].FromMemory.BufferLength, 
                                   FALSE,
                                   TRUE, // Charge Quota
                                   NULL
                                   );

            if(NULL == pMdl)
            {
                return(STATUS_INSUFFICIENT_RESOURCES );
            }

            //
            // Lock it down
            //
            MmProbeAndLockPages(
                                pMdl,
                                UserMode,
                                IoReadAccess
                                );
        
            //
            // Chain the MDL
            //
    
            *(*pMdlLink)  = pMdl; 
            *pMdlLink     = &pMdl->Next;

            *BytesBuffered += pHttpEntityBody[i].FromMemory.BufferLength;


            //
            // Now, end the chunk with a CRLF.
            //

            if(bChunked)
            {
                pMdlBuffer = pBuffer;

                (*(UNALIGNED64 USHORT *)pBuffer) = CRLF;
                pBuffer += CRLF_SIZE;

                UcpAllocateAndChainEntityMdl(
                    pMdlBuffer,
                    CRLF_SIZE,
                    pMdlLink,
                    BytesBuffered
                    );
            }
        }
    } 

    if(bLastEntity && bChunked)
    {
        // Build an MDL for the last chunk.
        // The last chunk begins with 0 <CRLF>. The chunk is ended with
        // another CRLF

        pMdlBuffer = pBuffer;

        (*(UNALIGNED64 ULONG *)pBuffer)  = LAST_CHUNK;
        pBuffer += LAST_CHUNK_SIZE;


        (*(UNALIGNED64 USHORT *)pBuffer) = CRLF;
        pBuffer += CRLF_SIZE;

        MdlLength = LAST_CHUNK_SIZE + CRLF_SIZE;

        UcpAllocateAndChainEntityMdl(
            pMdlBuffer,
            MdlLength,
            pMdlLink,
            BytesBuffered
            );
    }

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Cancel a pending request. This routine is called when we're canceling
    a request that's on the pending list, hasn't been sent and hasn't caused
    a connect request.

Arguments:

    pDeviceObject           - Pointer to device object.
    Irp                     - Pointer to IRP being canceled.

Return Value:



--***************************************************************************/
VOID
UcpCancelSendEntity(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    Irp
    )
{
    PUC_HTTP_SEND_ENTITY_BODY     pEntity;
    PUC_HTTP_REQUEST              pRequest;
    PUC_CLIENT_CONNECTION         pConnection;
    KIRQL                         OldIrql;

    UNREFERENCED_PARAMETER(pDeviceObject);

    // Release the cancel spin lock, since we're not using it.

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    // Retrieve the pointers we need. The request pointer is stored inthe
    // driver context array, and a back pointer to the connection is stored
    // in the request. Whoever set the cancel routine is responsible for
    // referencing the connection for us.

    pEntity = (PUC_HTTP_SEND_ENTITY_BODY) Irp->Tail.Overlay.DriverContext[0];

    pRequest = pEntity->pRequest;

    pConnection = pEntity->pRequest->pConnection;

    UC_WRITE_TRACE_LOG(
        g_pUcTraceLog,
        UC_ACTION_ENTITY_CANCELLED,
        pRequest,
        pEntity,
        Irp,
        STATUS_CANCELLED
        );

    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

    UcFreeSendMdls(pEntity->pMdlHead);

    pEntity->pMdlHead = NULL;

    RemoveEntryList(&pEntity->Linkage);

    UL_FREE_POOL_WITH_QUOTA(
        pEntity, 
        UC_ENTITY_POOL_TAG,
        NonPagedPool,
        pEntity->BytesAllocated,
        pRequest->pServerInfo->pProcess
        );

    UcFailRequest(pRequest, STATUS_CANCELLED, OldIrql);

    UC_DEREFERENCE_REQUEST(pRequest);

    Irp->IoStatus.Status = STATUS_CANCELLED;

    UlCompleteRequest(Irp, IO_NO_INCREMENT);
}
 
/***************************************************************************++

Routine Description:

    Initalize the request code.
    
Arguments:

    
Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcInitializeHttpRequests(
    VOID
    )
{
    //
    // First we allocate space for the per-process Server Information 
    // structure.
    //

    ExInitializeNPagedLookasideList(
        &g_ClientRequestLookaside,
        NULL,
        NULL,
        0,
        UC_REQUEST_LOOKASIDE_SIZE,
        UC_REQUEST_POOL_TAG,
        0
        );

    g_ClientRequestLookasideInitialized = TRUE;

    return STATUS_SUCCESS;
}


VOID
UcTerminateHttpRequests(
    VOID
    )
{
    if(g_ClientRequestLookasideInitialized)
    {
        ExDeleteNPagedLookasideList(&g_ClientRequestLookaside);
    }
}

/***************************************************************************++

Routine Description:

    Allcoates and chains the header MDL.

Arguments:

    pRequest - Internal http request.


Return Value:
    None


--***************************************************************************/
VOID
UcAllocateAndChainHeaderMdl(
    IN  PUC_HTTP_REQUEST pRequest
    )
{ 
    PMDL pMdl;
    pMdl =  UlAllocateMdl(
                      pRequest->pHeaders,     // VA
                      pRequest->HeaderLength, // Length
                      FALSE,                  // Secondary Buffer
                      TRUE,                   // Charge Quota
                      NULL                    // IRP
                      );

    if(!pMdl)
    {
        ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
    }
    else
    {
        MmBuildMdlForNonPagedPool(pMdl);
    }

    //
    // Chain the MDL
    //
        
    pMdl->Next               = pRequest->pMdlHead;
    pRequest->pMdlHead       = pMdl;

    pRequest->BytesBuffered +=  pRequest->HeaderLength;
}

/***************************************************************************++

Routine Description:

    Allcoates and chains the entity MDL.

Arguments:

    pMdlBuffer    - The buffer
    MdlLength     - Length of buffer
    pMdlLink      - Pointer for quick chaining.
    BytesBuffered - The number of bytes that got buffered.

Return Value:
    None

--***************************************************************************/
VOID
UcpAllocateAndChainEntityMdl(
    IN  PVOID  pMdlBuffer,
    IN  ULONG  MdlLength,
    IN  PMDL   **pMdlLink,
    IN  PULONG BytesBuffered
    )
{
    PMDL pMdl;

    //
    // Allocate a new MDL describing our new location
    // in the auxiliary buffer, then build the MDL
    // to properly describe non paged pool
    //

    pMdl = UlAllocateMdl(
              pMdlBuffer,  // VA
              MdlLength,   // Length
              FALSE,       // 2nd Buffer
              TRUE,        // Charge Quota
              NULL         // IRP
              );

    if(pMdl == NULL)
    {
        ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
    }

    MmBuildMdlForNonPagedPool(pMdl);

    //
    // Chain the MDL
    //

    *(*pMdlLink) = pMdl;
    *pMdlLink    = &pMdl->Next;
    
    *BytesBuffered += MdlLength;
}

/***************************************************************************++

Routine Description:

    Builds a HTTP request for sending the CONNECT VERB. There are a few things  
    that we need to do here.
    
    - Firstly, we need to send a "seperate" request that establishes the SSL
      tunnel. In order to do this, we create a UC_HTTP_REQUEST structure that
      is not associated with any IRP. We put this IRP at the head of the 
      pending list. This is done as soon as we establish a TCP connection. 
     
    - This request is special because it has to go  unfiltered - i.e without
      hitting the filter.
      
    - If we are doing ProxyAuth, then we should pass the ProxyAuth headers
      with the connect verb as well.
      
    - If this special request succeeds, we will change the state of the 
      TCP connection as "connected" and allow additional requests to go out.
      
    - If the special request fails, we will "propogate" the failure to the
      next request (there has to be at least one), and fail the remaining 
      pipelined requests. We'll also set the connection state to IDLE so 
      that the next request will re-start this procedure. It might be easier
      to just disconnect the TCP connection (then we can always consolidate
      this code in the ConnectComplete handler). 

Arguments:

    pContext           - Pointer to the UL_CONNECTION
    pKernelBuffer      - Pointer to kernel buffer
    pUserBuffer        - Pointer to user buffer
    OutputBufferLength - Length of output buffer
    pBuffer            - Buffer for holding any data
    InitialLength      - Size of input data.

--***************************************************************************/
PUC_HTTP_REQUEST
UcBuildConnectVerbRequest(
     IN PUC_CLIENT_CONNECTION pConnection,
     IN PUC_HTTP_REQUEST      pHeadRequest
     )
{
    ULONG                          Size;
    ULONG                          HeaderLength;
    ULONG                          AlignHeaderLength;
    PUC_PROCESS_SERVER_INFORMATION pServInfo;
    PUC_HTTP_REQUEST               pRequest;
    PUCHAR                         pBuffer;

    pServInfo = pHeadRequest->pServerInfo;

    //
    // If we are doing SSL through a proxy, we need to establish a tunnel
    // For this, we'll create a request structure & will send it on the
    // connection before anything else.
    //

    HeaderLength = UcComputeConnectVerbHeaderSize(
                        pServInfo, 
                        pHeadRequest->pProxyAuthInfo
                        );

    AlignHeaderLength =  ALIGN_UP(HeaderLength, PVOID);


    Size = AlignHeaderLength             +
           sizeof(UC_HTTP_REQUEST)       +
           sizeof(HTTP_RESPONSE)         + 
           UC_RESPONSE_EXTRA_BUFFER;

    if(Size <= UC_REQUEST_LOOKASIDE_SIZE)
    {
        //
        // Yes, we can service this request from the lookaside.
        //
        
        pRequest = (PUC_HTTP_REQUEST)
                        ExAllocateFromNPagedLookasideList(
                            &g_ClientRequestLookaside
                            );
        
        if(!pRequest)
        {
            return NULL;
        }
    }
    else
    {
        pRequest  =  (PUC_HTTP_REQUEST) UL_ALLOCATE_POOL_WITH_QUOTA(
                                             NonPagedPool,
                                             Size,
                                             UC_REQUEST_POOL_TAG,
                                             pServInfo->pProcess
                                             );
        if(!pRequest)
        {
            return NULL;
        }
    }
    
    //
    // Initialize.
    //

    UcpRequestInitialize(
        pRequest,
        Size,
        0,
        NULL,
        NULL,
        pConnection,
        NULL,
        NULL,
        pServInfo
        );

    //
    // UcpRequestInitialize takes a ref for the IRP. For the connect verb
    // request, we don't need this.
    //
    UC_DEREFERENCE_REQUEST(pRequest);

    // No need to call UcSetFlag for these.

    pRequest->RequestFlags.Value                   = 0; 
    pRequest->RequestFlags.NoResponseEntityBodies  = TRUE;
    pRequest->RequestFlags.LastEntitySeen          = TRUE;
    pRequest->RequestFlags.ProxySslConnect         = TRUE;

    pRequest->MaxHeaderLength = AlignHeaderLength;
    pRequest->HeaderLength  = HeaderLength;
    pRequest->pHeaders      = (PUCHAR)(pRequest + 1);

    pBuffer = (PUCHAR) pRequest->pHeaders + AlignHeaderLength;

    pRequest->pInternalResponse = (PHTTP_RESPONSE) pBuffer;

    UcpRequestCommonInitialize(
            pRequest,
            sizeof(HTTP_RESPONSE) + UC_RESPONSE_EXTRA_BUFFER,
            pBuffer
            );

    //
    // Build the headers.
    //

    UcGenerateConnectVerbHeader(pRequest,
                                pHeadRequest,
                                pHeadRequest->pProxyAuthInfo
                                );

    pRequest->RequestConnectionClose = FALSE;

    UcAllocateAndChainHeaderMdl(pRequest);

    return pRequest;
}

/***************************************************************************++

Routine Description:

    Fails a request, closes the connection if required.

Arguments:

    pRequest - Pointer to UC_HTTP_REQUEST
    Status   - Failure status.

--***************************************************************************/
VOID
UcFailRequest(
    IN PUC_HTTP_REQUEST pRequest,
    IN NTSTATUS         Status,
    IN KIRQL            OldIrql
    )
{
    PUC_CLIENT_CONNECTION pConnection;
    
    pConnection = pRequest->pConnection;

    ASSERT( UC_IS_VALID_CLIENT_CONNECTION(pConnection) );

    ASSERT( UlDbgSpinLockOwned(&pConnection->SpinLock) );

    UC_WRITE_TRACE_LOG(
        g_pUcTraceLog,
        UC_ACTION_REQUEST_FAILED,
        pConnection,
        pRequest,
        pRequest->RequestIRP,
        UlongToPtr(pRequest->RequestState)
        );

    //
    // See if we have to close the connection. We have to do this if the
    // request has hit the wire. There is no point in doing this if 
    // the request has already failed (as it's supposed to be done by
    // the code that was responsible for failing the request).
    //

    switch(pRequest->RequestState)
    {
        case UcRequestStateCaptured:
        case UcRequestStateResponseParsed:

            pRequest->RequestState = UcRequestStateDone;

            UcCompleteParsedRequest(
                    pRequest,
                    Status,
                    TRUE,
                    OldIrql
                    );

            break;

        case UcRequestStateSent:
        case UcRequestStateNoSendCompletePartialData:
        case UcRequestStateNoSendCompleteFullData:
        case UcRequestStateSendCompleteNoData:
        case UcRequestStateSendCompletePartialData:

            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

            UC_CLOSE_CONNECTION(pConnection, TRUE, Status);

            break;

        default:
            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
            break;

    }
}

/***************************************************************************++

Routine Description:

    This routine is called when a request is to be reissued (only 
    authenticated requests are reissued by the driver.)

Arguments:

    pWorkItem - Work item that was used to schedule the current (worker)
                thread

Return Value:

    None.

--***************************************************************************/
VOID
UcReIssueRequestWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUC_HTTP_REQUEST      pRequest;
    PUC_CLIENT_CONNECTION pConnection;
    NTSTATUS              Status;
    KIRQL                 OldIrql;
    PLIST_ENTRY           pList;
    PUCHAR                pBuffer;
    PIO_STACK_LOCATION    pIrpSp;
    PIRP                  Irp;
    BOOLEAN               bCancelRoutineCalled;
    ULONG                 OutLength;

    PAGED_CODE();

    pRequest = CONTAINING_RECORD(
                        pWorkItem,
                        UC_HTTP_REQUEST,
                        WorkItem
                        );

    ASSERT(UC_IS_VALID_HTTP_REQUEST(pRequest));

    ASSERT(pRequest->ResponseStatusCode == 401 || 
           pRequest->ResponseStatusCode == 407
          );

    pIrpSp      = pRequest->RequestIRPSp;
    Irp         = pRequest->RequestIRP;
    pConnection = pRequest->pConnection;

    //
    // Adjust the Authorization header.
    //

    __try
    {

        if(pRequest->ResponseStatusCode == 401)
        {
            Status = UcUpdateAuthorizationHeader(
                        pRequest,
                        (PUC_HTTP_AUTH)pRequest->pAuthInfo,
                        &pRequest->DontFreeMdls
                        );
        }   
        else 
        {
            Status = UcUpdateAuthorizationHeader(
                        pRequest,
                        (PUC_HTTP_AUTH)pRequest->pProxyAuthInfo,
                        &pRequest->DontFreeMdls
                        );
        }
    } __except( UL_EXCEPTION_FILTER())
    {
        Status = GetExceptionCode();
    }
    
    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

    if(!NT_SUCCESS(Status) ||
       pConnection->ConnectionState != UcConnectStateConnectReady ||
       Irp == NULL)
    {

        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

        UC_DEREFERENCE_REQUEST(pRequest);

        if(NT_SUCCESS(Status))
        {
            if(Irp == NULL)
                Status = STATUS_CANCELLED;
            else 
                Status = STATUS_CONNECTION_ABORTED;
        }

        UC_CLOSE_CONNECTION(pConnection, TRUE, Status);

        return;
    }

    //
    // Clean up any allocated buffers
    //

    while(!IsListEmpty(&pRequest->pBufferList))
    {
        PUC_RESPONSE_BUFFER pResponseBuffer;

        pList = RemoveHeadList(&pRequest->pBufferList);

        pResponseBuffer = CONTAINING_RECORD(pList,
                                            UC_RESPONSE_BUFFER,
                                            Linkage);

        ASSERT(IS_VALID_UC_RESPONSE_BUFFER(pResponseBuffer));

        UL_FREE_POOL_WITH_QUOTA(
                    pResponseBuffer, 
                    UC_RESPONSE_APP_BUFFER_POOL_TAG,
                    NonPagedPool,
                    pResponseBuffer->BytesAllocated,
                    pRequest->pServerInfo->pProcess
                    );

        UC_DEREFERENCE_REQUEST(pRequest);
    }

    // 
    // Re-initialize the request.
    //

    OutLength = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if(OutLength == 0)
    {
        pBuffer = NULL;
    }
    else
    {
        ASSERT(OutLength >= sizeof(HTTP_RESPONSE));

        pBuffer = (PUCHAR) MmGetSystemAddressForMdlSafe(
                                pRequest->AppMdl,
                                NormalPagePriority);

        if(!pBuffer)
        {
            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

            UC_CLOSE_CONNECTION(pConnection, 
                                TRUE, 
                                STATUS_INSUFFICIENT_RESOURCES);

            UC_DEREFERENCE_REQUEST(pRequest);
            return;
        }
    }

    UcpRequestCommonInitialize(
        pRequest, 
        OutLength,
        pBuffer
        );

    ASSERT(!IsListEmpty(&pConnection->SentRequestList));

    RemoveEntryList(&pRequest->Linkage);

    ASSERT(IsListEmpty(&pConnection->SentRequestList));

    //
    // Remove the IRP cancel routine that we set.
    //

    bCancelRoutineCalled = UcRemoveRequestCancelRoutine(pRequest);

    if(bCancelRoutineCalled)
    {
        //
        // This IRP has already got cancelled, let's move on. 
        //

        //
        // NOTE: The request is not there on any list, but since it's state
        // is "captured". So, it will get cleaned up in UcFailRequest, which
        // will be called from the cancel routine.
        //

        ASSERT(pRequest->RequestState == UcRequestStateCaptured);

        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

        // We have to close the connection here as the request was cancelled
        // in the middle of a handshake.

        UC_CLOSE_CONNECTION(pConnection, TRUE, STATUS_CANCELLED);

        UC_DEREFERENCE_REQUEST(pRequest);

        return;
    }

    InsertHeadList(&pConnection->PendingRequestList, &pRequest->Linkage);

    if(!(pConnection->Flags & CLIENT_CONN_FLAG_SEND_BUSY))
    {
        UcIssueRequests(pConnection, OldIrql);
    }
    else
    {
        // Somebody else is sending, they will pick it up.

        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
    }

    UC_DEREFERENCE_REQUEST(pRequest);
}

/***************************************************************************++

Routine Description:

    This routine is called to update the pre-auth cache 

Arguments:

    pWorkItem - Work item that was used to schedule the current (worker)
                thread

Return Value:

    None.

--***************************************************************************/
VOID
UcpPreAuthWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUC_HTTP_REQUEST      pRequest;
    NTSTATUS              Status;
    PUC_HTTP_AUTH         pAuth;
    KIRQL                 OldIrql;

    PAGED_CODE();

    pRequest = CONTAINING_RECORD(
                        pWorkItem,
                        UC_HTTP_REQUEST,
                        WorkItem
                        );

    ASSERT(UC_IS_VALID_HTTP_REQUEST(pRequest));

    //
    // See if we have to update the auth cache.
    //

    if(UcpCheckForPreAuth(pRequest))
    {
        //
        // The user passed credentials and we got back
        // a successful response. We can add this entry to
        // the pre-auth cache.
        //

        pAuth = (PUC_HTTP_AUTH) pRequest->pAuthInfo;

        if(pAuth->Credentials.AuthType == HttpAuthTypeDigest)
        {
            if(pAuth->ParamValue[HttpAuthDigestDomain].Length)
            {
                Status = UcAddURIEntry(
                            pAuth->Credentials.AuthType,
                            pRequest->pServerInfo,
                            pRequest->pUri,
                            pRequest->UriLength,
                            pAuth->ParamValue[HttpAuthDigestRealm].Value,
                            pAuth->ParamValue[HttpAuthDigestRealm].Length,
                            pAuth->ParamValue[HttpAuthDigestDomain].Value,
                            pAuth->ParamValue[HttpAuthDigestDomain].Length,
                            pRequest->pAuthInfo
                           );
            }
            else
            {
                //
                // If no domain is specified, then the
                // protection space is all URIs on the
                // server.
                //
                CHAR pDomain[] = "/";

                Status = UcAddURIEntry(
                             HttpAuthTypeDigest,
                             pRequest->pServerInfo,
                             pRequest->pUri,
                             pRequest->UriLength,
                             pAuth->ParamValue[HttpAuthDigestRealm].Value,
                             pAuth->ParamValue[HttpAuthDigestRealm].Length,
                             pDomain,
                             2,
                             pRequest->pAuthInfo
                            );
            }
        }
        else
        {
            ASSERT(pAuth->Credentials.AuthType == HttpAuthTypeBasic);

            Status = UcAddURIEntry(
                        pAuth->Credentials.AuthType,
                        pRequest->pServerInfo,
                        pRequest->pUri,
                        pRequest->UriLength,
                        NULL,
                        0,
                        0,
                        0,
                        pRequest->pAuthInfo
                       );
        }

        if(NT_SUCCESS(Status))
        {
            // The auth blob got used properly and now
            // belongs to the auth cache. NULL it here so
            // that we don't free it

            pRequest->pAuthInfo = 0;
        }
    }

    //
    // See if we have to update the proxy auth cache.
    //

    if(UcpCheckForProxyPreAuth(pRequest))
    {
        ASSERT(pRequest->pProxyAuthInfo->AuthInternalLength);

        UlAcquirePushLockExclusive(&pRequest->pServerInfo->PushLock);

        if(pRequest->pServerInfo->pProxyAuthInfo)
        {
            UcDestroyInternalAuth(pRequest->pServerInfo->pProxyAuthInfo,
                                  pRequest->pServerInfo->pProcess);
        }

        pRequest->pServerInfo->pProxyAuthInfo =
                (PUC_HTTP_AUTH) pRequest->pProxyAuthInfo;

        pRequest->pProxyAuthInfo = 0;

        UlReleasePushLock(&pRequest->pServerInfo->PushLock);
    }

    //  
    // In UcCompleteParsedRequest, we make a check for pre-auth or proxy
    // pre-auth. If the request has credentials that can land up in
    // one of these, we call this worker thread & pend UcCompleteParsedRequest.
    //
    // Now, we will pick up the pended UcCompleteParsedRequest. 
    // 
    // In order to avoid infinite recursion, we'll make sure that the 
    // pre-auth & proxy-preauth credentials aren't present. i.e if we have been
    // called in this routine & we haven't moved the pre-auth entries to our
    // cache, we'll just destroy it.
    //

    if(pRequest->pAuthInfo != NULL)
    {
        UcDestroyInternalAuth(pRequest->pAuthInfo,
                              pRequest->pServerInfo->pProcess);

        pRequest->pAuthInfo = NULL;
    }

    if(pRequest->pProxyAuthInfo != NULL)
    {
        UcDestroyInternalAuth(pRequest->pProxyAuthInfo,
                              pRequest->pServerInfo->pProcess);

        pRequest->pProxyAuthInfo = NULL;
    }


    UlAcquireSpinLock(&pRequest->pConnection->SpinLock, &OldIrql);

    UcCompleteParsedRequest(
        pRequest,
        STATUS_SUCCESS,
        TRUE,
        OldIrql
        );

    UC_DEREFERENCE_REQUEST(pRequest);
}



/***************************************************************************++

Routine Description:

    Routine tests if this request has credentials that should land up in 
    a pre-auth cache.

Arguments:
    
    pRequest - Input HTTP request.

Return Value:

    None.

--***************************************************************************/
__inline
BOOLEAN
UcpCheckForPreAuth(
    IN PUC_HTTP_REQUEST pRequest
    )
{
    if((pRequest->pServerInfo->PreAuthEnable &&
       pRequest->pAuthInfo &&
       (pRequest->pAuthInfo->Credentials.AuthType == HttpAuthTypeBasic ||
        pRequest->pAuthInfo->Credentials.AuthType == HttpAuthTypeDigest) &&
       pRequest->ResponseStatusCode == 200) 
        )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/***************************************************************************++

Routine Description:

    Routine tests if this request has credentials that should land up in 
    a proxy pre-auth cache.

Arguments:
    
    pRequest - Input HTTP request.

Return Value:

    None.

--***************************************************************************/
__inline
BOOLEAN
UcpCheckForProxyPreAuth(
    IN PUC_HTTP_REQUEST pRequest
    )
{

    if(pRequest->pServerInfo->ProxyPreAuthEnable &&
       pRequest->pProxyAuthInfo &&
       (pRequest->pProxyAuthInfo->Credentials.AuthType == HttpAuthTypeBasic ||
        pRequest->pProxyAuthInfo->Credentials.AuthType == HttpAuthTypeDigest))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\sendrequest.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    sendrequest.h

Abstract:

    This module contains declarations for manipulating HTTP requests.

Author:

    Rajesh Sundaram (rajeshsu)

Revision History:


--*/


#ifndef _SENDREQUEST_H_
#define _SENDREQUEST_H_


//
// Size of the lookaside for the send-request structure.
//
#define UC_REQUEST_LOOKASIDE_SIZE (sizeof(UC_HTTP_REQUEST)+1024)

//
// It takes 2 cycles per byte to RtlCopyMemory. It takes 1024 cycles to 
// ProbeLock and 1024 cycles to ProbeUnLock. So, as a rule, it is always 
// cheaper to copy if the BufferSize is < 2048. 
//

#define UC_REQUEST_COPY_THRESHOLD (PAGE_SIZE/2)
#define UC_REQUEST_HEADER_CHUNK_COUNT 1

//
// We allow the user to specify the chunk using a ULONG. So, the maximum chunk
// size is FFFFFFFF <CRLF>. We add another CRLF for terminating the data.
//
#define UC_MAX_CHUNK_SIZE (10 + 2 * CRLF_SIZE)

#define MULTIPART_SEPARATOR_SIZE 80

//
// Forwarders.
//

typedef struct _UC_HTTP_REQUEST *PUC_HTTP_REQUEST;
typedef struct _UC_PROCESS_SERVER_INFORMATION *PUC_PROCESS_SERVER_INFORMATION;
typedef struct _UC_CLIENT_CONNECTION *PUC_CLIENT_CONNECTION;

//
// This structure is used to store a parsed HTTP response. 
// 
#define UC_RESPONSE_EXTRA_BUFFER 1024
#define UC_INSUFFICIENT_INDICATION_EXTRA_BUFFER 1024

typedef struct _UC_RESPONSE_BUFFER
{
    ULONG                       Signature;
    LIST_ENTRY                  Linkage;
    ULONG                       Flags;
    ULONG                       BytesWritten;
    ULONG                       BytesAllocated;
    HTTP_RESPONSE               HttpResponse;
} UC_RESPONSE_BUFFER, *PUC_RESPONSE_BUFFER;


#define UC_RESPONSE_BUFFER_SIGNATURE MAKE_SIGNATURE('UcRB')

#define IS_VALID_UC_RESPONSE_BUFFER(pBuffer) \
    HAS_VALID_SIGNATURE(pBuffer, UC_RESPONSE_BUFFER_SIGNATURE)


//
// Flags definition for UC_RESPONSE_BUFFER.Flags
//
#define UC_RESPONSE_BUFFER_FLAG_READY         0x00000001
#define UC_RESPONSE_BUFFER_FLAG_NOT_MERGEABLE 0x00000002


typedef enum _UC_RESPONSE_PARSER
{
    UcParseStatusLineVersion,
    UcParseStatusLineStatusCode,
    UcParseStatusLineReasonPhrase,
    UcParseHeaders,
    UcParseEntityBody,
    UcParseTrailers,
    UcParseEntityBodyMultipartInit,
    UcParseEntityBodyMultipartHeaders,
    UcParseEntityBodyMultipartFinal,
    UcParseError,
    UcParseDone
} UC_RESPONSE_PARSER_STATE, *PUC_RESPONSE_PARSER_STATE;

typedef enum _UC_REQUEST_STATE
{
    UcRequestStateCaptured,                   // has been captured

    UcRequestStateSent,                       // captured & sent.

    UcRequestStateSendCompleteNoData,         // send has completed, but 
                                              // haven't seen any response

    UcRequestStateSendCompletePartialData,    // send has completed & we have
                                              // seen some response, but not all
                                              // of it.
    
    UcRequestStateNoSendCompletePartialData,  // no send complete & we have seen
                                              // a portion of the response.

    UcRequestStateNoSendCompleteFullData,     // no send complete & we have 
                                              // seen all response.

    UcRequestStateResponseParsed,             // fully parsed, send completed,
                                              // app has to post additional
                                              // receive buffers.

    UcRequestStateDone                        // app has seen all data.
} UC_REQUEST_STATE, *PUC_REQUEST_STATE;


//
// Did we receive any response for this request?
//
#define UC_IS_RESPONSE_RECEIVED(pRequest)                               \
(pRequest->RequestState == UcRequestStateSendCompletePartialData   ||   \
 pRequest->RequestState == UcRequestStateNoSendCompletePartialData ||   \
 pRequest->RequestState == UcRequestStateNoSendCompleteFullData    ||   \
 pRequest->RequestState == UcRequestStateResponseParsed)


typedef union _UC_REQUEST_FLAGS
{
    //
    // This field overlays all of the settable flags. This allows us to
    // update all flags in a thread-safe manner using the
    // UlInterlockedCompareExchange() API.
    //

    LONG Value;

    struct
    {
        ULONG CleanPended:1;               // 00000001
        ULONG RequestChunked:1;            // 00000002
        ULONG LastEntitySeen:1;            // 00000004
        ULONG ContentLengthSpecified:1;    // 00000008
        ULONG ReceiveBufferSpecified:1;    // 00000010
        ULONG RequestBuffered:1;           // 00000020
        ULONG CompleteIrpEarly:1;          // 00000040
        ULONG ContentLengthLast:1;         // 00000080
        ULONG PipeliningAllowed:1;         // 00000100
        ULONG CancelSet:1;                 // 00000200
        ULONG NoResponseEntityBodies:1;    // 00000400
        ULONG ProxySslConnect:1;           // 00000800
        ULONG Cancelled:1;                 // 00001000
        ULONG NoRequestEntityBodies:1;     // 00002000
        ULONG UsePreAuth:1;                // 00004000
        ULONG UseProxyPreAuth:1;           // 00008000
    };

} UC_REQUEST_FLAGS;

#define UC_MAKE_REQUEST_FLAG_ROUTINE(name)                                 \
    __inline LONG UcMakeRequest##name##Flag()                              \
    {                                                                      \
        UC_REQUEST_FLAGS flags = { 0 };                                    \
        flags.name = 1;                                                    \
        return flags.Value;                                                \
    }

UC_MAKE_REQUEST_FLAG_ROUTINE( RequestChunked );
UC_MAKE_REQUEST_FLAG_ROUTINE( LastEntitySeen );
UC_MAKE_REQUEST_FLAG_ROUTINE( ContentLengthSpecified );
UC_MAKE_REQUEST_FLAG_ROUTINE( ContentLengthLast );
UC_MAKE_REQUEST_FLAG_ROUTINE( CancelSet );
UC_MAKE_REQUEST_FLAG_ROUTINE( Cancelled );
UC_MAKE_REQUEST_FLAG_ROUTINE( CleanPended );


#define UC_REQUEST_RECEIVE_READY       (1L)
#define UC_REQUEST_RECEIVE_BUSY        (2L)
#define UC_REQUEST_RECEIVE_CANCELLED   (3L)


typedef struct _UC_HTTP_REQUEST
{
    ULONG                       Signature;
    LIST_ENTRY                  Linkage;

    LONG                        RefCount;
    ULONGLONG                   RequestContentLengthRemaining;
    NTSTATUS                    RequestStatus;
    UC_REQUEST_FLAGS            RequestFlags; 

    HTTP_REQUEST_ID             RequestId;
    UL_WORK_ITEM                WorkItem;

    //
    // We could be piggybacking on the applications IRP.
    // if this is the case, we need to restore some 
    // parameters.
    //
    KPROCESSOR_MODE             AppRequestorMode;
    
    UCHAR                       Pad[3];

    PMDL                        AppMdl;

    PIRP                        RequestIRP;
    PIO_STACK_LOCATION          RequestIRPSp;
    ULONG                       RequestIRPBytesWritten;
    PFILE_OBJECT                pFileObject;
    PUC_CLIENT_CONNECTION       pConnection;
    ULONG                       ConnectionIndex;



    //
    // All the MDL information.
    //
    PMDL   pMdlHead;
    PMDL  *pMdlLink;          // Pointer to the head of the MDL chain. 
                              // used to easily chain MDLs.
    ULONG  BytesBuffered;      // Total # of bytes buffered in 
                              // the MDL chains.

    //
    // For holding the parsed respose. 
    //
    UC_RESPONSE_PARSER_STATE  ParseState;
    UC_REQUEST_STATE          RequestState;

    //
    // The following fields hold data pertaining to the current buffer that 
    // the parser has to write its response to. The current buffer could
    // either be the buffer passed by the application, or it could point to an 
    // internally allocated buffer. 
    //
    // All internally allocated buffers are stored in pBufferList. 
    //

    PHTTP_RESPONSE           pInternalResponse;

    struct {

        ULONG                BytesAllocated;
        ULONG                BytesAvailable;
        PUCHAR               pOutBufferHead;   // Pointer to the head of output 
                                               // buffer
        PUCHAR               pOutBufferTail;   // Pointer to the tail of 
                                               // output buffer
        PHTTP_RESPONSE       pResponse;        // pointer to the response 
                                               // structure of current buffer
        PUC_RESPONSE_BUFFER  pCurrentBuffer;   // A pointer to the current 
                                               // buffer.
    } CurrentBuffer;

    LIST_ENTRY     pBufferList;      // This holds a list of chained 
                                     // buffers.   

    LIST_ENTRY     ReceiveResponseIrpList;

    BOOLEAN        ResponseMultipartByteranges;
    BOOLEAN        ResponseConnectionClose;
    BOOLEAN        RequestConnectionClose;
    BOOLEAN        ResponseVersion11;
    BOOLEAN        ResponseEncodingChunked;
    BOOLEAN        ResponseContentLengthSpecified;
    BOOLEAN        DontFreeMdls;
    BOOLEAN        Renegotiate;

    ULONGLONG      ResponseContentLength;
    ULONG          ParsedFirstChunk;
    SIZE_T         RequestSize;


    LIST_ENTRY     PendingEntityList;
    LIST_ENTRY     SentEntityList;

    ULONG          MaxHeaderLength;
    ULONG          HeaderLength;
    PUCHAR         pHeaders;
    FAST_MUTEX     Mutex;

    PUC_HTTP_AUTH  pAuthInfo;
    PUC_HTTP_AUTH  pProxyAuthInfo;

    PCHAR          pMultipartStringSeparator;
    CHAR           MultipartStringSeparatorBuffer[MULTIPART_SEPARATOR_SIZE];
    ULONG          MultipartStringSeparatorLength;
    ULONG          MultipartRangeRemaining;

    ULONG          ResponseStatusCode;
    PUC_PROCESS_SERVER_INFORMATION pServerInfo;
    PSTR           pUri;
    USHORT         UriLength;

    LONG           ReceiveBusy;

} UC_HTTP_REQUEST, *PUC_HTTP_REQUEST;


//
// Http request can go out on any available connection.
//
#define HTTP_REQUEST_ON_CONNECTION_ANY    (~(0UL))


typedef struct _UC_HTTP_RECEIVE_RESPONSE
{
    LIST_ENTRY          Linkage;
    PIRP                pIrp;
    BOOLEAN             CancelSet;
    PUC_HTTP_REQUEST    pRequest;
    LIST_ENTRY          ResponseBufferList;

} UC_HTTP_RECEIVE_RESPONSE, *PUC_HTTP_RECEIVE_RESPONSE;

typedef struct _UC_HTTP_SEND_ENTITY_BODY
{
    ULONG            Signature;
    LIST_ENTRY       Linkage;
    PIRP             pIrp;
    BOOLEAN          CancelSet;
    BOOLEAN          Last;
    PUC_HTTP_REQUEST pRequest;
    PMDL             pMdlHead;
    PMDL            *pMdlLink;
    ULONG            BytesBuffered;
    KPROCESSOR_MODE  AppRequestorMode;
    UCHAR            Pad[3];
    PMDL             AppMdl;
    SIZE_T           BytesAllocated;
} UC_HTTP_SEND_ENTITY_BODY, *PUC_HTTP_SEND_ENTITY_BODY;

#define UC_REQUEST_SIGNATURE MAKE_SIGNATURE('HREQ')
#define UC_REQUEST_SIGNATURE_X MAKE_FREE_SIGNATURE(UC_REQUEST_SIGNATURE)

#define UC_ENTITY_SIGNATURE MAKE_SIGNATURE('HENT')
#define UC_ENTITY_SIGNATURE_X MAKE_FREE_SIGNATURE(UC_REQUEST_SIGNATURE)

#define UC_IS_VALID_HTTP_REQUEST(pRequest)                \
    HAS_VALID_SIGNATURE(pRequest, UC_REQUEST_SIGNATURE)

#define UC_REFERENCE_REQUEST(s)              \
            UcReferenceRequest(              \
            (s)                              \
            REFERENCE_DEBUG_ACTUAL_PARAMS    \
            )

#define UC_DEREFERENCE_REQUEST(s)            \
            UcDereferenceRequest(            \
            (s)                              \
            REFERENCE_DEBUG_ACTUAL_PARAMS    \
            )


NTSTATUS
UcCaptureHttpRequest(IN  PUC_PROCESS_SERVER_INFORMATION pServInfo,
                     IN  PHTTP_SEND_REQUEST_INPUT_INFO  pHttpRequest,
                     IN  PIRP                           Irp,
                     IN  PIO_STACK_LOCATION             IrpSp,
                     OUT PUC_HTTP_REQUEST              *ppInternalRequest,
                     IN  PULONG                         pBytesTaken);

VOID
UcpProbeAndCopyHttpRequest(
    IN PHTTP_REQUEST    pHttpRequest,
    IN PHTTP_REQUEST    pLocalHttpRequest,
    IN KPROCESSOR_MODE  RequestorMode
    );

VOID
UcpRetrieveContentLength(
    IN  PHTTP_REQUEST    pHttpRequest,
    OUT PBOOLEAN         pbContentLengthSpecified,
    OUT PULONGLONG       pContentLength
    );

VOID
UcpRequestInitialize(
    IN PUC_HTTP_REQUEST      pRequest,
    IN SIZE_T                RequestLength,
    IN ULONGLONG             RemainingContentLength,
    IN PUC_HTTP_AUTH         pAuth,
    IN PUC_HTTP_AUTH         pProxyAuth,
    IN PUC_CLIENT_CONNECTION pConnection,
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    pIrpSp,
    IN PUC_PROCESS_SERVER_INFORMATION   pServerInfo
    );

VOID
UcpRequestCommonInitialize(
    IN PUC_HTTP_REQUEST   pRequest,
    IN ULONG              OutLength,
    IN PUCHAR             pBuffer
    );

VOID
UcpFixAppBufferPointers(
    PUC_HTTP_REQUEST pRequest,
    PIRP pIrp
    );

VOID
UcpProbeConfigList(
    IN PHTTP_REQUEST_CONFIG           pRequestConfig,
    IN USHORT                         RequestConfigCount,
    IN KPROCESSOR_MODE                RequestorMode,
    IN PUC_PROCESS_SERVER_INFORMATION pServInfo,
    IN PUC_HTTP_AUTH                  *ppIAuth,
    IN PUC_HTTP_AUTH                  *ppIProxyAuth,
    IN PULONG                          pConnectionIndex
    );

VOID
UcFreeSendMdls(
               IN PMDL pMdl
               );
    
VOID
UcReferenceRequest(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

VOID
UcDereferenceRequest(
    IN PVOID  pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

PIRP
UcPrepareRequestIrp(
    IN  PUC_HTTP_REQUEST pRequest,
    IN  NTSTATUS         Status
    );

NTSTATUS
UcCompleteParsedRequest(
    IN PUC_HTTP_REQUEST pRequest,
    IN NTSTATUS         Status,
    IN BOOLEAN          NextRequest,
    IN KIRQL            OldIrql
    );

BOOLEAN
UcSetRequestCancelRoutine(
    PUC_HTTP_REQUEST pRequest, 
    PDRIVER_CANCEL   pCancelRoutine
    );

BOOLEAN
UcRemoveRequestCancelRoutine(
    PUC_HTTP_REQUEST pRequest
    );

BOOLEAN
UcSetEntityCancelRoutine(
    PUC_HTTP_SEND_ENTITY_BODY   pEntity,
    PDRIVER_CANCEL              pCancelRoutine
    );

BOOLEAN
UcRemoveEntityCancelRoutine(
    PUC_HTTP_SEND_ENTITY_BODY pEntity
    );

BOOLEAN
UcSetRecvResponseCancelRoutine(
    PUC_HTTP_RECEIVE_RESPONSE pResponse,
    PDRIVER_CANCEL            pCancelRoutine
    );


BOOLEAN
UcRemoveRcvRespCancelRoutine(
    PUC_HTTP_RECEIVE_RESPONSE pResponse
    );

VOID
UcpFreeRequest(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UcCopyResponseToIrp(
    PIRP                pIrp,
    PLIST_ENTRY         pResponseBufferList,
    PBOOLEAN            bDone,
    PULONG              pBytesTaken
    );

NTSTATUS
UcReceiveHttpResponse(
    IN PUC_HTTP_REQUEST  pRequest,
    IN PIRP              pIrp,
    IN PULONG            pBytesTaken
    );

VOID
UcpCancelReceiveResponse(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    Irp
    );

VOID
UcpCancelSendEntity(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    Irp
    );

VOID
UcpComputeEntityBodyLength(
    USHORT           EntityChunkCount,
    PHTTP_DATA_CHUNK pEntityChunks,
    BOOLEAN          bContentLengthSpecified,
    BOOLEAN          bServer11,
    PULONGLONG       UncopiedLength,
    PULONGLONG       CopiedLength
    );

NTSTATUS
UcCaptureEntityBody(
    PHTTP_SEND_REQUEST_ENTITY_BODY_INFO   pSendInfo,
    PIRP                                  Irp,
    PUC_HTTP_REQUEST                      pRequest,
    PUC_HTTP_SEND_ENTITY_BODY            *ppKeEntity,
    BOOLEAN                               bLast
    );

NTSTATUS
UcpBuildEntityMdls(
    USHORT           ChunkCount,
    PHTTP_DATA_CHUNK pHttpEntityBody,
    BOOLEAN          bServer11,
    BOOLEAN          bChunked,
    BOOLEAN          bLast,
    PSTR             pBuffer,
    PMDL             **pMdlLink,
    PULONG           BytesBuffered
    );

NTSTATUS
UcInitializeHttpRequests(
    VOID
    );

VOID
UcTerminateHttpRequests(
    VOID
    );

VOID
UcAllocateAndChainHeaderMdl(
    IN  PUC_HTTP_REQUEST pRequest
    );

VOID
UcpAllocateAndChainEntityMdl(
    IN  PVOID    pMdlBuffer,
    IN  ULONG    MdlLength,
    IN  PMDL   **pMdlLink,
    IN  PULONG   BytesBuffered
    );

PUC_HTTP_REQUEST
UcBuildConnectVerbRequest(
     IN PUC_CLIENT_CONNECTION pConnection,
     IN PUC_HTTP_REQUEST      pHeadRequest
     );

VOID
UcFailRequest(
    IN PUC_HTTP_REQUEST pRequest,
    IN NTSTATUS         Status,
    IN KIRQL            OldIrql
    );

VOID
UcReIssueRequestWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UcpProbeAndCopyEntityChunks(
    IN  KPROCESSOR_MODE                RequestorMode,
    IN  PHTTP_DATA_CHUNK               pEntityChunks,
    IN  ULONG                          EntityChunkCount,
    IN  PHTTP_DATA_CHUNK               pLocalEntityChunksArray,
    OUT PHTTP_DATA_CHUNK               *ppLocalEntityChunks
    );

#define IS_MDL_LOCKED(pmdl) (((pmdl)->MdlFlags & MDL_PAGES_LOCKED) != 0)

NTSTATUS
UcFindBuffersForReceiveResponseIrp(
    IN  PUC_HTTP_REQUEST     pRequest,
    IN  ULONG                OutBufferLen,
    IN  BOOLEAN              bForceComplete,
    OUT PLIST_ENTRY          pResponseBufferList,
    OUT PULONG               pTotalBytes
    );

VOID
UcpPreAuthWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

__inline
BOOLEAN
UcpCheckForPreAuth(
    IN PUC_HTTP_REQUEST pRequest
    );

__inline
BOOLEAN
UcpCheckForProxyPreAuth(
    IN PUC_HTTP_REQUEST pRequest
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\sendresponse.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    sendresponse.h

Abstract:

    This module contains declarations for manipulating HTTP responses.

Author:

    Keith Moore (keithmo)       07-Aug-1998

Revision History:

    Paul McDaniel (paulmcd)     15-Mar-1999     Modified SendResponse

--*/


#ifndef _SENDRESPONSE_H_
#define _SENDRESPONSE_H_


//
// Forwarders.
//

typedef struct _UL_INTERNAL_DATA_CHUNK *PUL_INTERNAL_DATA_CHUNK;
typedef struct _UL_INTERNAL_REQUEST *PUL_INTERNAL_REQUEST;
typedef struct _UL_INTERNAL_RESPONSE *PUL_INTERNAL_RESPONSE;
typedef struct _UL_HTTP_CONNECTION *PUL_HTTP_CONNECTION;
typedef struct _UL_LOG_DATA_BUFFER *PUL_LOG_DATA_BUFFER;
typedef struct _UL_URI_CACHE_ENTRY *PUL_URI_CACHE_ENTRY;


typedef enum _UL_SEND_CACHE_RESULT
{
    UlSendCacheResultNotSet,            // Not yet set
    UlSendCacheServedFromCache,         // Served from cache successfully
    UlSendCacheMiss,                    // Need to bounce up to user mode
    UlSendCacheConnectionRefused,       // Connection is refused (con limits)
    UlSendCachePreconditionFailed,      // Need to terminate connection
    UlSendCacheFailed,                  // Other failure (memory etc) need to terminate

    UlSendCacheMaximum

} UL_SEND_CACHE_RESULT, *PUL_SEND_CACHE_RESULT;

#define TRANSLATE_SEND_CACHE_RESULT(r)      \
    ((r) == UlSendCacheResultNotSet         ? "ResultNotSet" :          \
     (r) == UlSendCacheServedFromCache      ? "ServedFromCache" :       \
     (r) == UlSendCacheMiss                 ? "CacheMiss" :             \
     (r) == UlSendCacheConnectionRefused    ? "ConnectionRefused" :     \
     (r) == UlSendCachePreconditionFailed   ? "PreconditionFailed" :    \
     (r) == UlSendCacheFailed               ? "SendCacheFailed" : "UNKNOWN")


typedef enum _UL_RESUME_PARSING_TYPE
{
    UlResumeParsingNone,                // No need to resume parsing
    UlResumeParsingOnLastSend,          // Resume parsing on last send
    UlResumeParsingOnSendCompletion,    // Resume parsing on send completion

    UlResumeParsingMaximum

} UL_RESUME_PARSING_TYPE, *PUL_RESUME_PARSING_TYPE;


NTSTATUS
UlSendHttpResponse(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUL_INTERNAL_RESPONSE pResponse,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UlSendCachedResponse(
    IN  PUL_HTTP_CONNECTION   pHttpConn,
    OUT PUL_SEND_CACHE_RESULT pSendCacheResult,
    OUT PBOOLEAN              pResumeParsing
    );

NTSTATUS
UlCacheAndSendResponse(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUL_INTERNAL_RESPONSE pResponse,
    IN PUL_APP_POOL_PROCESS pProcess,
    IN HTTP_CACHE_POLICY Policy,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext,
    OUT PBOOLEAN pServedFromCache
    );


typedef enum _UL_CAPTURE_FLAGS
{
    UlCaptureNothing = 0x00,
    UlCaptureCopyData = 0x01,
    UlCaptureKernelMode = 0x02,
    UlCaptureCopyDataInKernelMode = UlCaptureCopyData | UlCaptureKernelMode,

} UL_CAPTURE_FLAGS;


typedef struct _UL_INTERNAL_DATA_CHUNK
{
    //
    // Chunk type.
    //

    HTTP_DATA_CHUNK_TYPE ChunkType;

    //
    // The data chunk structures, one per supported data chunk type.
    //

    union
    {
        //
        // From memory data chunk.
        //

        struct
        {
            PMDL pMdl;
            PVOID pCopiedBuffer;

            PVOID pUserBuffer;
            ULONG BufferLength;

        } FromMemory;

        //
        // From file handle data chunk.
        //

        struct
        {
            HTTP_BYTE_RANGE ByteRange;
            HANDLE FileHandle;
            UL_FILE_CACHE_ENTRY FileCacheEntry;

        } FromFileHandle;

        //
        // From fragment cache data chunk.
        //

        struct
        {
            PUL_URI_CACHE_ENTRY pCacheEntry;

        } FromFragmentCache;

    };

} UL_INTERNAL_DATA_CHUNK, *PUL_INTERNAL_DATA_CHUNK;


#define IS_FROM_MEMORY( pchunk )                                            \
    ( (pchunk)->ChunkType == HttpDataChunkFromMemory )

#define IS_FROM_FILE_HANDLE( pchunk )                                       \
    ( (pchunk)->ChunkType == HttpDataChunkFromFileHandle )

#define IS_FROM_FRAGMENT_CACHE( pchunk )                                    \
    ( (pchunk)->ChunkType == HttpDataChunkFromFragmentCache )

#define UL_IS_VALID_INTERNAL_RESPONSE(x)                                    \
    HAS_VALID_SIGNATURE(x, UL_INTERNAL_RESPONSE_POOL_TAG)


//
// WARNING!  All fields of this structure must be explicitly initialized.
//

typedef struct _UL_INTERNAL_RESPONSE
{
    //
    // NonPagedPool
    //

    //
    // This MUST be the first field in the structure. This is the linkage
    // used by the lookaside package for storing entries in the lookaside
    // list.
    //

    SLIST_ENTRY LookasideEntry;

    //
    // UL_INTERNAL_RESPONSE_POOL_TAG
    //

    ULONG Signature;

    //
    // Reference count.
    //

    LONG ReferenceCount;

    //
    // The original request.
    //

    PUL_INTERNAL_REQUEST pRequest;

    //
    // Does the response need to perform a sync I/O read?
    //

    BOOLEAN SyncRead;

    //
    // Was a Content-Length specified?
    //

    BOOLEAN ContentLengthSpecified;

    // 
    // Should we generate a Date: header?
    //

    BOOLEAN GenDateHeader;

    //
    // Was Transfer-Encoding "Chunked" specified?
    //

    BOOLEAN ChunkedSpecified;

    //
    // Is this from a lookaside list?  Used to determine how to free.
    //

    BOOLEAN FromLookaside;

    //
    // Is this from kernel mode (UlSendErrorResponse)?
    //

    BOOLEAN FromKernelMode;

    //
    // Has this response gone through the EnqueueSendHttpResponse logic?
    //

    BOOLEAN SendEnqueued;

    //
    // Should we try to copy some data so we can complete the IRP early?
    //

    BOOLEAN CopySend;

    //
    // The maximum IRP stack size of all file systems associated
    // with this response.
    //

    CCHAR MaxFileSystemStackSize;

    //
    // If parsing needs to be resumed on send completion.
    //

    UL_RESUME_PARSING_TYPE ResumeParsingType;

    //
    // HTTP_SEND_RESPONSE flags.
    //

    ULONG Flags;

    //
    // Status code & verb.
    //

    USHORT StatusCode;
    HTTP_VERB Verb;

    //
    // Should we generate a ConnectionHeader?
    //

    UL_CONN_HDR ConnHeader;

    //
    // The headers.
    //

    ULONG HeaderLength;
    ULONG VariableHeaderLength;
    PUCHAR pHeaders;
    PUCHAR pVariableHeader;

    //
    // System time of Date header
    //

    LARGE_INTEGER CreationTime;

    //
    // ETag from HTTP_RESPONSE
    //

    ULONG  ETagLength;
    PUCHAR pETag;

    //
    // Content-Type and Content-Encoding from HTTP_RESPONSE
    //

    UL_CONTENT_TYPE   ContentType;
    ULONG  ContentEncodingLength;
    PUCHAR pContentEncoding;

    //
    // Optional pointer to the space containing all embedded
    // file names and copied data. This may be NULL for in-memory-only
    // responses that are strictly locked down.
    //

    ULONG AuxBufferLength;
    PVOID pAuxiliaryBuffer;

    //
    // Logging data passed down by the user
    //

    PUL_LOG_DATA_BUFFER pLogData;

    //
    // Length of the entire response
    //

    ULONGLONG ResponseLength;

    //
    // Total length of the FromMemory chunks of the response
    //

    ULONGLONG FromMemoryLength;

    //
    // "Quota" taken in either ConnectionSendLimit or GlobalSendLimit
    //

    ULONGLONG ConnectionSendBytes;
    ULONGLONG GlobalSendBytes;

    //
    // Total number of bytes transferred for the entire
    // response. These are necessary to properly complete the IRP.
    //

    ULONGLONG BytesTransferred;

    //
    // A push lock taken when a send (call to TDI) is in progress.
    //

    UL_PUSH_LOCK PushLock;

    //
    // IoStatus and IRP used to complete the send response IRP.
    //

    IO_STATUS_BLOCK IoStatus;
    PIRP pIrp;

    //
    // Completion routine & context.
    //

    PUL_COMPLETION_ROUTINE pCompletionRoutine;
    PVOID pCompletionContext;

    //
    // Current file read offset and bytes remaining.
    //

    ULARGE_INTEGER FileOffset;
    ULARGE_INTEGER FileBytesRemaining;

    //
    // The total number of chunks in pDataChunks[].
    //

    ULONG ChunkCount;

    //
    // The current chunk in pDataChunks[].
    //

    ULONG CurrentChunk;

    //
    // The data chunks describing the data for this response.
    //

    UL_INTERNAL_DATA_CHUNK pDataChunks[0];

} UL_INTERNAL_RESPONSE, *PUL_INTERNAL_RESPONSE;

#define IS_SEND_COMPLETE( resp )                                            \
    ( ( (resp)->CurrentChunk ) == (resp)->ChunkCount )

#define IS_DISCONNECT_TIME( resp )                                          \
    ( (((resp)->Flags & HTTP_SEND_RESPONSE_FLAG_DISCONNECT) != 0) &&        \
      (((resp)->Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) == 0) )


//
// Types of trackers
//

typedef enum _UL_TRACKER_TYPE
{
    UlTrackerTypeSend,
    UlTrackerTypeBuildUriEntry,

    UlTrackerTypeMaximum

} UL_TRACKER_TYPE, *PUL_TRACKER_TYPE;


//
// A MDL_RUN is a set of MDLs that came from the same source (either
// a series of memory buffers, or data from a single file read) that
// can be released all at once with the same mechanism.
//

#define UL_MAX_MDL_RUNS 5

typedef struct _UL_MDL_RUN
{
    PMDL pMdlTail;
    UL_FILE_BUFFER FileBuffer;
    
} UL_MDL_RUN, *PUL_MDL_RUN;


//
// The UL_CHUNK_TRACKER is for iterating through the chunks in
// a UL_INTERNAL_RESPONSE. It is used for sending responses
// and generating cache entries.
//
// WARNING!  All fields of this structure must be explicitly initialized.
//

typedef struct _UL_CHUNK_TRACKER
{
    //
    // This MUST be the first field in the structure. This is the linkage
    // used by the lookaside package for storing entries in the lookaside
    // list.
    //

    SLIST_ENTRY LookasideEntry;

    //
    // A signature.
    //

    ULONG Signature;

    //
    // Refcount on the tracker. We only use this refcount for the non-cache
    // case to sync various aynsc paths happening because of two outstanding
    // IRPs; Read and Send IRPs.
    //

    LONG  RefCount;

    //
    // Flag to understand whether we have completed the send request on
    // this tracker or not. To synch the multiple completion paths.
    //

    LONG Terminated;

    //
    // Is this from a lookaside list?  Used to determine how to free.
    //

    BOOLEAN FromLookaside;

    //
    // First piece of the response (MDL_RUN) of SendHttpResponse/EntityBody.
    //

    BOOLEAN FirstResponse;

    //
    // type of tracker
    //

    UL_TRACKER_TYPE Type;

    //
    // this connection keeps our reference count on the UL_CONNECTION
    //

    PUL_HTTP_CONNECTION pHttpConnection;

    //
    // The actual response.
    //

    PUL_INTERNAL_RESPONSE pResponse;

    //
    // The precreated file read and send IRP.
    //

    PIRP pIrp;

    //
    // The precreated IRP context for send.
    //

    UL_IRP_CONTEXT IrpContext;

    //
    // A work item, used for queuing to a worker thread.
    //

    UL_WORK_ITEM WorkItem;

    //
    // WARNING: RtlZeroMemory is only called for feilds below this line.
    // All fields above should be explicitly initialized.
    //

    IO_STATUS_BLOCK IoStatus;

    //
    // Used to queue the tracker on the pending response list.
    //

    LIST_ENTRY ListEntry;

    union
    {
        struct _SEND_TRACK_INFO
        {
            //
            // The head of the MDL chain buffered for this send.
            //

            PMDL pMdlHead;

            //
            // Pointer to the Next field of the last MDL on the chain.
            // This makes it very easy to append to the chain.
            //

            PMDL *pMdlLink;

            //
            // The number of bytes currently buffered in the MDL chain.
            //

            ULONG BytesBuffered;

            //
            // The number of active MDL runs.
            //

            ULONG MdlRunCount;

            //
            // This is the MDL in the MDL chain starting from pMdlHead that
            // we are going to split.
            //

            PMDL pMdlToSplit;

            //
            // This is the MDL whose Next field points to pMdlToSplit or it is
            // NULL when pMdlToSplit == pMdlHead.
            //

            PMDL pMdlPrevious;

            //
            // This is the partial MDL we have built for the split send and
            // represents the first part of the data in pMdlToSplit; or
            // it can be pMdlToSplit itself where the MDL chain up to
            // pMdlToSplit has exactly 1/2 of BytesBuffered.
            //

            PMDL pMdlSplitFirst;

            //
            // This is the partial MDL we have built for the split send and
            // represents the second part of the data in pMdlToSplit; or
            // it can be pMdlToSplit->Next where the MDL chain up to
            // pMdlToSplit has exactly 1/2 of BytesBuffered.
            //

            PMDL pMdlSplitSecond;

            //
            // How many sends (TDI calls) we have issued to flush the tracker.
            //

            LONG SendCount;

            //
            // The MDL runs.
            //

            UL_MDL_RUN MdlRuns[UL_MAX_MDL_RUNS];

        } SendInfo;

        struct _BUILD_TRACK_INFO
        {
            //
            // The cache entry
            //

            PUL_URI_CACHE_ENTRY pUriEntry;

            //
            // File buffer information for reading.
            //

            UL_FILE_BUFFER FileBuffer;

            //
            // Offset inside pUriEntry->pMdl to copy the next buffer.
            //

            ULONG Offset;

        } BuildInfo;
    };

} UL_CHUNK_TRACKER, *PUL_CHUNK_TRACKER;

#define IS_VALID_CHUNK_TRACKER( tracker )                                   \
    (HAS_VALID_SIGNATURE(tracker, UL_CHUNK_TRACKER_POOL_TAG)                \
        && ((tracker)->Type < UlTrackerTypeMaximum) )


//
// This structure is for tracking an autonomous send with one full response
//
// WARNING!  All fields of this structure must be explicitly initialized.
//

typedef struct _UL_FULL_TRACKER
{
    //
    // This MUST be the first field in the structure. This is the linkage
    // used by the lookaside package for storing entries in the lookaside
    // list.
    //

    SLIST_ENTRY LookasideEntry;

    //
    // A signature.
    //

    ULONG Signature;

    //
    // The HTTP Verb
    //

    HTTP_VERB RequestVerb;

    //
    // The HTTP status code (e.g. 200).
    //

    USHORT ResponseStatusCode;

    //
    // Is this from a lookaside list?  Used to determine how to free.
    //

    BOOLEAN FromLookaside;

    //
    // Is this from the internal request?  Won't try to free if set.
    //

    BOOLEAN FromRequest;

    //
    // Set if send is buffered for this response.
    //

    BOOLEAN SendBuffered;

    //
    // If parsing needs to be resumed on send completion.
    //

    UL_RESUME_PARSING_TYPE ResumeParsingType;

    //
    // A work item, used for queuing to a worker thread.
    //

    UL_WORK_ITEM WorkItem;

    //
    // The cache entry.
    //

    PUL_URI_CACHE_ENTRY pUriEntry;

    //
    // Preallocated buffer for the fixed headers, variable headers and entity
    // body to be copied in the cache-miss case, or for the variable headers
    // only in the cache-hit case.
    //

    ULONG AuxilaryBufferLength;
    PUCHAR pAuxiliaryBuffer;

    //
    // MDL for the variable headers in the cache-hit case or for both the
    // fixed headers and variable headers plus the copied entity body in
    // the cache-miss case.
    //

    union
    {
        PMDL pMdlVariableHeaders;
        PMDL pMdlAuxiliary;
    };

    //
    // MDL for the fixed headers in the cache-hit case or for the user
    // buffer in the cache-miss case.
    //

    union
    {
        PMDL pMdlFixedHeaders;
        PMDL pMdlUserBuffer;
    };

    //
    // MDL for the content in the cache-hit case.
    //

    PMDL pMdlContent;

    //
    // The original request that is saved for logging purpose.
    //

    PUL_INTERNAL_REQUEST pRequest;

    //
    // This connection keeps our reference count on the UL_CONNECTION.
    //

    PUL_HTTP_CONNECTION pHttpConnection;

    //
    // The log data captured if any.
    //

    PUL_LOG_DATA_BUFFER pLogData;

    //
    // Completion routine & context.
    //

    PUL_COMPLETION_ROUTINE pCompletionRoutine;
    PVOID pCompletionContext;

    //
    // Flags.
    //

    ULONG Flags;

    //
    // The precreated send IRP.
    //

    PIRP pSendIrp;

    //
    // The precreated IRP context for send.
    //

    UL_IRP_CONTEXT IrpContext;

    //
    // The orignal user send IRP if exists.
    //

    PIRP pUserIrp;

    //
    // "Quota" taken in either ConnectionSendLimit or GlobalSendLimit.
    //

    ULONGLONG ConnectionSendBytes;
    ULONGLONG GlobalSendBytes;

    //
    // I/O status from the completion routine.
    //

    IO_STATUS_BLOCK IoStatus;

} UL_FULL_TRACKER, *PUL_FULL_TRACKER;

#define IS_VALID_FULL_TRACKER( tracker )                                    \
    HAS_VALID_SIGNATURE(tracker, UL_FULL_TRACKER_POOL_TAG)


//
// An inline function to initialize the full tracker.
//

__inline
VOID
UlInitializeFullTrackerPool(
    IN PUL_FULL_TRACKER pTracker,
    IN CCHAR SendIrpStackSize
    )
{
    USHORT SendIrpSize;

    UlInitializeWorkItem(&pTracker->WorkItem);

    //
    // Set up the IRP.
    //

    SendIrpSize = IoSizeOfIrp(SendIrpStackSize);

    pTracker->pSendIrp =
        (PIRP)((PCHAR)pTracker +
            ALIGN_UP(sizeof(UL_FULL_TRACKER), PVOID));

    IoInitializeIrp(
        pTracker->pSendIrp,
        SendIrpSize,
        SendIrpStackSize
        );

    pTracker->pLogData = NULL;
    
    //
    // Set the Mdl's for the FixedHeaders/Variable pair and
    // the UserBuffer/AuxiliaryBuffer pair.
    //

    pTracker->pMdlFixedHeaders =
        (PMDL)((PCHAR)pTracker->pSendIrp + SendIrpSize);

    pTracker->pMdlVariableHeaders =
        (PMDL)((PCHAR)pTracker->pMdlFixedHeaders + g_UlFixedHeadersMdlLength);

    pTracker->pMdlContent =
        (PMDL)((PCHAR)pTracker->pMdlVariableHeaders + g_UlVariableHeadersMdlLength);

    //
    // Set up the auxiliary buffer pointer for the variable header plus
    // the fixed header and the entity body in the cache-miss case.
    //

    pTracker->pAuxiliaryBuffer =
        (PUCHAR)((PCHAR)pTracker->pMdlContent + g_UlContentMdlLength);

    //
    // Initialize the auxiliary MDL.
    //

    MmInitializeMdl(
        pTracker->pMdlAuxiliary,
        pTracker->pAuxiliaryBuffer,
        pTracker->AuxilaryBufferLength
        );

    MmBuildMdlForNonPagedPool( pTracker->pMdlAuxiliary );
}


NTSTATUS
UlCaptureHttpResponse(
    IN PUL_APP_POOL_PROCESS pProcess OPTIONAL,
    IN PHTTP_RESPONSE pUserResponse OPTIONAL,
    IN PUL_INTERNAL_REQUEST pRequest,
    IN USHORT ChunkCount,
    IN PHTTP_DATA_CHUNK pDataChunks,
    IN UL_CAPTURE_FLAGS Flags,
    IN ULONG SendFlags,
    IN BOOLEAN CaptureCache,
    IN PHTTP_LOG_FIELDS_DATA pLogData OPTIONAL,
    OUT PUSHORT pStatusCode,
    OUT PUL_INTERNAL_RESPONSE *ppKernelResponse
    );

NTSTATUS
UlCaptureUserLogData(
    IN  PHTTP_LOG_FIELDS_DATA  pCapturedUserLogData,
    IN  PUL_INTERNAL_REQUEST   pRequest,
    OUT PUL_LOG_DATA_BUFFER   *ppKernelLogData
    );

NTSTATUS
UlPrepareHttpResponse(
    IN HTTP_VERSION Version,
    IN PHTTP_RESPONSE pUserResponse,
    IN PUL_INTERNAL_RESPONSE pResponse,
    IN KPROCESSOR_MODE AccessMode
    );

VOID
UlCleanupHttpResponse(
    IN PUL_INTERNAL_RESPONSE pResponse
    );

VOID
UlReferenceHttpResponse(
    IN PUL_INTERNAL_RESPONSE pResponse
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

VOID
UlDereferenceHttpResponse(
    IN PUL_INTERNAL_RESPONSE pResponse
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define UL_REFERENCE_INTERNAL_RESPONSE( presp )                             \
    UlReferenceHttpResponse(                                                \
        (presp)                                                             \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

#define UL_DEREFERENCE_INTERNAL_RESPONSE( presp )                           \
    UlDereferenceHttpResponse(                                              \
        (presp)                                                             \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

PMDL
UlAllocateLockedMdl(
    IN PVOID VirtualAddress,
    IN ULONG Length,
    IN LOCK_OPERATION Operation
    );

VOID
UlFreeLockedMdl(
    PMDL pMdl
    );

NTSTATUS
UlInitializeAndLockMdl(
    IN PMDL pMdl,
    IN PVOID VirtualAddress,
    IN ULONG Length,
    IN LOCK_OPERATION Operation
    );

VOID
UlCompleteSendResponse(
    IN PUL_CHUNK_TRACKER pTracker,
    IN NTSTATUS Status
    );

VOID
UlSetRequestSendsPending(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN OUT PUL_LOG_DATA_BUFFER * ppLogData,
    IN OUT PUL_RESUME_PARSING_TYPE pResumeParsingType
    );

VOID
UlUnsetRequestSendsPending(
    IN PUL_INTERNAL_REQUEST pRequest,
    OUT PUL_LOG_DATA_BUFFER * ppLogData,
    OUT PBOOLEAN pResumeParsing
    );


//
// Check pRequest->SentResponse and pRequest->SentLast flags for
// UlSendHttpResponseIoctl
//

__inline
NTSTATUS
UlCheckSendHttpResponseFlags(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN ULONG Flags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Make sure only one response header goes back. We can test this
    // without acquiring the request resource, since the flag is only set
    // (never reset).
    //

    if (1 == InterlockedCompareExchange(
                (PLONG)&pRequest->SentResponse,
                1,
                0
                ))
    {
        //
        // Already sent a response.  Bad.
        //

        Status = STATUS_INVALID_PARAMETER;

        UlTraceError(SEND_RESPONSE, (
            "http!UlCheckSendHttpResponseFlags(pRequest = %p (%I64x)) %s\n"
            "        Tried to send a second response!\n",
            pRequest,
            pRequest->RequestId,
            HttpStatusToString(Status)
            ));

        goto end;
    }

    //
    // Also ensure that all previous calls to SendHttpResponse
    // and SendEntityBody had the MORE_DATA flag set.
    //

    if (0 == (Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA))
    {
        //
        // Remember if the more data flag is not set.
        //

        if (1 == InterlockedCompareExchange(
                    (PLONG)&pRequest->SentLast,
                    1,
                    0
                    ))
        {
            Status = STATUS_INVALID_PARAMETER;

            UlTraceError(SEND_RESPONSE, (
                "http!UlCheckSendHttpResponseFlags(pRequest = %p (%I64x)) %s\n"
                "        Last send after previous last send!\n",
                pRequest,
                pRequest->RequestId,
                HttpStatusToString(Status)
                ));

            goto end;
        }
    }
    else
    if (pRequest->SentLast == 1)
    {
        Status = STATUS_INVALID_PARAMETER;

        UlTraceError(SEND_RESPONSE, (
            "http!UlCheckSendHttpResponseFlags(pRequest = %p (%I64x)) %s\n"
            "        Tried to send again after last send!\n",
            pRequest,
            pRequest->RequestId,
            HttpStatusToString(Status)
            ));

        goto end;
    }

end:

    return Status;

} // UlCheckSendHttpResponseFlags


//
// Check pRequest->SentResponse and pRequest->SentLast flags for
// UlSendEntityBodyIoctl
//

__inline
NTSTATUS
UlCheckSendEntityBodyFlags(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN ULONG Flags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Ensure a response has already been sent. We can test this without
    // acquiring the request resource, since the flag is only set (never
    // reset).
    //

    if (pRequest->SentResponse == 0)
    {
        //
        // The application is sending entity without first having
        // send a response header. This is generally an error, however
        // we allow the application to override this by passing
        // the HTTP_SEND_RESPONSE_FLAG_RAW_HEADER flag.
        //

        if (Flags & HTTP_SEND_RESPONSE_FLAG_RAW_HEADER)
        {
            UlTrace(SEND_RESPONSE, (
                "http!UlCheckSendEntityBodyFlags(pRequest = %p (%I64x))\n"
                "        Intentionally sending raw header!\n",
                pRequest,
                pRequest->RequestId
                ));

            if (1 == InterlockedCompareExchange(
                        (PLONG)&pRequest->SentResponse,
                        1,
                        0
                        ))
            {
                Status = STATUS_INVALID_PARAMETER;

                UlTraceError(SEND_RESPONSE, (
                    "http!UlCheckSendEntityBodyFlags(pRequest = %p (%I64x))\n"
                    "        Already sent a response, %s!\n",
                    pRequest,
                    pRequest->RequestId,
                    HttpStatusToString(Status)
                    ));

                goto end;
            }
        }
        else
        {
            Status = STATUS_INVALID_PARAMETER;

            UlTraceError(SEND_RESPONSE, (
                "http!UlCheckSendEntityBodyFlags(pRequest = %p (%I64x)) %s\n"
                "        No response yet!\n",
                pRequest,
                pRequest->RequestId,
                HttpStatusToString(Status)
                ));

            goto end;
        }
    }

    //
    // Also ensure that all previous calls to SendHttpResponse
    // and SendEntityBody had the MORE_DATA flag set.
    //

    if ((Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) == 0)
    {
        //
        // Remember that this was the last send. We shouldn't
        // get any more data after this.
        //

        if (1 == InterlockedCompareExchange(
                    (PLONG)&pRequest->SentLast,
                    1,
                    0
                    ))
        {
            Status = STATUS_INVALID_PARAMETER;

            UlTraceError(SEND_RESPONSE, (
                "http!UlCheckSendEntityBodyFlags(pRequest = %p (%I64x)) %s\n"
                "        Last send after previous last send!\n",
                pRequest,
                pRequest->RequestId,
                HttpStatusToString(Status)
                ));

            goto end;
        }
    }
    else
    if (pRequest->SentLast == 1)
    {
        Status = STATUS_INVALID_PARAMETER;

        UlTraceError(SEND_RESPONSE, (
            "http!UlCheckSendEntityBodyFlags(pRequest = %p (%I64x)) %s\n"
            "        Tried to send again after last send!\n",
            pRequest,
            pRequest->RequestId,
            HttpStatusToString(Status)
            ));

        goto end;
    }

end:

    return Status;

} // UlCheckSendEntityBodyFlags


//
// Check/Uncheck ConnectionSendLimit and GlobalSendLimit
//

extern ULONGLONG g_UlTotalSendBytes;
extern UL_EXCLUSIVE_LOCK g_UlTotalSendBytesExLock;

__inline
NTSTATUS
UlCheckSendLimit(
    IN PUL_HTTP_CONNECTION pHttpConnection,
    IN ULONGLONG SendBytes,
    IN PULONGLONG pConnectionSendBytes,
    IN PULONGLONG pGlobalSendBytes
    )
{
    NTSTATUS Status = STATUS_DEVICE_BUSY;

    PAGED_CODE();
    ASSERT( pConnectionSendBytes && pGlobalSendBytes );
    ASSERT( *pConnectionSendBytes == 0 && *pGlobalSendBytes == 0 );

    //
    // Try ConnectionSendLimit first.
    //

    UlAcquireExclusiveLock( &pHttpConnection->ExLock );

    if (pHttpConnection->TotalSendBytes <= g_UlConnectionSendLimit)
    {
        pHttpConnection->TotalSendBytes += SendBytes;
        *pConnectionSendBytes = SendBytes;
        Status = STATUS_SUCCESS;
    }

    UlReleaseExclusiveLock( &pHttpConnection->ExLock );

    if (STATUS_SUCCESS == Status)
    {
        return Status;
    }

    //
    // If we fail the ConnectionSendLimit test, try GlobalSendLimit.
    //

    UlAcquireExclusiveLock( &g_UlTotalSendBytesExLock );

    if (g_UlTotalSendBytes <= g_UlGlobalSendLimit)
    {
        g_UlTotalSendBytes += SendBytes;
        *pGlobalSendBytes = SendBytes;
        Status = STATUS_SUCCESS;
    }

    UlReleaseExclusiveLock( &g_UlTotalSendBytesExLock );

    return Status;

} // UlCheckSendLimit


__inline
VOID
UlUncheckSendLimit(
    IN PUL_HTTP_CONNECTION pHttpConnection,
    IN ULONGLONG ConnectionSendBytes,
    IN ULONGLONG GlobalSendBytes
    )
{
    if (ConnectionSendBytes)
    {
        ASSERT( GlobalSendBytes == 0 );

        UlAcquireExclusiveLock( &pHttpConnection->ExLock );
        pHttpConnection->TotalSendBytes -= ConnectionSendBytes;
        UlReleaseExclusiveLock( &pHttpConnection->ExLock );
    }

    if (GlobalSendBytes)
    {
        ASSERT( ConnectionSendBytes == 0 );

        UlAcquireExclusiveLock( &g_UlTotalSendBytesExLock );
        g_UlTotalSendBytes -= GlobalSendBytes;
        UlReleaseExclusiveLock( &g_UlTotalSendBytesExLock );
    }

} // UlUncheckSendLimit


//
// Checkout a cache entry using the fragment name
//

__inline
NTSTATUS
UlCheckoutFragmentCacheEntry(
    IN PCWSTR pFragmentName,
    IN ULONG FragmentNameLength,
    IN PUL_APP_POOL_PROCESS pProcess,
    OUT PUL_URI_CACHE_ENTRY *pFragmentCacheEntry
    )
{
    PUL_URI_CACHE_ENTRY pCacheEntry = NULL;
    URI_SEARCH_KEY SearchKey;
    NTSTATUS Status = STATUS_SUCCESS;

    *pFragmentCacheEntry = NULL;

    if (!g_UriCacheConfig.EnableCache)
    {
        Status = STATUS_NOT_SUPPORTED;
        goto end;
    }

    SearchKey.Type = UriKeyTypeNormal;
    SearchKey.Key.Hash = HashStringNoCaseW(pFragmentName, 0);
    SearchKey.Key.Hash = HashRandomizeBits(SearchKey.Key.Hash);
    SearchKey.Key.pUri = (PWSTR) pFragmentName;
    SearchKey.Key.Length = FragmentNameLength;
    SearchKey.Key.pPath = NULL;

    pCacheEntry = UlCheckoutUriCacheEntry(&SearchKey);

    if (NULL == pCacheEntry)
    {
        Status = STATUS_OBJECT_PATH_NOT_FOUND;
        goto end;
    }

    //
    // Return error if the cache entry has no content.
    //

    if (0 == pCacheEntry->ContentLength)
    {
        Status = STATUS_FILE_INVALID;
        goto end;
    }

    //
    // Make sure the process belongs to the same AppPool that created
    // the fragment cache entry or this is a full response cache that
    // is meant to be public.
    //

    if (IS_FRAGMENT_CACHE_ENTRY(pCacheEntry) &&
        pCacheEntry->pAppPool != pProcess->pAppPool)
    {
        Status = STATUS_INVALID_ID_AUTHORITY;
        goto end;
    }

end:

    if (NT_SUCCESS(Status))
    {
        *pFragmentCacheEntry = pCacheEntry;
    }
    else
    {
        if (pCacheEntry)
        {
            UlCheckinUriCacheEntry(pCacheEntry);
        }
    }

    return Status;

} // UlCheckoutFragmentCacheEntry


//
// Check to if we need to log.
//

__inline
VOID
UlLogHttpResponse(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUL_LOG_DATA_BUFFER pLogData
    )
{
    //
    // If this is the last response for this request and there was a
    // log data passed down by the user then now its time to log.
    //

    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pRequest ) );
    ASSERT( IS_VALID_LOG_DATA_BUFFER( pLogData ) );

    //
    // Update the send status if send was not success.
    //

    LOG_UPDATE_WIN32STATUS( pLogData, pRequest->LogStatus );

    //
    // Pick the right logging type.
    //

    if (pLogData->Flags.Binary)
    {
        UlRawLogHttpHit( pLogData );
    }
    else
    {
        UlLogHttpHit( pLogData );
    }

    //
    // Done with pLogData.
    //

    UlDestroyLogDataBuffer( pLogData );

} // UlLogHttpResponse


//
// Validate and sanitize the specified file byte range.
//

__inline
NTSTATUS
UlSanitizeFileByteRange (
    IN PHTTP_BYTE_RANGE InByteRange,
    OUT PHTTP_BYTE_RANGE OutByteRange,
    IN ULONGLONG FileLength
    )
{
    ULONGLONG Offset;
    ULONGLONG Length;

    Offset = InByteRange->StartingOffset.QuadPart;
    Length = InByteRange->Length.QuadPart;

    if (HTTP_BYTE_RANGE_TO_EOF == Offset) {
        return STATUS_NOT_SUPPORTED;
    }

    if (HTTP_BYTE_RANGE_TO_EOF == Length) {
        if (Offset > FileLength) {
            return STATUS_FILE_INVALID;
        }

        Length = FileLength - Offset;
    }

    if (Length > FileLength || Offset > (FileLength - Length)) {
        return STATUS_FILE_INVALID;
    }

    OutByteRange->StartingOffset.QuadPart = Offset;
    OutByteRange->Length.QuadPart = Length;

    return STATUS_SUCCESS;

} // UlSanitizeFileByteRange

#endif  // _SENDRESPONSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\sendresponsep.h ===
/*++

Copyright (c) 1999-2002 Microsoft Corporation

Module Name:

    sendresponsep.h

Abstract:

    The private definition of response sending interfaces.

Author:

    Michael Courage (mcourage)      15-Jun-1999

Revision History:

--*/


#ifndef _SENDRESPONSEP_H_
#define _SENDRESPONSEP_H_


//
// Private constants.
//

//
// Convenience macro to test if a MDL describes locked memory.
//

#define IS_MDL_LOCKED(pmdl) (((pmdl)->MdlFlags & MDL_PAGES_LOCKED) != 0)

#define HEADER_CHUNK_COUNT  2


//
// Private prototypes.
//

ULONG
UlpComputeFixedHeaderSize(
    IN PHTTP_RESPONSE pUserResponse
    );

VOID
UlpComputeChunkBufferSizes(
    IN ULONG ChunkCount,
    IN PHTTP_DATA_CHUNK pDataChunks,
    IN UL_CAPTURE_FLAGS Flags,
    OUT PULONG pAuxBufferSize,
    OUT PULONG pCopiedMemorySize,
    OUT PULONG pUncopiedMemorySize
    );

VOID
UlpDestroyCapturedResponse(
    IN PUL_INTERNAL_RESPONSE pResponse
    );

VOID
UlpEnqueueSendHttpResponse(
    IN PUL_CHUNK_TRACKER pTracker,
    IN BOOLEAN FromKernelMode
    );

VOID
UlpDequeueSendHttpResponse(
    IN PUL_INTERNAL_REQUEST pRequest
    );

VOID
UlpSendHttpResponseWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpCloseConnectionComplete(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

NTSTATUS
UlpProbeHttpResponse(
    IN PHTTP_RESPONSE pUserResponse,
    IN USHORT ChunkCount,
    IN PHTTP_DATA_CHUNK pCapturedDataChunks,
    IN UL_CAPTURE_FLAGS Flags,
    IN PHTTP_LOG_FIELDS_DATA pCapturedLogData,
    IN KPROCESSOR_MODE RequestorMode
    );

PUL_CHUNK_TRACKER
UlpAllocateChunkTracker(
    IN UL_TRACKER_TYPE TrackerType,
    IN CCHAR SendIrpStackSize,
    IN CCHAR ReadIrpStackSize,
    IN BOOLEAN FirstResponse,
    IN PUL_HTTP_CONNECTION pHttpConnection,
    IN PUL_INTERNAL_RESPONSE pResponse
    );

VOID
UlpFreeChunkTracker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpCompleteSendResponseWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UlpRestartMdlRead(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

VOID
UlpMdlReadCompleteWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpRestartMdlSend(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

NTSTATUS
UlpCopySend(
    IN PUL_CHUNK_TRACKER pTracker,
    IN PMDL pMdl,
    IN ULONG Length,
    IN BOOLEAN InitiateDisconnect,
    IN BOOLEAN RequestComplete
    );

VOID
UlpRestartCopySend(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpMdlSendCompleteWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UlpFlushMdlRuns(
    IN PUL_CHUNK_TRACKER pTracker
    );

VOID
UlpFreeMdlRuns(
    IN PUL_CHUNK_TRACKER pTracker
    );

VOID
UlpFreeFileMdlRun(
    IN OUT PUL_CHUNK_TRACKER pTracker,
    IN OUT PUL_MDL_RUN pMdlRun
    );

VOID
UlpIncrementChunkPointer(
    IN OUT PUL_INTERNAL_RESPONSE pResponse
    );

__inline
VOID
UlpInitMdlRuns(
    IN OUT PUL_CHUNK_TRACKER pTracker
    )
{
    pTracker->SendInfo.pMdlHead = NULL;
    pTracker->SendInfo.pMdlLink = &pTracker->SendInfo.pMdlHead;
    pTracker->SendInfo.MdlRunCount = 0;
    pTracker->SendInfo.BytesBuffered = 0;
}

__inline
VOID
UlpBuildExtendedSearchKey(
    IN  PUL_INTERNAL_REQUEST pRequest,
    OUT PURI_SEARCH_KEY      pSearchKey
    )
{
    ASSERT(pSearchKey);
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    ASSERT(pRequest->CookedUrl.Length > 0);
    ASSERT(DIFF(pRequest->CookedUrl.pAbsPath - pRequest->CookedUrl.pUrl) > 0);
    
    pSearchKey->Type = UriKeyTypeExtended;
    pSearchKey->ExKey.pAbsPath = pRequest->CookedUrl.pAbsPath;
    pSearchKey->ExKey.AbsPathLength = pRequest->CookedUrl.Length
     - (DIFF(pRequest->CookedUrl.pAbsPath - pRequest->CookedUrl.pUrl) * sizeof(WCHAR));

    ASSERT(pSearchKey->ExKey.AbsPathLength > 0);
    ASSERT(wcslen(pSearchKey->ExKey.pAbsPath) * sizeof(WCHAR) 
                == pSearchKey->ExKey.AbsPathLength);
        
    pSearchKey->ExKey.Hash = pRequest->CookedUrl.RoutingHash;        
    pSearchKey->ExKey.pToken = pRequest->CookedUrl.pRoutingToken;
    pSearchKey->ExKey.TokenLength = pRequest->CookedUrl.RoutingTokenLength;    

    ASSERT(pSearchKey->ExKey.TokenLength > 0);
    ASSERT(wcslen(pSearchKey->ExKey.pToken) * sizeof(WCHAR) 
                == pSearchKey->ExKey.TokenLength);
}

//
// read stuff into the cache
//

NTSTATUS
UlpBuildCacheEntry(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUL_INTERNAL_RESPONSE pResponse,
    IN PUL_APP_POOL_PROCESS pProcess,
    IN HTTP_CACHE_POLICY CachePolicy,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

VOID
UlpBuildCacheEntryWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UlpRestartCacheMdlRead(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

VOID
UlpCacheMdlReadCompleteWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UlpRestartCacheMdlFree(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

VOID
UlpCompleteCacheBuild(
    IN PUL_CHUNK_TRACKER pTracker,
    IN NTSTATUS Status
    );

VOID
UlpCompleteCacheBuildWorker(
    IN PUL_WORK_ITEM pWorkItem
    );


//
// send cache entry across the wire
//

NTSTATUS
UlpSendCacheEntry(
    PUL_HTTP_CONNECTION pHttpConnection,
    ULONG Flags,
    PUL_URI_CACHE_ENTRY pUriCacheEntry,
    PUL_COMPLETION_ROUTINE pCompletionRoutine,
    PVOID pCompletionContext,
    PUL_LOG_DATA_BUFFER pLogData,
    UL_RESUME_PARSING_TYPE ResumeParsingType
    );

VOID
UlpSendCacheEntryWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpCompleteSendCacheEntry(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpCompleteSendCacheEntry(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpCompleteSendCacheEntryWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

PUL_FULL_TRACKER
UlpAllocateCacheTracker(
    IN CCHAR SendIrpStackSize
    );

VOID
UlpFreeCacheTracker(
    IN PUL_FULL_TRACKER pTracker
    );

VOID
UlReferenceChunkTracker(
    IN PUL_CHUNK_TRACKER pTracker
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

VOID
UlDereferenceChunkTracker(
    IN PUL_CHUNK_TRACKER pTracker
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define UL_REFERENCE_CHUNK_TRACKER( pTracker )                              \
    UlReferenceChunkTracker(                                                \
        (pTracker)                                                          \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

#define UL_DEREFERENCE_CHUNK_TRACKER( pTracker )                            \
    UlDereferenceChunkTracker(                                              \
        (pTracker)                                                          \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

__inline
VOID
UlpQueueResponseWorkItem(
    IN PUL_WORK_ITEM    pWorkItem,
    IN PUL_WORK_ROUTINE pWorkRoutine,
    IN BOOLEAN          SyncItem
    )
{
    if (SyncItem)
    {
        UL_QUEUE_SYNC_ITEM( pWorkItem, pWorkRoutine );
    }
    else
    {
        UL_QUEUE_WORK_ITEM( pWorkItem, pWorkRoutine );
    }
}

#endif // _SENDRESPONSEP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\servinfo.h ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    servinfo.h

Abstract:

    Contains the public definitions for the server information structure.

Author:

    Henry Sanders (henrysa)         10-Aug-2000

Revision History:

--*/

#ifndef _SERVINFO_H_
#define _SERVINFO_H_

//
// Forward references.
//

typedef unsigned char BYTE;
typedef unsigned char *PBYTE;


//
// Private constants.
//

#define SERVER_NAME_BUFFER_SIZE               64
#define UC_DEFAULT_SI_TABLE_SIZE              32
#define UC_DEFAULT_INITIAL_CONNECTION_COUNT   1

//
// Private types.
//

//
// Cloned Security DATA_BLOB
//
typedef struct _HTTP_DATA_BLOB
{
    ULONG  cbData;
    PUCHAR pbData;
} HTTP_DATA_BLOB, *PHTTP_DATA_BLOB;


//
// The structure of the server info table header. The server info table is a
// hash table consisting of an array of these headers, each of which points
// to a linked list of server info structures.
//

typedef struct _UC_SERVER_INFO_TABLE_HEADER
{
    UL_ERESOURCE        Resource;
    LIST_ENTRY          List;
    ULONG               Version;

} UC_SERVER_INFO_TABLE_HEADER, *PUC_SERVER_INFO_TABLE_HEADER;



//
// Public constants
//

#define DEFAULT_MAX_CONNECTION_COUNT        2

//
// Public types                   
//

//
// The structure representing our server information. This contains information
// the the version of the remote server, whether or not pipelining is supported
// to that server, etc. Note that this information is about the final endpoint
// server, not the first hop server (which may be a proxy).
//
typedef struct _UC_COMMON_SERVER_INFORMATION
{
    ULONG                        Signature;
    LONG                         RefCount;
    LIST_ENTRY                   Linkage;
    WCHAR                        ServerNameBuffer[SERVER_NAME_BUFFER_SIZE];
    CHAR                         AnsiServerNameBuffer[SERVER_NAME_BUFFER_SIZE];
    USHORT                       ServerNameLength;
    USHORT                       AnsiServerNameLength;
    PWSTR                        pServerName;
    PSTR                         pAnsiServerName;
    ULONG                        bPortNumber  :1;
    ULONG                        Version11    :1;
    PUC_SERVER_INFO_TABLE_HEADER pHeader;
    PEPROCESS                    pProcess;
} UC_COMMON_SERVER_INFORMATION, *PUC_COMMON_SERVER_INFORMATION;


typedef enum _HTTP_SSL_SERVER_CERT_INFO_STATE
{
    HttpSslServerCertInfoStateNotPresent,
    HttpSslServerCertInfoStateNotValidated,
    HttpSslServerCertInfoStateValidated,

    HttpSslServerCertInfoStateMax
} HTTP_SSL_SERVER_CERT_INFO_STATE, *PHTTP_SSL_SERVER_CEERT_INFO_STATE;

//
// The following structure is used to maintain a per-process Server Information
// structure.  By default, threads of the same process will share this info.
//
// This structure contains a list of connections that we have outstanding to
// the server. There is a default list we use when direct connected, and there
// is also a list of proxies being used to get to the server, each of which
// may itself have a list of connections.
//

typedef struct _UC_PROCESS_SERVER_INFORMATION
{

    //
    // Structure signature.
    //

    ULONG               Signature;

    LIST_ENTRY          Linkage;                // Linkage on free list or
                                                // in server info table.

    PUC_CLIENT_CONNECTION *Connections;         // Connections to server

    ULONG               ActualConnectionCount;  // actual # of elements
                                                // in Connections array

    //
    // Initial array of pointers to connections
    //
    PUC_CLIENT_CONNECTION ConnectionArray[DEFAULT_MAX_CONNECTION_COUNT];

    ULONG               NextConnection;         // index of the next
                                                // connection to be used.

    LONG                RefCount;

    ULONG               CurrentConnectionCount; // Number of connections in
                                                //
    ULONG               MaxConnectionCount;     // Maximum number of 
                                                // connections allowed.

    ULONG               ConnectionTimeout;

    ULONG               IgnoreContinues;        // True if we want to ignore
                                                // 1XX responses 

    BOOLEAN             bSecure;
    BOOLEAN             bProxy;

    UL_PUSH_LOCK        PushLock;               // Push lock protecting this.


    PUC_COMMON_SERVER_INFORMATION pServerInfo; // Info regarding origin server
    PUC_COMMON_SERVER_INFORMATION pNextHopInfo;// Info regarding next hop

    ULONG               GreatestAuthHeaderMaxLength;
    LIST_ENTRY          pAuthListHead;         // List of URIs for pre-auth

    LONG                PreAuthEnable;
    LONG                ProxyPreAuthEnable;

    PUC_HTTP_AUTH       pProxyAuthInfo;


    //
    // This contains the resolved address - Could be either the 
    // server or the proxy address. The resolution is done in user mode, so
    // we don't even know what this is.
    //

    union
    {
        TA_IP_ADDRESS     V4Address;
        TA_IP6_ADDRESS    V6Address;
        TRANSPORT_ADDRESS GenericTransportAddress;
    } RemoteAddress;

    PTRANSPORT_ADDRESS     pTransportAddress;
    ULONG                  TransportAddressLength;

    PEPROCESS           pProcess;

    // Ssl protocol version
    ULONG                           SslProtocolVersion;

    // Ok to access ServerCertValidation without holding lock
    ULONG                           ServerCertValidation;

    HTTP_SSL_SERVER_CERT_INFO_STATE ServerCertInfoState;
    HTTP_SSL_SERVER_CERT_INFO       ServerCertInfo;

    // Client cert
    PVOID                           pClientCert;

} UC_PROCESS_SERVER_INFORMATION, *PUC_PROCESS_SERVER_INFORMATION;

#define UC_PROCESS_SERVER_INFORMATION_SIGNATURE   MAKE_SIGNATURE('UcSp')

#define UC_COMMON_SERVER_INFORMATION_SIGNATURE    MAKE_SIGNATURE('UcSc')


#define IS_VALID_SERVER_INFORMATION(pInfo)                            \
    HAS_VALID_SIGNATURE(pInfo, UC_PROCESS_SERVER_INFORMATION_SIGNATURE)
      

#define REFERENCE_SERVER_INFORMATION(s)             \
            UcReferenceServerInformation(           \
            (s)                                     \
            )
        
#define DEREFERENCE_SERVER_INFORMATION(s)           \
            UcDereferenceServerInformation(         \
            (s)                                     \
            )

#define IS_VALID_COMMON_SERVER_INFORMATION(pInfo)                     \
    HAS_VALID_SIGNATURE(pInfo, UC_COMMON_SERVER_INFORMATION_SIGNATURE)


#define REFERENCE_COMMON_SERVER_INFORMATION(s)    \
            UcReferenceCommonServerInformation(   \
            (s)                                   \
            )

#define DEREFERENCE_COMMON_SERVER_INFORMATION(s)  \
            UcDereferenceCommonServerInformation( \
            (s)                                   \
            )

//
// Add a connection at the specified place in servinfo connections array
//
#define ADD_CONNECTION_TO_SERV_INFO(pServInfo, pConnection, index)            \
do {                                                                          \
    ASSERT(index < pServInfo->MaxConnectionCount);                            \
    ASSERT(pServInfo->Connections[index] == NULL);                            \
                                                                              \
    pConnection->pServerInfo = pServInfo;                                     \
    pConnection->ConnectionIndex = index;                                     \
                                                                              \
    pServInfo->Connections[index] = pConnection;                              \
    pServInfo->CurrentConnectionCount++;                                      \
    ASSERT(pServInfo->CurrentConnectionCount<= pServInfo->MaxConnectionCount);\
} while (0, 0)


//
// Free serialized certificate and serialized cert store.
//

#define UC_FREE_SERIALIZED_CERT(pServerCertInfo, pProcess)                 \
do {                                                                       \
    if ((pServerCertInfo)->Cert.pSerializedCert)                           \
    {                                                                      \
        UL_FREE_POOL_WITH_QUOTA(                                           \
            (pServerCertInfo)->Cert.pSerializedCert,                       \
            UC_SSL_CERT_DATA_POOL_TAG,                                     \
            NonPagedPool,                                                  \
            (pServerCertInfo)->Cert.SerializedCertLength,                  \
            pProcess);                                                     \
                                                                           \
        (pServerCertInfo)->Cert.pSerializedCert = NULL;                    \
        (pServerCertInfo)->Cert.SerializedCertLength = 0;                  \
    }                                                                      \
                                                                           \
    if ((pServerCertInfo)->Cert.pSerializedCertStore)                      \
    {                                                                      \
        UL_FREE_POOL_WITH_QUOTA(                                           \
            (pServerCertInfo)->Cert.pSerializedCertStore,                  \
            UC_SSL_CERT_DATA_POOL_TAG,                                     \
            NonPagedPool,                                                  \
            (pServerCertInfo)->Cert.SerializedCertStoreLength,             \
            pProcess);                                                     \
                                                                           \
        (pServerCertInfo)->Cert.pSerializedCertStore = NULL;               \
        (pServerCertInfo)->Cert.SerializedCertStoreLength = 0;             \
    }                                                                      \
} while (0, 0)


//
// Move serialized certificate and serialized store from a connection to
// a server information.
//

#define UC_MOVE_SERIALIZED_CERT(pServInfo, pConnection)                       \
do {                                                                          \
    PHTTP_SSL_SERVER_CERT_INFO pServerCertInfo = &pConnection->ServerCertInfo;\
                                                                              \
    UC_FREE_SERIALIZED_CERT(&pServInfo->ServerCertInfo, pServInfo->pProcess); \
                                                                              \
    RtlCopyMemory(&pServInfo->ServerCertInfo.Cert,                            \
                  &pServerCertInfo->Cert,                                     \
                  sizeof(HTTP_SSL_SERIALIZED_CERT));                          \
                                                                              \
    pServerCertInfo->Cert.pSerializedCert = NULL;                             \
    pServerCertInfo->Cert.SerializedCertLength = 0;                           \
                                                                              \
    pServerCertInfo->Cert.pSerializedCertStore = NULL;                        \
    pServerCertInfo->Cert.SerializedCertStoreLength = 0;                      \
                                                                              \
} while (0, 0)


//
// Free certificate issuer list.
//

#define UC_FREE_CERT_ISSUER_LIST(pServerCertInfo, pProcess)     \
do {                                                            \
    if ((pServerCertInfo)->IssuerInfo.IssuerListLength)         \
    {                                                           \
        UL_FREE_POOL_WITH_QUOTA(                                \
            (pServerCertInfo)->IssuerInfo.pIssuerList,          \
            UC_SSL_CERT_DATA_POOL_TAG,                          \
            NonPagedPool,                                       \
            (pServerCertInfo)->IssuerInfo.IssuerListLength,     \
            pProcess);                                          \
                                                                \
        (pServerCertInfo)->IssuerInfo.IssuerListLength  = 0;    \
        (pServerCertInfo)->IssuerInfo.IssuerCount       = 0;    \
        (pServerCertInfo)->IssuerInfo.pIssuerList       = NULL; \
    }                                                           \
} while (0, 0)

//
// First copy issuer list if any.
//

#define UC_MOVE_CERT_ISSUER_LIST(pServInfo, pConnection)                 \
do {                                                                     \
    if ((pConnection)->ServerCertInfo.IssuerInfo.IssuerListLength)       \
    {                                                                    \
        /* Free old copy */                                              \
        UC_FREE_CERT_ISSUER_LIST(&(pServInfo)->ServerCertInfo,           \
                                 (pServInfo)->pProcess);                 \
                                                                         \
        /* Get new copy */                                               \
        RtlCopyMemory(&(pServInfo)->ServerCertInfo.IssuerInfo,           \
                      &(pConnection)->ServerCertInfo.IssuerInfo,         \
                      sizeof((pConnection)->ServerCertInfo.IssuerInfo)); \
                                                                         \
        /* Remove it from the connection */                              \
        RtlZeroMemory(&(pConnection)->ServerCertInfo.IssuerInfo,         \
                      sizeof((pConnection)->ServerCertInfo.IssuerInfo)); \
    }                                                                    \
} while (0, 0)


//
// Compare server cert hash on pservinfo and pconnection.
//

#define UC_COMPARE_CERT_HASH(pSCI1, pSCI2)                              \
((pSCI1)->Cert.CertHashLength == (pSCI2)->Cert.CertHashLength &&        \
 (RtlCompareMemory((pSCI1)->Cert.CertHash,                              \
                   (pSCI2)->Cert.CertHash,                              \
                   (pSCI1)->Cert.CertHashLength)                        \
  == (pSCI1)->Cert.CertHashLength))


//
// Indicates if SERVER_CERT_INFO.Cert contains serialized certificate.
//
#define HTTP_SSL_SERIALIZED_CERT_PRESENT 0x00000001


//
// Private prototypes.
//

NTSTATUS
UcpLookupCommonServerInformation(
    PWSTR                          pServerName,
    USHORT                         ServerNameLength,
    ULONG                          CommonHashCode,
    PEPROCESS                      pProcess,
    PUC_COMMON_SERVER_INFORMATION  *pCommonInfo
    );

VOID
UcpFreeServerInformation(
    PUC_PROCESS_SERVER_INFORMATION    pInfo
    );

VOID
UcpFreeCommonServerInformation(
    PUC_COMMON_SERVER_INFORMATION    pInfo
    );

NTSTATUS
UcpGetConnectionOnServInfo(
    IN  PUC_PROCESS_SERVER_INFORMATION pServInfo,
    IN  ULONG                          ConnectionIndex,
    OUT PUC_CLIENT_CONNECTION         *ppConnection
    );

NTSTATUS
UcpGetNextConnectionOnServInfo(
    IN  PUC_PROCESS_SERVER_INFORMATION pServInfo,
    OUT PUC_CLIENT_CONNECTION         *ppConnection
    );

NTSTATUS
UcpSetServInfoMaxConnectionCount(
    IN PUC_PROCESS_SERVER_INFORMATION pServInfo,
    IN ULONG                          NewCount
    );

NTSTATUS
UcpFixupIssuerList(
    IN OUT PUCHAR pIssuerList,
    IN     PUCHAR BaseAddr,
    IN     ULONG  IssuerCount,
    IN     ULONG  IssuerListLength
    );

BOOLEAN
UcpNeedToCaptureSerializedCert(
    IN PHTTP_SSL_SERVER_CERT_INFO     pCertInfo,
    IN PUC_PROCESS_SERVER_INFORMATION pServInfo
    );


//
// Public prototypes                   
//

NTSTATUS
UcInitializeServerInformation(
    VOID
    );

VOID
UcTerminateServerInformation(
    VOID
    );

NTSTATUS
UcCreateServerInformation(
    OUT PUC_PROCESS_SERVER_INFORMATION    *pServerInfo,
    IN  PWSTR                              pServerName,
    IN  USHORT                             ServerNameLength,
    IN  PWSTR                              pProxyName,
    IN  USHORT                             ProxyNameLength,
    IN  PTRANSPORT_ADDRESS                 pTransportAddress,
    IN  USHORT                             TransportAddressLength,
    IN  KPROCESSOR_MODE                    RequestorMode
    );

VOID
UcReferenceServerInformation(
    PUC_PROCESS_SERVER_INFORMATION    pServerInfo
    );
        
VOID
UcDereferenceServerInformation(
    PUC_PROCESS_SERVER_INFORMATION    pServerInfo
    );

VOID
UcReferenceCommonServerInformation(
    PUC_COMMON_SERVER_INFORMATION    pServerInfo
    );
        
VOID
UcDereferenceCommonServerInformation(
    PUC_COMMON_SERVER_INFORMATION    pServerInfo
    );

NTSTATUS
UcSendRequest(
    PUC_PROCESS_SERVER_INFORMATION    pServerInfo,
    PUC_HTTP_REQUEST          pRequest
    );

VOID
UcCloseServerInformation(
    IN PUC_PROCESS_SERVER_INFORMATION pServInfo
    );

NTSTATUS
UcSetServerContextInformation(
    IN PUC_PROCESS_SERVER_INFORMATION pServInfo,
    IN HTTP_SERVER_CONFIG_ID          ConfigID,
    IN PVOID                          pMdlBuffer,
    IN ULONG                          BufferLength,
    IN PIRP                           pIrp
    );

NTSTATUS
UcQueryServerContextInformation(
    IN  PUC_PROCESS_SERVER_INFORMATION   pServInfo,
    IN  HTTP_SERVER_CONFIG_ID            ConfigID,
    IN  PVOID                            pOutBuffer,
    IN  ULONG                            OutBufferLength,
    OUT PULONG                           pBytesTaken,
    IN  PVOID                            pAppBase
    );

NTSTATUS
UcCaptureSslServerCertInfo(
    IN  PUX_FILTER_CONNECTION      pConnection,
    IN  PHTTP_SSL_SERVER_CERT_INFO pCertInfo,
    IN  ULONG                      CertInfoLength,
    OUT PHTTP_SSL_SERVER_CERT_INFO pCopyCertInfo,
    OUT PULONG                     pTakenLength
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\sendresponse.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    sendresponse.c

Abstract:

    This module implements the UlSendHttpResponse() API.

    CODEWORK: The current implementation is not super performant.
    Specifically, it ends up allocating & freeing a ton of IRPs to send
    a response. There are a number of optimizations that need to be made
    to this code:

        1.  Coalesce contiguious from-memory chunks and send them
            with a single TCP send.

        2.  Defer sending the from-memory chunks until either

                a)  We reach the end of the response

                b)  We reach a from-file chunk, have read the
                    (first?) block of data from the file,
                    and are ready to send the first block. Also,
                    after that last (only?) file block is read and
                    subsequent from-memory chunks exist in the response,
                    we can attach the from-memory chunks before sending.

            The end result of these optimizations is that, for the
            common case (one or more from-memory chunks containing
            response headers, followed by one from-file chunk containing
            static file data, followed by zero or more from-memory chunks
            containing footer data) the response can be sent with a single
            TCP send. This is a Good Thing.

        3.  Build a small "IRP pool" in the send tracker structure,
            then use this pool for all IRP allocations. This will
            require a bit of work to determine the maximum IRP stack
            size needed.

        4.  Likewise, build a small "MDL pool" for the MDLs that need
            to be created for the various MDL chains. Keep in mind that
            we cannot chain the MDLs that come directly from the captured
            response structure, nor can we chain the MDLs that come back
            from the file system. In both cases, these MDLs are considered
            "shared resources" and we're not allowed to modify them. We
            can, however, "clone" the MDLs and chain the cloned MDLs
            together. We'll need to run some experiments to determine
            if the overhead for cloning a MDL is worth the effort. I
            strongly suspect it will be.

Author:

    Keith Moore (keithmo)       07-Aug-1998

Revision History:

    Paul McDaniel (paulmcd)     15-Mar-1999     Modified to handle
                                                multiple sends

    Michael Courage (mcourage)  15-Jun-1999     Integrated cache functionality

    Chun Ye (chunye)            08-Jun-2002     Implemented split send

--*/

#include "precomp.h"
#include "sendresponsep.h"


//
// Private globals.
//


ULONGLONG g_UlTotalSendBytes = 0;
UL_EXCLUSIVE_LOCK g_UlTotalSendBytesExLock = UL_EX_LOCK_FREE;


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, UlCaptureHttpResponse )
#pragma alloc_text( PAGE, UlCaptureUserLogData )
#pragma alloc_text( PAGE, UlPrepareHttpResponse )
#pragma alloc_text( PAGE, UlCleanupHttpResponse )
#pragma alloc_text( PAGE, UlAllocateLockedMdl )
#pragma alloc_text( PAGE, UlInitializeAndLockMdl )
#pragma alloc_text( PAGE, UlSendCachedResponse )
#pragma alloc_text( PAGE, UlCacheAndSendResponse )

#pragma alloc_text( PAGE, UlpEnqueueSendHttpResponse )
#pragma alloc_text( PAGE, UlpDequeueSendHttpResponse )
#pragma alloc_text( PAGE, UlpSendHttpResponseWorker )
#pragma alloc_text( PAGE, UlpMdlSendCompleteWorker )
#pragma alloc_text( PAGE, UlpMdlReadCompleteWorker )
#pragma alloc_text( PAGE, UlpCacheMdlReadCompleteWorker )
#pragma alloc_text( PAGE, UlpFlushMdlRuns )
#pragma alloc_text( PAGE, UlpFreeMdlRuns )
#pragma alloc_text( PAGE, UlpCopySend )
#pragma alloc_text( PAGE, UlpBuildCacheEntry )
#pragma alloc_text( PAGE, UlpBuildCacheEntryWorker )
#pragma alloc_text( PAGE, UlpCompleteCacheBuildWorker )
#pragma alloc_text( PAGE, UlpSendCacheEntry )
#pragma alloc_text( PAGE, UlpSendCacheEntryWorker )
#pragma alloc_text( PAGE, UlpAllocateCacheTracker )
#pragma alloc_text( PAGE, UlpFreeCacheTracker )
#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlSendHttpResponse
NOT PAGEABLE -- UlReferenceHttpResponse
NOT PAGEABLE -- UlDereferenceHttpResponse
NOT PAGEABLE -- UlFreeLockedMdl
NOT PAGEABLE -- UlCompleteSendResponse
NOT PAGEABLE -- UlSetRequestSendsPending
NOT PAGEABLE -- UlUnsetRequestSendsPending

NOT PAGEABLE -- UlpDestroyCapturedResponse
NOT PAGEABLE -- UlpAllocateChunkTracker
NOT PAGEABLE -- UlpFreeChunkTracker
NOT PAGEABLE -- UlpRestartMdlRead
NOT PAGEABLE -- UlpRestartMdlSend
NOT PAGEABLE -- UlpRestartCopySend
NOT PAGEABLE -- UlpIncrementChunkPointer
NOT PAGEABLE -- UlpRestartCacheMdlRead
NOT PAGEABLE -- UlpRestartCacheMdlFree
NOT PAGEABLE -- UlpIssueFileChunkIo
NOT PAGEABLE -- UlpCompleteCacheBuild
NOT PAGEABLE -- UlpCompleteSendCacheEntry
NOT PAGEABLE -- UlpCompleteSendResponseWorker
NOT PAGEABLE -- UlpCompleteSendCacheEntryWorker
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Sends an HTTP response on the specified connection.

Arguments:

    pConnection - Supplies the HTTP_CONNECTION to send the response on.

    pResponse - Supplies the HTTP response.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the send has completed.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlSendHttpResponse(
    IN PUL_INTERNAL_REQUEST     pRequest,
    IN PUL_INTERNAL_RESPONSE    pResponse,
    IN PUL_COMPLETION_ROUTINE   pCompletionRoutine,
    IN PVOID                    pCompletionContext
    )
{
    NTSTATUS                    Status;
    PUL_CHUNK_TRACKER           pTracker;
    PUL_HTTP_CONNECTION         pHttpConn;
    UL_CONN_HDR                 ConnHeader;
    BOOLEAN                     Disconnect;
    ULONG                       VarHeaderGenerated;
    ULONGLONG                   TotalResponseSize;
    ULONG                       ContentLengthStringLength;
    UCHAR                       ContentLength[MAX_ULONGLONG_STR];
    ULONG                       Flags = pResponse->Flags;

    //
    // Sanity check.
    //

    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pRequest ) );
    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pResponse ) );

    pHttpConn = pRequest->pHttpConn;
    ASSERT( UL_IS_VALID_HTTP_CONNECTION( pHttpConn ) );

    TRACE_TIME(
        pRequest->ConnectionId,
        pRequest->RequestId,
        TIME_ACTION_SEND_RESPONSE
        );

    if (Flags & (~HTTP_SEND_RESPONSE_FLAG_VALID))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Setup locals so we know how to cleanup on exit.
    //

    pTracker = NULL;

    //
    // Should we close the connection?
    //

    if ((Flags & HTTP_SEND_RESPONSE_FLAG_DISCONNECT))
    {
        //
        // Caller is forcing a disconnect.
        //

        Disconnect = TRUE;
    }
    else
    {
        Disconnect = UlCheckDisconnectInfo( pRequest );

        if (0 == (Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA))
        {
            //
            // No more data is coming, should we disconnect?
            //

            if (Disconnect)
            {
                Flags |= HTTP_SEND_RESPONSE_FLAG_DISCONNECT;
                pResponse->Flags = Flags;
            }
        }
    }

    //
    // How big is the response?
    //

    TotalResponseSize = pResponse->ResponseLength;

    //
    // Generate the Content-Length header if we meet the following conditions:
    // 1. This is a response (not entity body).
    // 2. The app didn't provide Content-Length.
    // 3. The app didn't generate a chunked response.
    //

    if (pResponse->HeaderLength > 0 &&
        !pResponse->ContentLengthSpecified &&
        !pResponse->ChunkedSpecified &&
        UlNeedToGenerateContentLength(
            pRequest->Verb,
            pResponse->StatusCode,
            Flags
            ))
    {
        //
        // Autogenerate a Content-Length header.
        //

        PCHAR pEnd = UlStrPrintUlonglong(
                            (PCHAR) ContentLength,
                            pResponse->ResponseLength - pResponse->HeaderLength,
                            ANSI_NULL
                            );
        ContentLengthStringLength = DIFF(pEnd - (PCHAR) ContentLength);
    }
    else
    {
        //
        // Either we cannot or do not need to autogenerate a
        // Content-Length header.
        //

        ContentLength[0] = ANSI_NULL;
        ContentLengthStringLength = 0;
    }

    //
    // See if user explicitly wants Connection: header removed, or we will
    // choose one for them.
    //

    if (ConnHdrNone == pResponse->ConnHeader)
    {
        ConnHeader = pResponse->ConnHeader;
    }
    else
    {
        ConnHeader = UlChooseConnectionHeader( pRequest->Version, Disconnect );
    }

    //
    // Completion info.
    //

    pResponse->pCompletionRoutine = pCompletionRoutine;
    pResponse->pCompletionContext = pCompletionContext;

    //
    // Allocate and initialize a tracker for this response.
    //

    pTracker =
        UlpAllocateChunkTracker(
            UlTrackerTypeSend,
            pHttpConn->pConnection->ConnectionObject.pDeviceObject->StackSize,
            pResponse->MaxFileSystemStackSize,
            TRUE,
            pHttpConn,
            pResponse
            );

    if (pTracker == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    //
    // Initialize the first chunk and MDL_RUN for the send.
    //

    UlpIncrementChunkPointer( pResponse );

    //
    // Generate var headers, and init the second chunk.
    //

    if (pResponse->HeaderLength)
    {
        UlGenerateVariableHeaders(
            ConnHeader,
            pResponse->GenDateHeader,
            ContentLength,
            ContentLengthStringLength,
            pResponse->pVariableHeader,
            &VarHeaderGenerated,
            &pResponse->CreationTime
            );

        ASSERT( VarHeaderGenerated <= g_UlMaxVariableHeaderSize );

        pResponse->VariableHeaderLength = VarHeaderGenerated;

        //
        // Increment total size.
        //

        TotalResponseSize += VarHeaderGenerated;

        //
        // Build a MDL for it.
        //

        pResponse->pDataChunks[1].ChunkType = HttpDataChunkFromMemory;
        pResponse->pDataChunks[1].FromMemory.BufferLength = VarHeaderGenerated;

        pResponse->pDataChunks[1].FromMemory.pMdl =
            UlAllocateMdl(
                pResponse->pVariableHeader, // VirtualAddress
                VarHeaderGenerated,         // Length
                FALSE,                      // SecondaryBuffer
                FALSE,                      // ChargeQuota
                NULL                        // Irp
                );

        if (pResponse->pDataChunks[1].FromMemory.pMdl == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        MmBuildMdlForNonPagedPool( pResponse->pDataChunks[1].FromMemory.pMdl );
    }

    UlTrace(SEND_RESPONSE, (
        "UlSendHttpResponse: tracker %p, response %p\n",
        pTracker,
        pResponse
        ));

    //
    // Adjust SendsPending and while holding the lock, transfer the
    // ownership of pLogData and ResumeParsing information from
    // pResponse to pRequest.
    //

    UlSetRequestSendsPending(
        pRequest,
        &pResponse->pLogData,
        &pResponse->ResumeParsingType
        );

    //
    // Start MinBytesPerSecond timer, since we now know TotalResponseSize.
    //

    UlSetMinBytesPerSecondTimer(
        &pHttpConn->TimeoutInfo,
        TotalResponseSize
        );

    if (ETW_LOG_MIN() && (0 == (Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA)))
    {
        UlEtwTraceEvent(
            &UlTransGuid,
            ETW_TYPE_END,
            (PVOID) &pTracker->pResponse->pRequest->RequestIdCopy,
            sizeof(HTTP_REQUEST_ID),
            (PVOID) &pResponse->StatusCode,
            sizeof(USHORT),
            NULL,
            0
            );
    }

    //
    // Queue the response to the request's pending response list or start
    // processing the send right away if no other sends are pending. As an
    // optimization, we can call UlpSendHttpResponseWorker directly without
    // applying the queuing logic if no send is pending, if this is from an
    // IOCTL and all of the response's data chunks are FromMemory, in which
    // case we are guaranteed that returning from the current routine will
    // have all the send data pended in TDI.
    //

    if (pRequest->SendInProgress ||
        pResponse->MaxFileSystemStackSize ||
        pResponse->FromKernelMode)
    {
        pResponse->SendEnqueued = TRUE;
        UlpEnqueueSendHttpResponse( pTracker, pResponse->FromKernelMode );
    }
    else
    {
        pResponse->SendEnqueued = FALSE;
        UlpSendHttpResponseWorker( &pTracker->WorkItem );
    }

    return STATUS_PENDING;

cleanup:

    UlTrace(SEND_RESPONSE, (
        "UlSendHttpResponse: failure %08lx\n",
        Status
        ));

    ASSERT( !NT_SUCCESS( Status ) );

    if (pTracker != NULL)
    {
        //
        // Very early termination for the chunk tracker. RefCounting not
        // even started yet. ( Means UlpSendHttpResponseWorker hasn't been
        // called ). Therefore straight cleanup.
        //

        ASSERT( pTracker->RefCount == 1 );

        UlpFreeChunkTracker( &pTracker->WorkItem );
    }

    return Status;

}   // UlSendHttpResponse


/***************************************************************************++

Routine Description:

    Captures a user-mode HTTP response and morphs it into a form suitable
    for kernel-mode.

Arguments:

    pUserResponse - Supplies the user-mode HTTP response.

    Flags - Supplies zero or more UL_CAPTURE_* flags.

    pStatusCode - Receives the captured HTTP status code.

    pKernelResponse - Receives the captured response if successful.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCaptureHttpResponse(
    IN PUL_APP_POOL_PROCESS     pProcess OPTIONAL,
    IN PHTTP_RESPONSE           pUserResponse OPTIONAL,
    IN PUL_INTERNAL_REQUEST     pRequest,
    IN USHORT                   ChunkCount,
    IN PHTTP_DATA_CHUNK         pUserDataChunks,
    IN UL_CAPTURE_FLAGS         Flags,
    IN ULONG                    SendFlags,
    IN BOOLEAN                  CaptureCache,
    IN PHTTP_LOG_FIELDS_DATA    pUserLogData OPTIONAL,
    OUT PUSHORT                 pStatusCode,
    OUT PUL_INTERNAL_RESPONSE   *ppKernelResponse
    )
{
    ULONG                       i;
    NTSTATUS                    Status = STATUS_SUCCESS;
    PUL_INTERNAL_RESPONSE       pKeResponse = NULL;
    PUL_HTTP_CONNECTION         pHttpConn;
    ULONG                       AuxBufferLength;
    ULONG                       CopiedBufferLength;
    ULONG                       UncopiedBufferLength;
    PUCHAR                      pBuffer;
    ULONG                       HeaderLength;
    ULONG                       VariableHeaderLength = 0;
    ULONG                       SpaceLength;
    PUL_INTERNAL_DATA_CHUNK     pKeDataChunks;
    BOOLEAN                     FromKernelMode;
    BOOLEAN                     FromLookaside;
    ULONG                       KernelChunkCount;
    HTTP_KNOWN_HEADER           ETagHeader = { 0, NULL };
    HTTP_KNOWN_HEADER           ContentEncodingHeader = { 0, NULL };
    KPROCESSOR_MODE             RequestorMode;
    HTTP_VERSION                Version;
    HTTP_VERB                   Verb;
    PHTTP_KNOWN_HEADER          pKnownHeaders;
    USHORT                      RawValueLength;
    PCSTR                       pRawValue;
    UNICODE_STRING              KernelFragmentName;
    UNICODE_STRING              UserFragmentName;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pRequest ) );
    ASSERT( pUserDataChunks != NULL || ChunkCount == 0 );
    ASSERT( ppKernelResponse != NULL );

    Version = pRequest->Version;
    Verb = pRequest->Verb;
    pHttpConn = pRequest->pHttpConn;

    __try
    {
        FromKernelMode =
            (BOOLEAN) ((Flags & UlCaptureKernelMode) == UlCaptureKernelMode);

        if (ChunkCount >= UL_MAX_CHUNKS)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        if (FromKernelMode)
        {
            RequestorMode = (KPROCESSOR_MODE) KernelMode;
        }
        else
        {
            RequestorMode = (KPROCESSOR_MODE) UserMode;
        }

        if (pUserResponse)
        {
            UlProbeForRead(
                pUserResponse,
                sizeof(HTTP_RESPONSE),
                sizeof(PVOID),
                RequestorMode
                );

            //
            // Remember the HTTP status code for ETW tracing.
            //

            if (pStatusCode)
            {
                *pStatusCode = pUserResponse->StatusCode;
            }
        }

        //
        // ProbeForRead every buffer we will access.
        //

        Status = UlpProbeHttpResponse(
                        pUserResponse,
                        ChunkCount,
                        pUserDataChunks,
                        Flags,
                        pUserLogData,
                        RequestorMode
                        );

        if (!NT_SUCCESS(Status))
        {
            goto end;
        }

        //
        // Figure out how much memory we need.
        //

        Status = UlComputeFixedHeaderSize(
                        Version,
                        pUserResponse,
                        RequestorMode,
                        &HeaderLength
                        );

        if (!NT_SUCCESS(Status))
        {
            goto end;
        }

        //
        // Allocate space for variable headers with fixed headers.
        //

        if (HeaderLength)
        {
            VariableHeaderLength = g_UlMaxVariableHeaderSize;
        }

        UlpComputeChunkBufferSizes(
            ChunkCount,
            pUserDataChunks,
            Flags,
            &AuxBufferLength,
            &CopiedBufferLength,
            &UncopiedBufferLength
            );

        UlTrace(SEND_RESPONSE, (
            "Http!UlCaptureHttpResponse(pUserResponse = %p) "
            "    ChunkCount             = %d\n"
            "    Flags                  = 0x%x\n"
            "    AuxBufferLength        = 0x%x\n"
            "    UncopiedBufferLength   = 0x%x\n",
            pUserResponse,
            ChunkCount,
            Flags,
            AuxBufferLength,
            UncopiedBufferLength
            ));

        //
        // Add two extra chunks for the headers (fixed & variable).
        //

        if (HeaderLength > 0)
        {
            KernelChunkCount = ChunkCount + HEADER_CHUNK_COUNT;
        }
        else
        {
            KernelChunkCount = ChunkCount;
        }

        //
        // Compute the space needed for all of our structures.
        //

        SpaceLength = (KernelChunkCount * sizeof(UL_INTERNAL_DATA_CHUNK))
                        + ALIGN_UP(HeaderLength, sizeof(CHAR))
                        + ALIGN_UP(VariableHeaderLength, sizeof(CHAR))
                        + AuxBufferLength;

        //
        // Add space for ETag and Content-Encoding if it exists, including space 
        // for ANSI_NULL.
        //

        if (CaptureCache && pUserResponse)
        {
            ETagHeader = pUserResponse->Headers.KnownHeaders[HttpHeaderEtag];

            if (ETagHeader.RawValueLength)
            {
                SpaceLength += (ETagHeader.RawValueLength + sizeof(CHAR));

                UlProbeAnsiString(
                    ETagHeader.pRawValue,
                    ETagHeader.RawValueLength,
                    RequestorMode
                    );

                UlTrace(SEND_RESPONSE, (
                    "http!UlCaptureHttpResponse(pUserResponse = %p)\n"
                    "    ETag: %s\n"
                    "    Length: %d\n",
                    pUserResponse,
                    ETagHeader.pRawValue,
                    ETagHeader.RawValueLength
                    ));
            }

            ContentEncodingHeader = 
               pUserResponse->Headers.KnownHeaders[HttpHeaderContentEncoding];

            if (ContentEncodingHeader.RawValueLength)
            {
                SpaceLength += (ContentEncodingHeader.RawValueLength +
                                sizeof(CHAR));

                UlProbeAnsiString(
                    ContentEncodingHeader.pRawValue,
                    ContentEncodingHeader.RawValueLength,
                    RequestorMode
                    );

                //
                // FUTURE: if the app sets the content encoding to "identity", 
                // treat it as empty.
                //
               
                UlTrace(SEND_RESPONSE, (
                    "http!UlCaptureHttpResponse(pUserResponse = %p)\n"
                    "    ContentEncoding: %s\n"
                    "    Length: %d\n",
                    pUserResponse,
                    ContentEncodingHeader.pRawValue,
                    ContentEncodingHeader.RawValueLength
                    ));
            }
        }

        //
        // Allocate the internal response.
        //

        if (pUserResponse &&
            g_UlResponseBufferSize >=
                (ALIGN_UP(sizeof(UL_INTERNAL_RESPONSE), PVOID) + SpaceLength))
        {
            pKeResponse = UlPplAllocateResponseBuffer();
            FromLookaside = TRUE;
        }
        else
        {
            pKeResponse = UL_ALLOCATE_STRUCT_WITH_SPACE(
                NonPagedPool,
                UL_INTERNAL_RESPONSE,
                SpaceLength,
                UL_INTERNAL_RESPONSE_POOL_TAG
                );
            FromLookaside = FALSE;
        }

        if (pKeResponse == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }

        //
        // Initialize the fixed fields in the response.
        //

        pKeResponse->FromLookaside = FromLookaside;

        pKeResponse->Signature = UL_INTERNAL_RESPONSE_POOL_TAG;
        pKeResponse->ReferenceCount = 1;
        pKeResponse->ChunkCount = KernelChunkCount;

        //
        // Note that we set the current chunk to just *before* the first
        // chunk, then call the increment function. This allows us to go
        // through the common increment/update path.
        //

        pKeResponse->CurrentChunk = ULONG_MAX;
        pKeResponse->FileOffset.QuadPart = 0;
        pKeResponse->FileBytesRemaining.QuadPart = 0;

        RtlZeroMemory(
            pKeResponse->pDataChunks,
            sizeof(UL_INTERNAL_DATA_CHUNK) * KernelChunkCount
            );

        UL_REFERENCE_INTERNAL_REQUEST( pRequest );
        pKeResponse->pRequest = pRequest;

        pKeResponse->Flags = SendFlags;
        pKeResponse->SyncRead = FALSE;
        pKeResponse->ContentLengthSpecified = FALSE;
        pKeResponse->ChunkedSpecified = FALSE;
        pKeResponse->CopySend = FALSE;
        pKeResponse->ResponseLength = 0;
        pKeResponse->FromMemoryLength = 0;
        pKeResponse->BytesTransferred = 0;
        pKeResponse->IoStatus.Status = STATUS_SUCCESS;
        pKeResponse->IoStatus.Information = 0;
        pKeResponse->pIrp = NULL;
        pKeResponse->StatusCode = 0;
        pKeResponse->FromKernelMode = FromKernelMode;
        pKeResponse->MaxFileSystemStackSize = 0;
        pKeResponse->CreationTime.QuadPart = 0;
        pKeResponse->ETagLength = 0;
        pKeResponse->pETag = NULL;
        pKeResponse->pContentEncoding = NULL;
        pKeResponse->ContentEncodingLength = 0;
        pKeResponse->GenDateHeader = TRUE;
        pKeResponse->ConnHeader = ConnHdrKeepAlive;
        pKeResponse->pLogData = NULL;
        pKeResponse->pCompletionRoutine = NULL;
        pKeResponse->pCompletionContext = NULL;

        UlInitializePushLock(
            &pKeResponse->PushLock,
            "UL_INTERNAL_RESPONSE[%p].PushLock",
            pKeResponse,
            UL_INTERNAL_RESPONSE_PUSHLOCK_TAG
            );

        //
        // Decide whether we need to resume parsing and how. Ideally
        // if we have seen the last response, we should be able to
        // resume parsing right away after the send but before the
        // send completion. When requests are pipelined, this arrangement
        // alleviates the problem of delayed-ACK of 200ms when an odd numbers
        // of TCP frames are sent. The logic is disabled if we have reached
        // the limit of concurrent outstanding pipelined requests we allow.
        //

        if (0 == (SendFlags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA))
        {
            if (pHttpConn->PipelinedRequests < g_UlMaxPipelinedRequests &&
                0 == pRequest->ContentLength &&
                0 == pRequest->Chunked)
            {
                pKeResponse->ResumeParsingType = UlResumeParsingOnLastSend;
            }
            else
            {
                pKeResponse->ResumeParsingType = UlResumeParsingOnSendCompletion;
            }
        }
        else
        {
            pKeResponse->ResumeParsingType = UlResumeParsingNone;
        }

        RtlZeroMemory(
            &pKeResponse->ContentType,
            sizeof(UL_CONTENT_TYPE)
            );

        //
        // Point to the header buffer space.
        //

        pKeResponse->HeaderLength = HeaderLength;
        pKeResponse->pHeaders = (PUCHAR)
            (pKeResponse->pDataChunks + pKeResponse->ChunkCount);

        //
        // And the variable header buffer space.
        //

        pKeResponse->VariableHeaderLength = VariableHeaderLength;
        pKeResponse->pVariableHeader = pKeResponse->pHeaders + HeaderLength;

        //
        // And the aux buffer space.
        //

        pKeResponse->AuxBufferLength = AuxBufferLength;
        pKeResponse->pAuxiliaryBuffer = (PVOID)
            (pKeResponse->pHeaders + HeaderLength + VariableHeaderLength);

        //
        // And the ETag and Content-Encoding buffer space plus the ANSI_NULLs.
        //

        if (ETagHeader.RawValueLength)
        {
            pKeResponse->ETagLength = ETagHeader.RawValueLength + sizeof(CHAR);
            pKeResponse->pETag = (PUCHAR) pKeResponse->pAuxiliaryBuffer +
                AuxBufferLength;
        }

        if (ContentEncodingHeader.RawValueLength)
        {
            pKeResponse->ContentEncodingLength = 
                (ContentEncodingHeader.RawValueLength + sizeof(CHAR));
            pKeResponse->pContentEncoding = 
                (PUCHAR) pKeResponse->pAuxiliaryBuffer + 
                AuxBufferLength +
                pKeResponse->ETagLength ;
        }

        //
        // Remember if a Content-Length header was specified.
        //

        if (pUserResponse != NULL)
        {
            pKeResponse->Verb = Verb;
            pKeResponse->StatusCode = pUserResponse->StatusCode;

            if (pKeResponse->StatusCode > UL_MAX_HTTP_STATUS_CODE)
            {
                ExRaiseStatus( STATUS_INVALID_PARAMETER );
            }

            pKnownHeaders = pUserResponse->Headers.KnownHeaders;

            //
            // If the response explicitly deletes the Connection: header,
            // make sure we DON'T generate it.
            //

            RawValueLength = pKnownHeaders[HttpHeaderConnection].RawValueLength;
            pRawValue = pKnownHeaders[HttpHeaderConnection].pRawValue;

            if (0 == RawValueLength && NULL != pRawValue)
            {
                UlProbeAnsiString(
                    pRawValue,
                    sizeof(ANSI_NULL),
                    RequestorMode
                    );

                if (ANSI_NULL == pRawValue[0])
                {
                    pKeResponse->ConnHeader = ConnHdrNone;
                }
            }

            //
            // Decide if we need to generate a Date: header.
            //

            RawValueLength = pKnownHeaders[HttpHeaderDate].RawValueLength;
            pRawValue = pKnownHeaders[HttpHeaderDate].pRawValue;

            if (0 == RawValueLength && NULL != pRawValue)
            {
                UlProbeAnsiString(
                    pRawValue,
                    sizeof(ANSI_NULL),
                    RequestorMode
                    );

                //
                // Only permit non-generation in the "delete" case.
                //

                if (ANSI_NULL == pRawValue[0])
                {
                    pKeResponse->GenDateHeader = FALSE;
                }
            }
            else
            {
                pKeResponse->GenDateHeader = TRUE;
            }

            if (pKnownHeaders[HttpHeaderContentLength].RawValueLength > 0)
            {
                pKeResponse->ContentLengthSpecified = TRUE;
            }

            //
            // As long as we're here, also remember if "Chunked"
            // Transfer-Encoding was specified.
            //

            if (UlpIsChunkSpecified(pKnownHeaders, RequestorMode))
            {
                //
                // NOTE: If a response has a chunked Transfer-Encoding,
                // then it shouldn't have a Content-Length
                //

                if (pKeResponse->ContentLengthSpecified)
                {
                    ExRaiseStatus( STATUS_INVALID_PARAMETER );
                }

                pKeResponse->ChunkedSpecified = TRUE;
            }

            //
            // Only capture the following if we're building a cached response.
            //

            if (CaptureCache)
            {
                //
                // Capture the ETag and put it on the UL_INTERNAL_RESPONSE.
                //

                if (ETagHeader.RawValueLength)
                {
                    //
                    // NOTE: Already probed above
                    //
                    
                    RtlCopyMemory(
                        pKeResponse->pETag,        // Dest
                        ETagHeader.pRawValue,      // Src
                        ETagHeader.RawValueLength  // Bytes
                        );

                    //
                    // Add NULL termination.
                    //

                    pKeResponse->pETag[ETagHeader.RawValueLength] = ANSI_NULL;
                }

                //
                // Capture the ContentType and put it on the
                // UL_INTERNAL_RESPONSE.
                //

                pRawValue = pKnownHeaders[HttpHeaderContentType].pRawValue;
                RawValueLength =
                    pKnownHeaders[HttpHeaderContentType].RawValueLength;

                if (RawValueLength > 0)
                {
                    UlProbeAnsiString(
                        pRawValue,
                        RawValueLength,
                        RequestorMode
                        );

                    UlGetTypeAndSubType(
                        pRawValue,
                        RawValueLength,
                        &pKeResponse->ContentType
                        );

                    UlTrace(SEND_RESPONSE, (
                        "http!UlCaptureHttpResponse(pUserResponse = %p) \n"
                        "    Content Type: %s \n"
                        "    Content SubType: %s\n",
                        pUserResponse,
                        (pKeResponse->ContentType.Type ? 
                           pKeResponse->ContentType.Type : (PUCHAR)"<none>"),
                        (pKeResponse->ContentType.SubType ?
                           pKeResponse->ContentType.SubType : (PUCHAR)"<none>")
                        ));
                }

                //
                // Capture the Content-Encoding
                //

                if (ContentEncodingHeader.RawValueLength)
                {
                    //
                    // NOTE: Already probed above
                    //
                    
                    RtlCopyMemory(
                        pKeResponse->pContentEncoding,       // Dest
                        ContentEncodingHeader.pRawValue,     // Src
                        ContentEncodingHeader.RawValueLength // Bytes
                        );

                    //
                    // Add NULL termination.
                    //

                    pKeResponse->pContentEncoding[
                        ContentEncodingHeader.RawValueLength] = ANSI_NULL;
                }

                //
                // Capture the Last-Modified time (if it exists).
                //

                pRawValue = pKnownHeaders[HttpHeaderLastModified].pRawValue;
                RawValueLength =
                    pKnownHeaders[HttpHeaderLastModified].RawValueLength;

                if (RawValueLength)
                {
                    UlProbeAnsiString(
                        pRawValue,
                        RawValueLength,
                        RequestorMode
                        );

                    if (!StringTimeToSystemTime(
                            pRawValue,
                            RawValueLength,
                            &pKeResponse->CreationTime
                            ))
                    {
                        ExRaiseStatus( STATUS_INVALID_PARAMETER );
                    }
                }
                else
                {
                    KeQuerySystemTime( &pKeResponse->CreationTime );
                }
            }
        }

        //
        // Copy the aux bytes from the chunks.
        //

        pBuffer = (PUCHAR) pKeResponse->pAuxiliaryBuffer;

        //
        // Skip the header chunks.
        //

        if (pKeResponse->HeaderLength > 0)
        {
            pKeDataChunks = pKeResponse->pDataChunks + HEADER_CHUNK_COUNT;
        }
        else
        {
            pKeDataChunks = pKeResponse->pDataChunks;
        }

        for (i = 0 ; i < ChunkCount ; i++)
        {
            pKeDataChunks[i].ChunkType = pUserDataChunks[i].DataChunkType;

            switch (pUserDataChunks[i].DataChunkType)
            {
            case HttpDataChunkFromMemory:

                //
                // From-memory chunk. If the caller wants us to copy
                // the data (or if its relatively small), then do it
                // We allocate space for all of the copied data and any
                // filename buffers. Otherwise (it's OK to just lock
                // down the data), then allocate a MDL describing the
                // user's buffer and lock it down. Note that
                // MmProbeAndLockPages() and MmLockPagesSpecifyCache()
                // will raise exceptions if they fail.
                //

                pKeResponse->FromMemoryLength +=
                        pUserDataChunks[i].FromMemory.BufferLength;

                pKeDataChunks[i].FromMemory.pCopiedBuffer = NULL;

                if ((Flags & UlCaptureCopyData) ||
                    pUserDataChunks[i].FromMemory.BufferLength
                        <= g_UlMaxCopyThreshold)
                {
                    ASSERT(pKeResponse->AuxBufferLength > 0);

                    pKeDataChunks[i].FromMemory.pUserBuffer =
                        pUserDataChunks[i].FromMemory.pBuffer;

                    pKeDataChunks[i].FromMemory.BufferLength =
                        pUserDataChunks[i].FromMemory.BufferLength;

                    RtlCopyMemory(
                        pBuffer,
                        pKeDataChunks[i].FromMemory.pUserBuffer,
                        pKeDataChunks[i].FromMemory.BufferLength
                        );

                    pKeDataChunks[i].FromMemory.pCopiedBuffer = pBuffer;
                    pBuffer += pKeDataChunks[i].FromMemory.BufferLength;

                    //
                    // Allocate a new MDL describing our new location
                    // in the auxiliary buffer, then build the MDL
                    // to properly describe nonpaged pool.
                    //

                    pKeDataChunks[i].FromMemory.pMdl =
                        UlAllocateMdl(
                            pKeDataChunks[i].FromMemory.pCopiedBuffer,
                            pKeDataChunks[i].FromMemory.BufferLength,
                            FALSE,
                            FALSE,
                            NULL
                            );

                    if (pKeDataChunks[i].FromMemory.pMdl == NULL)
                    {
                        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                        break;
                    }

                    MmBuildMdlForNonPagedPool(
                        pKeDataChunks[i].FromMemory.pMdl
                        );
                }
                else
                {
                    //
                    // Build a MDL describing the user's buffer.
                    //

                    pKeDataChunks[i].FromMemory.BufferLength =
                        pUserDataChunks[i].FromMemory.BufferLength;

                    pKeDataChunks[i].FromMemory.pMdl =
                        UlAllocateMdl(
                            pUserDataChunks[i].FromMemory.pBuffer,
                            pUserDataChunks[i].FromMemory.BufferLength,
                            FALSE,
                            FALSE,
                            NULL
                            );

                    if (pKeDataChunks[i].FromMemory.pMdl == NULL)
                    {
                        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                        break;
                    }

                    //
                    // Lock it down.
                    //

                    MmProbeAndLockPages(
                        pKeDataChunks[i].FromMemory.pMdl,   // MDL
                        UserMode,                           // AccessMode
                        IoReadAccess                        // Operation
                        );

                    if (CaptureCache)
                    {
                        MmMapLockedPagesSpecifyCache(
                            pKeDataChunks[i].FromMemory.pMdl,
                            KernelMode,
                            MmCached,
                            NULL,
                            FALSE,
                            LowPagePriority
                        );
                    }
                }

                break;

            case HttpDataChunkFromFileHandle:

                //
                // From handle.
                //

                pKeDataChunks[i].FromFileHandle.ByteRange =
                    pUserDataChunks[i].FromFileHandle.ByteRange;

                pKeDataChunks[i].FromFileHandle.FileHandle =
                    pUserDataChunks[i].FromFileHandle.FileHandle;

                break;

            case HttpDataChunkFromFragmentCache:

                //
                // From fragment cache.
                //

                if (CaptureCache)
                {
                    //
                    // Content from fragment cache are meant to be dynamic
                    // so they shouldn't go to the static response cache.
                    //

                    Status = STATUS_NOT_SUPPORTED;
                    goto end;
                }

                UserFragmentName.Buffer = (PWSTR)
                        pUserDataChunks[i].FromFragmentCache.pFragmentName;
                UserFragmentName.Length =
                        pUserDataChunks[i].FromFragmentCache.FragmentNameLength;
                UserFragmentName.MaximumLength =
                        UserFragmentName.Length;

                Status = UlProbeAndCaptureUnicodeString(
                            &UserFragmentName,
                            RequestorMode,
                            &KernelFragmentName,
                            0
                            );

                if (!NT_SUCCESS(Status))
                {
                    goto end;
                }

                Status = UlCheckoutFragmentCacheEntry(
                            KernelFragmentName.Buffer,
                            KernelFragmentName.Length,
                            pProcess,
                            &pKeDataChunks[i].FromFragmentCache.pCacheEntry
                            );

                UlFreeCapturedUnicodeString( &KernelFragmentName );

                if (!NT_SUCCESS(Status))
                {
                    goto end;
                }

                ASSERT( pKeDataChunks[i].FromFragmentCache.pCacheEntry );

                break;

            default :

                ExRaiseStatus( STATUS_INVALID_PARAMETER );
                break;

            }   // switch (pUserDataChunks[i].DataChunkType)

        }   // for (i = 0 ; i < ChunkCount ; i++)

        //
        // Ensure we didn't mess up our buffer calculations.
        //

        ASSERT( DIFF(pBuffer - (PUCHAR)(pKeResponse->pAuxiliaryBuffer)) ==
                AuxBufferLength );

        UlTrace(SEND_RESPONSE, (
            "Http!UlCaptureHttpResponse: captured %p from user %p\n",
            pKeResponse,
            pUserResponse
            ));
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE( GetExceptionCode() );
    }

end:

    if (NT_SUCCESS(Status) == FALSE)
    {
        if (pKeResponse != NULL)
        {
            UlpDestroyCapturedResponse( pKeResponse );
            pKeResponse = NULL;
        }
    }

    //
    // Return the captured response.
    //

    *ppKernelResponse = pKeResponse;

    RETURN( Status );

}   // UlCaptureHttpResponse


/***************************************************************************++

Routine Description:

    Captures a user-mode log data to kernel pLogData structure.

Arguments:

    pCapturedUserLogData - Supplies the captured HTTP_LOG_FIELDS_DATA.
        However there are still embedded pointers pointing to user mode
        memory inside this captured structure.

    pRequest - Supplies the request to capture.

    ppKernelLogData - Buffer to hold the pointer to the newly allocated
        LogData. WILL be set to null if logging is disabled

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCaptureUserLogData(
    IN PHTTP_LOG_FIELDS_DATA    pCapturedUserLogData,
    IN PUL_INTERNAL_REQUEST     pRequest,
    OUT PUL_LOG_DATA_BUFFER     *ppKernelLogData
    )
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    PUL_CONFIG_GROUP_OBJECT     pLoggingConfig;
    BOOLEAN                     BinaryLoggingEnabled;
    PUL_LOG_DATA_BUFFER         pLogData;

    ASSERT( pCapturedUserLogData );
    ASSERT( ppKernelLogData );
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pRequest ) );

    //
    // Init the caller's pLogData pointer to NULL.
    //

    *ppKernelLogData = pLogData = NULL;

    //
    // Capture the log data. Note that the binary logging takes
    // precedence over the normal logging.
    //

    BinaryLoggingEnabled = UlBinaryLoggingEnabled(
                                pRequest->ConfigInfo.pControlChannel
                                );

    pLoggingConfig = pRequest->ConfigInfo.pLoggingConfig;

    __try
    {
        //
        // If either type of logging is enabled, then allocate a kernel buffer
        // and capture it down.
        //

        if (BinaryLoggingEnabled)
        {
            Status = UlCaptureRawLogData(
                        pCapturedUserLogData,
                        pRequest,
                        &pLogData
                        );
        }
        else
        if (pLoggingConfig)
        {
            ASSERT( IS_VALID_CONFIG_GROUP( pLoggingConfig ) );

            switch(pLoggingConfig->LoggingConfig.LogFormat)
            {
            case HttpLoggingTypeW3C:

                Status = UlCaptureLogFieldsW3C(
                                pCapturedUserLogData,
                                pRequest,
                                &pLogData
                                );
                break;

            case HttpLoggingTypeNCSA:

                Status = UlCaptureLogFieldsNCSA(
                                pCapturedUserLogData,
                                pRequest,
                                &pLogData
                                );
                break;

            case HttpLoggingTypeIIS:

                Status = UlCaptureLogFieldsIIS(
                                pCapturedUserLogData,
                                pRequest,
                                &pLogData
                                );
                break;

            default:

                ASSERT( !"Invalid Text Logging Format!" );
                return STATUS_INVALID_PARAMETER;
            }
        }
        else
        {
            return STATUS_SUCCESS;  // Logging is disabled for this site.
        }

        if (NT_SUCCESS(Status))
        {
            //
            // Success set the callers buffer to point to the freshly
            // allocated/formatted pLogData.
            //

            ASSERT( IS_VALID_LOG_DATA_BUFFER( pLogData ) );
            *ppKernelLogData = pLogData;
        }
        else
        {
            //
            // If the logging capture function returns an error,
            // kernel buffer should not have been allocated.
            //

            ASSERT( pLogData == NULL );
        }
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        if (pLogData)
        {
            //
            // If the logging capture function raised and exception
            // after allocating a pLogData, we need to cleanup here.
            //

            UlDestroyLogDataBuffer( pLogData );
        }

        Status = UL_CONVERT_EXCEPTION_CODE( GetExceptionCode() );
    }

    return Status;

}   // UlCaptureUserLogData


/***************************************************************************++

Routine Description:

    Probes all the buffers passed to use in a user-mode HTTP response.

Arguments:

    pUserResponse - Supplies the response to probe.

    ChunkCount - Supplies the number of data chunks.

    pDataChunks - Supplies the array of data chunks.

    Flags - Capture flags.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpProbeHttpResponse(
    IN PHTTP_RESPONSE           pUserResponse OPTIONAL,
    IN USHORT                   ChunkCount,
    IN PHTTP_DATA_CHUNK         pCapturedDataChunks OPTIONAL,
    IN UL_CAPTURE_FLAGS         Flags,
    IN PHTTP_LOG_FIELDS_DATA    pCapturedLogData OPTIONAL,
    IN KPROCESSOR_MODE          RequestorMode
    )
{
    USHORT                      KeyUriLength;
    PCWSTR                      pKeyUri;
    NTSTATUS                    Status;
    ULONG                       i;

    Status = STATUS_SUCCESS;

    __try
    {
        //
        // Probe the response structure if it exits.
        //

        if (pUserResponse)
        {
            if (pUserResponse->Flags & ~HTTP_RESPONSE_FLAG_VALID)
            {
                ExRaiseStatus( STATUS_INVALID_PARAMETER );
            }

            //
            // We don't support trailers for this release.
            //

            if (pUserResponse->Headers.TrailerCount != 0 ||
                pUserResponse->Headers.pTrailers != NULL)
            {
                ExRaiseStatus( STATUS_INVALID_PARAMETER );
            }
        }

        //
        // Probe the log data if it exists.
        //

        if (pCapturedLogData)
        {
            UlProbeLogData( pCapturedLogData, RequestorMode );
        }

        //
        // And now the body part.
        //

        if (pCapturedDataChunks != NULL)
        {
            for (i = 0 ; i < ChunkCount ; i++)
            {
                switch (pCapturedDataChunks[i].DataChunkType)
                {
                case HttpDataChunkFromMemory:

                    //
                    // From-memory chunk.
                    //

                    if (pCapturedDataChunks[i].FromMemory.BufferLength == 0 ||
                        pCapturedDataChunks[i].FromMemory.pBuffer == NULL)
                    {
                        return STATUS_INVALID_PARAMETER;
                    }

                    if ((Flags & UlCaptureCopyData) ||
                        pCapturedDataChunks[i].FromMemory.BufferLength <=
                            g_UlMaxCopyThreshold)
                    {
                        UlProbeForRead(
                            pCapturedDataChunks[i].FromMemory.pBuffer,
                            pCapturedDataChunks[i].FromMemory.BufferLength,
                            sizeof(CHAR),
                            RequestorMode
                            );
                    }

                    break;

                case HttpDataChunkFromFileHandle:

                    //
                    // From handle chunk.  the handle will be validated later
                    // by the object manager.
                    //

                    break;

                case HttpDataChunkFromFragmentCache:

                    KeyUriLength =
                        pCapturedDataChunks[i].FromFragmentCache.FragmentNameLength;
                    pKeyUri =
                        pCapturedDataChunks[i].FromFragmentCache.pFragmentName;

                    //
                    // From-fragment-cache chunk. Probe the KeyUri buffer.
                    //

                    UlProbeWideString(
                        pKeyUri,
                        KeyUriLength,
                        RequestorMode
                        );

                    break;

                default :

                    Status = STATUS_INVALID_PARAMETER;
                    break;

                }   // switch (pCapturedDataChunks[i].DataChunkType)

            }   // for (i = 0 ; i < ChunkCount ; i++)

        }   // if (pCapturedDataChunks != NULL)
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE( GetExceptionCode() );
    }

    return Status;

}   // UlpProbeHttpResponse


/***************************************************************************++

Routine Description:

    Figures out how much space we need in the internal response aux buffer.
    The buffer contains copied memory chunks, and names of files to open.

    CODEWORK: need to be aware of chunk encoding.

Arguments:

    ChunkCount - The number of chunks in the array.

    pDataChunks - The array of data chunks.

    Flags - Capture flags.

    pAuxBufferSize - Returns the size of the aux buffer.

    pCopiedMemorySize - Returns the size of user buffer that is going to
        be copied.

    pUncopiedMemorySize - Returns the size of the user buffer that is
        going to be ProbeAndLocked.

Return Value:

    None.

--***************************************************************************/
VOID
UlpComputeChunkBufferSizes(
    IN ULONG            ChunkCount,
    IN PHTTP_DATA_CHUNK pDataChunks,
    IN UL_CAPTURE_FLAGS Flags,
    OUT PULONG          pAuxBufferSize,
    OUT PULONG          pCopiedMemorySize,
    OUT PULONG          pUncopiedMemorySize
    )
{
    ULONG               AuxLength = 0;
    ULONG               CopiedLength = 0;
    ULONG               UncopiedLength = 0;
    ULONG               i;

    for (i = 0; i < ChunkCount; i++)
    {
        switch (pDataChunks[i].DataChunkType)
        {
        case HttpDataChunkFromMemory:

            //
            // If we're going to copy the chunk, then make some space in
            // the aux buffer.
            //

            if ((Flags & UlCaptureCopyData) ||
                pDataChunks[i].FromMemory.BufferLength <= g_UlMaxCopyThreshold)
            {
                AuxLength += pDataChunks[i].FromMemory.BufferLength;
                CopiedLength += pDataChunks[i].FromMemory.BufferLength;
            }
            else
            {
                UncopiedLength += pDataChunks[i].FromMemory.BufferLength;
            }

            break;

        case HttpDataChunkFromFileHandle:
        case HttpDataChunkFromFragmentCache:

            break;

        default:

            //
            // We should have caught this in the probe.
            //

            ASSERT( !"Invalid chunk type" );
            break;
        }
    }

    *pAuxBufferSize = AuxLength;
    *pCopiedMemorySize = CopiedLength;
    *pUncopiedMemorySize = UncopiedLength;

}   // UlpComputeChunkBufferSizes


/***************************************************************************++

Routine Description:

    Prepares the specified response for sending. This preparation
    consists mostly of opening any files referenced by the response.

Arguments:

    Version - Supplies the version of the user response to prepare.

    pUserResponse - Supplies the user response to prepare.

    pResponse - Supplies the kernel response to prepare.

    AccessMode - Supplies the access mode.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlPrepareHttpResponse(
    IN HTTP_VERSION             Version,
    IN PHTTP_RESPONSE           pUserResponse,
    IN PUL_INTERNAL_RESPONSE    pResponse,
    IN KPROCESSOR_MODE          AccessMode
    )
{
    ULONG                       i;
    NTSTATUS                    Status = STATUS_SUCCESS;
    PUL_INTERNAL_DATA_CHUNK     pInternalChunk;
    PUL_FILE_CACHE_ENTRY        pFileCacheEntry;
    ULONG                       HeaderLength;
    CCHAR                       MaxStackSize = 0;

    //
    // Sanity check.
    //

    PAGED_CODE();

    UlTrace(SEND_RESPONSE, (
        "Http!UlPrepareHttpResponse: response %p\n",
        pResponse
        ));

    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pResponse ) );

    //
    // Build the HTTP response protocol part and check that the caller
    // passed in headers to send.
    //

    if (pResponse->HeaderLength > 0)
    {
        ASSERT( pUserResponse != NULL );

        //
        // Generate the fixed headers.
        //

        Status = UlGenerateFixedHeaders(
                        Version,
                        pUserResponse,
                        pResponse->StatusCode,
                        pResponse->HeaderLength,
                        AccessMode,
                        pResponse->pHeaders,
                        &HeaderLength
                        );

        if (!NT_SUCCESS(Status))
            goto end;

        if (HeaderLength < pResponse->HeaderLength)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }

        //
        // It is possible that no headers got generated (0.9 request).
        //

        if (HeaderLength > 0)
        {
            //
            // Build a MDL for it.
            //

            pResponse->pDataChunks[0].ChunkType = HttpDataChunkFromMemory;
            pResponse->pDataChunks[0].FromMemory.BufferLength =
                pResponse->HeaderLength;

            pResponse->pDataChunks[0].FromMemory.pMdl =
                UlAllocateMdl(
                    pResponse->pHeaders,        // VirtualAddress
                    pResponse->HeaderLength,    // Length
                    FALSE,                      // SecondaryBuffer
                    FALSE,                      // ChargeQuota
                    NULL                        // Irp
                    );

            if (pResponse->pDataChunks[0].FromMemory.pMdl == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto end;
            }

            MmBuildMdlForNonPagedPool(
                pResponse->pDataChunks[0].FromMemory.pMdl
                );
        }
    }

    //
    // Scan the chunks looking for "from file" chunks.
    //

    for (i = 0, pInternalChunk = pResponse->pDataChunks;
         i < pResponse->ChunkCount;
         i++, pInternalChunk++)
    {
        switch (pInternalChunk->ChunkType)
        {
        case HttpDataChunkFromFileHandle:

            //
            // File chunk.
            //

            pFileCacheEntry = &pInternalChunk->FromFileHandle.FileCacheEntry;

            UlTrace(SEND_RESPONSE, (
                "UlPrepareHttpResponse: opening handle %p\n",
                &pInternalChunk->FromFileHandle.FileHandle
                ));

            //
            // Found one. Try to open it.
            //

            Status = UlCreateFileEntry(
                        pInternalChunk->FromFileHandle.FileHandle,
                        pFileCacheEntry
                        );

            if (NT_SUCCESS(Status) == FALSE)
                goto end;

            //
            // Check if this is going to be a sync read. All sync reads
            // goto special thread pools since they can be blocking.
            //

            if (!pFileCacheEntry->BytesPerSector)
            {
                pResponse->SyncRead = TRUE;
            }

            if (pFileCacheEntry->pDeviceObject->StackSize > MaxStackSize)
            {
                MaxStackSize = pFileCacheEntry->pDeviceObject->StackSize;
            }

            //
            // Validate & sanitize the specified byte range.
            //

            Status = UlSanitizeFileByteRange(
                        &pInternalChunk->FromFileHandle.ByteRange,
                        &pInternalChunk->FromFileHandle.ByteRange,
                        pFileCacheEntry->EndOfFile.QuadPart
                        );

            if (NT_SUCCESS(Status) == FALSE)
                goto end;

            pResponse->ResponseLength +=
                pInternalChunk->FromFileHandle.ByteRange.Length.QuadPart;

            break;

        case HttpDataChunkFromMemory:

            pResponse->ResponseLength +=
                pInternalChunk->FromMemory.BufferLength;

            break;

        case HttpDataChunkFromFragmentCache:

            pResponse->ResponseLength +=
                pInternalChunk->FromFragmentCache.pCacheEntry->ContentLength;

            break;

        default:

            ASSERT( FALSE );
            Status = STATUS_INVALID_PARAMETER;
            goto end;

        }   // switch (pInternalChunk->ChunkType)
    }

    pResponse->MaxFileSystemStackSize = MaxStackSize;

end:

    if (NT_SUCCESS(Status) == FALSE)
    {
        //
        // Undo anything done above.
        //

        UlCleanupHttpResponse( pResponse );
    }

    RETURN( Status );

}   // UlPrepareHttpResponse


/***************************************************************************++

Routine Description:

    Cleans a response by undoing anything done in UlPrepareHttpResponse().

Arguments:

    pResponse - Supplies the response to cleanup.

Return Value:

    None.

 --***************************************************************************/
VOID
UlCleanupHttpResponse(
    IN PUL_INTERNAL_RESPONSE    pResponse
    )
{
    ULONG                       i;
    PUL_INTERNAL_DATA_CHUNK     pInternalChunk;

    //
    // Sanity check.
    //

    PAGED_CODE();

    UlTrace(SEND_RESPONSE, (
        "UlCleanupHttpResponse: response %p\n",
        pResponse
        ));

    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pResponse ) );

    //
    // Scan the chunks looking for "from file" chunks.
    //

    pInternalChunk = pResponse->pDataChunks;

    for (i = 0; i < pResponse->ChunkCount; i++, pInternalChunk++)
    {
        if (IS_FROM_FILE_HANDLE(pInternalChunk))
        {
            if (!pInternalChunk->FromFileHandle.FileCacheEntry.pFileObject)
            {
                break;
            }

            UlDestroyFileCacheEntry(
                &pInternalChunk->FromFileHandle.FileCacheEntry
                );

            pInternalChunk->FromFileHandle.FileCacheEntry.pFileObject = NULL;
        }
        else
        {
            ASSERT( IS_FROM_MEMORY( pInternalChunk ) ||
                    IS_FROM_FRAGMENT_CACHE( pInternalChunk ) );
        }
    }

}   // UlCleanupHttpResponse


/***************************************************************************++

Routine Description:

    References the specified response.

Arguments:

    pResponse - Supplies the response to reference.

Return Value:

    None.

--***************************************************************************/
VOID
UlReferenceHttpResponse(
    IN PUL_INTERNAL_RESPONSE    pResponse
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG                        RefCount;

    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pResponse ) );

    RefCount = InterlockedIncrement( &pResponse->ReferenceCount );

    WRITE_REF_TRACE_LOG(
        g_pHttpResponseTraceLog,
        REF_ACTION_REFERENCE_HTTP_RESPONSE,
        RefCount,
        pResponse,
        pFileName,
        LineNumber
        );

    UlTrace(SEND_RESPONSE, (
        "UlReferenceHttpResponse: response %p refcount %ld\n",
        pResponse,
        RefCount
        ));

}   // UlReferenceHttpResponse


/***************************************************************************++

Routine Description:

    Dereferences the specified response.

Arguments:

    pResponse - Supplies the response to dereference.

Return Value:

    None.

--***************************************************************************/
VOID
UlDereferenceHttpResponse(
    IN PUL_INTERNAL_RESPONSE    pResponse
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG                        RefCount;

    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pResponse ) );

    RefCount = InterlockedDecrement( &pResponse->ReferenceCount );

    WRITE_REF_TRACE_LOG(
        g_pHttpResponseTraceLog,
        REF_ACTION_DEREFERENCE_HTTP_RESPONSE,
        RefCount,
        pResponse,
        pFileName,
        LineNumber
        );

    UlTrace(SEND_RESPONSE, (
        "UlDereferenceHttpResponse: response %p refcount %ld\n",
        pResponse,
        RefCount
        ));

    if (RefCount == 0)
    {
        UlpDestroyCapturedResponse( pResponse );
    }

}   // UlDereferenceHttpResponse


/***************************************************************************++

Routine Description:

    A helper function that allocates an MDL for a range of memory, and
    locks it down. UlpSendCacheEntry uses these MDLs to make sure the
    (normally paged) cache entries don't get paged out when TDI is
    sending them.

Arguments:

    VirtualAddress - Supplies the address of the memory.

    Length - Supplies the length of the memory to allocate a MDL for.

    Operation - Either IoWriteAcess or IoReadAccess.

Return Values:

    Pointer to a MDL if success or NULL otherwise.

--***************************************************************************/
PMDL
UlAllocateLockedMdl(
    IN PVOID            VirtualAddress,
    IN ULONG            Length,
    IN LOCK_OPERATION   Operation
    )
{
    PMDL                pMdl = NULL;
    NTSTATUS            Status = STATUS_SUCCESS;

    //
    // Sanity check.
    //

    PAGED_CODE();

    __try
    {
        pMdl = UlAllocateMdl(
                    VirtualAddress,     // VirtualAddress
                    Length,             // Length
                    FALSE,              // SecondaryBuffer
                    FALSE,              // ChargeQuota
                    NULL                // Irp
                    );

        if (pMdl)
        {
            MmProbeAndLockPages(
                pMdl,                   // MDL
                KernelMode,             // AccessMode
                Operation               // Operation
                );

        }
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE( GetExceptionCode() );

        UlFreeMdl( pMdl );
        pMdl = NULL;
    }

    return pMdl;

}   // UlAllocateLockedMdl


/***************************************************************************++

Routine Description:

    Unlocks and frees an MDL allocated with UlAllocateLockedMdl.

Arguments:

    pMdl - Supplies the MDL to free.

Return Values:

    None.

--***************************************************************************/
VOID
UlFreeLockedMdl(
    IN PMDL pMdl
    )
{
    //
    // Sanity check.
    //

    ASSERT( IS_MDL_LOCKED(pMdl) );

    MmUnlockPages( pMdl );
    UlFreeMdl( pMdl );

}   // UlFreeLockedMdl


/***************************************************************************++

Routine Description:

    A helper function that initializes an MDL for a range of memory, and
    locks it down. UlpSendCacheEntry uses these MDLs to make sure the
    (normally paged) cache entries don't get paged out when TDI is
    sending them.

Arguments:

    pMdl - Supplies the memory descriptor for the MDL to initialize.

    VirtualAddress - Supplies the address of the memory.

    Length - Supplies the length of the memory.

    Operation - Either IoWriteAcess or IoReadAccess.

Return Values:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlInitializeAndLockMdl(
    IN PMDL             pMdl,
    IN PVOID            VirtualAddress,
    IN ULONG            Length,
    IN LOCK_OPERATION   Operation
    )
{
    NTSTATUS            Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    __try
    {
        MmInitializeMdl(
            pMdl,
            VirtualAddress,
            Length
            );

        MmProbeAndLockPages(
            pMdl,                   // MDL
            KernelMode,             // AccessMode
            Operation               // Operation
            );

    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE( GetExceptionCode() );
    }

    return Status;

}   // UlInitializeAndLockMdl


/***************************************************************************++

Routine Description:

    Once we've parsed a request, we pass it in here to try and serve
    from the response cache. This function will either send the response,
    or do nothing at all.

Arguments:

    pHttpConn - Supplies the connection with a request to be handled.

    pSendCacheResult - Result of the cache sent attempt.

    pResumeParsing - Returns to the parser if parsing needs to be resumed.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlSendCachedResponse(
    IN PUL_HTTP_CONNECTION      pHttpConn,
    OUT PUL_SEND_CACHE_RESULT   pSendCacheResult,
    OUT PBOOLEAN                pResumeParsing
    )
{
    NTSTATUS                    Status;
    PUL_URI_CACHE_ENTRY         pUriCacheEntry = NULL;
    ULONG                       Flags;
    ULONG                       RetCacheControl;
    LONGLONG                    BytesToSend;
    ULONG                       SiteId;
    URI_SEARCH_KEY              SearchKey;
    PUL_INTERNAL_REQUEST        pRequest;
    PUL_SITE_COUNTER_ENTRY      pCtr;
    ULONG                       Connections;
    UL_RESUME_PARSING_TYPE      ResumeParsingType;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( UL_IS_VALID_HTTP_CONNECTION( pHttpConn ) );
    ASSERT( UlDbgPushLockOwnedExclusive( &pHttpConn->PushLock ) );
    ASSERT( pSendCacheResult );
    ASSERT( pResumeParsing );

    pRequest = pHttpConn->pRequest;
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pRequest ) );

    *pResumeParsing = FALSE;

    //
    // See if we need to lookup based on Host + IP.
    //

    if (UlGetHostPlusIpBoundUriCacheCount() > 0)
    {
        Status = UlGenerateRoutingToken( pRequest, FALSE );

        if (!NT_SUCCESS(Status))
        {
            //
            // Memory failure bail out. Always set the error code if we are
            // going to fail the request.
            //

            UlSetErrorCode(
                pRequest,
                UlErrorInternalServer,
                NULL
                );

            *pSendCacheResult = UlSendCacheFailed;
            return Status;
        }

        UlpBuildExtendedSearchKey( pRequest, &SearchKey );
        pUriCacheEntry = UlCheckoutUriCacheEntry( &SearchKey );

        if (pUriCacheEntry)
        {
            ASSERT( pUriCacheEntry->ConfigInfo.SiteUrlType ==
                    HttpUrlSite_NamePlusIP );

            UlTrace(URI_CACHE, (
                "Http!UlSendCachedResponse (Host+Ip) "
                "pUriCacheEntry: (%p) Uri: (%S)\n",
                pUriCacheEntry,
                pUriCacheEntry ? pUriCacheEntry->UriKey.pUri : L""
                ));
        }
    }

    //
    // Do not serve from cache if there's a Host + IP bound site
    // in the cgroup.
    //

    if (pUriCacheEntry == NULL)
    {
        Status = UlLookupHostPlusIPSite( pRequest );

        if (NT_SUCCESS(Status))
        {
            //
            // There is a Host + IP bound site for this request.
            // This should not be served from cache.
            // Bail out!
            //

            *pSendCacheResult = UlSendCacheMiss;
            return Status;
        }
        else
        if (STATUS_NO_MEMORY == Status)
        {
            UlSetErrorCode(
                pRequest,
                UlErrorInternalServer,
                NULL
                );

            *pSendCacheResult = UlSendCacheFailed;
            return Status;
        }
    }

    //
    // Do the normal lookup based on the cooked Url.
    //

    if (pUriCacheEntry == NULL)
    {
        SearchKey.Type          = UriKeyTypeNormal;
        SearchKey.Key.Hash      = pRequest->CookedUrl.Hash;
        SearchKey.Key.Length    = pRequest->CookedUrl.Length;
        SearchKey.Key.pUri      = pRequest->CookedUrl.pUrl;
        SearchKey.Key.pPath     = NULL;

        pUriCacheEntry = UlCheckoutUriCacheEntry( &SearchKey );

        UlTrace(URI_CACHE, (
            "Http!UlSendCachedResponse (CookedUrl) "
            "pUriCacheEntry: (%p) Uri: (%S)\n",
            pUriCacheEntry,
            pUriCacheEntry ? pUriCacheEntry->UriKey.pUri : L""
            ));
    }

    if (pUriCacheEntry == NULL)
    {
        //
        // No match in the URI cache, bounce up to user-mode.
        //

        *pSendCacheResult = UlSendCacheMiss;
        return STATUS_SUCCESS;
    }

    //
    // Verify the cache entry.
    //

    ASSERT( IS_VALID_URI_CACHE_ENTRY( pUriCacheEntry ) );
    ASSERT( IS_VALID_URL_CONFIG_GROUP_INFO( &pUriCacheEntry->ConfigInfo ) );

    if (!pUriCacheEntry->HeaderLength)
    {
        //
        // Treat a match to a headless fragment cache entry as no-match.
        //

        UlCheckinUriCacheEntry( pUriCacheEntry );

        *pSendCacheResult = UlSendCacheMiss;
        return STATUS_SUCCESS;
    }

    //
    // Check "Accept:" header.
    //

    if (FALSE == pRequest->AcceptWildcard)
    {
        if (FALSE == UlIsAcceptHeaderOk(pRequest, pUriCacheEntry))
        {
            //
            // Cache entry did not match requested accept header; bounce up
            // to user-mode for response.
            //

            UlCheckinUriCacheEntry( pUriCacheEntry );

            *pSendCacheResult = UlSendCacheMiss;
            return STATUS_SUCCESS;
        }
    }

    //
    // Check "Accept-Encoding:" header
    //
    
    if (FALSE == UlIsContentEncodingOk(pRequest, pUriCacheEntry))
    {
        //
        // Cache entry did not match requested Accept-Encoding
        // header; bounce up to user-mode for response.
        //

        UlCheckinUriCacheEntry( pUriCacheEntry );

        *pSendCacheResult = UlSendCacheMiss;
        return STATUS_SUCCESS;
    }


    //
    // Now from this point on, the response will either be from cache or
    // we will fail/refuse the connection. Always return from end, so that
    // tracing can work.
    //

    Status = STATUS_SUCCESS;

    //
    // Enforce the connection limit now.
    //

    if (FALSE == UlCheckSiteConnectionLimit(
                    pHttpConn,
                    &pUriCacheEntry->ConfigInfo
                    ))
    {
        //
        // Check in the cache entry back. Connection is refused!
        //

        UlSetErrorCode(
            pRequest,
            UlErrorConnectionLimit,
            pUriCacheEntry->ConfigInfo.pAppPool
            );

        UlCheckinUriCacheEntry( pUriCacheEntry );

        *pSendCacheResult = UlSendCacheConnectionRefused;
        Status = STATUS_INVALID_DEVICE_STATE;
        goto end;
    }

    //
    // Perf Counters (cached).
    //

    pCtr = pUriCacheEntry->ConfigInfo.pSiteCounters;
    if (pCtr)
    {
        //
        // NOTE: pCtr may be NULL if the SiteId was never set on the root-level
        // NOTE: Config Group for the site. BVTs may need to be updated.
        //

        ASSERT( IS_VALID_SITE_COUNTER_ENTRY( pCtr ) );

        if (pUriCacheEntry->Verb == HttpVerbGET)
        {
            UlIncSiteNonCriticalCounterUlong( pCtr, HttpSiteCounterGetReqs );
        }
        else
        if (pUriCacheEntry->Verb == HttpVerbHEAD)
        {
            UlIncSiteNonCriticalCounterUlong( pCtr, HttpSiteCounterHeadReqs );
        }

        UlIncSiteNonCriticalCounterUlong( pCtr, HttpSiteCounterAllReqs );

        if (pCtr != pHttpConn->pPrevSiteCounters)
        {
            if (pHttpConn->pPrevSiteCounters)
            {
                UlDecSiteCounter(
                    pHttpConn->pPrevSiteCounters,
                    HttpSiteCounterCurrentConns
                    );
                DEREFERENCE_SITE_COUNTER_ENTRY( pHttpConn->pPrevSiteCounters );
            }

            UlIncSiteNonCriticalCounterUlong(
                pCtr,
                HttpSiteCounterConnAttempts
                );
            Connections =
                (ULONG) UlIncSiteCounter( pCtr, HttpSiteCounterCurrentConns );
            UlMaxSiteCounter(
                pCtr,
                HttpSiteCounterMaxConnections,
                Connections
                );

            //
            // Add ref for new site counters.
            //

            REFERENCE_SITE_COUNTER_ENTRY( pCtr );
            pHttpConn->pPrevSiteCounters = pCtr;
        }
    }

    //
    // Install a filter if BWT is enabled for this request's site
    // or for the control channel that owns the site. If fails,
    // refuse the connection back (503).
    //

    Status = UlTcAddFilterForConnection(
                pHttpConn,
                &pUriCacheEntry->ConfigInfo
                );

    if (!NT_SUCCESS(Status))
    {
        UlSetErrorCode(
            pRequest,
            UlErrorUnavailable,
            pUriCacheEntry->ConfigInfo.pAppPool
            );

        UlCheckinUriCacheEntry( pUriCacheEntry );

        *pSendCacheResult = UlSendCacheFailed;
        goto end;
    }

    //
    // Now we are about to do a cache send, we need to enforce the limit for
    // pipelined requests on the connection. If we return FALSE for resume
    // parsing, the next request on the connection will be parsed after
    // the send completion. Otherwise the HTTP receive logic will kick the
    // parser back into action.
    //

    if (pHttpConn->PipelinedRequests < g_UlMaxPipelinedRequests)
    {
        ResumeParsingType = UlResumeParsingOnLastSend;
    }
    else
    {
        ResumeParsingType = UlResumeParsingOnSendCompletion;
    }

    //
    // Set BytesToSend and SiteId since we are reasonably sure this is a
    // cache-hit and so that the 304 code path will get these values too.
    //

    BytesToSend = pUriCacheEntry->ContentLength + pUriCacheEntry->HeaderLength;
    SiteId = pUriCacheEntry->ConfigInfo.SiteId;

    //
    // Cache-Control: Check the If-* headers to see if we can/should skip
    // sending of the cached response. This does a passive syntax check on
    // the Etags in the request's If-* headers. This call will issue a send
    // if the return code is 304.
    //

    RetCacheControl =
        UlCheckCacheControlHeaders(
            pRequest,
            pUriCacheEntry,
            (BOOLEAN) (UlResumeParsingOnSendCompletion == ResumeParsingType)
            );

    if (RetCacheControl)
    {
        //
        // Check-in cache entry, since completion won't run.
        //

        UlCheckinUriCacheEntry( pUriCacheEntry );

        switch (RetCacheControl)
        {
        case 304:

            //
            // Resume parsing only if we have sent a 304. In other cases,
            // the request is deliverd to the user or the connection is reset.
            //

            *pResumeParsing =
                (BOOLEAN) (UlResumeParsingOnLastSend == ResumeParsingType);

            //
            // Mark as "served from cache".
            //

            *pSendCacheResult = UlSendCacheServedFromCache;
            break;

        case 412:

            //
            // Indicate that the parser should send error 412 (Precondition
            // Failed). Just the send the error response but do not close
            // the connection.
            //

            UlSetErrorCode( pRequest, UlErrorPreconditionFailed, NULL );

            *pSendCacheResult = UlSendCachePreconditionFailed;
            Status = STATUS_INVALID_DEVICE_STATE;
            break;

        case 400:
        default:

            //
            // Indicate that the parser should send error 400 (Bad Request).
            //

            UlSetErrorCode( pRequest, UlError, NULL );

            *pSendCacheResult = UlSendCacheFailed;
            Status = STATUS_INVALID_DEVICE_STATE;
            break;
        }

        //
        // Return success.
        //

        goto end;
    }

    //
    // Figure out correct flags.
    //

    if (UlCheckDisconnectInfo(pHttpConn->pRequest))
    {
        Flags = HTTP_SEND_RESPONSE_FLAG_DISCONNECT;
    }
    else
    {
        Flags = 0;
    }

    //
    // Start the MinBytesPerSecond timer, since the data length
    // is in the UL_URI_CACHE_ENTRY.
    //

    UlSetMinBytesPerSecondTimer(
        &pHttpConn->TimeoutInfo,
        BytesToSend
        );

    Status = UlpSendCacheEntry(
                    pHttpConn,          // pHttpConnection
                    Flags,              // Flags
                    pUriCacheEntry,     // pUriCacheEntry
                    NULL,               // pCompletionRoutine
                    NULL,               // pCompletionContext
                    NULL,               // pLogData
                    ResumeParsingType   // ResumeParsingType
                    );

    //
    // Check in cache entry on failure since our completion
    // routine won't run.
    //

    if (!NT_SUCCESS(Status) )
    {
        //
        // Return failure so that the request doesn't bounce back to
        // user mode.
        //

        UlSetErrorCode(
            pRequest,
            UlErrorUnavailable,
            pUriCacheEntry->ConfigInfo.pAppPool
            );

        UlCheckinUriCacheEntry( pUriCacheEntry );
        *pSendCacheResult = UlSendCacheFailed;
    }
    else
    {
        //
        // Success!
        //

        *pSendCacheResult = UlSendCacheServedFromCache;
    }

end:

    //
    // If the request is served from cache, fire the ETW end event here.
    //

    if (ETW_LOG_MIN() && (*pSendCacheResult == UlSendCacheServedFromCache))
    {
        UlEtwTraceEvent(
            &UlTransGuid,
            ETW_TYPE_CACHED_END,
            (PVOID) &pRequest,
            sizeof(PVOID),
            &SiteId,
            sizeof(ULONG),
            &BytesToSend,
            sizeof(ULONG),
            NULL,
            0
            );
    }

    UlTrace(URI_CACHE, (
        "Http!UlSendCachedResponse(httpconn = %p) ServedFromCache = (%s),"
        "Status = %x\n",
        pHttpConn,
        TRANSLATE_SEND_CACHE_RESULT(*pSendCacheResult),
        Status
        ));

    return Status;

}   // UlSendCachedResponse


/***************************************************************************++

Routine Description:

    If the response is cacheable, then this routine starts building a
    cache entry for it. When the entry is complete it will be sent to
    the client and may be added to the hash table.

Arguments:

    pRequest - Supplies the initiating request.

    pResponse - Supplies the generated response.

    pProcess - Supplies the WP that is sending the response.

    Flags - UlSendHttpResponse flags.

    Policy - Supplies the cache policy for this response.

    pCompletionRoutine - Supplies the completion routine to be called
        after entry is sent.

    pCompletionContext - Supplies the context passed to pCompletionRoutine.

    pServedFromCache - Always set. TRUE if we'll handle sending response.
        FALSE indicates that the caller should send it.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCacheAndSendResponse(
    IN PUL_INTERNAL_REQUEST     pRequest,
    IN PUL_INTERNAL_RESPONSE    pResponse,
    IN PUL_APP_POOL_PROCESS     pProcess,
    IN HTTP_CACHE_POLICY        Policy,
    IN PUL_COMPLETION_ROUTINE   pCompletionRoutine,
    IN PVOID                    pCompletionContext,
    OUT PBOOLEAN                pServedFromCache
    )
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    ULONG                       Flags = pResponse->Flags;
    USHORT                      StatusCode = pResponse->StatusCode;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( pServedFromCache );

    //
    // Should we close the connection?
    //

    if (UlCheckDisconnectInfo(pRequest))
    {
        Flags |= HTTP_SEND_RESPONSE_FLAG_DISCONNECT;
        pResponse->Flags = Flags;
    }

    //
    // Do the real work.
    //

    if (UlCheckCacheResponseConditions(pRequest, pResponse, Flags, Policy))
    {
        Status = UlpBuildCacheEntry(
                        pRequest,
                        pResponse,
                        pProcess,
                        Policy,
                        pCompletionRoutine,
                        pCompletionContext
                        );

        if (NT_SUCCESS(Status))
        {
            *pServedFromCache = TRUE;
        }
        else
        {
            *pServedFromCache = FALSE;
            Status = STATUS_SUCCESS;
        }
    }
    else
    {
        *pServedFromCache = FALSE;
    }

    UlTrace(URI_CACHE, (
        "Http!UlCacheAndSendResponse ServedFromCache = %d\n",
        *pServedFromCache
        ));

    //
    // We will record this as cache miss since the original request
    // was a miss.
    //

    if (ETW_LOG_MIN() && *pServedFromCache)
    {
        UlEtwTraceEvent(
            &UlTransGuid,
            ETW_TYPE_CACHE_AND_SEND,
            (PVOID) &pRequest->RequestIdCopy,
            sizeof(HTTP_REQUEST_ID),
            (PVOID) &StatusCode,
            sizeof(USHORT),
            NULL,
            0
            );
    }

    return Status;

}   // UlCacheAndSendResponse


/***************************************************************************++

Routine Description:

    Completes a "send response" represented by a send tracker.
    UlCompleteSendResponse takes the ownership of the tracker reference.

Arguments:

    pTracker - Supplies the tracker to complete.

    Status - Supplies the completion status.

Return Value:

    None.

--***************************************************************************/
VOID
UlCompleteSendResponse(
    IN PUL_CHUNK_TRACKER    pTracker,
    IN NTSTATUS             Status
    )
{
    //
    // Although the chunk tracker will be around until all the outstanding
    // Read/Send IRPs are complete, we should only complete the send once.
    //

    if (FALSE != InterlockedExchange(&pTracker->Terminated, TRUE))
    {
        return;
    }

    UlTrace(SEND_RESPONSE,(
        "UlCompleteSendResponse: tracker %p, status %08lx\n",
        pTracker,
        Status
        ));

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    pTracker->IoStatus.Status = Status;

    UL_QUEUE_WORK_ITEM(
        &pTracker->WorkItem,
        UlpCompleteSendResponseWorker
        );

}   // UlCompleteSendResponse


/***************************************************************************++

Routine Description:

    Increment pRequest->SendsPending in a lock and decide if we need to
    transfer the logging and resume parsing information to pRequest.

Arguments:

    pRequest - Supplies the pointer to a UL_INTERNAL_REQUEST structure
        that SendsPending needs incremented.

    ppLogData - Supplies the pointer to a PUL_LOG_DATA_BUFFER structure
        that we need to transfer to pRequest.

    pResumeParsingType - Supplies the pointer to UL_RESUME_PARSING_TYPE
        that we need to transfer to pRequest.

Return Value:

    None.

--***************************************************************************/
VOID
UlSetRequestSendsPending(
    IN PUL_INTERNAL_REQUEST         pRequest,
    IN OUT PUL_LOG_DATA_BUFFER *    ppLogData,
    IN OUT PUL_RESUME_PARSING_TYPE  pResumeParsingType
    )
{
    KIRQL                           OldIrql;

    //
    // Sanity check.
    //

    ASSERT( PASSIVE_LEVEL == KeGetCurrentIrql() );
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pRequest ) );
    ASSERT( ppLogData );
    ASSERT( NULL == *ppLogData || IS_VALID_LOG_DATA_BUFFER( *ppLogData ) );
    ASSERT( pResumeParsingType );

    UlAcquireSpinLock( &pRequest->SpinLock, &OldIrql );

    pRequest->SendsPending++;

    if (*ppLogData)
    {
        ASSERT( NULL == pRequest->pLogData );

        pRequest->pLogData = *ppLogData;
        *ppLogData = NULL;
    }

    if (UlResumeParsingOnSendCompletion == *pResumeParsingType)
    {
        ASSERT( FALSE == pRequest->ResumeParsing );

        pRequest->ResumeParsing = TRUE;
        *pResumeParsingType = UlResumeParsingNone;
    }

    UlReleaseSpinLock( &pRequest->SpinLock, OldIrql );

}   // UlSetRequestSendsPending


/***************************************************************************++

Routine Description:

    Decrement pRequest->SendsPending in a lock and decide if we need to
    log and resume parsing. The caller then should either log and/or
    resume parsing depending on the values returned. It is assumed here
    the values for both *ppLogData and *pResumeParsing are initialized
    when entering this function.

Arguments:

    pRequest - Supplies the pointer to a UL_INTERNAL_REQUEST structure
        that SendsPending needs decremented.

    ppLogData - Supplies the pointer to a PUL_LOG_DATA_BUFFER structure
        to receive the logging information.

    pResumeParsing - Supplies the pointer to a BOOLEAN to receive the
        resume parsing information.

Return Value:

    None.

--***************************************************************************/
VOID
UlUnsetRequestSendsPending(
    IN PUL_INTERNAL_REQUEST     pRequest,
    OUT PUL_LOG_DATA_BUFFER *   ppLogData,
    OUT PBOOLEAN                pResumeParsing
    )
{
    KIRQL                       OldIrql;

    //
    // Sanity check.
    //

    ASSERT( PASSIVE_LEVEL == KeGetCurrentIrql() );
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pRequest ) );
    ASSERT( ppLogData );
    ASSERT( NULL == *ppLogData );
    ASSERT( pResumeParsing );
    ASSERT( FALSE == *pResumeParsing );

    UlAcquireSpinLock( &pRequest->SpinLock, &OldIrql );

    pRequest->SendsPending--;

    if (0 == pRequest->SendsPending)
    {
        if (pRequest->pLogData)
        {
            *ppLogData = pRequest->pLogData;
            pRequest->pLogData = NULL;
        }

        if (pRequest->ResumeParsing)
        {
            *pResumeParsing = pRequest->ResumeParsing;
            pRequest->ResumeParsing = FALSE;
        }
    }

    UlReleaseSpinLock( &pRequest->SpinLock, OldIrql );

}   // UlUnsetRequestSendsPending


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Destroys an internal HTTP response captured by UlCaptureHttpResponse().
    This involves closing open files, unlocking memory, and releasing any
    resources allocated to the response.

Arguments:

    pResponse - Supplies the internal response to destroy.

Return Values:

    None.

--***************************************************************************/
VOID
UlpDestroyCapturedResponse(
    IN PUL_INTERNAL_RESPONSE    pResponse
    )
{
    PUL_INTERNAL_DATA_CHUNK     pDataChunk;
    PIRP                        pIrp;
    PIO_STACK_LOCATION          pIrpSp;
    ULONG                       i;

    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pResponse ) );
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pResponse->pRequest ) );

    UlTrace(SEND_RESPONSE,(
        "UlpDestroyCapturedResponse: response %p\n",
        pResponse
        ));

    UlDeletePushLock( &pResponse->PushLock );

    //
    // Scan the chunks.
    //

    for (i = 0; i < pResponse->ChunkCount; ++i)
    {
        pDataChunk = &pResponse->pDataChunks[i];

        if (IS_FROM_MEMORY(pDataChunk))
        {
            //
            // It's from memory. If necessary, unlock the pages, then
            // free the MDL.
            //

            if (pDataChunk->FromMemory.pMdl != NULL)
            {
                if (IS_MDL_LOCKED(pDataChunk->FromMemory.pMdl))
                {
                    MmUnlockPages( pDataChunk->FromMemory.pMdl );
                }

                UlFreeMdl( pDataChunk->FromMemory.pMdl );
                pDataChunk->FromMemory.pMdl = NULL;
            }
        }
        else
        if (IS_FROM_FRAGMENT_CACHE(pDataChunk))
        {
            //
            // It's a fragment chunk. If there is a cache entry checked
            // out, check it back in.
            //

            if (pDataChunk->FromFragmentCache.pCacheEntry != NULL)
            {
                UlCheckinUriCacheEntry(
                    pDataChunk->FromFragmentCache.pCacheEntry
                    );
            }
        }
        else
        {
            //
            // It's a file chunk. If there is an associated file cache
            // entry, then dereference it.
            //

            ASSERT( IS_FROM_FILE_HANDLE( pDataChunk ) );

            if (pDataChunk->FromFileHandle.FileCacheEntry.pFileObject != NULL)
            {
                UlDestroyFileCacheEntry(
                    &pDataChunk->FromFileHandle.FileCacheEntry
                    );
                pDataChunk->FromFileHandle.FileCacheEntry.pFileObject = NULL;
            }
        }
    }

    //
    // We should clean up the log buffer here if nobody has cleaned it up yet.
    // Unless there's an error during capture, the log buffer will be cleaned
    // up when send tracker's (cache/chunk) are completed in their respective
    // routines.
    //

    if (pResponse->pLogData)
    {
        UlDestroyLogDataBuffer( pResponse->pLogData );
    }

    //
    // Complete the IRP if we have one.
    //

    pIrp = pResponse->pIrp;

    if (pIrp)
    {
        //
        // Uncheck either ConnectionSendBytes or GlobalSendBytes.
        //

        UlUncheckSendLimit(
            pResponse->pRequest->pHttpConn,
            pResponse->ConnectionSendBytes,
            pResponse->GlobalSendBytes
            );

        //
        // Unset the Type3InputBuffer since we are completing the IRP.
        //

        pIrpSp = IoGetCurrentIrpStackLocation( pIrp );
        pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

        pIrp->IoStatus = pResponse->IoStatus;
        UlCompleteRequest( pIrp, IO_NETWORK_INCREMENT );
    }

    UL_DEREFERENCE_INTERNAL_REQUEST( pResponse->pRequest );

    if (pResponse->FromLookaside)
    {
        UlPplFreeResponseBuffer( pResponse );
    }
    else
    {
        UL_FREE_POOL_WITH_SIG( pResponse, UL_INTERNAL_RESPONSE_POOL_TAG );
    }

}   // UlpDestroyCapturedResponse


/***************************************************************************++

Routine Description:

    Process the UL_INTERNAL_RESPONSE we have created. If no other sends
    are being processed, start processing the current one by scheduling
    a worker item; otherwise, queue the current response in the pending
    response queue of the request. In the case where the request has been
    cleaned up (UlCancelRequestIo has been called), we immediately complete
    the response with STATUS_CANCELLED.

Arguments:

    pTracker - Supplies the tracker to send the response.

    FromKernelMode - If this comes from UlSendErrorResponse or not.

Return Values:

    None.

--***************************************************************************/
VOID
UlpEnqueueSendHttpResponse(
    IN PUL_CHUNK_TRACKER    pTracker,
    IN BOOLEAN              FromKernelMode
    )
{
    PUL_INTERNAL_RESPONSE   pResponse;
    PUL_INTERNAL_REQUEST    pRequest;
    BOOLEAN                 ProcessCurrentResponse = FALSE;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );
    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pTracker->pResponse ) );
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pTracker->pResponse->pRequest ) );

    pResponse = pTracker->pResponse;
    pRequest = pResponse->pRequest;

    if (!FromKernelMode)
    {
        UlAcquirePushLockExclusive( &pRequest->pHttpConn->PushLock );
    }

    if (!pRequest->InCleanup)
    {
        if (pRequest->SendInProgress)
        {
            InsertTailList(
                &pRequest->ResponseHead,
                &pTracker->ListEntry
                );
        }
        else
        {
            ASSERT( IsListEmpty( &pRequest->ResponseHead ) );

            //
            // Start the send process (and set the SendInProgress flag) if
            // there are no other sends in progress. The SendInProgress flag
            // is removed from the list when the last piece of the data is
            // pended in TDI. If an error occurs, the connection gets reset
            // so UlCancelRequestIo will eventually cancel all pending sends.
            //

            pRequest->SendInProgress = 1;
            ProcessCurrentResponse = TRUE;
        }
    }
    else
    {
        UlCompleteSendResponse( pTracker, STATUS_CONNECTION_RESET );
    }

    if (!FromKernelMode)
    {
        UlReleasePushLockExclusive( &pRequest->pHttpConn->PushLock );

        if (ProcessCurrentResponse)
        {
            //
            // Call UlpSendHttpResponseWorker directly if this comes from the
            // IOCTL. This is to reduce potential contentions on the
            // HttpConnection push lock when sends are overlapped since an
            // application semantically can't really send again until the
            // previous call returns (not necessarily completes). Calling
            // UlpSendHttpResponseWorker directly will cleanup the
            // SendInProgress flag most of the time when the send returns
            // unless the send requires disk I/O.
            //

            UlpSendHttpResponseWorker( &pTracker->WorkItem );
        }
    }
    else
    {
        if (ProcessCurrentResponse)
        {
            //
            // But if this is called from kernel mode, we need to queue a
            // work item to be safe because TDI can complete a send inline
            // resulting UlResumeParsing getting called with the
            // HttpConnection push lock held.
            //

            UlpQueueResponseWorkItem(
                &pTracker->WorkItem,
                UlpSendHttpResponseWorker,
                pTracker->pResponse->SyncRead
                );
        }
    }

}   // UlpEnqueueSendHttpResponse


/***************************************************************************++

Routine Description:

    Unset SendInProgress flag and the try to remove the next response from
    the request's response list. If there are more responses pending, start
    processing them as well.

Arguments:

    pRequest - Supplies the request that has a list of responses queued.

Return Values:

    None.

--***************************************************************************/
VOID
UlpDequeueSendHttpResponse(
    IN PUL_INTERNAL_REQUEST pRequest
    )
{
    PLIST_ENTRY             pEntry;
    IN PUL_CHUNK_TRACKER    pTracker;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pRequest ) );
    ASSERT( pRequest->SendInProgress );

    UlAcquirePushLockExclusive( &pRequest->pHttpConn->PushLock );

    if (!pRequest->InCleanup && !IsListEmpty(&pRequest->ResponseHead))
    {
        pEntry = RemoveHeadList( &pRequest->ResponseHead );

        pTracker = CONTAINING_RECORD(
                        pEntry,
                        UL_CHUNK_TRACKER,
                        ListEntry
                        );

        ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );
        ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pTracker->pResponse ) );

        //
        // Start the send process for the next response in the request's
        // response list.
        //

        UlpQueueResponseWorkItem(
            &pTracker->WorkItem,
            UlpSendHttpResponseWorker,
            pTracker->pResponse->SyncRead
            );
    }
    else
    {
        ASSERT( IsListEmpty( &pRequest->ResponseHead ) );

        //
        // No more pending send IRPs. This means we can take the fast send
        // path if asked so.
        //

        pRequest->SendInProgress = 0;
    }

    UlReleasePushLockExclusive( &pRequest->pHttpConn->PushLock );

}   // UlpDequeueSendHttpResponse


/***************************************************************************++

Routine Description:

    Worker routine for managing an in-progress UlSendHttpResponse().

Arguments:

    pWorkItem - Supplies a pointer to the work item queued. This should
        point to the WORK_ITEM structure embedded in a UL_CHUNK_TRACKER.

Return Values:

    None.

--***************************************************************************/
VOID
UlpSendHttpResponseWorker(
    IN PUL_WORK_ITEM        pWorkItem
    )
{
    PUL_CHUNK_TRACKER       pTracker;
    NTSTATUS                Status;
    PUL_INTERNAL_DATA_CHUNK pCurrentChunk;
    PUL_FILE_CACHE_ENTRY    pFileCacheEntry;
    PUL_FILE_BUFFER         pFileBuffer;
    PMDL                    pNewMdl;
    ULONG                   RunCount;
    ULONG                   BytesToRead;
    BOOLEAN                 ResumeParsing = FALSE;
    PUL_URI_CACHE_ENTRY     pFragmentCacheEntry;
    PUL_INTERNAL_RESPONSE   pResponse;
    PUL_MDL_RUN             pMdlRuns;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pTracker = CONTAINING_RECORD(
                    pWorkItem,
                    UL_CHUNK_TRACKER,
                    WorkItem
                    );

    UlTrace(SEND_RESPONSE, (
        "UlpSendHttpResponseWorker: tracker %p\n",
        pTracker
        ));

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    pResponse = pTracker->pResponse;

    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pResponse ) );

    Status = STATUS_SUCCESS;

    pMdlRuns = &pTracker->SendInfo.MdlRuns[0];

    while (TRUE)
    {
        //
        // Capture the current chunk pointer, then check for end of
        // response.
        //

        pCurrentChunk = &pResponse->pDataChunks[pResponse->CurrentChunk];

        if (IS_SEND_COMPLETE(pResponse))
        {
            ASSERT( Status == STATUS_SUCCESS );
            break;
        }

        RunCount = pTracker->SendInfo.MdlRunCount;

        //
        // Determine the chunk type.
        //

        if (IS_FROM_MEMORY(pCurrentChunk) ||
            IS_FROM_FRAGMENT_CACHE(pCurrentChunk))
        {
            //
            // It's from a locked-down memory buffer or fragment cache.
            // Since these are always handled in-line (never pended) we can
            // go ahead and adjust the current chunk pointer in the
            // tracker.
            //

            UlpIncrementChunkPointer( pResponse );

            if (IS_FROM_MEMORY(pCurrentChunk))
            {
                //
                // Ignore empty buffers.
                //

                if (pCurrentChunk->FromMemory.BufferLength == 0)
                {
                    continue;
                }

                //
                // Clone the incoming MDL.
                //

                ASSERT( pCurrentChunk->FromMemory.pMdl->Next == NULL );
                pNewMdl = UlCloneMdl(
                            pCurrentChunk->FromMemory.pMdl,
                            MmGetMdlByteCount(pCurrentChunk->FromMemory.pMdl)
                            );
            }
            else
            {
                //
                // Build a partial MDL for the cached data.
                //

                pFragmentCacheEntry =
                    pCurrentChunk->FromFragmentCache.pCacheEntry;

                //
                // Ignore cached HEAD responses.
                //

                if (pFragmentCacheEntry->ContentLength == 0)
                {
                    continue;
                }

                pNewMdl = UlCloneMdl(
                            pFragmentCacheEntry->pMdl,
                            pFragmentCacheEntry->ContentLength
                            );
            }

            if (pNewMdl == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            //
            // Update the buffered byte count and append the cloned MDL
            // onto our MDL chain.
            //

            pTracker->SendInfo.BytesBuffered += MmGetMdlByteCount( pNewMdl );
            (*pTracker->SendInfo.pMdlLink) = pNewMdl;
            pTracker->SendInfo.pMdlLink = &pNewMdl->Next;

            //
            // Add the MDL to the run list. As an optimization, if the
            // last run in the list was "from memory", we can just
            // append the MDL to the last run. A "from fragment cache"
            // chunk is similar to "from memory".
            //

            if (RunCount == 0 ||
                IS_FILE_BUFFER_IN_USE(&pMdlRuns[RunCount - 1].FileBuffer))
            {
                //
                // Create a new run.
                //

                pMdlRuns[RunCount].pMdlTail = pNewMdl;
                pTracker->SendInfo.MdlRunCount++;

                pFileBuffer = &pMdlRuns[RunCount].FileBuffer;
                RtlZeroMemory( pFileBuffer, sizeof(*pFileBuffer) );

                //
                // If we have exhausted our static MDL run array,
                // then we'll need to initiate a flush.
                //

                if (UL_MAX_MDL_RUNS == pTracker->SendInfo.MdlRunCount)
                {
                    ASSERT( Status == STATUS_SUCCESS );
                    break;
                }
            }
            else
            {
                //
                // Append to the last run in the list.
                //

                pMdlRuns[RunCount - 1].pMdlTail->Next = pNewMdl;
                pMdlRuns[RunCount - 1].pMdlTail = pNewMdl;
            }
        }
        else
        {
            //
            // It's a filesystem MDL.
            //

            ASSERT( IS_FROM_FILE_HANDLE( pCurrentChunk ) );

            //
            // Ignore 0 bytes read.
            //

            if (pResponse->FileBytesRemaining.QuadPart == 0)
            {
                UlpIncrementChunkPointer( pResponse );
                continue;
            }

            pFileCacheEntry = &pCurrentChunk->FromFileHandle.FileCacheEntry;
            ASSERT( IS_VALID_FILE_CACHE_ENTRY( pFileCacheEntry ) );

            pFileBuffer = &pMdlRuns[RunCount].FileBuffer;

            ASSERT( pFileBuffer->pMdl == NULL );
            ASSERT( pFileBuffer->pFileData == NULL );

            RtlZeroMemory( pFileBuffer, sizeof(*pFileBuffer) );

            //
            // Initiate file read.
            //

            BytesToRead = MIN(
                            g_UlMaxBytesPerRead,
                            (ULONG) pResponse->FileBytesRemaining.QuadPart
                            );

            //
            // Initialize the UL_FILE_BUFFER.
            //

            pFileBuffer->pFileCacheEntry    = pFileCacheEntry;
            pFileBuffer->FileOffset         = pResponse->FileOffset;
            pFileBuffer->Length             = BytesToRead;
            pFileBuffer->pCompletionRoutine = UlpRestartMdlRead;
            pFileBuffer->pContext           = pTracker;

            //
            // Bump up the tracker refcount before starting the Read I/O.
            // In case Send operation later on will complete before the read,
            // we still want the tracker around until UlpRestartMdlRead
            // finishes its business. It will be released when
            // UlpRestartMdlRead gets called back.
            //

            UL_REFERENCE_CHUNK_TRACKER( pTracker );

            //
            // Issue the I/O.
            //

            Status = UlReadFileEntry(
                            pFileBuffer,
                            pTracker->pIrp
                            );

            //
            // If the read isn't pending, then deref the tracker since
            // UlpRestartMdlRead isn't going to get called.
            //

            if (Status != STATUS_PENDING)
            {
                UL_DEREFERENCE_CHUNK_TRACKER( pTracker );
            }

            break;
        }
    }

    //
    // If we fell out of the above loop with status == STATUS_SUCCESS,
    // then the last send we issued was buffered and needs to be flushed.
    // Otherwise, if the status is anything but STATUS_PENDING, then we
    // hit an in-line failure and need to complete the original request.
    //

    if (Status == STATUS_SUCCESS)
    {
        if (IS_SEND_COMPLETE(pResponse) &&
            UlResumeParsingOnLastSend == pResponse->ResumeParsingType)
        {
            ResumeParsing = TRUE;
        }

        if (pTracker->SendInfo.BytesBuffered > 0)
        {
            //
            // Flush the send.
            //

            Status = UlpFlushMdlRuns( pTracker );
        }
        else
        if (IS_DISCONNECT_TIME(pResponse))
        {
            //
            // Increment up until connection close is complete.
            //

            UL_REFERENCE_CHUNK_TRACKER( pTracker );

            Status = UlDisconnectHttpConnection(
                            pTracker->pHttpConnection,
                            UlpCloseConnectionComplete,
                            pTracker
                            );

            ASSERT( Status == STATUS_PENDING );
        }

        //
        // Kick the parser into action if this is the last send for the
        // keep-alive. Resuming parsing here improves latency when incoming
        // requests are pipelined.
        //

        if (ResumeParsing)
        {
            UlTrace(HTTP_IO, (
                "http!UlpSendHttpResponseWorker(pHttpConn = %p), "
                "RequestVerb=%d, ResponseStatusCode=%hu\n",
                pResponse->pRequest->pHttpConn,
                pResponse->pRequest->Verb,
                pResponse->StatusCode
                ));

            UlResumeParsing(
                pResponse->pRequest->pHttpConn,
                FALSE,
                (BOOLEAN) (pResponse->Flags & HTTP_SEND_RESPONSE_FLAG_DISCONNECT)
                );
        }
    }

    //
    // Did everything complete?
    //

    if (Status != STATUS_PENDING)
    {
        //
        // Nope, something went wrong!
        //

        UlCompleteSendResponse( pTracker, Status );
    }
    else
    {
        //
        // Release our grab on the tracker we are done with it.
        //

        UL_DEREFERENCE_CHUNK_TRACKER( pTracker );
    }

}   // UlpSendHttpResponseWorker


/***************************************************************************++

Routine Description:

    Completion handler for UlCloseConnection().

Arguments:

    pCompletionContext - Supplies an uninterpreted context value
        as passed to the asynchronous API. This is actually a
        PUL_CHUNK_TRACKER pointer.

    Status - Supplies the final completion status of the
        asynchronous API.

    Information - Optionally supplies additional information about
        the completed operation, such as the number of bytes
        transferred. This field is unused for UlCloseConnection().

Return Values:

    None.

--***************************************************************************/
VOID
UlpCloseConnectionComplete(
    IN PVOID            pCompletionContext,
    IN NTSTATUS         Status,
    IN ULONG_PTR        Information
    )
{
    PUL_CHUNK_TRACKER   pTracker;

    UNREFERENCED_PARAMETER( Information );

    //
    // Snag the context.
    //

    pTracker = (PUL_CHUNK_TRACKER) pCompletionContext;

    UlTrace(SEND_RESPONSE, (
        "UlpCloseConnectionComplete: tracker %p\n",
        pTracker
        ));

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    UlCompleteSendResponse( pTracker, Status );

}   // UlpCloseConnectionComplete


/***************************************************************************++

Routine Description:

    Allocates a new send tracker. The newly created tracker must eventually
    be freed with UlpFreeChunkTracker().

Arguments:

    SendIrpStackSize - Supplies the stack size for the network send IRPs.

    ReadIrpStackSize - Supplies the stack size for the file system read
        IRPs.

Return Value:

    PUL_CHUNK_TRACKER - The new send tracker if successful, NULL otherwise.

--***************************************************************************/
PUL_CHUNK_TRACKER
UlpAllocateChunkTracker(
    IN UL_TRACKER_TYPE          TrackerType,
    IN CCHAR                    SendIrpStackSize,
    IN CCHAR                    ReadIrpStackSize,
    IN BOOLEAN                  FirstResponse,
    IN PUL_HTTP_CONNECTION      pHttpConnection,
    IN PUL_INTERNAL_RESPONSE    pResponse
    )
{
    PUL_CHUNK_TRACKER           pTracker;
    CCHAR                       MaxIrpStackSize;
    USHORT                      MaxIrpSize;
    ULONG                       ChunkTrackerSize;

    ASSERT( TrackerType == UlTrackerTypeSend ||
            TrackerType == UlTrackerTypeBuildUriEntry
            );

    MaxIrpStackSize = MAX(SendIrpStackSize, ReadIrpStackSize);

    //
    // Try to allocate from the lookaside list if possible.
    //

    if (MaxIrpStackSize > DEFAULT_MAX_IRP_STACK_SIZE)
    {
        MaxIrpSize = (USHORT) ALIGN_UP(IoSizeOfIrp(MaxIrpStackSize), PVOID);

        ChunkTrackerSize = ALIGN_UP(sizeof(UL_CHUNK_TRACKER), PVOID) +
                           MaxIrpSize;

        pTracker = (PUL_CHUNK_TRACKER) UL_ALLOCATE_POOL(
                                            NonPagedPool,
                                            ChunkTrackerSize,
                                            UL_CHUNK_TRACKER_POOL_TAG
                                            );

        if (pTracker)
        {
            pTracker->Signature = UL_CHUNK_TRACKER_POOL_TAG;
            pTracker->IrpContext.Signature = UL_IRP_CONTEXT_SIGNATURE;
            pTracker->FromLookaside = FALSE;

            //
            // Set up the IRP.
            //

            pTracker->pIrp = (PIRP)
                ((PCHAR)pTracker + ALIGN_UP(sizeof(UL_CHUNK_TRACKER), PVOID));

            IoInitializeIrp(
                pTracker->pIrp,
                MaxIrpSize,
                MaxIrpStackSize
                );
        }
    }
    else
    {
        pTracker = UlPplAllocateChunkTracker();
    }

    if (pTracker != NULL)
    {
        pTracker->Type = TrackerType;
        pTracker->FirstResponse = FirstResponse;

        //
        // RefCounting is necessary since we might have two Aysnc (Read & Send)
        // Io Operation on the same tracker along the way.
        //

        pTracker->RefCount   = 1;
        pTracker->Terminated = 0;

        //
        // Tracker will keep a reference to the connection.
        //

        UL_REFERENCE_HTTP_CONNECTION( pHttpConnection );
        pTracker->pHttpConnection = pHttpConnection;

        //
        // Response info.
        //

        UL_REFERENCE_INTERNAL_RESPONSE( pResponse );
        pTracker->pResponse = pResponse;

        //
        // Zero the remaining fields.
        //

        UlInitializeWorkItem( &pTracker->WorkItem );

        RtlZeroMemory(
            (PUCHAR)pTracker + FIELD_OFFSET(UL_CHUNK_TRACKER, IoStatus),
            sizeof(*pTracker) - FIELD_OFFSET(UL_CHUNK_TRACKER, IoStatus)
            );

        if (TrackerType == UlTrackerTypeSend)
        {
            UlpInitMdlRuns( pTracker );
        }
    }

    if (TrackerType == UlTrackerTypeSend)
    {
        UlTrace(SEND_RESPONSE, (
            "Http!UlpAllocateChunkTracker: tracker %p (send)\n",
            pTracker
            ));
    }
    else
    {
        UlTrace(URI_CACHE, (
            "Http!UlpAllocateChunkTracker: tracker %p (build uri)\n",
            pTracker
            ));
    }

    return pTracker;

}   // UlpAllocateChunkTracker


/***************************************************************************++

Routine Description:

    Frees a chunk tracker allocated with UlpAllocateChunkTracker().
    If this is a send tracker, also free the MDL_RUNs attached to it.

Arguments:

    pWorkItem - Supplies the work item embedded in UL_CHUNK_TRACKER.

Return Value:

    None.

--***************************************************************************/
VOID
UlpFreeChunkTracker(
    IN PUL_WORK_ITEM        pWorkItem
    )
{
    PUL_CHUNK_TRACKER       pTracker;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pTracker = CONTAINING_RECORD(
                    pWorkItem,
                    UL_CHUNK_TRACKER,
                    WorkItem
                    );

    ASSERT( pTracker );
    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );
    ASSERT( pTracker->Type == UlTrackerTypeSend ||
            pTracker->Type == UlTrackerTypeBuildUriEntry
            );

    //
    // Free the MDLs attached if this is a send tracker.
    //

    if (pTracker->Type == UlTrackerTypeSend)
    {
        UlTrace(SEND_RESPONSE, (
            "Http!UlpFreeChunkTracker: tracker %p (send)\n",
            pTracker
            ));

        UlpFreeMdlRuns( pTracker );
    }
    else
    {
        UlTrace(URI_CACHE, (
            "Http!UlpFreeChunkTracker: tracker %p (build uri)\n",
            pTracker
            ));
    }

#if DBG
    //
    // There should be no file buffer hanging around at this time.
    //

    if (pTracker->Type == UlTrackerTypeSend)
    {
        ULONG       i;
        PUL_MDL_RUN pMdlRun = &pTracker->SendInfo.MdlRuns[0];

        for (i = 0; i < UL_MAX_MDL_RUNS; i++)
        {
            if (pMdlRun->FileBuffer.pFileCacheEntry)
            {
                ASSERT( pMdlRun->FileBuffer.pMdl == NULL );
                ASSERT( pMdlRun->FileBuffer.pFileData == NULL );
            }
            pMdlRun++;
        }
    }
#endif // DBG

    //
    // Release our ref to the connection and response.
    //

    UL_DEREFERENCE_HTTP_CONNECTION( pTracker->pHttpConnection );
    UL_DEREFERENCE_INTERNAL_RESPONSE( pTracker->pResponse );

    if (pTracker->FromLookaside)
    {
        UlPplFreeChunkTracker( pTracker );
    }
    else
    {
        UL_FREE_POOL_WITH_SIG( pTracker, UL_CHUNK_TRACKER_POOL_TAG );
    }

}   // UlpFreeChunkTracker


/***************************************************************************++

Routine Description:

    Increments the reference count on the chunk tracker.

Arguments:

    pTracker - Supplies the chunk trucker to the reference.

    pFileName (REFERENCE_DEBUG only) - Supplies the name of the file
        containing the calling function.

    LineNumber (REFERENCE_DEBUG only) - Supplies the line number of
        the calling function.

Return Value:

    None.

--***************************************************************************/
VOID
UlReferenceChunkTracker(
    IN PUL_CHUNK_TRACKER    pTracker
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG                    RefCount;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    //
    // Reference it.
    //

    RefCount = InterlockedIncrement( &pTracker->RefCount );
    ASSERT( RefCount > 1 );

    //
    // Keep the logs updated.
    //

    WRITE_REF_TRACE_LOG(
        g_pChunkTrackerTraceLog,
        REF_ACTION_REFERENCE_CHUNK_TRACKER,
        RefCount,
        pTracker,
        pFileName,
        LineNumber
        );

    UlTrace(SEND_RESPONSE,(
        "Http!UlReferenceChunkTracker: tracker %p RefCount %ld\n",
        pTracker,
        RefCount
        ));

}   // UlReferenceChunkTracker


/***************************************************************************++

Routine Description:

    Decrements the reference count on the specified chunk tracker.

Arguments:

    pTracker - Supplies the chunk trucker to the reference.

    pFileName (REFERENCE_DEBUG only) - Supplies the name of the file
        containing the calling function.

    LineNumber (REFERENCE_DEBUG only) - Supplies the line number of
        the calling function.

Return Value:

    None.

--***************************************************************************/
VOID
UlDereferenceChunkTracker(
    IN PUL_CHUNK_TRACKER    pTracker
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG                    RefCount;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    //
    // Dereference it.
    //

    RefCount = InterlockedDecrement( &pTracker->RefCount );
    ASSERT(RefCount >= 0);

    //
    // Keep the logs updated.
    //

    WRITE_REF_TRACE_LOG(
        g_pChunkTrackerTraceLog,
        REF_ACTION_DEREFERENCE_CHUNK_TRACKER,
        RefCount,
        pTracker,
        pFileName,
        LineNumber
        );

    UlTrace(SEND_RESPONSE,(
        "Http!UlDereferenceChunkTracker: tracker %p RefCount %ld\n",
        pTracker,
        RefCount
        ));

    if (RefCount == 0)
    {
        //
        // The final reference to the chunk tracker has been removed,
        // so it's time to free-up the ChunkTracker.
        //

        UL_CALL_PASSIVE(
            &pTracker->WorkItem,
            UlpFreeChunkTracker
            );
    }

}   // UlDereferenceChunkTracker


/***************************************************************************++

Routine Description:

    Closes the connection if neccessary, cleans up trackers, and completes
    the response.

Arguments:

    pWorkItem - Supplies the work item embedded in our UL_CHUNK_TRACKER.

Return Value:

    None.

--***************************************************************************/
VOID
UlpCompleteSendResponseWorker(
    PUL_WORK_ITEM           pWorkItem
    )
{
    PUL_CHUNK_TRACKER       pTracker;
    PUL_COMPLETION_ROUTINE  pCompletionRoutine;
    PVOID                   pCompletionContext;
    PUL_HTTP_CONNECTION     pHttpConnection;
    PUL_INTERNAL_REQUEST    pRequest;
    PUL_INTERNAL_RESPONSE   pResponse;
    NTSTATUS                Status;
    ULONGLONG               BytesTransferred;
    KIRQL                   OldIrql;
    BOOLEAN                 ResumeParsing;
    BOOLEAN                 InDisconnect;
    HTTP_VERB               RequestVerb;
    USHORT                  ResponseStatusCode;
    PUL_LOG_DATA_BUFFER     pLogData; 

    //
    // Sanity check.
    //

    PAGED_CODE();

    pTracker = CONTAINING_RECORD(
                    pWorkItem,
                    UL_CHUNK_TRACKER,
                    WorkItem
                    );

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    pResponse = pTracker->pResponse;

    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pResponse ) );
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pResponse->pRequest ) );
    ASSERT( !pResponse->pLogData );
    ASSERT( pResponse->ResumeParsingType != UlResumeParsingOnSendCompletion );

    //
    // Pull info from the tracker.
    //

    RequestVerb         = pResponse->pRequest->Verb;
    pCompletionRoutine  = pResponse->pCompletionRoutine;
    pCompletionContext  = pResponse->pCompletionContext;
    pRequest            = pResponse->pRequest;
    BytesTransferred    = pResponse->BytesTransferred;
    ResponseStatusCode  = pResponse->StatusCode;
    Status              = pTracker->IoStatus.Status;
    pHttpConnection     = pTracker->pHttpConnection;
    ResumeParsing       = FALSE;
    pLogData            = NULL;
    InDisconnect = (BOOLEAN)
        (pResponse->Flags & HTTP_SEND_RESPONSE_FLAG_DISCONNECT);

    TRACE_TIME(
        pHttpConnection->ConnectionId,
        pRequest->RequestId,
        TIME_ACTION_SEND_COMPLETE
        );

    //
    // Reset the connection if there was an error.
    //

    if (!NT_SUCCESS(Status))
    {
        UlCloseConnection(
            pHttpConnection->pConnection,
            TRUE,
            NULL,
            NULL
            );
    }

    //
    // Adjust the bytes sent and send status on the request.
    //

    UlInterlockedAdd64(
        (PLONGLONG) &pRequest->BytesSent,
        BytesTransferred
        );

    if (!NT_SUCCESS(Status) && NT_SUCCESS(pRequest->LogStatus))
    {
        pRequest->LogStatus = Status;
    }

    IF_DEBUG(LOGBYTES)
    {
        TIME_FIELDS RcvdTimeFields;

        RtlTimeToTimeFields( &pRequest->TimeStamp, &RcvdTimeFields );

        UlTrace(LOGBYTES, (
            "Http!UlpCompleteSendResponseWorker: [Rcvd @ %02d:%02d:%02d] "
            "Bytes %010I64u Total %010I64u Status %08lX\n",
            RcvdTimeFields.Hour,
            RcvdTimeFields.Minute,
            RcvdTimeFields.Second,
            BytesTransferred,
            pRequest->BytesSent,
            Status
            ));
    }

    //
    // Stop MinBytesPerSecond timer and start Connection Idle timer.
    //

    UlLockTimeoutInfo(
        &pHttpConnection->TimeoutInfo,
        &OldIrql
        );

    //
    // Turn off MinBytesPerSecond timer if there are no outstanding sends.
    //

    UlResetConnectionTimer(
        &pHttpConnection->TimeoutInfo,
        TimerMinBytesPerSecond
        );

    if (0 == (pResponse->Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) &&
        pRequest->ParseState >= ParseDoneState)
    {
        //
        // Turn on Idle Timer if there's no more response data AND all of
        // the request data has been received.
        //

        UlSetConnectionTimer(
            &pHttpConnection->TimeoutInfo,
            TimerConnectionIdle
            );
    }

    UlUnlockTimeoutInfo(
        &pHttpConnection->TimeoutInfo,
        OldIrql
        );

    UlEvaluateTimerState(
        &pHttpConnection->TimeoutInfo
        );

    //
    // Adjust SendsPending and if that drops to zero, see if we need to log
    // and resume parsing.
    //

    UlUnsetRequestSendsPending(
        pRequest,
        &pLogData,
        &ResumeParsing
        );

    if (pLogData)
    {
        UlLogHttpResponse( pRequest, pLogData );
    }

    //
    // Unlink the request from process if we are done with all sends.
    //

    if (0 == (pResponse->Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) &&
        0 == pRequest->ContentLength &&
        0 == pRequest->Chunked &&
        pRequest->ConfigInfo.pAppPool)
    {
        ASSERT( pRequest->SentLast );

        UlUnlinkRequestFromProcess(
            pRequest->ConfigInfo.pAppPool,
            pRequest
            );
    }

    //
    // Complete the send response IRP.
    //

    ASSERT( pCompletionRoutine != NULL );

    (pCompletionRoutine)(
        pCompletionContext,
        Status,
        (ULONG) MIN(BytesTransferred, MAXULONG)
        );

    //
    // Kick the parser on the connection and release our hold.
    //

    if (ResumeParsing && STATUS_SUCCESS == Status)
    {
        UlTrace(HTTP_IO, (
            "http!UlpCompleteSendResponseWorker(pHttpConn = %p), "
            "RequestVerb=%d, ResponseStatusCode=%hu\n",
            pHttpConnection,
            RequestVerb,
            ResponseStatusCode
            ));

        UlResumeParsing( pHttpConnection, FALSE, InDisconnect );
    }

    //
    // Deref the tracker that we have bumped up before queueing this worker
    // function. This has to be done after UlResumeParsing since the tracker
    // holds a reference on the HTTP connection.
    //

    UL_DEREFERENCE_CHUNK_TRACKER( pTracker );

}   // UlpCompleteSendResponseWorker


/***************************************************************************++

Routine Description:

    Completion handler for MDL READ IRPs used for reading file data.

Arguments:

    pDeviceObject - Supplies the device object for the IRP being
        completed.

    pIrp - Supplies the IRP being completed.

    pContext - Supplies the context associated with this request.
        This is actually a PUL_CHUNK_TRACKER.

Return Value:

    NTSTATUS - STATUS_SUCCESS if IO should continue processing this
        IRP, STATUS_MORE_PROCESSING_REQUIRED if IO should stop processing
        this IRP.

--***************************************************************************/
NTSTATUS
UlpRestartMdlRead(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    )
{
    PUL_CHUNK_TRACKER   pTracker;

    UNREFERENCED_PARAMETER( pDeviceObject );

    pTracker = (PUL_CHUNK_TRACKER) pContext;

    UlTrace(SEND_RESPONSE, (
        "UlpRestartMdlRead: tracker %p\n",
        pTracker
        ));

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    pTracker->IoStatus = pIrp->IoStatus;

    UlpQueueResponseWorkItem(
        &pTracker->WorkItem,
        UlpMdlReadCompleteWorker,
        pTracker->pResponse->SyncRead
        );

    return STATUS_MORE_PROCESSING_REQUIRED;

}   // UlpRestartMdlRead


/***************************************************************************++

Routine Description:

    The worker routine for UlpRestartMdlRead since we can potentially call
    into UlResumeParsing which requires PASSIVE.

Arguments:

    pWorkItem - Supplies the work item embedded in UL_CHUNK_TRACKER.

Return Value:

    None.

--***************************************************************************/
VOID
UlpMdlReadCompleteWorker(
    IN PUL_WORK_ITEM        pWorkItem
    )
{
    NTSTATUS                Status;
    PUL_CHUNK_TRACKER       pTracker;
    PUL_INTERNAL_RESPONSE   pResponse;
    ULONG                   BytesRead;
    PMDL                    pMdl;
    PMDL                    pMdlTail;
    BOOLEAN                 ResumeParsing = FALSE;
    PUL_MDL_RUN             pMdlRun;
    PUL_FILE_BUFFER         pFileBuffer;
    ULONG                   RunCount;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pTracker = CONTAINING_RECORD(
                    pWorkItem,
                    UL_CHUNK_TRACKER,
                    WorkItem
                    );

    UlTrace(SEND_RESPONSE, (
        "UlpMdlReadCompleteWorker: tracker %p\n",
        pTracker
        ));

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    pResponse = pTracker->pResponse;

    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pResponse ) );

    //
    // Get the last MdlRun from the tracker.
    //

    RunCount = pTracker->SendInfo.MdlRunCount;
    pMdlRun  = &pTracker->SendInfo.MdlRuns[RunCount];

    Status = pTracker->IoStatus.Status;

    if (NT_SUCCESS(Status))
    {
        BytesRead = (ULONG) pTracker->IoStatus.Information;

        if (BytesRead)
        {
            pFileBuffer = &pMdlRun->FileBuffer;
            pMdl        = pFileBuffer->pMdl;

            ASSERT( pMdl );

            //
            // Update the buffered byte count and append the new MDL onto
            // our MDL chain.
            //

            pMdlTail = UlFindLastMdlInChain( pMdl );

            pTracker->SendInfo.BytesBuffered += BytesRead;
            (*pTracker->SendInfo.pMdlLink) = pMdl;
            pTracker->SendInfo.pMdlLink = &pMdlTail->Next;

            pMdlRun->pMdlTail = pMdlTail;
            pTracker->SendInfo.MdlRunCount++;

            //
            // Update the file offset & bytes remaining. If we've
            // finished this file chunk (bytes remaining is now zero)
            // then advance to the next chunk.
            //

            pResponse->FileOffset.QuadPart += (ULONGLONG) BytesRead;
            pResponse->FileBytesRemaining.QuadPart -= (ULONGLONG) BytesRead;
        }
        else
        {
            ASSERT( !"Status success but zero bytes received!" );
        }

        if (pResponse->FileBytesRemaining.QuadPart == 0)
        {
            UlpIncrementChunkPointer( pResponse );
        }

        //
        // If we've not exhausted our static MDL run array,
        // we've exceeded the maximum number of bytes we want to
        // buffer, then we'll need to initiate a flush.
        //

        if (IS_SEND_COMPLETE(pResponse) ||
            UL_MAX_MDL_RUNS == pTracker->SendInfo.MdlRunCount ||
            pTracker->SendInfo.BytesBuffered >= g_UlMaxBytesPerSend)
        {
            if (IS_SEND_COMPLETE(pResponse) &&
                UlResumeParsingOnLastSend == pResponse->ResumeParsingType)
            {
                ResumeParsing = TRUE;
            }

            Status = UlpFlushMdlRuns( pTracker );

            //
            // Kick the parser into action if this is the last send for the
            // keep-alive. Resuming parsing here improves latency when incoming
            // requests are pipelined.
            //

            if (ResumeParsing)
            {
                UlTrace(HTTP_IO, (
                    "http!UlpRestartMdlRead(pHttpConn = %p), "
                    "RequestVerb=%d, ResponseStatusCode=%hu\n",
                    pResponse->pRequest->pHttpConn,
                    pResponse->pRequest->Verb,
                    pResponse->StatusCode
                    ));

                UlResumeParsing(
                    pResponse->pRequest->pHttpConn,
                    FALSE,
                    (BOOLEAN) (pResponse->Flags & HTTP_SEND_RESPONSE_FLAG_DISCONNECT)
                    );
            }
        }
        else
        {
            //
            // RefCount the chunk tracker up for the UlpSendHttpResponseWorker.
            // It will DeRef it when it's done with the chunk tracker itself.
            // Since this is a passive call we had to increment the refcount
            // for this guy to make sure that tracker is around until it wakes
            // up. Other places makes calls to UlpSendHttpResponseWorker has
            // also been updated as well.
            //

            UL_REFERENCE_CHUNK_TRACKER( pTracker );

            UlpSendHttpResponseWorker( &pTracker->WorkItem );
        }
    }
    else
    {
        //
        // Do not increment the MdlRunCount, as we are not able to update the
        // MDL Links. Instead cleanup the last allocated MDL Run for the read.
        //

        UlpFreeFileMdlRun( pTracker, pMdlRun );
    }

    if (!NT_SUCCESS(Status))
    {
        UlCompleteSendResponse( pTracker, Status );
    }
    else
    {
        //
        // Read I/O has been completed release our refcount
        // on the chunk tracker.
        //

        UL_DEREFERENCE_CHUNK_TRACKER( pTracker );
    }

}   // UlpMdlReadCompleteWorker


/***************************************************************************++

Routine Description:

    Completion handler for UlSendData().

Arguments:

    pCompletionContext - Supplies an uninterpreted context value
        as passed to the asynchronous API. This is actually a
        pointer to a UL_CHUNK_TRACKER structure.

    Status - Supplies the final completion status of the
        asynchronous API.

    Information - Optionally supplies additional information about
        the completed operation, such as the number of bytes
        transferred.

Return Value:

    None.

--***************************************************************************/
VOID
UlpRestartMdlSend(
    IN PVOID            pCompletionContext,
    IN NTSTATUS         Status,
    IN ULONG_PTR        Information
    )
{
    PUL_CHUNK_TRACKER   pTracker;
    LONG                SendCount;

    pTracker = (PUL_CHUNK_TRACKER) pCompletionContext;

    UlTrace(SEND_RESPONSE, (
        "UlpRestartMdlSend: tracker %p\n",
        pTracker
        ));

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    //
    // Handle the completion in a work item. We need to get to passive
    // level and we also need to prevent a recursive loop on filtered
    // connections or any other case where our sends might all be
    // completing in-line.
    //

    if (pTracker->SendInfo.pMdlToSplit)
    {
        //
        // This is the split send.
        //

        SendCount = InterlockedDecrement( &pTracker->SendInfo.SendCount );
        ASSERT( SendCount >= 0 );

        if (0 == SendCount)
        {
            //
            // Simply drops the reference on the tracker if this is the
            // second part of the split send.
            //

            UL_DEREFERENCE_CHUNK_TRACKER( pTracker );
        }
        else
        {
            pTracker->IoStatus.Status = Status;

            if (NT_SUCCESS(Status))
            {
                //
                // Report the bytes transferred for the whole send in the
                // success case since we may have split into 2 TDI calls.
                //

                pTracker->IoStatus.Information = pTracker->SendInfo.BytesBuffered;
            }
            else
            {
                pTracker->IoStatus.Information = Information;
            }

            UlpQueueResponseWorkItem(
                &pTracker->WorkItem,
                UlpMdlSendCompleteWorker,
                pTracker->pResponse->SyncRead
                );
        }
    }
    else
    {
        //
        // This is the normal send.
        //

        ASSERT( -1 == pTracker->SendInfo.SendCount );

        pTracker->IoStatus.Status = Status;
        pTracker->IoStatus.Information = Information;

        UlpQueueResponseWorkItem(
            &pTracker->WorkItem,
            UlpMdlSendCompleteWorker,
            pTracker->pResponse->SyncRead
            );
    }

}   // UlpRestartMdlSend


/***************************************************************************++

Routine Description:

    Deferred handler for UlpRestartMdlSend.

Arguments:

    pWorkItem - Supplies a pointer to the work item queued. This should
        point to the WORK_ITEM structure embedded in a UL_CHUNK_TRACKER.

Return Value:

    None.

--***************************************************************************/
VOID
UlpMdlSendCompleteWorker(
    IN PUL_WORK_ITEM        pWorkItem
    )
{
    PUL_CHUNK_TRACKER       pTracker;
    PUL_CHUNK_TRACKER       pSendTracker;
    PUL_INTERNAL_RESPONSE   pResponse;
    PUL_HTTP_CONNECTION     pHttpConn;
    PDEVICE_OBJECT          pConnectionObject;
    NTSTATUS                Status;
    BOOLEAN                 DerefChunkTracker = TRUE;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pTracker = CONTAINING_RECORD(
                    pWorkItem,
                    UL_CHUNK_TRACKER,
                    WorkItem
                    );

    UlTrace(SEND_RESPONSE, (
        "UlpMdlSendCompleteWorker: tracker %p\n",
        pTracker
        ));

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );
    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pTracker->pResponse ) );

    pResponse = pTracker->pResponse;

    //
    // If the chunk completed successfully, then update the bytes
    // transferred and queue another work item for the next chunk if
    // there's more work to do. Otherwise, just complete the request now.
    //

    Status = pTracker->IoStatus.Status;

    if (NT_SUCCESS(Status))
    {
        pResponse->BytesTransferred += pTracker->IoStatus.Information;

        if (!IS_SEND_COMPLETE(pResponse))
        {
            //
            // Allocate a new send tracker for the next round of MDL_RUNs.
            //

            pHttpConn = pTracker->pHttpConnection;
            pConnectionObject =
                pHttpConn->pConnection->ConnectionObject.pDeviceObject;

            pSendTracker =
                UlpAllocateChunkTracker(
                    UlTrackerTypeSend,
                    pConnectionObject->StackSize,
                    pResponse->MaxFileSystemStackSize,
                    FALSE,
                    pHttpConn,
                    pResponse
                    );

            if (pSendTracker)
            {
                UlpSendHttpResponseWorker( &pSendTracker->WorkItem );
                goto end;
            }
            else
            {
                //
                // Reset the connection since we hit an internal error.
                //

                UlCloseConnection(
                    pHttpConn->pConnection,
                    TRUE,
                    NULL,
                    NULL
                    );

                Status = STATUS_NO_MEMORY;
            }
        }

    }

    //
    // All done.
    //

    UlCompleteSendResponse( pTracker, Status );

    //
    // UlCompleteSendResponse takes ownership of the CHUNK_TRACKER so no extra
    // dereference is required.
    //

    DerefChunkTracker = FALSE;

end:

    //
    // Release our grab on the Tracker. Send I/O is done for this MDL run.
    //

    if (DerefChunkTracker)
    {
        UL_DEREFERENCE_CHUNK_TRACKER( pTracker );
    }

}   // UlpMdlSendCompleteWorker


/***************************************************************************++

Routine Description:

    Flush the MDL_RUNs we have built so far.

Arguments:

    pTracker - Supplies the send tracker to flush.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpFlushMdlRuns(
    IN PUL_CHUNK_TRACKER    pTracker
    )
{
    PUL_INTERNAL_RESPONSE   pResponse;
    PMDL                    pMdlToSplit = NULL;
    PMDL                    pMdlPrevious;
    PMDL                    pMdlSplitFirst;
    PMDL                    pMdlSplitSecond = NULL;
    PMDL                    pMdlHead = NULL;
    ULONG                   BytesToSplit = 0;
    ULONG                   BytesBuffered;
    ULONG                   BytesPart1;
    ULONG                   BytesPart2;
    NTSTATUS                Status;
    BOOLEAN                 SendComplete;
    BOOLEAN                 CopySend = FALSE;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );
    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pTracker->pResponse ) );
    ASSERT( pTracker->SendInfo.pMdlHead );

    pResponse = pTracker->pResponse;
    SendComplete = (BOOLEAN) IS_SEND_COMPLETE( pResponse );

    //
    // We may need to split the send into 2 TDI calls if the send is *large*
    // and it is not filtered.
    //

    if (!pTracker->pHttpConnection->pConnection->FilterInfo.pFilterChannel &&
        pTracker->SendInfo.BytesBuffered > g_UlMaxCopyThreshold &&
        (!SendComplete || pResponse->CopySend))
    {
        //
        // These many bytes go to the first part of the MDL chain after split.
        //

        if (!SendComplete)
        {
            BytesToSplit = pTracker->SendInfo.BytesBuffered / 2;
        }
        else
        {
            ASSERT( pResponse->CopySend );

            CopySend = TRUE;
            BytesToSplit = pTracker->SendInfo.BytesBuffered -
                           g_UlMaxCopyThreshold;
        }

        //
        // Find the first MDL starting from pMdlHead that has more than
        // or equal to BytesToSplit bytes buffered.
        //

        pMdlPrevious = NULL;
        pMdlToSplit = pTracker->SendInfo.pMdlHead;
        BytesBuffered = 0;

        while (pMdlToSplit->Next)
        {
            if ((BytesBuffered + pMdlToSplit->ByteCount) >= BytesToSplit)
            {
                //
                // So the current MDL splits the chain.
                //

                break;
            }

            BytesBuffered += pMdlToSplit->ByteCount;
            pMdlPrevious = pMdlToSplit;
            pMdlToSplit = pMdlToSplit->Next;
        }

        ASSERT( pMdlToSplit );
        ASSERT( (BytesBuffered + pMdlToSplit->ByteCount) >= BytesToSplit );

        if ((BytesBuffered + pMdlToSplit->ByteCount) == BytesToSplit)
        {
            //
            // There is no need to build partial MDLs of the split MDL. The
            // whole MDL chain up to and including pMdlToSplit goes to the
            // first half the splitted chain and the MDL chain starting from
            // pMdlToSplit->Next goes to the second half.
            //

            ASSERT( pMdlToSplit->Next );

            pMdlHead = pTracker->SendInfo.pMdlHead;
            pMdlSplitFirst = pMdlToSplit;
            pMdlSplitSecond = pMdlToSplit->Next;
            pMdlToSplit->Next = NULL;
        }
        else
        {
            BytesPart2 = BytesBuffered + pMdlToSplit->ByteCount - BytesToSplit;
            BytesPart1 = pMdlToSplit->ByteCount - BytesPart2;

            ASSERT( BytesPart1 );
            ASSERT( BytesPart2 );

            pMdlSplitFirst =
                UlAllocateMdl(
                    (PCHAR) MmGetMdlVirtualAddress(pMdlToSplit),
                    BytesPart1,
                    FALSE,
                    FALSE,
                    NULL
                    );

            if (!pMdlSplitFirst)
            {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            pMdlSplitSecond =
                UlAllocateMdl(
                    (PCHAR) MmGetMdlVirtualAddress(pMdlToSplit) + BytesPart1,
                    BytesPart2,
                    FALSE,
                    FALSE,
                    NULL
                    );

            if (!pMdlSplitSecond)
            {
                UlFreeMdl( pMdlSplitFirst );
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            IoBuildPartialMdl(
                pMdlToSplit,
                pMdlSplitFirst,
                (PCHAR) MmGetMdlVirtualAddress(pMdlToSplit),
                BytesPart1
                );

            IoBuildPartialMdl(
                pMdlToSplit,
                pMdlSplitSecond,
                (PCHAR) MmGetMdlVirtualAddress(pMdlToSplit) + BytesPart1,
                BytesPart2
                );

            //
            // Relink the MDL chains after the split.
            //

            if (pMdlPrevious)
            {
                pMdlHead = pTracker->SendInfo.pMdlHead;
                pMdlPrevious->Next = pMdlSplitFirst;
            }
            else
            {
                ASSERT( pMdlToSplit == pTracker->SendInfo.pMdlHead );
                pMdlHead = pMdlSplitFirst;
            }

            pMdlSplitSecond->Next = pMdlToSplit->Next;
        }

        //
        // Remember how we have split the send.
        //

        pTracker->SendInfo.pMdlToSplit = pMdlToSplit;
        pTracker->SendInfo.pMdlPrevious = pMdlPrevious;
        pTracker->SendInfo.pMdlSplitFirst = pMdlSplitFirst;
        pTracker->SendInfo.pMdlSplitSecond = pMdlSplitSecond;
    }

    //
    // Make sure there are no other sends in progress on this response.
    // Wait if this is the case. Since it is possible for the first part
    // of the split send to complete inline, it can start a new MDL run
    // and proceed to flush *before* the second part of the split send
    // has a chance to pend the data in TDI. Of course, this logic is not
    // needed if we know the current flush is both the first and the last
    // of MDL runs.
    //

    if (!SendComplete || !pTracker->FirstResponse)
    {
        UlAcquirePushLockExclusive( &pResponse->PushLock );
    }

    //
    // Increment the reference on tracker for each Send I/O.
    // UlpMdlSendCompleteWorker will release it later.
    //

    UL_REFERENCE_CHUNK_TRACKER( pTracker );

    if (pMdlToSplit)
    {
        //
        // We need to issue 2 TDI calls since we have split the send.
        //

        pTracker->SendInfo.SendCount = 2;

        Status = UlSendData(
                    pTracker->pHttpConnection->pConnection,
                    pMdlHead,
                    BytesToSplit,
                    UlpRestartMdlSend,
                    pTracker,
                    pTracker->pIrp,
                    &pTracker->IrpContext,
                    FALSE,
                    FALSE
                    );

        ASSERT( Status == STATUS_PENDING);

        //
        // Increment the extra reference on tracker for the Split Send I/O.
        // UlpMdlSendCompleteWorker will release it later.
        //

        UL_REFERENCE_CHUNK_TRACKER( pTracker );

        if (CopySend)
        {
            Status = UlpCopySend(
                        pTracker,
                        pMdlSplitSecond,
                        pTracker->SendInfo.BytesBuffered - BytesToSplit,
                        (BOOLEAN) (SendComplete &&
                                   IS_DISCONNECT_TIME(pResponse)),
                        (BOOLEAN) (pResponse->pRequest->ParseState >=
                                   ParseDoneState)
                        );
        }
        else
        {
            Status = UlSendData(
                        pTracker->pHttpConnection->pConnection,
                        pMdlSplitSecond,
                        pTracker->SendInfo.BytesBuffered - BytesToSplit,
                        UlpRestartMdlSend,
                        pTracker,
                        NULL,
                        NULL,
                        (BOOLEAN) (SendComplete &&
                                   IS_DISCONNECT_TIME(pResponse)),
                        (BOOLEAN) (pResponse->pRequest->ParseState >=
                                   ParseDoneState)
                        );
        }
    }
    else
    {
        //
        // Use -1 so we know we haven't done any split on this send.
        //

        pTracker->SendInfo.SendCount = -1;

        //
        // If this the last send to be issued for this response, we can ask
        // UlSendData to initiate a disconnect on our behalf if appropriate.
        //

        Status = UlSendData(
                    pTracker->pHttpConnection->pConnection,
                    pTracker->SendInfo.pMdlHead,
                    pTracker->SendInfo.BytesBuffered,
                    UlpRestartMdlSend,
                    pTracker,
                    pTracker->pIrp,
                    &pTracker->IrpContext,
                    (BOOLEAN) (SendComplete &&
                               IS_DISCONNECT_TIME(pResponse)),
                    (BOOLEAN) (pResponse->pRequest->ParseState >=
                               ParseDoneState)
                    );
    }

    //
    // Pave the way for a new UlpFlushMdlRuns to proceed.
    //

    if (!SendComplete || !pTracker->FirstResponse)
    {
        UlReleasePushLockExclusive( &pResponse->PushLock );
    }

    //
    // Start the next response in the pending response list if exists.
    // The tracker should still have one reference held by the caller
    // so it is safe to touch its fields here.
    //

    if (pResponse->SendEnqueued && SendComplete)
    {
        ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pResponse->pRequest ) );
        UlpDequeueSendHttpResponse( pResponse->pRequest );
    }

    ASSERT( Status == STATUS_PENDING);

    return Status;

}   // UlpFlushMdlRuns


/***************************************************************************++

Routine Description:

    Cleans the MDL_RUNs in the specified tracker and prepares the
    tracker for reuse.

Arguments:

    pTracker - Supplies the tracker to clean.

Return Value:

    None.

--***************************************************************************/
VOID
UlpFreeMdlRuns(
    IN PUL_CHUNK_TRACKER    pTracker
    )
{
    PMDL                    pMdlHead;
    PMDL                    pMdlNext;
    PMDL                    pMdlTmp;
    PMDL                    pMdlToSplit;
    PMDL                    pMdlPrevious;
    PMDL                    pMdlSplitFirst;
    PMDL                    pMdlSplitSecond;
    PUL_MDL_RUN             pMdlRun;
    ULONG                   RunCount;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    //
    // Restore the original MDL chain and ByteCount if we have splitted
    // this send.
    //

    pMdlToSplit = pTracker->SendInfo.pMdlToSplit;

    if (pMdlToSplit)
    {
        pMdlPrevious = pTracker->SendInfo.pMdlPrevious;
        pMdlSplitFirst = pTracker->SendInfo.pMdlSplitFirst;
        pMdlSplitSecond = pTracker->SendInfo.pMdlSplitSecond;

        ASSERT( pMdlSplitFirst );
        ASSERT( pMdlSplitSecond );

        if (pMdlSplitFirst == pMdlToSplit)
        {
            //
            // No partial MDL involved. Simply link back the MDLs.
            //

            pMdlSplitFirst->Next = pMdlSplitSecond;
        }
        else
        {
            ASSERT( pMdlToSplit->Next == pMdlSplitSecond->Next );

            if (pMdlPrevious)
            {
                pMdlPrevious->Next = pMdlToSplit;
            }
            else
            {
                ASSERT( pMdlToSplit == pTracker->SendInfo.pMdlHead );
            }

            //
            // Free the partial MDLs we have built for the split send.
            //

            UlFreeMdl( pMdlSplitFirst );
            UlFreeMdl( pMdlSplitSecond );
        }
    }

    pMdlHead = pTracker->SendInfo.pMdlHead;
    pMdlRun = &pTracker->SendInfo.MdlRuns[0];
    RunCount = pTracker->SendInfo.MdlRunCount;

    while (RunCount > 0)
    {
        ASSERT( pMdlHead != NULL );
        ASSERT( pMdlRun->pMdlTail != NULL );

        pMdlNext = pMdlRun->pMdlTail->Next;
        pMdlRun->pMdlTail->Next = NULL;

        if (pMdlRun->FileBuffer.pFileCacheEntry == NULL)
        {
            //
            // It's a memory/cache run; just walk & free the MDL chain.
            // UlFreeMdl unmaps the data for partial MDLs so no need to
            // unmap here.
            //

            while (pMdlHead != NULL)
            {
                pMdlTmp = pMdlHead->Next;
                UlFreeMdl( pMdlHead );
                pMdlHead = pMdlTmp;
            }
        }
        else
        {
            //
            // It's a file run, free the Mdl.
            //

            UlpFreeFileMdlRun( pTracker, pMdlRun );
        }

        pMdlHead = pMdlNext;
        pMdlRun++;
        RunCount--;
    }

}   // UlpFreeMdlRuns


/***************************************************************************++

Routine Description:

    Clean up the specified Read File MDL_RUN.

Arguments:

    pTracker - Supplies the UL_CHUNK_TRACKER to clean up.

    pMdlRun - Supplies the Read File MDL_RUN.

Return Value:

    None.

--***************************************************************************/
VOID
UlpFreeFileMdlRun(
    IN OUT PUL_CHUNK_TRACKER    pTracker,
    IN OUT PUL_MDL_RUN          pMdlRun
    )
{
    NTSTATUS                    Status;
    PUL_FILE_BUFFER             pFileBuffer;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    //
    // It should be a file run.
    //

    pFileBuffer = &pMdlRun->FileBuffer;

    ASSERT( pFileBuffer->pFileCacheEntry );

    Status = UlReadCompleteFileEntryFast( pFileBuffer );

    if (!NT_SUCCESS(Status))
    {
        //
        // Fast path failed, we'll need an IRP which has been pre-built.
        // We need to do this synchronously as the read IRP can be used by
        // the next UlpFreeFileMdlRun. UlReadCompleteFileEntry will complete
        // synchronously if we set pCompletionRoutine to NULL.
        //

        pFileBuffer->pCompletionRoutine = NULL;
        pFileBuffer->pContext = NULL;

        Status = UlReadCompleteFileEntry(
                    pFileBuffer,
                    pTracker->pIrp
                    );

        ASSERT( STATUS_SUCCESS == Status );
    }

}   // UlpFreeFileMdlRun


/***************************************************************************++

Routine Description:

    Copy the data from the MDL chain starting from pMdl and send it to TDI.

Arguments:

    pTracker - Supplies the tracker to send.

    pMdl - Supplies the MDL chain to send.

    Length - Supplies the total length of the MDL chain.

    InitiateDisconnect - Supplies the disconnect flag passed to TDI.

    RequestComplete - Supplies the request-complete flag passed to TDI.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpCopySend(
    IN PUL_CHUNK_TRACKER    pTracker,
    IN PMDL                 pMdl,
    IN ULONG                Length,
    IN BOOLEAN              InitiateDisconnect,
    IN BOOLEAN              RequestComplete
    )
{
    PMDL                    pMdlCopied  = NULL;
    PUCHAR                  pDataCopied = NULL;
    PUCHAR                  pData;
    NTSTATUS                Status;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( pMdl );
    ASSERT( g_UlMaxCopyThreshold == Length );
    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );
    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pTracker->pResponse ) );

    //
    // Allocate memory and MDL that can hold the whole incoming MDL chain.
    //

    pDataCopied = (PUCHAR) UL_ALLOCATE_POOL(
                                NonPagedPool,
                                Length,
                                UL_COPY_SEND_DATA_POOL_TAG
                                );

    if (!pDataCopied)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto end;
    }

    pMdlCopied = UlAllocateMdl(
                    pDataCopied,
                    Length,
                    FALSE,
                    FALSE,
                    NULL
                    );

    if (!pMdlCopied)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto end;
    }

    MmBuildMdlForNonPagedPool( pMdlCopied );

    //
    // Copy the data from the MDL chain starting pMdl to pMdlCopied.
    //

    while (pMdl)
    {
        pData = MmGetSystemAddressForMdlSafe(
                    pMdl,
                    LowPagePriority
                    );

        if (!pData)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }

        RtlCopyMemory(
            pDataCopied,
            pData,
            MmGetMdlByteCount(pMdl)
            );

        pDataCopied += MmGetMdlByteCount(pMdl);
        pMdl = pMdl->Next;
    }

    //
    // Send pMdlCopied if everything is ok so far.
    //

    Status = UlSendData(
                pTracker->pHttpConnection->pConnection,
                pMdlCopied,
                Length,
                UlpRestartCopySend,
                pMdlCopied,
                NULL,
                NULL,
                InitiateDisconnect,
                RequestComplete
                );

    ASSERT( Status == STATUS_PENDING);

end:

    //
    // Return pending from here since we always complete the send
    // inline in both error and success cases. 
    //

    if (!NT_SUCCESS(Status))
    {
        if (pDataCopied)
        {
            UL_FREE_POOL( pDataCopied, UL_COPY_SEND_DATA_POOL_TAG );  
        }

        if (pMdlCopied)
        {
            UlFreeMdl( pMdlCopied );
        }

        UlpRestartMdlSend( pTracker, Status, 0 );
    } 
    else
    {
        UlpRestartMdlSend( pTracker, STATUS_SUCCESS, Length );
    }

    return STATUS_PENDING;

}   // UlpCopySend


/***************************************************************************++

Routine Description:

    Completion for the second half of a copy send.

Arguments:

    pCompletionContext - Supplies an uninterpreted context value
        as passed to the asynchronous API.

    Status - Supplies the final completion status of the
        asynchronous API.

    Information - Optionally supplies additional information about
        the completed operation, such as the number of bytes
        transferred.

Return Value:

    None

--***************************************************************************/
VOID
UlpRestartCopySend(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    PMDL pMdl = (PMDL) pCompletionContext;

    UNREFERENCED_PARAMETER( Status );
    UNREFERENCED_PARAMETER( Information );

    UL_FREE_POOL(
        MmGetMdlVirtualAddress( pMdl ),
        UL_COPY_SEND_DATA_POOL_TAG
        );

    UlFreeMdl( pMdl );

}   // UlpRestartCopySend


/***************************************************************************++

Routine Description:

    Increments the current chunk pointer in the tracker and initializes
    some of the "from file" related tracker fields if necessary.

Arguments:

    pTracker - Supplies the UL_CHUNK_TRACKER to manipulate.

Return Value:

    None.

--***************************************************************************/
VOID
UlpIncrementChunkPointer(
    IN OUT PUL_INTERNAL_RESPONSE    pResponse
    )
{
    PUL_INTERNAL_DATA_CHUNK         pCurrentChunk;

    //
    // Bump the data chunk. If the request is still incomplete, then
    // check the new current chunk. If it's "from file", then
    // initialize the file offset & bytes remaining from the
    // supplied byte range.
    //

    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pResponse ) );
    ASSERT( pResponse->CurrentChunk == ULONG_MAX ||
            pResponse->CurrentChunk < pResponse->ChunkCount );

    if (ULONG_MAX == pResponse->CurrentChunk)
    {
        pResponse->CurrentChunk = 0;
    }
    else
    {
        pResponse->CurrentChunk++;
    }

    if (!IS_SEND_COMPLETE(pResponse))
    {
        pCurrentChunk = &pResponse->pDataChunks[pResponse->CurrentChunk];

        if (IS_FROM_FILE_HANDLE(pCurrentChunk))
        {
            pResponse->FileOffset =
                pCurrentChunk->FromFileHandle.ByteRange.StartingOffset;
            pResponse->FileBytesRemaining =
                pCurrentChunk->FromFileHandle.ByteRange.Length;
        }
        else
        {
            ASSERT( IS_FROM_MEMORY(pCurrentChunk) ||
                    IS_FROM_FRAGMENT_CACHE(pCurrentChunk) );
        }
    }

}   // UlpIncrementChunkPointer


/***************************************************************************++

Routine Description:

    Creates a cache entry for the given response. This routine actually
    allocates the entry and partly initializes it. Then it allocates
    a UL_CHUNK_TRACKER to keep track of filesystem reads.

Arguments:

    pRequest - Supplies the initiating request.

    pResponse - Supplies the generated response.

    pProcess - UL_APP_POOL_PROCESS that is building this cache entry.

    Flags - UlSendHttpResponse flags.

    CachePolicy - Supplies the cache policy to be enforced on the cache entry.

    pCompletionRoutine - Supplies the completion routine to be called after
        entry is sent.

    pCompletionContext - Supplies the completion context passed to
        pCompletionRoutine.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpBuildCacheEntry(
    IN PUL_INTERNAL_REQUEST     pRequest,
    IN PUL_INTERNAL_RESPONSE    pResponse,
    IN PUL_APP_POOL_PROCESS     pProcess,
    IN HTTP_CACHE_POLICY        CachePolicy,
    IN PUL_COMPLETION_ROUTINE   pCompletionRoutine,
    IN PVOID                    pCompletionContext
    )
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    PUL_URI_CACHE_ENTRY         pEntry = NULL;
    PUL_CHUNK_TRACKER           pTracker = NULL;
    ULONG                       SpaceLength = 0;
    USHORT                      LogDataLength = 0;
    ULONG                       ContentLength;
    PUL_LOG_DATA_BUFFER         pLogData = NULL;
    ULONG                       CookedUrlLength = pRequest->CookedUrl.Length;
    LONG                        AbsPathLength;
    ULONG                       i;

    //
    // Sanity check.
    //

    PAGED_CODE();

    if (HttpCachePolicyTimeToLive == CachePolicy.Policy &&
        0 == CachePolicy.SecondsToLive )
    {
        //
        // A TTL of 0 seconds doesn't make sense. Bail out.
        //

        return STATUS_INVALID_PARAMETER;
    }

    ContentLength =
        (ULONG) (pResponse->ResponseLength - pResponse->HeaderLength);

    //
    // See if we need to store any logging data. If so, we need to
    // calculate the required cache space for the logging data.
    //

    if (pResponse->pLogData)
    {
        pLogData = pResponse->pLogData;
        ASSERT( IS_VALID_LOG_DATA_BUFFER( pLogData ) );

        LogDataLength = UlComputeCachedLogDataLength( pLogData );
    }

    if (pRequest->ConfigInfo.SiteUrlType == HttpUrlSite_NamePlusIP)
    {
        //
        // RoutingToken + AbsPath goes to cache.
        //

        ASSERT( DIFF(pRequest->CookedUrl.pAbsPath - pRequest->CookedUrl.pUrl) > 0 );

        CookedUrlLength -=
            DIFF(pRequest->CookedUrl.pAbsPath - pRequest->CookedUrl.pUrl)
            * sizeof(WCHAR);

        CookedUrlLength += pRequest->CookedUrl.RoutingTokenLength;
    }

    SpaceLength =
        CookedUrlLength + sizeof(WCHAR) +   // Space for Hash key +
        pResponse->ETagLength +             // ETag +
        pResponse->ContentEncodingLength +  // Content-Encoding +
        LogDataLength;                      // Logging

    UlTrace(URI_CACHE, (
        "Http!UlpBuildCacheEntry allocating UL_URI_CACHE_ENTRY, "
        "0x%x bytes of data\n"
        "    Url.Length = 0x%x, aligned Length = 0x%x\n"
        "    ContentLength=0x%x, %d\n"
        "\n",
        SpaceLength,
        CookedUrlLength,
        ALIGN_UP(CookedUrlLength, WCHAR),
        ContentLength,
        ContentLength
        ));

    //
    // Allocate a cache entry.
    //

    pEntry = UlAllocateCacheEntry(
                SpaceLength,
                ContentLength + pResponse->HeaderLength
                );

    if (pEntry)
    {
        //
        // Initialize the entry.
        //

        if (pRequest->ConfigInfo.SiteUrlType == HttpUrlSite_NamePlusIP)
        {
            AbsPathLength =
                pRequest->CookedUrl.Length
                - (DIFF(pRequest->CookedUrl.pAbsPath
                        - pRequest->CookedUrl.pUrl) * sizeof(WCHAR));

            ASSERT( AbsPathLength > 0 );

            UlInitCacheEntry(
                pEntry,
                pRequest->CookedUrl.RoutingHash,
                (ULONG) AbsPathLength,
                pRequest->CookedUrl.pAbsPath,
                NULL,
                pRequest->CookedUrl.pRoutingToken,
                pRequest->CookedUrl.RoutingTokenLength
                );
        }
        else
        {
            UlInitCacheEntry(
                pEntry,
                pRequest->CookedUrl.Hash,
                pRequest->CookedUrl.Length,
                pRequest->CookedUrl.pUrl,
                pRequest->CookedUrl.pAbsPath,
                NULL,
                0
                );
        }

        //
        // Copy the ETag from the response (for If-* headers).
        //

        pEntry->pETag =
            (((PUCHAR) pEntry->UriKey.pUri) +           // Start of URI +
            pEntry->UriKey.Length + sizeof(WCHAR));     // Length of URI

        pEntry->ETagLength = pResponse->ETagLength;

        if (pEntry->ETagLength)
        {
            RtlCopyMemory(
                pEntry->pETag,
                pResponse->pETag,
                pEntry->ETagLength
                );
        }

        // 
        // Capture Content-Encoding so we can verify the Accept-Encoding header
        // on requests.
        //

        pEntry->pContentEncoding = pEntry->pETag + pEntry->ETagLength;
        pEntry->ContentEncodingLength = pResponse->ContentEncodingLength;
        
        if (pEntry->ContentEncodingLength)
        {
            RtlCopyMemory(
                pEntry->pContentEncoding,
                pResponse->pContentEncoding,
                pEntry->ContentEncodingLength
                );            
        }

        //
        // Capture Content-Type so we can verify the Accept: header on requests.
        //

        if (pResponse->ContentType.Type &&
            pResponse->ContentType.SubType )
        {
            RtlCopyMemory(
                &pEntry->ContentType,
                &pResponse->ContentType,
                sizeof(UL_CONTENT_TYPE)
                );
        }

        //
        // Get the System Time of the Date: header (for If-* headers).
        //

        pEntry->CreationTime.QuadPart   = pResponse->CreationTime.QuadPart;
        pEntry->ContentLengthSpecified  = pResponse->ContentLengthSpecified;
        pEntry->StatusCode              = pResponse->StatusCode;
        pEntry->Verb                    = pRequest->Verb;
        pEntry->CachePolicy             = CachePolicy;

        if (CachePolicy.Policy == HttpCachePolicyTimeToLive)
        {
            ASSERT( 0 != CachePolicy.SecondsToLive );

            KeQuerySystemTime( &pEntry->ExpirationTime );

            if (CachePolicy.SecondsToLive > C_SECS_PER_YEAR)
            {
                //
                // Maximum TTL is 1 year.
                //

                pEntry->CachePolicy.SecondsToLive = C_SECS_PER_YEAR;
            }

            //
            // Convert seconds to 100 nanosecond intervals (x * 10^7).
            //

            pEntry->ExpirationTime.QuadPart +=
                pEntry->CachePolicy.SecondsToLive * C_NS_TICKS_PER_SEC;

        }
        else
        {
            pEntry->ExpirationTime.QuadPart = 0;
        }

        //
        // Capture the Config Info from the request.
        //

        ASSERT( IS_VALID_URL_CONFIG_GROUP_INFO( &pRequest->ConfigInfo ) );

        UlConfigGroupInfoDeepCopy(
            &pRequest->ConfigInfo,
            &pEntry->ConfigInfo
            );

        //
        // Remember who created us.
        //

        pEntry->pProcess = pProcess;

        //
        // Generate the content and fixed headers.
        //

        if (NULL == pEntry->pMdl)
        {
            Status = STATUS_NO_MEMORY;
            goto cleanup;
        }

        pEntry->HeaderLength = pResponse->HeaderLength;

        if (FALSE == UlCacheEntrySetData(
                        pEntry,                     // Dest CacheEntry
                        pResponse->pHeaders,        // Buffer to copy
                        pResponse->HeaderLength,    // Length to copy
                        ContentLength               // Offset in Dest MDL
                        ))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        //
        // Generate the content body.
        //

        pEntry->ContentLength = ContentLength;

        //
        // Copy over the log data.
        //

        if (pLogData)
        {
            //
            // There may be no field to save in the cache entry but the logging
            // might still be enabled for those fields we generate later such as
            // date and time.
            //

            pEntry->LoggingEnabled  = TRUE;
            pEntry->LogDataLength   = LogDataLength;
            pEntry->pLogData        = pEntry->pContentEncoding + 
                                      pEntry->ContentEncodingLength;

            //
            // Copy over the partially complete log line excluding the date and
            // time fields to the cache entry. Also remember the length of the
            // data.
            //

            UlCopyCachedLogData(
                pLogData,
                LogDataLength,
                pEntry
                );
        }

        UlTrace(URI_CACHE, (
            "Http!UlpBuildCacheEntry\n"
            "    entry = %p\n"
            "    pUri = %p '%ls'\n"
            "    pMdl = %p (%d bytes)\n"
            "    pETag = %p\n"
            "    pContentEncoding = %p\n"
            "    pLogData = %p\n"
            "    end = %p\n",
            pEntry,
            pEntry->UriKey.pUri, pEntry->UriKey.pUri,
            pEntry->pMdl, pEntry->ContentLength + pEntry->HeaderLength,
            pEntry->pETag,
            pEntry->pContentEncoding,
            pEntry->pLogData,
            ((PUCHAR)pEntry->UriKey.pUri) + SpaceLength
            ));

        //
        // Completion info.
        //

        pResponse->pCompletionRoutine = pCompletionRoutine;
        pResponse->pCompletionContext = pCompletionContext;

        pTracker = UlpAllocateChunkTracker(
                        UlTrackerTypeBuildUriEntry,
                        0,
                        pResponse->MaxFileSystemStackSize,
                        TRUE,
                        pRequest->pHttpConn,
                        pResponse
                        );

        if (pTracker)
        {
            //
            // Initialize the first chunk for the cache build.
            //

            UlpIncrementChunkPointer( pResponse );

            //
            // Init the tracker's BuildInfo.
            //

            pTracker->BuildInfo.pUriEntry = pEntry;
            pTracker->BuildInfo.Offset = 0;

            RtlZeroMemory(
                &pTracker->BuildInfo.FileBuffer,
                sizeof(pTracker->BuildInfo.FileBuffer)
                );

            //
            // Skip over the header chunks because we already
            // got that stuff.
            //

            for (i = 0; i < HEADER_CHUNK_COUNT; i++)
            {
                ASSERT( !IS_SEND_COMPLETE( pResponse ) );
                UlpIncrementChunkPointer( pResponse );
            }

            //
            // Let the worker do the dirty work, no reason to queue off,
            // it will queue the first time it needs to do I/O.
            //

            UlpBuildCacheEntryWorker( &pTracker->WorkItem );

            Status = STATUS_PENDING;
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        Status = STATUS_NO_MEMORY;
    }

cleanup:

    UlTrace(URI_CACHE, (
        "Http!UlpBuildCacheEntry Status = %x, pEntry = %x\n",
        Status,
        pEntry
        ));

    if (!NT_SUCCESS(Status))
    {
        if (pEntry)
        {
            UlFreeCacheEntry( pEntry );
        }

        if (pTracker)
        {
            UL_FREE_POOL_WITH_SIG( pTracker, UL_CHUNK_TRACKER_POOL_TAG );
        }
    }

    return Status;

}   // UlpBuildCacheEntry


/***************************************************************************++

Routine Description:

    Worker routine for managing an in-progress UlpBuildCacheEntry().
    This routine iterates through all the chunks in the response
    and copies the data into the cache entry.

Arguments:

    pWorkItem - Supplies a pointer to the work item queued. This should
        point to the WORK_ITEM structure embedded in a UL_CHUNK_TRACKER.

Return Value:

    None.

--***************************************************************************/
VOID
UlpBuildCacheEntryWorker(
    IN PUL_WORK_ITEM        pWorkItem
    )
{
    PUL_CHUNK_TRACKER       pTracker;
    NTSTATUS                Status;
    PUL_INTERNAL_DATA_CHUNK pCurrentChunk;
    PUCHAR                  pBuffer;
    ULONG                   BufferLength;
    PUL_FILE_BUFFER         pFileBuffer;
    PUL_INTERNAL_RESPONSE   pResponse;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pTracker = CONTAINING_RECORD(
                    pWorkItem,
                    UL_CHUNK_TRACKER,
                    WorkItem
                    );

    UlTrace(URI_CACHE, (
        "Http!UlpBuildCacheEntryWorker: tracker %p\n",
        pTracker
        ));

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    pResponse = pTracker->pResponse;

    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pResponse ) );

    Status = STATUS_SUCCESS;

    while (TRUE)
    {
        //
        // Capture the current chunk pointer, then check for end of
        // response.
        //

        pCurrentChunk = &pResponse->pDataChunks[pResponse->CurrentChunk];

        if (IS_SEND_COMPLETE(pResponse))
        {
            ASSERT( Status == STATUS_SUCCESS );
            break;
        }

        //
        // Determine the chunk type.
        //

        if (IS_FROM_MEMORY(pCurrentChunk))
        {
            //
            // It's from a locked-down memory buffer. Since these
            // are always handled in-line (never pended) we can
            // go ahead and adjust the current chunk pointer in the
            // tracker.
            //

            UlpIncrementChunkPointer( pResponse );

            //
            // Ignore empty buffers.
            //

            if (pCurrentChunk->FromMemory.BufferLength == 0)
            {
                continue;
            }

            //
            // Copy the incoming memory.
            //

            ASSERT( pCurrentChunk->FromMemory.pMdl->Next == NULL );

            pBuffer = (PUCHAR) MmGetMdlVirtualAddress(
                                    pCurrentChunk->FromMemory.pMdl
                                    );
            BufferLength = MmGetMdlByteCount( pCurrentChunk->FromMemory.pMdl );

            UlTrace(LARGE_MEM, (
                "Http!UlpBuildCacheEntryWorker: "
                "copy range %u (%x) -> %u\n",
                pTracker->BuildInfo.Offset,
                BufferLength,
                pTracker->BuildInfo.Offset + BufferLength
                ));

            if (FALSE == UlCacheEntrySetData(
                            pTracker->BuildInfo.pUriEntry,
                            pBuffer,
                            BufferLength,
                            pTracker->BuildInfo.Offset
                            ))
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            pTracker->BuildInfo.Offset += BufferLength;
            ASSERT( pTracker->BuildInfo.Offset <=
                    pTracker->BuildInfo.pUriEntry->ContentLength );
        }
        else
        {
            //
            // It's a filesystem MDL.
            //

            ASSERT( IS_FROM_FILE_HANDLE( pCurrentChunk ) );

            //
            // Ignore empty file ranges.
            //

            if (pCurrentChunk->FromFileHandle.ByteRange.Length.QuadPart == 0)
            {
                UlpIncrementChunkPointer( pResponse );
                continue;
            }

            //
            // Do the read.
            //

            pFileBuffer = &pTracker->BuildInfo.FileBuffer;

            pFileBuffer->pFileCacheEntry =
                &pCurrentChunk->FromFileHandle.FileCacheEntry;

            pFileBuffer->FileOffset = pResponse->FileOffset;
            pFileBuffer->Length =
                MIN(
                    (ULONG) pResponse->FileBytesRemaining.QuadPart,
                    g_UlMaxBytesPerRead
                    );

            pFileBuffer->pCompletionRoutine = UlpRestartCacheMdlRead;
            pFileBuffer->pContext = pTracker;

            Status = UlReadFileEntry(
                            pFileBuffer,
                            pTracker->pIrp
                            );

            break;
        }
    }

    //
    // Did everything complete?
    //

    if (Status != STATUS_PENDING)
    {
        //
        // Yep, complete the response.
        //

        UlpCompleteCacheBuild( pTracker, Status );
    }

}   // UlpBuildCacheEntryWorker


/***************************************************************************++

Routine Description:

    Completion handler for MDL READ IRPs used for reading file data.

Arguments:

    pDeviceObject - Supplies the device object for the IRP being
        completed.

    pIrp - Supplies the IRP being completed.

    pContext - Supplies the context associated with this request.
        This is actually a PUL_CHUNK_TRACKER.

Return Value:

    NTSTATUS - STATUS_SUCCESS if IO should continue processing this
        IRP, STATUS_MORE_PROCESSING_REQUIRED if IO should stop processing
        this IRP.

--***************************************************************************/
NTSTATUS
UlpRestartCacheMdlRead(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    )
{
    PUL_CHUNK_TRACKER   pTracker = (PUL_CHUNK_TRACKER) pContext;

    UNREFERENCED_PARAMETER( pDeviceObject );

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    pTracker->IoStatus = pIrp->IoStatus;

    UlpQueueResponseWorkItem(
        &pTracker->WorkItem,
        UlpCacheMdlReadCompleteWorker,
        pTracker->pResponse->SyncRead
        );

    return STATUS_MORE_PROCESSING_REQUIRED;

}   // UlpRestartCacheMdlRead


/***************************************************************************++

Routine Description:

    The worker routine for UlpRestartCacheMdlRead since UlpRestartCacheMdlRead
    can be called at DISPATH_LEVEL but the cache entry is from PagedPool. 

Arguments:

    pWorkItem - Supplies the work item embedded in UL_CHUNK_TRACKER.

Return Value:

    None.

--***************************************************************************/
VOID
UlpCacheMdlReadCompleteWorker(
    IN PUL_WORK_ITEM    pWorkItem
    )
{
    NTSTATUS            Status;
    NTSTATUS            TempStatus;
    PUL_CHUNK_TRACKER   pTracker;
    PMDL                pMdl;
    PUCHAR              pData;
    ULONG               DataLen;
    PUL_FILE_BUFFER     pFileBuffer;

    PAGED_CODE();

    pTracker = CONTAINING_RECORD(
                    pWorkItem,
                    UL_CHUNK_TRACKER,
                    WorkItem
                    );

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    UlTrace(URI_CACHE, (
        "Http!UlpCacheMdlReadCompleteWorker: tracker %p, status %x info %Iu\n",
        pTracker,
        pTracker->IoStatus.Status,
        pTracker->IoStatus.Information
        ));

    Status = pTracker->IoStatus.Status;

    if (NT_SUCCESS(Status))
    {
        //
        // Copy read data into the cache buffer.
        //

        pMdl = pTracker->BuildInfo.FileBuffer.pMdl;

        while (pMdl)
        {
            //
            // The MDL chain returned by CacheManager is only guranteed to be
            // locked but not mapped so we have to map before using them.
            // However, there is no need to unmap after using the MDLs as
            // IRP_MN_COMPLETE calls MmUnlockPages which automatically unmaps
            // MDLs if they are mapped into system space.
            //

            pData = MmGetSystemAddressForMdlSafe(
                        pMdl,
                        LowPagePriority
                        );

            if (!pData)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            DataLen = MmGetMdlByteCount( pMdl );

            UlTrace(LARGE_MEM, (
                "Http!UlpRestartCacheMdlRead: "
                "copy range %u (%x) -> %u\n",
                pTracker->BuildInfo.Offset,
                DataLen,
                pTracker->BuildInfo.Offset + DataLen
                ));

            if (FALSE == UlCacheEntrySetData(
                            pTracker->BuildInfo.pUriEntry,
                            pData,
                            DataLen,
                            pTracker->BuildInfo.Offset
                            ))
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            pTracker->BuildInfo.Offset += DataLen;
            ASSERT( pTracker->BuildInfo.Offset <=
                    pTracker->BuildInfo.pUriEntry->ContentLength );

            pMdl = pMdl->Next;
        }

        //
        // Free the MDLs.
        //

        pFileBuffer = &pTracker->BuildInfo.FileBuffer;

        if (NT_SUCCESS(Status))
        {
            pFileBuffer->pCompletionRoutine = UlpRestartCacheMdlFree;
            pFileBuffer->pContext = pTracker;

            Status = UlReadCompleteFileEntry(
                            pFileBuffer,
                            pTracker->pIrp
                            );

            ASSERT( STATUS_PENDING == Status );
        }
        else
        {
            pFileBuffer->pCompletionRoutine = NULL;
            pFileBuffer->pContext = NULL;

            TempStatus = UlReadCompleteFileEntry(
                            pFileBuffer,
                            pTracker->pIrp
                            );

            ASSERT( STATUS_SUCCESS == TempStatus );
        }
    }

    if (!NT_SUCCESS(Status))
    {
        UlpCompleteCacheBuild( pTracker, Status );
    }

}   // UlpRestartCacheMdlRead


/***************************************************************************++

Routine Description:

    Completion handler for MDL free IRPs used after reading/copying file data.

Arguments:

    pDeviceObject - Supplies the device object for the IRP being
        completed.

    pIrp - Supplies the IRP being completed.

    pContext - Supplies the context associated with this request.
        This is actually a PUL_CHUNK_TRACKER.

Return Value:

    NTSTATUS - STATUS_SUCCESS if IO should continue processing this
        IRP, STATUS_MORE_PROCESSING_REQUIRED if IO should stop processing
        this IRP.

--***************************************************************************/
NTSTATUS
UlpRestartCacheMdlFree(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp,
    IN PVOID                pContext
    )
{
    NTSTATUS                Status;
    PUL_CHUNK_TRACKER       pTracker;
    PUL_INTERNAL_RESPONSE   pResponse;

    UNREFERENCED_PARAMETER( pDeviceObject );

    pTracker = (PUL_CHUNK_TRACKER) pContext;

    UlTrace(URI_CACHE, (
        "Http!UlpRestartCacheMdlFree: tracker %p, status %x info %Iu\n",
        pTracker,
        pIrp->IoStatus.Status,
        pIrp->IoStatus.Information
        ));

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );
    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pTracker->pResponse ) );

    pResponse = pTracker->pResponse;

    Status = pIrp->IoStatus.Status;

    if (NT_SUCCESS(Status))
    {
        //
        // Update the file offset & bytes remaining. If we've
        // finished this file chunk (bytes remaining is now zero)
        // then advance to the next chunk.
        //

        pResponse->FileOffset.QuadPart += pIrp->IoStatus.Information;
        pResponse->FileBytesRemaining.QuadPart -= pIrp->IoStatus.Information;

        if (pResponse->FileBytesRemaining.QuadPart == 0 )
        {
            UlpIncrementChunkPointer( pResponse );
        }

        //
        // Go back into the loop if there's more to read
        //

        if (IS_SEND_COMPLETE(pResponse))
        {
            UlpCompleteCacheBuild( pTracker, Status );
        }
        else
        {
            UlpQueueResponseWorkItem(
                &pTracker->WorkItem,
                UlpBuildCacheEntryWorker,
                pTracker->pResponse->SyncRead
                );
        }
    }
    else
    {
        //
        // MDL free should never fail.
        //

        ASSERT( FALSE );

        UlpCompleteCacheBuild( pTracker, Status );
    }

    return STATUS_MORE_PROCESSING_REQUIRED;

}   // UlpRestartCacheMdlFree


/***************************************************************************++

Routine Description:

    This routine gets called when we finish building a cache entry.

Arguments:

    pTracker - Supplies the tracker to complete.

    Status - Supplies the completion status.

Return Value:

    None.

--***************************************************************************/
VOID
UlpCompleteCacheBuild(
    IN PUL_CHUNK_TRACKER    pTracker,
    IN NTSTATUS             Status
    )
{
    UlTrace(URI_CACHE, (
        "Http!UlpCompleteCacheBuild: tracker %p, status %08lx\n",
        pTracker,
        Status
        ));

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    pTracker->IoStatus.Status = Status;

    UL_CALL_PASSIVE(
        &pTracker->WorkItem,
        UlpCompleteCacheBuildWorker
        );

}   // UlpCompleteCacheBuild


/***************************************************************************++

Routine Description:

    Called when we finish building a cache entry. If the entry was
    built successfully, we send the response down the wire.

Arguments:

    pWorkItem - Supplies a pointer to the work item queued. This should
        point to the WORK_ITEM structure embedded in a UL_CHUNK_TRACKER.

Return Value:

    None.

--***************************************************************************/
VOID
UlpCompleteCacheBuildWorker(
    IN PUL_WORK_ITEM        pWorkItem
    )
{
    PUL_CHUNK_TRACKER       pTracker;
    PUL_URI_CACHE_ENTRY     pUriCacheEntry;
    PUL_HTTP_CONNECTION     pHttpConnection;
    PUL_COMPLETION_ROUTINE  pCompletionRoutine;
    PVOID                   pCompletionContext;
    ULONG                   Flags;
    PUL_LOG_DATA_BUFFER     pLogData;
    LONGLONG                BytesToSend;
    NTSTATUS                Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pTracker = CONTAINING_RECORD(
                    pWorkItem,
                    UL_CHUNK_TRACKER,
                    WorkItem
                    );

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );
    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pTracker->pResponse ) );

    pUriCacheEntry = pTracker->BuildInfo.pUriEntry;
    ASSERT( IS_VALID_URI_CACHE_ENTRY( pUriCacheEntry ) );

    pHttpConnection     = pTracker->pHttpConnection;
    Flags               = pTracker->pResponse->Flags;
    pCompletionRoutine  = pTracker->pResponse->pCompletionRoutine;
    pCompletionContext  = pTracker->pResponse->pCompletionContext;
    Status              = pTracker->IoStatus.Status;

    //
    // Save the logging data pointer before releasing the tracker and
    // its response pointer.
    //

    pLogData = pTracker->pResponse->pLogData;

    if (pLogData)
    {
        //
        // To prevent SendResponse to free our log buffer.
        //

        pTracker->pResponse->pLogData = NULL;

        //
        // Give the sign that this log data buffer is ready and later
        // there's no need to refresh its content from cache again.
        //

        pLogData->Flags.CacheAndSendResponse = TRUE;
    }

    if (NT_SUCCESS(Status))
    {
        //
        // Try to put the entry into the hash table.
        //

        UlAddCacheEntry( pUriCacheEntry );

        //
        // Start the MinBytesPerSecond timer, since the data length
        // is in the UL_URI_CACHE_ENTRY.
        //

        BytesToSend = pUriCacheEntry->ContentLength +
                      pUriCacheEntry->HeaderLength;

        UlSetMinBytesPerSecondTimer(
            &pHttpConnection->TimeoutInfo,
            BytesToSend
            );

        //
        // Grab the connection lock because UlpSendCacheEntry assumes you
        // have it.
        //

        UlAcquirePushLockExclusive( &pHttpConnection->PushLock );

        //
        // Send the cache entry.
        //
        // We never pipeline requests for build & send path. We will defer
        // resume parsing until send completion.
        //

        Status = UlpSendCacheEntry(
                        pHttpConnection,
                        Flags,
                        pUriCacheEntry,
                        pCompletionRoutine,
                        pCompletionContext,
                        pLogData,
                        UlResumeParsingOnSendCompletion
                        );

        //
        // Get rid of the cache entry if it didn't work.
        //

        if (!NT_SUCCESS(Status))
        {
            UlCheckinUriCacheEntry( pUriCacheEntry );
        }

        //
        // Done with the connection lock.
        //

        UlReleasePushLockExclusive( &pHttpConnection->PushLock );
    }

    //
    // We assume the ownership of the original log buffer.
    // If send didn't go through, then we have to clean it
    // up here.
    //

    if (pLogData && !NT_SUCCESS(Status))
    {
        UlDestroyLogDataBuffer( pLogData );
    }

    //
    // Free the read tracker. Do this after calling UlpSendCacheEntry
    // as to hold onto the HTTP connection reference.
    //

    UlpFreeChunkTracker( &pTracker->WorkItem );

    //
    // If it's not STATUS_PENDING for some reason, complete the request.
    //

    if (Status != STATUS_PENDING && pCompletionRoutine != NULL)
    {
        (pCompletionRoutine)(
            pCompletionContext,
            Status,
            0
            );
    }

}  // UlpCompleteCacheBuildWorker


/***************************************************************************++

Routine Description:

    Sends a cache entry down the wire.

    The logging related part of this function below, surely depends on
    the fact that pCompletionContext will be null if this is called for
    pure cache hits (in other words from UlSendCachedResponse) otherwise
    pointer to Irp will be passed down as the pCompletionContext.

Arguments:

    pHttpConnection - Supplies the UL_HTTP_CONNECTION to send the cached
        response.

    Flags - HTTP_SEND_RESPONSE flags.

    pUriCacheEntry - Supplies the cache entry to send the response.

    pCompletionRoutine - Supplies the completion routine to call upon
        send completion.

    pCompletionContext - Passed to pCompletionRoutine.

    pLogData - Supplies the log data (only in the build cache case).

    ResumeParsingType - Tells whether resume parsing happens on send completion
        or after send but before send completion.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpSendCacheEntry(
    PUL_HTTP_CONNECTION     pHttpConnection,
    ULONG                   Flags,
    PUL_URI_CACHE_ENTRY     pUriCacheEntry,
    PUL_COMPLETION_ROUTINE  pCompletionRoutine,
    PVOID                   pCompletionContext,
    PUL_LOG_DATA_BUFFER     pLogData,
    UL_RESUME_PARSING_TYPE  ResumeParsingType
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    PUL_FULL_TRACKER        pTracker;
    CCHAR                   SendIrpStackSize;
    UL_CONN_HDR             ConnHeader;
    ULONG                   VarHeaderGenerated;
    ULONG                   ContentLengthStringLength;
    UCHAR                   ContentLength[MAX_ULONGLONG_STR];
    LARGE_INTEGER           CreationTime;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( UL_IS_VALID_HTTP_CONNECTION( pHttpConnection ) );
    ASSERT( IS_VALID_URI_CACHE_ENTRY( pUriCacheEntry ) );
    ASSERT( UlDbgPushLockOwnedExclusive( &pHttpConnection->PushLock ) );

    UlTrace(URI_CACHE, (
        "Http!UlpSendCacheEntry(httpconn %p, flags %x, uri %p, ...)\n",
        pHttpConnection,
        Flags,
        pUriCacheEntry
        ));

    //
    // Init vars so we can cleanup correctly if we jump to the end.
    //

    pTracker = NULL;

    //
    // Make sure we're still connected.
    //

    if (pHttpConnection->UlconnDestroyed)
    {
        Status = STATUS_CONNECTION_ABORTED;
        goto cleanup;
    }

    ASSERT( pHttpConnection->pRequest );

    if (!pUriCacheEntry->ContentLengthSpecified &&
        UlNeedToGenerateContentLength(
            pUriCacheEntry->Verb,
            pUriCacheEntry->StatusCode,
            Flags
            ))
    {
        //
        // Autogenerate a Content-Length header.
        //

        PCHAR pEnd = UlStrPrintUlonglong(
                            (PCHAR) ContentLength,
                            (ULONGLONG) pUriCacheEntry->ContentLength,
                            ANSI_NULL
                            );
        ContentLengthStringLength = DIFF(pEnd - (PCHAR) ContentLength);
    }
    else
    {
        //
        // Either we cannot or do not need to autogenerate a
        // Content-Length header.
        //

        ContentLength[0] = ANSI_NULL;
        ContentLengthStringLength = 0;
    }

    ConnHeader = UlChooseConnectionHeader(
                        pHttpConnection->pRequest->Version,
                        (BOOLEAN) (Flags & HTTP_SEND_RESPONSE_FLAG_DISCONNECT)
                        );

    //
    // Create a cache tracker.
    //

    SendIrpStackSize =
        pHttpConnection->pConnection->ConnectionObject.pDeviceObject->StackSize;

    if (SendIrpStackSize > DEFAULT_MAX_IRP_STACK_SIZE)
    {
        pTracker = UlpAllocateCacheTracker( SendIrpStackSize );
    }
    else
    {
        pTracker = pHttpConnection->pRequest->pTracker;
    }

    if (pTracker)
    {
        //
        // Init the tracker.
        //

        UL_REFERENCE_HTTP_CONNECTION( pHttpConnection );
        UL_REFERENCE_INTERNAL_REQUEST( pHttpConnection->pRequest );

        pTracker->pUriEntry             = pUriCacheEntry;
        pTracker->pHttpConnection       = pHttpConnection;
        pTracker->pRequest              = pHttpConnection->pRequest;
        pTracker->pCompletionRoutine    = pCompletionRoutine;
        pTracker->pCompletionContext    = pCompletionContext;
        pTracker->Flags                 = Flags;
        pTracker->pLogData              = NULL;

        //
        // Resume parse if this cache response comes from
        // the UlpCompleteCacheBuildWorker path, or if we are at maximum
        // pipelined requests.
        //

        pTracker->ResumeParsingType = ResumeParsingType;

        //
        // Build MDLs for send.
        //

        ASSERT( pUriCacheEntry->pMdl != NULL );

        MmInitializeMdl(
            pTracker->pMdlFixedHeaders,
            (PCHAR) MmGetMdlVirtualAddress(pUriCacheEntry->pMdl) +
                    pUriCacheEntry->ContentLength,
            pUriCacheEntry->HeaderLength
            );

        IoBuildPartialMdl(
            pUriCacheEntry->pMdl,
            pTracker->pMdlFixedHeaders,
            (PCHAR) MmGetMdlVirtualAddress(pUriCacheEntry->pMdl) +
                    pUriCacheEntry->ContentLength,
            pUriCacheEntry->HeaderLength
            );

        //
        // Generate the variable headers and build a MDL for them.
        //

        UlGenerateVariableHeaders(
            ConnHeader,
            TRUE,
            ContentLength,
            ContentLengthStringLength,
            pTracker->pAuxiliaryBuffer,
            &VarHeaderGenerated,
            &CreationTime
            );

        ASSERT( VarHeaderGenerated <= g_UlMaxVariableHeaderSize );
        ASSERT( VarHeaderGenerated <= pTracker->AuxilaryBufferLength );

        pTracker->pMdlVariableHeaders->ByteCount = VarHeaderGenerated;
        pTracker->pMdlFixedHeaders->Next = pTracker->pMdlVariableHeaders;

        //
        // Build a MDL for the body.
        //

        if (pUriCacheEntry->ContentLength)
        {
            MmInitializeMdl(
                pTracker->pMdlContent,
                MmGetMdlVirtualAddress(pUriCacheEntry->pMdl),
                pUriCacheEntry->ContentLength
                );

            IoBuildPartialMdl(
                pUriCacheEntry->pMdl,
                pTracker->pMdlContent,
                MmGetMdlVirtualAddress(pUriCacheEntry->pMdl),
                pUriCacheEntry->ContentLength
                );

            pTracker->pMdlVariableHeaders->Next = pTracker->pMdlContent;
        }
        else
        {
            pTracker->pMdlVariableHeaders->Next = NULL;
        }

        //
        // Check whether we have to log this cache hit or not.
        //

        if (pUriCacheEntry->LoggingEnabled)
        {
            //
            // If logging data is provided use it rather than allocating
            // a new one. Because the log buffer already gets allocated
            // for build & send cache hits.
            //

            if (pLogData)
            {
                ASSERT( pCompletionContext != NULL );
                pTracker->pLogData = pLogData;
            }

            //
            // Or else, LogData will get allocated when send completion
            // happens just before we do the logging.
            //
        }

        //
        // Go go go!
        //

        UL_QUEUE_WORK_ITEM(
            &pTracker->WorkItem,
            UlpSendCacheEntryWorker
            );

        Status = STATUS_PENDING;
    }
    else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

cleanup:

    //
    // Clean up the tracker if we don't need it.
    //

    if (!NT_SUCCESS(Status))
    {
        if (pTracker)
        {
            UL_DEREFERENCE_INTERNAL_REQUEST( pTracker->pRequest );
            pTracker->pRequest = NULL;

            UL_DEREFERENCE_HTTP_CONNECTION( pTracker->pHttpConnection );
            pTracker->pHttpConnection = NULL;

            UlpFreeCacheTracker( pTracker );
        }
    }

    UlTrace(URI_CACHE, (
        "Http!UlpSendCacheEntry status = %08x\n",
        Status
        ));

    return Status;

}   // UlpSendCacheEntry


/***************************************************************************++

Routine Description:

    Called to send a cached response. This is done in a worker to avoid
    holding the connection resource for too long. This also prevents
    recursion if we keep on hitting pipelined cache-hit responses.

Arguments:

    pWorkItem - Supplies a pointer to the work item queued. This should
        point to the WORK_ITEM structure embedded in a UL_FULL_TRACKER.

Return Value:

    None.

--***************************************************************************/
VOID
UlpSendCacheEntryWorker(
    IN PUL_WORK_ITEM    pWorkItem
    )
{
    PUL_FULL_TRACKER    pTracker;
    NTSTATUS            Status;
    PUL_HTTP_CONNECTION pHttpConnection = NULL;
    BOOLEAN             ResumeParsing = FALSE;
    BOOLEAN             InDisconnect = FALSE;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pTracker = CONTAINING_RECORD(
                    pWorkItem,
                    UL_FULL_TRACKER,
                    WorkItem
                    );

    ASSERT( IS_VALID_FULL_TRACKER( pTracker ) );

    UlTrace(URI_CACHE, (
        "Http!UlpSendCacheEntryWorker(pTracker %p)\n",
        pTracker
        ));

    //
    // Take an extra reference for the pHttpConnection if we are going to
    // resume parsing inline because UlpCompleteSendCacheEntry can be
    // called when UlSendData returns.
    //

    if (UlResumeParsingOnLastSend == pTracker->ResumeParsingType)
    {
        pHttpConnection = pTracker->pHttpConnection;
        UL_REFERENCE_HTTP_CONNECTION( pHttpConnection );

        ResumeParsing = TRUE;
    }

    if (pTracker->Flags & HTTP_SEND_RESPONSE_FLAG_DISCONNECT)
    {
        InDisconnect = TRUE;
    }

    Status = UlSendData(
                pTracker->pHttpConnection->pConnection,
                pTracker->pMdlFixedHeaders,
                MmGetMdlByteCount(pTracker->pMdlFixedHeaders) +
                    MmGetMdlByteCount(pTracker->pMdlVariableHeaders) +
                    pTracker->pUriEntry->ContentLength,
                UlpCompleteSendCacheEntry,
                pTracker,
                pTracker->pSendIrp,
                &pTracker->IrpContext,
                InDisconnect,
                TRUE
                );

    if (ResumeParsing)
    {
        //
        // pHttpConnection is safe to use since we have already added an
        // extra reference for it.
        //

        if (NT_SUCCESS(Status))
        {
            UlResumeParsing( pHttpConnection, TRUE, InDisconnect );
        }

        UL_DEREFERENCE_HTTP_CONNECTION( pHttpConnection );
    }

    if (!NT_SUCCESS(Status))
    {
        if (pTracker->pLogData)
        {
            UlDestroyLogDataBuffer( pTracker->pLogData );
            pTracker->pLogData = NULL;
        }

        UL_DEREFERENCE_INTERNAL_REQUEST( pTracker->pRequest );
        UL_DEREFERENCE_HTTP_CONNECTION( pTracker->pHttpConnection );

        UlpFreeCacheTracker( pTracker );
    }

}   // UlpSendCacheEntryWorker


/***************************************************************************++

Routine Description:

    Called when we finish sending data to the client. Just queues to
    a worker that runs at passive level.

Arguments:

    pCompletionContext - Supplies a pointer to UL_FULL_TRACKER.

    Status - Status of the send.

    Information - Bytes transferred.

Return Value:

    None.

--***************************************************************************/
VOID
UlpCompleteSendCacheEntry(
    IN PVOID            pCompletionContext,
    IN NTSTATUS         Status,
    IN ULONG_PTR        Information
    )
{
    PUL_FULL_TRACKER    pTracker;

    pTracker = (PUL_FULL_TRACKER) pCompletionContext;

    pTracker->IoStatus.Status = Status;
    pTracker->IoStatus.Information = Information;

    UlTrace(URI_CACHE, (
        "UlpCompleteSendCacheEntry: "
        "tracker=%p, status = %x, transferred %d bytes\n",
        pTracker,
        Status,
        (LONG) Information
        ));

    IF_DEBUG(LOGBYTES)
    {
        TIME_FIELDS RcvdTimeFields;

        RtlTimeToTimeFields( &pTracker->pRequest->TimeStamp, &RcvdTimeFields );

        UlTrace(LOGBYTES,
            ("Http!UlpCompleteSendCacheEntry   : [Rcvd @ %02d:%02d:%02d] "
            "Bytes %010I64u Status %08lx\n",
            RcvdTimeFields.Hour,
            RcvdTimeFields.Minute,
            RcvdTimeFields.Second,
            (ULONGLONG) pTracker->IoStatus.Information,
            Status
            ));
    }

    UL_QUEUE_WORK_ITEM(
        &pTracker->WorkItem,
        UlpCompleteSendCacheEntryWorker
        );

}   // UlpCompleteSendCacheEntry


/***************************************************************************++

Routine Description:

    Called when we finish sending cached data to the client. This routine
    frees the UL_FULL_TRACKER, and calls the completion routine originally
    passed to UlCacheAndSendResponse.

Arguments:

    pWorkItem - Supplies a pointer to the work item queued. This should
        point to the WORK_ITEM structure embedded in a UL_FULL_TRACKER.

Return Value:

    None.

--***************************************************************************/
VOID
UlpCompleteSendCacheEntryWorker(
    IN PUL_WORK_ITEM        pWorkItem
    )
{
    PUL_FULL_TRACKER        pTracker;
    PUL_HTTP_CONNECTION     pHttpConnection;
    PUL_INTERNAL_REQUEST    pRequest;
    ULONG                   Flags;
    PUL_URI_CACHE_ENTRY     pUriCacheEntry;
    NTSTATUS                Status;
    KIRQL                   OldIrql;
    BOOLEAN                 ResumeParsing;
    HTTP_VERB               RequestVerb;
    USHORT                  ResponseStatusCode;
    BOOLEAN                 FromCache;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pTracker = CONTAINING_RECORD(
                    pWorkItem,
                    UL_FULL_TRACKER,
                    WorkItem
                    );

    UlTrace(URI_CACHE, (
        "Http!UlpCompleteSendCacheEntryWorker(pTracker %p)\n",
        pTracker
        ));

    //
    // Pull context out of the tracker.
    //

    pHttpConnection     = pTracker->pHttpConnection;
    pRequest            = pTracker->pRequest;
    RequestVerb         = pTracker->RequestVerb;
    ResponseStatusCode  = pTracker->ResponseStatusCode;
    Flags               = pTracker->Flags;
    pUriCacheEntry      = pTracker->pUriEntry;

    ASSERT( UL_IS_VALID_HTTP_CONNECTION( pHttpConnection ) );
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pRequest ) );
    ASSERT( IS_VALID_URI_CACHE_ENTRY( pUriCacheEntry ) );

    Status = pTracker->IoStatus.Status;

    //
    // If the send failed, then initiate an *abortive* disconnect.
    //

    if (!NT_SUCCESS(Status))
    {
        UlTrace(URI_CACHE, (
            "Http!UlpCompleteSendCacheEntryWorker(pTracker %p) "
            "Closing connection\n",
            pTracker
            ));

        UlCloseConnection(
            pHttpConnection->pConnection,
            TRUE,
            NULL,
            NULL
            );
    }

    //
    // Stop MinBytesPerSecond timer and start Connection Idle timer.
    //

    UlLockTimeoutInfo(
        &pHttpConnection->TimeoutInfo,
        &OldIrql
        );

    UlResetConnectionTimer(
        &pHttpConnection->TimeoutInfo,
        TimerMinBytesPerSecond
        );

    UlSetConnectionTimer(
        &pHttpConnection->TimeoutInfo,
        TimerConnectionIdle
        );

    UlUnlockTimeoutInfo(
        &pHttpConnection->TimeoutInfo,
        OldIrql
        );

    UlEvaluateTimerState(
        &pHttpConnection->TimeoutInfo
        );

    //
    // Unmap the FixedHeaders and Content MDLs if necessary.
    //

    if (pTracker->pMdlFixedHeaders->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA)
    {
        MmUnmapLockedPages(
            pTracker->pMdlFixedHeaders->MappedSystemVa,
            pTracker->pMdlFixedHeaders
            );
    }

    if (pTracker->pMdlVariableHeaders->Next &&
        (pTracker->pMdlContent->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA))
    {
        ASSERT( pTracker->pMdlVariableHeaders->Next == pTracker->pMdlContent );

        MmUnmapLockedPages(
            pTracker->pMdlContent->MappedSystemVa,
            pTracker->pMdlContent
            );
    }

    //
    // Do the logging before cleaning up the tracker.
    //

    if (pUriCacheEntry->LoggingEnabled)
    {
        if (pUriCacheEntry->BinaryLogged)
        {
            UlRawLogHttpCacheHit( pTracker );
        }
        else
        {
            UlLogHttpCacheHit( pTracker );
        }
    }

    //
    // Unlink the request from process if we are done with all sends.
    //

    if (0 == (pTracker->Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) &&
        0 == pRequest->ContentLength &&
        0 == pRequest->Chunked &&
        pRequest->ConfigInfo.pAppPool)
    {
        ASSERT( pRequest->SentLast );

        UlUnlinkRequestFromProcess(
            pRequest->ConfigInfo.pAppPool,
            pRequest
            );
    }

    //
    // Kick the parser back into action, if resume parsing is set in tracker.
    //

    ResumeParsing = (BOOLEAN)
        (UlResumeParsingOnSendCompletion == pTracker->ResumeParsingType);

    //
    // Invoke completion routine.
    //

    if (pTracker->pCompletionRoutine != NULL)
    {
        (pTracker->pCompletionRoutine)(
            pTracker->pCompletionContext,
            Status,
            pTracker->IoStatus.Information
            );
    }

    //
    // Clean up tracker.
    //

    FromCache = (BOOLEAN) (pTracker->pCompletionContext == NULL);
    UlpFreeCacheTracker( pTracker );

    //
    // Deref the cache entry.
    //

    UlCheckinUriCacheEntry( pUriCacheEntry );

    //
    // Deref the internal request.
    //

    UL_DEREFERENCE_INTERNAL_REQUEST( pRequest );

    if (ResumeParsing)
    {
        UlTrace(HTTP_IO, (
            "http!UlpCompleteSendCacheEntryWorker(pHttpConn = %p), "
            "RequestVerb=%d, ResponseStatusCode=%hu\n",
            pHttpConnection,
            RequestVerb,
            ResponseStatusCode
            ));

        UlResumeParsing(
            pHttpConnection,
            FromCache,
            (BOOLEAN) (Flags & HTTP_SEND_RESPONSE_FLAG_DISCONNECT)
            );
    }

    //
    // Deref the HTTP connection.
    //

    UL_DEREFERENCE_HTTP_CONNECTION( pHttpConnection );

}   // UlpCompleteSendCacheEntryWorker


/***************************************************************************++

Routine Description:

    Allocates a non-paged UL_FULL_TRACKER used as context for sending
    cached content to the client.

    CODEWORK: this routine should probably do all tracker init.

Arguments:

    SendIrpStackSize - Size of the stack for the send IRP.

Return Values:

    Either a pointer to a UL_FULL_TRACKER, or NULL if it couldn't be made.

--***************************************************************************/
PUL_FULL_TRACKER
UlpAllocateCacheTracker(
    IN CCHAR            SendIrpStackSize
    )
{
    PUL_FULL_TRACKER    pTracker;
    USHORT              SendIrpSize;
    ULONG               CacheTrackerSize;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( SendIrpStackSize > DEFAULT_MAX_IRP_STACK_SIZE );

    SendIrpSize = (USHORT) ALIGN_UP(IoSizeOfIrp(SendIrpStackSize), PVOID);

    //
    // No need to allocate space for the entire auxiliary buffer in this
    // case since this is one-time deal only.
    //

    CacheTrackerSize = ALIGN_UP(sizeof(UL_FULL_TRACKER), PVOID) +
                            SendIrpSize +
                            g_UlMaxVariableHeaderSize +
                            g_UlFixedHeadersMdlLength +
                            g_UlVariableHeadersMdlLength +
                            g_UlContentMdlLength;

    pTracker = (PUL_FULL_TRACKER) UL_ALLOCATE_POOL(
                                        NonPagedPool,
                                        CacheTrackerSize,
                                        UL_FULL_TRACKER_POOL_TAG
                                        );

    if (pTracker)
    {
        pTracker->Signature             = UL_FULL_TRACKER_POOL_TAG;
        pTracker->FromLookaside         = FALSE;
        pTracker->FromRequest           = FALSE;
        pTracker->AuxilaryBufferLength  = g_UlMaxVariableHeaderSize;
        pTracker->RequestVerb           = HttpVerbInvalid;
        pTracker->ResponseStatusCode    = 200; // OK

        UlInitializeFullTrackerPool( pTracker, SendIrpStackSize );
    }

    UlTrace( URI_CACHE, (
        "Http!UlpAllocateCacheTracker: tracker %p\n",
        pTracker
        ));

    return pTracker;

}   // UlpAllocateCacheTracker


/***************************************************************************++

Routine Description:

    Frees a UL_FULL_TRACKER.

Arguments:

    pTracker - Specifies the UL_FULL_TRACKER to free.

Return Values:

    None.

--***************************************************************************/
VOID
UlpFreeCacheTracker(
    IN PUL_FULL_TRACKER pTracker
    )
{
    UlTrace(URI_CACHE, (
        "Http!UlpFreeCacheTracker: tracker %p\n",
        pTracker
        ));

    ASSERT( IS_VALID_FULL_TRACKER( pTracker ) );

    pTracker->pHttpConnection = NULL;

    if (pTracker->FromRequest == FALSE)
    {
        if (pTracker->FromLookaside)
        {
            UlPplFreeFullTracker( pTracker );
        }
        else
        {
            UL_FREE_POOL_WITH_SIG( pTracker, UL_FULL_TRACKER_POOL_TAG );
        }
    }

}   // UlpFreeCacheTracker
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\seutil.c ===
/*++

Copyright (c) 1999-2002 Microsoft Corporation

Module Name:

    seutil.c

Abstract:

    This module implements general security utilities, and
    dispatch routines for security IRPs.

Author:

    Keith Moore (keithmo)       25-Mar-1999

Revision History:

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, UlAssignSecurity )
#pragma alloc_text( PAGE, UlDeassignSecurity )
#pragma alloc_text( PAGE, UlSetSecurity )
#pragma alloc_text( PAGE, UlQuerySecurity )
#pragma alloc_text( PAGE, UlAccessCheck )
#pragma alloc_text( PAGE, UlSetSecurityDispatch )
#pragma alloc_text( PAGE, UlQuerySecurityDispatch )
#pragma alloc_text( PAGE, UlThreadAdminCheck )
#pragma alloc_text( PAGE, UlCreateSecurityDescriptor )
#pragma alloc_text( PAGE, UlCleanupSecurityDescriptor )
#pragma alloc_test( PAGE, UlMapGenericMask )
#endif  // ALLOC_PRAGMA
#if 0
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Assigns a new security descriptor.

Arguments:

    pSecurityDescriptor - Supplies a pointer to the current security
        descriptor pointer. The current security descriptor pointer
        will be updated with the new security descriptor.

    pAccessState - Supplies the ACCESS_STATE structure containing
        the state of an access in progress.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlAssignSecurity(
    IN OUT PSECURITY_DESCRIPTOR *pSecurityDescriptor,
    IN PACCESS_STATE pAccessState
    )
{
    NTSTATUS status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( pSecurityDescriptor != NULL );
    ASSERT( pAccessState != NULL );

    //
    // Assign the security descriptor.
    //

    SeLockSubjectContext( &pAccessState->SubjectSecurityContext );

    status = SeAssignSecurity(
                    NULL,                   // ParentDescriptor
                    pAccessState->SecurityDescriptor,
                    pSecurityDescriptor,
                    FALSE,                  // IsDirectoryObject
                    &pAccessState->SubjectSecurityContext,
                    IoGetFileObjectGenericMapping(),
                    PagedPool
                    );

    SeUnlockSubjectContext( &pAccessState->SubjectSecurityContext );

    return status;

}   // UlAssignSecurity


/***************************************************************************++

Routine Description:

    Deletes a security descriptor.

Arguments:

    pSecurityDescriptor - Supplies a pointer to the current security
        descriptor pointer. The current security descriptor pointer
        will be deleted.

--***************************************************************************/
VOID
UlDeassignSecurity(
    IN OUT PSECURITY_DESCRIPTOR *pSecurityDescriptor
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( pSecurityDescriptor != NULL );

    //
    // If there's a security descriptor present, free it.
    //

    if (*pSecurityDescriptor != NULL)
    {
        SeDeassignSecurity( pSecurityDescriptor );
    }

}   // UlDeassignSecurity


/***************************************************************************++

Routine Description:

    Sets a new security descriptor.

Arguments:

    pSecurityDescriptor - Supplies a pointer to the current security
        descriptor pointer. The current security descriptor will be
        updated with the new security information.

    pSecurityInformation - Indicates which security information is
        to be applied to the object.

    pNewSecurityDescriptor - Pointer to the new security descriptor
        to be applied to the object.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlSetSecurity(
    IN OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
    IN PSECURITY_INFORMATION pSecurityInformation,
    IN PSECURITY_DESCRIPTOR pNewSecurityDescriptor
    )
{
    NTSTATUS                    status;
    PSECURITY_DESCRIPTOR        pOldSecurityDescriptor;
    SECURITY_SUBJECT_CONTEXT    securitySubjectContext;

    PAGED_CODE();

    pOldSecurityDescriptor = *ppSecurityDescriptor;

    SeCaptureSubjectContext(&securitySubjectContext);
    SeLockSubjectContext(&securitySubjectContext);

    status = SeSetSecurityDescriptorInfo(
                    NULL,
                    pSecurityInformation,
                    pNewSecurityDescriptor,
                    ppSecurityDescriptor,
                    PagedPool,
                    IoGetFileObjectGenericMapping()
                    );

    SeUnlockSubjectContext(&securitySubjectContext);
    SeReleaseSubjectContext(&securitySubjectContext);

    if (NT_SUCCESS(status))
    {
        SeDeassignSecurity(&pOldSecurityDescriptor);
    }

    return status;
}


/***************************************************************************++

Routine Description:

    Query for security descriptor information for an object.

Arguments:

    pSecurityInformation - specifies what information is being queried.

    pSecurityDescriptor - Supplies a pointer to the security descriptor
        to be filled in.

    pLength -  Address of variable containing length of the above security
        descriptor buffer. Upon return, this will contain the length needed
        to store the requested information.

    ppSecurityDescriptor - Address of a pointer to the objects security
        descriptor.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlQuerySecurity(
    IN PSECURITY_INFORMATION pSecurityInformation,
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN OUT PULONG pLength,
    IN PSECURITY_DESCRIPTOR *ppSecurityDescriptor
    )
{
    NTSTATUS                    status;
    SECURITY_SUBJECT_CONTEXT    securitySubjectContext;

    PAGED_CODE();

    SeCaptureSubjectContext(&securitySubjectContext);
    SeLockSubjectContext(&securitySubjectContext);

    status = SeQuerySecurityDescriptorInfo(
                    pSecurityInformation,
                    pSecurityDescriptor,
                    pLength,
                    ppSecurityDescriptor
                    );

    SeUnlockSubjectContext(&securitySubjectContext);
    SeReleaseSubjectContext(&securitySubjectContext);

    return status;
}


/***************************************************************************++

Routine Description:

    Determines if a user has access to the specified resource.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor protecting
        the resource.

    pAccessState - Supplies the ACCESS_STATE structure containing
        the state of an access in progress.

    DesiredAccess - Supplies an access mask describing the user's
        desired access to the resource. This mask is assumed to not
        contain generic access types.

    RequestorMode - Supplies the processor mode by which the access is
        being requested.

    pObjectName - Supplies the name of the object being referenced.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlAccessCheck(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PACCESS_STATE pAccessState,
    IN ACCESS_MASK DesiredAccess,
    IN KPROCESSOR_MODE RequestorMode,
    IN PCWSTR pObjectName
    )
{
    NTSTATUS status, aaStatus;
    BOOLEAN accessGranted;
    PPRIVILEGE_SET pPrivileges = NULL;
    ACCESS_MASK grantedAccess;
    UNICODE_STRING objectName;
    UNICODE_STRING typeName;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( pSecurityDescriptor != NULL );
    ASSERT( pAccessState != NULL );

    //
    // Perform the access check.
    //

    SeLockSubjectContext( &pAccessState->SubjectSecurityContext );

    accessGranted = SeAccessCheck(
                        pSecurityDescriptor,
                        &pAccessState->SubjectSecurityContext,
                        TRUE,               // SubjectContextLocked
                        DesiredAccess,
                        0,                  // PreviouslyGrantedAccess
                        &pPrivileges,
                        IoGetFileObjectGenericMapping(),
                        RequestorMode,
                        &grantedAccess,
                        &status
                        );

    if (pPrivileges != NULL)
    {
        SeAppendPrivileges( pAccessState, pPrivileges );
        SeFreePrivileges( pPrivileges );
    }

    if (accessGranted)
    {
        pAccessState->PreviouslyGrantedAccess |= grantedAccess;
        pAccessState->RemainingDesiredAccess &= ~(grantedAccess | MAXIMUM_ALLOWED);
    }

    aaStatus = UlInitUnicodeStringEx( &typeName, L"Ul" );

    if ( NT_SUCCESS(aaStatus) )
    {
        aaStatus = UlInitUnicodeStringEx( &objectName, pObjectName );

        if ( NT_SUCCESS(aaStatus) )
        {
            SeOpenObjectAuditAlarm(
                &typeName,
                NULL,               // Object
                &objectName,
                pSecurityDescriptor,
                pAccessState,
                FALSE,              // ObjectCreated
                accessGranted,
                RequestorMode,
                &pAccessState->GenerateOnClose
                );
        }
    }

    SeUnlockSubjectContext( &pAccessState->SubjectSecurityContext );

    if (accessGranted)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        //
        // SeAccessCheck() should have set the completion status.
        //

        ASSERT( !NT_SUCCESS(status) );
    }
    
    return status;

}   // UlAccessCheck


NTSTATUS
UlSetSecurityDispatch(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    NTSTATUS                status;
    PIO_STACK_LOCATION      pIrpSp;
    PFILE_OBJECT            pFileObject;
    PUL_APP_POOL_PROCESS    pProcess;

    UNREFERENCED_PARAMETER(pDeviceObject);

    PAGED_CODE();

    UL_ENTER_DRIVER( "UlSetSecurityDispatch", pIrp );

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pFileObject = pIrpSp->FileObject;
    
    //
    //  We only allow changing the security descriptor on app
    //  pool handles.
    //
    if (!IS_APP_POOL_FO(pFileObject))
    {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    pProcess = GET_APP_POOL_PROCESS(pFileObject);

    status = UlSetSecurity(
                &pProcess->pAppPool->pSecurityDescriptor,
                &pIrpSp->Parameters.SetSecurity.SecurityInformation,
                pIrpSp->Parameters.SetSecurity.SecurityDescriptor
                );
    
complete:

    pIrp->IoStatus.Status = status;

    UlCompleteRequest(pIrp, IO_NO_INCREMENT);

    UL_LEAVE_DRIVER( "UlSetSecurityDispatch" );
    RETURN(status);

} // UlSetSecurityDispatch


NTSTATUS
UlQuerySecurityDispatch(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    NTSTATUS                status;
    PIO_STACK_LOCATION      pIrpSp;
    PFILE_OBJECT            pFileObject;
    PUL_APP_POOL_PROCESS    pProcess;

    UNREFERENCED_PARAMETER(pDeviceObject);

    PAGED_CODE();

    UL_ENTER_DRIVER( "UlQuerySecurityDispatch", pIrp );

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pFileObject = pIrpSp->FileObject;
    
    //
    //  We only allow querying the security descriptor on app
    //  pool handles.
    //
    if (!IS_APP_POOL_FO(pFileObject))
    {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    pProcess = GET_APP_POOL_PROCESS(pFileObject);

    status = UlQuerySecurity(
                &pIrpSp->Parameters.QuerySecurity.SecurityInformation,
                pIrp->UserBuffer,
                &pIrpSp->Parameters.QuerySecurity.Length,
                &pProcess->pAppPool->pSecurityDescriptor
                );

    if (pIrp->UserIosb)
    {
        pIrp->UserIosb->Information = pIrpSp->Parameters.QuerySecurity.Length;
    }

complete:

    pIrp->IoStatus.Status = status;

    UlCompleteRequest(pIrp, IO_NO_INCREMENT);

    UL_LEAVE_DRIVER( "UlQuerySecurityDispatch" );
    RETURN(status);

} // UlQuerySecurityDispatch


/***************************************************************************++

Routine Description:

    Determines if this is a thread with Admin/LocalSystem privileges.

Arguments:

    DesiredAccess - Supplies an access mask describing the user's
        desired access to the resource. This mask is assumed to not
        contain generic access types.

    RequestorMode - Supplies the processor mode by which the access is
        being requested.

    pObjectName - Supplies the name of the object being referenced.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlThreadAdminCheck(
    IN ACCESS_MASK     DesiredAccess,
    IN KPROCESSOR_MODE RequestorMode,
    IN PCWSTR pObjectName
    )
{
    ACCESS_STATE    AccessState;
    AUX_ACCESS_DATA AuxData;
    NTSTATUS        Status;

    Status = SeCreateAccessState(
                    &AccessState,
                    &AuxData,
                    DesiredAccess,
                    NULL
                    );

    if(NT_SUCCESS(Status))
    {
        Status = UlAccessCheck(
                        g_pAdminAllSystemAll,
                        &AccessState,
                        DesiredAccess,
                        RequestorMode,
                        pObjectName
                        );

        SeDeleteAccessState(&AccessState);
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    Allocates and initializes a security descriptor with the specified
    attributes.

Arguments:

    pSecurityDescriptor - Supplies a pointer to the security descriptor
        to initialize.

    pSidMaskPairs - Supplies an array of SID/ACCESS_MASK pairs.

    NumSidMaskPairs - Supplies the number of SID/ACESS_MASK pairs.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCreateSecurityDescriptor(
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSID_MASK_PAIR pSidMaskPairs,
    IN ULONG NumSidMaskPairs
    )
{
    NTSTATUS status;
    PACL pDacl;
    ULONG daclLength;
    ULONG i;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( pSecurityDescriptor != NULL );
    ASSERT( pSidMaskPairs != NULL );
    ASSERT( NumSidMaskPairs > 0 );

    //
    // Setup locals so we know how to cleanup on exit.
    //

    pDacl = NULL;

    //
    // Initialize the security descriptor.
    //

    status = RtlCreateSecurityDescriptor(
                    pSecurityDescriptor,            // SecurityDescriptor
                    SECURITY_DESCRIPTOR_REVISION    // Revision
                    );

    if (!NT_SUCCESS(status))
    {
        goto cleanup;
    }

    //
    // Calculate the DACL length.
    //

    daclLength = sizeof(ACL);

    for (i = 0 ; i < NumSidMaskPairs ; i++)
    {
        daclLength += sizeof(ACCESS_ALLOWED_ACE);
        daclLength += RtlLengthSid( pSidMaskPairs[i].pSid );
    }

    //
    // Allocate & initialize the DACL.
    //

    pDacl = (PACL) UL_ALLOCATE_POOL(
                PagedPool,
                daclLength,
                UL_SECURITY_DATA_POOL_TAG
                );

    if (pDacl == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    status = RtlCreateAcl(
                    pDacl,                          // Acl
                    daclLength,                     // AclLength
                    ACL_REVISION                    // AclRevision
                    );

    if (!NT_SUCCESS(status))
    {
        goto cleanup;
    }

    //
    // Add the necessary access-allowed ACEs to the DACL.
    //

    for (i = 0 ; i < NumSidMaskPairs ; i++)
    {
        status = RtlAddAccessAllowedAceEx(
                        pDacl,                          // Acl
                        ACL_REVISION,                   // AceRevision
                        pSidMaskPairs[i].AceFlags,      // Inheritance flags
                        pSidMaskPairs[i].AccessMask,    // AccessMask
                        pSidMaskPairs[i].pSid           // Sid
                        );

        if (!NT_SUCCESS(status))
        {
            goto cleanup;
        }
    }

    //
    // Attach the DACL to the security descriptor.
    //

    status = RtlSetDaclSecurityDescriptor(
                    pSecurityDescriptor,                // SecurityDescriptor
                    TRUE,                               // DaclPresent
                    pDacl,                              // Dacl
                    FALSE                               // DaclDefaulted
                    );

    if (!NT_SUCCESS(status))
    {
        goto cleanup;
    }

    //
    // Success!
    //

    ASSERT( NT_SUCCESS(status) );
    return STATUS_SUCCESS;

cleanup:

    ASSERT( !NT_SUCCESS(status) );

    if (pDacl != NULL)
    {
        UL_FREE_POOL(
            pDacl,
            UL_SECURITY_DATA_POOL_TAG
            );
    }

    return status;

}   // UlpCreateSecurityDescriptor

/***************************************************************************++

Routine Description:

    Frees any resources associated with the security descriptor created
    by UlpCreateSecurityDescriptor().

Arguments:

    pSecurityDescriptor - Supplies the security descriptor to cleanup.

--***************************************************************************/
VOID
UlCleanupSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    NTSTATUS status;
    PACL pDacl;
    BOOLEAN daclPresent;
    BOOLEAN daclDefaulted;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( RtlValidSecurityDescriptor( pSecurityDescriptor ) );

    //
    // Try to retrieve the DACL from the security descriptor.
    //

    status = RtlGetDaclSecurityDescriptor(
                    pSecurityDescriptor,            // SecurityDescriptor
                    &daclPresent,                   // DaclPresent
                    &pDacl,                         // Dacl
                    &daclDefaulted                  // DaclDefaulted
                    );

    if (NT_SUCCESS(status))
    {
        if (daclPresent && (pDacl != NULL))
        {
            UL_FREE_POOL(
                pDacl,
                UL_SECURITY_DATA_POOL_TAG
                );
        }
    }

}   // UlCleanupSecurityDescriptor


/**************************************************************************++

Routine Description:

    This routine maps the generic access masks of the ACE's present in the
    DACL of the supplied security descriptor.

    CODEWORK: Get RtlpApplyAclToObject exported.

Arguments:

    pSecurityDescriptor - Supplies security descriptor.

Return Value:

    NTSTATUS.

--**************************************************************************/
NTSTATUS
UlMapGenericMask(
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    ULONG       i;
    PACE_HEADER Ace;
    PACL        Dacl;
    NTSTATUS    Status;
    BOOLEAN     Ignore;
    BOOLEAN     DaclPresent = FALSE;

    //
    // Get the DACL.
    //

    Status = RtlGetDaclSecurityDescriptor(
                 pSecurityDescriptor,
                 &DaclPresent,
                 &Dacl,
                 &Ignore
                 );

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    if (DaclPresent)
    {
        //
        // RtlpApplyAclToObject(Acl, GenericMapping) is cloned below since
        // it is not exported.
        //

        //
        // Now walk the ACL, mapping each ACE as we go.
        //

        for (i = 0, Ace = FirstAce(Dacl);
             i < Dacl->AceCount;
             i += 1, Ace = NextAce(Ace))
        {
            if (IsMSAceType(Ace))
            {
                RtlApplyAceToObject(Ace, &g_UrlAccessGenericMapping);
            }
        }
    }

    return STATUS_SUCCESS;
}


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\seutil.h ===
/*++

Copyright (c) 1999-2002 Microsoft Corporation

Module Name:

    seutil.h

Abstract:

    This module contains general security utilities.

Author:

    Keith Moore (keithmo)       25-Mar-1999

Revision History:

--*/


#ifndef _SEUTIL_H_
#define _SEUTIL_H_

//
// Generic Access Map for url acls
//

#define HTTP_ALLOW_REGISTER_URL 0x0001
#define HTTP_ALLOW_DELEGATE_URL 0x0002

//
// Public functions
//

NTSTATUS
UlAssignSecurity(
    IN OUT PSECURITY_DESCRIPTOR *pSecurityDescriptor,
    IN PACCESS_STATE pAccessState
    );

VOID
UlDeassignSecurity(
    IN OUT PSECURITY_DESCRIPTOR *pSecurityDescriptor
    );

NTSTATUS
UlSetSecurity(
    IN OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
    IN PSECURITY_INFORMATION pSecurityInformation,
    IN PSECURITY_DESCRIPTOR pNewSecurityDescriptor
    );

NTSTATUS
UlQuerySecurity(
    IN PSECURITY_INFORMATION pSecurityInformation,
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN OUT PULONG pLength,
    IN PSECURITY_DESCRIPTOR *ppSecurityDescriptor
    );

NTSTATUS
UlAccessCheck(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PACCESS_STATE pAccessState,
    IN ACCESS_MASK DesiredAccess,
    IN KPROCESSOR_MODE RequestorMode,
    IN PCWSTR pObjectName
    );

NTSTATUS
UlSetSecurityDispatch(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
UlQuerySecurityDispatch(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
UlThreadAdminCheck(
    IN ACCESS_MASK     DesiredAccess,
    IN KPROCESSOR_MODE RequestorMode,
    IN PCWSTR pObjectName
    );

typedef struct _SID_MASK_PAIR
{
    PSID        pSid;
    ACCESS_MASK AccessMask;
    ULONG       AceFlags;
    
} SID_MASK_PAIR, *PSID_MASK_PAIR;

NTSTATUS
UlCreateSecurityDescriptor(
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSID_MASK_PAIR pSidMaskPairs,
    IN ULONG NumSidMaskPairs
    );

VOID
UlCleanupSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

NTSTATUS
UlMapGenericMask(
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

#endif  // _SEUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\strlog.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    strlog.c

Abstract:

    This module implements a string log.

    A string log is a fast, in-memory, thread-safe activity log of
    variable-length strings. It's modelled on the tracelog code.

Author:

    George V. Reilly (GeorgeRe)  23-Jul-2001

Revision History:

--*/


#include "precomp.h"
#include "strlogp.h"

ULONG g_StringLogDbgPrint = 0;

/***************************************************************************++

Routine Description:

    Creates a new (empty) string log.

Arguments:

    LogSize - Supplies the number of bytes in the string buffer.

    ExtraBytesInHeader - Supplies the number of extra bytes to include
        in the log header. This is useful for adding application-specific
        data to the log.

Return Value:

    PSTRING_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--***************************************************************************/
PSTRING_LOG
CreateStringLog(
    IN ULONG    LogSize,
    IN ULONG    ExtraBytesInHeader,
    BOOLEAN     EchoDbgPrint
    )
{
    ULONG TotalHeaderSize;
    PSTRING_LOG pLog;
    PUCHAR pLogBuffer;

    if (LogSize >= 20 * 1024 * 1024)
        return NULL;

    //
    // Round up to page size
    //

    LogSize = (LogSize + (PAGE_SIZE-1)) & ~(PAGE_SIZE-1);

    //
    // Allocate & initialize the log structure.
    //

    TotalHeaderSize = sizeof(*pLog) + ExtraBytesInHeader;

    pLogBuffer = (PUCHAR) ExAllocatePoolWithTag(
                                NonPagedPool,
                                LogSize,
                                UL_STRING_LOG_BUFFER_POOL_TAG
                                );

    if (pLogBuffer == NULL)
        return NULL;

    pLog = (PSTRING_LOG) ExAllocatePoolWithTag(
                                NonPagedPool,
                                TotalHeaderSize,
                                UL_STRING_LOG_POOL_TAG
                                );

    //
    // Initialize it.
    //

    if (pLog != NULL)
    {
        RtlZeroMemory( pLog, TotalHeaderSize );

        pLog->Signature = STRING_LOG_SIGNATURE;
        pLog->pLogBuffer = pLogBuffer;
        pLog->LogSize = LogSize;
        pLog->EchoDbgPrint = EchoDbgPrint;
        KeInitializeSpinLock(&pLog->SpinLock);

        ResetStringLog(pLog);
    }
    else
    {
        ExFreePoolWithTag( pLogBuffer, UL_STRING_LOG_BUFFER_POOL_TAG );
    }

    return pLog;

}   // CreateStringLog


/***************************************************************************++

Routine Description:

    Resets the specified string log such that the next entry written
    will be placed at the beginning of the log.

Arguments:

    pLog - Supplies the string log to reset.

--***************************************************************************/
VOID
ResetStringLog(
    IN PSTRING_LOG pLog
    )
{
    // Keep this in sync with !ulkd.strlog -r
        
    if (pLog != NULL)
    {
        PSTRING_LOG_MULTI_ENTRY pMultiEntry
            = (PSTRING_LOG_MULTI_ENTRY) pLog->pLogBuffer;
        KIRQL OldIrql;

        KeAcquireSpinLock(&pLog->SpinLock, &OldIrql);
    
        ASSERT( pLog->Signature == STRING_LOG_SIGNATURE );

        RtlZeroMemory(pLog->pLogBuffer, pLog->LogSize);
        pLog->NextEntry = 0;
        pLog->LastEntryLength = 0;
        pLog->WrapAroundCount = 0;

        //
        // Write an initial multi-entry record at the very beginning
        // of the log buffer. When we wraparound, we always place a
        // multi-entry record at the beginning of the log buffer.
        // Having this invariant makes !ulkd.strlog simpler.
        //

        pMultiEntry->Signature  = STRING_LOG_ENTRY_MULTI_SIGNATURE;
        pMultiEntry->NumEntries = 0;
        pMultiEntry->PrevDelta  = 0;

        ++pMultiEntry;
        pMultiEntry->Signature = STRING_LOG_ENTRY_LAST_SIGNATURE;

        pLog->MultiOffset = 0;
        pLog->Offset = sizeof(STRING_LOG_MULTI_ENTRY);
        pLog->MultiByteCount = sizeof(STRING_LOG_MULTI_ENTRY);
        pLog->MultiNumEntries = 0;

        pLog->InitialTimeStamp.QuadPart = 0;

        KeReleaseSpinLock(&pLog->SpinLock, OldIrql);
    }

} // ResetStringLog


/***************************************************************************++

Routine Description:

    Destroys a string log created with CreateStringLog().

Arguments:

    pLog - Supplies the string log to destroy.

--***************************************************************************/
VOID
DestroyStringLog(
    IN PSTRING_LOG pLog
    )
{
    if (pLog != NULL)
    {
        ASSERT( pLog->Signature == STRING_LOG_SIGNATURE );

        pLog->Signature = STRING_LOG_SIGNATURE_X;
        ExFreePoolWithTag( pLog->pLogBuffer, UL_STRING_LOG_BUFFER_POOL_TAG );
        ExFreePoolWithTag( pLog, UL_STRING_LOG_POOL_TAG );
    }

}   // DestroyStringLog


/***************************************************************************++

Routine Description:

    Writes a new entry to the specified string log.

Arguments:

    pLog - Supplies the log to write to.

    Format - printf-style format string

    arglist - va_list bundling up the arguments

Return Value:

    LONGLONG - Index of the newly written entry

--***************************************************************************/
LONGLONG
__cdecl
WriteStringLogVaList(
    IN PSTRING_LOG pLog,
    IN PCH Format,
    IN va_list arglist
    )
{
    UCHAR Buffer[PRINTF_BUFFER_LEN];
    PUCHAR pTarget;
    int cb;
    ULONG i;
    ULONG cb2;
    ULONG PrevDelta;
    ULONG MultiPrevDelta;
    PSTRING_LOG_ENTRY pEntry;
    LONGLONG index;
    KIRQL OldIrql;
    BOOLEAN NeedMultiEntry = FALSE;
    LARGE_INTEGER TimeStamp;

    ASSERT( pLog->Signature == STRING_LOG_SIGNATURE );

    cb = _vsnprintf((char*) Buffer, sizeof(Buffer), Format, arglist);

    //
    // Local Buffer overflow?
    //

    if (cb < 0)
    {
        cb = sizeof(Buffer);
    }

    // _vsnprintf doesn't always NUL-terminate the buffer
    Buffer[DIMENSION(Buffer)-1] = '\0';

    if (pLog->EchoDbgPrint)
        DbgPrint("%s", (PCH) Buffer);

    //
    // Add 1 to 4 bytes of zeroes at end to terminate string,
    // then round up to ULONG alignment
    //
    
    cb2 = ((sizeof(STRING_LOG_ENTRY) + cb + sizeof(ULONG))
                & ~(sizeof(ULONG) - 1));
    ASSERT(cb2 < 0x10000);  // Must fit in a USHORT

    //
    // Find the next slot, copy the entry to the slot.
    //
    KeQuerySystemTime(&TimeStamp);

    KeAcquireSpinLock(&pLog->SpinLock, &OldIrql);
    
    if (0 == pLog->InitialTimeStamp.QuadPart)
        pLog->InitialTimeStamp = TimeStamp;

    TimeStamp.QuadPart -= pLog->InitialTimeStamp.QuadPart;
        
    index = pLog->NextEntry++;

    PrevDelta = pLog->LastEntryLength;
    MultiPrevDelta = pLog->MultiByteCount;
    pLog->LastEntryLength = (USHORT) cb2;

    ASSERT(pLog->Offset <= pLog->LogSize);
    
    //
    // Handle wraparound of the log buffer. Since LogSize is typically much
    // larger than PRINTF_BUFFER_LEN, this is an infrequent operation.
    // Must have enough space for all of the regular STRING_LOG_ENTRY,
    // a multi STRING_LOG_ENTRY, and the zero-terminated string itself.
    //
    
    if (pLog->Offset + cb2 + sizeof(STRING_LOG_ENTRY) >= pLog->LogSize)
    {
        ULONG WastedSpace = pLog->LogSize - pLog->Offset;

        ASSERT(WastedSpace > 0);

        // Clear to the end of the log buffer
        for (i = 0;  i < WastedSpace;  i += sizeof(ULONG))
        {
            PULONG pul = (PULONG) (pLog->pLogBuffer + pLog->Offset + i);
            ASSERT(((ULONG_PTR) pul & (sizeof(ULONG) - 1)) == 0);
            *pul = STRING_LOG_ENTRY_EOB_SIGNATURE;
        }

        // Reset to the beginning
        pLog->Offset = 0;
        ++pLog->WrapAroundCount;
        PrevDelta += WastedSpace;
        MultiPrevDelta += WastedSpace;

        // Always want a multi-entry record at the beginning of the log buffer
        NeedMultiEntry = TRUE;
    }
    else if (pLog->MultiNumEntries >= STRING_LOG_MULTIPLE_ENTRIES)
    {
        NeedMultiEntry = TRUE;
    }
    else
    {
        ++pLog->MultiNumEntries;
    }

    //
    // If we've had STRING_LOG_MULTIPLE_ENTRIES regular entries since the
    // last multi-entry or if we've wrapped around the beginning of the
    // log buffer, we need a new multi-entry.
    //
    
    if (NeedMultiEntry)
    {
        PSTRING_LOG_MULTI_ENTRY pMultiEntry;

        pTarget = pLog->pLogBuffer + pLog->Offset;
        ASSERT(((ULONG_PTR) pTarget & (sizeof(ULONG) - 1)) == 0);

        pMultiEntry = (PSTRING_LOG_MULTI_ENTRY) pTarget;
        pMultiEntry->Signature = STRING_LOG_ENTRY_MULTI_SIGNATURE;

        ASSERT(pLog->MultiNumEntries <= STRING_LOG_MULTIPLE_ENTRIES);
        pMultiEntry->NumEntries = pLog->MultiNumEntries;
        pLog->MultiNumEntries = 1;   // for the entry generated below

        ASSERT(MultiPrevDelta < 0x10000);
        pMultiEntry->PrevDelta = (USHORT) MultiPrevDelta;

        pLog->MultiOffset = pLog->Offset;
        pLog->MultiByteCount = sizeof(STRING_LOG_MULTI_ENTRY);

        pLog->Offset += sizeof(STRING_LOG_MULTI_ENTRY);
        PrevDelta += sizeof(STRING_LOG_MULTI_ENTRY);
    }

    pTarget = pLog->pLogBuffer + pLog->Offset;
    ASSERT(((ULONG_PTR) pTarget & (sizeof(ULONG) - 1)) == 0);

    pLog->MultiByteCount = (USHORT) (pLog->MultiByteCount + (USHORT) cb2);
    pLog->Offset += (USHORT) cb2;

    ASSERT(pLog->Offset <= pLog->LogSize);
    ASSERT(pLog->pLogBuffer <= pTarget
           && pTarget + cb2 < pLog->pLogBuffer + pLog->LogSize);
    
    // Put a special signature where the next entry will start
    *(PULONG) (pTarget + cb2) = STRING_LOG_ENTRY_LAST_SIGNATURE;

    if (g_StringLogDbgPrint)
    {
        DbgPrint("%4I64d: %s"
                 "\tLen=%d (%x), PD=%d (%x); "
                 "Off=%d (%x), Lel=%d (%x); "
                 "Multi: Off=%d (%x), Lel=%d (%x), NE=%d; "
                 "WA=%lu, NME=%d\n",
                 index, Buffer,
                 cb, cb, PrevDelta, PrevDelta,
                 pLog->Offset, pLog->Offset,
                 pLog->LastEntryLength, pLog->LastEntryLength,
                 pLog->MultiOffset, pLog->MultiOffset,
                 pLog->MultiByteCount, pLog->MultiByteCount,
                 pLog->MultiNumEntries,
                 pLog->WrapAroundCount, (int) NeedMultiEntry
                 );
    }

    KeReleaseSpinLock(&pLog->SpinLock, OldIrql);
    
    // Finally, fill out the entry
    
    pEntry = (PSTRING_LOG_ENTRY) pTarget;

    pEntry->Signature = STRING_LOG_ENTRY_SIGNATURE;
    pEntry->Length = (USHORT) cb;
    ASSERT(PrevDelta < 0x10000);
    pEntry->PrevDelta = (USHORT) PrevDelta;
    pEntry->Processor = (UCHAR) KeGetCurrentProcessorNumber();
    pEntry->TimeStampLowPart  = TimeStamp.LowPart;
    pEntry->TimeStampHighPart = TimeStamp.HighPart;

    pTarget = (PUCHAR) (pEntry + 1);
    
    RtlCopyMemory( pTarget, Buffer, cb );

    for (i = cb;  i < cb2 - sizeof(STRING_LOG_ENTRY);  ++i)
        pTarget[i] = '\0';

    pTarget = (PUCHAR) (pEntry + cb2);

    return index;
}   // WriteStringLogVaList


/***************************************************************************++

Routine Description:

    Writes a new entry to the specified string log.

Arguments:

    pLog - Supplies the log to write to.

    Format... - printf-style format string and arguments

Return Value:

    LONGLONG - Index of the newly written entry within the string.

--***************************************************************************/
LONGLONG
__cdecl
WriteStringLog(
    IN PSTRING_LOG pLog,
    IN PCH Format,
    ...
    )
{
    LONGLONG index;
    va_list arglist;
    
    if (pLog == NULL)
        return -1;

    va_start(arglist, Format);

    index = WriteStringLogVaList(pLog, Format, arglist);

    va_end(arglist);

    return index;
}   // WriteStringLog


/***************************************************************************++

Routine Description:

    Writes a new entry to the global string log.

Arguments:

    pLog - Supplies the log to write to.

    Format... - printf-style format string and arguments

Return Value:

    LONGLONG - Index of the newly written entry within the string.

--***************************************************************************/
LONGLONG
__cdecl
WriteGlobalStringLog(
    IN PCH Format,
    ...
    )
{
    LONGLONG index;
    va_list arglist;
    
    if (g_pGlobalStringLog == NULL)
        return -1;

    va_start(arglist, Format);

    index = WriteStringLogVaList(g_pGlobalStringLog, Format, arglist);

    va_end(arglist);

    return index;
} // WriteGlobalStringLog
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\servinfo.c ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    servinfo.c

Abstract:

    Contains the code that implements a server information structure.

Author:

    Henry Sanders (henrysa) 10-Aug0-2000

Revision History:

--*/

#include "precomp.h"


//
// Private constants.
//

#define HTTP_PREFIX_W       L"HTTP://"
#define HTTP_PREFIX_LENGTH  (sizeof(HTTP_PREFIX_W) - sizeof(WCHAR))
#define HTTPS_PREFIX_W      L"HTTPS://"
#define HTTPS_PREFIX_LENGTH (sizeof(HTTPS_PREFIX_W) - sizeof(WCHAR))

//
// The macros to compute our hash code.
//

#define HTTP_HASH_CHAR(hash, val)   (HASH_MULTIPLY(hash) + (ULONG)(val))
#define HTTP_HASH_ID(hash, val)     (HASH_MULTIPLY(hash) + (ULONG)(val))

//
// Which globals have been initialized?
//
#define SERVINFO_CLIENT_LOOKASIDE       0x00000001UL
#define SERVINFO_COMMON_LOOKASIDE       0x00000002UL
#define SERVINFO_LIST                   0x00000004UL
#define SERVINFO_LIST_RESOURCE          0x00000008UL
#define SERVINFO_COMMON_TABLE           0x00000010UL


//
// Private globals
//

//
// Which globals have been initialized?
//

ULONG g_ServInfoInitFlags = 0;

//
// Global size of the server info hash table.
//

ULONG   g_CommonSIHashTableSize = UC_DEFAULT_SI_TABLE_SIZE;

//
// Server information lookaside
//

NPAGED_LOOKASIDE_LIST   g_ClientServerInformationLookaside;
NPAGED_LOOKASIDE_LIST   g_CommonServerInformationLookaside;

//
// Server Information list - global list of server information structures.
//

LIST_ENTRY              g_ServInfoList;
UL_ERESOURCE            g_ServInfoListResource;

//
// Variables used for quick check of URL prefix.
// They must be 64 bit aligned on IA64
//
DECLSPEC_ALIGN(UL_CACHE_LINE)
const USHORT g_HttpPrefix[] = L"http";

DECLSPEC_ALIGN(UL_CACHE_LINE)
const USHORT g_HttpPrefix2[] = L"://\0";

DECLSPEC_ALIGN(UL_CACHE_LINE)
const USHORT g_HttpSPrefix2[] = L"s://";

//
// Pointer to the server info table.
//

PUC_SERVER_INFO_TABLE_HEADER  g_UcCommonServerInfoTable;


#ifdef ALLOC_PRAGMA

#pragma alloc_text( INIT, UcInitializeServerInformation )
#pragma alloc_text( PAGE, UcTerminateServerInformation )
#pragma alloc_text( PAGE, UcCreateServerInformation )
#pragma alloc_text( PAGE, UcpLookupCommonServerInformation )

#pragma alloc_text( PAGEUC, UcReferenceServerInformation )
#pragma alloc_text( PAGEUC, UcDereferenceServerInformation )
#pragma alloc_text( PAGEUC, UcSendRequest )
#pragma alloc_text( PAGEUC, UcpFreeServerInformation )
#pragma alloc_text( PAGEUC, UcCloseServerInformation )
#pragma alloc_text( PAGEUC, UcpFreeCommonServerInformation )
#pragma alloc_text( PAGEUC, UcReferenceCommonServerInformation )
#pragma alloc_text( PAGEUC, UcDereferenceCommonServerInformation )
#pragma alloc_text( PAGEUC, UcSetServerContextInformation )
#pragma alloc_text( PAGEUC, UcQueryServerContextInformation )
#pragma alloc_text( PAGEUC, UcpGetConnectionOnServInfo )
#pragma alloc_text( PAGEUC, UcpGetNextConnectionOnServInfo )
#pragma alloc_text( PAGEUC, UcpSetServInfoMaxConnectionCount )
#pragma alloc_text( PAGEUC, UcpFixupIssuerList )
#pragma alloc_text( PAGEUC, UcpNeedToCaptureSerializedCert )
#pragma alloc_text( PAGEUC, UcCaptureSslServerCertInfo )

#endif  // ALLOC_PRAGMA


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Initalize the server information code.

Arguments:


Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcInitializeServerInformation(
    VOID
    )
{
    ULONG           i;

    ExInitializeNPagedLookasideList(
        &g_ClientServerInformationLookaside,
        NULL,
        NULL,
        0,
        sizeof(UC_PROCESS_SERVER_INFORMATION),
        UC_PROCESS_SERVER_INFORMATION_POOL_TAG,
        0
        );

    g_ServInfoInitFlags |= SERVINFO_CLIENT_LOOKASIDE;

    UlInitializeResource(
        &g_ServInfoListResource,
        "Global Server Info Table",
        0,
        UC_SERVER_INFO_TABLE_POOL_TAG
        );

    g_ServInfoInitFlags |= SERVINFO_LIST_RESOURCE;

    InitializeListHead(&g_ServInfoList);

    g_ServInfoInitFlags |= SERVINFO_LIST;

    //
    // Each per-process ServerInformation structure points to a globally
    // shared per-server structure. Let's initialize this now. Again, no
    // quota charging.
    //

    g_UcCommonServerInfoTable = (PUC_SERVER_INFO_TABLE_HEADER)
                        UL_ALLOCATE_POOL(
                              NonPagedPool,
                              (g_CommonSIHashTableSize *
                              sizeof(UC_SERVER_INFO_TABLE_HEADER)),
                              UC_SERVER_INFO_TABLE_POOL_TAG
                              );

    if(NULL == g_UcCommonServerInfoTable)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    g_ServInfoInitFlags |= SERVINFO_COMMON_TABLE;

    ExInitializeNPagedLookasideList(
        &g_CommonServerInformationLookaside,
        NULL,
        NULL,
        0,
        sizeof(UC_COMMON_SERVER_INFORMATION),
        UC_COMMON_SERVER_INFORMATION_POOL_TAG,
        0
        );

    g_ServInfoInitFlags |= SERVINFO_COMMON_LOOKASIDE;

    RtlZeroMemory(g_UcCommonServerInfoTable,
                 (g_CommonSIHashTableSize *
                  sizeof(UC_SERVER_INFO_TABLE_HEADER)) );

    for (i = 0; i < g_CommonSIHashTableSize; i++)
    {
        UlInitializeResource(
            &g_UcCommonServerInfoTable[i].Resource,
            "Common Server Info Table %d",
            i,
            UC_SERVER_INFO_TABLE_POOL_TAG
            );

        InitializeListHead(&g_UcCommonServerInfoTable[i].List);

        g_UcCommonServerInfoTable[i].Version = 0;
    }

    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    Terminate the server information code.

Arguments:


Return Value:


--***************************************************************************/
VOID
UcTerminateServerInformation(
    VOID
    )
{
    ULONG  i;

    if (g_ServInfoInitFlags & SERVINFO_COMMON_TABLE)
    {
        ASSERT(g_UcCommonServerInfoTable);

        // Make sure this cleanup doesn't happen again.
        g_ServInfoInitFlags &= ~SERVINFO_COMMON_TABLE;

        for (i = 0; i < g_CommonSIHashTableSize; i++)
        {
            UlDeleteResource(
                &g_UcCommonServerInfoTable[i].Resource
                );

            ASSERT(IsListEmpty(&g_UcCommonServerInfoTable[i].List));
        }

        // No Quota
        UL_FREE_POOL(g_UcCommonServerInfoTable, UC_SERVER_INFO_TABLE_POOL_TAG);
    }
    else
    {
        ASSERT(g_UcCommonServerInfoTable == NULL);
    }

    if (g_ServInfoInitFlags & SERVINFO_COMMON_LOOKASIDE)
    {
        // Make sure this cleanup does't happen again.
        g_ServInfoInitFlags &= ~SERVINFO_COMMON_LOOKASIDE;

        ExDeleteNPagedLookasideList(&g_CommonServerInformationLookaside);
    }

    if (g_ServInfoInitFlags & SERVINFO_LIST)
    {
        // Make sure this cleanup does't happen again.
        g_ServInfoInitFlags &= ~SERVINFO_LIST;

        ASSERT(IsListEmpty(&g_ServInfoList));
    }

    if (g_ServInfoInitFlags & SERVINFO_LIST_RESOURCE)
    {
        // Make sure this cleanup doesn't happen again.
        g_ServInfoInitFlags &= ~SERVINFO_LIST_RESOURCE;

        UlDeleteResource(&g_ServInfoListResource);
    }

    if (g_ServInfoInitFlags & SERVINFO_CLIENT_LOOKASIDE)
    {
        // Make sure this cleanup doesn't happen again.
        g_ServInfoInitFlags &= ~SERVINFO_CLIENT_LOOKASIDE;

        ExDeleteNPagedLookasideList(&g_ClientServerInformationLookaside);
    }
}

/***************************************************************************++

Routine Description:

    Find a server information structure appropriate for the URI. If no
    such structure exists we'll attempt to create one.

    As part of this we'll validate that the input URI is well formed.

Arguments:

    pServerInfo         - Receives a pointer to the server info structure.
    pUri                - Pointer to the URI string.
    uriLength           - Length (in bytes) of URI string.
    bShared             - False if we're to create a new server information
                          structure, regardless of whether or not one exists.
    pProxy              - The name of the proxy (optional)
    ProxyLength         - Length (in bytes) of the proxy name.

Return Value:

    Status of attempt.

--***************************************************************************/
NTSTATUS
UcCreateServerInformation(
    OUT PUC_PROCESS_SERVER_INFORMATION    *pServerInfo,
    IN  PWSTR                              pServerName,
    IN  USHORT                             ServerNameLength,
    IN  PWSTR                              pProxyName,
    IN  USHORT                             ProxyNameLength,
    IN  PTRANSPORT_ADDRESS                 pTransportAddress,
    IN  USHORT                             TransportAddressLength,
    IN  KPROCESSOR_MODE                    RequestorMode
    )
{
    ULONG                          HashCode;
    PUC_PROCESS_SERVER_INFORMATION pInfo;
    BOOLEAN                        bSecure;
    LONG                           i;
    PWCHAR                         pServerNameStart, pServerNameEnd;
    PWCHAR                         pUriEnd;
    NTSTATUS                       Status = STATUS_SUCCESS;
    PTA_ADDRESS                    CurrentAddress;

    pInfo             = NULL;
    bSecure           = FALSE;
    pServerNameStart  = NULL;

    __try
    {
        //
        // Probe parameters since they come from user mode.
        //
        
        UlProbeWideString(
                pServerName, 
                ServerNameLength,
                RequestorMode
                );

        if(ProxyNameLength)
        {
            UlProbeWideString(
                    pProxyName,
                    ProxyNameLength,
                    RequestorMode
                    );
        }

        UlProbeForRead(
                pTransportAddress,
                TransportAddressLength,
                sizeof(PVOID),
                RequestorMode
                );

        //
        // Process the scheme name. We need at least one character after the
        // http:// or https://, so the comparision is > instead of >=
        //
        
        if(ServerNameLength > HTTP_PREFIX_LENGTH)
        {
            if (_wcsnicmp(pServerName,
                          HTTP_PREFIX_W,
                          HTTP_PREFIX_LENGTH/sizeof(WCHAR)) == 0)
            {
                pServerNameStart = pServerName +
                                        (HTTP_PREFIX_LENGTH/sizeof(WCHAR));
            }
            else if(ServerNameLength > HTTPS_PREFIX_LENGTH)
            {
                if (_wcsnicmp(pServerName,
                              HTTPS_PREFIX_W,
                              HTTPS_PREFIX_LENGTH/sizeof(WCHAR)) == 0)
                {
                    pServerNameStart = pServerName +
                                            (HTTPS_PREFIX_LENGTH/sizeof(WCHAR));

                    bSecure = TRUE;
                }
                else
                {
                    // neither http:// nor https://
                    ExRaiseStatus(STATUS_INVALID_PARAMETER);
                }
            }
            else
            {
                // Not enough space to compare https://
                ExRaiseStatus(STATUS_INVALID_PARAMETER);
            }
        }
        else
        {
            // Not enough space to compare http://
            ExRaiseStatus(STATUS_INVALID_PARAMETER);
        }

        ASSERT(pServerNameStart != NULL);

        pUriEnd = pServerName + (ServerNameLength/sizeof(WCHAR));

        ASSERT(pServerNameStart != pUriEnd);

        pServerNameEnd = pServerNameStart;
        HashCode       = 0;
        while(*pServerNameEnd != L'/')
        {
            HashCode = HTTP_HASH_CHAR(HashCode, *pServerNameEnd);
            pServerNameEnd ++;
            if(pServerNameEnd == pUriEnd)
            {
                break;
            }
        }

        //
        // Check for a zero server name
        // 

        if(pServerNameStart == pServerNameEnd)
        {
            // app passsed http:/// or https:///
            ExRaiseStatus(STATUS_INVALID_PARAMETER);
        }

        // Get a server info from our lookaside cache. If we can't, fail.

        pInfo = (PUC_PROCESS_SERVER_INFORMATION)
                    ExAllocateFromNPagedLookasideList(
                            &g_ClientServerInformationLookaside
                            );

        if (pInfo == NULL)
        {
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        }

        //
        // Got an entry, now initialize it.
        //

        pInfo->RefCount  = 0;
        pInfo->Signature = UC_PROCESS_SERVER_INFORMATION_SIGNATURE;

        for (i = 0; i < DEFAULT_MAX_CONNECTION_COUNT; i++)
        {
            pInfo->ConnectionArray[i] = NULL;
        }

        pInfo->Connections            = pInfo->ConnectionArray;
        pInfo->ActualConnectionCount  = DIMENSION(pInfo->ConnectionArray);
        pInfo->NextConnection         = 0;
        pInfo->CurrentConnectionCount = 0;
        pInfo->MaxConnectionCount     = DIMENSION(pInfo->ConnectionArray);
        pInfo->ConnectionTimeout      = 0;

        UlInitializePushLock(
                &pInfo->PushLock, 
                "Server Information spinlock",
                pInfo,
                UC_SERVINFO_PUSHLOCK_TAG
                );

        InitializeListHead(&pInfo->pAuthListHead);
        InitializeListHead(&pInfo->Linkage);

        pInfo->PreAuthEnable               = FALSE;
        pInfo->GreatestAuthHeaderMaxLength = 0;

        pInfo->ProxyPreAuthEnable = FALSE;
        pInfo->pProxyAuthInfo     = 0;
        pInfo->bSecure            = bSecure;
        pInfo->bProxy             = (BOOLEAN)(ProxyNameLength != 0);
        pInfo->IgnoreContinues    = TRUE;

        pInfo->pTransportAddress      = NULL;
        pInfo->TransportAddressLength = 0;

        //
        // Ssl related stuff
        //

        // Protocol version
        pInfo->SslProtocolVersion = 0;

        // Server cert stuff
        pInfo->ServerCertValidation = HttpSslServerCertValidationAutomatic;
        pInfo->ServerCertInfoState  = HttpSslServerCertInfoStateNotPresent;
        RtlZeroMemory(&pInfo->ServerCertInfo, 
                      sizeof(HTTP_SSL_SERVER_CERT_INFO));

        // Client Cert
        pInfo->pClientCert = NULL;

        //
        // Set this to the current process, we will use this field to charge
        // allocation quotas for the driver.
        //
        pInfo->pProcess = IoGetCurrentProcess();

        pInfo->pServerInfo  = NULL;
        pInfo->pNextHopInfo = NULL;

        //
        // Do a lookup based on the server name
        //
        Status = UcpLookupCommonServerInformation(
                        pServerNameStart,
                        (USHORT)
                           (pServerNameEnd - pServerNameStart) * sizeof(WCHAR),
                        HashCode,
                        pInfo->pProcess,
                        &pInfo->pServerInfo
                        );

        if(!NT_SUCCESS(Status))
        {
            ExRaiseStatus(Status);
        }


        // If a proxy is present, the next hop is the proxy, else it's the 
        // origin server. Except when we are doing SSL over proxies -- When 
        // doing SSL, the next hop is always the origin server, because the 
        // proxy is a tunnel. 
 
        // This introduces one wierdness with the CONNECT verb - because the 
        // CONNECT is sent to the proxy. But, in this case, the version of the 
        // next hop does not matter. We are using the version to either 
        // pipeline or do chunked sends & none of these affect the CONNECT 
        // verb request.
       
        if(ProxyNameLength && !bSecure)
        {
            PWCHAR pProxyNameStart, pProxyNameEnd;

            pProxyNameStart = pProxyName;
            pProxyNameEnd   = pProxyName + ProxyNameLength/sizeof(WCHAR);
            HashCode        = 0;

            //
            // Compute the hash code for the proxy.
            //
           
            while(pProxyNameStart != pProxyNameEnd)
            {
                HashCode = HTTP_HASH_CHAR(HashCode, *pProxyNameStart);
                pProxyNameStart ++;
            }

            Status = UcpLookupCommonServerInformation(
                            pProxyName,
                            ProxyNameLength,
                            HashCode,
                            pInfo->pProcess,
                            &pInfo->pNextHopInfo
                            );

            if(!NT_SUCCESS(Status))
            {
                ExRaiseStatus(Status);
            }
        }
        else
        {
            // Next hop is the same as the server. We'll just set the pointer
            // and take a reference.
            //
            REFERENCE_COMMON_SERVER_INFORMATION(pInfo->pServerInfo);
            pInfo->pNextHopInfo = pInfo->pServerInfo;
        }

        //
        // Make a local copy of Transport Address & point to it.
        // 
        
        if(TransportAddressLength <= sizeof(pInfo->RemoteAddress))
        {
            pInfo->pTransportAddress = 
                &pInfo->RemoteAddress.GenericTransportAddress;
        }
        else
        {
            pInfo->pTransportAddress = 
                UL_ALLOCATE_POOL_WITH_QUOTA(
                    NonPagedPool,
                    TransportAddressLength,
                    UC_TRANSPORT_ADDRESS_POOL_TAG,
                    pInfo->pProcess
                    );

            if(NULL == pInfo->pTransportAddress)
            {
                ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
            }
        }

        pInfo->TransportAddressLength = TransportAddressLength;
                
        RtlCopyMemory(pInfo->pTransportAddress,
                      pTransportAddress,
                      TransportAddressLength
                      );

        pTransportAddress = pInfo->pTransportAddress;

        //
        // Fail if we don't have space to read a TRANSPORT_ADDRESS or if there
        // are 0 addresses.
        //
        if((TransportAddressLength < 
                    FIELD_OFFSET(TRANSPORT_ADDRESS, Address)) ||
           pTransportAddress->TAAddressCount == 0)
        {
            ExRaiseStatus(STATUS_INVALID_PARAMETER);
        }

        CurrentAddress = (PTA_ADDRESS) pTransportAddress->Address;
        TransportAddressLength -= FIELD_OFFSET(TRANSPORT_ADDRESS, Address);

        for(i=0; i<pTransportAddress->TAAddressCount; i ++)
        {
            if(TransportAddressLength < FIELD_OFFSET(TA_ADDRESS, Address))
            {
                ExRaiseStatus(STATUS_ACCESS_VIOLATION);
            }
            TransportAddressLength = 
                TransportAddressLength - FIELD_OFFSET(TA_ADDRESS, Address);

            if(TransportAddressLength < CurrentAddress->AddressLength)
            {
                ExRaiseStatus(STATUS_ACCESS_VIOLATION);
            }

            TransportAddressLength = 
                TransportAddressLength - CurrentAddress->AddressLength;

            switch(CurrentAddress->AddressType)
            {
                case TDI_ADDRESS_TYPE_IP:
                    if(CurrentAddress->AddressLength != TDI_ADDRESS_LENGTH_IP)
                    {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }
                    break;

                case TDI_ADDRESS_TYPE_IP6:
                    if(CurrentAddress->AddressLength != TDI_ADDRESS_LENGTH_IP6)
                    {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }
                    break;
  
                default:
                    ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    break;
            }

            CurrentAddress = (PTA_ADDRESS)
                                 (CurrentAddress->Address +
                                  CurrentAddress->AddressLength);
        }

        if(TransportAddressLength != 0)
        {
            ExRaiseStatus(STATUS_ACCESS_VIOLATION);
        }

        //
        // Insert the ServInfo in a global list.
        //
        UlAcquireResourceExclusive(&g_ServInfoListResource, TRUE);

        InsertTailList(&g_ServInfoList, &pInfo->Linkage);

        //
        // Reference the server information structure for our caller.
        //

        REFERENCE_SERVER_INFORMATION(pInfo);

        UlReleaseResource(&g_ServInfoListResource);

        UlTrace(SERVINFO,
                ("[UcFindServerInformation: Creating PROCESS ServInfo 0x%x "
                 "for %ws\n", pInfo, pInfo->pServerInfo->pServerName));

        *pServerInfo = pInfo;

        // 
        // Page in all of the client code. In Win2K this is API is not very 
        // efficient. So, if we ever back port to Win2K we'd have to add our
        // own ref-counts so that we do it for the first Create only
        //
        MmLockPagableSectionByHandle(g_ClientImageHandle);

        Status = STATUS_SUCCESS;

    } __except( UL_EXCEPTION_FILTER())
    {
        Status = GetExceptionCode();

        if(pInfo)
        {
            UcpFreeServerInformation(pInfo);
        }
    }

    return Status;
}

/***************************************************************************++

    Routine Description:

    Reference a server information structure.

Arguments:

    pServerInfo         - Pointer to the server info structure to be referenced.


Return Value:

--***************************************************************************/
__inline
VOID
UcReferenceServerInformation(
    PUC_PROCESS_SERVER_INFORMATION    pServerInfo
    )
{
    LONG        RefCount;

    ASSERT( IS_VALID_SERVER_INFORMATION(pServerInfo) );

    RefCount = InterlockedIncrement((PLONG)&pServerInfo->RefCount);

    ASSERT( RefCount > 0 );
}

/***************************************************************************++

Routine Description:

    Dereference a server information structure. If the reference count goes
    to 0, we'll free the structure.

Arguments:

    pServerInfo         - Pointer to the server info structure to be
                            dereferenced.


Return Value:

--***************************************************************************/
__inline
VOID
UcDereferenceServerInformation(
    PUC_PROCESS_SERVER_INFORMATION     pServerInfo
    )
{
    LONG        RefCount;

    ASSERT( IS_VALID_SERVER_INFORMATION(pServerInfo) );

    RefCount = InterlockedDecrement(&pServerInfo->RefCount);

    ASSERT(RefCount >= 0);

    if (RefCount == 0)
    {
        UcpFreeServerInformation(pServerInfo);
    }
}


/***************************************************************************++

Routine Description:

    Get a particular connection on this server information
    If a connection is not already present, it adds a new connection.

Arguments:

    pServerInfo         - Pointer to the server info structure
    ConnectionIndex     - Which connection?
    ppConnection        - Returned pointer to connection

Return Value:

    STATUS_SUCCESS
    STATUS_INVALID_PARAMETER

--***************************************************************************/
NTSTATUS
UcpGetConnectionOnServInfo(
    IN  PUC_PROCESS_SERVER_INFORMATION pServInfo,
    IN  ULONG                          ConnectionIndex,
    OUT PUC_CLIENT_CONNECTION         *ppConnection
    )
{
    NTSTATUS              Status;
    PUC_CLIENT_CONNECTION pConnection;
    BOOLEAN               bReuseConnection;

    // Sanity check
    ASSERT(IS_VALID_SERVER_INFORMATION(pServInfo));
    ASSERT(ConnectionIndex != HTTP_REQUEST_ON_CONNECTION_ANY);

    // Initialize the locals & output
    *ppConnection = NULL;
    pConnection = NULL;
    bReuseConnection = FALSE;

    // Don't disturb please!
    UlAcquirePushLockExclusive(&pServInfo->PushLock);

    // Is the connection index valid?
    if (ConnectionIndex >= pServInfo->MaxConnectionCount)
    {
        // Nope. Bail out with an error.
        Status = STATUS_INVALID_PARAMETER;
        goto Release_Quit;
    }

    // Is there a connection present?
    if (pServInfo->Connections[ConnectionIndex] == NULL)
    {
        // Get a new connection
        Status = UcOpenClientConnection(pServInfo, &pConnection);

        // Bail out if we couldn't get a new connection
        if (!NT_SUCCESS(Status))
        {
            goto Release_Quit;
        }

        // OK to add this connection

        // Reference the client connection twice, once for the
        // server information linkage itself and once for the
        // pointer we're returning.
        //
        // UcOpenClientConnection returns with a ref.


        // Save the back pointer to the server information. We don't
        // explicitly reference the server information here, that would
        // create a circular reference problem. This back pointer is only
        // valid while there are requests queued on the connection. See
        // the comments about this field in clientconn.h for details.

        ADD_CONNECTION_TO_SERV_INFO(pServInfo, pConnection,
                                    ConnectionIndex);

    }

    *ppConnection = pServInfo->Connections[ConnectionIndex];

    REFERENCE_CLIENT_CONNECTION(*ppConnection);

    Status = STATUS_SUCCESS;

 Release_Quit:
    UlReleasePushLock(&pServInfo->PushLock);

    return Status;
}


/***************************************************************************++

Routine Description:

    Get the next connection on this server information (in round-robin fashion)

Arguments:

    pServerInfo         - Pointer to the server info structure
    ppConnection        - Returned pointer to connection

Return Value:

    STATUS_SUCCESS
    STATUS_INVALID_PARAMETER

--***************************************************************************/
NTSTATUS
UcpGetNextConnectionOnServInfo(
    IN  PUC_PROCESS_SERVER_INFORMATION pServInfo,
    OUT PUC_CLIENT_CONNECTION         *ppConnection
    )
{
    NTSTATUS              Status;
    PUC_CLIENT_CONNECTION pConnection;

    // Sanity check
    ASSERT(IS_VALID_SERVER_INFORMATION(pServInfo));

    // Initialize the locals & output
    *ppConnection = NULL;
    pConnection = NULL;

    UlAcquirePushLockExclusive(&pServInfo->PushLock);

    // See if we can add a new connection
    if (pServInfo->CurrentConnectionCount < pServInfo->MaxConnectionCount)
    {
        ULONG i, j;

        // Get a new connection
        Status = UcOpenClientConnection(pServInfo, &pConnection);

        // Bail out if we couldn't get a new connection
        if (!NT_SUCCESS(Status))
        {
            goto Quit;
        }

        // Update output
        *ppConnection = pConnection;
        REFERENCE_CLIENT_CONNECTION(pConnection);

        // Put this connection in the connections array
        // Start seaching form the NextConnection as it is most likely
        // empty.
        ASSERT(pServInfo->NextConnection < pServInfo->MaxConnectionCount);

        i = pServInfo->NextConnection;
        j = pServInfo->MaxConnectionCount;

        while(j)
        {
            if (pServInfo->Connections[i] == NULL)
            {
                ADD_CONNECTION_TO_SERV_INFO(pServInfo, pConnection, i);
                pConnection = NULL;
                break;
            }

            i = (i + 1) % pServInfo->MaxConnectionCount;
            j--;
        }

        // Update NextConnection
        pServInfo->NextConnection = (i+1) % pServInfo->MaxConnectionCount;

        ASSERT(pConnection == NULL);
    }
    else
    {
        ASSERT(pServInfo->NextConnection < pServInfo->MaxConnectionCount);
        *ppConnection = pServInfo->Connections[pServInfo->NextConnection];
        pServInfo->NextConnection = (pServInfo->NextConnection + 1) %
                                    pServInfo->MaxConnectionCount;

        REFERENCE_CLIENT_CONNECTION(*ppConnection);

        Status = STATUS_SUCCESS;
    }

 Quit:
    UlReleasePushLock(&pServInfo->PushLock);

    return Status;
}


/***************************************************************************++

Routine Description:

    Send a request to a remote server. We take a server information
    structure and a request, then we find a connection for that request and
    assign the request to it. We then start the request processing going.

Arguments:

    pServerInfo         - Pointer to the server info structure
    pRequest            - Pointer to the request to be sent.

Return Value:

    NTSTATUS - Status of attempt to send request.

--***************************************************************************/
NTSTATUS
UcSendRequest(
    PUC_PROCESS_SERVER_INFORMATION    pServerInfo,
    PUC_HTTP_REQUEST                  pRequest
    )
{

    KIRQL                   OldIRQL;
    PUC_CLIENT_CONNECTION   pConnection;
    NTSTATUS                Status;


    ASSERT( IS_VALID_SERVER_INFORMATION(pServerInfo) );

    if (pRequest->ConnectionIndex == HTTP_REQUEST_ON_CONNECTION_ANY)
    {
        Status = UcpGetNextConnectionOnServInfo(pServerInfo, &pConnection);
    }
    else
    {
        Status = UcpGetConnectionOnServInfo(pServerInfo,
                                            pRequest->ConnectionIndex,
                                            &pConnection);
    }

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    //
    // At this point we have a valid client connection. Send the request on it.
    // Get the spin lock, queue the request, and check the state of the
    // connection.
    //

    pRequest->RequestIRP->Tail.Overlay.DriverContext[0] = NULL;

    pRequest->pConnection = pConnection;

    // Reference the connection for this request. This reference will be removed
    // when the request is off all of our lists, either due to a cancel or a
    // completion.

    REFERENCE_CLIENT_CONNECTION(pConnection);

    UlAcquireSpinLock(&pConnection->SpinLock, &OldIRQL);

    InsertTailList(&pConnection->PendingRequestList, &pRequest->Linkage);

    if(pRequest->RequestFlags.CompleteIrpEarly)
    {
        UC_WRITE_TRACE_LOG(
            g_pUcTraceLog,
            UC_ACTION_REQUEST_COMPLETE_EARLY,
            pConnection,
            pRequest,
            pRequest->RequestIRP,
            0
            );

        ASSERT(pRequest->RequestFlags.RequestBuffered);

        //
        // NULL the request IRP so that it does not get completed
        // twice.
        //

        pRequest->RequestIRP = 0;

        UlReleaseSpinLock(&pConnection->SpinLock, OldIRQL);

        DEREFERENCE_CLIENT_CONNECTION(pConnection);

        return STATUS_SUCCESS;
    }
    else if(pRequest->RequestFlags.RequestBuffered)
    {
        BOOLEAN RequestCancelled;

        //
        // We can't send now, so leave it queued. Since we're leaving this
        // request queued set it up for cancelling now.
        //

        IoMarkIrpPending(pRequest->RequestIRP);

        RequestCancelled = UcSetRequestCancelRoutine(
                            pRequest,
                            UcpCancelPendingRequest
                            );


        if (RequestCancelled)
        {
            UC_WRITE_TRACE_LOG(
                g_pUcTraceLog,
                UC_ACTION_REQUEST_CANCELLED,
                pConnection,
                pRequest,
                pRequest->RequestIRP,
                UlongToPtr((ULONG)STATUS_CANCELLED)
                );


            pRequest->RequestIRP = NULL;

            //
            // Make sure that any new API calls for this request ID are failed.
            //

            UcSetFlag(&pRequest->RequestFlags.Value,
                      UcMakeRequestCancelledFlag());
        }

        UC_WRITE_TRACE_LOG(
            g_pUcTraceLog,
            UC_ACTION_REQUEST_QUEUED,
            pConnection,
            pRequest,
            pRequest->RequestIRP,
            UlongToPtr((ULONG)STATUS_PENDING)
            );

        Status = STATUS_PENDING;

        UlReleaseSpinLock(&pConnection->SpinLock, OldIRQL);
    }
    else
    {
        Status = UcSendRequestOnConnection(pConnection, pRequest, OldIRQL);
    }

    DEREFERENCE_CLIENT_CONNECTION(pConnection);

    return Status;
}




/***************************************************************************++

Routine Description:

    Free a server information structure. The server information structure
    must be at zero references.

Arguments:

    pInfo - Pointer to the server information structure to be freed.

Return Value:


--***************************************************************************/
VOID
UcpFreeServerInformation(
    PUC_PROCESS_SERVER_INFORMATION    pInfo
    )
{
    PUC_CLIENT_CONNECTION     pConn;
    KIRQL                     OldIrql;
    KEVENT                    ConnectionCleanupEvent;
    ULONG                     i;

    ASSERT( IS_VALID_SERVER_INFORMATION(pInfo) );

    PAGED_CODE();

    UlAcquireResourceExclusive(&g_ServInfoListResource, TRUE);

    RemoveEntryList(&pInfo->Linkage);

    UlReleaseResource(&g_ServInfoListResource);

    ASSERT(pInfo->RefCount == 0);

    KeInitializeEvent(&ConnectionCleanupEvent, SynchronizationEvent, FALSE);

    // Now walk through the connections on this structure and dereference
    // them.


    for (i = 0; i < pInfo->MaxConnectionCount; i++)
    {
        if ((pConn = pInfo->Connections[i]) == NULL)
            continue;

        ASSERT( UC_IS_VALID_CLIENT_CONNECTION(pConn) );

        UlAcquireSpinLock(&pConn->SpinLock, &OldIrql);

        ASSERT(pConn->pEvent == NULL);

        pConn->pEvent = &ConnectionCleanupEvent;

        UC_WRITE_TRACE_LOG(
            g_pUcTraceLog,
            UC_ACTION_SERVINFO_FREE,
            pConn,
            UlongToPtr(pConn->ConnectionState),
            UlongToPtr(pConn->ConnectionStatus),
            UlongToPtr(pConn->Flags)
            );

        switch(pConn->ConnectionState)
        {
            case UcConnectStateConnectCleanup:
            case UcConnectStateConnectCleanupBegin:

                // Cleanup has already begun, don't do it again.

                UlReleaseSpinLock(&pConn->SpinLock, OldIrql);

                break;

            case UcConnectStateConnectIdle:

                // Initiate a cleanup.

                pConn->ConnectionState  = UcConnectStateConnectCleanup;
                pConn->ConnectionStatus = STATUS_CANCELLED;

                UcKickOffConnectionStateMachine(
                    pConn, 
                    OldIrql, 
                    UcConnectionPassive
                    );
                break;

            case UcConnectStateConnectPending:

                // If its in UcConnectStateConnectPending, then we will clean
                // up when the connect completes.

                UlReleaseSpinLock(&pConn->SpinLock, OldIrql);

                break;

            default:

                UlReleaseSpinLock(&pConn->SpinLock, OldIrql);

                UC_CLOSE_CONNECTION(pConn, TRUE, STATUS_CANCELLED);

                break;
        }

        DEREFERENCE_CLIENT_CONNECTION(pConn);

        //
        // Wait for the ref on this client connection to go to 0
        //

        KeWaitForSingleObject(
            &ConnectionCleanupEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        UlTrace(SERVINFO,
                ("[UcpFreeServerInformation]: Done with Connection 0x%x \n",
                 pConn));
    }

    // Free Connections array if necessary
    if (pInfo->Connections != pInfo->ConnectionArray)
    {
        UL_FREE_POOL_WITH_QUOTA(pInfo->Connections,
                                UC_PROCESS_SERVER_CONNECTION_POOL_TAG,
                                NonPagedPool,
                                pInfo->ActualConnectionCount * 
                                    sizeof(PUC_CLIENT_CONNECTION),
                                pInfo->pProcess);

        pInfo->Connections = NULL;
    }

    if(pInfo->pTransportAddress && 
       (pInfo->pTransportAddress != 
            &pInfo->RemoteAddress.GenericTransportAddress))
    {
        UL_FREE_POOL_WITH_QUOTA(
                pInfo->pTransportAddress,
                UC_TRANSPORT_ADDRESS_POOL_TAG,
                NonPagedPool,
                pInfo->TransportAddressLength,
                pInfo->pProcess
                );
    }

    //
    // Flush the pre-auth cache for this servinfo.
    //

    UcDeleteAllURIEntries(pInfo);


    if(pInfo->pProxyAuthInfo != NULL)
    {
        UcDestroyInternalAuth(pInfo->pProxyAuthInfo,
                              pInfo->pProcess);
        pInfo->pProxyAuthInfo = 0;
    }

    UC_FREE_SERIALIZED_CERT(&pInfo->ServerCertInfo, pInfo->pProcess);
    UC_FREE_CERT_ISSUER_LIST(&pInfo->ServerCertInfo, pInfo->pProcess);

    UlTrace(SERVINFO,
            ("[UcpFreeServerInformation]: Freeing PROCESS Servinfo 0x%x "
             " for URI %ws \n", pInfo, pInfo->pServerInfo->pServerName));

    if(pInfo->pServerInfo)
    {
        DEREFERENCE_COMMON_SERVER_INFORMATION(pInfo->pServerInfo);
    }

    if(pInfo->pNextHopInfo)
    {
        DEREFERENCE_COMMON_SERVER_INFORMATION(pInfo->pNextHopInfo);
    }

    //
    // Terminate the push lock
    //
    UlDeletePushLock(&pInfo->PushLock);

    ExFreeToNPagedLookasideList(&g_ClientServerInformationLookaside, pInfo);
}


/***************************************************************************++

Routine Description:

    A utility routine to close the servinfo structure. This is called from
    the CLOSE IRP (i.e when a process is dying)

Arguments:

    pServInfo       - Pointer to the server information

Return Value:


--***************************************************************************/
VOID
UcCloseServerInformation(
    IN PUC_PROCESS_SERVER_INFORMATION pServInfo
    )
{
    DEREFERENCE_SERVER_INFORMATION(pServInfo);

    MmUnlockPagableImageSection(g_ClientImageHandle);
}

/***************************************************************************++

Routine Description:

    Lookup a server information structure in the server info table. If we
    don't find one return NULL.

Arguments:

    pServerName         - Pointer to unicode server name
    HashCode            - Hashcode for the server name. May need to be trimmed
                            as appropriate for the table size.
    ServerNameLength    - Length (in chars) of server name string.
    ProcessID           - ID of the process we're trying to find.
    pVersion            - Receives the Version valus of the header entry.


Return Value:

    A pointer to a server info if we find one, or NULL if not.

--***************************************************************************/
NTSTATUS
UcpLookupCommonServerInformation(
    IN  PWSTR                          pServerName,
    IN  USHORT                         ServerNameLength,
    IN  ULONG                          CommonHashCode,
    IN  PEPROCESS                      pProcess,
    OUT PUC_COMMON_SERVER_INFORMATION *pCommonInfo
    )
{
    PUC_COMMON_SERVER_INFORMATION   pInfo = NULL;
    PUC_SERVER_INFO_TABLE_HEADER    pHeader;
    PLIST_ENTRY                     pListHead, pCurrent;
    LONG                            i;
    BOOLEAN                         bAllocated = FALSE;
    NTSTATUS                        Status = STATUS_SUCCESS;

    *pCommonInfo = NULL;

    // Trim the HashCode.

    CommonHashCode %= g_CommonSIHashTableSize;

    pHeader = &g_UcCommonServerInfoTable[CommonHashCode];

    //
    // The common server information will not be created that often, so it's
    // OK for this to be an exclusive lock. We will change it later if required
    //
    // If we change this to use a shared lock during the search, then we have
    // to do the same "Version" trick that we do with the per-process server
    // information - After we acquire the exclusive lock we need to check if
    // another thread has come an inserted the same entry
    //

    UlAcquireResourceExclusive(&pHeader->Resource, TRUE);

    pListHead = &pHeader->List;
    pCurrent = pListHead->Flink;

    //
    // Since we are going to touch user mode pointers, we better be in 
    // _try _except
    //

    __try
    {
        // Walk through the list of server information structures on this list.
        // For each structure, make sure that the name of the server is the same
        // length as the input server name, and if it is compare the two names.
        //

        while (pCurrent != pListHead)
        {
            // Retrieve the server information from the list entry.

            pInfo = CONTAINING_RECORD(
                        pCurrent,
                        UC_COMMON_SERVER_INFORMATION,
                        Linkage
                        );

            ASSERT( IS_VALID_COMMON_SERVER_INFORMATION(pInfo) );

            // See if they're the same length

            if (pInfo->pProcess == pProcess && 
                pInfo->ServerNameLength == ServerNameLength)
            {
                if(_wcsnicmp(pInfo->pServerName,
                             pServerName,
                             ServerNameLength/sizeof(WCHAR)) == 0)
                {
                    break;
                }
            }

            pCurrent = pInfo->Linkage.Flink;
        }


        if (pCurrent != pListHead)
        {
            //
            // Take a ref for the caller.
            //

            ASSERT(NULL != pInfo);

            UlTrace(SERVINFO,
                    ("[UcpLookupCommonServerInformation]: Found COMMON servinfo"
                     " 0x%x for %ws (HTTP Version %d) \n",
                    pInfo, pInfo->pServerName, pInfo->Version11));

            REFERENCE_COMMON_SERVER_INFORMATION(pInfo);
        }
        else
        {
            //
            // Let's create a new one.
            //
           
            bAllocated = TRUE;

            pInfo = (PUC_COMMON_SERVER_INFORMATION)
                        ExAllocateFromNPagedLookasideList(
                                       &g_CommonServerInformationLookaside
                                       );

            if (pInfo == NULL)
            {
                ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
            }

            // Got an entry, now initialize it. 
            //

            pInfo->RefCount            = 1;
            pInfo->Signature           = UC_COMMON_SERVER_INFORMATION_SIGNATURE;

            pInfo->Version11            = 0;
            pInfo->pHeader              = pHeader;
            pInfo->ServerNameLength     = ServerNameLength;
            pInfo->AnsiServerNameLength = ServerNameLength/sizeof(WCHAR);
            pInfo->bPortNumber          = 0;
            pInfo->pProcess             = pProcess;

            //
            // Go ahead and insert it, if there is a failure from now onwards,
            // we'll call Deref.
            //

            InsertTailList(&pHeader->List, &pInfo->Linkage);

            if ((ServerNameLength+sizeof(WCHAR)) <= SERVER_NAME_BUFFER_SIZE)
            {
                pInfo->pServerName     = pInfo->ServerNameBuffer;
                pInfo->pAnsiServerName = pInfo->AnsiServerNameBuffer;
            }
            else
            {
                pInfo->pServerName     = NULL;
                pInfo->pAnsiServerName = NULL;

                // The server name is too big, need to allocate a buffer. 

                pInfo->pServerName = 
                    (PWSTR) UL_ALLOCATE_POOL_WITH_QUOTA(
                                        NonPagedPool,
                                        (ServerNameLength+sizeof(WCHAR)),
                                        SERVER_NAME_BUFFER_POOL_TAG,
                                        pProcess
                                        );

                if (pInfo->pServerName == NULL)
                {
                    ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
                }

                pInfo->pAnsiServerName = 
                    (PSTR) UL_ALLOCATE_POOL_WITH_QUOTA(
                                    NonPagedPool,
                                    pInfo->AnsiServerNameLength + 1,
                                    SERVER_NAME_BUFFER_POOL_TAG,
                                    pProcess
                                    );

                if(pInfo->pAnsiServerName == NULL)
                {
                    ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
                }
            }

            RtlCopyMemory(pInfo->pServerName,
                          pServerName,
                          ServerNameLength
                          );

            pInfo->pServerName[ServerNameLength/sizeof(WCHAR)] = L'\0';

            //
            // Convert the name to ANSI, we need this for generating the host
            // header.
            //

            HttpUnicodeToUTF8Encode(
               pInfo->pServerName,
               pInfo->ServerNameLength/sizeof(WCHAR),
               (PUCHAR)pInfo->pAnsiServerName,
               pInfo->AnsiServerNameLength,
               NULL,
               TRUE
               );

            pInfo->pAnsiServerName[pInfo->AnsiServerNameLength] = '\0';

            //
            // Determine if there is a port number present in the server name
            // To optimize, start from the end of the server name
            //              Any char except digit [0-9] and ':' means no port
            //              a ':' means a port number if followed by digits
            //

            for (i = (LONG)pInfo->AnsiServerNameLength - 1; i >= 0; i--)
            {
                if (pInfo->pAnsiServerName[i] == ':' &&
                    i != (LONG)pInfo->AnsiServerNameLength - 1)
                {
                    // Yes, there is a port number
                    pInfo->bPortNumber = 1;
                    break;
                }

                if (!isdigit(pInfo->pAnsiServerName[i]))
                {
                    // Non-digit chars means no port number
                    break;
                }
            }

            UlTrace(
                SERVINFO,
                ("[UcpLookupCommonServerInformation]: Created COMMON servinfo"
                " 0x%x for %ws \n", pInfo, pInfo->pServerName)
                );
        }
    } __except( UL_EXCEPTION_FILTER())
    {
        Status = GetExceptionCode();

        if(bAllocated && pInfo)
        {
            DEREFERENCE_COMMON_SERVER_INFORMATION(pInfo);
        }

        pInfo = NULL;
    }

    UlReleaseResource(&pHeader->Resource);
    *pCommonInfo = pInfo;
    return Status;
}

/***************************************************************************++

Routine Description:

    Free a server information structure. The server information structure
    must be at zero references.

Arguments:

    pInfo               - Pointer to the server information structure to be
                            freed.


Return Value:


--***************************************************************************/
VOID
UcpFreeCommonServerInformation(
    PUC_COMMON_SERVER_INFORMATION    pInfo
    )
{
    ASSERT( IS_VALID_COMMON_SERVER_INFORMATION(pInfo) );
    ASSERT(pInfo->RefCount == 0);

    UlTrace(SERVINFO,
            ("[UcpFreeServerInformation]: Freeing COMMON Servinfo 0x%x "
             " for URI %ws \n", pInfo, pInfo->pServerName));

    // If we've got a server name buffer allocated, free it first if
    // it's not NULL.

    if (pInfo->pServerName != pInfo->ServerNameBuffer)
    {
        if (pInfo->pServerName != NULL)
        {
            UL_FREE_POOL_WITH_QUOTA(
                pInfo->pServerName, 
                SERVER_NAME_BUFFER_POOL_TAG,
                NonPagedPool,
                pInfo->ServerNameLength + sizeof(WCHAR),
                pInfo->pProcess
                );
        }
    }

    if (pInfo->pAnsiServerName != pInfo->AnsiServerNameBuffer)
    {
        if (pInfo->pAnsiServerName != NULL)
        {
            UL_FREE_POOL_WITH_QUOTA(
                pInfo->pAnsiServerName, 
                SERVER_NAME_BUFFER_POOL_TAG,
                NonPagedPool,
                pInfo->AnsiServerNameLength + 1,
                pInfo->pProcess
                );
        }
    }

    UlAcquireResourceExclusive(&pInfo->pHeader->Resource, TRUE);

    RemoveEntryList(&pInfo->Linkage);

    UlReleaseResource(&pInfo->pHeader->Resource);

    ExFreeToNPagedLookasideList(&g_CommonServerInformationLookaside, pInfo);
}

/***************************************************************************++

Routine Description:

    Reference a server information structure.

Arguments:

    pServerInfo         - Pointer to the server info structure to be referenced.


Return Value:

--***************************************************************************/
__inline
VOID
UcReferenceCommonServerInformation(
    PUC_COMMON_SERVER_INFORMATION    pServerInfo
    )
{
    LONG        RefCount;

    ASSERT( IS_VALID_COMMON_SERVER_INFORMATION(pServerInfo) );

    RefCount = InterlockedIncrement(&pServerInfo->RefCount);

    ASSERT( RefCount > 0 );

}

/***************************************************************************++

Routine Description:

    Dereference a server information structure. If the reference count goes
    to 0, we'll free the structure.

Arguments:

    pServerInfo         - Pointer to the server info structure to be
                            dereferenced.


Return Value:

--***************************************************************************/
__inline
VOID
UcDereferenceCommonServerInformation(
    PUC_COMMON_SERVER_INFORMATION     pServerInfo
    )
{
    LONG        RefCount;

    ASSERT( IS_VALID_COMMON_SERVER_INFORMATION(pServerInfo) );

    RefCount = InterlockedDecrement(&pServerInfo->RefCount);

    ASSERT(RefCount >= 0);

    if (RefCount == 0)
    {
        UcpFreeCommonServerInformation(pServerInfo);
    }
}


/***************************************************************************++

Routine Description:

Arguments:

Return Value:

    Status

--***************************************************************************/
NTSTATUS
UcpSetServInfoMaxConnectionCount(
    IN PUC_PROCESS_SERVER_INFORMATION pServInfo,
    IN ULONG                          NewCount
    )
{
    UC_CLIENT_CONNECTION **ppConnection, **ppOldConnection;
    ULONG                  i, ActualCount, OldActualCount;
    NTSTATUS               Status;

    UlAcquirePushLockExclusive(&pServInfo->PushLock);

    // Reducing connection count?
    if (NewCount < pServInfo->MaxConnectionCount)
    {
        Status = STATUS_SUCCESS;

        if (pServInfo->CurrentConnectionCount > NewCount)
        {
            // We can't reduce connection below current connection count!
            Status = STATUS_INVALID_PARAMETER;
        }
        else
        {
            // See if we can reduce connections from higher indices.
            for (i = NewCount; i < pServInfo->MaxConnectionCount; i++)
                if (pServInfo->Connections[i] != NULL)
                    Status = STATUS_INVALID_PARAMETER;
        }

        if (Status == STATUS_SUCCESS)
        {
            InterlockedExchange((LONG *)&pServInfo->MaxConnectionCount,
                                (LONG)NewCount);

            if (pServInfo->NextConnection >= pServInfo->MaxConnectionCount)
            {
                pServInfo->NextConnection = 0;
            }
        }
    }
    else if (NewCount == pServInfo->MaxConnectionCount)
    {
        // Trivial case!
        Status = STATUS_SUCCESS;
    }
    else if (NewCount <= pServInfo->ActualConnectionCount)
    {
        // We already have space for the additional connections, just use it!
#if DBG
        for (i = pServInfo->MaxConnectionCount;
             i < pServInfo->ActualConnectionCount;
             i++)
        {
            ASSERT(pServInfo->Connections[i] == NULL);
        }
#endif

        InterlockedExchange((LONG *)&pServInfo->MaxConnectionCount,
                            (LONG)NewCount);

        Status = STATUS_SUCCESS;
    }
    else
    {
        ASSERT(NewCount > pServInfo->MaxConnectionCount);
        ASSERT(NewCount > pServInfo->ActualConnectionCount);

        ActualCount = NewCount;

        // allocate new Connection Array
        //
        // NOTE: sizeof(PUC_CLIENT_CONNECTION) is intentional because we are
        // allocating space for storing pointers & not the structure itself.
        //

        ppConnection = (UC_CLIENT_CONNECTION **)UL_ALLOCATE_POOL_WITH_QUOTA(
                           NonPagedPool,
                           ActualCount * sizeof(PUC_CLIENT_CONNECTION),
                           UC_PROCESS_SERVER_CONNECTION_POOL_TAG,
                           pServInfo->pProcess);

        if (ppConnection == NULL)
        {
             Status = STATUS_INSUFFICIENT_RESOURCES;
             goto Release_Quit;
        }

        // Copy the pointers
        for (i = 0; i < pServInfo->MaxConnectionCount; i++)
        {
            ppConnection[i] = pServInfo->Connections[i];
        }
        for (; i < ActualCount; i++)
        {
            ppConnection[i] = NULL;
        }

        // set new connection array
        ppOldConnection = pServInfo->Connections;
        pServInfo->Connections = ppConnection;

        // Set new max connection count
        InterlockedExchange((LONG *)&pServInfo->MaxConnectionCount,
                            (LONG)NewCount);

        // Set new actual connection count
        OldActualCount = pServInfo->ActualConnectionCount;
        pServInfo->ActualConnectionCount = ActualCount;

        // release spinlock
        UlReleasePushLock(&pServInfo->PushLock);

        // free memory if necessary
        if (ppOldConnection != pServInfo->ConnectionArray)
        {
            UL_FREE_POOL_WITH_QUOTA(
                ppOldConnection,
                UC_PROCESS_SERVER_CONNECTION_POOL_TAG,
                NonPagedPool,
                OldActualCount * sizeof(PUC_CLIENT_CONNECTION),
                pServInfo->pProcess
                );
        }

        Status = STATUS_SUCCESS;
        goto Quit;
    }

 Release_Quit:
    UlReleasePushLock(&pServInfo->PushLock);
 Quit:
    return Status;
}


/***************************************************************************++

Routine Description:

    This routine is called to set server config.  We will be calling this
    from the HttpSetServerConfig IOCTL.

    NOTE: This is a IN_DIRECT IOCTL.

Arguments:

    pServerInfo         - Pointer to the server info structure
    pConfigID           - The config object that is being set.
    pMdlBuffer          - InputBuffer
    BufferLength        - Length of Input Buffer

Return Value:

    Status

--***************************************************************************/
NTSTATUS
UcSetServerContextInformation(
    IN PUC_PROCESS_SERVER_INFORMATION pServInfo,
    IN HTTP_SERVER_CONFIG_ID          ConfigID,
    IN PVOID                          pInBuffer,
    IN ULONG                          InBufferLength,
    IN PIRP                           pIrp
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    LONG        Value;

    PAGED_CODE();

    __try 
    {
        // If the app has passed input buffers, make sure that it's 
        // readable.

        if(!InBufferLength)
        {
            UlProbeForRead(pInBuffer, 
                           InBufferLength, 
                           sizeof(ULONG),
                           pIrp->RequestorMode
                           );
        }

        switch(ConfigID)
        {
            case HttpServerConfigConnectionTimeout:
            {
                if(InBufferLength != sizeof(ULONG))
                {
                    return(STATUS_INVALID_PARAMETER);
                }

                pServInfo->ConnectionTimeout  = (*(ULONG *)pInBuffer);
    
                break;
            }
    
            case HttpServerConfigIgnoreContinueState:
            {
                ULONG bValue;
    
                if(InBufferLength != sizeof(ULONG))
                {
                    return STATUS_INVALID_PARAMETER;
                }
    
                bValue = (*(ULONG *)pInBuffer);
    
                if(bValue == 0 || bValue == 1)
                {
                    pServInfo->IgnoreContinues = bValue;
                }
                else
                {
                    Status = STATUS_INVALID_PARAMETER;
                }
    
                break;
    
            }
    
            case HttpServerConfigConnectionCount:
            {
                if(InBufferLength != sizeof(ULONG))
                {
                    return STATUS_INVALID_PARAMETER;
                }
    
                Value = (*(LONG *)pInBuffer);
    
                if(Value <= 0)
                {
                    Status = STATUS_INVALID_PARAMETER;
                }
                else
                {
                    Status = UcpSetServInfoMaxConnectionCount(pServInfo,
                                                              (ULONG)Value);
                }
    
                break;
            }
    
            case HttpServerConfigPreAuthState:
            {
                if(InBufferLength != sizeof(ULONG))
                {
                    return STATUS_INVALID_PARAMETER;
                }
    
                Value = (*(LONG *)pInBuffer);
                if(Value == 0 || Value == 1)
                {
                    pServInfo->PreAuthEnable = Value;
                }
                else
                {
                    Status = STATUS_INVALID_PARAMETER;
                }
    
                break;
            }
    
            case HttpServerConfigProxyPreAuthState:
            {
                if(InBufferLength != sizeof(ULONG))
                {
                    return STATUS_INVALID_PARAMETER;
                }
    
                Value = (*(LONG *)pInBuffer);
                if(Value == 0 || Value == 1)
                {
                    pServInfo->ProxyPreAuthEnable = Value;
                }
                else
                {
                    Status = STATUS_INVALID_PARAMETER;
                }
    
                break;
            }
    
            case HttpServerConfigProxyPreAuthFlushCache:
            {
                PUC_HTTP_AUTH pAuth;

                if(InBufferLength != 0)
                {
                    return STATUS_INVALID_PARAMETER;
                }
    
                UlTrace(AUTH_CACHE,
                        ("[UcSetServerContextInformation]: Flushing Proxy Auth "
                         "cache for %ws\n", 
                         pServInfo->pServerInfo->pServerName));
    
                UlAcquirePushLockExclusive(&pServInfo->PushLock);

                pAuth = pServInfo->pProxyAuthInfo;

                pServInfo->pProxyAuthInfo = NULL;

                UlReleasePushLock(&pServInfo->PushLock);
    
                if(pAuth)
                {
                    UcDestroyInternalAuth(pAuth, pServInfo->pProcess);
                }
    
                break;
            }
    
            case HttpServerConfigPreAuthFlushURICache:
            {
                if(InBufferLength != 0)
                {
                    return STATUS_INVALID_PARAMETER;
                }
    
                UlTrace(AUTH_CACHE,
                        ("[UcSetServerContextInformation]: Flushing Auth cache"
                         " for %ws \n", pServInfo->pServerInfo->pServerName));
    
                UcDeleteAllURIEntries(pServInfo);
                break;
            }
    
            case HttpServerConfigServerCertValidation:
            {
                ULONG Option;

                if(InBufferLength != sizeof(ULONG))
                {
                    return STATUS_INVALID_PARAMETER;
                }

                Option = *(ULONG *)pInBuffer;

                if (Option != HttpSslServerCertValidationIgnore     &&
                    Option != HttpSslServerCertValidationManual     &&
                    Option != HttpSslServerCertValidationManualOnce &&
                    Option != HttpSslServerCertValidationAutomatic)
                {
                    return STATUS_INVALID_PARAMETER;
                }
    
                InterlockedExchange((PLONG)&pServInfo->ServerCertValidation,
                                    Option);

                break;
            }

            case HttpServerConfigServerCertAccept:
            {
                ULONG                 i;
                PUC_CLIENT_CONNECTION pConnection;
                PUC_CLIENT_CONNECTION pCloseConn = NULL;
                ULONG                 Action;
                KIRQL                 NewIrql;


                // Input must be an ULONG.
                if (InBufferLength != sizeof(ULONG))
                {
                    return STATUS_INVALID_PARAMETER;
                }

                // Must be TRUE or FALSE
                Action = *(ULONG *)pInBuffer;
                if (Action != TRUE && Action != FALSE)
                {
                    return STATUS_INVALID_PARAMETER;
                }

                UlAcquirePushLockExclusive(&pServInfo->PushLock);

                if (pServInfo->ServerCertInfoState ==
                    HttpSslServerCertInfoStateNotValidated)
                {
                    //
                    // Server certificate was not validated.
                    //

                    Status = STATUS_SUCCESS;

                    if (Action == TRUE)
                    {
                        // The server cert was accepted.
                        pServInfo->ServerCertInfoState = 
                            HttpSslServerCertInfoStateValidated;
                    }
                    else
                    {
                        // The server cert was rejected.
                        pServInfo->ServerCertInfoState = 
                            HttpSslServerCertInfoStateNotPresent;
                    }

                    // For each connection...
                    for (i = 0; i < pServInfo->MaxConnectionCount; i++)
                    {
                        if ((pConnection = pServInfo->Connections[i]) == NULL)
                            continue;

                        ASSERT(UC_IS_VALID_CLIENT_CONNECTION(pConnection));

                        UlAcquireSpinLock(&pConnection->SpinLock, &NewIrql);

                        if (pConnection->ConnectionState ==
                            UcConnectStatePerformingSslHandshake)
                        {
                            if (pConnection->SslState == 
                                UcSslStateValidatingServerCert)
                            {
                                // The connection was waiting for server cert
                                // validation.
                                if (Action == TRUE)
                                {
                                    // Cert was accepted.  Proceed.
                                    pConnection->SslState =
                                        UcSslStateHandshakeComplete;

                                    pConnection->ConnectionState =
                                        UcConnectStateConnectReady;

                                    UcKickOffConnectionStateMachine(
                                                pConnection,
                                                NewIrql,
                                                UcConnectionWorkItem
                                                );
                                }
                                else
                                {
                                    ASSERT(NULL == pCloseConn);

                                    // Cert was rejected. Close the connection.
                                    pCloseConn = pConnection;

                                    UlReleaseSpinLock(&pConnection->SpinLock,
                                                      NewIrql);
                                }
                            }
                            else if (pConnection->SslState ==
                                     UcSslStateServerCertReceived)
                            {
                                // Waiting for server cert comparision.
                                UcKickOffConnectionStateMachine(
                                        pConnection,
                                        NewIrql,
                                        UcConnectionWorkItem
                                        );
                            }
                            else
                            {
                                UlReleaseSpinLock(&pConnection->SpinLock,
                                                  NewIrql);
                            }
                        }
                        else
                        {
                            UlReleaseSpinLock(&pConnection->SpinLock,
                                              NewIrql);
                        }
                    }
                }

                UlReleasePushLock(&pServInfo->PushLock);

                if (pCloseConn)
                {
                    UC_CLOSE_CONNECTION(pCloseConn, TRUE, STATUS_CANCELLED);
                }

                break;
            }

            case HttpServerConfigSslProtocolVersion:
            {
                if(InBufferLength != sizeof(ULONG))
                {
                    return STATUS_INVALID_PARAMETER;
                }
                else
                {
                    ULONG SslProtocolVersion = *(PULONG)pInBuffer;

                    InterlockedExchange((LONG *)&pServInfo->SslProtocolVersion,
                                        (LONG)SslProtocolVersion);

                    Status = STATUS_SUCCESS;
                }

                break;
            }

            case HttpServerConfigClientCert:
            {
                if(InBufferLength != sizeof(PVOID))
                {
                    return STATUS_INVALID_PARAMETER;
                }
                else
                {
                    PVOID pClientCert;

                    // Make sure pInBuffer is PVOID aligned.
                    UlProbeForRead(pInBuffer, 
                                   InBufferLength, 
                                   sizeof(PVOID),
                                   pIrp->RequestorMode);

                    pClientCert = *(PVOID *)pInBuffer;

                    InterlockedExchangePointer(&pServInfo->pClientCert,
                                               pClientCert);

                    Status = STATUS_SUCCESS;
                }

                break;
            }
    
            default:
                Status = STATUS_INVALID_PARAMETER;
                break;
        }

    } __except( UL_EXCEPTION_FILTER())
    {
        Status = GetExceptionCode();
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    This routine is called to query server config.

    NOTE: This is a OUT_DIRECT IOCTL.

Arguments:

    pServerInfo         - Pointer to the server info structure
    pConfigID           - The config object that is being set.
    pMdlBuffer          - OutputBuffer
    BufferLength        - Length of Output Buffer
    pBytesTaken         - Amount we have written

Return Value:

    Status

--***************************************************************************/
NTSTATUS
UcQueryServerContextInformation(
    IN  PUC_PROCESS_SERVER_INFORMATION   pServInfo,
    IN  HTTP_SERVER_CONFIG_ID            ConfigID,
    IN  PVOID                            pOutBuffer,
    IN  ULONG                            OutBufferLength,
    OUT PULONG                           pBytesTaken,
    IN  PVOID                            pAppBase
    )
{
    NTSTATUS Status = STATUS_SUCCESS;


    *pBytesTaken = 0;

    ASSERT(NULL != pOutBuffer);
    ASSERT(pOutBuffer == ALIGN_UP_POINTER(pOutBuffer, ULONG));

    //
    // NOTE: Since this is an OUT_DIRECT ioctl, we don't need to be in a 
    // _try _except block.
    //

    switch(ConfigID)
    {
        case HttpServerConfigConnectionTimeout:
        {
            PULONG Value = (PULONG)pOutBuffer;

            *pBytesTaken = sizeof(pServInfo->ConnectionTimeout);

            if(OutBufferLength < sizeof(pServInfo->ConnectionTimeout))
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            *Value = pServInfo->ConnectionTimeout;

            break;
        }

        case HttpServerConfigIgnoreContinueState:
        {
            PULONG Value = (PULONG)pOutBuffer;

            *pBytesTaken = sizeof(pServInfo->IgnoreContinues);

            if(OutBufferLength < sizeof(pServInfo->IgnoreContinues))
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            *Value =  pServInfo->IgnoreContinues;

            break;
        }

        case HttpServerConfigConnectionCount:
        {
            PLONG Value = (PLONG)pOutBuffer;

            *pBytesTaken = sizeof(pServInfo->MaxConnectionCount);

            if(OutBufferLength < sizeof(pServInfo->MaxConnectionCount))
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            *Value = pServInfo->MaxConnectionCount;

            break;
        }

        case HttpServerConfigPreAuthState:
        {
            PLONG Value = (PLONG)pOutBuffer;

            *pBytesTaken = sizeof(pServInfo->PreAuthEnable);

            if(OutBufferLength < sizeof(pServInfo->PreAuthEnable))
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            *Value = pServInfo->PreAuthEnable;

            break;
        }

        case HttpServerConfigProxyPreAuthState:
        {
            PLONG Value = (PLONG)pOutBuffer;

            *pBytesTaken = sizeof(pServInfo->ProxyPreAuthEnable);

            if(OutBufferLength < sizeof(pServInfo->ProxyPreAuthEnable))
            {
                return STATUS_BUFFER_TOO_SMALL;
            }

            *Value = pServInfo->ProxyPreAuthEnable;

            break;
        }

        case HttpServerConfigServerCert:
        {
            PHTTP_SSL_SERVER_CERT_INFO pCertInfo    = NULL;
            PHTTP_SSL_SERVER_CERT_INFO pOutCertInfo = NULL;
            PUCHAR                     ptr          = NULL;

            // Make sure pOutBuffer is PVOID aligned.
            if (pOutBuffer != ALIGN_UP_POINTER(pOutBuffer, PVOID))
            {
                return STATUS_DATATYPE_MISALIGNMENT_ERROR;
            }

            // by default, server cert is not present
            Status = STATUS_NOT_FOUND;

            UlAcquirePushLockExclusive(&pServInfo->PushLock);

            //
            // Server certificate there?
            //
            if(pServInfo->ServerCertInfoState !=
                   HttpSslServerCertInfoStateNotPresent)
            {
                pCertInfo = &pServInfo->ServerCertInfo;

                *pBytesTaken = sizeof(HTTP_SSL_SERVER_CERT_INFO) +
                               pCertInfo->Cert.SerializedCertLength +
                               pCertInfo->Cert.SerializedCertStoreLength;

                //
                // Can the output buffer hold the certificate?
                //
                if (OutBufferLength < *pBytesTaken)
                {
                    // Nope
                    Status = STATUS_BUFFER_TOO_SMALL;
                }
                else
                {
                    //
                    // Yeap...copy the certificate info
                    //
                    pOutCertInfo = (PHTTP_SSL_SERVER_CERT_INFO)pOutBuffer;

                    // First, copy SERVER_CERT_INFO structure
                    RtlCopyMemory(pOutCertInfo,
                                  pCertInfo,
                                  sizeof(HTTP_SSL_SERVER_CERT_INFO));

                    // Make space for serialized cert
                    ptr = (PUCHAR)(pOutCertInfo + 1);
                    pOutCertInfo->Cert.pSerializedCert = ptr;

                    // Copy serialized cert
                    RtlCopyMemory(ptr,
                                  pCertInfo->Cert.pSerializedCert,
                                  pCertInfo->Cert.SerializedCertLength);

                    // Make space for serialized cert store
                    ptr = ptr + pCertInfo->Cert.SerializedCertLength;
                    pOutCertInfo->Cert.pSerializedCertStore = ptr;


                    // Copy serialized cert store
                    RtlCopyMemory(ptr,
                                  pCertInfo->Cert.pSerializedCertStore,
                                  pCertInfo->Cert.SerializedCertStoreLength);

                    // Fix app's serialized cert pointer
                    pOutCertInfo->Cert.pSerializedCert = (PUCHAR)pAppBase +
                       (pOutCertInfo->Cert.pSerializedCert - 
                        (PUCHAR)pOutCertInfo);

                    // Fix app's serialized cert store pointer
                    pOutCertInfo->Cert.pSerializedCertStore =(PUCHAR)pAppBase +
                        (pOutCertInfo->Cert.pSerializedCertStore -
                         (PUCHAR)pOutCertInfo);

                    Status = STATUS_SUCCESS;
                }
            }

            UlReleasePushLock(&pServInfo->PushLock);

            break;
        }
    
        case HttpServerConfigServerCertValidation:
        {
            *pBytesTaken = sizeof(ULONG);

            if(OutBufferLength < sizeof(ULONG))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                // No locks needed!
                *(PULONG)pOutBuffer = pServInfo->ServerCertValidation;

                Status = STATUS_SUCCESS;
            }

            break;
        }

        case HttpServerConfigSslProtocolVersion:
        {
            *pBytesTaken = sizeof(ULONG);

            if(OutBufferLength < sizeof(ULONG))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                // No locks needed!
                *(PULONG)pOutBuffer = pServInfo->SslProtocolVersion;

                Status = STATUS_SUCCESS;
            }

            break;
        }

        case HttpServerConfigClientCert:
        {
            // Make sure pOutBuffer is PVOID aligned.
            if (pOutBuffer != ALIGN_UP_POINTER(pOutBuffer, PVOID))
            {
                return STATUS_DATATYPE_MISALIGNMENT_ERROR;
            }

            *pBytesTaken = sizeof(PVOID);

            if(OutBufferLength < sizeof(PVOID))
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                // No locks needed!
                *(PVOID *)pOutBuffer = pServInfo->pClientCert;

                Status = STATUS_SUCCESS;
            }

            break;
        }

        case HttpServerConfigClientCertIssuerList:
        {
            PHTTP_SSL_CERT_ISSUER_INFO pIssuerInfo;
            PUCHAR                     ptr;

            // Make sure pOutBuffer is PVOID aligned.
            if (pOutBuffer != ALIGN_UP_POINTER(pOutBuffer, PVOID))
            {
                return STATUS_DATATYPE_MISALIGNMENT_ERROR;
            }

            // By default, no issuer list is present.
            Status = STATUS_NOT_FOUND;

            UlAcquirePushLockExclusive(&pServInfo->PushLock);

            if (pServInfo->ServerCertInfo.IssuerInfo.IssuerListLength)
            {
                // Compute the bytes required for storing issuer list
                *pBytesTaken = sizeof(HTTP_SSL_CERT_ISSUER_INFO) +
                    pServInfo->ServerCertInfo.IssuerInfo.IssuerListLength;

                // By default, output buffer is small.
                Status = STATUS_BUFFER_TOO_SMALL;

                if (OutBufferLength >= *pBytesTaken)
                {
                    //
                    // Output buffer is big enough to hold issuer list.
                    //

                    pIssuerInfo = (PHTTP_SSL_CERT_ISSUER_INFO)pOutBuffer;

                    // First copy CERT_ISSUER_INFO structure
                    RtlCopyMemory(pIssuerInfo,
                                  &pServInfo->ServerCertInfo.IssuerInfo,
                                  sizeof(HTTP_SSL_CERT_ISSUER_INFO));

                    // Make space for Issuer List
                    ptr = (PUCHAR)(pIssuerInfo + 1);
                    pIssuerInfo->pIssuerList = (PUCHAR)pAppBase +
                                               (ptr - (PUCHAR)pOutBuffer);

                    // Copy the actual Issuer List
                    RtlCopyMemory(
                        ptr,
                        pServInfo->ServerCertInfo.IssuerInfo.pIssuerList,
                        pServInfo->ServerCertInfo.IssuerInfo.IssuerListLength);

                    // Fixup app's pointers.
                    Status = UcpFixupIssuerList(
                        ptr,
                        pServInfo->ServerCertInfo.IssuerInfo.pIssuerList,
                        pServInfo->ServerCertInfo.IssuerInfo.IssuerCount,
                        pServInfo->ServerCertInfo.IssuerInfo.IssuerListLength);

                    ASSERT(Status == STATUS_SUCCESS);
                }
            }

            UlReleasePushLock(&pServInfo->PushLock);
            break;
        }

        default:
            Status = STATUS_INVALID_PARAMETER;
            break;
    }

    return Status;
}


/****************************************************************************++

Routine Description:

    Determines whether to make an kernel mode copy of serialized certificate
    passed by the filter.  In general, we avoid copying as much as possible.

Arguments:

    pCertInfo - Kernel copy of Filter supplied server certificate info
    pServInfo - ServInfo that will eventually receive this pCertInfo

Return Value:

    TRUE - copy serialized certificate (Too bad!)
    FALSE - Don't copy the serialized certificate :-)

--****************************************************************************/
BOOLEAN
UcpNeedToCaptureSerializedCert(
    IN PHTTP_SSL_SERVER_CERT_INFO     pCertInfo,
    IN PUC_PROCESS_SERVER_INFORMATION pServInfo
    )
{
    BOOLEAN retval;


    // Sanity check
    ASSERT(pCertInfo);
    ASSERT(IS_VALID_SERVER_INFORMATION(pServInfo));

    // By default, copy serialized certificate
    retval = TRUE;

    UlAcquirePushLockExclusive(&pServInfo->PushLock);

    switch(pServInfo->ServerCertValidation)
    {
    case HttpSslServerCertValidationIgnore:
    case HttpSslServerCertValidationAutomatic:
        //
        // In ignore or automatic mode, only one copy of the server 
        // certificate is needed (in case the user wants to see it).
        // If one is already present, don't copy.  NotValidated, Validated
        // states indicate presence of server certificate.
        //
        if (pServInfo->ServerCertInfoState ==
                HttpSslServerCertInfoStateNotValidated ||
            pServInfo->ServerCertInfoState ==
                HttpSslServerCertInfoStateValidated)
        {
            retval = FALSE;
        }
        break;

    case HttpSslServerCertValidationManualOnce:
        //
        // If ManualOnce case, if the new cert is same as old one, 
        // skip copying.  Compare to see if they are same.
        //
        if (pServInfo->ServerCertInfoState == 
                HttpSslServerCertInfoStateValidated && 
            UC_COMPARE_CERT_HASH(&pServInfo->ServerCertInfo, pCertInfo))
        {
            retval = FALSE;
        }
        break;

    case HttpSslServerCertValidationManual:
        // Always copy.
        break;

    default:
        ASSERT(FALSE);
        break;
    }

    UlReleasePushLock(&pServInfo->PushLock);

    return TRUE;
}


/****************************************************************************++

Routine Description:

    Fixes the pointers present in the Issuer List returned by Schannel.

Arguments:

    IN OUT PUCHAR pIssuerList      - Kernel mode copy of Issuer List
    IN     PUCHAR BaseAddr         - User mode pointer to Issuer List
    IN     ULONG  IssuerCount      - Number of Issuers
    IN     ULONG  IssuerListLength - Total length of memory blob

Return Value:

    NTSTATUS

--****************************************************************************/
NTSTATUS
UcpFixupIssuerList(
    IN OUT PUCHAR pIssuerList,
    IN     PUCHAR BaseAddr,
    IN     ULONG  IssuerCount,
    IN     ULONG  IssuerListLength
    )
{
    NTSTATUS        Status;
    ULONG           i;
    PHTTP_DATA_BLOB pDataBlob;


    ASSERT(pIssuerList && IssuerCount && IssuerListLength);
    ASSERT(BaseAddr);

    Status    = STATUS_INVALID_PARAMETER;
    pDataBlob = (PHTTP_DATA_BLOB)pIssuerList;

    // Blob must at least contain 'IssuerCount' number of HTTP_DATA_BLOB
    if (IssuerListLength <= sizeof(PHTTP_DATA_BLOB) * IssuerCount)
    {
        goto error;
    }

    // For each HTTP_DATA_BLOB, adjust pbData.
    for (i = 0; i < IssuerCount; i++)
    {
        pDataBlob[i].pbData = pIssuerList + (pDataBlob[i].pbData - BaseAddr);

        // pbData must point somewhere inside the blob.
        if (pDataBlob[i].pbData >= pIssuerList + IssuerListLength)
        {
            goto error;
        }
    }

    Status = STATUS_SUCCESS;

 error:
    return Status;
}


/***************************************************************************++

Routine Description:

    Captures SSL server certificate passed down in a UlFilterAppWrite
    call with a UlFilterBufferSslServerCert type.

Arguments:

    pCertInfo - the cert data to capture
    SslCertInfoLength - size of the buffer passed to us
    ppCapturedCert - this is where we stick the info we get
    pTakenLength - gets the number of bytes we read

--***************************************************************************/
NTSTATUS
UcCaptureSslServerCertInfo(
    IN  PUX_FILTER_CONNECTION      pConnection,
    IN  PHTTP_SSL_SERVER_CERT_INFO pCertInfo,
    IN  ULONG                      CertInfoLength,
    OUT PHTTP_SSL_SERVER_CERT_INFO pCopyCertInfo,
    OUT PULONG                     pTakenLength
    )
{
    NTSTATUS              Status;
    PUC_CLIENT_CONNECTION pClientConn;
    PUCHAR                pCert;
    PUCHAR                pCertStore;
    PUCHAR                pIssuerList;


    // Sanity check
    ASSERT(IS_VALID_FILTER_CONNECTION(pConnection));
    ASSERT(pCertInfo && CertInfoLength);
    ASSERT(pCopyCertInfo);
    ASSERT(pTakenLength);

    // Initialize locals
    Status = STATUS_SUCCESS;
    pClientConn = (PUC_CLIENT_CONNECTION)pConnection->pConnectionContext;
    ASSERT(UC_IS_VALID_CLIENT_CONNECTION(pClientConn));

    pCert = NULL;
    pCertStore = NULL;
    pIssuerList = NULL;

    // Initialize output variables
    *pTakenLength = 0;

    //
    // See if it's ok to capture...
    //
    if (CertInfoLength != sizeof(HTTP_SSL_SERVER_CERT_INFO))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Capture the server cert info.
    //
    __try
    {
        // OK to copy the structure
        RtlCopyMemory(pCopyCertInfo,
                      pCertInfo,
                      sizeof(HTTP_SSL_SERVER_CERT_INFO));

        // Return the number of bytes read.
        *pTakenLength = sizeof(HTTP_SSL_SERVER_CERT_INFO);

        if (pCopyCertInfo->Cert.CertHashLength > HTTP_SSL_CERT_HASH_LENGTH)
        {
            ExRaiseStatus(STATUS_INVALID_PARAMETER);
        }

        //
        // Capture Issuer list if any.
        //
        if (pCopyCertInfo->IssuerInfo.IssuerListLength &&
            pCopyCertInfo->IssuerInfo.IssuerCount &&
            pCopyCertInfo->IssuerInfo.pIssuerList)
        {
            // IssuerList must be accessible.
            UlProbeForRead(pCopyCertInfo->IssuerInfo.pIssuerList,
                           pCopyCertInfo->IssuerInfo.IssuerListLength,
                           sizeof(ULONG),
                           UserMode);

            // Allocate memory to store IssuerList.
            pIssuerList = UL_ALLOCATE_POOL_WITH_QUOTA(
                              NonPagedPool,
                              pCopyCertInfo->IssuerInfo.IssuerListLength,
                              UC_SSL_CERT_DATA_POOL_TAG,
                              pClientConn->pServerInfo->pProcess);

            if (!pIssuerList)
            {
                ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
            }

            // Copy IssuerList to allocated memory.
            RtlCopyMemory(pIssuerList,
                          pCopyCertInfo->IssuerInfo.pIssuerList,
                          pCopyCertInfo->IssuerInfo.IssuerListLength);

            // Fixup the pointers inside IssuerList
            Status = UcpFixupIssuerList(
                         pIssuerList,
                         pCopyCertInfo->IssuerInfo.pIssuerList,
                         pCopyCertInfo->IssuerInfo.IssuerCount,
                         pCopyCertInfo->IssuerInfo.IssuerListLength);

            if (!NT_SUCCESS(Status))
            {
                ExRaiseStatus(Status);
            }

            // Finally copy the pointer to the internal copy of IssuerInfo
            pCopyCertInfo->IssuerInfo.pIssuerList = pIssuerList;
        }
        else
        {
            pCopyCertInfo->IssuerInfo.IssuerListLength  = 0;
            pCopyCertInfo->IssuerInfo.IssuerCount = 0;
            pCopyCertInfo->IssuerInfo.pIssuerList = NULL;
        }

        //
        // Serialized Certificates and Certificate stores are huge.
        // Make there internal copies only if required.

        //
        // A copy is made in the following case:
        // 1. if an issuer list is specified
        // 2. if the new certificate is different from the existing one
        //

        if (pIssuerList != NULL ||
            UcpNeedToCaptureSerializedCert(pCopyCertInfo,
                                           pClientConn->pServerInfo))
        {
            // Required to copy serialized certificate.

            // Initialize Flags
            pCopyCertInfo->Cert.Flags = HTTP_SSL_SERIALIZED_CERT_PRESENT;

            //
            // Copy serialized server ceritificate
            //
            if (pCopyCertInfo->Cert.SerializedCertLength)
            {
                // Serialized cert must be accessible
                UlProbeForRead(pCopyCertInfo->Cert.pSerializedCert,
                               pCopyCertInfo->Cert.SerializedCertLength,
                               sizeof(UCHAR),
                               UserMode);

                // Allocate memory for serialized cert
                pCert = UL_ALLOCATE_POOL_WITH_QUOTA(
                            NonPagedPool,
                            pCopyCertInfo->Cert.SerializedCertLength,
                            UC_SSL_CERT_DATA_POOL_TAG,
                            pClientConn->pServerInfo->pProcess);

                if (!pCert)
                {
                    ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
                }

                // Copy serialized cert
                RtlCopyMemory(pCert,
                              pCopyCertInfo->Cert.pSerializedCert,
                              pCopyCertInfo->Cert.SerializedCertLength);

                // Internal copy of the serialized cert
                pCopyCertInfo->Cert.pSerializedCert = pCert;
            }
            else
            {
                pCopyCertInfo->Cert.pSerializedCert = NULL;
            }

            //
            // Copy serialized certificate store
            //
            if (pCopyCertInfo->Cert.SerializedCertStoreLength)
            {
                // Serialized cert store must be accessible
                UlProbeForRead(pCopyCertInfo->Cert.pSerializedCertStore,
                               pCopyCertInfo->Cert.SerializedCertStoreLength,
                               sizeof(UCHAR),
                               UserMode);

                // Allocate memory for serialized cert store
                pCertStore = UL_ALLOCATE_POOL_WITH_QUOTA(
                                 NonPagedPool,
                                 pCopyCertInfo->Cert.SerializedCertStoreLength,
                                 UC_SSL_CERT_DATA_POOL_TAG,
                                 pClientConn->pServerInfo->pProcess);

                if (!pCertStore)
                {
                    ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
                }

                // Copy serialized cert store
                RtlCopyMemory(pCertStore,
                              pCopyCertInfo->Cert.pSerializedCertStore,
                              pCopyCertInfo->Cert.SerializedCertStoreLength);

                // Internal copy of the serialized cert
                pCopyCertInfo->Cert.pSerializedCertStore = pCertStore;
            }
            else
            {
                pCopyCertInfo->Cert.pSerializedCertStore = NULL;
            }
        }
        else
        {
            // No Need to copy serialized certificate!
            pCopyCertInfo->Cert.Flags = 0;
            pCopyCertInfo->Cert.pSerializedCert = NULL;
            pCopyCertInfo->Cert.SerializedCertLength = 0;
            pCopyCertInfo->Cert.pSerializedCertStore = NULL;
            pCopyCertInfo->Cert.SerializedCertStoreLength = 0;
        }
    }
    __except(UL_EXCEPTION_FILTER())
    {
        Status = GetExceptionCode();

        if (pIssuerList)
        {
            UL_FREE_POOL_WITH_QUOTA(pIssuerList,
                                    UC_SSL_CERT_DATA_POOL_TAG,
                                    NonPagedPool,
                                    pCopyCertInfo->IssuerInfo.IssuerListLength,
                                    pClientConn->pServerInfo->pProcess);
        }

        if (pCert)
        {
            UL_FREE_POOL_WITH_QUOTA(pCert,
                                    UC_SSL_CERT_DATA_POOL_TAG,
                                    NonPagedPool,
                                    pCopyCertInfo->Cert.SerializedCertLength,
                                    pClientConn->pServerInfo->pProcess);
        }

        if (pCertStore)
        {
            UL_FREE_POOL_WITH_QUOTA(
                pCertStore,
                UC_SSL_CERT_DATA_POOL_TAG,
                NonPagedPool,
                pCopyCertInfo->Cert.SerializedCertStoreLength,
                pClientConn->pServerInfo->pProcess);
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\strlog.h ===
/*++

Copyright (c) 2001-2002 Microsoft Corporation

Module Name:

    strlog.h

Abstract:

    A tracelog for variable-length strings. Strings are written to
    an in-memory circular buffer, instead of the debug output port.
    The buffer can be dumped with !ulkd.strlog.
    
    DbgPrint is verrry slooow and radically affects timing, especially
    on a multiprocessor system. Also, with this approach, you can
    have multiple string logs, instead of having all the output
    mixed up.
    
Author:

    George V. Reilly  Jul-2001

Revision History:

--*/


#ifndef _STRLOG_H_
#define _STRLOG_H_


//
// Manipulators.
//

typedef struct _STRING_LOG *PSTRING_LOG;

PSTRING_LOG
CreateStringLog(
    IN ULONG    LogSize,
    IN ULONG    ExtraBytesInHeader,
    BOOLEAN     EchoDbgPrint
    );

VOID
DestroyStringLog(
    IN PSTRING_LOG pLog
    );

LONGLONG
__cdecl
WriteStringLog(
    IN PSTRING_LOG pLog,
    IN PCH Format,
    ...
    );

LONGLONG
__cdecl
WriteGlobalStringLog(
    IN PCH Format,
    ...
    );

VOID
ResetStringLog(
    IN PSTRING_LOG pLog
    );


#if TRACE_TO_STRING_LOG

#define CREATE_STRING_LOG( ptr, size, extra, dbgprint )                     \
    (ptr) = CreateStringLog( (size), (extra), (dbgprint) )

#define DESTROY_STRING_LOG( ptr )                                           \
    do                                                                      \
    {                                                                       \
        DestroyStringLog( ptr );                                            \
        (ptr) = NULL;                                                       \
    } while (FALSE, FALSE)

#else // !TRACE_TO_STRING_LOG

#define CREATE_STRING_LOG( ptr, size, extra, dbgprint ) NOP_FUNCTION
#define DESTROY_STRING_LOG( ptr )                       NOP_FUNCTION

#endif // !TRACE_TO_STRING_LOG


#endif  // _STRLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\strlogp.h ===
/*++

Copyright (c) 2001-2002 Microsoft Corporation

Module Name:

    strlogp.h

Abstract:

    A tracelog for variable-length strings. Private definitions.
    
Author:

    George V. Reilly  23-Jul-2001

Revision History:

--*/


#ifndef _STRLOGP_H_
#define _STRLOGP_H_


#undef WriteGlobalStringLog

#define STRING_LOG_SIGNATURE MAKE_SIGNATURE('$Log')
#define STRING_LOG_SIGNATURE_X MAKE_FREE_SIGNATURE(STRING_LOG_SIGNATURE)

#define STRING_LOG_ENTRY_SIGNATURE          MAKE_SIGNATURE('$LE_')
#define STRING_LOG_ENTRY_MULTI_SIGNATURE    MAKE_SIGNATURE('$LE#')
#define STRING_LOG_ENTRY_EOB_SIGNATURE      MAKE_SIGNATURE('$LE@')
#define STRING_LOG_ENTRY_LAST_SIGNATURE     MAKE_SIGNATURE('$LE!')

#define PRINTF_BUFFER_LEN_BITS 9
#define PRINTF_BUFFER_LEN ((1 << PRINTF_BUFFER_LEN_BITS) - 1)

#define STRING_LOG_MULTIPLE_ENTRIES 100

#define STRING_LOG_PROCESSOR_BITS   6  // MAXIMUM_PROCESSORS == 64 on Win64

C_ASSERT((1 << STRING_LOG_PROCESSOR_BITS) >= MAXIMUM_PROCESSORS);
C_ASSERT(PRINTF_BUFFER_LEN_BITS + STRING_LOG_PROCESSOR_BITS <= 16);

//
// There are actually two kinds of STRING_LOG_ENTRYs, regular ones and
// multi-entrys. A regular entry is immediately followed by a zero-terminated
// string; a multi-entry is always followed by a regular entry.
//
// A regular entry uses PrevDelta to point back to the preceding entry
// in the STRING_LOG circular log buffer. Starting at the end (as pointed to by
// STRING_LOG::Offset and STRING_LOG::LastEntryLength), !strlog can walk
// back through all the entries remaining in the circular log buffer.
//
// Multi-entrys allow !ulkd.strlog to skip multiple records, reducing the time
// to walk back a few thousand entries from approximately a minute to under
// a second.
//

typedef struct _STRING_LOG_ENTRY
{
    // STRING_LOG_ENTRY_SIGNATURE
    ULONG   Signature;

    // length of string, excluding trailing zeroes
    ULONG   Length : PRINTF_BUFFER_LEN_BITS;

    // delta to beginning of previous entry
    ULONG   PrevDelta : 1 + PRINTF_BUFFER_LEN_BITS;

    // processor executing WriteStringLog
    ULONG   Processor : STRING_LOG_PROCESSOR_BITS;

    // timestamp. Broken into two ULONGs to minimize alignment constraints
    ULONG   TimeStampLowPart;
    ULONG   TimeStampHighPart;
} STRING_LOG_ENTRY, *PSTRING_LOG_ENTRY;

// Make sure that USHORT STRING_LOG_MULTI_ENTRY::PrevDelta will not overflow
C_ASSERT((PRINTF_BUFFER_LEN + sizeof(STRING_LOG_ENTRY) + sizeof(ULONG))
            * STRING_LOG_MULTIPLE_ENTRIES
         < 0x10000);

typedef struct _STRING_LOG_MULTI_ENTRY
{
    ULONG   Signature;  // STRING_LOG_ENTRY_MULTI_SIGNATURE
    USHORT  NumEntries; // number of regular entries
    USHORT  PrevDelta;  // delta to beginning of previous multi-entry
} STRING_LOG_MULTI_ENTRY, *PSTRING_LOG_MULTI_ENTRY;


typedef struct _STRING_LOG
{
    //
    // Signature: STRING_LOG_SIGNATURE;
    //
    
    ULONG Signature;
    
    //
    // The total number of bytes in the string buffer, pLogBuffer
    //

    ULONG LogSize;

    //
    // Protects NextEntry and other data
    //
    
    KSPIN_LOCK SpinLock;
    
    //
    // The notional index of the next entry to record. Unlike regular
    // tracelogs, there is no random access to entries.
    //

    LONGLONG NextEntry;

    //
    // Offset within pLogBuffer at which next regular entry will be written
    //
    
    ULONG Offset;

    //
    // Number of times we have wrapped around
    //
    
    ULONG WrapAroundCount;

    //
    // Should we also call DbgPrint on each string?
    //
    
    BOOLEAN EchoDbgPrint;

    //
    // Size in bytes of previous entry
    //

    USHORT LastEntryLength;

    //
    // Walking back through thousands of entries one-by-one is slow.
    // We maintain a second-level index that skips back up to
    // STRING_LOG_MULTIPLE_ENTRIES at a time.
    //

    USHORT MultiNumEntries; // # regular entries since last multi-entry
    USHORT MultiByteCount;  // # bytes since last multi-entry
    ULONG  MultiOffset;     // offset of last multi-entry from pLogBuffer

    //
    // Pointer to the start of the circular buffer of strings.
    //

    PUCHAR pLogBuffer;

    //
    // When was the first entry written? All other entries are timestamped
    // relative to this.
    //
    
    LARGE_INTEGER InitialTimeStamp;

    //
    // The extra header bytes and actual log entries go here.
    //
    // BYTE ExtraHeaderBytes[ExtraBytesInHeader];
    // BYTE Entries[LogSize];
    //

} STRING_LOG, *PSTRING_LOG;


#endif  // _STRLOGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\thrdpoolp.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    thrdpoolp.h

Abstract:

    This module contains private declarations for the thread pool package.

Author:

    Keith Moore (KeithMo)       10-Jun-1998

Revision History:

    Chun Ye (ChunYe)            Spring 2001
    George V. Reilly (GeorgeRe) Summer 2001

--*/


#ifndef _THRDPOOLP_H_
#define _THRDPOOLP_H_


//
// CODEWORK: Build a new kind of tracelog for threadpool. Reftrace is
// inadequate.
//

// Special threads

enum {
    WaitThreadPool,
    HighPriorityThreadPool,
    MaxThreadPools              // must be last
};


//
// Various states that a thread pool worker thread can be in
//

typedef enum {
    ThreadPoolCreated = 1,
    ThreadPoolInit,
    ThreadPoolFlush,
    ThreadPoolSearchOther,
    ThreadPoolBlock,
    ThreadPoolReverseList,
    ThreadPoolExecute,
    ThreadPoolException,
    ThreadPoolTerminated,
} UL_THREAD_POOL_STATE;


typedef struct _UL_THREAD_POOL *PUL_THREAD_POOL;


//
// Thread tracker object. One of these objects is created for each
// thread in the pool. These are useful for (among other things)
// debugging.
//

typedef struct _UL_THREAD_TRACKER
{
    //
    // Links onto the per-thread-pool list.
    //

    LIST_ENTRY ThreadListEntry;

    //
    // Back pointer to owning threadpool
    //

    PUL_THREAD_POOL pThreadPool;

    //
    // The thread.
    //

    PETHREAD pThread;

    //
    // The thread handle returned from PsCreateSystemThread.
    //

    HANDLE ThreadHandle;

    //
    // List of worker items currently being processed in inner loop
    // and length of that list
    //

    SLIST_ENTRY CurrentListHead;
    ULONG       ListLength;

    //
    // Current state of the thread 
    //

    UL_THREAD_POOL_STATE State;

    //
    // Current workitem and current workroutine
    //

    PUL_WORK_ROUTINE pWorkRoutine;
    PUL_WORK_ITEM    pWorkItem;

    //
    // Statistics
    // Average queue length (at time of flush) = SumQueueLength / QueueFlushes
    //
    
    ULONGLONG Executions;
    ULONGLONG SumQueueLengths;
    ULONG     QueueFlushes;
    ULONG     MaxQueueLength;

} UL_THREAD_TRACKER, *PUL_THREAD_TRACKER;


//
// The thread pool object.
//

typedef struct _UL_THREAD_POOL
{
    //
    // List of unprocessed worker items on this thread pool.
    //

    SLIST_HEADER WorkQueueSList;

    //
    // An event used to wakeup the thread from blocking state.
    //

    KEVENT WorkQueueEvent;

    //
    // List of threads.
    //

    LIST_ENTRY ThreadListHead;

    //
    // Pointer to the special thread designated as the IRP thread. The
    // IRP thread is the first pool thread created and the last one to
    // die. It is also the target for all asynchronous IRPs.
    //

    PETHREAD pIrpThread;

    //
    // A very infrequently used spinlock.
    //

    UL_SPIN_LOCK ThreadSpinLock;

    //
    // The number of threads we created for this pool.
    //

    UCHAR ThreadCount;

    //
    // Flag used to indicate that this pool has been successfully
    // initialized.
    //

    BOOLEAN Initialized;

    //
    // Target CPU for this pool. The worker threads use this to set
    // their hard affinity.
    //

    UCHAR ThreadCpu;

    //
    // Regular worker threads can pull workitems from
    // other regular queues on other processors.
    //

    BOOLEAN LookOnOtherQueues;

} UL_THREAD_POOL, *PUL_THREAD_POOL;


//
// Necessary to ensure our array of UL_THREAD_POOL structures is
// cache aligned.
//

typedef union _UL_ALIGNED_THREAD_POOL
{
    UL_THREAD_POOL ThreadPool;

    UCHAR CacheAlignment[(sizeof(UL_THREAD_POOL) + UL_CACHE_LINE - 1)
                         & ~(UL_CACHE_LINE - 1)];

} UL_ALIGNED_THREAD_POOL;


//
// Inline function to validate that a UL_WORK_ITEM has been properly
// initialized. Bugcheck if it's not.
//

__inline
VOID
UlpValidateWorkItem(
    IN PUL_WORK_ITEM pWorkItem,
    IN PCSTR         pFileName,
    IN USHORT        LineNumber
    )
{
    if (! UlIsInitializedWorkItem(pWorkItem))
    {
        ASSERT(! "Uninitialized workitem");

        //
        // If the workitem was not properly zeroed, then chances are that
        // it's already on a work queue. If we were to requeue the work item,
        // it would corrupt the work queue. Better to fail hard now, while
        // there's some hope of figuring out what went wrong, than let it
        // crash mysteriously later.
        //
        
        UlBugCheckEx(
            HTTP_SYS_BUGCHECK_WORKITEM,
            (ULONG_PTR) pWorkItem,
            (ULONG_PTR) pFileName,
            (ULONG_PTR) LineNumber
            );
    }
} // UlpValidateWorkItem


//
// Inline function to queue a preinitialized UL_WORK_ITEM.
//

__inline
VOID
QUEUE_UL_WORK_ITEM(
    PUL_THREAD_POOL pThreadPool,
    IN PUL_WORK_ITEM pWorkItem
    )
{
    if (NULL == InterlockedPushEntrySList(
                    &pThreadPool->WorkQueueSList,
                    &pWorkItem->QueueListEntry
                    ))
    {
        //
        // If the work queue was empty when we added this item,
        // set the event to wake the thread up
        //

        KeSetEvent(
            &pThreadPool->WorkQueueEvent,
            0,
            FALSE
            );
    }

}


//
// Private prototypes.
//

NTSTATUS
UlpCreatePoolThread(
    IN PUL_THREAD_POOL pThreadPool
    );

VOID
UlpThreadPoolWorker(
    IN PVOID Context
    );

VOID
UlpInitThreadTracker(
    IN PUL_THREAD_POOL pThreadPool,
    IN PETHREAD pThread,
    IN PUL_THREAD_TRACKER pThreadTracker
    );

VOID
UlpDestroyThreadTracker(
    IN PUL_THREAD_TRACKER pThreadTracker
    );

PUL_THREAD_TRACKER
UlpPopThreadTracker(
    IN PUL_THREAD_POOL pThreadPool
    );

VOID
UlpKillThreadWorker(
    IN PUL_WORK_ITEM pWorkItem
    );


//
// Private globals.
//

extern DECLSPEC_ALIGN(UL_CACHE_LINE)
UL_ALIGNED_THREAD_POOL g_UlThreadPool[];

#define CURRENT_THREAD_POOL()           \
    &g_UlThreadPool[KeGetCurrentProcessorNumber()].ThreadPool

#define CURRENT_SYNC_THREAD_POOL()   \
    &g_UlThreadPool[g_UlNumberOfProcessors + KeGetCurrentProcessorNumber()].ThreadPool

#define WAIT_THREAD_POOL()              \
    &g_UlThreadPool[(g_UlNumberOfProcessors * 2) + WaitThreadPool].ThreadPool

#define HIGH_PRIORITY_THREAD_POOL()     \
    &g_UlThreadPool[(g_UlNumberOfProcessors * 2) + HighPriorityThreadPool].ThreadPool

extern PUL_WORK_ITEM g_pKillerWorkItems;

#endif  // _THRDPOOLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\timeouts.h ===
/*++

Copyright (c) 2001-2002 Microsoft Corporation

Module Name:

    timeouts.h

Abstract:

    Declaration for timeout monitoring primitives.

Author:

    Eric Stenson (EricSten)     24-Mar-2001

Revision History:

--*/

#ifndef __TIMEOUTS_H__
#define __TIMEOUTS_H__


//
// Connection Timeout Monitor Functions
//

VOID
UlInitializeTimeoutMonitor(
    VOID
    );

VOID
UlTerminateTimeoutMonitor(
    VOID
    );

VOID
UlSetTimeoutMonitorInformation(
    IN PHTTP_CONTROL_CHANNEL_TIMEOUT_LIMIT pInfo
    );

VOID
UlInitializeConnectionTimerInfo(
    PUL_TIMEOUT_INFO_ENTRY pInfo
    );

VOID
UlTimeoutRemoveTimerWheelEntry(
    PUL_TIMEOUT_INFO_ENTRY pInfo
    );

VOID
UlSetPerSiteConnectionTimeoutValue(
    PUL_TIMEOUT_INFO_ENTRY pInfo,
    LONGLONG TimeoutValue
    );

#define UlLockTimeoutInfo(pInfo, pOldIrql) \
    UlAcquireSpinLock(&(pInfo)->Lock, pOldIrql)

#define UlUnlockTimeoutInfo(pInfo, OldIrql) \
    UlReleaseSpinLock(&(pInfo)->Lock, OldIrql)

VOID
UlSetConnectionTimer(
    PUL_TIMEOUT_INFO_ENTRY pInfo,
    CONNECTION_TIMEOUT_TIMER Timer
    );

VOID
UlResetConnectionTimer(
    PUL_TIMEOUT_INFO_ENTRY pInfo,
    CONNECTION_TIMEOUT_TIMER Timer
    );

VOID
UlSetMinBytesPerSecondTimer(
    PUL_TIMEOUT_INFO_ENTRY pInfo,
    LONGLONG BytesToSend
    );

VOID
UlEvaluateTimerState(
    PUL_TIMEOUT_INFO_ENTRY pInfo
    );


extern LONGLONG g_TM_ConnectionTimeout;


#define TIMER_OFF_TICK           0xffffffff

#define UlIsConnectionTimerOn(pInfo, Timer)   \
    (TIMER_OFF_TICK != (pInfo)->Timers[(Timer)])

#define UlIsConnectionTimerOff(pInfo, Timer)   \
    (TIMER_OFF_TICK == (pInfo)->Timers[(Timer)])


#endif // __TIMEOUTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\timeoutsp.h ===
/*++

Copyright (c) 2001-2002 Microsoft Corporation

Module Name:

    timeoutsp.h

Abstract:

    Declaration for timeout monitoring private declarations.

Author:

    Eric Stenson (EricSten)     24-Mar-2001

Revision History:

--*/

#ifndef __TIMEOUTSP_H__
#define __TIMEOUTSP_H__


//
// Private macro definitions
// 

#define DEFAULT_POLLING_INTERVAL (30 * C_NS_TICKS_PER_SEC)
#define TIMER_WHEEL_SLOTS        509
#define TIMER_OFF_SYSTIME        (MAXLONGLONG)
#define TIMER_OFF_SLOT           TIMER_WHEEL_SLOTS

// NOTE: Slot number TIMER_WHEEL_SLOTS is reserved for TIMER_OFF_SYSTIME/TIMER_OFF_TICK
#define IS_VALID_TIMER_WHEEL_SLOT(x) ( (x) <= TIMER_WHEEL_SLOTS )

#define TIMER_WHEEL_TICKS(x) ((ULONG)( (x) / DEFAULT_POLLING_INTERVAL ))

//
// Table for the error log entry timeout info.
// NOTE: Order must match with CONNECTION_TIMEOUT_TIMER type.
//

typedef struct _UL_TIMEOUT_ERROR_INFO
{
    CONNECTION_TIMEOUT_TIMER Timer;
    PCSTR  pInfo;
    USHORT InfoSize;
    
} UL_TIMEOUT_ERROR_INFO, PUL_TIMEOUT_ERROR_INFO;

#define TIMEOUT_ERROR_ENTRY(Timer, pInfo)               \
    {                                                   \
        (Timer),                                        \
        (pInfo),                                        \
        sizeof((pInfo))-sizeof(CHAR),                   \
    }

const
UL_TIMEOUT_ERROR_INFO TimeoutInfoTable[] =
{
    TIMEOUT_ERROR_ENTRY(TimerConnectionIdle,    "Timer_ConnectionIdle"), 
    TIMEOUT_ERROR_ENTRY(TimerHeaderWait,        "Timer_HeaderWait"), 
    TIMEOUT_ERROR_ENTRY(TimerMinBytesPerSecond, "Timer_MinBytesPerSecond"), 
    TIMEOUT_ERROR_ENTRY(TimerEntityBody,        "Timer_EntityBody"), 
    TIMEOUT_ERROR_ENTRY(TimerResponse,          "Timer_Response"), 
    TIMEOUT_ERROR_ENTRY(TimerAppPool,           "Timer_AppPool")
};


//
// Connection Timeout Monitor Functions
//

VOID
UlpSetTimeoutMonitorTimer(
    VOID
    );

VOID
UlpTimeoutMonitorDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
UlpTimeoutMonitorWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

ULONG
UlpTimeoutCheckExpiry(
    VOID
    );

VOID
UlpTimeoutInsertTimerWheelEntry(
    PUL_TIMEOUT_INFO_ENTRY pInfo
    );

/***************************************************************************++

Routine Description:

    Converts a system time/Timer Wheel Tick into a Timer Wheel(c) slot index.

Arguments:

    SystemTime      System Time to be converted

Returns:

    Slot index into g_TimerWheel.  TIMER_OFF is in TIMER_SLOT_OFF.

--***************************************************************************/
__inline
USHORT
UlpSystemTimeToTimerWheelSlot(
    LONGLONG    SystemTime
    )
{
    if ( TIMER_OFF_SYSTIME == SystemTime )
    {
        return TIMER_OFF_SLOT;
    }
    else
    {
        return (USHORT) (TIMER_WHEEL_TICKS(SystemTime) % TIMER_WHEEL_SLOTS);
    }
} // UlpSystemTimeToTimerWheelSlot

__inline
USHORT
UlpTimerWheelTicksToTimerWheelSlot(
    ULONG WheelTicks
    )
{
    if ( TIMER_OFF_TICK == WheelTicks )
    {
        return TIMER_OFF_SLOT;
    }
    else
    {
        return (USHORT) (WheelTicks % TIMER_WHEEL_SLOTS);
    }
} // UlpTimerWheelTicksToTimerWheelSlot


#endif // __TIMEOUTSP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\thrdpool.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    thrdpool.c

Abstract:

    This module implements the thread pool package.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include <precomp.h>
#include "thrdpoolp.h"


//
// Private globals.
//

DECLSPEC_ALIGN(UL_CACHE_LINE)
UL_ALIGNED_THREAD_POOL
g_UlThreadPool[(MAXIMUM_PROCESSORS * 2) + MaxThreadPools];

PUL_WORK_ITEM g_pKillerWorkItems = NULL;


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeThreadPool )
// #pragma alloc_text( PAGE, UlTerminateThreadPool )
#pragma alloc_text( PAGE, UlpCreatePoolThread )
#pragma alloc_text( PAGE, UlpThreadPoolWorker )

#endif  // ALLOC_PRAGMA
#if 0
NOT PAGEABLE -- UlpInitThreadTracker
NOT PAGEABLE -- UlpDestroyThreadTracker
NOT PAGEABLE -- UlpPopThreadTracker
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Initialize the thread pool.

Arguments:

    ThreadsPerCpu - Supplies the number of threads to create per CPU.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlInitializeThreadPool(
    IN USHORT ThreadsPerCpu
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUL_THREAD_POOL pThreadPool;
    CLONG i;
    USHORT j;

    //
    // Sanity check.
    //

    PAGED_CODE();

    RtlZeroMemory( g_UlThreadPool, sizeof(g_UlThreadPool) );

    //
    // Preallocate the small array of special work items used by
    // UlTerminateThreadPool, so that we can safely shut down even
    // in low-memory conditions. This must be the first allocation
    // or shutdown will not work.
    //

    g_pKillerWorkItems = UL_ALLOCATE_ARRAY(
                            NonPagedPool,
                            UL_WORK_ITEM,
                            ((g_UlNumberOfProcessors * 2) + MaxThreadPools)
                                * ThreadsPerCpu,
                            UL_WORK_ITEM_POOL_TAG
                            );

    if (g_pKillerWorkItems == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (i = 0; i < (g_UlNumberOfProcessors * 2) + MaxThreadPools; i++)
    {
        pThreadPool = &g_UlThreadPool[i].ThreadPool;

        UlTrace(WORK_ITEM,
                ("Initializing threadpool[%d] @ %p\n", i, pThreadPool));
            

        //
        // Initialize the kernel structures.
        //

        InitializeSListHead( &pThreadPool->WorkQueueSList );

        KeInitializeEvent(
            &pThreadPool->WorkQueueEvent,
            SynchronizationEvent,
            FALSE
            );

        UlInitializeSpinLock( &pThreadPool->ThreadSpinLock, "ThreadSpinLock" );

        //
        // Initialize the other fields.
        //

        pThreadPool->pIrpThread = NULL;
        pThreadPool->ThreadCount = 0;
        pThreadPool->Initialized = FALSE;
        pThreadPool->ThreadCpu = (UCHAR) i;
        pThreadPool->LookOnOtherQueues = FALSE;

        InitializeListHead( &pThreadPool->ThreadListHead );
    }

    for (i = 0; i < (g_UlNumberOfProcessors * 2) + MaxThreadPools; i++)
    {
        ULONG NumThreads = (i < (g_UlNumberOfProcessors * 2)) ?
                            ThreadsPerCpu : 1;

        pThreadPool = &g_UlThreadPool[i].ThreadPool;

        //
        // Create the threads.
        //

        for (j = 0; j < NumThreads; j++)
        {
            UlTrace(WORK_ITEM,
                    ("Creating thread[%d,%d] @ %p\n", i, j, pThreadPool));

            Status = UlpCreatePoolThread( pThreadPool );

            if (NT_SUCCESS(Status))
            {
                pThreadPool->Initialized = TRUE;
                pThreadPool->ThreadCount++;
            }
            else
            {
                break;
            }
        }

        if (!NT_SUCCESS(Status))
        {
            break;
        }
    }

    return Status;

}   // UlInitializeThreadPool


/***************************************************************************++

Routine Description:

    Terminates the thread pool, waiting for all worker threads to exit.

--***************************************************************************/
VOID
UlTerminateThreadPool(
    VOID
    )
{
    PUL_THREAD_POOL pThreadPool;
    PUL_THREAD_TRACKER pThreadTracker;
    CLONG i, j;
    PUL_WORK_ITEM pKiller = g_pKillerWorkItems;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // If there is no killer, the thread pool has never been initialized.
    //

    if (pKiller == NULL)
    {
        return;
    }

    for (i = 0; i < (g_UlNumberOfProcessors * 2) + MaxThreadPools; i++)
    {
        pThreadPool = &g_UlThreadPool[i].ThreadPool;

        if (pThreadPool->Initialized)
        {
            //
            // Queue a killer work item for each thread. Each
            // killer tells one thread to kill itself.
            //

            for (j = 0; j < pThreadPool->ThreadCount; j++)
            {
                //
                // Need a separate work item for each thread.
                // Worker threads will free the below memory
                // before termination. UlpKillThreadWorker is
                // a sign to a worker thread for self termination.
                //

                UlInitializeWorkItem(pKiller);
                pKiller->pWorkRoutine = &UlpKillThreadWorker;

                QUEUE_UL_WORK_ITEM( pThreadPool, pKiller );

                pKiller++;
            }

            //
            // Wait for all threads to go away.
            //

            while (NULL != (pThreadTracker = UlpPopThreadTracker(pThreadPool)))
            {
                UlpDestroyThreadTracker( pThreadTracker );
            }
        }

        ASSERT( IsListEmpty( &pThreadPool->ThreadListHead ) );
    }

    UL_FREE_POOL(g_pKillerWorkItems, UL_WORK_ITEM_POOL_TAG);
    g_pKillerWorkItems = NULL;

}   // UlTerminateThreadPool


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Creates a new pool thread, setting pIrpThread if necessary.

Arguments:

    pThreadPool - Supplies the pool that is to receive the new thread.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpCreatePoolThread(
    IN PUL_THREAD_POOL pThreadPool
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PUL_THREAD_TRACKER pThreadTracker;
    PETHREAD pThread;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Ensure we can allocate a thread tracker.
    //

    pThreadTracker = (PUL_THREAD_TRACKER) UL_ALLOCATE_POOL(
                            NonPagedPool,
                            sizeof(*pThreadTracker),
                            UL_THREAD_TRACKER_POOL_TAG
                            );

    if (pThreadTracker != NULL)
    {
        RtlZeroMemory(pThreadTracker, sizeof(*pThreadTracker));

        pThreadTracker->pThreadPool = pThreadPool;
        pThreadTracker->State = ThreadPoolCreated;

        //
        // Create the thread.
        //

        InitializeObjectAttributes(
            &ObjectAttributes,                      // ObjectAttributes
            NULL,                                   // ObjectName
            OBJ_KERNEL_HANDLE,                       // Attributes
            NULL,                                   // RootDirectory
            NULL                                    // SecurityDescriptor
            );

        Status = PsCreateSystemThread(
                     &pThreadTracker->ThreadHandle, // ThreadHandle
                     THREAD_ALL_ACCESS,             // DesiredAccess
                     &ObjectAttributes,             // ObjectAttributes
                     NULL,                          // ProcessHandle
                     NULL,                          // ClientId
                     UlpThreadPoolWorker,           // StartRoutine
                     pThreadTracker                 // StartContext
                     );

        if (NT_SUCCESS(Status))
        {
            //
            // Get a pointer to the thread.
            //

            Status = ObReferenceObjectByHandle(
                        pThreadTracker->ThreadHandle,// ThreadHandle
                        FILE_READ_ACCESS,           // DesiredAccess
                        *PsThreadType,              // ObjectType
                        KernelMode,                 // AccessMode
                        (PVOID*) &pThread,          // Object
                        NULL                        // HandleInformation
                        );

            if (NT_SUCCESS(Status))
            {
                //
                // Set up the thread tracker.
                //
                
                UlpInitThreadTracker(pThreadPool, pThread, pThreadTracker);

                //
                // If this is the first thread created for this pool,
                // make it into the special IRP thread.
                //

                if (pThreadPool->pIrpThread == NULL)
                {
                    pThreadPool->pIrpThread = pThread;
                }
            }
            else
            {
                //
                // That call really should not fail.
                //

                ASSERT(NT_SUCCESS(Status));

                //
                // Preserve return val from ObReferenceObjectByHandle.
                //

                ZwClose( pThreadTracker->ThreadHandle );

                UL_FREE_POOL(
                    pThreadTracker,
                    UL_THREAD_TRACKER_POOL_TAG
                    );

            }
        }
        else
        {
            //
            // Couldn't create the thread, kill the tracker.
            //

            UL_FREE_POOL(
                pThreadTracker,
                UL_THREAD_TRACKER_POOL_TAG
                );
        }
    }
    else
    {
        //
        // Couldn't create a thread tracker.
        //

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;

}   // UlpCreatePoolThread


/***************************************************************************++

Routine Description:

    This is the main worker function for pool threads.

Arguments:

    pContext - Supplies a context value for the thread. This is actually
        a UL_THREAD_TRACKER pointer.

--***************************************************************************/
VOID
UlpThreadPoolWorker(
    IN PVOID pContext
    )
{
    //
    // Note: we have very few local variables. Instead, most variables
    // are member variables of pThreadPool. This allows us to inspect the
    // entire state of all the thread pool workers easily in !ulkd.thrdpool.
    //

    PUL_THREAD_TRACKER pThreadTracker = (PUL_THREAD_TRACKER) pContext;
    PUL_THREAD_POOL    pThreadPool    = pThreadTracker->pThreadPool;
    NTSTATUS           Status         = STATUS_SUCCESS;
    PSLIST_ENTRY       pListEntry     = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();
    
    pThreadTracker->State = ThreadPoolInit;

    //
    // Is this a regular work queue?
    //

    if ( pThreadPool->ThreadCpu < (g_UlNumberOfProcessors * 2) )
    {
        KAFFINITY AffinityMask;
        ULONG     ThreadCpu;

        ThreadCpu = pThreadPool->ThreadCpu % g_UlNumberOfProcessors;

        //
        // Only regular worker threads can pull workitems from
        // other regular queues on other processors.
        //

        if (pThreadPool->ThreadCpu < g_UlNumberOfProcessors &&
            g_UlNumberOfProcessors > 1)
        {
            pThreadPool->LookOnOtherQueues = TRUE;
        }

        //
        // Set this thread's hard affinity if enabled plus ideal processor.
        //

        if ( g_UlEnableThreadAffinity )
        {
            AffinityMask = 1U << ThreadCpu;
        }
        else
        {
            AffinityMask = (KAFFINITY) g_UlThreadAffinityMask;
        }

        Status = ZwSetInformationThread(
                    pThreadTracker->ThreadHandle,
                    ThreadAffinityMask,
                    &AffinityMask,
                    sizeof(AffinityMask)
                    );

        ASSERT( NT_SUCCESS( Status ) );

        //
        // Always set thread's ideal processor.
        //

        Status = ZwSetInformationThread(
                    pThreadTracker->ThreadHandle,
                    ThreadIdealProcessor,
                    &ThreadCpu,
                    sizeof(ThreadCpu)
                    );

        ASSERT( NT_SUCCESS( Status ) );
    }

    else if ( pThreadPool == WAIT_THREAD_POOL())
    {
        // no special initialization needed
    }

    else if ( pThreadPool == HIGH_PRIORITY_THREAD_POOL())
    {
        //
        // Boost the base priority of the High Priority thread(s)
        // 

        PKTHREAD CurrentThread = KeGetCurrentThread();
        LONG OldIncrement
            = KeSetBasePriorityThread(CurrentThread, IO_NETWORK_INCREMENT+1);

        UlTrace(WORK_ITEM,
                ("Set base priority of hi-pri thread, %p. Was %d\n",
                 CurrentThread, OldIncrement
                 ));

        UNREFERENCED_PARAMETER( OldIncrement );
    }

    else
    {
        ASSERT(! "Unknown worker thread");
    }

    //
    // Disable hard error popups from IoRaiseHardError(), which can cause
    // deadlocks. Highest-level drivers, particularly file system drivers,
    // call IoRaiseHardError().
    //

    IoSetThreadHardErrorMode( FALSE );

    //
    // Loop forever, or at least until we're told to stop.
    //

    while ( TRUE )
    {
        //
        // Flush the accumulated work items. The inner loop will handle
        // them all.
        //

        pThreadTracker->State = ThreadPoolFlush;

        pListEntry = InterlockedFlushSList( &pThreadPool->WorkQueueSList );

        //
        // If the list is empty, see if we can do work for some other
        // processor. Only the regular worker threads should look for
        // work on the other processors' work queues. We don't want the
        // blocking (wait) queue executing workitems that could block and
        // we don't want the high-priority queue executing regular work
        // items.
        //

        if ( NULL == pListEntry && pThreadPool->LookOnOtherQueues )
        {
            ULONG Cpu;
            ULONG NextCpu;

            ASSERT( pThreadPool->ThreadCpu < g_UlNumberOfProcessors );

            //
            // Try to get a workitem from the other regular queues.
            //

            pThreadTracker->State = ThreadPoolSearchOther;

            NextCpu = pThreadPool->ThreadCpu + 1;

            for (Cpu = 0;  Cpu < g_UlNumberOfProcessors;  Cpu++, NextCpu++)
            {
                PUL_THREAD_POOL pThreadPoolNext;

                if (NextCpu >= g_UlNumberOfProcessors)
                {
                    NextCpu = 0;
                }

                pThreadPoolNext = &g_UlThreadPool[NextCpu].ThreadPool;

                ASSERT( WAIT_THREAD_POOL() != pThreadPoolNext );
                ASSERT( HIGH_PRIORITY_THREAD_POOL() != pThreadPoolNext );
                ASSERT( pThreadPoolNext->ThreadCpu < g_UlNumberOfProcessors );

                //
                // Only take an item if the other processor's work
                // queue has at least g_UlMinWorkDequeueDepth items.
                //

                if ( ExQueryDepthSList( &pThreadPoolNext->WorkQueueSList ) >= 
                     g_UlMinWorkDequeueDepth )
                {
                    pListEntry = InterlockedPopEntrySList(
                                        &pThreadPoolNext->WorkQueueSList
                                        );

                    if ( NULL != pListEntry )
                    {
                        //
                        // Make sure we didn't pop up a killer. If so,
                        // push it back to where it is popped from.
                        //

                        PUL_WORK_ITEM pWorkItem
                            = CONTAINING_RECORD(
                                        pListEntry,
                                        UL_WORK_ITEM,
                                        QueueListEntry
                                        );

                        if (pWorkItem->pWorkRoutine != &UlpKillThreadWorker)
                        {
                            //
                            // Clear next pointer because we only
                            // took one item, not the whole queue
                            //

                            pListEntry->Next = NULL;
                        }
                        else
                        {
                            WRITE_REF_TRACE_LOG(
                                g_pWorkItemTraceLog,
                                REF_ACTION_PUSH_BACK_WORK_ITEM,
                                0,
                                pWorkItem,
                                __FILE__,
                                __LINE__
                                );

                            QUEUE_UL_WORK_ITEM(pThreadPoolNext, pWorkItem);

                            pListEntry = NULL;
                        }

                        break;
                    }
                }
            }
        }

        //
        // No work to be done? Then block until the thread is signaled
        //

        if ( NULL == pListEntry )
        {
            pThreadTracker->State = ThreadPoolBlock;

            KeWaitForSingleObject(
                    &pThreadPool->WorkQueueEvent,
                    Executive,
                    KernelMode,
                    FALSE,
                    0
                    );

            // back to the top of the outer loop
            continue;
        }

        ASSERT( NULL != pListEntry );

        //
        // Initialize CurrentListHead to reverse the order of items
        // from InterlockedFlushSList. The SList is a stack. Reversing
        // a stack gives us a queue; i.e., we'll execute the work
        // items in the order they were received.
        //

        pThreadTracker->State = ThreadPoolReverseList;

        pThreadTracker->CurrentListHead.Next = NULL;
        pThreadTracker->ListLength = 0;

        //
        // Rebuild the list with reverse order of what we received.
        //

        while ( pListEntry != NULL )
        {
            PSLIST_ENTRY pNext;

            WRITE_REF_TRACE_LOG(
                g_pWorkItemTraceLog,
                REF_ACTION_FLUSH_WORK_ITEM,
                0,
                pListEntry,
                __FILE__,
                __LINE__
                );

            pNext = pListEntry->Next;
            pListEntry->Next = pThreadTracker->CurrentListHead.Next;
            pThreadTracker->CurrentListHead.Next = pListEntry;

            ++pThreadTracker->ListLength;
            pListEntry = pNext;
        }

        //
        // Update per-pool statistics
        //

        pThreadTracker->QueueFlushes    += 1;
        pThreadTracker->SumQueueLengths += pThreadTracker->ListLength;
        pThreadTracker->MaxQueueLength   = max(pThreadTracker->ListLength,
                                               pThreadTracker->MaxQueueLength);

        //
        // We can now process the work items in the order that they
        // were received
        //

        pThreadTracker->State = ThreadPoolExecute;

        while (NULL != ( pListEntry = pThreadTracker->CurrentListHead.Next ))
        {
            --pThreadTracker->ListLength;

            pThreadTracker->CurrentListHead.Next = pListEntry->Next;

            pThreadTracker->pWorkItem
                = CONTAINING_RECORD(
                            pListEntry,
                            UL_WORK_ITEM,
                            QueueListEntry
                            );

            WRITE_REF_TRACE_LOG(
                g_pWorkItemTraceLog,
                REF_ACTION_PROCESS_WORK_ITEM,
                0,
                pThreadTracker->pWorkItem,
                __FILE__,
                __LINE__
                );

            //
            // Call the actual work item routine.
            //

            ASSERT( pThreadTracker->pWorkItem->pWorkRoutine != NULL );

            if ( pThreadTracker->pWorkItem->pWorkRoutine
                 == &UlpKillThreadWorker )
            {
                //
                // Received a special signal for self-termination.
                // Push all remaining work items back to the queue
                // before we exit the current thread. This is necessary
                // when we have more than one worker thread per thread pool.
                // Each thread needs to be given a chance to pick up one
                // killer work item, but each thread greedily picks up
                // all of the unhandled work items. Pushing back any
                // remaining work items ensures that all threads in this
                // thread pool will get killed.
                //

                while (NULL != ( pListEntry
                                    = pThreadTracker->CurrentListHead.Next ))
                {
                    pThreadTracker->CurrentListHead.Next = pListEntry->Next;

                    pThreadTracker->pWorkItem
                        = CONTAINING_RECORD(
                                    pListEntry,
                                    UL_WORK_ITEM,
                                    QueueListEntry
                                    );

                    ASSERT( pThreadTracker->pWorkItem->pWorkRoutine
                            == &UlpKillThreadWorker );

                    WRITE_REF_TRACE_LOG(
                        g_pWorkItemTraceLog,
                        REF_ACTION_PUSH_BACK_WORK_ITEM,
                        0,
                        pThreadTracker->pWorkItem,
                        __FILE__,
                        __LINE__
                        );

                    QUEUE_UL_WORK_ITEM(
                        pThreadPool,
                        pThreadTracker->pWorkItem
                        );
                }

                goto exit;
            }

            //
            // Regular workitem. Use the UL_ENTER_DRIVER debug
            // stuff to keep track of ERESOURCES acquired, etc,
            // while executing the workitem.
            //

            UL_ENTER_DRIVER( "UlpThreadPoolWorker", NULL );

            //
            // Clear the workitem as an indication that this item has
            // started processing. Must do this before calling the
            // routine, as the routine may destroy the work item or queue
            // it again. Also, this means that callers need only
            // explicitly initialize a workitem struct once, when the
            // enclosing object is first allocated.
            //

            pThreadTracker->pWorkRoutine
                = pThreadTracker->pWorkItem->pWorkRoutine;

            UlInitializeWorkItem(pThreadTracker->pWorkItem);

            (*pThreadTracker->pWorkRoutine)(
                pThreadTracker->pWorkItem
                );

            UL_LEAVE_DRIVER( "UlpThreadPoolWorker" );

            //
            // Sanity check
            //

            PAGED_CODE();

            ++pThreadTracker->Executions;
            pThreadTracker->pWorkRoutine = NULL;
            pThreadTracker->pWorkItem = NULL;
        }
    } // while (TRUE)

exit:

    pThreadTracker->State = ThreadPoolTerminated;

    //
    // Suicide is painless.
    //

    PsTerminateSystemThread( STATUS_SUCCESS );

}   // UlpThreadPoolWorker


/***************************************************************************++

Routine Description:

    Initializes a new thread tracker and inserts it into the thread pool.

Arguments:

    pThreadPool - Supplies the thread pool to own the new tracker.

    pThread - Supplies the thread for the tracker.

    pThreadTracker - Supplise the tracker to be initialized

--***************************************************************************/
VOID
UlpInitThreadTracker(
    IN PUL_THREAD_POOL pThreadPool,
    IN PETHREAD pThread,
    IN PUL_THREAD_TRACKER pThreadTracker
    )
{
    KIRQL oldIrql;

    ASSERT( pThreadPool != NULL );
    ASSERT( pThread != NULL );
    ASSERT( pThreadTracker != NULL );

    pThreadTracker->pThread = pThread;

    UlAcquireSpinLock( &pThreadPool->ThreadSpinLock, &oldIrql );

    InsertTailList(
        &pThreadPool->ThreadListHead,
        &pThreadTracker->ThreadListEntry
        );

    UlReleaseSpinLock( &pThreadPool->ThreadSpinLock, oldIrql );

}   // UlpInitThreadTracker


/***************************************************************************++

Routine Description:

    Removes the specified thread tracker from the thread pool.

Arguments:

    pThreadPool - Supplies the thread pool that owns the tracker.

    pThreadTracker - Supplies the thread tracker to remove.

Return Value:

    None

--***************************************************************************/
VOID
UlpDestroyThreadTracker(
    IN PUL_THREAD_TRACKER pThreadTracker
    )
{
    //
    // Sanity check.
    //

    ASSERT( pThreadTracker != NULL );

    //
    // Wait for the thread to die.
    //

    KeWaitForSingleObject(
        (PVOID)pThreadTracker->pThread,     // Object
        UserRequest,                        // WaitReason
        KernelMode,                         // WaitMode
        FALSE,                              // Alertable
        NULL                                // Timeout
        );

    //
    // Cleanup.
    //

    ObDereferenceObject( pThreadTracker->pThread );

    
    //
    // Release the thread handle.
    //
    
    ZwClose( pThreadTracker->ThreadHandle );

    //
    // Do it.
    //

    UL_FREE_POOL(
        pThreadTracker,
        UL_THREAD_TRACKER_POOL_TAG
        );

}   // UlpDestroyThreadTracker


/***************************************************************************++

Routine Description:

    Removes a thread tracker from the thread pool.

Arguments:

    pThreadPool - Supplies the thread pool that owns the tracker.

Return Value:

    A pointer to the tracker or NULL (if list is empty)

--***************************************************************************/
PUL_THREAD_TRACKER
UlpPopThreadTracker(
    IN PUL_THREAD_POOL pThreadPool
    )
{
    PLIST_ENTRY pEntry;
    PUL_THREAD_TRACKER pThreadTracker;
    KIRQL oldIrql;

    ASSERT( pThreadPool != NULL );
    ASSERT( pThreadPool->Initialized );

    UlAcquireSpinLock( &pThreadPool->ThreadSpinLock, &oldIrql );

    if (IsListEmpty(&pThreadPool->ThreadListHead))
    {
        pThreadTracker = NULL;
    }
    else
    {
        pEntry = RemoveHeadList(&pThreadPool->ThreadListHead);
        pThreadTracker = CONTAINING_RECORD(
                                pEntry,
                                UL_THREAD_TRACKER,
                                ThreadListEntry
                                );
    }

    UlReleaseSpinLock( &pThreadPool->ThreadSpinLock, oldIrql );

    return pThreadTracker;

}   // UlpPopThreadTracker


/***************************************************************************++

Routine Description:

    A dummy function to indicate that the thread should be terminated.

Arguments:

    pWorkItem - Supplies the dummy work item.

Return Value:

    None

--***************************************************************************/
VOID
UlpKillThreadWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    UNREFERENCED_PARAMETER( pWorkItem );

    return;

}   // UlpKillThreadWorker


/***************************************************************************++

Routine Description:

    A function that queues a worker item to a thread pool.

Arguments:

    pWorkItem - Supplies the work item.

    pWorkRoutine - Supplies the work routine.

Return Value:

    None

--***************************************************************************/
VOID
UlQueueWorkItem(
    IN PUL_WORK_ITEM    pWorkItem,
    IN PUL_WORK_ROUTINE pWorkRoutine,
    IN PCSTR            pFileName,
    IN USHORT           LineNumber
    )
{
    PUL_THREAD_POOL pThreadPool;
    CLONG Cpu, NextCpu;

    //
    // Sanity check.
    //

    ASSERT( pWorkItem != NULL );
    ASSERT( pWorkRoutine != NULL );

    WRITE_REF_TRACE_LOG(
        g_pWorkItemTraceLog,
        REF_ACTION_QUEUE_WORK_ITEM,
        0,
        pWorkItem,
        pFileName,
        LineNumber
        );

    UlpValidateWorkItem(pWorkItem, pFileName, LineNumber);

    //
    // Save the pointer to the worker routine, then queue the item.
    //

    pWorkItem->pWorkRoutine = pWorkRoutine;

    //
    // Queue the work item on the idle processor if possible.
    //

    NextCpu = KeGetCurrentProcessorNumber();

    for (Cpu = 0; Cpu < g_UlNumberOfProcessors; Cpu++, NextCpu++)
    {
        if (NextCpu >= g_UlNumberOfProcessors)
        {
            NextCpu = 0;
        }

        pThreadPool = &g_UlThreadPool[NextCpu].ThreadPool;

        ASSERT(WAIT_THREAD_POOL() != pThreadPool);
        ASSERT(HIGH_PRIORITY_THREAD_POOL() != pThreadPool);

        if (ExQueryDepthSList(&pThreadPool->WorkQueueSList) <= 
            g_UlMaxWorkQueueDepth)
        {
            QUEUE_UL_WORK_ITEM( pThreadPool, pWorkItem );
            return;
        }
    }

    //
    // Queue the work item on the current thread pool.
    //

    pThreadPool = CURRENT_THREAD_POOL();
    QUEUE_UL_WORK_ITEM( pThreadPool, pWorkItem );

}   // UlQueueWorkItem


/***************************************************************************++

Routine Description:

    A function that queues a worker item that involves sync I/O to a special
    thread pool.

Arguments:

    pWorkItem - Supplies the work item.

    pWorkRoutine - Supplies the work routine.

Return Value:

    None

--***************************************************************************/
VOID
UlQueueSyncItem(
    IN PUL_WORK_ITEM    pWorkItem,
    IN PUL_WORK_ROUTINE pWorkRoutine,
    IN PCSTR            pFileName,
    IN USHORT           LineNumber
    )
{
    PUL_THREAD_POOL pThreadPool;

    //
    // Sanity check.
    //

    ASSERT( pWorkItem != NULL );
    ASSERT( pWorkRoutine != NULL );

    WRITE_REF_TRACE_LOG(
        g_pWorkItemTraceLog,
        REF_ACTION_QUEUE_SYNC_ITEM,
        0,
        pWorkItem,
        pFileName,
        LineNumber
        );

    UlpValidateWorkItem(pWorkItem, pFileName, LineNumber);

    //
    // Save the pointer to the worker routine, then queue the item.
    //

    pWorkItem->pWorkRoutine = pWorkRoutine;

    //
    // Queue the work item on the special wait thread pool.
    //

    pThreadPool = CURRENT_SYNC_THREAD_POOL();
    QUEUE_UL_WORK_ITEM( pThreadPool, pWorkItem );

}   // UlQueueSyncItem


/***************************************************************************++

Routine Description:

    A function that queues a blocking worker item to a special thread pool.

Arguments:

    pWorkItem - Supplies the work item.

    pWorkRoutine - Supplies the work routine.

Return Value:

    None

--***************************************************************************/
VOID
UlQueueWaitItem(
    IN PUL_WORK_ITEM    pWorkItem,
    IN PUL_WORK_ROUTINE pWorkRoutine,
    IN PCSTR            pFileName,
    IN USHORT           LineNumber
    )
{
    PUL_THREAD_POOL pThreadPool;

    //
    // Sanity check.
    //

    ASSERT( pWorkItem != NULL );
    ASSERT( pWorkRoutine != NULL );

    WRITE_REF_TRACE_LOG(
        g_pWorkItemTraceLog,
        REF_ACTION_QUEUE_WAIT_ITEM,
        0,
        pWorkItem,
        pFileName,
        LineNumber
        );

    UlpValidateWorkItem(pWorkItem, pFileName, LineNumber);

    //
    // Save the pointer to the worker routine, then queue the item.
    //

    pWorkItem->pWorkRoutine = pWorkRoutine;

    //
    // Queue the work item on the special wait thread pool.
    //

    pThreadPool = WAIT_THREAD_POOL();
    QUEUE_UL_WORK_ITEM( pThreadPool, pWorkItem );

}   // UlQueueWaitItem


/***************************************************************************++

Routine Description:

    A function that queues a blocking worker item to the high-priority
    thread pool.

Arguments:

    pWorkItem - Supplies the work item.

    pWorkRoutine - Supplies the work routine.

Return Value:

    None

--***************************************************************************/
VOID
UlQueueHighPriorityItem(
    IN PUL_WORK_ITEM    pWorkItem,
    IN PUL_WORK_ROUTINE pWorkRoutine,
    IN PCSTR            pFileName,
    IN USHORT           LineNumber
    )
{
    PUL_THREAD_POOL pThreadPool;

    //
    // Sanity check.
    //

    ASSERT( pWorkItem != NULL );
    ASSERT( pWorkRoutine != NULL );

    WRITE_REF_TRACE_LOG(
        g_pWorkItemTraceLog,
        REF_ACTION_QUEUE_HIGH_PRIORITY_ITEM,
        0,
        pWorkItem,
        pFileName,
        LineNumber
        );

    UlpValidateWorkItem(pWorkItem, pFileName, LineNumber);

    //
    // Save the pointer to the worker routine, then queue the item.
    //

    pWorkItem->pWorkRoutine = pWorkRoutine;

    //
    // Queue the work item on the special wait thread pool.
    //

    pThreadPool = HIGH_PRIORITY_THREAD_POOL();
    QUEUE_UL_WORK_ITEM( pThreadPool, pWorkItem );

} // UlQueueHighPriorityItem


/***************************************************************************++

Routine Description:

    A function that either queues a worker item to a thread pool if the
    caller is at DISPATCH_LEVEL/APC_LEVEL or it simply calls the work
    routine directly.

    Note: if the work item has to execute on a system thread, then
    you must use UL_QUEUE_WORK_ITEM instead.

Arguments:

    pWorkItem - Supplies the work item.

    pWorkRoutine - Supplies the work routine.

Return Value:

    None

--***************************************************************************/
VOID
UlCallPassive(
    IN PUL_WORK_ITEM    pWorkItem,
    IN PUL_WORK_ROUTINE pWorkRoutine,
    IN PCSTR            pFileName,
    IN USHORT           LineNumber
    )
{
    //
    // Sanity check.
    //

    ASSERT( pWorkItem != NULL );
    ASSERT( pWorkRoutine != NULL );

    WRITE_REF_TRACE_LOG(
        g_pWorkItemTraceLog,
        REF_ACTION_CALL_PASSIVE,
        0,
        pWorkItem,
        pFileName,
        LineNumber
        );

    UlpValidateWorkItem(pWorkItem, pFileName, LineNumber);

    if (KeGetCurrentIrql() == PASSIVE_LEVEL)
    {
        //
        // Clear this for consistency with UlpThreadPoolWorker.
        //

        UlInitializeWorkItem(pWorkItem);

        (*pWorkRoutine)(pWorkItem);
    }
    else
    {
        UL_QUEUE_WORK_ITEM(pWorkItem, pWorkRoutine);
    }

}   // UlCallPassive


/***************************************************************************++

Routine Description:

    Queries the "IRP thread", the special worker thread used as the
    target for all asynchronous IRPs.

Arguments:

    None

Return Value:

    None

--***************************************************************************/
PETHREAD
UlQueryIrpThread(
    VOID
    )
{
    PUL_THREAD_POOL pThreadPool;

    //
    // Sanity check.
    //

    pThreadPool = CURRENT_THREAD_POOL();
    ASSERT( pThreadPool->Initialized );

    //
    // Return the IRP thread.
    //

    return pThreadPool->pIrpThread;

}   // UlQueryIrpThread
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\timetrace.c ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    timetrace.c

Abstract:

    This module implements a request timing tracing facility.

Author:

    Michael Courage (mcourage)  8-Mar-2000

Revision History:

--*/


#include "precomp.h"


#if !ENABLE_TIME_TRACE

static int g_TimeTraceDummyDeclarationToKeepW4WarningsQuiet;

#else

#pragma warning( disable : 4035 )           // Warning : No return value
#pragma warning( disable : 4142 )           // Warning : benign redefinition of type
__inline ULONGLONG RDTSC( VOID )
{
#if defined(_X86_)
    __asm __emit 0x0F __asm __emit 0xA2     // CPUID (memory barrier)
    __asm __emit 0x0F __asm __emit 0x31     // RDTSC
#else
    return 0;
#endif
}
#pragma warning( default : 4035 )
#pragma warning( default : 4142 )


/***************************************************************************++

Routine Description:

    Creates a new (empty) time trace log buffer.

Arguments:

    LogSize - Supplies the number of entries in the log.

    ExtraBytesInHeader - Supplies the number of extra bytes to include
        in the log header. This is useful for adding application-
        specific data to the log.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--***************************************************************************/
PTRACE_LOG
CreateTimeTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    )
{
    return CreateTraceLog(
               TIME_TRACE_LOG_SIGNATURE,
               LogSize,
               ExtraBytesInHeader,
               sizeof(TIME_TRACE_LOG_ENTRY),
               TRACELOG_HIGH_PRIORITY,
               UL_REF_TRACE_LOG_POOL_TAG
               );

}   // CreateTimeTraceLog


/***************************************************************************++

Routine Description:

    Destroys a time trace log buffer created with CreateTimeTraceLog().

Arguments:

    pLog - Supplies the time trace log buffer to destroy.

--***************************************************************************/
VOID
DestroyTimeTraceLog(
    IN PTRACE_LOG pLog
    )
{
    DestroyTraceLog( pLog, UL_REF_TRACE_LOG_POOL_TAG );

}   // DestroyTimeTraceLog


/***************************************************************************++

Routine Description:

    Writes a new entry to the specified time trace log.

Arguments:

    pLog - Supplies the log to write to.

    ConnectionId - the id of the connection we're tracing

    RequestId - the id of the request we're tracing

    Action - Supplies an action code for the new log entry.


--***************************************************************************/
VOID
WriteTimeTraceLog(
    IN PTRACE_LOG pLog,
    IN HTTP_CONNECTION_ID ConnectionId,
    IN HTTP_REQUEST_ID RequestId,
    IN USHORT Action
    )
{
    TIME_TRACE_LOG_ENTRY entry;

    //
    // Initialize the entry.
    //
//    entry.TimeStamp = KeQueryInterruptTime();
    entry.TimeStamp = RDTSC();
    entry.ConnectionId = ConnectionId;
    entry.RequestId = RequestId;
    entry.Action = Action;
    entry.Processor = (USHORT)KeGetCurrentProcessorNumber();

    //
    // Write it to the logs.
    //

    WriteTraceLog( pLog, &entry );

}   // WriteTimeTraceLog

#endif  // ENABLE_TIME_TRACE

#if ENABLE_APP_POOL_TIME_TRACE

/***************************************************************************++

Routine Description:

    Creates a new (empty) time trace log buffer.

Arguments:

    LogSize - Supplies the number of entries in the log.

    ExtraBytesInHeader - Supplies the number of extra bytes to include
        in the log header. This is useful for adding application-
        specific data to the log.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--***************************************************************************/
PTRACE_LOG
CreateAppPoolTimeTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    )
{
    return 
        CreateTraceLog(
           APP_POOL_TIME_TRACE_LOG_SIGNATURE,
           LogSize,
           ExtraBytesInHeader,
           sizeof(APP_POOL_TIME_TRACE_LOG_ENTRY),
           TRACELOG_HIGH_PRIORITY,
           UL_REF_TRACE_LOG_POOL_TAG
           );

}   // CreateTimeTraceLog


/***************************************************************************++

Routine Description:

    Destroys a time trace log buffer created with CreateTimeTraceLog().

Arguments:

    pLog - Supplies the time trace log buffer to destroy.

--***************************************************************************/
VOID
DestroyAppPoolTimeTraceLog(
    IN PTRACE_LOG pLog
    )
{
    DestroyTraceLog( pLog, UL_REF_TRACE_LOG_POOL_TAG );

}   // DestroyTimeTraceLog


/***************************************************************************++

Routine Description:

    Writes a new entry to the specified time trace log.

Arguments:

    pLog - Supplies the log to write to.

    - App Pool

    - App Pool Process
    
    Action - Supplies an action code for the new log entry.


--***************************************************************************/
VOID
WriteAppPoolTimeTraceLog(
    IN PTRACE_LOG       pLog,
    IN PVOID            Context1,   // Appool
    IN PVOID            Context2,   // Appool Process
    IN USHORT           Action
    )
{
    APP_POOL_TIME_TRACE_LOG_ENTRY entry;

    //
    // Initialize the entry.
    //
    
    entry.TimeStamp     = KeQueryInterruptTime();
    entry.Context1      = Context1;
    entry.Context2      = Context2;
    entry.Action        = Action;
    entry.Processor     = (USHORT)KeGetCurrentProcessorNumber();

    //
    // Write it to the logs.
    //

    WriteTraceLog( pLog, &entry );

}   // WriteTimeTraceLog

#endif  // ENABLE_APP_POOL_TIME_TRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\thrdpool.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    thrdpool.h

Abstract:

    This module contains public declarations for the thread pool package.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _THRDPOOL_H_
#define _THRDPOOL_H_


//
// Pointer to a thread pool worker function.
//

typedef union _UL_WORK_ITEM *PUL_WORK_ITEM;

typedef
VOID
(*PUL_WORK_ROUTINE)(
    IN PUL_WORK_ITEM pWorkItem
    );


//
// A work item. A work item may only appear on the work queue once.
//

typedef union _UL_WORK_ITEM
{
    DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) ULONGLONG Alignment;

    struct
    {
        SLIST_ENTRY         QueueListEntry; // Next pointer
        PUL_WORK_ROUTINE    pWorkRoutine;   // Callback routine
    };

} UL_WORK_ITEM, *PUL_WORK_ITEM;

//
// We have to be sure that the DriverContext (PVOID [4]) in the IRP is
// big enough to hold both the process pointer and a UL_WORK_ITEM.
//

C_ASSERT(FIELD_OFFSET(UL_WORK_ITEM, pWorkRoutine)
            <= (4 - 2) * sizeof(PVOID));

//
// Public functions.
//

NTSTATUS
UlInitializeThreadPool(
    IN USHORT ThreadsPerCpu
    );

VOID
UlTerminateThreadPool(
    VOID
    );

//
// One-time initialization of a UL_WORK_ITEM. Note that UlpThreadPoolWorker
// will reinitialize the workitem just before calling pWorkRoutine(), so
// this only needs to be done when the UL_WORK_ITEM (or enclosing struct)
// is first created. We need this so that we can check that a workitem is
// not being queued when it is already on the queue---a catastrophic error.
//

#if DBG
// Use non-zero values to ensure that item is properly initialized
// and not just zero by coincidence
# define WORK_ITEM_INIT_LIST_ENTRY ((PSLIST_ENTRY)     0xda7a)
# define WORK_ITEM_INIT_ROUTINE    ((PUL_WORK_ROUTINE) 0xc0de)
#else
// Use zero for efficiency
# define WORK_ITEM_INIT_LIST_ENTRY NULL
# define WORK_ITEM_INIT_ROUTINE    NULL
#endif

__inline
VOID
UlInitializeWorkItem(
    IN PUL_WORK_ITEM pWorkItem)
{
    pWorkItem->QueueListEntry.Next = WORK_ITEM_INIT_LIST_ENTRY;
    pWorkItem->pWorkRoutine        = WORK_ITEM_INIT_ROUTINE;
}

__inline
BOOLEAN
UlIsInitializedWorkItem(
    IN PUL_WORK_ITEM pWorkItem)
{
    return (BOOLEAN)(WORK_ITEM_INIT_LIST_ENTRY == pWorkItem->QueueListEntry.Next
            && WORK_ITEM_INIT_ROUTINE == pWorkItem->pWorkRoutine);
}

VOID
UlQueueWorkItem(
    IN PUL_WORK_ITEM    pWorkItem,
    IN PUL_WORK_ROUTINE pWorkRoutine,
    IN PCSTR            pFileName,
    IN USHORT           LineNumber
    );

#define UL_QUEUE_WORK_ITEM( pWorkItem, pWorkRoutine )                   \
    UlQueueWorkItem(                                                    \
        pWorkItem,                                                      \
        pWorkRoutine,                                                   \
        __FILE__, (USHORT) __LINE__                                     \
        )

//
// Store a WORK_ITEM inside IRP::Tail.Overlay.DriverContext (array of 4 PVOIDs)
// Ensure that it's correctly aligned for the platform
//

#ifdef _WIN64

// DriverContext[1] is 16-byte aligned

C_ASSERT(((1 * sizeof(PVOID) + FIELD_OFFSET(IRP, Tail.Overlay.DriverContext))
            & (MEMORY_ALLOCATION_ALIGNMENT - 1)
          ) == 0);

#define UL_PROCESS_FROM_IRP( _irp )                                     \
        (*(PEPROCESS*)&((_irp)->Tail.Overlay.DriverContext[0]))

#define UL_MDL_FROM_IRP( _irp )                                         \
        (*(PMDL*)&((_irp)->Tail.Overlay.DriverContext[0]))

#define UL_WORK_ITEM_FROM_IRP( _irp )                                   \
        (PUL_WORK_ITEM)&((_irp)->Tail.Overlay.DriverContext[1])

#define UL_WORK_ITEM_TO_IRP( _workItem )                                \
        CONTAINING_RECORD( (_workItem), IRP, Tail.Overlay.DriverContext[1])

#else // !_WIN64

// DriverContext[0] is 8-byte aligned

C_ASSERT(((0 * sizeof(PVOID) + FIELD_OFFSET(IRP, Tail.Overlay.DriverContext))
            & (MEMORY_ALLOCATION_ALIGNMENT - 1)
          ) == 0);

#define UL_PROCESS_FROM_IRP( _irp )                                     \
        (*(PEPROCESS*)&((_irp)->Tail.Overlay.DriverContext[3]))

#define UL_MDL_FROM_IRP( _irp )                                         \
        (*(PMDL*)&((_irp)->Tail.Overlay.DriverContext[3]))

#define UL_WORK_ITEM_FROM_IRP( _irp )                                   \
        (PUL_WORK_ITEM)&((_irp)->Tail.Overlay.DriverContext[0])

#define UL_WORK_ITEM_TO_IRP( _workItem )                                \
        CONTAINING_RECORD( (_workItem), IRP, Tail.Overlay.DriverContext[0])

#endif // !_WIN64

VOID
UlQueueSyncItem(
    IN PUL_WORK_ITEM    pWorkItem,
    IN PUL_WORK_ROUTINE pWorkRoutine,
    IN PCSTR            pFileName,
    IN USHORT           LineNumber
    );

#define UL_QUEUE_SYNC_ITEM( pWorkItem, pWorkRoutine )                   \
    UlQueueSyncItem(                                                    \
        pWorkItem,                                                      \
        pWorkRoutine,                                                   \
        __FILE__, __LINE__                                              \
        )

VOID
UlQueueWaitItem(
    IN PUL_WORK_ITEM    pWorkItem,
    IN PUL_WORK_ROUTINE pWorkRoutine,
    IN PCSTR            pFileName,
    IN USHORT           LineNumber
    );

#define UL_QUEUE_WAIT_ITEM( pWorkItem, pWorkRoutine )                   \
    UlQueueWaitItem(                                                    \
        pWorkItem,                                                      \
        pWorkRoutine,                                                   \
        __FILE__, __LINE__                                              \
        )

VOID
UlQueueHighPriorityItem(
    IN PUL_WORK_ITEM    pWorkItem,
    IN PUL_WORK_ROUTINE pWorkRoutine,
    IN PCSTR            pFileName,
    IN USHORT           LineNumber
    );

#define UL_QUEUE_HIGH_PRIORITY_ITEM( pWorkItem, pWorkRoutine )          \
    UlQueueHighPriorityItem(                                            \
        pWorkItem,                                                      \
        pWorkRoutine,                                                   \
        __FILE__, __LINE__                                              \
        )

VOID
UlCallPassive(
    IN PUL_WORK_ITEM    pWorkItem,
    IN PUL_WORK_ROUTINE pWorkRoutine,
    IN PCSTR            pFileName,
    IN USHORT           LineNumber
    );

#define UL_CALL_PASSIVE( pWorkItem, pWorkRoutine )                      \
    UlCallPassive(                                                      \
        pWorkItem,                                                      \
        pWorkRoutine,                                                   \
        __FILE__, __LINE__                                              \
        )

PETHREAD
UlQueryIrpThread(
    VOID
    );


#endif  // _THRDPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\timetrace.h ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    timetrace.h

Abstract:

    This module contains public declarations and definitions for tracing
    and debugging the timing of request processing.

Author:

    Michael Courage (mcourage)  8-Mar-2000

Revision History:

--*/


#ifndef _TIMETRACE_H_
#define _TIMETRACE_H_


//
// This defines the entry written to the trace log.
//

typedef struct _TIME_TRACE_LOG_ENTRY
{
    ULONGLONG               TimeStamp;
    HTTP_CONNECTION_ID      ConnectionId;
    HTTP_REQUEST_ID         RequestId;
    USHORT                  Action;
    USHORT                  Processor;

} TIME_TRACE_LOG_ENTRY, *PTIME_TRACE_LOG_ENTRY;


//
// Action codes.
//
// N.B. These codes must be contiguous, starting at zero. If you update
//      this list, you must also update the corresponding array in
//      ul\ulkd\time.c.
//

#define TIME_ACTION_CREATE_CONNECTION               0
#define TIME_ACTION_CREATE_REQUEST                  1
#define TIME_ACTION_ROUTE_REQUEST                   2
#define TIME_ACTION_COPY_REQUEST                    3
#define TIME_ACTION_SEND_RESPONSE                   4
#define TIME_ACTION_SEND_COMPLETE                   5

#define TIME_ACTION_COUNT                           6

#define TIME_TRACE_LOG_SIGNATURE   MAKE_SIGNATURE('TmLg')

//
// Manipulators.
//

PTRACE_LOG
CreateTimeTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    );

VOID
DestroyTimeTraceLog(
    IN PTRACE_LOG pLog
    );

VOID
WriteTimeTraceLog(
    IN PTRACE_LOG pLog,
    IN HTTP_CONNECTION_ID ConnectionId,
    IN HTTP_REQUEST_ID RequestId,
    IN USHORT Action
    );


#if ENABLE_TIME_TRACE

#define CREATE_TIME_TRACE_LOG( ptr, size, extra )                           \
    (ptr) = CreateTimeTraceLog( (size), (extra) )

#define DESTROY_TIME_TRACE_LOG( ptr )                                       \
    do                                                                      \
    {                                                                       \
        DestroyTimeTraceLog( ptr );                                         \
        (ptr) = NULL;                                                       \
    } while (FALSE, FALSE)

#define WRITE_TIME_TRACE_LOG( plog, cid, rid, act )                         \
    WriteTimeTraceLog(                                                      \
        (plog),                                                             \
        (cid),                                                              \
        (rid),                                                              \
        (act)                                                               \
        )

#else   // !ENABLE_TIME_TRACE

#define CREATE_TIME_TRACE_LOG( ptr, size, extra )       NOP_FUNCTION
#define DESTROY_TIME_TRACE_LOG( ptr )                   NOP_FUNCTION
#define WRITE_TIME_TRACE_LOG( plog, cid, rid, act )     NOP_FUNCTION

#endif  // ENABLE_TIME_TRACE

#define TRACE_TIME( cid, rid, act )                                         \
    WRITE_TIME_TRACE_LOG(                                                   \
        g_pTimeTraceLog,                                                    \
        (cid),                                                              \
        (rid),                                                              \
        (act)                                                               \
        )


//
// This defines the entry written to the appool time trace log.
//

typedef struct _APP_POOL_TIME_TRACE_LOG_ENTRY
{
    ULONGLONG TimeStamp;    
    PVOID     Context1;     // For PUL_APP_POOL_OBJECT
    PVOID     Context2;     // For PUL_APP_POOL_PROCESS    
    USHORT    Action;       // One of the below
    USHORT    Processor;    

} APP_POOL_TIME_TRACE_LOG_ENTRY, *PAPP_POOL_TIME_TRACE_LOG_ENTRY;

//
// Action codes.
//
// N.B. Do not forget to update !ulkd.atimelog if you update this.
//

#define APP_POOL_TIME_ACTION_CREATE_APPOOL            0
#define APP_POOL_TIME_ACTION_MARK_APPOOL_ACTIVE       1
#define APP_POOL_TIME_ACTION_MARK_APPOOL_INACTIVE     2
#define APP_POOL_TIME_ACTION_CREATE_PROCESS           3
#define APP_POOL_TIME_ACTION_DETACH_PROCESS           4
#define APP_POOL_TIME_ACTION_DETACH_PROCESS_COMPLETE  5
#define APP_POOL_TIME_ACTION_DESTROY_APPOOL           6
#define APP_POOL_TIME_ACTION_DESTROY_APPOOL_PROCESS   7
#define APP_POOL_TIME_ACTION_LOAD_BAL_CAPABILITY      8

#define APP_POOL_TIME_ACTION_COUNT                    9

#define APP_POOL_TIME_TRACE_LOG_SIGNATURE   MAKE_SIGNATURE('TaLg')

//
// Manipulators.
//

PTRACE_LOG
CreateAppPoolTimeTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    );

VOID
DestroyAppPoolTimeTraceLog(
    IN PTRACE_LOG pLog
    );

VOID
WriteAppPoolTimeTraceLog(
    IN PTRACE_LOG   pLog,
    IN PVOID        Context1,
    IN PVOID        Context2,
    IN USHORT       Action
    );

#if ENABLE_APP_POOL_TIME_TRACE

#define CREATE_APP_POOL_TIME_TRACE_LOG( ptr, size, extra )              \
    (ptr) = CreateAppPoolTimeTraceLog( (size), (extra) )

#define DESTROY_APP_POOL_TIME_TRACE_LOG( ptr )                          \
    do                                                                  \
    {                                                                   \
        DestroyAppPoolTimeTraceLog( ptr );                              \
        (ptr) = NULL;                                                   \
    } while (FALSE, FALSE)

#define WRITE_APP_POOL_TIME_TRACE_LOG( c1, c2, act )                     \
    WriteAppPoolTimeTraceLog(                                           \
        (g_pAppPoolTimeTraceLog),                                       \
        (c1),                                                           \
        (c2),                                                           \
        (act)                                                           \
        )

#else   // !ENABLE_APP_POOL_TIME_TRACE

#define CREATE_APP_POOL_TIME_TRACE_LOG( ptr, size, extra )  NOP_FUNCTION
#define DESTROY_APP_POOL_TIME_TRACE_LOG( ptr )              NOP_FUNCTION
#define WRITE_APP_POOL_TIME_TRACE_LOG( c1, c2, act )        NOP_FUNCTION

#endif  // ENABLE_APP_POOL_TIME_TRACE


#endif  // _TIMETRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\timeouts.c ===
/*++

Copyright (c) 2001-2002 Microsoft Corporation

Module Name:

    timeouts.c

Abstract:

    Implement connection timeout quality-of-service (QoS) functionality.

    The following timers must be monitored during the lifetime of
    a connection:

    * Connection Timeout
    * Header Wait Timeout
    * Entity Body Receive Timeout
    * Response Processing Timeout
    * Minimum Bandwidth (implemented as a Timeout)

    When any one of these timeout values expires, the connection should be
    terminated.

    The timer information is maintained in a timeout info block,
    UL_TIMEOUT_INFO_ENTRY, as part of the UL_HTTP_CONNECTION object.

    A timer can be Set or Reset.  Setting a timer calculates when the specific
    timer should expire, and updates the timeout info block. Resetting a timer
    turns a specific timer off.  Both Setting and Resetting a timer will cause
    the timeout block to be re-evaluated to find the least valued expiry time.

    // TODO:
    The timeout manager uses a Timer Wheel(c) technology, as used
    by NT's TCP/IP stack for monitoring TCB timeouts.  We will reimplement
    and modify the logic they use.  The linkage for the Timer Wheel(c)
    queues is provided in the timeout info block.

    // TODO: CONVERT TO USING Timer Wheel Ticks instead of SystemTime.
    There are three separate units of time: SystemTime (100ns intervals), Timer
    Wheel Ticks (SystemTime / slot interval length), and Timer Wheel Slot 
    (Timer Wheel Ticks modulo the number of slots in the Timer Wheel).

Author:

    Eric Stenson (EricSten)     24-Mar-2001

Revision History:

    This was originally implemented as the Connection Timeout Monitor.

--*/

#include "precomp.h"
#include "timeoutsp.h"

//
// Private globals.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeTimeoutMonitor )
#pragma alloc_text( PAGE, UlTerminateTimeoutMonitor )
#pragma alloc_text( PAGE, UlSetTimeoutMonitorInformation )
#pragma alloc_text( PAGE, UlpTimeoutMonitorWorker )
#pragma alloc_text( PAGE, UlSetPerSiteConnectionTimeoutValue )
#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlpSetTimeoutMonitorTimer
NOT PAGEABLE -- UlpTimeoutMonitorDpcRoutine
NOT PAGEABLE -- UlpTimeoutCheckExpiry
NOT PAGEABLE -- UlpTimeoutInsertTimerWheelEntry
NOT PAGEABLE -- UlTimeoutRemoveTimerWheelEntry
NOT PAGEABLE -- UlInitializeConnectionTimerInfo
NOT PAGEABLE -- UlSetConnectionTimer
NOT PAGEABLE -- UlSetMinBytesPerSecondTimer
NOT PAGEABLE -- UlResetConnectionTimer
NOT PAGEABLE -- UlEvaluateTimerState
#endif // 0


//
// Connection Timeout Montior globals
//

LONG            g_TimeoutMonitorInitialized = FALSE;
KDPC            g_TimeoutMonitorDpc;
KTIMER          g_TimeoutMonitorTimer;
KEVENT          g_TimeoutMonitorTerminationEvent;
KEVENT          g_TimeoutMonitorAddListEvent;
UL_WORK_ITEM    g_TimeoutMonitorWorkItem;

//
// Timeout constants
//

ULONG           g_TM_MinBytesPerSecondDivisor;   // Bytes/Sec
LONGLONG        g_TM_ConnectionTimeout; // 100ns ticks  (Global...can be overriden)
LONGLONG        g_TM_HeaderWaitTimeout; // 100ns ticks

//
// NOTE: Must be in sync with the _CONNECTION_TIMEOUT_TIMERS enum in httptypes.h
//
CHAR *g_aTimeoutTimerNames[] = {
    "ConnectionIdle",   // TimerConnectionIdle
    "HeaderWait",       // TimerHeaderWait
    "MinBytesPerSecond",         // TimerMinBytesPerSecond
    "EntityBody",       // TimerEntityBody
    "Response",         // TimerResponse
    "AppPool",          // TimerAppPool
};

//
// Timer Wheel(c)
//

static LIST_ENTRY      g_TimerWheel[TIMER_WHEEL_SLOTS+1]; // TODO: alloc on its own page.
static UL_SPIN_LOCK    g_TimerWheelMutex;
static USHORT          g_TimerWheelCurrentSlot;


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Initializes the Timeout Monitor and kicks off the first polling interval

Arguments:

    (none)


--***************************************************************************/
VOID
UlInitializeTimeoutMonitor(
    VOID
    )
{
    int i;
    LARGE_INTEGER   Now;

    //
    // Sanity check.
    //

    PAGED_CODE();

    UlTrace(TIMEOUTS, (
        "http!UlInitializeTimeoutMonitor\n"
        ));

    ASSERT( FALSE == g_TimeoutMonitorInitialized );

    //
    // Set default configuration information.
    //
    g_TM_ConnectionTimeout = 2 * 60 * C_NS_TICKS_PER_SEC; // 2 min
    g_TM_HeaderWaitTimeout = 2 * 60 * C_NS_TICKS_PER_SEC; // 2 min
    g_TM_MinBytesPerSecondDivisor   = 150;  // 150 == 1200 baud

    //
    // Init Timer Wheel(c) state
    //

    //
    // Set current slot
    //

    KeQuerySystemTime(&Now);
    g_TimerWheelCurrentSlot = UlpSystemTimeToTimerWheelSlot(Now.QuadPart);

    //
    // Init Timer Wheel(c) slots & mutex
    //

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);    // InitializeListHead requirement

    for ( i = 0; i < TIMER_WHEEL_SLOTS ; i++ )
    {
        InitializeListHead( &(g_TimerWheel[i]) );
    }

    InitializeListHead( &(g_TimerWheel[TIMER_OFF_SLOT]) );

    UlInitializeSpinLock( &(g_TimerWheelMutex), "TimeoutMonitor" );

    UlInitializeWorkItem(&g_TimeoutMonitorWorkItem);
    
    //
    // Init DPC object & set DPC routine
    //
    KeInitializeDpc(
        &g_TimeoutMonitorDpc,         // DPC object
        &UlpTimeoutMonitorDpcRoutine, // DPC routine
        NULL                          // context
        );

    KeInitializeTimer(
        &g_TimeoutMonitorTimer
        );

    //
    // Event to control rescheduling of the timeout monitor timer
    //
    KeInitializeEvent(
        &g_TimeoutMonitorAddListEvent,
        NotificationEvent,
        TRUE
        );

    //
    // Initialize the termination event.
    //
    KeInitializeEvent(
        &g_TimeoutMonitorTerminationEvent,
        NotificationEvent,
        FALSE
        );

    //
    // Init done!
    //
    InterlockedExchange( &g_TimeoutMonitorInitialized, TRUE );

    //
    // Kick-off the first monitor sleep period
    //
    UlpSetTimeoutMonitorTimer();
}


/***************************************************************************++

Routine Description:

    Terminate the Timeout Monitor, including any pending timer events.

Arguments:

    (none)


--***************************************************************************/
VOID
UlTerminateTimeoutMonitor(
    VOID
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    UlTrace(TIMEOUTS, (
        "http!UlTerminateTimeoutMonitor\n"
        ));

    //
    // Clear the "initialized" flag. If the timeout monitor runs soon,
    // it will see this flag, set the termination event, and exit
    // quickly.
    //
    if ( TRUE == InterlockedCompareExchange(
        &g_TimeoutMonitorInitialized,
        FALSE,
        TRUE) )
    {
        //
        // Cancel the timeout monitor timer. If it fails, the monitor
        // is running.  Wait for it to complete.
        //
        if ( !KeCancelTimer( &g_TimeoutMonitorTimer ) )
        {
            NTSTATUS    Status;
            
            Status = KeWaitForSingleObject(
                        (PVOID)&g_TimeoutMonitorTerminationEvent,
                        UserRequest,
                        KernelMode,
                        FALSE,
                        NULL
                        );
            
            ASSERT( STATUS_SUCCESS == Status );
        }

    }

    UlTrace(TIMEOUTS, (
        "http!UlTerminateTimeoutMonitor: Done!\n"
        ));

} // UlpTerminateTimeoutMonitor


/***************************************************************************++

Routine Description:

    Sets the global Timeout Monitor configuration information

Arguments:

    pInfo       pointer to HTTP_CONTROL_CHANNEL_TIMEOUT_LIMIT structure


--***************************************************************************/
VOID
UlSetTimeoutMonitorInformation(
    IN PHTTP_CONTROL_CHANNEL_TIMEOUT_LIMIT pInfo
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( pInfo );

    UlTrace(TIMEOUTS, (
        "http!UlSetTimeoutMonitorInformation:\n"
        "  ConnectionTimeout: %d\n"
        "  HeaderWaitTimeout: %d\n"
        "  MinFileKbSec: %d\n",
        pInfo->ConnectionTimeout,
        pInfo->HeaderWaitTimeout,
        pInfo->MinFileKbSec
        ));

    
    if ( pInfo->ConnectionTimeout )
    {
        UlInterlockedExchange64(
            &g_TM_ConnectionTimeout,
            (LONGLONG)(pInfo->ConnectionTimeout * C_NS_TICKS_PER_SEC)
            );
    }

    if ( pInfo->HeaderWaitTimeout )
    {
        UlInterlockedExchange64(
            &g_TM_HeaderWaitTimeout,
            (LONGLONG)(pInfo->HeaderWaitTimeout * C_NS_TICKS_PER_SEC)
            );
    }

    //
    // Allow MinBytesPerSecond to be set to zero (for long running
    // transactions)
    //
    InterlockedExchange( (PLONG)&g_TM_MinBytesPerSecondDivisor, pInfo->MinFileKbSec );

} // UlSetTimeoutMonitorInformation



/***************************************************************************++

Routine Description:

    Sets up a timer event to fire after the polling interval has expired.

Arguments:

    (none)


--***************************************************************************/
VOID
UlpSetTimeoutMonitorTimer(
    VOID
    )
{
    LARGE_INTEGER TimeoutMonitorInterval;

    ASSERT( TRUE == g_TimeoutMonitorInitialized );

    UlTraceVerbose(TIMEOUTS, (
        "http!UlpSetTimeoutMonitorTimer\n"
        ));

    //
    // Don't want to execute this more often than few seconds.
    // In particular, do not want to execute this every 0 seconds, as the
    // machine will become completely unresponsive.
    //

    //
    // negative numbers mean relative time
    //
    TimeoutMonitorInterval.QuadPart = -DEFAULT_POLLING_INTERVAL;

    KeSetTimer(
        &g_TimeoutMonitorTimer,
        TimeoutMonitorInterval,
        &g_TimeoutMonitorDpc
        );

}

/***************************************************************************++

Routine Description:

    Dispatch routine called by the timer event that queues up the Timeout
    Montior

Arguments:

    (all ignored)


--***************************************************************************/
VOID
UlpTimeoutMonitorDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(DeferredContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    if( g_TimeoutMonitorInitialized )
    {
        //
        // Do that timeout monitor thang.
        //

        UL_QUEUE_WORK_ITEM(
            &g_TimeoutMonitorWorkItem,
            &UlpTimeoutMonitorWorker
            );

    }

} // UlpTimeoutMonitorDpcRoutine


/***************************************************************************++

Routine Description:

    Timeout Monitor thread

Arguments:

    pWorkItem       (ignored)

--***************************************************************************/
VOID
UlpTimeoutMonitorWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    UNREFERENCED_PARAMETER(pWorkItem);

    //
    // sanity check
    //
    PAGED_CODE();

    UlTraceVerbose(TIMEOUTS, (
        "http!UlpTimeoutMonitorWorker\n"
        ));

    //
    // Check for things to expire now.
    //
    UlpTimeoutCheckExpiry();

    UlTrace(TIMEOUTS, (
        "http!UlpTimeoutMonitorWorker: g_TimerWheelCurrentSlot is now %d\n",
        g_TimerWheelCurrentSlot
        ));

    if ( g_TimeoutMonitorInitialized )
    {
        //
        // Reschedule ourselves
        //
        UlpSetTimeoutMonitorTimer();
    }
    else
    {
        //
        // Signal shutdown event
        //
        KeSetEvent(
            &g_TimeoutMonitorTerminationEvent,
            0,
            FALSE
            );
    }

} // UlpTimeoutMonitor


/***************************************************************************++

Routine Description:

    Walks a given timeout watch list looking for items that should be expired

Returns:

    Count of connections remaining on list (after all expired connections removed)

Notes:

    Possible Issue:  Since we use the system time to check to see if something
    should be expired, it's possible we will mis-expire some connections if the
    system time is set forward.

    Similarly, if the clock is set backward, we may not expire connections as
    expected.

--***************************************************************************/
ULONG
UlpTimeoutCheckExpiry(
    VOID
    )
{
    LARGE_INTEGER           Now;
    KIRQL                   OldIrql;
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pHead;
    PUL_HTTP_CONNECTION     pHttpConn;
    PUL_TIMEOUT_INFO_ENTRY  pInfo;
    LIST_ENTRY              ZombieList;
    ULONG                   Entries;
    USHORT                  Limit;
    USHORT                  CurrentSlot;
    BOOLEAN                 bLowMemoryCondition;


    PAGED_CODE();

    //
    // Init zombie list
    //
    InitializeListHead(&ZombieList);

    //
    // Get current time
    //
    KeQuerySystemTime(&Now);

    Limit = UlpSystemTimeToTimerWheelSlot( Now.QuadPart );
    ASSERT( TIMER_OFF_SLOT != Limit );

    //
    // Must check low memory condition outside of spin lock
    //
    
    bLowMemoryCondition = UlIsLowNPPCondition();

    //
    // Lock Timer Wheel(c)
    //
    UlAcquireSpinLock(
        &g_TimerWheelMutex,
        &OldIrql
        );

    CurrentSlot = g_TimerWheelCurrentSlot;

    //
    // Walk the slots up until Limit
    //
    Entries = 0;

    while ( CurrentSlot != Limit )
    {
        pHead  = &(g_TimerWheel[CurrentSlot]);
        pEntry = pHead->Flink;

        ASSERT( pEntry );

        //
        // Walk this slot's queue
        //

        while ( pEntry != pHead )
        {
            pInfo = CONTAINING_RECORD(
                pEntry,
                UL_TIMEOUT_INFO_ENTRY,
                QueueEntry
                );

            ASSERT( MmIsAddressValid(pInfo) );

            pHttpConn = CONTAINING_RECORD(
                pInfo,
                UL_HTTP_CONNECTION,
                TimeoutInfo
                );

            ASSERT( (pHttpConn != NULL) && \
                    (pHttpConn->Signature == UL_HTTP_CONNECTION_POOL_TAG) );

            //
            // go to next node (in case we remove the current one from the list)
            //
            pEntry = pEntry->Flink;
            Entries++;

            //
            // See if we should move this entry to a different slot
            //
            if ( pInfo->SlotEntry != CurrentSlot )
            {
                ASSERT( IS_VALID_TIMER_WHEEL_SLOT(pInfo->SlotEntry) );
                ASSERT( pInfo->QueueEntry.Flink != NULL );

                //
                // Move to correct slot
                //

                RemoveEntryList(
                    &pInfo->QueueEntry
                    );

                InsertTailList(
                    &(g_TimerWheel[pInfo->SlotEntry]),
                    &pInfo->QueueEntry
                    );

                Entries--;

                continue;   // inner while loop
            }

            //
            // See if connection will go away soon.
            // Add pseudo-ref to the pHttpConn to prevent it being killed
            // before we can kill it ourselves. (zombifying)
            //

            if (1 == InterlockedIncrement(&pHttpConn->RefCount))
            {
                //
                // If the ref-count has gone to zero, the httpconn will be
                // cleaned up soon; ignore this item and let the cleanup
                // do its job.
                //

                InterlockedDecrement(&pHttpConn->RefCount);
                Entries--;
                continue;   // inner while loop
            }

            //
            // If we are in this slot, we should expire this connection now.
            //

            WRITE_REF_TRACE_LOG2(
                g_pHttpConnectionTraceLog,
                pHttpConn->pConnection->pHttpTraceLog,
                REF_ACTION_EXPIRE_HTTP_CONNECTION,
                pHttpConn->RefCount,
                pHttpConn,
                __FILE__,
                __LINE__
                );

            UlTrace(TIMEOUTS, (
                "http!UlpTimeoutCheckExpiry: pInfo %p expired because %s timer\n",
                pInfo,
                g_aTimeoutTimerNames[pInfo->CurrentTimer]
                ));

            //
            // Expired.  Remove entry from list & move to Zombie list
            //

            UlAcquireSpinLockAtDpcLevel( &pInfo->Lock );

            pInfo->Expired = TRUE;

            RemoveEntryList(
                &pInfo->QueueEntry
                );

            pInfo->QueueEntry.Flink = NULL;

            InsertTailList(
                &ZombieList,
                &pInfo->ZombieEntry
                );

            UlReleaseSpinLockFromDpcLevel( &pInfo->Lock );

        } // Walk slot queue

        CurrentSlot = ((CurrentSlot + 1) % TIMER_WHEEL_SLOTS);

    } // ( CurrentSlot != Limit )

    //  
    // Low-memory check & cleanup here
    //
    
    if ( bLowMemoryCondition )
    {
        USHORT LowMemoryLimit;
        LONGLONG MaxTimeoutTime;

        MaxTimeoutTime = MAX( g_TM_HeaderWaitTimeout, g_TM_ConnectionTimeout );
        MaxTimeoutTime += Now.QuadPart;

        LowMemoryLimit = UlpSystemTimeToTimerWheelSlot( MaxTimeoutTime );

        ASSERT( TIMER_OFF_SLOT != LowMemoryLimit );
        
        //
        // Walk slots from Current to largest slot which could contain
        // a ConnectionIdle, HeaderWait or EntityBodyWait timer
        //

        while ( CurrentSlot != LowMemoryLimit )
        {
            pHead  = &(g_TimerWheel[CurrentSlot]);
            pEntry = pHead->Flink;

            ASSERT( pEntry );

            //
            // Walk this slot's queue
            //

            while ( pEntry != pHead )
            {
                pInfo = CONTAINING_RECORD(
                    pEntry,
                    UL_TIMEOUT_INFO_ENTRY,
                    QueueEntry
                    );

                ASSERT( MmIsAddressValid(pInfo) );

                pHttpConn = CONTAINING_RECORD(
                    pInfo,
                    UL_HTTP_CONNECTION,
                    TimeoutInfo
                    );

                ASSERT( (pHttpConn != NULL) && \
                        (pHttpConn->Signature == UL_HTTP_CONNECTION_POOL_TAG) );

                //
                // go to next node (in case we remove the current one from the list)
                //
                pEntry = pEntry->Flink;
                Entries++;

                //
                // See if connection will go away soon.
                // Add pseudo-ref to the pHttpConn to prevent it being killed
                // before we can kill it ourselves. (zombifying)
                //

                if (1 == InterlockedIncrement(&pHttpConn->RefCount))
                {
                    //
                    // If the ref-count has gone to zero, the httpconn will be
                    // cleaned up soon; ignore this item and let the cleanup
                    // do its job.
                    //

                    InterlockedDecrement(&pHttpConn->RefCount);
                    Entries--;
                    continue;   // inner while loop
                }

                ASSERT(pHttpConn->RefCount > 0);

                if ( (pInfo->SlotEntry == CurrentSlot)
                     && ((pInfo->CurrentTimer == TimerConnectionIdle)
                       ||(pInfo->CurrentTimer == TimerHeaderWait)
                       ||(pInfo->CurrentTimer == TimerAppPool)))
                {
                    // 
                    // Expire connection that hasn't been sent up to user mode yet
                    //

                    WRITE_REF_TRACE_LOG2(
                        g_pHttpConnectionTraceLog,
                        pHttpConn->pConnection->pHttpTraceLog,
                        REF_ACTION_EXPIRE_HTTP_CONNECTION,
                        pHttpConn->RefCount,
                        pHttpConn,
                        __FILE__,
                        __LINE__
                        );


                    UlTrace(TIMEOUTS, (
                        "http!UlpTimeoutCheckExpiry: pInfo %p expired because"
                        " of low memory condition.  Timer [%s]\n",
                        pInfo,
                        g_aTimeoutTimerNames[pInfo->CurrentTimer]
                        ));

                    //
                    // Expired.  Remove entry from list & move to Zombie list
                    //

                    UlAcquireSpinLockAtDpcLevel( &pInfo->Lock );

                    pInfo->Expired = TRUE;

                    RemoveEntryList(
                        &pInfo->QueueEntry
                        );

                    pInfo->QueueEntry.Flink = NULL;

                    InsertTailList(
                        &ZombieList,
                        &pInfo->ZombieEntry
                        );

                    UlReleaseSpinLockFromDpcLevel( &pInfo->Lock );
                }
                else
                {
                    // remove pseudo-reference added above
                    UL_DEREFERENCE_HTTP_CONNECTION(pHttpConn);
                }
            }

            CurrentSlot = ((CurrentSlot + 1) % TIMER_WHEEL_SLOTS);
        }
    } // low memory check

    g_TimerWheelCurrentSlot = Limit;

    UlReleaseSpinLock(
        &g_TimerWheelMutex,
        OldIrql
        );

    //
    // Remove entries on zombie list
    //
    
    while ( !IsListEmpty(&ZombieList) )
    {
        pEntry = RemoveHeadList( &ZombieList );

        pInfo = CONTAINING_RECORD(
                    pEntry,
                    UL_TIMEOUT_INFO_ENTRY,
                    ZombieEntry
                    );

        ASSERT( MmIsAddressValid(pInfo) );

        pHttpConn = CONTAINING_RECORD(
                        pInfo,
                        UL_HTTP_CONNECTION,
                        TimeoutInfo
                        );

        ASSERT( UL_IS_VALID_HTTP_CONNECTION(pHttpConn) );

        pEntry = pEntry->Flink;

        //
        // Close the conn and error log (if no one has done it yet)
        //
        
        UlAcquirePushLockExclusive(&pHttpConn->PushLock);

        UlErrorLog(pHttpConn,
                    NULL,
                    (PCHAR) TimeoutInfoTable[pInfo->CurrentTimer].pInfo,
                    TimeoutInfoTable[pInfo->CurrentTimer].InfoSize,
                    TRUE
                    );

        UlReleasePushLockExclusive(&pHttpConn->PushLock);
        
        UlCloseConnection(
            pHttpConn->pConnection, 
            TRUE, 
            NULL, 
            NULL
            );
                
        //
        // Remove the reference we added when zombifying
        //
        UL_DEREFERENCE_HTTP_CONNECTION(pHttpConn);

        Entries--;
    }

    return Entries;

} // UlpTimeoutCheckExpiry


//
// New Timer Wheel(c) primatives
//

/***************************************************************************++

Routine Description:


Arguments:


--***************************************************************************/
VOID
UlInitializeConnectionTimerInfo(
    PUL_TIMEOUT_INFO_ENTRY pInfo
    )
{
    LARGE_INTEGER           Now;
    int                     i;

    ASSERT( TRUE == g_TimeoutMonitorInitialized );

    //
    // Get current time
    //

    KeQuerySystemTime(&Now);

    //
    // Init Lock
    //

    UlInitializeSpinLock( &pInfo->Lock, "TimeoutInfoLock" );

    //
    // Timer state
    //

    ASSERT( 0 == TimerConnectionIdle );

    for ( i = 0; i < TimerMaximumTimer; i++ )
    {
        pInfo->Timers[i] = TIMER_OFF_TICK;
    }

    pInfo->CurrentTimer  = TimerConnectionIdle;
    pInfo->Timers[TimerConnectionIdle] = TIMER_WHEEL_TICKS(Now.QuadPart + g_TM_ConnectionTimeout);
    pInfo->CurrentExpiry = pInfo->Timers[TimerConnectionIdle];
    pInfo->MinBytesPerSecondSystemTime = TIMER_OFF_SYSTIME;
    pInfo->Expired = FALSE;
    pInfo->SendCount = 0;

    pInfo->ConnectionTimeoutValue = g_TM_ConnectionTimeout;
    pInfo->BytesPerSecondDivisor  = g_TM_MinBytesPerSecondDivisor;

    //
    // Wheel state
    //

    pInfo->SlotEntry = UlpTimerWheelTicksToTimerWheelSlot( pInfo->CurrentExpiry );
    UlpTimeoutInsertTimerWheelEntry(pInfo);

} // UlInitializeConnectionTimerInfo


/***************************************************************************++

Routine Description:


Arguments:


--***************************************************************************/
VOID
UlpTimeoutInsertTimerWheelEntry(
    PUL_TIMEOUT_INFO_ENTRY pInfo
    )
{
    KIRQL                   OldIrql;

    ASSERT( NULL != pInfo );
    ASSERT( TRUE == g_TimeoutMonitorInitialized );
    ASSERT( IS_VALID_TIMER_WHEEL_SLOT(pInfo->SlotEntry) );

    UlTrace(TIMEOUTS, (
        "http!UlTimeoutInsertTimerWheelEntry: pInfo %p Slot %d\n",
        pInfo,
        pInfo->SlotEntry
        ));

    UlAcquireSpinLock(
        &g_TimerWheelMutex,
        &OldIrql
        );

    InsertTailList(
        &(g_TimerWheel[pInfo->SlotEntry]),
        &pInfo->QueueEntry
        );


    UlReleaseSpinLock(
        &g_TimerWheelMutex,
        OldIrql
        );

} // UlTimeoutInsertTimerWheel


/***************************************************************************++

Routine Description:


Arguments:


--***************************************************************************/
VOID
UlTimeoutRemoveTimerWheelEntry(
    PUL_TIMEOUT_INFO_ENTRY pInfo
    )
{
    KIRQL                   OldIrql;

    ASSERT( NULL != pInfo );
    ASSERT( !IsListEmpty(&pInfo->QueueEntry) );

    UlTrace(TIMEOUTS, (
        "http!UlTimeoutRemoveTimerWheelEntry: pInfo %p\n",
        pInfo
        ));

    UlAcquireSpinLock(
        &g_TimerWheelMutex,
        &OldIrql
        );

    if (pInfo->QueueEntry.Flink != NULL)
    {
        RemoveEntryList(
            &pInfo->QueueEntry
            );

        pInfo->QueueEntry.Flink = NULL;
    }

    UlReleaseSpinLock(
        &g_TimerWheelMutex,
        OldIrql
        );

} // UlTimeoutRemoveTimerWheelEntry


/***************************************************************************++

Routine Description:

    Set the per Site Connection Timeout Value override


Arguments:

    pInfo           Timeout info block

    TimeoutValue    Override value

--***************************************************************************/
VOID
UlSetPerSiteConnectionTimeoutValue(
    PUL_TIMEOUT_INFO_ENTRY pInfo,
    LONGLONG TimeoutValue
    )
{
    ASSERT( NULL != pInfo );
    ASSERT( 0L   != TimeoutValue );

    PAGED_CODE();

    UlTrace(TIMEOUTS, (
        "http!UlSetPerSiteConnectionTimeoutValue: pInfo %p TimeoutValue = %ld secs.\n",
        pInfo,
        (LONG) (TimeoutValue / C_NS_TICKS_PER_SEC)
        ));

    ExInterlockedCompareExchange64(
        &pInfo->ConnectionTimeoutValue, // Destination
        &TimeoutValue,                  // Exchange
        &pInfo->ConnectionTimeoutValue, // Comperand
        &pInfo->Lock.KSpinLock          // Lock
        );

} // UlSetPerSiteConnectionTimeoutValue



/***************************************************************************++

Routine Description:

    Starts a given timer in the timer info block.


Arguments:

    pInfo   Timer info block

    Timer   Timer to set

--***************************************************************************/
VOID
UlSetConnectionTimer(
    PUL_TIMEOUT_INFO_ENTRY pInfo,
    CONNECTION_TIMEOUT_TIMER Timer
    )
{
    LARGE_INTEGER           Now;

    ASSERT( NULL != pInfo );
    ASSERT( IS_VALID_TIMEOUT_TIMER(Timer) );
    ASSERT( UlDbgSpinLockOwned( &pInfo->Lock ) );

    //
    // Get current time
    //

    KeQuerySystemTime(&Now);

    //
    // Set timer to apropriate value
    //

    switch ( Timer )
    {
    case TimerConnectionIdle:
    case TimerEntityBody:
    case TimerResponse:
    case TimerAppPool:
        // all can be handled with the same timeout value

        UlTraceVerbose(TIMEOUTS, (
            "http!UlSetConnectionTimer: pInfo %p Timer %s, Timeout = %ld secs\n",
            pInfo,
            g_aTimeoutTimerNames[Timer],
            (LONG) (pInfo->ConnectionTimeoutValue / C_NS_TICKS_PER_SEC)
            ));

        pInfo->Timers[Timer]
            = TIMER_WHEEL_TICKS(Now.QuadPart + pInfo->ConnectionTimeoutValue);
        break;

    case TimerHeaderWait:
        UlTraceVerbose(TIMEOUTS, (
            "http!UlSetConnectionTimer: pInfo %p Timer %s, Timeout = %ld secs\n",
            pInfo,
            g_aTimeoutTimerNames[Timer],
            (LONG) (g_TM_HeaderWaitTimeout / C_NS_TICKS_PER_SEC)
            ));

        pInfo->Timers[TimerHeaderWait]
            = TIMER_WHEEL_TICKS(Now.QuadPart + g_TM_HeaderWaitTimeout);
        break;

        // NOTE: TimerMinBytesPerSecond is handled in UlSetMinBytesPerSecondTimer()

    default:
        UlTrace(TIMEOUTS, (
            "http!UlSetConnectionTimer: Bad Timer! (%d)\n",
            Timer
            ));

        ASSERT( !"Bad Timer" );
    }

} // UlSetConnectionTimer


/***************************************************************************++

Routine Description:

    Turns on the MinBytesPerSecond timer, adds the number of secs given the minimum
    bandwidth specified.

Arguments:

    pInfo       - Timer info block

    BytesToSend - Bytes to be sent

--***************************************************************************/
VOID
UlSetMinBytesPerSecondTimer(
    PUL_TIMEOUT_INFO_ENTRY pInfo,
    LONGLONG BytesToSend
    )
{
    LONGLONG    XmitTicks;
    KIRQL       OldIrql; 
    ULONG       NewTick;
    BOOLEAN     bCallEvaluate = FALSE;


    ASSERT( NULL != pInfo );

    if ( 0 == pInfo->BytesPerSecondDivisor )
    {
        UlTraceVerbose(TIMEOUTS, (
            "http!UlSetMinBytesPerSecondTimer: pInfo %p, disabled\n",
            pInfo
            ));

        return;
    }
    
    //
    // Calculate the estimated time required to send BytesToSend
    //

    XmitTicks = BytesToSend / pInfo->BytesPerSecondDivisor;

    if (0 == XmitTicks)
    {
        XmitTicks = C_NS_TICKS_PER_SEC;
    }
    else
    {
        XmitTicks *= C_NS_TICKS_PER_SEC;
    }

    UlAcquireSpinLock(
        &pInfo->Lock,
        &OldIrql
        );

    if ( TIMER_OFF_SYSTIME == pInfo->MinBytesPerSecondSystemTime )
    {
        LARGE_INTEGER Now;

        //
        // Get current time
        //
        KeQuerySystemTime(&Now);

        pInfo->MinBytesPerSecondSystemTime = (Now.QuadPart + XmitTicks);

    }
    else
    {
        pInfo->MinBytesPerSecondSystemTime += XmitTicks;
    }

    NewTick = TIMER_WHEEL_TICKS(pInfo->MinBytesPerSecondSystemTime);

    if ( NewTick != pInfo->Timers[TimerMinBytesPerSecond] )
    {
        bCallEvaluate = TRUE;
        pInfo->Timers[TimerMinBytesPerSecond] = NewTick;
    }

    pInfo->SendCount++;

    UlTraceVerbose(TIMEOUTS, (
        "http!UlSetMinBytesPerSecondTimer: pInfo %p BytesToSend %ld SendCount %d\n",
        pInfo,
        BytesToSend,
        pInfo->SendCount
        ));

    UlReleaseSpinLock(
        &pInfo->Lock,
        OldIrql
        );

    if ( TRUE == bCallEvaluate )
    {
        UlEvaluateTimerState(pInfo);
    }

} // UlSetMinBytesPerSecondTimer


/***************************************************************************++

Routine Description:

    Turns off a given timer in the timer info block.

Arguments:

    pInfo   Timer info block

    Timer   Timer to reset

--***************************************************************************/
VOID
UlResetConnectionTimer(
    PUL_TIMEOUT_INFO_ENTRY pInfo,
    CONNECTION_TIMEOUT_TIMER Timer
    )
{
    ASSERT( NULL != pInfo );
    ASSERT( IS_VALID_TIMEOUT_TIMER(Timer) );
    ASSERT( UlDbgSpinLockOwned( &pInfo->Lock ) );

    UlTraceVerbose(TIMEOUTS, (
        "http!UlResetConnectionTimer: pInfo %p Timer %s\n",
        pInfo,
        g_aTimeoutTimerNames[Timer]
        ));

    //
    // Turn off timer
    //

    // CODEWORK: handle case when MinBytes/Sec is disabled/enabled while 
    // CODEWORK: timer is running.
    if ( TimerMinBytesPerSecond == Timer && pInfo->BytesPerSecondDivisor )
    {
        ASSERT( pInfo->SendCount > 0 );
        
        pInfo->SendCount--;

        if ( pInfo->SendCount )
        {
            // Do not reset timer if there are sends outstanding
            return;
        }
    }

    pInfo->Timers[Timer] = TIMER_OFF_TICK;

    if ( TimerMinBytesPerSecond == Timer && pInfo->BytesPerSecondDivisor )
    {
        pInfo->MinBytesPerSecondSystemTime = TIMER_OFF_SYSTIME;
    }

} // UlResetConnectionTimer


//
// Private functions
//

/***************************************************************************++

Routine Description:

    Evaluate which timer will expire first and move pInfo to a new
    timer wheel slot if necessary

Arguments:


--***************************************************************************/
VOID
UlEvaluateTimerState(
    PUL_TIMEOUT_INFO_ENTRY pInfo
    )
{
    int         i;
    ULONG       MinTimeout = TIMER_OFF_TICK;
    CONNECTION_TIMEOUT_TIMER  MinTimeoutTimer = TimerConnectionIdle;

    ASSERT( NULL != pInfo );
    ASSERT( !UlDbgSpinLockOwned( &pInfo->Lock ) );

    for ( i = 0; i < TimerMaximumTimer; i++ )
    {
        if (pInfo->Timers[i] < MinTimeout)
        {
            MinTimeout = pInfo->Timers[i];
            MinTimeoutTimer = (CONNECTION_TIMEOUT_TIMER) i;
        }
    }

    //
    // If we've found a different expiry time, update expiry state.
    //
    
    if (pInfo->CurrentExpiry != MinTimeout)
    {
        KIRQL   OldIrql;
        USHORT  NewSlot;

        //
        // Calculate new slot
        //

        NewSlot = UlpTimerWheelTicksToTimerWheelSlot(MinTimeout);
        ASSERT(IS_VALID_TIMER_WHEEL_SLOT(NewSlot));

        InterlockedExchange((LONG *) &pInfo->SlotEntry, NewSlot);

        //
        // Move to new slot if necessary
        //

        if ( (NewSlot != TIMER_OFF_SLOT) && (MinTimeout < pInfo->CurrentExpiry) )
        {
            //
            // Only move if it's on the Wheel; If Flink is null, it's in
            // the process of being expired.
            //
            
            UlAcquireSpinLock(
                &g_TimerWheelMutex,
                &OldIrql
                );

            if ( NULL != pInfo->QueueEntry.Flink )
            {
                UlTrace(TIMEOUTS, (
                    "http!UlEvaluateTimerInfo: pInfo %p: Moving to new slot %hd\n",
                    pInfo,
                    NewSlot
                    ));

                RemoveEntryList(
                    &pInfo->QueueEntry
                    );

                InsertTailList(
                    &(g_TimerWheel[NewSlot]),
                    &pInfo->QueueEntry
                    );
            }

            UlReleaseSpinLock(
                &g_TimerWheelMutex,
                OldIrql
                );
        }
 
        //
        // Update timer wheel state
        //

        pInfo->CurrentExpiry = MinTimeout;
        pInfo->CurrentTimer  = MinTimeoutTimer;

        UlTraceVerbose(TIMEOUTS, (
            "http!UlEvaluateTimerState: pInfo %p -> Timer %s, Expiry %d\n",
            pInfo,
            g_aTimeoutTimerNames[MinTimeoutTimer],
            MinTimeout
            ));
    }

} // UlEvaluateTimerState
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\tracelog.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    tracelog.c

Abstract:

    This module implements a trace log.

    A trace log is a fast, in-memory, thread safe activity log useful
    for debugging certain classes of problems. They are especially useful
    when debugging reference count bugs.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include "precomp.h"


#if !REFERENCE_DEBUG

static int g_TraceLogDummyDeclarationToKeepW4WarningsQuiet;

#else // REFERENCE_DEBUG


//
// Environmental stuff.
//

#define MY_ASSERT(expr) ASSERT(expr)


/***************************************************************************++

Routine Description:

    Creates a new (empty) trace log buffer.

Arguments:

    TypeSignature - Signature used by debugger extensions to match
        specialized tracelogs

    LogSize - Supplies the number of entries in the log.

    ExtraBytesInHeader - Supplies the number of extra bytes to include
        in the log header. This is useful for adding application-specific
        data to the log.

    EntrySize - Supplies the size (in bytes) of each entry.

    AllocationPriority - (currently ignored) If memory consumption is
        high, use AllocationPriority to determine if allocation succeeds

    PoolTag - Helps !poolused attribute different kinds of tracelogs

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--***************************************************************************/
PTRACE_LOG
CreateTraceLog(
    IN ULONG             TypeSignature,
    IN ULONG             LogSize,
    IN ULONG             ExtraBytesInHeader,
    IN ULONG             EntrySize,
    IN TRACELOG_PRIORITY AllocationPriority,
    IN ULONG             PoolTag
    )
{
    ULONG totalSize;
    ULONG ExtraHeaderSize;
    PTRACE_LOG pLog;

    //
    // Sanity check the parameters.
    //

    MY_ASSERT( LogSize > 0 );
    MY_ASSERT( EntrySize > 0 );
    MY_ASSERT( ( EntrySize & 3 ) == 0 );

    //
    // Round up to platform allocation size to ensure that pLogBuffer
    // is correctly aligned
    //

    ExtraHeaderSize = (ExtraBytesInHeader + (MEMORY_ALLOCATION_ALIGNMENT-1))
                       & ~(MEMORY_ALLOCATION_ALIGNMENT-1);

    //
    // Allocate & initialize the log structure.
    //

    totalSize = sizeof(*pLog) + ( LogSize * EntrySize ) + ExtraHeaderSize;
    MY_ASSERT( totalSize > 0 );

    // 
    // CODEWORK: check AllocationPriority and memory consumption.
    // Fail allocation if memory too low and priority not high enough
    // 

    pLog = (PTRACE_LOG) ExAllocatePoolWithTag(
                            NonPagedPool,
                            totalSize,
                            PoolTag
                            );

    //
    // Initialize it.
    //

    if (pLog != NULL)
    {
        RtlZeroMemory( pLog, totalSize );

        pLog->Signature = TRACE_LOG_SIGNATURE;
        pLog->TypeSignature = TypeSignature;
        pLog->LogSize = LogSize;
        pLog->NextEntry = -1;
        pLog->EntrySize = EntrySize;
        pLog->AllocationPriority = AllocationPriority;
        pLog->pLogBuffer = (PUCHAR)( pLog + 1 ) + ExtraBytesInHeader;
    }

    return pLog;

}   // CreateTraceLog


/***************************************************************************++

Routine Description:

    Destroys a trace log buffer created with CreateTraceLog().

Arguments:

    pLog - Supplies the trace log buffer to destroy.

--***************************************************************************/
VOID
DestroyTraceLog(
    IN PTRACE_LOG pLog,
    IN ULONG      PoolTag
    )
{
    if (pLog != NULL)
    {
        MY_ASSERT( pLog->Signature == TRACE_LOG_SIGNATURE );

        pLog->Signature = TRACE_LOG_SIGNATURE_X;
        ExFreePoolWithTag( pLog, PoolTag );
    }

}   // DestroyTraceLog


/***************************************************************************++

Routine Description:

    Writes a new entry to the specified trace log.

Arguments:

    pLog - Supplies the log to write to.

    pEntry - Supplies a pointer to the data to write. This buffer is
        assumed to be pLog->EntrySize bytes long.

Return Value:

    LONGLONG - Index of the newly written entry within the tracelog.

--***************************************************************************/
LONGLONG
WriteTraceLog(
    IN PTRACE_LOG pLog,
    IN PVOID pEntry
    )
{
    PUCHAR pTarget;
    ULONGLONG index = (ULONGLONG) -1;

    if (pLog != NULL)
    {
        MY_ASSERT( pLog->Signature == TRACE_LOG_SIGNATURE );
        MY_ASSERT( pEntry != NULL );

        //
        // Find the next slot, copy the entry to the slot.
        //

        index = (ULONGLONG) UlInterlockedIncrement64( &pLog->NextEntry );

        pTarget = ( (index % pLog->LogSize) * pLog->EntrySize )
                        + pLog->pLogBuffer;

        RtlCopyMemory( pTarget, pEntry, pLog->EntrySize );
    }

    return index;
}   // WriteTraceLog


/***************************************************************************++

Routine Description:

    Resets the specified trace log such that the next entry written
    will be placed at the beginning of the log.

Arguments:

    pLog - Supplies the trace log to reset.

--***************************************************************************/
VOID
ResetTraceLog(
    IN PTRACE_LOG pLog
    )
{
    if (pLog != NULL)
    {
        MY_ASSERT( pLog->Signature == TRACE_LOG_SIGNATURE );

        RtlZeroMemory(pLog->pLogBuffer, pLog->LogSize * pLog->EntrySize);

        pLog->NextEntry = -1;
    }

}   // ResetTraceLog


#endif  // REFERENCE_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ucaction.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    ucaction.h

Abstract:

    Action codes for reftracing http.sys. The !httpkd.uc debugger extension
    uses this file with a different definition of UC_ACTION() to
    print out symbolic information.

Author:

    Rajesh Sundaram (rajeshsu) - 17th July 2001.

--*/
//
// Action codes.
//

#ifndef BEGIN_UC_ACTION
# define BEGIN_UC_ACTION()     enum UC_ACTION {
# define END_UC_ACTION()       };
# define UC_ACTION(x)          UC_ACTION_##x ,
#endif // !BEGIN_UC_ACTION

BEGIN_UC_ACTION()
    UC_ACTION( NO_OP )  // == 0
    

    UC_ACTION( NEW_RESPONSE )

    UC_ACTION( REQUEST_NEW )
    UC_ACTION( REQUEST_COMPLETE_IRP )
    UC_ACTION( REQUEST_COMPLETE_EARLY )
    UC_ACTION( REQUEST_CANCELLED )
    UC_ACTION( REQUEST_SEND_COMPLETE )
    UC_ACTION( REQUEST_SET_CANCEL_ROUTINE )
    UC_ACTION( REQUEST_BUFFERED )
    UC_ACTION( REQUEST_SENT )
    UC_ACTION( REQUEST_MORE_ENTITY_NEEDED )
    UC_ACTION( REQUEST_QUEUED )
    UC_ACTION( REQUEST_FAILED )
    UC_ACTION( REQUEST_PARSE_DONE )
    UC_ACTION( REQUEST_CLEAN_PENDED)
    UC_ACTION( REQUEST_CLEAN_RESUMED)

    UC_ACTION( ENTITY_NEW )
    UC_ACTION( ENTITY_CANCELLED )
    UC_ACTION( ENTITY_LAST )
    UC_ACTION( ENTITY_SENT )
    UC_ACTION( ENTITY_BUFFERED )
    UC_ACTION( ENTITY_READY_TO_SEND )
    UC_ACTION( ENTITY_QUEUED )

    UC_ACTION( RESPONSE_CANCELLED )

    UC_ACTION( CONNECTION_STATE_ENTER )
    UC_ACTION( CONNECTION_STATE_LEAVE )

    UC_ACTION( CONNECTION_CLOSE )
    UC_ACTION( CONNECTION_RAW_CLOSE )
    UC_ACTION( CONNECTION_RAW_FILTER_CLOSE )
    UC_ACTION( CONNECTION_RAW_FILTER_DISCONNECT )
    UC_ACTION( CONNECTION_BEGIN_DISCONNECT )
    UC_ACTION( CONNECTION_RESTART_DISCONNECT )
    UC_ACTION( CONNECTION_BEGIN_ABORT )
    UC_ACTION( CONNECTION_RESTART_ABORT )
    UC_ACTION( CONNECTION_TDI_DISCONNECT)
    UC_ACTION( CONNECTION_CLEANUP)
    UC_ACTION( CONNECTION_BEGIN_CONNECT)
    UC_ACTION( CONNECTION_RESTART_CONNECT)
    UC_ACTION( CONNECTION_CLEAN_PENDED)
    UC_ACTION( CONNECTION_CLEAN_RESUMED)
    UC_ACTION( CONNECTION_CLEANED)
    UC_ACTION( SERVINFO_FREE)

    UC_ACTION( MAX )   // *must* be last
END_UC_ACTION();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\type.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    type.h

Abstract:

    This module contains global type definitions.

Author:

    Keith Moore (keithmo)       15-Jun-1998

Revision History:

--*/


#ifndef _TYPE_H_
#define _TYPE_H_


//
// Routine invoked after asynchronous API completion.
//
// Arguments:
//
//      pCompletionContext - Supplies an uninterpreted context value
//          as passed to the asynchronous API.
//
//      Status - Supplies the final completion status of the
//          asynchronous API.
//
//      Information - Optionally supplies additional information about
//          the completed operation, such as the number of bytes
//          transferred.
//

typedef
VOID
(*PUL_COMPLETION_ROUTINE)(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );


//
// The following structure contains all UL data that must be
// nonpaged at all times.
//
// Note: if you modify this struct, please make the corresponding
// changes to ..\ulkd\glob.c
//

typedef struct _UL_NONPAGED_DATA
{
    //
    // Lookaside lists for speedy allocations.
    //

    HANDLE                  IrpContextLookaside;
    HANDLE                  ReceiveBufferLookaside;
    HANDLE                  RequestBufferLookaside;
    HANDLE                  InternalRequestLookaside;
    HANDLE                  ChunkTrackerLookaside;
    HANDLE                  FullTrackerLookaside;
    HANDLE                  ResponseBufferLookaside;
    HANDLE                  LogFileBufferLookaside;
    HANDLE                  BinaryLogDataBufferLookaside;
    HANDLE                  AnsiLogDataBufferLookaside;
    HANDLE                  ErrorLogBufferLookaside;

    //
    // Non-paged resources for cgroup.c
    //

    //
    // we use 2 locks to prevent a very delicate deadlock situation with
    // HTTP_CONNECTION resources and the config group tree.  we need to
    // allow the http engine read only access to the tree during critical
    // times, like deleting sites, which requires deleting the http endpoint,
    // which needs to aquire the HTTP_CONNECTION resource, thus the deadlock.
    // this is most common during shutdown under load.
    //

    UL_ERESOURCE            ConfigGroupResource;    // Locks the tree, readers
                                                    // use this one.  writers
                                                    // also use it when it's
                                                    // unsafe for readers to
                                                    // access the tree
    //
    // Non-paged resources for apool.c
    //

    UL_ERESOURCE            AppPoolResource;        // Locks the global app
                                                    // pool list

    UL_ERESOURCE            DisconnectResource;     // Locks everything related
                                                    // to UlWaitForDisconnect
    //
    // Non-paged resources for cache.c
    //

    UL_ERESOURCE            UriZombieResource;      // Locks URI Zombie list

    //                                                //
    // Non-paged resources for filter.c
    //

    UL_SPIN_LOCK            FilterSpinLock;         // Locks the global
                                                    // filter list.

    //
    // Non-paged resources for ullog.c
    //

    UL_PUSH_LOCK            LogListPushLock;        // Locks the log
                                                    // file list
    //
    // Non-paged resources for ultci.c
    //

    UL_PUSH_LOCK            TciIfcPushLock;         // Locks the QoS
                                                    // Interface list
    //
    // Non-paged resources for parse.c
    //

    UL_PUSH_LOCK            DateHeaderPushLock;     // Date Cache Lock

    //
    // Non-paged resources for control.c
    //

    UL_PUSH_LOCK            ControlChannelPushLock;     // Protects cc list    

} UL_NONPAGED_DATA, *PUL_NONPAGED_DATA;


#define CG_LOCK_READ() \
do { \
    UlAcquireResourceShared(&(g_pUlNonpagedData->ConfigGroupResource), TRUE); \
} while (0, 0)

#define CG_UNLOCK_READ() \
do { \
    UlReleaseResource(&(g_pUlNonpagedData->ConfigGroupResource)); \
} while (0, 0)

#define CG_LOCK_WRITE() \
do { \
    UlAcquireResourceExclusive(&(g_pUlNonpagedData->ConfigGroupResource), TRUE); \
} while (0, 0)

#define CG_UNLOCK_WRITE() \
do { \
    UlReleaseResource(&(g_pUlNonpagedData->ConfigGroupResource)); \
} while (0, 0)



//
// Structure used to simulate synchronous I/O when issueing IRPs directly.
//

typedef struct _UL_STATUS_BLOCK
{
    IO_STATUS_BLOCK IoStatus;
    KEVENT Event;

} UL_STATUS_BLOCK, *PUL_STATUS_BLOCK;

#define UlInitializeStatusBlock( pstatus )                                  \
    do                                                                      \
    {                                                                       \
        (pstatus)->IoStatus.Status = STATUS_PENDING;                        \
        (pstatus)->IoStatus.Information = 0;                                \
        KeInitializeEvent( &((pstatus)->Event), NotificationEvent, FALSE ); \
    } while (0, 0)

#define UlWaitForStatusBlockEvent( pstatus )                                \
    KeWaitForSingleObject(                                                  \
        (PVOID)&((pstatus)->Event),                                         \
        UserRequest,                                                        \
        KernelMode,                                                         \
        FALSE,                                                              \
        NULL                                                                \
        )

#define UlResetStatusBlockEvent( pstatus )                                  \
    KeResetEvent( &((pstatus)->Event) )

#define UlSignalStatusBlock( pstatus, status, info )                        \
    do                                                                      \
    {                                                                       \
        (pstatus)->IoStatus.Status = (status);                              \
        (pstatus)->IoStatus.Information = (info);                           \
        KeSetEvent( &((pstatus)->Event), 0, FALSE );                        \
    } while (0, 0)


#endif  // _TYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\tracelog.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    tracelog.h

Abstract:

    This module contains public declarations and definitions for creating
    trace logs.

    A trace log is a fast, in-memory, threadsafe, circular activity log useful
    for debugging certain classes of problems. They are especially useful
    when debugging reference count bugs.

    Note that the creator of the log has the option of adding "extra"
    bytes to the log header. This can be useful if the creator wants to
    create a set of global logs, each on a linked list.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _TRACELOG_H_
#define _TRACELOG_H_


//
// Look at memory consumption when allocating tracelog. Return NULL if
// memory is low and priority is not high enough.
//

typedef enum _TRACELOG_PRIORITY {
    TRACELOG_LOW_PRIORITY = 1,
    TRACELOG_NORMAL_PRIORITY,
    TRACELOG_HIGH_PRIORITY
} TRACELOG_PRIORITY;


typedef struct _TRACE_LOG
{
    //
    // Signature: TRACE_LOG_SIGNATURE;
    //
    
    ULONG Signature;
    
    //
    // TypeSignature: Ref, FiltQ, Irp, etc
    //
    
    ULONG TypeSignature;

    //
    // The total number of entries available in the log.
    //

    ULONG LogSize;

    //
    // The byte size of each entry.
    //

    ULONG EntrySize;

    //
    // The index of the next entry to use. For long runs in a busy
    // tracelog, a 32-bit index will overflow in a few days. Consider
    // what would happen if we jumped from OxFFFFFFFF (4,294,967,295) to
    // 0 when LogSize = 10,000: the index would jump from 7295 to 0,
    // leaving a large gap of stale records at the end, and !ulkd.ref
    // would not be able to find the preceding ones with high indices.
    //

    LONGLONG NextEntry;

    //
    // Priority this was created with
    //

    TRACELOG_PRIORITY AllocationPriority;

    //
    // Pointer to the start of the circular buffer.
    //

    PUCHAR pLogBuffer;

    //
    // The extra header bytes and actual log entries go here.
    //
    // BYTE ExtraHeaderBytes[ExtraBytesInHeader];
    // BYTE Entries[LogSize][EntrySize];
    //

#ifdef _WIN64
    ULONG_PTR Padding;
#endif

} TRACE_LOG, *PTRACE_LOG;

// sizeof(TRACE_LOG) must be a multiple of MEMORY_ALLOCATION_ALIGNMENT
C_ASSERT((sizeof(TRACE_LOG) & (MEMORY_ALLOCATION_ALIGNMENT - 1)) == 0);

//
// Log header signature.
//

#define TRACE_LOG_SIGNATURE   MAKE_SIGNATURE('Tlog')
#define TRACE_LOG_SIGNATURE_X MAKE_FREE_SIGNATURE(TRACE_LOG_SIGNATURE)


//
// This macro maps a TRACE_LOG pointer to a pointer to the 'extra'
// data associated with the log.
//

#define TRACE_LOG_TO_EXTRA_DATA(log)    (PVOID)( (log) + 1 )


//
// Manipulators.
//

// CODEWORK: think about adding alignment flags so that entries will always
// be pointer-aligned on the hardware

PTRACE_LOG
CreateTraceLog(
    IN ULONG             TypeSignature,
    IN ULONG             LogSize,
    IN ULONG             ExtraBytesInHeader,
    IN ULONG             EntrySize,
    IN TRACELOG_PRIORITY AllocationPriority,
    IN ULONG             PoolTag
    );

VOID
DestroyTraceLog(
    IN PTRACE_LOG pLog,
    IN ULONG      PoolTag
    );

LONGLONG
WriteTraceLog(
    IN PTRACE_LOG pLog,
    IN PVOID pEntry
    );

VOID
ResetTraceLog(
    IN PTRACE_LOG pLog
    );


#endif  // _TRACELOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ucparse.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    ucparse.c

Abstract:

    Contains all of the kernel mode HTTP parsing code for the client 

Author:

    Rajesh Sundaram (rajeshsu)     10-Oct-2000  Implemented client parser

Revision History:

    Rajesh Sundaram (rajeshsu)     15-Feb-2002  Moved from parse.c

--*/


#include "precomp.h"

#include "ucparse.h"
#include "ucrcv.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGEUC, UcComputeRequestHeaderSize)
#pragma alloc_text( PAGEUC, UcGenerateRequestHeaders)
#pragma alloc_text( PAGEUC, UcGenerateContentLength)
#pragma alloc_text( PAGEUC, UcComputeConnectVerbHeaderSize)
#pragma alloc_text( PAGEUC, UcGenerateConnectVerbHeader)
#pragma alloc_text( PAGEUC, UcCheckDisconnectInfo)
#pragma alloc_text( PAGEUC, UcCanonicalizeURI)
#pragma alloc_text( PAGEUC, UcParseWWWAuthenticateHeader)
#pragma alloc_text( PAGEUC, UcpFindAttribValuePair)
#pragma alloc_text( PAGEUC, UcpParseAuthParams)
#pragma alloc_text( PAGEUC, UcpParseAuthBlob)

#pragma alloc_text( PAGEUC, UcFindHeaderNameEnd)
#pragma alloc_text( PAGEUC, UcpLookupHeader)
#pragma alloc_text( PAGEUC, UcParseHeader)
#pragma alloc_text( PAGEUC, UcSingleHeaderHandler)
#pragma alloc_text( PAGEUC, UcMultipleHeaderHandler)
#pragma alloc_text( PAGEUC, UcAuthenticateHeaderHandler)
#pragma alloc_text( PAGEUC, UcContentLengthHeaderHandler)
#pragma alloc_text( PAGEUC, UcTransferEncodingHeaderHandler)
#pragma alloc_text( PAGEUC, UcConnectionHeaderHandler)
#pragma alloc_text( PAGEUC, UcContentTypeHeaderHandler)

#endif


//
// The enum->verb translation table
//
LONG_VERB_ENTRY EnumVerbTable[HttpVerbMaximum] =
{
    CREATE_LONG_VERB_ENTRY(GET),      // Unparsed defaults to GET
    CREATE_LONG_VERB_ENTRY(GET),      // Unknown  defaults to GET
    CREATE_LONG_VERB_ENTRY(GET),      // Invalid  defaults to GET
    CREATE_LONG_VERB_ENTRY(OPTIONS),
    CREATE_LONG_VERB_ENTRY(GET),
    CREATE_LONG_VERB_ENTRY(HEAD),
    CREATE_LONG_VERB_ENTRY(POST),
    CREATE_LONG_VERB_ENTRY(PUT),
    CREATE_LONG_VERB_ENTRY(DELETE),
    CREATE_LONG_VERB_ENTRY(TRACE),
    CREATE_LONG_VERB_ENTRY(CONNECT),
    CREATE_LONG_VERB_ENTRY(TRACK),
    CREATE_LONG_VERB_ENTRY(MOVE),
    CREATE_LONG_VERB_ENTRY(COPY),
    CREATE_LONG_VERB_ENTRY(PROPFIND),
    CREATE_LONG_VERB_ENTRY(PROPPATCH),
    CREATE_LONG_VERB_ENTRY(MKCOL),
    CREATE_LONG_VERB_ENTRY(LOCK),
    CREATE_LONG_VERB_ENTRY(UNLOCK),
    CREATE_LONG_VERB_ENTRY(SEARCH)
};


//
// A macro to process the header value.
// It stips leading LWS and trailing LWS and CRLF from a header value.
//

#define UC_PROCESS_HEADER_VALUE(pHeaderValue, HeaderValueLength)           \
{                                                                          \
    while((HeaderValueLength) > 0 && IS_HTTP_LWS(*(pHeaderValue)))         \
    {                                                                      \
        (pHeaderValue)++;                                                  \
        (HeaderValueLength)--;                                             \
    }                                                                      \
    while((HeaderValueLength) > 0 &&                                       \
           IS_HTTP_WS_TOKEN((pHeaderValue)[(HeaderValueLength)-1]))        \
    {                                                                      \
        (HeaderValueLength)--;                                             \
    }                                                                      \
}

//
// Private macros.
//

//
// COPY_DATA_TO_BUFFER
//     copies source buffer to destination buffer after making sure that 
//     the destination buffer can hold the data.
//

#define COPY_DATA_TO_BUFFER(pDest, DestLen, pSrc, SrcLen)       \
do {                                                            \
    if ((SrcLen) > (DestLen))                                   \
    {                                                           \
        ASSERT(FALSE);                                          \
        return STATUS_BUFFER_TOO_SMALL;                         \
    }                                                           \
    RtlCopyMemory((pDest), (pSrc), (SrcLen));                   \
    (pDest) += (SrcLen);                                        \
    (DestLen) -= (SrcLen);                                      \
} while (0)

//
// ADVANCE_POINTER
//    Advances a pointer to buffer after making sure that the new pointer
//    does not point beyond the buffer.
//

#define ADVANCE_POINTER(pDest, DestLen, SrcLen)                 \
do {                                                            \
    if ((SrcLen) > (DestLen))                                   \
    {                                                           \
        ASSERT(FALSE);                                          \
        return STATUS_BUFFER_TOO_SMALL;                         \
    }                                                           \
    (pDest) += (SrcLen);                                        \
    (DestLen) -= (SrcLen);                                      \
} while (0)

//
// COPY_UCHAR_TO_BUFFER
//

#define COPY_UCHAR_TO_BUFFER(pDest, DestLen, UChar)             \
do {                                                            \
    if (sizeof(UCHAR) > (DestLen))                              \
    {                                                           \
        ASSERT(FALSE);                                          \
        return STATUS_BUFFER_TOO_SMALL;                         \
    }                                                           \
    *(pDest)++ = (UChar);                                       \
    (DestLen) -= sizeof(UCHAR);                                 \
} while (0)

//
// COPY_SP_TO_BUFFER
//

#define COPY_SP_TO_BUFFER(pDest, DestLen) \
            COPY_UCHAR_TO_BUFFER(pDest, DestLen, SP)

//
// COPY_CRLF_TO_BUFFER
//

#define COPY_CRLF_TO_BUFFER(pDest, DestLen)                     \
do {                                                            \
    if (CRLF_SIZE > (DestLen))                                  \
    {                                                           \
        ASSERT(FALSE);                                          \
        return STATUS_BUFFER_TOO_SMALL;                         \
    }                                                           \
    *((UNALIGNED64 USHORT *)(pDest)) = CRLF;                    \
    (pDest) += CRLF_SIZE;                                       \
    (DestLen) -= CRLF_SIZE;                                     \
} while (0)

//
// COPY_HEADER_NAME_SP_TO_BUFFER
//

#define  COPY_HEADER_NAME_SP_TO_BUFFER(pBuffer, BufferLen, i)          \
do {                                                                   \
       PHEADER_MAP_ENTRY _pEntry;                                      \
       _pEntry = &(g_RequestHeaderMapTable[g_RequestHeaderMap[i]]);    \
                                                                       \
       if (_pEntry->HeaderLength + sizeof(UCHAR) > (BufferLen))        \
       {                                                               \
           ASSERT(FALSE);                                              \
           return STATUS_BUFFER_TOO_SMALL;                             \
       }                                                               \
                                                                       \
       (BufferLen) -= (_pEntry->HeaderLength + sizeof(UCHAR));         \
                                                                       \
       RtlCopyMemory((pBuffer),                                        \
                     _pEntry->MixedCaseHeader,                         \
                     _pEntry->HeaderLength);                           \
                                                                       \
       (pBuffer) += _pEntry->HeaderLength;                             \
       *(pBuffer)++ = SP;                                              \
                                                                       \
} while (0)


//
// Request Generator functions.
//


/***************************************************************************++

Routine Description:

    Figures out how big the fixed headers are. Fixed headers include the
    request line, and any headers that don't have to be generated for
    every request (such as Date and Connection).

    The final CRLF separating headers from body is considered part of
    the variable headers.

Arguments:

    pServInfo            - The server information.
    pHttpRequest         - The request structure.
    bChunked             - a boolean that tells if the encoding is chunked.
    bContentLengthHeader - a boolean that tells if the Content-Length header
                           is to be generated.
    UriLength            - An OUT parameter that will contain the URI length.

Return Values:

    The number of bytes in the fixed headers.

--***************************************************************************/
ULONG
UcComputeRequestHeaderSize(
    IN  PUC_PROCESS_SERVER_INFORMATION  pServInfo,
    IN  PHTTP_REQUEST                   pHttpRequest,
    IN  BOOLEAN                         bChunked,
    IN  BOOLEAN                         bContentLengthHeader,
    IN  PUC_HTTP_AUTH                   pAuth,
    IN  PUC_HTTP_AUTH                   pProxyAuth,
    IN  PBOOLEAN                        bPreAuth,
    IN  PBOOLEAN                        bProxyPreAuth
    )
{
    ULONG                   MethodLength, HeaderLength;
    ULONG                   i;
    PHTTP_KNOWN_HEADER      pKnownHeaders;
    PHTTP_UNKNOWN_HEADER    pUnknownHeaders;
    PHEADER_MAP_ENTRY       pEntry;

    pKnownHeaders   =  pHttpRequest->Headers.KnownHeaders;
    pUnknownHeaders =  pHttpRequest->Headers.pUnknownHeaders;

    ASSERT(*bPreAuth == FALSE);
    ASSERT(*bProxyPreAuth == FALSE);

    //
    // Sanity check.
    //

    PAGED_CODE();

    HeaderLength = 0;

    if(pHttpRequest->UnknownVerbLength)
    {
        //
        // The app has passed an unknown verb. 
        //

        HeaderLength = pHttpRequest->UnknownVerbLength;
    }
    else 
    {
        // Enums are signed, so we have to do the < 0 check!

        if(pHttpRequest->Verb < 0                 ||
           pHttpRequest->Verb >= HttpVerbMaximum  ||
           pHttpRequest->Verb == HttpVerbUnparsed ||
           pHttpRequest->Verb == HttpVerbUnknown  ||
           pHttpRequest->Verb == HttpVerbInvalid
           )
        {
            return 0;
        }
        else
        {
            HeaderLength = EnumVerbTable[pHttpRequest->Verb].RawVerbLength;
        }
    }

    MethodLength = HeaderLength;
   
    // SP 
    HeaderLength ++;

    //
    // If we are going through a proxy, we need to compute space for the 
    // scheme & the server name.
    //
    if(pServInfo->bProxy)
    {
        HeaderLength += pServInfo->pServerInfo->AnsiServerNameLength;

        if(pServInfo->bSecure)
        {
            HeaderLength += HTTPS_PREFIX_ANSI_LENGTH;
        }
        else 
        {
            HeaderLength += HTTP_PREFIX_ANSI_LENGTH;
        }
    }

    //
    // Formulate the version. We'll support only 1.0 or 1.1 requests,
    // so we allocate space only for HTTP/1.1
    //

    HeaderLength += VERSION_SIZE;

    HeaderLength += CRLF_SIZE;       // CRLF

    //
    // Loop through the known headers.
    //

    for (i = 0; i < HttpHeaderRequestMaximum; ++i)
    {
        ULONG RawValueLength = pKnownHeaders[i].RawValueLength;

        //
        // skip some headers that we generate.
        //

        if (RawValueLength > 0 && 
            !g_RequestHeaderMapTable[g_RequestHeaderMap[i]].AutoGenerate)
        {
            HeaderLength += g_RequestHeaderMapTable[
                                g_RequestHeaderMap[i]
                                ].HeaderLength +                // Header-Name
                            1 +                                 // SP
                            RawValueLength +                    // Header-Value
                            CRLF_SIZE;                          // CRLF
        }
    }


    //
    // Include the default headers we may need to generate on behalf of the 
    // application. We do this only if the application has not specified any 
    // headers by itself.
    //

    pEntry = &(g_RequestHeaderMapTable[g_RequestHeaderMap[
                    HttpHeaderContentLength]]);

    if(bContentLengthHeader)
    {
        HeaderLength += (pEntry->HeaderLength + 1 + CRLF_SIZE);
        HeaderLength += MAX_ULONGLONG_STR;
    }
    else
    {
        if(!bChunked)    
        {
            //
            // We are going to compute the content length at some point
            // in the future. Might as well allocate a content length
            // for this right away. We do this to avoid allocating a 
            // new buffer + MDL when we know the actual length.
            //

            HeaderLength += (pEntry->HeaderLength + 1 + CRLF_SIZE);
            HeaderLength += MAX_ULONGLONG_STR;
        }
    }

    //
    // If we are using chunked encoding, we need to update the 
    // TransferEncoding field. If the app has already passed a 
    // value, we need to append "chunked" to the end of the Transfer
    // encoding.
    //

    if(bChunked)
    {
        pEntry = &(g_RequestHeaderMapTable[g_RequestHeaderMap[
                        HttpHeaderTransferEncoding]]);
        
        HeaderLength += (pEntry->HeaderLength + 1 + CRLF_SIZE);

        HeaderLength += CHUNKED_HDR_LENGTH; 
    }

    //
    // Add a host header - We'll override the app's header, even if they 
    // have passed one. This is done by the "AutoGenerate" flag
    //

    HeaderLength += g_RequestHeaderMapTable[
        g_RequestHeaderMap[HttpHeaderHost]
        ].HeaderLength +                // Header-Name
        1 +                             // SP
        pServInfo->pServerInfo->AnsiServerNameLength + // Value
        CRLF_SIZE;                      // CRLF

    //
    // And the unknown headers (this might throw an exception).
    //

    if (pUnknownHeaders != NULL)
    {
        for (i = 0 ; i < pHttpRequest->Headers.UnknownHeaderCount; ++i)
        {
            if (pUnknownHeaders[i].NameLength > 0)
            {
                HeaderLength += 
                    pUnknownHeaders[i].NameLength +     // Header-Name
                    1 +                                 // ':'
                    1 +                                 // SP
                    pUnknownHeaders[i].RawValueLength + // Header-Value
                    CRLF_SIZE;                          // CRLF

            }
        }
    }

    if(pHttpRequest->Headers.KnownHeaders
        [HttpHeaderAuthorization].RawValueLength == 0)
    {
        if(pAuth)
        {
            // User has passed auth credentials. We'll just use this.

            HeaderLength += pAuth->RequestAuthHeaderMaxLength;
        }
        else if((pServInfo->PreAuthEnable && 
                 pServInfo->GreatestAuthHeaderMaxLength))
        {
            HeaderLength += pServInfo->GreatestAuthHeaderMaxLength;
            *bPreAuth = TRUE;
        }
    }
    else
    {
        //
        // User has passed their creds, let's just use that. The space
        // for this was accounted when we computed the known header size.
        //
    }
    
    //
    // Do the same thing for Proxy Auth.
    //

    if(pHttpRequest->Headers.KnownHeaders
           [HttpHeaderProxyAuthorization].RawValueLength == 0)
    {
        if(pProxyAuth)
        {
            HeaderLength += pProxyAuth->RequestAuthHeaderMaxLength;
        }
        else if(pServInfo->ProxyPreAuthEnable && pServInfo->pProxyAuthInfo)
        {
            HeaderLength +=  
                pServInfo->pProxyAuthInfo->RequestAuthHeaderMaxLength;
            *bProxyPreAuth = TRUE;
        }
    }
    else
    {
        //
        // User has passed their creds, let's just use that. The space
        // for this was accounted when we computed the known header size.
        //
    }

    // Header terminator.
    HeaderLength += CRLF_SIZE;       // CRLF

    return HeaderLength;
    
}   // UcComputeRequestHeaderSize


/***************************************************************************++

Routine Description:

    Generates the header for HTTP requests. 

Arguments:

    pRequest             - The HTTP request structure passed by the app
    pKeRequest           - Our internal representation of the structure.  
    pAuth                - The Auth credentials as passed by the app.
    pProxyAuth           - The Proxy auth credentials as passed by the app.
    bChunked             - To indicate if we are using chunked encoding.
    ContentLength        - Content Length

--***************************************************************************/
NTSTATUS
UcGenerateRequestHeaders(
    IN  PHTTP_REQUEST          pRequest,
    IN  PUC_HTTP_REQUEST       pKeRequest,
    IN  BOOLEAN                bChunked,
    IN  ULONGLONG              ContentLength
    )
{
    PUCHAR                  pStartHeaders;
    ULONG                   BytesCopied;
    ULONG                   i;
    PHTTP_UNKNOWN_HEADER    pUnknownHeaders;
    ULONG                   RemainingLen = pKeRequest->MaxHeaderLength;
    PUCHAR                  pBuffer = pKeRequest->pHeaders;
    PSTR                    pMethod;
    ULONG                   MethodLength;
    NTSTATUS                Status = STATUS_SUCCESS;
    BOOLEAN                 bProxySslRequest = FALSE;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pRequest != NULL);
    ASSERT(pBuffer != NULL && RemainingLen > 0);

    //
    // Remember the start of the headers buffer.
    //

    pStartHeaders = pBuffer;

    //
    // Generate the request line.
    // Request-Line   = Method SP Request-URI SP HTTP-Version CRLF
    //

    pMethod = (PSTR) pBuffer;

    if(pRequest->UnknownVerbLength)
    {
        //
        // The app has passed an unknown verb.
        //

        COPY_DATA_TO_BUFFER(pBuffer,
                            RemainingLen,
                            pRequest->pUnknownVerb,
                            pRequest->UnknownVerbLength);
    }
    else
    {
        ASSERT(0 <= pRequest->Verb && pRequest->Verb < HttpVerbMaximum);

        COPY_DATA_TO_BUFFER(pBuffer,
                            RemainingLen,
                            EnumVerbTable[pRequest->Verb].RawVerb,
                            EnumVerbTable[pRequest->Verb].RawVerbLength);
    }

    MethodLength = (ULONG)((PUCHAR)pBuffer - (PUCHAR)pMethod);

    //
    // Add a SP.
    //

    COPY_SP_TO_BUFFER(pBuffer, RemainingLen);

    //
    // Copy the request URI.
    //

    if(pKeRequest->pServerInfo->bProxy)
    {
        //
        // Normally, when a proxy is present, an absoluteURI is generated
        // in the request.  In case of SSL, the proxy mainly acts as a tunnel.
        // We, therefore, don't generate an absoluteURI but generate
        // abs_path instead.
        //

        if(pKeRequest->pServerInfo->bSecure)
        {
            bProxySslRequest = TRUE;
        }
        else
        {
            //
            // Add "http://" prefix.
            //

            COPY_DATA_TO_BUFFER(pBuffer,
                                RemainingLen,
                                HTTP_PREFIX_ANSI,
                                HTTP_PREFIX_ANSI_LENGTH);

            //
            // Now, copy the server name.
            //

            COPY_DATA_TO_BUFFER(
                pBuffer,
                RemainingLen,
                pKeRequest->pServerInfo->pServerInfo->pAnsiServerName,
                pKeRequest->pServerInfo->pServerInfo->AnsiServerNameLength
                );
        }
    }

    //
    // Copy the Uri.
    //

    COPY_DATA_TO_BUFFER(pBuffer,
                        RemainingLen,
                        pKeRequest->pUri,
                        pKeRequest->UriLength);

    //
    // Add a SP.
    //

    COPY_SP_TO_BUFFER(pBuffer, RemainingLen);

    //
    // Add the protocol.
    //

    if(pRequest->Version.MajorVersion == 1)
    {
        if(pRequest->Version.MinorVersion == 1)
        {
            //
            // Copy "HTTP/1.1" string.
            //

            COPY_DATA_TO_BUFFER(pBuffer,
                                RemainingLen,
                                HTTP_VERSION_11,
                                VERSION_SIZE);
        }
        else if(pRequest->Version.MinorVersion == 0)
        {
            //
            // Copy "HTTP/1.0" string.
            //

            COPY_DATA_TO_BUFFER(pBuffer,
                                RemainingLen,
                                HTTP_VERSION_10,
                                VERSION_SIZE);
        }
        else
        {
            //
            // We don't support minor versions > 1.
            //

            return STATUS_INVALID_PARAMETER;
        }
    }
    else
    {
        //
        // We don't support major version != 1.
        //

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Terminate the request-line with a CRLF.
    //

    COPY_CRLF_TO_BUFFER(pBuffer, RemainingLen);

    //
    // Determine if we have to close the TCP connection after sending 
    // this request.
    //

    pKeRequest->RequestConnectionClose = 
        UcCheckDisconnectInfo(&pRequest->Version,
                              pRequest->Headers.KnownHeaders);

    //
    // Loop through the known headers.
    //
    
    for (i = 0; i < HttpHeaderRequestMaximum; ++i)
    {
        //
        // skip some headers we'll generate
        //

        if (pRequest->Headers.KnownHeaders[i].RawValueLength > 0)
        {
            PHEADER_MAP_ENTRY pEntry;

            pEntry = &(g_RequestHeaderMapTable[g_RequestHeaderMap[i]]);

            if(pEntry->AutoGenerate == FALSE)
            {
                //
                // Copy known header name followed by a ':' and a SP.
                //

                COPY_HEADER_NAME_SP_TO_BUFFER(pBuffer, RemainingLen, i);

                //
                // Copy known header value.
                //

                COPY_DATA_TO_BUFFER(
                    pBuffer,
                    RemainingLen,
                    pRequest->Headers.KnownHeaders[i].pRawValue,
                    pRequest->Headers.KnownHeaders[i].RawValueLength
                    );

                //
                // Terminate the header by CRLF.
                //

                COPY_CRLF_TO_BUFFER(pBuffer, RemainingLen);
            }
        }
    }

    //
    // Add a host header - We'll override the app's header, even if they 
    // have passed one. This is done by the "AutoGenerate" flag.
    //

    // Copy "Host: " string.
    COPY_HEADER_NAME_SP_TO_BUFFER(pBuffer, RemainingLen, HttpHeaderHost);

    // Copy server name.
    COPY_DATA_TO_BUFFER(
        pBuffer,
        RemainingLen,
        pKeRequest->pServerInfo->pServerInfo->pAnsiServerName,
        pKeRequest->pServerInfo->pServerInfo->AnsiServerNameLength
        );

    // Terminate the host header with a CRLF.
    COPY_CRLF_TO_BUFFER(pBuffer, RemainingLen);

    //
    // Generate the content length header.
    //

    if(ContentLength)
    {
        Status = UcGenerateContentLength(ContentLength,
                                         pBuffer,
                                         RemainingLen,
                                         &BytesCopied);
        if (!NT_SUCCESS(Status))
        {
            return Status;
        }

        ASSERT(BytesCopied <= RemainingLen);

        ADVANCE_POINTER(pBuffer, RemainingLen, BytesCopied);
    }

    if(bChunked)
    {
        //
        // If we are using chunked encoding, we have to add the
        // "Transfer-Encoding: chunked" header. 
        //

        // Copy header name - "Transfer-Encoding: ".
        COPY_HEADER_NAME_SP_TO_BUFFER(pBuffer,
                                      RemainingLen,
                                      HttpHeaderTransferEncoding);

        // Copy header value - "chunked".
        COPY_DATA_TO_BUFFER(pBuffer,
                            RemainingLen,
                            CHUNKED_HDR,
                            CHUNKED_HDR_LENGTH);

        // Terminate header with CRLF.
        COPY_CRLF_TO_BUFFER(pBuffer, RemainingLen);
    }
    
    //
    // And now the unknown headers 
    //
    
    pUnknownHeaders = pRequest->Headers.pUnknownHeaders;
    if (pUnknownHeaders != NULL)
    {
        for (i = 0 ; i < pRequest->Headers.UnknownHeaderCount; ++i)
        {
            if (pUnknownHeaders[i].NameLength > 0)
            {
                // First, copy the header name.
                COPY_DATA_TO_BUFFER(pBuffer,
                                    RemainingLen,
                                    pUnknownHeaders[i].pName,
                                    pUnknownHeaders[i].NameLength);

                // Copy ':' after header name.
                COPY_UCHAR_TO_BUFFER(pBuffer, RemainingLen, ':');

                // Add a space.
                COPY_SP_TO_BUFFER(pBuffer, RemainingLen);

                // Now, copy the header value.
                COPY_DATA_TO_BUFFER(pBuffer,
                                    RemainingLen,
                                    pUnknownHeaders[i].pRawValue,
                                    pUnknownHeaders[i].RawValueLength);

                // Terminate the header with a CRLF.
                COPY_CRLF_TO_BUFFER(pBuffer, RemainingLen);

            } // if (pUnknownHeaders[i].NameLength > 0)
        }
    } // if (pUnknownHeaders != NULL)

    //
    // Generate the Authorization headers. This should be done at the very last
    // since we might have to update the Authorization header & re-issue the 
    // request (for NTLM/kerberos). The size of the new Authorization header
    // will not be the same as the old one. 
    //
    // If the Authorization header is at the end, we can easily re-generate it.
    // and append it with the existing headers. 
    //
    // The one exception to this rule is content-length - If the app is 
    // indicating data in chunks and has not specified a content-length, it will
    // get generated at the very end. But this is no big deal. We can easily 
    // re-generate the content-length hdr.
    //

    if(pRequest->Headers.KnownHeaders[HttpHeaderAuthorization].RawValueLength 
       == 0)
    {
        if(pKeRequest->pAuthInfo)
        {
            //
            // User has supplied credentials, we have to use it.
            //

            Status =
                UcGenerateAuthHeaderFromCredentials(
                    pKeRequest->pServerInfo,
                    pKeRequest->pAuthInfo,
                    HttpHeaderAuthorization,
                    pMethod,
                    MethodLength,
                    pKeRequest->pUri,
                    pKeRequest->UriLength,
                    pBuffer,
                    RemainingLen,
                    &BytesCopied,
                    &pKeRequest->DontFreeMdls
                    );

            if(!NT_SUCCESS(Status))
            {
                return(Status);
            }

            ASSERT(BytesCopied <= RemainingLen);
            ADVANCE_POINTER(pBuffer, RemainingLen, BytesCopied);
        }
        else if (pKeRequest->RequestFlags.UsePreAuth)
        {
            //
            // See if PreAuth is enabled. We cannot check for the
            // pServerInfo->PreAuth flag here. We check for this
            // in the UcpComputeAuthHeaderSize function. If we check
            // for this here, we cannot be sure that this flag was
            // set when we called UcpComputeAuthHeaderSize
            //

            UcFindURIEntry(pKeRequest->pServerInfo,
                           pKeRequest->pUri,
                           pKeRequest,
                           pMethod,
                           MethodLength,
                           pBuffer,
                           RemainingLen,
                           &BytesCopied);

            ASSERT(BytesCopied <= RemainingLen);
            ADVANCE_POINTER(pBuffer, RemainingLen, BytesCopied);
        }
    }

    if (pRequest->Headers.KnownHeaders[HttpHeaderProxyAuthorization].
        RawValueLength == 0)
    {

        if (pKeRequest->pProxyAuthInfo)
        {
            if(!bProxySslRequest)
            {
                Status = 
                        UcGenerateAuthHeaderFromCredentials(
                            pKeRequest->pServerInfo,
                            pKeRequest->pProxyAuthInfo,
                            HttpHeaderProxyAuthorization,
                            pMethod,
                            MethodLength,
                            pKeRequest->pUri,
                            pKeRequest->UriLength,
                            pBuffer,
                            RemainingLen,
                            &BytesCopied,
                            &pKeRequest->DontFreeMdls
                            );

                if(!NT_SUCCESS(Status))
                {
                    return(Status);
                }

                ASSERT(BytesCopied <= RemainingLen);
                ADVANCE_POINTER(pBuffer, RemainingLen, BytesCopied);
            }
        } 
        else if (pKeRequest->RequestFlags.UseProxyPreAuth && !bProxySslRequest)
        {
            Status = UcGenerateProxyAuthHeaderFromCache(pKeRequest,
                                                        pMethod,
                                                        MethodLength,
                                                        pBuffer,
                                                        RemainingLen,
                                                        &BytesCopied);

            if (!NT_SUCCESS(Status))
            {
                return Status;
            }

            ASSERT(BytesCopied <= RemainingLen);
            ADVANCE_POINTER(pBuffer, RemainingLen, BytesCopied);
        }
    }

    pKeRequest->HeaderLength = DIFF(pBuffer - pStartHeaders);

    //
    // Ensure we didn't use too much.
    //

    ASSERT(pBuffer <= pStartHeaders + pKeRequest->MaxHeaderLength);

    return Status;

}   // UcGenerateRequestHeaders


/***************************************************************************++

Routine Description:

    Generates the content length header.

Arguments:

    ContentLength - Supplies the content length.
    pBuffer - Supplies pointer to the output buffer.
    BufferLen - Supplies length of the output buffer.
    BytesWritten - Returns the number of bytes consumed from the buffer.

Return Value:

    NTSTATUS.

--***************************************************************************/
NTSTATUS
UcGenerateContentLength(
    IN  ULONGLONG ContentLength,
    IN  PUCHAR    pBuffer,
    IN  ULONG     BufferLen,
    OUT PULONG    pBytesWritten
    )
{
    PUCHAR            pBufferTemp;
    ULONG             BufferLenTemp;

    // Initialize locals.
    pBufferTemp = pBuffer;
    BufferLenTemp = BufferLen;

    *pBytesWritten = 0;

    //
    // Copy "Content-Length:" header name and a space.
    //

    COPY_HEADER_NAME_SP_TO_BUFFER(pBuffer,
                                  BufferLen,
                                  HttpHeaderContentLength);

    //
    // Check if there is enough space to copy ULONGLONG content length
    // in string format and a CRLF.
    //

    if (MAX_ULONGLONG_STR + CRLF_SIZE > BufferLen)
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    pBuffer = (PUCHAR) UlStrPrintUlonglong((PCHAR) pBuffer,
                                           ContentLength,
                                           '\0');
    //
    //
    //
    BufferLen -= MAX_ULONGLONG_STR;

    COPY_CRLF_TO_BUFFER(pBuffer, BufferLen);

    *pBytesWritten = (ULONG)(pBuffer - pBufferTemp);
    ASSERT(*pBytesWritten <= BufferLenTemp);

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Figures out the header size for the CONNECT verb. 


Arguments:

    pServInfo      - The server information.
    pProxyAuthInfo - Proxy auth info.

Return Values:

    The number of bytes in the fixed headers.

--***************************************************************************/
ULONG
UcComputeConnectVerbHeaderSize(
    IN  PUC_PROCESS_SERVER_INFORMATION  pServInfo,
    IN  PUC_HTTP_AUTH                   pProxyAuthInfo
    )
{

#define PROXY_CONNECTION_KEEPALIVE "Proxy-Connection: Keep-Alive"
#define PROXY_CONNECTION_KEEPALIVE_SIZE (sizeof(PROXY_CONNECTION_KEEPALIVE)-1)

    ULONG HeaderLength;

    //
    // IE adds the following headers as well.
    // UserAgent:
    // Content-Length : 0
    // Pragma: no-cache
    //

    HeaderLength = 
        EnumVerbTable[HttpVerbCONNECT].RawVerbLength  +  // Method
        1                                             +  // SP 
        pServInfo->pServerInfo->AnsiServerNameLength  +  // URI
        4                                             +  // port
        1                                             +  // SP 
        VERSION_SIZE                                  +  // Version
        CRLF_SIZE;

    //
    // Add a host header
    //

    HeaderLength += 
            g_RequestHeaderMapTable[
                                   g_RequestHeaderMap[HttpHeaderHost]
                                   ].HeaderLength +
            1 +                                            // SP
            pServInfo->pServerInfo->AnsiServerNameLength + // Value
            CRLF_SIZE;                                     // CRLF

    //
    // Add a Proxy keepalive.
    //
    HeaderLength += PROXY_CONNECTION_KEEPALIVE_SIZE + CRLF_SIZE;


    //
    // If we are doing proxy auth, add a proxy auth header. Since we have 
    // already generated this header when we built the request, we can 
    // just clone it from there.
    //

    if (pProxyAuthInfo)
    {
        HeaderLength += pProxyAuthInfo->RequestAuthHeaderMaxLength;
    }
    else if(pServInfo->ProxyPreAuthEnable && pServInfo->pProxyAuthInfo)
    {
        HeaderLength += pServInfo->pProxyAuthInfo->RequestAuthHeaderMaxLength;
    }

    //
    // Terminate
    //
    HeaderLength += CRLF_SIZE;

    return HeaderLength;
}


/***************************************************************************++

Routine Description:

    Generates the header size for the CONNECT verb. 


Arguments:

    pServInfo          - The server information.
    pProxyAuthInfo     - Proxy auth info.

Return Values:

    Status.

--***************************************************************************/
NTSTATUS
UcGenerateConnectVerbHeader(
    IN  PUC_HTTP_REQUEST       pRequest,
    IN  PUC_HTTP_REQUEST       pHeadRequest,
    IN  PUC_HTTP_AUTH          pProxyAuthInfo
    )
{
    PUCHAR   pBuffer, pStartHeaders;
    PUCHAR   pUri;
    USHORT   UriLength;
    ULONG    BytesWritten;
    ULONG    RemainingLength;
    NTSTATUS Status;

    //
    // Remember the start of header and max total header length.
    //

    pStartHeaders = pBuffer = pRequest->pHeaders;
    RemainingLength = pRequest->MaxHeaderLength;

    //
    // Copy "CONNECT" verb.
    //

    COPY_DATA_TO_BUFFER(pBuffer,
                        RemainingLength,
                        EnumVerbTable[HttpVerbCONNECT].RawVerb,
                        EnumVerbTable[HttpVerbCONNECT].RawVerbLength);

    // Copy a SP.
    COPY_SP_TO_BUFFER(pBuffer, RemainingLength);

    //
    // Now, the URI. The URI here is the name of the origin server
    // followed by the port number.
    //

    pUri = pBuffer;

    COPY_DATA_TO_BUFFER(
       pBuffer,
       RemainingLength,
       pRequest->pServerInfo->pServerInfo->pAnsiServerName,
       pRequest->pServerInfo->pServerInfo->AnsiServerNameLength
       );

    //
    // If server name does not have a port number, include the default
    // port number.  Note that, the only way the port number could be
    // different is when it is present in the server name.
    //

    if (!pRequest->pServerInfo->pServerInfo->bPortNumber)
    {
        //
        // Copy the default port number.
        //

        COPY_DATA_TO_BUFFER(pBuffer,
                            RemainingLength,
                            ":443",
                            STRLEN_LIT(":443"));
    }

    UriLength = DIFF_USHORT(pBuffer - pUri);

    //
    // Remember URI and Uri Length in Request structure for future use.
    //

    pRequest->UriLength = UriLength;
    pRequest->pUri      = (PSTR) pUri;

    // Add a space
    COPY_SP_TO_BUFFER(pBuffer, RemainingLength);

    //
    // Add the protocol.
    //

    COPY_DATA_TO_BUFFER(pBuffer,
                        RemainingLength,
                        HTTP_VERSION_11,
                        VERSION_SIZE);

    //
    // Terminate the request-line with a CRLF.
    //

    COPY_CRLF_TO_BUFFER(pBuffer, RemainingLength);

    //
    // Generate the host header
    //

    COPY_HEADER_NAME_SP_TO_BUFFER(pBuffer, RemainingLength, HttpHeaderHost);

    COPY_DATA_TO_BUFFER(
        pBuffer,
        RemainingLength,
        pRequest->pServerInfo->pServerInfo->pAnsiServerName,
        pRequest->pServerInfo->pServerInfo->AnsiServerNameLength
        );

    COPY_CRLF_TO_BUFFER(pBuffer, RemainingLength);

    //
    // Proxy Keepalive
    //

    COPY_DATA_TO_BUFFER(pBuffer,
                        RemainingLength,
                        PROXY_CONNECTION_KEEPALIVE,
                        PROXY_CONNECTION_KEEPALIVE_SIZE);

    COPY_CRLF_TO_BUFFER(pBuffer, RemainingLength);

    //
    // Proxy Auth
    //

    if (pProxyAuthInfo)
    {
        Status = UcGenerateAuthHeaderFromCredentials(
                     pRequest->pServerInfo,
                     pProxyAuthInfo,
                     HttpHeaderProxyAuthorization,
                     (PSTR)EnumVerbTable[HttpVerbCONNECT].RawVerb,
                     EnumVerbTable[HttpVerbCONNECT].RawVerbLength,
                     (PSTR) pUri,
                     UriLength,
                     pBuffer,
                     RemainingLength,
                     &BytesWritten,
                     &pRequest->DontFreeMdls
                     );

        //
        // What do we do if this fails ? It's probably OK to just send the
        // request which will result in another 401. There is no clean way 
        // of propogating this to the app.
        //

        if (NT_SUCCESS(Status))
        {
            ASSERT(BytesWritten <= RemainingLength);
            ADVANCE_POINTER(pBuffer, RemainingLength, BytesWritten);
        }
    }
    else if(pRequest->pServerInfo->ProxyPreAuthEnable && 
            pRequest->pServerInfo->pProxyAuthInfo)
    {
        Status = UcGenerateProxyAuthHeaderFromCache(
                     pHeadRequest,
                     (PSTR) EnumVerbTable[HttpVerbCONNECT].RawVerb,
                     EnumVerbTable[HttpVerbCONNECT].RawVerbLength,
                     pBuffer,
                     RemainingLength,
                     &BytesWritten
                     );

        if (NT_SUCCESS(Status))
        {
            ASSERT(BytesWritten < RemainingLength);
            ADVANCE_POINTER(pBuffer, RemainingLength, BytesWritten);
        }
    }

    //
    // Header end.
    //

    COPY_CRLF_TO_BUFFER(pBuffer, RemainingLength);

    pRequest->HeaderLength = DIFF(pBuffer - pStartHeaders);
    ASSERT(pRequest->HeaderLength <= pRequest->MaxHeaderLength);

    return STATUS_SUCCESS;
}

//
// Convert '%xy' to byte value  (works with Unicode strings)
//

NTSTATUS
UnescapeW(
    IN  PCWSTR pWChar,
    OUT PWCHAR pOutWChar
    )

{
    WCHAR Result, Digit;

    //
    // Sanity check.
    //

    if (pWChar[0] != '%' || pWChar[1] >= 0x80 || pWChar[2] >= 0x80 ||
        !IS_HTTP_HEX(pWChar[1]) || !IS_HTTP_HEX(pWChar[2]))
    {
        UlTraceError(PARSER, (
                    "ul!Unescape( %C%C%C ) not HTTP_HEX format\n",
                    pWChar[0],
                    pWChar[1],
                    pWChar[2]
                    ));

        return STATUS_OBJECT_PATH_SYNTAX_BAD;
    }

    //
    // HexToChar() inlined. Note: '0' < 'A' < 'a'
    //

    // uppercase #1
    //
    if ('a' <= pWChar[1])
    {
        ASSERT('a' <= pWChar[1]  &&  pWChar[1] <= 'f');
        Digit = pWChar[1] - 'a' + 0xA;
    }
    else if ('A' <= pWChar[1])
    {
        ASSERT('A' <= pWChar[1]  &&  pWChar[1] <= 'F');
        Digit = pWChar[1] - 'A' + 0xA;
    }
    else
    {
        ASSERT('0' <= pWChar[1]  &&  pWChar[1] <= '9');
        Digit = pWChar[1] - '0';
    }

    ASSERT(Digit < 0x10);

    Result = Digit << 4;

    // uppercase #2
    //
    if ('a' <= pWChar[2])
    {
        ASSERT('a' <= pWChar[2]  &&  pWChar[2] <= 'f');
        Digit = pWChar[2] - 'a' + 0xA;
    }
    else if ('A' <= pWChar[2])
    {
        ASSERT('A' <= pWChar[2]  &&  pWChar[2] <= 'F');
        Digit = pWChar[2] - 'A' + 0xA;
    }
    else
    {
        ASSERT('0' <= pWChar[2]  &&  pWChar[2] <= '9');
        Digit = pWChar[2] - '0';
    }

    ASSERT(Digit < 0x10);

    Result |= Digit;

    *pOutWChar = Result;

    return STATUS_SUCCESS;

}   // UnescapeW

__inline
BOOLEAN
UcCheckDisconnectInfo(
    IN PHTTP_VERSION       pVersion,
    IN PHTTP_KNOWN_HEADER  pKnownHeaders
    )
{
    BOOLEAN Disconnect;

    //
    // Sanity check
    //

    if (
        //
        // or version 1.0 with no Connection: Keep-Alive
        // CODEWORK: and no Keep-Alive header
        //

        (HTTP_EQUAL_VERSION(*pVersion, 1, 0) &&
            (pKnownHeaders[HttpHeaderConnection].RawValueLength == 0 ||
            !(pKnownHeaders[HttpHeaderConnection].RawValueLength == 10 &&
                (_stricmp(
                   (const char*) pKnownHeaders[HttpHeaderConnection].pRawValue,
                    "keep-alive"
                    ) == 0)))) ||

        //
        // or version 1.1 with a Connection: close
        // CODEWORK: move to parser or just make better in general..
        //

        (HTTP_EQUAL_VERSION(*pVersion, 1, 1) &&
            pKnownHeaders[HttpHeaderConnection].RawValueLength == 5 &&
            _stricmp((const char*) 
                pKnownHeaders[HttpHeaderConnection].pRawValue, "close") == 0)
        )
    {
        Disconnect = TRUE;
    } 
    else 
    {
        Disconnect = FALSE;
    }

    return Disconnect;
}


/***************************************************************************++

Routine Description:

    Canonicalizes abs path in a URI.  The tasks performed are:
    - Remove extra '/'             e.g. /a///b       => /a/b
    - Process '.' and '..'         e.g. /./a/../b    => /b
    - Copy Query string as it is
    - Copy Fragment as it is
    - Encode the output in UTF8
    - Optionally hex encode bytes >= 0x80

Arguments:
    IN      pInUri       Input URI in Unicode
    IN      InUriLen     Length of input URI (in CHAR)
    IN      pOutUri      Pointer to the output buffer
    IN OUT  pOutUriLen   Length of the output buffer
                         the actual number of bytes written is returned back
    IN      bEncode      TRUE if chars >= 0x80 should be escaped

Return Values:

    Status.

--***************************************************************************/

UCHAR NextStateTable[TOTAL_STATES][CHAR_TOTAL_TYPES+2] = INIT_TRANSITION_TABLE;
UCHAR (*ActionTable)[TOTAL_STATES][CHAR_TOTAL_TYPES+2] = &NextStateTable;

#define NEXT_STATE(state, type) ((NextStateTable[state][type])&0xf)
#define ACTION(state, type)   ((((*ActionTable)[state][type])>>4)&0xf)

//
// Macro to read next char from the input URI
// The macro handles correctly a '.' char even if it is escaped as %2E (or %2e)
// HttpChars is used to quickly lookup '/', '.', '#' or '?' chars
//
#define GET_NEXT_CHAR(pInUri, CharsLeft, CurrChar, CurrCharType)    \
    do                                                              \
    {                                                               \
        CurrCharType = CHAR_END_OF_STRING;                          \
        if (CharsLeft == 0)                                         \
            break;                                                  \
                                                                    \
        CurrChar = *pInUri++;                                       \
        CharsLeft--;                                                \
                                                                    \
        CurrCharType = CHAR_EXTENDED_CHAR;                          \
        if (CurrChar >= 0x80)                                       \
            break;                                                  \
                                                                    \
        if (CurrChar == '%')                                        \
        {                                                           \
            WCHAR UnescapedChar;                                    \
                                                                    \
            if (CharsLeft < 2)                                      \
                goto error;                                         \
                                                                    \
            pInUri--;                                               \
            CharsLeft++;                                            \
                                                                    \
            if (!NT_SUCCESS(UnescapeW(pInUri, &UnescapedChar)))     \
                goto error;                                         \
                                                                    \
            pInUri++;                                               \
            CharsLeft--;                                            \
                                                                    \
            if (UnescapedChar == '.')                               \
            {                                                       \
                CurrChar = L'.';                                    \
                pInUri += 2;                                        \
                CharsLeft -= 2;                                     \
            }                                                       \
        }                                                           \
                                                                    \
        CurrCharType = (HttpChars[CurrChar]>>HTTP_CHAR_SHIFT);      \
        if (CurrCharType == 0)                                      \
            CurrCharType = (IS_URL_TOKEN(CurrChar))?                \
                           CHAR_PATH_CHAR : CHAR_INVALID_CHAR;      \
                                                                    \
    } while (0)


//
// Output a BYTE to the output buffer.
// PERF NOTE: Replace the comparision of OutBufLeft by an ASSERT.
//
#define EMIT_A_BYTE(b)                          \
    do                                          \
    {                                           \
        ASSERT(b < 0x80);                       \
                                                \
        if (OutBufLeft == 0)                    \
            goto overflow;                      \
                                                \
        *pOutput++ = (b);                       \
        OutBufLeft--;                           \
    } while (0)


//
// Output a CHAR to the output buffer. Encodes a UNICODE char in UTF8.
// The UTF8 char is escaped if bEncode is specified.
//
#define EMIT_A_CHAR(c)                                          \
    do {                                                        \
        ULONG adj;                                              \
                                                                \
        if (OutBufLeft == 0)                                    \
            goto overflow;                                      \
                                                                \
        if ((c) < 0x80)                                         \
        {                                                       \
            *pOutput++ = (UCHAR)(c);                            \
            OutBufLeft--;                                       \
            break;                                              \
        }                                                       \
                                                                \
        if (!NT_SUCCESS(HttpUnicodeToUTF8Encode(&c, 1, pOutput, OutBufLeft, &adj, bEncode)))                                                   \
            goto overflow;                                      \
                                                                \
        pOutput += adj;                                         \
        OutBufLeft -= adj;                                      \
                                                                \
    } while (0)

//
// Main routine.
//
NTSTATUS
UcCanonicalizeURI(
    IN     LPCWSTR    pInUri,     // Input URI in Unicode
    IN     USHORT     InUriLen,   // Length of input URI (in wchar)
    IN OUT PUCHAR     pOutUri,    // buffer where the output goes
    IN OUT PUSHORT    pOutUriLen, // length of the output buffer
    IN     BOOLEAN    bEncode     // TRUE if char >= 0x80 should be escaped
    )
{
    ULONG    state, nstate, action;

    WCHAR    CurrChar = L'\0';
    ULONG    CurrCharType;

    PUCHAR   pOutput    = pOutUri;
    ULONG    OutBufLeft = *pOutUriLen;

    // Sanity check
    ASSERT(pInUri && InUriLen != 0);
    ASSERT(pOutUri && *pOutUriLen != 0);

    nstate = state = 0;

    do
    {
        GET_NEXT_CHAR(pInUri, InUriLen, CurrChar, CurrCharType);

        nstate = NEXT_STATE(state, CurrCharType);

        action = ACTION(state, CurrCharType);

        UlTraceVerbose(PARSER, ("UcCanonicalizeURI: CurrChar = 0x%02x, "
                         "CurrCharType = %ld, state %ld, nstate = %ld\n",
                         (ULONG)CurrChar, CurrCharType, state, nstate));

        switch (action)
        {
        case ACT_EMIT_DOT_DOT_CHAR:
            EMIT_A_BYTE('.');
            // fall through
        case ACT_EMIT_DOT_CHAR:
            EMIT_A_BYTE('.');
            // fall through
        case ACT_EMIT_CHAR:
            EMIT_A_CHAR(CurrChar);
            break;

        case ACT_NONE:
            break;

        case ACT_BACKUP:
        case ACT_BACKUP_EMIT_CHAR:
            ASSERT(pOutput > pOutUri && pOutput[-1] == '/' && *pOutUri == '/');
            //
            // Can we backup?  (e.g. if the URI is "/../", we can't)
            //
            if (pOutput > pOutUri + 1) 
            {
                // Yes we can backup to a pervious '/'
                pOutput -= 2;
                while (*pOutput != '/')
                    pOutput--, OutBufLeft++;
                pOutput++;

                OutBufLeft += 1;

                ASSERT(pOutput > pOutUri);
            }
            
            if (action == ACT_BACKUP_EMIT_CHAR)
                EMIT_A_CHAR(CurrChar);
            break;

        case ACT_ERROR:
            // URI is invalid
            goto error;
            break;

        case ACT_PANIC:
            // Internal error...we shouldn't be here!
        default:
            UlTraceError(PARSER, ("UcCanonicalizeURI: internal error\n"));
            ASSERT(FALSE);
            break;
        }

        state = nstate;

    } while (state != 6);

    ASSERT(pOutput >= pOutUri && pOutput <= pOutUri + *pOutUriLen);
    UlTrace(PARSER, ("UcCanonicalizeURI: Return length = %d\n", 
                     pOutput - pOutUri));

    // return the actual number of bytes written to the output buffer
    *pOutUriLen = (USHORT)(pOutput - pOutUri);

    return STATUS_SUCCESS;

 error:
    // Invalid URI
    return STATUS_INVALID_PARAMETER;

 overflow:
    // Output buffer is not big enough
    return STATUS_INSUFFICIENT_RESOURCES;
}


//
// Response Parser functions.
// 

/***************************************************************************++

Routine Description:

    Find the header name terminator of a header:value pair.

Arguments:

    pHttpRequest        - Pointer to the current request.
    HttpRequestLength   - Bytes left in the request.
    HeaderNameLength    - Pointer to return header name.

Return Value:

    STATUS_SUCCESS                  : Worked.
    STATUS_INVALID_DEVICE_REQUEST   : Invalid header.
    STATUS_MORE_PROCESSING_REQUIRED : More data required.

--***************************************************************************/
NTSTATUS
UcFindHeaderNameEnd(
    IN  PUCHAR pHttpRequest,
    IN  ULONG  HttpRequestLength,
    OUT PULONG HeaderNameLength
    )
{
    ULONG     CurrentOffset;
    NTSTATUS  Status;
    UCHAR     CurrentChar;

    for (CurrentOffset = 0; CurrentOffset < HttpRequestLength; CurrentOffset++)
    {
        CurrentChar = *(pHttpRequest + CurrentOffset);

        if (CurrentChar == ':')
        {
            // We've found the end of the header.
            break;
        }
        else
        {
            if (!IS_HTTP_TOKEN(CurrentChar))
            {
                // Uh-oh, this isn't a valid header. What do we do now?
                //

                UlTraceError(PARSER,
                        ("[UcFindHeaderNameEnd]: Bogus header \n"));

                return STATUS_INVALID_DEVICE_REQUEST;
            }
        }

    }

    // Find out why we got out. If the current offset is less than the
    // header length, we got out because we found the :.

    if (CurrentOffset < HttpRequestLength)
    {
        // Found the terminator. Point Beyond the terminator.
        *HeaderNameLength = CurrentOffset + 1;

        if(*HeaderNameLength > ANSI_STRING_MAX_CHAR_LEN)
        {   
            UlTraceError(PARSER,
                    ("[UcFindHeaderNameEnd]: Very long header name \n"));
            *HeaderNameLength = 0;
            Status = STATUS_INVALID_NETWORK_RESPONSE;
        }
        else
        {
            Status = STATUS_SUCCESS;
        }
    }
    else
    {
        // Didn't find the :, need more.
        //
        *HeaderNameLength = 0;
        Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    return Status;

}

/***************************************************************************++

Routine Description:

    Find the end of header value. 

Arguments:

    pHeaderValue          - Pointer to the header value
    RemainingBufferLength - Bytes remaining
    ppFoldingHeader       - Will be Non NULL if we allocate from pool to do 
                            header folding. Caller has to free this buffer.
    pBytesTaken           - Bytes Consumed.

Return Value:

    STATUS_SUCCESS                  : Worked.
    STATUS_INVALID_DEVICE_REQUEST   : Invalid header.
    STATUS_MORE_PROCESSING_REQUIRED : More data required.

--***************************************************************************/
NTSTATUS
UcFindHeaderValueEnd(
    IN PUCHAR    pHeaderValue,
    IN ULONG     RemainingBufferLength,
    IN PUCHAR    *ppFoldingHeader,
    IN PULONG    pBytesTaken
    )
{
    ULONG    BytesTaken = 0;
    PUCHAR   pFoldingBuffer;
    NTSTATUS Status;

    ASSERT(NULL == *ppFoldingHeader);

    //
    // Find the end of the header value
    //
    Status = FindHeaderEndReadOnly(
                    pHeaderValue,
                    RemainingBufferLength,
                    &BytesTaken
                    );

    if(STATUS_MORE_PROCESSING_REQUIRED == Status)
    {
        // 
        // The headers need to be folded. Since we can't modify TCP's data
        // we'll allocate a buffer for this. We don't really care to optimize
        // for this case, because header folding is pretty rare, so we won't 
        // bother with lookaside lists, etc.
        //

        pFoldingBuffer = UL_ALLOCATE_POOL(
                            NonPagedPool,
                            RemainingBufferLength,
                            UC_HEADER_FOLDING_POOL_TAG
                            );

        if(!pFoldingBuffer)
        {
            // Can't use STATUS_INSUFFICIENT_RESOURCES because it means 
            // something else.

            return STATUS_NO_MEMORY;
        }

        RtlCopyMemory(pFoldingBuffer,
                      pHeaderValue,
                      RemainingBufferLength
                      );

        Status = FindHeaderEnd(
                    pFoldingBuffer,
                    RemainingBufferLength,
                    &BytesTaken
                    );

        if(!NT_SUCCESS(Status))
        {
            ASSERT(BytesTaken == 0);

            UL_FREE_POOL(pFoldingBuffer, UC_HEADER_FOLDING_POOL_TAG);

            return Status;
        }
        else
        {
            if(BytesTaken == 0)
            {
                UL_FREE_POOL(pFoldingBuffer, UC_HEADER_FOLDING_POOL_TAG);

                return STATUS_MORE_PROCESSING_REQUIRED;
            }
            else if(BytesTaken > ANSI_STRING_MAX_CHAR_LEN)
            {
                UL_FREE_POOL(pFoldingBuffer, UC_HEADER_FOLDING_POOL_TAG);
    
                UlTraceError(PARSER,
                        ("[UcFindHeaderValueEnd]: Very long header value \n"));
    
                return STATUS_INVALID_NETWORK_RESPONSE;
            }
        }

        *ppFoldingHeader = pFoldingBuffer;
    }
    else if(NT_SUCCESS(Status))
    {
        if(BytesTaken == 0)
        {
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
        else if(BytesTaken > ANSI_STRING_MAX_CHAR_LEN)
        {
            UlTraceError(PARSER,
                    ("[UcFindHeaderValueEnd]: Very long header value \n"));

            return STATUS_INVALID_NETWORK_RESPONSE;
        }
    }

    *pBytesTaken = BytesTaken;

    return Status;
}

/***************************************************************************++

Routine Description:

    Look up a header that we don't have in our fast lookup table. This
    could be because it's a header we don't understand, or because we
    couldn't use the fast lookup table due to insufficient buffer length.
    The latter reason is uncommon, but we'll check the input table anyway
    if we're given one. If we find a header match in our mapping table,
    we'll call the header handler. Otherwise we'll try to allocate an
    unknown header element, fill it in and chain it on the http connection.

Arguments:

    pHttpConn           - Pointer to the current connection on which the
                            request arrived.
    pHttpRequest        - Pointer to the current request.
    HttpRequestLength   - Bytes left in the request.
    pHeaderMap          - Pointer to start of an array of header map entries
                            (may be NULL).
    HeaderMapCount      - Number of entries in array pointed to by pHeaderMap.

Return Value:

    Number of bytes in the header (including CRLF), or 0 if we couldn't
    parse the header.

--***************************************************************************/
NTSTATUS
UcpLookupHeader(
    IN  PUC_HTTP_REQUEST      pRequest,
    IN  PUCHAR                pHttpRequest,
    IN  ULONG                 HttpRequestLength,
    IN  PHEADER_MAP_ENTRY     pHeaderMap,
    IN  ULONG                 HeaderMapCount,
    OUT ULONG  *              pBytesTaken
    )
{
    NTSTATUS               Status = STATUS_SUCCESS;
    ULONG                  HeaderNameLength;
    ULONG                  i;
    ULONG                  BytesTaken;
    ULONG                  HeaderValueLength, RemainingBufferLength;
    PUCHAR                 pBufferHead;
    PUCHAR                 pBufferTail;
    PHTTP_UNKNOWN_HEADER   pUnknownHeader;
    PUCHAR                 pHeaderValue;
    PUCHAR                 pFoldingBuffer = NULL;
    ULONG                  AlignNameLength, AlignValueLength;


    // First, let's find the terminating : of the header name, if there is one.
    // This will also give us the length of the header, which we can then
    // use to search the header map table if we have one.
    //

    Status = UcFindHeaderNameEnd(
                pHttpRequest,
                HttpRequestLength,
                &HeaderNameLength
                );

    if(!NT_SUCCESS(Status))
    {   
        return Status;
    }

    // See if we have a header map array we need to search.
    //
    if (pHeaderMap != NULL)
    {
        // We do have an array to search.
        for (i = 0; i < HeaderMapCount; i++)
        {
            ASSERT(pHeaderMap->pClientHandler != NULL);

            if (HeaderNameLength == pHeaderMap->HeaderLength &&
                _strnicmp(
                    (const char *)(pHttpRequest),
                    (const char *)(pHeaderMap->Header.HeaderChar),
                    HeaderNameLength
                    ) == 0  &&
                pHeaderMap->pClientHandler != NULL)
            {

                // First, find the header end.

                pHeaderValue          = pHttpRequest + HeaderNameLength;
                RemainingBufferLength = (HttpRequestLength - HeaderNameLength);

                Status = UcFindHeaderValueEnd(
                            pHeaderValue,
                            RemainingBufferLength,
                            &pFoldingBuffer,
                            &BytesTaken
                            );

                if(!NT_SUCCESS(Status))
                {
                    return Status;
                }
           
                ASSERT(BytesTaken >= CRLF_SIZE);

                HeaderValueLength = BytesTaken - CRLF_SIZE;

                if(pFoldingBuffer != NULL)
                {
                    pHeaderValue = pFoldingBuffer;
                }

                UC_PROCESS_HEADER_VALUE(pHeaderValue,  HeaderValueLength);

                // This header matches. Call the handling function for it.
                Status = (*(pHeaderMap->pClientHandler))(
                                pRequest,
                                pHeaderValue,
                                HeaderValueLength,
                                pHeaderMap->HeaderID
                                );

                goto end;

            }

            pHeaderMap++;
        }
    }

    // OK, at this point either we had no header map array or none of them
    // matched. We have an unknown header. Just make sure this header is
    // terminated and save a pointer to it.
    //
    // Find the end of the header value
    //
    pHeaderValue      = pHttpRequest + HeaderNameLength;
    HeaderValueLength = (HttpRequestLength - HeaderNameLength);

    Status = UcFindHeaderValueEnd(
                    pHeaderValue,
                    HeaderValueLength,
                    &pFoldingBuffer,
                    &BytesTaken
                    );

    if(!NT_SUCCESS(Status))
    {
        return Status;
    }

    ASSERT(BytesTaken >= CRLF_SIZE);

    HeaderValueLength = BytesTaken - CRLF_SIZE;

    if(pFoldingBuffer != NULL)
    {
        pHeaderValue = pFoldingBuffer;
    }

    UC_PROCESS_HEADER_VALUE(pHeaderValue, HeaderValueLength);

    //
    // We Have an unknown header. We don't have to search our list of
    // unknown headers to see if this unknown header already exists.
    // even if it does exist, we cannot concatenate these two header
    // values - Since the header is unknown, the syntax for the header-value 
    // is also unknown and merging might mess around with the field terminator 
    //

    //
    // Carve out a UNKNOWN_HEADER structure using pBufferHead
    //

    pBufferHead = pRequest->CurrentBuffer.pOutBufferHead;
    pBufferTail = pRequest->CurrentBuffer.pOutBufferTail;

    AlignNameLength  = ALIGN_UP(HeaderNameLength, PVOID);
    AlignValueLength = ALIGN_UP(HeaderValueLength, PVOID);

    if(pRequest->CurrentBuffer.BytesAvailable >= 
            sizeof(HTTP_UNKNOWN_HEADER) + AlignNameLength + AlignValueLength)
    {
        pUnknownHeader            = (PHTTP_UNKNOWN_HEADER)pBufferHead;

        // 
        // The Header name has a ':'. 
        //

        pUnknownHeader->NameLength = (USHORT) (HeaderNameLength - 1);

        pBufferTail -= AlignNameLength;

        pUnknownHeader->pName      = (PCSTR) pBufferTail;

        RtlCopyMemory(
                pBufferTail,
                pHttpRequest,
                (USHORT) (HeaderNameLength - 1)
                );

        //
        // header value
        //

        pUnknownHeader->RawValueLength = (USHORT) HeaderValueLength;

        pBufferTail -= AlignValueLength;

        pUnknownHeader->pRawValue = (PCSTR) pBufferTail;

        RtlCopyMemory(
                pBufferTail,
                pHeaderValue,
                (USHORT) HeaderValueLength
                );

        pRequest->CurrentBuffer.pResponse->Headers.UnknownHeaderCount ++;

        pRequest->CurrentBuffer.pOutBufferHead = 
            pBufferHead + sizeof(HTTP_UNKNOWN_HEADER);

        pRequest->CurrentBuffer.pOutBufferTail = pBufferTail;

        pRequest->CurrentBuffer.BytesAvailable -= 
            (sizeof(HTTP_UNKNOWN_HEADER) + AlignNameLength + AlignValueLength);
    }
    else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

end:
    if (NT_SUCCESS(Status))
    {
        *pBytesTaken = HeaderNameLength + BytesTaken;
    }

    if(pFoldingBuffer)
    {
        UL_FREE_POOL(pFoldingBuffer, UC_HEADER_FOLDING_POOL_TAG);
    }

    return Status;

}   // UcpLookupHeader

                        
/***************************************************************************++

Routine Description:

    The routine to parse an individual header. We take in a pointer to the
    header and the bytes remaining in the request, and try to find
    the header in our lookup table. We try first the fast way, and then
    try again the slow way in case there wasn't quite enough data the first
    time.

    On input, HttpRequestLength is at least CRLF_SIZE.

Arguments:

    pRequest            - Pointer to the current connection on which the
                            request arrived.
    pHttpRequest        - Pointer to the current request.
    HttpRequestLength   - Bytes left in the request.

Return Value:

    Number of bytes in the header (including CRLF), or 0 if we couldn't
    parse the header.

--***************************************************************************/

NTSTATUS
UcParseHeader(  
    IN  PUC_HTTP_REQUEST  pRequest,
    IN  PUCHAR            pHttpRequest,
    IN  ULONG             HttpRequestLength,
    OUT ULONG  *          pBytesTaken
    )
{
    NTSTATUS               Status = STATUS_SUCCESS;
    ULONG                  i;
    ULONG                  j;
    ULONG                  BytesTaken;
    ULONGLONG              Temp;
    UCHAR                  c;
    PHEADER_MAP_ENTRY      pCurrentHeaderMap;
    ULONG                  HeaderMapCount;
    BOOLEAN                SmallHeader = FALSE;
    PHTTP_RESPONSE_HEADERS pResponseHeaders;
    PUCHAR                 *pOutBufferHead;
    PUCHAR                 *pOutBufferTail;
    PULONG                 BytesAvailable;
    PUCHAR                 pHeaderValue;
    ULONG                  HeaderValueLength;
    ULONG                  RemainingBufferLength;
    PUCHAR                 pFoldingBuffer = NULL;

    //
    // Sanity check.
    //

    ASSERT(HttpRequestLength >= CRLF_SIZE);

    pResponseHeaders = &pRequest->CurrentBuffer.pResponse->Headers;
    pOutBufferHead   = &pRequest->CurrentBuffer.pOutBufferHead;
    pOutBufferTail   = &pRequest->CurrentBuffer.pOutBufferTail;
    BytesAvailable   = &pRequest->CurrentBuffer.BytesAvailable;

    c = *pHttpRequest;

    // message-headers start with field-name [= token]
    //
    if (IS_HTTP_TOKEN(c) == FALSE)
    {
        UlTraceError(PARSER, (
                    "ul!UcParseHeader c = 0x%x ERROR: invalid header char\n",
                    c
                    ));

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    // Does the header start with an alpha?
    //
    if (IS_HTTP_ALPHA(c))
    {
        // Uppercase the character, and find the appropriate set of header map
        // entries.
        //
        c = UPCASE_CHAR(c);

        c -= 'A';

        pCurrentHeaderMap = g_ResponseHeaderIndexTable[c].pHeaderMap;
        HeaderMapCount    = g_ResponseHeaderIndexTable[c].Count;

        // Loop through all the header map entries that might match
        // this header, and check them. The count will be 0 if there
        // are no entries that might match and we'll skip the loop.

        for (i = 0; i < HeaderMapCount; i++)
        {

            ASSERT(pCurrentHeaderMap->pClientHandler != NULL);

            // If we have enough bytes to do the fast check, do it.
            // Otherwise skip this. We may skip a valid match, but if
            // so we'll catch it later.

            if (HttpRequestLength >= pCurrentHeaderMap->MinBytesNeeded)
            {
                ASSERT(HttpRequestLength >= ((pCurrentHeaderMap->ArrayCount-1) *
                       sizeof(ULONGLONG)));

                for (j = 0; j < pCurrentHeaderMap->ArrayCount; j++)
                {
                    Temp = *(UNALIGNED64 ULONGLONG *)(pHttpRequest +
                                            (j * sizeof(ULONGLONG)));

                    if ((Temp & pCurrentHeaderMap->HeaderMask[j]) !=
                        pCurrentHeaderMap->Header.HeaderLong[j] )
                    {
                        break;
                    }
                }

                // See why we exited out.
                if (j == pCurrentHeaderMap->ArrayCount &&
                    pCurrentHeaderMap->pClientHandler != NULL)
                {
                    pHeaderValue = pHttpRequest + 
                                        pCurrentHeaderMap->HeaderLength;
    
                    RemainingBufferLength = (HttpRequestLength - 
                                             pCurrentHeaderMap->HeaderLength);
    
                    Status = UcFindHeaderValueEnd(
                                pHeaderValue,
                                RemainingBufferLength,
                                &pFoldingBuffer,
                                &BytesTaken
                                );

                    if(!NT_SUCCESS(Status))
                    {
                        return Status;
                    }

                    ASSERT(BytesTaken >= CRLF_SIZE);
                    HeaderValueLength = BytesTaken - CRLF_SIZE;

                    if(pFoldingBuffer != NULL)
                    {
                        pHeaderValue = pFoldingBuffer;
                    }
    
                    UC_PROCESS_HEADER_VALUE(pHeaderValue, HeaderValueLength);

                    // Exited because we found a match. Call the
                    // handler for this header to take cake of this.

                    Status = (*(pCurrentHeaderMap->pClientHandler))(
                                    pRequest,
                                    pHeaderValue,
                                    HeaderValueLength,
                                    pCurrentHeaderMap->HeaderID
                                    );

                    if (NT_SUCCESS(Status) == FALSE)
                        goto end;

                    ASSERT(BytesTaken != 0);

                    *pBytesTaken = pCurrentHeaderMap->HeaderLength + BytesTaken;
                    goto end;

                }

                // If we get here, we exited out early because a match
                // failed, so keep going.
            }
            else if (SmallHeader == FALSE)
            {
                //
                // Remember that we didn't check a header map entry
                // because the bytes in the buffer was not LONGLONG
                // aligned
                //
                SmallHeader = TRUE;
            }

            // Either didn't match or didn't have enough bytes for the
            // check. In either case, check the next header map entry.

            pCurrentHeaderMap++;
        }

        // Got all the way through the appropriate header map entries
        // without a match. This could be because we're dealing with a
        // header we don't know about or because it's a header we
        // care about that was too small to do the fast check. The
        // latter case should be very rare, but we still need to
        // handle it.

        // Update the current header map pointer to point back to the
        // first of the possibles. If there were no possibles,
        // the pointer will be NULL and the HeaderMapCount 0, so it'll
        // stay NULL. Otherwise the subtraction will back it up the
        // appropriate amount.

        if (SmallHeader)
        {
            pCurrentHeaderMap -= HeaderMapCount;
        }
        else
        {
            pCurrentHeaderMap = NULL;
            HeaderMapCount = 0;
        }

    }
    else
    {
        pCurrentHeaderMap = NULL;
        HeaderMapCount = 0;
    }

    // At this point either the header starts with a non-alphabetic
    // character or we don't have a set of header map entries for it.

    Status = UcpLookupHeader(
                    pRequest,
                    pHttpRequest,
                    HttpRequestLength,
                    pCurrentHeaderMap,
                    HeaderMapCount,
                    &BytesTaken
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    // Lookup header returns the total bytes taken, including the header name
    //
    *pBytesTaken = BytesTaken;

end:
    if(pFoldingBuffer != NULL)
    {
        UL_FREE_POOL(pFoldingBuffer, UC_HEADER_FOLDING_POOL_TAG);
    }

    return Status;

}   // UcParseHeader


/***************************************************************************++

Routine Description:

    Parses WWW-Authenticate header value.  The value can contain multiple
    challenges.  Each challenge can have zero or more comma-separated
    auth-parameters.

    The routine returns pointers (pointing into the original header value)
    to each auth scheme found in the header.

Arguments:

    IN  pAuthHeader      - WWW-Authenticate header value (value only)
    IN  AuthHeaderLength - Length of the header value
    OUT AuthSchemes      - Contains pointers to various auth schemes
                           present in the header value.
                           e.g. AuthSchemes[HttpAuthTypeBasic] will
                           be initialized to point to Basic scheme
                           portion of the AuthHeader.

Return Values:

    Status.

--***************************************************************************/
NTSTATUS
UcParseWWWAuthenticateHeader(
    IN   PCSTR                    pAuthHeader,
    IN   ULONG                    AuthHeaderLength,
    OUT  PHTTP_AUTH_PARSED_PARAMS pAuthParsedParams
    )
{
    ULONG    i;
    NTSTATUS Status;
    PCSTR    ptr = pAuthHeader;

    // Sanity check
    ASSERT(pAuthHeader && AuthHeaderLength);
    ASSERT(pAuthParsedParams);

    do
    {
        // skip white space
        while (AuthHeaderLength && IS_HTTP_LWS(*ptr))
            AuthHeaderLength--, ptr++;

        // See if any header left to parse
        if (AuthHeaderLength == 0)
            break;

        // See if any scheme name matches
        for (i = 1; i < HttpAuthTypesCount; i++)
        {
            // Quick test for lengths and delimiters
            if ((AuthHeaderLength == HttpAuthScheme[i].NameLength) ||
                ((AuthHeaderLength > HttpAuthScheme[i].NameLength) &&
                 (IS_HTTP_LWS(ptr[HttpAuthScheme[i].NameLength]) ||
                  ptr[HttpAuthScheme[i].NameLength] == ',')))
            {
                // See if the scheme name matches
                if (_strnicmp(
                        ptr,
                        HttpAuthScheme[i].Name,
                        HttpAuthScheme[i].NameLength) == 0)
                {
                    // An auth scheme should not appear more than once!
                    if (pAuthParsedParams[i].bPresent)
                        return STATUS_INVALID_PARAMETER;

                    // Parse its parameters, if any
                    Status = HttpAuthScheme[i].ParamParser(
                                 &HttpAuthScheme[i],
                                 &pAuthParsedParams[i],
                                 &ptr,
                                 &AuthHeaderLength
                                 );

                    if (!NT_SUCCESS(Status))
                        return Status;

                    // No need to loop thro' other schemes
                    break;
                }
            }
        }

        // Error if we don't identify a scheme
        if (i >= HttpAuthTypesCount)
            return STATUS_INVALID_PARAMETER;

    } while (1);

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Searches for an attribute=value pair.

    The routine returns
       -1 : if parse error
        0 : if no attribute value pair is found
        1 : if only "attribute" is found (not followed by an '=')
        3 : if a valid attribute=value pair is found

    WWW-Authenticate header pointer and length are updated to next non-space
    character.  If the return value is 3, the pointer and length are updated
    past the attribute-value pair.

Arguments:

    IN OUT ppHeader         -    Pointer to WWW-Authenticate header value
    IN OUT pHeaderLength    -    Pointer to length of WWW-Auth header value
    OUT    Attrib           -    Pointer to attribute
    OUT    AttribLen        -    Length of the attribute string
    OUT    Value            -    Pointer to value
    OUT    ValueLen         -    Length of the value string

Return Values:

    Status.

--***************************************************************************/
LONG
UcpFindAttribValuePair(
    PCSTR *ppHeader,
    ULONG *pHeaderLength,
    PCSTR *Attrib,
    ULONG *AttribLen,
    PCSTR *Value,
    ULONG *ValueLen
    )
{
    LONG retval = 3;
    PCSTR pHeader = *ppHeader;
    ULONG HeaderLength = *pHeaderLength;

    // Initialize return values
    *Attrib = NULL;
    *AttribLen = 0;
    *Value = NULL;
    *ValueLen = 0;

    // Skip space 
    while (HeaderLength && IS_HTTP_LWS(*pHeader))
        HeaderLength--, pHeader++;

    // Update header pointer and length
    *ppHeader = pHeader;
    *pHeaderLength = HeaderLength;

    // Remember the start of an attribute
    *Attrib = pHeader;

    // Skip the attribute name
    while (HeaderLength && IS_HTTP_TOKEN(*pHeader))
        HeaderLength--, pHeader++;

    // Length of the attribute
    *AttribLen = (ULONG)(pHeader - *Attrib);

    // If we did not see any attribute name
    if (pHeader == *Attrib)
    {
        // Nope.
        retval = 0;
        goto done;
    }

    //  an attribute must be terminated by an '='
    if (HeaderLength == 0 || *pHeader != '=')
    {
        // Saw only an attribute
        retval = 1;
        goto done;
    }

    // Skip '='
    HeaderLength--, pHeader++;

    // Quoted string
    if (HeaderLength && *pHeader == '"')
    {
        // Skip '"'
        HeaderLength--, pHeader++;

        // Remember the start of value ('"' not included)
        *Value = pHeader;

        // Find the matching '"'
        while (HeaderLength && *pHeader != '"')
        {
            if (*pHeader == '\\')
            {
                // Skip '\\' char
                HeaderLength--, pHeader++;

                if (HeaderLength == 0)
                {
                    // Error!  There must be at least one char following '\\'.
                    retval = -1;
                    goto done;
                }
                // Else skip the char that appeared after '\\'.
            }

            HeaderLength--, pHeader++;
        }

        // Calculate length of the value string
        *ValueLen = (ULONG)(pHeader - *Value);

        // Error if we did not find a matching '"'
        if (HeaderLength == 0)
            retval = -1;
        else
            // Skip '"'
            HeaderLength--, pHeader++;
    }
    // Token
    else
    {
        // Remember start of the value string
        *Value = pHeader;

        // Find the end of value string
        while (HeaderLength && IS_HTTP_TOKEN(*pHeader))
            HeaderLength--, pHeader++;

        // Calculate the length of the value string
        *ValueLen = (ULONG)(pHeader - *Value);
    }

    // Update header pointer and length
    *pHeaderLength = HeaderLength;
    *ppHeader = pHeader;

 done:
    return retval;
}


/***************************************************************************++

Routine Description:

    Parses WWW-Authenticate header for an authentication scheme which
    has parameters in the form of attribute value pairs. (e.g. Digest)

    The routine returns pointer to the parameter values and their lengths.
    WWW-Authenticate header pointer and length are updated.

Arguments:

    IN     pAuthScheme      -    Pointer to the auth scheme being parsed
    OUT    pAuthParamValues -    Output parameter value pointers and lengths
    IN OUT ppHeader         -    Pointer to WWW-Authenticate header value
    IN OUT pHeaderLength    -    Pointer to length of WWW-Auth header value

Return Values:

    Status.

--***************************************************************************/
NTSTATUS
UcpParseAuthParams(
    PHTTP_AUTH_SCHEME pAuthScheme,
    PHTTP_AUTH_PARSED_PARAMS pAuthParsedParams,
    PCSTR *ppHeader,
    ULONG *pHeaderLength
    )
{
    ULONG    i;
    LONG     retval;
    PCSTR    attrib, value;
    ULONG    attribLen, valueLen;

    ULONG    ParamCount = 0;
    PCSTR    pHeader = *ppHeader;
    ULONG    HeaderLength = *pHeaderLength;
    PHTTP_AUTH_PARAM_VALUE pAuthParamValues;

    // Sanity check
    ASSERT(pAuthParsedParams);
    ASSERT(pHeader && HeaderLength);
    ASSERT(pAuthScheme);
    ASSERT(pAuthScheme->NumberParams);
    ASSERT(pAuthScheme->NameLength <= HeaderLength);
    ASSERT(_strnicmp(pAuthScheme->Name, pHeader, pAuthScheme->NameLength) == 0);

    pAuthParsedParams->pScheme = pHeader;
    pAuthParamValues = pAuthParsedParams->Params;

    // Zero out return value
    if (pAuthParamValues)
        RtlZeroMemory(
            pAuthParamValues,
            sizeof(*pAuthParamValues) * pAuthScheme->NumberParams
            );

    // Skip the scheme name
    pHeader += pAuthScheme->NameLength;
    HeaderLength -= pAuthScheme->NameLength;

    do {

        // Find an attribute value pair
        retval = UcpFindAttribValuePair(
                     &pHeader,
                     &HeaderLength,
                     &attrib,
                     &attribLen,
                     &value,
                     &valueLen
                     );

        // Parse error!
        if (retval < 0)
            return STATUS_INVALID_PARAMETER;

        switch (retval)
        {
        case 0:                 // No attribute value pair found
        case 1:                 // Only attribute found (not followed by '=')
            goto done;

        case 3:                 // valid attribute value pair found

            // A valid parameter was found.
            ParamCount++;

            // See if the caller is interested in parameter values
            if (pAuthParamValues)
            {
                // See if the auth scheme supports the attribute
                for (i = 0; i < pAuthScheme->NumberParams; i++)
                {
                    if (attribLen == pAuthScheme->ParamAttribs[i].Length &&
                        _strnicmp(attrib, pAuthScheme->ParamAttribs[i].Name,
                                  attribLen) == 0)
                    {
                        if (pAuthParamValues[i].Value ||
                            pAuthParamValues[i].Length)
                            return STATUS_INVALID_PARAMETER;

                        pAuthParsedParams->NumberKnownParams++;

                        // Return the parameter value
                        pAuthParamValues[i].Value = value;
                        pAuthParamValues[i].Length = valueLen;

                        break;
                    }
                }

                if (i >= pAuthScheme->NumberParams)
                    pAuthParsedParams->NumberUnknownParams++;
            }

            // Skip blank spaces
            while (HeaderLength && IS_HTTP_LWS(*pHeader))
                HeaderLength--, pHeader++;

            // A ',' must be present.
            if (HeaderLength)
            {
                if (*pHeader != ',')
                    return STATUS_INVALID_PARAMETER;

                HeaderLength--, pHeader++;
            }

            break;

        default:
            // Should not be here!
            ASSERT(FALSE);
            break;
        }

    } while (HeaderLength);

 done:

    // We must have parsed at least one parameter.
    if (ParamCount == 0)
    {
        return STATUS_INVALID_PARAMETER;
    }

    // Update WWW-Authenticate header pointer and length
    pAuthParsedParams->bPresent = TRUE;
    pAuthParsedParams->Length = (ULONG)(pHeader - pAuthParsedParams->pScheme);
    *ppHeader = pHeader;
    *pHeaderLength = HeaderLength;

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Parses WWW-Authenticate header for an authentication scheme which
    has only one parameter NOT in the form of attribute value pair.
    (e.g. auth scheme NTLM).

    The routine returns pointer to the parameter value and its length.
    WWW-Authenticate header pointer and length are updated.

Arguments:

    IN     pAuthScheme   -    Pointer to the auth scheme being parsed
    OUT    pAuthParams   -    Output parameter pointer and its length
    IN OUT ppHeader      -    Pointer to WWW-Authenticate header value
    IN OUT pHeaderLength -    Pointer to the length of WWW-Auth header value

Return Values:

    Status.

--***************************************************************************/
NTSTATUS
UcpParseAuthBlob(
    PHTTP_AUTH_SCHEME pAuthScheme,
    PHTTP_AUTH_PARSED_PARAMS pAuthParsedParams,
    PCSTR *ppHeader,
    ULONG *pHeaderLength
    )
{
    PCSTR pHeader = *ppHeader;
    ULONG HeaderLength = *pHeaderLength;
    PCSTR value;         // Pointer to the parameter value
    PHTTP_AUTH_PARAM_VALUE pAuthParams;

    // Sanity check
    ASSERT(pAuthParsedParams);
    ASSERT(pHeader);
    ASSERT(pAuthScheme);
    ASSERT(pAuthScheme->NumberParams == 0);
    ASSERT(pAuthScheme->NameLength <= HeaderLength);
    ASSERT(_strnicmp(pAuthScheme->Name, pHeader, pAuthScheme->NameLength) == 0);

    pAuthParsedParams->pScheme = pHeader;
    pAuthParams = pAuthParsedParams->Params;

    // Zero out the return values
    if (pAuthParams)
        RtlZeroMemory(pAuthParams, sizeof(*pAuthParams));

    // Skip the scheme name
    pHeader += pAuthScheme->NameLength;
    HeaderLength -= pAuthScheme->NameLength;

    // Skip white spaces
    while (HeaderLength && IS_HTTP_LWS(*pHeader))
        HeaderLength--, pHeader++;

    // Begining of paramter value 
    value = pHeader;

    // Search for the end
    while (HeaderLength && *pHeader != ',')
        HeaderLength--, pHeader++;

    // Return the parameter value, if any, if asked 
    if (pHeader != value && pAuthParams)
    {
        pAuthParsedParams->NumberUnknownParams++;
        pAuthParams->Value = value;
        pAuthParams->Length = (ULONG)(pHeader - value);
    }

    // Skip the trailing ','
    if (HeaderLength > 0 && *pHeader == ',')
        HeaderLength--, pHeader++;

    pAuthParsedParams->bPresent = TRUE;
    // Update header pointer and length
    pAuthParsedParams->Length = (ULONG)(pHeader - pAuthParsedParams->pScheme);
    *ppHeader = pHeader;
    *pHeaderLength = HeaderLength;

    return STATUS_SUCCESS;
}

/****************************************************************************++

Routine Description:

    The default routine for handling single headers. 

Arguments:

    pRequest        - pointer to internal request.
    pHeader         - Pointer to the header value.
    HeaderLength    - Length of data pointed to by pHeader.
    HeaderID        - ID of the header.
    pBytesTaken     - BytesTaken

Return Value:

   STATUS_SUCCESS if success, else failure.
    

--****************************************************************************/
NTSTATUS
UcSingleHeaderHandler(
    IN  PUC_HTTP_REQUEST pRequest,
    IN  PUCHAR           pHeader,
    IN  ULONG            HeaderValueLength,
    IN  HTTP_HEADER_ID   HeaderID
    )
{
    NTSTATUS           Status = STATUS_SUCCESS;
    ULONG              AlignLength;
    PUCHAR             pBufferHead;
    PUCHAR             pBufferTail;
    PHTTP_KNOWN_HEADER pKnownHeaders;

    pKnownHeaders  =  pRequest->CurrentBuffer.pResponse->Headers.KnownHeaders;
    pBufferHead    =  pRequest->CurrentBuffer.pOutBufferHead;
    pBufferTail    =  pRequest->CurrentBuffer.pOutBufferTail;

    // do we have an existing header?
    //
    if (pKnownHeaders[HeaderID].RawValueLength == 0)
    {
        // No existing header, just save this pointer for now.
        //

        AlignLength = ALIGN_UP(HeaderValueLength, PVOID);

        if(pRequest->CurrentBuffer.BytesAvailable >= AlignLength)
        {
            PUCHAR pBuffer = pBufferTail-AlignLength;

            ASSERT(pBuffer >= pBufferHead);

            //
            // copy and NULL terminate.
            //

            RtlCopyMemory(pBuffer, pHeader, HeaderValueLength);

            pKnownHeaders[HeaderID].RawValueLength = 
                            (USHORT)HeaderValueLength;

            pKnownHeaders[HeaderID].pRawValue = (PCSTR) pBuffer;

            pRequest->CurrentBuffer.pOutBufferTail = pBuffer;

            pRequest->CurrentBuffer.BytesAvailable -= AlignLength;
        }
        else 
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }
    }
    else
    {
        //
        // uh oh.  Have an existing header, fail the request.
        //

        UlTraceError(PARSER, (
                    "[UcSingleHeaderHandler]: (pHeader = %p)\n"
                    "    ERROR: multiple headers not allowed.\n",
                    pHeader
                    ));

        Status = STATUS_INVALID_NETWORK_RESPONSE;
        goto end;

    }

end:
    return Status;

}   // UcSingleHeaderHandler


/****************************************************************************++

Routine Description:

    The default routine for handling multiple headers. This function handles 
    multiple headers with the same name, and appends the values together 
    separated by commas.

Arguments:

    pRequest        - pointer to internal request.
    pHeader         - Pointer to the header value.
    HeaderLength    - Length of data pointed to by pHeader.
    HeaderID        - ID of the header.
    pBytesTaken     - BytesTaken

Return Value:

   STATUS_SUCCESS if success, else failure.


--****************************************************************************/
NTSTATUS
UcMultipleHeaderHandler(
    IN  PUC_HTTP_REQUEST    pRequest,
    IN  PUCHAR              pHeader,
    IN  ULONG               HeaderValueLength,
    IN  HTTP_HEADER_ID      HeaderID
    )
{
    NTSTATUS           Status = STATUS_SUCCESS;
    ULONG              AlignLength;
    PUCHAR             pBufferHead;
    PUCHAR             pBufferTail;
    PHTTP_KNOWN_HEADER pKnownHeaders;
    

    pKnownHeaders  =  pRequest->CurrentBuffer.pResponse->Headers.KnownHeaders;
    pBufferHead    =  pRequest->CurrentBuffer.pOutBufferHead;
    pBufferTail    =  pRequest->CurrentBuffer.pOutBufferTail;

    // do we have an existing header?
    //
    if (pKnownHeaders[HeaderID].RawValueLength == 0)
    {
        AlignLength = ALIGN_UP(HeaderValueLength, PVOID);

        if(pRequest->CurrentBuffer.BytesAvailable >= AlignLength)
        {
            PUCHAR pBuffer = pBufferTail-AlignLength;

            ASSERT(pBuffer >= pBufferHead);

            //
            // copy & null terminate it.  
            //
            RtlCopyMemory(pBuffer, pHeader, HeaderValueLength);

            pKnownHeaders[HeaderID].RawValueLength = 
                            (USHORT)HeaderValueLength;

            pKnownHeaders[HeaderID].pRawValue      = (PCSTR) pBuffer;

            pRequest->CurrentBuffer.pOutBufferTail = pBuffer;

            pRequest->CurrentBuffer.BytesAvailable -= AlignLength;
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }
    }
    else
    {
        ULONG  OldHeaderLength;
        ULONG  CombinedHeaderLength;
        PUCHAR pBuffer;

        // Have an existing header, append this one.

        OldHeaderLength      = pKnownHeaders[HeaderID].RawValueLength;
        CombinedHeaderLength = OldHeaderLength + HeaderValueLength + 1;

        AlignLength = ALIGN_UP(CombinedHeaderLength, PVOID);

        //
        // UC_BUGBUG:
        //
        if(pRequest->CurrentBuffer.BytesAvailable >= AlignLength)
        {

            pBuffer = pBufferTail-AlignLength;
            pRequest->CurrentBuffer.pOutBufferTail = pBuffer;

            ASSERT(pBuffer >= pBufferHead);


            // Copy the old header.
            RtlCopyMemory(pBuffer,
                          pKnownHeaders[HeaderID].pRawValue,
                          pKnownHeaders[HeaderID].RawValueLength);

            //
            // Save pointers to the new values.
            //
            pKnownHeaders[HeaderID].pRawValue      = (PCSTR) pBuffer;
            

            // advance the buffer.

            pBuffer += pKnownHeaders[HeaderID].RawValueLength;

            // Add a ','

            *pBuffer = ',';
            pBuffer ++;
        
            //
            // append the new header
            //

            RtlCopyMemory(pBuffer, pHeader, HeaderValueLength); 
           
            //
            // Account for the new header + a ',' 
            //
            pKnownHeaders[HeaderID].RawValueLength += 
                        ((USHORT)HeaderValueLength + 1);

            pRequest->CurrentBuffer.BytesAvailable -= AlignLength;
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }

    }

end:
    return Status;

}   // UcMultipleHeaderHandler


/****************************************************************************++

Routine Description:

    The default routine for handling ProxyAuthenticte & WwwAuthenticate

Arguments:

    pRequest        - pointer to internal request.
    pHeader         - Pointer to the header value.
    HeaderLength    - Length of data pointed to by pHeader.
    HeaderID        - ID of the header.
    pBytesTaken     - BytesTaken

Return Value:

   STATUS_SUCCESS if success, else failure.


--****************************************************************************/

NTSTATUS
UcAuthenticateHeaderHandler(
    IN  PUC_HTTP_REQUEST     pRequest,
    IN  PUCHAR               pHeader,
    IN  ULONG                HeaderLength,
    IN  HTTP_HEADER_ID       HeaderID
    )
{
    NTSTATUS             Status;
    PCSTR                pBuffer;
    ULONG                BufLen;
    PHTTP_KNOWN_HEADER   pKnownHeaders;

    pKnownHeaders  =  pRequest->CurrentBuffer.pResponse->Headers.KnownHeaders;

    ASSERT(HeaderID == HttpHeaderProxyAuthenticate ||
           HeaderID == HttpHeaderWwwAuthenticate);

    Status = UcMultipleHeaderHandler(pRequest,    
                                   pHeader,
                                   HeaderLength,
                                   HeaderID
                                   );

    if(NT_SUCCESS(Status))
    {
        //
        // First detect the auth scheme.
        //

        pBuffer = pKnownHeaders[HeaderID].pRawValue;
        BufLen  = pKnownHeaders[HeaderID].RawValueLength;

        if(HeaderID == HttpHeaderWwwAuthenticate)
        {
            if((Status = UcParseAuthChallenge(
                               pRequest->pAuthInfo,
                               pBuffer,
                               BufLen,
                               pRequest,
                               &pRequest->CurrentBuffer.pResponse->Flags
                               )) != STATUS_SUCCESS)
            {
                return Status;
            }
        }
        else
        {
            if((Status = UcParseAuthChallenge(
                               pRequest->pProxyAuthInfo,
                               pBuffer,
                               BufLen,
                               pRequest,
                               &pRequest->CurrentBuffer.pResponse->Flags
                               )) != STATUS_SUCCESS)
            {
                return Status;
            }
        }
    }

    return Status;
}

/****************************************************************************++

Routine Description:

    The default routine for handling Content-Length header

Arguments:

    pRequest        - pointer to internal request.
    pHeader         - Pointer to the header value.
    HeaderLength    - Length of data pointed to by pHeader.
    HeaderID        - ID of the header.
    pBytesTaken     - BytesTaken

Return Value:

   STATUS_SUCCESS if success, else failure.


--****************************************************************************/
NTSTATUS
UcContentLengthHeaderHandler(
    IN  PUC_HTTP_REQUEST     pRequest,
    IN  PUCHAR               pHeader,
    IN  ULONG                HeaderLength,
    IN  HTTP_HEADER_ID       HeaderID
    )
{
    NTSTATUS             Status;
    PUCHAR               pBuffer;
    USHORT               Length;
    PHTTP_KNOWN_HEADER   pKnownHeaders;

    pKnownHeaders  =  pRequest->CurrentBuffer.pResponse->Headers.KnownHeaders;

    ASSERT(HeaderID == HttpHeaderContentLength);

    Status = UcSingleHeaderHandler(pRequest,    
                                 pHeader,
                                 HeaderLength,
                                 HeaderID
                                 );

    if(Status == STATUS_SUCCESS)
    {
        //
        // Convert to ULONG
        //

        pRequest->ResponseContentLengthSpecified = TRUE;
        pRequest->ResponseContentLength          = 0;
        pBuffer = (PUCHAR) pKnownHeaders[HttpHeaderContentLength].pRawValue;
        Length  = pKnownHeaders[HttpHeaderContentLength].RawValueLength;

        Status = UlAnsiToULongLong(
                    pBuffer,
                    Length,
                    10,
                    &pRequest->ResponseContentLength
                    );
    
        if(!NT_SUCCESS(Status))
        {
            // Eat the error code that is returned by UlAnsiToULongLong

            Status = STATUS_INVALID_NETWORK_RESPONSE;
        }
    }

    return Status;
}

/****************************************************************************++

Routine Description:

    The default routine for handling transfer encoding header

Arguments:

    pRequest        - pointer to internal request.
    pHeader         - Pointer to the header value.
    HeaderLength    - Length of data pointed to by pHeader.
    HeaderID        - ID of the header.
    pBytesTaken     - BytesTaken

Return Value:

   STATUS_SUCCESS if success, else failure.


--****************************************************************************/
NTSTATUS
UcTransferEncodingHeaderHandler(
    IN  PUC_HTTP_REQUEST     pRequest,
    IN  PUCHAR               pHeader,
    IN  ULONG                HeaderLength,
    IN  HTTP_HEADER_ID       HeaderID
    )
{
    NTSTATUS             Status;
    PHTTP_KNOWN_HEADER   pKnownHeaders;

    pKnownHeaders  =  pRequest->CurrentBuffer.pResponse->Headers.KnownHeaders;

    ASSERT(HeaderID == HttpHeaderTransferEncoding);

    Status = UcMultipleHeaderHandler(pRequest,    
                                     pHeader,
                                     HeaderLength,
                                     HeaderID
                                     );

    if(Status == STATUS_SUCCESS)
    {
        //
        // Since this is a multiple header, we have to do a strstr. 
        // We can't do strstr, since input string is not NULL terminated.
        // so, we use our internal function
        //

        if(UxStriStr(
                pKnownHeaders[HttpHeaderTransferEncoding].pRawValue,
                "identity",
                pKnownHeaders[HttpHeaderTransferEncoding].RawValueLength
                ))
        {
            pRequest->ResponseEncodingChunked = FALSE;
        }
        else
        {
            pRequest->ResponseEncodingChunked = TRUE;
            pRequest->ResponseContentLength   = 0;
            pRequest->ParsedFirstChunk        = 0;
        }
    }

    return Status;
}

/****************************************************************************++

Routine Description:

    The default routine for handling Connection close header

Arguments:

    pRequest        - pointer to internal request.
    pHeader         - Pointer to the header value.
    HeaderLength    - Length of data pointed to by pHeader.
    HeaderID        - ID of the header.
    pBytesTaken     - BytesTaken

Return Value:

   STATUS_SUCCESS if success, else failure.


--****************************************************************************/
NTSTATUS
UcConnectionHeaderHandler(
    IN  PUC_HTTP_REQUEST     pRequest,
    IN  PUCHAR               pHeader,
    IN  ULONG                HeaderLength,
    IN  HTTP_HEADER_ID       HeaderID
    )
{
    NTSTATUS             Status;
    PHTTP_KNOWN_HEADER   pKnownHeaders;

    pKnownHeaders  =  pRequest->CurrentBuffer.pResponse->Headers.KnownHeaders;

    ASSERT(HeaderID == HttpHeaderConnection);

    Status = UcMultipleHeaderHandler(pRequest,
                                     pHeader,
                                     HeaderLength,
                                     HeaderID
                                     );

    if(NT_SUCCESS(Status))
    {
        if(pRequest->ResponseVersion11)
        {
            ASSERT(pRequest->ResponseConnectionClose == FALSE);

            // If it's a 1.1 response, we have to look for the 
            // Connection:Close header
        
            if(UxStriStr(
                    pKnownHeaders[HttpHeaderConnection].pRawValue,
                    "close",
                    pKnownHeaders[HttpHeaderConnection].RawValueLength))
            {
                pRequest->ResponseConnectionClose = TRUE;
            }
    
         }
         else 
         {
             // If it's a 1.0 server, by default we close the connection.
             // unless we see a Keepalive

             ASSERT(pRequest->ResponseConnectionClose == TRUE);
        
             if(UxStriStr(
                    pKnownHeaders[HttpHeaderConnection].pRawValue,
                    "keep-alive",
                    pKnownHeaders[HttpHeaderConnection].RawValueLength))
             {
                 pRequest->ResponseConnectionClose = FALSE;
             }
         }
    }

    return Status;
}

/****************************************************************************++

Routine Description:

    The default routine for handling Content-Type header (used for byte range)

Arguments:

    pRequest        - pointer to internal request.
    pHeader         - Pointer to the header value.
    HeaderLength    - Length of data pointed to by pHeader.
    HeaderID        - ID of the header.
    pBytesTaken     - BytesTaken

Return Value:

   STATUS_SUCCESS if success, else failure.


--****************************************************************************/
NTSTATUS
UcContentTypeHeaderHandler(
    IN  PUC_HTTP_REQUEST     pRequest,
    IN  PUCHAR               pHeader,
    IN  ULONG                HeaderLength,
    IN  HTTP_HEADER_ID       HeaderID
    )
{
    NTSTATUS             Status;
    PHTTP_KNOWN_HEADER   pKnownHeaders;
    BOOLEAN              bEndQuote;

    pKnownHeaders  =  pRequest->CurrentBuffer.pResponse->Headers.KnownHeaders;

    Status = UcSingleHeaderHandler(
                pRequest,
                pHeader,
                HeaderLength,
                HeaderID
                );
        
    if(NT_SUCCESS(Status))
    {
        if(pKnownHeaders[HttpHeaderContentType].RawValueLength < 
           (STRLEN_LIT("multipart/byteranges")))
        {
            return Status;
        }

        if(_strnicmp((const char *)
                     (pKnownHeaders[HttpHeaderContentType].pRawValue),
                     "multipart/byteranges",
                     STRLEN_LIT("multipart/byteranges")) == 0)
        {
             PCSTR  s;
             USHORT l;

             // Now, we need to store the string separator in the internal
             // request structure, so that it can be used for parsing out
             // individual ranges.
             //
             // The content-type header is encoded as follows:
             // multipart/byteranges; boundary=THIS_STRING_SEPERATES.

             // Can't use UcFindKeyValuePair as the string separator might have
             // a space (quoted string).
             //
             s = pKnownHeaders[HttpHeaderContentType].pRawValue;
             l = pKnownHeaders[HttpHeaderContentType].RawValueLength;

             bEndQuote = FALSE;

             // Walk up to the '='
    
             while(l)
             {
                if(*s == '=')
                {
                    s++; l--;

                    // Ignore the quote after the string

                    if(l && *s == '"')
                    {
                        bEndQuote = TRUE;
                        s++; l--;
                    }

                    break;
                }
                    
                s++; l--;
             }

             if(l == 0)
             {
                // We have reached the end with no boundary separator!
                return STATUS_INVALID_NETWORK_RESPONSE;
             }

             pRequest->MultipartStringSeparatorLength = 2 + l;

             if(pRequest->MultipartStringSeparatorLength+1 < 
                MULTIPART_SEPARATOR_SIZE)
             {
                 pRequest->pMultipartStringSeparator = 
                     pRequest->MultipartStringSeparatorBuffer;
             }
             else 
             {
                 // The string separator is too big, allocate a buffer
                 pRequest->pMultipartStringSeparator = (PSTR) 
                    UL_ALLOCATE_POOL_WITH_QUOTA(
                        NonPagedPool,
                        pRequest->MultipartStringSeparatorLength+1,
                        UC_MULTIPART_STRING_BUFFER_POOL_TAG,
                        pRequest->pServerInfo->pProcess
                        );

                 if(!pRequest->pMultipartStringSeparator)
                    return STATUS_INVALID_NETWORK_RESPONSE;
              }
           
              pRequest->pMultipartStringSeparator[0] = '-';
              pRequest->pMultipartStringSeparator[1] = '-';

              RtlCopyMemory(pRequest->pMultipartStringSeparator+2,
                            s,
                            pRequest->MultipartStringSeparatorLength-2
                            );


             // If there was an end quote, then the trailing quote 
             // should be ignored.

             if(bEndQuote)
             {
                pRequest->pMultipartStringSeparator[
                    pRequest->MultipartStringSeparatorLength-1] = 0; 
                pRequest->MultipartStringSeparatorLength --;
             }

             pRequest->pMultipartStringSeparator[
                    pRequest->MultipartStringSeparatorLength] = ANSI_NULL;

             pRequest->ResponseMultipartByteranges = TRUE;

        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ucparse.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    ucparse.h

Abstract:

    Contains definitions for ucparse.c .

Author:

    Rajesh Sundaram (rajeshsu) 15-Feb-2002.

Revision History:

--*/

#ifndef _UCPARSE_H_
#define _UCPARSE_H_


/***************************************************************************++

Macros related to client URI parsing and canonicalization.

--***************************************************************************/
//
// Char Types: Used to determine the next state, given the current state
//             and the current char type
//
#define CHAR_END_OF_STRING    0                                    // 0
#define CHAR_FORWARD_SLASH    (HTTP_CHAR_SLASH  >>HTTP_CHAR_SHIFT) // Must be 1
#define CHAR_DOT              (HTTP_CHAR_DOT    >>HTTP_CHAR_SHIFT) // Must be 2
#define CHAR_QUEST_HASH       (HTTP_CHAR_QM_HASH>>HTTP_CHAR_SHIFT) // Must be 3
#define CHAR_PATH_CHAR        4                  // valid URI path chars
#define CHAR_INVALID_CHAR     5                  // invalid URI chars
#define CHAR_EXTENDED_CHAR    CHAR_PATH_CHAR     // chars >= 0x80
#define CHAR_TOTAL_TYPES      6

//
// Total states in the canonicalizer state machine
//
#define TOTAL_STATES 8

//
// Actions performed during state transitions
//
#define ACT_ERROR             0 // Error in the URI
#define ACT_EMIT_CHAR         1 // Emit the current char
#define ACT_EMIT_DOT_CHAR     2 // Emit a '.' and the current char
#define ACT_EMIT_DOT_DOT_CHAR 3 // Emit a '..' and the current char
#define ACT_BACKUP            4 // Backup to a previous '/'
#define ACT_NONE              5 // Do nothing
#define ACT_BACKUP_EMIT_CHAR  6 // Backup to '/' and emit the current char
#define ACT_PANIC             7 // Internal error; bug in the code


//
// The following table serves two purposes:
// (1) help determine the next state based on the current state and 
//     the current char type
// (2) Determine the action that needs to be performed
//
// The first 4 bits denote the action and last 4 bits denote the next state.
// e.g. if the current state = 0,
//         the current char = '/' (type = CHAR_FORWARD_SLASH = 1)
//      then, the next state = NextStateTable[0][CHAR_FORWARD_SLASH]&0xf => 1
//            the action     = NextStateTable[0][CHAR_FORWARD_SLASH]>>4  => 1
//      Hence, the next state is 1 and action is 1 (i.e. ACT_EMIT_CHAR).
//
// NOTE: Junk columns are added to make the column count a power of 2.

#define INIT_TRANSITION_TABLE                                         \
{                                                                     \
/*State     EOS      /      .    (?/#)  (P/E)   I     Junk   Junk */  \
/* 0 */    {0x07,  0x11,  0x07,  0x07,  0x07,  0x07,  0x77,  0x77},   \
/* 1 */    {0x56,  0x51,  0x53,  0x12,  0x14,  0x07,  0x77,  0x77},   \
/* 2 */    {0x56,  0x12,  0x12,  0x12,  0x12,  0x07,  0x77,  0x77},   \
/* 3 */    {0x56,  0x51,  0x55,  0x12,  0x24,  0x07,  0x77,  0x77},   \
/* 4 */    {0x56,  0x11,  0x14,  0x12,  0x14,  0x07,  0x77,  0x77},   \
/* 5 */    {0x46,  0x41,  0x34,  0x62,  0x34,  0x07,  0x77,  0x77},   \
/* 6 */    {0x77,  0x77,  0x77,  0x77,  0x77,  0x77,  0x77,  0x77},   \
/* 7 */    {0x77,  0x77,  0x77,  0x77,  0x77,  0x77,  0x77,  0x77},   \
}


#define  UC_COPY_HEADER_NAME_SP(pBuffer, i)                            \
do {                                                                   \
       PHEADER_MAP_ENTRY _pEntry;                                      \
       _pEntry = &(g_RequestHeaderMapTable[g_RequestHeaderMap[i]]);    \
                                                                       \
       RtlCopyMemory(                                                  \
                     (pBuffer),                                        \
                     _pEntry->MixedCaseHeader,                         \
                     _pEntry->HeaderLength                             \
                     );                                                \
                                                                       \
       (pBuffer) += _pEntry->HeaderLength;                             \
       *(pBuffer)++ = SP;                                              \
                                                                       \
} while (0, 0)

// 1 for SP char.
#define UC_HEADER_NAME_SP_LENGTH(id) \
    (g_RequestHeaderMapTable[g_RequestHeaderMap[id]].HeaderLength + 1)


ULONG
UcComputeRequestHeaderSize(
    IN  PUC_PROCESS_SERVER_INFORMATION  pServInfo,
    IN  PHTTP_REQUEST                   pHttpRequest,
    IN  BOOLEAN                         bChunked,
    IN  BOOLEAN                         bContentLengthHeader,
    IN  PUC_HTTP_AUTH                   pAuth,
    IN  PUC_HTTP_AUTH                   pProxyAuth,
    IN  PBOOLEAN                        bPreAuth,
    IN  PBOOLEAN                        bProxyPreAuth
    );

NTSTATUS
UcGenerateRequestHeaders(
    IN  PHTTP_REQUEST          pRequest,
    IN  PUC_HTTP_REQUEST       pKeRequest,
    IN  BOOLEAN                bChunked,
    IN  ULONGLONG              ContentLength
    );

NTSTATUS
UcGenerateContentLength(
    IN  ULONGLONG ContentLength,
    IN  PUCHAR    pBuffer,
    IN  ULONG     BufferLen,
    OUT PULONG    BytesWritten
    );

ULONG
UcComputeConnectVerbHeaderSize(
    IN  PUC_PROCESS_SERVER_INFORMATION  pServInfo,
    IN  PUC_HTTP_AUTH                   pProxyAuthInfo
    );

NTSTATUS
UcGenerateConnectVerbHeader(
    IN  PUC_HTTP_REQUEST       pRequest,
    IN  PUC_HTTP_REQUEST       pHeadRequest,
    IN  PUC_HTTP_AUTH          pProxyAuthInfo
    );

NTSTATUS
UnescapeW(
    IN  PCWSTR pWChar,
    OUT PWCHAR pOutWChar
    );


__inline
BOOLEAN
UcCheckDisconnectInfo(
    IN PHTTP_VERSION       pVersion,
    IN PHTTP_KNOWN_HEADER  pKnownHeaders
    );


NTSTATUS
UcCanonicalizeURI(
    IN     LPCWSTR    pInUri,
    IN     USHORT     InUriLen,
    IN     PUCHAR     pOutUri,
    IN OUT PUSHORT    pOutUriLen,
    IN     BOOLEAN    bEncode
    );

//
// Response parser functions
//

NTSTATUS
UcFindHeaderNameEnd(
    IN  PUCHAR pHttpRequest,
    IN  ULONG  HttpRequestLength,
    OUT PULONG HeaderNameLength
    );

NTSTATUS
UcFindHeaderValueEnd(
    IN PUCHAR    pHeader,
    IN ULONG     HeaderValueLength,
    IN PUCHAR   *ppFoldingHeader,
    IN PULONG    pBytesTaken
    );

NTSTATUS
UcpLookupHeader(
    IN  PUC_HTTP_REQUEST      pRequest,
    IN  PUCHAR                pHttpRequest,
    IN  ULONG                 HttpRequestLength,
    IN  PHEADER_MAP_ENTRY     pHeaderMap,
    IN  ULONG                 HeaderMapCount,
    OUT ULONG  *              pBytesTaken
    );

NTSTATUS
UcParseHeader(
    IN  PUC_HTTP_REQUEST      pRequest,
    IN  PUCHAR                pHttpRequest,
    IN  ULONG                 HttpRequestLength,
    OUT ULONG  *              pBytesTaken
    );

NTSTATUS
UcParseWWWAuthenticateHeader(
    IN   PCSTR                    pAuthHeader,
    IN   ULONG                    AuthHeaderLength,
    OUT  PHTTP_AUTH_PARSED_PARAMS pAuthSchemeParams
    );

LONG
UcpFindAttribValuePair(
    PCSTR *ppHeader,
    ULONG *pHeaderLength,
    PCSTR *Attrib,
    ULONG *AttribLen,
    PCSTR *Value,
    ULONG *ValueLen
    );


NTSTATUS
UcpParseAuthParams(
    PHTTP_AUTH_SCHEME pAuthScheme,
    PHTTP_AUTH_PARSED_PARAMS pAuthParsedParams,
    PCSTR *ppHeader,
    ULONG *pHeaderLength
    );

NTSTATUS
UcpParseAuthBlob(
    PHTTP_AUTH_SCHEME pAuthScheme,
    PHTTP_AUTH_PARSED_PARAMS pAuthParsedParams,
    PCSTR *ppHeader,
    ULONG *pHeaderLength
    );

NTSTATUS
UcSingleHeaderHandler(
    IN  PUC_HTTP_REQUEST    pRequest,
    IN  PUCHAR              pHeader,
    IN  ULONG               HeaderLength,
    IN  HTTP_HEADER_ID      HeaderID
    );

NTSTATUS
UcMultipleHeaderHandler(
    IN  PUC_HTTP_REQUEST    pRequest,
    IN  PUCHAR              pHeader,
    IN  ULONG               HeaderLength,
    IN  HTTP_HEADER_ID      HeaderID
    );

NTSTATUS
UcAuthenticateHeaderHandler(
    IN  PUC_HTTP_REQUEST    pRequest,
    IN  PUCHAR              pHeader,
    IN  ULONG               HeaderLength,
    IN  HTTP_HEADER_ID      HeaderID
    );

NTSTATUS
UcContentLengthHeaderHandler(
    IN  PUC_HTTP_REQUEST    pRequest,
    IN  PUCHAR              pHeader,
    IN  ULONG               HeaderLength,
    IN  HTTP_HEADER_ID      HeaderID
    );

NTSTATUS
UcTransferEncodingHeaderHandler(
    IN  PUC_HTTP_REQUEST    pRequest,
    IN  PUCHAR              pHeader,
    IN  ULONG               HeaderLength,
    IN  HTTP_HEADER_ID      HeaderID
    );

NTSTATUS
UcConnectionHeaderHandler(
    IN  PUC_HTTP_REQUEST    pRequest,
    IN  PUCHAR              pHeader,
    IN  ULONG               HeaderLength,
    IN  HTTP_HEADER_ID      HeaderID
    );



NTSTATUS
UcContentTypeHeaderHandler(
    IN  PUC_HTTP_REQUEST    pRequest,
    IN  PUCHAR              pHeader,
    IN  ULONG               HeaderLength,
    IN  HTTP_HEADER_ID      HeaderID
    );

#endif // _UCPARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ucauth.h ===
/***************************************************************************++

Copyright (c) 2001-2002 Microsoft Corporation

Module Name:

    ucauth.h

Abstract:

    This module implements the Authentication for the client APIs

Author:

    Rajesh Sundaram (rajeshsu)  01-Jan-2001

Revision History:

--***************************************************************************/

#ifndef UC_AUTH_H
#define UC_AUTH_H

// 
// Forwards
// 

typedef struct _UC_HTTP_REQUEST *PUC_HTTP_REQUEST;
typedef struct _UC_HTTP_AUTH *PUC_HTTP_AUTH;
typedef struct _UC_PROCESS_SERVER_INFORMATION *PUC_PROCESS_SERVER_INFORMATION;
typedef struct _UC_HTTP_AUTH_CACHE *PUC_HTTP_AUTH_CACHE;


//
// HTTP Auth schemes
//

#define HTTP_AUTH_BASIC             "Basic"
#define HTTP_AUTH_BASIC_LENGTH      STRLEN_LIT(HTTP_AUTH_BASIC)
#define HTTP_AUTH_DIGEST            "Digest"
#define HTTP_AUTH_DIGEST_LENGTH     STRLEN_LIT(HTTP_AUTH_DIGEST)
#define HTTP_AUTH_NTLM              "NTLM"
#define HTTP_AUTH_NTLM_LENGTH       STRLEN_LIT(HTTP_AUTH_NTLM)
#define HTTP_AUTH_NEGOTIATE         "Negotiate"
#define HTTP_AUTH_NEGOTIATE_LENGTH  STRLEN_LIT(HTTP_AUTH_NEGOTIATE)
#define HTTP_AUTH_KERBEROS          "Kerberos"
#define HTTP_AUTH_KERBEROS_LENGTH   STRLEN_LIT(HTTP_AUTH_KERBEROS)

// In Wide char
#define HTTP_AUTH_BASIC_W        L"Basic"
#define HTTP_AUTH_BASIC_W_LENGTH \
            (WCSLEN_LIT(HTTP_AUTH_BASIC_W) * sizeof(WCHAR))

#define HTTP_AUTH_WDIGEST_W        L"WDigest"
#define HTTP_AUTH_WDIGEST_W_LENGTH \
            (WCSLEN_LIT(HTTP_AUTH_WDIGEST_W) * sizeof(WCHAR))

#define HTTP_AUTH_NTLM_W        L"NTLM"
#define HTTP_AUTH_NTLM_W_LENGTH \
            (WCSLEN_LIT(HTTP_AUTH_NTLM_W) * sizeof(WCHAR))

#define HTTP_AUTH_KERBEROS_W         L"Kerberos"
#define HTTP_AUTH_KERBEROS_W_LENGTH  \
            (WCSLEN_LIT(HTTP_AUTH_KERBEROS_W) * sizeof(WCHAR))

#define HTTP_AUTH_NEGOTIATE_W         L"Negotiate"
#define HTTP_AUTH_NEGOTIATE_W_LENGTH  \
            (WCSLEN_LIT(HTTP_AUTH_NEGOTIATE_W) * sizeof(WCHAR))

//
// HTTP Auth scheme parameter attribute name
// Each scheme has an array of this attribute structure.
//

typedef struct _HTTP_AUTH_PARAM_ATTRIB {
    PCSTR Name;                 // points to the name of the attribute
    ULONG Length;               // length of the name
} HTTP_AUTH_PARAM_ATTRIB, *PHTTP_AUTH_PARAM_ATTRIB;


//
// HTTP Auth scheme parameter value
// Parameter attribute's value is represented by this struct.
//

typedef struct _HTTP_AUTH_PARAM_VALUE {
    PCSTR Value;                // points to the value
    ULONG Length;               // length of the value
} HTTP_AUTH_PARAM_VALUE, *PHTTP_AUTH_PARAM_VALUE;


//
// HTTP Auth scheme parameters after parsing
// Per scheme.  Points to parsed parameter values.
//

typedef struct _HTTP_AUTH_PARSED_PARAMS {
    BOOLEAN bPresent;               // Scheme present in the header?
    ULONG   Length;                 // Length of the scheme in the header
    PCSTR   pScheme;                // Pointer to scheme in header
    ULONG   NumberKnownParams;      // Number of known parameters in header
    ULONG   NumberUnknownParams;    // Number of unknown parameters
    PHTTP_AUTH_PARAM_VALUE Params;  // Actual parameter values
} HTTP_AUTH_PARSED_PARAMS, *PHTTP_AUTH_PARSED_PARAMS;


//
// Each auth scheme is represented by an auth scheme structure.
// It contains a pointer to function that parses the auth scheme 
// in the WWW-Authenticate header.
//

typedef struct _HTTP_AUTH_SCHEME 
{
    PCSTR Name;                // Auth scheme name
    ULONG NameLength;          // Length of auth scheme name

    PCWSTR NameW;               // Scheme name in wide char
    ULONG  NameWLength;         // Length of scheme name (in bytes)

    // Pointer to a function which parses this auth scheme's parameters
    NTSTATUS (*ParamParser)(struct _HTTP_AUTH_SCHEME *,
                            HTTP_AUTH_PARSED_PARAMS *,
                            PCSTR *ppHeader,
                            ULONG *HeaderLength);

    
    ULONG NumberParams;                   // Number of known parameters
    HTTP_AUTH_PARAM_ATTRIB *ParamAttribs; // Names of the known parameters

    //
    // SSPI related information
    //
    BOOLEAN bSupported;                   // Whether or not the scheme is
                                          // supported by SSPI
    ULONG   SspiMaxTokenSize;             // Maximum token size for SSPI
    BOOLEAN bServerNameRequired;          // Does SSPI need server name?

} HTTP_AUTH_SCHEME, *PHTTP_AUTH_SCHEME;

//
// Macro for easy access
//

#define SSPI_MAX_TOKEN_SIZE(AuthType) \
    (HttpAuthScheme[AuthType].SspiMaxTokenSize)

//
// Macro for generating known attribute names (for known schemes)
//

#define GEN_AUTH_PARAM_ATTRIB(arg) {arg, STRLEN_LIT(arg)}

//
// NULL scheme
//

#define HTTP_AUTH_SCHEME_NULL {NULL, 0, NULL, 0, NULL, 0, NULL, FALSE,0,FALSE}

//
// Basic scheme
//

extern HTTP_AUTH_PARAM_ATTRIB HttpAuthBasicParams[];

typedef enum _HTTP_AUTH_BASIC_PARAM
{
    HttpAuthBasicRealm = 0,
    HttpAuthBasicParamCount
} HTTP_AUTH_BASIC_PARAM;

// Make sure HTTP_AUTH_BASIC_PARAMS_INIT is correctly initialized.
C_ASSERT(HttpAuthBasicRealm == 0);

#define HTTP_AUTH_BASIC_PARAMS_INIT    {GEN_AUTH_PARAM_ATTRIB("realm")}

#define HTTP_AUTH_SCHEME_BASIC                  \
{                                               \
    HTTP_AUTH_BASIC,                            \
    HTTP_AUTH_BASIC_LENGTH,                     \
    HTTP_AUTH_BASIC_W,                          \
    HTTP_AUTH_BASIC_W_LENGTH,                   \
    UcpParseAuthParams,                         \
    DIMENSION(HttpAuthBasicParams),             \
    HttpAuthBasicParams,                        \
    TRUE,                                       \
    0,                                          \
    FALSE                                       \
}


//
// Digest scheme
//

extern HTTP_AUTH_PARAM_ATTRIB HttpAuthDigestParams[];

// Do not change the order.  Must be same as HTTP_AUTH_DIGEST_PARAMS_INIT
typedef enum _HTTP_AUTH_DIGEST_PARAM
{
    HttpAuthDigestRealm = 0,
    HttpAuthDigestDomain,
    HttpAuthDigestNonce,
    HttpAuthDigestOpaque,
    HttpAuthDigestStale,
    HttpAuthDigestAlgorithm,
    HttpAuthDigestQop,
    HttpAuthDigestParamCount
} HTTP_AUTH_DIGEST_PARAM;

// Make sure HTTP_AUTH_DIGEST_PARAMES_INIT is initialized correctly.
C_ASSERT(HttpAuthDigestRealm      == 0);
C_ASSERT(HttpAuthDigestDomain     == 1);
C_ASSERT(HttpAuthDigestNonce      == 2);
C_ASSERT(HttpAuthDigestOpaque     == 3);
C_ASSERT(HttpAuthDigestStale      == 4);
C_ASSERT(HttpAuthDigestAlgorithm  == 5);
C_ASSERT(HttpAuthDigestQop        == 6);
C_ASSERT(HttpAuthDigestParamCount == 7);

#define HTTP_AUTH_DIGEST_PARAMS_INIT    \
{                                       \
    GEN_AUTH_PARAM_ATTRIB("realm"),     \
    GEN_AUTH_PARAM_ATTRIB("domain"),    \
    GEN_AUTH_PARAM_ATTRIB("nonce"),     \
    GEN_AUTH_PARAM_ATTRIB("opaque"),    \
    GEN_AUTH_PARAM_ATTRIB("stale"),     \
    GEN_AUTH_PARAM_ATTRIB("algorithm"), \
    GEN_AUTH_PARAM_ATTRIB("qop")        \
}

#define HTTP_AUTH_SCHEME_DIGEST                                         \
{                                                                       \
    HTTP_AUTH_DIGEST,                                                   \
    HTTP_AUTH_DIGEST_LENGTH,                                            \
    HTTP_AUTH_WDIGEST_W,                                                \
    HTTP_AUTH_WDIGEST_W_LENGTH,                                         \
    UcpParseAuthParams,                                                 \
    DIMENSION(HttpAuthDigestParams),                                    \
    HttpAuthDigestParams,                                               \
    FALSE,                                                              \
    0,                                                                  \
    FALSE                                                               \
}


//
// NTLM
//

#define HTTP_AUTH_SCHEME_NTLM                   \
{                                               \
    HTTP_AUTH_NTLM,                             \
    HTTP_AUTH_NTLM_LENGTH,                      \
    HTTP_AUTH_NTLM_W,                           \
    HTTP_AUTH_NTLM_W_LENGTH,                    \
    UcpParseAuthBlob,                           \
    0,                                          \
    NULL,                                       \
    FALSE,                                      \
    0,                                          \
    FALSE                                       \
}


//
// Negotiate
//

#define HTTP_AUTH_SCHEME_NEGOTIATE              \
{                                               \
    HTTP_AUTH_NEGOTIATE,                        \
    HTTP_AUTH_NEGOTIATE_LENGTH,                 \
    HTTP_AUTH_NEGOTIATE_W,                      \
    HTTP_AUTH_NEGOTIATE_W_LENGTH,               \
    UcpParseAuthBlob,                           \
    0,                                          \
    NULL,                                       \
    FALSE,                                      \
    0,                                          \
    TRUE                                        \
}


//
// Kerberos
//

#define HTTP_AUTH_SCHEME_KERBEROS               \
{                                               \
    HTTP_AUTH_KERBEROS,                         \
    HTTP_AUTH_KERBEROS_LENGTH,                  \
    HTTP_AUTH_KERBEROS_W,                       \
    HTTP_AUTH_KERBEROS_W_LENGTH,                \
    UcpParseAuthBlob,                           \
    0,                                          \
    NULL,                                       \
    FALSE,                                      \
    0,                                          \
    TRUE                                        \
}


//
// Assert that the auth scheme enums can be used as an index 
// into HttpAuthScheme table
//

C_ASSERT(HttpAuthTypeAutoSelect == 0);
C_ASSERT(HttpAuthTypeBasic      == 1);
C_ASSERT(HttpAuthTypeDigest     == 2);
C_ASSERT(HttpAuthTypeNTLM       == 3);
C_ASSERT(HttpAuthTypeNegotiate  == 4);
C_ASSERT(HttpAuthTypeKerberos   == 5);
C_ASSERT(HttpAuthTypesCount     == 6);

extern HTTP_AUTH_SCHEME HttpAuthScheme[HttpAuthTypesCount];

//
// Initialization for HttpAuthScheme
//

#define HTTP_AUTH_SCHEME_INIT                   \
{                                               \
    HTTP_AUTH_SCHEME_NULL,                      \
    HTTP_AUTH_SCHEME_BASIC,                     \
    HTTP_AUTH_SCHEME_DIGEST,                    \
    HTTP_AUTH_SCHEME_NTLM,                      \
    HTTP_AUTH_SCHEME_NEGOTIATE,                 \
    HTTP_AUTH_SCHEME_KERBEROS                   \
}


//
// Auth types in the order of preference
//

extern HTTP_AUTH_TYPE PreferredAuthTypes[];

#define PREFERRED_AUTH_TYPES_INIT {             \
    HttpAuthTypeNegotiate,                      \
    HttpAuthTypeKerberos,                       \
    HttpAuthTypeNTLM,                           \
    HttpAuthTypeDigest                          \
}


//
// Maximum number of parameters any known scheme accepts
//

#define HTTP_MAX_AUTH_PARAM_COUNT HttpAuthDigestParamCount

//
// Total number of parameters (considering all known schemes)
//

#define HTTP_TOTAL_AUTH_PARAM_COUNT             \
(1 + /* extra - unused */                       \
 HttpAuthBasicParamCount +                      \
 HttpAuthDigestParamCount +                     \
 1 + /* NTLM */                                 \
 1 + /* Negotiate */                            \
 1   /* Kerberos  */                            \
)


//
// When parsing a WWW-Authenticate header, the parsed parameters struct
// must be initialize to point to an array of parameter values
// in which the result will be returned.  Initialize to NULL if you're
// not interested in return values.
//

#define INIT_AUTH_PARSED_PARAMS(AuthParsedParams, AuthParamValue)       \
do {                                                                    \
    RtlZeroMemory(AuthParsedParams, sizeof(AuthParsedParams));          \
    if (AuthParamValue)                                                 \
    {                                                                   \
        int i;                                                          \
        PHTTP_AUTH_PARAM_VALUE ptr = AuthParamValue;                    \
                                                                        \
        for (i = 1; i < HttpAuthTypesCount; i++)                        \
        {                                                               \
            AuthParsedParams[i].Params = ptr;                           \
            ptr += MIN(HttpAuthScheme[i].NumberParams, 1);              \
        }                                                               \
    }                                                                   \
} while (0, 0)


//
// Initialize a perticular auth scheme
//

#define INIT_AUTH_PARSED_PARAMS_FOR_SCHEME(ParsedParams, pParamValue, type) \
do {                                                                 \
    ParsedParams[type].Params = pParamValue;                         \
} while (0, 0)


// 
// HTTP Auth parameters
//

#define HTTP_COPY_QUOTE_AUTH_PARAM(pBuffer, param, pValue, ValueLength)     \
do {                                                                  \
    RtlCopyMemory((pBuffer),                                          \
                  HTTP_AUTH_##param##,                                \
                  (sizeof(HTTP_AUTH_##param##) - sizeof(CHAR))        \
                 );                                                   \
    (pBuffer) += (sizeof(HTTP_AUTH_##param##) - sizeof(CHAR));        \
    *(pBuffer) = '=';                                                 \
    (pBuffer)++;                                                      \
    *(pBuffer) = '"';                                                 \
    (pBuffer)++;                                                      \
    RtlCopyMemory((pBuffer),                                          \
                  (pValue),                                           \
                  (ValueLength)                                       \
                 );                                                   \
    (pBuffer) += (ValueLength);                                       \
    *(pBuffer) = '"';                                                 \
    (pBuffer)++;                                                      \
    *(pBuffer) = ',';                                                 \
    (pBuffer)++;                                                      \
    *(pBuffer) = ' ';                                                 \
    (pBuffer)++;                                                      \
} while (0, 0)

#define HTTP_COPY_UNQUOTE_AUTH_PARAM(pBuffer, param, pValue, ValueLength)     \
do {                                                                  \
    RtlCopyMemory((pBuffer),                                          \
                  HTTP_AUTH_##param##,                                \
                  (sizeof(HTTP_AUTH_##param##) - sizeof(CHAR))        \
                 );                                                   \
    (pBuffer) += (sizeof(HTTP_AUTH_##param##) - sizeof(CHAR));        \
    *(pBuffer) = '=';                                                 \
    (pBuffer)++;                                                      \
    RtlCopyMemory((pBuffer),                                          \
                  (pValue),                                           \
                  (ValueLength)                                       \
                 );                                                   \
    (pBuffer) += (ValueLength);                                       \
    *(pBuffer) = ',';                                                 \
    (pBuffer)++;                                                      \
    *(pBuffer) = ' ';                                                 \
    (pBuffer)++;                                                      \
} while (0, 0)


#define HTTP_AUTH_BASIC_REALM "realm"
#define HTTP_AUTH_BASIC_REALM_LENGTH STRLEN_LIT(HTTP_AUTH_BASIC_REALM)

//
// Helper macros
//

#define UcpUriCompareLongest(a,b) \
        (strstr((const char *)a,(const char *)b) == a?1:0)
#define UcpUriCompareExact(a,b) strcmp(a, b)
#define UcpRealmCompare(a,b) strcmp((const char *)a,(const char *)b)

#define UcFreeAuthCacheEntry(pContext)                            \
{                                                                 \
    if((pContext)->pAuthBlob)                                     \
        UL_FREE_POOL((pContext)->pAuthBlob, UC_AUTH_POOL_TAG);    \
    UL_FREE_POOL((pContext), UC_AUTH_POOL_TAG);                   \
}


#define UC_AUTH_CACHE_SIGNATURE   MAKE_SIGNATURE('AUTH')
#define UC_AUTH_CACHE_SIGNATURE_X MAKE_FREE_SIGNATURE(UC_AUTH_CACHE_SIGNATURE)
#define UC_IS_VALID_AUTH_CACHE(pAuth)                \
    HAS_VALID_SIGNATURE(pAuth, UC_AUTH_CACHE_SIGNATURE)

typedef struct _UC_HTTP_AUTH_CACHE
{
    ULONG               Signature;
    HTTP_AUTH_TYPE      AuthType;
    LIST_ENTRY          Linkage;
    LIST_ENTRY          DigestLinkage;
    LIST_ENTRY          pDigestUriList;
    PSTR                pRealm;
    ULONG               RealmLength;
    PSTR                pUri;
    ULONG               UriLength;
    BOOLEAN             Valid;
    PUC_HTTP_AUTH       pAuthBlob;
    PUC_HTTP_AUTH_CACHE pDependParent;
    ULONG               AuthCacheSize;
} UC_HTTP_AUTH_CACHE, *PUC_HTTP_AUTH_CACHE;


//
// An Internal structure for authentication
//

typedef struct _UC_HTTP_AUTH
{

    // Length of memory allocated for this structure.
    ULONG                 AuthInternalLength;

    // User's credentials.
    HTTP_AUTH_CREDENTIALS Credentials;

    //
    // pRequestAuthBlob points to the blob after the "Authorization:" field
    // in the request headers.  RequestAuthBlobMaxLength determines how big
    // the auth blob can be (worst case).  RequestAuthHeaderMaxLength is the
    // length of the entire header (worst case).
    //

    ULONG                 RequestAuthHeaderMaxLength;
    ULONG                 RequestAuthBlobMaxLength;
    PUCHAR                pRequestAuthBlob;

    // Authenticate scheme information (used only for digest)
    HTTP_AUTH_PARSED_PARAMS AuthSchemeInfo;

    // Authentication parameter values
    HTTP_AUTH_PARAM_VALUE ParamValue[HTTP_MAX_AUTH_PARAM_COUNT];

    struct
    {
        PUCHAR      pEncodedBuffer;// We will allocate buffer for 
                                   // storing the username:password string.
        ULONG       EncodedBufferLength;
    } Basic;

    //
    // SSPI related parameters
    //
    BOOLEAN     bValidCredHandle;
    BOOLEAN     bValidCtxtHandle;
    CredHandle  hCredentials;
    CtxtHandle  hContext;

    PUCHAR      pChallengeBuffer;
    ULONG       ChallengeBufferSize;
    ULONG       ChallengeBufferMaxSize;

} UC_HTTP_AUTH, *PUC_HTTP_AUTH;


HTTP_AUTH_TYPE
UcpAutoSelectAuthType(
    IN PHTTP_AUTH_CREDENTIALS pAuth
    );

NTSTATUS
UcpGeneratePreAuthHeader(
    IN  PUC_HTTP_REQUEST pKeRequest,
    IN  PUC_HTTP_AUTH    pInternalAuth,
    IN  HTTP_HEADER_ID   HeaderId,
    IN  PSTR             pMethod,
    IN  ULONG            MethodLength,
    IN  PUCHAR           pBuffer,
    IN  ULONG            BufferLength,
    OUT PULONG           pBytesTaken
    );

NTSTATUS
UcpGenerateDigestAuthHeader(
    IN  PUC_HTTP_AUTH          pInternalAuth,
    IN  HTTP_HEADER_ID         HeaderID,
    IN  PSTR                   pMethod,
    IN  ULONG                  MethodLength,
    IN  PSTR                   pUri,
    IN  ULONG                  UriLength,
    IN  PUCHAR                 pOutBuffer,
    IN  ULONG                  OutBufferLen,
    OUT PULONG                 pOutBytesTaken
    );

NTSTATUS
UcpGenerateSSPIAuthHeader(
    IN  PUC_PROCESS_SERVER_INFORMATION pServInfo,
    IN  PUC_HTTP_AUTH                  pInternalAuth,
    IN  HTTP_HEADER_ID                 HeaderID,
    IN  PUCHAR                         pOutBuffer,
    IN  ULONG                          OutBufferLen,
    OUT PULONG                         pOutBytesTaken,
    OUT PBOOLEAN                       bRenegotiate
    );

NTSTATUS
UcpGenerateSSPIAuthBlob(
    IN     PUC_PROCESS_SERVER_INFORMATION pServInfo,
    IN     PUC_HTTP_AUTH                  pUcAuth,
    IN     PUCHAR                         pOutBuffer,
    IN     ULONG                          OutBufferLen,
       OUT PULONG                         pOutBytesTaken,
       OUT PBOOLEAN                       bRenegotiate
    );

NTSTATUS
UcInitializeSSPI();

NTSTATUS
UcFindURIEntry(
    IN  PUC_PROCESS_SERVER_INFORMATION pServInfo,
    IN  PSTR                           pUri,
    IN  PUC_HTTP_REQUEST               pRequest,
    IN  PSTR                           pMethod,
    IN  ULONG                          MethodLength,
    IN  PUCHAR                         pBuffer,
    IN  ULONG                          BufferLen,
    OUT PULONG                         pBytesTaken
    );

NTSTATUS
UcAddURIEntry(
    IN HTTP_AUTH_TYPE                 AuthType,
    IN PUC_PROCESS_SERVER_INFORMATION pServInfo,
    IN PCSTR                          pInputURI,
    IN USHORT                         UriLength,
    IN PCSTR                          pInputRealm,
    IN ULONG                          RealmLength,
    IN PCSTR                          pUriList,
    IN ULONG                          UriListLength,
    IN PUC_HTTP_AUTH                  pAuthBlob
    );

ULONG
UcComputeAuthHeaderSize(
    PHTTP_AUTH_CREDENTIALS         pAuth,
    PULONG                         AuthInternalLength,
    PHTTP_AUTH_TYPE                pAuthInternalType,
    HTTP_HEADER_ID                 HeaderId
    );

NTSTATUS
UcGenerateAuthHeaderFromCredentials(
    IN  PUC_PROCESS_SERVER_INFORMATION pServerInfo,
    IN  PUC_HTTP_AUTH                  pInternalAuth,
    IN  HTTP_HEADER_ID                 HeaderId,
    IN  PSTR                           pMethod,
    IN  ULONG                          MethodLength,
    IN  PSTR                           pUri,
    IN  ULONG                          UriLength,
    IN  PUCHAR                         pBuffer,
    IN  ULONG                          BufferLength,
    OUT PULONG                         BytesWritten,
    OUT PBOOLEAN                       bDontFreeMdls
    );

NTSTATUS
UcGenerateProxyAuthHeaderFromCache(
    IN  PUC_HTTP_REQUEST pKeRequest,
    IN  PSTR             pMethod,
    IN  ULONG            MethodLength,
    IN  PUCHAR           pBuffer,
    IN  ULONG            BufferLength,
    OUT PULONG           pBytesTaken
    );

NTSTATUS
UcpProcessUriForPreAuth(
    IN PSTR    pUri,
    IN PUSHORT UriLength
    );

PUC_HTTP_AUTH_CACHE
UcpAllocateAuthCacheEntry(
    IN PUC_PROCESS_SERVER_INFORMATION pInfo,
    IN HTTP_AUTH_TYPE AuthType,
    IN ULONG          UriLength,
    IN ULONG          RealmLength,
    IN PCSTR          pInputURI,
    IN PCSTR          pInputRealm,
    IN PUC_HTTP_AUTH  pAuthBlob
    );

VOID
UcDeleteURIEntry(
    IN PUC_PROCESS_SERVER_INFORMATION pInfo,
    IN PUC_HTTP_AUTH_CACHE            pAuth
    );

VOID
UcDeleteAllURIEntries(
    IN PUC_PROCESS_SERVER_INFORMATION pInfo
    );

NTSTATUS
UcDestroyInternalAuth(
    IN  PUC_HTTP_AUTH           pIAuth,
    IN  PEPROCESS               pProcess
    );

NTSTATUS
UcCopyAuthCredentialsToInternal(
    IN  PUC_HTTP_AUTH            pInternalAuth,
    IN  ULONG                    AuthInternalLength,
    IN  HTTP_AUTH_TYPE           AuthInternalType,
    IN  PHTTP_AUTH_CREDENTIALS   pAuth,
    IN  ULONG                    AuthHeaderLength
    );

ULONG
_WideCharToMultiByte(
    ULONG uCodePage,
    ULONG dwFlags,
    PCWSTR lpWideCharStr,
    int cchWideChar,
    PSTR lpMultiByteStr,
    int cchMultiByte,
    PCSTR lpDefaultChar,
    BOOLEAN *lpfUsedDefaultChar
    );

NTSTATUS
UcParseAuthChallenge(
    IN  PUC_HTTP_AUTH          pInternalAuth,
    IN  PCSTR                  pBuffer,
    IN  ULONG                  BufLen,
    IN  PUC_HTTP_REQUEST       pRequest,
    OUT PULONG                 Flags
    );

NTSTATUS
UcUpdateAuthorizationHeader(
    IN  PUC_HTTP_REQUEST pRequest,
    IN  PUC_HTTP_AUTH    pAuth,
    OUT PBOOLEAN         bRenegotiate
    );


NTSTATUS
UcpAcquireClientCredentialsHandle(
    IN  PWSTR                  SchemeName,
    IN  USHORT                 SchemeNameLength,
    IN  PHTTP_AUTH_CREDENTIALS pCredentials,
    OUT PCredHandle            pClientCred
    );

NTSTATUS
UcpGenerateBasicHeader(
    IN  PHTTP_AUTH_CREDENTIALS         pAuth,
    IN  PUC_HTTP_AUTH                  pInternalAuth
    );

NTSTATUS
UcpGenerateDigestPreAuthHeader(
    IN  HTTP_HEADER_ID HeaderID,
    IN  PCtxtHandle    phClientContext,
    IN  PSTR           pUri,
    IN  ULONG          UriLength,
    IN  PSTR           pMethod,
    IN  ULONG          MethodLength,
    IN  PUCHAR         pOutBuffer,
    IN  ULONG          OutBufferLen,
    OUT PULONG         pOutBytesTaken
    );

NTSTATUS
UcpUpdateSSPIAuthHeader(
    IN PUC_HTTP_REQUEST pRequest,
    IN PUC_HTTP_AUTH    pAuth,
    IN PBOOLEAN         bRenegotiate
    );

NTSTATUS
UcpProcessAuthParams(
    IN PUC_HTTP_REQUEST         pRequest,
    IN PUC_HTTP_AUTH            pInternalAuth,
    IN PHTTP_AUTH_PARSED_PARAMS AuthParsedParams,
    IN HTTP_AUTH_TYPE           AuthType
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\uctdi.c ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    uctdi.c

Abstract:

    Contains the TDI related functionality for the HTTP client side stuff.
    
Author:
    
    Henry Sanders   (henrysa)   07-Aug-2000
    Rajesh Sundaram (rajeshsu)  01-Oct-2000

Revision History:

--*/

#include "precomp.h"


#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGEUC, UcClientConnect)
#pragma alloc_text( PAGEUC, UcCloseConnection)
#pragma alloc_text( PAGEUC, UcSendData)
#pragma alloc_text( PAGEUC, UcReceiveData)
#pragma alloc_text( PAGEUC, UcpTdiDisconnectHandler)
#pragma alloc_text( PAGEUC, UcpCloseRawConnection)
#pragma alloc_text( PAGEUC, UcCloseRawFilterConnection)
#pragma alloc_text( PAGEUC, UcDisconnectRawFilterConnection)
#pragma alloc_text( PAGEUC, UcpSendRawData)
#pragma alloc_text( PAGEUC, UcpReceiveRawData)
#pragma alloc_text( PAGEUC, UcpTdiReceiveHandler)
#pragma alloc_text( PAGEUC, UcpReceiveExpeditedHandler)
#pragma alloc_text( PAGEUC, UcpRestartSendData)
#pragma alloc_text( PAGEUC, UcpBeginDisconnect)
#pragma alloc_text( PAGEUC, UcpRestartDisconnect)
#pragma alloc_text( PAGEUC, UcpBeginAbort)
#pragma alloc_text( PAGEUC, UcpRestartAbort)
#pragma alloc_text( PAGEUC, UcpRestartReceive)
#pragma alloc_text( PAGEUC, UcpRestartClientReceive)
#pragma alloc_text( PAGEUC, UcpConnectComplete)
#pragma alloc_text( PAGEUC, UcSetFlag)
#pragma alloc_text( PAGEUC, UcpBuildTdiReceiveBuffer)

#endif  // ALLOC_PRAGMA

//
// Public functions.
//


/***************************************************************************++

Routine Description:

    Connects an UC connection to a remote server. We take as input an 
    HTTP connection object. It's assumed that the connection object 
    already has the remote address information filled in.
    
Arguments:

    pConnection         - Pointer to the HTTP connection object to be connected.
    pIrp                - Pointer to Irp to use for the connect request.
    
Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcClientConnect(
    IN PUC_CLIENT_CONNECTION    pConnection,
    IN PIRP                     pIrp
    )

{
    NTSTATUS    status;
    LONGLONG    llTimeOut;
    PLONGLONG   pllTimeOut = NULL;
    USHORT      AddressType;

#if CLIENT_IP_ADDRESS_TRACE

    CHAR        IpAddressString[MAX_IP_ADDR_AND_PORT_STRING_LEN + 1];
    ULONG       Length;

#endif

    AddressType = pConnection->pNextAddress->AddressType;

    ASSERT(AddressType == TDI_ADDRESS_TYPE_IP ||
           AddressType == TDI_ADDRESS_TYPE_IP6);

#if CLIENT_IP_ADDRESS_TRACE

    Length =  HostAddressAndPortToString(
                 IpAddressString,
                 pConnection->pNextAddress->Address,
                 AddressType
                 );

    ASSERT(Length < sizeof(IpAddressString));

    UlTrace(TDI, ("[UcClientConnect]: Trying Address %s \n", IpAddressString));

#endif

    // 
    // Format the connect IRP. When the IRP completes our completion routine
    // (UcConnectComplete) will be called.
    //

    pConnection->pTdiObjects->TdiInfo.RemoteAddress = 
            &pConnection->RemoteAddress;

    pConnection->pTdiObjects->TdiInfo.RemoteAddressLength =
            (FIELD_OFFSET(TRANSPORT_ADDRESS, Address) +
             FIELD_OFFSET(TA_ADDRESS, Address) + 
             pConnection->pNextAddress->AddressLength 
            );

    pConnection->RemoteAddress.GenericTransportAddress.TAAddressCount = 1;

    ASSERT(sizeof(pConnection->RemoteAddress) >=
                pConnection->pTdiObjects->TdiInfo.RemoteAddressLength);

    RtlCopyMemory(
            pConnection->RemoteAddress.GenericTransportAddress.Address,
            pConnection->pNextAddress,
            FIELD_OFFSET(TA_ADDRESS, Address) + 
            pConnection->pNextAddress->AddressLength
            );
            
    if(pConnection->pServerInfo->ConnectionTimeout)
    {
        llTimeOut = Int32x32To64(pConnection->pServerInfo->ConnectionTimeout, 
                                 -10000);

        pllTimeOut = &llTimeOut;
    }

    TdiBuildConnect(
        pIrp,
        pConnection->pTdiObjects->ConnectionObject.pDeviceObject,
        pConnection->pTdiObjects->ConnectionObject.pFileObject, 
        UcpConnectComplete,
        pConnection,
        pllTimeOut,
        &pConnection->pTdiObjects->TdiInfo,
        NULL
        );

    status = UlCallDriver(
                pConnection->pTdiObjects->ConnectionObject.pDeviceObject,
                pIrp
                );

    return status;
}

/***************************************************************************++

Routine Description:

    Closes a previously accepted connection.

Arguments:

    pConnection - Supplies a pointer to a connection as previously
        indicated to the PUL_CONNECTION_REQUEST handler.

    AbortiveDisconnect - Supplies TRUE if the connection is to be abortively
        disconnected, FALSE if it should be gracefully disconnected.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the connection is fully closed.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcCloseConnection(
    IN PVOID                  pConnectionContext,
    IN BOOLEAN                AbortiveDisconnect,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID                  pCompletionContext,
    IN NTSTATUS               status
    )
{
    KIRQL                  OldIrql;
    PUC_CLIENT_CONNECTION  pConnection;

    //
    // Sanity check.
    //

    pConnection = (PUC_CLIENT_CONNECTION) pConnectionContext;
    ASSERT( UC_IS_VALID_CLIENT_CONNECTION( pConnection ) );

    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

    if(AbortiveDisconnect)
    {
        switch(pConnection->ConnectionState)
        {
            case UcConnectStateConnectComplete:
            case UcConnectStateProxySslConnect:
            case UcConnectStateProxySslConnectComplete:
            case UcConnectStateConnectReady:
            case UcConnectStateDisconnectComplete:
            case UcConnectStatePerformingSslHandshake:

                pConnection->ConnectionState  = UcConnectStateAbortPending;
                pConnection->ConnectionStatus = status;

                UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

                status = UcpCloseRawConnection(
                                pConnection,
                                AbortiveDisconnect,
                                pCompletionRoutine,
                                pCompletionContext
                                );
                break;

            case UcConnectStateDisconnectPending:

                // We had originally sent a graceful disconnect, but now
                // we intend to RST the connection. We should propagate the
                // new error code.

                pConnection->ConnectionStatus = status;
                pConnection->Flags |= CLIENT_CONN_FLAG_ABORT_PENDING;

                UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

                break;

            default:
                UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
                break;
        }
    }
    else
    {
        switch(pConnection->ConnectionState)
        {
            case UcConnectStateConnectReady:
    
                //
                // We only send graceful disconnects through the filter
                // process. There's also no point in going through the
                // filter if the connection is already being closed or
                // aborted.
                //
                pConnection->ConnectionStatus = status;
    
                if(pConnection->FilterInfo.pFilterChannel)
                {
                    pConnection->ConnectionState =
                        UcConnectStateIssueFilterClose;
    
                    ASSERT(pCompletionRoutine == NULL);
                    ASSERT(pCompletionContext == NULL);

                    UcKickOffConnectionStateMachine(
                        pConnection, 
                        OldIrql, 
                        UcConnectionWorkItem
                        );
                }
                else
                {
                    pConnection->ConnectionState =  
                        UcConnectStateDisconnectPending;
        
                    UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

                    //
                    // Really close the connection.
                    //
                    
                    status = UcpCloseRawConnection(
                                    pConnection,
                                    AbortiveDisconnect,
                                    pCompletionRoutine,
                                    pCompletionContext
                                    );
                }
                break;

            default:
                UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
                break;
        }
    }

    return status;

}   // UcCloseConnection

/*********************************************************************++

Routine Description:

    This is our basic TDI send routine. We take an request structure, format
    the IRP as a TDI send IRP, and send it.
            
Arguments:

    pRequest            - Pointer to request to be sent.    
    pConnection         - Connection on which request is to be sent.
    
Return Value:

    NTSTATUS - Status of send.

--*********************************************************************/
NTSTATUS
UcSendData(
    IN PUC_CLIENT_CONNECTION     pConnection,
    IN PMDL                      pMdlChain,
    IN ULONG                     Length,
    IN PUL_COMPLETION_ROUTINE    pCompletionRoutine,
    IN PVOID                     pCompletionContext,
    IN PIRP                      pIrp,
    IN BOOLEAN                   RawSend
    )
{
    PUL_IRP_CONTEXT pIrpContext;
    NTSTATUS        status;

    //
    // Sanity Checks.
    //
    ASSERT( UC_IS_VALID_CLIENT_CONNECTION(pConnection) );
    ASSERT( pMdlChain != NULL);
    ASSERT( Length > 0);
    ASSERT( pCompletionRoutine != NULL);


    //
    // Allocate and initialize the IRP context
    //
    pIrpContext = UlPplAllocateIrpContext();

    if(pIrpContext == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto fatal;
    }

    ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );

    pIrpContext->pConnectionContext = (PVOID)pConnection;
    pIrpContext->pCompletionContext = pCompletionContext;
    pIrpContext->pOwnIrp            = pIrp;
    pIrpContext->pCompletionRoutine = pCompletionRoutine;
    pIrpContext->OwnIrpContext      = FALSE;

    //
    // Try to send the data.
    //

    if (pConnection->FilterInfo.pFilterChannel && !RawSend)
    {
        PAGED_CODE();
        //
        // First go through the filter.
        //
        status = UlFilterSendHandler(
                        &pConnection->FilterInfo,
                        pMdlChain,
                        Length,
                        pIrpContext
                        );

        ASSERT(status == STATUS_PENDING);

    }
    else 
    {

        //
        // Just send it directly to the network.
        //

        status = UcpSendRawData(
                        pConnection,
                        pMdlChain,
                        Length,
                        pIrpContext,
                        FALSE
                        );
    }

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    return STATUS_PENDING;

fatal:

    ASSERT(!NT_SUCCESS(status));
    
    if(pIrpContext != NULL)
    {
        UlPplFreeIrpContext(pIrpContext);
    }

    UC_CLOSE_CONNECTION(pConnection, TRUE, status);


    status =  UlInvokeCompletionRoutine(
                    status,
                    0,
                    pCompletionRoutine,
                    pCompletionContext
                    );

    return status;

} // UcSendData

/***************************************************************************++

Routine Description:

    Receives data from the specified connection. This function is
    typically used after a receive indication handler has failed to
    consume all of the indicated data.

    If the connection is filtered, the data will be read from the filter
    channel.

Arguments:

    pConnection - Supplies a pointer to a connection as previously
        indicated to the PUL_CONNECTION_REQUEST handler.

    pBuffer - Supplies a pointer to the target buffer for the received
        data.

    BufferLength - Supplies the length of pBuffer.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the listening endpoint is fully closed.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcReceiveData(
    IN PVOID                  pConnectionContext,
    IN PVOID                  pBuffer,
    IN ULONG                  BufferLength,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID                  pCompletionContext
    )
{
    NTSTATUS               status;
    PUC_CLIENT_CONNECTION  pConnection;

    pConnection = (PUC_CLIENT_CONNECTION) pConnectionContext;

    //
    // Sanity check.
    //

    ASSERT( UC_IS_VALID_CLIENT_CONNECTION( pConnection ) );

    if(pConnection->FilterInfo.pFilterChannel)
    {
        //
        // This is a filtered connection, get the data from the 
        // filter.
        //

        status = UlFilterReadHandler(
                    &pConnection->FilterInfo,
                    (PBYTE)pBuffer,
                    BufferLength,
                    pCompletionRoutine,
                    pCompletionContext
                    );
    }
    else 
    {
        // 
        // This is not a filtered connection. Get the data from 
        // TDI.
        //

        status = UcpReceiveRawData(
                    pConnectionContext,
                    pBuffer,
                    BufferLength,
                    pCompletionRoutine,
                    pCompletionContext
                    );
    }

    return status;
}
    



//
// Private Functions
//

/***************************************************************************++

Routine Description:

    Handler for disconnect requests.

Arguments:

    pTdiEventContext - Supplies the context associated with the address
        object. This should be a PUL_ENDPOINT.

    ConnectionContext - Supplies the context associated with the
        connection object. This should be a PUC_CONNECTION.

    DisconnectDataLength - Optionally supplies the length of any
        disconnect data associated with the disconnect request.

    pDisconnectData - Optionally supplies a pointer to any disconnect
        data associated with the disconnect request.

    DisconnectInformationLength - Optionally supplies the length of any
        disconnect information associated with the disconnect request.

    pDisconnectInformation - Optionally supplies a pointer to any
        disconnect information associated with the disconnect request.

    DisconnectFlags - Supplies the disconnect flags. This will be zero
        or more TDI_DISCONNECT_* flags.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcpTdiDisconnectHandler(
    IN PVOID              pTdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN LONG               DisconnectDataLength,
    IN PVOID              pDisconnectData,
    IN LONG               DisconnectInformationLength,
    IN PVOID              pDisconnectInformation,
    IN ULONG              DisconnectFlags
    )
{
    PUC_CLIENT_CONNECTION pConnection;
    PUC_TDI_OBJECTS       pTdiObjects;
    NTSTATUS              status = STATUS_SUCCESS;
    KIRQL                 OldIrql;


    UNREFERENCED_PARAMETER(pDisconnectInformation);
    UNREFERENCED_PARAMETER(DisconnectInformationLength);
    UNREFERENCED_PARAMETER(pDisconnectData);
    UNREFERENCED_PARAMETER(DisconnectDataLength);
    UNREFERENCED_PARAMETER(pTdiEventContext);

    UL_ENTER_DRIVER("UcpTdiDisconnectHandler", NULL);
     
    pTdiObjects = (PUC_TDI_OBJECTS) ConnectionContext;

    pConnection = pTdiObjects->pConnection;

    if(pConnection == NULL)
    {
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    ASSERT( UC_IS_VALID_CLIENT_CONNECTION(pConnection) );

    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

    //
    // Update the connection state based on the type of disconnect.
    //

    if(DisconnectFlags & TDI_DISCONNECT_ABORT)
    {
        pConnection->Flags |= CLIENT_CONN_FLAG_ABORT_RECEIVED;

        UC_WRITE_TRACE_LOG(
            g_pUcTraceLog,
            UC_ACTION_CONNECTION_TDI_DISCONNECT,
            pConnection,
            UlongToPtr((ULONG)STATUS_CONNECTION_ABORTED),
            UlongToPtr(pConnection->ConnectionState),
            UlongToPtr(pConnection->Flags)
            );

        switch(pConnection->ConnectionState)
        {
            case UcConnectStateConnectReady:
            case UcConnectStateDisconnectComplete:
            case UcConnectStatePerformingSslHandshake:
            case UcConnectStateConnectComplete:
            case UcConnectStateProxySslConnectComplete:
            case UcConnectStateProxySslConnect:

                // Received an abort when we were connected or have completed
                // our half close, proceed to cleanup. Cleanup can be done
                // only at passive, so we start the worker.

                pConnection->ConnectionStatus = STATUS_CONNECTION_ABORTED;
                pConnection->ConnectionState = UcConnectStateConnectCleanup;

                UC_WRITE_TRACE_LOG(
                    g_pUcTraceLog,
                    UC_ACTION_CONNECTION_CLEANUP,
                    pConnection,
                    UlongToPtr((ULONG)pConnection->ConnectionStatus),
                    UlongToPtr(pConnection->ConnectionState),
                    UlongToPtr(pConnection->Flags)
                    );

                UcKickOffConnectionStateMachine(
                    pConnection, 
                    OldIrql, 
                    UcConnectionWorkItem
                    );

                break;


            case  UcConnectStateDisconnectPending:

                // We got a RST when we had a pending disconnect. Let's flag
                // the connection so that we complete the cleanup when our
                // Disconnect Completes.

                pConnection->ConnectionStatus = STATUS_CONNECTION_ABORTED;

                UlReleaseSpinLock(&pConnection->SpinLock,OldIrql);

                break;

            case UcConnectStateDisconnectIndicatedPending:

                // When we get a disconnect indication, we issue one ourselves.
                // Therefore, there is no need for us to do anything with this
                // abort. When our pending disconnect compeltes, we'll 
                // cleanup anyway.

                pConnection->ConnectionStatus = STATUS_CONNECTION_ABORTED;

                UlReleaseSpinLock(&pConnection->SpinLock,OldIrql);

                break;


            default:
                //
                // We don't have to do anything here.
                //

                UlReleaseSpinLock(&pConnection->SpinLock,OldIrql);

                break;
        }
    }
    else
    {
        pConnection->Flags |= CLIENT_CONN_FLAG_DISCONNECT_RECEIVED;

        UC_WRITE_TRACE_LOG(
            g_pUcTraceLog,
            UC_ACTION_CONNECTION_TDI_DISCONNECT,
            pConnection,
            UlongToPtr((ULONG)STATUS_CONNECTION_DISCONNECTED),
            UlongToPtr(pConnection->ConnectionState),
            UlongToPtr(pConnection->Flags)
            );

        switch(pConnection->ConnectionState)
        {
            case UcConnectStateConnectReady:

                pConnection->ConnectionStatus = STATUS_CONNECTION_DISCONNECTED;

                if(pConnection->FilterInfo.pFilterChannel)
                {
                    //
                    // When we receive a graceful close, it means that the 
                    // server has finished sending data on this connection 
                    // & has initiated a half close. However, some of this 
                    // received data might be stuck in the filter. 
                    //
                    // Therefore, we have to wait till the filter calls us back
                    // in the receive handler before we cleanup this 
                    // connection. Hence we will send the disconnect 
                    // indication via the filter.
                    //
                    // This allows the filter routine to call us back 
                    // (via HttpCloseFilter, which will result in a call to 
                    // UcpCloseRawConnection) after it has indicated all the 
                    // data.
                    // 
                    // Since we are at DPC, we cannot issue this from here. 
                    // We'll fire the connection worker to achieve this. 
                    //

                    pConnection->ConnectionState = 
                        UcConnectStateIssueFilterDisconnect;

                    UcKickOffConnectionStateMachine(
                        pConnection, 
                        OldIrql, 
                        UcConnectionWorkItem
                        );

                }
                else
                {
                    pConnection->ConnectionState = 
                        UcConnectStateDisconnectIndicatedPending;
    
                    UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
    
                    UcpCloseRawConnection( pConnection,
                                           FALSE,
                                           NULL,
                                           NULL
                                           );
                }

                break;

            case UcConnectStateConnectComplete:
            case UcConnectStatePerformingSslHandshake:
            case UcConnectStateProxySslConnectComplete:
            case UcConnectStateProxySslConnect:
    
                // We were waiting for the server cert to be negotiated, but
                // we got called in the disconnect handler. We'll treat this
                // as a normal Disconnect.

                pConnection->ConnectionStatus = STATUS_CONNECTION_DISCONNECTED;
                pConnection->ConnectionState = 
                    UcConnectStateDisconnectIndicatedPending;

                UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

                UcpCloseRawConnection( pConnection,
                                       FALSE,
                                       NULL,
                                       NULL
                                       );
                break;

            case UcConnectStateDisconnectComplete:

                //
                // If we receive a graceful close in this state, we still
                // need to bounce this via the filter, since we need to
                // synchronize this close with the already indicated data.
                // (see description above). However, when the filter calls
                // us back, we must proceed directly to clean the 
                // connection.
                //

                if(pConnection->FilterInfo.pFilterChannel &&
                   !(pConnection->Flags & CLIENT_CONN_FLAG_FILTER_CLOSED))
                {
                    //
                    // Flag it so that we will directly cleanup when we get
                    // called back by the filter.
                    //

                    pConnection->Flags |= CLIENT_CONN_FLAG_FILTER_CLEANUP;

                    pConnection->ConnectionState = 
                        UcConnectStateIssueFilterDisconnect;
    
                }
                else
                {

                    pConnection->ConnectionState = UcConnectStateConnectCleanup;

                    UC_WRITE_TRACE_LOG(
                        g_pUcTraceLog,
                        UC_ACTION_CONNECTION_CLEANUP,
                        pConnection,
                        UlongToPtr((ULONG)pConnection->ConnectionStatus),
                        UlongToPtr(pConnection->ConnectionState),
                        UlongToPtr(pConnection->Flags)
                        );
                }
    
                UcKickOffConnectionStateMachine(
                    pConnection, 
                    OldIrql, 
                    UcConnectionWorkItem
                    );

                break;
                
            case UcConnectStateDisconnectPending:
        
                // We have received a disconnect when we have sent ours,
                // which is not yet complete. Flag the connection so that
                // we do the cleanup when the disconnect is complete.

    
                UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

                break;

            default:

                UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

                break;

        }
    }

end:

    UL_LEAVE_DRIVER("UcpTdiDisconnectHandler");

    return status;
}

/***************************************************************************++

Routine Description:

    Closes a previously open connection.

Arguments:

    pConnection- Supplies the connection object

    AbortiveDisconnect - TRUE if the connection has to be abortively 
                         disconnected, FALSE if it has to be gracefully 
                         disconnected.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcpCloseRawConnection(
    IN  PVOID                  pConn,
    IN  BOOLEAN                AbortiveDisconnect,
    IN  PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN  PVOID                  pCompletionContext
   )
{
    PUC_CLIENT_CONNECTION  pConnection = (PUC_CLIENT_CONNECTION) pConn;

    ASSERT( UC_IS_VALID_CLIENT_CONNECTION(pConnection) );

    UC_WRITE_TRACE_LOG(
        g_pUcTraceLog,
        UC_ACTION_CONNECTION_RAW_CLOSE,
        pConnection,
        UlongToPtr(AbortiveDisconnect),
        UlongToPtr(pConnection->Flags),
        UlongToPtr(pConnection->ConnectionState)
        );

    //
    // This is the final close handler for all types of connections
    // filter, non filter. We should not go through this path twice
    //

    if(AbortiveDisconnect)
    {
        ASSERT(pConnection->ConnectionState == UcConnectStateAbortPending);

        return UcpBeginAbort(
                    pConnection,
                    pCompletionRoutine,
                    pCompletionContext
                    );
    }
    else
    {
        ASSERT(pConnection->ConnectionState == 
                    UcConnectStateDisconnectIndicatedPending ||
               pConnection->ConnectionState == 
                    UcConnectStateDisconnectPending);

        return UcpBeginDisconnect(
                    pConnection,
                    pCompletionRoutine,
                    pCompletionContext
                    );
    }
}

/***************************************************************************++

Routine Description:

    Closes a previously open connection; called from the filter code. The 
    server code just uses UlpCloseRawConnection for this routine. 
    
    We need a seperate routine because we want to conditionally call
    UcpCloseRawConnection based on some state. 

Arguments:

    pConnection- Supplies the connection object

    AbortiveDisconnect - TRUE if the connection has to be abortively 
                         disconnected, FALSE if it has to be gracefully 
                         disconnected.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcCloseRawFilterConnection(
    IN  PVOID                  pConn,
    IN  BOOLEAN                AbortiveDisconnect,
    IN  PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN  PVOID                  pCompletionContext
   )
{
    KIRQL                  OldIrql;
    PUC_CLIENT_CONNECTION  pConnection = (PUC_CLIENT_CONNECTION) pConn;

    ASSERT( UC_IS_VALID_CLIENT_CONNECTION(pConnection) );

    UC_WRITE_TRACE_LOG(
        g_pUcTraceLog,
        UC_ACTION_CONNECTION_RAW_FILTER_CLOSE,
        pConnection,
        UlongToPtr(AbortiveDisconnect),
        UlongToPtr(pConnection->Flags),
        UlongToPtr(pConnection->ConnectionState)
        );


    if(AbortiveDisconnect)
    {
        //
        // This will do some state checks & land up calling 
        // UcpCloseRawConnection. In order to modularize the code, we just 
        // call UcCloseConnection.
        //

        return UcCloseConnection(pConnection,
                                 AbortiveDisconnect,
                                 pCompletionRoutine,
                                 pCompletionContext,
                                 STATUS_CONNECTION_ABORTED
                                 );
    }

    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

    pConnection->Flags |= CLIENT_CONN_FLAG_FILTER_CLOSED;

    if(pConnection->ConnectionState == UcConnectStateDisconnectPending ||
       pConnection->ConnectionState == UcConnectStatePerformingSslHandshake ||
       pConnection->ConnectionState == UcConnectStateIssueFilterDisconnect ||
       pConnection->ConnectionState == UcConnectStateDisconnectIndicatedPending)
    {
        pConnection->ConnectionState = UcConnectStateDisconnectPending;

        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

        //
        // We've routed the disconnect via the filter. We can just proceed
        // to close the raw connection.
        //
    
        return UcpCloseRawConnection(
                        pConnection,
                        AbortiveDisconnect,
                        pCompletionRoutine,
                        pCompletionContext
                        );
    }
    else
    {

        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
    
        return UlInvokeCompletionRoutine(
                        STATUS_SUCCESS,
                        0,
                        pCompletionRoutine,
                        pCompletionContext
                        );
    }
    
}

/***************************************************************************++

Routine Description:

    The filter calls us back in this routine after it's processed the incoming
    disconnet indication.

Arguments:

    pConnection - Supplies a pointer to a connection

--***************************************************************************/
VOID
UcDisconnectRawFilterConnection(
    IN PVOID pConnectionContext
    )
{
    KIRQL                 OldIrql;
    PUC_CLIENT_CONNECTION pConnection;

    pConnection = (PUC_CLIENT_CONNECTION)pConnectionContext;

    //
    // Sanity check.
    //

    ASSERT(UC_IS_VALID_CLIENT_CONNECTION(pConnection));

    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

    UC_WRITE_TRACE_LOG(
        g_pUcTraceLog,
        UC_ACTION_CONNECTION_RAW_FILTER_DISCONNECT,
        pConnection,
        UlongToPtr(pConnection->Flags),
        UlongToPtr(pConnection->ConnectionState),
        0
        );

    if(pConnection->ConnectionState == UcConnectStateDisconnectIndicatedPending)
    {
        if(pConnection->Flags & CLIENT_CONN_FLAG_FILTER_CLEANUP)
        {
            pConnection->ConnectionState = UcConnectStateConnectCleanup;
    
            UcKickOffConnectionStateMachine(
                pConnection, 
                OldIrql, 
                UcConnectionWorkItem
                );
        }
        else
        {
            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
    
            UcpCloseRawConnection(
                    pConnection,
                    FALSE, // Abortive Disconnect
                    NULL,
                    NULL
                    );
        }
    }
    else
    {
        // Sometimes, the wierd filter calls us more than once for the 
        // same connection.

        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
    }
    
}   // UcDisconnectRawFilterConnection
    
/*********************************************************************++

Routine Description:

    Sends a block of data on the specified connection.

Arguments:

    pConnection - Supplies a pointer to a connection as previously
        indicated to the PUL_CONNECTION_REQUEST handler.

    pMdlChain - Supplies a pointer to a MDL chain describing the
        data buffers to send.

    Length - Supplies the length of the data referenced by the MDL
        chain.

    pIrpContext - used to indicate completion to the caller.

    InitiateDisconnect - Supplies TRUE if a graceful disconnect should
        be initiated immediately after initiating the send (i.e. before
        the send actually completes).

--*********************************************************************/
NTSTATUS
UcpSendRawData(
    IN PVOID                 pConnectionContext,
    IN PMDL                  pMdlChain,
    IN ULONG                 Length,
    IN PUL_IRP_CONTEXT       pIrpContext,
    IN BOOLEAN               InitiateDisconnect
    )
{
    PUC_CLIENT_CONNECTION pConnection;
    NTSTATUS              status;
    PIRP                  pIrp;
    BOOLEAN               OwnIrpContext = TRUE;

    UNREFERENCED_PARAMETER(InitiateDisconnect);

    pConnection = (PUC_CLIENT_CONNECTION) pConnectionContext;
    pIrp        = pIrpContext->pOwnIrp;

    ASSERT( UC_IS_VALID_CLIENT_CONNECTION(pConnection) );

    //
    // See if there is space in the IRP to handle this request.
    //

    if(pIrp == NULL || 
       pIrp->CurrentLocation - 
       pConnection->pTdiObjects->ConnectionObject.pDeviceObject->StackSize < 1)
    {
        pIrp = 
          UlAllocateIrp(
            pConnection->pTdiObjects->ConnectionObject.pDeviceObject->StackSize,
            FALSE
            );

        if(!pIrp)
        {
            status = STATUS_INSUFFICIENT_RESOURCES;

            goto fatal;
        }

        OwnIrpContext = FALSE;
    }


    ASSERT( pIrp );

    //
    // The connection is already referenced for us while the request is
    // on a queue, so we don't need to do it again.

    pIrp->RequestorMode = KernelMode;
    // pIrp->Tail.Overlay.Thread = PsGetCurrentThread();
    // pIrp->Tail.Overlay.OriginalFileObject = pTdiObject->pFileObject;

    TdiBuildSend(
        pIrp,
        pConnection->pTdiObjects->ConnectionObject.pDeviceObject,
        pConnection->pTdiObjects->ConnectionObject.pFileObject, 
        &UcpRestartSendData,
        pIrpContext,
        pMdlChain,
        0,
        Length
        );

    WRITE_REF_TRACE_LOG(
         g_pMdlTraceLog,
         REF_ACTION_SEND_MDL,
         PtrToLong(pMdlChain->Next),     // bugbug64
         pMdlChain,
         __FILE__,
         __LINE__
         );


    //
    // Submit the IRP.
    // UC_BUGBUG (PERF) UL does this thing called fast send, check later.
    //

    UlCallDriver(
                pConnection->pTdiObjects->ConnectionObject.pDeviceObject,
                pIrp
                );
    
    return STATUS_PENDING;

fatal:

    ASSERT(!NT_SUCCESS(status));

    if(pIrp != NULL && OwnIrpContext == FALSE)
    {
        UlFreeIrp(pIrp);
    }

    UC_CLOSE_CONNECTION(pConnection, TRUE, status);

    return status;
}

/***************************************************************************++

Routine Description:

    Receives data from the specified connection. This function is
    typically used after a receive indication handler has failed to
    consume all of the indicated data.

Arguments:

    pConnection - Supplies a pointer to a connection as previously
        indicated to the PUL_CONNECTION_REQUEST handler.

    pBuffer - Supplies a pointer to the target buffer for the received
        data.

    BufferLength - Supplies the length of pBuffer.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the listening endpoint is fully closed.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcpReceiveRawData(
    IN PVOID                  pConnectionContext,
    IN PVOID                  pBuffer,
    IN ULONG                  BufferLength,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID                  pCompletionContext
    )
{
    NTSTATUS              Status;
    PUX_TDI_OBJECT        pTdiObject;
    PUL_IRP_CONTEXT       pIrpContext;
    PIRP                  pIrp;
    PMDL                  pMdl;
    PUC_CLIENT_CONNECTION pConnection;

    pConnection = (PUC_CLIENT_CONNECTION) pConnectionContext;

    ASSERT(UC_IS_VALID_CLIENT_CONNECTION(pConnection));

    pTdiObject = &pConnection->pTdiObjects->ConnectionObject;
    ASSERT( IS_VALID_TDI_OBJECT( pTdiObject ) );

    ASSERT( pCompletionRoutine != NULL );

    //
    // Setup locals so we know how to cleanup on failure.
    //

    pIrpContext = NULL;
    pIrp = NULL;
    pMdl = NULL;

    //
    // Create & initialize a receive IRP.
    //

    pIrp = UlAllocateIrp(
                pTdiObject->pDeviceObject->StackSize,   // StackSize
                FALSE                                   // ChargeQuota
                );

    if (pIrp != NULL)
    {
        //
        // Snag an IRP context.
        //

        pIrpContext = UlPplAllocateIrpContext();

        if (pIrpContext != NULL)
        {
            ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );

            pIrpContext->pConnectionContext = (PVOID)pConnection;
            pIrpContext->pCompletionRoutine = pCompletionRoutine;
            pIrpContext->pCompletionContext = pCompletionContext;
            pIrpContext->OwnIrpContext      = FALSE;

            //
            // Create an MDL describing the client's buffer.
            //

            pMdl = UlAllocateMdl(
                        pBuffer,                // VirtualAddress
                        BufferLength,           // Length
                        FALSE,                  // SecondaryBuffer
                        FALSE,                  // ChargeQuota
                        NULL                    // Irp
                        );

            if (pMdl != NULL)
            {
                //
                // Adjust the MDL for our non-paged buffer.
                //

                MmBuildMdlForNonPagedPool( pMdl );

                //
                // Reference the connection, finish building the IRP.
                //

                REFERENCE_CLIENT_CONNECTION( pConnection );

                TdiBuildReceive(
                    pIrp,                       // Irp
                    pTdiObject->pDeviceObject,  // DeviceObject
                    pTdiObject->pFileObject,    // FileObject
                    &UcpRestartClientReceive,   // CompletionRoutine
                    pIrpContext,                // CompletionContext
                    pMdl,                       // Mdl
                    TDI_RECEIVE_NORMAL,         // Flags
                    BufferLength                // Length
                    );

                //
                // Let the transport do the rest.
                //

                UlCallDriver( pTdiObject->pDeviceObject, pIrp );
                return STATUS_PENDING;
            }
        }
    }

    //
    // We only make it this point if we hit an allocation failure.
    //

    if (pMdl != NULL)
    {
        UlFreeMdl( pMdl );
    }

    if (pIrpContext != NULL)
    {
        UlPplFreeIrpContext( pIrpContext );
    }

    if (pIrp != NULL)
    {
        UlFreeIrp( pIrp );
    }

    Status = UlInvokeCompletionRoutine(
                    STATUS_INSUFFICIENT_RESOURCES,
                    0,
                    pCompletionRoutine,
                    pCompletionContext
                    );

    return Status;

}   // UcpReceiveRawData

/***************************************************************************++

Routine Description:

    Handler for normal receive data.

Arguments:

    pTdiEventContext - Supplies the context associated with the address
        object. This should be a PUL_ENDPOINT.

    ConnectionContext - Supplies the context associated with the
        connection object. This should be a PUC_CONNECTION.

    ReceiveFlags - Supplies the receive flags. This will be zero or more
        TDI_RECEIVE_* flags.

    BytesIndicated - Supplies the number of bytes indicated in pTsdu.

    BytesAvailable - Supplies the number of bytes available in this
        TSDU.

    pBytesTaken - Receives the number of bytes consumed by this handler.

    pTsdu - Supplies a pointer to the indicated data.

    pIrp - Receives an IRP if the handler needs more data than indicated.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcpTdiReceiveHandler(
    IN  PVOID              pTdiEventContext,
    IN  CONNECTION_CONTEXT ConnectionContext,
    IN  ULONG              ReceiveFlags,
    IN  ULONG              BytesIndicated,
    IN  ULONG              BytesAvailable,
    OUT ULONG             *pBytesTaken,
    IN  PVOID              pTsdu,
    OUT PIRP              *pIrp
    )
{
    NTSTATUS                     status;
    PUC_TDI_OBJECTS              pTdiObjects;
    PUC_CLIENT_CONNECTION        pConnection;
    PUX_TDI_OBJECT               pTdiObject;
    KIRQL                        OldIrql;

    UNREFERENCED_PARAMETER(ReceiveFlags);
    UNREFERENCED_PARAMETER(pTdiEventContext);

    UL_ENTER_DRIVER("UcpTdiReceiveHandler", NULL);

    //
    // Sanity check.
    //

    pTdiObjects = (PUC_TDI_OBJECTS) ConnectionContext;

    pConnection = pTdiObjects->pConnection;
    ASSERT( UC_IS_VALID_CLIENT_CONNECTION( pConnection ) );

    pTdiObject = &pConnection->pTdiObjects->ConnectionObject;

    ASSERT( IS_VALID_TDI_OBJECT( pTdiObject ) );

    //
    // Clear the bytes taken output var
    //

    *pBytesTaken = 0;

    if(pConnection->FilterInfo.pFilterChannel)
    {
        if(pConnection->ConnectionState == 
                UcConnectStateConnectReady ||
           pConnection->ConnectionState == 
                UcConnectStatePerformingSslHandshake
           )
        {
            //
            // Needs to go through a filter.
            //
    
            status = UlFilterReceiveHandler(
                            &pConnection->FilterInfo,
                            pTsdu,
                            BytesIndicated,
                            BytesAvailable - BytesIndicated,
                            pBytesTaken
                            );
        }
        else
        {
            // We have not delivered the connection to the filter as yet.
            // Let's first do that with the state transistion & then pass the
            // data on.
        
            UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

            switch(pConnection->ConnectionState)
            {
                case UcConnectStateConnectComplete:
                {
                    ULONG TakenLength;
    
                    pConnection->ConnectionState = 
                        UcConnectStatePerformingSslHandshake;
        
                    UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
        
                    UlDeliverConnectionToFilter(
                            &pConnection->FilterInfo,
                            NULL,
                            0,
                            &TakenLength
                            );
        
                    ASSERT(TakenLength == 0);

                    status = UlFilterReceiveHandler(
                                    &pConnection->FilterInfo,
                                    pTsdu,
                                    BytesIndicated,
                                    BytesAvailable - BytesIndicated,
                                    pBytesTaken
                                    );
                }

                break;

                case UcConnectStateProxySslConnect:
                    UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
                    goto handle_response;
                    break;

                default:
                    UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
                    status = UlFilterReceiveHandler(
                                    &pConnection->FilterInfo,
                                    pTsdu,
                                    BytesIndicated,
                                    BytesAvailable - BytesIndicated,
                                    pBytesTaken
                                    );
                    break;
            }
        }
    
        ASSERT( *pBytesTaken <= BytesIndicated);
        ASSERT( status != STATUS_MORE_PROCESSING_REQUIRED);
    }
    else
    {
handle_response:
        if(BytesAvailable > BytesIndicated)
        {
            status = STATUS_MORE_PROCESSING_REQUIRED;
        }
        else
        {
            //
            // otherwise, give the client a crack at the data.
            //

            status = UcHandleResponse(
                                NULL,
                                pConnection,
                                pTsdu,
                                BytesIndicated,
                                0,
                                pBytesTaken
                                );
    
            ASSERT( status != STATUS_MORE_PROCESSING_REQUIRED);
        }
    }

    if (status == STATUS_SUCCESS)
    {
        //
        // done.
        //
    }
    else  if (status == STATUS_MORE_PROCESSING_REQUIRED)
    {
        //
        // The client consumed part of the indicated data.
        //
        // A subsequent receive indication will be made to the client when
        // additional data is available. This subsequent indication will
        // include the unconsumed data from the current indication plus
        // any additional data received.
        //
        // We need to allocate a receive buffer so we can pass an IRP back
        // to the transport.
        //

        status = UcpBuildTdiReceiveBuffer(pTdiObject, 
                                          pConnection, 
                                          pIrp
                                          );

        if(status == STATUS_MORE_PROCESSING_REQUIRED)
        {
            //
            // Make the next stack location current. Normally, UlCallDriver
            // would do this for us, but since we're bypassing UlCallDriver,
            // we must do it ourselves.
            //

            IoSetNextIrpStackLocation( *pIrp );

        }
        else
        {
            goto fatal;
        }
    }
    else
    {
fatal:
        //
        // If we made it this far, then we've hit a fatal condition. Either the
        // client returned a status code other than STATUS_SUCCESS or
        // STATUS_MORE_PROCESSING_REQUIRED, or we failed to allocation the
        // receive IRP to pass back to the transport. In either case, we need
        // to abort the connection.
        //

        UC_CLOSE_CONNECTION(pConnection, TRUE, status);
    }

    UL_LEAVE_DRIVER("UcpTdiReceiveHandler");

    return status;

}   // UcpTdiReceiveHandler


/***************************************************************************++

Routine Description:

    Handler for expedited receive data.

Arguments:

    pTdiEventContext - Supplies the context associated with the address
        object. This should be a PUL_ENDPOINT.
    
    ConnectionContext - Supplies the context associated with the
        connection object. This should be a PUL_CONNECTION.
    
    ReceiveFlags - Supplies the receive flags. This will be zero or more
        TDI_RECEIVE_* flags.
    
    BytesIndiated - Supplies the number of bytes indicated in pTsdu.

    BytesAvailable - Supplies the number of bytes available in this
        TSDU.
    
    pBytesTaken - Receives the number of bytes consumed by this handler.
    
    pTsdu - Supplies a pointer to the indicated data.
    
    pIrp - Receives an IRP if the handler needs more data than indicated.
    
    Return Value:

NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcpReceiveExpeditedHandler(
    IN PVOID pTdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *pBytesTaken,
    IN PVOID pTsdu,
    OUT PIRP *pIrp
    )
{
    PUC_CLIENT_CONNECTION pConnection;

    UNREFERENCED_PARAMETER(pIrp);
    UNREFERENCED_PARAMETER(pTsdu);
    UNREFERENCED_PARAMETER(BytesIndicated);
    UNREFERENCED_PARAMETER(ReceiveFlags);
    UNREFERENCED_PARAMETER(pTdiEventContext);

    UL_ENTER_DRIVER("UcpReceiveExpeditedHandler", NULL);
    
    pConnection = (PUC_CLIENT_CONNECTION)ConnectionContext;
    
    ASSERT( UC_IS_VALID_CLIENT_CONNECTION(pConnection) );
    
    //
    // We don't support expedited data, so just consume it all.
    //
    *pBytesTaken = BytesAvailable;
    
    UL_LEAVE_DRIVER("UcpReceiveExpeditedHandler");
    
    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    Completion handler for send IRPs.

Arguments:

    pDeviceObject - Supplies the device object for the IRP being
        completed.
    
    pIrp - Supplies the IRP being completed.
    
    pContext - Supplies the context associated with this request.
        This is actually a PUL_IRP_CONTEXT.
    
Return Value:
    
    NTSTATUS - STATUS_SUCCESS if IO should continue processing this
        IRP, STATUS_MORE_PROCESSING_REQUIRED if IO should stop processing
        this IRP.

--***************************************************************************/
NTSTATUS
UcpRestartSendData(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp,
    IN PVOID          pContext
    )
{
    PUC_CLIENT_CONNECTION  pConnection;
    PUL_IRP_CONTEXT        pIrpContext;
    BOOLEAN                OwnIrpContext;
   
    UNREFERENCED_PARAMETER(pDeviceObject);
    
    //
    // Sanity check.
    //
    
    pIrpContext = (PUL_IRP_CONTEXT) pContext;
    ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );
    ASSERT( pIrpContext->pCompletionRoutine != NULL );
    
    pConnection = (PUC_CLIENT_CONNECTION) pIrpContext->pConnectionContext;
    
    ASSERT( UC_IS_VALID_CLIENT_CONNECTION( pConnection ) );
    
    OwnIrpContext = (BOOLEAN)(pIrpContext->pOwnIrp == NULL);
    
    //
    // Tell the client that the send is complete.
    //
    
    (pIrpContext->pCompletionRoutine)(
        pIrpContext->pCompletionContext,
        pIrp->IoStatus.Status,
        pIrp->IoStatus.Information
        );
    
    //
    // Free the context & the IRP since we're done with them, then 
    // tell IO to stop processing the IRP.
    //
    
    UlPplFreeIrpContext( pIrpContext );

    if(OwnIrpContext)
    {
        UlFreeIrp( pIrp );
    }

    return STATUS_MORE_PROCESSING_REQUIRED;

}   // UcpRestartSendData


/***************************************************************************++

Routine Description:

    Initiates a graceful disconnect on the specified connection.

Arguments:

    pConnection - Supplies the connection to disconnect.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the connection is disconnected.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

    CleaningUp - TRUE if we're cleaning up the connection.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcpBeginDisconnect(
    IN PUC_CLIENT_CONNECTION pConnection,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    )
{
    PIRP                pIrp;
    PUL_IRP_CONTEXT     pIrpContext;
    
    //
    // Sanity check.
    //

    ASSERT( UC_IS_VALID_CLIENT_CONNECTION( pConnection ) );

    UC_WRITE_TRACE_LOG(
        g_pUcTraceLog,
        UC_ACTION_CONNECTION_BEGIN_DISCONNECT,
        pConnection,
        0,
        NULL,
        0
        );

    pIrpContext = &pConnection->pTdiObjects->IrpContext;

    ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );

    pIrpContext->pConnectionContext = (PVOID)pConnection;
    pIrpContext->pCompletionRoutine = pCompletionRoutine;
    pIrpContext->pCompletionContext = pCompletionContext;
    pIrpContext->OwnIrpContext      = TRUE;

    pIrp = pConnection->pTdiObjects->pIrp;

    UxInitializeDisconnectIrp(
        pIrp,
        &pConnection->pTdiObjects->ConnectionObject,
        TDI_DISCONNECT_RELEASE,
        &UcpRestartDisconnect,
        pIrpContext
        );

    //
    // Add a reference to the connection, then call the driver to initiate
    // the disconnect.
    //

    REFERENCE_CLIENT_CONNECTION( pConnection );

    UlCallDriver( 
          pConnection->pTdiObjects->ConnectionObject.pDeviceObject,
          pIrp
          );

    return STATUS_PENDING;

}   // BeginDisconnect

/***************************************************************************++

Routine Description:

    Completion handler for graceful disconnect IRPs.

Arguments:

    pDeviceObject - Supplies the device object for the IRP being
        completed.

    pIrp - Supplies the IRP being completed.

    pContext - Supplies the context associated with this request.
        This is actually a PUL_IRP_CONTEXT.

Return Value:

    NTSTATUS - STATUS_SUCCESS if IO should continue processing this
        IRP, STATUS_MORE_PROCESSING_REQUIRED if IO should stop processing
        this IRP.

--***************************************************************************/
NTSTATUS
UcpRestartDisconnect(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    )
{
    PUL_IRP_CONTEXT        pIrpContext;
    PUC_CLIENT_CONNECTION  pConnection;
    KIRQL                  OldIrql;
    NTSTATUS               Status = STATUS_MORE_PROCESSING_REQUIRED;

    NTSTATUS               IrpStatus;
    ULONG_PTR              IrpInformation;
    PUL_COMPLETION_ROUTINE pCompletionRoutine;
    PVOID                  pCompletionContext;

    UNREFERENCED_PARAMETER(pDeviceObject);

    //
    // Sanity check.
    //

    pIrpContext = (PUL_IRP_CONTEXT) pContext;
    ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );

    pConnection = (PUC_CLIENT_CONNECTION) pIrpContext->pConnectionContext;
    ASSERT( UC_IS_VALID_CLIENT_CONNECTION( pConnection ) );

    UC_WRITE_TRACE_LOG(
        g_pUcTraceLog,
        UC_ACTION_CONNECTION_RESTART_DISCONNECT,
        pConnection,
        0,
        NULL,
        0
        );

    //
    // Remember the completion routine, completion context, Irp status,
    // Irp information fields before calling the connection state machine.
    // This is done because the connection state machine might change/free
    // them.
    //

    pCompletionRoutine = pIrpContext->pCompletionRoutine;
    pCompletionContext = pIrpContext->pCompletionContext;
    IrpStatus          = pIrp->IoStatus.Status;
    IrpInformation     = pIrp->IoStatus.Information;

    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

    pConnection->Flags |= CLIENT_CONN_FLAG_DISCONNECT_COMPLETE;

    if(pConnection->Flags & CLIENT_CONN_FLAG_ABORT_RECEIVED)
    {
        pConnection->ConnectionState  = UcConnectStateConnectCleanup;

        UC_WRITE_TRACE_LOG(
            g_pUcTraceLog,
            UC_ACTION_CONNECTION_CLEANUP,
            pConnection,
            UlongToPtr((ULONG)pConnection->ConnectionStatus),
            UlongToPtr(pConnection->ConnectionState),
            UlongToPtr(pConnection->Flags)
            );


        UcKickOffConnectionStateMachine(
            pConnection, 
            OldIrql, 
            UcConnectionWorkItem
            );
    }
    else if(pConnection->Flags & CLIENT_CONN_FLAG_ABORT_PENDING)
    {
        pConnection->ConnectionState = UcConnectStateAbortPending;

        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

        UcpBeginAbort(pConnection,
                      pIrpContext->pCompletionRoutine,
                      pIrpContext->pCompletionContext
                      );

        //
        // Don't complete the user's completion routine below, as it will
        // be handled when the Abort completes.
        //

        DEREFERENCE_CLIENT_CONNECTION( pConnection );

        return Status;

    }
    else if(pConnection->Flags & CLIENT_CONN_FLAG_DISCONNECT_RECEIVED ||
            pConnection->ConnectionState == 
                UcConnectStateDisconnectIndicatedPending)
    {
        pConnection->ConnectionState = UcConnectStateConnectCleanup;
        UC_WRITE_TRACE_LOG(
            g_pUcTraceLog,
            UC_ACTION_CONNECTION_CLEANUP,
            pConnection,
            UlongToPtr((ULONG)pConnection->ConnectionStatus),
            UlongToPtr(pConnection->ConnectionState),
            UlongToPtr(pConnection->Flags)
            );


        UcKickOffConnectionStateMachine(
            pConnection, 
            OldIrql, 
            UcConnectionWorkItem
            );
    }
    else
    {
        pConnection->ConnectionState = UcConnectStateDisconnectComplete;

        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
    }

#if 0
    if(!newFlags.DisconnectIndicated && !newFlags.AbortIndicated)
    {
        //
        // Only try to drain if it is not already aborted or disconnect
        // indication is not already happened.
        //

        if (pConnection->FilterInfo.pFilterChannel)
        {
            //
            // Put a reference on filter connection until the drain
            // is done.
            //
            REFERENCE_FILTER_CONNECTION(&pConnection->FilterInfo);

            UL_QUEUE_WORK_ITEM(
                    &pConnection->FilterInfo.WorkItem,
                    &UlFilterDrainIndicatedData
                    );
        }
    }
#endif

    //
    // Invoke the user's completion routine.
    //

    if (pCompletionRoutine)
    {
        pCompletionRoutine(pCompletionContext, IrpStatus, IrpInformation);
    }

    //
    // The connection was referenced in BeginDisconnect function.
    // Deference it.
    //

    DEREFERENCE_CLIENT_CONNECTION( pConnection );

    return Status;

}   // UcpRestartDisconnect

/***************************************************************************++

Routine Description:

    Initiates an abortive disconnect on the specified connection.

Arguments:

    pConnection - Supplies the connection to disconnect.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcpBeginAbort(
    IN PUC_CLIENT_CONNECTION pConnection,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    )
{
    PIRP                pIrp;
    PUL_IRP_CONTEXT     pIrpContext;

    ASSERT( UC_IS_VALID_CLIENT_CONNECTION(pConnection) );

    UC_WRITE_TRACE_LOG(
        g_pUcTraceLog,
        UC_ACTION_CONNECTION_BEGIN_ABORT,
        pConnection,
        0,
        NULL,
        0
        );

    pIrpContext = &pConnection->pTdiObjects->IrpContext;

    ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );

    pIrpContext->pConnectionContext = (PVOID)pConnection;
    pIrpContext->pCompletionRoutine = pCompletionRoutine;
    pIrpContext->pCompletionContext = pCompletionContext;
    pIrpContext->OwnIrpContext      = TRUE;

    pIrp = pConnection->pTdiObjects->pIrp;

    UxInitializeDisconnectIrp(
        pIrp,
        &pConnection->pTdiObjects->ConnectionObject,
        TDI_DISCONNECT_ABORT,
        &UcpRestartAbort,
        pIrpContext
        );

    //
    // Add a reference to the connection, then call the driver to initialize 
    // the disconnect.
    //

    REFERENCE_CLIENT_CONNECTION(pConnection);

    UlCallDriver( 
          pConnection->pTdiObjects->ConnectionObject.pDeviceObject,
          pIrp
          );

    return STATUS_PENDING;
}

/***************************************************************************++

Routine Description:

    Completion handler for abortive disconnect IRPs.

Arguments:

    pDeviceObject - Supplies the device object for the IRP being
        completed.

    pIrp - Supplies the IRP being completed.

    pContext - Supplies the context associated with this request.
        This is actually a PUL_IRP_CONTEXT.

Return Value:

    NTSTATUS - STATUS_SUCCESS if IO should continue processing this
        IRP, STATUS_MORE_PROCESSING_REQUIRED if IO should stop processing
        this IRP.

--***************************************************************************/
NTSTATUS
UcpRestartAbort(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp,
    IN PVOID          pContext
    )
{
    PUL_IRP_CONTEXT       pIrpContext;
    PUC_CLIENT_CONNECTION pConnection;
    KIRQL                 OldIrql;

    PUL_COMPLETION_ROUTINE pCompletionRoutine;
    PVOID                  pCompletionContext;
    NTSTATUS               IrpStatus;
    ULONG_PTR              IrpInformation;

    UNREFERENCED_PARAMETER(pDeviceObject);

    //
    // Sanity check.
    //

    pIrpContext = (PUL_IRP_CONTEXT)pContext;
    ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );

    pConnection = (PUC_CLIENT_CONNECTION)pIrpContext->pConnectionContext;
    ASSERT( UC_IS_VALID_CLIENT_CONNECTION( pConnection ) );

    UC_WRITE_TRACE_LOG(
        g_pUcTraceLog,
        UC_ACTION_CONNECTION_RESTART_ABORT,
        pConnection,
        0,
        0,
        0
        );

    //
    // Remember the completion routine, completion context, Irp status,
    // Irp information fields before calling the connection state machine.
    // This is done because the connection state machine might change/free
    // them.
    //

    pCompletionRoutine = pIrpContext->pCompletionRoutine;
    pCompletionContext = pIrpContext->pCompletionContext;
    IrpStatus          = pIrp->IoStatus.Status;
    IrpInformation     = pIrp->IoStatus.Information;

    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

    pConnection->Flags |= CLIENT_CONN_FLAG_ABORT_COMPLETE;

    pConnection->ConnectionState = UcConnectStateConnectCleanup;

    UC_WRITE_TRACE_LOG(
        g_pUcTraceLog,
        UC_ACTION_CONNECTION_CLEANUP,
        pConnection,
        UlongToPtr((ULONG)pConnection->ConnectionStatus),
        UlongToPtr(pConnection->ConnectionState),
        UlongToPtr(pConnection->Flags)
        );

    UcKickOffConnectionStateMachine(
        pConnection,
        OldIrql,
        UcConnectionWorkItem
        );

    //
    // Invoke the user's completion routine.
    //

    if (pCompletionRoutine)
    {
        pCompletionRoutine(pCompletionContext, IrpStatus, IrpInformation);
    }

    //
    // The connection was referenced in BeginAbort.  Dereference it.
    //

    DEREFERENCE_CLIENT_CONNECTION( pConnection );

    return STATUS_MORE_PROCESSING_REQUIRED;

}   // UcpRestartAbort


/***************************************************************************++

Routine Description:

    Completion handler for receive IRPs passed back to the transport from
    our receive indication handler.

Arguments:

    pDeviceObject - Supplies the device object for the IRP being
        completed.

    pIrp - Supplies the IRP being completed.

    pContext - Supplies the context associated with this request.
        This is actually a PUL_RECEIVE_BUFFER.

Return Value:

    NTSTATUS - STATUS_SUCCESS if IO should continue processing this
        IRP, STATUS_MORE_PROCESSING_REQUIRED if IO should stop processing
        this IRP.

--***************************************************************************/
NTSTATUS
UcpRestartReceive(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    )
{
    NTSTATUS              status;
    PUL_RECEIVE_BUFFER    pBuffer;
    PUC_CLIENT_CONNECTION pConnection;
    PUX_TDI_OBJECT        pTdiObject;
    ULONG                 bytesTaken;
    ULONG                 bytesRemaining;

    UNREFERENCED_PARAMETER(pDeviceObject);

    //
    // Sanity check.
    //

    pBuffer = (PUL_RECEIVE_BUFFER)pContext;
    ASSERT( IS_VALID_RECEIVE_BUFFER( pBuffer ) );

    pConnection = (PUC_CLIENT_CONNECTION) pBuffer->pConnectionContext;
    ASSERT( UC_IS_VALID_CLIENT_CONNECTION( pConnection ) );

    pTdiObject = &pConnection->pTdiObjects->ConnectionObject;
    ASSERT( IS_VALID_TDI_OBJECT( pTdiObject ) );

    // The connection could be destroyed before we get a chance to
    // receive the completion for the receive IRP. In that case the
    // irp status won't be success but STATUS_CONNECTION_RESET or similar.
    // We should not attempt to pass this case to the client.
    //
    
    status = pBuffer->pIrp->IoStatus.Status;

    if(status != STATUS_SUCCESS)
    {
        // The HttpConnection has already been destroyed
        // or receive completion failed for some reason
        // no need to go to client
        
        goto end;
    }

    //
    // Fake a receive indication to the client.
    //

    pBuffer->UnreadDataLength += (ULONG)pBuffer->pIrp->IoStatus.Information;

    bytesTaken = 0;

    //
    // Pass the data on.
    //

    if (pConnection->FilterInfo.pFilterChannel)
    {
        //
        // Needs to go through a filter.
        //
        status = UlFilterReceiveHandler(
                        &pConnection->FilterInfo,
                        pBuffer->pDataArea,
                        pBuffer->UnreadDataLength,
                        0,
                        &bytesTaken
                        );

    }
    else
    {
        //
        // Go directly to client.
        //

        status = UcHandleResponse(
                        NULL,
                        pConnection,
                        pBuffer->pDataArea,
                        pBuffer->UnreadDataLength,
                        0,
                        &bytesTaken
                        );
    }

    ASSERT( bytesTaken <= pBuffer->UnreadDataLength );
    ASSERT(status != STATUS_MORE_PROCESSING_REQUIRED);

    //
    // Note that this basically duplicates the logic that's currently in
    // UcpTdiReceiveHandler.
    //

    if(status == STATUS_SUCCESS)
    {
        //
        // The client consumed part of the indicated data.
        //
        // We'll need to copy the untaken data forward within the receive
        // buffer, build an MDL describing the remaining part of the buffer,
        // then repost the receive IRP.
        //
    
        bytesRemaining = pBuffer->UnreadDataLength - bytesTaken;

        if(bytesRemaining != 0)
        {
            //
            // Do we have enough buffer space for more?
            //
        
            if (bytesRemaining < g_UlReceiveBufferSize)
            {
                //
                // Move the unread portion of the buffer to the beginning.
                //
        
                RtlMoveMemory(
                    pBuffer->pDataArea,
                    (PUCHAR)pBuffer->pDataArea + bytesTaken,
                    bytesRemaining
                    );
        
                pBuffer->UnreadDataLength = bytesRemaining;
        
                //
                // Build a partial mdl representing the remainder of the
                // buffer.
                //
        
                IoBuildPartialMdl(
                    pBuffer->pMdl,                              // SourceMdl
                    pBuffer->pPartialMdl,                       // TargetMdl
                    (PUCHAR)pBuffer->pDataArea + bytesRemaining,// VA
                    g_UlReceiveBufferSize - bytesRemaining      // Length
                    );
        
                //
                // Finish initializing the IRP.
                //
        
                TdiBuildReceive(
                    pBuffer->pIrp,                          // Irp
                    pTdiObject->pDeviceObject,              // DeviceObject
                    pTdiObject->pFileObject,                // FileObject
                    &UcpRestartReceive,                     // CompletionRoutine
                    pBuffer,                                // CompletionContext
                    pBuffer->pPartialMdl,                   // MdlAddress
                    TDI_RECEIVE_NORMAL,                     // Flags
                    g_UlReceiveBufferSize - bytesRemaining  // Length
                    );
        
                //
                // Call the driver.
                //
        
                UlCallDriver( 
                      pConnection->pTdiObjects->ConnectionObject.pDeviceObject,
                      pIrp
                      );
    
                //
                // Tell IO to stop processing this request.
                //
        
                return STATUS_MORE_PROCESSING_REQUIRED;
            }
            else
            {
                status = STATUS_BUFFER_OVERFLOW;
            }
        }
    }
    
end:
    if (status != STATUS_SUCCESS)
    {
        //
        // The client failed the indication. Abort the connection.
        //

        UC_CLOSE_CONNECTION(pConnection, TRUE, status);
    }

    if (pTdiObject->pDeviceObject->StackSize > DEFAULT_IRP_STACK_SIZE)
    {
        UlFreeReceiveBufferPool( pBuffer );
    }
    else
    {
        UlPplFreeReceiveBuffer( pBuffer );
    }

    //
    // Remove the connection we added in the receive indication handler,
    // free the receive buffer, then tell IO to stop processing the IRP.
    //

    DEREFERENCE_CLIENT_CONNECTION( pConnection );

    return STATUS_MORE_PROCESSING_REQUIRED;

}   // UcpRestartReceive


/***************************************************************************++

Routine Description:

    Completion handler for receive IRPs initiated from UcReceiveData().

Arguments:

    pDeviceObject - Supplies the device object for the IRP being
        completed.

    pIrp - Supplies the IRP being completed.

    pContext - Supplies the context associated with this request.
        This is actually a PUL_IRP_CONTEXT.

Return Value:

    NTSTATUS - STATUS_SUCCESS if IO should continue processing this
        IRP, STATUS_MORE_PROCESSING_REQUIRED if IO should stop processing
        this IRP.

--***************************************************************************/
NTSTATUS
UcpRestartClientReceive(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    )
{
    PUL_IRP_CONTEXT       pIrpContext;
    PUC_CLIENT_CONNECTION pConnection;

    UNREFERENCED_PARAMETER(pDeviceObject);

    //
    // Sanity check.
    //

    pIrpContext= (PUL_IRP_CONTEXT)pContext;
    ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );

    pConnection = (PUC_CLIENT_CONNECTION)pIrpContext->pConnectionContext;
    ASSERT( UC_IS_VALID_CLIENT_CONNECTION( pConnection ) );

    //
    // Invoke the client's completion handler.
    //

    (pIrpContext->pCompletionRoutine)(
        pIrpContext->pCompletionContext,
        pIrp->IoStatus.Status,
        pIrp->IoStatus.Information
        );

    //
    // Free the IRP context we allocated.
    //
    UlPplFreeIrpContext(pIrpContext);

    //
    // IO can't handle completing an IRP with a non-paged MDL attached
    // to it, so we'll free the MDL here.
    //

    ASSERT( pIrp->MdlAddress != NULL );
    UlFreeMdl( pIrp->MdlAddress );
    pIrp->MdlAddress = NULL;

    //
    // Remove the connection we added in UcReceiveData(), then tell IO to
    // continue processing this IRP.
    //

    DEREFERENCE_CLIENT_CONNECTION( pConnection );
    return STATUS_MORE_PROCESSING_REQUIRED;

}

/*********************************************************************++

Routine Description:

    This is our connection completion routine. It's called by an underlying
    transport when a connection request completes, either good or bad. We
    figure out what happened, free the IRP, and call upwards to notify
    the rest of the code.
        
Arguments:

    pDeviceObject           - The device object we called.
    pIrp                    - The IRP that is completing.
    Context                 - Our context value, really a pointer to an
                                HTTP client connection structure.
    
Return Value:

    STATUS_MORE_PROCESSING_REQUIRED so the I/O system doesn't do anything
    else.

--*********************************************************************/
NTSTATUS
UcpConnectComplete(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp,
    PVOID           Context
    )
{
    PUC_CLIENT_CONNECTION pConnection;
    NTSTATUS              Status;
    KIRQL                 OldIrql;

    UNREFERENCED_PARAMETER(pDeviceObject);

    pConnection = (PUC_CLIENT_CONNECTION)Context;


    Status = pIrp->IoStatus.Status;
    
    ASSERT( UC_IS_VALID_CLIENT_CONNECTION( pConnection ) );

    UcRestartClientConnect(pConnection, Status);

    //
    // We need to kick off the connection state machine.
    //

    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

    UcKickOffConnectionStateMachine(
        pConnection, 
        OldIrql, 
        UcConnectionWorkItem
        );

    //
    // Deref for the CONNECT
    //

    DEREFERENCE_CLIENT_CONNECTION( pConnection );

    return STATUS_MORE_PROCESSING_REQUIRED;
}

/***************************************************************************++

Routine Description:

    This function sets a new flag in the connection's flag set. The setting
    of the flag is synchronized such that only one flag is set at a time.

Arguments:

   ConnFlag - Supplies a pointer to the location which stores the current flag.

   NewFlag - Supplies a 32-bit value to be or-ed into the current flag set.

Return Value:

    The new set of connection flags after the update.

--***************************************************************************/
ULONG
UcSetFlag(
    IN OUT  PLONG ConnFlag,
    IN      LONG  NewFlag
    )
{
    LONG MynewFlags;
    LONG oldFlags;

    //
    // Sanity check.
    //

    do
    {
        //        
        // Capture the current value and initialize the new value.
        //

        oldFlags   = *ConnFlag;

        MynewFlags = (*ConnFlag) | NewFlag;

        if (InterlockedCompareExchange(
                ConnFlag,
                MynewFlags,
                oldFlags) == oldFlags)
        {
            break;
        }

    } while (TRUE);

    return MynewFlags;

}   // UcSetFlag

/***************************************************************************++

Routine Description:

    Build a receive buffer and IRP to TDI to get any pending data.

Arguments:

    pTdiObject - Supplies the TDI connection object to manipulate.

    pConnection - Supplies the UL_CONNECTION object.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcpBuildTdiReceiveBuffer(
    IN  PUX_TDI_OBJECT        pTdiObject,
    IN  PUC_CLIENT_CONNECTION pConnection,
    OUT PIRP                 *pIrp
    )
{
    PUL_RECEIVE_BUFFER  pBuffer;

    if (pTdiObject->pDeviceObject->StackSize > DEFAULT_IRP_STACK_SIZE)
    {
        pBuffer = UlAllocateReceiveBuffer(
                        pTdiObject->pDeviceObject->StackSize
                        );
    }
    else
    {
        pBuffer = UlPplAllocateReceiveBuffer();
    }

    if (pBuffer != NULL)
    {
        //
        // Finish initializing the buffer and the IRP.
        //

        REFERENCE_CLIENT_CONNECTION( pConnection );
        pBuffer->pConnectionContext = pConnection;
        pBuffer->UnreadDataLength = 0;

        TdiBuildReceive(
            pBuffer->pIrp,                  // Irp
            pTdiObject->pDeviceObject,      // DeviceObject
            pTdiObject->pFileObject,        // FileObject
            &UcpRestartReceive,             // CompletionRoutine
            pBuffer,                        // CompletionContext
            pBuffer->pMdl,                  // MdlAddress
            TDI_RECEIVE_NORMAL,             // Flags
            g_UlReceiveBufferSize           // Length
            );

        //
        // We must trace the IRP before we set the next stack
        // location so the trace code can pull goodies from the
        // IRP correctly.
        //

        TRACE_IRP( IRP_ACTION_CALL_DRIVER, pBuffer->pIrp );

        //
        // Pass the IRP back to the transport.
        //

        *pIrp = pBuffer->pIrp;

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    return STATUS_INSUFFICIENT_RESOURCES;
} // UcpBuildTdiReceiveBuffer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ucrcv.c ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    ucrcv.c

Abstract:

    Contains the code that parses incoming HTTP responses. We have
    to handle the following cases.

        - Pipelined responses (an indication has more than one response).
        - Batched TDI receives (response split across TDI indications).
        - App does not have sufficent buffer space to hold the parsed
          response.
        - Differnet types of encoding.
        - Efficient parsing.

    We try to minimize the number of buffer copies. In the best case,
    we parse directly into the app's buffer. The best case is achieved
    when the app has passed output buffer in the HttpSendRequest() call.

    
    Also contains all of the per-header handling code for received headers.

Author:

    Rajesh Sundaram (rajeshsu), 25th Aug 2000

Revision History:

--*/

#include "precomp.h"
#include "ucparse.h"


#ifdef ALLOC_PRAGMA

//
// None of these routines are PAGEABLE since we are parsing at DPC.
//

#pragma alloc_text( PAGEUC, UcpGetResponseBuffer)
#pragma alloc_text( PAGEUC, UcpMergeIndications)
#pragma alloc_text( PAGEUC, UcpParseHttpResponse)
#pragma alloc_text( PAGEUC, UcHandleResponse)
#pragma alloc_text( PAGEUC, UcpHandleConnectVerbFailure)
#pragma alloc_text( PAGEUC, UcpHandleParsedRequest)
#pragma alloc_text( PAGEUC, UcpCarveDataChunk)
#pragma alloc_text( PAGEUC, UcpCopyEntityToDataChunk )
#pragma alloc_text( PAGEUC, UcpReferenceForReceive  )
#pragma alloc_text( PAGEUC, UcpDereferenceForReceive  )
#pragma alloc_text( PAGEUC, UcpCopyHttpResponseHeaders )
#pragma alloc_text( PAGEUC, UcpExpandResponseBuffer )
#pragma alloc_text( PAGEUC, UcpCompleteReceiveResponseIrp )

#endif


        
//
// Private Functions.
//

/***************************************************************************++

Routine Description:

    This routine carves a HTTP_DATA_CHUNK in the HTTP_RESPONSE structure and
    adjusts all the pointers in the UC_HTTP_REQUEST structure.


Arguments:

    pResponse       - The HTTP_RESPONSE
    pRequest        - The internal HTTP request.
    pIndication     - pointer to buffer
    BytesIndicated  - buffer length to be written.
    AlignLength     - The align'd length for pointer manipulations.

Return Value:

    STATUS_SUCCESS  - Successfully copied.
    STATUS_INTEGER_OVERFLOW - Entity chunk overflow

--***************************************************************************/
NTSTATUS
_inline
UcpCarveDataChunk(
    IN PHTTP_RESPONSE   pResponse,
    IN PUC_HTTP_REQUEST pRequest,
    IN PUCHAR           pIndication,
    IN ULONG            BytesIndicated,
    IN ULONG            AlignLength
    )
{
    USHORT  j;
    PUCHAR pBuffer;

    ASSERT(AlignLength == ALIGN_UP(BytesIndicated, PVOID));

    j = pResponse->EntityChunkCount;

    if((pResponse->EntityChunkCount + 1) < j)
    {
        return STATUS_INTEGER_OVERFLOW;
    }

    pResponse->EntityChunkCount++;

    pBuffer = pRequest->CurrentBuffer.pOutBufferTail - AlignLength;

    pResponse->pEntityChunks[j].FromMemory.BufferLength = BytesIndicated;

    pResponse->pEntityChunks[j].FromMemory.pBuffer = pBuffer;

    RtlCopyMemory(
        pBuffer,
        pIndication,
        BytesIndicated
        );

    pRequest->CurrentBuffer.pOutBufferHead += sizeof(HTTP_DATA_CHUNK);

    pRequest->CurrentBuffer.pOutBufferTail -= AlignLength;

    pRequest->CurrentBuffer.BytesAvailable -=  (sizeof(HTTP_DATA_CHUNK) +
                                                AlignLength);

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    This routine carves a HTTP_DATA_CHUNK in the HTTP_RESPONSE structure and
    adjusts all the pointers in the UC_HTTP_REQUEST structure.

Arguments:

    pRequest        - The internal HTTP request.
    BytesToTake     - Bytes we want to consume.
    BytesIndicated  - Total no of bytes indicated by TDI.
    pIndication     - pointer to buffer
    pBytesTaken     - Bytes we consumed.

Return Value:

    UcDataChunkCopyAll    : We copied of BytesToTake into a HTTP_DATA_CHUNK
    UcDataChunkCopyPartial: We copied some of BytesToTake into HTTP_DATA_CHUNK
                            
--***************************************************************************/
UC_DATACHUNK_RETURN
UcpCopyEntityToDataChunk(
    IN  PHTTP_RESPONSE   pResponse,
    IN  PUC_HTTP_REQUEST pRequest,
    IN  ULONG            BytesToTake,
    IN  ULONG            BytesIndicated,
    IN  PUCHAR           pIndication,
    OUT PULONG           pBytesTaken
    )
{
    ULONG    AlignLength;

    *pBytesTaken = 0;

    if(BytesToTake == 0)
    {
        // What's the point in creating a 0 length chunk?
        //
        return UcDataChunkCopyAll;
    }

    if(BytesToTake > BytesIndicated)
    {
        // We don't want to exceed the amount that is indicated by TDI.
        //
        BytesToTake = BytesIndicated;
    }

    AlignLength = ALIGN_UP(BytesToTake, PVOID);

    if(pRequest->CurrentBuffer.BytesAvailable >=
        AlignLength + sizeof(HTTP_DATA_CHUNK))
    {
        // There is enough out buffer space to consume the indicated data
        //
        if(UcpCarveDataChunk(
                pResponse,
                pRequest,
                pIndication,
                BytesToTake,
                AlignLength
                ) == STATUS_SUCCESS)
        {
            *pBytesTaken += BytesToTake;
    
            return UcDataChunkCopyAll;
        }
    }
    else if(pRequest->CurrentBuffer.BytesAvailable > sizeof(HTTP_DATA_CHUNK))
    {
        ULONG Size = pRequest->CurrentBuffer.BytesAvailable -
                        sizeof(HTTP_DATA_CHUNK);

        AlignLength = ALIGN_DOWN(Size, PVOID);

        if(0 != AlignLength)
        {
            if(UcpCarveDataChunk(pResponse,
                                 pRequest,
                                 pIndication,
                                 AlignLength,
                                 AlignLength
                                 ) == STATUS_SUCCESS)
            {
                *pBytesTaken += AlignLength;
            }
        }
    }

    return UcDataChunkCopyPartial;
}


/**************************************************************************++

Routine Description:

    This routine is called when we have a parsed response buffer that can be
    copied to a Receive Response IRP.

Arguments:

    pRequest - The Request
    OldIrql  - The IRQL at which the connection spin lock was acquired.

Return Value:

    None.

--**************************************************************************/
VOID
UcpCompleteReceiveResponseIrp(
    IN PUC_HTTP_REQUEST pRequest,
    IN KIRQL            OldIrql
    )
{
    NTSTATUS                  Status;
    PIRP                      pIrp;
    PIO_STACK_LOCATION        pIrpSp;
    ULONG                     OutBufferLen;
    ULONG                     BytesTaken;
    PUC_HTTP_RECEIVE_RESPONSE pHttpResponse;
    LIST_ENTRY                TmpIrpList;
    PLIST_ENTRY               pListEntry;
    PUC_RESPONSE_BUFFER       pTmpBuffer;


    //
    // Sanity check
    //
    ASSERT(UC_IS_VALID_HTTP_REQUEST(pRequest));
    ASSERT(UlDbgSpinLockOwned(&pRequest->pConnection->SpinLock));

    //
    // Initialize locals.
    //

    pIrp = NULL;
    pIrpSp = NULL;
    pHttpResponse = NULL;
    Status = STATUS_INVALID_PARAMETER;

    //
    // Initially no App's IRP to complete.
    //

    InitializeListHead(&TmpIrpList);

    //
    // If there is a Receive Response IRP waiting, try to complete it now.
    //

 Retry:
    if (!IsListEmpty(&pRequest->ReceiveResponseIrpList))
    {
        pListEntry = RemoveHeadList(&pRequest->ReceiveResponseIrpList);

        pHttpResponse = CONTAINING_RECORD(pListEntry,
                                          UC_HTTP_RECEIVE_RESPONSE,
                                          Linkage);

        if (UcRemoveRcvRespCancelRoutine(pHttpResponse))
        {
            //
            // This IRP has already got cancelled, let's move on
            //
            InitializeListHead(&pHttpResponse->Linkage);
            goto Retry;
        }

        pIrp         = pHttpResponse->pIrp;
        pIrpSp       = IoGetCurrentIrpStackLocation( pIrp );
        OutBufferLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

        //
        // Find parsed response buffers to copy to this IRP's buffer
        //

        Status = UcFindBuffersForReceiveResponseIrp(
                     pRequest,
                     OutBufferLen,
                     TRUE,
                     &pHttpResponse->ResponseBufferList,
                     &BytesTaken);

        switch(Status)
        {
        case STATUS_INVALID_PARAMETER:
        case STATUS_PENDING:
            //
            // There must be at least one buffer available for copying
            //
            ASSERT(FALSE);
            break;

        case STATUS_BUFFER_TOO_SMALL:
            //
            // This IRP is too small to hold the parsed response.
            //
            pIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;

            //
            // Note that since this is async completion, the IO mgr
            // will make the Information field available to the app.
            //
            pIrp->IoStatus.Information = BytesTaken;

            InsertTailList(&TmpIrpList, &pHttpResponse->Linkage);

            goto Retry;

        case STATUS_SUCCESS:
            //
            // We got buffers to copy...
            //
            break;

        default:
            ASSERT(FALSE);
            break;
        }
    }

    //
    // Do the dirty work outside the spinlock.
    //

    UlReleaseSpinLock(&pRequest->pConnection->SpinLock,  OldIrql);

    if (Status == STATUS_SUCCESS)
    {
        //
        // We found an IPR and parsed response buffers to copy to the IRP.
        // Copy the parsed response buffers and complete the IRP
        //
        BOOLEAN             bDone;

        //
        // Copy parsed response buffers to the IRP
        //

        Status = UcCopyResponseToIrp(pIrp, 
                                     &pHttpResponse->ResponseBufferList,
                                     &bDone,
                                     &BytesTaken);

        //
        // The request must not be done right now!
        //
        ASSERT(bDone == FALSE);

        pIrp->IoStatus.Status      = Status;
        pIrp->IoStatus.Information = BytesTaken;

        //
        // Queue the IRP for completion
        //
        InsertTailList(&TmpIrpList, &pHttpResponse->Linkage);

        //
        // Free parsed response buffers
        //
        while (!IsListEmpty(&pHttpResponse->ResponseBufferList))
        {
            pListEntry = RemoveHeadList(&pHttpResponse->ResponseBufferList);

            pTmpBuffer = CONTAINING_RECORD(pListEntry,
                                           UC_RESPONSE_BUFFER,
                                           Linkage);

            ASSERT(IS_VALID_UC_RESPONSE_BUFFER(pTmpBuffer));

            UL_FREE_POOL_WITH_QUOTA(pTmpBuffer,
                                    UC_RESPONSE_APP_BUFFER_POOL_TAG,
                                    NonPagedPool,
                                    pTmpBuffer->BytesAllocated,
                                    pRequest->pServerInfo->pProcess);
        }
    }

    //
    // Complete Receive Response IRP's
    //
    while(!IsListEmpty(&TmpIrpList))
    {
        pListEntry = RemoveHeadList(&TmpIrpList);

        pHttpResponse = CONTAINING_RECORD(pListEntry,
                                          UC_HTTP_RECEIVE_RESPONSE,
                                          Linkage);

        UlCompleteRequest(pHttpResponse->pIrp, IO_NETWORK_INCREMENT);

        UL_FREE_POOL_WITH_QUOTA(pHttpResponse,
                                UC_HTTP_RECEIVE_RESPONSE_POOL_TAG,
                                NonPagedPool,
                                sizeof(UC_HTTP_RECEIVE_RESPONSE),
                                pRequest->pServerInfo->pProcess);

        UC_DEREFERENCE_REQUEST(pRequest);
    }
}


/**************************************************************************++

Routine Description:

    This routine copies one response buffer to a new (must be bigger) 
    response buffer.

    We make sure that all response headers are stored in a single response
    buffer.  When a buffer is found to be too small to contain all the
    headers, a new bigger buffer is allocated.  This routine is then called
    to copy old buffer into the new buffer.  Bufer layout:

    HTTP_RESPONSE Reason  Unknown Header       Known Header  Unknown Header
         |        String      array               Values       Name/Values
         |          |           |                   |               |
         V          V           V                   V               V
    +---------------------------------------------------------------------+
    |           |        |             |\\\\\\\|            |             |
    +---------------------------------------------------------------------+
                                       ^       ^
                                       Head    Tail

Arguments:

    pNewResponse - New response buffer
    pOldResponse - Old response buffer
    ppBufferHead - Pointer to pointer to top of the free buffer space
    ppBufferTail - Pointer to pointer to bottom of the free buffer space

Return Value:

    None.

--**************************************************************************/
VOID
UcpCopyHttpResponseHeaders(
    PHTTP_RESPONSE pNewResponse,
    PHTTP_RESPONSE pOldResponse,
    PUCHAR        *ppBufferHead,
    PUCHAR        *ppBufferTail
    )
{
    USHORT i;
    PUCHAR pBufferHead, pBufferTail;

    //
    // Sanity check
    //
    ASSERT(pNewResponse);
    ASSERT(pOldResponse);
    ASSERT(ppBufferHead && *ppBufferHead);
    ASSERT(ppBufferTail && *ppBufferTail);

    //
    // Initialize locals
    //
    pBufferHead = *ppBufferHead;
    pBufferTail = *ppBufferTail;

    //
    // First, copy the HTTP_RESPONSE structure.
    //
    RtlCopyMemory(pNewResponse, pOldResponse, sizeof(HTTP_RESPONSE));

    //
    // Then, copy the Reason string, if any
    //
    if (pNewResponse->ReasonLength)
    {
        pNewResponse->pReason = (PCSTR)pBufferHead;

        RtlCopyMemory((PUCHAR)pNewResponse->pReason,
                      (PUCHAR)pOldResponse->pReason,
                      pNewResponse->ReasonLength);

        pBufferHead += pNewResponse->ReasonLength;
    }

    //
    // Copy unknown headers, if any
    //

    pBufferHead = ALIGN_UP_POINTER(pBufferHead, PVOID);

    pNewResponse->Headers.pUnknownHeaders = (PHTTP_UNKNOWN_HEADER)pBufferHead;

    if (pNewResponse->Headers.UnknownHeaderCount)
    {
        pBufferHead = (PUCHAR)((PHTTP_UNKNOWN_HEADER)pBufferHead +
                               pNewResponse->Headers.UnknownHeaderCount);

        for (i = 0; i < pNewResponse->Headers.UnknownHeaderCount; i++)
        {
            ASSERT(pOldResponse->Headers.pUnknownHeaders[i].pName);
            ASSERT(pOldResponse->Headers.pUnknownHeaders[i].NameLength);
            ASSERT(pOldResponse->Headers.pUnknownHeaders[i].pRawValue);
            ASSERT(pOldResponse->Headers.pUnknownHeaders[i].RawValueLength);

            //
            // Copy HTTP_UNKNOWN_HEADER structure
            //
            RtlCopyMemory(&pNewResponse->Headers.pUnknownHeaders[i],
                          &pOldResponse->Headers.pUnknownHeaders[i],
                          sizeof(HTTP_UNKNOWN_HEADER));

            //
            // Make space for unknown header name
            //
            pBufferTail -= pNewResponse->Headers.pUnknownHeaders[i].NameLength;

            pNewResponse->Headers.pUnknownHeaders[i].pName =(PCSTR)pBufferTail;

            //
            // Copy unknown header name
            //
            RtlCopyMemory(
                (PUCHAR)pNewResponse->Headers.pUnknownHeaders[i].pName,
                (PUCHAR)pOldResponse->Headers.pUnknownHeaders[i].pName,
                pNewResponse->Headers.pUnknownHeaders[i].NameLength);

            //
            // Make space for unknown header value
            //
            pBufferTail -=
                pNewResponse->Headers.pUnknownHeaders[i].RawValueLength;

            pNewResponse->Headers.pUnknownHeaders[i].pRawValue = 
                (PCSTR)pBufferTail;

            //
            // Copy unknow header value
            //
            RtlCopyMemory(
                (PUCHAR)pNewResponse->Headers.pUnknownHeaders[i].pRawValue,
                (PUCHAR)pOldResponse->Headers.pUnknownHeaders[i].pRawValue,
                pNewResponse->Headers.pUnknownHeaders[i].RawValueLength);
        }
    }

    //
    // Copy known headers.
    //

    for (i = 0; i < HttpHeaderResponseMaximum; i++)
    {
        if (pNewResponse->Headers.KnownHeaders[i].RawValueLength)
        {
            //
            // Make space for known header value
            //
            pBufferTail -=pNewResponse->Headers.KnownHeaders[i].RawValueLength;

            pNewResponse->Headers.KnownHeaders[i].pRawValue =
                (PCSTR)pBufferTail;

            //
            // Copy known header value
            //
            RtlCopyMemory(
                (PUCHAR)pNewResponse->Headers.KnownHeaders[i].pRawValue,
                (PUCHAR)pOldResponse->Headers.KnownHeaders[i].pRawValue,
                pNewResponse->Headers.KnownHeaders[i].RawValueLength);
        }
    }

    //
    // There should not be any entities
    //
    ASSERT(pNewResponse->EntityChunkCount == 0);
    ASSERT(pNewResponse->pEntityChunks == NULL);

    //
    // Return head and tail pointers
    //

    *ppBufferHead = pBufferHead;
    *ppBufferTail = pBufferTail;
}


/**************************************************************************++

Routine Description:

    This routine allocates a new UC_RESPONSE_BUFFER and copies the current
    UC_RESPONSE_BUFFER to this new buffer.  This routine is called when
    we run out of buffer space while parsing response headers.  Since all
    the headers must be present into a single buffer, a new buffer is 
    allocated.

Arguments:

    pRequest             - The Request
    BytesIndicated       - The number of bytes indicated by TDI.
    pResponseBufferFlags - Flags the new buffer must have.

Return Value:

    NTSTATUS

--**************************************************************************/
NTSTATUS
UcpExpandResponseBuffer(
    IN PUC_HTTP_REQUEST pRequest,
    IN ULONG            BytesIndicated,
    IN ULONG            ResponseBufferFlags
    )
{
    PUC_RESPONSE_BUFFER   pInternalBuffer;
    ULONG                 BytesToAllocate;
    ULONGLONG             TmpLength;
    PUCHAR                pBufferHead, pBufferTail;
    PUCHAR                pTmpHead, pTmpTail;
    PUC_CLIENT_CONNECTION pConnection;
    KIRQL                 OldIrql;
    PIRP                  pIrp;


    //
    // Client connection
    //
    pConnection = pRequest->pConnection;
    ASSERT(UC_IS_VALID_CLIENT_CONNECTION(pConnection));
   
    //
    // Allocate a new 2 times bigger buffer that can contain all
    // response headers. (hopefully!)
    //

    //
    // pRequest->CurrentBuffer.BytesAllocated contains the buffer length
    // in both case:  case 1, we're using App's buffer OR
    //                case 2, we're using Driver allocated buffer.
    //
    TmpLength = 2 * (pRequest->CurrentBuffer.BytesAllocated + BytesIndicated)
                + sizeof(UC_RESPONSE_BUFFER);

    //
    // Align up.  Is there ALIGN_UP for ULONGLONG?
    //
    TmpLength = (TmpLength+sizeof(PVOID)-1) & (~((ULONGLONG)sizeof(PVOID)-1));

    BytesToAllocate = (ULONG)TmpLength;

    //
    // Check for Arithmetic Overflow.
    //

    if (TmpLength == BytesToAllocate)
    {
        //
        // No arithmetic overflow.  Try allocating memory.
        //

        pInternalBuffer = (PUC_RESPONSE_BUFFER)
                          UL_ALLOCATE_POOL_WITH_QUOTA(
                              NonPagedPool,
                              BytesToAllocate,
                              UC_RESPONSE_APP_BUFFER_POOL_TAG,
                              pRequest->pServerInfo->pProcess);
    }
    else
    {
        //
        // There was an Overflow in the above computation of TmpLength.
        // We can't handle more than 4GB of headers.
        //
        pInternalBuffer = NULL;
    }

    if (pInternalBuffer == NULL)
    {
        //
        // Either there was an arithmetic overflow or memory allocation
        // failed.  In both cases, return error.
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize pInternalBuffer
    //

    RtlZeroMemory(pInternalBuffer, sizeof(UC_RESPONSE_BUFFER));
    pInternalBuffer->Signature = UC_RESPONSE_BUFFER_SIGNATURE;
    pInternalBuffer->BytesAllocated = BytesToAllocate;

    //
    // Header buffer is not mergeable with previous buffers.
    //
    pInternalBuffer->Flags  = ResponseBufferFlags;
    pInternalBuffer->Flags |= UC_RESPONSE_BUFFER_FLAG_NOT_MERGEABLE;

    //
    // Copy old HTTP_RESPONSE to new buffer's HTTP_RESPONSE.
    //

    pTmpHead = pBufferHead = (PUCHAR)(pInternalBuffer + 1);
    pTmpTail = pBufferTail = (PUCHAR)(pInternalBuffer) + BytesToAllocate;

    //
    // If we are using App's buffer, the InternalResponse must be used
    // while copying.  Otherwise we use the original buffer's Response
    // strucuture.  In any case, the CurrentBuffer.pResponse is already
    // init'ed to point to "the right" place.
    //
    ASSERT(pRequest->CurrentBuffer.pResponse != NULL);

    UcpCopyHttpResponseHeaders(&pInternalBuffer->HttpResponse,
                               pRequest->CurrentBuffer.pResponse,
                               &pBufferHead,
                               &pBufferTail);

    ASSERT(pTmpHead <= pBufferHead);
    ASSERT(pTmpTail >= pBufferTail);
    ASSERT(pBufferHead <= pBufferTail);

    //
    // Set up the current buffer structure...
    //

    //
    // BytesAllocated is sizeof(HTTP_RESPONSE) + Data buffer length
    // It is used to determine how much space is needed to copy
    // this parsed response buffer.
    //
    pRequest->CurrentBuffer.BytesAllocated = BytesToAllocate -
        (sizeof(UC_RESPONSE_BUFFER) - sizeof(HTTP_RESPONSE));

    //
    // Update bytes allocated
    //
    pRequest->CurrentBuffer.BytesAvailable =
            pRequest->CurrentBuffer.BytesAllocated - sizeof(HTTP_RESPONSE)
            - (ULONG)(pBufferHead - pTmpHead)
            - (ULONG)(pTmpTail - pBufferTail);

    pRequest->CurrentBuffer.pResponse = &pInternalBuffer->HttpResponse;

    pRequest->CurrentBuffer.pOutBufferHead = pBufferHead;
    pRequest->CurrentBuffer.pOutBufferTail = pBufferTail;

    if (pRequest->CurrentBuffer.pCurrentBuffer)
    {
        //
        // Old buffer was a driver allocated buffer.  Free it now.
        //

        PLIST_ENTRY         pEntry;
        PUC_RESPONSE_BUFFER pOldResponseBuffer;

        //
        // Remove old buffer and insert new one.
        //

        UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

        pOldResponseBuffer = pRequest->CurrentBuffer.pCurrentBuffer;

        pEntry = RemoveHeadList(&pRequest->pBufferList);

        ASSERT(pEntry == &pRequest->CurrentBuffer.pCurrentBuffer->Linkage);

        InsertHeadList(&pRequest->pBufferList, &pInternalBuffer->Linkage);

        pRequest->CurrentBuffer.pCurrentBuffer = pInternalBuffer;

        UlReleaseSpinLock(&pConnection->SpinLock,  OldIrql);

        UL_FREE_POOL_WITH_QUOTA(pOldResponseBuffer,
                                UC_RESPONSE_APP_BUFFER_POOL_TAG,
                                NonPagedPool,
                                pOldResponseBuffer->BytesAllocated,
                                pConnection->pServerInfo->pProcess);
    }
    else
    {
        //
        // App's buffer...complete App's IRP
        //

        UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

        //
        // Set the current buffer pointer.
        //

        pRequest->CurrentBuffer.pCurrentBuffer = pInternalBuffer;

        //
        // Insert the buffer in the list.
        //

        ASSERT(IsListEmpty(&pRequest->pBufferList));

        InsertHeadList(&pRequest->pBufferList, &pInternalBuffer->Linkage);

        //
        // Reference the request for the buffer just added.
        //

        UC_REFERENCE_REQUEST(pRequest);

        if(pRequest->CurrentBuffer.pResponse &&
           !((pRequest->ResponseStatusCode == 401 ||
              pRequest->ResponseStatusCode == 407) &&
              pRequest->Renegotiate == TRUE &&
              pRequest->DontFreeMdls == TRUE &&
              pRequest->RequestStatus == STATUS_SUCCESS
             )
           && pRequest->RequestState == UcRequestStateSendCompletePartialData
          )
        {
            //
            // Complete App's IRP with error
            //

            pIrp = UcPrepareRequestIrp(pRequest, STATUS_BUFFER_TOO_SMALL);

            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

            if(pIrp)
            {
                pIrp->IoStatus.Information = BytesToAllocate;
                UlCompleteRequest(pIrp, 0);
            }
        }
        else
        {
            UlReleaseSpinLock(&pConnection->SpinLock,  OldIrql);
        }
    }

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    This routine is used by the HTTP response parser to get buffer space to
    hold the parsed response.


Arguments:

    pRequest        - The internal HTTP request.
    BytesIndicated  - The number of bytes indicated by TDI. We will buffer for
                      at least this amount

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UcpGetResponseBuffer(
    IN PUC_HTTP_REQUEST pRequest,
    IN ULONG            BytesIndicated,
    IN ULONG            ResponseBufferFlags
    )
{
    PUC_RESPONSE_BUFFER   pInternalBuffer;
    PUC_CLIENT_CONNECTION pConnection = pRequest->pConnection;
    ULONG                 BytesToAllocate;
    ULONG                 AlignLength;
    KIRQL                 OldIrql;
    PIRP                  pIrp;


    //
    // All the headers must go into one buffer.  If the buffer ran out
    // of space when parsing headers, a buffer is allocated and old contents
    // are copied to the new buffer.  If the old buffer came from App, the
    // App's request is failed with STATUS_BUFFER_TOO_SMALL.
    //

    switch(pRequest->ParseState)
    {
    case UcParseStatusLineVersion:
    case UcParseStatusLineStatusCode:
        //
        // If we are allocating buffer in this state, then the buffers should
        // not be mergeable.
        //
        ResponseBufferFlags |= UC_RESPONSE_BUFFER_FLAG_NOT_MERGEABLE;
        break;

    case UcParseStatusLineReasonPhrase:
    case UcParseHeaders:
        //
        // If the app did not pass any buffers and this the first time
        // buffers are allocated for this response, goto the normal path.
        //
        if (pRequest->CurrentBuffer.BytesAllocated == 0)
        {
            break;
        }

        return UcpExpandResponseBuffer(pRequest,
                                       BytesIndicated,
                                       ResponseBufferFlags);

    default:
        break;
    }


    //
    // If we are in this routine, we have run out of buffer space. This
    // allows us to complete the app's IRP
    //

    if(!pRequest->CurrentBuffer.pCurrentBuffer)
    {

        if(pRequest->CurrentBuffer.pResponse &&
          !((pRequest->ResponseStatusCode == 401 ||
             pRequest->ResponseStatusCode == 407) &&
             pRequest->Renegotiate == TRUE &&
             pRequest->DontFreeMdls == TRUE &&
             pRequest->RequestStatus == STATUS_SUCCESS
            )
          )
        {
            pRequest->CurrentBuffer.pResponse->Flags |=
                    HTTP_RESPONSE_FLAG_MORE_DATA;

            UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

            pRequest->RequestIRPBytesWritten =
                    pRequest->CurrentBuffer.BytesAllocated -
                    pRequest->CurrentBuffer.BytesAvailable;

            if(pRequest->RequestState ==
                    UcRequestStateSendCompletePartialData)
            {
                //
                // We have been called in the send complete and we own
                // the  IRP completion.
                //
                pIrp = UcPrepareRequestIrp(pRequest, STATUS_SUCCESS);

                UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

                if(pIrp)
                {
                    UlCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
                }
            }
            else
            {
                UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
            }
        }
        else
        {
            // App did not post any buffers, this IRP should have been
            // completed by the SendComplete handler.
        }
    }
    else
    {
        UlAcquireSpinLock(&pRequest->pConnection->SpinLock, &OldIrql);

        pRequest->CurrentBuffer.pCurrentBuffer->Flags |=
            UC_RESPONSE_BUFFER_FLAG_READY;

        pRequest->CurrentBuffer.pCurrentBuffer->BytesWritten =
            pRequest->CurrentBuffer.BytesAllocated -
            pRequest->CurrentBuffer.BytesAvailable;

        pRequest->CurrentBuffer.pResponse->Flags |= 
            HTTP_RESPONSE_FLAG_MORE_DATA;

        //
        // Complete App's receive response Irp, if any.
        //
        UcpCompleteReceiveResponseIrp(pRequest, OldIrql);
    }

    //
    // UC_BUGBUG (PERF): want to use fixed size pools ?
    //

    //
    // TDI has indicated BytesIndicated bytes of data. We have to allocate
    // a buffer space for holding all of this data. Now, some of these might
    // be  unknown headers or entity bodies. Since we parse unknown headers
    // and entity bodies as variable length arrays, we need some array space.
    // Since we have not parsed these unknown headers or entity bodies as yet,
    // we have to make a guess on the count of these and hope that we allocate
    // sufficient space. If our guess does not work, we'll land up calling
    // this routine again.
    //

    AlignLength     = ALIGN_UP(BytesIndicated, PVOID);
    BytesToAllocate =  AlignLength +
                       sizeof(UC_RESPONSE_BUFFER) +
                       UC_RESPONSE_EXTRA_BUFFER;

    pInternalBuffer = (PUC_RESPONSE_BUFFER)
                            UL_ALLOCATE_POOL_WITH_QUOTA(
                                NonPagedPool,
                                BytesToAllocate,
                                UC_RESPONSE_APP_BUFFER_POOL_TAG,
                                pRequest->pServerInfo->pProcess
                                );

    if(!pInternalBuffer)
    {
        UlTrace(PARSER,
                ("[UcpGetResponseBuffer]: Could not allocate memory for "
                 "buffering \n"));

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pInternalBuffer, BytesToAllocate);

    //
    // Set up the internal request structure so that we have nice pointers.
    //

    pInternalBuffer->Signature = UC_RESPONSE_BUFFER_SIGNATURE;

    pInternalBuffer->BytesAllocated = BytesToAllocate;

    pInternalBuffer->Flags |= ResponseBufferFlags;

    pRequest->CurrentBuffer.BytesAllocated = AlignLength +
                                             UC_RESPONSE_EXTRA_BUFFER +
                                             sizeof(HTTP_RESPONSE);

    pRequest->CurrentBuffer.BytesAvailable =
            pRequest->CurrentBuffer.BytesAllocated - sizeof(HTTP_RESPONSE);

    pRequest->CurrentBuffer.pResponse = &pInternalBuffer->HttpResponse;

    pRequest->CurrentBuffer.pOutBufferHead  =
               (PUCHAR) ((PUCHAR)pInternalBuffer + sizeof(UC_RESPONSE_BUFFER));

    pRequest->CurrentBuffer.pOutBufferTail  =
                      pRequest->CurrentBuffer.pOutBufferHead +
                      AlignLength +
                      UC_RESPONSE_EXTRA_BUFFER;

    pRequest->CurrentBuffer.pCurrentBuffer  = pInternalBuffer;

    //
    // depending on where we are, setup the response pointers.
    //

    switch(pRequest->ParseState)
    {
        case UcParseEntityBody:
        case UcParseEntityBodyMultipartFinal:

            pRequest->CurrentBuffer.pResponse->pEntityChunks =
                (PHTTP_DATA_CHUNK)pRequest->CurrentBuffer.pOutBufferHead;
            break;

        case UcParseHeaders:
        case UcParseEntityBodyMultipartInit:
        case UcParseEntityBodyMultipartHeaders:
            pRequest->CurrentBuffer.pResponse->Headers.pUnknownHeaders =
                (PHTTP_UNKNOWN_HEADER) pRequest->CurrentBuffer.pOutBufferHead;
            break;
        default:
            break;
    }

    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

    InsertTailList(
            &pRequest->pBufferList,
            &pInternalBuffer->Linkage
            );

    UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);


    //
    // Take a ref on the request for this buffer
    //
    UC_REFERENCE_REQUEST(pRequest);

    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    This routine is used by the HTTP response parser to merge a TDI indication
    with a previously buffered one.

    There could be cases when a TDI indication does not carry the entire
    data required to parse the HTTP response. For e.g. if we were parsing
    headers and the TDI indication ended with "Accept-", we would not know
    which header to parse the indication to.

    In such cases, we buffer the un-parsed portion of the response (in this
    case it would be "Accept-"), and merge the subsequent indication from TDI
    with the buffered indication, and process it as one chunk.

    Now, in order to minimize the buffering overhead, we don't merge all of the
    new indication with the old one. We just assume that the data can be parsed
    using the next 256 bytes, and copy that amount into the prior indication.
    If this was not sufficient, we'll just copy more data.

    We'll then treat these as two (or one) seperate  indications.

Arguments:

    pConnection      - A pointer to UC_CLIENT_CONNECTION
    pIndication      - A pointer to the (new) TDI indication.
    BytesIndicated   - The number of bytes in the new indication.
    Indication       - An output array that carries the seperated indications
    IndicationLength - An output array that stores the length of the
                       indications.
    IndicationCount  - The # of seperated indications.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

VOID
UcpMergeIndications(
    IN  PUC_CLIENT_CONNECTION pConnection,
    IN  PUCHAR                pIndication,
    IN  ULONG                 BytesIndicated,
    OUT PUCHAR                Indication[2],
    OUT ULONG                 IndicationLength[2],
    OUT PULONG                IndicationCount
    )
{
    PUCHAR pOriginalIndication;
    ULONG  BytesAvailable;


    //
    // It's okay to chain this off the connection - this is not a per-request
    // thing.
    //

    if(pConnection->MergeIndication.pBuffer)
    {
        //
        // Yes - there was a portion of a prior indication that we did not
        // consume. We'll just assume that the next
        //

        pOriginalIndication = pConnection->MergeIndication.pBuffer +
            pConnection->MergeIndication.BytesWritten;

        BytesAvailable = pConnection->MergeIndication.BytesAllocated -
            pConnection->MergeIndication.BytesWritten;

        if(BytesIndicated <= BytesAvailable)
        {
            // the second indication completly fits into our merge buffer.
            // we'll just merge all of this and treat as one indication.

            RtlCopyMemory(pOriginalIndication,
                          pIndication,
                          BytesIndicated);

            pConnection->MergeIndication.BytesWritten += BytesIndicated;

            *IndicationCount    = 1;
            Indication[0]       = pConnection->MergeIndication.pBuffer;
            IndicationLength[0] = pConnection->MergeIndication.BytesWritten;
        }
        else
        {
            // Fill up the Merge buffer completly.

            RtlCopyMemory(pOriginalIndication,
                          pIndication,
                          BytesAvailable);

            pConnection->MergeIndication.BytesWritten += BytesAvailable;

            pIndication    += BytesAvailable;
            BytesIndicated -= BytesAvailable;

            //
            // We need to process 2 buffers.
            //

            *IndicationCount      = 2;

            Indication[0]         = pConnection->MergeIndication.pBuffer;
            IndicationLength[0]   = pConnection->MergeIndication.BytesWritten;

            Indication[1]         = pIndication;
            IndicationLength[1]   = BytesIndicated;
        }
    }
    else
    {
        //
        // No original buffer, let's just process the new indication.
        //

        *IndicationCount         = 1;
        Indication[0]            = pIndication;
        IndicationLength[0]      = BytesIndicated;

    }
}

/***************************************************************************++

Routine Description:

  This is the core HTTP response protocol parsing engine. It takes a stream of
  bytes and parses them as a HTTP response.


Arguments:

    pRequest         - The Internal HTTP request structure.
    pIndicatedBuffer - The current Indication
    BytesIndicated   - Size of the current Indication.
    BytesTaken       - An output parameter that indicates the # of bytes that
                       got consumed by the parser. Note that even when this
                       routine returns an error code, it could have consumed
                       some amount of data.

                       For e.g. if we got something like
                       "HTTP/1.1 200 OK .... CRLF Accept-", we'll consume all
                       data till the "Accept-".

Return Value:

    NTSTATUS - Completion status.

    STATUS_MORE_PROCESSING_REQUIRED  : The Indication was not sufficient to
                                       parse the response. This happens when
                                       the indication ends inbetween a header
                                       boundary. In such cases, the caller has
                                       to buffer the data and call this routine
                                       when it gets more data.

    STATUS_INSUFFICIENT_RESOURCES    : The parser ran out of output buffer.
                                       When this happens, the parser has to get
                                       more buffer and resume the parsing.

    STATUS_SUCCESS                   : This request got parsed successfully.

    STATUS_INVALID_NETWORK_RESPONSE  : Illegal HTTP response.


--***************************************************************************/
NTSTATUS
UcpParseHttpResponse(
                     PUC_HTTP_REQUEST pRequest,
                     PUCHAR           pIndicatedBuffer,
                     ULONG            BytesIndicated,
                     PULONG           BytesTaken
                    )
{
    PUCHAR              pStartReason, pStart;
    PHTTP_RESPONSE      pResponse;
    ULONG               i;
    NTSTATUS            Status;
    ULONG               ResponseRangeLength, HeaderBytesTaken;
    PCHAR               pEnd;
    ULONG               AlignLength;
    BOOLEAN             bFoundLWS, bEnd;
    BOOLEAN             bIgnoreParsing;
    PUCHAR              pFoldingBuffer = NULL;
    ULONG               EntityBytesTaken;
    UC_DATACHUNK_RETURN DataChunkStatus;
    USHORT              OldMinorVersion;


    HeaderBytesTaken = 0;

    *BytesTaken = 0;
    pResponse   = pRequest->CurrentBuffer.pResponse;

    bIgnoreParsing = (BOOLEAN)(pRequest->RequestFlags.ProxySslConnect != 0);

    if(!pResponse)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    while(BytesIndicated > 0)
    {
        switch(pRequest->ParseState)
        {
        case UcParseStatusLineVersion:

            //
            // Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
            //
            
            pStart = pIndicatedBuffer;

            //
            // Skip LWS
            //

            while(BytesIndicated && IS_HTTP_LWS(*pIndicatedBuffer))
            {
                pIndicatedBuffer ++;
                BytesIndicated --;
            }
            
            //
            // Do we have enough buffer to strcmp the version ?
            //
            
            if(BytesIndicated < MIN_VERSION_SIZE)
            {
                return STATUS_MORE_PROCESSING_REQUIRED;
            }

            ASSERT(VERSION_OTHER_SIZE <= MIN_VERSION_SIZE);


            if(strncmp((const char *)pIndicatedBuffer,
                       HTTP_VERSION_OTHER,
                       VERSION_OTHER_SIZE) == 0)
            {
                pIndicatedBuffer    = pIndicatedBuffer + VERSION_OTHER_SIZE;
                BytesIndicated     -= VERSION_OTHER_SIZE;

                //
                // Parse the Major Version number. We'll only accept a major
                // version of 1.
                //
                pResponse->Version.MajorVersion = 0;

                while(BytesIndicated > 0  && IS_HTTP_DIGIT(*pIndicatedBuffer))
                {
                    pResponse->Version.MajorVersion =
                            (pResponse->Version.MajorVersion * 10) +
                            *pIndicatedBuffer - '0';
                    pIndicatedBuffer ++;
                    BytesIndicated --;

                    // 
                    // Check for overflow.
                    //
                    if(pResponse->Version.MajorVersion > 1)
                    {
                        UlTrace(PARSER,
                                ("[UcpParseHttpResponse]:Invalid HTTP "
                                 "version \n"));
                        return STATUS_INVALID_NETWORK_RESPONSE;
                    }
                }

                if(0 == BytesIndicated)
                {
                    return STATUS_MORE_PROCESSING_REQUIRED;
                }

                if(*pIndicatedBuffer != '.' ||
                   pResponse->Version.MajorVersion != 1)
                {
                    //
                    // INVALID HTTP version!!
                    //

                    UlTrace(PARSER,
                            ("[UcpParseHttpResponse]:Invalid HTTP version \n"));
                    return STATUS_INVALID_NETWORK_RESPONSE;
                }

                //
                // Ignore the '.'
                //
                pIndicatedBuffer ++;
                BytesIndicated --;

                //
                // Parse the Minor Version number. We'll accept anything for
                // the minor version number as long as it's a USHORT (to be 
                // protocol compliant)
                //

                pResponse->Version.MinorVersion = 0;
                OldMinorVersion                 = 0;

                while(BytesIndicated > 0  && IS_HTTP_DIGIT(*pIndicatedBuffer))
                {
                    OldMinorVersion = pResponse->Version.MinorVersion;

                    pResponse->Version.MinorVersion =
                        (pResponse->Version.MinorVersion * 10) +
                        *pIndicatedBuffer - '0';

                    pIndicatedBuffer ++;
                    BytesIndicated --;

                    // 
                    // Check for overflow.
                    //
                    if(pResponse->Version.MinorVersion < OldMinorVersion)
                    {
                        UlTrace(PARSER,
                                ("[UcpParseHttpResponse]:Invalid HTTP "
                                 "version \n"));

                        return STATUS_INVALID_NETWORK_RESPONSE;
                    }
                }

                if(0 == BytesIndicated)
                {
                    return STATUS_MORE_PROCESSING_REQUIRED;
                }


                ASSERT(pResponse->Version.MajorVersion == 1 );

                if(
                    pResponse->Version.MinorVersion == 0
                  )
                {
                    // By default, we have to close the connection for 1.0
                    // requests.

                    pRequest->ResponseVersion11       = FALSE;
                    pRequest->ResponseConnectionClose = TRUE;
                }
                else
                {
                    PUC_CLIENT_CONNECTION pConnection;

                    pRequest->ResponseVersion11       = TRUE;
                    pRequest->ResponseConnectionClose = FALSE;

                    //
                    // Also update the version number on the COMMON
                    // SERVINFO, so that future requests to this server use
                    // the proper version.
                    //
                    pConnection = pRequest->pConnection;
                    pConnection->pServerInfo->pNextHopInfo->Version11 = TRUE;
                }

                pRequest->ParseState = UcParseStatusLineStatusCode;

                *BytesTaken += DIFF(pIndicatedBuffer - pStart);
            }
            else
            {
                UlTrace(PARSER,
                        ("[UcpParseHttpResponse]: Invalid HTTP version \n"));
                return STATUS_INVALID_NETWORK_RESPONSE;
            }

            //
            // FALLTHROUGH
            //

        case UcParseStatusLineStatusCode:

            ASSERT(pRequest->ParseState == UcParseStatusLineStatusCode);

            pStart = pIndicatedBuffer;

            //
            // skip LWS
            //

            bFoundLWS = FALSE;
            while(BytesIndicated && IS_HTTP_LWS(*pIndicatedBuffer))
            {
                bFoundLWS = TRUE;
                pIndicatedBuffer ++;
                BytesIndicated --;
            }


            // 
            // NOTE: Order of the following two if conditions is important
            // We don't want to fail this response if we got here when 
            // BytesIndicated was 0 in the first place.
            //

            if(BytesIndicated < STATUS_CODE_LENGTH)
            {
                return STATUS_MORE_PROCESSING_REQUIRED;
            }

            if(!bFoundLWS)
            {
                UlTrace(PARSER,
                        ("[UcpParseHttpResponse]: No LWS between reason & "
                         "status code \n"));

                return STATUS_INVALID_NETWORK_RESPONSE;
            }

            pResponse->StatusCode = 0;

            for(i = 0; i < STATUS_CODE_LENGTH; i++)
            {
                //
                // The status code has to be a 3 digit string
                //

                if(!IS_HTTP_DIGIT(*pIndicatedBuffer))
                {
                    UlTrace(PARSER,
                           ("[UcpParseHttpResponse]: Invalid status code \n"));
                    return STATUS_INVALID_NETWORK_RESPONSE;
                }

                pResponse->StatusCode = (pResponse->StatusCode * 10) +
                    *pIndicatedBuffer - '0';
                pIndicatedBuffer ++;
                BytesIndicated --;
            }

            pRequest->ResponseStatusCode = pResponse->StatusCode;

            pRequest->ParseState = UcParseStatusLineReasonPhrase;

            if(pRequest->ResponseStatusCode >= 100 &&
               pRequest->ResponseStatusCode <= 199 &&
               pRequest->pServerInfo->IgnoreContinues)
            {
                bIgnoreParsing = TRUE;
            }

            *BytesTaken += DIFF(pIndicatedBuffer - pStart);

            //
            // FALLTHROUGH
            //

        case UcParseStatusLineReasonPhrase:

            ASSERT(pRequest->ParseState == UcParseStatusLineReasonPhrase);

            pStart = pIndicatedBuffer;

            // 
            // Make sure we have bytes to look for a LWS. Make sure that it is 
            // indeed a LWS.
            // 

            bFoundLWS = FALSE;

            while(BytesIndicated && IS_HTTP_LWS(*pIndicatedBuffer))
            {
                bFoundLWS = TRUE;
                pIndicatedBuffer ++;
                BytesIndicated --;
            }

            // 
            // NOTE: Order of the following two if conditions is important
            // We don't want to fail this response if we got here when 
            // BytesIndicated was 0 in the first place.
            //

            if(BytesIndicated == 0)
            {
                return STATUS_MORE_PROCESSING_REQUIRED;
            }

            if(!bFoundLWS)
            {
                UlTrace(PARSER,
                        ("[UcpParseHttpResponse]: No LWS between reason & "
                         "status code \n"));

                return STATUS_INVALID_NETWORK_RESPONSE;
            }

            //
            // Look for a CRLF
            //

            pStartReason = pIndicatedBuffer;

            while(BytesIndicated >= CRLF_SIZE)
            {
                if (*(UNALIGNED64 USHORT *)pIndicatedBuffer == CRLF ||
                    *(UNALIGNED64 USHORT *)pIndicatedBuffer == LFLF)
                {
                    break;
                }

                //
                // Advance to the next character.
                //
                pIndicatedBuffer ++;
                BytesIndicated   --;
            }

            if(BytesIndicated < CRLF_SIZE)
            {
                return STATUS_MORE_PROCESSING_REQUIRED;
            }

            //
            // We've reached end of reason string, consume the CRLF.
            //
            pIndicatedBuffer += CRLF_SIZE;
            BytesIndicated   -= CRLF_SIZE;

            if(!bIgnoreParsing)
            {
                //
                // Set the reason string pointer and copy out the reason
                // string.
                //
    
                pResponse->pReason=
                        (PSTR)pRequest->CurrentBuffer.pOutBufferHead;
    
                pResponse->ReasonLength
                    = DIFF_USHORT(pIndicatedBuffer - pStartReason) - CRLF_SIZE;
    
                AlignLength = ALIGN_UP(pResponse->ReasonLength, PVOID);
    
                if(pRequest->CurrentBuffer.BytesAvailable >= AlignLength)
                {
                    RtlCopyMemory((PSTR) pResponse->pReason,
                                  pStartReason,
                                  pResponse->ReasonLength);
    
                    pRequest->CurrentBuffer.pOutBufferHead  += AlignLength;
                    pRequest->CurrentBuffer.BytesAvailable  -= AlignLength;
    
                }
                else
                {
                    pResponse->pReason       = NULL;
                    pResponse->ReasonLength  = 0;
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }
    
            // The head pointer is now going to be used for the unknown header 
            // array. Let's set it.
            //
    
            pResponse->Headers.pUnknownHeaders = (PHTTP_UNKNOWN_HEADER)
                     pRequest->CurrentBuffer.pOutBufferHead;
    
            *BytesTaken         += DIFF(pIndicatedBuffer - pStart);
            pRequest->ParseState = UcParseHeaders;
    
            //
            // FALLTHROUGH
            //
        
            ASSERT(pRequest->ParseState == UcParseHeaders);

        case UcParseHeaders:
        case UcParseTrailers:
        case UcParseEntityBodyMultipartHeaders:

            pStart = pIndicatedBuffer;

            while(BytesIndicated >= CRLF_SIZE)
            {
                //
                // If this is an empty header, we are done.
                //

                if (*(UNALIGNED64 USHORT *)pIndicatedBuffer == CRLF ||
                    *(UNALIGNED64 USHORT *)pIndicatedBuffer == LFLF)
                {
                    break;
                }

                //
                // Parse the headers.
                //

                if(bIgnoreParsing)
                {
                    ULONG   HeaderNameLength;

                    Status = UcFindHeaderNameEnd(
                                pIndicatedBuffer,
                                BytesIndicated,
                                &HeaderNameLength
                                );

                    if(!NT_SUCCESS(Status))
                    {
                        return Status;
                    }

                    ASSERT(BytesIndicated - HeaderNameLength
                                < ANSI_STRING_MAX_CHAR_LEN);

                    Status = UcFindHeaderValueEnd(
                                pIndicatedBuffer + HeaderNameLength,
                                (USHORT) (BytesIndicated - HeaderNameLength),
                                &pFoldingBuffer,
                                &HeaderBytesTaken
                                );

                    if(!NT_SUCCESS(Status))
                    {
                        return Status;
                    };

                    ASSERT(HeaderBytesTaken != 0);

                    // No need to check for NT_STATUS here. We are ignoring
                    // headers anyway.

                    if(pFoldingBuffer)
                    {
                        UL_FREE_POOL(
                            pFoldingBuffer,
                            UC_HEADER_FOLDING_POOL_TAG
                            );
                    }

                    HeaderBytesTaken += HeaderNameLength;
                }
                else
                {
                    Status = UcParseHeader(pRequest,
                                           pIndicatedBuffer,
                                           BytesIndicated,
                                           &HeaderBytesTaken);
    
                }
                if(!NT_SUCCESS(Status))
                {
                    return Status;
                }
                else
                {
                    ASSERT(HeaderBytesTaken != 0);
                    pIndicatedBuffer         += HeaderBytesTaken;
                    BytesIndicated           -= HeaderBytesTaken;
                    *BytesTaken              += HeaderBytesTaken;
                }
            }

            if(BytesIndicated >= CRLF_SIZE)
            {
                //
                // We have reached the end of the headers.
                //

                pIndicatedBuffer += CRLF_SIZE;
                BytesIndicated   -= CRLF_SIZE;
                *BytesTaken      += CRLF_SIZE;

                //
                // If we were parsing headers, we have to parse entity bodies.
                // if we were parsing trailers, we are done!
                //
    
                if(pRequest->ParseState == UcParseHeaders)
                {
                    //
                    // See if it is valid for this response to include a
                    // message body. All 1xx, 204 and 304 responses should not
                    // have a message body.
    
                    //
                    // For 1XX responses, we need to re-set the ParseState to
                    // Init, so that we parse the subsequent response also.
                    //
    
                    if((pResponse->StatusCode >= 100 &&
                        pResponse->StatusCode <= 199))
                    {
                        pRequest->ParseState = UcParseStatusLineVersion;
    
                        if(!bIgnoreParsing)
                        {
                            return STATUS_INSUFFICIENT_RESOURCES;
                        }
                        else
                        {   
                            continue;
                        }
                    }
    
                    if((pResponse->StatusCode == 204) ||
                       (pResponse->StatusCode == 304) ||
                       (pRequest->RequestFlags.NoResponseEntityBodies == TRUE)
                       )
                    {
                        //
                        // These responses cannot have a entity body. If a
                        // rogue server has passed an entity body, it will
                        // just be treated as the part of a subsequent
                        // indication
                        //
    
                        pRequest->ParseState = UcParseDone;
                        return STATUS_SUCCESS;
                    }
    
                    //
                    // Set up the pointers for the entity body.
                    //
    
                    pResponse->EntityChunkCount = 0;
                    pResponse->pEntityChunks =  (PHTTP_DATA_CHUNK)
                            pRequest->CurrentBuffer.pOutBufferHead;
    
                    if(pResponse->StatusCode == 206 &&
                       pRequest->ResponseMultipartByteranges)
                    {
                        if(pRequest->ResponseEncodingChunked)
                        {
                            // UC_BUGBUG (WORKITEM)
                            // Ouch. We can't handle this right now.
                            // we have to first unchunk the entitities,
                            // and then decode the multipart response.
                            // for now, we'll fail this request.
    
                            UlTrace(PARSER,
                                    ("[UcpParseHttpResponse]: "
                                     "Multipart-chunked\n"));
                            return STATUS_INVALID_NETWORK_RESPONSE;
                        }
    
                        // multipart byterange
                        pRequest->ParseState = UcParseEntityBodyMultipartInit;
                    }
                    else
                    {
                        pRequest->ParseState = UcParseEntityBody;
                    }
                }
                else if(pRequest->ParseState == UcParseTrailers)
                {
                        pRequest->ParseState = UcParseDone;
                        return STATUS_SUCCESS;
                }
                else
                {
                    pResponse->EntityChunkCount = 0;
                    pResponse->pEntityChunks =  (PHTTP_DATA_CHUNK)
                            pRequest->CurrentBuffer.pOutBufferHead;
    
                    pRequest->ParseState = UcParseEntityBodyMultipartFinal;
                    pRequest->MultipartRangeRemaining = 0;
                }
            }
            else
            {
                return STATUS_MORE_PROCESSING_REQUIRED;
            }
    
            break;
    
        case UcParseEntityBodyMultipartInit:

            pStart = pIndicatedBuffer;

            if(BytesIndicated >= pRequest->MultipartStringSeparatorLength)
            {
                pEnd = UxStrStr(
                            (const char *) pIndicatedBuffer,
                            (const char *) pRequest->pMultipartStringSeparator,
                            BytesIndicated
                            );

                if(!pEnd)
                {
                    return STATUS_MORE_PROCESSING_REQUIRED;
                }

                pIndicatedBuffer =
                    (PUCHAR) pEnd + pRequest->MultipartStringSeparatorLength;

                BytesIndicated -= DIFF(pIndicatedBuffer - pStart);

                if(BytesIndicated >= 2 &&
                   *pIndicatedBuffer == '-' && *(pIndicatedBuffer+1) == '-')
                {
                    BytesIndicated -= 2;
                    pIndicatedBuffer += 2;
                    bEnd = TRUE;
                }
                else
                {
                    bEnd = FALSE;
                }

                //
                // skip any LWS.
                //

                while(BytesIndicated && IS_HTTP_LWS(*pIndicatedBuffer))
                {
                    pIndicatedBuffer ++;
                    BytesIndicated --;
                }

                if(BytesIndicated >= 2)
                {
                   if(*(UNALIGNED64 USHORT *)pIndicatedBuffer == CRLF ||
                      *(UNALIGNED64 USHORT *)pIndicatedBuffer == LFLF)
                   {
                       BytesIndicated   -= CRLF_SIZE;
                       pIndicatedBuffer += CRLF_SIZE;

                       if(!bEnd)
                       {
                           // we are ready to parse the range. Since we always
                           // indicate Multipart in a new HTTP_RESPONSE
                           // structure, get more buffer.

                           Status = UcpGetResponseBuffer(
                                        pRequest,
                                        BytesIndicated,
                                        UC_RESPONSE_BUFFER_FLAG_NOT_MERGEABLE);

                           if(!NT_SUCCESS(Status))
                           {
                               return Status;
                           }

                           pResponse = pRequest->CurrentBuffer.pResponse;

                           pRequest->ParseState =
                                UcParseEntityBodyMultipartHeaders;
                       }
                       else
                       {
                            if(BytesIndicated == 2)
                            {
                                if(*(UNALIGNED64 USHORT *)pIndicatedBuffer
                                   == CRLF)
                                {
                                    BytesIndicated   -= CRLF_SIZE;
                                    pIndicatedBuffer += CRLF_SIZE;

                                    pRequest->ParseState = UcParseDone;
                                }
                                else
                                {
                                    return STATUS_INVALID_NETWORK_RESPONSE;
                                }
                            }
                            else
                            {
                                return STATUS_MORE_PROCESSING_REQUIRED;
                            }
                        }
                   }
                }
                else
                {
                    return STATUS_MORE_PROCESSING_REQUIRED;
                }
            }
            else
            {
                return STATUS_MORE_PROCESSING_REQUIRED;
            }

            *BytesTaken += DIFF(pIndicatedBuffer - pStart);

            break;

        case UcParseEntityBodyMultipartFinal:

            //
            // We have parsed out the Content-Type & Content-Range of the
            // Multipart encoding, we now proceed to carve out HTTP_DATA_CHUNKs
            // for the data. We will keep searching the data till we hit a
            // seperator.
            //

            if(pRequest->MultipartRangeRemaining != 0)
            {
                //
                // We didn't consume part of an earlier range.
                // 
                DataChunkStatus = UcpCopyEntityToDataChunk(
                            pResponse,
                            pRequest,
                            pRequest->MultipartRangeRemaining, // BytesToTake
                            BytesIndicated,                    // BytesIndicated
                            pIndicatedBuffer,
                            &EntityBytesTaken
                            );

                *BytesTaken += EntityBytesTaken;
                pRequest->MultipartRangeRemaining -= EntityBytesTaken;

                if(UcDataChunkCopyAll == DataChunkStatus)
                {
                    if(0 == pRequest->MultipartRangeRemaining)
                    {
                        // Done with this range, we consumed all of it.
                        
                        pRequest->ParseState = UcParseEntityBodyMultipartInit;
                        pIndicatedBuffer += EntityBytesTaken;
                        BytesIndicated   -= EntityBytesTaken;

                        break;
                    }
                    else
                    {
                        // We consumed all, but there's more data remaining.
                        
                        return STATUS_MORE_PROCESSING_REQUIRED;
                    }
                }
                else
                {
                    // We consumed partial, need more buffer
                    
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            else if(BytesIndicated >= pRequest->MultipartStringSeparatorLength)
            {
                pEnd = UxStrStr(
                            (const char *) pIndicatedBuffer,
                            (const char *) pRequest->pMultipartStringSeparator,
                            BytesIndicated
                            );

                if(!pEnd)
                {
                    // If we haven't reached the end, we can't blindly carve 
                    // out a data chunk with whatever we have! This is because 
                    // we could have a case where the StringSeperator is 
                    // spread across indications & we wouldn't want to treat 
                    // the part of the string separator as entity!
                    
                  
                    // So, we'll carve out a data chunk for
                    // BytesIndicated - MultipartStringSeparatorLength. we are
                    // guaranteed that this is entity body.
                    
                    
                    ResponseRangeLength = 
                      BytesIndicated - pRequest->MultipartStringSeparatorLength;

                    DataChunkStatus = UcpCopyEntityToDataChunk(
                                pResponse,
                                pRequest,
                                ResponseRangeLength, // BytesToTake
                                BytesIndicated,      // BytesIndicated
                                pIndicatedBuffer,
                                &EntityBytesTaken
                                );

                    *BytesTaken += EntityBytesTaken;

                    if(UcDataChunkCopyAll == DataChunkStatus)
                    {
                        // Since we haven't yet seen the terminator, we have
                        // to return STATUS_MORE_PROCESSING_REQUIRED.
                        //
                        
                        return STATUS_MORE_PROCESSING_REQUIRED;
                    }
                    else
                    {
                        // consumed partial, more buffer required
                        return STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
                else
                {
                    ResponseRangeLength = DIFF((PUCHAR)pEnd - pIndicatedBuffer);

                    ASSERT(ResponseRangeLength < BytesIndicated);

                    DataChunkStatus = UcpCopyEntityToDataChunk(
                                pResponse,
                                pRequest,
                                ResponseRangeLength, // BytesToTake
                                BytesIndicated,      // BytesIndicated
                                pIndicatedBuffer,
                                &EntityBytesTaken
                                );


                    *BytesTaken += EntityBytesTaken;

                    if(UcDataChunkCopyAll == DataChunkStatus)
                    {
                        //
                        // Done with this range, we consumed all of it.
                        //
                        
                        ASSERT(EntityBytesTaken == ResponseRangeLength);

                        pRequest->ParseState = UcParseEntityBodyMultipartInit;

                        // Update these fields, because we have to continue
                        // parsing.
                        
                        pIndicatedBuffer += ResponseRangeLength;
                        BytesIndicated   -= ResponseRangeLength;

                        break;
                    }
                    else
                    {
                        // this field has to be a ULONG, because we are 
                        // gated by BytesIndicated. It doesn't have to be a 
                        // ULONGLONG.
                        
                        pRequest->MultipartRangeRemaining = 
                                ResponseRangeLength - EntityBytesTaken;

                        return STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
            }
            else
            {
                return STATUS_MORE_PROCESSING_REQUIRED;
            }

            break;

        case UcParseEntityBody:

            if(pRequest->ResponseEncodingChunked)
            {
                //
                // If there's a chunk that we've not fully consumed.
                // The chunk-length of the current chunk is stored in 
                // ResponseContentLength.
                //
                
                if(pRequest->ResponseContentLength)
                {
                    DataChunkStatus = 
                        UcpCopyEntityToDataChunk(
                           pResponse,
                           pRequest,
                           (ULONG)pRequest->ResponseContentLength,
                           BytesIndicated,
                           pIndicatedBuffer,
                          &EntityBytesTaken
                           );

                    pRequest->ResponseContentLength -= EntityBytesTaken;

                    *BytesTaken += EntityBytesTaken;

                    if(UcDataChunkCopyAll == DataChunkStatus)
                    {
                        if(0 == pRequest->ResponseContentLength)
                        {
                            // We are done. Move onto the next chunk.
                            //
                            pIndicatedBuffer += EntityBytesTaken;
                            BytesIndicated   -= EntityBytesTaken;
                            break;
                        }
                        else
                        {
                            ASSERT(BytesIndicated == EntityBytesTaken);
                            return STATUS_MORE_PROCESSING_REQUIRED;
                        }
                    }
                    else
                    {
                        return STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
                else
                {
                    ULONG ChunkBytesTaken;

                    Status = ParseChunkLength(
                                pRequest->ParsedFirstChunk,
                                pIndicatedBuffer,
                                BytesIndicated,
                                &ChunkBytesTaken,
                                &pRequest->ResponseContentLength
                                );

                    if(!NT_SUCCESS(Status))
                    {
                        return Status;
                    }

                    *BytesTaken += ChunkBytesTaken;

                    pIndicatedBuffer += ChunkBytesTaken;
                    BytesIndicated   -= ChunkBytesTaken;

                    pRequest->ParsedFirstChunk = 1;

                    if(0 == pRequest->ResponseContentLength)
                    {
                        //
                        // We are done - Let's handle the trailers.
                        //
                        pRequest->ParseState = UcParseTrailers;
                        bIgnoreParsing       = TRUE;
                    }

                    break;
                }
            }
            else if(pRequest->ResponseContentLengthSpecified)
            {
                if(pRequest->ResponseContentLength == 0)
                {
                    pRequest->ParseState = UcParseDone;
                    return STATUS_SUCCESS;
                }

                DataChunkStatus = UcpCopyEntityToDataChunk(
                            pResponse,
                            pRequest,
                            (ULONG) pRequest->ResponseContentLength,
                            BytesIndicated,
                            pIndicatedBuffer,
                            &EntityBytesTaken
                            );

                *BytesTaken += EntityBytesTaken;
                pRequest->ResponseContentLength -= EntityBytesTaken;

                if(UcDataChunkCopyAll == DataChunkStatus)
                {
                    if(0 == pRequest->ResponseContentLength)
                    {
                        //
                        // We've consumed everything.
                        //
                        pRequest->ParseState = UcParseDone;
                        return STATUS_SUCCESS;
                    }
                    else
                    {
                        return STATUS_MORE_PROCESSING_REQUIRED;
                    }
                }
                else
                {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            else
            {
                //
                // Consume all of it. We will assume that this will end when
                // we get called in the disconnect handler.
                //
               
                DataChunkStatus = UcpCopyEntityToDataChunk(
                            pResponse,
                            pRequest,
                            BytesIndicated,
                            BytesIndicated,
                            pIndicatedBuffer,
                            &EntityBytesTaken
                            );

                *BytesTaken += EntityBytesTaken;

                if(UcDataChunkCopyAll == DataChunkStatus)
                {
                    return STATUS_MORE_PROCESSING_REQUIRED;
                }
                else
                {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            break;

        case UcParseDone:
            return STATUS_SUCCESS;
            break;

        default:

            ASSERT(FALSE);
            UlTrace(PARSER,
                    ("[UcpParseHttpResponse]: Invalid state \n"));
            return STATUS_INVALID_NETWORK_RESPONSE;

        } // case
    }

    if(pRequest->ParseState !=  UcParseDone)
    {
        //
        // Ideally, we want to do this check inside UcParseEntityBody -
        // however, if BytesIndicated == 0 adn we are done, we might not
        // get a chance to even go there.
        //

        if(pRequest->ParseState == UcParseEntityBody &&
           pRequest->ResponseContentLengthSpecified &&
           pRequest->ResponseContentLength == 0)
        {
            pRequest->ParseState = UcParseDone;
            return STATUS_SUCCESS;
        }

        return STATUS_MORE_PROCESSING_REQUIRED;
    }
    else
    {
        return STATUS_SUCCESS;
    }
}

/***************************************************************************++

Routine Description:

  This is the main routine that gets called from the TDI receive indication
  handler. It merges the indications, allocates buffers (if required) and
  kicks of the Parser.

Arguments:

    pConnectionContext - The UC_CLIENT_CONNECTION structure.
    pIndicatedBuffer   - The current Indication
    BytesIndicated     - Size of the current Indication.
    UnreceivedLength   - Bytes the transport has, but arent in buffer.

Return Value:

    NTSTATUS - Completion status.

    STATUS_SUCCESS                   : Parsed or buffered the indication.

    STATUS_INSUFFICIENT_RESOURCES    : Out of memory. This will result in a
                                       connection tear down.

    STATUS_INVALID_NETWORK_RESPONSE  : Illegal HTTP response, mismatched
                                       response.


--***************************************************************************/
NTSTATUS
UcHandleResponse(IN  PVOID  pListeningContext,
                 IN  PVOID  pConnectionContext,
                 IN  PVOID  pIndicatedBuffer,
                 IN  ULONG  BytesIndicated,
                 IN  ULONG  UnreceivedLength,
                 OUT PULONG pBytesTaken)
{
    ULONG                 BytesTaken;
    ULONG                 i;
    PUC_CLIENT_CONNECTION pConnection;
    PUCHAR                pIndication, Indication[2], pOldIndication;
    ULONG                 IndicationLength[2];
    ULONG                 IndicationCount;
    PUC_HTTP_REQUEST      pRequest;
    NTSTATUS              Status;
    PLIST_ENTRY           pList;
    KIRQL                 OldIrql;
    ULONG                 OriginalBytesIndicated;
    ULONG                 OldIndicationBytesAllocated;
    BOOLEAN               DoneWithLoop = FALSE;

    UNREFERENCED_PARAMETER(pListeningContext);
    UNREFERENCED_PARAMETER(UnreceivedLength);

    OriginalBytesIndicated = BytesIndicated;
    OldIndicationBytesAllocated = 0;
    *pBytesTaken = 0;

    pConnection = (PUC_CLIENT_CONNECTION) pConnectionContext;

    ASSERT( UC_IS_VALID_CLIENT_CONNECTION(pConnection) );

    //
    // Right now, no body calls the client receive function with
    // Unreceived length. In TDI receive handler, we always drain
    // out the data before calling UcHandleResponse.
    //

    ASSERT(UnreceivedLength == 0);

    //
    // We might have got insufficient indication from a prior indication.
    // Let's see if we need to merge this.
    //

    UcpMergeIndications(pConnection,
                        (PUCHAR)pIndicatedBuffer,
                        BytesIndicated,
                        Indication,
                        IndicationLength,
                        &IndicationCount);

    ASSERT( (IndicationCount == 1 || IndicationCount == 2) );

    //
    // Begin parsing.
    //

    for(i=0; !DoneWithLoop && i<IndicationCount; i++)
    {
        BytesIndicated = IndicationLength[i];
        pIndication    = Indication[i];

        while(BytesIndicated)
        {
            //
            // We first need to pick the first request that got submitted to
            // TDI. We need this to match responses to requests. There will be
            // an entry in this list even if the app did not submit an output
            // buffer with the request.
            //

            UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

            //
            // If the connection is being cleaned up, we should not even
            // be here. Ideally, this will never happen, because TDI will
            // not call our cleanup handler till all outstanding receives
            // are complete.
            //
            // However, when we go over SSL, we buffer the data & complete
            // TDI's receive thread.
            //

            if(pConnection->ConnectionState ==
                    UcConnectStateConnectCleanup ||
               pConnection->ConnectionState ==
                    UcConnectStateConnectCleanupBegin)
            {
                UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

                UlTrace(PARSER,
                        ("[UcHandleResponse]: Connection cleaned \n"));

                return STATUS_INVALID_NETWORK_RESPONSE;
            }

            if(IsListEmpty(&pConnection->SentRequestList))
            {
                //
                // This can happen if the server sends a screwed up response.
                // we'll never be able to match responses with requests. We are
                // forced to tear down the connection.
                //

                //
                // We won't do any clean-up here - This status code will cause
                // the connection to get torn down and we'll localize all the
                // conneciton cleanup code.
                //

                UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

                UlTrace(PARSER,
                        ("[UcHandleResponse]: Malformed HTTP packet \n"));

                return STATUS_INVALID_NETWORK_RESPONSE;
            }

            pList = (&pConnection->SentRequestList)->Flink;

            pRequest = CONTAINING_RECORD(pList, UC_HTTP_REQUEST, Linkage);

            if(pRequest->ParseState == UcParseDone)
            {
                UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
                return STATUS_INVALID_NETWORK_RESPONSE;
            }

            switch(pRequest->RequestState)
            {
                case UcRequestStateSent:

                    // Received first byte of data but haven't got called
                    // in send complete handler.

                    pRequest->RequestState =
                        UcRequestStateNoSendCompletePartialData;
                    break;

                case UcRequestStateNoSendCompletePartialData:

                    // Received more data but still haven't got called
                    // in send complete handler. We'll remain in the same
                    // state.

                    break;

                case UcRequestStateSendCompleteNoData:

                    // We have been called in Send complete & are receiving
                    // the first byte of data.

                    pRequest->RequestState =
                        UcRequestStateSendCompletePartialData;
                    break;

                case UcRequestStateSendCompletePartialData:
                    // We have been called in Send complete & are receiving
                    // data.
                    break;

                default:
                    ASSERT(0);
                    break;
            }


            if(UcpReferenceForReceive(pRequest) == FALSE)
            {
                UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

                UlTrace(PARSER,
                        ("[UcHandleResponse]: Receive cancelled \n"));

                return STATUS_CANCELLED;
            }

            pConnection->Flags |= CLIENT_CONN_FLAG_RECV_BUSY;

            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

            //
            // Given a request & response buffer, we will loop till we parse
            // out this completly.
            //

            while(TRUE)
            {
                Status  = UcpParseHttpResponse(pRequest,
                                               pIndication,
                                               BytesIndicated,
                                               &BytesTaken);

                //
                // Even if there is an error, we could have consumed some
                // amount of data.
                //

                BytesIndicated -= BytesTaken;
                pIndication    += BytesTaken;

                ASSERT((LONG)BytesIndicated >= 0);

                if(Status == STATUS_SUCCESS)
                {
                    //
                    // This one worked! Complete the IRP that got pended.
                    //

                    UcpHandleParsedRequest(pRequest,
                                           &pIndication,
                                           &BytesIndicated,
                                           BytesTaken
                                           );

                    UcpDereferenceForReceive(pRequest);

                    break;
                }
                else
                {
                    if(Status == STATUS_MORE_PROCESSING_REQUIRED)
                    {
                        UcpDereferenceForReceive(pRequest);

                        if(BytesIndicated == 0)
                        {
                            // This just means that this indication was parsed
                            // completly, but we did not reach the end of the
                            // response. Let's move on to the next indication.

                            // This will take us out of the While(TRUE) loop
                            // as well as while(BytesIndicated) loop.

                            break;
                        }
                        else if(DoneWithLoop || i == IndicationCount - 1)
                        {
                            // We ran out of buffer space for the last
                            // indication. This could either be a TDI
                            // indication or a  "merged" indication
                            //
                            // If its a TDI indication we have to copy since
                            // we don't own the TDI buffers. If its our
                            // indication, we still have to copy since some
                            // portion of it might have got consumed by the
                            // parser & we care only about the remaining.

                            pOldIndication =
                                pConnection->MergeIndication.pBuffer;

                            OldIndicationBytesAllocated =
                                pConnection->MergeIndication.BytesAllocated;

                            pConnection->MergeIndication.pBuffer =
                                (PUCHAR) UL_ALLOCATE_POOL_WITH_QUOTA(
                                    NonPagedPool,
                                    BytesIndicated +
                                    UC_INSUFFICIENT_INDICATION_EXTRA_BUFFER,
                                    UC_RESPONSE_TDI_BUFFER_POOL_TAG,
                                    pConnection->pServerInfo->pProcess
                                    );

                            if(!pConnection->MergeIndication.pBuffer)
                            {
                                if(pOldIndication)
                                {
                                    UL_FREE_POOL_WITH_QUOTA(
                                        pOldIndication,
                                        UC_RESPONSE_TDI_BUFFER_POOL_TAG,
                                        NonPagedPool,
                                        OldIndicationBytesAllocated,
                                        pConnection->pServerInfo->pProcess
                                        );
                                }

                                UlAcquireSpinLock(&pConnection->SpinLock,
                                                  &OldIrql);

                                UcClearConnectionBusyFlag(
                                        pConnection,
                                        CLIENT_CONN_FLAG_RECV_BUSY,
                                        OldIrql,
                                        FALSE
                                        );

                                return STATUS_INSUFFICIENT_RESOURCES;
                            }

                            pConnection->MergeIndication.BytesAllocated =
                                BytesIndicated +
                                UC_INSUFFICIENT_INDICATION_EXTRA_BUFFER;

                            pConnection->MergeIndication.BytesWritten =
                                BytesIndicated;

                            RtlCopyMemory(
                                pConnection->MergeIndication.pBuffer,
                                pIndication,
                                BytesIndicated
                                );

                            if(pOldIndication)
                            {
                                UL_FREE_POOL_WITH_QUOTA(
                                    pOldIndication,
                                    UC_RESPONSE_TDI_BUFFER_POOL_TAG,
                                    NonPagedPool,
                                    OldIndicationBytesAllocated,
                                    pConnection->pServerInfo->pProcess
                                    );
                            }

                            //
                            // Let's pretend as if we have read all of the data.
                            //

                            *pBytesTaken = OriginalBytesIndicated;

                            UlAcquireSpinLock(&pConnection->SpinLock,
                                              &OldIrql);

                            UcClearConnectionBusyFlag(
                                    pConnection,
                                    CLIENT_CONN_FLAG_RECV_BUSY,
                                    OldIrql,
                                    FALSE
                                    );

                            return STATUS_SUCCESS;
                        }
                        else
                        {
                            //
                            // Our merge did not go well. We have to copy more
                            // data from the TDI indication into this
                            // and continue. To keep things simple, we'll just
                            // copy everything.
                            //

                            ASSERT(i==0);
                            ASSERT(pConnection->MergeIndication.pBuffer);

                            if(pConnection->MergeIndication.BytesAllocated <
                               (BytesIndicated + IndicationLength[i+1] +
                                UC_INSUFFICIENT_INDICATION_EXTRA_BUFFER)
                              )
                            {
                                pOldIndication =
                                    pConnection->MergeIndication.pBuffer;

                                OldIndicationBytesAllocated =
                                    pConnection->MergeIndication.BytesAllocated;

                                pConnection->MergeIndication.pBuffer =
                                    (PUCHAR) UL_ALLOCATE_POOL_WITH_QUOTA(
                                        NonPagedPool,
                                        BytesIndicated+ IndicationLength[i+1]+
                                        UC_INSUFFICIENT_INDICATION_EXTRA_BUFFER,
                                        UC_RESPONSE_TDI_BUFFER_POOL_TAG,
                                        pConnection->pServerInfo->pProcess
                                        );

                                if(!pConnection->MergeIndication.pBuffer)
                                {
                                    UL_FREE_POOL_WITH_QUOTA(
                                        pOldIndication,
                                        UC_RESPONSE_TDI_BUFFER_POOL_TAG,
                                        NonPagedPool,
                                        OldIndicationBytesAllocated,
                                        pConnection->pServerInfo->pProcess
                                        );

                                    UlAcquireSpinLock(&pConnection->SpinLock,
                                                      &OldIrql);

                                    UcClearConnectionBusyFlag(
                                            pConnection,
                                            CLIENT_CONN_FLAG_RECV_BUSY,
                                            OldIrql,
                                            FALSE
                                            );

                                    return STATUS_INSUFFICIENT_RESOURCES;
                                }

                                pConnection->MergeIndication.BytesAllocated =
                                    BytesIndicated +  IndicationLength[i+1] +
                                    UC_INSUFFICIENT_INDICATION_EXTRA_BUFFER;

                            }
                            else
                            {
                                pOldIndication = 0;
                            }

                            RtlCopyMemory(
                                    pConnection->MergeIndication.pBuffer,
                                    pIndication,
                                    BytesIndicated
                                    );

                            RtlCopyMemory(
                                pConnection->MergeIndication.pBuffer +
                                BytesIndicated,
                                Indication[i+1],
                                IndicationLength[i+1]
                                );

                            if(pOldIndication)
                            {
                                UL_FREE_POOL_WITH_QUOTA(
                                    pOldIndication,
                                    UC_RESPONSE_TDI_BUFFER_POOL_TAG,
                                    NonPagedPool,
                                    OldIndicationBytesAllocated,
                                    pConnection->pServerInfo->pProcess
                                    );
                            }

                            pConnection->MergeIndication.BytesWritten =
                                BytesIndicated + IndicationLength[i+1];

                            //
                            // Fix up all the variables so that we run through
                            // the loop only once with the new buffer.
                            //

                            pIndication    =
                                pConnection->MergeIndication.pBuffer;

                            BytesIndicated =
                                pConnection->MergeIndication.BytesWritten;

                            DoneWithLoop = TRUE;

                            //
                            // This will take us out of the while(TRUE) loop.
                            // so we will resume at while(BytesIndicated) loop
                            // pick the next request & party on.
                            //

                            break;
                        }
                    }
                    else if(Status == STATUS_INSUFFICIENT_RESOURCES)
                    {
                        //
                        // We ran out of output buffer space. Let's get more
                        // buffer to hold the response.
                        //

                        Status = UcpGetResponseBuffer(pRequest,
                                                      BytesIndicated,
                                                      0);

                        if(!NT_SUCCESS(Status))
                        {
                            UcpDereferenceForReceive(pRequest);

                            UlAcquireSpinLock(&pConnection->SpinLock,
                                              &OldIrql);

                            UcClearConnectionBusyFlag(
                                    pConnection,
                                    CLIENT_CONN_FLAG_RECV_BUSY,
                                    OldIrql,
                                    FALSE
                                    );

                            return Status;
                        }

                        //
                        // since we have got more buffer, continue parsing the
                        // response.
                        //
                        continue;
                    }
                    else
                    {
                        //
                        // Some other error - Bail right away.
                        //

                        pRequest->ParseState = UcParseError;

                        UcpDereferenceForReceive(pRequest);

                        // The common parser returns
                        // STATUS_INVALID_DEVICE_REQUEST if it finds an
                        // illegal response. A better error code would be
                        // STATUS_INVALID_NETWORK_RESPONSE. Since we don't
                        // want to change the common parser, we'll just eat
                        // this error code.

                        if(STATUS_INVALID_DEVICE_REQUEST == Status)
                        {
                            Status = STATUS_INVALID_NETWORK_RESPONSE;
                        }

                        UlAcquireSpinLock(&pConnection->SpinLock,
                                          &OldIrql);

                        UcClearConnectionBusyFlag(
                                pConnection,
                                CLIENT_CONN_FLAG_RECV_BUSY,
                                OldIrql,
                                FALSE
                                );

                        return Status;
                    }
                }

                //
                // We can never get here.
                //

                // ASSERT(FALSE);

            } // while(TRUE)

            UlAcquireSpinLock(&pConnection->SpinLock,
                              &OldIrql);

            UcClearConnectionBusyFlag(
                    pConnection,
                    CLIENT_CONN_FLAG_RECV_BUSY,
                    OldIrql,
                    FALSE
                    );

        } // while(BytesIndicated)

    } // for(i=0; i<IndicationCount; i++)

    //
    // If we have reached here, we have successfully parsed out the
    // buffers

    if(pConnection->MergeIndication.pBuffer)
    {
        UL_FREE_POOL_WITH_QUOTA(
            pConnection->MergeIndication.pBuffer,
            UC_RESPONSE_TDI_BUFFER_POOL_TAG,
            NonPagedPool,
            pConnection->MergeIndication.BytesAllocated,
            pConnection->pServerInfo->pProcess
            );

        pConnection->MergeIndication.pBuffer = 0;
    }

    *pBytesTaken = OriginalBytesIndicated;

    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    This routine handles failures to the CONNECT verb. In such cases, we have
    to pick up the head request from the pending list that initiated the
    connect & fail it.

Arguments:

    pConnection - pointer to the connection

Return Value:

    None

--***************************************************************************/
VOID
UcpHandleConnectVerbFailure(
    IN  PUC_CLIENT_CONNECTION pConnection,
    OUT PUCHAR               *pIndication,
    OUT PULONG                BytesIndicated,
    IN  ULONG                 BytesTaken
    )
{
    PLIST_ENTRY      pEntry;
    KIRQL            OldIrql;
    PUC_HTTP_REQUEST pRequest;

    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

    //
    // Remove the dummy request form the sent list.
    //
    pEntry = RemoveHeadList(&pConnection->SentRequestList);

    //
    // Initialize it so that we won't remove it again.
    //
    InitializeListHead(pEntry);

    if(pConnection->ConnectionState == UcConnectStateProxySslConnect)
    {
        pConnection->ConnectionState = UcConnectStateConnectComplete;
    }

    //
    // Remove the head request from the pending list &
    // insert in the sent request list.
    //
    ASSERT(IsListEmpty(&pConnection->SentRequestList));

    if(!IsListEmpty(&pConnection->PendingRequestList))
    {

        pEntry =  RemoveHeadList(&pConnection->PendingRequestList);

        pRequest = CONTAINING_RECORD(pEntry,
                                     UC_HTTP_REQUEST,
                                     Linkage);

        InsertHeadList(&pConnection->SentRequestList, pEntry);


        //
        // Fake a send completion.
        //

        ASSERT(pRequest->RequestState == UcRequestStateCaptured);

        pRequest->RequestState = UcRequestStateSent;

        UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

        UcRestartMdlSend(pRequest,
                         STATUS_SUCCESS,
                         0
                         );

        *pIndication    -= BytesTaken;
        *BytesIndicated += BytesTaken;

    }
}

/***************************************************************************++

Routine Description:

    This routine does post parsing book keeping for a request. We update the
    auth cache, proxy auth cache, re-issue NTLM requests, etc, etc.

Arguments:

    pRequest - The fully parsed request

Return Value:

    None

--***************************************************************************/
VOID
UcpHandleParsedRequest(
    IN  PUC_HTTP_REQUEST pRequest,
    OUT PUCHAR           *pIndication,
    OUT PULONG            BytesIndicated,
    IN  ULONG             BytesTaken
    )
{
    PUC_CLIENT_CONNECTION pConnection;
    KIRQL                 OldIrql;

    pConnection = pRequest->pConnection;

    //
    // See if we have to issue a close. There are two cases - If the server
    // has sent a Connection: close header OR if we are doing error detection
    // for POSTs.
    //

    if(
       (pRequest->ResponseConnectionClose &&
        !pRequest->RequestConnectionClose) ||
        (!(pRequest->ResponseStatusCode >= 200 &&
           pRequest->ResponseStatusCode <=299) &&
           !pRequest->RequestFlags.NoRequestEntityBodies &&
           !pRequest->Renegotiate)
       )
    {
        // Error Detection for POSTS:
        //
        // The scenario here is that the client sends a request with
        // entity body, has not sent all of the entity in one call & is
        // hitting a URI that triggers a error response (e.g. 401).

        // As per section 8.2.2, we have to terminate the entity send when
        // we see the error response. Now, we can do this in two ways. If the
        // request is sent using content-length encoding, we are forced to
        // close the connection. If the request is sent with chunked encoding,
        // we can send a 0 length chunk.
        //
        // However, we will ALWAYS close the connection. There are two reasons
        // behind this design rationale
        //      a.  Simplifies the code.
        //      b.  Allows us to expose a consistent API semantic. Subsequent
        //          HttpSendRequestEntityBody will fail with
        //          STATUS_CONNECTION_DISCONNECTED. When this happens, the
        //          app CAN see the response by posting a response buffer.

        UC_CLOSE_CONNECTION(pConnection, FALSE, STATUS_CONNECTION_DISCONNECTED);
    }

    //
    // Now, we have to complete the IRP.
    //

    UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

    //
    // If we have allocated buffers, we need to adjust BytesWritten
    //

    if(pRequest->CurrentBuffer.pCurrentBuffer)
    {
        pRequest->CurrentBuffer.pCurrentBuffer->Flags |=
            UC_RESPONSE_BUFFER_FLAG_READY;

        pRequest->CurrentBuffer.pCurrentBuffer->BytesWritten =
                pRequest->CurrentBuffer.BytesAllocated -
                pRequest->CurrentBuffer.BytesAvailable;
    }

    switch(pRequest->RequestState)
    {
        case UcRequestStateNoSendCompletePartialData:

            // Request got parsed completly before we got called in
            // the send complete.

            pRequest->RequestState = UcRequestStateNoSendCompleteFullData;

            //
            // If we are pipelining sends, we don't want the next response
            // to be re-parsed into this already parsed request.
            //

            if(!pRequest->Renegotiate)
            {

                RemoveEntryList(&pRequest->Linkage);

                InitializeListHead(&pRequest->Linkage);
            }

            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
            break;

        case UcRequestStateSendCompletePartialData:

            if(pRequest->RequestFlags.Cancelled == FALSE)
            {
                pRequest->RequestState = UcRequestStateResponseParsed;

                UcCompleteParsedRequest(
                    pRequest,
                    pRequest->RequestStatus,
                    TRUE,
                    OldIrql);
            }
            else
                UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);

            break;

        default:
            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
            break;
    }

    if(pRequest->RequestFlags.ProxySslConnect &&
       pRequest->Renegotiate == FALSE)
    {
        if(pRequest->ResponseStatusCode != 200)
        {
            // Some real error, we need to show this to the app.

            UcpHandleConnectVerbFailure(
                pConnection,
                pIndication,
                BytesIndicated,
                BytesTaken
                );
        }
        else
        {
            UlAcquireSpinLock(&pConnection->SpinLock, &OldIrql);

            if(pConnection->ConnectionState == UcConnectStateProxySslConnect)
            {
                pConnection->ConnectionState =
                    UcConnectStateProxySslConnectComplete;
            }

            UlReleaseSpinLock(&pConnection->SpinLock, OldIrql);
        }
    }
}

/***************************************************************************++

Routine Description:

    This routine references a request for the receive parser.

Arguments:

    pRequest - The request

Return Value:

    None

--***************************************************************************/
BOOLEAN
UcpReferenceForReceive(
    IN PUC_HTTP_REQUEST pRequest
    )
{
    LONG OldReceiveBusy;


    //
    // Flag this request so that it doesn't get cancelled beneath us
    //

    OldReceiveBusy = InterlockedExchange(
                         &pRequest->ReceiveBusy,
                         UC_REQUEST_RECEIVE_BUSY
                         );

    if(OldReceiveBusy == UC_REQUEST_RECEIVE_CANCELLED)
    {
        // This request already got cancelled
        return FALSE;
    }

    ASSERT(OldReceiveBusy == UC_REQUEST_RECEIVE_READY);

    UC_REFERENCE_REQUEST(pRequest);

    return TRUE;
}

/***************************************************************************++

Routine Description:

    This routine de-references a request for the receive parser. Resumes
    any cleanup if required.

Arguments:

    pRequest - The request

Return Value:

    None

--***************************************************************************/
VOID
UcpDereferenceForReceive(
    IN PUC_HTTP_REQUEST pRequest
    )
{
    LONG OldReceiveBusy;

    OldReceiveBusy = InterlockedExchange(
                         &pRequest->ReceiveBusy,
                         UC_REQUEST_RECEIVE_READY
                         );

    if(OldReceiveBusy == UC_REQUEST_RECEIVE_CANCELLED)
    {
        //
        // The reqeust got cancelled when the receive thread was running,
        // we now have to resume it.
        //

        IoAcquireCancelSpinLock(&pRequest->RequestIRP->CancelIrql);

        UC_WRITE_TRACE_LOG(
            g_pUcTraceLog,
            UC_ACTION_REQUEST_CLEAN_RESUMED,
            pRequest->pConnection,
            pRequest,
            pRequest->RequestIRP,
            UlongToPtr((ULONG)STATUS_CANCELLED)
            );

        UcCancelSentRequest(
            NULL,
            pRequest->RequestIRP
            );
    }
    else
    {
        ASSERT(OldReceiveBusy == UC_REQUEST_RECEIVE_BUSY);
    }

    UC_DEREFERENCE_REQUEST(pRequest);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ucauth.c ===
/*++

Copyright (c) 2001-2002 Microsoft Corporation

Module Name:

    ucauth.c

Abstract:

    This module implements the Authentication for the client APIs

Author:

    Rajesh Sundaram (rajeshsu)  01-Jan-2001

Revision History:

--*/


#include "precomp.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGEUC, UcpAutoSelectAuthType )
#pragma alloc_text( PAGEUC, UcUpdateAuthorizationHeader )
#pragma alloc_text( PAGEUC, UcInitializeSSPI )
#pragma alloc_text( PAGEUC, UcComputeAuthHeaderSize )
#pragma alloc_text( PAGEUC, UcpGenerateDigestAuthHeader )
#pragma alloc_text( PAGEUC, UcGenerateAuthHeaderFromCredentials )
#pragma alloc_text( PAGEUC, UcGenerateProxyAuthHeaderFromCache )
#pragma alloc_text( PAGEUC, UcpGenerateSSPIAuthHeader )
#pragma alloc_text( PAGEUC, UcFindURIEntry )
#pragma alloc_text( PAGEUC, UcDeleteURIEntry )
#pragma alloc_text( PAGEUC, UcAddURIEntry )
#pragma alloc_text( PAGEUC, UcpProcessUriForPreAuth )
#pragma alloc_text( PAGEUC, UcpAllocateAuthCacheEntry )
#pragma alloc_text( PAGEUC, UcDeleteAllURIEntries )
#pragma alloc_text( PAGEUC, UcpGenerateBasicHeader )
#pragma alloc_text( PAGEUC, UcCopyAuthCredentialsToInternal )
#pragma alloc_text( PAGEUC, UcpProcessAuthParams )
#pragma alloc_text( PAGEUC, UcParseAuthChallenge )
#pragma alloc_text( PAGEUC, UcpAcquireClientCredentialsHandle  )
#pragma alloc_text( PAGEUC, UcpGenerateSSPIAuthBlob  )
#pragma alloc_text( PAGEUC, UcpGenerateDigestPreAuthHeader  )
#pragma alloc_text( PAGEUC, UcpUpdateSSPIAuthHeader  )
#pragma alloc_text( PAGEUC, UcDestroyInternalAuth  )
#pragma alloc_text( PAGEUC, UcpGeneratePreAuthHeader )

#endif

//
// Used in wide char to multibyte conversion
//

static char DefaultChar = '_';

//
// Known parameters for known auth schemes
//

HTTP_AUTH_PARAM_ATTRIB HttpAuthBasicParams[] = HTTP_AUTH_BASIC_PARAMS_INIT;
HTTP_AUTH_PARAM_ATTRIB HttpAuthDigestParams[] = HTTP_AUTH_DIGEST_PARAMS_INIT;

//
// Auth scheme structs for all supported auth schemes
//

HTTP_AUTH_SCHEME HttpAuthScheme[HttpAuthTypesCount] = HTTP_AUTH_SCHEME_INIT;

//
// The order in which auth schemes are selected for (HttpAuthAutoSelect)
//

HTTP_AUTH_TYPE PreferredAuthTypes[] = PREFERRED_AUTH_TYPES_INIT;


/***************************************************************************++

Routine Description:

    Used to initialize the SSPI module. Finds out the auth schemes supported
    and the size of the max SSPI blob.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS

--***************************************************************************/
NTSTATUS
UcInitializeSSPI(
    VOID
    )
{
    PSecPkgInfoW    pkgInfo;
    UNICODE_STRING  Scheme;
    SECURITY_STATUS SecStatus;

    //
    // First try NTLM
    //

    Scheme.Length        = HTTP_AUTH_NTLM_W_LENGTH;
    Scheme.MaximumLength = Scheme.Length;
    Scheme.Buffer        = HTTP_AUTH_NTLM_W;

    SecStatus = QuerySecurityPackageInfoW(&Scheme, &pkgInfo);

    if (SecStatus == SEC_E_OK)
    {
        HttpAuthScheme[HttpAuthTypeNTLM].bSupported = TRUE;

        SSPI_MAX_TOKEN_SIZE(HttpAuthTypeNTLM) = pkgInfo->cbMaxToken;
    }

    FreeContextBuffer(pkgInfo);

    //
    // Then Kerberos
    //

    Scheme.Length        = HTTP_AUTH_KERBEROS_W_LENGTH;
    Scheme.MaximumLength = Scheme.Length;
    Scheme.Buffer        = HTTP_AUTH_KERBEROS_W;

    SecStatus = QuerySecurityPackageInfoW(&Scheme, &pkgInfo);

    if(SecStatus == SEC_E_OK)
    {
        HttpAuthScheme[HttpAuthTypeKerberos].bSupported = TRUE;

        SSPI_MAX_TOKEN_SIZE(HttpAuthTypeKerberos) = pkgInfo->cbMaxToken;
    }

    FreeContextBuffer(pkgInfo);

    //
    // Then Negotiate
    //

    Scheme.Length        = HTTP_AUTH_NEGOTIATE_W_LENGTH;
    Scheme.MaximumLength = Scheme.Length;
    Scheme.Buffer        = HTTP_AUTH_NEGOTIATE_W;

    SecStatus = QuerySecurityPackageInfoW(&Scheme, &pkgInfo);

    if(SecStatus == SEC_E_OK)
    {
        HttpAuthScheme[HttpAuthTypeNegotiate].bSupported = TRUE;

        SSPI_MAX_TOKEN_SIZE(HttpAuthTypeNegotiate) = pkgInfo->cbMaxToken;
    }

    FreeContextBuffer(pkgInfo);

    //
    // Then WDigest
    //

    Scheme.Length        = HTTP_AUTH_WDIGEST_W_LENGTH;
    Scheme.MaximumLength = Scheme.Length;
    Scheme.Buffer        = HTTP_AUTH_WDIGEST_W;

    SecStatus = QuerySecurityPackageInfoW(&Scheme, &pkgInfo);

    if(SecStatus == SEC_E_OK)
    {
        HttpAuthScheme[HttpAuthTypeDigest].bSupported = TRUE;

        SSPI_MAX_TOKEN_SIZE(HttpAuthTypeDigest) = pkgInfo->cbMaxToken;
    }

    FreeContextBuffer(pkgInfo);

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Select the "strongest" auth type from the WWW-Authenticate header.

Arguments:

    pAuth - Supplies AUTH structure.

Return Value:

    HTTP_AUTH_TYPE - Selected auth type or HttpAuthTypeAutoSelect

--***************************************************************************/
HTTP_AUTH_TYPE
UcpAutoSelectAuthType(
    IN PHTTP_AUTH_CREDENTIALS pAuth
    )
{
    ULONG                   i;
    NTSTATUS                Status;
    HTTP_AUTH_PARSED_PARAMS AuthSchemeParams[HttpAuthTypesCount];

    // Sanity check
    ASSERT(pAuth);

    // Can't do anything if the header value is not specified
    if (!pAuth->pHeaderValue || pAuth->HeaderValueLength == 0)
    {
        return HttpAuthTypeAutoSelect;
    }

    INIT_AUTH_PARSED_PARAMS(AuthSchemeParams, NULL);

    //
    // Parse the header value
    // find which schemes are specified in the header
    //
    Status = UcParseWWWAuthenticateHeader(
                 pAuth->pHeaderValue,
                 pAuth->HeaderValueLength,
                 AuthSchemeParams
                 );

    if (NT_SUCCESS(Status))
    {
        //
        // Check the scheme in the order of preference
        // Return the first scheme that is present in the header
        //

        for (i = 0; i < DIMENSION(PreferredAuthTypes); i++)
        {
            if (AuthSchemeParams[PreferredAuthTypes[i]].bPresent)
                return PreferredAuthTypes[i];
        }
    }

    // Default return auth select
    return HttpAuthTypeAutoSelect;
}


/***************************************************************************++

Routine Description:

    This is a wrapper routine that prepares arguments for the SSPI function 
    AcquireCredentialsHandle and calls it.

Arguments:

    SchemeName       - Name of the Auth scheme
    SchemeNameLength - Length of Auth scheme (in bytes)
    pCredentials     - User supplied credentials.
    pClientCred      - Credentials Handle (Return value)

Return Value:

    NTSTATUS

--***************************************************************************/
NTSTATUS
UcpAcquireClientCredentialsHandle(
    IN  PWSTR                  SchemeName,
    IN  USHORT                 SchemeNameLength,
    IN  PHTTP_AUTH_CREDENTIALS pCredentials,
    OUT PCredHandle            pClientCred
    )
{
    SECURITY_STATUS           SecStatus;
    TimeStamp                 LifeTime;
    SECURITY_STRING           PackageName;
    SEC_WINNT_AUTH_IDENTITY_W AuthData, *pAuthData;

#ifdef WINNT_50
//
// SSPI in Windows 2000 requires memory to be allocated from the
// process's virtual address space.
//
#error Does not work with WINNT_50!
#endif

    // Sanity check
    PAGED_CODE();
    ASSERT(SchemeName && SchemeNameLength);
    ASSERT(pCredentials);
    ASSERT(pClientCred);

    // Use default credentials, unless specified otherwise!
    pAuthData = NULL;

    // Did user specify credentials?
    if (!(pCredentials->AuthFlags & HTTP_AUTH_FLAGS_DEFAULT_CREDENTIALS))
    {
        // Yes.  Use them.

        AuthData.User       = (PWSTR)pCredentials->pUserName;
        AuthData.UserLength = pCredentials->UserNameLength/sizeof(WCHAR);

        AuthData.Domain       = (PWSTR)pCredentials->pDomain;
        AuthData.DomainLength = pCredentials->DomainLength/sizeof(WCHAR);

        AuthData.Password       = (PWSTR)pCredentials->pPassword;
        AuthData.PasswordLength = pCredentials->PasswordLength/sizeof(WCHAR);

        // Above strings are in unicode
        AuthData.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        // Use user specified credentials.
        pAuthData = &AuthData;
    }

    // The package we are interested in.
    PackageName.Buffer        = SchemeName;
    PackageName.Length        = SchemeNameLength;
    PackageName.MaximumLength = SchemeNameLength;

    // Call SSPI to acquire credentials handle
    SecStatus = AcquireCredentialsHandleW(NULL,
                                          &PackageName,
                                          SECPKG_CRED_OUTBOUND,
                                          NULL,
                                          pAuthData,
                                          NULL,
                                          NULL,
                                          pClientCred,
                                          &LifeTime);

    if (!(pCredentials->AuthFlags & HTTP_AUTH_FLAGS_DEFAULT_CREDENTIALS))
    {
        //
        // Once a credentials handle is obtained, there is no need to store
        // the user credentials.  Erase these values.
        //

        RtlSecureZeroMemory((PUCHAR)pCredentials->pUserName,
                            pCredentials->UserNameLength);

        RtlSecureZeroMemory((PUCHAR)pCredentials->pDomain,
                            pCredentials->DomainLength);

        RtlSecureZeroMemory((PUCHAR)pCredentials->pPassword,
                            pCredentials->PasswordLength);
    }

    //
    // It is very important to return an NTSTATUS code from this function
    // as the status can be as an IRP completion status.
    //

    return SecStatusToNtStatus(SecStatus);
}


/***************************************************************************++

Routine Description:
    Calls SSPI to get the blob. UUEncodes the blob and writes it in pOutBuffer.

Arguments:
    pServInf         - Server Information
    pUcAuth          - Internal auth structure
    pOutBuffer       - points to output buffer
    bRenegotiate     - set if further renegotiation is required

Return Value:

    NTSTATUS.

--***************************************************************************/
NTSTATUS
UcpGenerateSSPIAuthBlob(
    IN  PUC_PROCESS_SERVER_INFORMATION pServInfo,
    IN  PUC_HTTP_AUTH                  pUcAuth,
    IN  PUCHAR                         pOutBuffer,
    IN  ULONG                          OutBufferLen,
    OUT PULONG                         pOutBytesTaken,
    OUT PBOOLEAN                       bRenegotiate
    )
{
    PSecBufferDesc                pInputBuffer;
    SecBufferDesc                 InBufferDesc, OutBufferDesc;
    SecBuffer                     InBuffer, OutBuffer;
    TimeStamp                     LifeTime;
    NTSTATUS                      Status;
    SECURITY_STATUS               SecStatus;
    ULONG                         ContextAttributes;
    PSECURITY_STRING              pTarget;
    UNICODE_STRING                ServerName;
    PVOID                         pVirtualBufferStart = 0;
    ULONG                         VirtualBufferSize;
    PCtxtHandle                   pContext;

    HTTP_AUTH_TYPE                AuthType;
    PWSTR                         pScheme;
    ULONG                         SchemeLength;

    // Sanity check
    PAGED_CODE();

    //
    // Initialize Output arguments.
    //

    *pOutBytesTaken = 0;
    *bRenegotiate = FALSE;

    AuthType = pUcAuth->Credentials.AuthType;
    ASSERT(AuthType == HttpAuthTypeNTLM ||
           AuthType == HttpAuthTypeKerberos ||
           AuthType == HttpAuthTypeNegotiate);

    // See if the auth scheme is supported.
    if (HttpAuthScheme[AuthType].bSupported == FALSE)
    {
        return STATUS_NOT_SUPPORTED;
    }

    // Retrieve the auth scheme name.
    pScheme      = (PWSTR)HttpAuthScheme[AuthType].NameW;
    SchemeLength = HttpAuthScheme[AuthType].NameWLength;

    if(pUcAuth->bValidCredHandle == FALSE)
    {
        // Get a valid credentials handle from the SSP.
        Status = UcpAcquireClientCredentialsHandle(pScheme,
                                                   (USHORT)SchemeLength,
                                                   &pUcAuth->Credentials,
                                                   &pUcAuth->hCredentials);

        if (!NT_SUCCESS(Status))
        {
            return Status;
        }

        pUcAuth->bValidCredHandle = TRUE;

        pInputBuffer = NULL;

        pContext = NULL;
    }
    else
    {
        //
        // Prepare the Input buffers
        //

        ASSERT(pUcAuth->ChallengeBufferSize != 0 &&
               pUcAuth->pChallengeBuffer != NULL);

        pInputBuffer = &InBufferDesc;

        InBufferDesc.ulVersion = SECBUFFER_VERSION;
        InBufferDesc.cBuffers  = 1;
        InBufferDesc.pBuffers  = &InBuffer;

        InBuffer.BufferType    = SECBUFFER_TOKEN;
        InBuffer.cbBuffer      = pUcAuth->ChallengeBufferSize;
        InBuffer.pvBuffer      = pUcAuth->pChallengeBuffer;

        pContext               = &pUcAuth->hContext;
    }

    //
    // Prepare the output buffer.
    //

    VirtualBufferSize = HttpAuthScheme[AuthType].SspiMaxTokenSize;

    pVirtualBufferStart = UL_ALLOCATE_POOL(PagedPool,
                                           VirtualBufferSize,
                                           UC_SSPI_POOL_TAG);

    if(pVirtualBufferStart == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    OutBufferDesc.ulVersion = SECBUFFER_VERSION;
    OutBufferDesc.cBuffers  = 1;
    OutBufferDesc.pBuffers  = &OutBuffer;

    OutBuffer.cbBuffer      = VirtualBufferSize;
    OutBuffer.BufferType    = SECBUFFER_TOKEN;
    OutBuffer.pvBuffer      = (PUCHAR) pVirtualBufferStart;

    //
    // Prepare sever name unicode string
    //
    pTarget = NULL;

    if(HttpAuthScheme[AuthType].bServerNameRequired)
    {
        pTarget = &ServerName;

        ServerName.Length = (USHORT) pServInfo->pServerInfo->ServerNameLength;
        ServerName.MaximumLength = ServerName.Length;
        ServerName.Buffer = (PWCHAR) pServInfo->pServerInfo->pServerName;
    }

    // We must have a valid credentials handle at this point
    ASSERT(pUcAuth->bValidCredHandle);

    // Call SSPI
    SecStatus = InitializeSecurityContextW(
                    &pUcAuth->hCredentials,
                    pContext,
                    pTarget,
                    (ISC_REQ_DELEGATE|ISC_REQ_MUTUAL_AUTH),
                    0,          // reserved
                    SECURITY_NATIVE_DREP,
                    pInputBuffer,
                    0,          // reserved
                    &pUcAuth->hContext,
                    &OutBufferDesc,
                    &ContextAttributes,
                    &LifeTime
                    );

    //
    // Convert SecStatus it to NTSTATUS.  Status will be returned from this
    // function hence it must be NTSTATUS.
    //

    Status = SecStatusToNtStatus(SecStatus);

    if(!NT_SUCCESS(Status))
    {
        //
        // We are computing the max size of a token and we are using that
        // So, this API can never return SEC_E_NO_MEMORY.
        //
        ASSERT(SecStatus != SEC_E_INSUFFICIENT_MEMORY);
    }
    else
    {
        // pUcAuth has a valid context handle that must be freed eventually.
        pUcAuth->bValidCtxtHandle = TRUE;

        if(SEC_I_CONTINUE_NEEDED == SecStatus)
        {
            *bRenegotiate = TRUE;

            Status = BinaryToBase64((PUCHAR)OutBuffer.pvBuffer,
                                    OutBuffer.cbBuffer,
                                    pOutBuffer,
                                    OutBufferLen,
                                    pOutBytesTaken);
        }
        else if(SEC_E_OK == SecStatus)
        {
            Status = BinaryToBase64((PUCHAR)OutBuffer.pvBuffer,
                                    OutBuffer.cbBuffer,
                                    pOutBuffer,
                                    OutBufferLen,
                                    pOutBytesTaken);
        }
        else if(SEC_I_COMPLETE_NEEDED == SecStatus ||
                SEC_I_COMPLETE_AND_CONTINUE == SecStatus)
        {
            //
            // NTLM, Negotiate & Kerberos cannot return this status.
            // This is returned only by DCE.
            //

            ASSERT(FALSE);
            Status = STATUS_NOT_SUPPORTED;
        }
    }

    UL_FREE_POOL(pVirtualBufferStart, UC_SSPI_POOL_TAG);

    return Status;
}

/***************************************************************************++

Routine Description:

    Computes the size required for Authentication headers.

Arguments:

    pAuth               - The Auth config object
    UriLength           - URI length (required for Digest)
    AuthInternalLength  - Space required for storing the internal auth structure

Return Value:

    The header size.


--***************************************************************************/
ULONG
UcComputeAuthHeaderSize(
    PHTTP_AUTH_CREDENTIALS         pAuth,
    PULONG                         AuthInternalLength,
    PHTTP_AUTH_TYPE                pAuthInternalType,
    HTTP_HEADER_ID                 HeaderId
    )
{
    PHEADER_MAP_ENTRY pEntry;
    ULONG             AuthHeaderLength;
    NTSTATUS          Status;
    ULONG             BinaryLength;
    ULONG             Base64Length;
    ULONG             MaxTokenSize;

    // Sanity check.
    ASSERT(pAuth);

    pEntry = &(g_RequestHeaderMapTable[g_RequestHeaderMap[HeaderId]]);

    // 1 for SP char?
    AuthHeaderLength = (pEntry->HeaderLength + 1 + CRLF_SIZE);

    *AuthInternalLength = 0;

    *pAuthInternalType = pAuth->AuthType;

    // See if the user wants us to select an auth type.
    if (*pAuthInternalType == HttpAuthTypeAutoSelect)
    {
        // Select an auth type.
        *pAuthInternalType = UcpAutoSelectAuthType(pAuth);

        if (*pAuthInternalType == HttpAuthTypeAutoSelect)
        {
            // Could not select an auth type.
            ExRaiseStatus(STATUS_INVALID_PARAMETER);
        }
    }

    switch(*pAuthInternalType)
    {
        case HttpAuthTypeBasic:

            //
            // Basic Authorization header format:
            //
            //     "[Proxy-]Authorization: Basic username:password\r\n"
            //
            // Where, the substring username:password is Base64 encoded.
            //
            // AuthHeaderLength is already initialized to account for
            // "[Proxy-]Authorization: \r\n".  Account space for the
            // remaining fields.
            //

            AuthHeaderLength += HTTP_AUTH_BASIC_LENGTH + 1; // 1 for SP

            BinaryLength =   pAuth->UserNameLength / sizeof(WCHAR)
                           + pAuth->PasswordLength / sizeof(WCHAR)
                           + 1;

            //
            // BinaryLength contains the bytes required to store 
            // unencoded "username:password" string.  Find the number of
            // bytes required when this string is Base64 encoded.
            //

            Status = BinaryToBase64Length(BinaryLength,
                                          &Base64Length);

            // No arithmetic overflow can occur here.
            ASSERT(Status == STATUS_SUCCESS);

            // In auth header, username:password is base64 encoded.
            AuthHeaderLength += Base64Length;

            //
            // Internally, we store more that just the auth header.
            // We create a UC_HTTP_AUTH structure and store the
            // auth header, username (in WCHAR), password (in WCHAR),
            // domain (in WCHAR), unencoded username:password in it.
            //

            *AuthInternalLength = AuthHeaderLength;

            *AuthInternalLength +=   sizeof(UC_HTTP_AUTH)
                                   + pAuth->UserNameLength
                                   + pAuth->PasswordLength
                                   + pAuth->DomainLength
                                   + BinaryLength;

            break;

        case HttpAuthTypeDigest:

            AuthHeaderLength += 
                (HTTP_AUTH_DIGEST_LENGTH
                 + 1 // for SP
                 + SSPI_MAX_TOKEN_SIZE(HttpAuthTypeDigest));

            *AuthInternalLength +=   sizeof(UC_HTTP_AUTH) +
                                     pAuth->UserNameLength +
                                     pAuth->PasswordLength +
                                     pAuth->DomainLength +
                                     pAuth->HeaderValueLength +
                                     1; // For a '\0'

            break;

        case HttpAuthTypeNTLM:
        case HttpAuthTypeNegotiate:
        case HttpAuthTypeKerberos:

            MaxTokenSize = HttpAuthScheme[*pAuthInternalType].SspiMaxTokenSize;

            Status = BinaryToBase64Length(MaxTokenSize,
                                          &Base64Length);

            // If there was an overflow, return now.
            if (!NT_SUCCESS(Status))
            {
                ExRaiseStatus(Status);
            }

            //
            // Header format:
            //
            //     [Proxy-]Authorization: SchemeName SP AuthBlob
            //
            // where AuthBlob is Base64 encoded.
            //

            AuthHeaderLength += HttpAuthScheme[*pAuthInternalType].NameLength
                                + 1 // for SP
                                + Base64Length;

            //
            // In the internal structure, we store the blob returned from
            // the server in a challenge.
            //
            // N.B. The server's challenge blob is Base64 encoded.
            //      We convert the challenge blob into binary before 
            //      storing the blob in the internal structure.
            //

            *AuthInternalLength = sizeof(UC_HTTP_AUTH)
                                  + pAuth->UserNameLength
                                  + pAuth->PasswordLength
                                  + pAuth->DomainLength
                                  + MaxTokenSize;

            break;

        default:
            ExRaiseStatus(STATUS_INVALID_PARAMETER);
            break;
    }

    return AuthHeaderLength;
}


/**************************************************************************++

Routine Description:

    This routine generate the preauth header in a buffer.

Arguments:

    pKeRequest    - Supplies the internal request structure.
    pInternalAuth - Supplied the internal authentication structure.
    HeaderId      - Suplies the header that will be generated.
    pMethod       - Supplies the request method.
    MethodLength  - Supplied the length of the method in bytes.
    pBuffer       - Supplies a pointer to the output buffer where the
                    header will be generated.
    BufferLength  - Supplies the length of the output buffer in bytes.
    BytesTaken    - Returns the number of bytes consumed from the output 
                    buffer.

Return Value:

    NTSTATUS.

--**************************************************************************/
NTSTATUS
UcpGeneratePreAuthHeader(
    IN  PUC_HTTP_REQUEST pKeRequest,
    IN  PUC_HTTP_AUTH    pInternalAuth,
    IN  HTTP_HEADER_ID   HeaderId,
    IN  PSTR             pMethod,
    IN  ULONG            MethodLength,
    IN  PUCHAR           pBuffer,
    IN  ULONG            BufferLength,
    OUT PULONG           pBytesTaken
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    ASSERT(pInternalAuth);
    ASSERT(UC_IS_VALID_HTTP_REQUEST(pKeRequest));
    ASSERT(pMethod && MethodLength);
    ASSERT(pBuffer && BufferLength);
    ASSERT(pBytesTaken);
    

    switch (pInternalAuth->Credentials.AuthType)
    {
    case HttpAuthTypeBasic:
    {
        PUCHAR pOrigBuffer = pBuffer;

        //
        // First generate header name then copy the header value.
        //
        // In case of Basic authentication, the encoded buffer contains
        // the header value in the format
        //
        //     Basic <username:password>CRLF
        //
        // where <username:password> is base64 encoded.
        //

        // Is there enought space to copy this header?
        if (UC_HEADER_NAME_SP_LENGTH(HeaderId)
            + pInternalAuth->Basic.EncodedBufferLength
            > BufferLength)
        {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            UC_COPY_HEADER_NAME_SP(pBuffer, HeaderId);

            RtlCopyMemory(pBuffer,
                          pInternalAuth->Basic.pEncodedBuffer,
                          pInternalAuth->Basic.EncodedBufferLength);

            pBuffer += pInternalAuth->Basic.EncodedBufferLength;

            ASSERT(pBuffer <= pOrigBuffer + BufferLength);
            *pBytesTaken = (ULONG)(pBuffer - pOrigBuffer);

            Status = STATUS_SUCCESS;
        }

        break;
    }
    case HttpAuthTypeDigest:

        Status = UcpGenerateDigestPreAuthHeader(HeaderId,
                                                &pInternalAuth->hContext,
                                                pKeRequest->pUri,
                                                pKeRequest->UriLength,
                                                pMethod,
                                                MethodLength,
                                                pBuffer,
                                                BufferLength,
                                                pBytesTaken);
        break;

    default:
        Status = STATUS_NOT_SUPPORTED;
        break;
    }

    return Status;
}


ULONG
_WideCharToMultiByte(
    ULONG uCodePage,
    ULONG dwFlags,
    PCWSTR lpWideCharStr,
    int cchWideChar,
    PSTR lpMultiByteStr,
    int cchMultiByte,
    PCSTR lpDefaultChar,
    PBOOLEAN lpfUsedDefaultChar
    )
{
    int i;

    UNREFERENCED_PARAMETER(uCodePage);
    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(cchMultiByte);
    UNREFERENCED_PARAMETER(lpfUsedDefaultChar);

    //
    // simply strip the upper byte, it's supposed to be ascii already
    //

    for (i = 0; i < cchWideChar; ++i)
    {
        if ((lpWideCharStr[i] & 0xff00) != 0 || IS_HTTP_CTL(lpWideCharStr[i]))
        {
            lpMultiByteStr[0] = *lpDefaultChar;
        }
        else
        {
            lpMultiByteStr[0] = (UCHAR)(lpWideCharStr[i]);
        }
        lpMultiByteStr += 1;
    }

    return (ULONG)(i);

}   // _WideCharToMultiByte



/***************************************************************************++

Routine Description:

    Generates the authorization header for Basic.

Arguments:

    pAuth              - The HTTP_AUTH_CREDENTIALS structure.
    pInternalAuth      - Pointer to our internal auth structure.

Return Value:

    STATUS_SUCCESS

--***************************************************************************/
NTSTATUS
UcpGenerateBasicHeader(
    IN  PHTTP_AUTH_CREDENTIALS         pAuth,
    IN  PUC_HTTP_AUTH                  pInternalAuth
    )
{
    NTSTATUS  Status;
    ULONG     BytesCopied;
    PUCHAR    pCurr;
    PUCHAR    pHeader, pBeginHeader;
    ULONG     CurrLen;
    PUCHAR    pScratchBuffer = pInternalAuth->Basic.pEncodedBuffer;
    ULONG     ScratchBufferSize = pInternalAuth->Basic.EncodedBufferLength;

    //
    // Temporary EncodedBuffer contains the following:
    //
    //  +--------------------------------------------------------------+
    //  | username:password | Basic SP Base64(username:password) CRLF  |
    //  +--------------------------------------------------------------+
    //

    CurrLen = ScratchBufferSize;
    pCurr = pScratchBuffer;

    //
    // Make sure the buffer has space to contain username:password.
    //

    if (pAuth->UserNameLength/sizeof(WCHAR)                 // Ansi Username
        + 1                                                 // ':' char
        + pAuth->PasswordLength/sizeof(WCHAR) > CurrLen)    // Ansi password
    {
        ASSERT(FALSE);
        return STATUS_BUFFER_TOO_SMALL;
    }

    // Copy username.
    BytesCopied = _WideCharToMultiByte(
                            0,
                            0,
                            pAuth->pUserName,
                            pAuth->UserNameLength / sizeof(WCHAR),
                            (PSTR)pCurr,
                            CurrLen,
                            &DefaultChar,
                            NULL
                            );

    ASSERT(BytesCopied <= CurrLen);

    pCurr += BytesCopied;
    CurrLen -= BytesCopied;

    // Copy ':'.
    *pCurr++ = ':';
    CurrLen--;

    // Copy password.
    BytesCopied = _WideCharToMultiByte(
                            0,
                            0,
                            pAuth->pPassword,
                            pAuth->PasswordLength / sizeof(WCHAR),
                            (PSTR)pCurr,
                            CurrLen,
                            &DefaultChar,
                            NULL
                            );

    ASSERT(BytesCopied <= CurrLen);

    pCurr += BytesCopied;
    CurrLen -= BytesCopied;

    //
    // Now, start generating the auth header.
    //

    pHeader = pBeginHeader = pCurr;

    // The buffer must have space to hold "Basic" string and a SP char.
    if (HTTP_AUTH_BASIC_LENGTH + 1 > CurrLen)
    {
        ASSERT(FALSE);
        return STATUS_BUFFER_TOO_SMALL;
    }

    RtlCopyMemory(pHeader, HTTP_AUTH_BASIC, HTTP_AUTH_BASIC_LENGTH);
    pHeader += HTTP_AUTH_BASIC_LENGTH;
    CurrLen -= HTTP_AUTH_BASIC_LENGTH;

    // Copy SP char.
    *pHeader++ = SP;
    CurrLen--;

    //
    // Generate base64 encoding of usename:password.
    //

    Status = BinaryToBase64(pScratchBuffer,
                            (ULONG)(pBeginHeader - pScratchBuffer),
                            pHeader,
                            CurrLen,
                            &BytesCopied);

    if (!NT_SUCCESS(Status))
    {
        ASSERT(FALSE);
        return Status;
    }

    ASSERT(BytesCopied <= CurrLen);

    pHeader += BytesCopied;
    CurrLen -= BytesCopied;

    //
    // Add a CRLF.
    //

    if (CRLF_SIZE > CurrLen)
    {
        ASSERT(FALSE);
        return STATUS_BUFFER_TOO_SMALL;
    }

    *((UNALIGNED64 USHORT *)pHeader) = CRLF;
    pHeader += CRLF_SIZE;
    CurrLen -= CRLF_SIZE;

    //
    // Now, overwrite the scratch buffer with the generated buffer.
    //

    pInternalAuth->Basic.EncodedBufferLength = (ULONG)(pHeader - pBeginHeader);

    RtlMoveMemory(pInternalAuth->Basic.pEncodedBuffer,
                  pBeginHeader,
                  pInternalAuth->Basic.EncodedBufferLength);

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Generates the authorization header for Digest.

Arguments:

    pInternalAuth        - Pointer to our internal auth structure.
    pAuth                - The HTTP_AUTH_CREDENTIALS structure.
    pRequest             - Internal request.
    pMethod              - The method (GET, POST, etc).
    MethodLength         - Length of the method.
    pOutBuffer           - Pointer to the input/output buffer.
    HeaderID             - HttpHeaderAuthorization or
                           HttpHeaderProxyAuthorization
Return Value:

    STATUS_SUCCESS

--***************************************************************************/
NTSTATUS
UcpGenerateDigestAuthHeader(
    IN  PUC_HTTP_AUTH          pInternalAuth,
    IN  HTTP_HEADER_ID         HeaderID,
    IN  PSTR                   pMethod,
    IN  ULONG                  MethodLength,
    IN  PSTR                   pUri,
    IN  ULONG                  UriLength,
    IN  PUCHAR                 pOutBuffer,
    IN  ULONG                  OutBufferLen,
    OUT PULONG                 pOutBytesTaken
    )
{
    NTSTATUS        Status;
    SECURITY_STATUS SecStatus;

    ULONG         ContextFlagsUsed;
    TimeStamp     LifeTime;
    SecBufferDesc InputBuffers;
    SecBufferDesc OutputBuffers;
    SecBuffer     InputTokens[6];
    SecBuffer     OutputTokens[6];

    SECURITY_STRING Uri;

    PUCHAR        pOutput = pOutBuffer;
    PCHAR         pUnicodeUri = NULL;
    ULONG         UnicodeUriLength;
    LONG          CharsTaken;

    // Sanity check
    PAGED_CODE();
    ASSERT(pInternalAuth);
    ASSERT(pUri && UriLength);
    ASSERT(pMethod && MethodLength);
    ASSERT(pOutBuffer && OutBufferLen);
    ASSERT(pOutBytesTaken);

    // Initialize output arguments.
    *pOutBytesTaken = 0;

    // See if WDigest is supported in kernel
    if (!HttpAuthScheme[HttpAuthTypeDigest].bSupported)
    {
        return STATUS_NOT_SUPPORTED;
    }

    // Do we need to get credentials handle?
    if (pInternalAuth->bValidCredHandle == FALSE)
    {
        Status = UcpAcquireClientCredentialsHandle(
                     HTTP_AUTH_WDIGEST_W,
                     HTTP_AUTH_WDIGEST_W_LENGTH,
                     &pInternalAuth->Credentials,
                     &pInternalAuth->hCredentials
                     );

        if (!NT_SUCCESS(Status))
        {
            goto quit;
        }

        pInternalAuth->bValidCredHandle = TRUE;
    }

    //
    // Digest header format:
    //     [Proxy-]Authorization: Digest SP Auth_Data CRLF
    //
    // Make sure the output buffer has the space to hold all of the above.
    //

    if (UC_HEADER_NAME_SP_LENGTH(HeaderID)           // Header name
        + HTTP_AUTH_DIGEST_LENGTH                    // "Digest" string
        + 1                                          // SP char
        + SSPI_MAX_TOKEN_SIZE(HttpAuthTypeDigest)    // Auth_Data
        + CRLF_SIZE > OutBufferLen)                  // CRLF
    {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto quit;
    }

    // Copy header name
    UC_COPY_HEADER_NAME_SP(pOutput, HeaderID);

    // Copy "Digest" string
    RtlCopyMemory(pOutput, HTTP_AUTH_DIGEST, HTTP_AUTH_DIGEST_LENGTH);
    pOutput += HTTP_AUTH_DIGEST_LENGTH;

    // Followed by a space char
    *pOutput++ = SP;

    //
    // In the worst case, UTF8ToUnicode conversion will take maximum of
    // double the UTF8 string size.
    //
    UnicodeUriLength = UriLength * sizeof(WCHAR);

    pUnicodeUri = UL_ALLOCATE_POOL(PagedPool,
                                   UnicodeUriLength,
                                   UC_SSPI_POOL_TAG);

    if (pUnicodeUri == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto quit;
    }

    ASSERT(UriLength <= ANSI_STRING_MAX_CHAR_LEN);

    CharsTaken = (LONG)UriLength;

    Status = HttpUTF8ToUnicode(pUri,
                               UriLength,
                               (PWSTR)pUnicodeUri,
                               &CharsTaken,
                               TRUE);

    // Because the UTF8 Uri was generated by us, it had better be correct.
    ASSERT(CharsTaken <= (LONG)UriLength);
    ASSERT(Status == STATUS_SUCCESS);

    // Prepare Unicode Uri
    Uri.Buffer        = (PWSTR)pUnicodeUri;
    Uri.Length        = (USHORT)CharsTaken * sizeof(WCHAR);
    Uri.MaximumLength = Uri.Length;

    // Prepare Input buffers
    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers  = 3;
    InputBuffers.pBuffers  = InputTokens;

    //
    // WWW-Authenticate header value
    //

    ASSERT(pInternalAuth->AuthSchemeInfo.Length >= HTTP_AUTH_DIGEST_LENGTH);
    ASSERT(pInternalAuth->AuthSchemeInfo.pScheme);
    ASSERT(_strnicmp(pInternalAuth->AuthSchemeInfo.pScheme,
                     HTTP_AUTH_DIGEST,
                     HTTP_AUTH_DIGEST_LENGTH) == 0);

    InputTokens[0].BufferType = SECBUFFER_TOKEN;
    InputTokens[0].cbBuffer   = pInternalAuth->AuthSchemeInfo.Length -
                                HTTP_AUTH_DIGEST_LENGTH;
    InputTokens[0].pvBuffer   = (PUCHAR)pInternalAuth->AuthSchemeInfo.pScheme +
                                HTTP_AUTH_DIGEST_LENGTH;

    // HTTP Method
    InputTokens[1].BufferType = SECBUFFER_PKG_PARAMS;
    InputTokens[1].cbBuffer   = MethodLength;
    InputTokens[1].pvBuffer   = pMethod;

    // Entity
    InputTokens[2].BufferType = SECBUFFER_PKG_PARAMS;
    InputTokens[2].cbBuffer   = 0;
    InputTokens[2].pvBuffer   = NULL;

    OutputBuffers.ulVersion = SECBUFFER_VERSION;
    OutputBuffers.cBuffers  = 1;
    OutputBuffers.pBuffers  = OutputTokens;

    OutputTokens[0].BufferType = SECBUFFER_TOKEN;
    OutputTokens[0].cbBuffer   = SSPI_MAX_TOKEN_SIZE(HttpAuthTypeDigest);
    OutputTokens[0].pvBuffer   = pOutput;

    // We must have a valid credentials handle at this point
    ASSERT(pInternalAuth->bValidCredHandle);

    // Call SSP

    SecStatus = STATUS_SUCCESS;
    __try
    {
    SecStatus = InitializeSecurityContextW(
                    &pInternalAuth->hCredentials,
                    NULL,
                    &Uri,
                    ISC_REQ_REPLAY_DETECT | ISC_REQ_CONNECTION,
                    0,
                    SECURITY_NATIVE_DREP,
                    &InputBuffers,
                    0,
                    &pInternalAuth->hContext,
                    &OutputBuffers,
                    &ContextFlagsUsed,
                    &LifeTime);
    }
    __except (UL_EXCEPTION_FILTER())
    {
        SecStatus = GetExceptionCode();
    }

    Status = SecStatusToNtStatus(SecStatus);

    if (!NT_SUCCESS(Status))
    {
        goto quit;
    }

    // pInternalAuth has a valid Context handle that must be freed eventually.
    pInternalAuth->bValidCtxtHandle = TRUE;

    // advance the pointer by the amount used
    pOutput += OutputTokens[0].cbBuffer;

    *((UNALIGNED64 USHORT *)pOutput) = CRLF;
    pOutput += CRLF_SIZE;

    ASSERT(pOutput <= pOutBuffer + OutBufferLen);

    *pOutBytesTaken = (ULONG)(pOutput - pOutBuffer);

 quit:
    if (pUnicodeUri)
    {
        UL_FREE_POOL(pUnicodeUri, UC_SSPI_POOL_TAG);
    }
    return Status;
}


/***************************************************************************++

Routine Description:

    Generates the preemptive authorization header for Digest.
    Assumes that there is at least SSPI_MAX_TOKEN_SIZE(HttpAuthTypeDigest)
    space in OutBuffer provided by the caller.

Arguments:

Return Value:

--***************************************************************************/
NTSTATUS
UcpGenerateDigestPreAuthHeader(
    IN  HTTP_HEADER_ID HeaderID,
    IN  PCtxtHandle    phClientContext,
    IN  PSTR           pUri,
    IN  ULONG          UriLength,
    IN  PSTR           pMethod,
    IN  ULONG          MethodLength,
    IN  PUCHAR         pOutBuffer,
    IN  ULONG          OutBufferLen,
    OUT PULONG         pOutBytesTaken
    )
{
    NTSTATUS        Status;
    SECURITY_STATUS SecStatus;

    SecBufferDesc InputBuffers;
    SecBuffer     InputTokens[5];

    PUCHAR        pOutput = pOutBuffer;

    // Sanity check
    PAGED_CODE();
    ASSERT(pUri && UriLength);
    ASSERT(pMethod && MethodLength);
    ASSERT(pOutBuffer && *pOutBuffer);

    // See if WDigest is supported in kernel.
    if (!HttpAuthScheme[HttpAuthTypeDigest].bSupported)
    {
        // Nope!
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Make sure that the output buffer has space to contain the following
    // header:
    //    [Proxy-]Authorization: Digest SP Auth_Data CRLF
    //
    if (UC_HEADER_NAME_SP_LENGTH(HeaderID)
        + HTTP_AUTH_DIGEST_LENGTH
        + 1
        + SSPI_MAX_TOKEN_SIZE(HttpAuthTypeDigest)
        + CRLF_SIZE > OutBufferLen)
    {
        ASSERT(FALSE);
        return STATUS_BUFFER_TOO_SMALL;
    }

    // Copy the header name followed by a ':' to the output
    UC_COPY_HEADER_NAME_SP(pOutput, HeaderID);

    // Copy "Digest" string to the output
    RtlCopyMemory(pOutput, HTTP_AUTH_DIGEST, HTTP_AUTH_DIGEST_LENGTH);
    pOutput += HTTP_AUTH_DIGEST_LENGTH;

    // Copy a SPACE
    *pOutput++ = SP;

    //
    // Prepare SSPI input buffers
    //

    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers  = 5;
    InputBuffers.pBuffers  = InputTokens;

    // No Challenge!
    InputTokens[0].BufferType = SECBUFFER_TOKEN;
    InputTokens[0].cbBuffer   = 0;
    InputTokens[0].pvBuffer   = NULL;

    // HTTP Method
    InputTokens[1].BufferType = SECBUFFER_PKG_PARAMS;
    InputTokens[1].cbBuffer   = MethodLength;
    InputTokens[1].pvBuffer   = pMethod;

    // Uri/Realm
    InputTokens[2].BufferType = SECBUFFER_PKG_PARAMS;
    InputTokens[2].cbBuffer   = UriLength;
    InputTokens[2].pvBuffer   = pUri;

    // Entity
    InputTokens[3].BufferType = SECBUFFER_PKG_PARAMS;
    InputTokens[3].cbBuffer   = 0;
    InputTokens[3].pvBuffer   = NULL;

    // Output
    InputTokens[4].BufferType = SECBUFFER_PKG_PARAMS;
    InputTokens[4].cbBuffer   = SSPI_MAX_TOKEN_SIZE(HttpAuthTypeDigest);
    InputTokens[4].pvBuffer   = pOutput;

    SecStatus = MakeSignature(phClientContext, // Handle to security context
                              0,               // QOP
                              &InputBuffers,   // SecBuffers
                              0);              // sequence # (always 0)

    Status = SecStatusToNtStatus(SecStatus);

    if (!NT_SUCCESS(Status))
    {
        goto quit;
    }

    // Advance the pOutput by the output written by SSPI
    pOutput += InputTokens[4].cbBuffer;

    // Write "\r\n"
    *((UNALIGNED64 USHORT *)pOutput) = CRLF;
    pOutput += CRLF_SIZE;

    ASSERT(pOutput <= pOutBuffer + OutBufferLen);

    // Return the bytes taken.
    *pOutBytesTaken = (ULONG)(pOutput - pOutBuffer);

 quit:

    return Status;
}


/***************************************************************************++

Routine Description:
    Generates the Authorization header for NTLM, Kerberos & Negotiate.

Arguments:

    bServer        - Whether to use server for InitializeSecurityContext
    pSchemeName    - NTLM or Kerberos or Negotiate. Used for generating the
                     Authorization header
    SchemeLength   - Length of scheme
    pSchemeNameW   - Wide char format of scheme name. Used for calling SSPI
                     which expects wide char names.
    SchemeLength   - Length of widechar scheme
    pOutBuffer     - Output buffer. On return contains  the output buffer that
                     is offset by the amount written.
    pAuth          - HTTP_AUTH_CREDENTIALS.
    pInternalAuth  - Pointer to internal Auth structure.
    HeaderID       - HttpHeaderAuthorization or HttpHeaderProxyAuthrorization

Return Value:

    STATUS_NOT_SUPPORTED - Invalid Auth scheme
    SEC_STATUS           - Security SSPI status.

--***************************************************************************/
NTSTATUS
UcpGenerateSSPIAuthHeader(
    IN  PUC_PROCESS_SERVER_INFORMATION pServInfo,
    IN  PUC_HTTP_AUTH                  pInternalAuth,
    IN  HTTP_HEADER_ID                 HeaderID,
    IN  PUCHAR                         pOutBuffer,
    IN  ULONG                          OutBufferLen,
    OUT PULONG                         pOutBytesTaken,
    OUT PBOOLEAN                       bRenegotiate
    )
{
    PUCHAR            pBuffer = pOutBuffer;
    PUCHAR            pBeginning = pOutBuffer;
    ULONG             BufferLen = OutBufferLen;
    ULONG             BytesTaken;
    NTSTATUS          Status;
    HTTP_AUTH_TYPE    AuthType;


    // Sanity check
    PAGED_CODE();

    AuthType = pInternalAuth->Credentials.AuthType;

    // Sanity check.
    ASSERT(AuthType == HttpAuthTypeNTLM     ||
           AuthType == HttpAuthTypeKerberos ||
           AuthType == HttpAuthTypeNegotiate);

    //
    // First, see if the scheme is supported.
    //

    if(!HttpAuthScheme[AuthType].bSupported)
    {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Must have space to store Header name, auth scheme name, SP char.
    //

    if (UC_HEADER_NAME_SP_LENGTH(HeaderID)
        + HttpAuthScheme[AuthType].NameLength
        + 1 > BufferLen)
    {
        ASSERT(FALSE);
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Write out the Authorization: header.
    //

    UC_COPY_HEADER_NAME_SP(pBuffer, HeaderID);
    BufferLen -= UC_HEADER_NAME_SP_LENGTH(HeaderID);

    //
    // Write the auth scheme name.
    //

    RtlCopyMemory(pBuffer,
                  HttpAuthScheme[AuthType].Name,
                  HttpAuthScheme[AuthType].NameLength);

    pBuffer += HttpAuthScheme[AuthType].NameLength;
    BufferLen -= HttpAuthScheme[AuthType].NameLength;

    //
    // Add a SP char.
    //

    *pBuffer++ = ' ';
    BufferLen--;

    //
    // Generate Auth blob.
    //

    // Remember the auth blob pointer.
    pInternalAuth->pRequestAuthBlob = (PUCHAR) pBuffer;

    // BlobMaxLength = {Auth header max length} - {"Header-name:SP" length}
    pInternalAuth->RequestAuthBlobMaxLength = 
        pInternalAuth->RequestAuthHeaderMaxLength
        - (ULONG)(pBuffer - pBeginning);

    Status = UcpGenerateSSPIAuthBlob(pServInfo,
                                     pInternalAuth,
                                     pBuffer,
                                     BufferLen,
                                     &BytesTaken,
                                     bRenegotiate);

    if (NT_SUCCESS(Status))
    {
        ASSERT(BytesTaken <= BufferLen);
        pBuffer += BytesTaken;
        BufferLen -= BytesTaken;
    }

    if (CRLF_SIZE > BufferLen)
    {
        ASSERT(FALSE);
        return STATUS_BUFFER_TOO_SMALL;
    }

    *((UNALIGNED64 USHORT *)pBuffer) = CRLF;
    pBuffer += CRLF_SIZE;

    ASSERT(pBuffer <= pOutBuffer + OutBufferLen);
    *pOutBytesTaken = (ULONG)(pBuffer - pOutBuffer);

    return Status;
}


/***************************************************************************++

Routine Description:

    Computes & Generates the Authorization header

Arguments:

    pServerInfo         - The servinfo structure
    pRequest            - Internal HTTP request
    pAuth               - The Auth config object
    pInternalAuth       - pointer to internal auth
    AuthInternalLength  - Length of Internal Auth
    pBuffer             - Output buffer
    HeaderId            - HttpHeaderAuthorization or HttpHeaderProxyAuth
    pMethod             - The method (required for Digest)
    MethodLength        - Method Length (required for Digest)
    pOutBuffer          - Output buffer (after generating headers)

Return Value:

--***************************************************************************/
NTSTATUS
UcGenerateAuthHeaderFromCredentials(
    IN  PUC_PROCESS_SERVER_INFORMATION pServerInfo,
    IN  PUC_HTTP_AUTH                  pInternalAuth,
    IN  HTTP_HEADER_ID                 HeaderId,
    IN  PSTR                           pMethod,
    IN  ULONG                          MethodLength,
    IN  PSTR                           pUri,
    IN  ULONG                          UriLength,
    IN  PUCHAR                         pOutBuffer,
    IN  ULONG                          OutBufferLen,
    OUT PULONG                         pBytesTaken,
    OUT PBOOLEAN                       bDontFreeMdls
    )
{
    PHTTP_AUTH_CREDENTIALS  pAuth;
    NTSTATUS                Status  = STATUS_SUCCESS;

    // Sanity check
    PAGED_CODE();

    pAuth = &pInternalAuth->Credentials;

    *pBytesTaken = 0;
    *bDontFreeMdls = FALSE;

    switch(pAuth->AuthType)
    {
        case HttpAuthTypeBasic:
        {
            PUCHAR pBuffer = pOutBuffer;

            Status = UcpGenerateBasicHeader(pAuth,
                                            pInternalAuth);

            //
            // Copy it out.
            //

            UC_COPY_HEADER_NAME_SP(pBuffer, HeaderId);

            RtlCopyMemory(pBuffer,
                          pInternalAuth->Basic.pEncodedBuffer,
                          pInternalAuth->Basic.EncodedBufferLength);

            pBuffer += pInternalAuth->Basic.EncodedBufferLength;

            ASSERT(pBuffer <= pOutBuffer + OutBufferLen);
            *pBytesTaken = (ULONG)(pBuffer - pOutBuffer);

            break;
        }

        case HttpAuthTypeDigest:

            Status = UcpGenerateDigestAuthHeader(
                          pInternalAuth,
                          HeaderId,
                          pMethod,
                          MethodLength,
                          pUri,
                          UriLength,
                          pOutBuffer,
                          OutBufferLen,
                          pBytesTaken
                          );

            break;

        case HttpAuthTypeNTLM:
        case HttpAuthTypeNegotiate:
        case HttpAuthTypeKerberos:

            Status = UcpGenerateSSPIAuthHeader(
                        pServerInfo,
                        pInternalAuth,
                        HeaderId,
                        pOutBuffer,
                        OutBufferLen,
                        pBytesTaken,
                        bDontFreeMdls
                        );

            break;

        default:
            ASSERT(FALSE);
            break;
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    Computes & Generates the Authorization header

Arguments:

    pRequest            - Internal HTTP request
    pBuffer             - Output buffer
    pMethod             - The method (required for Digest)
    MethodLength        - Method Length (required for Digest)

Return Value:

--***************************************************************************/
NTSTATUS
UcGenerateProxyAuthHeaderFromCache(
    IN  PUC_HTTP_REQUEST pKeRequest,
    IN  PSTR             pMethod,
    IN  ULONG            MethodLength,
    IN  PUCHAR           pBuffer,
    IN  ULONG            BufferLength,
    OUT PULONG           pBytesTaken
    )
{
    PUC_HTTP_AUTH pInternalAuth;
    NTSTATUS      Status;

    //
    // See if PreAuth is enabled. We cannot check for the
    // pServerInfo->PreAuth flag here. We check for this
    // in the UcpComputeAuthHeaderSize function. If we check
    // for this here, we cannot be sure that this flag was
    // set when we called UcpComputeAuthHeaderSize
    //

    UlAcquirePushLockExclusive(&pKeRequest->pServerInfo->PushLock);

    pInternalAuth = pKeRequest->pServerInfo->pProxyAuthInfo;

    Status = STATUS_SUCCESS;

    if(pInternalAuth)
    {
        Status = UcpGeneratePreAuthHeader(pKeRequest,
                                          pInternalAuth,
                                          HttpHeaderProxyAuthorization,
                                          pMethod,
                                          MethodLength,
                                          pBuffer,
                                          BufferLength,
                                          pBytesTaken);

        if (NT_SUCCESS(Status))
        {
            ASSERT(*pBytesTaken <= BufferLength);
            pBuffer += *pBytesTaken;
        }
    }

    UlReleasePushLock(&pKeRequest->pServerInfo->PushLock);

    return Status;
}


/***************************************************************************++

Routine Description:

    Used to update the Authorization header for NTLM or Kerberos or Negotiate
    This is called when we re-issue the request to complete the challenge-
    response handshake.

Arguments:
    pRequest     - Internal HTTP request.
    bServer      - Whether to pass ServerName when calling SSPI.
    pScheme      - Scheme to pass to SSPI
    SchemeLength - SchemeLength to pass to SSPI
    pAuth        - Internal AUTH structure.

Return Value:
    NTSTATUS     - SSPI return status.

--***************************************************************************/
NTSTATUS
UcpUpdateSSPIAuthHeader(
    IN  PUC_HTTP_REQUEST pRequest,
    IN  PUC_HTTP_AUTH    pAuth,
    OUT PBOOLEAN         bRenegotiate
    )
{
    PUCHAR   pBuffer;
    NTSTATUS Status;
    PMDL     pMdl;
    ULONG    BufferLen;
    ULONG    BytesWritten;

    // Sanity check
    PAGED_CODE();
    ASSERT(pRequest);
    ASSERT(pAuth);
    ASSERT(bRenegotiate);

    //
    // First adjust the HeaderLength.
    //

    pRequest->BytesBuffered -= pRequest->HeaderLength;

    //
    // Call SSPI to get the new blob, based on the old one.
    //

    pBuffer = pAuth->pRequestAuthBlob;
    BufferLen = pAuth->RequestAuthBlobMaxLength;

    Status  = UcpGenerateSSPIAuthBlob(pRequest->pServerInfo,
                                      pAuth,
                                      pBuffer,
                                      BufferLen,
                                      &BytesWritten,
                                      bRenegotiate);

    if(!NT_SUCCESS(Status))
    {
        return Status;
    }

    ASSERT(BytesWritten <= BufferLen);
    pBuffer += BytesWritten;
    BufferLen -= BytesWritten;

    *((UNALIGNED64 USHORT *)pBuffer) = CRLF;
    pBuffer += CRLF_SIZE;

    pRequest->HeaderLength = (ULONG)(pBuffer - pRequest->pHeaders);

    //
    // If there was a content length at the end of the headers,
    // re-generate it.
    //

    if(pRequest->RequestFlags.ContentLengthLast)
    {
        Status = UcGenerateContentLength(pRequest->BytesBuffered,
                                         pRequest->pHeaders
                                         + pRequest->HeaderLength,
                                         pRequest->MaxHeaderLength
                                         - pRequest->HeaderLength,
                                         &BytesWritten);

        ASSERT(Status == STATUS_SUCCESS);

        pRequest->HeaderLength += BytesWritten;
    }

    //
    // Terminate headers with CRLF.
    //

    ((UNALIGNED64 USHORT *)(pRequest->pHeaders +
               pRequest->HeaderLength))[0] = CRLF;
    pRequest->HeaderLength += CRLF_SIZE;

    pRequest->BytesBuffered  += pRequest->HeaderLength;

    //
    // Build a MDL for the headers. Free the old one & re-allocate a
    // new one.
    //
    pMdl = UlAllocateMdl(
                      pRequest->pHeaders,     // VA
                      pRequest->HeaderLength, // Length
                      FALSE,                  // Secondary Buffer
                      FALSE,                  // Charge Quota
                      NULL                    // IRP
                      );

    if(!pMdl)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        MmBuildMdlForNonPagedPool(pMdl);
    }

    pMdl->Next = pRequest->pMdlHead->Next;

    ASSERT(!IS_MDL_LOCKED(pRequest->pMdlHead));

    UlFreeMdl(pRequest->pMdlHead);

    pRequest->pMdlHead = pMdl;

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Used to update the Authorization header. For Digest, this is called when
    we compute the entity hash. For NTLM/Kerberos/Negotiate, this is called
    from the Re-issue request worker thread.

Arguments:
    pRequest     - Internal HTTP request.
    pAuth        - Internal Auth structure (could be for auth or proxy-auth)
    bRenegotiate - Returns whether further renegotiation is needed

Return Value:
    STATUS_NOT_SUPPORTED - Invalid auth scheme
    STATUS_SUCCESS       - success.
    SEC_STATUS_*         - Status returned from SSPI.

--***************************************************************************/
NTSTATUS
UcUpdateAuthorizationHeader(
    IN  PUC_HTTP_REQUEST  pRequest,
    IN  PUC_HTTP_AUTH     pAuth,
    OUT PBOOLEAN          bRenegotiate
    )
{
    NTSTATUS          Status;

    // Sanity check
    PAGED_CODE();
    ASSERT(pRequest);
    ASSERT(pAuth);
    ASSERT(bRenegotiate);

    *bRenegotiate = FALSE;

    if (pAuth->AuthInternalLength == 0)
    {
        return STATUS_SUCCESS;
    }

    switch(pAuth->Credentials.AuthType)
    {
    case HttpAuthTypeNTLM:
    case HttpAuthTypeKerberos:
    case HttpAuthTypeNegotiate:

        Status = UcpUpdateSSPIAuthHeader(pRequest,
                                         pAuth,
                                         bRenegotiate);
        break;

    default:
        Status = STATUS_NOT_SUPPORTED;
        break;
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    Do a longest prefix matching search on the URI auth cache. This routine
    is used to do pre-authentication. An entry will be used only if it's been
    marked valid.

Arguments:

    pServInfo : Pointer to the per-process serv info structure.
    pInputURI : The Input URI
    pOutBuffer: The buffer to which the Authorization header should be written.

Return Value:

    STATUS_SUCCESS   - Found a valid entry in the URI auth cache and wrote a
                       Authorization header

    STATUS_NOT_FOUND - Did not write the authorization header as no matching
                       entry was found.

--***************************************************************************/
NTSTATUS
UcFindURIEntry(
    IN  PUC_PROCESS_SERVER_INFORMATION pServInfo,
    IN  PSTR                           pUri,
    IN  PUC_HTTP_REQUEST               pRequest,
    IN  PSTR                           pMethod,
    IN  ULONG                          MethodLength,
    IN  PUCHAR                         pBuffer,
    IN  ULONG                          BufferSize,
    OUT PULONG                         pBytesTaken
    )
{
    PUC_HTTP_AUTH_CACHE pAuth;
    PLIST_ENTRY         pCurrent;
    NTSTATUS            Status;
    PUCHAR              pStart = pBuffer;
    ULONG               BytesTaken;

    PAGED_CODE();

    *pBytesTaken = 0;

    UlAcquirePushLockExclusive(&pServInfo->PushLock);

    pCurrent = pServInfo->pAuthListHead.Flink;

    while(pCurrent != &pServInfo->pAuthListHead)
    {
        // Retrieve the auth structure from the list entry

        pAuth = CONTAINING_RECORD(
                    pCurrent,
                    UC_HTTP_AUTH_CACHE,
                    Linkage
                    );

        ASSERT(UC_IS_VALID_AUTH_CACHE(pAuth));

        if(pAuth->Valid == TRUE &&
           UcpUriCompareLongest(pUri, pAuth->pUri) != 0)
        {
            // Yes, we found a matching URI. This URI is also the best match
            // because we store these elements in a ordered list, largest
            // one first.

            PUC_HTTP_AUTH pInternalAuth = (PUC_HTTP_AUTH) pAuth->pAuthBlob;

            ASSERT(UC_IS_VALID_HTTP_REQUEST(pRequest));

            Status = UcpGeneratePreAuthHeader(pRequest,
                                              pInternalAuth,
                                              HttpHeaderAuthorization,
                                              pMethod,
                                              MethodLength,
                                              pBuffer,
                                              BufferSize,
                                              &BytesTaken);

            if (NT_SUCCESS(Status))
            {
                ASSERT(BytesTaken <= BufferSize);
                pBuffer += BytesTaken;
            }

            UlReleasePushLock(&pServInfo->PushLock);

            ASSERT(pBuffer <= pStart + BufferSize);
            *pBytesTaken = (ULONG)(pBuffer-pStart);

            UlTrace(AUTH_CACHE,
                    ("[UcFindURIEntry]: Found matching URI (%s:%s) Valid %d\n",
                     pAuth->pUri,
                     pAuth->pRealm,
                     pAuth->Valid)
                    );


            return Status;
        }

        pCurrent = pCurrent->Flink;
    }

    UlReleasePushLock(&pServInfo->PushLock);

    UlTrace(AUTH_CACHE,
            ("[UcFindURIEntry]: No match for URI (%s) \n", pUri));

    return STATUS_NOT_FOUND;
}


VOID
UcDeleteURIEntry(
    IN PUC_PROCESS_SERVER_INFORMATION pInfo,
    IN PUC_HTTP_AUTH_CACHE            pAuth
    )
{
    PLIST_ENTRY         pCurrent;
    PUC_HTTP_AUTH_CACHE pDependAuth;

    if(pAuth->pDependParent)
    {
        pAuth = pAuth->pDependParent;
    }

    ASSERT(pAuth->pDependParent == 0);

    while(!IsListEmpty(&pAuth->pDigestUriList))
    {
        pCurrent = RemoveHeadList(&pAuth->pDigestUriList);

        pDependAuth = CONTAINING_RECORD(
                        pCurrent,
                        UC_HTTP_AUTH_CACHE,
                        DigestLinkage
                        );

        ASSERT(pDependAuth->pDependParent == pAuth);
        ASSERT(pDependAuth->pAuthBlob == pAuth->pAuthBlob);

        UlTrace(AUTH_CACHE,
                ("[UcDeleteURIEntry]: Deleting dependent entry for (%s:%s) \n",
                 pDependAuth->pUri,
                 pDependAuth->pRealm)
                );

        RemoveEntryList(&pDependAuth->Linkage);

        //
        // Depended structures don't have their own AuthBlobs.
        //
        UL_FREE_POOL_WITH_QUOTA(
            pDependAuth, 
            UC_AUTH_CACHE_POOL_TAG,
            NonPagedPool,
            pDependAuth->AuthCacheSize,
            pInfo->pProcess
            );
    }

    if(pAuth->pAuthBlob)
    {
        UcDestroyInternalAuth(pAuth->pAuthBlob, 
                              pInfo->pProcess);
    }

    UlTrace(AUTH_CACHE,
            ("[UcDeleteURIEntry]: Deleting entry for (%s:%s) \n",
             pAuth->pUri,
             pAuth->pRealm)
            );

    RemoveEntryList(&pAuth->Linkage);

    UL_FREE_POOL_WITH_QUOTA(
            pAuth, 
            UC_AUTH_CACHE_POOL_TAG,
            NonPagedPool,
            pAuth->AuthCacheSize,
            pInfo->pProcess
            );
}


/***************************************************************************++

Routine Description:

    Add an entry to the URI cache. This is typically called from the first
    401 that we see for a request.

Arguments:

    pServInfo   - A pointer to the per-process servinfo
    pInputURI   - The input URI
    pInputRealm - The realm.

Return Value:

    STATUS_SUCCESS                - Inserted (or updated an old entry)
    STATUS_INSUFFICIENT_RESOURCES - no memory.

--***************************************************************************/
NTSTATUS
UcAddURIEntry(
    IN HTTP_AUTH_TYPE                 AuthType,
    IN PUC_PROCESS_SERVER_INFORMATION pServInfo,
    IN PCSTR                          pInputURI,
    IN USHORT                         UriLength,
    IN PCSTR                          pInputRealm,
    IN ULONG                          RealmLength,
    IN PCSTR                          pUriList,
    IN ULONG                          UriListLength,
    IN PUC_HTTP_AUTH                  pAuthBlob
    )
{
    PLIST_ENTRY         pCurrent;
    PUC_HTTP_AUTH_CACHE pDeleteBegin, pAuth, pTemp, pNew;
    LONG                Compare;
    PCSTR               pStart;
    NTSTATUS            Status = STATUS_SUCCESS;


    UcpProcessUriForPreAuth((PSTR) pInputURI, &UriLength);

    pDeleteBegin = pAuth = 0;

    //
    // Logically, we store the URI prefixes in a tree. We implement this tree
    // as a length ordered list, with "longest" matches first. So, if the tree
    // was
    //
    //           www.foo.com/abc
    //           /             \
    //          /               \
    //         /                 \
    // www.foo.com/abc/def     www.foo.com/abc/xyz
    //
    // then the list would be
    //
    // www.foo.com/abc/xyz
    // www.foo.com/abc/def
    // www.foo.com/abc
    //

    UlAcquirePushLockExclusive(&pServInfo->PushLock);

    //
    // Scan the list in order and find the slot where we want to insert this
    // URI entry.
    //

    for(pCurrent = pServInfo->pAuthListHead.Flink;
        pCurrent != &pServInfo->pAuthListHead;
        pCurrent = pCurrent->Flink)
    {
        // Retrieve the auth structure from the list entry

        pAuth = CONTAINING_RECORD(
                    pCurrent,
                    UC_HTTP_AUTH_CACHE,
                    Linkage
                    );

        ASSERT(UC_IS_VALID_AUTH_CACHE(pAuth));

        Compare = UcpUriCompareExact(pInputURI, pAuth->pUri);

        if(Compare == 0)
        {
            //
            // We found another instance of the same URI in the cache.
            // We'll keep things simple by nuking this from the cache
            // and by adding it again.
            //

            UlTrace(AUTH_CACHE,
                    ("[UcAddURIEntry]: Found existing entry for %s \n",
                     pInputURI));

            UcDeleteURIEntry(pServInfo, pAuth);

            //
            // Resume the search from the beginning of the list. Potentially
            // we have removed quite a few entries from the list, and we
            // might not have the correct insert point.
            //
            // Note that we'll never get into an infinite loop, since we are
            // do this only after we remove at least one entry. So at some
            // point, the list is going to be empty.
            //

            pCurrent = pServInfo->pAuthListHead.Flink;

            continue;

        }
        else if(Compare > 0)
        {
            //
            // Input URI is greater than current entry. We have reached our
            // insertion point.

            break;
        }
    }

    if((pTemp = UcpAllocateAuthCacheEntry(pServInfo,
                                          AuthType,
                                          UriLength,
                                          RealmLength,
                                          pInputURI,
                                          pInputRealm,
                                          pAuthBlob
                                          )) == 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto quit;
    }

    ASSERT(pAuthBlob->RequestAuthHeaderMaxLength);

    if(pServInfo->GreatestAuthHeaderMaxLength <
           pAuthBlob->RequestAuthHeaderMaxLength)
    {
        pServInfo->GreatestAuthHeaderMaxLength =
            pAuthBlob->RequestAuthHeaderMaxLength;
    }

    if(pCurrent == &pServInfo->pAuthListHead)
    {
        // This could be the first insertion in the list or an insertion
        // at the very end.

        UlTrace(AUTH_CACHE,
                ("[UcAddURIEntry]: Inserting entry for (%s:%s) "
                 "at end of the list (Valid = %d) \n",
                 pTemp->pUri,
                 pTemp->pRealm,
                 pTemp->Valid)
                );

        InsertTailList(&pServInfo->pAuthListHead, &pTemp->Linkage);
    }
    else
    {
        UlTrace(AUTH_CACHE,
                ("[UcAddURIEntry]: Inserting entry for (%s:%s) "
                 "before (%s:%s), Valid = %d \n",
                 pTemp->pUri,
                 pTemp->pRealm,
                 pAuth->pUri,
                 pAuth->pRealm,
                 pAuth->Valid)
                );

        InsertTailList(&pAuth->Linkage, &pTemp->Linkage);
    }

    //
    // Digest AUTH can define a extended URI protection list.
    //
    // Let's assume the request URI was /auth. The server can return a
    // bunch of URIs in the domain list - All these URIs define/extend the
    // protection scope. Now, when we get back a 200 OK for the /auth, we have
    // to go back & validate all the "dependent" URIs.
    //
    // So, maintain a list of dependent URI entries, keyed off the request
    // URI.
    //

    while (UriListLength)
    {
        pStart = pUriList;

        // go to the end of the URI. The URI
        // space terminated or ends in \0

        while (UriListLength && *pUriList != ' ')
        {
            pUriList ++;
            UriListLength --;
        }

        //
        // We need to NULL terminate that URI before we can compare.
        //
        // The pUriList is not necessarily NULL terminated. It's basically
        // a pointer into the WWW-Authenticate header, which is NULL
        // terminated. So, basically, we can be assured that we have a char
        // to accomodate the NULL terminator.
        //

        if (UriListLength)
        {
            ASSERT(*pUriList == ' ');

            *(PSTR)pUriList = '\0';
        }
        else
        {
            ASSERT(*pUriList == '\0');
        }

        UlTrace(AUTH_CACHE,
                ("[UcAddURIEntry]: Adding dependent URI entry %s \n",
                 pStart));

        for(pCurrent = pServInfo->pAuthListHead.Flink;
            pCurrent != &pServInfo->pAuthListHead;
            pCurrent = pCurrent->Flink)
        {
            // Retrieve the auth structure from the list entry

            pAuth = CONTAINING_RECORD(
                        pCurrent,
                        UC_HTTP_AUTH_CACHE,
                        Linkage
                        );

            ASSERT(UC_IS_VALID_AUTH_CACHE(pAuth));

            if(pAuth == pTemp)
                continue;

            Compare = UcpUriCompareExact(pStart, pAuth->pUri);

            if(Compare == 0)
            {
                //
                // We found another instance of the same URI in the list.
                // Too bad, we have to nuke the old entry.
                //

                if(pAuth->pDependParent == pTemp)
                {
                    //
                    // The dependent URI list has duplicates.
                    // Ignore this URI.
                    //
                    UlTrace(AUTH_CACHE,
                            ("[UcAddURIEntry]: URI list has duplicate entries"
                             " for %s (Ignoring) \n", pStart));
                    goto NextURI;
                }

                UlTrace(AUTH_CACHE,
                        ("[UcAddURIEntry]: Found existing entry for %s "
                         " while doing depend insert \n", pStart));

                UcDeleteURIEntry(pServInfo, pAuth);

                pCurrent = pServInfo->pAuthListHead.Flink;

                continue;
            }
            else if(Compare > 0)
            {
                //
                // Input URI is greater than current entry. We have
                // reached our insertion point.

                break;
            }
        }

        if((pNew = UcpAllocateAuthCacheEntry(pServInfo,
                                             AuthType,
                                             (ULONG)(pUriList - pStart),
                                             RealmLength,
                                             pStart,
                                             pInputRealm,
                                             pAuthBlob
                                            )) == 0)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto quit;
        }

        pNew->pDependParent = pTemp;
        ASSERT(pNew->pAuthBlob == pTemp->pAuthBlob);

        InsertTailList(&pTemp->pDigestUriList, &pNew->DigestLinkage);

        if(pCurrent == &pServInfo->pAuthListHead)
        {
            // This could be the first insertion in the list or an
            // insertion at the very end.

            UlTrace(AUTH_CACHE,
                    ("[UcAddURIEntry]: Inserting dependent entry for "
                     " (%s:%s) at end of the list (Valid = %d)\n",
                     pNew->pUri,
                     pNew->pRealm,
                     pNew->Valid)
                    );

            InsertTailList(&pServInfo->pAuthListHead, &pNew->Linkage);
        }
        else
        {
            ASSERT(NULL != pAuth);

            UlTrace(AUTH_CACHE,
                    ("[UcAddURIEntry]: Inserting dependent entry for (%s:%s)"
                     " before (%s:%s) (Valid = %d) \n",
                     pNew->pUri,
                     pNew->pRealm,
                     pAuth->pUri,
                     pAuth->pRealm,
                     pAuth->Valid)
                    );

            InsertTailList(&pAuth->Linkage, &pNew->Linkage);
        }

NextURI:
        * (PSTR) pUriList++ = ' ';
    }

 quit:
    UlReleasePushLock(&pServInfo->PushLock);

    return Status;
}


/***************************************************************************++

Routine Description:

    Process a URI for pre-authentication. We call this just before adding
    an entry in the URI auth cache. This is done to "strip" the last portion
    of the URI

    For e.g. if the request is for /auth/foo/bar.htm, we want to define the
    protection scope as /auth/foo, and hence we have to strip everything from
    the last '/' character.

Arguments:

    pRequest    - The Request. This contains a pointer to the URI

Return Value:

    STATUS_SUCCESS                - Successfully processed

--***************************************************************************/

NTSTATUS
UcpProcessUriForPreAuth(
    IN PSTR    pUri,
    IN PUSHORT UriLength
    )
{
    //
    // the URI MUST be null terminated.
    //
    ASSERT(pUri[*UriLength] == '\0');


    UlTrace(AUTH_CACHE,
            ("[UcpProcessUriForPreAuth]: Before %d:%s ", *UriLength, pUri));


    //
    // walk backward and get rid of everything from the trailing
    // '/'

    // point to the last character.
    (*UriLength) --;

    while(*UriLength != 0 && pUri[*UriLength] != '/')
    {
       (*UriLength)--;
    }


    //
    // Null terminate
    //
    (*UriLength) ++;
    pUri[*UriLength] = '\0';
    (*UriLength) ++;

    UlTrace(AUTH_CACHE, (" After %d:%s \n", *UriLength, pUri));

    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    Allocates an entry for the auth URI cache.

Arguments:

    AuthType     - The auth type (basic/digest)
    UriLength    - Uri Length
    RealmLength  - Realm Length
    pInputURI    - Input URI
    pInputRealm  - Input Realm
    pAuthBlob    - Auth blob

Return Value:
    pointer to the allocated entry.

--***************************************************************************/

PUC_HTTP_AUTH_CACHE
UcpAllocateAuthCacheEntry(
    IN PUC_PROCESS_SERVER_INFORMATION pServInfo,
    IN HTTP_AUTH_TYPE                 AuthType,
    IN ULONG                          UriLength,
    IN ULONG                          RealmLength,
    IN PCSTR                          pInputURI,
    IN PCSTR                          pInputRealm,
    IN PUC_HTTP_AUTH                  pAuthBlob
    )
{

    PUC_HTTP_AUTH_CACHE pAuth;
    ULONG               BytesAllocated;

    BytesAllocated = sizeof(UC_HTTP_AUTH_CACHE) + UriLength +  RealmLength +
                     sizeof(CHAR);

    //
    // UC_BUGBUG (PERF): Use Lookasides
    //

    pAuth = (PUC_HTTP_AUTH_CACHE)
                UL_ALLOCATE_POOL_WITH_QUOTA(
                    NonPagedPool,
                    BytesAllocated,
                    UC_AUTH_CACHE_POOL_TAG,
                    pServInfo->pProcess
                    );

    if(!pAuth)
    {
        return NULL;
    }

    //
    // Initialize
    //

    pAuth->Signature      = UC_AUTH_CACHE_SIGNATURE;
    pAuth->AuthType       = AuthType;
    pAuth->pUri           = (PSTR)((PUCHAR) pAuth + sizeof(UC_HTTP_AUTH_CACHE));
    pAuth->UriLength      = UriLength;
    pAuth->pRealm         = (PSTR)((PUCHAR) pAuth->pUri + pAuth->UriLength);
    pAuth->RealmLength    = RealmLength + sizeof(CHAR);
    pAuth->pAuthBlob      = pAuthBlob;
    pAuth->pDependParent  = 0;
    pAuth->Valid          = (BOOLEAN)(pAuthBlob != 0);
    pAuth->AuthCacheSize  = BytesAllocated;

    InitializeListHead(&pAuth->pDigestUriList);

    //
    // This entry is not on any lists.
    //

    InitializeListHead(&pAuth->DigestLinkage);

    RtlCopyMemory(pAuth->pUri, pInputURI, UriLength);
    RtlCopyMemory(pAuth->pRealm, pInputRealm, RealmLength);
    *((PUCHAR)pAuth->pRealm + RealmLength) = 0;

    return pAuth;
}

/***************************************************************************++

Routine Description:

    Flushes all entries in the URI cache.

Arguments:

    pInfo - The server information

Return Value:
    None

--***************************************************************************/
VOID
UcDeleteAllURIEntries(
    IN PUC_PROCESS_SERVER_INFORMATION pInfo
    )
{
    PLIST_ENTRY         pEntry;
    PUC_HTTP_AUTH_CACHE pAuth;


    UlAcquirePushLockExclusive(&pInfo->PushLock);

    while ( !IsListEmpty(&pInfo->pAuthListHead) )
    {
        pEntry = RemoveHeadList(&pInfo->pAuthListHead);

        pAuth = CONTAINING_RECORD(pEntry, UC_HTTP_AUTH_CACHE, Linkage);

        ASSERT(UC_IS_VALID_AUTH_CACHE(pAuth));

        //
        // Initialize the list entry so that we remove it only once.
        //

        InitializeListHead(&pAuth->Linkage);

        UcDeleteURIEntry(pInfo, pAuth);
    }

    UlReleasePushLock(&pInfo->PushLock);
}

/***************************************************************************++

Routine Description:

    Destroys a UC_HTTP_AUTH structure

Arguments:

    pInternalAuth      - Pointer to UC_HTTP_AUTH structure
    AuthInternalLength - size of buffer
    pProcess           - Process that what charged quota for the structure

Return Value:
    STATUS_SUCCESS

--***************************************************************************/
NTSTATUS
UcDestroyInternalAuth(
    PUC_HTTP_AUTH pUcAuth,
    PEPROCESS     pProcess
    )
{
    NTSTATUS Status;
    ULONG Length = pUcAuth->AuthInternalLength;

    PAGED_CODE();

    if (pUcAuth->bValidCredHandle)
    {
        Status = FreeCredentialsHandle(&pUcAuth->hCredentials);
    }

    if (pUcAuth->bValidCtxtHandle)
    {
        Status = DeleteSecurityContext(&pUcAuth->hContext);
    }


    UL_FREE_POOL_WITH_QUOTA(pUcAuth,
                            UC_AUTH_CACHE_POOL_TAG,
                            NonPagedPool,
                            Length,
                            pProcess);

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Creates a UC_HTTP_AUTH structure from the HTTP_AUTH_CREDENTIALS structure

Arguments:

    pInternalAuth      - Pointer to UC_HTTP_AUTH
    AuthInternalLength - size of buffer
    pAuth              - The HTTP_AUTH_CREDENTIALS structure.

Return Value:
    STATUS_SUCCESS

--***************************************************************************/
NTSTATUS
UcCopyAuthCredentialsToInternal(
    IN  PUC_HTTP_AUTH            pInternalAuth,
    IN  ULONG                    AuthInternalLength,
    IN  HTTP_AUTH_TYPE           AuthInternalType,
    IN  PHTTP_AUTH_CREDENTIALS   pAuth,
    IN  ULONG                    AuthHeaderLength
    )
{
    PHTTP_AUTH_CREDENTIALS  pIAuth;
    PUCHAR                  pInput;
    HTTP_AUTH_PARSED_PARAMS AuthParsedParams[HttpAuthTypesCount];
    NTSTATUS                Status;

    // Sanity check
    PAGED_CODE();
    ASSERT(pInternalAuth && AuthInternalLength);
    ASSERT(pAuth);

    pIAuth        = &pInternalAuth->Credentials;
    pInput        = (PUCHAR)(pInternalAuth + 1);

    pIAuth->AuthType = pAuth->AuthType;
    pIAuth->AuthFlags = pIAuth->AuthFlags;
    pInternalAuth->AuthInternalLength = AuthInternalLength;
    pInternalAuth->RequestAuthHeaderMaxLength = AuthHeaderLength;

    //
    // Now, copy out the pointers.
    //

    if(pAuth->UserNameLength)
    {
        pIAuth->pUserName = (PWSTR) pInput;
        pIAuth->UserNameLength = pAuth->UserNameLength;
        pInput += pIAuth->UserNameLength;

        RtlCopyMemory((PWSTR) pIAuth->pUserName,
                      pAuth->pUserName,
                      pIAuth->UserNameLength);
    }

    // password

    if(pAuth->PasswordLength)
    {
        pIAuth->PasswordLength = pAuth->PasswordLength;
        pIAuth->pPassword = (PWSTR) pInput;
        pInput += pIAuth->PasswordLength;

        RtlCopyMemory((PWSTR) pIAuth->pPassword,
                      pAuth->pPassword,
                      pIAuth->PasswordLength);
    }

    //domain

    if(pAuth->DomainLength)
    {
        pIAuth->DomainLength = pAuth->DomainLength;
        pIAuth->pDomain = (PWSTR) pInput;
        pInput += pIAuth->DomainLength;

        RtlCopyMemory((PWSTR) pIAuth->pDomain,
                      pAuth->pDomain,
                      pIAuth->DomainLength);
    }


    // If the user wants us to select an authentication type
    if (pIAuth->AuthType == HttpAuthTypeAutoSelect)
    {
        // See if we already determined an auth type before
        pIAuth->AuthType = AuthInternalType;

        if (pIAuth->AuthType == HttpAuthTypeAutoSelect)
        {
            // Select an auth type
            pIAuth->AuthType = UcpAutoSelectAuthType(pAuth);

            // If no auth type found, return error
            if (pIAuth->AuthType == HttpAuthTypeAutoSelect)
            {
                return STATUS_INVALID_PARAMETER;
            }
        }
    }

    // Ideally we want to check here to make sure that the header passed by
    // the app (i.e the Www-Authenticate header returned by the server)
    // matches the selected AUTH scheme. However, we will do  this strict
    // verification only if we are going to this header. The only scheme that
    // currently uses the header is Digest.

    //
    // If it's basic or Digest, we need to do some additional work.
    //

    if(pIAuth->AuthType == HttpAuthTypeBasic)
    {
        pInternalAuth->Basic.pEncodedBuffer      = pInput;
        pInternalAuth->Basic.EncodedBufferLength =
                AuthInternalLength -
                  (ULONG)(pInput - (PUCHAR)pInternalAuth);

    }
    else  // Other schemes (Supported by SSPI)
    {
        pInternalAuth->bValidCredHandle = FALSE;
        pInternalAuth->bValidCtxtHandle = FALSE;

        RtlZeroMemory(&pInternalAuth->hCredentials,
                      sizeof(pInternalAuth->hCredentials));

        RtlZeroMemory(&pInternalAuth->hContext,
                      sizeof(pInternalAuth->hContext));

        pInternalAuth->pChallengeBuffer       = pInput;
        pInternalAuth->ChallengeBufferSize    = 0;
        pInternalAuth->ChallengeBufferMaxSize = 
               (ULONG)(AuthInternalLength - (pInput - (PUCHAR) pInternalAuth));

        ASSERT(pInternalAuth->pChallengeBuffer && 
                    pInternalAuth->ChallengeBufferMaxSize);

        // If the scheme is digest, do the additional work
        // - Copy WWW-Authenticate header
        // - Parse the header
        // - Get pointers to the parameter values
        // - Get pointer to the header where "Digest" key word begins
        // - Get Length of the digest header 

        if(pIAuth->AuthType == HttpAuthTypeDigest)
        {
            if(pAuth->HeaderValueLength == 0 || pAuth->pHeaderValue == NULL)
            {
                return STATUS_INVALID_PARAMETER;
            }

            pIAuth->HeaderValueLength = pAuth->HeaderValueLength;
            pIAuth->pHeaderValue = (PCSTR)pInput;
            pInput += pIAuth->HeaderValueLength;

            RtlCopyMemory((PUCHAR) pIAuth->pHeaderValue,
                          pAuth->pHeaderValue,
                          pIAuth->HeaderValueLength);

            // NULL terminate.
            *pInput ++ = '\0';
            pIAuth->HeaderValueLength++;

            //
            // We are interested in getting Digest parameters.
            // Initialize AuthParsedParams for Digest scheme.
            // The parsed parameters for digest scheme will be
            // returned in pInternalAuth->ParamValue.
            //

            INIT_AUTH_PARSED_PARAMS(AuthParsedParams, NULL);
            INIT_AUTH_PARSED_PARAMS_FOR_SCHEME(AuthParsedParams,
                                               pInternalAuth->ParamValue,
                                               HttpAuthTypeDigest);

            // Parse the header value
            Status = UcParseWWWAuthenticateHeader(
                         pIAuth->pHeaderValue,
                         pIAuth->HeaderValueLength-1, // ignore '\0'
                         AuthParsedParams);

            if (!NT_SUCCESS(Status))
            {
                return Status;
            }

            //
            // See if Digest scheme was present in the header.  Without, it
            // we can't do digest auth.
            //

            if (AuthParsedParams[HttpAuthTypeDigest].bPresent == FALSE)
            {
                return STATUS_INVALID_PARAMETER;
            }

            // Copy digest scheme info to internal auth structure
            RtlCopyMemory(&pInternalAuth->AuthSchemeInfo,
                          &AuthParsedParams[HttpAuthTypeDigest],
                          sizeof(pInternalAuth->AuthSchemeInfo));
        }
    }

    return STATUS_SUCCESS;
}


/**************************************************************************++

Routine Description:

    This is a helper routine that processes parsed parameters for the
    authentication schemes NTLM, Kerberos, Negotiate.

Arguments:

    pRequest         - Request for which the response was received.
    pInternalAuth    - Internal Auth Structure.
    AuthParsedParams - Parsed Parameters for the auth scheme.
    AuthType         - Authentication scheme.

Return Values:

    None.

--**************************************************************************/
__inline
NTSTATUS
UcpProcessAuthParams(
    IN PUC_HTTP_REQUEST         pRequest,
    IN PUC_HTTP_AUTH            pInternalAuth,
    IN PHTTP_AUTH_PARSED_PARAMS AuthParsedParams,
    IN HTTP_AUTH_TYPE           AuthType
    )
{
    NTSTATUS Status;
    ULONG    Base64Length;
    ULONG    BinaryLength;

    //
    // The assumption here is that, if the www-authenticate header
    // contains a scheme that has an auth blob, it must be the only
    // scheme specified in the header
    //

    if (pRequest->Renegotiate)
    {
        UlTrace(PARSER,
                ("[UcpProcessAuthParams]: Bogus "
                 " Auth blob for %d auth type renegotiate \n", AuthType));
        return STATUS_INVALID_NETWORK_RESPONSE;
    }

    //
    // If auth blob was present, process it.
    //

    if(AuthParsedParams[AuthType].NumberUnknownParams == 1)
    {
        if(!pInternalAuth)
        {
            UlTrace(PARSER,
                    ("[UcpProcessAuthParams]: Bogus "
                     " %d Renegotiate \n", AuthType));
            return STATUS_INVALID_NETWORK_RESPONSE;
        }

        //
        // We have a 401 challenge that we have to re-negotiate.
        // The challenge is UUEncoded, so we have to decode it
        // and store it.
        //

        //
        // First see if we have enough buffer space to copy the auth blob
        //

        Base64Length = AuthParsedParams[AuthType].Params[0].Length;

        Status = Base64ToBinaryLength(Base64Length, &BinaryLength);

        if (!NT_SUCCESS(Status))
        {
            UlTrace(PARSER,
                    ("[UcpProcessAuthParams]:Auth type %d blob invalid len %d",
                    AuthType, Base64Length));
            return STATUS_INVALID_NETWORK_RESPONSE;
        }

        if (BinaryLength > pInternalAuth->ChallengeBufferMaxSize)
        {
            UlTrace(PARSER,
                    ("[UcpProcessAuthParams]: Auth type %d blob too big %d",
                    AuthType, BinaryLength));
            return STATUS_INVALID_NETWORK_RESPONSE;
        }

        Status = Base64ToBinary(
                     (PUCHAR)AuthParsedParams[AuthType].Params[0].Value,
                     (ULONG)AuthParsedParams[AuthType].Params[0].Length,
                     (PUCHAR)pInternalAuth->pChallengeBuffer,
                     pInternalAuth->ChallengeBufferMaxSize,
                     &pInternalAuth->ChallengeBufferSize
                     );

        if (!NT_SUCCESS(Status))
        {
            UlTrace(PARSER,
                    ("[UcpProcessAuthParams]: Base64ToBinary failed 0x%x",
                    Status));
            return Status;
        }

        pRequest->Renegotiate = 1;
    }
    else if(AuthParsedParams[AuthType].NumberUnknownParams == 0)
    {
        pRequest->Renegotiate = 0;
    }
    else
    {
        return STATUS_INVALID_NETWORK_RESPONSE;
    }

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    This routine is called from the response thread of a 401 or a 407.
    All we do here is to find out if it's NTLM or Kerberos or Negotiate,
    and if so, whether we have to re-negotiate.

Arguments:

    pInternalAuth      - Pointer to UC_HTTP_AUTH
    pBuffer            - Pointer to header value. Guaranteed to be NULL
                         terminated.
    pRequest           - The UC_HTTP_REQUEST structure.

Return Value:
    STATUS_SUCCESS

--***************************************************************************/
NTSTATUS
UcParseAuthChallenge(
    IN  PUC_HTTP_AUTH     pInternalAuth,
    IN  PCSTR             pBuffer,
    IN  ULONG             BufLen,
    IN  PUC_HTTP_REQUEST  pRequest,
    OUT PULONG            Flags
    )
{
    ULONG                   AuthSchemeFlags = 0;
    HTTP_AUTH_PARSED_PARAMS AuthParsedParams[HttpAuthTypesCount];
    HTTP_AUTH_PARAM_VALUE   AuthNTLMParamValue;
    HTTP_AUTH_PARAM_VALUE   AuthKerberosParamValue;
    HTTP_AUTH_PARAM_VALUE   AuthNegotiateParamValue;
    NTSTATUS                Status;

    // Sanity check
    ASSERT(pBuffer && BufLen);
    ASSERT(pRequest);
    ASSERT(Flags);

    // By default, no renegotiation needed for this request.
    pRequest->Renegotiate = 0;

    // Zero out parsed params array
    INIT_AUTH_PARSED_PARAMS(AuthParsedParams, NULL);

    // We are interested in NTLM, Negotiate, Kerberos parameters.
    INIT_AUTH_PARSED_PARAMS_FOR_SCHEME(AuthParsedParams,
                                       &AuthNTLMParamValue,
                                       HttpAuthTypeNTLM);
    INIT_AUTH_PARSED_PARAMS_FOR_SCHEME(AuthParsedParams,
                                       &AuthNegotiateParamValue,
                                       HttpAuthTypeNegotiate);
    INIT_AUTH_PARSED_PARAMS_FOR_SCHEME(AuthParsedParams,
                                       &AuthKerberosParamValue,
                                       HttpAuthTypeKerberos);

    // Parse the header and retrive the parameters
    Status = UcParseWWWAuthenticateHeader(pBuffer,
                                          BufLen,
                                          AuthParsedParams);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    // Check if Basic authentication scheme is supported
    if (AuthParsedParams[HttpAuthTypeBasic].bPresent)
    {
        // Yes.  We don't parse the parameters now.  Just update the flag.
        AuthSchemeFlags |= HTTP_RESPONSE_FLAG_AUTH_BASIC;
    }

    // Check if Digest authentication scheme is supported
    if(AuthParsedParams[HttpAuthTypeDigest].bPresent)
    {
        // Yes.  We don't parse the parameters now.  Just update the flag.
        AuthSchemeFlags |= HTTP_RESPONSE_FLAG_AUTH_DIGEST;
    }

    //
    // Check if any of NTLM, Kerberos, Negotiate authentication schemes
    // are present.  If an auth scheme is present, update the flag.
    // If the auth scheme has an auth blob, copy the auth blob to
    // internal structure.
    // In any case, AT MOST one scheme should have an auth blob.
    //

    if(AuthParsedParams[HttpAuthTypeNTLM].bPresent)
    {
        Status = UcpProcessAuthParams(pRequest,
                                    pInternalAuth,
                                    AuthParsedParams,
                                    HttpAuthTypeNTLM);

        if (!NT_SUCCESS(Status))
        {
            return Status;
        }

        AuthSchemeFlags |= HTTP_RESPONSE_FLAG_AUTH_NTLM;
    }

    if(AuthParsedParams[HttpAuthTypeNegotiate].bPresent)
    {
        Status = UcpProcessAuthParams(pRequest,
                                      pInternalAuth,
                                      AuthParsedParams,
                                      HttpAuthTypeNegotiate);

        if (!NT_SUCCESS(Status))
        {
            return Status;
        }

        AuthSchemeFlags |= HTTP_RESPONSE_FLAG_AUTH_NEGOTIATE;
    }

    if(AuthParsedParams[HttpAuthTypeKerberos].bPresent)
    {
        Status = UcpProcessAuthParams(pRequest,
                                      pInternalAuth,
                                      AuthParsedParams,
                                      HttpAuthTypeKerberos);

        if (!NT_SUCCESS(Status))
        {
            return Status;
        }

        AuthSchemeFlags |= HTTP_RESPONSE_FLAG_AUTH_KERBEROS;
    }

    *Flags |= AuthSchemeFlags;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ucrcv.h ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    ucrcv.h

Abstract:

    This file contains the header defintions for the HTTP.SYS receive interface
    code.

Author:

    Rajesh Sundaram (rajeshsu)

Revision History:

--*/


#ifndef _UCRCV_H_
#define _UCRCV_H_

typedef enum _UC_DATACHUNK_RETURN
{
    UcDataChunkCopyPartial = 1,
    UcDataChunkCopyAll,
    UcDataChunkCopyMax
} UC_DATACHUNK_RETURN;

NTSTATUS
UcpCarveDataChunk(
    IN PHTTP_RESPONSE   pResponse,
    IN PUC_HTTP_REQUEST pRequest,
    IN PUCHAR           pIndication,
    IN ULONG            BytesIndicated,
    IN ULONG            AlignLength
    );

UC_DATACHUNK_RETURN
UcpCopyEntityToDataChunk(
    IN  PHTTP_RESPONSE   pResponse,
    IN  PUC_HTTP_REQUEST pRequest,
    IN  ULONG            BytesToTake,
    IN  ULONG            BytesIndicated,
    IN  PUCHAR           pIndication,
    OUT PULONG           pBytesTaken
    );


VOID
UcpCompleteReceiveResponseIrp(
    IN PUC_HTTP_REQUEST pRequest,
    IN KIRQL            OldIrql
    );

VOID
UcpCopyHttpResponseHeaders(
    PHTTP_RESPONSE pNewResponse,
    PHTTP_RESPONSE pOldResponse,
    PUCHAR        *ppBufferHead,
    PUCHAR        *ppBufferTail
    );

NTSTATUS
UcpExpandResponseBuffer(
    IN PUC_HTTP_REQUEST pRequest,
    IN ULONG            BytesIndicated,
    IN ULONG            ResponseBufferFlags
    );

NTSTATUS
UcpGetResponseBuffer(
    IN   PUC_HTTP_REQUEST pRequest,
    IN   ULONG            BytesIndicated,
    IN   ULONG            ResponseBufferFlags
    );

VOID
UcpMergeIndications(
    IN  PUC_CLIENT_CONNECTION pConnection,
    IN  PUCHAR                pIndication,
    IN  ULONG                 BytesIndicated,
    OUT PUCHAR                Indication[2],
    OUT ULONG                 IndicationLength[2],
    OUT PULONG                IndicationCount
    );

NTSTATUS
UcpParseHttpResponse(
    PUC_HTTP_REQUEST pRequest,
    PUCHAR           pIndicatedBuffer,
    ULONG            BytesIndicated,
    PULONG           BytesTaken
    );

NTSTATUS
UcHandleResponse(
        IN  PVOID  pListeningContext,
        IN  PVOID  pConnectionContext,
        IN  PVOID  pIndicatedBuffer,
        IN  ULONG  BytesIndicated,
        IN  ULONG  UnreceivedLength,
        OUT PULONG pBytesTaken
        );

VOID
UcpHandleConnectVerbFailure(
    IN  PUC_CLIENT_CONNECTION pConnection,
    OUT PUCHAR               *pIndication,
    OUT PULONG                BytesIndicated,
    IN  ULONG                 BytesTaken
    );

VOID
UcpHandleParsedRequest(
    IN  PUC_HTTP_REQUEST pRequest,
    OUT PUCHAR           *pIndication,
    OUT PULONG            BytesIndicated,
    IN  ULONG             BytesTaken
    );

BOOLEAN
UcpReferenceForReceive(
    IN PUC_HTTP_REQUEST pRequest
    );

VOID
UcpDereferenceForReceive(
    IN PUC_HTTP_REQUEST pRequest
    );

#endif  // _UCRCV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\uctdi.h ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    uctdi.h

Abstract:

    This file contains the header defintions for the HTTP.SYS TDI interface
    code.

Author:

    Henry Sanders (henrysa)         07-Aug-2000

Revision History:

--*/


#ifndef _UCTDI_H_
#define _UCTDI_H_


//
// Forward references.
//
typedef struct _UC_CLIENT_CONNECTION *PUC_CLIENT_CONNECTION;
typedef union _UC_CONNECTION_FLAGS UC_CONNECTION_FLAGS;



//
// Private constants.
//

//
// Private types.
//
//

NTSTATUS
UcCloseConnection(
    IN PVOID                  pConnectionContext,
    IN BOOLEAN                AbortiveDisconnect,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID                  pCompletionContext,
    IN NTSTATUS               Status
    );

NTSTATUS
UcpRestartSendData(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp,
    IN PVOID          pContext
    );

NTSTATUS
UcpBeginAbort(
    IN PUC_CLIENT_CONNECTION pConnection,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UcpBeginDisconnect(
    IN PUC_CLIENT_CONNECTION pConnection,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UcpRestartAbort(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp,
    IN PVOID          pContext
    );

NTSTATUS
UcpRestartDisconnect(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

NTSTATUS
UcpConnectComplete(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp,
    PVOID           Context
    );

NTSTATUS
UcpSendRequestComplete(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp,
    PVOID           Context
    );

NTSTATUS
UcpTdiReceiveHandler(
    IN  PVOID              pTdiEventContext,
    IN  CONNECTION_CONTEXT ConnectionContext,
    IN  ULONG              ReceiveFlags,
    IN  ULONG              BytesIndicated,
    IN  ULONG              BytesAvailable,
    OUT ULONG             *pBytesTaken,
    IN  PVOID              pTsdu,
    OUT PIRP              *pIrp
    );

NTSTATUS
UcpTdiDisconnectHandler(
    IN PVOID              pTdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN LONG               DisconnectDataLength,
    IN PVOID              pDisconnectData,
    IN LONG               DisconnectInformationLength,
    IN PVOID              pDisconnectInformation,
    IN ULONG              DisconnectFlags
    );


PIRP
UcpCreateDisconnectIrp(
    IN PUX_TDI_OBJECT         pTdiObject,
    IN ULONG_PTR              Flags,
    IN PIO_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID                  pCompletionContext
    );

NTSTATUS
UcpCloseRawConnection(
    IN PVOID                     pConn,
    IN BOOLEAN                   Abortive,
    IN PUL_COMPLETION_ROUTINE    pCompletionRoutine,
    IN PVOID                     pCompletionContext);

NTSTATUS
UcCloseRawFilterConnection(
    IN PVOID                     pConn,
    IN BOOLEAN                   Abortive,
    IN PUL_COMPLETION_ROUTINE    pCompletionRoutine,
    IN PVOID                     pCompletionContext
    );

VOID
UcDisconnectRawFilterConnection(
    IN PVOID pConnectionContext
    );

NTSTATUS
UcpSendRawData(
    IN PVOID                 pConnectionContext,
    IN PMDL                  pMdlChain,
    IN ULONG                 Length,
    IN PUL_IRP_CONTEXT       pIrpContext,
    IN BOOLEAN               InitiateDisconnect
    );

NTSTATUS
UcpReceiveRawData(
    IN PVOID                  pConnectionContext,
    IN PVOID                  pBuffer,
    IN ULONG                  BufferLength,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID                  pCompletionContext
    );

NTSTATUS
UcpRestartReceive(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

NTSTATUS
UcpRestartClientReceive(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

//
// Public Prototypes
//

ULONG
UcSetFlag(
    IN OUT  PLONG ConnFlag,
    IN      LONG  NewFlag
    );

NTSTATUS
UcClientConnect(
    IN PUC_CLIENT_CONNECTION     pConnection,
    IN PIRP                      pIrp
    );

NTSTATUS
UcSendData(
    IN PUC_CLIENT_CONNECTION     pConnection,
    IN PMDL                      pMdlChain,
    IN ULONG                     Length,
    IN PUL_COMPLETION_ROUTINE    pCompletionRoutine,
    IN PVOID                     pCompletionContext,
    IN PIRP                      pIrp,
    IN BOOLEAN                   RawSend
    );

NTSTATUS
UcReceiveData(
    IN PVOID                  pConnectionContext,
    IN PVOID                  pBuffer,
    IN ULONG                  BufferLength,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID                  pCompletionContext
    );

NTSTATUS
UcpBuildTdiReceiveBuffer(
    IN PUX_TDI_OBJECT        pTdiObject,
    IN PUC_CLIENT_CONNECTION pConnection,
    OUT PIRP *pIrp
    );

NTSTATUS
UcpReceiveExpeditedHandler(
    IN PVOID pTdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *pBytesTaken,
    IN PVOID pTsdu,
    OUT PIRP *pIrp
    );




#endif  // _UCTDI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\uctrace.h ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    uctrace.h

Abstract:

    This module contains public declarations and definitions for tracing
    and debugging client code.

Author:

    Rajesh Sundaram (rajeshsu) - 17th July 2001.

Revision History:

--*/


#ifndef _UC_TRACE_H_   

#define _UC_TRACE_H_


//
// This defines the entry written to the trace log.
//

typedef struct _UC_TRACE_LOG_ENTRY
{
    USHORT                  Action;
    USHORT                  Processor;
    PEPROCESS               pProcess;
    PETHREAD                pThread;

    PVOID                   pContext1;
    PVOID                   pContext2;
    PVOID                   pContext3;
    PVOID                   pContext4;

    PVOID                   pFileName;
    USHORT                  LineNumber;

} UC_TRACE_LOG_ENTRY, *PUC_TRACE_LOG_ENTRY;


//
// Action codes.
//
// N.B. These codes must be contiguous, starting at zero. If you update
//      this list, you must also update the corresponding array in
//      ul\ulkd\filt.c.
//



#define UC_TRACE_LOG_SIGNATURE   MAKE_SIGNATURE('UcLg')

//
// Manipulators.
//

PTRACE_LOG
UcCreateTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    );

VOID
UcDestroyTraceLog(
    IN PTRACE_LOG pLog
    );

VOID
UcWriteTraceLog(
    IN PTRACE_LOG pLog,
    IN USHORT Action,
    IN PVOID                  pContext1,
    IN PVOID                  pContext2,
    IN PVOID                  pContext3,
    IN PVOID                  pContext4,
    IN PVOID                  pFileName,
    IN USHORT                 LineNumber
    );

#if DBG

#define CREATE_UC_TRACE_LOG( ptr, size, extra )                          \
    (ptr) = UcCreateTraceLog( (size), (extra) )

#define DESTROY_UC_TRACE_LOG( ptr )                                      \
    do                                                                   \
    {                                                                    \
        UcDestroyTraceLog( ptr );                                        \
        (ptr) = NULL;                                                    \
    } while (FALSE, FALSE)

#define UC_WRITE_TRACE_LOG( log, act, pcon, preq, pirp, status)        \
    UcWriteTraceLog(                                                   \
        (log),                                                         \
        (act),                                                         \
        (PVOID)(pcon),                                                 \
        (PVOID)(preq),                                                 \
        (PVOID)(pirp),                                                 \
        (PVOID)(status),                                               \
        __FILE__,                                                      \
        __LINE__                                                       \
        )

#else // !DBG

#define CREATE_UC_TRACE_LOG( ptr, size, extra )                     NOP_FUNCTION
#define DESTROY_UC_TRACE_LOG( ptr )                                 NOP_FUNCTION
#define UC_WRITE_TRACE_LOG( log, act, pcon, preq, pirp, status)     NOP_FUNCTION

#endif // !DBG


#endif  // _UC_TRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\uletw.c ===
/*++

Copyright (c) 2001-2002 Microsoft Corporation

Module Name:

    uletw.c

Abstract:

    This module contains code for WDM WMI Irps and wrapper functions
    to send trace events to ETW.

Author:

    Melur Raghuraman (mraghu)  14-Feb-2001

Revision History:

--*/
#include "precomp.h"
#include "uletwp.h"

//
// Private globals.
//
LONG        g_UlEtwTraceEnable = 0;
TRACEHANDLE g_UlEtwLoggerHandle = 0;


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, UlEtwInitLog )
#pragma alloc_text( PAGE, UlEtwUnRegisterLog )
#pragma alloc_text( PAGE, UlEtwRegisterGuids )
#pragma alloc_text( PAGE, UlEtwEnableLog )
#pragma alloc_text( PAGE, UlEtwDisableLog )
#pragma alloc_text( PAGE, UlEtwDispatch )
#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlEtwTraceEvent
NOT PAGEABLE -- UlEtwGetTraceEnableFlags
#endif

//
// Public functions.
//


//
// Private functions.
//


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    This is the routine in which we call IoWMIRegistrationControl to 
    register for ETW logging.

Arguments:

    pDeviceObject - Supplies a pointer to the target device object.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlEtwInitLog(
    IN PDEVICE_OBJECT pDeviceObject
    )
{
    NTSTATUS status;

    //
    // Register wtih ETW
    //
    status = IoWMIRegistrationControl(pDeviceObject, WMIREG_ACTION_REGISTER);

    if (!NT_SUCCESS(status)) 
    {
        UlTrace(ETW, (
            "UlEtwInitLog: IoWMIRegistrationControl failed with %x\n",
             status
            ));
    }
    return status;
}



/***************************************************************************++

Routine Description:

    This is the routine in which we call IoWMIRegistrationControl to
    Unregister from ETW logging.

Arguments:

    pDeviceObject - Supplies a pointer to the target device object.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlEtwUnRegisterLog(
    IN PDEVICE_OBJECT pDeviceObject
    )
{
    NTSTATUS status;
    //
    // Register with ETW.
    //
    status = IoWMIRegistrationControl(pDeviceObject,
                                      WMIREG_ACTION_DEREGISTER);
    if (!NT_SUCCESS(status))
    {
        UlTrace(ETW, (
            "UlEtwUnRegisterLog: Failed to unregister for ETW support\n"
            ));
    }
    return status;
}


/***************************************************************************++

Routine Description:

    This function handles ETW GUID registration. 

Arguments:
    EtwRegInfo
    etwRegInfoSize,
    pReturnSize


Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlEtwRegisterGuids(
    IN PWMIREGINFO  EtwRegInfo,
    IN ULONG        etwRegInfoSize,
    IN PULONG       pReturnSize
    )
{
    //
    // Register a Control Guid as a Trace Guid.
    //

    ULONG           SizeNeeded;
    PWMIREGGUIDW    EtwRegGuidPtr;
    ULONG           GuidCount;
    ULONG           RegistryPathSize;
    ULONG           MofResourceSize;
    PUCHAR          ptmp;

    #if DBG
    GUID UlTestGuid = {0xdd5ef90a, 0x6398, 0x47a4, 0xad, 0x34, 0x4d, 0xce, 0xcd, 0xef, 0x79, 0x5f};
    ASSERT(IsEqualGUID(&UlControlGuid, &UlTestGuid));
    #endif

    *pReturnSize = 0;
    GuidCount = 1;

    //
    // Allocate WMIREGINFO for controlGuid + GuidCount.
    //
    RegistryPathSize = sizeof(REGISTRY_UL_INFORMATION) - sizeof(WCHAR) + sizeof(USHORT);
    MofResourceSize =  sizeof(UL_TRACE_MOF_FILE) - sizeof(WCHAR) + sizeof(USHORT);
    SizeNeeded = sizeof(WMIREGINFOW) + GuidCount * sizeof(WMIREGGUIDW) +
                 RegistryPathSize +
                 MofResourceSize;

    if (SizeNeeded  > etwRegInfoSize) {
        *((PULONG)EtwRegInfo) = SizeNeeded;
        *pReturnSize = sizeof(ULONG);
        return STATUS_BUFFER_TOO_SMALL;
    }


    RtlZeroMemory(EtwRegInfo, SizeNeeded);
    EtwRegInfo->BufferSize = SizeNeeded;
    EtwRegInfo->GuidCount = GuidCount;
    EtwRegInfo->RegistryPath = sizeof(WMIREGINFOW) + GuidCount * sizeof(WMIREGGUIDW);
    EtwRegInfo->MofResourceName = EtwRegInfo->RegistryPath + RegistryPathSize;
    EtwRegGuidPtr = &EtwRegInfo->WmiRegGuid[0];
    EtwRegGuidPtr->Guid = UlControlGuid;
    EtwRegGuidPtr->Flags |= WMIREG_FLAG_TRACED_GUID;
    EtwRegGuidPtr->Flags |= WMIREG_FLAG_TRACE_CONTROL_GUID;
    EtwRegGuidPtr->InstanceCount = 0;
    EtwRegGuidPtr->InstanceInfo = 0;

    ptmp = (PUCHAR)&EtwRegInfo->WmiRegGuid[1];
    *((PUSHORT)ptmp) = sizeof(REGISTRY_UL_INFORMATION) - sizeof(WCHAR);
    ptmp += sizeof(USHORT);
    RtlCopyMemory(ptmp, 
                  REGISTRY_UL_INFORMATION, 
                  sizeof(REGISTRY_UL_INFORMATION) - sizeof(WCHAR)
                 );

    ptmp = (PUCHAR)EtwRegInfo + EtwRegInfo->MofResourceName;
    *((PUSHORT)ptmp) = sizeof(UL_TRACE_MOF_FILE) - sizeof(WCHAR);

    ptmp += sizeof(USHORT);
    RtlCopyMemory(ptmp, 
                  UL_TRACE_MOF_FILE, 
                  sizeof(UL_TRACE_MOF_FILE) - sizeof(WCHAR)
                 );

    *pReturnSize =  SizeNeeded;
    return(STATUS_SUCCESS);
}



NTSTATUS
UlEtwEnableLog(
    IN  PVOID Buffer,
    IN  ULONG BufferSize
    )
{
    PWNODE_HEADER Wnode=NULL;

    ASSERT(Buffer);
    ASSERT(BufferSize >= sizeof(WNODE_HEADER));

    Wnode = (PWNODE_HEADER)Buffer;
    if (BufferSize >= sizeof(WNODE_HEADER)) {
        ULONG Level;
        g_UlEtwLoggerHandle = Wnode->HistoricalContext;

        Level = (ULONG) WmiGetLoggerEnableLevel ( g_UlEtwLoggerHandle ); 

        if (Level > ULMAX_TRACE_LEVEL) {
            Level = ULMAX_TRACE_LEVEL;
        }
        g_UlEtwTraceEnable = (1 << Level);
    }
    return STATUS_SUCCESS;

}


NTSTATUS
UlEtwDisableLog(
    )
{
    g_UlEtwTraceEnable  = 0;
    g_UlEtwLoggerHandle = 0;

    return(STATUS_SUCCESS);
}



NTSTATUS
UlEtwDispatch(
    IN PDEVICE_OBJECT pDO,
    IN PIRP Irp
    )
{

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG BufferSize = irpSp->Parameters.WMI.BufferSize;
    PVOID Buffer = irpSp->Parameters.WMI.Buffer;
    ULONG ReturnSize = 0;
    NTSTATUS status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(pDO);

    switch (irpSp->MinorFunction) {

        case IRP_MN_REGINFO:
        {
            status = UlEtwRegisterGuids( (PWMIREGINFO) Buffer,
                                     BufferSize,
                                     &ReturnSize);
            Irp->IoStatus.Information = ReturnSize;
            Irp->IoStatus.Status = status;

            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            break;
        }
        case IRP_MN_ENABLE_EVENTS:
        {
            status = UlEtwEnableLog(
                                    Buffer,
                                    BufferSize
                                    );
        
            Irp->IoStatus.Status = status;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            break;
        }
        case IRP_MN_DISABLE_EVENTS:
        {
            status = UlEtwDisableLog();
            Irp->IoStatus.Status = status;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            break;
        }
        default:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            break;
        }
    }

    return status;
}

/***************************************************************************++

Routine Description:

    This is the routine that is called to log a trace event with ETW 
    logger. 

Arguments:

    pGuid     - Supplies a pointer to the Guid of the event
    EventType - Type of the event being logged. 
    ...       - List of arguments to be logged with this event
                These are in pairs of
                    PVOID - ptr to argument
                    ULONG - size of argument
                and terminated by a pointer to NULL, length of zero pair

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlEtwTraceEvent(
    IN LPCGUID pGuid,
    IN ULONG   EventType,
    ...
    )
{
    NTSTATUS status;
    UL_ETW_TRACE_EVENT UlEvent;

    ULONG i;
    va_list ArgList;
    PVOID source;
    SIZE_T len;

    RtlZeroMemory(& UlEvent, sizeof(EVENT_TRACE_HEADER));

    va_start(ArgList, EventType);
    for (i = 0; i < MAX_MOF_FIELDS; i ++) {
        source = va_arg(ArgList, PVOID);
        if (source == NULL)
            break;
        len = va_arg(ArgList, SIZE_T);
        if (len == 0)
            break;
        UlEvent.MofField[i].DataPtr = (ULONGLONG) source;
        UlEvent.MofField[i].Length  = (ULONG) len;
    }
    va_end(ArgList);

    UlEvent.Header.Flags = WNODE_FLAG_TRACED_GUID |
                           WNODE_FLAG_USE_MOF_PTR |
                           WNODE_FLAG_USE_GUID_PTR;

    UlEvent.Header.Size         = (USHORT) (sizeof(EVENT_TRACE_HEADER) + (i * sizeof(MOF_FIELD)));
    UlEvent.Header.Class.Type = (UCHAR) EventType;
    UlEvent.Header.GuidPtr = (ULONGLONG)pGuid;
    ((PWNODE_HEADER)&UlEvent)->HistoricalContext = g_UlEtwLoggerHandle;
    status = IoWMIWriteEvent((PVOID)&UlEvent);
#if DBG
    if (!NT_SUCCESS(status) ) {
        UlTrace(ETW, ("UL: TraceEvent ErrorCode %x EventType %x\n",
                      status, EventType));
    }
#endif // DBG
    return status;
}

ULONG
UlEtwGetTraceEnableFlags(
    VOID
   )
{
    return WmiGetLoggerEnableFlags ( g_UlEtwLoggerHandle );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\uctrace.c ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    uctrace.c

Abstract:

    This module implements a tracing facility for the client.

Author:

    Rajesh Sundaram (rajeshsu) - 17th July 2001.

Revision History:

--*/


#include "precomp.h"

#if !DBG

static int g_UcTraceDummyDeclarationToKeepW4WarningsQuiet;

#else

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGEUC, UcCreateTraceLog )
#pragma alloc_text( PAGEUC, UcDestroyTraceLog )
#pragma alloc_text( PAGEUC, UcWriteTraceLog )

#endif

/***************************************************************************++

Routine Description:

    Creates a new (empty) trace log buffer.

Arguments:

    LogSize - Supplies the number of entries in the log.

    ExtraBytesInHeader - Supplies the number of extra bytes to include
        in the log header. This is useful for adding application-
        specific data to the log.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--***************************************************************************/
PTRACE_LOG
UcCreateTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    )
{
    return CreateTraceLog(
               UC_TRACE_LOG_SIGNATURE,
               LogSize,
               ExtraBytesInHeader,
               sizeof(UC_TRACE_LOG_ENTRY),
               TRACELOG_HIGH_PRIORITY,
               UL_REF_TRACE_LOG_POOL_TAG
               );

}   // UcCreateTraceLog


/***************************************************************************++

Routine Description:

    Destroys a filter queue trace log buffer created with
    UcCreateTraceLog().

Arguments:

    pLog - Supplies the filter queue trace log buffer to destroy.

--***************************************************************************/
VOID
UcDestroyTraceLog(
    IN PTRACE_LOG pLog
    )
{
    DestroyTraceLog( pLog, UL_REF_TRACE_LOG_POOL_TAG );

}   // UcDestroyTraceLog


/***************************************************************************++

Routine Description:

    Writes a new entry to the specified filter queue trace log.

Arguments:

    pLog - Supplies the log to write to.

    ConnectionId - the id of the connection we're tracing

    RequestId - the id of the request we're tracing

    Action - Supplies an action code for the new log entry.


--***************************************************************************/
VOID
UcWriteTraceLog(
    IN PTRACE_LOG             pLog,
    IN USHORT                 Action,
    IN PVOID                  pContext1,
    IN PVOID                  pContext2,
    IN PVOID                  pContext3,
    IN PVOID                  pContext4,
    IN PVOID                  pFileName,
    IN USHORT                 LineNumber
    )
{
    UC_TRACE_LOG_ENTRY entry;

    //
    // Initialize the entry.
    //
    entry.Action = Action;
    entry.Processor = (USHORT)KeGetCurrentProcessorNumber();
    entry.pProcess = PsGetCurrentProcess();
    entry.pThread = PsGetCurrentThread();

    entry.pContext1 = pContext1;
    entry.pContext2 = pContext2;
    entry.pContext3 = pContext3;
    entry.pContext4 = pContext4;


    entry.pFileName = pFileName;
    entry.LineNumber = LineNumber;

    //
    // Write it to the logs.
    //

    WriteTraceLog( pLog, &entry );

}   // UcWriteTraceLog

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\uletw.h ===
/*++

Copyright (c) 2001-2002 Microsoft Corporation

Module Name:

    uletw.h (UL IIS+ ETW logging)

Abstract:

    This module implements the Event Tracer for Windows (ETW)
    tracing capability for UL.

Author:

    Melur Raghuraman (mraghu)       26-Feb-2001

Revision History:

--*/

#ifndef _ULETW_H_
#define _ULETW_H_


DEFINE_GUID ( /* 3c419e3d-1d18-415b-a91a-9b558938de4b */
    UlTransGuid,
    0x3c419e3d,
    0x1d18,
    0x415b,
    0xa9, 0x1a, 0x9b, 0x55, 0x89, 0x38, 0xde, 0x4b
  );


DEFINE_GUID( /* dd5ef90a-6398-47a4-ad34-4dcecdef795f */
    UlControlGuid,
    0xdd5ef90a, 
    0x6398, 
    0x47a4, 
    0xad, 0x34, 0x4d, 0xce, 0xcd, 0xef, 0x79, 0x5f
);


//
// UL Specific Event Levels are defined here
//

#define ULMAX_TRACE_LEVEL   4

#define ETW_LEVEL_MIN       0       // Basic Logging of cache Miss case
#define ETW_LEVEL_CP        1       // Capacity Planning Resource Tracking
#define ETW_LEVEL_DBG       2       // Performance Analysis or Debug Tracing
#define ETW_LEVEL_MAX       3       // Very Detailed Debugging trace

#define ETW_FLAG_LOG_URL    0x00000001   // Log Url for ULDELIVER event. 

//
// UL specific EventTypes are defined here. 
//

#define ETW_TYPE_START                  0x01    // Request is received
#define ETW_TYPE_END                    0x02    // Response is sent

#define ETW_TYPE_ULPARSE_REQ            0x0A    // Parse the received Request
#define ETW_TYPE_ULDELIVER              0x0B    // Deliver Request to UM      
#define ETW_TYPE_ULRECV_RESP            0x0C    // Receive Response from UM
#define ETW_TYPE_ULRECV_RESPBODY        0x0D    // Receive Entity Body 

#define ETW_TYPE_CACHED_END             0x0E    // Cached Response
#define ETW_TYPE_CACHE_AND_SEND         0x0F    // Cache And Send Response

#define ETW_TYPE_ULRECV_FASTRESP        0x10    // Receive Resp thru fast path
#define ETW_TYPE_FAST_SEND              0x11    // Fast Send
#define ETW_TYPE_ZERO_SEND              0x12    // Last send 0 bytes
#define ETW_TYPE_SEND_ERROR             0x13    // Error sending last response


//
// Globals & Macros
//

extern LONG        g_UlEtwTraceEnable;

#define ETW_LOG_MIN()           (g_UlEtwTraceEnable >> ETW_LEVEL_MIN)
#define ETW_LOG_RESOURCE()      (g_UlEtwTraceEnable >> ETW_LEVEL_CP)
#define ETW_LOG_DEBUG()         (g_UlEtwTraceEnable >> ETW_LEVEL_DBG)
#define ETW_LOG_MAX()           (g_UlEtwTraceEnable >> ETW_LEVEL_MAX)
#define ETW_LOG_URL()           (UlEtwGetTraceEnableFlags() & ETW_FLAG_LOG_URL)


//
// Functions
//

NTSTATUS
UlEtwTraceEvent(
    IN LPCGUID pGuid,
    IN ULONG   EventType,
    ...
    );

NTSTATUS
UlEtwInitLog(
    IN PDEVICE_OBJECT pDeviceObject
    );

NTSTATUS
UlEtwUnRegisterLog(
    IN PDEVICE_OBJECT pDeviceObject
    );

ULONG
UlEtwGetTraceEnableFlags(
    VOID
   );
 

#endif  // _ULETW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ullog.h ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    ullog.h (Http.sys Ansi Logging)

Abstract:

    This module implements the logging facilities
    for Http.sys including the NCSA,IIS and W3C types
    of logging.

Author:

    Ali E. Turkoglu (aliTu)       10-May-2000

Revision History:

--*/

#ifndef _ULLOG_H_
#define _ULLOG_H_

//
// Forwarders.
//

typedef struct _UL_FULL_TRACKER *PUL_FULL_TRACKER;
typedef struct _UL_INTERNAL_REQUEST *PUL_INTERNAL_REQUEST;
typedef struct _UL_CONFIG_GROUP_OBJECT *PUL_CONFIG_GROUP_OBJECT;

//
// Brief information about how logging locks works; Whole link list is controlled
// by a global EResource g_pUlNonpagedData->LogListResource. Functions that require
// read access to this list are Hit(),CacheHit() & BufferFlush() and the ReCycle().
// Whereas functions that requires write access are Create(),Remove() and ReConfig().
// Also the log entry eresource (EntryResource) controls the per entry buffer.
// This eresource is acquired shared for the log hits.
//

//
// Structure to hold info for a log file
//

typedef struct _UL_LOG_FILE_ENTRY
{
    //
    // Signature is UL_LOG_FILE_ENTRY_POOL_TAG.
    //

    ULONG               Signature;

    //
    // This lock protects the whole entry. The ZwWrite operation
    // that's called after the lock acquired cannot run at APC_LEVEL
    // therefore we have to use push lock to prevent a bugcheck
    //

    UL_PUSH_LOCK        EntryPushLock;

    //
    // The name of the file. Full path including the directory.
    //

    UNICODE_STRING      FileName;
    PWSTR               pShortName;

    //
    // Following will be NULL until a request comes in to the
    // site that this entry represents.
    //

    PUL_LOG_FILE_HANDLE pLogFile;

    //
    // links all log file entries
    //

    LIST_ENTRY          LogFileListEntry;
        
    //
    // Private config info
    //
    
    HTTP_LOGGING_TYPE   Format;
    HTTP_LOGGING_PERIOD Period;
    ULONG               TruncateSize;
    ULONG               LogExtFileFlags;
    ULONG               SiteId;

    //
    // Time to expire field in terms of Hours.
    // This could be at most 24 * 31, that's for monthly
    // log cycling. Basically we keep a single periodic hourly
    // timer and every time it expires we traverse the
    // log list to figure out which log files are expired
    // at that time by looking at this fields. And then we
    // recylcle the log if necessary.
    //

    ULONG               TimeToExpire;

    //
    // File for the entry is automatically closed every 15
    // minutes. This is to track the idle time.
    //

    ULONG               TimeToClose;

    //
    // If this entry has MAX_SIZE or UNLIMITED
    // log period
    //

    ULONG               SequenceNumber;
    ULARGE_INTEGER      TotalWritten;

    union
    {
        //
        // Flags to show the field states mostly. Used by
        // recycling.
        //
        
        ULONG Value;
        struct
        {
            ULONG StaleSequenceNumber:1;
            ULONG StaleTimeToExpire:1;
            ULONG RecyclePending:1;
            ULONG LogTitleWritten:1;
            ULONG TitleFlushPending:1;
            ULONG Active:1;
            ULONG LocaltimeRollover:1;

            ULONG CreateFileFailureLogged:1;
            ULONG WriteFailureLogged:1;
        };

    } Flags;

    //
    // Each log file entry keeps a fixed amount of log buffer.
    // The buffer size is g_AllocationGranularity comes from
    // the system's allocation granularity.
    //

    PUL_LOG_FILE_BUFFER LogBuffer;

} UL_LOG_FILE_ENTRY, *PUL_LOG_FILE_ENTRY;

#define IS_VALID_LOG_FILE_ENTRY( pEntry )   \
    HAS_VALID_SIGNATURE(pEntry, UL_LOG_FILE_ENTRY_POOL_TAG)

//
// CGroup decides on whether logging is enabled for itself or not looking 
// at this macro.
//

#define IS_LOGGING_ENABLED(pCgobj)                          \
    ((pCgobj) != NULL &&                                    \
     (pCgobj)->LoggingConfig.Flags.Present  == 1 &&         \
     (pCgobj)->LoggingConfig.LoggingEnabled == TRUE &&      \
     (pCgobj)->pLogFileEntry != NULL)
     

//
// Followings are all parts of our internal buffer to hold
// the Logging information. We copy over this info from WP
// buffer upon SendResponse request. Yet few of this fields
// are calculated directly by us and filled. The order of
// this fields SHOULD match with the definition of the 
// UlFieldTitleLookupTable.
//

typedef enum _UL_LOG_FIELD_TYPE
{
    UlLogFieldDate = 0,         // 0
    UlLogFieldTime,    
    UlLogFieldSiteName,
    UlLogFieldServerName,
    UlLogFieldServerIp,         
    UlLogFieldMethod,           // 5
    UlLogFieldUriStem,
    UlLogFieldUriQuery,
    UlLogFieldServerPort,       
    UlLogFieldUserName,
    UlLogFieldClientIp,         // 10    
    UlLogFieldProtocolVersion,
    UlLogFieldUserAgent,        
    UlLogFieldCookie,           
    UlLogFieldReferrer,
    UlLogFieldHost,             // 15
    UlLogFieldProtocolStatus,
    UlLogFieldSubStatus,
    UlLogFieldWin32Status,    
    UlLogFieldBytesSent,
    UlLogFieldBytesReceived, // 20
    UlLogFieldTimeTaken,  

    UlLogFieldMaximum

} UL_LOG_FIELD_TYPE, *PUL_LOG_FIELD_TYPE;

//
// Size of the pre-allocated log line buffer inside the request structure.
//

#define UL_MAX_LOG_LINE_BUFFER_SIZE            (10*1024)

#define UL_MAX_TITLE_BUFFER_SIZE                (512)

//
// To avoid the infinite loop situation we have  to set  the  minimum
// allowable log file size to something bigger than maximum allowable
// log record line.
//

C_ASSERT(HTTP_MIN_ALLOWED_TRUNCATE_SIZE_FOR_LOG_FILE > 
               (UL_MAX_TITLE_BUFFER_SIZE + UL_MAX_LOG_LINE_BUFFER_SIZE));

//
// If somebody overwrites the default log buffering size which
// is system granularity size of 64K. We have to make sure the
// buffer size is not smaller then miminum allowed. Which   is
// MaximumAlowed Logrecord size of 10K. Also it  should be  4k
// aligned therefore makes it 12k at least.
//

#define MINIMUM_ALLOWED_LOG_BUFFER_SIZE         (12*1024)

C_ASSERT(MINIMUM_ALLOWED_LOG_BUFFER_SIZE > 
               (UL_MAX_TITLE_BUFFER_SIZE + UL_MAX_LOG_LINE_BUFFER_SIZE));

#define MAXIMUM_ALLOWED_LOG_BUFFER_SIZE         (64*1024)

//
// Fix size date and time fields per format.
//

#define W3C_DATE_FIELD_LEN                      (10)
#define W3C_TIME_FIELD_LEN                      (8)

#define NCSA_FIX_DATE_AND_TIME_FIELD_SIZE       (29)

C_ASSERT(STRLEN_LIT("[07/Jan/2000:00:02:23 -0800] ") 
            == NCSA_FIX_DATE_AND_TIME_FIELD_SIZE);

#define IIS_MAX_DATE_AND_TIME_FIELD_SIZE        (22)

C_ASSERT(STRLEN_LIT("12/31/2002, 17:05:40, ")
            == IIS_MAX_DATE_AND_TIME_FIELD_SIZE);

//
// IIS Log line is fragmented at the capture time the offsets
// are as follows and never get changed even if the buffer get 
// reallocated. This are default values and only the third
// fragment can get bigger.
//

#define IIS_LOG_LINE_FIRST_FRAGMENT_OFFSET                      (0)
#define IIS_LOG_LINE_DEFAULT_FIRST_FRAGMENT_ALLOCATION_SIZE     (512)             

#define IIS_LOG_LINE_SECOND_FRAGMENT_OFFSET                     (512)
#define IIS_LOG_LINE_DEFAULT_SECOND_FRAGMENT_ALLOCATION_SIZE    (512)

#define IIS_LOG_LINE_THIRD_FRAGMENT_OFFSET                      (1024) 
#define IIS_LOG_LINE_DEFAULT_THIRD_FRAGMENT_ALLOCATION_SIZE     (3072)

//
// The HTTP Hit Logging functions which we expose in this module.
//

NTSTATUS
UlInitializeLogs(
    VOID
    );

VOID
UlTerminateLogs(
    VOID
    );

NTSTATUS
UlSetUTF8Logging (
    IN BOOLEAN UTF8Logging
    );

NTSTATUS
UlCreateLogEntry(
    IN OUT PUL_CONFIG_GROUP_OBJECT    pConfigGroup,
    IN     PHTTP_CONFIG_GROUP_LOGGING pUserConfig
    );

VOID
UlRemoveLogEntry(
    IN PUL_CONFIG_GROUP_OBJECT pConfigGroup
    );

VOID
UlLogTimerHandler(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlLogTimerDpcRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );

VOID
UlBufferTimerHandler(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlBufferTimerDpcRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );

NTSTATUS
UlReConfigureLogEntry(
    IN  PUL_CONFIG_GROUP_OBJECT     pConfigGroup,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgOld,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgNew
    );

NTSTATUS
UlCaptureLogFieldsW3C(
    IN PHTTP_LOG_FIELDS_DATA pLogData,
    IN PUL_INTERNAL_REQUEST  pRequest,
    OUT PUL_LOG_DATA_BUFFER  *ppLogBuffer
    );

NTSTATUS
UlCaptureLogFieldsNCSA(
    IN PHTTP_LOG_FIELDS_DATA pLogData,
    IN PUL_INTERNAL_REQUEST  pRequest,
    OUT PUL_LOG_DATA_BUFFER  *ppLogBuffer
    );

NTSTATUS
UlCaptureLogFieldsIIS(
    IN PHTTP_LOG_FIELDS_DATA pLogData,
    IN PUL_INTERNAL_REQUEST  pRequest,
    OUT PUL_LOG_DATA_BUFFER  *ppLogBuffer
    );

NTSTATUS
UlLogHttpHit(
    IN PUL_LOG_DATA_BUFFER  pLogBuffer
    );

NTSTATUS
UlLogHttpCacheHit(
        IN PUL_FULL_TRACKER pTracker
        );

NTSTATUS
UlDisableLogEntry(
    IN OUT PUL_LOG_FILE_ENTRY pEntry
    );

#endif  // _ULLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\uletwp.h ===
/*++

Copyright (c) 2001-2002 Microsoft Corporation

Module Name:

    uletwp.h (UL IIS+ ETW logging)

Abstract:

    Contains private ETW declarations. 

Author:

    Melur Raghuraman (mraghu)       26-Feb-2001

Revision History:

--*/

#ifndef _ULETWP_H_
#define _ULETWP_H_


#include <ntwmi.h>
#include <evntrace.h>

//
// Private constants.
//
#define UL_TRACE_MOF_FILE     L"UlMofResource"

//
// Private types.
//

typedef struct _UL_ETW_TRACE_EVENT {
    EVENT_TRACE_HEADER  Header;
    MOF_FIELD           MofField[MAX_MOF_FIELDS];
} UL_ETW_TRACE_EVENT, *PUL_ETW_TRACE_EVENT;

//
// Private prototypes.
//

NTSTATUS
UlEtwRegisterGuids(
    IN PWMIREGINFO  EtwRegInfo,
    IN ULONG        etwRegInfoSize,
    IN PULONG       pReturnSize
    );

NTSTATUS
UlEtwEnableLog(
    IN  PVOID Buffer,
    IN  ULONG BufferSize
    );

NTSTATUS
UlEtwDisableLog(
    );

NTSTATUS
UlEtwDispatch(
    IN PDEVICE_OBJECT pDO,
    IN PIRP Irp
    );


#endif  // _ULETWP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ullog.c ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    ullog.c (UL IIS6 HIT Logging)

Abstract:

    This module implements the logging facilities
    for IIS6 including the NCSA, IIS and W3CE types
    of logging.

Author:

    Ali E. Turkoglu (aliTu)       10-May-2000

Revision History:

--*/


#include "precomp.h"
#include "ullogp.h"

//
// Generic Private globals.
//

LIST_ENTRY      g_LogListHead       = {NULL,NULL};
LONG            g_LogListEntryCount = 0;

BOOLEAN         g_InitLogsCalled = FALSE;
BOOLEAN         g_InitLogTimersCalled = FALSE;

CHAR            g_GMTOffset[SIZE_OF_GMT_OFFSET + 1];

//
// The global parameter keeps track of the changes to the
// utf8 logging which applies to the all sites.
//

BOOLEAN         g_UTF8Logging = FALSE;

//
// For Log Buffering and periodic flush of the buffers.
//

UL_LOG_TIMER    g_BufferTimer;

//
// For Log File ReCycling based on Local and/or GMT time.
//

UL_LOG_TIMER    g_LogTimer;


#ifdef ALLOC_PRAGMA

#pragma alloc_text( INIT, UlInitializeLogs )

#pragma alloc_text( PAGE, UlTerminateLogs )
#pragma alloc_text( PAGE, UlpGetGMTOffset )

#pragma alloc_text( PAGE, UlpRecycleLogFile )
#pragma alloc_text( PAGE, UlCreateLogEntry )
#pragma alloc_text( PAGE, UlpCreateLogFile )
#pragma alloc_text( PAGE, UlRemoveLogEntry )
#pragma alloc_text( PAGE, UlpConstructLogEntry )

#pragma alloc_text( PAGE, UlpAllocateLogDataBuffer )
#pragma alloc_text( PAGE, UlReConfigureLogEntry )

#pragma alloc_text( PAGE, UlBufferTimerHandler )
#pragma alloc_text( PAGE, UlpAppendW3CLogTitle )
#pragma alloc_text( PAGE, UlpWriteToLogFile )
#pragma alloc_text( PAGE, UlSetUTF8Logging )

#pragma alloc_text( PAGE, UlCaptureLogFieldsW3C )
#pragma alloc_text( PAGE, UlCaptureLogFieldsNCSA )
#pragma alloc_text( PAGE, UlCaptureLogFieldsIIS )
#pragma alloc_text( PAGE, UlLogHttpCacheHit )
#pragma alloc_text( PAGE, UlLogHttpHit )

#pragma alloc_text( PAGE, UlpGenerateDateAndTimeFields )

#pragma alloc_text( PAGE, UlpMakeEntryInactive )
#pragma alloc_text( PAGE, UlDisableLogEntry )

#pragma alloc_text( PAGE, UlpEventLogWriteFailure )

#endif  // ALLOC_PRAGMA

#if 0

NOT PAGEABLE -- UlLogTimerDpcRoutine
NOT PAGEABLE -- UlpTerminateLogTimer
NOT PAGEABLE -- UlpInsertLogEntry
NOT PAGEABLE -- UlLogTimerHandler
NOT PAGEABLE -- UlBufferTimerDpcRoutine
NOT PAGEABLE -- UlpTerminateTimers
NOT PAGEABLE -- UlpInitializeTimers
NOT PAGEABLE -- UlpBufferFlushAPC
NOT PAGEABLE -- UlDestroyLogDataBuffer
NOT PAGEABLE -- UlDestroyLogDataBufferWorker

#endif

//
// Public functions.
//

/***************************************************************************++

Routine Description:

    UlInitializeLogs :

        Initialize the resource for log list synchronization

--***************************************************************************/

NTSTATUS
UlInitializeLogs (
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(!g_InitLogsCalled);

    if (!g_InitLogsCalled)
    {
        InitializeListHead(&g_LogListHead);

        UlInitializePushLock(
            &g_pUlNonpagedData->LogListPushLock,
            "LogListPushLock",
            0,
            UL_LOG_LIST_PUSHLOCK_TAG
            );

        g_InitLogsCalled = TRUE;

        UlpInitializeTimers();

        UlpInitializeLogCache();

        UlpGetGMTOffset();
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    UlTerminateLogs :

        Deletes the resource for log list synchronization

--***************************************************************************/

VOID
UlTerminateLogs(
    VOID
    )
{
    PAGED_CODE();

    if (g_InitLogsCalled)
    {
        ASSERT( IsListEmpty( &g_LogListHead )) ;

        //
        // Make sure terminate the log timer before
        // deleting the log list resource
        //

        UlpTerminateTimers();

        UlDeletePushLock(
            &g_pUlNonpagedData->LogListPushLock
            );

        g_InitLogsCalled = FALSE;
    }
}


/***************************************************************************++

Routine Description:

    UlSetUTF8Logging :

        Sets the UTF8Logging on or off. Only once. Initially Utf8Logging is
        FALSE and it may only be set during the init once. Following possible
        changes won't be taken.

        ReConfiguration code is explicitly missing as WAS will anly call this
        only once (init) during the lifetime of the control channel.

--***************************************************************************/

NTSTATUS
UlSetUTF8Logging (
    IN BOOLEAN UTF8Logging
    )
{
    PLIST_ENTRY pLink;
    PUL_LOG_FILE_ENTRY pEntry;
    NTSTATUS Status;

    PAGED_CODE();
    Status = STATUS_SUCCESS;

    //
    // Update & Reycle. Need to acquire the logging resource to prevent
    // further log hits to be written to file before we finish our
    // business. recycle is necessary because files will be renamed to
    // have prefix "u_" once we enabled the UTF8.
    //

    UlTrace(LOGGING,("Http!UlSetUTF8Logging: UTF8Logging Old %d -> New %d\n",
                       g_UTF8Logging,UTF8Logging
                       ));

    UlAcquirePushLockExclusive(&g_pUlNonpagedData->LogListPushLock);

    //
    // Drop the change if the setting is not changing.
    //

    if ( g_UTF8Logging == UTF8Logging )
    {
        goto end;
    }

    g_UTF8Logging = UTF8Logging;

    for (pLink  = g_LogListHead.Flink;
         pLink != &g_LogListHead;
         pLink  = pLink->Flink
         )
    {
        pEntry = CONTAINING_RECORD(
                    pLink,
                    UL_LOG_FILE_ENTRY,
                    LogFileListEntry
                    );

        UlAcquirePushLockExclusive(&pEntry->EntryPushLock);

        if (pEntry->Flags.Active && !pEntry->Flags.RecyclePending)
        {
            pEntry->Flags.StaleSequenceNumber = 1;

            Status = UlpRecycleLogFile(pEntry);            
        }

        UlReleasePushLockExclusive(&pEntry->EntryPushLock);
    }

end:
    UlReleasePushLockExclusive(&g_pUlNonpagedData->LogListPushLock);

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpWriteToLogFile :

        Writes a record to a log file

Arguments:

    pFile   - Handle to a log file entry
    RecordSize - Length of the record to be written.
    pRecord - The log record to be written to the log buffer

--***************************************************************************/

NTSTATUS
UlpWriteToLogFile(
    IN PUL_LOG_FILE_ENTRY   pFile,
    IN ULONG                RecordSize,
    IN PCHAR                pRecord,
    IN ULONG                UsedOffset1,
    IN ULONG                UsedOffset2
    )
{
    NTSTATUS Status;

    PAGED_CODE();

    ASSERT(pRecord!=NULL);
    ASSERT(RecordSize!=0);
    ASSERT(IS_VALID_LOG_FILE_ENTRY(pFile));

    UlTrace(LOGGING, ("Http!UlpWriteToLogFile: pEntry %p\n", pFile));

    if ( pFile==NULL ||
         pRecord==NULL ||
         RecordSize==0 ||
         RecordSize>g_UlLogBufferSize
       )
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // We are safe here by dealing only with entry  eresource  since  the
    // time based recycling, reconfiguration and periodic buffer flushing
    // always acquires the global list eresource exclusively and  we  are 
    // already holding it shared. But we should still  be  carefull about
    // file size based  recyling  and we should only  do  it while we are
    // holding the entries eresource exclusive.I.e. look at the exclusive
    // writer down below.
    //

    if (g_UlDisableLogBuffering)
    {
        //
        // Above global variable is safe to look, it doesn't get changed
        // during the life-time of the driver. It's get initialized from
        // the registry and disables the log buffering.
        //
        
        UlAcquirePushLockExclusive(&pFile->EntryPushLock);

        Status = UlpWriteToLogFileDebug(
                    pFile,
                    RecordSize,
                    pRecord,
                    UsedOffset1,
                    UsedOffset2
                    );

        UlReleasePushLockExclusive(&pFile->EntryPushLock);

        return Status;    
    }
    
    //
    // Try UlpWriteToLogFileShared first which merely moves the
    // BufferUsed forward and copy the record to LogBuffer->Buffer.
    //

    UlAcquirePushLockShared(&pFile->EntryPushLock);

    Status = UlpWriteToLogFileShared(
                pFile,
                RecordSize,
                pRecord,
                UsedOffset1,
                UsedOffset2
                );

    UlReleasePushLockShared(&pFile->EntryPushLock);

    if (Status == STATUS_MORE_PROCESSING_REQUIRED)
    {
        //
        // UlpWriteToLogFileShared returns STATUS_MORE_PROCESSING_REQUIRED,
        // we need to flush the buffer and try to log again. This time, we
        // need to take the entry eresource exclusive.
        //

        UlAcquirePushLockExclusive(&pFile->EntryPushLock);

        Status = UlpWriteToLogFileExclusive(
                    pFile,
                    RecordSize,
                    pRecord,
                    UsedOffset1,
                    UsedOffset2
                    );

        UlReleasePushLockExclusive(&pFile->EntryPushLock);
    }

    return Status;
}

/***************************************************************************++

Routine Description:

  UlpAppendToLogBuffer  :

        Append a record to a log file

        REQUIRES you to hold the loglist resource shared and entry mutex
        shared or exclusive

Arguments:

    pFile   - Handle to a log file entry
    RecordSize - Length of the record to be written.
    pRecord - The log record to be written to the log buffer

--***************************************************************************/

__inline
VOID
UlpAppendToLogBuffer(
    IN PUL_LOG_FILE_ENTRY   pFile,
    IN ULONG                BufferUsed,
    IN ULONG                RecordSize,
    IN PCHAR                pRecord,
    IN ULONG                UsedOffset1,
    IN ULONG                UsedOffset2
    )
{
    PUL_LOG_FILE_BUFFER     pLogBuffer = pFile->LogBuffer;

    UlTrace(LOGGING,
        ("Http!UlpAppendToLogBuffer: pEntry %p TW:%I64d FileBuffer %p (%d + %d)\n", 
          pFile,
          pFile->TotalWritten.QuadPart,
          pLogBuffer->Buffer,
          BufferUsed,
          RecordSize
          ));

    //
    // IIS format log line may be fragmented (identified by looking at the 
    // UsedOffset2), handle it wisely.
    //

    if (UsedOffset2)
    {
        RtlCopyMemory(
            pLogBuffer->Buffer + BufferUsed,
            &pRecord[0],
            UsedOffset1
            );

        RtlCopyMemory(
            pLogBuffer->Buffer + BufferUsed + UsedOffset1,
            &pRecord[512],
            UsedOffset2
            );

        RtlCopyMemory(
            pLogBuffer->Buffer + BufferUsed + UsedOffset1 + UsedOffset2,
            &pRecord[1024],
            RecordSize - (UsedOffset1 + UsedOffset2)
            );
    }
    else
    {
        RtlCopyMemory(
            pLogBuffer->Buffer + BufferUsed,
            pRecord,
            RecordSize
            );
    }
}

/***************************************************************************++

Routine Description:

        REQUIRES LogListResource Shared & Entry eresource exclusive.

        Appends the W3C log file title to the existing buffer.

Arguments:

    pFile   - Pointer to the logfile entry
    pCurrentTimeFields - Current time fields

--***************************************************************************/

NTSTATUS
UlpAppendW3CLogTitle(
    IN     PUL_LOG_FILE_ENTRY   pEntry,
    OUT    PCHAR                pDestBuffer,
    IN OUT PULONG               pBytesCopied
    )
{
    PCHAR           TitleBuffer;
    LONG            BytesCopied;
    ULONG           LogExtFileFlags;
    TIME_FIELDS     CurrentTimeFields;
    LARGE_INTEGER   CurrentTimeStamp;
    PUL_LOG_FILE_BUFFER pLogBuffer;

    PAGED_CODE();

    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));
    ASSERT(pEntry->Format == HttpLoggingTypeW3C);

    pLogBuffer = pEntry->LogBuffer;
    LogExtFileFlags = pEntry->LogExtFileFlags;
    
    KeQuerySystemTime(&CurrentTimeStamp);
    RtlTimeToTimeFields(&CurrentTimeStamp, &CurrentTimeFields);

    if (pDestBuffer)
    {
        // Append to the provided buffer

        ASSERT(pBytesCopied);
        ASSERT(*pBytesCopied >= UL_MAX_TITLE_BUFFER_SIZE);

        UlTrace(LOGGING,("Http!UlpAppendW3CLogTitle: Copying to Provided Buffer %p\n", 
                           pDestBuffer));
        
        TitleBuffer = pDestBuffer;
    }
    else
    {
        // Append to the entry buffer        

        ASSERT(pLogBuffer);
        ASSERT(pLogBuffer->Buffer);

        UlTrace(LOGGING,("Http!UlpAppendW3CLogTitle: Copying to Entry Buffer %p\n", 
                           pLogBuffer));

        TitleBuffer = (PCHAR) pLogBuffer->Buffer + pLogBuffer->BufferUsed;
    }
        
    BytesCopied = _snprintf(
        TitleBuffer,
        UL_MAX_TITLE_BUFFER_SIZE,

        // TODO: Make this maintainance friendly

        "#Software: Microsoft Internet Information Services 6.0\r\n"
        "#Version: 1.0\r\n"
        "#Date: %4d-%02d-%02d %02d:%02d:%02d\r\n"
        "#Fields:%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls \r\n",

        CurrentTimeFields.Year,
        CurrentTimeFields.Month,
        CurrentTimeFields.Day,

        CurrentTimeFields.Hour,
        CurrentTimeFields.Minute,
        CurrentTimeFields.Second,

        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldDate,LogExtFileFlags,MD_EXTLOG_DATE),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldTime,LogExtFileFlags,MD_EXTLOG_TIME),       
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldSiteName,LogExtFileFlags,MD_EXTLOG_SITE_NAME),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldServerName,LogExtFileFlags,MD_EXTLOG_COMPUTER_NAME),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldServerIp,LogExtFileFlags,MD_EXTLOG_SERVER_IP),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldMethod,LogExtFileFlags,MD_EXTLOG_METHOD),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldUriStem,LogExtFileFlags,MD_EXTLOG_URI_STEM),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldUriQuery,LogExtFileFlags,MD_EXTLOG_URI_QUERY),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldServerPort,LogExtFileFlags,MD_EXTLOG_SERVER_PORT),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldUserName,LogExtFileFlags,MD_EXTLOG_USERNAME),        
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldClientIp,LogExtFileFlags,MD_EXTLOG_CLIENT_IP),        
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldProtocolVersion,LogExtFileFlags,MD_EXTLOG_PROTOCOL_VERSION),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldUserAgent,LogExtFileFlags,MD_EXTLOG_USER_AGENT),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldCookie,LogExtFileFlags,MD_EXTLOG_COOKIE),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldReferrer,LogExtFileFlags,MD_EXTLOG_REFERER),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldHost,LogExtFileFlags,MD_EXTLOG_HOST),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldProtocolStatus,LogExtFileFlags,MD_EXTLOG_HTTP_STATUS),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldSubStatus,LogExtFileFlags,MD_EXTLOG_HTTP_SUB_STATUS),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldWin32Status,LogExtFileFlags,MD_EXTLOG_WIN32_STATUS),        
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldBytesSent,LogExtFileFlags,MD_EXTLOG_BYTES_SENT),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldBytesReceived,LogExtFileFlags,MD_EXTLOG_BYTES_RECV),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldTimeTaken,LogExtFileFlags,MD_EXTLOG_TIME_TAKEN)

        );

    if (BytesCopied < 0)
    {
        ASSERT(!"Default title buffer size is too small !");
        BytesCopied = UL_MAX_TITLE_BUFFER_SIZE;
    }

    if (pDestBuffer)
    {
        *pBytesCopied = BytesCopied;
    }
    else
    {
        pLogBuffer->BufferUsed += BytesCopied; 
    }
        
    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

        Writes a record to the log buffer and flushes.
        This func only get called when debug parameter 
        g_UlDisableLogBuffering is set.

        REQUIRES you to hold the entry eresource EXCLUSIVE.

Arguments:

    pFile      - Handle to a log file entry
    RecordSize - Length of the record to be written.

--***************************************************************************/

NTSTATUS
UlpWriteToLogFileDebug(
    IN PUL_LOG_FILE_ENTRY   pFile,
    IN ULONG                RecordSize,
    IN PCHAR                pRecord,
    IN ULONG                UsedOffset1,
    IN ULONG                UsedOffset2
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    PUL_LOG_FILE_BUFFER     pLogBuffer;
    ULONG                   RecordSizePlusTitle = RecordSize;    
    CHAR                    TitleBuffer[UL_MAX_TITLE_BUFFER_SIZE];
    ULONG                   TitleBufferSize = UL_MAX_TITLE_BUFFER_SIZE;

    PAGED_CODE();

    ASSERT(IS_VALID_LOG_FILE_ENTRY(pFile));
    ASSERT(UlDbgPushLockOwnedExclusive(&pFile->EntryPushLock));
    ASSERT(g_UlDisableLogBuffering!=0);
    
    UlTrace(LOGGING,("Http!UlpWriteToLogFileDebug: pEntry %p\n", pFile ));

    if (!pFile->Flags.LogTitleWritten) 
    {
        //
        // First append to the temp buffer to calculate the size.
        //
        
        UlpAppendW3CLogTitle(pFile, TitleBuffer, &TitleBufferSize);            
        RecordSizePlusTitle += TitleBufferSize;
    }

    if (UlpIsLogFileOverFlow(pFile,RecordSizePlusTitle))
    {
        Status = UlpRecycleLogFile(pFile);
    }

    if (pFile->pLogFile==NULL || !NT_SUCCESS(Status))
    {
        //
        // If we were unable to acquire a new file handle that means logging
        // is temporarly ceased because of either STATUS_DISK_FULL or the 
        // drive went down for some reason. We just bail out.
        //
        
        return Status;
    }

    if (!pFile->LogBuffer)
    {
        //
        // The buffer will be null for each log hit when log buffering 
        // is disabled.
        //
        
        pFile->LogBuffer = UlPplAllocateLogFileBuffer();
        if (!pFile->LogBuffer)
        {
            return STATUS_NO_MEMORY;
        }
    }

    pLogBuffer = pFile->LogBuffer;
    ASSERT(pLogBuffer->BufferUsed == 0); 

    if (!pFile->Flags.LogTitleWritten)
    {
        ASSERT(pFile->Format == HttpLoggingTypeW3C);
        
        UlpAppendW3CLogTitle(pFile, NULL, NULL);
        pFile->Flags.LogTitleWritten = 1;
        pFile->Flags.TitleFlushPending = 1;
    }
    
    ASSERT(RecordSize + pLogBuffer->BufferUsed <= g_UlLogBufferSize);

    UlpAppendToLogBuffer(
        pFile,
        pLogBuffer->BufferUsed,
        RecordSize,
        pRecord,
        UsedOffset1,
        UsedOffset2
        );

    pLogBuffer->BufferUsed += RecordSize;

    Status = UlpFlushLogFile(pFile);
    if (!NT_SUCCESS(Status))
    {        
        return Status;
    }
    
    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    Writes an event log to system log for log file write failure.
    Entry pushlock should be acquired exclusive prior to calling this function.
    
Arguments:

    pEntry  - Log file entry
    Status  - Result of last write

--***************************************************************************/

VOID
UlpEventLogWriteFailure(
    IN PUL_LOG_FILE_ENTRY pEntry,
    IN NTSTATUS Status
    )
{
    NTSTATUS TempStatus = STATUS_SUCCESS;
    PWSTR    StringList[2];
    WCHAR    SiteName[MAX_ULONG_STR + 1];

    //
    // Sanity Check.
    //

    PAGED_CODE();
    
    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));

    //
    // There should better be a failure.
    //
    
    ASSERT(!NT_SUCCESS(Status));

    //
    // Bail out if we have already logged the event failure.
    //

    if (pEntry->Flags.WriteFailureLogged)
    {
        return;
    }

    //
    // Report the log file name and the site name.
    //

    ASSERT(pEntry->pShortName);
    ASSERT(pEntry->pShortName[0] == L'\\');
        
    StringList[0] = (PWSTR) (pEntry->pShortName + 1); // Skip the L'\'

    UlStrPrintUlongW(SiteName, pEntry->SiteId, 0, L'\0');
    StringList[1] = (PWSTR) SiteName;

    TempStatus = UlWriteEventLogEntry(
                  (NTSTATUS)EVENT_HTTP_LOGGING_FILE_WRITE_FAILED,
                   0,
                   2,
                   StringList,
                   sizeof(NTSTATUS),
                   (PVOID) &Status
                   );

    ASSERT(TempStatus != STATUS_BUFFER_OVERFLOW);
        
    if (TempStatus == STATUS_SUCCESS)
    {            
        pEntry->Flags.WriteFailureLogged = 1;
    }            
    
    UlTrace(LOGGING,(
            "Http!UlpEventLogWriteFailure: Event Logging Status %08lx\n",
            TempStatus
            ));
}

/***************************************************************************++

Routine Description:

    Simple wrapper function around global buffer flush.
    
Arguments:

    pEntry  - Log file entry

--***************************************************************************/

NTSTATUS
UlpFlushLogFile(
    IN PUL_LOG_FILE_ENTRY  pEntry
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));

    if (NULL != pEntry->LogBuffer  && 0 != pEntry->LogBuffer->BufferUsed)
    {
        Status = UlFlushLogFileBuffer(
                   &pEntry->LogBuffer,
                    pEntry->pLogFile,
                    (BOOLEAN)pEntry->Flags.TitleFlushPending,
                   &pEntry->TotalWritten.QuadPart                    
                    );

        if (!NT_SUCCESS(Status))
        {
            UlpEventLogWriteFailure(pEntry, Status);
        }
        else
        {
            //
            // If we have successfully flushed some data. 
            // Reset the event log indication.
            //
            
            pEntry->Flags.WriteFailureLogged = 0;
        }

        if (pEntry->Flags.TitleFlushPending)
        {
            pEntry->Flags.TitleFlushPending = 0;

            if (!NT_SUCCESS(Status))
            {
                //
                // We need to recopy the header, it couldn't make it
                // to the log file yet.
                //
            
                pEntry->Flags.LogTitleWritten = 0;
            }            
        }

        //
        // Buffer flush means activity reset the TimeToClose to its max.
        //

        pEntry->TimeToClose = DEFAULT_MAX_FILE_IDLE_TIME;
    }
            
    return Status;
}

/***************************************************************************++

Routine Description:

    UlpWriteToLogFileShared :

        Writes a record to a log file

        REQUIRES you to hold the loglist resource shared

Arguments:

    pFile   - Handle to a log file entry
    RecordSize - Length of the record to be written.
    pRecord - The log record to be written to the log buffer

--***************************************************************************/

NTSTATUS
UlpWriteToLogFileShared(
    IN PUL_LOG_FILE_ENTRY   pFile,
    IN ULONG                RecordSize,
    IN PCHAR                pRecord,
    IN ULONG                UsedOffset1,
    IN ULONG                UsedOffset2
    )
{
    PUL_LOG_FILE_BUFFER     pLogBuffer;
    LONG                    BufferUsed;

    PAGED_CODE();

    ASSERT(IS_VALID_LOG_FILE_ENTRY(pFile));
    ASSERT(g_UlDisableLogBuffering == 0);

    pLogBuffer = pFile->LogBuffer;

    UlTrace(LOGGING,("Http!UlpWriteToLogFileShared: pEntry %p\n", pFile));

    //
    // Bail out and try the exclusive writer for cases;
    //
    // 1. No log buffer available.
    // 2. Logging ceased. (NULL handle)
    // 3. Title needs to be written.
    // 4. The actual log file itself has to be recycled.
    //
    // Otherwise proceed with appending to the current buffer
    // if there is enough space avialable for us. If not;
    // 
    // 5. Bail out to get a new buffer
    //

    if ( pLogBuffer==NULL ||
         pFile->pLogFile==NULL ||
         !pFile->Flags.LogTitleWritten ||         
         UlpIsLogFileOverFlow(pFile,RecordSize)
       )
    {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    //
    // Reserve space in pLogBuffer by InterlockedCompareExchange add
    // RecordSize. If we exceed the limit, bail out and take the
    // exclusive lock to flush the buffer.
    //

    do
    {
        BufferUsed = *((volatile LONG *) &pLogBuffer->BufferUsed);

        if ( RecordSize + BufferUsed > g_UlLogBufferSize )
        {
            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        PAUSE_PROCESSOR;
        
    } while (BufferUsed != InterlockedCompareExchange(
                                &pLogBuffer->BufferUsed,
                                RecordSize + BufferUsed,
                                BufferUsed
                                ));

    //
    // Keep buffering until our buffer is full.
    //

    UlpAppendToLogBuffer(
        pFile,
        BufferUsed,
        RecordSize,
        pRecord,
        UsedOffset1,
        UsedOffset2
        );

    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

        By assuming that it's holding the entrie's eresource exclusively
        this function does various functions;
            - It Writes a record to a log file

        REQUIRES you to hold the loglist resource shared

Arguments:

    pFile  - Handle to a log file entry
    RecordSize - Length of the record to be written.

--***************************************************************************/

NTSTATUS
UlpWriteToLogFileExclusive(
    IN PUL_LOG_FILE_ENTRY   pFile,
    IN ULONG                RecordSize,
    IN PCHAR                pRecord,
    IN ULONG                UsedOffset1,
    IN ULONG                UsedOffset2
    )
{
    PUL_LOG_FILE_BUFFER     pLogBuffer;
    NTSTATUS                Status = STATUS_SUCCESS;
    ULONG                   RecordSizePlusTitle = RecordSize;
    CHAR                    TitleBuffer[UL_MAX_TITLE_BUFFER_SIZE];
    ULONG                   TitleBufferSize = UL_MAX_TITLE_BUFFER_SIZE;

    PAGED_CODE();

    ASSERT(IS_VALID_LOG_FILE_ENTRY(pFile));
    ASSERT(g_UlDisableLogBuffering == 0);
    ASSERT(UlDbgPushLockOwnedExclusive(&pFile->EntryPushLock));

    UlTrace(LOGGING,("Http!UlpWriteToLogFileExclusive: pEntry %p\n", pFile));

    //
    // First append title to the temp buffer to calculate the size of 
    // the title if we need to write the title as well.
    //
    
    if (!pFile->Flags.LogTitleWritten) 
    {
        UlpAppendW3CLogTitle(pFile, TitleBuffer, &TitleBufferSize);
        RecordSizePlusTitle += TitleBufferSize;
    }

    //
    // Now check log file overflow.
    //
    
    if (UlpIsLogFileOverFlow(pFile,RecordSizePlusTitle))
    {
        //
        // We already acquired the LogListResource Shared and the
        // entry eresource exclusive. Therefore ReCycle is fine. Look
        // at the comment in UlpWriteToLogFile.
        //

        Status = UlpRecycleLogFile(pFile);
    }

    if (pFile->pLogFile==NULL || !NT_SUCCESS(Status))
    {
        //
        // If somehow the logging ceased and handle released,it happens
        // when recycle isn't able to write to the log drive.
        //

        return Status;
    }

    pLogBuffer = pFile->LogBuffer;
    if (pLogBuffer)
    {
        //
        // There are two conditions we execute the following if block
        // 1. We were blocked on eresource exclusive and before us some 
        // other thread already take care of the buffer flush or recycling.
        // 2. Reconfiguration happened and log attempt needs to write the
        // title again.
        //
        
        if (RecordSizePlusTitle + pLogBuffer->BufferUsed <= g_UlLogBufferSize)
        {
            //
            // If this is the first log attempt after a reconfig, then we have
            // to write the title here. Reconfig doesn't immediately write the
            // title but rather depend on us by setting the LogTitleWritten flag
            // to false.
            //
            
            if (!pFile->Flags.LogTitleWritten)
            {
                ASSERT(RecordSizePlusTitle > RecordSize);
                ASSERT(pFile->Format == HttpLoggingTypeW3C);
                
                UlpAppendW3CLogTitle(pFile, NULL, NULL);
                pFile->Flags.LogTitleWritten = 1;
                pFile->Flags.TitleFlushPending = 1;
            }

            UlpAppendToLogBuffer(
                pFile,
                pLogBuffer->BufferUsed,
                RecordSize,
                pRecord,
                UsedOffset1,
                UsedOffset2
                );
            
            pLogBuffer->BufferUsed += RecordSize;

            return STATUS_SUCCESS;
        }

        //
        // Flush out the buffer first then proceed with allocating a new one.
        //

        Status = UlpFlushLogFile(pFile);
        if (!NT_SUCCESS(Status))
        {            
            return Status;
        }
    }

    ASSERT(pFile->LogBuffer == NULL);
    
    //
    // This can be the very first log attempt or the previous allocation
    // of LogBuffer failed, or the previous hit flushed and deallocated 
    // the old buffer. In either case, we allocate a new one,append the
    // (title plus) new record and return for more/shared processing.
    //

    pLogBuffer = pFile->LogBuffer = UlPplAllocateLogFileBuffer();
    if (pLogBuffer == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    //
    // Very first attempt needs to write the title, as well as the attempt
    // which causes the log file recycling. Both cases comes down here
    //
    
    if (!pFile->Flags.LogTitleWritten)
    {
        ASSERT(pFile->Format == HttpLoggingTypeW3C);
        
        UlpAppendW3CLogTitle(pFile, NULL, NULL);
        pFile->Flags.LogTitleWritten = 1;
        pFile->Flags.TitleFlushPending = 1;
    }

    UlpAppendToLogBuffer(
        pFile,
        pLogBuffer->BufferUsed,
        RecordSize,
        pRecord,
        UsedOffset1,
        UsedOffset2
        );

    pLogBuffer->BufferUsed += RecordSize;

    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    Create or open a new file from the existing fully qualifed file name on 
    the entry.
    
Arguments:

    pEntry  : Corresponding entry that we are closing and opening 
              the log files for.

    pConfigGroup : Current configuration for the entry.
              
--***************************************************************************/

NTSTATUS
UlpCreateLogFile(
    IN OUT PUL_LOG_FILE_ENTRY  pEntry,
    IN     PUL_CONFIG_GROUP_OBJECT pConfigGroup
    )
{
    NTSTATUS Status;
    PUNICODE_STRING pDirectory;

    //
    // Sanity check.
    //

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));
    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));    

    pDirectory = &pConfigGroup->LoggingConfig.LogFileDir;

    UlTrace(LOGGING,("Http!UlpCreateLogFile: pEntry %p\n", pEntry));

    //
    // It's possible that LogFileDir.Buffer could be NULL, 
    // if the allocation failed during the Set cgroup ioctl.
    //
    
    if (pDirectory == NULL || pDirectory->Buffer == NULL)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build the fully qualified file name.
    //
    
    Status = UlRefreshFileName(pDirectory, 
                               &pEntry->FileName,
                               &pEntry->pShortName
                               );    
    if (!NT_SUCCESS(Status))
    {
        return Status;  
    }

    //
    // Set the sequence number stale so that the recylcler below can
    // obtain the proper number by scanning the directory.
    //
    
    pEntry->Flags.StaleSequenceNumber = 1;

    //
    // This is the first time we are creating this log file,
    // set the time to expire stale so that recycle will
    // calculate it for us.
    //
    
    pEntry->Flags.StaleTimeToExpire = 1;

    //
    // After this, recycle does the whole job for us.
    //

    Status = UlpRecycleLogFile(pEntry);
    
    if (!NT_SUCCESS(Status))
    {                
        UlTrace(LOGGING,(
                "Http!UlpCreateLogFile: Filename: %S Status %08lx\n",
                pEntry->FileName.Buffer,
                Status
                ));
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    When logging configuration happens we create the entry but not the log
    file itself yet. Log file itself will be created when the first request 
    comes in. Please look at UlpCreateLogFile.
    
Arguments:

    pConfigGroup - Supplies the necessary information for constructing the
                   log file entry.
    pUserConfig  - Logging config from the user.

--***************************************************************************/

NTSTATUS
UlCreateLogEntry(
    IN OUT PUL_CONFIG_GROUP_OBJECT    pConfigGroup,
    IN     PHTTP_CONFIG_GROUP_LOGGING pUserConfig
    )
{
    NTSTATUS Status;
    PUL_LOG_FILE_ENTRY pNewEntry; 
    PHTTP_CONFIG_GROUP_LOGGING pConfig;    
        
    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));

    Status    = STATUS_SUCCESS;
    pNewEntry = NULL;    

    //
    // We have to acquire the LogListresource exclusively, prior to
    // the operations Create/Remove/ReConfig and anything touches to
    // the cgroup log parameters.
    //

    UlAcquirePushLockExclusive(&g_pUlNonpagedData->LogListPushLock);

    ASSERT(pConfigGroup->pLogFileEntry == NULL);

    //
    // Save the user logging info to the config group.
    //

    pConfigGroup->LoggingConfig = *pUserConfig;
    pConfig = &pConfigGroup->LoggingConfig;
        
    pConfig->LogFileDir.Buffer =
            (PWSTR) UL_ALLOCATE_ARRAY(
                PagedPool,
                UCHAR,
                pConfig->LogFileDir.MaximumLength,
                UL_CG_LOGDIR_POOL_TAG
                );
    if (pConfig->LogFileDir.Buffer == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    RtlCopyMemory(
        pConfig->LogFileDir.Buffer,
        pUserConfig->LogFileDir.Buffer,
        pUserConfig->LogFileDir.MaximumLength
        );

    pConfig->Flags.Present  = 1;
    pConfig->LoggingEnabled = TRUE;

    //
    // Now add a new entry to the global list of log entries.
    //

    Status = UlpConstructLogEntry(pConfig,&pNewEntry);
    if (!NT_SUCCESS(Status))
        goto end;

    //
    // Get the site id from the cgroup. Site id doesn't change
    // during the lifetime of the cgroup.
    //

    pNewEntry->SiteId = pConfigGroup->SiteId;
    
    UlpInsertLogEntry(pNewEntry);

    pConfigGroup->pLogFileEntry = pNewEntry;

    UlTrace(LOGGING,
      ("Http!UlCreateLogEntry: pEntry %p created for %S pConfig %p Rollover %d\n",
             pNewEntry,
             pConfig->LogFileDir.Buffer,
             pConfigGroup,
             pNewEntry->Flags.LocaltimeRollover
             ));

end:
    if (!NT_SUCCESS(Status))
    {
        UlTrace(LOGGING,("Http!UlCreateLogEntry: dir %S failure %08lx\n",
                 pConfig->LogFileDir.Buffer,
                 Status
                 ));

        //
        // Restore the logging disabled state on the cgroup, free the
        // memory for the dir.
        //
        
        if (pConfig->LogFileDir.Buffer)
        {
            UL_FREE_POOL(pConfig->LogFileDir.Buffer,
                          UL_CG_LOGDIR_POOL_TAG
                          );
        }
        pConfig->LogFileDir.Buffer = NULL;

        ASSERT(pConfigGroup->pLogFileEntry == NULL);

        pConfig->Flags.Present  = 0;
        pConfig->LoggingEnabled = FALSE;
        
    }

    UlReleasePushLockExclusive(&g_pUlNonpagedData->LogListPushLock);

    return Status;
}

/***************************************************************************++

Routine Description:

    Inserts a log file entry to our global log entry list.
    REQUIRES caller to have LogListresource EXCLUSIVELY.

Arguments:

    pEntry      - The log file entry to be added to the global list
    pTimeFields - The current time fields.

--***************************************************************************/

VOID
UlpInsertLogEntry(
    IN PUL_LOG_FILE_ENTRY  pEntry
    )
{
    LONG listSize;
    HTTP_LOGGING_PERIOD Period;
    KIRQL oldIrql;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));

    //
    // add to the list
    //

    InsertHeadList(&g_LogListHead, &pEntry->LogFileListEntry);

    Period = pEntry->Period;

    listSize = InterlockedIncrement(&g_LogListEntryCount);

    ASSERT(listSize >= 1);

    //
    // Time to start the Log Timer if we haven't done it yet.
    // Once we start this timer it keeps working until the
    // termination of the driver. Start the timer only if the
    // entry is running on a time dependent log format.
    //
    
    if (Period != HttpLoggingPeriodMaxSize)
    {
        UlAcquireSpinLock(&g_LogTimer.SpinLock, &oldIrql);
        if (g_LogTimer.Started == FALSE)
        {
            UlSetLogTimer(&g_LogTimer);
            g_LogTimer.Started = TRUE;
        }        
        UlReleaseSpinLock(&g_LogTimer.SpinLock, oldIrql);
    }

    //
    // Go ahead and start the buffer timer as soon as we have 
    // a log entry.
    //

    UlAcquireSpinLock(&g_BufferTimer.SpinLock, &oldIrql);
    if (g_BufferTimer.Started == FALSE)
    {
        UlSetBufferTimer(&g_BufferTimer);
        g_BufferTimer.Started = TRUE;
    }
    UlReleaseSpinLock(&g_BufferTimer.SpinLock, oldIrql);
    
}

/***************************************************************************++

Routine Description:

    Removes a log file entry from our global log entry list. Also cleans up 
    the config group's logging settings ( only directory string )

Arguments:

    pEntry  - The log file entry to be removed from the global list

--***************************************************************************/

VOID
UlRemoveLogEntry(
    IN PUL_CONFIG_GROUP_OBJECT pConfigGroup
    )
{
    LONG  listSize;
    PUL_LOG_FILE_ENTRY  pEntry;
    
    //
    // Sanity check.
    //

    PAGED_CODE();

    UlAcquirePushLockExclusive(&g_pUlNonpagedData->LogListPushLock);
        
    //
    // Clean up config group's directory string.
    //
    
    if (pConfigGroup->LoggingConfig.LogFileDir.Buffer)
    {
        UL_FREE_POOL(
            pConfigGroup->LoggingConfig.LogFileDir.Buffer,
            UL_CG_LOGDIR_POOL_TAG );
    }

    pEntry = pConfigGroup->pLogFileEntry;
    if (pEntry == NULL)
    {
        UlReleasePushLockExclusive(&g_pUlNonpagedData->LogListPushLock);
        return;
    }
    
    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));

    RemoveEntryList(&pEntry->LogFileListEntry);

    pEntry->LogFileListEntry.Flink =
        pEntry->LogFileListEntry.Blink = NULL;

    if (pEntry->pLogFile != NULL)
    {
        //
        // Flush the buffer, close the file and mark the entry
        // inactive.
        //

        UlpMakeEntryInactive(pEntry);
    }

    //
    // Free up the FileName (allocated when the entry becomes active
    // otherwise it's empty)
    //

    if (pEntry->FileName.Buffer)
    {
        UL_FREE_POOL(pEntry->FileName.Buffer,UL_CG_LOGDIR_POOL_TAG);
        pEntry->FileName.Buffer = NULL;
    }
    
    //
    // Delete the entry eresource
    //

    UlDeletePushLock(&pEntry->EntryPushLock);

    listSize = InterlockedDecrement(&g_LogListEntryCount);

    ASSERT(listSize >= 0);

    UlTrace(LOGGING,
            ("Http!UlRemoveLogFileEntry: pEntry %p removed\n",
             pEntry
             ));

    if (pEntry->LogBuffer)
    {
        UlPplFreeLogFileBuffer(pEntry->LogBuffer);
    }

    UL_FREE_POOL_WITH_SIG(pEntry,UL_LOG_FILE_ENTRY_POOL_TAG);

    UlReleasePushLockExclusive(&g_pUlNonpagedData->LogListPushLock);
}

/***************************************************************************++

Routine Description:

    Initializes the Log recycling and the buffering timers.

--***************************************************************************/
VOID
UlpInitializeTimers(
    VOID
    )
{
    // Guard against multiple inits
    
    if (g_InitLogTimersCalled) return;
    g_InitLogTimersCalled = TRUE;
    
    // Log timer

    g_LogTimer.Initialized  = TRUE;
    g_LogTimer.Started      = FALSE;
    
    g_LogTimer.Period       = -1;
    g_LogTimer.PeriodType   = UlLogTimerPeriodNone;

    UlInitializeSpinLock(&g_LogTimer.SpinLock, "g_LogTimersSpinLock");
    
    KeInitializeDpc(
        &g_LogTimer.DpcObject,       // DPC object
        &UlLogTimerDpcRoutine,       // DPC routine
        NULL                         // context
        );

    KeInitializeTimer(&g_LogTimer.Timer);
    
    // Buffer timer

    g_BufferTimer.Initialized = TRUE;
    g_BufferTimer.Started     = FALSE;
    
    g_BufferTimer.Period      = -1; // Not used
    g_BufferTimer.PeriodType  = UlLogTimerPeriodNone; // Not used

    UlInitializeSpinLock(&g_BufferTimer.SpinLock, "g_BufferTimersSpinLock");
    
    KeInitializeDpc(
        &g_BufferTimer.DpcObject,    // DPC object
        &UlBufferTimerDpcRoutine,    // DPC routine
        NULL                         // context
        );

    KeInitializeTimer(&g_BufferTimer.Timer);
    
}

/***************************************************************************++

Routine Description:

    Terminates the Log & buffering Timers

--***************************************************************************/

VOID
UlpTerminateTimers(
    VOID
    )
{
    KIRQL oldIrql;

    // Guard against multiple terminates
    
    if (!g_InitLogTimersCalled) return;
    g_InitLogTimersCalled = FALSE;
    
    // Log timer 

    UlAcquireSpinLock(&g_LogTimer.SpinLock, &oldIrql);

    g_LogTimer.Initialized = FALSE;

    KeCancelTimer(&g_LogTimer.Timer);
    
    UlReleaseSpinLock(&g_LogTimer.SpinLock,  oldIrql);
    

    // Buffer timer 

    UlAcquireSpinLock(&g_BufferTimer.SpinLock, &oldIrql);

    g_BufferTimer.Initialized = FALSE;

    KeCancelTimer(&g_BufferTimer.Timer);
    
    UlReleaseSpinLock(&g_BufferTimer.SpinLock,  oldIrql);

}

/***************************************************************************++

Routine Description:

    Work item for the threadpool that goes thru the log list and
    cycle the necessary logs.

Arguments:

    PUL_WORK_ITEM   -  Ignored but freed up once we are done.

--***************************************************************************/

VOID
UlLogTimerHandler(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    NTSTATUS Status;
    PLIST_ENTRY pLink;
    PUL_LOG_FILE_ENTRY  pEntry;
    BOOLEAN Picked;
    KIRQL OldIrql;

    PAGED_CODE();

    UlTrace(LOGGING,("Http!UlLogTimerHandler: Scanning the log entries ...\n"));

    UlAcquirePushLockExclusive(&g_pUlNonpagedData->LogListPushLock);

    // Attempt to reinit the GMT offset every hour, to pickup the changes
    // because of the day light changes. Synced by the logging eresource.

    UlpGetGMTOffset();

    for (pLink  = g_LogListHead.Flink;
         pLink != &g_LogListHead;
         pLink  = pLink->Flink
         )
    {
        pEntry = CONTAINING_RECORD(
                    pLink,
                    UL_LOG_FILE_ENTRY,
                    LogFileListEntry
                    );
        //
        // We should not recycle this entry if it's period
        // is not time based but size based.
        //

        UlAcquirePushLockExclusive(&pEntry->EntryPushLock);

        switch(g_LogTimer.PeriodType)
        {
            //
            // Rollover table:
            //
            //          LocaltimeRollover
            //          TRUE        FALSE (Default)
            // Format
            // ------------------------------
            // W3C  |   Local   |   GMT     |
            //      -------------------------
            // NCSA |   Local   |   Local   |
            //      -------------------------
            // IIS  |   Local   |   Local   |
            //      -------------------------
            //
            // If the timer waked up at the beginning of an hour 
            // for GMT, LocalTime or Both. E.g.
            //
            // 1) For Pacific Time Zone: (-8:00)
            //    PeriodType will always be UlLogTimerPeriodBoth
            //    and all of the entries will rollover regardless
            //    of their format.
            //
            // 2) For Adelaide (Australia) (+9:30)
            //    Timer will wake up seperately for GMT & Local.
            //    NCSA & IIS entries will always rollover at 
            //    UlLogTimerPeriodLocal, W3C will rollover at 
            //    UlLogTimerPeriodLocal only if LocaltimeRollover 
            //    is set otherwise it will rollover at 
            //    UlLogTimerPeriodGMT.
            //

            case UlLogTimerPeriodGMT:
                  //
                  // Only entries with W3C format type may rollover 
                  // at GMT only time interval.
                  //
            Picked = (BOOLEAN) ((pEntry->Flags.LocaltimeRollover == 0)
                        && (pEntry->Format == HttpLoggingTypeW3C));                  
            break;

            case UlLogTimerPeriodLocal:
                  //
                  // Entries with NCSA or IIS format type always rollover
                  // at Local time interval. W3C may also rollover if 
                  // LocaltimeRollover is set. 
                  //
            Picked = (BOOLEAN) ((pEntry->Flags.LocaltimeRollover == 1)
                        || (pEntry->Format != HttpLoggingTypeW3C));                  
            break;

            case UlLogTimerPeriodBoth:
                  //
                  // We really don't care what format the entry has, 
                  // since the local time and GMT hourly beginnings are 
                  // aligned.
                  //
            Picked = TRUE;
            break;

            default:
            ASSERT(!"Unexpected timer period type !\n");
            Picked = FALSE;
            break;
        }
        
        if (Picked &&
            pEntry->Flags.Active &&
            pEntry->Period != HttpLoggingPeriodMaxSize
            )
        {            
            if (pEntry->TimeToExpire == 1)
            {
                pEntry->Flags.StaleTimeToExpire = 1;

                //
                // Mark the entry inactive and postpone the recycle 
                // until the next request arrives.
                //

                Status = UlpMakeEntryInactive(pEntry);
            }
            else
            {
                //
                // Just decrement the hourly counter for this time.
                //
                
                pEntry->TimeToExpire -= 1;
            }            
        }

        UlReleasePushLockExclusive(&pEntry->EntryPushLock);
    }

    UlReleasePushLockExclusive(&g_pUlNonpagedData->LogListPushLock);

    //
    // Free the memory allocated (ByDpcRoutine below) for 
    // this work item.
    //

    UL_FREE_POOL( pWorkItem, UL_WORK_ITEM_POOL_TAG );

    //
    // Now reset the timer for the next hour.
    //

    UlAcquireSpinLock(&g_LogTimer.SpinLock, &OldIrql);

    if (g_LogTimer.Initialized == TRUE)
    {
        UlSetLogTimer(&g_LogTimer);
    }
    
    UlReleaseSpinLock(&g_LogTimer.SpinLock, OldIrql);

}

/***************************************************************************++

Routine Description:

    Allocates and queues a work item to do the the actual work at lowered
    irql.

Arguments:

    Ignored

--***************************************************************************/

VOID
UlLogTimerDpcRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )
{
    PUL_WORK_ITEM pWorkItem;

    //
    // Parameters are ignored.
    //
    
    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(DeferredContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    UlAcquireSpinLockAtDpcLevel(&g_LogTimer.SpinLock);

    if (g_LogTimer.Initialized == TRUE)
    {
        //
        // It's not possible to acquire the resource which protects
        // the log list at DISPATCH_LEVEL therefore we will queue a
        // work item for this.
        //

        pWorkItem = (PUL_WORK_ITEM) UL_ALLOCATE_POOL(
            NonPagedPool,
            sizeof(*pWorkItem),
            UL_WORK_ITEM_POOL_TAG
            );

        if (pWorkItem)
        {
            UlInitializeWorkItem(pWorkItem);
            UL_QUEUE_WORK_ITEM(pWorkItem, &UlLogTimerHandler);
        }
        else
        {
            UlTrace(LOGGING,("Http!UlLogTimerDpcRoutine: Not enough memory!\n"));
        }
        
    }

    UlReleaseSpinLockFromDpcLevel(&g_LogTimer.SpinLock);   
}

/***************************************************************************++

Routine Description:

    Queues a passive worker for the lowered irql.

Arguments:

    Ignored

--***************************************************************************/

VOID
UlBufferTimerDpcRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )
{
    PUL_WORK_ITEM pWorkItem;

    //
    // Parameters are ignored.
    //
    
    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(DeferredContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    UlAcquireSpinLockAtDpcLevel(&g_BufferTimer.SpinLock);

    if (g_BufferTimer.Initialized == TRUE)
    {
        //
        // It's not possible to acquire the resource which protects
        // the log list at DISPATCH_LEVEL therefore we will queue a
        // work item for this.
        //

        pWorkItem = (PUL_WORK_ITEM) UL_ALLOCATE_POOL(
            NonPagedPool,
            sizeof(*pWorkItem),
            UL_WORK_ITEM_POOL_TAG
            );

        if (pWorkItem)
        {
            UlInitializeWorkItem(pWorkItem);
            UL_QUEUE_WORK_ITEM(pWorkItem, &UlBufferTimerHandler);
        }
        else
        {
            UlTrace(LOGGING,("Http!UlBufferTimerDpcRoutine: Not enough memory.\n"));
        }
    }

    UlReleaseSpinLockFromDpcLevel(&g_BufferTimer.SpinLock);
    
}

/***************************************************************************++

Routine Description:

    UlLogBufferTimerHandler :

        Work item for the threadpool that goes thru the log list and
        flush the log's file buffers.

Arguments:

    PUL_WORK_ITEM   -  Ignored but cleaned up at the end

--***************************************************************************/

VOID
UlBufferTimerHandler(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    NTSTATUS Status;
    PLIST_ENTRY pLink;
    PUL_LOG_FILE_ENTRY pEntry;

    PAGED_CODE();

    UlTrace(LOGGING,("Http!UlBufferTimerHandler: Scanning the log entries ...\n"));

    UlAcquirePushLockShared(&g_pUlNonpagedData->LogListPushLock);

    for (pLink  = g_LogListHead.Flink;
         pLink != &g_LogListHead;
         pLink  = pLink->Flink
         )
    {        
        pEntry = CONTAINING_RECORD(
                    pLink,
                    UL_LOG_FILE_ENTRY,
                    LogFileListEntry
                    );

        UlAcquirePushLockExclusive(&pEntry->EntryPushLock);

        //
        // Entry may be staying inactive since no request came in yet.
        //
        
        if (pEntry->Flags.Active)
        {        
            if (pEntry->Flags.RecyclePending)
            {                
                //
                // Try to resurrect it back.
                //
                
                Status = UlpRecycleLogFile(pEntry);
            }
            else
            {
                //
                // Everything is fine simply flush.
                //

                if (NULL != pEntry->LogBuffer  && 0 != pEntry->LogBuffer->BufferUsed)
                {
                    Status = UlpFlushLogFile(pEntry);
                }
                else
                {
                    //
                    // Decrement the idle counter and close the file if necessary.
                    //

                    ASSERT( pEntry->TimeToClose > 0 );
                    
                    if (pEntry->TimeToClose == 1)
                    {
                        //
                        // Entry was staying inactive for too long, disable it.
                        // But next recycle should recalculate the timeToExpire
                        // or determine the proper sequence number according to
                        // the current period type.
                        //
                        
                        if (pEntry->Period == HttpLoggingPeriodMaxSize)
                        {
                            pEntry->Flags.StaleSequenceNumber = 1;
                        }
                        else
                        {
                            pEntry->Flags.StaleTimeToExpire = 1;    
                        }

                        Status = UlpMakeEntryInactive(pEntry);
                    }
                    else
                    {
                        pEntry->TimeToClose -= 1;
                    }                    
                }     
            }        
        }

        UlReleasePushLockExclusive(&pEntry->EntryPushLock);
    }

    UlReleasePushLockShared(&g_pUlNonpagedData->LogListPushLock);

    //
    // Free the memory allocated (ByDpcRoutine below) to
    // this work item.
    //

    UL_FREE_POOL( pWorkItem, UL_WORK_ITEM_POOL_TAG );
}


/***************************************************************************++

Routine Description:

    UlReconfigureLogEntry :

        This function implements the logging reconfiguration per attribute.
        Everytime config changes happens we try to update the existing logging
        parameters here.

Arguments:

    pConfig - corresponding cgroup object

    pCfgCurrent - Current logging config on the cgroup object
    pCfgNew     - New logging config passed down by the user.

--***************************************************************************/

NTSTATUS
UlReConfigureLogEntry(
    IN  PUL_CONFIG_GROUP_OBJECT     pConfigGroup,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgCurrent,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgNew
    )
{
    NTSTATUS Status ;
    PUL_LOG_FILE_ENTRY pEntry;
    BOOLEAN  HaveToReCycle;

    //
    // Sanity check first
    //

    PAGED_CODE();
    Status = STATUS_SUCCESS;
    HaveToReCycle = FALSE;

    UlTrace(LOGGING,("Http!UlReConfigureLogEntry: entry %p\n",
             pConfigGroup->pLogFileEntry));

    if (pCfgCurrent->LoggingEnabled==FALSE && pCfgNew->LoggingEnabled==FALSE)
    {
        //
        // Do nothing. Not even update the fields. As soon as we get enable,
        // field update will take place anyway.
        //

        return Status;
    }

    //
    // No matter what ReConfiguration should acquire the LogListResource
    // exclusively.
    //

    UlAcquirePushLockExclusive(&g_pUlNonpagedData->LogListPushLock);

    pEntry = pConfigGroup->pLogFileEntry;
    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));

    if (pCfgCurrent->LoggingEnabled==TRUE  && pCfgNew->LoggingEnabled==FALSE)
    {
        //
        // Disable the entry if necessary.
        //

        if (pEntry->Flags.Active == 1)
        {
            Status = UlpMakeEntryInactive(pEntry);        
        }

        pCfgCurrent->LoggingEnabled = FALSE;
        goto end;
    }
    else
    {
        pCfgCurrent->LoggingEnabled = TRUE;
    }
    
    //
    // If LogEntry is Inactive (means no request served for this site yet and
    // the LogFile itself hasn't been created yet), all we have to do is flush
    // the settings on the LogEntry, the cgroup and then return.
    //

    if (!pEntry->Flags.Active)
    {
        ASSERT(pEntry->pLogFile == NULL);
        
        if (RtlCompareUnicodeString(&pCfgNew->LogFileDir, 
                                    &pCfgCurrent->LogFileDir, TRUE) 
                                    != 0)
        {
            //
            // Store the new directory in the cgroup even if the entry is
            // inactive. Discard the return value, if failure happens we 
            // keep the old directory.
            //
            
            UlCopyLogFileDir(
                &pCfgCurrent->LogFileDir,
                &pCfgNew->LogFileDir
                );

            //
            // If creation fails later, we should event log.
            //
            
            pEntry->Flags.CreateFileFailureLogged = 0;
        }
        
        pEntry->Format = pCfgNew->LogFormat;
        pCfgCurrent->LogFormat = pCfgNew->LogFormat;
            
        pEntry->Period = (HTTP_LOGGING_PERIOD) pCfgNew->LogPeriod;
        pCfgCurrent->LogPeriod = pCfgNew->LogPeriod;
            
        pEntry->TruncateSize = pCfgNew->LogFileTruncateSize;
        pCfgCurrent->LogFileTruncateSize = pCfgNew->LogFileTruncateSize;
            
        pEntry->LogExtFileFlags = pCfgNew->LogExtFileFlags;
        pCfgCurrent->LogExtFileFlags = pCfgNew->LogExtFileFlags;

        pCfgCurrent->LocaltimeRollover = pCfgNew->LocaltimeRollover;
        pEntry->Flags.LocaltimeRollover = (pCfgNew->LocaltimeRollover ? 1 : 0);

        pCfgCurrent->SelectiveLogging = pCfgNew->SelectiveLogging;
         
        if (pEntry->Format != HttpLoggingTypeW3C)
        {
            pEntry->Flags.LogTitleWritten = 1;
        }
        
        goto end;
    }
        
    //
    // if the entry was active then proceed down to do proper reconfiguration
    // and recyle immediately if it's necessary.
    //

    Status = UlCheckLogDirectory(&pCfgNew->LogFileDir);
    if (!NT_SUCCESS(Status))
    {
        // Otherwise keep the old settings
        goto end;
    }    
                    
    if (RtlCompareUnicodeString(
           &pCfgNew->LogFileDir, &pCfgCurrent->LogFileDir, TRUE) != 0)
    {
        //
        // Store the new directory in the config group.
        //

        Status = UlCopyLogFileDir(&pCfgCurrent->LogFileDir,
                                    &pCfgNew->LogFileDir);
        if (!NT_SUCCESS(Status))
        {
            goto end;
        }
        
        //
        // Rebuild the fully qualified file name.
        //
        
        Status = UlRefreshFileName(&pCfgCurrent->LogFileDir, 
                                     &pEntry->FileName,
                                     &pEntry->pShortName
                                     );        
        if (!NT_SUCCESS(Status))
        {
            goto end;
        }        

        //
        // Set the sequence number stale so that the recylcler below can
        // obtain the proper number by scanning the directory.
        //
        
        pEntry->Flags.StaleSequenceNumber = 1;

        HaveToReCycle = TRUE;

    }

    if (pCfgNew->LogFormat != pCfgCurrent->LogFormat)
    {
        pCfgCurrent->LogFormat = pCfgNew->LogFormat;
        pEntry->Format = pCfgNew->LogFormat;

        pEntry->Flags.StaleTimeToExpire   = 1;
        pEntry->Flags.StaleSequenceNumber = 1;

        HaveToReCycle = TRUE;        
    }

    if (pCfgNew->LogPeriod != pCfgCurrent->LogPeriod)
    {
        pCfgCurrent->LogPeriod = pCfgNew->LogPeriod;
        pEntry->Period = (HTTP_LOGGING_PERIOD) pCfgNew->LogPeriod;

        pEntry->Flags.StaleTimeToExpire   = 1;
        pEntry->Flags.StaleSequenceNumber = 1;

        HaveToReCycle = TRUE;        
    }

    if (pCfgNew->LogFileTruncateSize != pCfgCurrent->LogFileTruncateSize)
    {                
        if (TRUE == UlUpdateLogTruncateSize(
                        pCfgNew->LogFileTruncateSize,
                       &pCfgCurrent->LogFileTruncateSize,
                       &pEntry->TruncateSize,
                        pEntry->TotalWritten
                        ))
        {
            HaveToReCycle = TRUE;
        }
    }

    if (pCfgNew->LogExtFileFlags != pCfgCurrent->LogExtFileFlags)
    {
        //
        // Just a change in the flags should not cause us to recyle.
        // Unless ofcourse something else is also changed.
        //

        pCfgCurrent->LogExtFileFlags = pCfgNew->LogExtFileFlags;
        pEntry->LogExtFileFlags = pCfgNew->LogExtFileFlags;

        if (pEntry->Format == HttpLoggingTypeW3C)
        {
            pEntry->Flags.LogTitleWritten = 0;
        }
    }

    if (pCfgNew->LocaltimeRollover != pCfgCurrent->LocaltimeRollover)
    {
        //
        // Need to reclycle if the format is W3C.
        //

        pCfgCurrent->LocaltimeRollover = pCfgNew->LocaltimeRollover;
        pEntry->Flags.LocaltimeRollover = (pCfgNew->LocaltimeRollover ? 1 : 0);
            
        HaveToReCycle = TRUE;
    }

    //
    // Copy over the new selective logging criteria. No change is required
    // at this time.
    //

    pCfgCurrent->SelectiveLogging = pCfgNew->SelectiveLogging;

    if (HaveToReCycle)
    {
        //
        // Mark the entry inactive and postpone the recycle until the next 
        // request arrives.
        //

        Status = UlpMakeEntryInactive(pEntry);
    }

  end:

    if (!NT_SUCCESS(Status))
    {
        UlTrace(LOGGING,("Http!UlReConfigureLogEntry: entry %p, failure %08lx\n",
                pEntry,
                Status
                ));
    }

    UlReleasePushLockExclusive(&g_pUlNonpagedData->LogListPushLock);

    return Status;
    
} // UlReConfigureLogEntry

/***************************************************************************++

Routine Description:

    Marks the entry inactive, closes the existing file.
    Caller should hold the log list eresource exclusive.
    
Arguments:

    pEntry - The log file entry which we will mark inactive.

--***************************************************************************/

NTSTATUS
UlpMakeEntryInactive(
    IN OUT PUL_LOG_FILE_ENTRY pEntry
    )
{
    //
    // Sanity checks
    //
    
    PAGED_CODE();
    
    UlTrace(LOGGING,("Http!UlpMakeEntryInactive: entry %p disabled.\n",
             pEntry
             ));

    //
    // Flush and close the old file until the next recycle.
    //

    if (pEntry->pLogFile != NULL)
    {
        UlpFlushLogFile(pEntry);

        UlCloseLogFile(&pEntry->pLogFile);
    }

    //
    // Mark this inactive so that the next http hit awakens the entry.
    //
    
    pEntry->Flags.Active = 0;

    return STATUS_SUCCESS;    
}

/***************************************************************************++

Routine Description:

    When the config group, the one that owns the log entry is disabled or lost
    all of its URLs then we temporarly disable the entry by marking it inactive
    until the config group get enabled and/or receives a URL.
    
Arguments:

    pEntry - The log file entry which we will disable.

--***************************************************************************/

NTSTATUS
UlDisableLogEntry(
    IN OUT PUL_LOG_FILE_ENTRY pEntry
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
        
    PAGED_CODE();

    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));

    UlAcquirePushLockExclusive(&g_pUlNonpagedData->LogListPushLock);

    //
    // If the entry is already disabled. Perhaps because of a recent reconfig, 
    // then just bail out.
    //

    if (pEntry->Flags.Active == 1)
    {
        //
        // Once the entry is disabled, it will be awaken when the next hit
        // happens.And that obviously cannot happen before cgroup receives 
        // a new URL.
        //

        Status = UlpMakeEntryInactive(pEntry);        
    }

    UlReleasePushLockExclusive(&g_pUlNonpagedData->LogListPushLock);
    
    return Status;    
}

/***************************************************************************++

Routine Description:

    Allocates the necessary file entry from non-paged pool. This entry 
    get removed from the list when the corresponding config group object
    has been destroyed. At that time RemoveLogFile entry called and
    it frees this memory.

Arguments:

    pConfig         - corresponding cgroup object
    ppEntry         - will point to newly created entry.

--***************************************************************************/

NTSTATUS
UlpConstructLogEntry(
    IN  PHTTP_CONFIG_GROUP_LOGGING pConfig,
    OUT PUL_LOG_FILE_ENTRY       * ppEntry
    )
{
    NTSTATUS            Status;
    PUL_LOG_FILE_ENTRY  pEntry;
    
    //
    // Sanity check and init.
    //
    
    PAGED_CODE();

    ASSERT(pConfig);
    ASSERT(ppEntry);

    Status = STATUS_SUCCESS;
    pEntry = NULL;

    //
    // Allocate a memory for our  new logfile entry in the list. To avoid the 
    // frequent  reallocs  for the log entry.E.g. we receive a  timer  update 
    // and the filename changes according to new time.We will try to allocate 
    // a fixed amount here for all the possible file_names ( But this doesn't
    // include the log_dir changes may happen through cgroup. In that case we 
    // will reallocate a new one) It should be nonpaged because it holds an 
    // eresource.
    //

    pEntry = UL_ALLOCATE_STRUCT(
                NonPagedPool,
                UL_LOG_FILE_ENTRY,
                UL_LOG_FILE_ENTRY_POOL_TAG
                );
    if (pEntry == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    pEntry->Signature = UL_LOG_FILE_ENTRY_POOL_TAG;

    //
    // No filename yet, it will generated when the first hit happens,
    // and before we actually create the log file.
    //
    
    pEntry->FileName.Buffer = NULL;
    pEntry->FileName.Length = 0;
    pEntry->FileName.MaximumLength = 0;
        
    //
    // Init the entry eresource
    //   
    UlInitializePushLock(
        &pEntry->EntryPushLock,
        "EntryPushLock",
        0,
        UL_LOG_FILE_ENTRY_POOL_TAG
        );

    //
    // No file handle or file until a request comes in.
    //
    pEntry->pLogFile = NULL;

    //
    // Set the private logging information from config group.
    //
    pEntry->Format          = pConfig->LogFormat;
    pEntry->Period          = (HTTP_LOGGING_PERIOD) pConfig->LogPeriod;
    pEntry->TruncateSize    = pConfig->LogFileTruncateSize;
    pEntry->LogExtFileFlags = pConfig->LogExtFileFlags;
    pEntry->SiteId          = 0;

    //
    // Time to initialize our Log Cycling parameter
    //
    pEntry->TimeToExpire    = 0;
    pEntry->TimeToClose     = 0;
    pEntry->SequenceNumber  = 1;
    pEntry->TotalWritten.QuadPart = (ULONGLONG) 0;

    //
    // The entry state bits 
    //
    pEntry->Flags.Value = 0;
    if (pEntry->Format != HttpLoggingTypeW3C)
    {
        pEntry->Flags.LogTitleWritten = 1;
    }

    if (pConfig->LocaltimeRollover)
    {
        pEntry->Flags.LocaltimeRollover = 1;
    }
    
    //
    // LogBuffer get allocated with the first incoming request
    //
    
    pEntry->LogBuffer = NULL;

    //
    // Lets happily return our entry
    //

    *ppEntry = pEntry;

    return STATUS_SUCCESS;
    
}

/***************************************************************************++

Routine Description:

    Small wrapper around handle recycle to ensure it happens under the system
    process context. 

Arguments:

    pEntry  - Points to the existing entry.

--***************************************************************************/

NTSTATUS
UlpRecycleLogFile(
    IN OUT PUL_LOG_FILE_ENTRY pEntry
    )
{
    NTSTATUS Status;

    PAGED_CODE();

    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));
    
    Status = UlQueueLoggingRoutine(
                (PVOID) pEntry,
                &UlpHandleRecycle
                );
    
    return Status;
}

/***************************************************************************++

Routine Description:

    This function requires to have the loglist resource shared,as well as
    the logfile entry mutex to be acquired.

    We do not want anybody to Create/Remove/ReConfig to the entry while
    we are working on it, therefore shared access to the loglist.

    We do not want anybody to Hit/Flush to the entry, therefore
    entry's mutex should be acquired.

    Or otherwise caller might have the loglist resource exclusively and
    this will automatically ensure the safety as well. As it is not
    possible for anybody else to acquire entry mutex first w/o having
    the loglist resource shared at least, according to the current
    design.

    Sometimes it may be necessary to scan the new directory to figure out
    the correct sequence numbe rand the file name. Especially after dir
    name reconfig and/or the period becomes MaskPeriod.

    * Always open/close the log files when running under system process. *

Arguments:

    pEntry  - Points to the existing entry.

--***************************************************************************/

NTSTATUS
UlpHandleRecycle(
    IN OUT PVOID            pContext
    )
{
    NTSTATUS                Status;
    PUL_LOG_FILE_ENTRY      pEntry;
    TIME_FIELDS             TimeFields;
    LARGE_INTEGER           TimeStamp;
    TIME_FIELDS             TimeFieldsLocal;
    LARGE_INTEGER           TimeStampLocal;    
    PUL_LOG_FILE_HANDLE     pLogFile;
    WCHAR                   _FileName[UL_MAX_FILE_NAME_SUFFIX_LENGTH + 1];
    UNICODE_STRING          FileName;
    BOOLEAN                 UncShare;
    BOOLEAN                 ACLSupport;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pEntry = (PUL_LOG_FILE_ENTRY) pContext;
    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));

    // Always create the log files when running under system process.    
    ASSERT(g_pUlSystemProcess == (PKPROCESS)IoGetCurrentProcess());
        
    Status = STATUS_SUCCESS;
    pLogFile = NULL;

    FileName.Buffer = _FileName;
    FileName.Length = 0;
    FileName.MaximumLength = sizeof(_FileName);
    
    //
    // We have two criterions for the log file name
    // its LogFormat and its LogPeriod
    //

    ASSERT(IS_VALID_ANSI_LOGGING_TYPE(pEntry->Format));
    ASSERT(pEntry->Period < HttpLoggingPeriodMaximum);
    ASSERT(pEntry->FileName.Length!=0);

    UlTrace( LOGGING, ("Http!UlpHandleRecycle: pEntry %p \n", pEntry ));

    //
    // This value is computed for the GMT time zone.
    //

    KeQuerySystemTime(&TimeStamp);
    RtlTimeToTimeFields(&TimeStamp, &TimeFields);

    ExSystemTimeToLocalTime(&TimeStamp, &TimeStampLocal);
    RtlTimeToTimeFields(&TimeStampLocal, &TimeFieldsLocal);    

    // If we need to scan the directory. Sequence number should start
    // from 1 again. Set this before constructing the log file name.

    if (pEntry->Flags.StaleSequenceNumber &&
        pEntry->Period==HttpLoggingPeriodMaxSize)
    {
        // Init otherwise if QueryDirectory doesn't find any it
        // will not update this value
        pEntry->SequenceNumber = 1;
    }

    //
    // Now construct the filename using the lookup table
    // And the current time
    //

    UlConstructFileName(
        pEntry->Period,
        UL_GET_LOG_FILE_NAME_PREFIX(pEntry->Format),
        DEFAULT_LOG_FILE_EXTENSION,
        &FileName,
        UL_PICK_TIME_FIELD(pEntry, &TimeFieldsLocal, &TimeFields),
        UTF8_LOGGING_ENABLED(),
        &pEntry->SequenceNumber
        );

    if ( pEntry->FileName.MaximumLength <= FileName.Length )
    {
        ASSERT(!"FileName buffer is not sufficient.");
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // Do the magic and renew the filename. Replace the old file
    // name with the new one.
    //

    ASSERT( pEntry->pShortName != NULL );

    //
    // Get rid of the old filename before flushing the
    // directories and reconcataneting the new file name
    // to the end again.
    //

    *((PWCHAR)pEntry->pShortName) = UNICODE_NULL;
    pEntry->FileName.Length =
        (USHORT) wcslen( pEntry->FileName.Buffer ) * sizeof(WCHAR);

    //
    // Create/Open the director(ies) first. This might be
    // necessary if we get called after an entry reconfiguration
    // and directory name change.
    //

    Status = UlCreateSafeDirectory(&pEntry->FileName, 
                                      &UncShare, 
                                      &ACLSupport
                                      );
    if (!NT_SUCCESS(Status))
        goto eventlog;

    //
    // Now Restore the short file name pointer back
    //

    pEntry->pShortName = (PWSTR)
        &(pEntry->FileName.Buffer[pEntry->FileName.Length/sizeof(WCHAR)]);

    //
    // Append the new file name ( based on updated current time )
    // to the end.
    //

    Status = RtlAppendUnicodeStringToString( &pEntry->FileName, &FileName );
    if (!NT_SUCCESS(Status))
        goto end;

    //
    // Time to close the old file and reopen a new one
    //

    if (pEntry->pLogFile != NULL)
    {
        //
        // Flush the buffer, close the file and mark the entry
        // inactive.
        //

        UlpMakeEntryInactive(pEntry);        
    }

    ASSERT(pEntry->pLogFile == NULL);

    //
    // If the sequence is stale because of the nature of the recycle.
    // And if our period is size based then rescan the new directory
    // to figure out the proper file to open.
    // 

    pEntry->TotalWritten.QuadPart = (ULONGLONG) 0;

    if (pEntry->Flags.StaleSequenceNumber &&
        pEntry->Period==HttpLoggingPeriodMaxSize)
    {
        // This call may update the filename, the file size and the
        // sequence number if there is an old file in the new dir.

        Status = UlQueryDirectory(
                       &pEntry->FileName,
                        pEntry->pShortName,
                        UL_GET_LOG_FILE_NAME_PREFIX(pEntry->Format),
                        DEFAULT_LOG_FILE_EXTENSION_PLUS_DOT,
                       &pEntry->SequenceNumber,
                       &pEntry->TotalWritten.QuadPart
                        );
        if (!NT_SUCCESS(Status))
        {
            if (Status == STATUS_ACCESS_DENIED)
            {
                Status = STATUS_INVALID_OWNER;
                goto eventlog;
            }
            else
            {
                goto end;
            }
        }
    }

    //
    // Allocate a new log file structure for the new log file we are about 
    // to open or create.
    //
    
    pLogFile = pEntry->pLogFile = 
        UL_ALLOCATE_STRUCT(
                NonPagedPool,
                UL_LOG_FILE_HANDLE,
                UL_LOG_FILE_HANDLE_POOL_TAG
                );
    if (pLogFile == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    pLogFile->Signature = UL_LOG_FILE_HANDLE_POOL_TAG;
    pLogFile->hFile = NULL;
    UlInitializeWorkItem(&pLogFile->WorkItem);
    
    //
    // Create the new log file.
    //
    
    Status = UlCreateLogFile(&pEntry->FileName,
                               UncShare,
                               ACLSupport,
                               &pLogFile->hFile
                               );    
    if (!NT_SUCCESS(Status))
    {
        goto eventlog;
    }

    ASSERT(pLogFile->hFile);
    pEntry->TotalWritten.QuadPart = UlGetLogFileLength(pLogFile->hFile);

    //
    // Recalculate the time to expire.
    //
    
    if (pEntry->Flags.StaleTimeToExpire &&
        pEntry->Period != HttpLoggingPeriodMaxSize)
    {
        UlCalculateTimeToExpire(
            UL_PICK_TIME_FIELD(pEntry, &TimeFieldsLocal, &TimeFields),
            pEntry->Period,
            &pEntry->TimeToExpire
            );
    }

    //
    // Set the time to close to default for a new file. The value is in
    // buffer flushup periods.
    //

    pEntry->TimeToClose = DEFAULT_MAX_FILE_IDLE_TIME;
    
    //
    // By  setting the flag  to zero, we mark that we need to write title 
    // with the next incoming request.But this only applies to W3C format.
    // Otherwise the flag  stays as set all  the time, and  the LogWriter 
    // does not attempt to write the  title for  NCSA and IIS log formats 
    // with the next incoming request.
    //

    if (pEntry->Format == HttpLoggingTypeW3C)
    {
        pEntry->Flags.LogTitleWritten = 0;
    }
    else
    {
        pEntry->Flags.LogTitleWritten = 1;
    }

    //
    // File is successfully opened and the entry is no longer inactive.
    // Update our state flags accordingly.
    //

    pEntry->Flags.Active = 1;
    pEntry->Flags.RecyclePending = 0;    
    pEntry->Flags.StaleSequenceNumber = 0;
    pEntry->Flags.StaleTimeToExpire = 0;
    pEntry->Flags.CreateFileFailureLogged = 0;
    pEntry->Flags.WriteFailureLogged = 0;
    pEntry->Flags.TitleFlushPending = 0;
                
    UlTrace(LOGGING, ("Http!UlpHandleRecycle: entry %p, file %S, handle %lx\n",
                       pEntry,
                       pEntry->FileName.Buffer,
                       pLogFile->hFile
                       ));
eventlog:
    
    if (!NT_SUCCESS(Status))
    {
        if (!pEntry->Flags.CreateFileFailureLogged)
        {
            NTSTATUS TempStatus;

            TempStatus = UlEventLogCreateFailure(
                            Status,
                            UlEventLogNormal,
                           &pEntry->FileName,
                            pEntry->SiteId
                            );
                        
            if (TempStatus == STATUS_SUCCESS)
            {
                //
                // Avoid filling up the event log with error entries. This code 
                // path might get hit every time a request arrives.
                //
                
                pEntry->Flags.CreateFileFailureLogged = 1;
            }            
            
            UlTrace(LOGGING,(
                    "Http!UlpHandleRecycle: Event Logging Status %08lx\n",
                    TempStatus
                    ));   
       }
   }

end:
    if (!NT_SUCCESS(Status))
    {
        UlTrace(LOGGING,("Http!UlpHandleRecycle: entry %p, failure %08lx\n",
                pEntry,
                Status
                ));

        if (pLogFile != NULL)
        {
            //
            // This means we have already closed the old file but failed
            // when we try to create or open the new one.
            //
            
            ASSERT(pLogFile->hFile == NULL);
            
            UL_FREE_POOL_WITH_SIG(pLogFile,UL_LOG_FILE_HANDLE_POOL_TAG);
            pEntry->pLogFile = NULL;
            pEntry->Flags.Active = 0;
        }
        else
        {
            //
            // We were about to recyle the old one but something failed
            // lets try to flush and close the existing file if it's still
            // around.
            //

            if (pEntry->pLogFile)
            {
                UlpMakeEntryInactive(pEntry);        
            }
        }

        //
        // Mark this entry RecyclePending so that buffer timer can try to
        // resurrect this back every minute.
        //
        
        pEntry->Flags.RecyclePending = 1;        
    }
    
    return Status;
}

/***************************************************************************++

Routine Description:

    When the log file is on size based recycling and if we write this new 
    record to the file, we have to recycle. This function returns TRUE.
    Otherwise it returns FALSE.

Arguments:

    pEntry: The log file entry.    
    NewRecordSize: The size of the new record going to the buffer. (Bytes)

--***************************************************************************/

__inline
BOOLEAN
UlpIsLogFileOverFlow(
        IN  PUL_LOG_FILE_ENTRY  pEntry,
        IN  ULONG               NewRecordSize
        )
{
    if (pEntry->Period != HttpLoggingPeriodMaxSize ||
        pEntry->TruncateSize == HTTP_LIMIT_INFINITE)
    {
        return FALSE;
    }
    else
    {
        //
        // BufferUsed: Amount of log buffer we are >currently< using.
        //
        
        ULONG BufferUsed = 0;
        
        if (pEntry->LogBuffer)
        {
            BufferUsed = pEntry->LogBuffer->BufferUsed;
        }
    
        //
        // TotalWritten get updated >only< with buffer flush. Therefore
        // we have to pay attention to the buffer used.
        //

        if ((pEntry->TotalWritten.QuadPart
             + (ULONGLONG) BufferUsed
             + (ULONGLONG) NewRecordSize
             ) >= (ULONGLONG) pEntry->TruncateSize)
        {
            UlTrace(LOGGING, 
                ("Http!UlpIsLogFileOverFlow: pEntry %p FileBuffer %p "
                 "TW:%I64d B:%d R:%d T:%d\n", 
                  pEntry,
                  pEntry->LogBuffer,
                  pEntry->TotalWritten.QuadPart,
                  BufferUsed,
                  NewRecordSize,
                  pEntry->TruncateSize
                  ));
        
            return TRUE;
        }
        else
        {
            return FALSE;
        }
        
    }
}

/***************************************************************************++

Routine Description:

    UlpInitializeGMTOffset :

        Calculates and builds the time difference string.
        Get called during the initialization.
        And every hour after that.

--***************************************************************************/

VOID
UlpGetGMTOffset()
{
    RTL_TIME_ZONE_INFORMATION Tzi;
    NTSTATUS Status;

    CHAR  Sign;
    LONG  Bias;
    ULONG Hour;
    ULONG Minute;
    ULONG DT = UL_TIME_ZONE_ID_UNKNOWN;
    LONG  BiasN = 0;
        
    PAGED_CODE();

    //
    // get the timezone data from the system
    //

    Status = NtQuerySystemInformation(
                SystemCurrentTimeZoneInformation,
                (PVOID)&Tzi,
                sizeof(Tzi),
                NULL
                );
                
    if (!NT_SUCCESS(Status)) 
    {
        UlTrace(LOGGING,("Http!UlpGetGMTOffset: failure %08lx\n", Status));
    }
    else
    {
        DT = UlCalcTimeZoneIdAndBias(&Tzi, &BiasN);   
    }

    if ( BiasN > 0 )
    {
        //
        // UTC = local time + bias
        //
        Bias = BiasN;
        Sign = '-';
    }
    else
    {
        Bias = -1 * BiasN;
        Sign = '+';
    }

    Minute = Bias % 60;
    Hour   = (Bias - Minute) / 60;
        
    UlTrace( LOGGING, 
            ("Http!UlpGetGMTOffset: %c%02d:%02d (h:m) D/S %d BiasN %d\n", 
                Sign, 
                Hour,
                Minute,
                DT,
                BiasN
                ) );

    _snprintf( g_GMTOffset,
               SIZE_OF_GMT_OFFSET,
               "%c%02d%02d",
               Sign,
               Hour,
               Minute
               );

}

/***************************************************************************++

Routine Description:

    Allocates a log data buffer from pool.
    
Arguments:

    pLogData  - The internal buffer to hold logging info. We will keep this
                around until we are done with logging.

    pRequest   - Pointer to the currently logged request.

    
    pConfigGroup - CG from cache or from request
    
--***************************************************************************/

PUL_LOG_DATA_BUFFER
UlpAllocateLogDataBuffer(
    IN  ULONG                   Size,
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUL_CONFIG_GROUP_OBJECT pConfigGroup
    )
{
    PUL_LOG_DATA_BUFFER pLogData = NULL;
        
    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));

    if (Size > UL_ANSI_LOG_LINE_BUFFER_SIZE)
    {
        //
        // Provided buffer is not big enough to hold the user data.        
        //

        pLogData = UlReallocLogDataBuffer(Size, FALSE);
    }
    else
    {
        //
        // Default is enough, try to pop it from the lookaside list.
        //
        
        pLogData = UlPplAllocateLogDataBuffer(FALSE);
    }

    //
    // If failed to allocate then bail out. We won't be logging this request.
    //

    if (pLogData)
    {
        ASSERT(IS_VALID_LOG_DATA_BUFFER(pLogData));
        ASSERT(pLogData->Flags.Binary == 0);
        ASSERT(pLogData->Size > 0);
    
        //
        // Initialize Log Fields in the Log Buffer
        //

        UL_REFERENCE_INTERNAL_REQUEST(pRequest);
        pLogData->pRequest = pRequest;

        pLogData->Flags.CacheAndSendResponse = FALSE;
        pLogData->BytesTransferred = 0;
        pLogData->Used = 0;

        pLogData->Data.Str.Format = pConfigGroup->LoggingConfig.LogFormat;
        pLogData->Data.Str.Flags  = 
            UL_GET_LOG_TYPE_MASK(
                pConfigGroup->LoggingConfig.LogFormat,
                pConfigGroup->LoggingConfig.LogExtFileFlags
                );

        pLogData->Data.Str.Offset1 = 0;
        pLogData->Data.Str.Offset2 = 0;
        pLogData->Data.Str.Offset3 = 0;
    
        UlInitializeWorkItem(&pLogData->WorkItem);

        pRequest->pLogDataCopy = pLogData;
    }

    UlTrace(LOGGING,("Http!UlAllocateLogDataBuffer: pLogData %p \n",pLogData));

    return pLogData;
}

/***************************************************************************++

Routine Description:

    Copy over the user log field by enforcing a limit.
    Post filter out the control characters according to the CharMask.
    Adds a separator character at the end.
    
Arguments:

    psz: Pointer to log data buffer. Enough space is assumed to be allocated.
    pField: Field to be copied over.
    FieldLength: It's length.
    FieldLimit:  Copy will not exceed this limit.
    chSeparator: Will be written after the converted field.
    bReplace : If field exceeds the limit should we truncate or replace with
               LOG_FIELD_TOO_BIG.
    RestrictiveMask : Mask for filtering out control chars.
    
Returns:

    the pointer to the log data buffer after the last written separator.

--***************************************************************************/

__inline
PCHAR
UlpCopyField(
    IN PCHAR    psz,
    IN PCSTR    pField,
    IN ULONG    FieldLength,
    IN ULONG    FieldLimit,
    IN CHAR     chSeparator,
    IN BOOLEAN  bReplace,
    IN ULONG    RestrictiveMask
    )
{
    if (FieldLength)
    {            
        if ((FieldLength > FieldLimit) && bReplace)
        {
            psz = UlStrPrintStr(psz, LOG_FIELD_TOO_BIG, chSeparator);
        }
        else
        {
            ULONG i = 0;

            FieldLength = MIN(FieldLength, FieldLimit);
                
            while (i < FieldLength)
            {
                if (IS_CHAR_TYPE((*pField),RestrictiveMask))
                {
                    *psz++ = '+';
                }                
                else
                {
                    *psz++ = *pField;
                }

                pField++;
                i++;
            }

            *psz++ = chSeparator;
        }
    }
    else
    {
        *psz++ = '-'; *psz++ = chSeparator;
    }

    return psz;
}

/***************************************************************************++

Routine Description:

    Either does Utf8 conversion or Local Code Page conversion.
    Post filter out the control characters according to the CharMask.
    Adds a separator character at the end.
    
Arguments:

    psz: Pointer to log data buffer. Enough space is assumed to be allocated.
    pwField: Unicode field to be converted.
    FieldLength: It's length.
    FieldLimit: Conversion will not exceed this limit.
    chSeparator: Will be written after the converted field.
    bUtf8Enabled: If FALSE Local Code Page conversion otherwise Utf8
    RestrictiveMask : Mask for filtering out control chars.
    
Returns:

    the pointer to the log data buffer after the last written separator.

--***************************************************************************/

__inline
PCHAR
UlpCopyUnicodeField(
    IN PCHAR    psz,
    IN PCWSTR   pwField,
    IN ULONG    FieldLength,    // In Bytes
    IN ULONG    FieldLimit,     // In Bytes
    IN CHAR     chSeparator,    
    IN BOOLEAN  bUtf8Enabled,
    IN ULONG    RestrictiveMask
    )
{
    ASSERT(FieldLimit > (2 * sizeof(WCHAR)));
    
    if (FieldLength)
    {    
        ULONG BytesConverted = 0;
        PCHAR pszT = psz;

        if (bUtf8Enabled)
        {
            LONG DstSize;  // In Bytes 
            LONG SrcSize;  // In Bytes

            // Utf8 Conversion may require up to two times of the source
            // buffer because of a possible 2 byte (a wchar) to 4 byte 
            // conversion. 

            // TODO: This calculation is slightly pessimistic because the worst case  
            // TODO: conversion is from 1 wchar to 3 byte sequence. 
            
            if ((FieldLength * 2) > FieldLimit)
            {
                // Conversion may exceed the dest buffer in the worst
                // case (where every wchar converted to 4 byte sequence), 
                // need to truncate the source to avoid overflow.

                SrcSize = FieldLimit / 2;
                DstSize = FieldLimit;
            }
            else
            {
                SrcSize = FieldLength;
                DstSize = FieldLength * 2;                    
            }

            //
            // HttpUnicodeToUTF8 does not truncate and convert. We actually
            // use shorter url when utf8 conversion is set, to be able to 
            // prevent a possible overflow.
            //
            BytesConverted =
                HttpUnicodeToUTF8(
                    pwField,
                    SrcSize / sizeof(WCHAR),    //  In WChars
                    psz,
                    DstSize                     // In Bytes
                    );
            
            ASSERT(BytesConverted);                
        }
        else
        {
            NTSTATUS Status;
            
            // Local codepage is normally closer to the half the length,
            // but due to the possibility of pre-composed characters, 
            // the upperbound of the ANSI length is the UNICODE length 
            // in bytes

            Status = 
                RtlUnicodeToMultiByteN(
                    psz,
                    FieldLimit,          // Dest in Bytes
                   &BytesConverted,
                    (PWSTR) pwField,
                    FieldLength          // Src in Bytes
                    );
            
            ASSERT(NT_SUCCESS(Status));
        }

        psz += BytesConverted;

        // Post convert control chars.
        
        while (pszT != psz)
        {
            if (IS_CHAR_TYPE((*pszT),RestrictiveMask))
            {
                *pszT = '+';
            }
            pszT++;
        }
        
        *psz++ = chSeparator;            
    }
    else
    {
        *psz++ = '-'; *psz++ = chSeparator;
    }

    return psz;
}

/***************************************************************************++

Routine Description:

    Extended check happens for w3c field against the total buffer size.
    Post filter out the control characters according to the CharMask.
    Adds a separator character at the end.
    
Arguments:

    psz: Pointer to log data buffer. Enough space is assumed to be allocated.
    Mask: Picked flags by the user config.
    Flag: Bitmask of the field passed in.
    pField: Field to be copied over.
    FieldLength: It's length.
    FieldLimit:  Copy will not exceed this limit.
    BufferUsed: Additional limit comparison happens against toatal buffer used

Returns:

    the pointer to the log data buffer after the last written separator.

--***************************************************************************/

__inline
PCHAR
UlpCopyW3CFieldEx(
    IN PCHAR    psz,
    IN ULONG    Mask,
    IN ULONG    Flag,
    IN PCSTR    pField,
    IN ULONG    FieldLength,
    IN ULONG    FieldLimit,
    IN ULONG    BufferUsed,
    IN ULONG    BufferSize
    )
{
    if (Mask & Flag) 
    {    
        if (FieldLength)
        {            
            if ((FieldLength > FieldLimit) || 
                ((BufferUsed + FieldLength) > BufferSize))
            {
                psz = UlStrPrintStr(psz, LOG_FIELD_TOO_BIG, ' ');
            }
            else
            {
                ULONG i = 0;

                ASSERT(FieldLength <= FieldLimit);
  
                while (i < FieldLength)
                {
                    if (IS_HTTP_WHITE((*pField)))
                    {
                        *psz++ = '+';
                    }                
                    else
                    {
                        *psz++ = *pField;
                    }

                    pField++;
                    i++;
                }

                *psz++ = ' ';
            }
        }
        else
        {
            *psz++ = '-'; *psz++ = ' ';
        }
    }

    return psz;
}

/***************************************************************************++

    Thin wrapper macros for log field copies. See above inline functions.
    
--***************************************************************************/

#define COPY_W3C_FIELD(psz,             \
                        Mask,           \
                        Flag,           \
                        pField,         \
                        FieldLength,    \
                        FieldLimit,     \
                        bReplace)       \
    if (Mask & Flag)                    \
    {                                   \
        psz = UlpCopyField(             \
                psz,                    \
                pField,                 \
                FieldLength,            \
                FieldLimit,             \
                ' ',                    \
                bReplace,               \
                HTTP_ISWHITE            \
                );                      \
    }

#define COPY_W3C_UNICODE_FIELD(         \
                        psz,            \
                        Mask,           \
                        Flag,           \
                        pwField,        \
                        FieldLength,    \
                        FieldLimit,     \
                        bUtf8Enabled)   \
    if (Mask & Flag)                    \
    {                                   \
        psz = UlpCopyUnicodeField(      \
                psz,                    \
                pwField,                \
                FieldLength,            \
                FieldLimit,             \
                ' ',                    \
                bUtf8Enabled,           \
                HTTP_ISWHITE            \
                );                      \
    }

/***************************************************************************++

Routine Description:

    For cache-hits extended w3c fields are generated from request headers.
    Post filter out the control characters according to the CharMask.
    Adds a separator character at the end.
    
Arguments:

    psz: Pointer to log data buffer. Enough space is assumed to be allocated.
    Mask: Picked flags by the user config.
    Flag: Bitmask of the field passed in.
    pRequest: Internal request
    HeaderId: Identifies the extended field.
    BufferUsed: Additional limit comparison happens against toatal buffer used
    
Returns:

    the pointer to the log data buffer after the last written separator.

--***************************************************************************/

__inline
PCHAR
UlpCopyRequestHeader(    
    IN PCHAR psz,    
    IN ULONG Mask,
    IN ULONG Flag,
    IN PUL_INTERNAL_REQUEST pRequest,
    IN HTTP_HEADER_ID HeaderId,
    IN ULONG BufferUsed
    )
{
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(HeaderId < HttpHeaderRequestMaximum);

    psz = UlpCopyW3CFieldEx(
                psz,
                Mask,
                Flag,
         (PCSTR)pRequest->Headers[HeaderId].pHeader,
                pRequest->HeaderValid[HeaderId] ?
                    pRequest->Headers[HeaderId].HeaderLength :
                    0,
                MAX_LOG_EXTEND_FIELD_LEN,
                BufferUsed,
                MAX_LOG_RECORD_LEN
                );

    return psz;        
}

/***************************************************************************++

Routine Description:

    Generic function which will generate the TimeStamp field by calculating
    the difference between the time request first get started to be  parsed 
    and the current time.
    
Arguments:

    psz: Pointer to log data buffer. Enough space is assumed to be allocated.
    pRequest: Pointer to internal request structure. For "TimeStamp"
    chSeparator : Once the LONGLONG lifetime converted, separator will be 
                  copied as well.
Returns:

    the pointer to the log data buffer after the last written separator.
    
--***************************************************************************/

__inline
PCHAR
UlpCopyTimeStamp(    
    IN PCHAR psz,    
    IN PUL_INTERNAL_REQUEST pRequest,
    IN CHAR chSeparator
    )
{
    LARGE_INTEGER CurrentTimeStamp;
    LONGLONG LifeTime;

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    KeQuerySystemTime(&CurrentTimeStamp);
    
    LifeTime  = CurrentTimeStamp.QuadPart 
                    - pRequest->TimeStamp.QuadPart;    
    
    LifeTime  = MAX(LifeTime,0);
    
    LifeTime /= C_NS_TICKS_PER_MSEC;

    psz = UlStrPrintUlonglong(
                psz, 
     (ULONGLONG)LifeTime,
                chSeparator
                );

    return psz;    
}

/***************************************************************************++

Routine Description:

    Small utility which will increment the total used for w3c fields.
    
Arguments:

    pTotal: Will be incremented.
    Mask: Picked flags by the user config.
    Flag: Bitmask of the field passed in.
    FieldLength: It's length.
    FieldLimit:  Copy will not exceed this limit.
    bUtf8Enabled
    
--***************************************************************************/

__inline
VOID
UlpIncForW3CField(
    IN PULONG  pTotal,
    IN ULONG   Mask,
    IN ULONG   Flag,    
    IN ULONG   FieldLength,
    IN ULONG   FieldLimit,
    IN BOOLEAN bUtf8Enabled
    )
{
    if (Mask & Flag)
    {
        if (FieldLength)
        {
            if (bUtf8Enabled)
            {
                *pTotal += MIN((FieldLength * 2),FieldLimit) + 1;
            }
            else
            {
                *pTotal += MIN(FieldLength,FieldLimit) + 1;            
            }
        }
        else
        {
            *pTotal += 2;   // For "- "   
        }
    }
}

/***************************************************************************++

Routine Description:

    This is a worst case estimate for the maximum possible buffer required to 
    generate the W3C Log record for a given set of user fields. All the fields 
    are assumed to be picked.
    
Arguments:

    pLogData : Captured copy of the user log field data.

--***************************************************************************/

__inline
ULONG
UlpMaxLogLineSizeForW3C(
    IN PHTTP_LOG_FIELDS_DATA pLogData,
    IN BOOLEAN Utf8Enabled
    )
{
    ULONG FastLength;

    //
    // For each field
    //
    //   1                      for separator space.
    // + 1                      for '-', in case field length is zero.
    // + pLogData->FieldLength  for field, assuming it's always picked.
    //                          enforce the field limitation to prevent overflow.
    //

    FastLength =   
          2 + MIN(pLogData->ClientIpLength,    MAX_LOG_DEFAULT_FIELD_LEN)
        + 2 + MIN(pLogData->ServiceNameLength,MAX_LOG_DEFAULT_FIELD_LEN)
        + 2 + MIN(pLogData->ServerNameLength,  MAX_LOG_DEFAULT_FIELD_LEN)
        + 2 + MIN(pLogData->ServerIpLength,    MAX_LOG_DEFAULT_FIELD_LEN)
        
        + 2 + MIN(pLogData->MethodLength,      MAX_LOG_METHOD_FIELD_LEN)
        
        + 2 + MIN(pLogData->UriQueryLength,    MAX_LOG_EXTEND_FIELD_LEN)
        + 2 + MIN(pLogData->UserAgentLength,   MAX_LOG_EXTEND_FIELD_LEN)
        + 2 + MIN(pLogData->CookieLength,      MAX_LOG_EXTEND_FIELD_LEN)
        + 2 + MIN(pLogData->ReferrerLength,    MAX_LOG_EXTEND_FIELD_LEN)
        + 2 + MIN(pLogData->HostLength,        MAX_LOG_EXTEND_FIELD_LEN)
        
        + MAX_W3C_FIX_FIELD_OVERHEAD
        ;

    //
    // If Utf8 logging is enabled, unicode fields require more space.
    //

    if (Utf8Enabled)
    {
        //
        // Allow only half of the normal limit, so that conversion doesn't
        // overflow even in the worst case ( 1 wchar to 4 byte conversion)
        //
        
        FastLength +=   
             2 + MIN((pLogData->UserNameLength * 2),MAX_LOG_USERNAME_FIELD_LEN)
           + 2 + MIN((pLogData->UriStemLength * 2), MAX_LOG_EXTEND_FIELD_LEN)
             ;
    }
    else
    {
        //
        // RtlUnicodeToMultiByteN requires no more than the original unicode
        // buffer size.
        //
        
        FastLength +=   
                2 + MIN(pLogData->UserNameLength, MAX_LOG_USERNAME_FIELD_LEN)
              + 2 + MIN(pLogData->UriStemLength,   MAX_LOG_EXTEND_FIELD_LEN)
                ;
    }

    return FastLength;
}

/***************************************************************************++

Routine Description:

    Now if the fast length calculation exceeds the default log buffer size.
    This function tries to calculate the max required log record length by
    paying attention to whether the field is picked or not. This is to avoid
    oversize-allocation. And we are in the slow path anyway.
    
Arguments:

    pLogData : Captured copy of the user log field data.

--***************************************************************************/

ULONG
UlpGetLogLineSizeForW3C(
    IN PHTTP_LOG_FIELDS_DATA pLogData,
    IN ULONG   Mask,
    IN BOOLEAN bUtf8Enabled
    )
{
    ULONG TotalLength = 0;

    // 
    // Increment the total length for each picked field.
    // 

    UlpIncForW3CField( &TotalLength, 
                          Mask, 
                          MD_EXTLOG_DATE, 
                          W3C_DATE_FIELD_LEN, 
                          W3C_DATE_FIELD_LEN, 
                          FALSE);
    
    UlpIncForW3CField( &TotalLength, 
                          Mask, 
                          MD_EXTLOG_TIME, 
                          W3C_TIME_FIELD_LEN, 
                          W3C_TIME_FIELD_LEN, 
                          FALSE);

    UlpIncForW3CField( &TotalLength, 
                          Mask, 
                          MD_EXTLOG_CLIENT_IP, 
                          pLogData->ClientIpLength, 
                          MAX_LOG_DEFAULT_FIELD_LEN, 
                          FALSE);

    UlpIncForW3CField( &TotalLength, 
                          Mask, 
                          MD_EXTLOG_USERNAME,
                          pLogData->UserNameLength, 
                          MAX_LOG_USERNAME_FIELD_LEN, 
                          bUtf8Enabled);

    UlpIncForW3CField( &TotalLength, 
                          Mask, 
                          MD_EXTLOG_SITE_NAME, 
                          pLogData->ServiceNameLength, 
                          MAX_LOG_DEFAULT_FIELD_LEN, 
                          FALSE);

    UlpIncForW3CField( &TotalLength, 
                          Mask, 
                          MD_EXTLOG_COMPUTER_NAME, 
                          pLogData->ServerNameLength, 
                          MAX_LOG_DEFAULT_FIELD_LEN, 
                          FALSE);

    UlpIncForW3CField( &TotalLength, 
                          Mask, 
                          MD_EXTLOG_SERVER_IP, 
                          pLogData->ServerIpLength, 
                          MAX_LOG_DEFAULT_FIELD_LEN, 
                          FALSE);

    UlpIncForW3CField( &TotalLength, 
                          Mask, 
                          MD_EXTLOG_METHOD, 
                          pLogData->MethodLength, 
                          MAX_LOG_METHOD_FIELD_LEN, 
                          FALSE);

    UlpIncForW3CField( &TotalLength, 
                          Mask, 
                          MD_EXTLOG_URI_STEM,
                          pLogData->UriStemLength, 
                          MAX_LOG_EXTEND_FIELD_LEN, 
                          bUtf8Enabled);

    UlpIncForW3CField( &TotalLength, 
                          Mask, 
                          MD_EXTLOG_URI_QUERY,
                          pLogData->UriQueryLength, 
                          MAX_LOG_EXTEND_FIELD_LEN, 
                          FALSE);

    UlpIncForW3CField( &TotalLength, 
                          Mask, 
                          MD_EXTLOG_HTTP_STATUS, 
                          UL_MAX_HTTP_STATUS_CODE_LENGTH, 
                          UL_MAX_HTTP_STATUS_CODE_LENGTH, 
                          FALSE);

    UlpIncForW3CField( &TotalLength, 
                          Mask, 
                          MD_EXTLOG_HTTP_SUB_STATUS, 
                          MAX_USHORT_STR, 
                          MAX_USHORT_STR, 
                          FALSE);
    
    UlpIncForW3CField( &TotalLength, 
                          Mask, 
                          MD_EXTLOG_WIN32_STATUS, 
                          MAX_ULONG_STR, 
                          MAX_ULONG_STR, 
                          FALSE);

    UlpIncForW3CField( &TotalLength, 
                          Mask, 
                          MD_EXTLOG_SERVER_PORT, 
                          MAX_USHORT_STR, 
                          MAX_USHORT_STR, 
                          FALSE);

    UlpIncForW3CField( &TotalLength, 
                          Mask, 
                          MD_EXTLOG_PROTOCOL_VERSION, 
                          UL_HTTP_VERSION_LENGTH, 
                          UL_HTTP_VERSION_LENGTH, 
                          FALSE);

    UlpIncForW3CField( &TotalLength, 
                          Mask, 
                          MD_EXTLOG_USER_AGENT,
                          pLogData->UserAgentLength, 
                          MAX_LOG_EXTEND_FIELD_LEN, 
                          FALSE);

    UlpIncForW3CField( &TotalLength, 
                          Mask, 
                          MD_EXTLOG_COOKIE,
                          pLogData->CookieLength, 
                          MAX_LOG_EXTEND_FIELD_LEN, 
                          FALSE);

    UlpIncForW3CField( &TotalLength, 
                          Mask, 
                          MD_EXTLOG_REFERER,
                          pLogData->ReferrerLength, 
                          MAX_LOG_EXTEND_FIELD_LEN, 
                          FALSE);

    UlpIncForW3CField( &TotalLength, 
                          Mask, 
                          MD_EXTLOG_HOST,
                          pLogData->HostLength, 
                          MAX_LOG_EXTEND_FIELD_LEN, 
                          FALSE);

    UlpIncForW3CField( &TotalLength, 
                          Mask, 
                          MD_EXTLOG_BYTES_SENT,
                          MAX_ULONGLONG_STR, 
                          MAX_ULONGLONG_STR, 
                          FALSE);

    UlpIncForW3CField( &TotalLength, 
                          Mask, 
                          MD_EXTLOG_BYTES_RECV,
                          MAX_ULONGLONG_STR, 
                          MAX_ULONGLONG_STR, 
                          FALSE);

    UlpIncForW3CField( &TotalLength, 
                          Mask, 
                          MD_EXTLOG_TIME_TAKEN,
                          MAX_ULONGLONG_STR, 
                          MAX_ULONGLONG_STR, 
                          FALSE);
    
    //
    // Finally increment the length for CRLF and terminating null.
    //

    TotalLength += 3;     // \r\n\0
    
    return TotalLength;        
}

__inline
ULONG
UlpGetCacheHitLogLineSizeForW3C(
    IN ULONG Flags,
    IN PUL_INTERNAL_REQUEST pRequest,
    IN ULONG SizeOfFieldsFrmCache
    )
{
    ULONG NewSize;

#define INC_FOR_REQUEST_HEADER(Flags,FieldMask,pRequest,Id,Size)        \
    if ((Flags & FieldMask) &&                                          \
         pRequest->HeaderValid[Id])                                     \
    {                                                                   \
        ASSERT( pRequest->Headers[Id].HeaderLength ==                   \
           strlen((const CHAR *)pRequest->Headers[Id].pHeader));        \
                                                                        \
        Size += 2 + pRequest->Headers[Id].HeaderLength;                 \
    }

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    NewSize = SizeOfFieldsFrmCache + MAX_W3C_CACHE_FIELD_OVERHEAD;
    
    //
    // And now add extended field's lengths.
    //

    INC_FOR_REQUEST_HEADER(Flags,
                              MD_EXTLOG_USER_AGENT,
                              pRequest,
                              HttpHeaderUserAgent,
                              NewSize);

    INC_FOR_REQUEST_HEADER(Flags,
                              MD_EXTLOG_COOKIE,
                              pRequest,
                              HttpHeaderCookie,
                              NewSize);
    
    INC_FOR_REQUEST_HEADER(Flags,
                              MD_EXTLOG_REFERER,
                              pRequest,
                              HttpHeaderReferer,
                              NewSize);

    INC_FOR_REQUEST_HEADER(Flags,
                              MD_EXTLOG_HOST,
                              pRequest,
                              HttpHeaderHost,
                              NewSize);
    return NewSize;    
}

__inline
ULONG
UlpGetLogLineSizeForNCSA(
    IN PHTTP_LOG_FIELDS_DATA pLogData,
    IN BOOLEAN bUtf8Enabled
    )
{
    ULONG Size;

#define NCSA_FIELD_SIZE(length,limit)       (1 + MAX(MIN((length),(limit)),1))
    
    //
    // For each field
    //
    //   1                      for separator ' '
    // + pLogData->FieldLength  for field, limited by a upper bound.
    //   max(length, 1) if length is zero we still need to log a dash.
    //
    //
    //  cIP - UserN [07/Jan/2000:00:02:23 -0800] "MTHD URI?QUERY VER" Status bSent
    //

    Size =  NCSA_FIELD_SIZE(pLogData->ClientIpLength, MAX_LOG_DEFAULT_FIELD_LEN)
            + 
            2                                   // "- " for remote user name
            + 
            NCSA_FIX_DATE_AND_TIME_FIELD_SIZE   // Including the separator
            + 
            1                                   // '"' : starting double quote
            +
            NCSA_FIELD_SIZE(pLogData->MethodLength,MAX_LOG_METHOD_FIELD_LEN)
            +
            1                                   // '?' 
            +            
            NCSA_FIELD_SIZE(pLogData->UriQueryLength,MAX_LOG_EXTEND_FIELD_LEN)
            +
            UL_HTTP_VERSION_LENGTH + 1
            +
            1                                   //  "' : ending double quote
            +
            UL_MAX_HTTP_STATUS_CODE_LENGTH + 1  // Status
            +
            MAX_ULONGLONG_STR                   // BytesSent
            +
            3                                   // \r\n\0
            ;
            
    if (bUtf8Enabled)
    {
        Size +=   
             NCSA_FIELD_SIZE((pLogData->UserNameLength * 2),MAX_LOG_USERNAME_FIELD_LEN)
             +
             NCSA_FIELD_SIZE((pLogData->UriStemLength * 2),MAX_LOG_EXTEND_FIELD_LEN)
             ;        
    }
    else
    {
        Size +=   
             NCSA_FIELD_SIZE(pLogData->UserNameLength,MAX_LOG_USERNAME_FIELD_LEN)
             +
             NCSA_FIELD_SIZE(pLogData->UriStemLength,MAX_LOG_EXTEND_FIELD_LEN)
             ;        
    }
    
    return Size;
}

__inline
ULONG
UlpGetLogLineSizeForIIS(
    IN PHTTP_LOG_FIELDS_DATA pLogData,
    IN BOOLEAN bUtf8Enabled
    )
{
    ULONG MaxSize,Frag1size,Frag2size,Frag3size;

#define IIS_FIELD_SIZE(length,limit)       (2 + MAX(MIN((length),(limit)),1))

    Frag1size =
        IIS_FIELD_SIZE(pLogData->ClientIpLength,MAX_LOG_DEFAULT_FIELD_LEN)
        + 
        IIS_MAX_DATE_AND_TIME_FIELD_SIZE    // Including the separators 
        ;

    Frag2size =
        IIS_FIELD_SIZE(pLogData->ServiceNameLength,MAX_LOG_DEFAULT_FIELD_LEN)
        + 
        IIS_FIELD_SIZE(pLogData->ServerNameLength,MAX_LOG_DEFAULT_FIELD_LEN)
        + 
        IIS_FIELD_SIZE(pLogData->ServerIpLength,MAX_LOG_DEFAULT_FIELD_LEN)
        +         
        2 + MAX_ULONGLONG_STR // TimeTaken
        +
        2 + MAX_ULONGLONG_STR // BytesReceived
        +
        2 + MAX_ULONGLONG_STR // BytesSend
        +
        2 + UL_MAX_HTTP_STATUS_CODE_LENGTH 
        +
        2 + MAX_ULONG_STR     // Win32 Status        
        ;
        
    Frag3size =
        IIS_FIELD_SIZE(pLogData->MethodLength,MAX_LOG_METHOD_FIELD_LEN)
        +
        IIS_FIELD_SIZE(pLogData->UriQueryLength,MAX_LOG_EXTEND_FIELD_LEN) 
        +
        3   // \r\n\0
        ;


    if (bUtf8Enabled)
    {
        Frag3size +=
            IIS_FIELD_SIZE((pLogData->UriStemLength * 2),MAX_LOG_EXTEND_FIELD_LEN);
            
        Frag1size +=   
            IIS_FIELD_SIZE((pLogData->UserNameLength * 2),MAX_LOG_USERNAME_FIELD_LEN);            
    }
    else
    {
        Frag3size +=
            IIS_FIELD_SIZE(pLogData->UriStemLength,MAX_LOG_EXTEND_FIELD_LEN);
            
        Frag1size +=   
            IIS_FIELD_SIZE(pLogData->UserNameLength,MAX_LOG_USERNAME_FIELD_LEN);        
    }

    //
    // First two fragments must always fit to the default buffer.
    //
    
    ASSERT(Frag1size < IIS_LOG_LINE_DEFAULT_FIRST_FRAGMENT_ALLOCATION_SIZE);
    ASSERT(Frag2size < IIS_LOG_LINE_DEFAULT_SECOND_FRAGMENT_ALLOCATION_SIZE);

    //
    // The required third fragment size may be too big for the default 
    // buffer size.
    //
    
    MaxSize = IIS_LOG_LINE_DEFAULT_FIRST_FRAGMENT_ALLOCATION_SIZE + 
              IIS_LOG_LINE_DEFAULT_SECOND_FRAGMENT_ALLOCATION_SIZE +
              Frag3size;
            
    return MaxSize;
}

/***************************************************************************++

Routine Description:

    Captures and writes the log fields from user buffer to the log line.

    pLogData itself must have been captured by the caller however embedded
    pointers inside of the structure are not, therefore we need to be carefull
    here and cleanup if an exception raises.
    
    Captures only those necessary fields according to the picked Flags.
    
    Does UTF8 and LocalCode Page conversion for UserName and URI Stem.
    
    Leaves enough space for Date & Time fields for late generation.

    WARNING:
    Even though the pUserData is already captured to the kernel buffer, it
    still holds pointers to user-mode memory for individual log fields,
    therefore this function should be called inside a try/except block and

    If this function raises an exception caller should cleanup the allocated
    pLogBuffer.

Arguments:

    pLogData    : Captured user data in a kernel buffer.
    pRequest    : Request.
    ppLogBuffer : Returning pLogBuffer.

--***************************************************************************/

NTSTATUS
UlCaptureLogFieldsW3C(
    IN PHTTP_LOG_FIELDS_DATA pLogData,
    IN PUL_INTERNAL_REQUEST  pRequest,
    OUT PUL_LOG_DATA_BUFFER  *ppLogBuffer
    )
{
    PUL_LOG_DATA_BUFFER pLogBuffer;
    PUL_CONFIG_GROUP_OBJECT pConfigGroup;
    ULONG    Flags;
    PCHAR    psz;
    PCHAR    pBuffer;
    ULONG    FastLength;
    BOOLEAN  bUtf8Enabled;
        
    //
    // Sanity check and init.
    //

    PAGED_CODE();
    ASSERT(pLogData);
    
    *ppLogBuffer = pLogBuffer = NULL;

    pConfigGroup = pRequest->ConfigInfo.pLoggingConfig;
    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));
        
    Flags = pConfigGroup->LoggingConfig.LogExtFileFlags;
    bUtf8Enabled = UTF8_LOGGING_ENABLED();

    //
    // Try the fast length calculation first. If this fails then 
    // we need to re-calculate the required length.
    //

    FastLength = UlpMaxLogLineSizeForW3C(pLogData, bUtf8Enabled);
    
    if (FastLength > UL_ANSI_LOG_LINE_BUFFER_SIZE)
    {
        FastLength = UlpGetLogLineSizeForW3C(
                        pLogData,
                        Flags,
                        bUtf8Enabled
                        );            
        if (FastLength > MAX_LOG_RECORD_LEN)
        {
            //
            // While we are enforcing 10k upper limit for the log  record 
            // length. We still allocate slightly larger space to include
            // the overhead for the post-generated log fields. As well as
            // for the replacement strings for "too long" fields.
            //

            // TODO: (PAGE_SIZE - ALIGN_UP(FastLength,PVOID))
            
            FastLength = MAX_LOG_RECORD_ALLOCATION_LENGTH;
        }                        
    }

    *ppLogBuffer = pLogBuffer = UlpAllocateLogDataBuffer(
                                    FastLength,
                                    pRequest,
                                    pConfigGroup
                                    );        
    if (!pLogBuffer)
    {
        return STATUS_INSUFFICIENT_RESOURCES;        
    }

    ASSERT(pLogBuffer->Data.Str.Format == HttpLoggingTypeW3C);
    ASSERT(pLogBuffer->Data.Str.Flags  == Flags);
        
    //  
    // Remember the beginning of the buffer.
    //

    psz = pBuffer = (PCHAR) pLogBuffer->Line;

    //
    // Skip the date and time fields, but reserve the space.
    //
    
    if ( Flags & MD_EXTLOG_DATE ) psz += W3C_DATE_FIELD_LEN + 1;
    if ( Flags & MD_EXTLOG_TIME ) psz += W3C_TIME_FIELD_LEN + 1;

    //
    // Remember if we have reserved any space for Date and Time or not.
    //
    
    pLogBuffer->Data.Str.Offset1 = DIFF_USHORT(psz - pBuffer);    

    COPY_W3C_FIELD(psz,
                    Flags,
                    MD_EXTLOG_SITE_NAME,
                    pLogData->ServiceName,
                    pLogData->ServiceNameLength,
                    MAX_LOG_DEFAULT_FIELD_LEN,
                    TRUE);    

    COPY_W3C_FIELD(psz,
                    Flags,
                    MD_EXTLOG_COMPUTER_NAME,
                    pLogData->ServerName,
                    pLogData->ServerNameLength,
                    MAX_LOG_DEFAULT_FIELD_LEN,
                    TRUE);    
                            
    COPY_W3C_FIELD(psz,
                    Flags,
                    MD_EXTLOG_SERVER_IP,
                    pLogData->ServerIp,
                    pLogData->ServerIpLength,
                    MAX_LOG_DEFAULT_FIELD_LEN,
                    TRUE);    

    COPY_W3C_FIELD(psz,
                    Flags,
                    MD_EXTLOG_METHOD,
                    pLogData->Method,
                    pLogData->MethodLength,
                    MAX_LOG_METHOD_FIELD_LEN,
                    FALSE);    

    COPY_W3C_UNICODE_FIELD(
                    psz,
                    Flags,
                    MD_EXTLOG_URI_STEM,
                    pLogData->UriStem,
                    pLogData->UriStemLength,
                    MAX_LOG_EXTEND_FIELD_LEN,
                    bUtf8Enabled);
                                            
    COPY_W3C_FIELD(psz,
                    Flags,
                    MD_EXTLOG_URI_QUERY,
                    pLogData->UriQuery,
                    pLogData->UriQueryLength,
                    MAX_LOG_EXTEND_FIELD_LEN,
                    TRUE);    
                        
    if ( Flags & MD_EXTLOG_SERVER_PORT ) 
    {   
        psz = UlStrPrintUlong(psz, pLogData->ServerPort,' ');
    }

    //
    // Fields after this point won't be stored in the uri cache entry.
    //
    
    pLogBuffer->Data.Str.Offset2 = DIFF_USHORT(psz - pBuffer);

    COPY_W3C_UNICODE_FIELD(
                    psz,
                    Flags,
                    MD_EXTLOG_USERNAME,
                    pLogData->UserName,
                    pLogData->UserNameLength,
                    MAX_LOG_USERNAME_FIELD_LEN,
                    bUtf8Enabled);

    COPY_W3C_FIELD(psz,
                    Flags,
                    MD_EXTLOG_CLIENT_IP,
                    pLogData->ClientIp,
                    pLogData->ClientIpLength,
                    MAX_LOG_DEFAULT_FIELD_LEN,
                    TRUE);    
        
    if ( Flags & MD_EXTLOG_PROTOCOL_VERSION ) 
    {    
        psz = UlCopyHttpVersion(psz, pRequest->Version, ' ');    
    }

    ASSERT(DIFF(psz - pBuffer) <= MAX_LOG_RECORD_LEN);
    
    //
    // Following fields may still overflow the allocated buffer
    // even though they are not exceeding their length limits.
    // Ex function does the extra check.
    //

    psz = UlpCopyW3CFieldEx(
                    psz,
                    Flags,
                    MD_EXTLOG_USER_AGENT,
                    pLogData->UserAgent,
                    pLogData->UserAgentLength,
                    MAX_LOG_EXTEND_FIELD_LEN,
                    DIFF(psz - pBuffer),
                    MAX_LOG_RECORD_LEN);    
    
    psz = UlpCopyW3CFieldEx(
                    psz,
                    Flags,
                    MD_EXTLOG_COOKIE,
                    pLogData->Cookie,
                    pLogData->CookieLength,
                    MAX_LOG_EXTEND_FIELD_LEN,
                    DIFF(psz - pBuffer),
                    MAX_LOG_RECORD_LEN);    

    psz = UlpCopyW3CFieldEx(
                    psz,
                    Flags,
                    MD_EXTLOG_REFERER,
                    pLogData->Referrer,
                    pLogData->ReferrerLength,
                    MAX_LOG_EXTEND_FIELD_LEN,
                    DIFF(psz - pBuffer),
                    MAX_LOG_RECORD_LEN);    

    psz = UlpCopyW3CFieldEx(
                    psz,
                    Flags,
                    MD_EXTLOG_HOST,
                    pLogData->Host,
                    pLogData->HostLength,
                    MAX_LOG_EXTEND_FIELD_LEN,
                    DIFF(psz - pBuffer),
                    MAX_LOG_RECORD_LEN);    

    //
    // Status fields may be updated upon send completion.
    //

    pLogBuffer->ProtocolStatus = 
        (USHORT) MIN(pLogData->ProtocolStatus,UL_MAX_HTTP_STATUS_CODE);

    pLogBuffer->SubStatus   = pLogData->SubStatus;
        
    pLogBuffer->Win32Status = pLogData->Win32Status;

    //
    // Finally calculate the used space and verify that we did not overflow.
    //
    
    pLogBuffer->Used = DIFF_USHORT(psz - pBuffer);

    ASSERT( pLogBuffer->Used <= MAX_LOG_RECORD_LEN );
    
    UlTrace(LOGGING, 
        ("Http!UlCaptureLogFields: user %p kernel %p\n",
          pLogData,pLogBuffer
          ));

    return STATUS_SUCCESS;
}


NTSTATUS 
UlCaptureLogFieldsNCSA(
    IN PHTTP_LOG_FIELDS_DATA    pLogData,
    IN OUT PUL_INTERNAL_REQUEST pRequest,    
    OUT PUL_LOG_DATA_BUFFER     *ppLogBuffer
    )
{
    PCHAR   psz;
    PCHAR   pBuffer;
    ULONG   MaxLength;
    BOOLEAN bUtf8Enabled;
    PUL_LOG_DATA_BUFFER pLogBuffer;
    PUL_CONFIG_GROUP_OBJECT pConfigGroup;

    //
    // Sanity check.
    //

    PAGED_CODE();
    
    *ppLogBuffer = pLogBuffer = NULL;

    pConfigGroup = pRequest->ConfigInfo.pLoggingConfig;
    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));
        
    bUtf8Enabled = UTF8_LOGGING_ENABLED();

    //
    // Estimate the maximum possible length (worst case) and 
    // allocate a bigger log data buffer line if necessary.
    //
    
    MaxLength  = UlpGetLogLineSizeForNCSA(pLogData, bUtf8Enabled);

    MaxLength  = MIN(MaxLength, MAX_LOG_RECORD_LEN);
    
    *ppLogBuffer = pLogBuffer = UlpAllocateLogDataBuffer(
                                    MaxLength,
                                    pRequest,
                                    pConfigGroup
                                    );        
    if (!pLogBuffer)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT(pLogBuffer->Data.Str.Format == HttpLoggingTypeNCSA);
    ASSERT(pLogBuffer->Data.Str.Flags  == UL_DEFAULT_NCSA_FIELDS);

    //
    //  cIP - UserN [07/Jan/2000:00:02:23 -0800] "MTHD URI?QUERY VER" Status bSent
    //

    psz = pBuffer = (PCHAR) pLogBuffer->Line;

    psz = UlpCopyField(psz,
                        pLogData->ClientIp,
                        pLogData->ClientIpLength,
                        MAX_LOG_DEFAULT_FIELD_LEN,
                        ' ',
                        TRUE,
                        HTTP_ISWHITE);    
    
    *psz++ = '-'; *psz++ = ' ';     // Fixed dash

    psz = UlpCopyUnicodeField(
                        psz,
                        pLogData->UserName,
                        pLogData->UserNameLength,
                        MAX_LOG_USERNAME_FIELD_LEN,
                        ' ',
                        bUtf8Enabled,
                        HTTP_ISWHITE);
                        
    //
    // Reserve a space for the date and time fields.
    //
    
    pLogBuffer->Data.Str.Offset1 = DIFF_USHORT(psz - pBuffer);
     
    psz += NCSA_FIX_DATE_AND_TIME_FIELD_SIZE;

    //
    // "MTHD U-STEM?U-QUERY P-VER"
    //
    
    *psz++  = '\"';

    psz = UlpCopyField(psz,
                        pLogData->Method,
                        pLogData->MethodLength,
                        MAX_LOG_METHOD_FIELD_LEN,
                        ' ',
                        FALSE,
                        HTTP_CTL);    

    psz = UlpCopyUnicodeField(
                        psz,
                        pLogData->UriStem,
                        pLogData->UriStemLength,
                        MAX_LOG_EXTEND_FIELD_LEN,
                        '?',
                        bUtf8Enabled,
                        HTTP_CTL);
    
    if (pLogData->UriQueryLength)
    {
        psz = UlpCopyField(psz,
                        pLogData->UriQuery,
                        pLogData->UriQueryLength,
                        MAX_LOG_EXTEND_FIELD_LEN,
                        ' ',
                        TRUE,
                        HTTP_CTL);
    }
    else
    {
        psz--;
        if ((*psz) == '?')  *psz = ' ';     // Eat the question mark
        psz++;
    }
    
    pLogBuffer->Data.Str.Offset2 = DIFF_USHORT(psz - pBuffer);

    psz = UlCopyHttpVersion(psz, pRequest->Version, '\"');
    *psz++ = ' ';

    //
    // Set the log record length
    //
    
    ASSERT(pLogBuffer->Used == 0);
    pLogBuffer->Used = DIFF_USHORT(psz - pBuffer);

    //
    // Store the status to the kernel buffer.
    //
    
    pLogBuffer->ProtocolStatus = 
        (USHORT) MIN(pLogData->ProtocolStatus,UL_MAX_HTTP_STATUS_CODE);

    return STATUS_SUCCESS;
}

NTSTATUS
UlCaptureLogFieldsIIS(
    IN PHTTP_LOG_FIELDS_DATA pLogData,
    IN PUL_INTERNAL_REQUEST  pRequest,
    OUT PUL_LOG_DATA_BUFFER  *ppLogBuffer
    )
{
    PUL_LOG_DATA_BUFFER pLogBuffer;
    PUL_CONFIG_GROUP_OBJECT pConfigGroup;    
    PCHAR    psz;
    PCHAR    pBuffer;
    ULONG    MaxLength;
    BOOLEAN  bUtf8Enabled;

    //
    // Sanity check.
    //

    PAGED_CODE();

    *ppLogBuffer = pLogBuffer = NULL;

    pConfigGroup = pRequest->ConfigInfo.pLoggingConfig;
    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));
        
    bUtf8Enabled = UTF8_LOGGING_ENABLED();

    //
    // Try worst case allocation.
    //
    
    MaxLength = UlpGetLogLineSizeForIIS(pLogData,bUtf8Enabled);

    ASSERT(MaxLength <= MAX_LOG_RECORD_LEN);
    
    *ppLogBuffer = pLogBuffer = UlpAllocateLogDataBuffer(
                                    MaxLength,
                                    pRequest,
                                    pConfigGroup
                                    );        
    if (!pLogBuffer)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT(pLogBuffer->Data.Str.Format == HttpLoggingTypeIIS);
    ASSERT(pLogBuffer->Data.Str.Flags  == UL_DEFAULT_IIS_FIELDS);

    // IIS log line is fragmented to three pieces as follows;
    //
    // [UIP, user, D, T, ][site, Server, SIP, Ttaken, BR, BS, PS, WS, ][M, URI, URIQUERY,]
    // 0               511 512                                     1023 1024          4096
    
    psz = pBuffer = (PCHAR) pLogBuffer->Line;

    psz = UlpCopyField(psz,
                        pLogData->ClientIp,
                        pLogData->ClientIpLength,
                        MAX_LOG_DEFAULT_FIELD_LEN,
                        ',',
                        TRUE,
                        HTTP_CTL);
    *psz++ = ' ';

    psz = UlpCopyUnicodeField(
                        psz,
                        pLogData->UserName,
                        pLogData->UserNameLength,
                        MAX_LOG_USERNAME_FIELD_LEN,
                        ',',
                        bUtf8Enabled,
                        HTTP_CTL);
    *psz++ = ' ';    

    // Store the current size of the 1st frag to Offset1

    pLogBuffer->Data.Str.Offset1 = DIFF_USHORT(psz - pBuffer);

    // Move pointer to the beginning of 2nd frag.

    pBuffer = psz = (PCHAR) &pLogBuffer->Line[IIS_LOG_LINE_SECOND_FRAGMENT_OFFSET];

    psz = UlpCopyField(psz,
                        pLogData->ServiceName,
                        pLogData->ServiceNameLength,
                        MAX_LOG_DEFAULT_FIELD_LEN,
                        ',',
                        TRUE,
                        HTTP_CTL);
    *psz++ = ' ';

    psz = UlpCopyField(psz,
                        pLogData->ServerName,
                        pLogData->ServerNameLength,
                        MAX_LOG_DEFAULT_FIELD_LEN,
                        ',',
                        TRUE,
                        HTTP_CTL);
    *psz++ = ' ';

    psz = UlpCopyField(psz,
                        pLogData->ServerIp,
                        pLogData->ServerIpLength,
                        MAX_LOG_DEFAULT_FIELD_LEN,
                        ',',
                        TRUE,
                        HTTP_CTL);
    *psz++ = ' ';

    // Store the current size of the 2nd frag to Offset2

    pLogBuffer->Data.Str.Offset2 = DIFF_USHORT(psz - pBuffer);

    // Following fields might be updated upon send completion
    // do not copy them yet, just store their values.

    pLogBuffer->ProtocolStatus = 
        (USHORT) MIN(pLogData->ProtocolStatus,UL_MAX_HTTP_STATUS_CODE);
    
    pLogBuffer->Win32Status = pLogData->Win32Status;
    
    // Move pointer to the beginning of 3rd frag.

    pBuffer = psz = (PCHAR) &pLogBuffer->Line[IIS_LOG_LINE_THIRD_FRAGMENT_OFFSET];
    
    psz = UlpCopyField(psz,
                        pLogData->Method,
                        pLogData->MethodLength,
                        MAX_LOG_METHOD_FIELD_LEN,
                        ',',
                        FALSE,
                        HTTP_CTL);    
    *psz++ = ' ';

    psz = UlpCopyUnicodeField(
                        psz,
                        pLogData->UriStem,
                        pLogData->UriStemLength,
                        MAX_LOG_EXTEND_FIELD_LEN,
                        ',',
                        bUtf8Enabled,
                        HTTP_CTL);    
    *psz++ = ' ';

    psz = UlpCopyField(psz,
                        pLogData->UriQuery,
                        pLogData->UriQueryLength,
                        MAX_LOG_EXTEND_FIELD_LEN,
                        ',',
                        TRUE,
                        HTTP_CTL);

    // Terminate the 3rd fragment. It is complete.
    
    *psz++ = '\r'; *psz++ = '\n';

    ASSERT(pLogBuffer->Used == 0);
    pLogBuffer->Used = DIFF_USHORT(psz - pBuffer);

    *psz++ = ANSI_NULL;

    return STATUS_SUCCESS;
}


USHORT
UlpCompleteLogRecordW3C(
    IN OUT PUL_LOG_DATA_BUFFER pLogData,
    IN     PUL_URI_CACHE_ENTRY pUriEntry
    )
{
    PUL_INTERNAL_REQUEST    pRequest;
    PCHAR                   psz;
    PCHAR                   pBuffer;
    PCHAR                   pLine;
    ULONG                   BytesWritten;
    ULONG                   Flags;

    ASSERT(IS_VALID_LOG_DATA_BUFFER(pLogData));
    ASSERT(pLogData->Data.Str.Format == HttpLoggingTypeW3C);

    BytesWritten = 0;
    Flags = pLogData->Data.Str.Flags;

    pRequest = pLogData->pRequest;
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    psz = pLine = (PCHAR) pLogData->Line;

    // For cache-miss and cache-and-send hits the space for
    // date and time is reserved at the beginning and their
    // sizes are already counted for to the "Used". For pure
    // cache hits, the buffer is freshly allocated. It's all
    // right to copy over.
    
    if (Flags & MD_EXTLOG_DATE)
    {
        UlGetDateTimeFields(
                               HttpLoggingTypeW3C,
                               psz,
                              &BytesWritten,
                               NULL,
                               NULL
                               );
        psz += BytesWritten; *psz++ = ' ';
        ASSERT(BytesWritten == W3C_DATE_FIELD_LEN);
    }

    if (Flags & MD_EXTLOG_TIME)
    {
        UlGetDateTimeFields(
                               HttpLoggingTypeW3C,
                               NULL,
                               NULL,
                               psz,
                              &BytesWritten
                               );
        psz += BytesWritten; *psz++ = ' ';
        ASSERT(BytesWritten == W3C_TIME_FIELD_LEN);
    }
    
    // If this is a cache hit restore the logging data in
    // to the newly allocated log data buffer.

    if (IS_PURE_CACHE_HIT(pUriEntry,pLogData))
    {
        ASSERT(IS_VALID_URI_CACHE_ENTRY(pUriEntry));    
        ASSERT(pLogData->Used == 0);

        // The picked flags should not change during the
        // lifetime of a cache entry.

        ASSERT(DIFF(psz - pLine) == pUriEntry->UsedOffset1);
        
        if (pUriEntry->LogDataLength)
        {
            RtlCopyMemory(psz,
                          pUriEntry->pLogData,
                          pUriEntry->LogDataLength
                          );

            psz += pUriEntry->LogDataLength;
        }

        // Some fields need to be generated for each cache hit. These
        // are not stored in the cache entry.

        if ( Flags & MD_EXTLOG_USERNAME ) 
        { 
            *psz++ = '-'; *psz++ = ' ';
        }

        if ( Flags & MD_EXTLOG_CLIENT_IP ) 
        { 
            psz = UlStrPrintIP(
                    psz,
                    pRequest->pHttpConn->pConnection->RemoteAddress,
                    pRequest->pHttpConn->pConnection->AddressType,
                    ' '
                    );
        }

        if ( Flags & MD_EXTLOG_PROTOCOL_VERSION ) 
        {    
            psz = UlCopyHttpVersion(psz, pRequest->Version, ' ');  
        }

        psz = UlpCopyRequestHeader(
                    psz,
                    Flags,
                    MD_EXTLOG_USER_AGENT,
                    pRequest,
                    HttpHeaderUserAgent,
                    DIFF(psz - pLine)
                    );

        psz = UlpCopyRequestHeader(
                    psz,
                    Flags,
                    MD_EXTLOG_COOKIE,
                    pRequest,
                    HttpHeaderCookie,
                    DIFF(psz - pLine)
                    );
                        
        psz = UlpCopyRequestHeader(
                    psz,
                    Flags,
                    MD_EXTLOG_REFERER,
                    pRequest,
                    HttpHeaderReferer,
                    DIFF(psz - pLine)
                    );

        psz = UlpCopyRequestHeader(
                    psz,
                    Flags,
                    MD_EXTLOG_HOST,
                    pRequest,
                    HttpHeaderHost,
                    DIFF(psz - pLine)
                    );
        
        // This was a newly allocated buffer, init the "Used" field
        // accordingly.
        
        pLogData->Used = DIFF_USHORT(psz - pLine);
    }
    
    // Now complete the half baked log record by copying the remaining 
    // fields to the end.
    
    pBuffer = psz = &pLine[pLogData->Used];

    if ( Flags & MD_EXTLOG_HTTP_STATUS ) 
    {  
        psz = UlStrPrintProtocolStatus(psz,pLogData->ProtocolStatus,' ');
    }

    if ( Flags & MD_EXTLOG_HTTP_SUB_STATUS ) 
    {
        psz = UlStrPrintUlong(psz, pLogData->SubStatus, ' ');
    }

    if ( Flags & MD_EXTLOG_WIN32_STATUS )
    { 
        psz = UlStrPrintUlong(psz, pLogData->Win32Status,' ');
    }

    if ( Flags & MD_EXTLOG_BYTES_SENT )
    {
        psz = UlStrPrintUlonglong(psz, pRequest->BytesSent,' ');
    }
    if ( Flags & MD_EXTLOG_BYTES_RECV )
    {
        psz = UlStrPrintUlonglong(psz, pRequest->BytesReceived,' ');
    }
    if ( Flags & MD_EXTLOG_TIME_TAKEN )
    {
        psz = UlpCopyTimeStamp(psz, pRequest, ' ');    
    }

    // Now calculate the space we have used

    pLogData->Used = 
        (USHORT) (pLogData->Used + DIFF_USHORT(psz - pBuffer));

    // Eat the last space and write the \r\n to the end.
    // Only if we have any fields picked and written.

    if (pLogData->Used)
    {
        psz = &pLine[pLogData->Used-1];     // Eat the last space
        *psz++ = '\r'; *psz++ = '\n'; *psz++ = ANSI_NULL;

        pLogData->Used += 1;
    }

    // Cleanup the UsedOffsets otherwise it will be interpreted by the
    // caller as fragmented.
    
    pLogData->Data.Str.Offset1 = pLogData->Data.Str.Offset2 = 0;

    ASSERT(pLogData->Size > pLogData->Used);

    return pLogData->Used;
}


USHORT
UlpCompleteLogRecordNCSA(
    IN OUT PUL_LOG_DATA_BUFFER  pLogData,
    IN     PUL_URI_CACHE_ENTRY  pUriEntry
    )
{
    PUL_INTERNAL_REQUEST    pRequest;
    PCHAR                   psz;
    PCHAR                   pBuffer;
    PCHAR                   pLine;
    ULONG                   BytesWritten;

    ASSERT(IS_VALID_LOG_DATA_BUFFER(pLogData));
    ASSERT(pLogData->Data.Str.Format == HttpLoggingTypeNCSA);

    BytesWritten = 0;

    pRequest = pLogData->pRequest;
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    psz = pLine = (PCHAR) pLogData->Line;

    // If this is a cache hit restore the logging data in
    // to the newly allocated log data buffer.

    if (IS_PURE_CACHE_HIT(pUriEntry,pLogData))
    {
        ASSERT(IS_VALID_URI_CACHE_ENTRY(pUriEntry));    
        ASSERT(pLogData->Used == 0);
        ASSERT(pLogData->Data.Str.Offset1 == 0);

        // Client IP       
        psz = UlStrPrintIP(
                psz,
                pRequest->pHttpConn->pConnection->RemoteAddress,
                pRequest->pHttpConn->pConnection->AddressType,
                ' '
                );

        // Fixed dash        
        *psz++ = '-'; *psz++ = ' ';

        // Authenticated users cannot be served from cache.
        *psz++ = '-'; *psz++ = ' ';

        // Mark the beginning of the date & time fields
        pLogData->Data.Str.Offset1 = DIFF_USHORT(psz - pLine);  
    }
    
    // [date:time GmtOffset] -> "[07/Jan/2000:00:02:23 -0800] "
    // Restore the pointer to the reserved space first.

    psz = &pLine[pLogData->Data.Str.Offset1];
    *psz++ = '[';

    UlGetDateTimeFields(
                           HttpLoggingTypeNCSA,
                           psz,
                          &BytesWritten,
                           NULL,
                           NULL
                           );
    psz += BytesWritten; *psz++ = ':';
    ASSERT(BytesWritten == 11);

    UlGetDateTimeFields(
                           HttpLoggingTypeNCSA,
                           NULL,
                           NULL,
                           psz,
                          &BytesWritten
                           );
    psz += BytesWritten; *psz++ = ' ';
    ASSERT(BytesWritten == 8);

    UlAcquirePushLockShared(&g_pUlNonpagedData->LogListPushLock);
    psz = UlStrPrintStr(psz, g_GMTOffset,']');
    UlReleasePushLockShared(&g_pUlNonpagedData->LogListPushLock);
    *psz++ = ' ';

    ASSERT(DIFF(psz - &pLine[pLogData->Data.Str.Offset1]) 
            == NCSA_FIX_DATE_AND_TIME_FIELD_SIZE);

    if (IS_PURE_CACHE_HIT(pUriEntry,pLogData))
    {
        ASSERT(pUriEntry->LogDataLength);
        ASSERT(pUriEntry->pLogData);

        RtlCopyMemory( psz, 
                       pUriEntry->pLogData, 
                       pUriEntry->LogDataLength
                       );
        psz += pUriEntry->LogDataLength;

        // Protocol Version
        psz = UlCopyHttpVersion(psz, pRequest->Version, '\"');                
        *psz++ = ' ';
        
        // Init the "Used" according to the cached data and date &
        // time fields we have generated.
        pLogData->Used = DIFF_USHORT(psz - pLine);  
    }

    // Forward to the end.
    pBuffer = psz = &pLine[pLogData->Used];

    psz = UlStrPrintProtocolStatus(psz, pLogData->ProtocolStatus,' ');

    psz = UlStrPrintUlonglong(psz, pRequest->BytesSent,'\r');

    pLogData->Used = 
        (USHORT) (pLogData->Used + DIFF_USHORT(psz - pBuffer));

    // \n\0

    *psz++ = '\n'; *psz++ = ANSI_NULL;
    pLogData->Used += 1;

    // Cleanup the UsedOffsets otherwise length calculation will
    // fail down below.
    
    pLogData->Data.Str.Offset1 = pLogData->Data.Str.Offset2 = 0;

    ASSERT(pLogData->Size > pLogData->Used);

    return pLogData->Used;
}

USHORT
UlpCompleteLogRecordIIS(
    IN OUT PUL_LOG_DATA_BUFFER  pLogData,
    IN     PUL_URI_CACHE_ENTRY  pUriEntry
    )
{    
    PUL_INTERNAL_REQUEST    pRequest;
    PCHAR                   psz;
    PCHAR                   pLine;
    PCHAR                   pTemp;    
    ULONG                   BytesWritten;

    ASSERT(IS_VALID_LOG_DATA_BUFFER(pLogData));
    ASSERT(pLogData->Data.Str.Format == HttpLoggingTypeIIS);

    BytesWritten = 0;

    pRequest = pLogData->pRequest;
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    psz = pLine = (PCHAR) pLogData->Line;
    
    // 
    // Now we need to handle two different ways of completing this
    // IIS log record; 1) Cache-miss, Build and Send Cache hit case, 
    // where the buffer interpreted as three different fragments. 
    // 2) Pure Cache-hit case where the buffer is used contiguously.
    //

    //
    // Complete the first fragment
    //

    if (IS_PURE_CACHE_HIT(pUriEntry,pLogData))
    {    
        ASSERT(pLogData->Used == 0);
        ASSERT(pLogData->Data.Str.Offset1 == 0);
        ASSERT(pLogData->Data.Str.Offset2 == 0);

        ASSERT(IS_VALID_URI_CACHE_ENTRY(pUriEntry));    

        // Client IP       
        psz = UlStrPrintIP(
                pLine,
                pRequest->pHttpConn->pConnection->RemoteAddress,
                pRequest->pHttpConn->pConnection->AddressType,
                ','
                );
        *psz++ = ' ';
        
        // Authenticated users cannot be served from cache.
        *psz++ = '-'; *psz++ = ','; *psz++ = ' ';
    }
    else
    {
        ASSERT(pLogData->Data.Str.Offset1);
        psz = pLine + pLogData->Data.Str.Offset1;
    }
    
    pTemp = psz;

    UlGetDateTimeFields(
                           HttpLoggingTypeIIS,
                           psz,
                          &BytesWritten,
                           NULL,
                           NULL
                           );
    psz += BytesWritten; *psz++ = ','; *psz++ = ' ';

    UlGetDateTimeFields(
                           HttpLoggingTypeIIS,
                           NULL,
                           NULL,
                           psz,
                          &BytesWritten
                           );
    psz += BytesWritten; *psz++ = ','; *psz++ = ' ';

    ASSERT(DIFF(psz - pTemp) <= IIS_MAX_DATE_AND_TIME_FIELD_SIZE);

    pLogData->Data.Str.Offset1 = DIFF_USHORT(psz - pLine);
    
    //
    // Complete the second fragment.
    //

    if (IS_PURE_CACHE_HIT(pUriEntry,pLogData))
    {     
        ASSERT(pUriEntry->pLogData);    
        ASSERT(pUriEntry->LogDataLength);
        ASSERT(pUriEntry->LogDataLength == 
                (ULONG) (pUriEntry->UsedOffset1 + 
                         pUriEntry->UsedOffset2)
                         );        

        // Remember the fragment start.
        pTemp = psz;
        
        // Restore it from the cache
        RtlCopyMemory( psz,
                       pUriEntry->pLogData,
                       pUriEntry->UsedOffset1
                       );
        
        psz += pUriEntry->UsedOffset1;        
    }
    else
    {
        // Fragmented. And 2nd frag cannot be empty.
        ASSERT(pLogData->Data.Str.Offset2);

        // Remember the fragment start.
        pTemp = pLine 
                + IIS_LOG_LINE_SECOND_FRAGMENT_OFFSET;
        
        // Jump to the end of the 2nd frag.
        psz = pTemp
              + pLogData->Data.Str.Offset2;
    }

    psz = UlpCopyTimeStamp(psz, pRequest, ',');
    *psz++ = ' ';

    psz = UlStrPrintUlonglong(psz, pRequest->BytesReceived,',');
    *psz++ = ' ';

    psz = UlStrPrintUlonglong(psz, pRequest->BytesSent,',');
    *psz++ = ' ';

    psz = UlStrPrintProtocolStatus(psz,pLogData->ProtocolStatus,','); 
    *psz++ = ' ';

    psz = UlStrPrintUlong(psz, pLogData->Win32Status,','); 
    *psz++ = ' ';

    pLogData->Data.Str.Offset2 = DIFF_USHORT(psz - pTemp);

    //
    // Complete the third fragment.
    //
    
    if (IS_PURE_CACHE_HIT(pUriEntry,pLogData))
    {     
        RtlCopyMemory( psz,
                      &pUriEntry->pLogData[pUriEntry->UsedOffset1],
                       pUriEntry->UsedOffset2
                       );                

        // Total record size is whatever we have copied before this
        // last copy plus the size of the last copy.
        
        pLogData->Used = (USHORT)
            (DIFF_USHORT(psz - pLine) + pUriEntry->UsedOffset2);

        // Reset the UsedOffset1 & 2 to zero to tell that the log line
        // is not fragmented anymore but a complete line.
        
        pLogData->Data.Str.Offset1 = pLogData->Data.Str.Offset2 = 0;
    }
    else
    {
        // It is already there and its size is stored in "Used".
        
        ASSERT(pLogData->Used);
    }
    
    ASSERT(pLogData->Size > (pLogData->Data.Str.Offset1 + 
                              pLogData->Data.Str.Offset2 + 
                              pLogData->Used));
        
    //
    // Return the complete size of the IIS log record.
    //

    return (pLogData->Data.Str.Offset1 + 
             pLogData->Data.Str.Offset2 + 
             pLogData->Used);
}

/***************************************************************************++

Routine Description:

    UlLogHttpHit :

       This function ( or its cache pair ) gets called everytime a log hit
       happens. Just before completing the SendResponse request to the user.

       The most likely places for calling this API or its pair for cache
       is just before the send completion when we were about the destroy
       send trackers.

       Means:

        1.  UlpCompleteSendRequestWorker for ORDINARY hits; before destroying
            the PUL_CHUNK_TRACKER for send operation.

        2.  UlpCompleteSendCacheEntryWorker for both types of CACHE hits
            (cache build&send or just pure cache hit) before destroying the
            the PUL_FULL_TRACKER for cache send operation.
            
        3.  Fast I/O path.

       This function requires Request & Response structures ( whereas its
       cache pair only requires the Request ) to successfully generate the
       the log fields and even for referencing to the right log configuration
       settings for this  site ( thru pRequest's pConfigInfo  pointer ).

Arguments:

    pLogBuffer - Half baked log data allocated at the capture time.

                 >MUST< be cleaned up by the caller.

--***************************************************************************/

NTSTATUS
UlLogHttpHit(
    IN PUL_LOG_DATA_BUFFER  pLogData
    )
{
    NTSTATUS                Status;
    PUL_CONFIG_GROUP_OBJECT pConfigGroup;
    PUL_INTERNAL_REQUEST    pRequest;
    PUL_LOG_FILE_ENTRY      pEntry;
    USHORT                  LogSize;

    //
    // A LOT of sanity checks.
    //

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    UlTrace(LOGGING, ("Http!UlLogHttpHit: pLogData %p\n", pLogData));

    ASSERT(IS_VALID_LOG_DATA_BUFFER(pLogData));

    pRequest = pLogData->pRequest;
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    //
    // If logging is disabled or log settings don't
    // exist then do not proceed. Just exit out.
    //

    if (pRequest->ConfigInfo.pLoggingConfig == NULL ||
        IS_LOGGING_DISABLED(pRequest->ConfigInfo.pLoggingConfig)
        )
    {
        return STATUS_SUCCESS;
    }

    pConfigGroup = pRequest->ConfigInfo.pLoggingConfig;
    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));

#ifdef IMPLEMENT_SELECTIVE_LOGGING
    //
    // See if the selective logging is turned on. If it is on and
    // if the request's response code does not match,  do not log
    // this request.
    //
    
    if (!UlpIsRequestSelected(pConfigGroup,pLogData->ProtocolStatus))
    {
        return STATUS_SUCCESS;
    }
#endif

    //
    // Generate the remaining log fields.
    //
    
    switch(pLogData->Data.Str.Format)
    {
        case HttpLoggingTypeW3C:
        {
            LogSize = UlpCompleteLogRecordW3C(pLogData, NULL);
            if (LogSize == 0)
            {
                return STATUS_SUCCESS; // No log fields, nothing to log
            }
        }
        break;

        case HttpLoggingTypeNCSA:
        {
             LogSize = UlpCompleteLogRecordNCSA(pLogData, NULL);
             ASSERT(LogSize > 0);
        }
        break;

        case HttpLoggingTypeIIS:
        {
             LogSize = UlpCompleteLogRecordIIS(pLogData, NULL);
             ASSERT(LogSize > 0);            
        }
        break;

        default:
        {
            ASSERT(!"Unknown Log Format Type\n");
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Finally this log line is ready to rock. Lets write it out.
    //

    UlAcquirePushLockShared(&g_pUlNonpagedData->LogListPushLock);

    //
    // We might have null pEntry pointer if the allocation failed 
    // because of a lack of resources. This case should be handled
    // by minute timer.
    //
    
    pEntry = pConfigGroup->pLogFileEntry;

    if (pEntry == NULL)
    {
        UlTrace(LOGGING,("Http!UlLogHttpHit: Null logfile entry !\n"));        
        UlReleasePushLockShared(&g_pUlNonpagedData->LogListPushLock);        
        return STATUS_INVALID_PARAMETER;
    }
    
    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));

    Status = UlpCheckAndWrite(pEntry, pConfigGroup, pLogData);
    
    if (!NT_SUCCESS(Status))
    {
        UlTrace(LOGGING, ("Http!UlLogHttpHit: entry %p, failure %08lx \n",
                            pEntry,
                            Status
                            ));
    }

    UlReleasePushLockShared(&g_pUlNonpagedData->LogListPushLock);

    return Status;
}

/***************************************************************************++

Routine Description:

    If the tracker doesn't supply a pLogData, it pre-calculates the max size
    and then completes the log record. Finally it logs the "complete" record 
    out to the log file buffer.

    It also assumes the responsibility of cleaning up the pLogData,regardless
    of the fact that it is provided by pTracker or not.

Arguments:

    pTracker - Supplies the tracker to complete.

--***************************************************************************/

NTSTATUS
UlLogHttpCacheHit(
    IN OUT PUL_FULL_TRACKER pTracker
    )
{
    NTSTATUS                Status;
    PUL_LOG_DATA_BUFFER     pLogData;
    PUL_LOG_FILE_ENTRY      pEntry;    
    ULONG                   NewLength;
    PUL_INTERNAL_REQUEST    pRequest;
    PUL_URI_CACHE_ENTRY     pUriEntry;
    PUL_CONFIG_GROUP_OBJECT pConfigGroup;
    USHORT                  LogSize;

    //
    // A Lot of sanity checks.
    //

    PAGED_CODE();

    ASSERT(pTracker);
    ASSERT(IS_VALID_FULL_TRACKER(pTracker));

    Status = STATUS_SUCCESS;

    pRequest = pTracker->pRequest;
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    pUriEntry = pTracker->pUriEntry;
    ASSERT(IS_VALID_URI_CACHE_ENTRY(pUriEntry));    

    //
    // If the tracker has already a log buffer allocated , carry 
    // over the  ownership of that  pLogData. This would  happen
    // for  build and send type of cache hits.
    //
    
    pLogData = pTracker->pLogData;
    pTracker->pLogData = NULL;

    //
    // If logging is disabled or log settings don't  exist, then 
    // just exit out. However goto cleanup path just in case  we
    // have acquired a pLogData from the tracker above.
    //

    pConfigGroup = pUriEntry->ConfigInfo.pLoggingConfig;

    if (pConfigGroup == NULL || IS_LOGGING_DISABLED(pConfigGroup))
    {
        goto end;        
    }

    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));

#ifdef IMPLEMENT_SELECTIVE_LOGGING

    //
    // See if the selective logging is turned on. If it is on and
    // if the request's response code does not match,  do not log
    // this request.
    //

    if (!UlpIsRequestSelected(pConfigGroup,pUriEntry->StatusCode))
    {
        goto end;
    }
#endif

    //
    // If this was a pure cache hit, we will need to allocate a new 
    // log data buffer here.
    //
    
    if (pLogData)
    {
        ASSERT(IS_VALID_LOG_DATA_BUFFER(pLogData));
        ASSERT(pLogData->Flags.CacheAndSendResponse == 1);        
    }
    else
    {
        switch(pConfigGroup->LoggingConfig.LogFormat)
        {
            case HttpLoggingTypeW3C:
            NewLength = UlpGetCacheHitLogLineSizeForW3C(
                            pConfigGroup->LoggingConfig.LogExtFileFlags,
                            pRequest,
                            pUriEntry->LogDataLength
                            );
            ASSERT(NewLength < MAX_LOG_RECORD_ALLOCATION_LENGTH);
            break;

            case HttpLoggingTypeNCSA:
            NewLength = MAX_NCSA_CACHE_FIELD_OVERHEAD
                        + pUriEntry->LogDataLength; 
            break;

            case HttpLoggingTypeIIS:
            NewLength = MAX_IIS_CACHE_FIELD_OVERHEAD
                        + pUriEntry->LogDataLength; 
            break;

            default:
            ASSERT(!"Unknown Log Format.\n");
            Status = STATUS_INVALID_DEVICE_STATE;
            goto end;
        }
        
        pLogData = UlpAllocateLogDataBuffer(
                        NewLength,
                        pRequest,
                        pConfigGroup
                        );        
        if (!pLogData)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }    
        
        ASSERT(IS_VALID_LOG_DATA_BUFFER(pLogData));
    }

    UlTrace(LOGGING,("Http!UlLogHttpCacheHit: pLogData %p\n",pLogData));

    pLogData->ProtocolStatus = pUriEntry->StatusCode;
    pLogData->SubStatus = 0;
    
    LOG_SET_WIN32STATUS(
        pLogData, 
        pTracker->IoStatus.Status
        );
    
    // TODO: For cache hits send bytes info is coming from the tracker.
    // TODO: Need to update pRequest->BytesSent for cache hits as well.
    
    pRequest->BytesSent = pTracker->IoStatus.Information;
        
    switch(pLogData->Data.Str.Format)
    {
        case HttpLoggingTypeW3C: 
        {             
            LogSize = UlpCompleteLogRecordW3C(pLogData, pUriEntry);
            if (LogSize == 0)
            {
                goto end; // No log fields, nothing to log
            }                
        }
        break;

        case HttpLoggingTypeNCSA:
        {
            LogSize = UlpCompleteLogRecordNCSA(pLogData, pUriEntry);
            ASSERT(LogSize);
        }
        break;

        case HttpLoggingTypeIIS:
        {
            LogSize = UlpCompleteLogRecordIIS(pLogData, pUriEntry);
            ASSERT(LogSize);                
        }
        break;

        default:
        ASSERT(!"Unknown Log Format !");
        goto end;
    }

    //
    // Finally this log line is ready to rock. Let's log it out.
    //

    UlAcquirePushLockShared(&g_pUlNonpagedData->LogListPushLock);

    pEntry = pConfigGroup->pLogFileEntry;

    if (pEntry == NULL)
    {
        UlTrace(LOGGING,
            ("Http!UlpLogHttpcacheHit: pEntry is NULL !"));
        
        UlReleasePushLockShared(
            &g_pUlNonpagedData->LogListPushLock);    
        
        goto end;
    }
    
    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));

    Status = UlpCheckAndWrite(pEntry, pConfigGroup, pLogData);
    
    if (!NT_SUCCESS(Status))
    {
        UlTrace(LOGGING,
         ("Http!UlpLogHttpcacheHit: pEntry %p, Failure %08lx \n",
           pEntry,
           Status
           ));
    }

    UlReleasePushLockShared(&g_pUlNonpagedData->LogListPushLock);

end:
    if (pLogData)
    {        
        UlDestroyLogDataBuffer(pLogData);
    }
    
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ulnamesp.h ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    ulnamesp.c

Abstract:

    This module implements the namespace reservation and registration 
    support.

Author:

    Anish Desai (anishd) 13-May-2002

Revision History:

--*/

//
// Private declaration
//

//
// Scheme and port binding entry
//

typedef struct _UL_PORT_SCHEME_PAIR {

    USHORT         PortNumber;
    BOOLEAN        Secure;
    LONG           RefCount;

} UL_PORT_SCHEME_PAIR, *PUL_PORT_SCHEME_PAIR;

//
// Scheme and port binding table
//

typedef struct _UL_PORT_SCHEME_TABLE {

    LONG                UsedCount;
    LONG                AllocatedCount;
    UL_PORT_SCHEME_PAIR Table[0];

} UL_PORT_SCHEME_TABLE, *PUL_PORT_SCHEME_TABLE;

//
// Default table size  (Make it a power of 2.)
//

#define UL_DEFAULT_PORT_SCHEME_TABLE_SIZE 2

//
// Private functions
//

BOOLEAN
UlpFindPortNumberIndex(
    IN  USHORT  PortNumber,
    OUT PLONG   pIndex
    );

NTSTATUS
UlpBindSchemeToPort(
    IN BOOLEAN Secure,
    IN USHORT  PortNumber
    );

NTSTATUS
UlpUnbindSchemeFromPort(
    IN BOOLEAN Secure,
    IN USHORT  PortNumber
    );

NTSTATUS
UlpQuerySchemeForPort(
    IN  USHORT   PortNumber,
    OUT PBOOLEAN Secure
    );

NTSTATUS
UlpUpdateReservationInRegistry(
    IN BOOLEAN                   Add,
    IN PHTTP_PARSED_URL          pParsedUrl,
    IN PSECURITY_DESCRIPTOR      pSecurityDescriptor,
    IN ULONG                     SecurityDescriptorLength
    );

NTSTATUS
UlpLogGeneralInitFailure(
    IN NTSTATUS LogStatus
    );

NTSTATUS
UlpLogSpecificInitFailure(
    IN PKEY_VALUE_FULL_INFORMATION pFullInfo,
    IN NTSTATUS                    LogStatus
    );

NTSTATUS
UlpValidateUrlSdPair(
    IN  PKEY_VALUE_FULL_INFORMATION pFullInfo,
    OUT PWSTR *                     ppSanitizedUrl,
    OUT PHTTP_PARSED_URL            pParsedUrl
    );

NTSTATUS
UlpReadReservations(
    VOID
    );

NTSTATUS
UlpTreeAllocateNamespace(
    IN  PHTTP_PARSED_URL        pParsedUrl,
    IN  HTTP_URL_OPERATOR_TYPE  OperatorType,
    IN  PACCESS_STATE           AccessState,
    IN  ACCESS_MASK             DesiredAccess,
    IN  KPROCESSOR_MODE         RequestorMode,
    OUT PUL_CG_URL_TREE_ENTRY  *ppEntry
    );

NTSTATUS
UlpTreeReserveNamespace(
    IN  PHTTP_PARSED_URL            pParsedUrl,
    IN  PSECURITY_DESCRIPTOR        pUrlSD,
    IN  PACCESS_STATE               AccessState,
    IN  ACCESS_MASK                 DesiredAccess,
    IN  KPROCESSOR_MODE             RequestorMode
    );

NTSTATUS
UlpReserveUrlNamespace(
    IN PHTTP_PARSED_URL          pParsedUrl,
    IN PSECURITY_DESCRIPTOR      pUrlSD,
    IN PACCESS_STATE             AccessState,
    IN ACCESS_MASK               DesiredAccess,
    IN KPROCESSOR_MODE           RequestorMode
    );

PUL_DEFERRED_REMOVE_ITEM
UlpAllocateDeferredRemoveItem(
    IN PHTTP_PARSED_URL pParsedUrl
    );

NTSTATUS
UlpTreeRegisterNamespace(
    IN PHTTP_PARSED_URL            pParsedUrl,
    IN HTTP_URL_CONTEXT            UrlContext,
    IN PUL_CONFIG_GROUP_OBJECT     pConfigObject,
    IN PACCESS_STATE               AccessState,
    IN ACCESS_MASK                 DesiredAccess,
    IN KPROCESSOR_MODE             RequestorMode
    );

NTSTATUS
UlpRegisterUrlNamespace(
    IN PHTTP_PARSED_URL          pParsedUrl,
    IN HTTP_URL_CONTEXT          UrlContext,
    IN PUL_CONFIG_GROUP_OBJECT   pConfigObject,
    IN PACCESS_STATE             AccessState,
    IN ACCESS_MASK               DesiredAccess,
    IN KPROCESSOR_MODE           RequestorMode
    );

NTSTATUS
UlpPrepareSecurityDescriptor(
    IN  PSECURITY_DESCRIPTOR   pInSecurityDescriptor,
    IN  KPROCESSOR_MODE        RequestorMode,
    OUT PSECURITY_DESCRIPTOR * ppPreparedSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR * ppCapturedSecurityDescriptor,
    OUT PULONG                 pCapturedSecurityDescriptorLength
    );

NTSTATUS
UlpAddReservationEntry(
    IN PHTTP_PARSED_URL          pParsedUrl,
    IN PSECURITY_DESCRIPTOR      pUserSecurityDescriptor,
    IN ULONG                     SecurityDescriptorLength,
    IN PACCESS_STATE             AccessState,
    IN ACCESS_MASK               AccessMask,
    IN KPROCESSOR_MODE           RequestorMode,
    IN BOOLEAN                   bPersist
    );

NTSTATUS
UlpDeleteReservationEntry(
    IN PHTTP_PARSED_URL          pParsedUrl,
    IN PACCESS_STATE             AccessState,
    IN ACCESS_MASK               AccessMask,
    IN KPROCESSOR_MODE           RequestorMode
    );

NTSTATUS
UlpNamespaceAccessCheck(
    IN  PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN  PACCESS_STATE        AccessState           OPTIONAL,
    IN  ACCESS_MASK          DesiredAccess         OPTIONAL,
    IN  KPROCESSOR_MODE      RequestorMode         OPTIONAL,
    IN  PCWSTR               pObjectName           OPTIONAL
    );

//
// Public functions
//

NTSTATUS
UlInitializeNamespace(
    VOID
    );

VOID
UlTerminateNamespace(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ullogp.h ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    ullogp.h (Http.sys Ansi Logging)

Abstract:

    This module implements the logging facilities
    for Http.sys including the NCSA, IIS and W3CE types
    of logging.

Author:

    Ali E. Turkoglu (aliTu)       10-May-2000

Revision History:

--*/


#ifndef _ULLOGP_H_
#define _ULLOGP_H_

//
// Private definitions for the Ul Logging Module
//

#define UTF8_LOGGING_ENABLED()           (g_UTF8Logging)

#define _UL_GET_LOG_FILE_NAME_PREFIX(x)                             \
    (   (x) == HttpLoggingTypeW3C   ? L"\\extend" :                 \
        (x) == HttpLoggingTypeIIS   ? L"\\inetsv" :                 \
        (x) == HttpLoggingTypeNCSA  ? L"\\ncsa"   : L"\\unknwn"     \
        )

#define _UL_GET_LOG_FILE_NAME_PREFIX_UTF8(x)                        \
    (   (x) == HttpLoggingTypeW3C   ? L"\\u_extend" :               \
        (x) == HttpLoggingTypeIIS   ? L"\\u_inetsv" :               \
        (x) == HttpLoggingTypeNCSA  ? L"\\u_ncsa"   : L"\\u_unknwn" \
        )

#define UL_GET_LOG_FILE_NAME_PREFIX(x) \
    (UTF8_LOGGING_ENABLED() ? _UL_GET_LOG_FILE_NAME_PREFIX_UTF8(x) :\
                              _UL_GET_LOG_FILE_NAME_PREFIX(x))

//
// Obsolete - Only used by Old Hit
// Replace this with a switch statement inside a inline function
// which is  more efficient, if u start using it again
//

#define UL_GET_NAME_FOR_HTTP_VERB(v)                            \
    (   (v) == HttpVerbUnparsed  ? L"UNPARSED" :                \
        (v) == HttpVerbUnknown   ? L"UNKNOWN" :                 \
        (v) == HttpVerbInvalid   ? L"INVALID" :                 \
        (v) == HttpVerbOPTIONS   ? L"OPTIONS" :                 \
        (v) == HttpVerbGET       ? L"GET" :                     \
        (v) == HttpVerbHEAD      ? L"HEAD" :                    \
        (v) == HttpVerbPOST      ? L"POST" :                    \
        (v) == HttpVerbPUT       ? L"PUT" :                     \
        (v) == HttpVerbDELETE    ? L"DELETE" :                  \
        (v) == HttpVerbTRACE     ? L"TRACE" :                   \
        (v) == HttpVerbCONNECT   ? L"CONNECT" :                 \
        (v) == HttpVerbTRACK     ? L"TRACK" :                   \
        (v) == HttpVerbMOVE      ? L"MOVE" :                    \
        (v) == HttpVerbCOPY      ? L"COPY" :                    \
        (v) == HttpVerbPROPFIND  ? L"PROPFIND" :                \
        (v) == HttpVerbPROPPATCH ? L"PROPPATCH" :               \
        (v) == HttpVerbMKCOL     ? L"MKCOL" :                   \
        (v) == HttpVerbLOCK      ? L"LOCK" :                    \
        (v) == HttpVerbUNLOCK    ? L"UNLOCK" :                  \
        (v) == HttpVerbSEARCH    ? L"SEARCH" :                  \
        L"???"                                                  \
        )

#define UL_DEFAULT_NCSA_FIELDS          (MD_EXTLOG_CLIENT_IP                | \
                                         MD_EXTLOG_USERNAME                 | \
                                         MD_EXTLOG_DATE                     | \
                                         MD_EXTLOG_TIME                     | \
                                         MD_EXTLOG_METHOD                   | \
                                         MD_EXTLOG_URI_STEM                 | \
                                         MD_EXTLOG_URI_QUERY                | \
                                         MD_EXTLOG_PROTOCOL_VERSION         | \
                                         MD_EXTLOG_HTTP_STATUS              | \
                                         MD_EXTLOG_BYTES_SENT)

#define UL_DEFAULT_IIS_FIELDS           (MD_EXTLOG_CLIENT_IP                | \
                                         MD_EXTLOG_USERNAME                 | \
                                         MD_EXTLOG_DATE                     | \
                                         MD_EXTLOG_TIME                     | \
                                         MD_EXTLOG_SITE_NAME                | \
                                         MD_EXTLOG_COMPUTER_NAME            | \
                                         MD_EXTLOG_SERVER_IP                | \
                                         MD_EXTLOG_TIME_TAKEN               | \
                                         MD_EXTLOG_BYTES_RECV               | \
                                         MD_EXTLOG_BYTES_SENT               | \
                                         MD_EXTLOG_HTTP_STATUS              | \
                                         MD_EXTLOG_WIN32_STATUS             | \
                                         MD_EXTLOG_METHOD                   | \
                                         MD_EXTLOG_URI_STEM)

#define UL_GET_LOG_TYPE_MASK(x,y)                                     \
    (   (x) == HttpLoggingTypeW3C   ? (y) :                           \
        (x) == HttpLoggingTypeIIS   ? UL_DEFAULT_IIS_FIELDS  :        \
        (x) == HttpLoggingTypeNCSA  ? UL_DEFAULT_NCSA_FIELDS : 0      \
        )

//
// The order of the following should match with
// UL_LOG_FIELD_TYPE enum definition.
//

PWSTR UlFieldTitleLookupTable[] =
    {
        L" date",
        L" time",        
        L" s-sitename",
        L" s-computername",
        L" s-ip",
        L" cs-method",
        L" cs-uri-stem",
        L" cs-uri-query", 
        L" s-port",
        L" cs-username",        
        L" c-ip",        
        L" cs-version",
        L" cs(User-Agent)",
        L" cs(Cookie)",
        L" cs(Referer)",
        L" cs-host",
        L" sc-status",
        L" sc-substatus",
        L" sc-win32-status",        
        L" sc-bytes",
        L" cs-bytes",
        L" time-taken"
    };

#define UL_GET_LOG_FIELD_TITLE(x)      \
        ((x)>=UlLogFieldMaximum ? L"Unknown" : UlFieldTitleLookupTable[(x)])

#define UL_GET_LOG_TITLE_IF_PICKED(x,y,z)  \
        ((y)&(z) ? UL_GET_LOG_FIELD_TITLE((x)) : L"")

//
// Pick the local time for file name & rollover if format is NCSA or IIS, 
// otherwise (W3C) pick the local time only if LocaltimeRollover is set. 
//

#define UL_PICK_TIME_FIELD(pEntry, tflocal,tfgmt)           \
    ((pEntry->Flags.LocaltimeRollover ||                    \
        (pEntry->Format != HttpLoggingTypeW3C)) ? (tflocal) : (tfgmt))

#define DEFAULT_LOG_FILE_EXTENSION          L"log"
#define DEFAULT_LOG_FILE_EXTENSION_PLUS_DOT L".log"

#define SIZE_OF_GMT_OFFSET              (6)

#define IS_LOGGING_DISABLED(g)                                      \
    ((g) == NULL ||                                                 \
     (g)->LoggingConfig.Flags.Present == 0 ||                       \
     (g)->LoggingConfig.LoggingEnabled == FALSE)

//
// UlpWriteW3CLogRecord attempts to use a buffer size upto this
//

#define UL_DEFAULT_WRITE_BUFFER_LEN         (512)

//
// When a log field exceeds its limit it's replaced by
// the following default warning string.
//
#define LOG_FIELD_TOO_BIG                     "..."

//
// No log record can be longer than this. Applies to all
// log formats.
//
#define MAX_LOG_RECORD_LEN                    (10240)

//
// Any log field provided to the driver enforced by some
// sanity limit.
//
#define MAX_LOG_DEFAULT_FIELD_LEN             (64)

//
// WARNING: Logging capturing functions,  especially   the W3C
// one has been designed with  respect to the above hard coded 
// numbers. If you change any  of the above numbers,you SHOULD
// review the capturing functions to avoid the buffer overruns.
// See also the MAX_LOG_RECORD_ALLOCATION_LENGTH down below.
//

//
// W3C Capture and complete functions will allocate and use this 
// much extra space for non-string fields for cache-miss case.
// This is used for worst case allocation.
//

#define MAX_W3C_FIX_FIELD_OVERHEAD                          \
    (/* Date */        W3C_DATE_FIELD_LEN + 1 +             \
     /* Time */        W3C_TIME_FIELD_LEN + 1 +             \
     /* ServerPort */  MAX_USHORT_STR + 1 +                 \
     /* PVersion */    UL_HTTP_VERSION_LENGTH + 1 +         \
     /* PStatus */     UL_MAX_HTTP_STATUS_CODE_LENGTH + 1 + \
     /* Win32Status */ MAX_ULONG_STR + 1 +                  \
     /* SubStatus */   MAX_USHORT_STR + 1 +                 \
     /* BSent */       MAX_ULONGLONG_STR + 1 +              \
     /* BReceived */   MAX_ULONGLONG_STR + 1 +              \
     /* TTaken */      MAX_ULONGLONG_STR + 1 +              \
     /* "\r\n\0" */    3                                    \
     )

//
// W3C complete function will allocate and use this much
// much extra space for non-string fields for cache-hit 
// case. This is used for worst case allocation.
//

#define MAX_W3C_CACHE_FIELD_OVERHEAD                         \
    (/* Date */         W3C_DATE_FIELD_LEN + 1 +             \
     /* Time */         W3C_TIME_FIELD_LEN + 1 +             \
     /* UserName "- "*/ 2 +                                  \
     /* ClientIp */     MAX_IP_ADDR_STRING_LEN + 1 +         \
     /* PVersion */     UL_HTTP_VERSION_LENGTH + 1 +         \
     /* PStatus */      UL_MAX_HTTP_STATUS_CODE_LENGTH + 1 + \
     /* Win32Status */  MAX_ULONG_STR + 1 +                  \
     /* SubStatus */    MAX_USHORT_STR + 1 +                 \
     /* BSent */        MAX_ULONGLONG_STR + 1 +              \
     /* BReceived */    MAX_ULONGLONG_STR + 1 +              \
     /* TTaken */       MAX_ULONGLONG_STR + 1 +              \
     /* "\r\n\0" */     3                                    \
     )

//
// Similar definitions for NCSA and IIS formats.
//

#define MAX_NCSA_CACHE_FIELD_OVERHEAD                       \
    (/* ClientIp */    MAX_IP_ADDR_STRING_LEN + 1 +         \
     /* Fix Dash */    2 +                                  \
     /* UserName */    2 +                                  \
     /* Date & Time */ NCSA_FIX_DATE_AND_TIME_FIELD_SIZE +  \
     /* PVersion " */  UL_HTTP_VERSION_LENGTH + 1 + 1 +     \
     /* PStatus */     UL_MAX_HTTP_STATUS_CODE_LENGTH + 1 + \
     /* BSent */       MAX_ULONGLONG_STR +                  \
     /* \r\n\0 */      3                                    \
     )

#define MAX_IIS_CACHE_FIELD_OVERHEAD                        \
    (/* Client Ip */   MAX_IP_ADDR_STRING_LEN + 2 +         \
     /* UserName */    3 +                                  \
     /* Date & Time */ IIS_MAX_DATE_AND_TIME_FIELD_SIZE +   \
     /* TTaken */      MAX_ULONGLONG_STR + 2 +              \
     /* BReceived */   MAX_ULONGLONG_STR + 2 +              \
     /* BSent */       MAX_ULONGLONG_STR + 2 +              \
     /* PStatus */     UL_MAX_HTTP_STATUS_CODE_LENGTH + 2 + \
     /* Win32Status */ MAX_ULONG_STR + 2                    \
     )

//
// Default IIS fragments must be big enough to hold the max-length fields.
//

C_ASSERT(IIS_LOG_LINE_DEFAULT_FIRST_FRAGMENT_ALLOCATION_SIZE >=
    (/* ClientIp */    2 + MAX_LOG_DEFAULT_FIELD_LEN +
     /* UserName */    2 + MAX_LOG_USERNAME_FIELD_LEN +
     /* Date&Time */   2 + IIS_MAX_DATE_AND_TIME_FIELD_SIZE));

C_ASSERT(IIS_LOG_LINE_DEFAULT_FIRST_FRAGMENT_ALLOCATION_SIZE >=
    (/* ServiceName */    2 + MAX_LOG_DEFAULT_FIELD_LEN +
     /* ServerName */     2 + MAX_LOG_DEFAULT_FIELD_LEN +
     /* ServerIp */       2 + MAX_LOG_DEFAULT_FIELD_LEN +
     /* TimeTaken */      2 + MAX_ULONGLONG_STR +
     /* BytesReceived */  2 + MAX_ULONGLONG_STR +
     /* BytesSend */      2 + MAX_ULONGLONG_STR +
     /* Protocol St. */   2 + UL_MAX_HTTP_STATUS_CODE_LENGTH +
     /* Win32 St. */      2 + MAX_ULONG_STR     
     ));

#define IIS_LOG_LINE_MAX_THIRD_FRAGMENT_SIZE                \
    (/* Method */    2 + MAX_LOG_METHOD_FIELD_LEN +         \
     /* UriQuery */  2 + MAX_LOG_EXTEND_FIELD_LEN +         \
     /* UriStem */   2 + MAX_LOG_EXTEND_FIELD_LEN +         \
     /* "r\n\0" */   3)

C_ASSERT(UL_ANSI_LOG_LINE_BUFFER_SIZE == 
    (IIS_LOG_LINE_DEFAULT_FIRST_FRAGMENT_ALLOCATION_SIZE  + 
     IIS_LOG_LINE_DEFAULT_SECOND_FRAGMENT_ALLOCATION_SIZE +
     IIS_LOG_LINE_DEFAULT_THIRD_FRAGMENT_ALLOCATION_SIZE)   );

//
// Maximum log record allocation for W3C format;
//
// MAX_LOG_RECORD_LEN           : Upper limit for log record
// + 16 Bytes                   : 4 * (sizeof(LOG_FIELD_TOO_BIG) + 
//                                       SeparatorSpace:' ')
//                              : For UserAgent,Cookie,Referer,Host
// + MAX_W3C_FIX_FIELD_OVERHEAD : To be able to ensure reserved space for 
//                              : post-generated log fields.

#define MAX_LOG_RECORD_ALLOCATION_LENGTH                    \
            (MAX_LOG_RECORD_LEN +                           \
             4 * (STRLEN_LIT(LOG_FIELD_TOO_BIG) + 1) +      \
             MAX_W3C_FIX_FIELD_OVERHEAD                     \
             )

//
// Private function calls
//

NTSTATUS
UlpConstructLogEntry(
    IN  PHTTP_CONFIG_GROUP_LOGGING pConfig,
    OUT PUL_LOG_FILE_ENTRY       * ppEntry
    );

VOID
UlpInsertLogEntry(
    IN PUL_LOG_FILE_ENTRY  pEntry
    );

NTSTATUS
UlpAppendW3CLogTitle(
    IN     PUL_LOG_FILE_ENTRY   pEntry,
    OUT    PCHAR                pDestBuffer,
    IN OUT PULONG               pBytesCopied
    );

VOID
UlpInitializeTimers(
    VOID
    );

VOID
UlpTerminateTimers(
    VOID
    );

NTSTATUS
UlpRecycleLogFile(
    IN  PUL_LOG_FILE_ENTRY  pEntry
    );

NTSTATUS
UlpHandleRecycle(
    IN OUT PVOID            pContext
    );

__inline
BOOLEAN
UlpIsLogFileOverFlow(
        IN  PUL_LOG_FILE_ENTRY  pEntry,
        IN  ULONG               ReqdBytes
        );

VOID
UlpEventLogWriteFailure(
    IN PUL_LOG_FILE_ENTRY pEntry,
    IN NTSTATUS Status
    );

NTSTATUS
UlpFlushLogFile(
    IN PUL_LOG_FILE_ENTRY  pEntry
    );
    
NTSTATUS
UlpRefreshFileName(
    IN PUNICODE_STRING      pDirectory,
    IN PUL_LOG_FILE_ENTRY   pEntry
    );

VOID
UlpGetGMTOffset();

VOID
UlpLogHttpCacheHitWorker(
    IN PUL_LOG_DATA_BUFFER     pLogData,
    IN PUL_CONFIG_GROUP_OBJECT pConfigGroup
    );

NTSTATUS
UlpWriteToLogFile(
    IN PUL_LOG_FILE_ENTRY  pFile,
    IN ULONG               RecordSize,
    IN PCHAR               pRecord,
    IN ULONG               UsedOffset1,
    IN ULONG               UsedOffset2
    );

NTSTATUS
UlpWriteToLogFileShared(
    IN PUL_LOG_FILE_ENTRY  pFile,
    IN ULONG               RecordSize,
    IN PCHAR               pRecord,
    IN ULONG               UsedOffset1,
    IN ULONG               UsedOffset2
    );

NTSTATUS
UlpWriteToLogFileExclusive(
    IN PUL_LOG_FILE_ENTRY  pFile,
    IN ULONG               RecordSize,
    IN PCHAR               pRecord,
    IN ULONG               UsedOffset1,
    IN ULONG               UsedOffset2
    );

NTSTATUS
UlpWriteToLogFileDebug(
    IN PUL_LOG_FILE_ENTRY   pFile,
    IN ULONG                RecordSize,
    IN PCHAR                pRecord,
    IN ULONG                UsedOffset1,
    IN ULONG                UsedOffset2
    );

NTSTATUS
UlpMakeEntryInactive(
    IN OUT PUL_LOG_FILE_ENTRY pEntry
    );

PUL_LOG_DATA_BUFFER
UlpAllocateLogDataBuffer(
    IN  ULONG                   Size,
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUL_CONFIG_GROUP_OBJECT pConfigGroup
    );

NTSTATUS
UlpCreateLogFile(
    IN OUT PUL_LOG_FILE_ENTRY  pEntry,
    IN     PUL_CONFIG_GROUP_OBJECT pConfigGroup
    );

#ifdef IMPLEMENT_SELECTIVE_LOGGING
/***************************************************************************++

Routine Description:

    Simple macro will return TRUE if request status code type is matching 
    with user's selection in the logging config.
    
Arguments:

    pConfigGroup - Config Group for the logging configuration.
    StatusCode - Protocol status code.

--***************************************************************************/

__inline 
BOOLEAN
UlpIsRequestSelected(
    IN PUL_CONFIG_GROUP_OBJECT pConfigGroup,
    IN USHORT StatusCode
    )
{    
    ASSERT(StatusCode <= UL_MAX_HTTP_STATUS_CODE);
    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));

    //
    // The 4xx and 5xx status codes are considered an error.
    //
    // - 4xx: Client Error - The request contains bad syntax or cannot
    //   be fulfilled
    //
    // - 5xx: Server Error - The server failed to fulfill an apparently
    //   valid request        
    //

    switch(pConfigGroup->LoggingConfig.SelectiveLogging)
    {
        case HttpLogAllRequests:
            return TRUE;
        break;

        case HttpLogSuccessfulRequests:
            return ((BOOLEAN) (StatusCode   < 400 || StatusCode >= 600));
        break;

        case HttpLogErrorRequests:
            return ((BOOLEAN) (StatusCode >= 400 && StatusCode < 600));          
        break;   

        default:
            ASSERT(!"Invalid Selective Logging Type !");
        break;
    }

    return FALSE;
}
#endif

__inline
NTSTATUS
UlpCheckAndWrite(
    IN OUT PUL_LOG_FILE_ENTRY      pEntry,
    IN     PUL_CONFIG_GROUP_OBJECT pConfigGroup,
    IN     PUL_LOG_DATA_BUFFER     pLogData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUL_STR_LOG_DATA pStrData = &pLogData->Data.Str;
    
    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));
    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));

    //
    // Check whether we have to create the log file first or not.
    //        
    
    if (!pEntry->Flags.Active)
    {    
        UlAcquirePushLockExclusive(&pEntry->EntryPushLock);

        //
        // Ping again to see if we have been blocked on the lock, and
        // somebody else already took care of the creation.
        //
        
        if (!pEntry->Flags.Active)
        {
            Status = UlpCreateLogFile(pEntry, pConfigGroup);            
        }
        
        UlReleasePushLockExclusive(&pEntry->EntryPushLock);

        if (!NT_SUCCESS(Status))
        {
            return Status;
        }
    }
    
    //
    // Now we know that the log file is there, therefore it's time to write.
    //
    
    Status =
       UlpWriteToLogFile (
            pEntry,
            pStrData->Offset1 + pStrData->Offset2 + pLogData->Used,
            (PCHAR) pLogData->Line,
            pStrData->Offset1,
            pStrData->Offset2
            );

    return Status;    
}

ULONG
UlpGetLogLineSizeForW3C(
    IN PHTTP_LOG_FIELDS_DATA pLogData,
    IN ULONG   Mask,
    IN BOOLEAN Utf8Enabled
    );

#define IS_PURE_CACHE_HIT(pUriEntry, pLogData)             \
            ((pUriEntry) && ((pLogData)->Flags.CacheAndSendResponse == 0))

#endif  // _ULLOGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ulnamesp.c ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    ulnamesp.c

Abstract:

    This module implements the namespace reservation and registration
    functions.

Author:

    Anish Desai (anishd) 13-May-2002

Revision History:

--*/


#include "precomp.h"
#include "cgroupp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UlpFindPortNumberIndex)
#pragma alloc_text(PAGE, UlpQuerySchemeForPort)
#pragma alloc_text(PAGE, UlpBindSchemeToPort)
#pragma alloc_text(PAGE, UlpUnbindSchemeFromPort)
#pragma alloc_text(PAGE, UlpUpdateReservationInRegistry)
#pragma alloc_text(INIT, UlpLogGeneralInitFailure)
#pragma alloc_text(INIT, UlpLogSpecificInitFailure)
#pragma alloc_text(INIT, UlpValidateUrlSdPair)
#pragma alloc_text(INIT, UlpReadReservations)
#pragma alloc_text(INIT, UlInitializeNamespace)
#pragma alloc_text(PAGE, UlTerminateNamespace)
#pragma alloc_text(PAGE, UlpNamespaceAccessCheck)
#pragma alloc_text(PAGE, UlpTreeAllocateNamespace)
#pragma alloc_text(PAGE, UlpTreeReserveNamespace)
#pragma alloc_text(PAGE, UlpReserveUrlNamespace)
#pragma alloc_text(PAGE, UlpAllocateDeferredRemoveItem)
#pragma alloc_text(PAGE, UlpTreeRegisterNamespace)
#pragma alloc_text(PAGE, UlpRegisterUrlNamespace)
#pragma alloc_text(PAGE, UlpPrepareSecurityDescriptor)
#pragma alloc_text(PAGE, UlpAddReservationEntry)
#pragma alloc_text(PAGE, UlpDeleteReservationEntry)
#endif

//
// File Global variables.
//

PUL_PORT_SCHEME_TABLE g_pPortSchemeTable = NULL;
UL_PUSH_LOCK          g_PortSchemeTableLock;
BOOLEAN               g_InitNamespace = FALSE;
HANDLE                g_pUrlAclKeyHandle = NULL;


/**************************************************************************++

Routine Description:

    This routine searches the global port scheme assignment table for a
    given port number.  g_PortSchemeTableLock must be acquired either
    exclusive or shared.

Arguments:

    PortNumber - Supplies the port number to be searched.

    pIndex - Returns the index where the port number is present.
        If no match is found, it contains the index where this PortNumber
        must be inserted.

Return Value:

    TRUE - If a match is found.
    FALSE - Otherwise.

--**************************************************************************/
BOOLEAN
UlpFindPortNumberIndex(
    IN  USHORT  PortNumber,
    OUT PLONG   pIndex
    )
{
    LONG StartIndex, EndIndex, Index;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(pIndex != NULL);

    ASSERT(g_pPortSchemeTable != NULL);
    ASSERT(g_pPortSchemeTable->UsedCount <= MAXUSHORT + 1);
    ASSERT(g_pPortSchemeTable->AllocatedCount <= MAXUSHORT + 1);

    StartIndex = 0;
    EndIndex = g_pPortSchemeTable->UsedCount - 1;

    //
    // Binary search the table of port numbers and schemes.
    //

    while (StartIndex <= EndIndex)
    {
        ASSERT(0 <= StartIndex && StartIndex < g_pPortSchemeTable->UsedCount);
        ASSERT(0 <= EndIndex   && EndIndex   < g_pPortSchemeTable->UsedCount);

        Index = (StartIndex + EndIndex) / 2;

        if (PortNumber == g_pPortSchemeTable->Table[Index].PortNumber)
        {
            //
            // Found the port number.
            //

            *pIndex = Index;

            return TRUE;
        }
        else if (PortNumber < g_pPortSchemeTable->Table[Index].PortNumber)
        {
            EndIndex = Index - 1;
        }
        else
        {
            StartIndex = Index + 1;
        }
    }

    //
    // Did not find a match.  Return the position where it should be inserted.
    //

    *pIndex = StartIndex;

    return FALSE;
}


/**************************************************************************++

Routine Description:

    This routine returns scheme bound to a port number.

Arguments:

    PortNumber - Supplies the port number.

    Secure - Returns whether a http or https scheme is bound to the
        supplied port number.

Return Value:

    STATUS_SUCCESS - if a scheme is bound to the port number.
    STATUS_INVALID_PARAMETER - if no scheme is bound to the port number.

--**************************************************************************/
NTSTATUS
UlpQuerySchemeForPort(
    IN  USHORT   PortNumber,
    OUT PBOOLEAN Secure
    )
{
    NTSTATUS Status;
    LONG     Index;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Find if there is a scheme bound to the port number.
    //

    Status = STATUS_INVALID_PARAMETER;

    UlAcquirePushLockShared(&g_PortSchemeTableLock);

    if (UlpFindPortNumberIndex(PortNumber, &Index))
    {
        *Secure = g_pPortSchemeTable->Table[Index].Secure;
        Status = STATUS_SUCCESS;
    }

    UlReleasePushLockShared(&g_PortSchemeTableLock);

    return Status;
}


/**************************************************************************++

Routine Description:

    This routine adds a port, scheme pair to the global table.

Arguments:

    PortNumber - Supplies the port number.

    Scheme - Supplies the scheme.

Return Value:

    NTSTATUS.

--**************************************************************************/
NTSTATUS
UlpBindSchemeToPort(
    IN BOOLEAN Secure,
    IN USHORT  PortNumber
    )
{
    LONG     StartIndex;
    BOOLEAN  bFound;
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Acquire lock exclusively.
    //

    UlAcquirePushLockExclusive(&g_PortSchemeTableLock);

    //
    // Find an existing scheme that is bound to the port.
    //

    bFound = UlpFindPortNumberIndex(PortNumber, &StartIndex);

    if (bFound)
    {
        ASSERT(0 <= StartIndex && StartIndex < g_pPortSchemeTable->UsedCount);
        ASSERT(g_pPortSchemeTable->Table[StartIndex].PortNumber == PortNumber);

        if (g_pPortSchemeTable->Table[StartIndex].Secure != Secure)
        {
            //
            // Trying to bind a scheme that is different from an
            // existing bound scheme.
            //

            Status = STATUS_OBJECT_NAME_COLLISION;
            goto end;
        }

        //
        // The reference count is a LONG.  Don't let it overflow.
        //

        if (g_pPortSchemeTable->Table[StartIndex].RefCount == MAXLONG)
        {
            Status = STATUS_INTEGER_OVERFLOW;
            goto end;
        }

        //
        // Found an existing entry, increment the reference count.
        //

        ASSERT(g_pPortSchemeTable->Table[StartIndex].RefCount > 0);
        g_pPortSchemeTable->Table[StartIndex].RefCount++;
        Status = STATUS_SUCCESS;
        goto end;
    }

    //
    // StartIndex is the place where this new entry must be added!
    //

    ASSERT(0 <= StartIndex && StartIndex <= g_pPortSchemeTable->UsedCount);

    //
    // Is the table full?
    //

    if (g_pPortSchemeTable->UsedCount == g_pPortSchemeTable->AllocatedCount)
    {
        //
        // Allocate a bigger table.
        //

        PUL_PORT_SCHEME_TABLE pNewTable;
        ULONG                 NewTableSize;

        //
        // Table does not need more than 65536 entries.
        //

        ASSERT(g_pPortSchemeTable->AllocatedCount < MAXUSHORT + 1);

        NewTableSize = MIN(g_pPortSchemeTable->AllocatedCount*2, MAXUSHORT+1);

        pNewTable = UL_ALLOCATE_STRUCT_WITH_SPACE(
                        PagedPool,
                        UL_PORT_SCHEME_TABLE,
                        sizeof(UL_PORT_SCHEME_PAIR) * NewTableSize,
                        UL_PORT_SCHEME_TABLE_POOL_TAG
                        );

        if (pNewTable == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto end;
        }

        //
        // Initialize the new table.
        //

        pNewTable->UsedCount = g_pPortSchemeTable->UsedCount;
        pNewTable->AllocatedCount = NewTableSize;

        //
        // Copy 0 to (StartIndex-1) entries from the current table to the
        // new table.
        //

        if (StartIndex > 0)
        {
            RtlCopyMemory(
                &pNewTable->Table[0],
                &g_pPortSchemeTable->Table[0],
                sizeof(UL_PORT_SCHEME_PAIR) * StartIndex
                );
        }

        //
        // Copy StartIndex to (UsedCount-1) entries from the current table
        // to the new table.  They are copied from position (StartIndex+1)
        // in the new table, effectively creating a free entry at StartIndex.
        //

        if (g_pPortSchemeTable->UsedCount - StartIndex > 0)
        {
            RtlCopyMemory(
                &pNewTable->Table[StartIndex + 1],
                &g_pPortSchemeTable->Table[StartIndex],
                sizeof(UL_PORT_SCHEME_PAIR)
                    * (g_pPortSchemeTable->UsedCount - StartIndex)
                );
        }

        //
        // Free the current table.  Make new table current.
        //

        UL_FREE_POOL(g_pPortSchemeTable, UL_PORT_SCHEME_TABLE_POOL_TAG);

        g_pPortSchemeTable = pNewTable;
    }
    else
    {
        //
        // Table must have free entries at the bottom (higher indices.)
        //

        ASSERT(g_pPortSchemeTable->UsedCount
               < g_pPortSchemeTable->AllocatedCount);
        //
        // No table expansion.  But move entries from StartIndex to
        // (UsedCount-1) to new location at (StartIndex+1) to UsedCount.
        //

        if (g_pPortSchemeTable->UsedCount - StartIndex > 0)
        {
            RtlMoveMemory(
                &g_pPortSchemeTable->Table[StartIndex + 1],
                &g_pPortSchemeTable->Table[StartIndex],
                sizeof(UL_PORT_SCHEME_PAIR)
                    * (g_pPortSchemeTable->UsedCount - StartIndex)
                );
        }
    }

    //
    // Add the new entry to the table.
    //

    ASSERT(g_pPortSchemeTable->UsedCount < g_pPortSchemeTable->AllocatedCount);
    ASSERT(0 <= StartIndex && StartIndex <= g_pPortSchemeTable->UsedCount);

    g_pPortSchemeTable->UsedCount++;
    g_pPortSchemeTable->Table[StartIndex].PortNumber = PortNumber;
    g_pPortSchemeTable->Table[StartIndex].Secure = Secure;
    g_pPortSchemeTable->Table[StartIndex].RefCount = 1;
    Status = STATUS_SUCCESS;

 end:
    UlReleasePushLockExclusive(&g_PortSchemeTableLock);
    return Status;
}


/**************************************************************************++

Routine Description:

    This routine unbinds a previously bound scheme from a port.

Arguments:

    PortNumber - Supplies the port number.

    Scheme - Supplies the scheme.

Return Value:

    NTSTATUS.

--**************************************************************************/
NTSTATUS
UlpUnbindSchemeFromPort(
    IN BOOLEAN Secure,
    IN USHORT  PortNumber
    )
{
    LONG     StartIndex;
    BOOLEAN  bFound;
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Acquire lock exclusively.
    //

    UlAcquirePushLockExclusive(&g_PortSchemeTableLock);

    //
    // Find an existing scheme that is bound to PortNumber.
    //

    bFound = UlpFindPortNumberIndex(PortNumber, &StartIndex);

    if (bFound == FALSE)
    {
        //
        // There is no scheme bound to PortNumber.
        //

        ASSERT(FALSE); // catch this misuse
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto end;
    }

    //
    // Sanity check.  StartIndex must be within bounds.  PortNumber must match.
    //

    ASSERT(0 <= StartIndex && StartIndex < g_pPortSchemeTable->UsedCount);
    ASSERT(g_pPortSchemeTable->Table[StartIndex].PortNumber == PortNumber);

    //
    // Is the scheme bound to PortNumber same as Scheme?
    //

    if (g_pPortSchemeTable->Table[StartIndex].Secure != Secure)
    {
        //
        // Tried to unbind a scheme from a port and the port is not bound to
        // the scheme.
        //

        ASSERT(FALSE); // catch this misuse
        Status = STATUS_OBJECT_NAME_COLLISION;
        goto end;
    }

    //
    // Decrement the ref count.
    //

    ASSERT(g_pPortSchemeTable->Table[StartIndex].RefCount > 0);

    g_pPortSchemeTable->Table[StartIndex].RefCount--;

    //
    // If RefCount drops to zero, its time to cleanup that entry.
    //

    if (g_pPortSchemeTable->Table[StartIndex].RefCount == 0)
    {
        LONG                  NewTableSize = 0;
        PUL_PORT_SCHEME_TABLE pNewTable = NULL;
        BOOLEAN               bContract = FALSE;

        //
        // Do we need to contract the table?
        //

        if (4 * (g_pPortSchemeTable->UsedCount - 1)
                <= g_pPortSchemeTable->AllocatedCount)
        {
            //
            // Current table is less than 25% used.
            //

            NewTableSize = g_pPortSchemeTable->AllocatedCount / 2;

            if (NewTableSize >= UL_DEFAULT_PORT_SCHEME_TABLE_SIZE)
            {
                //
                // Current table is at least twice bigger than the default
                // size.
                //

                pNewTable = UL_ALLOCATE_STRUCT_WITH_SPACE(
                                PagedPool,
                                UL_PORT_SCHEME_TABLE,
                                sizeof(UL_PORT_SCHEME_PAIR) * NewTableSize,
                                UL_PORT_SCHEME_TABLE_POOL_TAG
                                );

                if (pNewTable != NULL)
                {
                    //
                    // Could allocate memory for a smaller table.
                    //

                    bContract = TRUE;
                }
            }
        }

        if (bContract)
        {
            //
            // We are going to contract the existing table.
            //

            ASSERT(pNewTable != NULL);
            ASSERT(NewTableSize >= UL_DEFAULT_PORT_SCHEME_TABLE_SIZE);
            ASSERT(NewTableSize >= g_pPortSchemeTable->UsedCount - 1);

            //
            // Initialize the new table.
            //

            pNewTable->UsedCount = g_pPortSchemeTable->UsedCount;
            pNewTable->AllocatedCount = NewTableSize;

            //
            // Copy all entries from 0 to (StartIndex - 1)
            // from the current table to the new table.
            //

            if (StartIndex > 0)
            {
                RtlCopyMemory(
                    &pNewTable->Table[0],
                    &g_pPortSchemeTable->Table[0],
                    sizeof(UL_PORT_SCHEME_PAIR) * StartIndex
                    );
            }

            //
            // Copy all entries from (StartIndex+1) to (UsedCount-1)
            // from the current table to the new table.
            //
            // Effectively, StartIndex entry is eliminated.
            //

            if (g_pPortSchemeTable->UsedCount - StartIndex - 1 > 0)
            {
                RtlCopyMemory(
                    &pNewTable->Table[StartIndex],
                    &g_pPortSchemeTable->Table[StartIndex+1],
                    sizeof(UL_PORT_SCHEME_PAIR)
                        * (g_pPortSchemeTable->UsedCount - StartIndex - 1)
                    );
            }

            //
            // Free the current table.
            //

            UL_FREE_POOL(g_pPortSchemeTable, UL_PORT_SCHEME_TABLE_POOL_TAG);

            //
            // The new table becomes the current table.
            //

            g_pPortSchemeTable = pNewTable;
        }
        else
        {
            //
            // We are not going to contract the table but still have to
            // eliminate the unused table entry.  Move all entries from
            // (StartIndex + 1) to (UsedCount - 1) one position up.
            //

            if (g_pPortSchemeTable->UsedCount - StartIndex - 1 > 0)
            {
                RtlMoveMemory(
                    &g_pPortSchemeTable->Table[StartIndex],
                    &g_pPortSchemeTable->Table[StartIndex+1],
                    sizeof(UL_PORT_SCHEME_PAIR)
                        * (g_pPortSchemeTable->UsedCount - StartIndex - 1)
                    );
            }
        }

        g_pPortSchemeTable->UsedCount--;
    }

    Status = STATUS_SUCCESS;

 end:
    UlReleasePushLockExclusive(&g_PortSchemeTableLock);
    return Status;
}


/**************************************************************************++

Routine Description:

    This routine adds (or deletes) a (url, security descriptor) pair to
    (or from) the registry.

Arguments:

    Add - Supplies the operation, TRUE imples add and FALSE implies delete.

    pParsedUrl - Supplies the parsed url of the reservation.

    pSecurityDescriptor - Supplies the security descriptor.
        (It must be valid while adding and NULL while deleting.)

    SecurityDescriptorLength - Supplies the length of the security
        descriptor in bytes.  (It must be non-zero when adding and
        zero when deleting.)

Return Value:

    NTSTATUS.

--**************************************************************************/
NTSTATUS
UlpUpdateReservationInRegistry(
    IN BOOLEAN                   Add,
    IN PHTTP_PARSED_URL          pParsedUrl,
    IN PSECURITY_DESCRIPTOR      pSecurityDescriptor,
    IN ULONG                     SecurityDescriptorLength
    )
{
    NTSTATUS       Status;
    PWSTR          pUrlToWrite = NULL;
    PWSTR          pNewUrl = NULL;
    UNICODE_STRING UnicodeUrl;

    //
    // sanity check
    //

    PAGED_CODE();
    ASSERT(IS_VALID_HTTP_PARSED_URL(pParsedUrl));
    ASSERT(pParsedUrl->pFullUrl[pParsedUrl->UrlLength] == UNICODE_NULL);
    ASSERT(Add?(pSecurityDescriptor != NULL):(pSecurityDescriptor == NULL));
    ASSERT(Add?(SecurityDescriptorLength > 0):(SecurityDescriptorLength == 0));

    //
    // Do we have a valid handle to the registry key?  It can be invalid, 
    // for instance, if during driver initialization ZwCreateKey failed.
    //

    if (g_pUrlAclKeyHandle == NULL)
    {
        return STATUS_INVALID_HANDLE;
    }

    //
    // default error code
    //

    Status = STATUS_INVALID_PARAMETER;

    //
    // Do some special processing for literal ip address sites.
    //

    if (HttpUrlSite_IP == pParsedUrl->SiteType)
    {
        //
        // convert scheme://ip:port:ip/ to scheme://ip:port/
        //

        PWSTR  pToken;
        PWSTR  pLiteralAddr;
        SIZE_T UrlLength;

        //
        // length of original url in wchar (+1 for UNICODE_NULL)
        //

        UrlLength = (pParsedUrl->UrlLength + 1);

        pNewUrl = UL_ALLOCATE_ARRAY(
                      PagedPool,
                      WCHAR,
                      UrlLength,
                      URL_POOL_TAG
                      );

        if (pNewUrl == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto end;
        }

        RtlCopyMemory(pNewUrl, pParsedUrl->pFullUrl, UrlLength*sizeof(WCHAR));

        //
        // skip ipv6 literal address if present
        //

        pToken = &pNewUrl[HTTP_PREFIX_COLON_INDEX + 3];

        if (pToken[0] == L'[' || pToken[1] == L'[')
        {
            pToken = wcschr(pToken, L']');

            if (pToken == NULL)
            {
                ASSERT(FALSE);
                goto end;
            }
        }

        //
        // skip to the port number
        //

        pToken = wcschr(pToken, L':');

        if (pToken == NULL)
        {
            ASSERT(FALSE);
            goto end;
        }

        //
        // skip ':'
        //

        pToken++;

        //
        // find the literal address
        //

        pToken = wcschr(pToken, L':');

        if (pToken == NULL)
        {
            ASSERT(FALSE);
            goto end;
        }

        pLiteralAddr = pToken;

        //
        // find begining of abs path
        //

        pToken = wcschr(pToken, L'/');

        if (pToken == NULL)
        {
            ASSERT(FALSE);
            goto end;
        }

        //
        // overwrite literal address.  effectively convert
        // scheme://host:port:ip/abs_path -> scheme://host:port/abs_path
        //

        while (*pToken != L'\0')
        {
            *pLiteralAddr++ = *pToken++;
        }

        *pLiteralAddr = L'\0';

        //
        // use new url when writing to registry
        //

        pUrlToWrite = pNewUrl;
    }
    else
    {
        pUrlToWrite = pParsedUrl->pFullUrl;
    }

    ASSERT(pUrlToWrite != NULL);

    //
    // convert url to unicode for registry functions
    //

    Status = UlInitUnicodeStringEx(&UnicodeUrl, pUrlToWrite);

    if (!NT_SUCCESS(Status))
    {
        goto end;
    }

    if (Add)
    {
        //
        // write url and security descriptor to registry
        //

        Status = ZwSetValueKey(
                     g_pUrlAclKeyHandle,
                     &UnicodeUrl,
                     0, // title index; must be zero.
                     REG_BINARY,
                     pSecurityDescriptor,
                     SecurityDescriptorLength
                     );

        if (!NT_SUCCESS(Status))
        {
            //
            // too bad...can't write to registry.  delete the old key value.
            // ignore the return status.
            //

            ZwDeleteValueKey(g_pUrlAclKeyHandle, &UnicodeUrl);
        }
    }
    else
    {
        //
        // delete url from the registry.
        //

        Status = ZwDeleteValueKey(g_pUrlAclKeyHandle, &UnicodeUrl);
    }

 end:

    if (pNewUrl != NULL)
    {
        UL_FREE_POOL(pNewUrl, URL_POOL_TAG);
    }

    return Status;
}


/**************************************************************************++

Routine Description:

    This routine is called during namespace initialization if an error
    occurs while intializing the config group url tree using the entries
    in registry.

Arguments:

    LogCount - Supplies the number of logs written in the past.  Returns
        one more than the input value.

    LogStatus - Supplies the status to log in the event log.

Return Value:

    NTSTATUS.

--**************************************************************************/
__inline
NTSTATUS
UlpLogGeneralInitFailure(
    IN NTSTATUS LogStatus
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Write an event log entry.
    //

    Status = UlWriteEventLogEntry(
                 EVENT_HTTP_NAMESPACE_INIT_FAILED, // EventCode
                 0,                                // UniqueEventValue
                 0,                                // NumStrings
                 NULL,                             // pStringArray
                 sizeof(LogStatus),                // DataSize
                 &LogStatus                        // Data
                 );

    return Status;
}


/**************************************************************************++

Routine Description:

    This routine writes an event log message about a specific namespace
    reservation initialization failure.  It logs the url present in the
    full info structure.

Arguments:

    LogCount - Supplies the number of logs written in the past.  Returns
        one more than the input value.

    pFullInfo - Supplies information read from registry.

    LogStatus - Supplies the error status to log.

Return Value:

    NTSTATUS.

--**************************************************************************/
NTSTATUS
UlpLogSpecificInitFailure(
    IN PKEY_VALUE_FULL_INFORMATION pFullInfo,
    IN NTSTATUS                    LogStatus
    )
{
    NTSTATUS Status;
    PWSTR    pMessage;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(pFullInfo != NULL);

    //
    // pFullInfo->Name contains the url to be written and it not 
    // UNICODE_NULL terminated.  Allocate memory to copy.
    //

    pMessage = UL_ALLOCATE_ARRAY(
                   PagedPool,
                   WCHAR,
                   (pFullInfo->NameLength / sizeof(WCHAR)) + 1,
                   URL_POOL_TAG
                   );

    if (pMessage != NULL)
    {
        //
        // Copy url and null terminate it.
        //

        RtlCopyMemory(pMessage, pFullInfo->Name, pFullInfo->NameLength);
        pMessage[pFullInfo->NameLength / sizeof(WCHAR)] = UNICODE_NULL;

        //
        // Write event log entry.
        //

        Status = UlEventLogOneStringEntry(
                     EVENT_HTTP_NAMESPACE_INIT2_FAILED,
                     pMessage,
                     TRUE,
                     LogStatus
                     );

        UL_FREE_POOL(pMessage, URL_POOL_TAG);
    }
    else
    {
        //
        // Could not allocate memory.  Log just the error code.
        //

        Status = UlpLogGeneralInitFailure(LogStatus);
    }

    return Status;
}


/**************************************************************************++

Routine Description:

    This routine validates registry key value name (url) and data (security
    descriptor).  Called only during driver initialization.

Arguments:

    pFullInfo - Supplies the registry key value name and data.

    ppSanitizeUrl - Returns sanitized url.  Must be freed to paged pool.

    pParsedUrl - Returns parsed url information.

Return Value:

    NTSTATUS.

--**************************************************************************/
NTSTATUS
UlpValidateUrlSdPair(
    IN  PKEY_VALUE_FULL_INFORMATION pFullInfo,
    OUT PWSTR *                     ppSanitizedUrl,
    OUT PHTTP_PARSED_URL            pParsedUrl
    )
{
    NTSTATUS Status;
    BOOLEAN  Success;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(pFullInfo != NULL);
    ASSERT(ppSanitizedUrl != NULL);
    ASSERT(pParsedUrl != NULL);

    //
    // Key value type must be binary.
    //

    if (pFullInfo->Type != REG_BINARY)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Then, validate security descriptor.  It must be a self-relative
    // security descriptor.
    //

    Success = RtlValidRelativeSecurityDescriptor(
                  (PUCHAR)pFullInfo + pFullInfo->DataOffset,
                  pFullInfo->DataLength,
                  0
                  );

    if (!Success)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Value name must be at least one unicode char long.
    //

    if (pFullInfo->NameLength < sizeof(WCHAR))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Then validate the url.
    //

    Status = UlSanitizeUrl(
                 pFullInfo->Name,
                 pFullInfo->NameLength / sizeof(WCHAR),
                 TRUE, // trailing slash required
                 ppSanitizedUrl,
                 pParsedUrl
                 );

    return Status;
}


/***************************************************************************++

Routine Description:

    This function gets called from the Driver Load routine. It builds the
    URL ACLing information from the registry. If the URL ACLing key itself
    is not present, we'll add the defaults.

    If there are any bogus entries in the URIACL entry, we'll ignore them with
    and eventlog. The routine will return failure only on a major error.

    Not-reentrant.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS.

--***************************************************************************/
NTSTATUS
UlpReadReservations(
    VOID
    )
{
    KEY_VALUE_FULL_INFORMATION  fullInfo;
    PKEY_VALUE_FULL_INFORMATION pFullInfo = NULL;
    ULONG                       Length;
    ULONG                       Index;
    UNICODE_STRING              BaseName;
    NTSTATUS                    Status;
    OBJECT_ATTRIBUTES           objectAttributes;
    ULONG                       Disposition;
    ULONG                       bEventLog = TRUE;
    ULONG                       dataLength;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Open the registry.
    //

    Status = UlInitUnicodeStringEx(&BaseName, REGISTRY_URLACL_INFORMATION);

    if (!NT_SUCCESS(Status))
    {
        //
        // Write an event log entry.
        //

        ASSERT(FALSE); // shouldn't happen!
        UlpLogGeneralInitFailure(Status);
        goto end;
    }

    InitializeObjectAttributes(
        &objectAttributes,                        // ObjectAttributes
        &BaseName,                                // ObjectName
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,                                     // RootDirectory
        NULL                                      // SecurityDescriptor
        );

    Status = ZwCreateKey(
                &g_pUrlAclKeyHandle,
                KEY_READ | KEY_WRITE,    // AccessMask
                &objectAttributes,
                0,                       // TitleIndex
                NULL,                    // Class
                REG_OPTION_NON_VOLATILE,
                &Disposition
                );

    if (!NT_SUCCESS(Status))
    {
        //
        // Write an event log entry.
        //

        UlpLogGeneralInitFailure(Status);

        //
        // Make the handle NULL so that it is not used elsewhere accidentally.
        //

        g_pUrlAclKeyHandle = NULL;
        goto end;
    }

    if (Disposition == REG_CREATED_NEW_KEY)
    {
        //
        // we created the key, hence there is nothing to read!
        //

        goto end;
    }

    pFullInfo = &fullInfo;
    Length    = sizeof(fullInfo);
    Index     = 0;

    dataLength = 0;
    RtlZeroMemory(pFullInfo, Length);

    //
    // loop through all registry key values, making reservations for each
    //

    for (;;)
    {
        Status = ZwEnumerateValueKey(
                        g_pUrlAclKeyHandle,
                        Index,
                        KeyValueFullInformation,
                        (PVOID) pFullInfo,
                        Length,
                        &dataLength
                        );

        if (Status == STATUS_SUCCESS)
        {
            PWSTR           pSanitizedUrl;
            HTTP_PARSED_URL ParsedUrl;

            //
            // First validate the registry data.
            //

            Status = UlpValidateUrlSdPair(
                         pFullInfo,
                         &pSanitizedUrl,
                         &ParsedUrl
                         );

            if (NT_SUCCESS(Status))
            {
                //
                // Add this url to the CG url tree.
                //

                Status = UlpAddReservationEntry(
                             &ParsedUrl,
                             (PSECURITY_DESCRIPTOR)
                             ((PUCHAR) pFullInfo + pFullInfo->DataOffset),
                             pFullInfo->DataLength,
                             (PACCESS_STATE)NULL,
                             (ACCESS_MASK)0,
                             KernelMode,
                             FALSE
                             );

                //
                // Free memory that was allocated by UlSanitizeUrl.
                //

                UL_FREE_POOL(pSanitizedUrl, URL_POOL_TAG);
            }
            else
            {
                Status = STATUS_REGISTRY_CORRUPT;
            }

            if (!NT_SUCCESS(Status))
            {
                //
                // Write an event log entry that an error occurred.
                // Ignore the error and continue processing.
                //

                if (bEventLog)
                {
                    bEventLog = FALSE;
                    UlpLogSpecificInitFailure(pFullInfo, Status);
                }
            }

            //
            // Move to the next value in registry.
            //

            Index ++;
        }
        else if (Status == STATUS_NO_MORE_ENTRIES)
        {
            //
            // We've reached the end, so this is a success.
            //

            break;
        }
        else if (Status == STATUS_BUFFER_OVERFLOW)
        {
            //
            // Sanity check.
            //

            ASSERT(dataLength >= pFullInfo->DataLength +
                                 pFullInfo->NameLength +
                                 FIELD_OFFSET(KEY_VALUE_FULL_INFORMATION, Name)
                  );

            //
            // Remember how much memory to allocate.
            //

            Length = dataLength;

            //
            // If any memory was allocated in previous iterations, free it now.
            //

            if (pFullInfo != &fullInfo)
            {
                UL_FREE_POOL(pFullInfo, UL_REGISTRY_DATA_POOL_TAG);
            }

            //
            // Allocate memory.
            //

            pFullInfo = UL_ALLOCATE_POOL(
                            PagedPool,
                            dataLength,
                            UL_REGISTRY_DATA_POOL_TAG
                            );

            if(!pFullInfo)
            {
                //
                // Write an event log entry.
                //

                UlpLogGeneralInitFailure(STATUS_INSUFFICIENT_RESOURCES);
                goto end;
            }

            //
            // Initialize.
            //

            RtlZeroMemory(pFullInfo, dataLength);
        }
        else
        {
            //
            // An unknown error occurred.  Event log and get out.
            //

            UlpLogGeneralInitFailure(Status);
            goto end;
        }
    }

 end:

    //
    // Free pFullInfo structure if it was allocated above.
    //

    if (pFullInfo != &fullInfo && pFullInfo != NULL)
    {
        UL_FREE_POOL(pFullInfo, UL_REGISTRY_DATA_POOL_TAG);
    }

    return STATUS_SUCCESS;
}


/**************************************************************************++

Routine Description:

    This routine initializes the namespace registration and reservation
    support.  Not re-entrant.

Arguments:

    None.

Return Value:

    NTSTATUS.

--**************************************************************************/
NTSTATUS
UlInitializeNamespace(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(!g_InitNamespace);

    if (!g_InitNamespace)
    {
        //
        // Allocate port scheme table.
        //

        g_pPortSchemeTable = UL_ALLOCATE_STRUCT_WITH_SPACE(
                                 PagedPool,
                                 UL_PORT_SCHEME_TABLE,
                                 sizeof(UL_PORT_SCHEME_PAIR)
                                 * UL_DEFAULT_PORT_SCHEME_TABLE_SIZE,
                                 UL_PORT_SCHEME_TABLE_POOL_TAG
                                 );

        if (g_pPortSchemeTable == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto end;
        }

        g_pPortSchemeTable->UsedCount = 0;
        g_pPortSchemeTable->AllocatedCount = UL_DEFAULT_PORT_SCHEME_TABLE_SIZE;

        //
        // Initialize pushlock.
        //

        UlInitializePushLock(&g_PortSchemeTableLock,
                             "g_PortSchemeTableLock",
                             0,
                             UL_PORT_SCHEME_TABLE_POOL_TAG
                             );

        //
        // Now add reservation entries from registry.
        //

        CG_LOCK_WRITE();

        Status = UlpReadReservations();

        CG_UNLOCK_WRITE();

        if (!NT_SUCCESS(Status))
        {
            UL_FREE_POOL(g_pPortSchemeTable, UL_PORT_SCHEME_TABLE_POOL_TAG);
            UlDeletePushLock(&g_PortSchemeTableLock);
            goto end;
        }

        g_InitNamespace = TRUE;
    }

 end:
    return Status;
}


/**************************************************************************++

Routine Description:

    This routine terminates the namespace stuff.  Not re-entrant.

Arguments:

    None.

Return Value:

    None.

--**************************************************************************/
VOID
UlTerminateNamespace(
    VOID
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    if (g_InitNamespace)
    {
        //
        // Delete pushlock.
        //

        UlDeletePushLock(&g_PortSchemeTableLock);

        //
        // Delete port scheme table.
        //

        ASSERT(g_pPortSchemeTable != NULL);
        UL_FREE_POOL(g_pPortSchemeTable, UL_PORT_SCHEME_TABLE_POOL_TAG);
        g_pPortSchemeTable = NULL;

        //
        // Delete the handle to registry key.
        //

        if(g_pUrlAclKeyHandle != NULL)
        {
            ZwClose(g_pUrlAclKeyHandle);
            g_pUrlAclKeyHandle = NULL;
        }

        //
        // Terminated.
        //

        g_InitNamespace = FALSE;
    }
}


/**************************************************************************++

Routine Description:

    This routine performs access check based on the supplied access state.
    All access check succeeds for administrators and local system.

    Note: If the access state is NULL, the function returns success.
          USE AT YOUR OWN RISK!

Arguments:

    pSecurityDescriptor - Supplies security descriptor protecting the
        namespace.

    AccessState - Supplies a pointer to the access state of the caller.

    DesiredAccess - Supplies access mask.

    RequestorMode - Supplies the requestor mode.

    pObjectName - Supplies the namespace that is being access.

Return Value:

    NTSTATUS.

--**************************************************************************/
NTSTATUS
UlpNamespaceAccessCheck(
    IN  PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN  PACCESS_STATE        AccessState           OPTIONAL,
    IN  ACCESS_MASK          DesiredAccess         OPTIONAL,
    IN  KPROCESSOR_MODE      RequestorMode         OPTIONAL,
    IN  PCWSTR               pObjectName           OPTIONAL
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(pSecurityDescriptor != NULL);
    ASSERT(RtlValidSecurityDescriptor(pSecurityDescriptor));

    if (AccessState == NULL)
    {
        //
        // No access check.  USE EXTREME CAUTION!
        //

        return STATUS_SUCCESS;
    }

    //
    // Check the access.
    //

    Status = UlAccessCheck(
                 pSecurityDescriptor,
                 AccessState,
                 DesiredAccess,
                 RequestorMode,
                 pObjectName
                 );

    if (!NT_SUCCESS(Status))
    {
        //
        // Access check failed.  See if the caller has admin or system
        // privileges.
        //

        Status = UlAccessCheck(
                     g_pAdminAllSystemAll,
                     AccessState,
                     DesiredAccess,
                     RequestorMode,
                     pObjectName
                     );
    }

    return Status;
}


/**************************************************************************++

Routine Description:

    This routine allocates a namespace in the config group url tree.  It is
    mainly called during reservations and registrations.

    It ensures that the caller is authorized to do the operation and there
    are no duplicate reservations and registrations.

Arguments:

    pParsedUrl - Supplies the parsed url of the namespace.

    OperatorType - Supplies the operation being performed (either
                   registration or reservation.)

    AccessState - Supplies the access state of the caller.

    DesiredAccess - Supplies the access desired by the caller.

    RequestorMode - Supplies the processor mode of the caller.

    ppEntry - Returns the config group url tree entry for the namespace.

Return Value:

    NTSTATUS.

--**************************************************************************/
NTSTATUS
UlpTreeAllocateNamespace(
    IN  PHTTP_PARSED_URL        pParsedUrl,
    IN  HTTP_URL_OPERATOR_TYPE  OperatorType,
    IN  PACCESS_STATE           AccessState,
    IN  ACCESS_MASK             DesiredAccess,
    IN  KPROCESSOR_MODE         RequestorMode,
    OUT PUL_CG_URL_TREE_ENTRY  *ppEntry
    )
{
    NTSTATUS              Status;
    PUL_CG_URL_TREE_ENTRY pSiteEntry;
    PUL_CG_URL_TREE_ENTRY pEntry;
    PUL_CG_URL_TREE_ENTRY pReservation;
    PWSTR                 pNextToken;
    PSECURITY_DESCRIPTOR  pSD;

    //
    // Sanity check.
    //
    PAGED_CODE();
    ASSERT(IS_CG_LOCK_OWNED_WRITE());
    ASSERT(IS_VALID_HTTP_PARSED_URL(pParsedUrl));
    ASSERT(ppEntry != NULL);

    //
    // Initialize return value.
    //

    *ppEntry = NULL;

    //
    // Find a matching site.
    //

    Status = UlpTreeFindSite(pParsedUrl->pFullUrl, &pNextToken, &pSiteEntry);

    if (NT_SUCCESS(Status))
    {
        //
        // Found a matching site.
        //

        //
        // Find the longest matching reservation and exact matching entries.
        //

        Status = UlpTreeFindNodeHelper(
                     pSiteEntry,
                     pNextToken,
                     FNC_LONGEST_RESERVATION,
                     &pReservation,
                     &pEntry
                     );

        if (NT_SUCCESS(Status))
        {
            //
            // Found an exact match.
            //

            //
            // Fail duplicate registrations and reservations.
            //

            ASSERT(IS_VALID_TREE_ENTRY(pEntry));

            if (OperatorType == HttpUrlOperatorTypeRegistration)
            {
                if (pEntry->Registration == TRUE)
                {
                    //
                    // Adding a registration when it already exists!
                    //

                    Status = STATUS_OBJECT_NAME_COLLISION;
                    goto end;
                }
            }
            else if (OperatorType == HttpUrlOperatorTypeReservation)
            {
                if (pEntry->Reservation == TRUE)
                {
                    //
                    // Adding a reservation when it already exists!
                    //

                    Status = STATUS_OBJECT_NAME_COLLISION;
                    goto end;
                }
            }
            else
            {
                //
                // Should not be here!
                //

                ASSERT(FALSE);
                Status = STATUS_OBJECT_NAME_COLLISION;
                goto end;
            }
        }
        else
        {
            //
            // Did not find an exact match.
            //

            pEntry = NULL;
        }

        //
        // Find a security descriptor to check access against.
        //

        if (pReservation != NULL)
        {
            //
            // Use the SD from the longest matching reservation entry.
            //

            ASSERT(IS_VALID_TREE_ENTRY(pReservation));
            pSD = pReservation->pSecurityDescriptor;
        }
        else
        {
            //
            // No longest matching reservations...use default SD.
            //

            pSD = g_pAdminAllSystemAll;
        }

        ASSERT(pSD != NULL && RtlValidSecurityDescriptor(pSD));

        //
        // Perform access check.
        //

        Status = UlpNamespaceAccessCheck(
                     pSD,
                     AccessState,
                     DesiredAccess,
                     RequestorMode,
                     pParsedUrl->pFullUrl
                     );

        if (!NT_SUCCESS(Status))
        {
            //
            // Ouch...
            //

            goto end;
        }
    }
    else if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
    {
        //
        // Adding a new site.  Perform access check.
        // Only admin and system can add new site.
        //

        Status = UlpNamespaceAccessCheck(
                     g_pAdminAllSystemAll,
                     AccessState,
                     DesiredAccess,
                     RequestorMode,
                     pParsedUrl->pFullUrl
                     );

        if (!NT_SUCCESS(Status))
        {
            //
            // Ouch...
            //

            goto end;
        }

        //
        // The caller has permission to create a new site.
        //

        Status = UlpTreeCreateSite(
                     pParsedUrl->pFullUrl,
                     pParsedUrl->SiteType,
                     &pNextToken,
                     &pSiteEntry
                     );

        if (!NT_SUCCESS(Status))
        {
            goto end;
        }

        //
        // We have not found an exact entry.
        // Note: If one tries to allocate http://site:80/ and site is not
        //       present, we'll create the site above.  Now the pEntry
        //       is same as pSiteEntry.  We don't handle the expection
        //       here and let the UlpTreeInsert() take care of it.
        //

        pEntry = NULL;
    }
    else
    {
        //
        // Could not find the site for some reason.
        //

        goto end;
    }

    //
    // If there is no exact matching entry, create one.
    //

    if (pEntry == NULL)
    {
        //
        // Try to insert.  This will cleanup dummy nodes and sites if it fails.
        // Note:  If UlpTreeInsert finds a existing entry, it just returns
        //        the existing entry and does not add a new one.
        //

        Status = UlpTreeInsert(
                     pParsedUrl->pFullUrl,
                     pParsedUrl->SiteType,
                     pNextToken,
                     pSiteEntry,
                     &pEntry
                     );

        if (!NT_SUCCESS(Status))
        {
            goto end;
        }
    }

    //
    // Return the entry.
    //

    ASSERT(NT_SUCCESS(Status));
    *ppEntry = pEntry;

 end:
    return Status;
}


/**************************************************************************++

Routine Description:

    This routine reserves a namespace in the CG tree.

Arguments:

    pParsedUrl - Supplies the parsed url of the namespace to be reserved.

    pNextToken - Supplies the unparsed portion of the url (abs path.)

    pUrlSD - Supplies the security descriptor to be applied to the
        namespace.

    pSiteEntry - Supplies the site level tree entry under which the
        reservation will be made.

    AccessState - Supplies the access state of the caller.

    DesiredAccess - Supplies the access mask of the caller.

    RequestorMode - Supplies the processor mode of the caller.

Retutn Value:

    NTSTATUS.

--**************************************************************************/
NTSTATUS
UlpTreeReserveNamespace(
    IN  PHTTP_PARSED_URL            pParsedUrl,
    IN  PSECURITY_DESCRIPTOR        pUrlSD,
    IN  PACCESS_STATE               AccessState,
    IN  ACCESS_MASK                 DesiredAccess,
    IN  KPROCESSOR_MODE             RequestorMode
    )
{
    NTSTATUS              Status;
    PUL_CG_URL_TREE_ENTRY pEntry;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(IS_CG_LOCK_OWNED_WRITE());
    ASSERT(IS_VALID_HTTP_PARSED_URL(pParsedUrl));
    ASSERT(pUrlSD != NULL && RtlValidSecurityDescriptor(pUrlSD));

    Status = UlpTreeAllocateNamespace(
                 pParsedUrl,
                 HttpUrlOperatorTypeReservation,
                 AccessState,
                 DesiredAccess,
                 RequestorMode,
                 &pEntry
                 );

    if (!NT_SUCCESS(Status))
    {
        goto end;
    }

    //
    // mark it as a reservation entry.
    //

    ASSERT(pEntry->Reservation == FALSE);

    pEntry->Reservation = TRUE;
    InsertTailList(&g_ReservationListHead, &pEntry->ReservationListEntry);

    //
    // add security descriptor.
    //

    ASSERT(pEntry->pSecurityDescriptor == NULL);
    pEntry->pSecurityDescriptor = pUrlSD;

    //
    // all done
    //

    Status = STATUS_SUCCESS;

 end:
    return Status;
}


/**************************************************************************++

Routine Description:

    The higher level routine calls helper routines to make a namespace
    reservation.

Arguments:

    pUrl - Supplies the namespace.

    SiteType - Supplies the type of the url.

    pUrlSD - Supplies the security descriptor to be applied to the
        namespace.

    AccessState - Supplies the access state of the caller.

    DesiredAccess - Supplies the access mask of the caller.

    RequestorMode - Supplies the processor mode of the caller.

Return Value:

    NTSTATUS.

--**************************************************************************/
NTSTATUS
UlpReserveUrlNamespace(
    IN PHTTP_PARSED_URL          pParsedUrl,
    IN PSECURITY_DESCRIPTOR      pUrlSD,
    IN PACCESS_STATE             AccessState,
    IN ACCESS_MASK               DesiredAccess,
    IN KPROCESSOR_MODE           RequestorMode
    )
{
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(IS_CG_LOCK_OWNED_WRITE());

    ASSERT(pParsedUrl != NULL);
    ASSERT(pUrlSD != NULL);
    ASSERT(RtlValidSecurityDescriptor(pUrlSD));

    //
    // Don't allow reservation of urls with different schemes but same port
    // number.  For instance, if http://www.microsoft.com:80/ is reserved,
    // then don't allow reservation of https://anyhostname:80/.  Because
    // these different schemes can not share the same port.
    //

    Status = UlpBindSchemeToPort(pParsedUrl->Secure, pParsedUrl->PortNumber);

    if (!NT_SUCCESS(Status))
    {
        goto end;
    }

    //
    // Proceed to the actual reservation.
    //

    Status = UlpTreeReserveNamespace(
                 pParsedUrl,
                 pUrlSD,
                 AccessState,
                 DesiredAccess,
                 RequestorMode
                 );

    if (!NT_SUCCESS(Status))
    {
        //
        // The reservation failed.  Undo the binding done above.
        //

        NTSTATUS TempStatus;

        TempStatus = UlpUnbindSchemeFromPort(
                         pParsedUrl->Secure,
                         pParsedUrl->PortNumber
                         );

        ASSERT(NT_SUCCESS(TempStatus));
    }

 end:
    return Status;
}


/**************************************************************************++

Routine Description:

    This routine allocates a UL_DEFERRED_REMOVE_ITEM and initializes
    it with port number and scheme.  Caller must free it to the paged
    pool.

Arguments:

    pParsedUrl - Supplies the parsed url containing scheme and port number.

Return Value:

    PUL_DEFERRED_REMOVE_ITEM - if successful.
    NULL - otherwise.

--**************************************************************************/
__inline
PUL_DEFERRED_REMOVE_ITEM
UlpAllocateDeferredRemoveItem(
    IN PHTTP_PARSED_URL pParsedUrl
    )
{
    PUL_DEFERRED_REMOVE_ITEM pWorker;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(pParsedUrl != NULL);

    //
    // Allocate the structure.
    //

    pWorker = UL_ALLOCATE_STRUCT(
                  PagedPool,
                  UL_DEFERRED_REMOVE_ITEM,
                  UL_DEFERRED_REMOVE_ITEM_POOL_TAG
                  );

    if (pWorker == NULL)
    {
        return NULL;
    }

    //
    // Initialize the structure.
    //

    pWorker->Signature = UL_DEFERRED_REMOVE_ITEM_POOL_TAG;
    pWorker->UrlSecure = pParsedUrl->Secure;
    pWorker->UrlPort   = pParsedUrl->PortNumber;

    return pWorker;
}


/**************************************************************************++

Routine Description:

    This routine does the actual reservation in the CG tree.

Arguments:

    pParsedUrl - Supplies the parsed url of the namespace to be reserverd.

    pNextToken - Supplies the unparsed portion of the url.

    UrlContext - Supplies an opaque associated with this url.

    pConfigObject - Supplies a pointer to the config group to which the
        url belongs.

    pSiteEntry - Supplies a pointer to the site node.

    AccessState - Supplies access state of the caller.

    DesiredAccess - Supplies access mask of the caller.

    RequestorMode - Supplies the processor mode of the caller.

Return Value:

    NTSTATUS.

--**************************************************************************/
NTSTATUS
UlpTreeRegisterNamespace(
    IN PHTTP_PARSED_URL            pParsedUrl,
    IN HTTP_URL_CONTEXT            UrlContext,
    IN PUL_CONFIG_GROUP_OBJECT     pConfigObject,
    IN PACCESS_STATE               AccessState,
    IN ACCESS_MASK                 DesiredAccess,
    IN KPROCESSOR_MODE             RequestorMode
    )
{
    NTSTATUS              Status;
    PUL_CG_URL_TREE_ENTRY pEntry;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(IS_CG_LOCK_OWNED_WRITE());

    ASSERT(pParsedUrl != NULL);
    ASSERT(AccessState != NULL);
    ASSERT(RequestorMode == UserMode);

    Status = UlpTreeAllocateNamespace(
                 pParsedUrl,
                 HttpUrlOperatorTypeRegistration,
                 AccessState,
                 DesiredAccess,
                 RequestorMode,
                 &pEntry
                 );

    if (!NT_SUCCESS(Status))
    {
        goto end;
    }

    //
    // mark the site
    //

    ASSERT(pEntry->Registration == FALSE);
    pEntry->Registration = TRUE;

    //
    // context associated with this url
    //

    pEntry->UrlContext = UrlContext;

    //
    // link the cfg group + the url
    //

    ASSERT(pEntry->pConfigGroup == NULL);
    ASSERT(pEntry->ConfigGroupListEntry.Flink == NULL);

    pEntry->pConfigGroup = pConfigObject;
    InsertTailList(&pConfigObject->UrlListHead, &pEntry->ConfigGroupListEntry);

    //
    // Sanity check.
    //

    ASSERT(pEntry->pRemoveSiteWorkItem == NULL);
    ASSERT(pEntry->SiteAddedToEndpoint == FALSE);

    //
    // Allocate a work item (initialization is done during allocation.)
    //

    Status = STATUS_INSUFFICIENT_RESOURCES;

    pEntry->pRemoveSiteWorkItem = UlpAllocateDeferredRemoveItem(pParsedUrl);

    if (pEntry->pRemoveSiteWorkItem != NULL)
    {
        //
        // Allocation succeeded.  Now add pEntry to endpoint list.
        //

        ASSERT(IS_VALID_DEFERRED_REMOVE_ITEM(pEntry->pRemoveSiteWorkItem));

        Status = UlAddSiteToEndpointList(pParsedUrl);

        if (NT_SUCCESS(Status))
        {
            //
            // Remember that this entry was added to endpoint list.
            //

            pEntry->SiteAddedToEndpoint = TRUE;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        //
        // Something went wrong.  Need to cleanup this entry.
        //

        NTSTATUS TempStatus;

        ASSERT(pEntry->SiteAddedToEndpoint == FALSE);

        //
        // Free work item.
        //

        if (pEntry->pRemoveSiteWorkItem != NULL)
        {
            ASSERT(IS_VALID_DEFERRED_REMOVE_ITEM(pEntry->pRemoveSiteWorkItem));

            UL_FREE_POOL(
                pEntry->pRemoveSiteWorkItem,
                UL_DEFERRED_REMOVE_ITEM_POOL_TAG
                );

            pEntry->pRemoveSiteWorkItem = NULL;
            pEntry->SiteAddedToEndpoint = FALSE;
        }

        //
        // Delete the registration.
        //

        TempStatus = UlpTreeDeleteRegistration(pEntry);
        ASSERT(NT_SUCCESS(TempStatus));
    }

 end:
    return Status;
}


/**************************************************************************++

Routine Description:

    This routine is called for registering a namespace.

Arguments:

    pParsedUrl - Supplies the parsed url of the namespace to be reserverd.

    UrlContext - Supplies an opaque associated with this url.

    pConfigObject - Supplies a pointer to the config group to which the
        url belongs.

    AccessState - Supplies access state of the caller.

    DesiredAccess - Supplies access mask of the caller.

    RequestorMode - Supplies the processor mode of the caller.

Return Value:

--**************************************************************************/
NTSTATUS
UlpRegisterUrlNamespace(
    IN PHTTP_PARSED_URL          pParsedUrl,
    IN HTTP_URL_CONTEXT          UrlContext,
    IN PUL_CONFIG_GROUP_OBJECT   pConfigObject,
    IN PACCESS_STATE             AccessState,
    IN ACCESS_MASK               DesiredAccess,
    IN KPROCESSOR_MODE           RequestorMode
    )
{
    NTSTATUS              Status;
    BOOLEAN               Secure;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(IS_CG_LOCK_OWNED_WRITE());
    ASSERT(pParsedUrl != NULL);
    ASSERT(pConfigObject != NULL);
    ASSERT(AccessState != NULL);
    ASSERT(RequestorMode == UserMode);

    //
    // If there are any reservations on for a different scheme on the same
    // port, then fail this registration.
    //

    Status = UlpQuerySchemeForPort(pParsedUrl->PortNumber, &Secure);

    if (NT_SUCCESS(Status) && Secure != pParsedUrl->Secure)
    {
        //
        // Ouch...
        //

        Status = STATUS_OBJECT_NAME_COLLISION;
        goto end;
    }

    //
    // Add actual registration.
    //

    Status = UlpTreeRegisterNamespace(
                 pParsedUrl,
                 UrlContext,
                 pConfigObject,
                 AccessState,
                 DesiredAccess,
                 RequestorMode
                 );

 end:
    return Status;
}


/**************************************************************************++

Routine Description:

    Given a security descriptor, this routine returns two security 
    descriptors.  One (called captured security descriptor), is the
    the caputured and validated version of the input security descriptor.
    The other (call prepared security descriptor), is a copy of the
    captured security descriptor with the generic access mask bits
    in the DACL mapped.

Arguments:

    pInSecurityDescriptor - Supplies the input security descriptor to
        prepare.

    RequestorMode - Supplies the processor mode of the caller.

    ppPreparedSecurityDescriptor - Returns a security descriptor that is
        captured and mapped.

    ppCapturedSecurityDescriptor - Returns the captued security descriptor.

    pCapturedSecurityDescriptorLength - Returns the length of the captured
        security descriptor.

Return Value:

    NTSTATUS.

--**************************************************************************/
NTSTATUS
UlpPrepareSecurityDescriptor(
    IN  PSECURITY_DESCRIPTOR   pInSecurityDescriptor,
    IN  KPROCESSOR_MODE        RequestorMode,
    OUT PSECURITY_DESCRIPTOR * ppPreparedSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR * ppCapturedSecurityDescriptor,
    OUT PULONG                 pCapturedSecurityDescriptorLength
    )
{
    NTSTATUS             Status;
    PSECURITY_DESCRIPTOR pSD;
    ULONG                SDLength;
    PSECURITY_DESCRIPTOR pPreparedSD;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(pInSecurityDescriptor != NULL);
    ASSERT(ppPreparedSecurityDescriptor != NULL);
    ASSERT(ppCapturedSecurityDescriptor != NULL);
    ASSERT(pCapturedSecurityDescriptorLength != NULL);

    //
    // Initialize locals.
    //

    pSD = NULL;         // Caputured security descriptor
    SDLength = 0;       // Caputured security descriptor length
    pPreparedSD = NULL;

    //
    // First capture the security descriptor.
    //

    Status = SeCaptureSecurityDescriptor(
                 pInSecurityDescriptor,
                 RequestorMode,
                 PagedPool,
                 TRUE, // force capture
                 &pSD
                 );

    if (!NT_SUCCESS(Status))
    {
        pSD = NULL;
        goto end;
    }

    //
    // Now validate the security descriptor.
    //

    if (!RtlValidSecurityDescriptor(pSD))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // Calculate the length of the security descriptor.
    //

    SDLength = RtlLengthSecurityDescriptor(pSD);

    //
    // Make sure that the security descriptor is self-relative.
    //

    if (!RtlValidRelativeSecurityDescriptor(pSD, SDLength, 0))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // Make a copy of the captured security descriptor.
    //

    Status = SeCaptureSecurityDescriptor(
                 pSD,
                 KernelMode,
                 PagedPool,
                 TRUE, // force capture
                 &pPreparedSD
                 );

    if (!NT_SUCCESS(Status))
    {
        pPreparedSD = NULL;
        goto end;
    }

    //
    // Map generic access to url namespace specific rights.
    //

    Status = UlMapGenericMask(pPreparedSD);

    if (!NT_SUCCESS(Status))
    {
        goto end;
    }

 end:
    if (!NT_SUCCESS(Status))
    {
        //
        // If necessary, cleanup.
        //

        if (pSD != NULL)
        {
            SeReleaseSecurityDescriptor(pSD, RequestorMode, TRUE);
        }

        if (pPreparedSD != NULL)
        {
            SeReleaseSecurityDescriptor(pPreparedSD, KernelMode, TRUE);
        }

        *ppPreparedSecurityDescriptor = NULL;
        *ppCapturedSecurityDescriptor = NULL;
        *pCapturedSecurityDescriptorLength = 0;
    }
    else
    {
        //
        // Return values.
        //

        *ppPreparedSecurityDescriptor = pPreparedSD;
        *ppCapturedSecurityDescriptor = pSD;
        *pCapturedSecurityDescriptorLength = SDLength;
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    This routine adds a reservation entry to the CG tree and optionally to
    registry.

Arguments:

    pParsedUrl - Supplies the parsed url of the namespace to be reserved.

    pUserSecurityDescriptor - Supplies the security descriptor to be applied
        to the namespace.

    SecurityDescriptorLength - Supplies the length of the security
        descriptor.

    AccessState - Supplies the access state of the caller.

    DesiredAccess - Supplies the access mask of the caller.

    RequestorMode - Supplies the mode of the caller.

    bPersiste - Supplies the flag to force a write to the registry.

Return Value:

    NTSTATUS.

--***************************************************************************/
NTSTATUS
UlpAddReservationEntry(
    IN PHTTP_PARSED_URL          pParsedUrl,
    IN PSECURITY_DESCRIPTOR      pUserSecurityDescriptor,
    IN ULONG                     SecurityDescriptorLength,
    IN PACCESS_STATE             AccessState,
    IN ACCESS_MASK               DesiredAccess,
    IN KPROCESSOR_MODE           RequestorMode,
    IN BOOLEAN                   bPersist
    )
{
    NTSTATUS             Status;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    PSECURITY_DESCRIPTOR pCapturedSecurityDescriptor;
    ULONG                CapturedSecurityDescriptorLength;

    UNREFERENCED_PARAMETER(SecurityDescriptorLength);

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(IS_CG_LOCK_OWNED_WRITE());
    ASSERT(IS_VALID_HTTP_PARSED_URL(pParsedUrl));

    //
    // Prepare security descriptor.
    //

    Status = UlpPrepareSecurityDescriptor(
                 pUserSecurityDescriptor,
                 RequestorMode,
                 &pSecurityDescriptor,
                 &pCapturedSecurityDescriptor,
                 &CapturedSecurityDescriptorLength
                 );

    if (!NT_SUCCESS(Status))
    {
        pSecurityDescriptor = NULL;
        pCapturedSecurityDescriptor = NULL;
        CapturedSecurityDescriptorLength = 0;
        goto Cleanup;
    }

    //
    // Try reserving for the namespace.
    //

    Status = UlpReserveUrlNamespace(
                 pParsedUrl,
                 pSecurityDescriptor,
                 AccessState,
                 DesiredAccess,
                 RequestorMode
                 );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Security descriptor will be freed with the reservation entry.
    //

    pSecurityDescriptor = NULL;

    //
    // If we are required to write this entry to registry, do it now.
    //

    if (bPersist)
    {
        //
        // Use the captured security descriptor while writing to the 
        // registry.
        //

        Status = UlpUpdateReservationInRegistry(
                     TRUE,
                     pParsedUrl,
                     pCapturedSecurityDescriptor,
                     CapturedSecurityDescriptorLength
                     );

        if (!NT_SUCCESS(Status))
        {
            //
            // failed to write to registry.  now delete reservation.
            //

            UlpDeleteReservationEntry(
                pParsedUrl,
                AccessState,
                DesiredAccess,
                RequestorMode
                );
        }
        else
        {
            //
            // Successful reservation.  Write an event log entry.
            //

            UlEventLogOneStringEntry(
                EVENT_HTTP_NAMESPACE_RESERVED,
                pParsedUrl->pFullUrl,
                FALSE,         // don't write error code
                STATUS_SUCCESS // don't care
                );
        }
    }

 Cleanup:

    if (!NT_SUCCESS(Status) && pSecurityDescriptor != NULL)
    {
        SeReleaseSecurityDescriptor(pSecurityDescriptor, RequestorMode, TRUE);
    }

    if (pCapturedSecurityDescriptor != NULL)
    {
        SeReleaseSecurityDescriptor(
            pCapturedSecurityDescriptor,
            KernelMode,
            TRUE
            );
    }

    return Status;
}


/**************************************************************************++

Routine Description:

    This routine delete a valid reservation both from CG tree and registry.

Arguments:

    pParsedUrl - Supplies parsed url of the reservation to be deleted.

    AccessState - Supplies the access state of the caller.

    DesiredAccess - Supplies the access mask of the caller.

    RequestorMode - Supplies the processor mode of the caller.

Return Value:

    NTSTATUS.

--**************************************************************************/
NTSTATUS
UlpDeleteReservationEntry(
    IN PHTTP_PARSED_URL pParsedUrl,
    IN PACCESS_STATE    AccessState,
    IN ACCESS_MASK      DesiredAccess,
    IN KPROCESSOR_MODE  RequestorMode
    )
{
    NTSTATUS              Status;
    PUL_CG_URL_TREE_ENTRY pEntry;
    PUL_CG_URL_TREE_ENTRY pAncestor;
    PSECURITY_DESCRIPTOR  pSD;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(IS_CG_LOCK_OWNED_WRITE());
    ASSERT(IS_VALID_HTTP_PARSED_URL(pParsedUrl));
    ASSERT(AccessState != NULL);
    ASSERT(RequestorMode == UserMode);

    //
    // Find the reservation entry.
    //

    Status = UlpTreeFindReservationNode(pParsedUrl->pFullUrl, &pEntry);

    if (!NT_SUCCESS(Status))
    {
        //
        // Too bad...did not find a matching entry.
        //

        goto end;
    }

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_TREE_ENTRY(pEntry));
    ASSERT(pEntry->Reservation == TRUE);

    //
    // Find the closest ancestor that is a reservation.
    //

    pAncestor = pEntry->pParent;

    while (pAncestor != NULL && pAncestor->Reservation == FALSE)
    {
        pAncestor = pAncestor->pParent;
    }

    //
    // Did we find a suitable ancestor?
    //

    if (pAncestor == NULL)
    {
        //
        // Nope.  Assume the default security descriptor.
        //

        pSD = g_pAdminAllSystemAll;
    }
    else
    {
        //
        // Good.  We found an ancestor reservation.  Pick sd from there.
        //

        ASSERT(IS_VALID_TREE_ENTRY(pAncestor));
        ASSERT(pAncestor->Reservation == TRUE);
        ASSERT(pAncestor->pSecurityDescriptor != NULL);

        pSD = pAncestor->pSecurityDescriptor;
    }

    //
    // Sanity check.
    //

    ASSERT(pSD != NULL && RtlValidSecurityDescriptor(pSD));

    //
    // Perform access check.
    //

    Status = UlpNamespaceAccessCheck(
                 pSD,
                 AccessState,
                 DesiredAccess,
                 RequestorMode,
                 pParsedUrl->pFullUrl
                 );

    if (NT_SUCCESS(Status))
    {
        //
        // Permission granted.  Delete the reservation from registry.
        //

        Status = UlpUpdateReservationInRegistry(
                     FALSE,         // delete
                     pParsedUrl,    // url to delete
                     NULL,          // must be NULL
                     0              // must be 0
                     );

        if (NT_SUCCESS(Status))
        {
            //
            // Remove the reservation from the CG url tree.
            //

            Status = UlpTreeDeleteReservation(pEntry);

            ASSERT(NT_SUCCESS(Status));

            //
            // Successful deletion.  Now unbind the scheme from port.
            //

            Status = UlpUnbindSchemeFromPort(
                         pParsedUrl->Secure,
                         pParsedUrl->PortNumber
                         );

            ASSERT(NT_SUCCESS(Status));

            //
            // Successful deletion.  Write an event log entry.
            //

            UlEventLogOneStringEntry(
                EVENT_HTTP_NAMESPACE_DERESERVED,
                pParsedUrl->pFullUrl,
                FALSE,         // don't write error code
                STATUS_SUCCESS // unused
                );
        }
    }

 end:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ulparse.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    ulparse.h

Abstract:

    Contains public definitions for ulparse.c.

Author:

    Henry Sanders (henrysa)       11-May-1998

Revision History:

    Rajesh Sundaram (rajeshs)     15-Feb-2002 - Reorganized from parse.h
                                                rcvhdrs.h, parsep.h.

--*/

#ifndef _ULPARSE_H_
#define _ULPARSE_H_

NTSTATUS
UlLookupHeader(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHttpRequest,
    IN  ULONG                   HttpRequestLength,
    IN  PHEADER_MAP_ENTRY       pCurrentHeaderMap,
    IN  ULONG                   HeaderMapCount,
    IN  BOOLEAN                 bIgnore,
    OUT ULONG  *                pBytesTaken
    );

NTSTATUS
UlParseHeaderWithHint(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHttpRequest,
    IN  ULONG                   HttpRequestLength,
    IN  PHEADER_MAP_ENTRY       pHeaderHintMap,
    OUT ULONG  *                pBytesTaken
    );

NTSTATUS
UlParseHeader(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHttpRequest,
    IN  ULONG                   HttpRequestLength,
    OUT ULONG  *                pBytesTaken
     );

NTSTATUS
UlParseHeaders(
    PUL_INTERNAL_REQUEST pRequest,
    PUCHAR pBuffer,
    ULONG BufferLength,
    PULONG pBytesTaken
    );


//
// The main HTTP parse routine(s).
//

NTSTATUS
UlParseHttp(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHttpRequest,
    IN  ULONG                   HttpRequestLength,
    OUT ULONG                   *pBytesTaken
    );

NTSTATUS
UlGenerateRoutingToken(
    IN OUT PUL_INTERNAL_REQUEST pRequest,
    IN     BOOLEAN IpBased
    );

NTSTATUS
UlGenerateFixedHeaders(
    IN HTTP_VERSION Version,
    IN PHTTP_RESPONSE pUserResponse,
    IN USHORT HttpStatusCode,
    IN ULONG BufferLength,
    IN KPROCESSOR_MODE AccessMode,
    OUT PUCHAR pBuffer,
    OUT PULONG pBytesCopied
    );

//
// Date header cache.
//

ULONG
UlGenerateDateHeader(
    OUT PUCHAR pBuffer,
    OUT PLARGE_INTEGER pSystemTime
    );

NTSTATUS
UlInitializeDateCache(
    VOID
    );

VOID
UlTerminateDateCache(
    VOID
    );

NTSTATUS
UlComputeFixedHeaderSize(
    IN HTTP_VERSION Version,
    IN PHTTP_RESPONSE pUserResponse,
    IN KPROCESSOR_MODE AccessMode,
    OUT PULONG pHeaderLength
    );

ULONG
UlComputeMaxVariableHeaderSize(
    VOID
    );

VOID
UlGenerateVariableHeaders(
    IN UL_CONN_HDR ConnHeader,
    IN BOOLEAN GenerateDate,
    IN PUCHAR pContentLengthString,
    IN ULONG ContentLengthStringLength,
    OUT PUCHAR pBuffer,
    OUT PULONG pBytesCopied,
    OUT PLARGE_INTEGER pDateTime
    );

NTSTATUS
UlAppendHeaderValue(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUL_HTTP_HEADER         pHttpHeader,
    IN  PUCHAR                  pHeader,
    IN  USHORT                  HeaderLength
    );

//
// Server header handlers.
// 
//

NTSTATUS
UlSingleHeaderHandler(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHeader,
    IN  USHORT                  HeaderLength,
    IN  HTTP_HEADER_ID          HeaderID,
    OUT PULONG                  pBytesTaken
    );

NTSTATUS
UlMultipleHeaderHandler(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHeader,
    IN  USHORT                  HeaderLength,
    IN  HTTP_HEADER_ID          HeaderID,
    OUT PULONG                  pBytesTaken
    );

NTSTATUS
UlAcceptHeaderHandler(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHeader,
    IN  USHORT                  HeaderLength,
    IN  HTTP_HEADER_ID          HeaderID,
    OUT PULONG                  pBytesTaken
    );

NTSTATUS
UlHostHeaderHandler(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHeader,
    IN  USHORT                  HeaderLength,
    IN  HTTP_HEADER_ID          HeaderID,
    OUT PULONG                  pBytesTaken
    );

//
// Utils
//
PCHAR
UlCopyHttpVerb(
    IN OUT PCHAR psz,
    IN PUL_INTERNAL_REQUEST pRequest,
    IN CHAR chTerminator    
    );

ULONG
UlCheckCacheControlHeaders(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUL_URI_CACHE_ENTRY  pUriCacheEntry,
    IN BOOLEAN              ResumeParsingOnSendCompletion
    );

BOOLEAN
UlIsAcceptHeaderOk(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUL_URI_CACHE_ENTRY  pUriCacheEntry
    );

__inline BOOLEAN
UlIsContentEncodingOk(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUL_URI_CACHE_ENTRY  pUriCacheEntry
    )
/*++

Routine Description:

    Checks the cached response against the AcceptEncoding header in the request
    to see if it can satisfy the requested Content-Encoding(s).

    It is assumed that the Content-Type of the cached item is acceptable to the
    client.

Arguments:

    pRequest - The request to check.

    pUriCacheEntry - The cache entry that might possibly match.

Returns:

    TRUE    At least one of the possible media encodings matched the Content-
            Encoding of the cached entry.

    FALSE   None of the requested media encodings matched the Content-Type 
            of the cached entry.

 --*/
{
    BOOLEAN     bRet = FALSE;
    ULONG       Len;
    PUCHAR      pHdr;
    PUCHAR      pTmp;
    PUCHAR      pEncoding;
    ULONG       EncodingLen;

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry));

    if (pRequest->HeaderValid[HttpHeaderAcceptEncoding])
    {
        Len  = pRequest->Headers[HttpHeaderAcceptEncoding].HeaderLength;
        pHdr = pRequest->Headers[HttpHeaderAcceptEncoding].pHeader;
    }
    else
    {
        Len  = 0;
        pHdr = NULL;
    }

    pEncoding   = pUriCacheEntry->pContentEncoding;
    EncodingLen = pUriCacheEntry->ContentEncodingLength ; 

    if (Len && pHdr)
    {
        //
        // If there is a q-value present on the request Accept-Encoding, bail out
        //
        
        if ( strnchr( (const char *) pHdr, ';', Len ) )
        {
            bRet = FALSE;
            goto end;
        }

        //
        // See if the cached item is encoded or in its "identity" form.
        //

        if ( 0 == EncodingLen )
        {
            //
            // Since the only way the "identity" form of a request can be specificly
            // excluded is by use of a q-value, and we know we don't have a q-value
            // at this point, we may serve the cached item.
            //
            
            bRet = TRUE;
            goto end;
        }

        //
        // If non-zero, EncodingLen includes the terminating NULL.  
        // Don't compare the NULL.
        //

        EncodingLen--;
                
        // 
        // Walk the Accept-Encoding list, looking for a match
        //

        while ( Len )
        {
            //
            // Wildcard check
            //
            
            if ( '*' == *pHdr && !IS_HTTP_TOKEN(pHdr[1]))
            {
                // Wildcard Hit!
                bRet = TRUE;
                goto end;
            }

            if (EncodingLen > Len)
            {
                // Bad! No more string left...Bail out.
                bRet = FALSE;
                goto end;
            }

            //
            // Exact token match
            // FUTURE: This should be case-insensitive compare
            //
            
            if ( (0 == _strnicmp(
                            (const char *) pHdr,
                            (const char *) pEncoding,
                            EncodingLen
                            )) &&
                 !IS_HTTP_TOKEN(pHdr[EncodingLen])   )
            {
                // Hit!
                bRet = TRUE;
                goto end;
            }

            //
            // Didn't match this one; advance to next Content-Type in the Accept field
            //

            pTmp = (PUCHAR) strnchr(  (const char *) pHdr, ',', Len);
            if (pTmp)
            {
                // Found a comma; step over it and any whitespace.

                ASSERT ( Len > DIFF(pTmp - pHdr));
                Len -= (DIFF(pTmp - pHdr) +1);
                pHdr = (pTmp+1);

                while( Len && IS_HTTP_LWS(*pHdr) )
                {
                    pHdr++;
                    Len--;
                }

            } 
            else
            {
                bRet = FALSE;
                goto end;
            }
        }
    }
    else
    {
        // 
        // If there wasn't an Accept-Encoding on the request, only serve if the
        // cached item is in its "identity" form.
        //

        if (0 == EncodingLen)
        {
            bRet = TRUE;
        }
    }

    //
    // If we got here, NOT OK!
    //
end:
    UlTrace(PARSER, 
        ("UlIsContentEncodingOk: returning %s\n", 
        bRet ? "TRUE" : "FALSE" 
        ));
    
    return bRet;
}

VOID
UlGetTypeAndSubType(
    IN PCSTR            pStr,
    IN ULONG            StrLen,
    IN PUL_CONTENT_TYPE pContentType
    );

#if DBG

PCSTR
UlVerbToString(
    HTTP_VERB Verb
    );

PCSTR
UlParseStateToString(
    PARSE_STATE ParseState
    );

#endif // DBG

#endif  // _ULPARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ulparse.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    ulparse.c

Abstract:

    Contains the kernel-mode server-side HTTP parsing code.

Author:

    Henry Sanders (henrysa)       27-Apr-1998

Revision History:

    Rajesh Sundaram (rajeshsu)     15-Feb-2002  Moved from parse.c

--*/


#include "precomp.h"
#include "ulparsep.h"
 
#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, UlpFindWSToken )
#pragma alloc_text( PAGE, UlpLookupVerb )
#pragma alloc_text( PAGE, UlpParseFullUrl )
#pragma alloc_text( PAGE, UlLookupHeader )
#pragma alloc_text( PAGE, UlParseHeaderWithHint )
#pragma alloc_text( PAGE, UlParseHeader )
#pragma alloc_text( PAGE, UlParseHeaders )
#pragma alloc_text( PAGE, UlParseHttp )
#pragma alloc_text( PAGE, UlpFormatPort )
#pragma alloc_text( PAGE, UlpCookUrl )
#pragma alloc_text( PAGE, UlGenerateRoutingToken )
#pragma alloc_text( PAGE, UlGenerateFixedHeaders )
#pragma alloc_text( PAGE, UlpGenerateDateHeaderString )
#pragma alloc_text( PAGE, UlGenerateDateHeader )
#pragma alloc_text( INIT, UlInitializeDateCache )
#pragma alloc_text( PAGE, UlTerminateDateCache )
#pragma alloc_text( PAGE, UlComputeFixedHeaderSize )
#pragma alloc_text( PAGE, UlComputeMaxVariableHeaderSize )
#pragma alloc_text( PAGE, UlGenerateVariableHeaders )
#pragma alloc_text( PAGE, UlAppendHeaderValue )
#pragma alloc_text( PAGE, UlSingleHeaderHandler )
#pragma alloc_text( PAGE, UlMultipleHeaderHandler )
#pragma alloc_text( PAGE, UlAcceptHeaderHandler )
#pragma alloc_text( PAGE, UlHostHeaderHandler )
#pragma alloc_text( PAGE, UlCheckCacheControlHeaders )
#pragma alloc_text( PAGE, UlIsAcceptHeaderOk )
#pragma alloc_text( PAGE, UlGetTypeAndSubType )

#if DBG
#pragma alloc_text( PAGE, UlVerbToString )
#pragma alloc_text( PAGE, UlParseStateToString )
#endif

#endif // ALLOC_PRAGMA

#if 0   // Non-Pageable Functions
NOT PAGEABLE -- UlIsContentEncodingOk
#endif // Non-Pageable Functions
//
// Global initialization flag.
//

BOOLEAN g_DateCacheInitialized = FALSE;

//
// Keep track of UrlLength statistics
//

#define URL_LENGTH_STATS 1

#ifdef URL_LENGTH_STATS

struct {
    ULONGLONG   SumUrlLengths;
    ULONG       NumUrls;
    ULONG       NumReallocs;
} g_UrlLengthStats = {0, 0, 0};

#define URL_LENGTH_STATS_UPDATE(UrlLength)                              \
    UlInterlockedAdd64((PLONGLONG) &g_UrlLengthStats.SumUrlLengths, UrlLength);\
    InterlockedIncrement((PLONG) &g_UrlLengthStats.NumUrls)

#define URL_LENGTH_STATS_REALLOC()                                      \
    InterlockedIncrement((PLONG) &g_UrlLengthStats.NumReallocs)

#else // !URL_LENGTH_STATS

#define URL_LENGTH_STATS_UPDATE(UrlLength)      ((void) 0)
#define URL_LENGTH_STATS_REALLOC()              ((void) 0)

#endif // !URL_LENGTH_STATS


// Hack for the special case of an AbsUri without a '/' for the abspath
const UCHAR g_SlashPath[3] = "/ ";



//
// The fast verb translation table. Ordered by frequency.
//

const DECLSPEC_ALIGN(UL_CACHE_LINE) FAST_VERB_ENTRY
FastVerbTable[] =
{
    CREATE_FAST_VERB_ENTRY(GET),
    CREATE_FAST_VERB_ENTRY(HEAD),
    CREATE_FAST_VERB_ENTRY(POST),
    CREATE_FAST_VERB_ENTRY(PUT),
    CREATE_FAST_VERB_ENTRY(DELETE),
    CREATE_FAST_VERB_ENTRY(TRACE),
    CREATE_FAST_VERB_ENTRY(TRACK),
    CREATE_FAST_VERB_ENTRY(OPTIONS),
    CREATE_FAST_VERB_ENTRY(CONNECT),
    CREATE_FAST_VERB_ENTRY(MOVE),
    CREATE_FAST_VERB_ENTRY(COPY),
    CREATE_FAST_VERB_ENTRY(MKCOL),
    CREATE_FAST_VERB_ENTRY(LOCK),
    CREATE_FAST_VERB_ENTRY(UNLOCK),
    CREATE_FAST_VERB_ENTRY(SEARCH)
};


//
// The long verb translation table. All known verbs more than 7 characters
// long belong in this table.
//

const LONG_VERB_ENTRY LongVerbTable[] =
{
    CREATE_LONG_VERB_ENTRY(PROPFIND),
    CREATE_LONG_VERB_ENTRY(PROPPATCH)
};

#define NUMBER_FAST_VERB_ENTRIES    DIMENSION(FastVerbTable)
#define NUMBER_LONG_VERB_ENTRIES    DIMENSION(LongVerbTable)

//
// The enum->verb translation table for error logging.
//
LONG_VERB_ENTRY NewVerbTable[HttpVerbMaximum] =
{
    CREATE_LONG_VERB_ENTRY(Unparsed),      
    CREATE_LONG_VERB_ENTRY(Unknown),      
    CREATE_LONG_VERB_ENTRY(Invalid),  
    CREATE_LONG_VERB_ENTRY(OPTIONS),
    CREATE_LONG_VERB_ENTRY(GET),
    CREATE_LONG_VERB_ENTRY(HEAD),
    CREATE_LONG_VERB_ENTRY(POST),
    CREATE_LONG_VERB_ENTRY(PUT),
    CREATE_LONG_VERB_ENTRY(DELETE),
    CREATE_LONG_VERB_ENTRY(TRACE),
    CREATE_LONG_VERB_ENTRY(CONNECT),
    CREATE_LONG_VERB_ENTRY(TRACK),
    CREATE_LONG_VERB_ENTRY(MOVE),
    CREATE_LONG_VERB_ENTRY(COPY),
    CREATE_LONG_VERB_ENTRY(PROPFIND),
    CREATE_LONG_VERB_ENTRY(PROPPATCH),
    CREATE_LONG_VERB_ENTRY(MKCOL),
    CREATE_LONG_VERB_ENTRY(LOCK),
    CREATE_LONG_VERB_ENTRY(UNLOCK),
    CREATE_LONG_VERB_ENTRY(SEARCH)
};


/*++

Routine Description:

    A utility routine to find a token. We take an input pointer, skip any
    preceding LWS, then scan the token until we find either LWS or a CRLF
    pair.

Arguments:

    pBuffer         - Buffer to search for token.
    BufferLength    - Length of data pointed to by pBuffer.
    ppTokenStart    - Start of token or NULL
    pTokenLength    - Where to return the length of the token.

Return Values:

    STATUS_SUCCESS  - Valid token, described by *ppTokenStart and *pTokenLength
    STATUS_MORE_PROCESSING_REQUIRED - No terminating WS_TOKEN found
                                        => retry later with more data
    STATUS_INVALID_DEVICE_REQUEST   - Invalid token characters.

--*/
NTSTATUS
UlpFindWSToken(
    IN  PUCHAR  pBuffer,
    IN  ULONG   BufferLength,
    OUT PUCHAR* ppTokenStart,
    OUT PULONG  pTokenLength
    )
{
    PUCHAR  pTokenStart;
#if DBG
    ULONG   OriginalBufferLength = BufferLength;
#endif

    PAGED_CODE();

    ASSERT(NULL != pBuffer);
    ASSERT(NULL != ppTokenStart);
    ASSERT(NULL != pTokenLength);

    *ppTokenStart = NULL;

    //
    // First, skip any preceding LWS (SP | HT).
    //

    while (BufferLength > 0  &&  IS_HTTP_LWS(*pBuffer))
    {
        pBuffer++;
        BufferLength--;
    }

    // If we stopped because we ran out of buffer, fail soft.
    if (BufferLength == 0)
    {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    pTokenStart = pBuffer;

    // Now skip over the token, until we see (SP | HT | CR | LF)

    do
    {
        // token = 1*<any CHAR except CTLs or separators>
        // If a non-token, non-whitespace character is found, fail hard.
        if (!IS_HTTP_TOKEN(*pBuffer))
        {
            UlTraceError(PARSER, (
                        "http!UlpFindWSToken(): non-token char %02x\n",
                        *pBuffer
                        ));
            return STATUS_INVALID_DEVICE_REQUEST;
        }

        pBuffer++;
        BufferLength--;
    } while ( ( BufferLength != 0 ) && ( !IS_HTTP_WS_TOKEN(*pBuffer) ));

    // See why we stopped.
    if (BufferLength == 0)
    {
        // Ran out of buffer before end of token. Fail soft.
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    // Success. Set the token length and return the start of the token.
    *ppTokenStart = pTokenStart;
    *pTokenLength = DIFF(pBuffer - pTokenStart);

    ASSERT(0 < *pTokenLength  &&  *pTokenLength < OriginalBufferLength);

    return STATUS_SUCCESS;

}   // UlpFindWSToken



/*++

Routine Description:

    The slower way to look up a verb. We find the verb in the request and then
    look for it in the LongVerbTable. If it's not found, we'll return
    UnknownVerb. If it can't be parsed we return UnparsedVerb. Otherwise
    we return the verb type.

Arguments:

    pRequest            - HTTP request.
    pHttpRequest        - Pointer to the incoming HTTP request data.
    HttpRequestLength   - Length of data pointed to by pHttpRequest.
    pBytesTaken         - The total length consumed, including the length of
                            the verb plus preceding & 1 trailing whitespace.

Return Value:

    STATUS_SUCCESS or STATUS_INVALID_DEVICE_REQUEST

--*/
NTSTATUS
UlpLookupVerb(
    IN OUT PUL_INTERNAL_REQUEST    pRequest,
    IN     PUCHAR                  pHttpRequest,
    IN     ULONG                   HttpRequestLength,
    OUT    PULONG                  pBytesTaken
    )
{
    NTSTATUS    Status;
    ULONG       TokenLength;
    PUCHAR      pToken;
    PUCHAR      pTempRequest;
    ULONG       TempLength;
    ULONG       i;

    //
    // Sanity check.
    //

    PAGED_CODE();

    // Since we may have gotten here due to a extraneous CRLF pair, skip
    // any of those now. Need to use a temporary variable since
    // the original input pointer and length are used below.

    pTempRequest = pHttpRequest;
    TempLength = HttpRequestLength;

    while ( TempLength != 0 &&
            ((*pTempRequest == CR) || (*pTempRequest == LF)) )
    {
        pTempRequest++;
        TempLength--;
    }

    // First find the verb.

    Status = UlpFindWSToken(pTempRequest, TempLength, &pToken, &TokenLength);

    if (!NT_SUCCESS(Status))
    {
        if (STATUS_MORE_PROCESSING_REQUIRED == Status)
        {
            // Didn't find it, let's get more buffer
            pRequest->Verb = HttpVerbUnparsed;

            *pBytesTaken = 0;

            return STATUS_SUCCESS;
        }

        ASSERT(STATUS_INVALID_DEVICE_REQUEST == Status);

        pRequest->Verb = HttpVerbInvalid;

        UlTraceError(PARSER, (
                    "http!UlpLookupVerb(pRequest = %p): "
                    "invalid token in verb\n",
                    pRequest
                    ));

        UlSetErrorCode(pRequest, UlErrorVerb, NULL);

        return Status;
    }

    ASSERT(STATUS_SUCCESS == Status);
    ASSERT(NULL != pToken);
    ASSERT(0 < TokenLength  &&  TokenLength < TempLength);
    ASSERT(IS_HTTP_WS_TOKEN(pToken[TokenLength]));

    // Is the verb terminated by CR or LF (instead of SP or HT),
    // or is it ridiculously long? Reject, if so.
    if (!IS_HTTP_LWS(pToken[TokenLength])  ||  TokenLength > MAX_VERB_LENGTH)
    {
        pRequest->Verb = HttpVerbInvalid;

        if (!IS_HTTP_LWS(pToken[TokenLength]))
        {
            UlTraceError(PARSER, (
                        "http!UlpLookupVerb(pRequest = %p) "
                        "ERROR: no LWS after verb, %02x\n",
                        pRequest, pToken[TokenLength]
                        ));
        }
        else
        {
            UlTraceError(PARSER, (
                        "http!UlpLookupVerb(pRequest = %p) "
                        "ERROR: Verb too long\n",
                        pRequest, TokenLength
                        ));
        }

        UlSetErrorCode(pRequest, UlErrorVerb, NULL);

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    // Otherwise, we found one, so update bytes taken and look up up in
    // the tables.

    *pBytesTaken = DIFF(pToken - pHttpRequest) + TokenLength + 1;

    //
    // If we ate some leading whitespace, or if the HttpRequestLength is less
    // than sizeof(ULONGLONG), we must look through the "fast" verb table
    // again, but do it the "slow" way. Note: verbs are case-sensitive.
    //
    for (i = 0; i < NUMBER_FAST_VERB_ENTRIES; i++)
    {
        ASSERT(FastVerbTable[i].RawVerbLength - STRLEN_LIT(" ")
                    < sizeof(ULONGLONG));

        if ((FastVerbTable[i].RawVerbLength == (TokenLength + STRLEN_LIT(" ")))
             && RtlEqualMemory(pToken, FastVerbTable[i].RawVerb.Char,
                               TokenLength))
        {
            // It matched. Save the translated verb from the
            // table, and bail out.
            //
            pRequest->Verb = FastVerbTable[i].TranslatedVerb;
            return STATUS_SUCCESS;
        }
    }

    //
    // Now look through the "long" verb table
    //
    for (i = 0; i < NUMBER_LONG_VERB_ENTRIES; i++)
    {
        ASSERT(LongVerbTable[i].RawVerbLength >= sizeof(ULONGLONG));

        if (LongVerbTable[i].RawVerbLength == TokenLength &&
            RtlEqualMemory(pToken, LongVerbTable[i].RawVerb, TokenLength))
        {
            // Found it.
            //
            pRequest->Verb = LongVerbTable[i].TranslatedVerb;
            return STATUS_SUCCESS;
        }
    }

    //
    // If we got here, we searched both tables and didn't find it.
    // It's a raw (unknown) verb
    //

    pRequest->Verb              = HttpVerbUnknown;
    pRequest->pRawVerb          = pToken;
    pRequest->RawVerbLength     = (UCHAR) TokenLength;

    ASSERT(pRequest->RawVerbLength == TokenLength);

    UlTrace(PARSER, (
                "http!UlpLookupVerb(pRequest = %p) "
                "Unknown verb (%lu) '%.*s'\n",
                pRequest, TokenLength, TokenLength, pToken
                ));
    //
    // include room for the terminator
    //

    pRequest->TotalRequestSize += (TokenLength + 1) * sizeof(CHAR);

    ASSERT( !(pRequest->RawVerbLength==3
                && RtlEqualMemory(pRequest->pRawVerb,"GET",3)));

    return STATUS_SUCCESS;

}   // UlpLookupVerb


/*++

Routine Description:

    A utility routine to parse an absolute URL in a URL string. When this
    is called, we already have loaded the entire url into RawUrl.pUrl and
    know that it starts with "http".

    This function's job is to set RawUrl.pHost and RawUrl.pAbsPath.

Arguments:

    pRequest        - Pointer to the HTTP_REQUEST

Return Value:

    NTSTATUS

Author:

    Henry Sanders ()                        1998
    Paul McDaniel (paulmcd)                 6-Mar-1999

--*/
NTSTATUS
UlpParseFullUrl(
    IN  PUL_INTERNAL_REQUEST    pRequest
    )
{
    PUCHAR  pURL;
    ULONG   UrlLength;
    PUCHAR  pUrlStart;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pURL = pRequest->RawUrl.pUrl;
    UrlLength = pRequest->RawUrl.Length;

    ASSERT(NULL != pURL);
    ASSERT(0 < UrlLength);

    // First four characters must be "http" (case-insensitive),
    // as guaranteed by the caller.
    ASSERT(UrlLength >= HTTP_PREFIX_SIZE &&
            (*(UNALIGNED64 ULONG *) pURL & HTTP_PREFIX_MASK) == HTTP_PREFIX);

    //
    // When we're called, we know that the start of the URL must point at
    // an absolute scheme prefix. Adjust for that now.
    //

    pUrlStart = pURL + HTTP_PREFIX_SIZE;
    UrlLength -= HTTP_PREFIX_SIZE;

    //
    // Now check the second half of the absolute URL prefix. We use the larger
    // of the two possible prefix lengths here to do the check, because even if
    // it's the smaller of the two, we'll need the extra bytes after the prefix
    // anyway for the host name.
    //

    if (UrlLength < HTTP_PREFIX2_SIZE)
    {
        C_ASSERT(HTTP_PREFIX2_SIZE >= HTTP_PREFIX1_SIZE);

        UlTraceError(PARSER, (
                    "http!UlpParseFullUrl(pRequest = %p) "
                    "ERROR: no room for URL scheme name\n",
                    pRequest
                    ));

        UlSetErrorCode(pRequest, UlErrorUrl, NULL);

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    // Are the next three characters == "://", i.e, starts with "http://" ?
    if ( (*(UNALIGNED64 ULONG *)pUrlStart & HTTP_PREFIX1_MASK) == HTTP_PREFIX1)
    {
        // Valid absolute URL.
        pUrlStart += HTTP_PREFIX1_SIZE;
        UrlLength -= HTTP_PREFIX1_SIZE;

        ASSERT(0 == _strnicmp((const char*) pRequest->RawUrl.pUrl,
                              "http://",
                              STRLEN_LIT("http://")));

        if (pRequest->Secure)
        {
           UlTraceError(PARSER, (
                        "http!UlpParseFullUrl(pRequest = %p) "
                        "ERROR: URL scheme name does not match endpoint "
                        "security: \"http://\" seen on secure endpoint\n",
                        pRequest
                        ));

            UlSetErrorCode(pRequest, UlErrorUrl, NULL);

            return STATUS_INVALID_DEVICE_REQUEST;
        }
    }

    // Or are the next four characters == "s://", i.e, starts with "https://" ?
    else if ( (*(UNALIGNED64 ULONG *)pUrlStart & HTTP_PREFIX2_MASK)
             == HTTP_PREFIX2)
    {
        // Valid absolute URL.
        pUrlStart += HTTP_PREFIX2_SIZE;
        UrlLength -= HTTP_PREFIX2_SIZE;

        ASSERT(0 == _strnicmp((const char*) pRequest->RawUrl.pUrl,
                              "https://",
                              STRLEN_LIT("https://")));

        if (!pRequest->Secure)
        {
           UlTraceError(PARSER, (
                        "http!UlpParseFullUrl(pRequest = %p) "
                        "ERROR: URL scheme name does not match endpoint "
                        "security: \"https://\" seen on insecure endpoint\n",
                        pRequest
                        ));

            UlSetErrorCode(pRequest, UlErrorUrl, NULL);

            return STATUS_INVALID_DEVICE_REQUEST;
        }
    }
    else
    {
        UlTraceError(PARSER, (
                    "http!UlpParseFullUrl(pRequest = %p) "
                    "ERROR: invalid URL scheme name\n",
                    pRequest
                    ));

        UlSetErrorCode(pRequest, UlErrorUrl, NULL);

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // OK, we've got a valid absolute URL, and we've skipped over
    // the prefix part of it. Save a pointer to the host, and
    // search the host string until we find the trailing slash,
    // which signifies the end of the host/start of the absolute
    // path.
    //

    pRequest->RawUrl.pHost = pUrlStart;

    //
    // scan the host looking for the terminator
    //

    while (UrlLength > 0 && pUrlStart[0] != '/')
    {
        pUrlStart++;
        UrlLength--;
    }

    if (UrlLength == 0)
    {
        // Special case: we've received something like
        //      GET http://www.example.com HTTP/1.1
        // (perhaps as a result of a redirect to "http://www.example.com",
        // see bug #527947). We will create a special path of "/".
        // 
        
        pUrlStart = (PUCHAR) &g_SlashPath[0];
    }

    //
    // pUrlStart points to the start of the absolute path portion.
    //

    pRequest->RawUrl.pAbsPath = pUrlStart;

    return STATUS_SUCCESS;

}   // UlpParseFullUrl

/*++

Routine Description:

    Look up a header that we don't have in our fast lookup table. This
    could be because it's a header we don't understand, or because we
    couldn't use the fast lookup table due to insufficient buffer length.
    The latter reason is uncommon, but we'll check the input table anyway
    if we're given one. If we find a header match in our mapping table,
    we'll call the header handler. Otherwise we'll try to allocate an
    unknown header element, fill it in, and chain it on the http connection.

Arguments:

    pRequest            - Pointer to the current request
    pHttpRequest        - Pointer to the current raw request data.
    HttpRequestLength   - Bytes left in the request data.
    pHeaderMap          - Pointer to start of an array of header map entries
                            (may be NULL).
    HeaderMapCount      - Number of entries in array pointed to by pHeaderMap.
    bIgnore             - We don't want to write to the buffer. 
                          (used for parsing trailers)
    pBytesTaken         - Bytes consumed by this routine from pHttpRequest,
                          including CRLF.

Return Value:

    STATUS_SUCCESS or an error.

--*/
NTSTATUS
UlLookupHeader(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHttpRequest,
    IN  ULONG                   HttpRequestLength,
    IN  PHEADER_MAP_ENTRY       pHeaderMap,
    IN  ULONG                   HeaderMapCount,
    IN  BOOLEAN                 bIgnore,
    OUT ULONG  *                pBytesTaken
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    ULONG                   CurrentOffset;
    USHORT                  HeaderNameLength;
    USHORT                  HeaderNameAndTrailingWSLength;
    ULONG                   i;
    ULONG                   BytesTaken;
    USHORT                  HeaderValueLength;
    USHORT                  TrailingWhiteSpaceCount;
    UCHAR                   CurrentChar;
    PUL_HTTP_UNKNOWN_HEADER pUnknownHeader;
    PLIST_ENTRY             pListStart;
    PLIST_ENTRY             pCurrentListEntry;
    ULONG                   OldHeaderLength;
    PUCHAR                  pHeaderValue;
    BOOLEAN                 ExternalAllocated;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // First, let's find the terminating : of the header name, if there is one.
    // This will also give us the length of the header, which we can then
    // use to search the header map table if we have one.
    //

    TrailingWhiteSpaceCount = 0;
    for (CurrentOffset = 0; CurrentOffset < HttpRequestLength; CurrentOffset++)
    {
        CurrentChar = *(pHttpRequest + CurrentOffset);

        if (CurrentChar == ':')
        {
            // We've found the end of the header.
            break;
        }
        else
        {
            if (CurrentOffset <= ANSI_STRING_MAX_CHAR_LEN)
            {
                if (IS_HTTP_TOKEN(CurrentChar))
                {
                    if (TrailingWhiteSpaceCount == 0)
                    {
                        // We haven't come across any LWS yet.
                        continue;
                    }

                    // else:
                    // We are in the midst of skipping trailing LWS,
                    // and don't expect anything but ':' or more LWS.
                    // Fall through to error handler.
                    //
                }
                else
                {
                    //
                    // Allow for trailing white-space chars
                    //
                    if (IS_HTTP_LWS(CurrentChar))
                    {
                        TrailingWhiteSpaceCount++;
                        continue;
                    }

                    // else:
                    // Invalid header; fall through to error handler
                    //
                }
            }

            // Uh-oh, this isn't a valid header. What do we do now?

            UlTraceError(PARSER, (
                        "UlLookupHeader(pRequest = %p) "
                        "CurrentChar = 0x%02x '%c' Offset=%lu\n"
                        "    ERROR: invalid header char\n",
                        pRequest,
                        CurrentChar,
                        isprint(CurrentChar) ? CurrentChar : '.',
                        CurrentOffset
                        ));

            UlSetErrorCode(pRequest, UlErrorHeader, NULL);

            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto end;
        }

    }


    // Find out why we got out. If the current offset is less than the
    // header length, we got out because we found the :.

    if (CurrentOffset < HttpRequestLength)
    {
        // Found the terminator.
        ASSERT( ':' == *(pHttpRequest + CurrentOffset) );

        CurrentOffset++;            // Update to point beyond terminator.
        HeaderNameAndTrailingWSLength = (USHORT) CurrentOffset;
        HeaderNameLength = HeaderNameAndTrailingWSLength - TrailingWhiteSpaceCount;
    }
    else
    {
        // Didn't find the :, need more.
        //
        *pBytesTaken = 0;
        goto end;
    }

    // See if we have a header map array we need to search.
    //
    if (pHeaderMap != NULL)
    {
        // We do have an array to search.
        for (i = 0; i < HeaderMapCount; i++)
        {
            ASSERT(pHeaderMap->pServerHandler != NULL);

            if (HeaderNameLength == pHeaderMap->HeaderLength &&

                //
                // Ignore the last character when doing the strnicmp - the
                // last character in pHeaderMap->Header.HeaderChar is a ':'
                // and the last character in pHttpRequest is either a space
                // or a ':'.
                //
                // We want to treat header-name<b>: as header-name:, so it's 
                // OK to ignore the last character. 
                //
                // Also note that we do this ONLY if the length's match.
                //

                _strnicmp(
                    (const char *)(pHttpRequest),
                    (const char *)(pHeaderMap->Header.HeaderChar),
                    (HeaderNameLength-1)
                    ) == 0  &&

                pHeaderMap->pServerHandler != NULL)
            {
                ASSERT(
                    (*(pHttpRequest + HeaderNameLength - 1) == ':')
                         ||
                    (*(pHttpRequest + HeaderNameLength - 1) == ' ')
                    );

                if (HttpRequestLength - HeaderNameLength
                        > ANSI_STRING_MAX_CHAR_LEN)
                {
                    UlTraceError(PARSER, (
                                "UlLookupHeader(pRequest = %p) "
                                "Header too long: %lu\n",
                                pRequest,
                                HttpRequestLength - HeaderNameLength
                                ));

                    UlSetErrorCode(pRequest, UlErrorHeader, NULL);
                    Status = STATUS_INVALID_DEVICE_REQUEST;

                    goto end;
                }

                // This header matches. Call the handling function for it.
                Status = (*(pHeaderMap->pServerHandler))(
                                pRequest,
                                pHttpRequest + HeaderNameAndTrailingWSLength,
                                (USHORT) (HttpRequestLength - HeaderNameAndTrailingWSLength),
                                pHeaderMap->HeaderID,
                                &BytesTaken
                                );

                if (NT_SUCCESS(Status) == FALSE)
                    goto end;

                // If the handler consumed a non-zero number of bytes, it
                // worked, so return that number plus whatever is consumed
                // already.

                //
                // BUGBUG - it might be possible for a header handler to
                // encounter an error, for example being unable to
                // allocate memory, or a bad syntax in some header. We
                // need a more sophisticated method to detect this than
                // just checking bytes taken.
                //

                if (BytesTaken != 0)
                {
                    *pBytesTaken = HeaderNameAndTrailingWSLength + BytesTaken;
                    goto end;
                }

                // Otherwise he didn't take anything, so return 0.
                // we need more buffer
                //
                *pBytesTaken = 0;
                goto end;
            }

            pHeaderMap++;
        }
    }

    // The value's length must fit in a USHORT
    if (HttpRequestLength - HeaderNameLength > ANSI_STRING_MAX_CHAR_LEN)
    {
        UlTraceError(PARSER, (
                    "UlLookupHeader(pRequest = %p) "
                    "Header too long: %lu\n",
                    pRequest,
                    HttpRequestLength - HeaderNameLength
                    ));

        UlSetErrorCode(pRequest, UlErrorHeader, NULL);
        Status = STATUS_INVALID_DEVICE_REQUEST;

        goto end;
    }


    // OK, at this point either we had no header map array or none of them
    // matched. We have an unknown header. Just make sure this header is
    // terminated and save a pointer to it.
    //
    // Find the end of the header value
    //
    Status = FindRequestHeaderEnd(
                    pRequest,
                    pHttpRequest + HeaderNameAndTrailingWSLength,
                    (USHORT) (HttpRequestLength - HeaderNameAndTrailingWSLength),
                    &BytesTaken
                    );

    if (!NT_SUCCESS(Status))
        goto end;

    if (BytesTaken == 0)
    {
        *pBytesTaken = 0;
        goto end;
    }

    ASSERT(BytesTaken - CRLF_SIZE <= ANSI_STRING_MAX_CHAR_LEN);

    //
    // Strip off the trailing CRLF from the header value length
    //

    HeaderValueLength = (USHORT) (BytesTaken - CRLF_SIZE);

    pHeaderValue = pHttpRequest + HeaderNameAndTrailingWSLength;

    //
    // skip any preceding LWS.
    //

    while ( HeaderValueLength > 0 && IS_HTTP_LWS(*pHeaderValue) )
    {
        pHeaderValue++;
        HeaderValueLength--;
    }

    if(!bIgnore)
    {
        //
        // Have an unknown header. Search our list of unknown headers,
        // and if we've already seen one instance of this header add this
        // on. Otherwise allocate an unknown header structure and set it
        // to point at this header.
        //
        // RFC 2616, Section 4.2 "Message Headers" says:
        // "Multiple message-header fields with the same field-name MAY be 
        // present in a message if and only if the entire field-value for 
        // that header field is defined as a comma-separated list 
        // [i.e., #(values)]. It MUST be possible to combine the multiple 
        // header fields into one "field-name: field-value" pair, without 
        // changing the semantics of the message, by appending each subsequent 
        // field-value to the first, each separated by a comma."
        //
        // Therefore we search the list of unknown headers and add the new
        // field-value to the end of the existing comma delimited list of
        // field-values
        //
    
        pListStart = &pRequest->UnknownHeaderList;
    
        for (pCurrentListEntry = pRequest->UnknownHeaderList.Flink;
             pCurrentListEntry != pListStart;
             pCurrentListEntry = pCurrentListEntry->Flink
            )
        {
            pUnknownHeader = CONTAINING_RECORD(
                                pCurrentListEntry,
                                UL_HTTP_UNKNOWN_HEADER,
                                List
                                );
    
            //
            // somehow HeaderNameLength includes the ':' character,
            // which is not the case of pUnknownHeader->HeaderNameLength.
            //
            // so we need to adjust for this here
            //
    
            if ((HeaderNameLength-1) == pUnknownHeader->HeaderNameLength &&
                _strnicmp(
                    (const char *)(pHttpRequest),
                    (const char *)(pUnknownHeader->pHeaderName),
                    (HeaderNameLength-1)
                    ) == 0)
            {
                // This header matches.
    
                OldHeaderLength = pUnknownHeader->HeaderValue.HeaderLength;
    
                Status = UlAppendHeaderValue(
                                pRequest,
                                &pUnknownHeader->HeaderValue,
                                pHeaderValue,
                                HeaderValueLength
                                );
    
                if (NT_SUCCESS(Status) == FALSE)
                    goto end;
    
                //
                // Successfully appended it. Update the total request
                // length for the length added.  no need to add 1 for
                // the terminator, just add our new char count.
                //
    
                pRequest->TotalRequestSize +=
                    (pUnknownHeader->HeaderValue.HeaderLength
                        - OldHeaderLength) * sizeof(CHAR);
    
                //
                // don't subtract for the ':' character, as that character
                // was "taken"
                //
    
                *pBytesTaken = HeaderNameAndTrailingWSLength + BytesTaken;
                goto end;
    
            }   // if (headermatch)
    
        }   // for (walk list)
    
        //
        // Didn't find a match. Allocate a new unknown header structure, set
        // it up and add it to the list.
        //
    
         if (pRequest->NextUnknownHeaderIndex < DEFAULT_MAX_UNKNOWN_HEADERS)
        {
            ExternalAllocated = FALSE;
            pUnknownHeader = &pRequest->UnknownHeaders[pRequest->NextUnknownHeaderIndex];
            pRequest->NextUnknownHeaderIndex++;
        }
        else
        {
            ExternalAllocated = TRUE;
            pUnknownHeader = UL_ALLOCATE_STRUCT(
                                    NonPagedPool,
                                    UL_HTTP_UNKNOWN_HEADER,
                                    UL_HTTP_UNKNOWN_HEADER_POOL_TAG
                                    );
    
            //
            // Assume the memory allocation will succeed so just blindly set the
            // flag below to TRUE which forces us to take a slow path in
            // UlpFreeHttpRequest.
            //
    
            pRequest->HeadersAppended = TRUE;
        }
    
        if (pUnknownHeader == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto end;
        }
    
        //
        // subtract the : from the header name length
        //
    
        pUnknownHeader->HeaderNameLength = HeaderNameLength - 1;
        pUnknownHeader->pHeaderName = pHttpRequest;
    
        //
        // header value
        //
    
        pUnknownHeader->HeaderValue.HeaderLength = HeaderValueLength;
        pUnknownHeader->HeaderValue.pHeader = pHeaderValue;
    
        //
        // null terminate our copy, the terminating CRLF gives
        // us space for this
        //
    
        pHeaderValue[HeaderValueLength] = ANSI_NULL;
    
        //
        // flags
        //
    
        pUnknownHeader->HeaderValue.OurBuffer = 0;
        pUnknownHeader->HeaderValue.ExternalAllocated = ExternalAllocated;
    
        InsertTailList(&pRequest->UnknownHeaderList, &pUnknownHeader->List);
    
        pRequest->UnknownHeaderCount++;

        if(pRequest->UnknownHeaderCount == 0)
        {
            // Overflow!
            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto end;
        }
    
        //
        // subtract 1 for the ':' and add space for the 2 terminators
        //
    
        pRequest->TotalRequestSize +=
            ((HeaderNameLength - 1 + 1) + HeaderValueLength + 1) * sizeof(CHAR);
    }

    *pBytesTaken = HeaderNameAndTrailingWSLength + BytesTaken;

end:
    return Status;

}   // UlLookupHeader



/*++

Routine Description:

    The routine to parse an individual header based on a hint. We take in
    a pointer to the header and the bytes remaining in the request,
    and try to find the header based on the hint passed.

    On input, HttpRequestLength is at least CRLF_SIZE.

Arguments:

    pRequest            - Pointer to the current connection on which the
                            request arrived.
    pHttpRequest        - Pointer to the current request.
    HttpRequestLength   - Bytes left in the request.
    pHeaderHintMap      - Hint to the Map that may match the current request
    pBytesTaken         - Bytes consumed by this routine from pHttpRequest,
                          including CRLF.

Return Value:

    STATUS_SUCCESS or an error.

--*/

__inline
NTSTATUS
UlParseHeaderWithHint(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHttpRequest,
    IN  ULONG                   HttpRequestLength,
    IN  PHEADER_MAP_ENTRY       pHeaderHintMap,
    OUT ULONG  *                pBytesTaken
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    ULONG               BytesTaken;
    ULONGLONG           Temp;
    ULONG               j;

    PAGED_CODE();

    ASSERT(pHeaderHintMap != NULL);

    if (HttpRequestLength >= pHeaderHintMap->MinBytesNeeded)
    {
        for (j = 0; j < pHeaderHintMap->ArrayCount; j++)
        {
            Temp = *(UNALIGNED64 ULONGLONG *)(pHttpRequest +
                                    (j * sizeof(ULONGLONG)));

            if ((Temp & pHeaderHintMap->HeaderMask[j]) !=
                pHeaderHintMap->Header.HeaderLong[j] )
            {
                break;
            }
        }

        // See why we exited out.
        if (j == pHeaderHintMap->ArrayCount &&
            pHeaderHintMap->pServerHandler != NULL)
        {
            if (HttpRequestLength - pHeaderHintMap->HeaderLength
                    > ANSI_STRING_MAX_CHAR_LEN)
            {
                UlTraceError(PARSER, (
                            "UlParseHeaderWithHint(pRequest = %p) "
                            "Header too long: %lu\n",
                            pRequest,
                            HttpRequestLength - pHeaderHintMap->HeaderLength
                            ));

                UlSetErrorCode(pRequest, UlErrorHeader, NULL);
                Status = STATUS_INVALID_DEVICE_REQUEST;

                goto end;
            }

            // Exited because we found a match. Call the
            // handler for this header to take cake of this.

            Status = (*(pHeaderHintMap->pServerHandler))(
                    pRequest,
                    pHttpRequest + pHeaderHintMap->HeaderLength,
                    (USHORT) (HttpRequestLength - pHeaderHintMap->HeaderLength),
                    pHeaderHintMap->HeaderID,
                    &BytesTaken
                    );

            if (NT_SUCCESS(Status) == FALSE)
                goto end;

            // If the handler consumed a non-zero number of
            // bytes, it worked, so return that number plus
            // the header length.


            if (BytesTaken != 0)
            {
                *pBytesTaken = pHeaderHintMap->HeaderLength + BytesTaken;
                goto end;
            }

            // Otherwise need more buffer

            *pBytesTaken = 0;
        }
        else
        {
            // No match

            *pBytesTaken = (ULONG) -1;
        }
    }
    else
    {
        // No match

        *pBytesTaken = (ULONG) -1;
    }

end:

    return Status;

} // UlParseHeaderWithHint



/*++

Routine Description:

    The routine to parse an individual header. We take in a pointer to the
    header and the bytes remaining in the request, and try to find
    the header in our lookup table. We try first the fast way, and then
    try again the slow way in case there wasn't quite enough data the first
    time.

    On input, HttpRequestLength is at least CRLF_SIZE.

Arguments:

    pRequest            - Pointer to the current connection on which the
                            request arrived.
    pHttpRequest        - Pointer to the current request.
    HttpRequestLength   - Bytes left in the request.
    pBytesTaken         - Bytes consumed by this routine from pHttpRequest,
                          including CRLF.

Return Value:

    STATUS_SUCCESS or an error.

--*/

NTSTATUS
UlParseHeader(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHttpRequest,
    IN  ULONG                   HttpRequestLength,
    OUT ULONG  *                pBytesTaken
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    ULONG               i;
    ULONG               j;
    ULONG               BytesTaken;
    ULONGLONG           Temp;
    UCHAR               c;
    PHEADER_MAP_ENTRY   pCurrentHeaderMap;
    ULONG               HeaderMapCount;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(HttpRequestLength >= CRLF_SIZE);

    c = *pHttpRequest;

    // message-headers start with field-name [= token]
    //
    if (IS_HTTP_TOKEN(c) == FALSE)
    {
        UlTraceError(PARSER, (
                    "UlParseHeader (pRequest = %p) c = 0x%02x '%c'"
                    "ERROR: invalid header char \n",
                    pRequest,
                    c, isprint(c) ? c : '.'
                    ));

        UlSetErrorCode(pRequest, UlErrorHeader, NULL);

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    // Does the header start with an alpha?
    //
    if (!IS_HTTP_ALPHA(c))
    {
        pCurrentHeaderMap = NULL;
        HeaderMapCount = 0;
    }
    else
    {
        // Uppercase the character, and find the appropriate set of header map
        // entries.
        //
        c = UPCASE_CHAR(c);
        ASSERT('A' <= c  &&  c <= 'Z');
        c -= 'A';

        pCurrentHeaderMap = g_RequestHeaderIndexTable[c].pHeaderMap;
        HeaderMapCount    = g_RequestHeaderIndexTable[c].Count;

        // Loop through all the header map entries that might match
        // this header, and check them. The count will be 0 if there
        // are no entries that might match and we'll skip the loop.

        for (i = 0; i < HeaderMapCount; i++)
        {
            ASSERT(pCurrentHeaderMap->pServerHandler != NULL);

            // If we have enough bytes to do the fast check, do it.
            // Otherwise skip this. We may skip a valid match, but if
            // so we'll catch it later.

            if (HttpRequestLength >= pCurrentHeaderMap->MinBytesNeeded)
            {
                for (j = 0; j < pCurrentHeaderMap->ArrayCount; j++)
                {
                    Temp = *(UNALIGNED64 ULONGLONG *)(pHttpRequest +
                                            (j * sizeof(ULONGLONG)));

                    if ((Temp & pCurrentHeaderMap->HeaderMask[j]) !=
                        pCurrentHeaderMap->Header.HeaderLong[j] )
                    {
                        break;
                    }
                }

                // See why we exited out.
                if (j == pCurrentHeaderMap->ArrayCount &&
                    pCurrentHeaderMap->pServerHandler != NULL)
                {
                    if (HttpRequestLength - pCurrentHeaderMap->HeaderLength
                            > ANSI_STRING_MAX_CHAR_LEN)
                    {
                        UlTraceError(PARSER, (
                                    "UlParseHeader(pRequest = %p) "
                                    "Header too long: %lu\n",
                                    pRequest,
                                    HttpRequestLength
                                        - pCurrentHeaderMap->HeaderLength
                                    ));

                        UlSetErrorCode(pRequest, UlErrorHeader, NULL);
                        Status = STATUS_INVALID_DEVICE_REQUEST;

                        goto end;
                    }

                    // Exited because we found a match. Call the
                    // handler for this header to take cake of this.

                    Status = (*(pCurrentHeaderMap->pServerHandler))(
                            pRequest,
                            pHttpRequest + pCurrentHeaderMap->HeaderLength,
                            (USHORT) (HttpRequestLength
                                      - pCurrentHeaderMap->HeaderLength),
                            pCurrentHeaderMap->HeaderID,
                            &BytesTaken
                            );

                    if (NT_SUCCESS(Status) == FALSE)
                        goto end;

                    // If the handler consumed a non-zero number of
                    // bytes, it worked, so return that number plus
                    // the header length.

                    if (BytesTaken != 0)
                    {
                        *pBytesTaken = pCurrentHeaderMap->HeaderLength +
                            BytesTaken;
                        goto end;
                    }

                    // Otherwise need more buffer
                    //
                    *pBytesTaken = 0;
                    goto end;
                }

                // If we get here, we exited out early because a match
                // failed, so keep going.
            }

            // Either didn't match or didn't have enough bytes for the
            // check. In either case, check the next header map entry.

            pCurrentHeaderMap++;
        }

        // Got all the way through the appropriate header map entries
        // without a match. This could be because we're dealing with a
        // header we don't know about or because it's a header we
        // care about that was too small to do the fast check. The
        // latter case should be very rare, but we still need to
        // handle it.

        // Update the current header map pointer to point back to the
        // first of the possibles. 

        pCurrentHeaderMap = g_RequestHeaderIndexTable[c].pHeaderMap;

    }

    // At this point either the header starts with a non-alphabetic
    // character or we don't have a set of header map entries for it.

    Status = UlLookupHeader(
                    pRequest,
                    pHttpRequest,
                    HttpRequestLength,
                    pCurrentHeaderMap,
                    HeaderMapCount,
                    FALSE,
                    &BytesTaken
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    // Lookup header returns the total bytes taken, including the header name
    //
    *pBytesTaken = BytesTaken;

end:

    return Status;

}   // UlParseHeader


/*++

Routine Description:

    Parse all the remaining header data, breaking it into one or more
    headers. Terminates when an empty line is seen (end of headers),
    when buffer is exhausted (=> more data needed and UlParseHeaders()
    will be called again), or upon error.

Arguments:

    pRequest            - Pointer to the current request.
    pBuffer             - where to start parsing
    BufferLength        - Length of pBuffer, in bytes
    pBytesTaken         - how much of pBuffer was consumed

Return Value:

    STATUS_SUCCESS      - Found the terminating CRLF that ends the headers
    STATUS_MORE_PROCESSING_REQUIRED - haven't found the terminating CRLF,
                                        so need more header data
    various errors

--*/

NTSTATUS
UlParseHeaders(
    IN OUT PUL_INTERNAL_REQUEST pRequest,
    IN     PUCHAR pBuffer,
    IN     ULONG BufferLength,
    OUT    PULONG pBytesTaken
    )
{
    NTSTATUS            Status;
    ULONG               BytesTaken      = 0;
    LONG                NextHintIndex   = 0;
    LONG                HintIndex       = 0;
    PHEADER_MAP_ENTRY   pHeaderHintMap;
    UCHAR               UpcaseChar;

    PAGED_CODE();

    *pBytesTaken = 0;

    //
    // loop over all headers
    //

    while (BufferLength >= CRLF_SIZE)
    {
        //
        // If this is an empty header, we're done with this stage
        //

        if (*(UNALIGNED64 USHORT *)pBuffer == CRLF ||
            *(UNALIGNED64 USHORT *)pBuffer == LFLF)
        {

            //
            // consume it
            //

            pBuffer += CRLF_SIZE;
            *pBytesTaken += CRLF_SIZE;
            BufferLength -= CRLF_SIZE;

            Status = STATUS_SUCCESS;
            goto end;
        }

        // Otherwise call our header parse routine to deal with this.


        //
        // Try to find a header hint based on the first char and certain order
        //
        // We start from where we find a succeful hint + 1
        //

        pHeaderHintMap = NULL;

        if (IS_HTTP_ALPHA(*pBuffer))
        {
            UpcaseChar = UPCASE_CHAR(*pBuffer);

            for ( 
                  HintIndex = NextHintIndex;
                  HintIndex < NUMBER_HEADER_HINT_INDICES;
                  ++HintIndex
                )
            {
                if (g_RequestHeaderHintIndexTable[HintIndex].c == UpcaseChar)
                {

                    pHeaderHintMap
                        = g_RequestHeaderHintIndexTable[HintIndex].pHeaderMap;

                    break;
                }
            }
        }

        if (NULL != pHeaderHintMap)
        {
            Status = UlParseHeaderWithHint(
                            pRequest,
                            pBuffer,
                            BufferLength,
                            pHeaderHintMap,
                            &BytesTaken
                            );

            if (-1 == BytesTaken)
            {
                // hint failed

                Status = UlParseHeader(
                                pRequest,
                                pBuffer,
                                BufferLength,
                                &BytesTaken
                                );
            } else
            {
                NextHintIndex = HintIndex + 1;
            }
        }
        else
        {
            Status = UlParseHeader(
                            pRequest,
                            pBuffer,
                            BufferLength,
                            &BytesTaken
                            );
        }

        if (NT_SUCCESS(Status) == FALSE)
            goto end;

        //
        // Check if the parsed headers are longer than maximum allowed.
        //

        if ( (*pBytesTaken+BytesTaken) > g_UlMaxFieldLength )
        {
            UlTraceError(PARSER, (
                    "UlParseHeaders(pRequest = %p) "
                    "ERROR: Header field is too big\n",
                    pRequest
                    ));

            UlSetErrorCode(pRequest, UlErrorFieldLength, NULL);

            Status = STATUS_SECTION_TOO_BIG;
            goto end;
        }

        //
        // If no bytes were consumed, the header must be incomplete, so
        // bail out until we get more data on this connection.
        //

        if (BytesTaken == 0)
        {
            Status = STATUS_MORE_PROCESSING_REQUIRED;
            goto end;
        }

        //
        // Otherwise we parsed a header, so update and continue.
        //

        pBuffer += BytesTaken;
        *pBytesTaken += BytesTaken;
        BufferLength -= BytesTaken;

    }

    //
    // we only get here if we didn't see the CRLF headers terminator
    //
    // we need more data
    //

    Status = STATUS_MORE_PROCESSING_REQUIRED;

end:

    //
    // Terminate the header index table when we are done with parsing headers.
    //

    pRequest->HeaderIndex[pRequest->HeaderCount] = HttpHeaderRequestMaximum;

    return Status;

} // UlParseHeaders



/*++

Routine Description:

    This is the core HTTP protocol request engine. It takes a stream of bytes
    and parses them as an HTTP request.

Arguments:

    pRequest            - Pointer to the current request.
    pHttpRequest        - Pointer to the incoming raw HTTP request data.
    HttpRequestLength   - Length of data pointed to by pHttpRequest.
    pBytesTaken         - How much of pHttpRequest was consumed

Return Value:

    Status of parse attempt.

--*/
NTSTATUS
UlParseHttp(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHttpRequest,
    IN  ULONG                   HttpRequestLength,
    OUT ULONG *                 pBytesTaken
    )
{
    ULONG           OriginalBufferLength;
    ULONG           TokenLength;
    ULONG           CurrentBytesTaken = 0;
    ULONG           TotalBytesTaken;
    ULONG           i;
    NTSTATUS        ReturnStatus;
    PUCHAR          pStart;
    USHORT          Eol;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pRequest ) );

    ReturnStatus = STATUS_SUCCESS;
    TotalBytesTaken = 0;

    //
    // remember the original buffer length
    //

    OriginalBufferLength = HttpRequestLength;

    //
    // Put this label here to allow for a manual re-pump of the
    // parser. This is currently used for HTTP/0.9 requests.
    //

parse_it:

    //
    // what state are we in ?
    //

    switch (pRequest->ParseState)
    {

    case ParseVerbState:

        UlTraceVerbose(PARSER, (
                    "UlParseHttp(pRequest = %p): Entering ParseVerbState\n",
                    pRequest
                    ));

        // Look through the fast verb table for the verb. We can only do
        // this if the input data is big enough.
        if (HttpRequestLength >= sizeof(ULONGLONG))
        {
            ULONGLONG   RawInputVerb;

            RawInputVerb = *(UNALIGNED64 ULONGLONG *) pHttpRequest;

            // Loop through the fast verb table, looking for the verb.
            for (i = 0; i < NUMBER_FAST_VERB_ENTRIES; i++)
            {
                // Mask out the raw input verb and compare against this
                // entry. Note: verbs are case-sensitive.

                ASSERT(FastVerbTable[i].RawVerbLength - STRLEN_LIT(" ")
                            < sizeof(ULONGLONG));

                if ((RawInputVerb & FastVerbTable[i].RawVerbMask) ==
                    FastVerbTable[i].RawVerb.LongLong)
                {
                    // It matched. Save the translated verb from the
                    // table, update the request pointer and length,
                    // switch states, and get out.

                    pRequest->Verb = FastVerbTable[i].TranslatedVerb;
                    CurrentBytesTaken = FastVerbTable[i].RawVerbLength;

                    pRequest->ParseState = ParseUrlState;
                    break;
                }
            }
        }

        if (pRequest->ParseState != ParseUrlState)
        {
            // Didn't switch states yet, because we haven't found the
            // verb yet. This could be because a) the incoming request
            // was too small to allow us to use our fast lookup (which
            // might be OK in an HTTP/0.9 request), or b) the incoming
            // verb is a PROPFIND or such that is too big to fit into
            // our fast find table, or c) this is an unknown verb, or
            // d) there was leading white-space before the verb.
            // In any of these cases call our slower verb parser to try
            // again.

            ReturnStatus = UlpLookupVerb(
                                pRequest,
                                pHttpRequest,
                                HttpRequestLength,
                                &CurrentBytesTaken
                                );

            if (NT_SUCCESS(ReturnStatus) == FALSE)
                goto end;

            if (CurrentBytesTaken == 0)
            {
                ReturnStatus = STATUS_MORE_PROCESSING_REQUIRED;
                goto end;
            }

            //
            // we finished parsing the custom verb
            //

            pRequest->ParseState = ParseUrlState;

        }

        //
        // now fall through to ParseUrlState
        //

        ASSERT(CurrentBytesTaken <= HttpRequestLength);

        pHttpRequest += CurrentBytesTaken;
        HttpRequestLength -= CurrentBytesTaken;
        TotalBytesTaken += CurrentBytesTaken;


    case ParseUrlState:

        ASSERT(ParseUrlState == pRequest->ParseState);

        UlTraceVerbose(PARSER, (
                    "UlParseHttp(pRequest = %p): Verb='%s', "
                    "Entering ParseUrlState\n",
                    pRequest,
                    UlVerbToString(pRequest->Verb)
                    ));

        //
        // We're parsing the URL. pHttpRequest points to the incoming URL,
        // HttpRequestLength is the length of this request that is left.
        //

        //
        // Find the WS terminating the URL.
        //

        ReturnStatus = HttpFindUrlToken(
                            &g_UrlC14nConfig,
                            pHttpRequest,
                            HttpRequestLength,
                            &pRequest->RawUrl.pUrl,
                            &TokenLength,
                            &pRequest->RawUrlClean
                            );

        if (NT_SUCCESS(ReturnStatus) == FALSE)
        {
            UlTraceError(PARSER, (
                        "UlParseHttp(pRequest = %p) ERROR %s: "
                        "could not parse URL\n",
                        pRequest,
                        HttpStatusToString(ReturnStatus)
                        ));

            UlSetErrorCode(pRequest, UlErrorUrl, NULL);

            goto end;
        }

        if (pRequest->RawUrl.pUrl == NULL)
        {
            ReturnStatus = STATUS_MORE_PROCESSING_REQUIRED;
            goto end;
        }

        ASSERT(TokenLength > 0);
        ASSERT(pHttpRequest <= pRequest->RawUrl.pUrl
                &&  pRequest->RawUrl.pUrl < pHttpRequest + HttpRequestLength);

        if (TokenLength > g_UlMaxFieldLength)
        {
            //
            // The URL is longer than maximum allowed size
            //

            UlTraceError(PARSER, (
                        "UlParseHttp(pRequest = %p) ERROR: URL is too big\n",
                        pRequest
                        ));

            UlSetErrorCode(pRequest, UlErrorUrlLength, NULL);

            ReturnStatus = STATUS_SECTION_TOO_BIG;
            goto end;
        }

        //
        // Bytes taken includes leading WS in front of URL
        //
        CurrentBytesTaken = DIFF(pRequest->RawUrl.pUrl - pHttpRequest)
                                + TokenLength;
        ASSERT(CurrentBytesTaken <= HttpRequestLength);

        //
        // set url length
        //

        pRequest->RawUrl.Length = TokenLength;

        //
        // Now, let's see if this is an absolute URL. Check to see
        // if the first four characters are "http" (case-insensitive).
        //

        if (pRequest->RawUrl.Length >= HTTP_PREFIX_SIZE &&
            (*(UNALIGNED64 ULONG *)pRequest->RawUrl.pUrl & HTTP_PREFIX_MASK)
               == HTTP_PREFIX)
        {
            //
            // It is.  let's parse it and find the host.
            //

            ReturnStatus = UlpParseFullUrl(pRequest);

            if (NT_SUCCESS(ReturnStatus) == FALSE)
                goto end;
        }
        else
        {
            pRequest->RawUrl.pHost  = NULL;
            pRequest->RawUrl.pAbsPath = pRequest->RawUrl.pUrl;
        }

        //
        // count the space it needs in the user's buffer, including terminator.
        //

        pRequest->TotalRequestSize +=
            (pRequest->RawUrl.Length + 1) * sizeof(CHAR);

        //
        // adjust our book keeping vars
        //

        pHttpRequest += CurrentBytesTaken;
        HttpRequestLength -= CurrentBytesTaken;

        TotalBytesTaken += CurrentBytesTaken;

        //
        // fall through to parsing the version.
        //

        pRequest->ParseState = ParseVersionState;


    case ParseVersionState:

        ASSERT(ParseVersionState == pRequest->ParseState);

        UlTraceVerbose(PARSER, (
                    "UlParseHttp(pRequest = %p): Entering ParseVersionState\n",
                    pRequest
                    ));

        //
        // skip lws
        //

        pStart = pHttpRequest;

        while (HttpRequestLength > 0 && IS_HTTP_LWS(*pHttpRequest))
        {
            pHttpRequest++;
            HttpRequestLength--;
        }

        //
        // is this an HTTP/0.9 request (no version) ?
        //

        if (HttpRequestLength >= CRLF_SIZE)
        {
            Eol = *(UNALIGNED64 USHORT *)(pHttpRequest);

            if (Eol == CRLF || Eol == LFLF)
            {
                // This IS a 0.9 request. No need to go any further,
                // since by definition there are no more headers.
                // Just update things and get out.

                TotalBytesTaken += DIFF(pHttpRequest - pStart) + CRLF_SIZE;

                HTTP_SET_VERSION(pRequest->Version, 0, 9);

                UlTraceVerbose(PARSER, (
                    "UlParseHttp(pRequest = %p): HTTP/0.9 request\n",
                    pRequest
                    ));

                //
                // set the state to CookState so that we parse the url
                //

                pRequest->ParseState = ParseCookState;

                //
                // manually restart the parse switch, we changed the
                // parse state
                //

                goto parse_it;
            }
        }

        //
        // do we have enough buffer to strcmp the version?
        //

        if (HttpRequestLength < (MIN_VERSION_SIZE + CRLF_SIZE))
        {
            ReturnStatus = STATUS_MORE_PROCESSING_REQUIRED;
            goto end;
        }

        Eol = *(UNALIGNED64 USHORT *)(pHttpRequest + MIN_VERSION_SIZE);

        //
        // let's compare it
        //

        if ((*(UNALIGNED64 ULONGLONG *)pHttpRequest == HTTP_11_VERSION) &&
            (Eol == CRLF || Eol == LFLF))
        {
            HTTP_SET_VERSION(pRequest->Version, 1, 1);
            HttpRequestLength -= MIN_VERSION_SIZE;
            pHttpRequest += MIN_VERSION_SIZE;
        }
        else if ((*(UNALIGNED64 ULONGLONG *)pHttpRequest == HTTP_10_VERSION) &&
                 (Eol == CRLF || Eol == LFLF))
        {
            HTTP_SET_VERSION(pRequest->Version, 1, 0);
            HttpRequestLength -= MIN_VERSION_SIZE;
            pHttpRequest += MIN_VERSION_SIZE;
        }
        else
        {
            ULONG VersionBytes = UlpParseHttpVersion(
                                        pHttpRequest,
                                        HttpRequestLength,
                                        &pRequest->Version );

            if (0 != VersionBytes)
            {
                pHttpRequest += VersionBytes;
                HttpRequestLength -= VersionBytes;
            }
            else
            {
                // Could not parse version.

                UlTraceError(PARSER, (
                            "UlParseHttp(pRequest = %p) "
                            "ERROR: could not parse HTTP version\n",
                            pRequest
                            ));

                UlSetErrorCode(pRequest, UlError, NULL);

                ReturnStatus = STATUS_INVALID_DEVICE_REQUEST;
                goto end;
            }
        }

        //
        // skip trailing lws
        //

        while (HttpRequestLength > 0 && IS_HTTP_LWS(*pHttpRequest))
        {
            pHttpRequest++;
            HttpRequestLength--;
        }

        //
        // Make sure we're terminated on this line.
        //

        if (HttpRequestLength < CRLF_SIZE)
        {
            ReturnStatus = STATUS_MORE_PROCESSING_REQUIRED;
            goto end;
        }

        Eol = *(UNALIGNED64 USHORT *)(pHttpRequest);

        if (Eol != CRLF  &&  Eol != LFLF)
        {
            // Bad line termination after successfully grabbing version.

            UlTraceError(PARSER, (
                        "UlParseHttp(pRequest = %p) "
                        "ERROR: HTTP version not terminated correctly\n",
                        pRequest
                        ));

            UlSetErrorCode(pRequest, UlError, NULL);

            ReturnStatus = STATUS_INVALID_DEVICE_REQUEST;
            goto end;
        }

        pHttpRequest += CRLF_SIZE;
        HttpRequestLength -= CRLF_SIZE;

        TotalBytesTaken += DIFF(pHttpRequest - pStart);

        UlTraceVerbose(PARSER, (
                "UlParseHttp(pRequest = %p): HTTP/%hu.%hu request\n",
                pRequest,
                pRequest->Version.MajorVersion,
                pRequest->Version.MinorVersion
                ));

        //
        // Fall through to parsing the headers
        //

        pRequest->ParseState = ParseHeadersState;


    case ParseHeadersState:

        ASSERT(ParseHeadersState == pRequest->ParseState);

        UlTraceVerbose(PARSER, (
                    "UlParseHttp(pRequest = %p): Entering ParseHeadersState\n",
                    pRequest
                    ));

        ReturnStatus = UlParseHeaders(
                            pRequest,
                            pHttpRequest,
                            HttpRequestLength,
                            &CurrentBytesTaken
                            );

        pHttpRequest += CurrentBytesTaken;
        HttpRequestLength -= CurrentBytesTaken;
        TotalBytesTaken += CurrentBytesTaken;

        if (NT_SUCCESS(ReturnStatus) == FALSE)
            goto end;

        //
        // fall through, this is the only way to get here, we never return
        // pending in this state
        //

        pRequest->ParseState = ParseCookState;


    case ParseCookState:

        ASSERT(ParseCookState == pRequest->ParseState);

        UlTraceVerbose(PARSER, (
                    "UlParseHttp(pRequest = %p): Entering ParseCookState\n",
                    pRequest
                    ));

        //
        // time for post processing.  cook it up!
        //

        {
            //
            // First cook up the url, unicode it + such.
            //

            ReturnStatus = UlpCookUrl(pRequest);

            if (NT_SUCCESS(ReturnStatus) == FALSE)
                goto end;

            //
            // mark if we are chunk encoded (only possible for 1.1)
            //

            if ((HTTP_GREATER_EQUAL_VERSION(pRequest->Version, 1, 1)) &&
                (pRequest->HeaderValid[HttpHeaderTransferEncoding]))
            {
                ASSERT(pRequest->Headers[HttpHeaderTransferEncoding].pHeader != NULL);

                //
                // CODEWORK, there can be more than 1 encoding
                //

                if (_stricmp(
                        (const char *)(
                            pRequest->Headers[HttpHeaderTransferEncoding].pHeader
                            ),
                        "chunked"
                        ) == 0)
                {
                    pRequest->Chunked = 1;
                }
                else
                {
                    UlTraceError(PARSER, (
                                "UlParseHttp(pRequest = %p) "
                                "ERROR: unknown Transfer-Encoding!\n",
                                pRequest
                                ));

                    UlSetErrorCode(pRequest, UlErrorNotImplemented, NULL);

                    ReturnStatus = STATUS_INVALID_DEVICE_REQUEST;
                    goto end;
                }
            }

            //
            // Now let's decode the content length header
            //

            if (pRequest->HeaderValid[HttpHeaderContentLength])
            {
                ASSERT(pRequest->Headers[HttpHeaderContentLength].pHeader != NULL);

                ReturnStatus = 
                    UlAnsiToULongLong(
                        pRequest->Headers[HttpHeaderContentLength].pHeader,
                        pRequest->Headers[HttpHeaderContentLength].HeaderLength,
                        10,
                        &pRequest->ContentLength
                        );

                if (NT_SUCCESS(ReturnStatus) == FALSE)
                {
                    UlTraceError(PARSER, (
                                "UlParseHttp(pRequest = %p) "
                                "ERROR: couldn't decode Content-Length\n",
                                pRequest
                                ));

                    if (ReturnStatus == STATUS_SECTION_TOO_BIG)
                    {
                        UlSetErrorCode(pRequest, UlErrorEntityTooLarge, NULL);
                    }
                    else
                    {
                        UlSetErrorCode(pRequest, UlErrorNum, NULL);
                    }

                    goto end;
                }

                if (pRequest->Chunked == 0)
                {
                    //
                    // prime the first (and only) chunk size
                    //

                    pRequest->ChunkBytesToParse = pRequest->ContentLength;
                    pRequest->ChunkBytesToRead = pRequest->ContentLength;
                }

            }

        }

        pRequest->ParseState = ParseEntityBodyState;

        //
        // fall through
        //


    case ParseEntityBodyState:

        UlTraceVerbose(PARSER, (
                    "UlParseHttp(pRequest = %p): Entering ParseEntityBodyState\n",
                    pRequest
                    ));

        ASSERT(ParseEntityBodyState == pRequest->ParseState);

        //
        // the only parsing we do here is chunk length calculation,
        // and that is not necessary if we have no more bytes to parse
        //

        if (pRequest->ChunkBytesToParse == 0)
        {
            //
            // no more bytes left to parse, let's see if there are any
            // more in the request
            //

            if (pRequest->Chunked == 1)
            {

                //
                // the request is chunk encoded
                //

                //
                // attempt to read the size of the next chunk
                //

                ReturnStatus = ParseChunkLength(
                                    pRequest->ParsedFirstChunk,
                                    pHttpRequest,
                                    HttpRequestLength,
                                    &CurrentBytesTaken,
                                    &(pRequest->ChunkBytesToParse)
                                    );

                UlTraceVerbose(PARSER, (
                    "http!UlParseHttp(pRequest = %p): %s. "
                    "Chunk length: %lu bytes taken, "
                    "0x%I64x (%I64u) bytes to parse.\n",
                    pRequest,
                    HttpStatusToString(ReturnStatus),
                    CurrentBytesTaken,
                    pRequest->ChunkBytesToParse,
                    pRequest->ChunkBytesToParse
                    ));

                if (NT_SUCCESS(ReturnStatus) == FALSE)
                {
                    if (ReturnStatus == STATUS_MORE_PROCESSING_REQUIRED)
                    {
                        goto end;
                    }

                    UlTraceError(PARSER, (
                                "http!UlParseHttp (pRequest = %p) "
                                "ERROR: didn't grok chunk length\n",
                                pRequest
                                ));

                    if (ReturnStatus == STATUS_SECTION_TOO_BIG)
                    {
                        UlSetErrorCode(pRequest, UlErrorEntityTooLarge, NULL);
                    }
                    else
                    {
                        UlSetErrorCode(pRequest, UlErrorNum, NULL);
                    }

                    goto end;
                }

                //
                // Otherwise we parsed it, so update and continue.
                //

                pHttpRequest += CurrentBytesTaken;
                TotalBytesTaken += CurrentBytesTaken;
                HttpRequestLength -= CurrentBytesTaken;

                //
                // was this the first chunk?
                //

                if (pRequest->ParsedFirstChunk == 0)
                {
                    //
                    // Prime the reader, let it read the first chunk
                    // even though we haven't quite parsed it yet....
                    //

                    UlTraceVerbose(PARSER, (
                        "UlParseHttp (pRequest=%p) first-chunk seen\n",
                        pRequest
                        ));

                    pRequest->ChunkBytesToRead = pRequest->ChunkBytesToParse;

                    pRequest->ParsedFirstChunk = 1;

                }

                //
                // is this the last chunk (denoted with a 0 byte chunk)?
                //

                if (pRequest->ChunkBytesToParse == 0)
                {
                    //
                    // time to parse the trailer
                    //

                    UlTraceVerbose(PARSER, (
                        "UlParseHttp (pRequest=%p) last-chunk seen\n",
                        pRequest
                        ));

                    pRequest->ParseState = ParseTrailerState;

                }

            }
            else    // if (pRequest->Chunked == 1)
            {
                //
                // not chunk-encoded , all done
                //

                UlTraceVerbose(PARSER, (
                    "UlParseHttp (pRequest=%p) State: EntityBody->Done\n",
                    pRequest
                    ));

                pRequest->ParseState = ParseDoneState;
            }

        }   // if (pRequest->ChunkBytesToParse == 0)

        else
        {
            UlTraceVerbose(PARSER, (
                "UlParseHttp (pRequest=%p) State: EntityBody, "
                "ChunkBytesToParse=0x%I64x (%I64u).\n",
                pRequest,
                pRequest->ChunkBytesToParse, pRequest->ChunkBytesToParse
                ));
        }
        //
        // looks all good
        //

        if (pRequest->ParseState != ParseTrailerState)
        {
            break;
        }

        //
        // fall through
        //


    case ParseTrailerState:

        ASSERT(ParseTrailerState == pRequest->ParseState);

        UlTraceVerbose(PARSER, (
                    "UlParseHttp(pRequest = %p): Entering ParseTrailerState\n",
                    pRequest
                    ));

        //
        // parse any existing trailer
        //
        // ParseHeaders will bail immediately if CRLF is
        // next in the buffer (no trailer)
        //
       
        while(HttpRequestLength >= CRLF_SIZE)
        {
            if (*(UNALIGNED64 USHORT *)pHttpRequest == CRLF ||
                *(UNALIGNED64 USHORT *)pHttpRequest == LFLF)
            {
                pHttpRequest += CRLF_SIZE;
                HttpRequestLength -= CRLF_SIZE;
                TotalBytesTaken += CRLF_SIZE;
               
                //
                // All done.
                //
                UlTrace(PARSER, (
                    "UlParseHttp (pRequest=%p) State: Trailer->Done\n",
                    pRequest
                    ));

                pRequest->ParseState = ParseDoneState;
                ReturnStatus = STATUS_SUCCESS;
                goto end;
            }
            else
            {
                // Treat this as an unknown header, but don't write it.
               
                ReturnStatus = UlLookupHeader(
                                    pRequest,
                                    pHttpRequest,
                                    HttpRequestLength,
                                    NULL,
                                    0,
                                    TRUE,
                                    &CurrentBytesTaken
                                    );

                if (NT_SUCCESS(ReturnStatus) == FALSE)
                    goto end;

                //
                // If no bytes were consumed, the header must be incomplete, so
                // bail out until we get more data on this connection.
                //

                if (CurrentBytesTaken == 0)
                {
                    ReturnStatus = STATUS_MORE_PROCESSING_REQUIRED;
                    goto end;
                }

                pHttpRequest += CurrentBytesTaken;
                HttpRequestLength -= CurrentBytesTaken;
                TotalBytesTaken += CurrentBytesTaken;

            }
        }

        ReturnStatus = STATUS_MORE_PROCESSING_REQUIRED;

        break;

    default:
        //
        // this should never happen!
        //
        ASSERT(! "Unhandled ParseState");
        break;

    }   // switch (pRequest->ParseState)


end:
    *pBytesTaken = TotalBytesTaken;

    if (ReturnStatus == STATUS_MORE_PROCESSING_REQUIRED &&
        TotalBytesTaken == OriginalBufferLength)
    {
        //
        // convert this to success, we consumed the entire buffer
        //

        ReturnStatus = STATUS_SUCCESS;
    }

    UlTrace(PARSER, (
        "UlParseHttp returning %s, "
        "(%p)->ParseState = %d (%s), TotalBytesTaken = %lu\n",
        HttpStatusToString(ReturnStatus),
        pRequest,
        pRequest->ParseState,
        UlParseStateToString(pRequest->ParseState),
        TotalBytesTaken
        ));

    return ReturnStatus;

}   // UlParseHttp


/*++

Routine Description:

    Prints a TCP port number into a string buffer

Arguments:

    pString - Output buffer
    Port    - Port number, in host order

Return Value:

    Number of WCHARs

--*/
ULONG
UlpFormatPort(
    OUT PWSTR pString,
    IN  ULONG Port
    )
{
    PWSTR p1;
    PWSTR p2;
    WCHAR ch;
    ULONG digit;
    ULONG length;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Fast-path common ports. While we're at it, special case port 0,
    // which is definitely not common, but handling it specially makes
    // the general conversion code a bit simpler.
    //

    switch (Port)
    {
    case 0:
        *pString++ = L'0';
        *pString = UNICODE_NULL;
        return 1;

    case 80:
        *pString++ = L'8';
        *pString++ = L'0';
        *pString = UNICODE_NULL;
        return 2;

    case 443:
        *pString++ = L'4';
        *pString++ = L'4';
        *pString++ = L'3';
        *pString = UNICODE_NULL;
        return 3;

    default:
        break;
    }

    //
    // Pull the least significant digits off the port value and store them
    // into the pString. Note that this will store the digits in reverse
    // order.
    //

    p1 = p2 = pString;

    while (Port != 0)
    {
        digit = Port % 10;
        Port = Port / 10;

        *p1++ = L'0' + (WCHAR)digit;
    }

    length = DIFF(p1 - pString);

    //
    // Reverse the digits in the pString.
    //

    *p1-- = UNICODE_NULL;

    while (p1 > p2)
    {
        ch = *p1;
        *p1 = *p2;
        *p2 = ch;

        p2++;
        p1--;
    }

    return length;

}   // UlpFormatPort



/* 

   An origin server that does differentiate resources based on the host
   requested (sometimes referred to as virtual hosts or vanity host
   names) MUST use the following rules for determining the requested
   resource on an HTTP/1.1 request:

   1. If Request-URI is an absoluteURI, the host is part of the
     Request-URI. Any Host header field value in the request MUST be
     ignored.

   2. If the Request-URI is not an absoluteURI, and the request includes
     a Host header field, the host is determined by the Host header
     field value.

   3. If the host as determined by rule 1 or 2 is not a valid host on
     the server, the response MUST be a 400 (Bad Request) error message.

   Recipients of an HTTP/1.0 request that lacks a Host header field MAY
   attempt to use heuristics (e.g., examination of the URI path for
   something unique to a particular host) in order to determine what
   exact resource is being requested.
   
*/

NTSTATUS
UlpCookUrl(
    PUL_INTERNAL_REQUEST pRequest
    )
{
    NTSTATUS    Status;
    PUCHAR      pHost;
    ULONG       HostLength;
    PUCHAR      pAbsPath;
    ULONG       AbsPathLength;
    ULONG       UrlLength;
    ULONG       LengthCopied;
    PWSTR       pUrl = NULL;
    PWSTR       pCurrent;
    UCHAR       IpAddressString[MAX_IP_ADDR_AND_PORT_STRING_LEN + 1];
    USHORT      IpPortNum;
    HOSTNAME_TYPE HostnameType;
    URL_ENCODING_TYPE   HostnameEncodingType;
    SHORT       HostnameAddressType;
    SHORT       TransportAddressType
                     = pRequest->pHttpConn->pConnection->AddressType;
    ULONG       Index;
    ULONG       PortLength;



    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // We must have already parsed the entire headers + such
    //

    if (pRequest->ParseState != ParseCookState)
        return STATUS_INVALID_DEVICE_STATE;

    UlTraceVerbose(PARSER, ("http!UlpCookUrl(pRequest = %p)\n", pRequest));

    //
    // Better have an absolute url. We require a literal '/' at the beginning
    // of pAbsPath; we will not accept %2F or UTF-8 encoding. See bug 467445.
    //

    if (pRequest->RawUrl.pAbsPath[0] != '/')
    {
        UCHAR FirstChar  = pRequest->RawUrl.pAbsPath[0];
        UCHAR SecondChar = pRequest->RawUrl.pAbsPath[1];

        //
        // allow * for Verb = OPTIONS
        //

        if (FirstChar == '*' &&
            IS_HTTP_LWS(SecondChar) &&
            pRequest->Verb == HttpVerbOPTIONS)
        {
            // ok
        }
        else
        {
            UlTraceError(PARSER, (
                        "http!UlpCookUrl(pRequest = %p): "
                        "Invalid lead chars for URL, verb='%s', "
                        "'%c' 0x%02x\n '%c' 0x%02x\n",
                        pRequest,
                        UlVerbToString(pRequest->Verb),
                        IS_HTTP_PRINT(FirstChar)  ? FirstChar  : '?',
                        FirstChar,
                        IS_HTTP_PRINT(SecondChar) ? SecondChar : '?',
                        SecondChar
                        ));

            UlSetErrorCode(pRequest, UlErrorUrl, NULL);
            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto end;
        }
    }

    //
    // get the IP port from the transport
    //

    if (TransportAddressType == TDI_ADDRESS_TYPE_IP)
    {
        IpPortNum =
            pRequest->pHttpConn->pConnection->LocalAddrIn.sin_port;
    }
    else if (TransportAddressType == TDI_ADDRESS_TYPE_IP6)
    {
        IpPortNum =
            pRequest->pHttpConn->pConnection->LocalAddrIn6.sin6_port;
    }
    else
    {
        ASSERT(! "Unexpected TdiAddressType");
        IpPortNum = 0;
    }

    // Convert port from network order to host order
    IpPortNum = SWAP_SHORT(IpPortNum);

    //
    // collect the host + abspath sections
    //

    if (pRequest->RawUrl.pHost != NULL)
    {
        // We have an absUri in the Request-line

        PUCHAR pAbsUri;

        pAbsUri  = pRequest->RawUrl.pUrl;
        pHost    = pRequest->RawUrl.pHost;
        pAbsPath = pRequest->RawUrl.pAbsPath;

        HostnameType = Hostname_AbsUri;
        
        ASSERT(pRequest->RawUrl.Length >= HTTP_PREFIX_SIZE &&
                (*(UNALIGNED64 ULONG *) pAbsUri & HTTP_PREFIX_MASK)
                    == HTTP_PREFIX);
        ASSERT('/' == *pAbsPath);
        
        //
        // Even though we have a hostname in the Request-line, we still
        // MUST have a Host header for HTTP/1.1 requests. The Host header
        // was syntax checked, if present, but will otherwise be ignored.
        //

        if (!pRequest->HeaderValid[HttpHeaderHost]
            && HTTP_GREATER_EQUAL_VERSION(pRequest->Version, 1, 1))
        {
            UlTraceError(PARSER, (
                        "http!UlpCookUrl(pRequest = %p) "
                        "ERROR: 1.1 (or greater) request w/o host header\n",
                        pRequest
                        ));

            UlSetErrorCode(pRequest, UlErrorHost, NULL);

            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto end;
        }

        // Hack for the special case of an AbsUri without a '/' for the abspath
        if (&g_SlashPath[0] == pAbsPath)
        {
            // We just have the scheme and the hostname, no real AbsPath
            HostLength    = pRequest->RawUrl.Length - DIFF(pHost - pAbsUri);
            AbsPathLength = STRLEN_LIT("/");
        }
        else
        {
            HostLength    = DIFF(pAbsPath - pHost);
            AbsPathLength = pRequest->RawUrl.Length - DIFF(pAbsPath - pAbsUri);
        }

        ASSERT(HostLength > 0);
        ASSERT(AbsPathLength > 0);
    }
    else
    {
        // We do not have a hostname in the Request-line

        pHost = NULL;
        HostLength = 0;

        pAbsPath = pRequest->RawUrl.pAbsPath;
        AbsPathLength = pRequest->RawUrl.Length;

        //
        // do we have a Host header?
        //

        if (pRequest->HeaderValid[HttpHeaderHost] &&
           (pRequest->Headers[HttpHeaderHost].HeaderLength > 0) )
        {
            ASSERT(pRequest->Headers[HttpHeaderHost].pHeader != NULL);

            pHost        = pRequest->Headers[HttpHeaderHost].pHeader;
            HostLength   = pRequest->Headers[HttpHeaderHost].HeaderLength;
            HostnameType = Hostname_HostHeader;
        }
        else
        {
            //
            // If this was a 1.1 client, it's an invalid request
            // if it does not have a Host header, so fail it.
            // RFC 2616, 14.23 "Host" says the Host header can be empty,
            // but it MUST be present.
            //

            if (!pRequest->HeaderValid[HttpHeaderHost]
                &&  HTTP_GREATER_EQUAL_VERSION(pRequest->Version, 1, 1))
            {
                UlTraceError(PARSER, (
                            "http!UlpCookUrl(pRequest = %p) "
                            "ERROR: 1.1 (or greater) request w/o host header\n",
                            pRequest
                            ));

                UlSetErrorCode(pRequest, UlErrorHost, NULL);

                Status = STATUS_INVALID_DEVICE_REQUEST;
                goto end;
            }

            //
            // format the transport address into a string
            //

            pHost = IpAddressString;

            // CODEWORK: we probably ought to be writing the scope ID
            // for IPv6 literals
            HostLength = HostAddressAndPortToString(
                                pHost,
                                pRequest->pHttpConn->pConnection->LocalAddress,
                                TransportAddressType);

            ASSERT(HostLength < sizeof(IpAddressString));

            HostnameType = Hostname_Transport;
        }
    }

    //
    // is there a port # already there ?
    //

    for (Index = HostLength; Index-- > 0;  )
    {
        if (pHost[Index] == ':')
        {
            //
            // Remove the port length from HostLength since we always
            // generate the port number ourselves from the transport's port
            //

            HostLength = Index;
            break;
        }
        else if (pHost[Index] == ']')
        {
            // ']' => end of a literal IPv6 address. Not going to find
            // a valid port before this, so abort the rest of the loop
            break;
        }
    }

    //
    // Validate that the hostname is syntactically correct
    //

    Status = HttpValidateHostname(
                    &g_UrlC14nConfig,
                    pHost,
                    HostLength,
                    HostnameType,
                    &HostnameAddressType
                    );

    if (!NT_SUCCESS(Status))
    {
        UlSetErrorCode(pRequest, UlErrorHost, NULL);
        goto end;
    }

    //
    // If the hostname is a literal IPv4 or IPv6 address,
    // it must match the transport that the request was received on.
    //

    if (0 != HostnameAddressType)
    {
        BOOLEAN Valid = (BOOLEAN) (TransportAddressType == HostnameAddressType);

        // CODEWORK: should we check that the transport IP address
        // matches the hostname address?

        if (!Valid)
        {
            UlTraceError(PARSER, (
                        "http!UlpCookUrl(pRequest = %p): "
                        "Host is IPv%c, transport is IPv%c\n",
                        pRequest,
                        (TDI_ADDRESS_TYPE_IP == HostnameAddressType)
                            ? '4' 
                            : (TDI_ADDRESS_TYPE_IP6 == HostnameAddressType)
                                ? '6' : '?',
                        (TDI_ADDRESS_TYPE_IP == TransportAddressType)
                            ? '4' 
                            : (TDI_ADDRESS_TYPE_IP6 == TransportAddressType)
                                ? '6' : '?'
                        ));

            UlSetErrorCode(pRequest, UlErrorHost, NULL);

            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto end;
        }
    }

    //
    // Pessimistically calculate the largest buffer needed to hold the
    // cooked URL. If DBCS, %-encoded, or UTF-8 characters are present
    // in the raw URL, the cooked URL won't need this many WCHARs.
    //

    UrlLength = ((HTTP_PREFIX_SIZE+HTTP_PREFIX2_SIZE)
                 + HostLength
                 + STRLEN_LIT(":")
                 + MAX_PORT_LENGTH
                 + AbsPathLength
                 + 1)                  // terminating NUL
                * sizeof(WCHAR);

    //
    // Too big? Too bad!
    //

    if (UrlLength > UNICODE_STRING_MAX_BYTE_LEN)
    {
        UlTraceError(PARSER, (
                    "http!UlpCookUrl(pRequest = %p): "
                    "Url is too long, %lu\n",
                    pRequest, UrlLength
                    ));

        Status = STATUS_DATA_OVERRUN;
        goto end;
    }

    //
    // allocate a new buffer to hold this guy
    //

    URL_LENGTH_STATS_UPDATE(UrlLength);

    if (UrlLength > g_UlMaxInternalUrlLength)
    {
        pUrl = UL_ALLOCATE_ARRAY(
                    NonPagedPool,
                    WCHAR,
                    UrlLength / sizeof(WCHAR),
                    URL_POOL_TAG
                    );

        URL_LENGTH_STATS_REALLOC();
    }
    else
    {
        pUrl = pRequest->pUrlBuffer;
    }

    if (pUrl == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    pRequest->CookedUrl.pUrl = pCurrent = pUrl;

    HTTP_FILL_BUFFER(pCurrent, UrlLength);
    
    //
    // compute the scheme
    //

    if (pRequest->Secure)
    {
        RtlCopyMemory(pCurrent, L"https://", sizeof(L"https://"));

        pCurrent                    += WCSLEN_LIT(L"https://");
        pRequest->CookedUrl.Length   = WCSLEN_LIT(L"https://") * sizeof(WCHAR);
    }
    else
    {
        RtlCopyMemory(pCurrent, L"http://", sizeof(L"http://"));

        pCurrent                    += WCSLEN_LIT(L"http://");
        pRequest->CookedUrl.Length   = WCSLEN_LIT(L"http://") * sizeof(WCHAR);
    }

    //
    // assemble the rest of the url
    //

    Status = HttpCopyHost(
                &g_UrlC14nConfig,
                pCurrent,
                pHost,
                HostLength,
                &LengthCopied,
                &HostnameEncodingType
                );

    if (NT_SUCCESS(Status) == FALSE)
    {
        UlSetErrorCode(pRequest, UlErrorHost, NULL);
        goto end;
    }

    if (pRequest->CookedUrl.Length + LengthCopied > UNICODE_STRING_MAX_BYTE_LEN)
    {
        Status = STATUS_DATA_OVERRUN;
        goto end;
    }

    pRequest->CookedUrl.pHost   = pCurrent;
    pRequest->CookedUrl.Length += LengthCopied;

    pCurrent += LengthCopied / sizeof(WCHAR);

    //
    // port
    //

    *pCurrent = L':';

    ASSERT(0 != IpPortNum);

    PortLength = UlpFormatPort( pCurrent+1, IpPortNum ) + 1;
    ASSERT(PortLength <= (MAX_PORT_LENGTH+1));

    pCurrent += PortLength;

    // UlpFormatPort returns WCHAR not byte count
    pRequest->CookedUrl.Length += PortLength * sizeof(WCHAR);

    if (pRequest->CookedUrl.Length > UNICODE_STRING_MAX_BYTE_LEN)
    {
        Status = STATUS_DATA_OVERRUN;
        goto end;
    }

    //
    // abs_path
    //

    if (pRequest->RawUrlClean)
    {
        Status = HttpCopyUrl(
                        &g_UrlC14nConfig,
                        pCurrent,
                        pAbsPath,
                        AbsPathLength,
                        &LengthCopied,
                        &pRequest->CookedUrl.UrlEncoding
                        );
    }
    else
    {
        Status = HttpCleanAndCopyUrl(
                        &g_UrlC14nConfig,
                        UrlPart_AbsPath,
                        pCurrent,
                        pAbsPath,
                        AbsPathLength,
                        &LengthCopied,
                        &pRequest->CookedUrl.pQueryString,
                        &pRequest->CookedUrl.UrlEncoding
                        );
    }

    if (NT_SUCCESS(Status) == FALSE)
    {
        if (STATUS_OBJECT_PATH_INVALID == Status)
        {
            UlTraceError(PARSER, (
                        "http!UlpCookUrl(pRequest = %p) Invalid URL\n",
                        pRequest
                        ));

            UlSetErrorCode(pRequest, UlErrorForbiddenUrl, NULL);
        }

        goto end;
    }

    if (pRequest->CookedUrl.Length + LengthCopied > UNICODE_STRING_MAX_BYTE_LEN)
    {
        Status = STATUS_DATA_OVERRUN;
        goto end;
    }

    pRequest->CookedUrl.pAbsPath = pCurrent;
    pRequest->CookedUrl.Length  += LengthCopied;

    ASSERT(pRequest->CookedUrl.Length <= UrlLength);

    //
    // Update pRequest, include space for the terminator
    //

    pRequest->TotalRequestSize += pRequest->CookedUrl.Length + sizeof(WCHAR);

    //
    // Let's create the hash for the whole CookedUrl
    //

    pRequest->CookedUrl.Hash = HashStringNoCaseW(pRequest->CookedUrl.pUrl, 0);

    //
    // Scramble it
    //

    pRequest->CookedUrl.Hash = HashRandomizeBits(pRequest->CookedUrl.Hash);

    ASSERT(pRequest->CookedUrl.pHost != NULL);
    ASSERT(pRequest->CookedUrl.pAbsPath != NULL);

    //
    // Setup the routing token Pointers to point to the default 
    // token buffer (allocated inline with request).
    //

    ASSERT(pRequest->CookedUrl.pRoutingToken == NULL);
    ASSERT(pRequest->CookedUrl.RoutingTokenBufferSize == 0);
    ASSERT(pRequest->pDefaultRoutingTokenBuffer);
    
    pRequest->CookedUrl.pRoutingToken = pRequest->pDefaultRoutingTokenBuffer;
    pRequest->CookedUrl.RoutingTokenBufferSize = DEFAULT_MAX_ROUTING_TOKEN_LENGTH;

    pRequest->CookedUrl.RoutingTokenType = RoutingTokenNotExists;
    
    
    Status = STATUS_SUCCESS;

end:

    if (! NT_SUCCESS(Status))
    {        
        if (pUrl != NULL)
        {
            if (pUrl != pRequest->pUrlBuffer)
            {
                UL_FREE_POOL(pUrl, URL_POOL_TAG);
            }

            RtlZeroMemory(&pRequest->CookedUrl, sizeof(pRequest->CookedUrl));
        }

        //
        // has a specific error code been set?
        //

        UlTraceError(PARSER, (
                    "http!UlpCookUrl(pRequest = %p) "
                    "ERROR: unhappy. %s\n",
                    pRequest,
                    HttpStatusToString(Status)
                    ));

        if (pRequest->ErrorCode == UlErrorNone)
        {
            UlSetErrorCode(pRequest, UlErrorUrl, NULL);
        }
    }

    return Status;

}   // UlpCookUrl



/*++

Routine Description:

    A utility routine to generate the routing token. As well as
    the corresponding token hash. The hash is used if we decide
    to cache this url.
    
    This function is used for the IP Bound site lookup in the 
    cgroup tree.

    When token is generated TokenLength is in bytes, and does 
    not include the terminating NULL.

Arguments:

    pRequest - The request's cooked url holds the routing token

    IpBased  - If True, rather than copying the Host from 
               cooked url, the ip address used in place.
               This is for Ip-only site lookup.

Returns:

    STATUS_SUCCESS  - If the requested token is already there.
                    - If the token is successfully generated.

    STATUS_NO_MEMORY- If the memory allocation failed for a large
                      possible token size.
        
--*/

NTSTATUS
UlGenerateRoutingToken(
    IN OUT PUL_INTERNAL_REQUEST pRequest,
    IN     BOOLEAN IpBased
    )
{
    USHORT TokenLength = 0;
    PUL_HTTP_CONNECTION pHttpConn = NULL;
    PWCHAR pToken = NULL;

    PAGED_CODE();

    //
    // The Routing Token ends with a terminating null. 
    // And once it is generated, it will look like as;
    //
    // "http(s)://host:port:Ip" or "http(s)://Ip:port:Ip"
    //            --------- ---               ------- ---
    //             X         Y                  X      Y
    //
    // When IpBased is set to FALSE, X comes from cookedUrl
    // which's the host sent by the client. (case1)
    // When IpBased is set to TRUE, X comes from the Ip address
    // of the connection on which the request is received. (case2)
    //
    // Y always comes from the connection. For Host+Ip bound sites
    // cgroup needs the token in case1. For IP only bound sites 
    // cgroup needs the token in case2.    
    //

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    pHttpConn = pRequest->pHttpConn;
    ASSERT(IS_VALID_CONNECTION(pHttpConn->pConnection));

    ASSERT(pRequest->pDefaultRoutingTokenBuffer);
    ASSERT(pRequest->CookedUrl.pRoutingToken);
    ASSERT(pRequest->CookedUrl.RoutingTokenBufferSize);

    ASSERT(IS_VALID_ROUTING_TOKEN(pRequest->CookedUrl.RoutingTokenType));
    
    //
    // Short cut if the requested token is already there.
    //
    
    if (IpBased && 
        pRequest->CookedUrl.RoutingTokenType == RoutingTokenIP)
    {
        return STATUS_SUCCESS;
    }
    else if (IpBased == FALSE && 
        pRequest->CookedUrl.RoutingTokenType == RoutingTokenHostPlusIP)
    {
        return STATUS_SUCCESS;
    }              
        
    //
    // We should not be trying to generate a new token on the same 
    // buffer, if the previous token is already matched in the cgroup.
    // or in the uri cache.
    //
    
    ASSERT(pRequest->ConfigInfo.SiteUrlType == HttpUrlSite_None);

    if (IpBased)
    {
        PWSTR pUrl = pRequest->CookedUrl.pUrl;
        PWSTR pTemp;

        ASSERT(pUrl);

        pToken = (PWCHAR) pRequest->CookedUrl.pRoutingToken;
    
        //
        // Default buffer should always be big enough to hold the max 
        // possible IP Based routing token.
        // 
        
        ASSERT(MAX_IP_BASED_ROUTING_TOKEN_LENGTH 
                    <= pRequest->CookedUrl.RoutingTokenBufferSize);

        //
        // Build the HTTP prefix first.
        //

        if (pUrl[HTTP_PREFIX_COLON_INDEX] == L':')
        {
            RtlCopyMemory(
                pToken,
                HTTP_IP_PREFIX,
                HTTP_IP_PREFIX_LENGTH
                );

            TokenLength = HTTP_IP_PREFIX_LENGTH;
        }
        else
        {
            ASSERT(pUrl[HTTPS_PREFIX_COLON_INDEX] == L':');
            
            RtlCopyMemory(
                pToken,
                HTTPS_IP_PREFIX,
                HTTPS_IP_PREFIX_LENGTH
                );

            TokenLength = HTTPS_IP_PREFIX_LENGTH;
        }

        pTemp = pToken + (TokenLength / sizeof(WCHAR));
        
        //
        // Now Add the "Ip : Port : Ip"
        //

        ASSERT(IS_VALID_CONNECTION(pHttpConn->pConnection));        
        
        TokenLength = TokenLength +
            HostAddressAndPortToRoutingTokenW(
                            pTemp,
                            pHttpConn->pConnection->LocalAddress,
                            pHttpConn->pConnection->AddressType
                            );    

        ASSERT(TokenLength <= MAX_IP_BASED_ROUTING_TOKEN_LENGTH);

        pRequest->CookedUrl.RoutingTokenType = RoutingTokenIP;
        
    }
    else // Host + Ip based token (IpBased == FALSE)
    {
        USHORT MaxRoutingTokenSize;
        USHORT CookedHostLength = 
              DIFF_USHORT(pRequest->CookedUrl.pAbsPath - pRequest->CookedUrl.pUrl);

        ASSERT(CookedHostLength);

        //
        // Check if the default buffer is big enough to hold the token.
        //

        MaxRoutingTokenSize = (
            CookedHostLength +                      // For http(s)://host:port
            1 +                                     // For ':' after port  
            1 +                                     // For terminating Null
            MAX_IP_ADDR_PLUS_BRACKETS_STRING_LEN    // For IP Address at the end
            ) * sizeof(WCHAR) 
            ;
        
        if (MaxRoutingTokenSize > pRequest->CookedUrl.RoutingTokenBufferSize)
        {
            PWSTR pRoutingToken = UL_ALLOCATE_ARRAY(
                                        NonPagedPool,
                                        WCHAR,
                                        MaxRoutingTokenSize / sizeof(WCHAR),
                                        URL_POOL_TAG
                                        );
            
            if (pRoutingToken == NULL)
            {
                return STATUS_NO_MEMORY;
            }

            //
            // There shouldn't be a previous large buffer, but let's check 
            // it out anyway.
            //
            
            if (pRequest->CookedUrl.pRoutingToken != 
                    pRequest->pDefaultRoutingTokenBuffer)
            {
                ASSERT(!"This should never happen !");
                UL_FREE_POOL(pRequest->CookedUrl.pRoutingToken, URL_POOL_TAG);
            }   
                
            pRequest->CookedUrl.pRoutingToken = pRoutingToken;            
            pRequest->CookedUrl.RoutingTokenBufferSize = MaxRoutingTokenSize;        
        }

        //
        // Copy over everything from the beginning of the cooked url 
        // to the AbsPath of the cooked url.
        //
        
        pToken = (PWCHAR) pRequest->CookedUrl.pRoutingToken;

        RtlCopyMemory(pToken,
                      pRequest->CookedUrl.pUrl,
                      CookedHostLength * sizeof(WCHAR)
                      );

        pToken += CookedHostLength;

        ASSERT((pRequest->CookedUrl.pUrl)[CookedHostLength] == L'/');

        *pToken++ = L':';

        TokenLength = (CookedHostLength + 1) * sizeof(WCHAR);

        //
        // Now copy over the IP Address to the end.
        //
        
        TokenLength = TokenLength +
            HostAddressToStringW(
                            pToken,
                            pHttpConn->pConnection->LocalAddress,
                            pHttpConn->pConnection->AddressType
                            );   

        pRequest->CookedUrl.RoutingTokenType = RoutingTokenHostPlusIP;
    }
    
    //
    // Make sure that we did not overflow the allocated buffer.
    // TokenLength does not include the terminating null.
    //
    
    ASSERT((TokenLength + sizeof(WCHAR)) 
                <= pRequest->CookedUrl.RoutingTokenBufferSize);

    //
    // Set the tokenlength to show the actual amount we are using.
    // Also recalculate the token hash INCLUDING the AbsPath from the 
    // original cooked url.
    //

    pRequest->CookedUrl.RoutingTokenLength = TokenLength;

    //
    // Create the hash for the whole RoutingToken plus AbsPath.
    //

    pRequest->CookedUrl.RoutingHash = 
        HashStringsNoCaseW(
            pRequest->CookedUrl.pRoutingToken, 
            pRequest->CookedUrl.pAbsPath,
            0
            );
    
    pRequest->CookedUrl.RoutingHash = 
        HashRandomizeBits(pRequest->CookedUrl.RoutingHash);

    UlTrace(CONFIG_GROUP_FNC, 
        ("Http!UlGenerateRoutingToken: "
         "pRoutingToken:(%S) pAbsPath: (%S) Hash %lx\n", 
          pRequest->CookedUrl.pRoutingToken,
          pRequest->CookedUrl.pAbsPath,
          pRequest->CookedUrl.RoutingHash
          )); 

    //
    // Ready for a cgroup lookup !
    //
    
    return STATUS_SUCCESS;

} // UlGenerateRoutingToken



/***************************************************************************++

Routine Description:

    Generates the fixed part of the header. Fixed headers include the
    status line, and any headers that don't have to be generated for
    every request (such as Date and Connection).

    The final CRLF separating headers from body is considered part of
    the variable headers.

Arguments:

    Version         - the http version for the status line
    pUserResponse   - the user specified response
    BufferLength    - length of pBuffer
    AccessMode      - UserMode (probe) or KernelMode (no probe)
    pBuffer         - generate the headers here
    pBytesCopied    - gets the number of bytes generated

--***************************************************************************/
NTSTATUS
UlGenerateFixedHeaders(
    IN  HTTP_VERSION    Version,
    IN  PHTTP_RESPONSE  pUserResponse,
    IN  USHORT          HttpStatusCode,
    IN  ULONG           BufferLength,
    IN  KPROCESSOR_MODE AccessMode,
    OUT PUCHAR          pBuffer,
    OUT PULONG          pBytesCopied
    )
{
    PUCHAR                  pStartBuffer;
    PUCHAR                  pEndBuffer;
    ULONG                   BytesToCopy;
    ULONG                   i;
    PHTTP_KNOWN_HEADER      pKnownHeaders;
    PHTTP_UNKNOWN_HEADER    pUnknownHeaders;
    NTSTATUS                Status = STATUS_SUCCESS;
    USHORT                  ReasonLength;
    PCSTR                   pReason;
    USHORT                  RawValueLength;
    PCSTR                   pRawValue;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pUserResponse != NULL);
    ASSERT(pBuffer != NULL && BufferLength > 0);
    ASSERT(pBytesCopied != NULL);

    //
    // The pUserResponse is (probably) user-mode data and cannot be trusted.
    // Hence the try/except.
    //

    __try
    {
        pStartBuffer = pBuffer;
        pEndBuffer = pBuffer + BufferLength;

        // Check for arithmetic overflow
        if (pEndBuffer <= pStartBuffer)
            return STATUS_INVALID_PARAMETER;

        ReasonLength = pUserResponse->ReasonLength;
        pReason = pUserResponse->pReason;

        //
        // Build the response headers.
        //

        if (HTTP_NOT_EQUAL_VERSION(Version, 0, 9))
        {
            BytesToCopy =
                STRLEN_LIT("HTTP/1.1 ") +
                4 +
                ReasonLength +
                sizeof(USHORT);

            if (DIFF(pEndBuffer - pBuffer) < BytesToCopy)
            {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            //
            // Always send back 1.1 in the response.
            //

            RtlCopyMemory(pBuffer, "HTTP/1.1 ", STRLEN_LIT("HTTP/1.1 "));
            pBuffer += STRLEN_LIT("HTTP/1.1 ");

            //
            // Build ASCII representation of 3-digit status code
            // in reverse order: units, tens, hundreds.
            // Section 6.1.1 of RFC 2616 says that Status-Code is 3DIGIT;
            // reject anything that can't be represented in three digits.
            //

            if (HttpStatusCode > UL_MAX_HTTP_STATUS_CODE)
                return STATUS_INVALID_PARAMETER;

            pBuffer[2] = (UCHAR) ('0' + (HttpStatusCode % 10));
            HttpStatusCode /= 10;

            pBuffer[1] = (UCHAR) ('0' + (HttpStatusCode % 10));
            HttpStatusCode /= 10;

            pBuffer[0] = (UCHAR) ('0' + (HttpStatusCode % 10));

            pBuffer[3] = SP;

            pBuffer += 4;

            //
            // Copy the optional reason phrase.
            //

            if (0 != ReasonLength)
            {
                UlProbeAnsiString(pReason, ReasonLength, AccessMode);

                for (i = 0;  i < ReasonLength;  ++i)
                {
                    // Reason-Phrase must be printable ASCII characters or LWS
                    if (IS_HTTP_PRINT(pReason[i]))
                    {
                        *pBuffer++ = pReason[i];
                    }
                    else
                    {
                        return STATUS_INVALID_PARAMETER;
                    }
                }
            }

            //
            // Terminate with the CRLF.
            //

            ((UNALIGNED64 USHORT *)pBuffer)[0] = CRLF;
            pBuffer += sizeof(USHORT);

            //
            // Loop through the known headers.
            //

            pKnownHeaders = pUserResponse->Headers.KnownHeaders;

            for (i = 0; i < HttpHeaderResponseMaximum; ++i)
            {
                //
                // Skip some headers we'll generate.
                //

                if ((i == HttpHeaderDate) || 
                    (i == HttpHeaderConnection) ||
                    (i == HttpHeaderServer))
                {
                    continue;
                }

                RawValueLength = pKnownHeaders[i].RawValueLength;

                // We have no provision for sending back a known header
                // with an empty value, but the RFC specifies non-empty
                // values for each of the known headers.

                if (RawValueLength > 0)
                {
                    PHEADER_MAP_ENTRY pEntry
                        = &(g_ResponseHeaderMapTable[g_ResponseHeaderMap[i]]);
                    
                    pRawValue = pKnownHeaders[i].pRawValue;

                    UlProbeAnsiString(
                        pRawValue,
                        RawValueLength,
                        AccessMode
                        );
                        
                    BytesToCopy =
                        pEntry->HeaderLength +
                        1 +                 // space
                        RawValueLength +
                        sizeof(USHORT);     // CRLF

                    if (DIFF(pEndBuffer - pBuffer) < BytesToCopy)
                    {
                        return STATUS_INSUFFICIENT_RESOURCES;
                    }

                    RtlCopyMemory(
                        pBuffer,
                        pEntry->MixedCaseHeader,
                        pEntry->HeaderLength
                        );

                    pBuffer += pEntry->HeaderLength;

                    *pBuffer++ = SP;

                    RtlCopyMemory(
                        pBuffer,
                        pRawValue,
                        RawValueLength
                        );

                    pBuffer += RawValueLength;

                    ((UNALIGNED64 USHORT *)pBuffer)[0] = CRLF;
                    pBuffer += sizeof(USHORT);
                }
            }

            //
            // Handle the Server: header
            //

            if ( UL_DISABLE_SERVER_HEADER_ALL != g_UlDisableServerHeader )
            {
                if ( g_UlDisableServerHeader == UL_DISABLE_SERVER_HEADER_DRIVER &&
                    (pUserResponse->Flags & HTTP_RESPONSE_FLAG_DRIVER) )
                {
                    // skip generating server header on driver-created responses
                }
                else
                {
                    BOOLEAN Suppress = FALSE;

                    pRawValue = pKnownHeaders[HttpHeaderServer].pRawValue;
                    RawValueLength = pKnownHeaders[HttpHeaderServer
                        ].RawValueLength;

                    // check to see if app wishes to suppress Server: header
                    if ( (0 == RawValueLength) && pRawValue )
                    {
                        // Probe pRawValue and see if it's a single null char
                        UlProbeAnsiString(
                            pRawValue,
                            sizeof(UCHAR),
                            AccessMode
                            );

                        if ( '\0' == *pRawValue )
                        {
                            Suppress = TRUE;
                        }
                    }

                    // If we're not supressing it, generate it!
                    if ( !Suppress )
                    {
                        PHEADER_MAP_ENTRY pEntry;

                        pEntry = &(g_ResponseHeaderMapTable[g_ResponseHeaderMap[
                                    HttpHeaderServer]]);

                        BytesToCopy =
                            pEntry->HeaderLength +
                            1 +
                            DEFAULT_SERVER_HDR_LENGTH +
                            sizeof(USHORT);

                        if (DIFF(pEndBuffer - pBuffer) < BytesToCopy)
                        {
                            return STATUS_INSUFFICIENT_RESOURCES;
                        }

                        RtlCopyMemory(
                            pBuffer,
                            pEntry->MixedCaseHeader,
                            pEntry->HeaderLength
                            );

                        pBuffer += pEntry->HeaderLength;

                        *pBuffer++ = SP;

                        //
                        // Prepend user's Server header data + SP
                        //
                        
                        if ( RawValueLength )
                        {
                            BytesToCopy = RawValueLength +  // User's Data
                                          1 +               // SP
                                          DEFAULT_SERVER_HDR_LENGTH + 
                                          sizeof(USHORT);   // CRLF
                            
                            if (DIFF(pEndBuffer - pBuffer) < BytesToCopy)
                            {
                                return STATUS_INSUFFICIENT_RESOURCES;
                            }

                            UlProbeAnsiString(
                                pRawValue,
                                RawValueLength,
                                AccessMode
                                );

                            RtlCopyMemory(
                                pBuffer,
                                pRawValue,
                                RawValueLength
                                );

                            pBuffer += RawValueLength;
                            
                            *pBuffer++ = SP;
                        }

                        //
                        // Append default Server header vaule
                        //

                        RtlCopyMemory(
                            pBuffer,
                            DEFAULT_SERVER_HDR,
                            DEFAULT_SERVER_HDR_LENGTH
                            );

                        pBuffer += DEFAULT_SERVER_HDR_LENGTH;
                        
                        // Terminate the header
                        ((UNALIGNED64 USHORT *)pBuffer)[0] = CRLF;
                        pBuffer += sizeof(USHORT);
                    }
                }
            }

            //
            // And now the unknown headers (this might throw an exception).
            //

            pUnknownHeaders = pUserResponse->Headers.pUnknownHeaders;

            if (pUnknownHeaders != NULL)
            {
                USHORT UnknownHeaderCount
                    = pUserResponse->Headers.UnknownHeaderCount;

                if (UnknownHeaderCount >= UL_MAX_CHUNKS)
                {
                    return STATUS_INVALID_PARAMETER;
                }
                
                UlProbeForRead(
                    pUnknownHeaders,
                    sizeof(HTTP_UNKNOWN_HEADER) * UnknownHeaderCount,
                    TYPE_ALIGNMENT(PVOID),
                    AccessMode
                    );

                for (i = 0 ; i < UnknownHeaderCount; ++i)
                {
                    USHORT NameLength = pUnknownHeaders[i].NameLength;
                    PCSTR pName;

                    RawValueLength = pUnknownHeaders[i].RawValueLength;

                    if (NameLength > 0)
                    {
                        BytesToCopy =
                            NameLength +
                            STRLEN_LIT(": ") +
                            RawValueLength +
                            sizeof(USHORT);     // CRLF

                        if (DIFF(pEndBuffer - pBuffer) < BytesToCopy)
                        {
                            return STATUS_INSUFFICIENT_RESOURCES;
                        }

                        pName = pUnknownHeaders[i].pName;

                        UlProbeAnsiString(
                            pName,
                            NameLength,
                            AccessMode
                            );

                        RtlCopyMemory(
                            pBuffer,
                            pName,
                            NameLength
                            );
                        
                        pBuffer += NameLength;

                        *pBuffer++ = ':';
                        *pBuffer++ = SP;

                        //
                        // Empty values are legitimate
                        //

                        if (0 != RawValueLength)
                        {
                            pRawValue = pUnknownHeaders[i].pRawValue;

                            UlProbeAnsiString(
                                pRawValue,
                                RawValueLength,
                                AccessMode
                                );

                            RtlCopyMemory(
                                pBuffer,
                                pRawValue,
                                RawValueLength
                                );

                            pBuffer += RawValueLength;
                        }

                        ((UNALIGNED64 USHORT *)pBuffer)[0] = CRLF;
                        pBuffer += sizeof(USHORT);

                    }   // if (NameLength > 0)

                }

            }   // if (pUnknownHeaders != NULL)

            *pBytesCopied = DIFF(pBuffer - pStartBuffer);

        }   // if (Version > UlHttpVersion09)
        else
        {
            *pBytesCopied = 0;
        }

        //
        // Ensure we didn't use too much.
        //

        ASSERT(DIFF(pBuffer - pStartBuffer) <= BufferLength);

    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }

    return Status;

} // UlGenerateFixedHeaders


PCSTR Weekdays[] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
PCSTR Months[]   = { "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                     "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };

/***************************************************************************++

Routine Description:

    Generates a date header string from a LARGE_INTEGER.

Arguments:

    pBuffer: Buffer to store generated date string

    systemTime: A 64-bit Time value to be converted

--***************************************************************************/
ULONG
UlpGenerateDateHeaderString(
    OUT PUCHAR pBuffer,
    IN LARGE_INTEGER systemTime
    )
{
    TIME_FIELDS timeFields;
    int length;

    PAGED_CODE();

    RtlTimeToTimeFields( &systemTime, &timeFields );

    length = _snprintf(
                 (char *) pBuffer,
                 DATE_HDR_LENGTH,
                 "%s, %02hd %s %04hd %02hd:%02hd:%02hd GMT",
                 Weekdays[timeFields.Weekday],
                 timeFields.Day,
                 Months[timeFields.Month - 1],
                 timeFields.Year,
                 timeFields.Hour,
                 timeFields.Minute,
                 timeFields.Second
                 );

    return (ULONG)length;

}   // UlpGenerateDateHeaderString


/***************************************************************************++

Routine Description:

    Generates a date header and updates cached value if required.

Arguments:

    pBuffer: Buffer to store generated date header.

    pSystemTime: caller allocated buffer to receive the SystemTime equivalent
                 of the generated string time.

--***************************************************************************/
ULONG
UlGenerateDateHeader(
    OUT PUCHAR pBuffer,
    OUT PLARGE_INTEGER pSystemTime
    )
{
    LARGE_INTEGER CacheTime;

    LONGLONG timediff;

    PAGED_CODE();

    //
    // Get the current time.
    //

    KeQuerySystemTime( pSystemTime );
    CacheTime.QuadPart = g_UlSystemTime.QuadPart;

    //
    // Check the difference between the current time, and
    // the cached time. Note that timediff is signed.
    //

    timediff = pSystemTime->QuadPart - CacheTime.QuadPart;

    if (timediff < ONE_SECOND)
    {
        //
        // The entry hasn't gone stale yet. We can copy.
        // Force a barrier around reading the string into memory.
        //

        UL_READMOSTLY_READ_BARRIER();
        RtlCopyMemory(pBuffer, g_UlDateString, g_UlDateStringLength+1);
        UL_READMOSTLY_READ_BARRIER();


        //
        // Inspect the global time value again in case it changed.
        //

        if (CacheTime.QuadPart == g_UlSystemTime.QuadPart) {
            //
            // Global value hasn't changed. We are all set.
            //
            pSystemTime->QuadPart = CacheTime.QuadPart;
            return g_UlDateStringLength;

        }

    }

    //
    // The cached value is stale, or is/was being changed. We need to update
    // or re-read it. Note that we could also spin trying to re-read and
    // acquire the lock.
    //

    UlAcquirePushLockExclusive(&g_pUlNonpagedData->DateHeaderPushLock);

    //
    // Has someone else updated the time while we were blocked?
    //

    CacheTime.QuadPart = g_UlSystemTime.QuadPart;
    timediff = pSystemTime->QuadPart - CacheTime.QuadPart;

    if (timediff >= ONE_SECOND)
    {
        g_UlSystemTime.QuadPart = 0;
        KeQuerySystemTime( pSystemTime );

        UL_READMOSTLY_WRITE_BARRIER();
        g_UlDateStringLength = UlpGenerateDateHeaderString(
                                    g_UlDateString,
                                    *pSystemTime
                                    );
        UL_READMOSTLY_WRITE_BARRIER();

        g_UlSystemTime.QuadPart = pSystemTime->QuadPart;
    }
    else
    {
        // Capture the system time used to generate the buffer
        pSystemTime->QuadPart = g_UlSystemTime.QuadPart;
    }

    //
    // The time has been updated. Copy the new string into
    // the caller's buffer.
    //
    RtlCopyMemory(
        pBuffer,
        g_UlDateString,
        g_UlDateStringLength + 1
        );

    UlReleasePushLockExclusive(&g_pUlNonpagedData->DateHeaderPushLock);

    return g_UlDateStringLength;

}   // UlGenerateDateHeader


/***************************************************************************++

Routine Description:

    Initializes the date cache.

--***************************************************************************/
NTSTATUS
UlInitializeDateCache( VOID )
{
    LARGE_INTEGER now;

    KeQuerySystemTime(&now);
    g_UlDateStringLength = UlpGenerateDateHeaderString(g_UlDateString, now);

    UlInitializePushLock(
        &g_pUlNonpagedData->DateHeaderPushLock,
        "DateHeaderPushLock",
        0,
        UL_DATE_HEADER_PUSHLOCK_TAG
        );

    g_DateCacheInitialized = TRUE;

    return STATUS_SUCCESS;

} // UlInitializeDateCache


/***************************************************************************++

Routine Description:

    Terminates the date header cache.

--***************************************************************************/
VOID
UlTerminateDateCache( VOID )
{
    if (g_DateCacheInitialized)
    {
        UlDeletePushLock(&g_pUlNonpagedData->DateHeaderPushLock);
    }
}



/***************************************************************************++

Routine Description:

    Figures out how big the fixed headers are. Fixed headers include the
    status line, and any headers that don't have to be generated for
    every request (such as Date and Connection).

    The final CRLF separating headers from body is considered part of
    the variable headers.

Arguments:

    Version - HTTP Version of the request: 0.9, 1.0., 1.1

    pUserResponse - the response containing the headers

    pHeaderLength - result: the number of bytes in the fixed headers.

Return Value:

    NTSTATUS - STATUS_SUCCESS or an error code (possibly from an exception)

--***************************************************************************/
NTSTATUS
UlComputeFixedHeaderSize(
    IN HTTP_VERSION Version,
    IN PHTTP_RESPONSE pUserResponse,
    IN KPROCESSOR_MODE AccessMode,
    OUT PULONG pHeaderLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG HeaderLength = 0;
    ULONG i;
    PHTTP_UNKNOWN_HEADER pUnknownHeaders;
    USHORT UnknownHeaderCount;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pHeaderLength != NULL);

    if ((pUserResponse == NULL) || (HTTP_EQUAL_VERSION(Version, 0, 9)))
    {
        *pHeaderLength = 0;
        return STATUS_SUCCESS;
    }

    //
    // The pUserResponse is user-mode data and cannot be trusted.
    // Hence the try/except.
    //

    __try
    {
        HeaderLength
            += (VERSION_SIZE +                              // HTTP-Version
                1 +                                         // SP
                3 +                                         // Status-Code
                1 +                                         // SP
                pUserResponse->ReasonLength / sizeof(CHAR) +// Reason-Phrase
                CRLF_SIZE                                   // CRLF
               );

        //
        // Loop through the known headers.
        //
        
        for (i = 0; i < HttpHeaderResponseMaximum; ++i)
        {
            USHORT RawValueLength
                = pUserResponse->Headers.KnownHeaders[i].RawValueLength;

            // skip some headers we'll generate
            if ((i == HttpHeaderDate) || 
                (i == HttpHeaderConnection) ||
                (i == HttpHeaderServer)) {
                continue;
            }
            
            if (RawValueLength > 0)
            {
                HeaderLength
                    += (g_ResponseHeaderMapTable[
                            g_ResponseHeaderMap[i]
                            ].HeaderLength +                // Header-Name
                        1 +                                 // SP
                        RawValueLength / sizeof(CHAR) +     // Header-Value
                        CRLF_SIZE                           // CRLF
                       );
            }
        }

        //
        // Handle the Server header
        //

        if ( UL_DISABLE_SERVER_HEADER_ALL != g_UlDisableServerHeader )
        {
            if ( g_UlDisableServerHeader == UL_DISABLE_SERVER_HEADER_DRIVER &&
                (pUserResponse->Flags & HTTP_RESPONSE_FLAG_DRIVER) )
            {
                // skip generating server header on driver-created responses
            }
            else
            {
                BOOLEAN Suppress = FALSE;
                USHORT RawValueLength =
                    pUserResponse->Headers.KnownHeaders
                        [HttpHeaderServer].RawValueLength;
                PCSTR pRawValue =
                    pUserResponse->Headers.KnownHeaders
                        [HttpHeaderServer].pRawValue;

                // check to see if app wishes to suppress Server: header
                if ( (0 == RawValueLength) && pRawValue )
                {
                    // Probe pRawValue and see if it's a single null char
                    UlProbeAnsiString(
                        pRawValue,
                        sizeof(UCHAR),
                        AccessMode
                        );

                    if ( '\0' == *pRawValue )
                    {
                        Suppress = TRUE;
                    }
                }

                // If user specifies a server header, append it to 
                // the default Server header
                if ( !Suppress )
                {
                    HeaderLength += (g_ResponseHeaderMapTable[
                                    g_ResponseHeaderMap[HttpHeaderServer]
                                    ].HeaderLength +                // Header-Name
                                    1 +                             // SP
                                    DEFAULT_SERVER_HDR_LENGTH +     // Header-Value
                                    CRLF_SIZE                       // CRLF
                                    );

                    if (RawValueLength)
                    {
                        HeaderLength += (1 +            // SP
                                        RawValueLength  // User's Data to append
                                        );
                    }
                }
            }
        }

        //
        // And the unknown headers (this might throw an exception).
        //
        
        pUnknownHeaders = pUserResponse->Headers.pUnknownHeaders;

        if (pUnknownHeaders != NULL)
        {
            UnknownHeaderCount = pUserResponse->Headers.UnknownHeaderCount;

            if (UnknownHeaderCount >= UL_MAX_CHUNKS)
            {
                ExRaiseStatus( STATUS_INVALID_PARAMETER );
            }

            UlProbeForRead(
                pUnknownHeaders,
                sizeof(HTTP_UNKNOWN_HEADER) * UnknownHeaderCount,
                sizeof(PVOID),
                AccessMode
                );

            for (i = 0 ; i < UnknownHeaderCount; ++i)
            {
                USHORT Length = pUnknownHeaders[i].NameLength;
                
                if (Length > 0)
                {
                    HeaderLength += (Length / sizeof(CHAR) + // Header-Name
                                     1 +                     // ':'
                                     1 +                     // SP
                                     pUnknownHeaders[i].RawValueLength /
                                        sizeof(CHAR) +       // Header-Value
                                     CRLF_SIZE               // CRLF
                                    );
                }
            }
        }
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
        HeaderLength = 0;
    }

    *pHeaderLength = HeaderLength;

    return Status;

}   // UlComputeFixedHeaderSize


/***************************************************************************++

Routine Description:

    Figures out how big the maximum default variable headers are. Variable
    headers include Date, Content and Connection.

    The final CRLF separating headers from body is considered part of
    the variable headers.

Arguments:

Return Values:

    The maximum number of bytes in the variable headers.

--***************************************************************************/
ULONG
UlComputeMaxVariableHeaderSize( VOID )
{
    ULONG Length = 0;
    PHEADER_MAP_ENTRY pEntry;

    PAGED_CODE();

    //
    // Date: header
    //

    pEntry = &(g_ResponseHeaderMapTable[g_ResponseHeaderMap[HttpHeaderDate]]);
    Length += pEntry->HeaderLength;     // header name
    Length += 1;                        // SP
    Length += DATE_HDR_LENGTH;          // header value
    Length += CRLF_SIZE;                // CRLF

    //
    // Connection: header
    //

    pEntry = &(g_ResponseHeaderMapTable[g_ResponseHeaderMap[HttpHeaderConnection]]);

    Length += pEntry->HeaderLength;
    Length += 1;
    Length += MAX(CONN_CLOSE_HDR_LENGTH, CONN_KEEPALIVE_HDR_LENGTH);
    Length += CRLF_SIZE;

    //
    // Content-Length: header
    //

    pEntry = &(g_ResponseHeaderMapTable[g_ResponseHeaderMap[HttpHeaderContentLength]]);

    Length += pEntry->HeaderLength;
    Length += 1;
    Length += MAX_ULONGLONG_STR;
    Length += CRLF_SIZE;

    //
    // final CRLF
    //

    Length += CRLF_SIZE;

    return Length;

}   // UlComputeMaxVariableHeaderSize


/***************************************************************************++

Routine Description:

    Generates the variable part of the header, namely, Date:, Connection:,
    Content-Length:, and final CRLF.

    Relies on the caller having correctly allocated enough memory to hold
    these variable headers, which should have been done in
    UlComputeMaxVariableHeaderSize().

Arguments:

    ConnHeader - Supplies the type of Connection: header to generate.

    pContentLengthString - Supplies a header value for an optional
        Content-Length header. If this is the empty string "", then no
        Content-Length header is generated.

    ContentLengthStringLength - Supplies the length of the above string.

    pBuffer - Supplies the target buffer for the generated headers.

    pBytesCopied - Receives the number of header bytes generated.

    pDateTime - Receives the system time equivalent of the Date: header

--***************************************************************************/
VOID
UlGenerateVariableHeaders(
    IN  UL_CONN_HDR     ConnHeader,
    IN  BOOLEAN         GenerateDate,
    IN  PUCHAR          pContentLengthString,
    IN  ULONG           ContentLengthStringLength,
    OUT PUCHAR          pBuffer,
    OUT PULONG          pBytesCopied,
    OUT PLARGE_INTEGER  pDateTime
    )
{
    PHEADER_MAP_ENTRY pEntry;
    PUCHAR pStartBuffer;
    PUCHAR pCloseHeaderValue;
    ULONG CloseHeaderValueLength;
    ULONG BytesCopied;

    PAGED_CODE();

    ASSERT( pContentLengthString != NULL );
    ASSERT( pBuffer );
    ASSERT( pBytesCopied );
    ASSERT( pDateTime );

    pStartBuffer = pBuffer;

    //
    // generate Date: header
    //

    if (GenerateDate)
    {
        pEntry = &(g_ResponseHeaderMapTable[g_ResponseHeaderMap[HttpHeaderDate]]);

        RtlCopyMemory(
            pBuffer,
            pEntry->MixedCaseHeader,
            pEntry->HeaderLength
            );

        pBuffer += pEntry->HeaderLength;

        pBuffer[0] = SP;
        pBuffer += 1;

        BytesCopied = UlGenerateDateHeader( pBuffer, pDateTime );

        pBuffer += BytesCopied;

        ((UNALIGNED64 USHORT *)pBuffer)[0] = CRLF;
        pBuffer += sizeof(USHORT);
    }
    else
    {
        pDateTime->QuadPart = (LONGLONG) 0L;
    }

    //
    // generate Connection: header
    //

    switch (ConnHeader)
    {
    case ConnHdrNone:
        pCloseHeaderValue = NULL;
        CloseHeaderValueLength = 0;
        break;

    case ConnHdrClose:
        pCloseHeaderValue = (PUCHAR) CONN_CLOSE_HDR;
        CloseHeaderValueLength = CONN_CLOSE_HDR_LENGTH;
        break;

    case ConnHdrKeepAlive:
        pCloseHeaderValue = (PUCHAR) CONN_KEEPALIVE_HDR;
        CloseHeaderValueLength = CONN_KEEPALIVE_HDR_LENGTH;
        break;

    default:
        ASSERT(ConnHeader < ConnHdrMax);

        pCloseHeaderValue = NULL;
        CloseHeaderValueLength = 0;
        break;
    }

    if (pCloseHeaderValue != NULL)
    {
        pEntry = &(g_ResponseHeaderMapTable[g_ResponseHeaderMap[HttpHeaderConnection]]);

        RtlCopyMemory(
            pBuffer,
            pEntry->MixedCaseHeader,
            pEntry->HeaderLength
            );

        pBuffer += pEntry->HeaderLength;

        pBuffer[0] = SP;
        pBuffer += 1;

        RtlCopyMemory(
            pBuffer,
            pCloseHeaderValue,
            CloseHeaderValueLength
            );

        pBuffer += CloseHeaderValueLength;

        ((UNALIGNED64 USHORT *)pBuffer)[0] = CRLF;
        pBuffer += sizeof(USHORT);
    }

    if (pContentLengthString[0] != '\0')
    {
        ASSERT( ContentLengthStringLength > 0 );

        pEntry = &(g_ResponseHeaderMapTable[g_ResponseHeaderMap[HttpHeaderContentLength]]);

        RtlCopyMemory(
            pBuffer,
            pEntry->MixedCaseHeader,
            pEntry->HeaderLength
            );

        pBuffer += pEntry->HeaderLength;

        pBuffer[0] = SP;
        pBuffer += 1;

        RtlCopyMemory(
            pBuffer,
            pContentLengthString,
            ContentLengthStringLength
            );

        pBuffer += ContentLengthStringLength;

        ((UNALIGNED64 USHORT *)pBuffer)[0] = CRLF;
        pBuffer += sizeof(USHORT);
    }
    else
    {
        ASSERT( ContentLengthStringLength == 0 );
    }

    //
    // generate final CRLF
    //

    ((UNALIGNED64 USHORT *)pBuffer)[0] = CRLF;
    pBuffer += sizeof(USHORT);

    //
    // make sure we didn't use too much
    //

    BytesCopied = DIFF(pBuffer - pStartBuffer);
    *pBytesCopied = BytesCopied;

} // UlGenerateVariableHeaders



/*++

Routine Description:

    Append a header value to an existing HTTP_HEADER entry, allocating
    a buffer and copying the existing buffer.

Arguments:

    pHttpHeader     - Pointer to HTTP_HEADER structure to append to.
    pHeader         - Pointer header to be appended.
    HeaderLength    - Length of data pointed to by pHeader.

Return Value:

    TRUE if we succeed, FALSE otherwise.

--*/
NTSTATUS
UlAppendHeaderValue(
    PUL_INTERNAL_REQUEST    pRequest,
    PUL_HTTP_HEADER pHttpHeader,
    PUCHAR          pHeader,
    USHORT          HeaderLength
    )
{
    PUCHAR          pNewHeader, pOldHeader;
    USHORT          OldHeaderLength;

    PAGED_CODE();

    OldHeaderLength = pHttpHeader->HeaderLength;

    pNewHeader = UL_ALLOCATE_ARRAY(
                        NonPagedPool,
                        UCHAR,
                        OldHeaderLength + HeaderLength
                            + STRLEN_LIT(", ") + sizeof(CHAR),
                        HEADER_VALUE_POOL_TAG
                        );

    if (pNewHeader == NULL)
    {
        // Had a failure.
        return STATUS_NO_MEMORY;
    }

    //
    // Copy the old data into the new header.
    //
    RtlCopyMemory(pNewHeader, pHttpHeader->pHeader, OldHeaderLength);

    // And copy in the new data as well, seperated by a comma.
    //
    *(pNewHeader + OldHeaderLength) = ',';
    *(pNewHeader + OldHeaderLength + 1) = ' ';
    OldHeaderLength += STRLEN_LIT(", ");

    RtlCopyMemory( pNewHeader + OldHeaderLength, pHeader, HeaderLength);

    // Now replace the existing header.
    //
    pOldHeader = pHttpHeader->pHeader;
    pHttpHeader->HeaderLength = OldHeaderLength + HeaderLength;
    pHttpHeader->pHeader = pNewHeader;

    // If the old header was our buffer, free it too.
    //
    if (pHttpHeader->OurBuffer)
    {
        UL_FREE_POOL( pOldHeader, HEADER_VALUE_POOL_TAG );
    }

    pHttpHeader->OurBuffer = 1;

    //
    // null terminate it
    //

    pHttpHeader->pHeader[pHttpHeader->HeaderLength] = ANSI_NULL;

    pRequest->HeadersAppended = TRUE;

    return STATUS_SUCCESS;
}

/*++

Routine Description:

    The default routine for handling headers. Used when we don't want to
    do anything with the header but find out if we have the whole thing
    and save a pointer to it if we do.  This does not allow multiple header
    values to exist for this header.  Use UlMultipleHeaderHandler for
    handling that by appending the values together (CSV).

Arguments:

    pHttpConn       - HTTP connection on which this header was received.
    pHeader         - Pointer to the header value.
    HeaderLength    - Length of data pointed to by pHeader.
    HeaderID        - ID of the header.

Return Value:

    The length of the header value, or 0 if it's not terminated.

--*/
NTSTATUS
UlSingleHeaderHandler(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHeader,
    IN  USHORT                  HeaderLength,
    IN  HTTP_HEADER_ID          HeaderID,
    OUT PULONG                  pBytesTaken
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       BytesTaken;
    USHORT      HeaderValueLength;

    PAGED_CODE();

    // Find the end of the header value
    //
    Status = FindRequestHeaderEnd(pRequest, pHeader, HeaderLength, &BytesTaken);

    if (!NT_SUCCESS(Status))
        goto end;

    if (BytesTaken > 0)
    {
        ASSERT(BytesTaken <= ANSI_STRING_MAX_CHAR_LEN);

        // Strip off the trailing CRLF from the header value length
        HeaderValueLength = (USHORT) (BytesTaken - CRLF_SIZE);

        // skip any preceding LWS.

        while (HeaderValueLength > 0 && IS_HTTP_LWS(*pHeader))
        {
            pHeader++;
            HeaderValueLength--;
        }

        // remove any trailing LWS.

        while (HeaderValueLength > 0 && IS_HTTP_LWS(pHeader[HeaderValueLength-1]))
        {
            HeaderValueLength--;
        }

        // do we have an existing header?
        //
        if (pRequest->HeaderValid[HeaderID] == FALSE)
        {
            // No existing header, just save this pointer for now.
            //
            pRequest->HeaderIndex[pRequest->HeaderCount] = (UCHAR)HeaderID;
            pRequest->HeaderCount++;
            pRequest->HeaderValid[HeaderID] = TRUE;
            pRequest->Headers[HeaderID].HeaderLength = HeaderValueLength;
            pRequest->Headers[HeaderID].pHeader = pHeader;
            pRequest->Headers[HeaderID].OurBuffer = 0;

            //
            // null terminate it.  we have space as all headers end with CRLF.
            // we are over-writing the CR
            //

            pHeader[HeaderValueLength] = ANSI_NULL;

            //
            // make space for a terminator
            //

            pRequest->TotalRequestSize += (HeaderValueLength + 1) * sizeof(CHAR);

        }
        else
        {
            //
            // uh oh.  Have an existing header; ignore duplicate only if this
            // one exactly matches the first one.  See RAID: 466626
            //

            UlTrace(PARSER, (
                    "http!UlSingleHeaderHandler(pRequest = %p, pHeader = %p)\n"
                    "    WARNING: duplicate headers found.\n",
                    pRequest,
                    pHeader
                    ));
            
            //
            // null terminate it.  we have space as all headers end with CRLF.
            // we are over-writing the CR
            //
            
            pHeader[HeaderValueLength] = ANSI_NULL;

            //
            // If they aren't the same length or don't EXACTLY compare, fail
            // the request.
            //

            if ( (pRequest->Headers[HeaderID].HeaderLength != HeaderValueLength)
                || (HeaderValueLength != RtlCompareMemory(
                            pRequest->Headers[HeaderID].pHeader,
                            pHeader,
                            HeaderValueLength)) )
            {
                UlTraceError(PARSER, (
                        "http!UlSingleHeaderHandler(pRequest = %p, pHeader = %p)\n"
                        "    ERROR: mismatching duplicate headers found.\n",
                        pRequest,
                        pHeader
                        ));
                
                UlSetErrorCode(pRequest, UlErrorHeader, NULL);
                
                Status = STATUS_INVALID_DEVICE_REQUEST;
                goto end;
            }

        }

    }

    // Success!
    //
    *pBytesTaken = BytesTaken;

end:
    return Status;

}   // UlSingleHeaderHandler



/*++

Routine Description:

    The default routine for handling headers. Used when we don't want to
    do anything with the header but find out if we have the whole thing
    and save a pointer to it if we do.  This function handles multiple
    headers with the same name, and appends the values together separated
    by commas.

Arguments:

    pHttpConn       - HTTP connection on which this header was received.
    pHeader         - Pointer to the header value.
    HeaderLength    - Length of data pointed to by pHeader.
    HeaderID        - ID of the header.

Return Value:

    The length of the header value, or 0 if it's not terminated.

--*/
NTSTATUS
UlMultipleHeaderHandler(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHeader,
    IN  USHORT                  HeaderLength,
    IN  HTTP_HEADER_ID          HeaderID,
    OUT PULONG                  pBytesTaken
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       BytesTaken;
    USHORT      HeaderValueLength;

    PAGED_CODE();

    // Find the end of the header value
    //
    Status = FindRequestHeaderEnd(pRequest, pHeader, HeaderLength, &BytesTaken);

    if (!NT_SUCCESS(Status))
        goto end;

    if (BytesTaken > 0)
    {
        ASSERT(BytesTaken <= ANSI_STRING_MAX_CHAR_LEN);

        // Strip off the trailing CRLF from the header value length
        //
        HeaderValueLength = (USHORT) (BytesTaken - CRLF_SIZE);

        //
        // skip any preceding LWS.
        //

        while (HeaderValueLength > 0 && IS_HTTP_LWS(*pHeader))
        {
            pHeader++;
            HeaderValueLength--;
        }

        //
        // remove any trailing LWS.
        //

        while (HeaderValueLength > 0 && IS_HTTP_LWS(pHeader[HeaderValueLength-1]))
        {
            HeaderValueLength--;
        }

        // do we have an existing header?
        //
        if (pRequest->HeaderValid[HeaderID] == FALSE)
        {
            // No existing header, just save this pointer for now.
            //
            pRequest->HeaderIndex[pRequest->HeaderCount] = (UCHAR)HeaderID;
            pRequest->HeaderCount++;
            pRequest->HeaderValid[HeaderID] = TRUE;
            pRequest->Headers[HeaderID].HeaderLength = HeaderValueLength;
            pRequest->Headers[HeaderID].pHeader = pHeader;
            pRequest->Headers[HeaderID].OurBuffer = 0;

            //
            // null terminate it.  we have space as all headers end with CRLF.
            // we are over-writing the CR
            //

            pHeader[HeaderValueLength] = ANSI_NULL;

            //
            // make space for a terminator
            //

            pRequest->TotalRequestSize += (HeaderValueLength + 1) * sizeof(CHAR);

        }
        else
        {
            USHORT OldHeaderLength;

            // Have an existing header, append this one.

            OldHeaderLength = pRequest->Headers[HeaderID].HeaderLength;

            Status = UlAppendHeaderValue(
                            pRequest,
                            &pRequest->Headers[HeaderID],
                            pHeader,
                            HeaderValueLength
                            );

            if (NT_SUCCESS(Status) == FALSE)
                goto end;

            //
            // Update total request length for the amount we just added.
            // space for the terminator is already in there
            //

            pRequest->TotalRequestSize +=
                (pRequest->Headers[HeaderID].HeaderLength - OldHeaderLength) *
                    sizeof(CHAR);
        }
    }

    // Success!
    //
    *pBytesTaken = BytesTaken;

end:
    return Status;

}   // UlMultipleHeaderHandler



/*++

Routine Description:

    The routine for handling Accept headers. 

Arguments:

    pHttpConn       - HTTP connection on which this header was received.
    pHeader         - Pointer to the header value.
    HeaderLength    - Length of data pointed to by pHeader.
    HeaderID        - ID of the header.

Return Value:

    The length of the header value, or 0 if it's not terminated.
    Wildcard bit is set in the request if found

--*/
NTSTATUS
UlAcceptHeaderHandler(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHeader,
    IN  USHORT                  HeaderLength,
    IN  HTTP_HEADER_ID          HeaderID,
    OUT PULONG                  pBytesTaken
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       BytesTaken;
    USHORT      HeaderValueLength;

    PAGED_CODE();

    // Find the end of the header value
    //
    Status = FindRequestHeaderEnd(pRequest, pHeader, HeaderLength, &BytesTaken);

    if (!NT_SUCCESS(Status))
        goto end;

    if (BytesTaken > 0)
    {
        ASSERT(BytesTaken <= ANSI_STRING_MAX_CHAR_LEN);

        // Strip off the trailing CRLF from the header value length
        //
        HeaderValueLength = (USHORT) (BytesTaken - CRLF_SIZE);

        //
        // skip any preceding LWS.
        //

        while (HeaderValueLength > 0 && IS_HTTP_LWS(*pHeader))
        {
            pHeader++;
            HeaderValueLength--;
        }

        //
        // remove any trailing LWS.
        //

        while (HeaderValueLength > 0 && IS_HTTP_LWS(pHeader[HeaderValueLength-1]))
        {
            HeaderValueLength--;
        }

        // do we have an existing header?
        //
        if (pRequest->HeaderValid[HeaderID] == FALSE)
        {
            // No existing header, just save this pointer for now.
            //
            pRequest->HeaderIndex[pRequest->HeaderCount] = (UCHAR)HeaderID;
            pRequest->HeaderCount++;
            pRequest->HeaderValid[HeaderID] = TRUE;
            pRequest->Headers[HeaderID].HeaderLength = HeaderValueLength;
            pRequest->Headers[HeaderID].pHeader = pHeader;
            pRequest->Headers[HeaderID].OurBuffer = 0;

            //
            // null terminate it.  we have space as all headers end with CRLF.
            // we are over-writing the CR
            //

            pHeader[HeaderValueLength] = ANSI_NULL;

            //
            // make space for a terminator
            //

            pRequest->TotalRequestSize += (HeaderValueLength + 1) * sizeof(CHAR);

            if (HeaderValueLength > WILDCARD_SIZE)
            {

                // 
                // for the fast path, we'll check only */* at the end
                //

                if (
                    (*(UNALIGNED64 ULONG *) (&pHeader[HeaderValueLength - WILDCARD_SIZE]) == WILDCARD_SPACE) || 
                    (*(UNALIGNED64 ULONG *) (&pHeader[HeaderValueLength - WILDCARD_SIZE]) == WILDCARD_COMMA)
                   )
                {
                    pRequest->AcceptWildcard = TRUE;
                }
            }

        }
        else
        {
            ULONG OldHeaderLength;

            // Have an existing header, append this one.

            OldHeaderLength = pRequest->Headers[HeaderID].HeaderLength;

            Status = UlAppendHeaderValue(
                            pRequest,
                            &pRequest->Headers[HeaderID],
                            pHeader,
                            HeaderValueLength
                            );

            if (NT_SUCCESS(Status) == FALSE)
                goto end;

            //
            // Update total request length for the amount we just added.
            // space for the terminator is already in there
            //

            pRequest->TotalRequestSize +=
                (pRequest->Headers[HeaderID].HeaderLength - OldHeaderLength) *
                    sizeof(CHAR);

        }

    }

    // Success!
    //
    *pBytesTaken = BytesTaken;

end:
    return Status;

}   // UlAcceptHeaderHandler



/*++

Routine Description:

    The default routine for handling Host headers. Used when we don't want to
    do anything with the Host header but find out if we have the whole thing
    and save a pointer to it if we do.  this does not allow multiple Host header
    values to exist for this header.  use UlMultipleHeaderHandler for
    handling that by appending the values together (CSV) .

Arguments:

    pHttpConn       - HTTP connection on which this header was received.
    pHeader         - Pointer to the header value.
    HeaderLength    - Length of data pointed to by pHeader.
    HeaderID        - ID of the header.

Return Value:

    The length of the header value, or 0 if it's not terminated.

--*/
NTSTATUS
UlHostHeaderHandler(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHeader,
    IN  USHORT                  HeaderLength,
    IN  HTTP_HEADER_ID          HeaderID,
    OUT PULONG                  pBytesTaken
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       BytesTaken;
    USHORT      HeaderValueLength;
    SHORT       AddressType;

    PAGED_CODE();

    // Find the end of the header value

    Status = FindRequestHeaderEnd(pRequest, pHeader, HeaderLength, &BytesTaken);

    if (!NT_SUCCESS(Status))
        goto end;

    // Non-zero => Found the CRLF that terminates the header
    if (BytesTaken > 0)
    {
        ASSERT(BytesTaken <= ANSI_STRING_MAX_CHAR_LEN);

        // Strip off the trailing CRLF from the header value length

        HeaderValueLength = (USHORT) (BytesTaken - CRLF_SIZE);

        // skip any preceding LWS.

        while (HeaderValueLength > 0 && IS_HTTP_LWS(*pHeader))
        {
            pHeader++;
            HeaderValueLength--;
        }

        // remove any trailing LWS.

        while (HeaderValueLength > 0 && IS_HTTP_LWS(pHeader[HeaderValueLength-1]))
        {
            HeaderValueLength--;
        }

        // do we have an existing header?
        if (pRequest->HeaderValid[HeaderID] == FALSE)
        {
            // No existing header, just save this pointer for now.
            pRequest->HeaderIndex[pRequest->HeaderCount] = (UCHAR)HeaderID;
            pRequest->HeaderCount++;
            pRequest->HeaderValid[HeaderID] = TRUE;
            pRequest->Headers[HeaderID].HeaderLength = HeaderValueLength;
            pRequest->Headers[HeaderID].pHeader = pHeader;
            pRequest->Headers[HeaderID].OurBuffer = 0;

            //
            // null terminate it.  we have space as all headers end with CRLF.
            // we are over-writing the CR
            //

            pHeader[HeaderValueLength] = ANSI_NULL;

            //
            // make space for a terminator
            //

            pRequest->TotalRequestSize += (HeaderValueLength + 1) * sizeof(CHAR);

            // 
            // Now validate that the Host header has a well-formed value
            //

            Status = HttpValidateHostname(
                            &g_UrlC14nConfig,
                            pHeader,
                            HeaderValueLength,
                            Hostname_HostHeader,
                            &AddressType
                            );

            if (!NT_SUCCESS(Status))
            {
                UlSetErrorCode(pRequest, UlErrorHost, NULL);
                goto end;
            }
        }
        else
        {
            //
            // uh oh.  Have an existing Host header, fail the request.
            //

            UlTraceError(PARSER, (
                        "ul!UlHostHeaderHandler(pRequest = %p, pHeader = %p)\n"
                        "    ERROR: multiple headers not allowed.\n",
                        pRequest,
                        pHeader
                        ));

            UlSetErrorCode(pRequest, UlErrorHeader, NULL);

            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto end;
        }
    }

    // Success!
    //
    *pBytesTaken = BytesTaken;

end:
    return Status;

}   // UlHostHeaderHandler

/***************************************************************************++

Routine Description:

    Checks the request to see if it has any of the following headers:
      If-Modified-Since:
      If-Match:
      If-None-Match:

    If so, we see if we can skip the sending of the full item.  If we can skip,
    we send back the apropriate response of either 304 (not modified) or
    set the parser state to send back a 412 (precondition not met).

Arguments:

    pRequest - The request to check

    pUriCacheEntry - The cache entry being requested

Returns:

    0     Send cannot be skipped; continue with sending the cache entry.

    304   Send can be skipped.  304 response sent.  NOTE: pRequest may be
          invalid on return.

    400   Send can be skipped.  Caller must set ParseErrorState w/ErrorCode
          set to UlError

    412   Send can be skipped.  pRequest->ParseState set to ParseErrorState with
          pRequest->ErrorCode set to UlErrorPreconditionFailed (412)


--***************************************************************************/
ULONG
UlCheckCacheControlHeaders(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUL_URI_CACHE_ENTRY  pUriCacheEntry,
    IN BOOLEAN              ResumeParsing
    )
{
    ULONG RetStatus             = 0;    // Assume can't skip.
    BOOLEAN fIfNoneMatchPassed  = TRUE;
    BOOLEAN fSkipIfModifiedSince = FALSE;
    LARGE_INTEGER liModifiedSince;
    LARGE_INTEGER liUnmodifiedSince;
    LARGE_INTEGER liNow;
    ULONG         BytesSent     = 0;
    FIND_ETAG_STATUS EtagStatus;

    ASSERT( UL_IS_VALID_INTERNAL_REQUEST(pRequest) );
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );

    //
    // 1. Check If-Match
    //
    if ( pRequest->HeaderValid[HttpHeaderIfMatch] )
    {

        EtagStatus = FindInETagList( pUriCacheEntry->pETag,
                              pRequest->Headers[HttpHeaderIfMatch].pHeader,
                              FALSE);
        
        switch( EtagStatus )
        {
        case ETAG_NOT_FOUND:
            // Match failed.
            goto PreconditionFailed;
            
        case ETAG_PARSE_ERROR:
            goto ParseError;

        default: 
            break;
        }
    }

    //
    // 2. Check If-None-Match
    //
    if ( pRequest->HeaderValid[HttpHeaderIfNoneMatch] )
    {
        EtagStatus = FindInETagList( pUriCacheEntry->pETag,
                             pRequest->Headers[HttpHeaderIfNoneMatch].pHeader,
                             TRUE);
        switch( EtagStatus )
        {
        case ETAG_FOUND:
            // ETag found on list.
            fIfNoneMatchPassed = FALSE;
            break;

        case ETAG_NOT_FOUND:
            //
            // Header present and ETag not found on list.  This modifies
            // the semantic of the If-Modified-Since header; Namely,
            // If-None-Match takes precidence over If-Modified-Since.
            //
            fSkipIfModifiedSince = TRUE;
            break;

        case ETAG_PARSE_ERROR:
            goto ParseError;
        }
    }

    //
    // 3. Check If-Modified-Since
    //
    if ( !fSkipIfModifiedSince &&
         pRequest->HeaderValid[HttpHeaderIfModifiedSince] )
    {
        if ( StringTimeToSystemTime(
                (PCSTR) pRequest->Headers[HttpHeaderIfModifiedSince].pHeader,
                pRequest->Headers[HttpHeaderIfModifiedSince].HeaderLength,
                &liModifiedSince) )
        {
            //
            // If the cache entry was created before the
            // time specified in the If-Modified-Since header, we
            // can return a 304 (Not Modified) status.
            //
            if ( pUriCacheEntry->CreationTime.QuadPart <= liModifiedSince.QuadPart )
            {
                //
                // Check if the time specified in the request is
                // greater than the current time (i.e., Invalid).  If it is,
                // ignore the If-Modified-Since header.
                //
                KeQuerySystemTime(&liNow);

                if ( liModifiedSince.QuadPart < liNow.QuadPart )
                {
                    // Valid time.
                    goto NotModified;
                }
            }
        }
        else
        {
            //
            // if converting the If-Modified-Since header failed, we 
            // need to report the parse failure.
            //
            goto ParseError;
        }

        //
        // If-Modified-Since overrides If-None-Match.
        //
        fIfNoneMatchPassed = TRUE;

    }

    if ( !fIfNoneMatchPassed )
    {
        //
        // We could either skip the If-Modified-Since header, or it
        // was not present, AND we did not pass the If-None-Match
        // predicate.  Since this is a "GET" or "HEAD" request (because
        // that's all we cache, we should return 304.  If this were
        // any other verb, we should return 412.
        //
        ASSERT( (HttpVerbGET == pRequest->Verb) || (HttpVerbHEAD == pRequest->Verb) );
        goto NotModified;
    }

    //
    // 4. Check If-Unmodified-Since
    //
    if ( pRequest->HeaderValid[HttpHeaderIfUnmodifiedSince] )
    {
        if ( StringTimeToSystemTime(
                (PCSTR) pRequest->Headers[HttpHeaderIfUnmodifiedSince].pHeader,
                pRequest->Headers[HttpHeaderIfUnmodifiedSince].HeaderLength,
                &liUnmodifiedSince) )
        {
            //
            // If the cache entry was created after the time
            // specified in the If-Unmodified-Since header, we
            // MUST return a 412 (Precondition Failed) status.
            //
            if ( pUriCacheEntry->CreationTime.QuadPart > liUnmodifiedSince.QuadPart )
            {
                goto PreconditionFailed;
            }
        }
        else
        {
            //
            // if converting the If-Unmodified-Since header failed, we 
            // need to report the parse failure.
            //
            goto ParseError;
        }
    }


 Cleanup:

    return RetStatus;

 NotModified:

    RetStatus = 304;

    //
    // Send 304 (Not Modified) response
    //

    BytesSent = UlSendSimpleStatusEx(
                    pRequest,
                    UlStatusNotModified,
                    pUriCacheEntry,
                    ResumeParsing
                    );

    //
    // Update the server to client bytes sent.
    // The logging & perf counters will use it.
    //

    pRequest->BytesSent += BytesSent;

    goto Cleanup;

 PreconditionFailed:

    RetStatus = 412;

    goto Cleanup;

 ParseError:
    
    // Parse Error encountered.
    RetStatus = 400;

    goto Cleanup;

}   // UlCheckCacheControlHeaders


/***************************************************************************++

Routine Description:

    Checks the cached response against the "Accept:" header in the request
    to see if it can satisfy the requested Content-Type(s).

    (Yes, I know this is really gross...I encourage anyone to find a better
     way to parse this! --EricSten)

Arguments:

    pRequest - The request to check.

    pUriCacheEntry - The cache entry that might possibly match.

Returns:

    TRUE    At least one of the possible formats matched the Content-Type
            of the cached entry.

    FALSE   None of the requested types matched the Content-Type of the
            cached entry.

--***************************************************************************/
BOOLEAN
UlIsAcceptHeaderOk(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUL_URI_CACHE_ENTRY  pUriCacheEntry
    )
{
    BOOLEAN     bRet = TRUE;
    ULONG       Len;
    PUCHAR      pHdr;
    PUCHAR      pSubType;
    PUCHAR      pTmp;
    PUL_CONTENT_TYPE pContentType;

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry));

    if ( pRequest->HeaderValid[HttpHeaderAccept] &&
         (pRequest->Headers[HttpHeaderAccept].HeaderLength > 0) )
    {
        Len  = pRequest->Headers[HttpHeaderAccept].HeaderLength;
        pHdr = pRequest->Headers[HttpHeaderAccept].pHeader;

        pContentType = &pUriCacheEntry->ContentType;

        //
        // First, do "fast-path" check; see if "*/*" is anywhere in the header.
        //
        pTmp = (PUCHAR) strstr( (const char*) pHdr, "*/*" );

        //
        // If we found "*/*" and its either at the beginning of the line,
        // the end of the line, or surrounded by either ' ' or ',', then
        // it's really a wildcard.
        //

        if ((pTmp != NULL) &&
                ((pTmp == pHdr) ||
                 IS_HTTP_LWS(pTmp[-1]) ||
                 (pTmp[-1] == ',')) &&

                ((pTmp[3] == '\0') ||
                 IS_HTTP_LWS(pTmp[3]) ||
                 (pTmp[3] == ',')))
        {
            goto end;
        }

        //
        // Wildcard not found; continue with slow path
        //

        while (Len)
        {
            if (pContentType->TypeLen > Len)
            {
                // Bad! No more string left...Bail out.
                bRet = FALSE;
                goto end;
            }

            if ( (pContentType->TypeLen == RtlCompareMemory(
                                            pHdr,
                                            pContentType->Type,
                                            pContentType->TypeLen
                                            )) &&
                 ( '/' == pHdr[pContentType->TypeLen] ) )
            {
                //
                // Found matching type; check subtype
                //

                pSubType = &pHdr[pContentType->TypeLen + 1];

                if ( '*' == *pSubType )
                {
                    // Subtype wildcard match!
                    goto end;
                }
                else
                {
                    if ( pContentType->SubTypeLen >
                         (Len - ( pContentType->TypeLen + 1 )) )
                    {
                        // Bad!  No more string left...Bail out.
                        bRet = FALSE;
                        goto end;
                    }

                    if ( pContentType->SubTypeLen == RtlCompareMemory(
                                                    pSubType,
                                                    pContentType->SubType,
                                                    pContentType->SubTypeLen
                                                    ) &&
                         !IS_HTTP_TOKEN(pSubType[pContentType->SubTypeLen]) )
                    {
                        // Subtype exact match!
                        goto end;
                    }
                }
            }

            //
            // Didn't match this one; advance to next Content-Type in the Accept field
            //

            pTmp = (PUCHAR) strchr( (const char *) pHdr, ',' );
            if (pTmp)
            {
                // Found a comma; step over it and any whitespace.

                ASSERT ( Len > DIFF(pTmp - pHdr));
                Len -= (DIFF(pTmp - pHdr) +1);
                pHdr = (pTmp+1);

                while( Len && IS_HTTP_LWS(*pHdr) )
                {
                    pHdr++;
                    Len--;
                }

            } else
            {
                // No more content-types; bail.
                bRet = FALSE;
                goto end;
            }

        } // walk list of things

        //
        // Walked all Accept items and didn't find a match.
        //
        bRet = FALSE;
    }

 end:

    UlTrace(PARSER,
        ("UlIsAcceptHeaderOk: returning %s\n", 
        bRet ? "TRUE" : "FALSE" ));
    
    return bRet;

}   // UlIsAcceptHeaderOk



/***************************************************************************++

Routine Description:

    parses a content-type into its type and subtype components.

Arguments:

    pStr            String containing valid content type

    StrLen          Length of string (in bytes)

    pContentType    pointer to user provided UL_CONTENT_TYPE structure


--***************************************************************************/
VOID
UlGetTypeAndSubType(
    IN PCSTR            pStr,
    IN ULONG            StrLen,
    IN PUL_CONTENT_TYPE pContentType
    )
{
    PCHAR  pSlash;

    ASSERT(pStr && StrLen);
    ASSERT(pContentType);

    pSlash = strnchr(pStr, '/', StrLen);
    if ( NULL == pSlash ||
         pStr == pSlash ||
         (pSlash == (pStr + (StrLen-1))) )
    {
        //
        // BAD! 
        // 1. content types should always have a slash!
        // 2. content type can't have a null type
        // 3. content type can't have a null sub-type
        //
        return;
    }

    //
    // Minimal content type is "a/b"
    //
    ASSERT( StrLen >= 3 );

    pContentType->TypeLen = (ULONG) MIN( (pSlash - pStr), MAX_TYPE_LENGTH );

    RtlCopyMemory(
        pContentType->Type,
        pStr,
        pContentType->TypeLen
        );

    ASSERT( StrLen > (pContentType->TypeLen + 1) );
    pContentType->SubTypeLen = MIN( (StrLen - (pContentType->TypeLen + 1)), MAX_SUBTYPE_LENGTH );

    RtlCopyMemory(
        pContentType->SubType,
        pSlash+1,
        pContentType->SubTypeLen
        );
    
}   // UlGetTypeAndSubType
    
/*--
Routine Description:

    This function converts the enum verb type to string to the
    provided buffer. Used normally by the error logging. 
    Conversion happens as follows;

    For HttpVerbUnknown, pRequest->pRawVerb is copied over
    to the output buffer up to MAX_VERB_LENGTH characters.
    
    For others NewVerbTable is used.
        
Arguments:

    psz                 - Pointer to output buffer
    pHttpRequest        - Pointer to the incoming HTTP request.
    chTerminator        - Terminator will be written at the end.
    
Return Value:

    Pointer to the end of the copied space.

--*/

PCHAR
UlCopyHttpVerb(
    IN OUT PCHAR psz,
    IN PUL_INTERNAL_REQUEST pRequest,
    IN CHAR chTerminator    
    )
{
    //
    // Sanity check.
    //
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(pRequest->Verb < HttpVerbMaximum);

    if (pRequest->Verb == HttpVerbUnknown)
    {
        ULONG RawVerbLength = 
            MIN(MAX_VERB_LENGTH, pRequest->RawVerbLength);

        ASSERT(pRequest->pRawVerb && pRequest->RawVerbLength);
        
        RtlCopyMemory(
            psz,
            pRequest->pRawVerb,
            RawVerbLength
            );
    
        psz += RawVerbLength;        
    }
    else
    {
        //
        // Using the raw verb in the request should be fine.
        //

        RtlCopyMemory(
            psz,
            NewVerbTable[pRequest->Verb].RawVerb,
            NewVerbTable[pRequest->Verb].RawVerbLength
            );

        psz += NewVerbTable[pRequest->Verb].RawVerbLength;        
    }

    *psz = chTerminator;
    
    // Move past the terminator character unless it's a nul
    if (chTerminator != '\0')
        psz++;
        
    return psz;    
}

#if DBG

PCSTR
UlVerbToString(
    HTTP_VERB Verb
    )
{
    PAGED_CODE();

    switch (Verb)
    {
    case HttpVerbUnparsed:
        return "Unparsed";
    case HttpVerbUnknown:
        return "Unknown";
    case HttpVerbInvalid:
        return "Invalid";
    case HttpVerbOPTIONS:
        return "OPTIONS";
    case HttpVerbGET:
        return "GET";
    case HttpVerbHEAD:
        return "HEAD";
    case HttpVerbPOST:
        return "POST";
    case HttpVerbPUT:
        return "PUT";
    case HttpVerbDELETE:
        return "DELETE";
    case HttpVerbTRACE:
        return "TRACE";
    case HttpVerbCONNECT:
        return "CONNECT";
    case HttpVerbTRACK:
        return "TRACK";
    case HttpVerbMOVE:
        return "MOVE";
    case HttpVerbCOPY:
        return "COPY";
    case HttpVerbPROPFIND:
        return "PROPFIND";
    case HttpVerbPROPPATCH:
        return "PROPPATCH";
    case HttpVerbMKCOL:
        return "MKCOL";
    case HttpVerbLOCK:
        return "LOCK";
    case HttpVerbUNLOCK:
        return "UNLOCK";
    case HttpVerbSEARCH:
        return "SEARCH";
    default:
        ASSERT(! "Unrecognized HTTP_VERB");
        return "???";
    }
} // UlVerbToString



PCSTR
UlParseStateToString(
    PARSE_STATE ParseState
    )
{
    PAGED_CODE();

    switch (ParseState)
    {
    case ParseVerbState:
        return "Verb";
    case ParseUrlState:
        return "Url";
    case ParseVersionState:
        return "Version";
    case ParseHeadersState:
        return "Headers";
    case ParseCookState:
        return "Cook";
    case ParseEntityBodyState:
        return "EntityBody";
    case ParseTrailerState:
        return "Trailer";
    case ParseDoneState:
        return "Done";
    case ParseErrorState:
        return "Error";
    default:
        ASSERT(! "Unknown PARSE_STATE");
        return "?Unknown?";
    };

} // UlParseStateToString

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ultci.h ===
/*++

   Copyright (c) 2000-2002 Microsoft Corporation

   Module  Name :
       Ultci.h

   Abstract:
       This module implements a wrapper for QoS TC ( Traffic Control )
       Interface since the Kernel level API don't exist at this time.

       Any HTTP module might use this interface to make QoS calls.

   Author:
       Ali Ediz Turkoglu      (aliTu)     28-Jul-2000

   Project:
       Internet Information Server 6.0 - HTTP.SYS

   Revision History:

        -
--*/

#ifndef __ULTCI_H__
#define __ULTCI_H__


//
// UL does not use GPC_CF_CLASS_MAP client, all of the interfaces
// assumed to be using GPC_CF_QOS client type. And it's registered
// for all interfaces.
//

// #define MAX_STRING_LENGTH    (256) from traffic.h

//
// The interface objects get allocated during initialization.
// They hold the necessary information to create other
// QoS structures like flow & filter
//

typedef struct _UL_TCI_INTERFACE
{
    ULONG               Signature;                  // UL_TC_INTERFACE_POOL_TAG

    LIST_ENTRY          Linkage;                    // Linkage for the list of interfaces

    BOOLEAN             IsQoSEnabled;               // To see if QoS enabled or not for this interface

    ULONG               IfIndex;                    // Interface Index from TCPIP
    USHORT              NameLength;                 // Friendly name of the interface
    WCHAR               Name[MAX_STRING_LENGTH];
    USHORT              InstanceIDLength;           // ID from our WMI provider the beloved PSched
    WCHAR               InstanceID[MAX_STRING_LENGTH];

    LIST_ENTRY          FlowList;                   // List of site flows on this interface
    ULONG               FlowListSize;

    ULONG               AddrListBytesCount;         // Address list acquired from tc with Wmi call
    PADDRESS_LIST_DESCRIPTOR    pAddressListDesc;   // Points to a seperately allocated memory

#if REFERENCE_DEBUG
    //
    // Reference trace log.
    //

    PTRACE_LOG          pTraceLog;
#endif

} UL_TCI_INTERFACE, *PUL_TCI_INTERFACE;

#define IS_VALID_TCI_INTERFACE( entry )     \
    HAS_VALID_SIGNATURE(entry, UL_TCI_INTERFACE_POOL_TAG)


//
// The structure to hold the all of the flow related info.
// Each site may have one flow on each interface plus one
// extra global flow on each interface.
//

typedef struct _UL_TCI_FLOW
{
    ULONG               Signature;                  // UL_TC_FLOW_POOL_TAG

    HANDLE              FlowHandle;                 // Flow handle from TC

    LIST_ENTRY          Linkage;                    // Links us to flow list of "the interface"
                                                    // we have installed on

    PUL_TCI_INTERFACE   pInterface;                 // Back ptr to interface struc. Necessary to gather
                                                    // some information occasionally

    LIST_ENTRY          Siblings;                   // Links us to flow list of "the owner"
                                                    // In other words all the flows of the site or app.

    PVOID               pOwner;                     // Either points to a cgroup or a control channel
                                                    // For which we created the flow.

    TC_GEN_FLOW         GenFlow;                    // The details of the flowspec is stored in here

    UL_SPIN_LOCK        FilterListSpinLock;         // To LOCK the filterlist & its counter
    LIST_ENTRY          FilterList;                 // The list of filters on this flow
    ULONGLONG           FilterListSize;             // The number filters installed

} UL_TCI_FLOW, *PUL_TCI_FLOW;

#define IS_VALID_TCI_FLOW( entry )      \
    HAS_VALID_SIGNATURE(entry, UL_TCI_FLOW_POOL_TAG)


//
// The structure to hold the filter information.
// Each connection can only have one filter at a time.
//

typedef struct _UL_TCI_FILTER
{
    ULONG               Signature;                  // UL_TC_FILTER_POOL_TAG

    HANDLE              FilterHandle;               // GPC handle

    PUL_HTTP_CONNECTION pHttpConnection;            // For proper cleanup and
                                                    // to avoid the race conditions

    LIST_ENTRY          Linkage;                    // Next filter on the flow

} UL_TCI_FILTER, *PUL_TCI_FILTER;

#define IS_VALID_TCI_FILTER( entry )    \
    HAS_VALID_SIGNATURE(entry, UL_TCI_FILTER_POOL_TAG)

//
// To identify the local_loopbacks. This is a translation of
// 127.0.0.1.
//

#define LOOPBACK_ADDR       (0x0100007f)

//
// The functionality we expose to the other pieces.
//

/* Generic */

NTSTATUS
UlTcInitPSched(
    VOID
    );

BOOLEAN
UlTcPSchedInstalled(
    VOID
    );

/* Filters */

NTSTATUS
UlTcAddFilter(
    IN  PUL_HTTP_CONNECTION     pHttpConnection,
    IN  PVOID                   pOwner,
    IN  BOOLEAN                 Global      
    );

NTSTATUS
UlTcDeleteFilter(
    IN  PUL_HTTP_CONNECTION     pHttpConnection
    );

/* Flow manipulation */

NTSTATUS
UlTcAddFlows(
    IN PVOID                pOwner,
    IN HTTP_BANDWIDTH_LIMIT MaxBandwidth,
    IN BOOLEAN              Global
    );

NTSTATUS
UlTcModifyFlows(
    IN PVOID                pOwner,
    IN HTTP_BANDWIDTH_LIMIT MaxBandwidth,
    IN BOOLEAN              Global
    );

VOID
UlTcRemoveFlows(
    IN PVOID    pOwner,
    IN BOOLEAN  Global
    );

/* Init & Terminate */

NTSTATUS
UlTcInitialize(
    VOID
    );

VOID
UlTcTerminate(
    VOID
    );

/* Inline function to handle filter additions */

__inline
NTSTATUS
UlTcAddFilterForConnection(
    IN  PUL_HTTP_CONNECTION         pHttpConn,      /* connection */
    IN  PUL_URL_CONFIG_GROUP_INFO   pConfigInfo     /* request's config */
    )
{
    NTSTATUS                  Status = STATUS_SUCCESS;
    PUL_CONFIG_GROUP_OBJECT   pCGroup = NULL;
    PUL_CONTROL_CHANNEL       pControlChannel = NULL;
        
    //
    // Sanity Check.
    //
    
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConn));
    ASSERT(IS_VALID_URL_CONFIG_GROUP_INFO(pConfigInfo));

    //
    // No support for IPv6, however return success, we will still let
    // the connection in.
    //

    if (pHttpConn->pConnection->AddressType != TDI_ADDRESS_TYPE_IP)
    {        
        return STATUS_SUCCESS;
    }

    //
    // If exists enforce the site bandwidth limit.
    //
    
    pCGroup = pConfigInfo->pMaxBandwidth;

    if (BWT_ENABLED_FOR_CGROUP(pCGroup))
    {      
        ASSERT(IS_VALID_CONFIG_GROUP(pCGroup));
    
        Status = UlTcAddFilter(
                    pHttpConn,
                    pCGroup,
                    FALSE
                    );
    }
    else
    {
        //
        // Otherwise try to enforce the global (control channel) 
        // bandwidth limit.
        //
    
        pControlChannel = pConfigInfo->pControlChannel;
            
        ASSERT(IS_VALID_CONTROL_CHANNEL(pControlChannel));
        
        if (BWT_ENABLED_FOR_CONTROL_CHANNEL(pControlChannel))
        {            
            Status = UlTcAddFilter( 
                        pHttpConn, 
                        pControlChannel,
                        TRUE
                        );
        }
    }

    return Status;
}

#endif // __ULTCI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ulparsep.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    ulparsep.h

Abstract:

    Contains private definitions for ulparse.c.

Author:

    Henry Sanders (henrysa)       11-May-1998

Revision History:

    George V. Reilly (GeorgeRe)   03-May-2002
        Split apart from ulparse.h

--*/


#ifndef _ULPARSEP_H_
#define _ULPARSEP_H_

//
// Utility tokenizing routine.
//

NTSTATUS
UlpFindWSToken(
    IN  PUCHAR  pBuffer,
    IN  ULONG   BufferLength,
    OUT PUCHAR* ppTokenStart,
    OUT PULONG  pTokenLength
    );

NTSTATUS
UlpLookupVerb(
    IN OUT PUL_INTERNAL_REQUEST    pRequest,
    IN     PUCHAR                  pHttpRequest,
    IN     ULONG                   HttpRequestLength,
    OUT    PULONG                  pBytesTaken
    );

NTSTATUS
UlpParseFullUrl(
    IN  PUL_INTERNAL_REQUEST    pRequest
    );

ULONG
UlpFormatPort(
    OUT PWSTR pString,
    IN  ULONG Port
    );

// Call this only after the entire request has been parsed
//
NTSTATUS
UlpCookUrl(
    IN  PUL_INTERNAL_REQUEST    pRequest
    );

ULONG
UlpGenerateDateHeaderString(
    OUT PUCHAR pBuffer,
    IN LARGE_INTEGER systemTime
    );

#endif // _ULPARSEP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ultci.c ===
/*++

Copyright (c) 2000-2002 Microsoft Corporation

Module Name:

    ultci.c - UL TrafficControl Interface

Abstract:

    This module implements a wrapper for QoS TC (Traffic Control)
    Interface since the Kernel level API don't exist at this time.

    Any HTTP module can use this interface to invoke QoS calls.

Author:

    Ali Ediz Turkoglu (aliTu)       28-Jul-2000 Created a draft
                                                version

Revision History:

    Ali Ediz Turkoglu (aliTu)       03-11-2000  Modified to handle
                                                Flow & Filter (re)config
                                                as well as various other
                                                major changes.
--*/

#include "precomp.h"

LIST_ENTRY      g_TciIfcListHead = {NULL,NULL};
BOOLEAN         g_InitTciCalled  = FALSE;

//
// GPC handles to talk to
//

HANDLE          g_GpcFileHandle = NULL;     // result of CreateFile on GPC device
GPC_HANDLE      g_GpcClientHandle = NULL; // result of GPC client registration

//
// For querying the interface info like index & mtu size
//

HANDLE          g_TcpDeviceHandle = NULL;

//
// Shows if PSCHED is installed or not, protected by its 
// private push lock.
//

BOOLEAN         g_PSchedInstalled = FALSE;
UL_PUSH_LOCK    g_PSchedStatePushLock;

//
//  Optional Filter Stats
//

#if ENABLE_TC_STATS

typedef struct _TC_FILTER_STATS {

    LONG    Add;
    LONG    Delete;
    LONG    AddFailure;
    LONG    DeleteFailure;  

} TC_FILTER_STATS, *PTC_FILTER_STATS;

TC_FILTER_STATS g_TcStats = { 0, 0, 0, 0 };

#define INCREMENT_FILTER_ADD()                  \
    InterlockedIncrement( &g_TcStats.Add )

#define INCREMENT_FILTER_ADD_FAILURE()          \
    InterlockedIncrement( &g_TcStats.AddFailure )

#define INCREMENT_FILTER_DELETE()               \
    InterlockedIncrement( &g_TcStats.Delete )

#define INCREMENT_FILTER_DELETE_FAILURE()       \
    InterlockedIncrement( &g_TcStats.DeleteFailure )

#else

#define INCREMENT_FILTER_ADD()
#define INCREMENT_FILTER_ADD_FAILURE()
#define INCREMENT_FILTER_DELETE()
#define INCREMENT_FILTER_DELETE_FAILURE()

#endif

//
// For interface notifications
//

PVOID           g_TcInterfaceUpNotificationObject = NULL;
PVOID           g_TcInterfaceDownNotificationObject = NULL;
PVOID           g_TcInterfaceChangeNotificationObject = NULL;

//
// Simple macro for interface (ref) tracing.
// Actually we don't have the ref yet, but when
// and if we have we can use the 3rd param.
//

#define INT_TRACE(pTcIfc,Action)        \
    WRITE_REF_TRACE_LOG(                \
        (pTcIfc)->pTraceLog,            \
        REF_ACTION_ ## Action,          \
        0,                              \
        (pTcIfc),                       \
        __FILE__,                       \
        __LINE__                        \
        )


#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, UlTcInitialize)
#pragma alloc_text(PAGE, UlTcTerminate)
#pragma alloc_text(PAGE, UlpTcInitializeGpc)
#pragma alloc_text(PAGE, UlpTcRegisterGpcClient)
#pragma alloc_text(PAGE, UlpTcDeRegisterGpcClient)
#pragma alloc_text(PAGE, UlpTcGetFriendlyNames)
#pragma alloc_text(PAGE, UlpTcReleaseAll)
#pragma alloc_text(PAGE, UlpTcCloseInterface)
#pragma alloc_text(PAGE, UlpTcCloseAllInterfaces)
#pragma alloc_text(PAGE, UlpTcDeleteFlow)
#pragma alloc_text(PAGE, UlpAddFlow)
#pragma alloc_text(PAGE, UlpModifyFlow)
#pragma alloc_text(PAGE, UlTcAddFlows)
#pragma alloc_text(PAGE, UlTcModifyFlows)
#pragma alloc_text(PAGE, UlTcRemoveFlows)

#endif  // ALLOC_PRAGMA
#if 0

NOT PAGEABLE -- UlpRemoveFilterEntry
NOT PAGEABLE -- UlpInsertFilterEntry

#endif

//
// Init & Terminate stuff comes here.
//

/***************************************************************************++

Routine Description:

    UlTcInitialize :

        Will also initiate the Gpc client registration and make few WMI calls
        down to psched.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlTcInitialize (
    VOID
    )
{
    PAGED_CODE();

    ASSERT(!g_InitTciCalled);

    if (!g_InitTciCalled)
    {
        InitializeListHead(&g_TciIfcListHead);

        //
        // Init locks, they will be used until termination.
        //
        
        UlInitializePushLock(
            &g_pUlNonpagedData->TciIfcPushLock,
            "TciIfcPushLock",
            0,
            UL_TCI_PUSHLOCK_TAG
            );

        UlInitializePushLock(
            &g_PSchedStatePushLock,
            "PSchedStatePushLock",
            0,
            UL_PSCHED_STATE_PUSHLOCK_TAG
            );

        //
        // Attempt to init PSched and interface settings.
        // It may fail if Psched's not installed.
        //

        UlTcInitPSched();

        g_InitTciCalled = TRUE;        
    }

    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    Terminates the TCI module by releasing our TCI resource and
    cleaning up all the qos stuff.

--***************************************************************************/

VOID
UlTcTerminate(
    VOID
    )
{
    NTSTATUS Status;

    PAGED_CODE();

    if (g_InitTciCalled)
    {
        //
        // Terminate the PSched related global state
        //
        
        UlAcquirePushLockExclusive(&g_PSchedStatePushLock);

        if (g_PSchedInstalled)
        {
            //
            // No more Wmi callbacks for interface changes
            //

            if (g_TcInterfaceUpNotificationObject!=NULL)
            {
                ObDereferenceObject(g_TcInterfaceUpNotificationObject);
                g_TcInterfaceUpNotificationObject=NULL;
            }
            if(g_TcInterfaceDownNotificationObject!=NULL)
            {
                ObDereferenceObject(g_TcInterfaceDownNotificationObject);
                g_TcInterfaceDownNotificationObject = NULL;
            }

            if(g_TcInterfaceChangeNotificationObject!=NULL)
            {
                ObDereferenceObject(g_TcInterfaceChangeNotificationObject);
                g_TcInterfaceChangeNotificationObject = NULL;
            }

            //
            // Make sure to terminate all the QoS stuff.
            //

            Status = UlpTcReleaseAll();
            ASSERT(NT_SUCCESS(Status));

            if (g_TcpDeviceHandle != NULL)
            {
                ZwClose(g_TcpDeviceHandle);
                g_TcpDeviceHandle = NULL;
            }        
        }        
        
        g_PSchedInstalled = FALSE;
        g_InitTciCalled = FALSE;
        
        UlReleasePushLockExclusive(&g_PSchedStatePushLock);        

        //
        // Now terminate the global locks.
        //
        
        UlDeletePushLock( &g_pUlNonpagedData->TciIfcPushLock );

        UlDeletePushLock( &g_PSchedStatePushLock );        
    }

    UlTrace( TC, ("Http!UlTcTerminate.\n" ));
}

/***************************************************************************++

Routine Description:

    Try to init global tc state. Fails if PSched is not initialized.
    
Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlTcInitPSched(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    UlAcquirePushLockExclusive(&g_PSchedStatePushLock);

    if (g_PSchedInstalled)      // do not attempt to reinit
        goto cleanup;
    
    Status = UlpTcInitializeGpc();
    if (!NT_SUCCESS(Status))
    {
        UlTrace(TC, 
            ("Http!UlTcInitPSched: InitializeGpc FAILED %08lx \n", 
              Status ));
        goto cleanup;
    }    

    Status = UlpTcInitializeTcpDevice();
    if (!NT_SUCCESS(Status))
    {
        UlTrace(TC, 
            ("Http!UlTcInitPSched: InitializeTcp FAILED %08lx \n", 
              Status ));
        goto cleanup;
    }    

    Status = UlpTcGetFriendlyNames();
    if (!NT_SUCCESS(Status))
    {
        UlTrace(TC, 
            ("Http!UlTcInitialize: GetFriendlyNames FAILED %08lx \n", 
              Status ));    
        goto cleanup;
    }

    Status = UlpTcRegisterForCallbacks();
    if (!NT_SUCCESS(Status))
    {
        UlTrace(TC, 
            ("Http!UlTcInitialize: RegisterForCallbacks FAILED %08lx \n", 
              Status ));    
        goto cleanup;
    }

    //
    // Mark that PSched is installed & interface state is initialized !
    //

    g_PSchedInstalled = TRUE;

cleanup:

    if (!NT_SUCCESS(Status))
    {        
        //
        // Do not forget to deregister Gpc client
        // and close tcp device handle.
        //
        
        if (g_GpcClientHandle != NULL)
        {
            NTSTATUS TempStatus;

            TempStatus = UlpTcDeRegisterGpcClient();
            ASSERT(NT_SUCCESS(TempStatus));

            ASSERT(g_GpcFileHandle);
            ZwClose(g_GpcFileHandle);
            g_GpcFileHandle= NULL;
        }

        if (g_TcpDeviceHandle != NULL)
        {
            ZwClose(g_TcpDeviceHandle);
            g_TcpDeviceHandle=NULL;
        }
    }    

    UlReleasePushLockExclusive(&g_PSchedStatePushLock);
    
    UlTrace(TC, 
      ("Http!UlTcInitPSched: Initializing global Psched state. Status %08lx\n",
        Status
        ));
    
    return Status;
}

/***************************************************************************++

    To check whether packet scheduler is installed and global interface state
    is initialized properly or not. 

    Caller may decide to attempt to reinit the setting if we return FALSE.

--***************************************************************************/

BOOLEAN
UlTcPSchedInstalled(
    VOID
    )
{
    BOOLEAN Installed;
    
    //
    // Probe the value inside the lock.
    //
    
    UlAcquirePushLockShared(&g_PSchedStatePushLock);

    Installed = ( g_InitTciCalled && g_PSchedInstalled );

    UlReleasePushLockShared(&g_PSchedStatePushLock);

    return Installed;    
}

/***************************************************************************++

Routine Description:

    UlpTcInitializeGpc :

        It will open the Gpc file handle and attempt to register as Gpc
        client.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcInitializeGpc(
    VOID
    )
{
    NTSTATUS                Status;
    IO_STATUS_BLOCK         IoStatusBlock;
    UNICODE_STRING          GpcNameString;
    OBJECT_ATTRIBUTES       GpcObjAttribs;

    Status = STATUS_SUCCESS;

    //
    // Open Gpc Device Handle
    //

    Status = UlInitUnicodeStringEx(&GpcNameString, DD_GPC_DEVICE_NAME);

    if (!NT_SUCCESS(Status))
    {
        goto end;
    }

    InitializeObjectAttributes(&GpcObjAttribs,
                               &GpcNameString,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL
                                );

    Status = ZwCreateFile(&g_GpcFileHandle,
                           SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                          &GpcObjAttribs,
                          &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN_IF,
                           0,
                           NULL,
                           0
                           );

    if (!NT_SUCCESS(Status))
    {
        goto end;
    }

    ASSERT( g_GpcFileHandle != NULL );

    UlTrace( TC, ("Http!UlpTcInitializeGpc: Gpc Device Opened. %p\n",
                   g_GpcFileHandle ));

    //
    // Register as GPC_CF_QOS Gpc Client
    //

    Status = UlpTcRegisterGpcClient(GPC_CF_QOS);

end:
    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcRegisterGpcClient :

        Will build up the necessary structures and make a register call down
        to Gpc

Arguments:

    CfInfoType - Should be GPC_CF_QOS for our purposes.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcRegisterGpcClient(
    IN  ULONG   CfInfoType
    )
{
    NTSTATUS                Status;
    GPC_REGISTER_CLIENT_REQ GpcReq;
    GPC_REGISTER_CLIENT_RES GpcRes;
    ULONG                   InBuffSize;
    ULONG                   OutBuffSize;
    IO_STATUS_BLOCK         IoStatBlock;

    Status = STATUS_SUCCESS;

    if ( g_GpcFileHandle == NULL )
    {
        return STATUS_INVALID_PARAMETER;
    }

    InBuffSize  = sizeof(GPC_REGISTER_CLIENT_REQ);
    OutBuffSize = sizeof(GPC_REGISTER_CLIENT_RES);

    //
    // In HTTP we should only register for GPC_CF_QOS.
    //

    ASSERT(CfInfoType == GPC_CF_QOS);

    GpcReq.CfId  = CfInfoType;
    GpcReq.Flags = GPC_FLAGS_FRAGMENT;
    GpcReq.MaxPriorities = 1;
    GpcReq.ClientContext =  (GPC_CLIENT_HANDLE) 0;       // ???????? Possible BUGBUG ...
    //GpcReq.ClientContext = (GPC_CLIENT_HANDLE)GetCurrentProcessId(); // process id

    Status = UlpTcDeviceControl(g_GpcFileHandle,
                                NULL,
                                NULL,
                                NULL,
                               &IoStatBlock,
                                IOCTL_GPC_REGISTER_CLIENT,
                               &GpcReq,
                                InBuffSize,
                               &GpcRes,
                                OutBuffSize
                                );
    if (NT_SUCCESS(Status))
    {
        Status = GpcRes.Status;
        
        if (NT_SUCCESS(Status))
        {
            g_GpcClientHandle = GpcRes.ClientHandle;

            UlTrace(TC, 
                ("Http!UlpTcRegisterGpcClient: Gpc Client %p Registered.\n",
                  g_GpcClientHandle
                  ));        
        }
    }
    
    if (!NT_SUCCESS(Status))
    {
        g_GpcClientHandle = NULL;
        
        UlTrace(TC, 
          ("Http!UlpTcRegisterGpcClient: FAILURE %08lx \n", Status ));
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcDeRegisterGpcClient :

        Self explainatory.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcDeRegisterGpcClient(
    VOID
    )
{
    NTSTATUS                  Status;
    GPC_DEREGISTER_CLIENT_REQ GpcReq;
    GPC_DEREGISTER_CLIENT_RES GpcRes;
    ULONG                     InBuffSize;
    ULONG                     OutBuffSize;
    IO_STATUS_BLOCK           IoStatBlock;

    Status = STATUS_SUCCESS;

    if (g_GpcFileHandle == NULL && g_GpcClientHandle == NULL)
    {
        return STATUS_INVALID_PARAMETER;
    }

    InBuffSize  = sizeof(GPC_REGISTER_CLIENT_REQ);
    OutBuffSize = sizeof(GPC_REGISTER_CLIENT_RES);

    GpcReq.ClientHandle = g_GpcClientHandle;

    Status = UlpTcDeviceControl(g_GpcFileHandle,
                                NULL,
                                NULL,
                                NULL,
                               &IoStatBlock,
                                IOCTL_GPC_DEREGISTER_CLIENT,
                               &GpcReq,
                                InBuffSize,
                               &GpcRes,
                                OutBuffSize
                                );
    if (NT_SUCCESS(Status))
    {
        Status = GpcRes.Status;
        
        if (NT_SUCCESS(Status))
        {
            g_GpcClientHandle = NULL;

            UlTrace(TC, 
                ("Http!UlpTcDeRegisterGpcClient: Client Deregistered.\n" ));
        }
    }
    
    if (!NT_SUCCESS(Status))
    {        
        UlTrace(TC, 
            ("Http!UlpTcDeRegisterGpcClient: FAILURE %08lx \n", Status ));
    }
    
    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcInitializeTcpDevice :


Arguments:



Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcInitializeTcpDevice(
    VOID
    )
{
    NTSTATUS                Status;
    IO_STATUS_BLOCK         IoStatusBlock;
    UNICODE_STRING          TcpNameString;
    OBJECT_ATTRIBUTES       TcpObjAttribs;

    Status = STATUS_SUCCESS;

    //
    // Open Gpc Device
    //

    Status = UlInitUnicodeStringEx(&TcpNameString, DD_TCP_DEVICE_NAME);

    if ( !NT_SUCCESS(Status) )
    {
        goto end;
    }

    InitializeObjectAttributes(&TcpObjAttribs,
                               &TcpNameString,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL);

    Status = ZwCreateFile(   &g_TcpDeviceHandle,
                             GENERIC_EXECUTE,
                             &TcpObjAttribs,
                             &IoStatusBlock,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN_IF,
                             0,
                             NULL,
                             0);

    if ( !NT_SUCCESS(Status) )
    {
        goto end;
    }

    ASSERT( g_TcpDeviceHandle != NULL );

end:
    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcGetInterfaceIndex :

        Helper function to get the interface index from TCP for our internal
        interface structure.

Arguments:

    PUL_TCI_INTERFACE  pIntfc - The interface we will find the index for.

--***************************************************************************/

NTSTATUS
UlpTcGetInterfaceIndex(
    IN  PUL_TCI_INTERFACE  pIntfc
    )
{
    NTSTATUS                         Status;
    IPAddrEntry                      *pIpAddrTbl;
    ULONG                            IpAddrTblSize;
    ULONG                            k;
    IO_STATUS_BLOCK                  IoStatBlock;
    TDIObjectID                      *ID;
    TCP_REQUEST_QUERY_INFORMATION_EX trqiInBuf;
    ULONG                            InBuffLen;
    ULONG                            NumEntries;
    IPSNMPInfo                       IPSnmpInfo;
    NETWORK_ADDRESS UNALIGNED64    *pAddr;
    NETWORK_ADDRESS_IP UNALIGNED64 *pIpNetAddr = NULL;
    ULONG                           cAddr;
    ULONG                           index;

    //
    // Initialize & Sanity check first
    //

    Status     = STATUS_SUCCESS;
    NumEntries = 0;
    pIpAddrTbl = NULL;

    UlTrace(TC,("Http!UlpTcGetInterfaceIndex: ....\n" ));

    ASSERT( g_TcpDeviceHandle != NULL );

    if (!pIntfc->pAddressListDesc->AddressList.AddressCount)
    {
        return Status;
    }

    RtlZeroMemory(&trqiInBuf,sizeof(TCP_REQUEST_QUERY_INFORMATION_EX));
    InBuffLen  = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);

    ID = &(trqiInBuf.ID);

    ID->toi_entity.tei_entity   = CL_NL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_type                = INFO_TYPE_PROVIDER;

    for(;;) 
    {
        // First, get the count of addresses.
        
        ID->toi_id = IP_MIB_STATS_ID;
        Status = UlpTcDeviceControl(
                            g_TcpDeviceHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatBlock,
                            IOCTL_TCP_QUERY_INFORMATION_EX,
                            &trqiInBuf,
                            InBuffLen,
                            (PVOID)&IPSnmpInfo,
                            sizeof(IPSnmpInfo)
                            );

        if (!NT_SUCCESS(Status))
        {
            break;
        }

        // Allocate a private buffer to retrieve Ip Address table from TCP

        IpAddrTblSize = IPSnmpInfo.ipsi_numaddr * sizeof(IPAddrEntry);

        ASSERT(NULL == pIpAddrTbl);

        pIpAddrTbl = (IPAddrEntry *) UL_ALLOCATE_ARRAY(
                                PagedPool,
                                UCHAR,
                                IpAddrTblSize,
                                UL_TCI_GENERIC_POOL_TAG
                                );
        if (pIpAddrTbl == NULL)
        {
            Status = STATUS_NO_MEMORY;
            break;
        }
        RtlZeroMemory(pIpAddrTbl,IpAddrTblSize);

        // Now, get the addresses.

        ID->toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;
        Status = UlpTcDeviceControl(
                                g_TcpDeviceHandle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatBlock,
                                IOCTL_TCP_QUERY_INFORMATION_EX,
                                &trqiInBuf,
                                InBuffLen,
                                pIpAddrTbl,
                                IpAddrTblSize
                                );

        if(STATUS_BUFFER_OVERFLOW == Status)
        {
            // Someone has added a few more IP addresses. Let's re-do
            // the count query. Free the old buffer, we'll loop back & 
            // re-do the count query.
           
            UL_FREE_POOL(pIpAddrTbl, UL_TCI_GENERIC_POOL_TAG);
            pIpAddrTbl = NULL;
        }
        else
        {
            break;
        }
    }


    if(NT_SUCCESS(Status))
    {
        // Look at how many entries were written to the output buffer 
        // (pIpAddrTbl)

        NumEntries = (((ULONG)IoStatBlock.Information)/sizeof(IPAddrEntry));

        UlTrace(TC,
                ("Http!UlpTcGetInterfaceIndex: NumEntries %d\n", NumEntries ));

        //
        // Search for the matching IP address to IpAddr
        // in the table we got back from the stack
        //
        for (k=0; k<NumEntries; k++)
        {
            cAddr = pIntfc->pAddressListDesc->AddressList.AddressCount;
            pAddr = (UNALIGNED64 NETWORK_ADDRESS *) 
                        &pIntfc->pAddressListDesc->AddressList.Address[0];

            for (index = 0; index < cAddr; index++)
            {
                if (pAddr->AddressType == NDIS_PROTOCOL_ID_TCP_IP)
                {
                    pIpNetAddr = 
                        (UNALIGNED64 NETWORK_ADDRESS_IP *)&pAddr->Address[0];

                    if(pIpNetAddr->in_addr == pIpAddrTbl[k].iae_addr)
                    {
                        pIntfc->IfIndex = pIpAddrTbl[k].iae_index;

                        UlTrace(TC,
                           ("Http!UlpTcGetInterfaceIndex: got for index %d\n",
                           pIntfc->IfIndex ));

                        goto end;
                    }
                }

                pAddr = (UNALIGNED64 NETWORK_ADDRESS *)(((PUCHAR)pAddr)
                                           + pAddr->AddressLength
                                   + FIELD_OFFSET(NETWORK_ADDRESS, Address));
            }
        }
    }
    else
    {
       UlTrace(TC,("Http!UlpTcGetInterfaceIndex: FAILED Status %08lx\n",
                    Status));
    }

end:
    if ( pIpAddrTbl != NULL )
    {
        UL_FREE_POOL( pIpAddrTbl, UL_TCI_GENERIC_POOL_TAG );
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    Allocates a interface structure from the given arguments.

    Marks the interface enabled, if its address count is non-zero.
    
Argument:

    DescSize    Address list desc size in bytes
    Desc        Pointer to address list desc

    NameLength  Length is in bytes
    Name        Interface Name (Unicode buffer)

    InstanceIDLength    Length is in bytes.
    InstanceID  Instance Id is also unicode buffer

Return Value:

    PUL_TCI_INTERFACE - Newly allocated interface structure

--***************************************************************************/

PUL_TCI_INTERFACE
UlpTcAllocateInterface(
    IN ULONG    DescSize,
    IN PADDRESS_LIST_DESCRIPTOR Desc,
    IN ULONG    NameLength,
    IN PUCHAR   Name,
    IN ULONG    InstanceIDLength,
    IN PUCHAR   InstanceID
    )
{
    PUL_TCI_INTERFACE pTcIfc;

    //
    // Sanity Checks
    //

    PAGED_CODE();

    ASSERT(NameLength <= MAX_STRING_LENGTH);
    ASSERT(InstanceIDLength <= MAX_STRING_LENGTH);

    if (NameLength > MAX_STRING_LENGTH ||
        InstanceIDLength > MAX_STRING_LENGTH)
    {
        return NULL;
    }
    
    //
    // Allocate a new interface structure & initialize it
    //

    pTcIfc = UL_ALLOCATE_STRUCT(
                        PagedPool,
                        UL_TCI_INTERFACE,
                        UL_TCI_INTERFACE_POOL_TAG
                        );
    if ( pTcIfc == NULL )
    {
        return NULL;
    }

    RtlZeroMemory( pTcIfc, sizeof(UL_TCI_INTERFACE) );

    pTcIfc->Signature = UL_TCI_INTERFACE_POOL_TAG;

    InitializeListHead( &pTcIfc->FlowList );

    // Variable size addresslist

    pTcIfc->pAddressListDesc = (PADDRESS_LIST_DESCRIPTOR)
                    UL_ALLOCATE_ARRAY(
                            PagedPool,
                            UCHAR,
                            DescSize,
                            UL_TCI_INTERFACE_POOL_TAG
                            );
    if ( pTcIfc->pAddressListDesc == NULL )
    {
        UL_FREE_POOL_WITH_SIG(pTcIfc, UL_TCI_INTERFACE_POOL_TAG);
        return NULL;
    }

    CREATE_REF_TRACE_LOG( 
            pTcIfc->pTraceLog,
            96 - REF_TRACE_OVERHEAD,
            0, 
            TRACELOG_LOW_PRIORITY,
            UL_TCI_INTERFACE_REF_TRACE_LOG_POOL_TAG 
            );

    INT_TRACE(pTcIfc, TC_ALLOC);
    
    pTcIfc->AddrListBytesCount = DescSize;

    // Copy the instance name string data

    RtlCopyMemory(pTcIfc->Name,Name,NameLength);

    pTcIfc->NameLength = (USHORT)NameLength;
    pTcIfc->Name[NameLength/sizeof(WCHAR)] = UNICODE_NULL;

    // Copy the instance ID string data

    RtlCopyMemory(pTcIfc->InstanceID,InstanceID,InstanceIDLength);

    pTcIfc->InstanceIDLength = (USHORT)InstanceIDLength;
    pTcIfc->InstanceID[InstanceIDLength/sizeof(WCHAR)] = UNICODE_NULL;

    // Copy the Description data and extract the corresponding ip address

    RtlCopyMemory(pTcIfc->pAddressListDesc, Desc, DescSize);

    // IP Address of the interface is hidden in this desc data
    // we will find out and save it for faster lookup.

    pTcIfc->IsQoSEnabled = (BOOLEAN)
        (pTcIfc->pAddressListDesc->AddressList.AddressCount != 0);

    return pTcIfc;
}

/***************************************************************************++

Routine Description:

    Frees up the
    
        - Adress list descriptor
        - RefTrace log
        - The interface structure
    
Argument:

    pTcIfc Pointer to the interface struct.    

--***************************************************************************/

VOID
UlpTcFreeInterface(
    IN OUT PUL_TCI_INTERFACE  pTcIfc
    )
{
    PAGED_CODE();

    //
    // Do the cleanup.
    //
    
    if (pTcIfc)
    {
        DESTROY_REF_TRACE_LOG(
            pTcIfc->pTraceLog,
            UL_TCI_INTERFACE_REF_TRACE_LOG_POOL_TAG
            );
            
        if (pTcIfc->pAddressListDesc)
        {
            UL_FREE_POOL(pTcIfc->pAddressListDesc,
                         UL_TCI_INTERFACE_POOL_TAG
                         );
        }

        UL_FREE_POOL_WITH_SIG(pTcIfc, UL_TCI_INTERFACE_POOL_TAG);
    }
}

/***************************************************************************++

Routine Description:

    Make a Wmi Querry to get the firendly names of all interfaces.
    Its basically replica of the tcdll enumerate interfaces call.

    This function also allocates the global interface list. If it's not
    successfull it doesn't though.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcGetFriendlyNames(
    VOID
    )
{
    NTSTATUS            Status;
    PVOID               WmiObject;
    ULONG               MyBufferSize;
    PWNODE_ALL_DATA     pWnode;
    PWNODE_ALL_DATA     pWnodeBuffer;
    PUL_TCI_INTERFACE   pTcIfc;
    GUID                QoSGuid;
    PLIST_ENTRY         pEntry;
    PUL_TCI_INTERFACE   pInterface;

    //
    // Initialize defaults
    //

    Status       = STATUS_SUCCESS;
    WmiObject    = NULL;
    pWnodeBuffer = NULL;
    pTcIfc       = NULL;
    MyBufferSize = UL_DEFAULT_WMI_QUERY_BUFFER_SIZE;
    QoSGuid      = GUID_QOS_TC_SUPPORTED;

    //
    // Get a WMI block handle to the GUID_QOS_SUPPORTED
    //

    Status = IoWMIOpenBlock( (GUID *) &QoSGuid, 0, &WmiObject );

    if (!NT_SUCCESS(Status))
    {
        if (Status == STATUS_WMI_GUID_NOT_FOUND)
        {
            // This means there is no TC data provider (which's Psched)

            UlTrace(
                    TC,
                    ("Http!UlpTcGetFriendlyNames: PSCHED hasn't been "
                     "installed !\n"));
                }
        else
        {
            UlTrace(
                    TC,
                    ("Http!UlpTcGetFriendlyNames:IoWMIOpenBlock FAILED Status "
                     "%08lx\n", Status));
        }
        return Status;
    }

    do
    {
        //
        // Allocate a private buffer to retrieve all wnodes
        //

        pWnodeBuffer = (PWNODE_ALL_DATA) UL_ALLOCATE_ARRAY(
                            NonPagedPool,
                            UCHAR,
                            MyBufferSize,
                            UL_TCI_WMI_POOL_TAG
                            );
        if (pWnodeBuffer == NULL)
        {
            ObDereferenceObject(WmiObject);
            return STATUS_NO_MEMORY;
        }

        __try
        {
            Status = IoWMIQueryAllData(WmiObject, &MyBufferSize, pWnodeBuffer);

            UlTrace( TC,
                ("Http!UlpTcGetFriendlyNames: IoWMIQueryAllData Status %08lx\n",
                  Status
                  ));
        }
        __except ( UL_EXCEPTION_FILTER() )
        {
            Status = GetExceptionCode();
        }

        if (Status == STATUS_BUFFER_TOO_SMALL)
        {
            //
            // Failed since the buffer was too small.
            // Release the buffer and double the size.
            //

            MyBufferSize *= 2;
            UL_FREE_POOL( pWnodeBuffer, UL_TCI_WMI_POOL_TAG );
            pWnodeBuffer = NULL;
        }

    } while (Status == STATUS_BUFFER_TOO_SMALL);

    if (NT_SUCCESS(Status))
    {
        ULONG   dwInstanceNum;
        ULONG   InstanceSize = 0;
        PULONG  lpdwNameOffsets;
        BOOLEAN bFixedSize = FALSE;
        USHORT  usNameLength;
        ULONG   DescSize;
        PTC_SUPPORTED_INFO_BUFFER pTcInfoBuffer = NULL;

        pWnode = pWnodeBuffer;

        ASSERT(pWnode->WnodeHeader.Flags & WNODE_FLAG_ALL_DATA);

        do
        {
            //
            // Check for fixed instance size
            //

            if (pWnode->WnodeHeader.Flags & WNODE_FLAG_FIXED_INSTANCE_SIZE)
            {

                InstanceSize  = pWnode->FixedInstanceSize;
                bFixedSize    = TRUE;
                pTcInfoBuffer =
                    (PTC_SUPPORTED_INFO_BUFFER)OffsetToPtr(
                                         pWnode,
                                         pWnode->DataBlockOffset);
            }

            //
            //  Get a pointer to the array of offsets to the instance names
            //

            lpdwNameOffsets = (PULONG) OffsetToPtr(
                                            pWnode,
                                            pWnode->OffsetInstanceNameOffsets);

            for ( dwInstanceNum = 0;
                  dwInstanceNum < pWnode->InstanceCount;
                  dwInstanceNum++ )
            {
                usNameLength = *(PUSHORT)OffsetToPtr(
                                            pWnode,
                                            lpdwNameOffsets[dwInstanceNum]);

                //
                //  Length and offset for variable data
                //

                if ( !bFixedSize )
                {
                    InstanceSize =
                        pWnode->OffsetInstanceDataAndLength[
                            dwInstanceNum].LengthInstanceData;

                    pTcInfoBuffer = (PTC_SUPPORTED_INFO_BUFFER)
                        OffsetToPtr(
                                   (PBYTE)pWnode,
                                   pWnode->OffsetInstanceDataAndLength[
                                        dwInstanceNum].OffsetInstanceData);
                }

                //
                // We have all that is needed.
                //

                ASSERT(usNameLength < MAX_STRING_LENGTH);

                DescSize = InstanceSize - FIELD_OFFSET(
                                                      TC_SUPPORTED_INFO_BUFFER, 
                                                      AddrListDesc
                                                      );

                //
                // Allocate a new interface structure & initialize it with
                // the wmi data we have acquired.
                //

                pTcIfc = UlpTcAllocateInterface(
                            DescSize,
                            &pTcInfoBuffer->AddrListDesc,
                            usNameLength,
                            (PUCHAR) OffsetToPtr(
                                         pWnode,
                                         lpdwNameOffsets[dwInstanceNum] + 
                                         sizeof(USHORT)),
                            pTcInfoBuffer->InstanceIDLength,
                            (PUCHAR) &pTcInfoBuffer->InstanceID[0]
                            );
                if ( pTcIfc == NULL )
                {
                    Status = STATUS_NO_MEMORY;
                    goto end;
                }

                //
                // Get the interface index from TCP
                //

                Status = UlpTcGetInterfaceIndex( pTcIfc );
                ASSERT(NT_SUCCESS(Status));

                //
                // Add this interface to the global interface list
                //

                UlAcquirePushLockExclusive(&g_pUlNonpagedData->TciIfcPushLock);

                InsertTailList(&g_TciIfcListHead, &pTcIfc->Linkage );

                UlReleasePushLockExclusive(&g_pUlNonpagedData->TciIfcPushLock);

                //
                // Set to Null so we don't try to cleanup after we insert it
                // to the global list.
                //

                pTcIfc = NULL;
            }

            //
            //  Update Wnode to point to next node
            //

            if ( pWnode->WnodeHeader.Linkage != 0)
            {
                pWnode = (PWNODE_ALL_DATA) OffsetToPtr( pWnode,
                                                        pWnode->WnodeHeader.Linkage);
            }
            else
            {
                pWnode = NULL;
            }
        }
        while ( pWnode != NULL && NT_SUCCESS(Status) );

        UlTrace(TC,("Http!UlpTcGetFriendlyNames: got all the names.\n"));
    }

end:
    if (!NT_SUCCESS(Status))
    {
        UlTrace(TC,("Http!UlpTcGetFriendlyNames: FAILED Status %08lx\n",
                     Status
                     ));
        if (pTcIfc)
        {
            UlpTcFreeInterface( pTcIfc );
        }

        //
        // Cleanup the partially done interface list if not empty
        //

        while ( !IsListEmpty( &g_TciIfcListHead ) )
        {
            pEntry = g_TciIfcListHead.Flink;
            pInterface = CONTAINING_RECORD( pEntry,
                                            UL_TCI_INTERFACE,
                                            Linkage
                                            );
            RemoveEntryList( pEntry );
            UlpTcFreeInterface( pInterface );
        }
    }

    //
    // Release resources and close WMI handle
    //

    if (WmiObject != NULL)
    {
        ObDereferenceObject(WmiObject);
    }

    if (pWnodeBuffer)
    {
        UL_FREE_POOL(pWnodeBuffer, UL_TCI_WMI_POOL_TAG);
    }

    return Status;
}

/***************************************************************************++

Routine Description:

  UlpTcReleaseAll :

    Close all interfaces, all flows and all filters.
    Also deregister GPC clients and release all TC ineterfaces.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcReleaseAll(
    VOID
    )
{
    NTSTATUS Status;

    //
    // Close all interfaces their flows & filters
    //

    UlpTcCloseAllInterfaces();

    //
    // DeRegister the QoS GpcClient
    //

    Status = UlpTcDeRegisterGpcClient();

    if (!NT_SUCCESS(Status))
    {
        UlTrace( TC, ("Http!UlpTcReleaseAll: FAILURE %08lx \n", Status ));
    }

    //
    // Finally close our gpc file handle
    //

    ZwClose(g_GpcFileHandle);

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcCloseAllInterfaces :

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcCloseAllInterfaces(
    VOID
    )
{
    NTSTATUS            Status;
    PLIST_ENTRY         pEntry;
    PUL_TCI_INTERFACE   pInterface;

    Status = STATUS_SUCCESS;

    UlAcquirePushLockExclusive(&g_pUlNonpagedData->TciIfcPushLock);

    //
    // Close all interfaces in our global list
    //

    while ( !IsListEmpty( &g_TciIfcListHead ) )
    {
        pEntry = g_TciIfcListHead.Flink;

        pInterface = CONTAINING_RECORD( pEntry,
                                        UL_TCI_INTERFACE,
                                        Linkage
                                        );
        UlpTcCloseInterface( pInterface );

        RemoveEntryList( pEntry );

        UlpTcFreeInterface( pInterface );
    }

    UlReleasePushLockExclusive(&g_pUlNonpagedData->TciIfcPushLock);

    return Status;
}

/***************************************************************************++

Routine Description:

    Cleans up all the flows on the interface.

Arguments:

    pInterface - to be closed

--***************************************************************************/

NTSTATUS
UlpTcCloseInterface(
    PUL_TCI_INTERFACE   pInterface
    )
{
    NTSTATUS        Status;
    PLIST_ENTRY     pEntry;
    PUL_TCI_FLOW    pFlow;

    PAGED_CODE();
    
    ASSERT(IS_VALID_TCI_INTERFACE(pInterface));

    INT_TRACE(pInterface, TC_CLOSE);

    //
    // Go clean up all flows for the interface and remove itself as well
    //

    Status = STATUS_SUCCESS;

    while (!IsListEmpty(&pInterface->FlowList))
    {
        pEntry= pInterface->FlowList.Flink;

        pFlow = CONTAINING_RECORD(
                            pEntry,
                            UL_TCI_FLOW,
                            Linkage
                            );

        ASSERT(IS_VALID_TCI_FLOW(pFlow));

        //
        // Remove flow from the corresponding owner's flowlist
        // as well. Owner pointer should not be null for a flow.
        //

        ASSERT_FLOW_OWNER(pFlow->pOwner);
        
        RemoveEntryList(&pFlow->Siblings);
        pFlow->Siblings.Flink = pFlow->Siblings.Blink = NULL;
        pFlow->pOwner = NULL;

        //
        // Now remove from the interface.
        //

        Status = UlpTcDeleteFlow(pFlow);

        //
        // Above call may fail,if GPC removes the flow based on PSCHED's
        // notification before we get a chance to close our GPC handle.
        //
    }

    UlTrace(TC,("Http!UlpTcCloseInterface: All flows deleted on Ifc @ %p\n",
                  pInterface ));

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcWalkWnode :


Arguments:

    ... the WMI provided data buffer ...

--***************************************************************************/

NTSTATUS
UlpTcWalkWnode(
   IN PWNODE_HEADER pWnodeHdr,
   IN PUL_TC_NOTIF_HANDLER pNotifHandler
   )
{
    NTSTATUS        Status;
    PWCHAR          NamePtr;
    USHORT          NameSize;
    PUCHAR          DataBuffer;
    ULONG           DataSize;
    ULONG           Flags;
    PULONG          NameOffset;

    //
    // Try to capture the data frm WMI Buffer
    //

    ASSERT(pNotifHandler);

    Status = STATUS_SUCCESS;
    Flags  = pWnodeHdr->Flags;

    if (Flags & WNODE_FLAG_ALL_DATA)
    {
        //
        // WNODE_ALL_DATA structure has multiple interfaces
        //

        PWNODE_ALL_DATA pWnode = (PWNODE_ALL_DATA)pWnodeHdr;
        ULONG   Instance;

        UlTrace(TC,("Http!UlpTcWalkWnode: ALL_DATA ... \n" ));

        NameOffset = (PULONG) OffsetToPtr(pWnode,
                                          pWnode->OffsetInstanceNameOffsets );
        DataBuffer = (PUCHAR) OffsetToPtr(pWnode,
                                          pWnode->DataBlockOffset);

        for (Instance = 0;
             Instance < pWnode->InstanceCount;
             Instance++)
        {
            //  Instance Name

            NamePtr = (PWCHAR) OffsetToPtr(pWnode,NameOffset[Instance] + sizeof(USHORT));
            NameSize = * (PUSHORT) OffsetToPtr(pWnode,NameOffset[Instance]);

            //  Instance Data

            if ( Flags & WNODE_FLAG_FIXED_INSTANCE_SIZE )
            {
                DataSize = pWnode->FixedInstanceSize;
            }
            else
            {
                DataSize =
                    pWnode->OffsetInstanceDataAndLength[Instance].LengthInstanceData;
                DataBuffer =
                    (PUCHAR)OffsetToPtr(pWnode,
                                        pWnode->OffsetInstanceDataAndLength[Instance].OffsetInstanceData);
            }

            // Call the handler

            pNotifHandler( NamePtr, NameSize, (PTC_INDICATION_BUFFER) DataBuffer, DataSize );
        }
    }
    else if (Flags & WNODE_FLAG_SINGLE_INSTANCE)
    {
        //
        // WNODE_SINGLE_INSTANCE structure has only one instance
        //

        PWNODE_SINGLE_INSTANCE  pWnode = (PWNODE_SINGLE_INSTANCE)pWnodeHdr;

        if (Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES)
        {
            return STATUS_SUCCESS;
        }

        UlTrace(TC,("Http!UlpTcWalkWnode: SINGLE_INSTANCE ... \n" ));

        NamePtr = (PWCHAR)OffsetToPtr(pWnode,pWnode->OffsetInstanceName + sizeof(USHORT));
        NameSize = * (USHORT *) OffsetToPtr(pWnode,pWnode->OffsetInstanceName);

        //  Instance Data

        DataSize   = pWnode->SizeDataBlock;
        DataBuffer = (PUCHAR)OffsetToPtr (pWnode, pWnode->DataBlockOffset);

        // Call the handler

        pNotifHandler( NamePtr, NameSize, (PTC_INDICATION_BUFFER) DataBuffer, DataSize );

    }
    else if (Flags & WNODE_FLAG_SINGLE_ITEM)
    {
        //
        // WNODE_SINGLE_ITEM is almost identical to single_instance
        //

        PWNODE_SINGLE_ITEM  pWnode = (PWNODE_SINGLE_ITEM)pWnodeHdr;

        if (Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES)
        {
            return STATUS_SUCCESS;
        }

        UlTrace(TC,("Http!UlpTcWalkWnode: SINGLE_ITEM ... \n" ));

        NamePtr = (PWCHAR)OffsetToPtr(pWnode,pWnode->OffsetInstanceName + sizeof(USHORT));
        NameSize = * (USHORT *) OffsetToPtr(pWnode, pWnode->OffsetInstanceName);

        //  Instance Data

        DataSize   = pWnode->SizeDataItem;
        DataBuffer = (PUCHAR)OffsetToPtr (pWnode, pWnode->DataBlockOffset);

        // Call the handler

        pNotifHandler( NamePtr, NameSize, (PTC_INDICATION_BUFFER) DataBuffer, DataSize );

    }

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcHandleIfcUp :

        This functions handles the interface change notifications.
        We register for the corresponding notifications during init.

Arguments:

    PVOID Wnode - PSched data provided with WMI way

--***************************************************************************/

VOID
UlpTcHandleIfcUp(
    IN PWSTR Name,
    IN ULONG NameSize,
    IN PTC_INDICATION_BUFFER pTcBuffer,
    IN ULONG BufferSize
    )
{
    NTSTATUS Status;
    ULONG AddrListDescSize;
    PTC_SUPPORTED_INFO_BUFFER pTcInfoBuffer;
    PUL_TCI_INTERFACE pTcIfc;
    PUL_TCI_INTERFACE pTcIfcTemp;
    PLIST_ENTRY       pEntry;

    Status = STATUS_SUCCESS;

    UlTrace(TC,("Http!UlpTcHandleIfcUp: Adding %ws %d\n", Name, BufferSize ));
    
    UlAcquirePushLockExclusive(&g_pUlNonpagedData->TciIfcPushLock);

    //
    // Allocate a new interface structure for the newcoming interface
    //

    AddrListDescSize = BufferSize
                       - FIELD_OFFSET(TC_INDICATION_BUFFER,InfoBuffer)
                       - FIELD_OFFSET(TC_SUPPORTED_INFO_BUFFER, AddrListDesc);

    UlTrace(TC,("Http!UlpTcHandleIfcUp: AddrListDescSize %d\n", AddrListDescSize ));

    pTcInfoBuffer = & pTcBuffer->InfoBuffer;

    pTcIfc = UlpTcAllocateInterface(
                            AddrListDescSize,
                            &pTcInfoBuffer->AddrListDesc,
                            NameSize,
                            (PUCHAR) Name,
                            pTcInfoBuffer->InstanceIDLength,
                            (PUCHAR) &pTcInfoBuffer->InstanceID[0]
                            );
    if ( pTcIfc == NULL )
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    UL_DUMP_TC_INTERFACE( pTcIfc );

    //
    // If we are receiving a notification for an interface already exist then
    // drop this call. Prevent global interface list corruption if we receive
    // inconsistent notifications. But there may be multiple interfaces with
    // same zero IPs.
    //

    pEntry = g_TciIfcListHead.Flink;
    while ( pEntry != &g_TciIfcListHead )
    {
        pTcIfcTemp = CONTAINING_RECORD( pEntry, UL_TCI_INTERFACE, Linkage );
        if (wcsncmp(pTcIfcTemp->Name, pTcIfc->Name, NameSize/sizeof(WCHAR))==0)
        {
            ASSERT(!"Conflict in the global interface list !");
            Status = STATUS_CONFLICTING_ADDRESSES;
            goto end;
        }
        pEntry = pEntry->Flink;
    }

    //
    // Get the interface index from TCP.
    //

    Status = UlpTcGetInterfaceIndex( pTcIfc );
    if (!NT_SUCCESS(Status))
        goto end;

    //
    // Insert to the global interface list
    //

    InsertTailList( &g_TciIfcListHead, &pTcIfc->Linkage );

    INT_TRACE(pTcIfc, TC_UP);

end:
    if (!NT_SUCCESS(Status))
    {
        UlTrace(TC,("Http!UlpTcHandleIfcUp: FAILURE %08lx \n", Status ));

        if (pTcIfc != NULL)
        {
            UlpTcFreeInterface(pTcIfc);
        }
    }

    UlReleasePushLockExclusive(&g_pUlNonpagedData->TciIfcPushLock);

    return;
}
/***************************************************************************++

Routine Description:

    UlpTcHandleIfcDown :

        This functions handles the interface change notifications.
        We register for the corresponding notifications during init.

Arguments:

    PVOID Wnode - PSched data provided with WMI way

--***************************************************************************/

VOID
UlpTcHandleIfcDown(
    IN PWSTR Name,
    IN ULONG NameSize,
    IN PTC_INDICATION_BUFFER pTcBuffer,
    IN ULONG BufferSize
    )
{
    NTSTATUS Status;
    PUL_TCI_INTERFACE pTcIfc;
    PUL_TCI_INTERFACE pTcIfcTemp;
    PLIST_ENTRY       pEntry;

    UNREFERENCED_PARAMETER(pTcBuffer);
    UNREFERENCED_PARAMETER(BufferSize);
    
    Status = STATUS_SUCCESS;

    UlTrace(TC,("Http!UlpTcHandleIfcDown: Removing %ws\n", Name ));

    UlAcquirePushLockExclusive(&g_pUlNonpagedData->TciIfcPushLock);

    //
    // Find the corresponding ifc structure we keep.
    //

    pTcIfc = NULL;
    pEntry = g_TciIfcListHead.Flink;
    while ( pEntry != &g_TciIfcListHead )
    {
        pTcIfcTemp = CONTAINING_RECORD( pEntry, UL_TCI_INTERFACE, Linkage );
        if ( wcsncmp(pTcIfcTemp->Name, Name, NameSize) == 0 )
        {
            pTcIfc = pTcIfcTemp;
            break;
        }
        pEntry = pEntry->Flink;
    }

    if (pTcIfc == NULL)
    {
        ASSERT(FALSE);
        Status = STATUS_NOT_FOUND;
        goto end;
    }

    INT_TRACE(pTcIfc, TC_DOWN);

    //
    // Remove this interface and its flows etc ...
    //

    UlpTcCloseInterface( pTcIfc );

    RemoveEntryList( &pTcIfc->Linkage );

    UlpTcFreeInterface( pTcIfc );

end:
    if (!NT_SUCCESS(Status))
    {
        UlTrace(TC,("Http!UlpTcHandleIfcDown: FAILURE %08lx \n", Status ));
    }

    UlReleasePushLockExclusive(&g_pUlNonpagedData->TciIfcPushLock);

    return;
}

/***************************************************************************++

Routine Description:

    UlpTcHandleIfcChange :

        This functions handles the interface change notifications.
        We register for the corresponding notifications during init.

Arguments:

    PVOID Wnode - PSched data provided with WMI way

--***************************************************************************/

VOID
UlpTcHandleIfcChange(
    IN PWSTR Name,
    IN ULONG NameSize,
    IN PTC_INDICATION_BUFFER pTcBuffer,
    IN ULONG BufferSize
    )
{
    NTSTATUS Status;
    ULONG AddrListDescSize;
    PTC_SUPPORTED_INFO_BUFFER pTcInfoBuffer;
    PUL_TCI_INTERFACE pTcIfc;
    PUL_TCI_INTERFACE pTcIfcTemp;
    PLIST_ENTRY       pEntry;
    PADDRESS_LIST_DESCRIPTOR pAddressListDesc;

    Status = STATUS_SUCCESS;

    UlTrace(TC,("Http!UlpTcHandleIfcChange: Updating %ws\n", Name ));
    
    UlAcquirePushLockExclusive(&g_pUlNonpagedData->TciIfcPushLock);

    AddrListDescSize = BufferSize
                       - FIELD_OFFSET(TC_INDICATION_BUFFER,InfoBuffer)
                       - FIELD_OFFSET(TC_SUPPORTED_INFO_BUFFER, AddrListDesc);

    pTcInfoBuffer = & pTcBuffer->InfoBuffer;

    // Find the corresponding ifc structure we keep.

    pTcIfc = NULL;
    pEntry = g_TciIfcListHead.Flink;
    while ( pEntry != &g_TciIfcListHead )
    {
        pTcIfcTemp = CONTAINING_RECORD( pEntry, UL_TCI_INTERFACE, Linkage );
        if ( wcsncmp(pTcIfcTemp->Name, Name, NameSize) == 0 )
        {
            pTcIfc = pTcIfcTemp;
            break;
        }
        pEntry = pEntry->Flink;
    }

    if (pTcIfc == NULL)
    {
        ASSERT(FALSE);
        Status = STATUS_NOT_FOUND;
        goto end;
    }

    INT_TRACE(pTcIfc, TC_CHANGE);

    // Instance id

    RtlCopyMemory(pTcIfc->InstanceID,
                  pTcInfoBuffer->InstanceID,
                  pTcInfoBuffer->InstanceIDLength
                  );
    pTcIfc->InstanceIDLength = pTcInfoBuffer->InstanceIDLength;
    pTcIfc->InstanceID[pTcIfc->InstanceIDLength/sizeof(WCHAR)] = UNICODE_NULL;

    // The Description data and extract the corresponding ip address
    // ReWrite the fresh data. Size of the description data might be changed
    // so wee need to dynamically allocate it everytime changes

    pAddressListDesc =
            (PADDRESS_LIST_DESCRIPTOR) UL_ALLOCATE_ARRAY(
                            PagedPool,
                            UCHAR,
                            AddrListDescSize,
                            UL_TCI_INTERFACE_POOL_TAG
                            );
    if ( pAddressListDesc == NULL )
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    if (pTcIfc->pAddressListDesc)
    {
        UL_FREE_POOL(pTcIfc->pAddressListDesc,UL_TCI_INTERFACE_POOL_TAG);
    }

    pTcIfc->pAddressListDesc   = pAddressListDesc;
    pTcIfc->AddrListBytesCount = AddrListDescSize;

    RtlCopyMemory( pTcIfc->pAddressListDesc,
                  &pTcInfoBuffer->AddrListDesc,
                   AddrListDescSize
                   );

    // IP Address of the interface is hidden in this desc data

    pTcIfc->IsQoSEnabled = (BOOLEAN)
        (pTcIfc->pAddressListDesc->AddressList.AddressCount != 0);

    // ReFresh the interface index from TCP.

    Status = UlpTcGetInterfaceIndex( pTcIfc );
    if (!NT_SUCCESS(Status))
        goto end;

end:
    if (!NT_SUCCESS(Status))
    {
        UlTrace(TC,("Http!UlpTcHandleIfcChange: FAILURE %08lx \n", Status ));
    }

    UlReleasePushLockExclusive(&g_pUlNonpagedData->TciIfcPushLock);

    return;
}

/***************************************************************************++

Routine Description:

    UlTcNotifyCallback :

        This callback functions handles the interface change notifications.
        We register for the corresponding notifications during init.

Arguments:

    PVOID Wnode - PSched data provided with WMI way

--***************************************************************************/

VOID
UlTcNotifyCallback(
    IN PVOID pWnode,
    IN PVOID Context
    )
{
    GUID *pGuid;
    PWNODE_HEADER pWnodeHeader;

    UNREFERENCED_PARAMETER(Context);

    UlTrace( TC, ("Http!UlTcNotifyCallback: ... \n" ));

    pWnodeHeader = (PWNODE_HEADER) pWnode;
    pGuid = &pWnodeHeader->Guid;

    if (UL_COMPARE_QOS_NOTIFICATION(pGuid,&GUID_QOS_TC_INTERFACE_UP_INDICATION))
    {
        UlpTcWalkWnode( pWnodeHeader, UlpTcHandleIfcUp );
    }
    else if
    (UL_COMPARE_QOS_NOTIFICATION(pGuid, &GUID_QOS_TC_INTERFACE_DOWN_INDICATION))
    {
        UlpTcWalkWnode( pWnodeHeader, UlpTcHandleIfcDown );
    }
    else if
    (UL_COMPARE_QOS_NOTIFICATION(pGuid, &GUID_QOS_TC_INTERFACE_CHANGE_INDICATION))
    {
        UlpTcWalkWnode( pWnodeHeader, UlpTcHandleIfcChange );
    }

    UlTrace( TC, ("Http!UlTcNotifyCallback: Handled.\n" ));
}

/***************************************************************************++

Routine Description:

    UlpTcRegisterForCallbacks :

        We will open Block object until termination for each type of
        notification. And we will deref each object upon termination

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcRegisterForCallbacks(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    GUID     Guid;

    //
    // Get a WMI block handle register all the callback functions.
    //

    Guid   = GUID_QOS_TC_INTERFACE_UP_INDICATION;
    Status = IoWMIOpenBlock(&Guid,
                            WMIGUID_NOTIFICATION,
                            &g_TcInterfaceUpNotificationObject
                            );
    if (NT_SUCCESS(Status))
    {
        Status = IoWMISetNotificationCallback(
                     g_TcInterfaceUpNotificationObject,
                     (WMI_NOTIFICATION_CALLBACK) UlTcNotifyCallback,
                     NULL
                     );
        if (!NT_SUCCESS(Status))
            goto end;
    }

    Guid   = GUID_QOS_TC_INTERFACE_DOWN_INDICATION;
    Status = IoWMIOpenBlock(&Guid,
                            WMIGUID_NOTIFICATION,
                            &g_TcInterfaceDownNotificationObject
                            );
    if (NT_SUCCESS(Status))
    {
        Status = IoWMISetNotificationCallback(
                     g_TcInterfaceDownNotificationObject,
                     (WMI_NOTIFICATION_CALLBACK) UlTcNotifyCallback,
                     NULL
                     );
        if (!NT_SUCCESS(Status))
            goto end;
    }

    Guid   = GUID_QOS_TC_INTERFACE_CHANGE_INDICATION;
    Status = IoWMIOpenBlock(&Guid,
                            WMIGUID_NOTIFICATION,
                            &g_TcInterfaceChangeNotificationObject
                            );
    if (NT_SUCCESS(Status))
    {
        Status = IoWMISetNotificationCallback(
                     g_TcInterfaceChangeNotificationObject,
                     (WMI_NOTIFICATION_CALLBACK) UlTcNotifyCallback,
                     NULL
                     );
        if (!NT_SUCCESS(Status))
            goto end;
    }

end:
    // Cleanup if necessary

    if (!NT_SUCCESS(Status))
    {
        UlTrace(TC,("Http!UlpTcRegisterForCallbacks: FAILED %08lx\n",Status));

        if(g_TcInterfaceUpNotificationObject!=NULL)
        {
            ObDereferenceObject(g_TcInterfaceUpNotificationObject);
            g_TcInterfaceUpNotificationObject = NULL;
        }

        if(g_TcInterfaceDownNotificationObject!=NULL)
        {
            ObDereferenceObject(g_TcInterfaceDownNotificationObject);
            g_TcInterfaceDownNotificationObject = NULL;
        }

        if(g_TcInterfaceChangeNotificationObject!=NULL)
        {
            ObDereferenceObject(g_TcInterfaceChangeNotificationObject);
            g_TcInterfaceChangeNotificationObject = NULL;
        }
    }

    return Status;
}

//
// Following functions provide public/private interfaces for flow & filter
// creation/removal/modification for site & global flows.
//

/***************************************************************************++

Routine Description:

    UlpTcDeleteFlow :

        you should own the TciIfcPushLock exclusively before calling
        this function

Arguments:


Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcDeleteFlow(
    IN PUL_TCI_FLOW         pFlow
    )
{
    NTSTATUS                Status;
    PLIST_ENTRY             pEntry;
    PUL_TCI_FILTER          pFilter;
    HANDLE                  FlowHandle;
    PUL_TCI_INTERFACE       pInterface;

    //
    // Initialize
    //

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    ASSERT(g_InitTciCalled);

    ASSERT(IS_VALID_TCI_FLOW(pFlow));

    //
    // First remove all the filters belong to us
    //

    while (!IsListEmpty(&pFlow->FilterList))
    {
        pEntry = pFlow->FilterList.Flink;

        pFilter = CONTAINING_RECORD(
                            pEntry,
                            UL_TCI_FILTER,
                            Linkage
                            );

        Status = UlpTcDeleteFilter( pFlow, pFilter );
        ASSERT(NT_SUCCESS(Status));
    }

    //
    // Now remove the flow itself from our flowlist on the interface
    //

    pInterface = pFlow->pInterface;
    ASSERT( pInterface != NULL );

    RemoveEntryList( &pFlow->Linkage );

    ASSERT(pInterface->FlowListSize > 0);
    pInterface->FlowListSize -= 1;

    pFlow->Linkage.Flink = pFlow->Linkage.Blink = NULL;

    FlowHandle = pFlow->FlowHandle;

    UlTrace( TC, ("Http!UlpTcDeleteFlow: Flow deleted. %p\n", pFlow  ));

    UL_FREE_POOL_WITH_SIG( pFlow, UL_TCI_FLOW_POOL_TAG );

    //
    // Finally talk to TC
    //

    Status = UlpTcDeleteGpcFlow( FlowHandle );

    if (!NT_SUCCESS(Status))
    {
        UlTrace(TC, ("Http!UlpTcDeleteFlow: FAILURE %08lx \n", 
                        Status ));
    }
    else
    {
        UlTrace(TC, 
           ("Http!UlpTcDeleteFlow: FlowHandle %d deleted in TC as well.\n",
             FlowHandle
             ));
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcDeleteFlow :

        remove a flow from existing QoS Enabled interface

Arguments:



Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcDeleteGpcFlow(
    IN HANDLE  FlowHandle
    )
{
    NTSTATUS                Status;
    ULONG                   InBuffSize;
    ULONG                   OutBuffSize;
    GPC_REMOVE_CF_INFO_REQ  GpcReq;
    GPC_REMOVE_CF_INFO_RES  GpcRes;
    IO_STATUS_BLOCK         IoStatusBlock;

    //
    // Remove the flow frm psched
    //

    InBuffSize =  sizeof(GPC_REMOVE_CF_INFO_REQ);
    OutBuffSize = sizeof(GPC_REMOVE_CF_INFO_RES);

    GpcReq.ClientHandle    = g_GpcClientHandle;
    GpcReq.GpcCfInfoHandle = FlowHandle;

    Status = UlpTcDeviceControl( g_GpcFileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_GPC_REMOVE_CF_INFO,
                            &GpcReq,
                            InBuffSize,
                            &GpcRes,
                            OutBuffSize
                            );
    if (NT_SUCCESS(Status))
    {
        Status = GpcRes.Status;
    }
    
    if (!NT_SUCCESS(Status))
    {                  
        UlTrace(TC, 
           ("Http!UlpTcDeleteGpcFlow: FAILURE %08lx \n", Status ));
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcAllocateFlow :

        Allocates a flow and setup the FlowSpec according the passed BWT
        parameter

Arguments:

    HTTP_BANDWIDTH_LIMIT - FlowSpec will be created using this BWT limit
                           in B/s

Return Value

    PUL_TCI_FLOW - The newly allocated flow
    NULL         - If memory allocation failed

--***************************************************************************/

PUL_TCI_FLOW
UlpTcAllocateFlow(
    IN HTTP_BANDWIDTH_LIMIT MaxBandwidth
    )
{
    PUL_TCI_FLOW            pFlow;
    TC_GEN_FLOW             TcGenFlow;

    //
    // Setup the FlowSpec frm MaxBandwidth passed by the config handler
    //

    RtlZeroMemory(&TcGenFlow,sizeof(TcGenFlow));

    UL_SET_FLOWSPEC(TcGenFlow,MaxBandwidth);

    //
    // Since we hold a spinlock inside the flow structure allocating from
    // NonPagedPool. We will have this allocation only for bt enabled sites.
    //

    pFlow = UL_ALLOCATE_STRUCT(
                NonPagedPool,
                UL_TCI_FLOW,
                UL_TCI_FLOW_POOL_TAG
                );
    if( pFlow == NULL )
    {
        return NULL;
    }

    // Initialize the rest

    RtlZeroMemory( pFlow, sizeof(UL_TCI_FLOW) );

    pFlow->Signature = UL_TCI_FLOW_POOL_TAG;

    pFlow->GenFlow   = TcGenFlow;

    UlInitializeSpinLock( &pFlow->FilterListSpinLock, "FilterListSpinLock" );
    InitializeListHead( &pFlow->FilterList );

    pFlow->pOwner = NULL;

    return pFlow;
}

/***************************************************************************++

Routine Description:

    UlpModifyFlow :

        Modify an existing flow by sending an IOCTL down to GPC. Basically
        what this function does is to provide an updated TC_GEN_FLOW field
        to GPC for an existing flow.

Arguments:

    PUL_TCI_INTERFACE - Required to get the interfaces friendly name.

    PUL_TCI_FLOW      - To get the GPC flow handle as well as to be able to
                        update the new flow parameters.

--***************************************************************************/

NTSTATUS
UlpModifyFlow(
    IN  PUL_TCI_INTERFACE   pInterface,
    IN  PUL_TCI_FLOW        pFlow
    )
{
    PCF_INFO_QOS            Kflow;
    PGPC_MODIFY_CF_INFO_REQ pGpcReq;
    GPC_MODIFY_CF_INFO_RES  GpcRes;
    ULONG                   InBuffSize;
    ULONG                   OutBuffSize;

    IO_STATUS_BLOCK         IoStatusBlock;
    NTSTATUS                Status;

    //
    // Sanity check
    //

    PAGED_CODE();

    ASSERT(g_GpcClientHandle);
    ASSERT(IS_VALID_TCI_INTERFACE(pInterface));
    ASSERT(IS_VALID_TCI_FLOW(pFlow));

    InBuffSize  = sizeof(GPC_MODIFY_CF_INFO_REQ) + sizeof(CF_INFO_QOS);
    OutBuffSize = sizeof(GPC_MODIFY_CF_INFO_RES);

    pGpcReq = UL_ALLOCATE_STRUCT_WITH_SPACE(
                    PagedPool,
                    GPC_MODIFY_CF_INFO_REQ,
                    sizeof(CF_INFO_QOS),
                    UL_TCI_GENERIC_POOL_TAG
                    );
    if (pGpcReq == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(pGpcReq, InBuffSize);
    RtlZeroMemory(&GpcRes, OutBuffSize);

    pGpcReq->ClientHandle    = g_GpcClientHandle;
    pGpcReq->GpcCfInfoHandle = pFlow->FlowHandle;
    pGpcReq->CfInfoSize      = sizeof(CF_INFO_QOS);

    Kflow = (PCF_INFO_QOS)&pGpcReq->CfInfo;
    Kflow->InstanceNameLength = (USHORT) pInterface->NameLength;

    RtlCopyMemory(Kflow->InstanceName,
                  pInterface->Name,
                  pInterface->NameLength* sizeof(WCHAR));

    RtlCopyMemory(&Kflow->GenFlow,
                  &pFlow->GenFlow,
                  sizeof(TC_GEN_FLOW));

    Status = UlpTcDeviceControl( g_GpcFileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_GPC_MODIFY_CF_INFO,
                            pGpcReq,
                            InBuffSize,
                            &GpcRes,
                            OutBuffSize
                            );
    if (NT_SUCCESS(Status))
    {
        Status = GpcRes.Status;
    }
    
    if (!NT_SUCCESS(Status))
    {        
        UlTrace( TC, ("Http!UlpModifyFlow: FAILURE %08lx\n",
                        Status
                        ));
    }
    else
    {
        UlTrace( TC, ("Http!UlpModifyFlow: flow %p modified on interface %p \n",
                        pFlow,
                        pInterface
                        ));    
    }
    
    UL_FREE_POOL( pGpcReq, UL_TCI_GENERIC_POOL_TAG );

    return Status;
}

/***************************************************************************++

Routine Description:

    Builds the GPC structure and tries to add a QoS flow.

    Updates the handle if call is successfull.
    
Arguments:

    pInterface      
    pGenericFlow
    pHandle

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpAddFlow(
    IN  PUL_TCI_INTERFACE   pInterface,
    IN  PUL_TCI_FLOW        pGenericFlow,
    OUT PHANDLE             pHandle
    )
{
    NTSTATUS                Status;
    PCF_INFO_QOS            Kflow;
    PGPC_ADD_CF_INFO_REQ    pGpcReq;
    GPC_ADD_CF_INFO_RES     GpcRes;
    ULONG                   InBuffSize;
    ULONG                   OutBuffSize;
    IO_STATUS_BLOCK         IoStatusBlock;

    //
    // Find the interface from handle
    //

    PAGED_CODE();
    
    ASSERT(g_GpcClientHandle);

    InBuffSize  = sizeof(GPC_ADD_CF_INFO_REQ) + sizeof(CF_INFO_QOS);
    OutBuffSize = sizeof(GPC_ADD_CF_INFO_RES);

    pGpcReq = UL_ALLOCATE_STRUCT_WITH_SPACE(
                    PagedPool,
                    GPC_ADD_CF_INFO_REQ,
                    sizeof(CF_INFO_QOS),
                    UL_TCI_GENERIC_POOL_TAG
                    );
    if (pGpcReq == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory( pGpcReq, InBuffSize);
    RtlZeroMemory( &GpcRes, OutBuffSize);

    pGpcReq->ClientHandle       = g_GpcClientHandle;
    pGpcReq->ClientCfInfoContext= pGenericFlow;           // GPC_CF_QOS;         
    pGpcReq->CfInfoSize         = sizeof( CF_INFO_QOS);

    Kflow = (PCF_INFO_QOS)&pGpcReq->CfInfo;
    Kflow->InstanceNameLength = (USHORT) pInterface->NameLength;

    RtlCopyMemory(  Kflow->InstanceName,
                    pInterface->Name,
                    pInterface->NameLength* sizeof(WCHAR)
                    );

    RtlCopyMemory(  &Kflow->GenFlow,
                    &pGenericFlow->GenFlow,
                    sizeof(TC_GEN_FLOW)
                    );

    Status = UlpTcDeviceControl( g_GpcFileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_GPC_ADD_CF_INFO,
                            pGpcReq,
                            InBuffSize,
                            &GpcRes,
                            OutBuffSize
                            );

    if (NT_SUCCESS(Status))
    {
        Status = GpcRes.Status;

        if (NT_SUCCESS(Status))
        {
            (*pHandle) = (HANDLE) GpcRes.GpcCfInfoHandle;

            UlTrace( TC, 
              ("Http!UlpAddFlow: a new flow added %p on interface %p \n",
                pGenericFlow,
                pInterface
                ));            
        }
    }
    
    if (!NT_SUCCESS(Status))
    {                
        UlTrace( TC, ("Http!UlpAddFlow: FAILURE %08lx\n",
                        Status
                        ));
    }

    UL_FREE_POOL( pGpcReq, UL_TCI_GENERIC_POOL_TAG );

    return Status;
}

/***************************************************************************++

Routine Description:

    Add a flow on existing QoS Enabled interfaces for the caller. And updates
    the callers list. Caller is either cgroup or control channel.

    Will return (the last) error if * all * of the flow additions fail.
    If at least one flow addition is successfull, it will return success.

    Consider a machine with 2 NICs, if media is disconnected on one NIC, you
    would still expect to see QoS running properly on the other one. Returning
    success here means, there is at least one NIC with bandwidth throttling is
    properly enforced.
    
Arguments:

    pOwner          - Pointer to the cgroup or control channel.
    NewBandwidth    - The new bandwidth throttling setting in B/s
    Global          - TRUE if this call is for global flows.

Return Value:

    NTSTATUS - Completion status. (Last failure if all additions are failed)
             - Success if at least one flow addition was success.

--***************************************************************************/

NTSTATUS
UlTcAddFlows(
    IN PVOID                pOwner,
    IN HTTP_BANDWIDTH_LIMIT MaxBandwidth,
    IN BOOLEAN              Global
    )
{
    NTSTATUS                Status;
    BOOLEAN                 FlowAdded;
    PLIST_ENTRY             pFlowListHead;    
    PLIST_ENTRY             pInterfaceEntry;
    PUL_TCI_INTERFACE       pInterface;
    PUL_TCI_FLOW            pFlow;
    

    //
    // Sanity check and init first.
    //

    PAGED_CODE();

    Status    = STATUS_SUCCESS;
    FlowAdded = FALSE;
        
    ASSERT(MaxBandwidth != HTTP_LIMIT_INFINITE); 

    UlAcquirePushLockExclusive(&g_pUlNonpagedData->TciIfcPushLock);

    if (Global)
    {
        PUL_CONTROL_CHANNEL 
            pControlChannel = (PUL_CONTROL_CHANNEL) pOwner;
    
        ASSERT(IS_VALID_CONTROL_CHANNEL(pControlChannel));

        UlTrace(TC,("Http!UlTcAddFlows: For ControlChannel: %p"
                     "@ bwt-rate of %d B/s\n", 
                     pControlChannel,
                     MaxBandwidth
                     ));
        
        pFlowListHead = &pControlChannel->FlowListHead;        
    }
    else
    {
        PUL_CONFIG_GROUP_OBJECT 
            pConfigGroup = (PUL_CONFIG_GROUP_OBJECT) pOwner;
    
        ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));

        UlTrace(TC,("Http!UlTcAddFlows: For CGroup: %p"
                     "@ bwt-rate of %d B/s\n", 
                     pConfigGroup,
                     MaxBandwidth
                     ));
                
        pFlowListHead = &pConfigGroup->FlowListHead;          
    }

    //
    // Visit each interface and add a flow for the caller.
    //

    pInterfaceEntry = g_TciIfcListHead.Flink;
    while (pInterfaceEntry != &g_TciIfcListHead)
    {
        pInterface = CONTAINING_RECORD(
                            pInterfaceEntry,
                            UL_TCI_INTERFACE,
                            Linkage
                            );

        ASSERT(IS_VALID_TCI_INTERFACE(pInterface));
        
        //
        // Only if interface has a valid IP address, we attempt to add a 
        // flow for it. Otherwise we skip adding a flow for the interface.
        //
        
        if (!pInterface->IsQoSEnabled)
        {            
            UlTrace(TC,
                ("Http!UlTcAddFlows: Skipping for interface %p !\n",
                  pInterface
                  ));
        
            goto proceed;
        }        
        
        //
        // Allocate a http flow structure.
        //

        pFlow = UlpTcAllocateFlow(MaxBandwidth);
        if (pFlow == NULL)
        {
            Status = STATUS_NO_MEMORY;
            
            UlTrace(TC, ("Http!UlTcAddFlows: Failure %08lx \n",
                          Status
                          ));
            goto proceed;
        }

        //
        // Create the corresponding QoS flow as well. If GPC call fails
        // cleanup the allocated Http flow.
        //

        Status = UlpAddFlow( 
                    pInterface,
                    pFlow,
                   &pFlow->FlowHandle
                    );

        if (!NT_SUCCESS(Status))
        {
            UlTrace(TC, ("Http!UlTcAddFlows: Failure %08lx \n", 
                           Status 
                           ));

            UL_FREE_POOL_WITH_SIG(pFlow, UL_TCI_FLOW_POOL_TAG);

            goto proceed;
        }

        if (Global)
        {            
            INT_TRACE(pInterface, TC_GFLOW_ADD);                
        }
        else
        {
            INT_TRACE(pInterface, TC_FLOW_ADD);
        }
        
        //
        // Proceed with further initialization as we have successfully 
        // installed the flow. First link the flow back to its owner 
        // interface. And add this to the interface's flowlist.
        //

        pFlow->pInterface = pInterface;

        InsertHeadList(&pInterface->FlowList, &pFlow->Linkage);
        pInterface->FlowListSize++;

        //
        // Also add this to the owner's flowlist. Set the owner pointer.
        // Do not bump up the owner's refcount. Otherwise owner cannot be
        // cleaned up until Tc terminates. And flows cannot be removed
        // untill termination.
        //

        InsertHeadList(pFlowListHead, &pFlow->Siblings);
        pFlow->pOwner = pOwner;

        //
        // Mark that there's at least one interface on which we were able
        // to install a flow.
        //

        FlowAdded = TRUE;

        UlTrace( TC,
            ("Http!UlTcAddFlows: Flow %p on pInterface %p\n",
              pFlow,
              pInterface
              ));

        UL_DUMP_TC_FLOW(pFlow);

proceed:
        //
        // Proceed to the next interface.
        //

        pInterfaceEntry = pInterfaceEntry->Flink;
    }
    
    UlReleasePushLockExclusive(&g_pUlNonpagedData->TciIfcPushLock);

    if (FlowAdded)
    {
        //
        // Return success if at least one flow installed.
        //
        
        return STATUS_SUCCESS;
    }
        
    return Status;        
    
}


/***************************************************************************++

Routine Description:

    Will walk the caller's flow list and update the existing flows with the
    new flowspec.
    
    Its caller responsiblity to remember the new settings in the store.

    Caller is either cgroup or control channel.

    Will return error if one or some of the updates fails, but proceed walking 
    the whole list.
    
Arguments:

    pOwner          - Pointer to the cgroup or control channel.
    NewBandwidth    - The new bandwidth throttling setting in B/s
    Global          - TRUE if this call is for global flows.

Return Value:

    NTSTATUS - Completion status. (Last failure if there was any)

--***************************************************************************/

NTSTATUS
UlTcModifyFlows(
    IN PVOID                pOwner,
    IN HTTP_BANDWIDTH_LIMIT NewBandwidth,
    IN BOOLEAN              Global
    )
{
    NTSTATUS                Status;
    BOOLEAN                 FlowModified;
    PLIST_ENTRY             pFlowListHead;    
    PLIST_ENTRY             pFlowEntry;
    PUL_TCI_FLOW            pFlow;
    HTTP_BANDWIDTH_LIMIT    OldBandwidth;

    //
    // Sanity check and init.
    //

    PAGED_CODE();
    
    Status       = STATUS_SUCCESS;
    FlowModified = FALSE;
    OldBandwidth = 0;
    
    ASSERT(NewBandwidth != HTTP_LIMIT_INFINITE); // we do not remove flows.

    UlAcquirePushLockExclusive(&g_pUlNonpagedData->TciIfcPushLock);

    if (Global)
    {
        PUL_CONTROL_CHANNEL 
            pControlChannel = (PUL_CONTROL_CHANNEL) pOwner;
    
        ASSERT(IS_VALID_CONTROL_CHANNEL(pControlChannel));

        UlTrace(TC,("Http!UlTcModifyFlows: For ControlChannel: %p"
                     "to bwt-rate of %d B/s\n", 
                     pControlChannel,
                     NewBandwidth
                     ));
        
        pFlowListHead = &pControlChannel->FlowListHead;    
    }
    else
    {
        PUL_CONFIG_GROUP_OBJECT 
            pConfigGroup = (PUL_CONFIG_GROUP_OBJECT) pOwner;
    
        ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));

        UlTrace(TC,("Http!UlTcModifyFlows: For CGroup: %p"
                     "to bwt-rate of %d B/s\n", 
                     pConfigGroup,
                     NewBandwidth
                     ));
                
        pFlowListHead = &pConfigGroup->FlowListHead;        
    }
    
    //
    // Walk the list and attempt to modify the flows.
    //

    pFlowEntry = pFlowListHead->Flink;
    while (pFlowEntry != pFlowListHead)
    {
        PUL_TCI_INTERFACE pInterface;
    
        pFlow = CONTAINING_RECORD(
                            pFlowEntry,
                            UL_TCI_FLOW,
                            Siblings
                            );

        ASSERT(IS_VALID_TCI_FLOW(pFlow));
        ASSERT(pOwner ==  pFlow->pOwner);

        pInterface = pFlow->pInterface;
        ASSERT(IS_VALID_TCI_INTERFACE(pInterface));
        
        if (Global)
        {
            INT_TRACE(pInterface, TC_GFLOW_MODIFY);
        }
        else
        {
            INT_TRACE(pInterface, TC_FLOW_MODIFY);
        }
        
        //
        // Save the old bandwidth before attempting to modify.
        //
        
        OldBandwidth = UL_GET_BW_FRM_FLOWSPEC(pFlow->GenFlow);

        UL_SET_FLOWSPEC(pFlow->GenFlow, NewBandwidth);

        Status = UlpModifyFlow(pFlow->pInterface, pFlow);

        if (!NT_SUCCESS(Status))
        {
            //
            // Whine about it, but still continue. Restore the original 
            // flowspec back.
            //
            
            UlTrace(TC,("Http!UlTcModifyFlowsForSite: FAILURE %08lx \n", 
                          Status 
                          ));
            
            UL_SET_FLOWSPEC(pFlow->GenFlow, OldBandwidth);
        }
        else
        {
            FlowModified = TRUE;
        }                

        UL_DUMP_TC_FLOW(pFlow);

        //
        // Proceed to the next flow
        //
        
        pFlowEntry = pFlowEntry->Flink;
    }

    UlReleasePushLockExclusive(&g_pUlNonpagedData->TciIfcPushLock);

    if (FlowModified)
    {
        //
        // Return success if at least one flow modified.
        //
        
        return STATUS_SUCCESS;
    }

    return Status;
    
}

/***************************************************************************++

Routine Description:

    Walks the caller's list (either cgroup or control channel) and removes 
    the flows on the list. Since this flows are always added to these lists
    while holding the Interface lock exclusive, we will also acquire the 
    Interface lock exclusive here.
    
Arguments:

    pOwner      : Either points to pConfigGroup or pControlChannel.
    Global      : Must be true if this call is for removing global flows.
                  In that case pOwner points to pControlChannel
    
--***************************************************************************/

VOID
UlTcRemoveFlows(
    IN PVOID    pOwner,
    IN BOOLEAN  Global
    )
{
    NTSTATUS            Status;
    PLIST_ENTRY         pFlowListHead;    
    PLIST_ENTRY         pFlowEntry;
    PUL_TCI_FLOW        pFlow;

    //
    // Sanity check and dispatch the flow type.
    //

    PAGED_CODE();
    
    Status = STATUS_SUCCESS;

    UlAcquirePushLockExclusive(&g_pUlNonpagedData->TciIfcPushLock);
    
    if (Global)
    {
        PUL_CONTROL_CHANNEL 
            pControlChannel = (PUL_CONTROL_CHANNEL) pOwner;
    
        ASSERT(IS_VALID_CONTROL_CHANNEL(pControlChannel));

        UlTrace(TC,("Http!UlTcRemoveFlows: For ControlChannel: %p \n", 
                     pControlChannel
                     ));    

        pFlowListHead = &pControlChannel->FlowListHead;        
    }
    else
    {
        PUL_CONFIG_GROUP_OBJECT 
            pConfigGroup = (PUL_CONFIG_GROUP_OBJECT) pOwner;
    
        ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));
        
        UlTrace(TC,("Http!UlTcRemoveFlows: For CGroup %p\n", 
                      pConfigGroup
                      ));
        
        pFlowListHead = &pConfigGroup->FlowListHead;        
    }
    
    //
    // Walk the list and remove the flows.
    //

    while (!IsListEmpty(pFlowListHead))
    {
        PUL_TCI_INTERFACE pInterface;

        pFlowEntry = pFlowListHead->Flink;

        pFlow = CONTAINING_RECORD(
                            pFlowEntry,
                            UL_TCI_FLOW,
                            Siblings
                            );

        ASSERT(IS_VALID_TCI_FLOW(pFlow));
        ASSERT(pOwner ==  pFlow->pOwner);

        pInterface = pFlow->pInterface;
        ASSERT(IS_VALID_TCI_INTERFACE(pInterface));
            
        if (Global)
        {                
            INT_TRACE(pInterface, TC_GFLOW_REMOVE);
        }
        else
        {
            INT_TRACE(pInterface, TC_FLOW_REMOVE);
        }        
        
        //
        // Remove this from the owner's flowlist.
        //
        
        RemoveEntryList(&pFlow->Siblings);
        pFlow->Siblings.Flink = pFlow->Siblings.Blink = NULL;
        pFlow->pOwner = NULL;

        //
        // Remove it from the interface list as well.And delete 
        // the corresponding QoS flow. This should not fail.
        //
        
        Status = UlpTcDeleteFlow(pFlow);

        //
        // Above call may fail,if GPC removes the flow based on PSCHED's
        // notification before we get a chance to close our GPC handle.
        //
    }

    UlReleasePushLockExclusive(&g_pUlNonpagedData->TciIfcPushLock);

    return;
}

/***************************************************************************++

Routine Description:

    //
    // There are two possibilities. The request  could be served frm
    // cache or can be routed to the user. In  either case we need a
    // flow installed if the BW is enabled for  this request's  site
    // and there's no filter installed for this  connection yet.  We
    // will remove the filter as soon as the connection dropped. But
    // yes there's always a but,if the client is attempting to  make
    // requests to different sites using the same connection then we
    // need to drop the  filter frm the old site and move it to  the
    // newly requested site. This is a rare case but lets handle  it
    // anyway.
    //

    It's callers responsibility to ensure proper removal of the filter,
    after it's done.

    Algorithm:

    1. Find the flow from the flow list of cgroup (or from global flows)
    2. Add filter to that flow

Arguments:

    pHttpConnection - required - Filter will be attached for this connection
    pOwner          - Either points to cgroup or control channel.
    Global          - must be true if the flow owner is a control channel.

Return Values:

    STATUS_NOT_SUPPORTED         - For attempts on Local Loopback
    STATUS_OBJECT_NAME_NOT_FOUND - If flow has not been found for the cgroup
    STATUS_SUCCESS               - In other cases

--***************************************************************************/

NTSTATUS
UlTcAddFilter(
    IN  PUL_HTTP_CONNECTION     pHttpConnection,
    IN  PVOID                   pOwner,
    IN  BOOLEAN                 Global
    )
{
    NTSTATUS            Status;
    TC_GEN_FILTER       TcGenericFilter;
    PUL_TCI_FLOW        pFlow;
    PUL_TCI_INTERFACE   pInterface;
    IP_PATTERN          Pattern;
    IP_PATTERN          Mask;

    PUL_TCI_FILTER      pFilter;

    ULONG               InterfaceId;
    ULONG               LinkId;

    //
    // Sanity check
    //
    
    PAGED_CODE();
    
    Status = STATUS_SUCCESS;

    ASSERT_FLOW_OWNER(pOwner);
    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConnection));
    ASSERT(pHttpConnection->pConnection->AddressType == TDI_ADDRESS_TYPE_IP);
        
    //
    // Need to get the routing info to find the interface.
    //
    
    Status = UlGetConnectionRoutingInfo(
                pHttpConnection->pConnection,
                &InterfaceId,
                &LinkId
                );

    if(!NT_SUCCESS(Status))
    {
        return Status;
    }

    //
    // At this point we will be refering to the flows & filters
    // in our list therefore we need to acquire the lock
    //

    UlAcquirePushLockShared(&g_pUlNonpagedData->TciIfcPushLock);

    //
    // If connection already has a filter attached, need do few
    // more checks.
    //
    
    if (pHttpConnection->pFlow)
    {
        //
        // Already present flow and filter must be valid.
        //
        
        ASSERT(IS_VALID_TCI_FLOW(pHttpConnection->pFlow));
        ASSERT(IS_VALID_TCI_FILTER(pHttpConnection->pFilter));
        ASSERT_FLOW_OWNER(pHttpConnection->pFlow->pOwner);

        //
        // If pOwner is same with the old filter's, then 
        // we will skip adding the same filter again.
        //
        
        if (pOwner == pHttpConnection->pFlow->pOwner)
        {
           //
           // No need to add a new filter we are done.
           //
           
           UlTrace( TC,
                ("Http!UlTcAddFilter: Skipping same pFlow %p and"
                 "pFilter %p already exist\n",
                  pHttpConnection->pFlow,
                  pHttpConnection->pFilter,
                  pHttpConnection
                ));

           ASSERT(NT_SUCCESS(Status));
           
           goto end;
        }
        else
        {
            //
            // If there was another filter before and this newly coming  request
            // is being going to a different site/flow. Then move the filter frm
            // the old one to the new flow.
            //

            Status = UlpTcDeleteFilter(
                        pHttpConnection->pFlow, 
                        pHttpConnection->pFilter
                        );

            ASSERT(NT_SUCCESS(Status)); // We trust MSGPC.SYS
        }
    }

    //
    // Search through the cgroup's flowlist to find the one we need. 
    // This must find the flow which is installed on the interface
    // on which we will send the outgoing packets. Not necessarily 
    // the same ip we have received the request. See the routing call
    // above.
    //

    pFlow = UlpFindFlow(pOwner, Global, InterfaceId, LinkId);
    
    if ( pFlow == NULL )
    {
        //
        // Note: We'll come here for loopback interfaces, since we will not 
        // find a Traffic Control interfaces for loopback.
        //
        
        UlTrace( TC,
                ("Http!UlTcAddFilter: Unable to find interface %x \n",
                 InterfaceId
                 ));

        //
        // It's possible that we might not find out a flow
        // after all the interfaces went down, even though
        // qos configured on the cgroup.
        //
        
        Status = STATUS_SUCCESS;
        goto end;
    }

    pFilter = NULL;

    pInterface = pFlow->pInterface;
    ASSERT(IS_VALID_TCI_INTERFACE(pInterface));

    RtlZeroMemory( &Pattern, sizeof(IP_PATTERN) );
    RtlZeroMemory( &Mask,    sizeof(IP_PATTERN) );

    // Setup the filter's pattern 

    Pattern.SrcAddr = pHttpConnection->pConnection->LocalAddrIn.in_addr;
    Pattern.S_un.S_un_ports.s_srcport = pHttpConnection->pConnection->LocalAddrIn.sin_port;

    Pattern.DstAddr = pHttpConnection->pConnection->RemoteAddrIn.in_addr;
    Pattern.S_un.S_un_ports.s_dstport = pHttpConnection->pConnection->RemoteAddrIn.sin_port;

    Pattern.ProtocolId = IPPROTO_TCP;

    // Setup the filter's Mask 

    RtlFillMemory(&Mask, sizeof(IP_PATTERN), 0xff);

    TcGenericFilter.AddressType = NDIS_PROTOCOL_ID_TCP_IP;
    TcGenericFilter.PatternSize = sizeof( IP_PATTERN );
    TcGenericFilter.Pattern     = &Pattern;
    TcGenericFilter.Mask        = &Mask;

    Status = UlpTcAddFilter(
                    pFlow,
                    &TcGenericFilter,
                    LinkId,
                    &pFilter
                    );

    if (!NT_SUCCESS(Status))
    {
       //
       // Now this is a real failure, we will reject the connection.
       //
       
       UlTrace( TC,
            ("Http!UlTcAddFilter: Unable to add filter for;\n"
             "\t pInterface     : %p\n"
             "\t pFlow          : %p\n",
              pInterface,
              pFlow
              ));
        goto end;
    }

    //
    //  Update the connection's pointers here.
    //

    pHttpConnection->pFlow   = pFlow;
    pHttpConnection->pFilter = pFilter;

    pHttpConnection->BandwidthThrottlingEnabled = 1;

    //
    // Remember the connection for cleanup. If flow & filter get
    // removed aynscly when connection still pointing to them
    // we can go and null out the connection's private pointers.
    //

    pFilter->pHttpConnection = pHttpConnection;

    //
    // Sweet smell of success !
    //

    UlTrace(TC,
            ("Http!UlTcAddFilter: Success for;\n"
             "\t pInterface     : %p\n"
             "\t pFlow          : %p\n",
              pInterface,
              pFlow
              ));

    UL_DUMP_TC_FILTER(pFilter);

end:
    if (!NT_SUCCESS(Status))
    {
        UlTrace( TC, ("Http!UlTcAddFilter: FAILURE %08lx \n", Status ));
    }

    UlReleasePushLockShared(&g_pUlNonpagedData->TciIfcPushLock);

    return Status;
}

/***************************************************************************++

Routine Description:
 
    Add a filter on an existing flow.

Arguments:

    pFlow - Filter will be added on to this flow.
    pGenericFilter - Generic filter parameters.
    ppFilter - if everything goes ok. A new filter will be allocated.
 
--***************************************************************************/

NTSTATUS
UlpTcAddFilter(
    IN   PUL_TCI_FLOW       pFlow,
    IN   PTC_GEN_FILTER     pGenericFilter,
    IN   ULONG              LinkId,
    OUT  PUL_TCI_FILTER     *ppFilter
    )
{
    NTSTATUS                Status;
    PGPC_ADD_PATTERN_REQ    pGpcReq;
    GPC_ADD_PATTERN_RES     GpcRes;
    ULONG                   InBuffSize;
    ULONG                   OutBuffSize;
    ULONG                   PatternSize;
    IO_STATUS_BLOCK         IoStatBlock;
    PUCHAR                  pTemp;
    PGPC_IP_PATTERN         pIpPattern;
    PUL_TCI_FILTER          pFilter;

    //
    // Sanity check
    //

    Status  = STATUS_SUCCESS;
    pGpcReq = NULL;

    if ( !pGenericFilter || !pFlow || !g_GpcClientHandle )
    {
        return STATUS_INVALID_PARAMETER;
    }

    // Allocate a space for the filter

    pFilter = UL_ALLOCATE_STRUCT(
                NonPagedPool,
                UL_TCI_FILTER,
                UL_TCI_FILTER_POOL_TAG
                );
    if ( pFilter == NULL )
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }
    pFilter->Signature = UL_TCI_FILTER_POOL_TAG;

    // Buffer monkeying

    PatternSize = sizeof(GPC_IP_PATTERN);
    InBuffSize  = sizeof(GPC_ADD_PATTERN_REQ) + (2 * PatternSize);
    OutBuffSize = sizeof(GPC_ADD_PATTERN_RES);

    pGpcReq = UL_ALLOCATE_STRUCT_WITH_SPACE(
                    PagedPool,
                    GPC_ADD_PATTERN_REQ,
                    (2 * PatternSize),
                    UL_TCI_GENERIC_POOL_TAG
                    );
    if (pGpcReq == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    RtlZeroMemory( pGpcReq, InBuffSize);
    RtlZeroMemory( &GpcRes, OutBuffSize);

    pGpcReq->ClientHandle     = g_GpcClientHandle;
    pGpcReq->GpcCfInfoHandle  = pFlow->FlowHandle;
    pGpcReq->PatternSize      = PatternSize;
    pGpcReq->ProtocolTemplate = GPC_PROTOCOL_TEMPLATE_IP;

    pTemp = (PUCHAR) &pGpcReq->PatternAndMask;

    // Fill in the IP Pattern first

    RtlCopyMemory( pTemp, pGenericFilter->Pattern, PatternSize );
    pIpPattern = (PGPC_IP_PATTERN) pTemp;

    //
    // According to QoS Tc.dll ;
    // This is a work around so that TCPIP wil not to find the index/link
    // for ICMP/IGMP packets
    //
    
    pIpPattern->InterfaceId.InterfaceId = pFlow->pInterface->IfIndex;
    pIpPattern->InterfaceId.LinkId = LinkId;
    pIpPattern->Reserved[0] = 0;
    pIpPattern->Reserved[1] = 0;
    pIpPattern->Reserved[2] = 0;

    // Fill in the mask

    pTemp += PatternSize;

    RtlCopyMemory( pTemp, pGenericFilter->Mask, PatternSize );

    pIpPattern = (PGPC_IP_PATTERN) pTemp;

    pIpPattern->InterfaceId.InterfaceId = 0xffffffff;
    pIpPattern->InterfaceId.LinkId = 0xffffffff;
    pIpPattern->Reserved[0] = 0xff;
    pIpPattern->Reserved[1] = 0xff;
    pIpPattern->Reserved[2] = 0xff;

    // Time to invoke Gpsy

    Status = UlpTcDeviceControl( g_GpcFileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatBlock,
                            IOCTL_GPC_ADD_PATTERN,
                            pGpcReq,
                            InBuffSize,
                            &GpcRes,
                            OutBuffSize);
    if (NT_SUCCESS(Status))
    {
        Status = GpcRes.Status;

        if (NT_SUCCESS(Status))
        {
            //
            // Insert the freshly created filter to the flow.
            //

            pFilter->FilterHandle = (HANDLE) GpcRes.GpcPatternHandle;

            UlpInsertFilterEntry( pFilter, pFlow );

            //
            // Success!
            //

            *ppFilter = pFilter;

            INCREMENT_FILTER_ADD();
        }
    }    

end:
    if (!NT_SUCCESS(Status))
    {
        INCREMENT_FILTER_ADD_FAILURE();
        
        UlTrace( TC, ("Http!UlpTcAddFilter: FAILURE %08lx \n", Status ));

        // Cleanup filter only if we failed, otherwise it will go to
        // the filterlist of the flow.

        if (pFilter)
        {
            UL_FREE_POOL( pFilter, UL_TCI_FILTER_POOL_TAG );
        }
    }

    // Cleanup the temp Gpc buffer which we used to pass down filter info
    // to GPC. We don't need it anymore.

    if (pGpcReq)
    {
        UL_FREE_POOL( pGpcReq, UL_TCI_GENERIC_POOL_TAG );
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    UlTcDeleteFilter :

        Connection only deletes the filter prior to deleting itself. Any
        operation initiated by the connection requires tc resource shared
        and none of those cause race condition.

        Anything other than this, such as flow & filter removal because of
        BW disabling on the site will acquire the lock exclusively. Hence
        the pFlow & pFilter are safe as long as we acquire the tc resource
        shared.

Arguments:

    connection object to get the flow & filter after we acquire the tc lock

--***************************************************************************/

NTSTATUS
UlTcDeleteFilter(
    IN  PUL_HTTP_CONNECTION pHttpConnection
    )
{
    NTSTATUS    Status;

    //
    // Sanity check
    //
    Status = STATUS_SUCCESS;

    //
    // If we have been called w/o being initialized
    //
    ASSERT(g_InitTciCalled);

    UlTrace(TC,("Http!UlTcDeleteFilter: for connection %p\n", pHttpConnection));

    UlAcquirePushLockShared(&g_pUlNonpagedData->TciIfcPushLock);

    if (pHttpConnection->pFlow)
    {
        Status = UlpTcDeleteFilter(
                    pHttpConnection->pFlow,
                    pHttpConnection->pFilter
                    );
    }

    UlReleasePushLockShared(&g_pUlNonpagedData->TciIfcPushLock);

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcRemoveFilter :

Arguments:

    flow & filter

--***************************************************************************/

NTSTATUS
UlpTcDeleteFilter(
    IN PUL_TCI_FLOW     pFlow,
    IN PUL_TCI_FILTER   pFilter
    )
{
    NTSTATUS            Status;
    HANDLE              FilterHandle;

    //
    // Sanity check
    //

    Status  = STATUS_SUCCESS;

    ASSERT(IS_VALID_TCI_FLOW(pFlow));
    ASSERT(IS_VALID_TCI_FILTER(pFilter));

    if (pFlow == NULL || pFilter == NULL)
    {
        return STATUS_INVALID_PARAMETER;
    }

    FilterHandle = pFilter->FilterHandle;

    pFilter->pHttpConnection->pFlow   = NULL;
    pFilter->pHttpConnection->pFilter = NULL;

    //
    // Now call the actual worker for us
    //

    UlpRemoveFilterEntry( pFilter, pFlow );

    Status = UlpTcDeleteGpcFilter( FilterHandle );

    if (!NT_SUCCESS(Status))
    {
        UlTrace( TC, ("Http!UlpTcDeleteFilter: FAILURE %08lx \n", Status ));
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcRemoveFilter :

    This procedure builds up the structure necessary to delete a filter.
    It then calls a routine to pass this info to the GPC.

Arguments:

    FilterHandle - Handle of the filter to be deleted

--***************************************************************************/

NTSTATUS
UlpTcDeleteGpcFilter(
    IN  HANDLE                  FilterHandle
    )
{
    NTSTATUS                    Status;
    ULONG                       InBuffSize;
    ULONG                       OutBuffSize;
    GPC_REMOVE_PATTERN_REQ      GpcReq;
    GPC_REMOVE_PATTERN_RES      GpcRes;
    IO_STATUS_BLOCK             IoStatBlock;

    Status = STATUS_SUCCESS;

    ASSERT(FilterHandle != NULL);

    InBuffSize  = sizeof(GPC_REMOVE_PATTERN_REQ);
    OutBuffSize = sizeof(GPC_REMOVE_PATTERN_RES);

    GpcReq.ClientHandle     = g_GpcClientHandle;
    GpcReq.GpcPatternHandle = FilterHandle;

    ASSERT(g_GpcFileHandle);
    ASSERT(GpcReq.ClientHandle);
    ASSERT(GpcReq.GpcPatternHandle);

    Status = UlpTcDeviceControl( g_GpcFileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatBlock,
                            IOCTL_GPC_REMOVE_PATTERN,
                            &GpcReq,
                            InBuffSize,
                            &GpcRes,
                            OutBuffSize
                            );
    if (NT_SUCCESS(Status))
    {
        Status = GpcRes.Status;

        if (NT_SUCCESS(Status))
        {
            UlTrace( TC, 
             ("Http!UlpTcDeleteGpcFilter: FilterHandle %d deleted in TC as well.\n",
               FilterHandle
               ));

            INCREMENT_FILTER_DELETE();
        }
    }    
    
    if (!NT_SUCCESS(Status))
    {
        INCREMENT_FILTER_DELETE_FAILURE();
        
        UlTrace( TC, ("Http!UlpTcDeleteGpcFilter: FAILURE %08lx \n", Status ));
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpInsertFilterEntry :

        Inserts a filter entry to the filter list of the flow.

Arguments:

    pEntry  - The filter entry to be added to the flow list

--***************************************************************************/

VOID
UlpInsertFilterEntry(
    IN      PUL_TCI_FILTER      pEntry,
    IN OUT  PUL_TCI_FLOW        pFlow
    )
{
    LONGLONG listSize;
    KIRQL    oldIrql;

    //
    // Sanity check.
    //

    ASSERT(pEntry);
    ASSERT(IS_VALID_TCI_FILTER(pEntry));
    ASSERT(pFlow);

    //
    // add to the list
    //

    UlAcquireSpinLock( &pFlow->FilterListSpinLock, &oldIrql );

    InsertHeadList( &pFlow->FilterList, &pEntry->Linkage );

    pFlow->FilterListSize += 1;

    listSize = pFlow->FilterListSize;

    UlReleaseSpinLock( &pFlow->FilterListSpinLock, oldIrql );

    ASSERT( listSize >= 1);
}

/***************************************************************************++

Routine Description:

    UlRemoveFilterEntry :

        Removes a filter entry frm the filter list of the flow.

Arguments:

    pEntry  - The filter entry to be removed from the flow list

--***************************************************************************/

VOID
UlpRemoveFilterEntry(
    IN      PUL_TCI_FILTER  pEntry,
    IN OUT  PUL_TCI_FLOW    pFlow
    )
{
    LONGLONG    listSize;
    KIRQL       oldIrql;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_TCI_FLOW(pFlow));
    ASSERT(IS_VALID_TCI_FILTER(pEntry));

    //
    // And the work
    //

    UlAcquireSpinLock( &pFlow->FilterListSpinLock, &oldIrql );

    RemoveEntryList( &pEntry->Linkage );

    pFlow->FilterListSize -= 1;
    listSize = pFlow->FilterListSize;

    pEntry->Linkage.Flink = pEntry->Linkage.Blink = NULL;

    UlReleaseSpinLock( &pFlow->FilterListSpinLock, oldIrql );

    ASSERT( listSize >= 0 );

    UlTrace( TC, ("Http!UlpRemoveFilterEntry: FilterEntry %p removed/deleted.\n",
                    pEntry
                    ));

    UL_FREE_POOL_WITH_SIG( pEntry, UL_TCI_FILTER_POOL_TAG );
}

//
// Various helpful utilities for TCI module
//

/***************************************************************************++

Routine Description:

    Find the flow in the cgroups flow list by looking at the IP address
    of each flows interface. The rule is cgroup will install one flow
    on each interface available.

    By having a flow list in each cgroup we are able to do a faster
    flow lookup. This is more scalable than doing a linear search for
    all the flows of the interface.

Arguments:

    pOwner       - The config group of the site OR the control channel
    Global       - Must be TRUE if the owner is control channel.
    InterfaceID  - Interface ID
    LinkID       - LinkID

Return Value:

    PUL_TCI_FLOW  - The flow we found OR NULL if we couldn't find one.

--***************************************************************************/

PUL_TCI_FLOW
UlpFindFlow(
    IN PVOID            pOwner,
    IN BOOLEAN          Global,
    IN ULONG            InterfaceId,
    IN ULONG            LinkId
    )
{
    PLIST_ENTRY         pFlowListHead;
    PLIST_ENTRY         pFlowEntry;
    PUL_TCI_FLOW        pFlow;

    //
    // Sanity check and dispatch the flowlist.
    //
    
    PAGED_CODE();
    
    if (Global)
    {
        PUL_CONTROL_CHANNEL 
            pControlChannel = (PUL_CONTROL_CHANNEL) pOwner;
    
        ASSERT(IS_VALID_CONTROL_CHANNEL(pControlChannel));        
        pFlowListHead = &pControlChannel->FlowListHead;         
    }
    else
    {
        PUL_CONFIG_GROUP_OBJECT 
            pConfigGroup = (PUL_CONFIG_GROUP_OBJECT) pOwner;
    
        ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));                
        pFlowListHead = &pConfigGroup->FlowListHead;          
    }

    //
    // Walk the list and try to find the flow.
    //

    pFlowEntry = pFlowListHead->Flink;
    while ( pFlowEntry != pFlowListHead )
    {
        pFlow = CONTAINING_RECORD(
                    pFlowEntry,
                    UL_TCI_FLOW,
                    Siblings
                    );
        
        ASSERT(IS_VALID_TCI_FLOW(pFlow));
        ASSERT(IS_VALID_TCI_INTERFACE(pFlow->pInterface));
        
        if(UlpMatchTcInterface(
                pFlow->pInterface, 
                InterfaceId, 
                LinkId
                ))
        {
            return pFlow;
        }

        pFlowEntry = pFlowEntry->Flink;
    }

    //
    // Couldn't find one. Actually this could be the right time to 
    // refresh the flow list of this cgroup or control channel !!
    //
    
    return NULL;
}

/***************************************************************************++

Routine Description:

    UlpTcDeviceControl :


Arguments:

    As usual

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcDeviceControl(
    IN  HANDLE                          FileHandle,
    IN  HANDLE                          EventHandle,
    IN  PIO_APC_ROUTINE                 ApcRoutine,
    IN  PVOID                           ApcContext,
    OUT PIO_STATUS_BLOCK                pIoStatusBlock,
    IN  ULONG                           Ioctl,
    IN  PVOID                           InBuffer,
    IN  ULONG                           InBufferSize,
    IN  PVOID                           OutBuffer,
    IN  ULONG                           OutBufferSize
    )
{
    NTSTATUS    Status;

    UNREFERENCED_PARAMETER(EventHandle);
    UNREFERENCED_PARAMETER(ApcRoutine);
    UNREFERENCED_PARAMETER(ApcContext);
    
    //
    // Sanity check.
    //

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    Status = ZwDeviceIoControlFile(
                    FileHandle,                     // FileHandle
                    NULL,                           // Event
                    NULL,                           // ApcRoutine
                    NULL,                           // ApcContext
                    pIoStatusBlock,                 // IoStatusBlock
                    Ioctl,                          // IoControlCode
                    InBuffer,                       // InputBuffer
                    InBufferSize,                   // InputBufferLength
                    OutBuffer,                      // OutputBuffer
                    OutBufferSize                   // OutputBufferLength
                    );

    if (Status == STATUS_PENDING)
    {
        Status = ZwWaitForSingleObject(
                        FileHandle,                 // Handle
                        TRUE,                       // Alertable
                        NULL                        // Timeout
                        );

        Status = pIoStatusBlock->Status;
    }

    return Status;
}

#if DBG

/***************************************************************************++

Routine Description:

    UlDumpTCInterface :

        Helper utility to display interface content.

Arguments:

        PUL_TCI_INTERFACE   - TC Interface to be dumped

--***************************************************************************/

VOID
UlDumpTCInterface(
        IN PUL_TCI_INTERFACE   pTcIfc
        )
{
    ASSERT(IS_VALID_TCI_INTERFACE(pTcIfc));

    UlTrace( TC,("Http!UlDumpTCInterface: \n   pTcIfc @ %p\n"
                 "\t Signature           = %08lx \n",
                 pTcIfc, pTcIfc->Signature));

    UlTrace( TC,(
        "\t IsQoSEnabled:       = %u \n"
        "\t IfIndex:            = %d \n"
        "\t NameLength:         = %u \n"
        "\t Name:               = %ws \n"
        "\t InstanceIDLength:   = %u \n"
        "\t InstanceID:         = %ws \n"
        "\t FlowListSize:       = %d \n"
        "\t AddrListBytesCount: = %d \n"
        "\t pAddressListDesc:   = %p \n",
        pTcIfc->IsQoSEnabled,
        pTcIfc->IfIndex,
        pTcIfc->NameLength,
        pTcIfc->Name,
        pTcIfc->InstanceIDLength,
        pTcIfc->InstanceID,
        pTcIfc->FlowListSize,
        pTcIfc->AddrListBytesCount,
        pTcIfc->pAddressListDesc
        ));
}

/***************************************************************************++

Routine Description:

    UlDumpTCFlow :

        Helper utility to display interface content.

Arguments:

        PUL_TCI_FLOW   - TC Flow to be dumped

--***************************************************************************/

VOID
UlDumpTCFlow(
        IN PUL_TCI_FLOW   pFlow
        )
{
    ASSERT(IS_VALID_TCI_FLOW(pFlow));

    UlTrace( TC,
       ("Http!UlDumpTCFlow: \n"
        "   pFlow @ %p\n"
        "\t Signature           = %08lx \n"
        "\t pInterface          @ %p \n"
        "\t FlowHandle          = %d \n"
        "\t GenFlow             @ %p \n"
        "\t FlowRate KB/s       = %d \n"
        "\t FilterListSize      = %I64d \n"
        "\t pOwner (store)      = %p \n"
        ,
        pFlow,
        pFlow->Signature,
        pFlow->pInterface,
        pFlow->FlowHandle,
        &pFlow->GenFlow,
        pFlow->GenFlow.SendingFlowspec.TokenRate / 1024,
        pFlow->FilterListSize,
        pFlow->pOwner
        ));

    UNREFERENCED_PARAMETER(pFlow);
}

/***************************************************************************++

Routine Description:

    UlDumpTCFilter :

        Helper utility to display filter structure content.

Arguments:

        PUL_TCI_FILTER   pFilter

--***************************************************************************/

VOID
UlDumpTCFilter(
        IN PUL_TCI_FILTER   pFilter
        )
{
    ASSERT(IS_VALID_TCI_FILTER(pFilter));

    UlTrace( TC,
       ("Http!UlDumpTCFilter: \n"
        "   pFilter @ %p\n"
        "\t Signature           = %08lx \n"
        "\t pHttpConnection     = %p \n"
        "\t FilterHandle        = %d \n",
        pFilter,
        pFilter->Signature,
        pFilter->pHttpConnection,
        pFilter->FilterHandle
        ));

    UNREFERENCED_PARAMETER(pFilter);
}

#endif // DBG


/***************************************************************************++

Routine Description:

    See if the Traffic Interface matches the InterfaceID & LinkID. LinkId 
    matches are done only for WAN connections.

Arguments:
    pIntfc      - The TC inteface
    InterfaceId - Interface index.
    LinkId      - Link ID

Return Value:
    TRUE  - Matches.
    FALSE - Does not match.


--***************************************************************************/

BOOLEAN
UlpMatchTcInterface(
    IN  PUL_TCI_INTERFACE  pIntfc,
    IN  ULONG              InterfaceId,
    IN  ULONG              LinkId
    )
{
    NETWORK_ADDRESS UNALIGNED64    *pAddr;
    NETWORK_ADDRESS_IP UNALIGNED64 *pIpNetAddr = NULL;
    ULONG                           cAddr;
    ULONG                           index;

    if(pIntfc->IfIndex == InterfaceId)
    {
        // InterfaceID's matched. If it's a wan-link, we need to compare the
        // LinkId with the remote address.
        
        if(pIntfc->pAddressListDesc->MediaType == NdisMediumWan)
        {
            cAddr = pIntfc->pAddressListDesc->AddressList.AddressCount;
            pAddr = (UNALIGNED64 NETWORK_ADDRESS *) 
                        &pIntfc->pAddressListDesc->AddressList.Address[0];

            for (index = 0; index < cAddr; index++)
            {
                if (pAddr->AddressType == NDIS_PROTOCOL_ID_TCP_IP)
                {
                    pIpNetAddr = 
                        (UNALIGNED64 NETWORK_ADDRESS_IP *)&pAddr->Address[0];

                    if(pIpNetAddr->in_addr == LinkId)
                    {
                        return TRUE;
                    }
                }

                pAddr = (UNALIGNED64 NETWORK_ADDRESS *)(((PUCHAR)pAddr)
                                           + pAddr->AddressLength
                                   + FIELD_OFFSET(NETWORK_ADDRESS, Address));
            }
        }
        else
        {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ultdip.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    ultdip.h

Abstract:

    This module contains declarations private to the TDI component. These
    declarations are placed in a separate .H file to make it easier to access
    them from within the kernel debugger extension DLL.

    The TDI package manages two major object types: UL_ENDPOINT and
    UL_CONNECTION.

    A UL_ENDPOINT is basically a wrapper around a TDI address object. Each
    endpoint has a list of associated UL_CONNECTION objects for
    idle (non-connected) connections

    Active (connected) connections are on the global connection list.

    A UL_CONNECTION is basically a wrapper around a TDI connection object.
    Its main purpose is to manage TDI connection state. See the description
    of UL_CONNECTION_FLAGS below for the gory details.

    The relationship between these two objects is illustrated in the
    following diagram:

        +-----------+
        |           |
        |UL_ENDPOINT|
        |           |
        +---+----+--+
                 |
                 |
                 |  Idle Connections
                 |  +-------------+   +-------------+   +-------------+
                 |  |             |   |             |   |             |
                 +->|UL_CONNECTION|-->|UL_CONNECTION|-->|UL_CONNECTION|-->...
                    |             |   |             |   |             |
                    +-------------+   +-------------+   +-------------+
             
             

    Note: Idle connections do not hold references to their owning endpoint,
    but active connections do. When a listening endpoint is shutdown, all
    idle connections are simply purged, but active connections must be
    forcibly disconnected first.

Author:

    Keith Moore (keithmo)       15-Jun-1998

Revision History:

--*/


#ifndef _ULTDIP_H_
#define _ULTDIP_H_


//
// Forward references.
//

typedef struct _UL_ENDPOINT         *PUL_ENDPOINT;
typedef union  _UL_CONNECTION_FLAGS *PUL_CONNECTION_FLAGS;
typedef struct _UL_CONNECTION       *PUL_CONNECTION;
typedef struct _UL_RECEIVE_BUFFER   *PUL_RECEIVE_BUFFER;

//
// Private constants.
//

#define MAX_ADDRESS_EA_BUFFER_LENGTH                                        \
   (sizeof(FILE_FULL_EA_INFORMATION) - 1 +                                  \
    TDI_TRANSPORT_ADDRESS_LENGTH + 1 +                                      \
    sizeof(TA_IP6_ADDRESS))

#define MAX_CONNECTION_EA_BUFFER_LENGTH                                     \
   (sizeof(FILE_FULL_EA_INFORMATION) - 1 +                                  \
    TDI_CONNECTION_CONTEXT_LENGTH + 1 +                                     \
    sizeof(CONNECTION_CONTEXT))

#define TL_INSTANCE 0

//
// Private types.
//


//
// A generic IRP context. This is useful for storing additional completion
// information associated with a pending IRP.
//
// WARNING!  All fields of this structure must be explicitly initialized.
//

typedef struct _UL_IRP_CONTEXT
{
    //
    // This MUST be the first field in the structure. This is the linkage
    // used by the lookaside package for storing entries in the lookaside
    // list.
    //

    SLIST_ENTRY LookasideEntry;

    //
    // Structure signature.
    //

    ULONG Signature;

    //
    // Either the endpoint or endpoint associated with the IRP.
    //

    PVOID pConnectionContext;

    //
    // Completion information.
    //

    PUL_COMPLETION_ROUTINE pCompletionRoutine;
    PVOID pCompletionContext;

    //
    // Our own allocated IRP if set.
    //

    PIRP pOwnIrp;

    //
    // The TDI send flag (0 or TDI_SEND_AND_DISCONNECT).
    //

    USHORT TdiSendFlag;

    //
    // Our own allocated UL_IRP_CONTEXT if set.
    //

    BOOLEAN OwnIrpContext;

    //
    // Total send length we passed to TDI_SEND.
    //

    ULONG_PTR SendLength;

} UL_IRP_CONTEXT, *PUL_IRP_CONTEXT;

#define UL_IRP_CONTEXT_SIGNATURE    MAKE_SIGNATURE('IRPC')
#define UL_IRP_CONTEXT_SIGNATURE_X  MAKE_FREE_SIGNATURE(UL_IRP_CONTEXT_SIGNATURE)

#define IS_VALID_IRP_CONTEXT(pIrpContext)                                   \
    HAS_VALID_SIGNATURE(pIrpContext, UL_IRP_CONTEXT_SIGNATURE)


typedef enum _CONN_LIST_STATE
{
    NoConnList = 1,
    IdleConnList,
    ActiveNoConnList,
    RetiringNoConnList

} CONN_LIST_STATE;


//
// A TDI Address Object and it's pre-allocated lists of idle connections.  
// This is allocated together with a UL_ENDPOINT, which always has at 
// least one of these objects.
//
// This does not need a ref count since it's "contained" as part of 
// a UL_ENDPOINT object.  
//
// CODEWORK: When we want to do dynamic addition/removal of this object, 
// we'll need to add ref counting & add list-linkage to the endpoint, 
// rather than as an array tacked on the end.
//
// Methods on this pseudo-class:
//    UlpInitializeAddrIdleList
//    UlpCleanupAddrIdleList
//    UlpReplenishAddrIdleList
//    UlpReplenishAddrIdleListWorker
//    UlpTrimAddrIdleListWorker
//

typedef struct _UL_ADDR_IDLE_LIST
{
    //
    // Structure signature: UL_ADDR_IDLE_LIST_SIGNATURE
    //

    ULONG          Signature;
    
    //
    // The TDI address object.
    //

    UX_TDI_OBJECT  AddressObject;

    //
    // The local address we're bound to.
    //

    UL_TRANSPORT_ADDRESS LocalAddress;
    ULONG          LocalAddressLength;

    //
    // Heads of the per-address object connection lists.
    // Idle connections have a weak reference to 'this', the owning endpoint
    //

    HANDLE         IdleConnectionSListsHandle;

    //
    // When replenish is scheduled, we need to remember the cpu.
    //

    USHORT          CpuToReplenish;

    //
    // The owning endpoint
    //

    PUL_ENDPOINT   pOwningEndpoint;

    //
    // Work item for replenishing
    //

    UL_WORK_ITEM   WorkItem;
    LONG           WorkItemScheduled;
    
} UL_ADDR_IDLE_LIST, *PUL_ADDR_IDLE_LIST;

#define UL_ADDR_IDLE_LIST_SIGNATURE   MAKE_SIGNATURE('UlAI')
#define UL_ADDR_IDLE_LIST_SIGNATURE_X MAKE_FREE_SIGNATURE(UL_ADDR_IDLE_LIST_SIGNATURE)

#define IS_VALID_ADDR_IDLE_LIST(pAddrIdleList)      \
    HAS_VALID_SIGNATURE(pAddrIdleList, UL_ADDR_IDLE_LIST_SIGNATURE)

typedef struct _UL_TRIM_TIMER
{
    //
    // Timer itself and the corresponding Dpc object.    
    //
    
    KTIMER       Timer;
    KDPC         DpcObject;
    UL_WORK_ITEM WorkItem;
    LONG         WorkItemScheduled;

    LIST_ENTRY   ZombieConnectionListHead;

    //
    // Spinlock to protect the following state parameters
    //
    
    UL_SPIN_LOCK SpinLock;
    
    BOOLEAN      Initialized;
    BOOLEAN      Started;
        
} UL_TRIM_TIMER, *PUL_TRIM_TIMER;

//
// An endpoint is basically our wrapper around TDI address objects.
// There is one UL_ENDPOINT per TCP Port.  In the common case, there will 
// be three ports: 80 (HTTP), 443 (HTTPS), and a random port for the 
// IIS Admin site.
//

typedef struct _UL_ENDPOINT
{
    //
    // Structure signature: UL_ENDPOINT_SIGNATURE
    //

    ULONG Signature;

    //
    // Reference count.
    //

    LONG ReferenceCount;

    //
    // Usage count. This is used by the "URL-site-to-endpoint" thingie.
    //

    LONG UsageCount;

    //
    // Links onto the global endpoint list.
    //
    // GlobalEndpointListEntry.Flink is NULL if the endpoint is not
    // on the global list, g_TdiEndpointListHead, or the
    // to-be-deleted-soon list, g_TdiDeletedEndpointListHead.
    //

    LIST_ENTRY GlobalEndpointListEntry;

    //
    // Array of TDI Address Object + Connection Objects.  
    // One per entry on the global "Listen Only" list, or one entry 
    // representing INADDR_ANY/in6addr_any.  Allocated at endpoint
    // creation time, directly after the UL_ENDPOINT.
    //

    ULONG AddrIdleListCount;
    // REVIEW: what's the team's hungarian notation for an array?
    PUL_ADDR_IDLE_LIST aAddrIdleLists;

    // CODEWORK: ability to change from INADDR_ANY to Listen Only List
    // and vice versa.
    // CODEWORK: ability to dynamicly add/remove AO's. (need spinlock)

    //
    // Indication handlers & user context.
    //

    PUL_CONNECTION_REQUEST pConnectionRequestHandler;
    PUL_CONNECTION_COMPLETE pConnectionCompleteHandler;
    PUL_CONNECTION_DISCONNECT pConnectionDisconnectHandler;
    PUL_CONNECTION_DISCONNECT_COMPLETE pConnectionDisconnectCompleteHandler;
    PUL_CONNECTION_DESTROYED pConnectionDestroyedHandler;
    PUL_DATA_RECEIVE pDataReceiveHandler;
    PVOID pListeningContext;

    //
    // The local TCP Port we're bound to.
    //

    USHORT LocalPort;

    //
    // Is this a secure endpoint?
    //

    BOOLEAN Secure;

    //
    // Thread work item for deferred actions.
    //

    UL_WORK_ITEM WorkItem;

    LONG         WorkItemScheduled;

    //
    // An IRP context containing completion information necessary
    // while shutting down a listening endpoint.
    //

    UL_IRP_CONTEXT CleanupIrpContext;

    //
    // Has this endpoint taken a g_TdiEndpointCount?
    //

    BOOLEAN Counted;

    //
    // Has this endpoint been moved to the deleted list,
    // g_TdiDeletedEndpointListHead?
    //

    BOOLEAN Deleted;

} UL_ENDPOINT;

#define UL_ENDPOINT_SIGNATURE   MAKE_SIGNATURE('ENDP')
#define UL_ENDPOINT_SIGNATURE_X MAKE_FREE_SIGNATURE(UL_ENDPOINT_SIGNATURE)

#define IS_VALID_ENDPOINT(pEndpoint)                                        \
    HAS_VALID_SIGNATURE(pEndpoint, UL_ENDPOINT_SIGNATURE)


//
// Connection flags/state. These flags indicate the current state of a
// connection.
//
// Some of these flags may be simply updated directly. Others require
// UlInterlockedCompareExchange() to avoid race conditions.
//
// The following flags may be updated directly:
//
//     AcceptPending - SET in the TDI connection handler, just before the
//         accept IRP is returned to the transport. RESET only if the accept
//         IRP fails.
//
// The following flags must be updated using UlInterlockedCompareExchange():
//
//     AcceptComplete - SET in the accept IRP completion handler if the IRP
//         completed successfully. Once this flag is set, the connection must
//         be either gracefully disconnected or aborted before the connection
//         can be closed or reused.
//
//     DisconnectPending - SET just before a graceful disconnect IRP is
//         issued.
//
//     DisconnectComplete - SET in the graceful disconnect IRP completion
//         handler.
//
//     AbortPending - SET just before an abortive disconnect IRP is issued.
//
//     AbortComplete - SET in the abortive disconnect IRP completion handler.
//
//     DisconnectIndicated - SET in the TDI disconnect handler for graceful
//         disconnects issued by the remote client.
//
//     AbortIndicated - SET in the TDI disconnect handler for abortive
//         disconnects issued by the remote client.
//
//     CleanupPending - SET when cleanup is begun for a connection. This
//         is necessary to know when the final reference to the connection
//         can be removed.
//
//         CODEWORK: We can get rid of the CleanupPending flag. It is
//         only set when either a graceful or abortive disconnect is
//         issued, and only tested in UlpRemoveFinalReference(). The
//         test in UlpRemoveFinalReference() can just test for either
//         (DisconnectPending | AbortPending) instead.
//
//     FinalReferenceRemoved - SET when the final (i.e. "connected")
//         reference is removed from the connection.
//
// Note that the flags requiring UlInterlockedCompareExchange() are only SET,
// never RESET. This makes the implementation a bit simpler.
//
// And now a few words about connection management, TDI, and other mysteries.
//
// Some of the more annoying "features" of TDI are related to connection
// management and lifetime. Two of the most onerous issues are:
//
//     1. Knowing when a connection object handle can be closed without
//        causing an unwanted connection reset.
//
//     2. Knowing when TDI has given its last indication on a connection
//        so that resources can be released, reused, recycled, whatever.
//
// And, of course, this is further complicated by the inherent asynchronous
// nature of the NT I/O architecture and the parallelism of SMP systems.
//
// There are a few points worth keeping in mind while reading/modifying this
// source code or writing clients of this code:
//
//     1. As soon as an accept IRP is returned from the TDI connection
//        handler to the transport, the TDI client must be prepared for
//        any incoming indications, including data receive and disconnect.
//        In other words, incoming data & disconnect may occur *before* the
//        accept IRP actually completes.
//
//     2. A connection is considered "in use" until either both sides have
//        gracefully disconnected OR either side has aborted the connection.
//        Closing an "in use" connection will usually result in an abortive
//        disconnect.
//
//     3. The various flavors of disconnect (initiated by the local server,
//        initiated by the remote client, graceful, abortive, etc) may occur
//        in any order.
//

typedef union _UL_CONNECTION_FLAGS
{
    //
    // This field overlays all of the settable flags. This allows us to
    // update all flags in a thread-safe manner using the
    // UlInterlockedCompareExchange() API.
    //

    ULONG Value;

    struct
    {
        ULONG AcceptPending:1;          // 00000001 Recv SYN
        ULONG AcceptComplete:1;         // 00000002 Accepted
        ULONG :2;
        ULONG DisconnectPending:1;      // 00000010 Send FIN
        ULONG DisconnectComplete:1;     // 00000020 Send FIN
        ULONG :2;
        ULONG AbortPending:1;           // 00000100 Send RST
        ULONG AbortComplete:1;          // 00000200 Send RST
        ULONG :2;
        ULONG DisconnectIndicated:1;    // 00001000 Recv FIN
        ULONG AbortIndicated:1;         // 00002000 Recv RST
        ULONG :2;
        ULONG CleanupBegun:1;           // 00010000
        ULONG FinalReferenceRemoved:1;  // 00020000
        ULONG AbortDisconnect:1;        // 00040000 Send RST after Send FIN
        ULONG :1;
        ULONG LocalAddressValid:1;      // 00100000
        ULONG ReceivePending:1;         // 00200000
        ULONG :2;
        ULONG TdiConnectionInvalid:1;   // 01000000
    };

} UL_CONNECTION_FLAGS;

C_ASSERT( sizeof(UL_CONNECTION_FLAGS) == sizeof(ULONG) );

#define MAKE_CONNECTION_FLAG_ROUTINE(name)                                  \
    __inline ULONG Make##name##Flag()                                       \
    {                                                                       \
        UL_CONNECTION_FLAGS flags = { 0 };                                  \
        flags.name = 1;                                                     \
        return flags.Value;                                                 \
    }

MAKE_CONNECTION_FLAG_ROUTINE( AcceptPending );
MAKE_CONNECTION_FLAG_ROUTINE( AcceptComplete );
MAKE_CONNECTION_FLAG_ROUTINE( DisconnectPending );
MAKE_CONNECTION_FLAG_ROUTINE( DisconnectComplete );
MAKE_CONNECTION_FLAG_ROUTINE( AbortPending );
MAKE_CONNECTION_FLAG_ROUTINE( AbortComplete );
MAKE_CONNECTION_FLAG_ROUTINE( DisconnectIndicated );
MAKE_CONNECTION_FLAG_ROUTINE( AbortIndicated );
MAKE_CONNECTION_FLAG_ROUTINE( CleanupBegun );
MAKE_CONNECTION_FLAG_ROUTINE( FinalReferenceRemoved );
MAKE_CONNECTION_FLAG_ROUTINE( AbortDisconnect );
MAKE_CONNECTION_FLAG_ROUTINE( LocalAddressValid );
MAKE_CONNECTION_FLAG_ROUTINE( ReceivePending );
MAKE_CONNECTION_FLAG_ROUTINE( TdiConnectionInvalid );


typedef enum _UL_CONNECTION_STATE
{
    UlConnectStateConnectIdle,              // Idle
    UlConnectStateConnectCleanup,           // Cleanup
    UlConnectStateConnectReady,             // In Use
    UlConnectStateDisconnectPending,        // Sent FIN
    UlConnectStateDisconnectComplete,       // FIN Completes
    UlConnectStateAbortPending,             // Send RST

    UlConnectStateInvalid                   // TBD
   
} UL_CONNECTION_STATE;


//
// A connection is basically our wrapper around a TDI connection object.
//

typedef struct _UL_CONNECTION
{
    //
    // Link onto the per-endpoint idle connection list.
    //

    SLIST_ENTRY IdleSListEntry;

    //
    // Structure signature: UL_CONNECTION_SIGNATURE
    //

    ULONG Signature;

    //
    // Reference count.
    //

    LONG ReferenceCount;

    //
    // Connection flags.
    //

    UL_CONNECTION_FLAGS ConnectionFlags;

    //
    // To synchronize the RawCloseHandler
    //

    UL_CONNECTION_STATE ConnectionState;
    UL_SPIN_LOCK        ConnectionStateSpinLock;

    //
    // Cached Irp
    //

    PIRP pIrp;

    //
    // Addresses and ports. These are in host order.
    //

    USHORT AddressType;
    USHORT AddressLength;

    union
    {
        UCHAR           RemoteAddress[0];
        TDI_ADDRESS_IP  RemoteAddrIn;
        TDI_ADDRESS_IP6 RemoteAddrIn6;
    };

    union
    {
        UCHAR           LocalAddress[0];
        TDI_ADDRESS_IP  LocalAddrIn;
        TDI_ADDRESS_IP6 LocalAddrIn6;
    };

    //
    // Structure to get LocalAddress when Accept completes
    //

    TDI_CONNECTION_INFORMATION  TdiConnectionInformation;
    UL_TRANSPORT_ADDRESS        Ta;

    //
    // The Inteface & Link IDs as reported by TCP. These are filled
    // only on demand.
    //
    ULONG                       InterfaceId;
    ULONG                       LinkId;
    BOOLEAN                     bRoutingLookupDone;

    //
    //
    // On the endpoint's idle, active, or retiring connections list
    //

    CONN_LIST_STATE ConnListState;
    
    //
    // The TDI connection object.
    //

    UX_TDI_OBJECT ConnectionObject;

    //
    // User context.
    //

    PVOID pConnectionContext;

    //
    // The endpoint associated with this connection. Note that this
    // ALWAYS points to a valid endpoint. For idle connections, it's
    // a weak (non referenced) pointer. For active connections, it's
    // a strong (referenced) pointer.
    //

    PUL_ENDPOINT pOwningEndpoint;

    //
    // TDI wrapper & list managment object associated with the 
    // pOwningEndpoint.
    // 

    PUL_ADDR_IDLE_LIST pOwningAddrIdleList;

    //
    // The processor where this connection was allocated from
    // the idle list
    //
    
    ULONG OriginProcessor;

    //
    // Thread work item for deferred actions.
    //

    UL_WORK_ITEM WorkItem;

    //
    // Data captured from the listening endpoint at the time the
    // connection is created. This is captured to reduce references
    // to the listening endpoint.
    //

    PUL_CONNECTION_DESTROYED pConnectionDestroyedHandler;
    PVOID                    pListeningContext;

    //
    // Pre-allocated IrpContext for disconnect.
    //

    UL_IRP_CONTEXT IrpContext;

    //
    // HTTP connection.
    //

    UL_HTTP_CONNECTION HttpConnection;

    //
    // Filter related info.
    //

    UX_FILTER_CONNECTION FilterInfo;

    //
    // We've had too many problems with orphaned UL_CONNECTIONs.
    // Let's make it easy to find them all in the debugger.
    //

    LIST_ENTRY GlobalConnectionListEntry;

    //
    // Link to the short-lived retiring list in
    // UlpDisconnectAllActiveConnections.
    //

    LIST_ENTRY RetiringListEntry;

#if REFERENCE_DEBUG
    //
    // Private Reference trace log.
    //

    PTRACE_LOG  pTraceLog;
    PTRACE_LOG  pHttpTraceLog;
#endif // REFERENCE_DEBUG

} UL_CONNECTION, *PUL_CONNECTION;

#define UL_CONNECTION_SIGNATURE     MAKE_SIGNATURE('CONN')
#define UL_CONNECTION_SIGNATURE_X   MAKE_FREE_SIGNATURE(UL_CONNECTION_SIGNATURE)

#define IS_VALID_CONNECTION(pConnection)                                    \
    HAS_VALID_SIGNATURE(pConnection, UL_CONNECTION_SIGNATURE)


//
// A buffer, containing a precreated receive IRP, a precreated MDL, and
// sufficient space for a partial MDL. These buffers are typically used
// when passing a receive IRP back to the transport from within our receive
// indication handler.
//
// The buffer structure, IRP, MDLs, and data area are all allocated in a
// single pool block. The layout of the block is:
//
//      +-------------------+
//      |                   |
//      | UL_RECEIVE_BUFFER |
//      |                   |
//      +-------------------+
//      |                   |
//      |        IRP        |
//      |                   |
//      +-------------------+
//      |                   |
//      |        MDL        |
//      |                   |
//      +-------------------+
//      |                   |
//      |    Partial MDL    |
//      |                   |
//      +-------------------+
//      |                   |
//      |     Data Area     |
//      |                   |
//      +-------------------+
//
// WARNING!  All fields of this structure must be explicitly initialized.
//

typedef struct _UL_RECEIVE_BUFFER
{
    //
    // This MUST be the first field in the structure. This is the linkage
    // used by the lookaside package for storing entries in the lookaside
    // list.
    //

    SLIST_ENTRY LookasideEntry;

    //
    // Structure signature: UL_RECEIVE_BUFFER_SIGNATURE
    //

    ULONG Signature;

    //
    // Amount of unread data in the data area.
    //

    ULONG UnreadDataLength;

    //
    // The pre-built receive IRP.
    //

    PIRP pIrp;

    //
    // The pre-built MDL describing the entire data area.
    //

    PMDL pMdl;

    //
    // A secondary MDL describing part of the data area.
    //

    PMDL pPartialMdl;

    //
    // Pointer to the data area for this buffer.
    //

    PVOID pDataArea;

    //
    // Pointer to the connection referencing this buffer.
    //

    PVOID pConnectionContext;

} UL_RECEIVE_BUFFER;

#define UL_RECEIVE_BUFFER_SIGNATURE     MAKE_SIGNATURE('RBUF')
#define UL_RECEIVE_BUFFER_SIGNATURE_X   MAKE_FREE_SIGNATURE(UL_RECEIVE_BUFFER_SIGNATURE)

#define IS_VALID_RECEIVE_BUFFER(pBuffer)                                    \
    HAS_VALID_SIGNATURE(pBuffer, UL_RECEIVE_BUFFER_SIGNATURE)



//
// Private prototypes.
//

VOID
UlpDestroyEndpoint(
    IN PUL_ENDPOINT pEndpoint
    );

VOID
UlpDestroyConnectionWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpDestroyConnection(
    IN PUL_CONNECTION pConnection
    );

PUL_CONNECTION
UlpDequeueIdleConnection(
    IN PUL_ADDR_IDLE_LIST pAddrIdleList
    );

PUL_CONNECTION
UlpDequeueIdleConnectionToDrain(
    IN PUL_ADDR_IDLE_LIST pAddrIdleList
    );

VOID
UlpEnqueueActiveConnection(
    IN PUL_CONNECTION pConnection
    );

NTSTATUS
UlpConnectHandler(
    IN PVOID pTdiEventContext,
    IN LONG RemoteAddressLength,
    IN PVOID pRemoteAddress,
    IN LONG UserDataLength,
    IN PVOID pUserData,
    IN LONG OptionsLength,
    IN PVOID pOptions,
    OUT CONNECTION_CONTEXT *pConnectionContext,
    OUT PIRP *pAcceptIrp
    );

NTSTATUS
UlpDisconnectHandler(
    IN PVOID pTdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN LONG DisconnectDataLength,
    IN PVOID pDisconnectData,
    IN LONG DisconnectInformationLength,
    IN PVOID pDisconnectInformation,
    IN ULONG DisconnectFlags
    );

VOID
UlpDoDisconnectNotification(
    IN PVOID pConnectionContext
    );

NTSTATUS
UlpCloseRawConnection(
    IN PVOID pConnectionContext,
    IN BOOLEAN AbortiveDisconnect,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UlpSendRawData(
    IN PVOID pConnectionContext,
    IN PMDL pMdlChain,
    IN ULONG Length,
    IN PUL_IRP_CONTEXT pIrpContext,
    IN BOOLEAN InitiateDisconnect
    );

NTSTATUS
UlpReceiveRawData(
    IN PVOID pConnectionContext,
    IN PVOID pBuffer,
    IN ULONG BufferLength,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UlpDummyReceiveHandler(
    IN PVOID pTdiEventContext,
    IN PVOID ConnectionContext,
    IN PVOID pTsdu,
    IN ULONG BytesIndicated,
    IN ULONG BytesUnreceived,
    OUT ULONG *pBytesTaken
    );

NTSTATUS
UlpReceiveHandler(
    IN PVOID pTdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *pBytesTaken,
    IN PVOID pTsdu,
    OUT PIRP *pIrp
    );

NTSTATUS
UlpReceiveExpeditedHandler(
    IN PVOID pTdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *pBytesTaken,
    IN PVOID pTsdu,
    OUT PIRP *pIrp
    );

NTSTATUS
UlpRestartAccept(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

NTSTATUS
UlpRestartSendData(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

VOID
UlpReferenceEndpoint(
    IN PUL_ENDPOINT pEndpoint,
    IN REFTRACE_ACTION Action
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

VOID
UlpDereferenceEndpoint(
    IN PUL_ENDPOINT pEndpoint,
    IN PUL_CONNECTION pConnToEnqueue,
    IN REFTRACE_ACTION Action
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define REFERENCE_ENDPOINT(endp, action)                    \
    UlpReferenceEndpoint(                                   \
        (endp),                                             \
        (action)                                            \
        REFERENCE_DEBUG_ACTUAL_PARAMS                       \
        )

#define DEREFERENCE_ENDPOINT_SELF(endp, action)             \
    UlpDereferenceEndpoint(                                 \
        (endp),                                             \
        NULL,                                               \
        (action)                                            \
        REFERENCE_DEBUG_ACTUAL_PARAMS                       \
        )

#define DEREFERENCE_ENDPOINT_CONNECTION(endp, conn, action) \
    UlpDereferenceEndpoint(                                 \
        (endp),                                             \
        (conn),                                             \
        (action)                                            \
        REFERENCE_DEBUG_ACTUAL_PARAMS                       \
        )

VOID
UlpEndpointCleanupWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpCleanupConnectionId(
    IN PUL_CONNECTION pConnection
    );

VOID
UlpConnectionCleanupWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UlpAssociateConnection(
    IN PUL_CONNECTION pConnection,
    IN PUL_ADDR_IDLE_LIST pAddrIdleList
    );

NTSTATUS
UlpDisassociateConnection(
    IN PUL_CONNECTION pConnection
    );

NTSTATUS
UlpInitializeAddrIdleList( 
    IN  PUL_ENDPOINT pEndpoint,
    IN  USHORT Port,
    IN  PUL_TRANSPORT_ADDRESS pTa, 
    IN OUT PUL_ADDR_IDLE_LIST pAddrIdleList 
    );

VOID
UlpCleanupAddrIdleList(
    PUL_ADDR_IDLE_LIST pAddrIdleList
    );

NTSTATUS
UlpReplenishAddrIdleList(
    IN PUL_ADDR_IDLE_LIST pAddrIdleList,
    IN BOOLEAN      PopulateAll
    );

VOID
UlpReplenishAddrIdleListWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpTrimAddrIdleListWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UlpCreateConnection(
    IN PUL_ADDR_IDLE_LIST pAddrIdleList,
    OUT PUL_CONNECTION *ppConnection
    );

NTSTATUS
UlpInitializeConnection(
    IN PUL_CONNECTION pConnection
    );

__inline
VOID
UlpSetConnectionFlag(
    IN OUT PUL_CONNECTION pConnection,
    IN ULONG NewFlag
    )
{
    UL_CONNECTION_FLAGS oldFlags;
    UL_CONNECTION_FLAGS newFlags;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    for (;;)
    {
        //
        // Capture the current value and initialize the new value.
        //

        newFlags.Value = oldFlags.Value =
            *((volatile LONG *) &pConnection->ConnectionFlags.Value);

        newFlags.Value |= NewFlag;

        if (InterlockedCompareExchange(
                (PLONG) &pConnection->ConnectionFlags.Value,
                (LONG) newFlags.Value,
                (LONG) oldFlags.Value
                ) == (LONG) oldFlags.Value)
        {
            break;
        }

        PAUSE_PROCESSOR;

    }

}   // UlpSetConnectionFlag

NTSTATUS
UlpBeginDisconnect(
    IN PIRP pIrp,
    IN PUL_IRP_CONTEXT pIrpContext,
    IN PUL_CONNECTION pConnection,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UlpRestartDisconnect(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

NTSTATUS
UlpBeginAbort(
    IN PUL_CONNECTION pConnection,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UlpRestartAbort(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

VOID
UlpRemoveFinalReference(
    IN PUL_CONNECTION pConnection
    );

NTSTATUS
UlpRestartReceive(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

NTSTATUS
UlpRestartClientReceive(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

NTSTATUS
UlpDisconnectAllActiveConnections(
    IN PUL_ENDPOINT pEndpoint
    );

VOID
UlpUnbindConnectionFromEndpoint(
    IN PUL_CONNECTION pConnection
    );

VOID
UlpSynchronousIoComplete(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

PUL_ENDPOINT
UlpFindEndpointForPort(
    IN USHORT Port
    );

NTSTATUS
UlpOptimizeForInterruptModeration(
    IN PUX_TDI_OBJECT pTdiObject,
    IN BOOLEAN Flag
    );

NTSTATUS
UlpSetNagling(
    IN PUX_TDI_OBJECT pTdiObject,
    IN BOOLEAN Flag
    );

NTSTATUS
UlpRestartQueryAddress(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

VOID
UlpCleanupEarlyConnection(
    IN PUL_CONNECTION pConnection
    );

NTSTATUS
UlpQueryTcpFastSend(
    PWSTR DeviceName,
    OUT PUL_TCPSEND_DISPATCH* pDispatchRoutine
    );

NTSTATUS
UlpBuildTdiReceiveBuffer(
    IN PUX_TDI_OBJECT pTdiObject,
    IN PUL_CONNECTION pConnection,
    OUT PIRP *pIrp
    );

BOOLEAN
UlpConnectionIsOnValidList(
    IN PUL_CONNECTION pConnection
    );

NTSTATUS
UlpPopulateIdleList(
    IN OUT PUL_ADDR_IDLE_LIST pAddrIdleList,
    IN     ULONG              Proc
    );

VOID
UlpTrimAddrIdleList(
    IN OUT PUL_ADDR_IDLE_LIST pAddrIdleList,
       OUT PLIST_ENTRY        pZombieList
    );

VOID
UlpIdleListTrimTimerWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpIdleListTrimTimerDpcRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );

BOOLEAN
UlpIsUrlRouteableInListenScope(
    IN PHTTP_PARSED_URL pParsedUrl
    );

#if DBG

#define SHOW_LIST_INFO(Caller,Info,List,Proc)                   \
    UlTrace(TDI_STATS,                                          \
     ("%s: %s List %p Endp %p Proc %d "                         \
      "Delta %6d Conn Served P/C %5d:%5d PD/BD BLC %d [%5d]:[%5d]\n",  \
       ##Caller,                                                \
       Info,                                                    \
       List,                                                    \
       List->pOwningEndpoint,                                   \
       Proc,                                                    \
       PpslQueryDelta(                                          \
            List->IdleConnectionSListsHandle,                   \
            Proc                                                \
            ),                                                  \
       PpslQueryPrevServed(                                     \
            List->IdleConnectionSListsHandle,                   \
            Proc                                                \
            ),                                                  \
       PpslQueryServed(                                         \
            List->IdleConnectionSListsHandle,                   \
            Proc                                                \
            ),                                                  \
       PpslQueryTotalServed(                                    \
            List->IdleConnectionSListsHandle                    \
            ),                                                  \
       PpslQueryDepth(                                          \
            List->IdleConnectionSListsHandle,                   \
            Proc                                                \
            ),                                                  \
       PpslQueryBackingListDepth(                               \
            List->IdleConnectionSListsHandle                    \
            )                                                   \
       ))

__inline
VOID
UlpTraceIdleConnections(
    VOID
    )
{
    ULONG              Proc;
    ULONG              Index;
    PLIST_ENTRY        pLink;
    PUL_ENDPOINT       pEndpoint;
    PUL_ADDR_IDLE_LIST pAddrIdleList;

    for (pLink  = g_TdiEndpointListHead.Flink;
         pLink != &g_TdiEndpointListHead;
         pLink  = pLink->Flink
         )
    {
        pEndpoint = CONTAINING_RECORD(
                        pLink,
                        UL_ENDPOINT,
                        GlobalEndpointListEntry
                        );

        ASSERT(IS_VALID_ENDPOINT(pEndpoint));

        UlTrace(TDI_STATS,("ENDPOINT: %p AFTER TRIM\n",pEndpoint));

        for (Index = 0; Index < pEndpoint->AddrIdleListCount; Index++)
        {
            pAddrIdleList = &pEndpoint->aAddrIdleLists[Index];

            for (Proc = 0; Proc <= g_UlNumberOfProcessors; Proc++)
            {
                UlTrace(TDI_STATS,
                     ("\tList %p Proc %d Delta %6d P/C [%5d]/[%5d] BLC %d Depth [%5d]\n",
                       pAddrIdleList,
                       Proc,
                       PpslQueryDelta(
                            pAddrIdleList->IdleConnectionSListsHandle,
                            Proc
                            ),
                       PpslQueryPrevServed(
                            pAddrIdleList->IdleConnectionSListsHandle,
                            Proc
                            ),
                       PpslQueryServed(
                            pAddrIdleList->IdleConnectionSListsHandle,
                            Proc
                            ),  
                       PpslQueryTotalServed(
                            pAddrIdleList->IdleConnectionSListsHandle
                            ),
                       PpslQueryDepth(
                            pAddrIdleList->IdleConnectionSListsHandle,
                            Proc
                            )
                       ));
            } 
            UlTrace(TDI_STATS,("\n"));
        }            
    }
}

#define TRACE_IDLE_CONNECTIONS()        \
    IF_DEBUG(TDI_STATS)                 \
    {                                   \
        UlpTraceIdleConnections();      \
    }

__inline
ULONG
UlpZombieListDepth(
    IN PLIST_ENTRY pList
    )
{
    PLIST_ENTRY pLink =  pList;
    ULONG Depth = 0;
    
    while (pLink->Flink != pList)
    {
         Depth++;
         pLink = pLink->Flink;
    }
    
    return Depth;
}

#else 

#define SHOW_LIST_INFO(Caller,Info,List,Proc)

#define TRACE_IDLE_CONNECTIONS()

#endif // DBG


#endif  // _ULTDIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ultdi.h ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    ultdi.h

Abstract:

    This module defines the interface to the TDI/MUX/SSL component.

Author:

    Keith Moore (keithmo)       12-Jun-1998

Revision History:

--*/


#ifndef _ULTDI_H_
#define _ULTDI_H_


//
// Opaque structure pointers. These are defined (privately) in ULTDIP.H.
//

typedef struct _UL_ENDPOINT *PUL_ENDPOINT;
typedef struct _UL_CONNECTION *PUL_CONNECTION;

typedef union _UL_TRANSPORT_ADDRESS
{
    TRANSPORT_ADDRESS   Ta;
    TA_IP_ADDRESS       TaIp;
    TA_IP6_ADDRESS      TaIp6;
} UL_TRANSPORT_ADDRESS, *PUL_TRANSPORT_ADDRESS;


//
// Global data
//

extern ULONG g_TdiListenAddrCount;
extern PUL_TRANSPORT_ADDRESS g_pTdiListenAddresses;
extern LIST_ENTRY g_TdiEndpointListHead;

//
// Routine invoked after an incoming TCP/MUX connection has been
// received (but not yet accepted).
//
// Arguments:
//
//      pListeningContext - Supplies an uninterpreted context value
//          as passed to the UlCreateListeningEndpoint() API.
//
//      pConnection - Supplies the connection being established.
//
//      pRemoteAddress - Supplies the remote (client-side) address
//          requesting the connection.
//
//      RemoteAddressLength - Supplies the total byte length of the
//          pRemoteAddress structure.
//
//      ppConnectionContext - Receives a pointer to an uninterpreted
//          context value to be associated with the new connection if
//          accepted. If the new connection is not accepted, this
//          parameter is ignored.
//
// Return Value:
//
//      BOOLEAN - TRUE if the connection was accepted, FALSE if not.
//

typedef
BOOLEAN
(*PUL_CONNECTION_REQUEST)(
    IN PVOID pListeningContext,
    IN PUL_CONNECTION pConnection,
    IN PTRANSPORT_ADDRESS pRemoteAddress,
    IN ULONG RemoteAddressLength,
    OUT PVOID *ppConnectionContext
    );


//
// Routine invoked after an incoming TCP/MUX connection has been fully
// accepted.
//
// This routine is also invoked if an incoming connection was not accepted
// *after* PUL_CONNECTION_REQUEST returned TRUE. In other words, if
// PUL_CONNECTION_REQUEST indicated that the connection should be accepted
// but a fatal error occurred later, then PUL_CONNECTION_COMPLETE is
// invoked.
//
// Arguments:
//
//      pListeningContext - Supplies an uninterpreted context value
//          as passed to the UlCreateListeningEndpoint() API.
//
//      pConnectionContext - Supplies the uninterpreted context value
//          as returned by PUL_CONNECTION_REQUEST.
//
//      Status - Supplie the completion status. If this value is
//          STATUS_SUCCESS, then the connection is now fully accepted.
//          Otherwise, the connection has been aborted.
//

typedef
VOID
(*PUL_CONNECTION_COMPLETE)(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext,
    IN NTSTATUS Status
    );


//
// Routine invoked after an established TCP/MUX connection has been
// disconnected by the remote (client) side. This routine is only
// called for graceful disconnects initiated by the client, and
// only if the client has not already attempted to close the
// connection itself. The client may wish to close the connection
// when it becomes idle.
//
// Arguments:
//
//      pListeningContext - Supplies an uninterpreted context value
//          as passed to the UlCreateListeningEndpoint() API.
//
//      pConnectionContext - Supplies an uninterpreted context value
//          as returned from the PUL_CONNECTION_REQUEST callback.
//
//

typedef
VOID
(*PUL_CONNECTION_DISCONNECT)(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext
    );

//
// Routine invoked when a graceful disconnect requested by the client
// is complete. The client may want to drain the indicated data on the
// tdi connection to get the above indication.
//

typedef
VOID
(*PUL_CONNECTION_DISCONNECT_COMPLETE)(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext
    );

//
// Routine invoked just before the internal state for a connection
// is destroyed. This is the last chance to cleanup before the
// connection fully disappears.
//
// Arguments:
//
//      pListeningContext - Supplies an uninterpreted context value
//          as passed to the UlCreateListeningEndpoint() API.
//
//      pConnectionContext - Supplies an uninterpreted context value
//          as returned from the PUL_CONNECTION_REQUEST callback.
//

typedef
VOID
(*PUL_CONNECTION_DESTROYED)(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext
    );


//
// Routine invoked after data has been received on an established
// TCP/MUX connection.
//
// Arguments:
//
//      pListeningContext - Supplies an uninterpreted context value
//          as passed to the UlCreateListeningEndpoint() API.
//
//      pConnectionContext - Supplies an uninterpreted context value
//          as returned from the PUL_CONNECTION_REQUEST callback.
//
//      pBuffer - Supplies a pointer to the received data.
//
//      IndicatedLength - Supplies the length of the received data
//          available in pBuffer.
//
//      pTakenLength - Receives the number of bytes consumed by
//          the receive handler.
//
// Return Value:
//
//      NTSTATUS - The status of the consumed data. The behavior of
//          the TDI/MUX component is dependent on the return value
//          and the value set in *pTakenLength, and is defined as
//          follows:
//
//              STATUS_SUCCESS, *pTakenLength == IndicatedLength -
//                  All indicated data was consumed by the receive
//                  handler. Additional incoming data will cause
//                  subsequent receive indications.
//
//              STATUS_SUCCESS, *pTakenLength < IndicatedLength -
//                  Part of the indicated data was consumed by the
//                  receive handler. The network transport will
//                  buffer data and no further indications will be
//                  made until UlReceiveData() is called.
//
//              STATUS_MORE_PROCESSING_REQUIRED - Part of the
//                  indicated data was consumed by the receive handler.
//                  A subsequent receive indication will be made
//                  when additional data is available. The subsequent
//                  indication will include the unconsumed data from
//                  the current indication plus any additional data
//                  received.
//
//              Any other status - Indicates a fatal error in the
//                  receive handler. The connection will be aborted.
//
//              *pTakenLength > IndicatedLength - This is an error
//                  condition and should never occur.
//



//
// Public (within HTTP.SYS) entrypoints.
//

NTSTATUS
UlInitializeTdi(
    VOID
    );

VOID
UlTerminateTdi(
    VOID
    );


VOID
UlWaitForEndpointDrain(
    VOID
    );

ULONG
UlpComputeHttpRawConnectionLength(
    IN PVOID pConnectionContext
    );

ULONG
UlpGenerateHttpRawConnectionInfo(
    IN  PVOID   pContext,
    IN  PUCHAR  pKernelBuffer,
    IN  PVOID   pUserBuffer,
    IN  ULONG   OutputBufferLength,
    IN  PUCHAR  pBuffer,
    IN  ULONG   InitialLength
    );

NTSTATUS
UlCreateListeningEndpoint(
    IN PHTTP_PARSED_URL pParsedUrl,
    IN PUL_CONNECTION_REQUEST pConnectionRequestHandler,
    IN PUL_CONNECTION_COMPLETE pConnectionCompleteHandler,
    IN PUL_CONNECTION_DISCONNECT pConnectionDisconnectHandler,
    IN PUL_CONNECTION_DISCONNECT_COMPLETE pConnectionDisconnectCompleteHandler,
    IN PUL_CONNECTION_DESTROYED pConnectionDestroyedHandler,
    IN PUL_DATA_RECEIVE pDataReceiveHandler,
    OUT PUL_ENDPOINT *ppListeningEndpoint
    );

NTSTATUS
UlCloseListeningEndpoint(
    IN PUL_ENDPOINT pListeningEndpoint,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UlCloseConnection(
    IN PUL_CONNECTION pConnection,
    IN BOOLEAN AbortiveDisconnect,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UlSendData(
    IN PUL_CONNECTION pConnection,
    IN PMDL pMdlChain,
    IN ULONG Length,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext,
    IN PIRP pOwnIrp,
    IN PUL_IRP_CONTEXT pOwnIrpContext,
    IN BOOLEAN InitiateDisconnect,
    IN BOOLEAN RequestComplete
    );

NTSTATUS
UlReceiveData(
    IN PVOID          pConnectionContext,
    IN PVOID pBuffer,
    IN ULONG BufferLength,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UlAddSiteToEndpointList(
    IN PHTTP_PARSED_URL pParsedUrl
    );

NTSTATUS
UlRemoveSiteFromEndpointList(
    IN BOOLEAN UrlSecure,
    IN USHORT  UrlPort
    );

VOID
UlReferenceConnection(
    IN PVOID pConnectionContext
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

VOID
UlDereferenceConnection(
    IN PVOID pConnectionContext
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define REFERENCE_CONNECTION( pconn )                                       \
    UlReferenceConnection(                                                  \
        (pconn)                                                             \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

#define DEREFERENCE_CONNECTION( pconn )                                     \
    UlDereferenceConnection(                                                \
        (pconn)                                                             \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

//
// Prototype for TCP Send routine if Fast Send is possible.
//

typedef
NTSTATUS
(*PUL_TCPSEND_DISPATCH) (
   IN PIRP Irp,
   IN PIO_STACK_LOCATION IrpSp
   );


//
// Connection Refused instrumentation
//

typedef struct _UL_CONNECTION_STATS
{
    ULONG TotalConnections;
    ULONG GlobalLimit;
    ULONG EndpointDying;
    ULONG NoIdleConn;
    ULONG HttpConnCreateFailed;

} UL_CONNECTION_STATS;

extern UL_CONNECTION_STATS              g_UlConnectionStats;
#define UL_INC_CONNECTION_STATS(Stats)  g_UlConnectionStats.Stats++


NTSTATUS
UlRegMultiSzToUlAddrArray(
    IN PWSTR MultiSz,
    OUT PUL_TRANSPORT_ADDRESS *ppTa,
    OUT ULONG *pAddrCount
    );

/***************************************************************************++

Routine Description:

    Free up array of UL_TRANSPORT_ADDRESSES allocated by 
    UlRegMultiSzToUlAddrArray (encapsulates knowledge of pool tag)
    
--***************************************************************************/
__inline 
VOID
UlFreeUlAddr( 
    IN PUL_TRANSPORT_ADDRESS pTa 
    )
{
    ASSERT( pTa );
    UL_FREE_POOL( pTa, UL_TRANSPORT_ADDRESS_POOL_TAG );
} // UlFreeUlAddr


BOOLEAN
UlCheckListeningEndpointState(
    IN PUL_CONNECTION pConnection
    );

NTSTATUS
UlGetConnectionRoutingInfo(
    IN  PUL_CONNECTION pConnection,
    OUT PULONG         pInterfaceId,
    OUT PULONG         pLinkId
    );

#endif  // _ULTDI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\sources.inc ===
TARGETPATH=obj

IASDIR=$(PROJECT_ROOT)\ias

PASS0_HEADERDIR=$(IASDIR)\inc\$(O)

!ifndef IAS_NO_PCH
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=$(IASDIR)\inc\ias.h
PRECOMPILED_OPTION=/Yuias.h /Fp$(O)\pch.pch
PRECOMPILED_TARGET=$(O)\pch.pch
PRECOMPILED_OBJ=$(O)\pch.obj
!endif

USE_ATL=1
USE_MSVCRT=1
USE_NATIVE_EH=1
USE_VCCOM=1
USE_STL=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ultcip.h ===
/*++

   Copyright (c) 2000-2002 Microsoft Corporation

   Module  Name :
       Ultcip.h

   Abstract:
        Private definitions comes here

   Author:
       Ali Ediz Turkoglu      (aliTu)     28-Jul-2000

   Project:
       Internet Information Server 6.0 - HTTP.SYS

   Revision History:

        -
--*/

#ifndef __ULTCIP_H__
#define __ULTCIP_H__


#define OffsetToPtr(Base, Offset)     ((PUCHAR) ((PUCHAR)Base + Offset))

#define IPPROTO_TCP     (6)

//
// Set and Get macros for the QoS FlowSpec for the flows.
// Nt QoS team recommends following FlowSpec for limiting the
// maximum bandwidth;
//
//    ServiceType    = Best Effort
//    TokenRate      = Throttling rate
//    PeakRate       = Throttling Rate
//    MinPolicedSize = 40
//    MaxSduSize     = QOS_NOT_SPECIFIED
//    BucketSize     = TokenRate (bucket to hold upto 1 sec worth of data)
//

#define UL_SET_FLOWSPEC(Flow,BW)    do {                                            \
                                                                                        \
    (Flow).SendingFlowspec.ServiceType       = SERVICETYPE_BESTEFFORT;                  \
    (Flow).SendingFlowspec.TokenRate         = (BW);        /* In Bytes/sec */           \
    (Flow).SendingFlowspec.PeakBandwidth     = (BW);        /* In Bytes/sec */           \
    (Flow).SendingFlowspec.MinimumPolicedSize= 40;          /* In Bytes. perhaps 128*/   \
    (Flow).SendingFlowspec.MaxSduSize        = QOS_NOT_SPECIFIED;                        \
    (Flow).SendingFlowspec.TokenBucketSize   = (BW);        /* In Bytes */               \
    (Flow).SendingFlowspec.Latency           = 0;           /* In microseconds */        \
    (Flow).SendingFlowspec.DelayVariation    = 0;           /* In microseconds */        \
                                                                                        \
    } while (FALSE, FALSE)

#define UL_GET_BW_FRM_FLOWSPEC(Flow)                                                    \
    ((HTTP_BANDWIDTH_LIMIT) (Flow.SendingFlowspec.TokenRate))

#define UL_DEFAULT_WMI_QUERY_BUFFER_SIZE     (2*1024);

//
// For Interface Change Notifications
//

typedef
VOID
(*PUL_TC_NOTIF_HANDLER)(
    IN PWSTR Name,
    IN ULONG NameSize,
    IN PTC_INDICATION_BUFFER pTcBuffer,
    IN ULONG BufferSize
    );

//
// Macro to compare QoS GUIDs
//

#define UL_COMPARE_QOS_NOTIFICATION(rguid1, rguid2)  \
    (RtlCompareMemory((PVOID)rguid1,(PVOID)rguid2,sizeof(GUID)) == sizeof(GUID))

//
// Macro to check the validity of a flow owner.
//

#define ASSERT_FLOW_OWNER(pOwner)   \
        ASSERT(                                                             \
            NULL != (pOwner) &&                                             \
            (IS_VALID_CONFIG_GROUP((PUL_CONFIG_GROUP_OBJECT)(pOwner))       \
            || IS_VALID_CONTROL_CHANNEL((PUL_CONTROL_CHANNEL)(pOwner))      \
            )                                                               \
        )

//
// Private function prototypes
//

NTSTATUS
UlpTcInitializeGpc(
    VOID
    );
NTSTATUS
UlpTcRegisterGpcClient(
    IN  ULONG   CfInfoType
    );
NTSTATUS
UlpTcDeRegisterGpcClient(
    VOID
    );
NTSTATUS
UlpTcInitializeTcpDevice(
    VOID
    );

PUL_TCI_INTERFACE
UlpTcAllocateInterface(
    IN ULONG    DescSize,
    IN PADDRESS_LIST_DESCRIPTOR Desc,
    IN ULONG    NameLength,
    IN PUCHAR   Name,
    IN ULONG    InstanceIDLength,
    IN PUCHAR   InstanceID
    );

NTSTATUS
UlpTcGetInterfaceIndex(
    IN  PUL_TCI_INTERFACE  pIntfc
    );
NTSTATUS
UlpTcGetFriendlyNames(
    VOID
    );

NTSTATUS
UlpTcReleaseAll(
    VOID
    );
NTSTATUS
UlpTcCloseInterface(
    PUL_TCI_INTERFACE  pInterface
    );
NTSTATUS
UlpTcCloseAllInterfaces(
    VOID
    );

NTSTATUS
UlpTcWalkWnode(
   IN PWNODE_HEADER pWnodeHdr,
   IN PUL_TC_NOTIF_HANDLER pNotifHandler
   );

VOID
UlpTcHandleIfcUp(
    IN PWSTR Name,
    IN ULONG NameSize,
    IN PTC_INDICATION_BUFFER pTcBuffer,
    IN ULONG BufferSize
    );
VOID
UlpTcHandleIfcDown(
    IN PWSTR Name,
    IN ULONG NameSize,
    IN PTC_INDICATION_BUFFER pTcBuffer,
    IN ULONG BufferSize
    );
VOID
UlpTcHandleIfcChange(
    IN PWSTR Name,
    IN ULONG NameSize,
    IN PTC_INDICATION_BUFFER pTcBuffer,
    IN ULONG BufferSize
    );

NTSTATUS
UlpTcRegisterForCallbacks(
    VOID
    );

NTSTATUS
UlpTcDeleteFlow(
    IN PUL_TCI_FLOW        pFlow
    );
NTSTATUS
UlpTcDeleteGpcFlow(
    HANDLE  FlowHandle
    );

PUL_TCI_FLOW
UlpTcAllocateFlow(
    IN HTTP_BANDWIDTH_LIMIT MaxBandwidth
    );

NTSTATUS
UlpModifyFlow(
    IN  PUL_TCI_INTERFACE   pInterface,
    IN  PUL_TCI_FLOW        pFlow
    );
NTSTATUS
UlpAddFlow(
    IN  PUL_TCI_INTERFACE  pInterface,
    IN  PUL_TCI_FLOW       pGenericFlow,
    OUT PHANDLE            pHandle
    );

NTSTATUS
UlpTcAddFilter(
    IN   PUL_TCI_FLOW       pFlow,
    IN   PTC_GEN_FILTER     pGenericFilter,
    IN   ULONG              LinkId,
    OUT  PUL_TCI_FILTER     *ppFilter
    );

NTSTATUS
UlpTcDeleteFilter(
    IN PUL_TCI_FLOW     pFlow,
    IN PUL_TCI_FILTER   pFilter
    );
NTSTATUS
UlpTcDeleteGpcFilter(
    IN  HANDLE          FilterHandle
    );

VOID
UlpInsertFilterEntry(
    IN      PUL_TCI_FILTER      pEntry,
    IN OUT  PUL_TCI_FLOW        pFlow
    );

VOID
UlpRemoveFilterEntry(
    IN      PUL_TCI_FILTER  pEntry,
    IN OUT  PUL_TCI_FLOW    pFlow
    );

PUL_TCI_FLOW
UlpFindFlow(
    IN PVOID            pOwner,
    IN BOOLEAN          Global,
    IN ULONG            InterfaceId,
    IN ULONG            LinkId
    );

PUL_TCI_INTERFACE
UlpFindInterface(
    IN ULONG  IpAddr
    );

NTSTATUS
UlpTcDeviceControl(
    IN  HANDLE                          FileHandle,
    IN  HANDLE                          EventHandle,
    IN  PIO_APC_ROUTINE                 ApcRoutine,
    IN  PVOID                           ApcContext,
    OUT PIO_STATUS_BLOCK                pIoStatBlock,
    IN  ULONG                           Ioctl,
    IN  PVOID                           InBuffer,
    IN  ULONG                           InBufferSize,
    IN  PVOID                           OutBuffer,
    IN  ULONG                           OutBufferSize
    );

VOID
UlDumpTCInterface(
        PUL_TCI_INTERFACE pTcIfc
        );
VOID
UlDumpTCFlow(
        PUL_TCI_FLOW pFlow
        );
VOID
UlDumpTCFilter(
        PUL_TCI_FILTER pFilter
        );

BOOLEAN
UlpMatchTcInterface(
    IN  PUL_TCI_INTERFACE  pIntfc,
    IN  ULONG              InterfaceId,
    IN  ULONG              LinkId
    );

// Some helper dumpers

#if DBG

#define UL_DUMP_TC_INTERFACE( pTcIfc )          \
    UlDumpTCInterface(                          \
        (pTcIfc)                                \
        )
#define UL_DUMP_TC_FLOW( pFlow )                \
    UlDumpTCFlow(                               \
        (pFlow)                                 \
        )
#define UL_DUMP_TC_FILTER( pFilter )            \
    UlDumpTCFilter(                             \
        (pFilter)                               \
        )

#else  // !DBG

#define UL_DUMP_TC_INTERFACE( pTcIfc )  NOP_FUNCTION
#define UL_DUMP_TC_FLOW( pFlow )        NOP_FUNCTION
#define UL_DUMP_TC_FILTER( pFilter )    NOP_FUNCTION

#endif // !DBG


#endif // __ULTCIP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ias\iasjet\dll\resource.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, Microsoft Corp. All rights reserved.
//
// FILE
//
//    resource.h
//
// SYNOPSIS
//
//    Resource declarations.
//
// MODIFICATION HISTORY
//
//    04/13/2000    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef RESOURCE_H
#define RESOURCE_H
#if _MSC_VER >= 1000
#pragma once
#endif

#define IDR_REGISTRY    101

#endif // RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\http\sys\ultdi.c ===
/*++

Copyright (c) 1998-2002 Microsoft Corporation

Module Name:

    ultdi.c

Abstract:

    This module implements the TDI component.

Author:

    Keith Moore (keithmo)       15-Jun-1998

Revision History:

--*/


#include "precomp.h"

//
// Private globals.
//

//
// Global lists of all active and all waiting-to-be-deleted endpoints.
//

LIST_ENTRY g_TdiEndpointListHead;
LIST_ENTRY g_TdiDeletedEndpointListHead;    // for debugging
ULONG      g_TdiEndpointCount;   // #elements in active endpoint list

//
// Global lists of all connections, active, idle, or retiring
//

LIST_ENTRY g_TdiConnectionListHead;
ULONG      g_TdiConnectionCount;   // #elements in connection list

//
// Global list of all addresses to use when creating a listening
// endpoint object
//

ULONG g_TdiListenAddrCount = 0;
PUL_TRANSPORT_ADDRESS g_pTdiListenAddresses = NULL;

//
// Spinlock protecting the above lists.
//

UL_SPIN_LOCK g_TdiSpinLock;

//
// Global initialization flag.
//

BOOLEAN g_TdiInitialized = FALSE;

//
// Used to wait for endpoints and connections to close on shutdown
//

BOOLEAN g_TdiWaitingForEndpointDrain;
KEVENT  g_TdiEndpointDrainEvent;
KEVENT  g_TdiConnectionDrainEvent;

//
// TDI Send routine if Fast Send is possible.
//

PUL_TCPSEND_DISPATCH g_TcpFastSendIPv4 = NULL;
PUL_TCPSEND_DISPATCH g_TcpFastSendIPv6 = NULL;

//
// Connection statistics.
//

UL_CONNECTION_STATS g_UlConnectionStats;

//
// The idle list trim timer.
//

UL_TRIM_TIMER   g_UlTrimTimer;


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeTdi )
#pragma alloc_text( PAGE, UlCloseListeningEndpoint )
#pragma alloc_text( PAGE, UlpEndpointCleanupWorker )
#pragma alloc_text( PAGE, UlpDestroyConnectionWorker )
#pragma alloc_text( PAGE, UlpAssociateConnection )
#pragma alloc_text( PAGE, UlpDisassociateConnection )
#pragma alloc_text( PAGE, UlpInitializeAddrIdleList )
#pragma alloc_text( PAGE, UlpCleanupAddrIdleList )
#pragma alloc_text( PAGE, UlpReplenishAddrIdleList )
#pragma alloc_text( PAGE, UlpOptimizeForInterruptModeration )
#pragma alloc_text( PAGE, UlpSetNagling )
#pragma alloc_text( PAGE, UlpPopulateIdleList )
#pragma alloc_text( PAGE, UlpIdleListTrimTimerWorker )
#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlWaitForEndpointDrain
NOT PAGEABLE -- UlCreateListeningEndpoint
NOT PAGEABLE -- UlCloseConnection
NOT PAGEABLE -- UlReceiveData
NOT PAGEABLE -- UlSendData
NOT PAGEABLE -- UlAddSiteToEndpointList
NOT PAGEABLE -- UlRemoveSiteFromEndpointList
NOT PAGEABLE -- UlpReplenishAddrIdleListWorker
NOT PAGEABLE -- UlpDestroyEndpoint
NOT PAGEABLE -- UlpDestroyConnection
NOT PAGEABLE -- UlpDequeueIdleConnectionToDrain
NOT PAGEABLE -- UlpDequeueIdleConnection
NOT PAGEABLE -- UlpEnqueueActiveConnection
NOT PAGEABLE -- UlpConnectHandler
NOT PAGEABLE -- UlpDisconnectHandler
NOT PAGEABLE -- UlpDoDisconnectNotification
NOT PAGEABLE -- UlpCloseRawConnection
NOT PAGEABLE -- UlpQueryTcpFastSend
NOT PAGEABLE -- UlpSendRawData
NOT PAGEABLE -- UlpReceiveRawData
NOT PAGEABLE -- UlpReceiveHandler
NOT PAGEABLE -- UlpDummyReceiveHandler
NOT PAGEABLE -- UlpReceiveExpeditedHandler
NOT PAGEABLE -- UlpRestartAccept
NOT PAGEABLE -- UlpRestartSendData
NOT PAGEABLE -- UlpReferenceEndpoint
NOT PAGEABLE -- UlpDereferenceEndpoint
NOT PAGEABLE -- UlReferenceConnection
NOT PAGEABLE -- UlDereferenceConnection
NOT PAGEABLE -- UlpCleanupConnectionId
NOT PAGEABLE -- UlpCleanupEarlyConnection
NOT PAGEABLE -- UlpConnectionCleanupWorker
NOT PAGEABLE -- UlpCreateConnection
NOT PAGEABLE -- UlpInitializeConnection
NOT PAGEABLE -- UlpBeginDisconnect
NOT PAGEABLE -- UlpRestartDisconnect
NOT PAGEABLE -- UlpBeginAbort
NOT PAGEABLE -- UlpRestartAbort
NOT PAGEABLE -- UlpRemoveFinalReference
NOT PAGEABLE -- UlpRestartReceive
NOT PAGEABLE -- UlpRestartClientReceive
NOT PAGEABLE -- UlpDisconnectAllActiveConnections
NOT PAGEABLE -- UlpUnbindConnectionFromEndpoint
NOT PAGEABLE -- UlpSynchronousIoComplete
NOT PAGEABLE -- UlpFindEndpointForPort
NOT PAGEABLE -- UlpRestartQueryAddress
NOT PAGEABLE -- UlpIdleListTrimTimerDpcRoutine
NOT PAGEABLE -- UlpSetIdleListTrimTimer
NOT PAGEABLE -- UlCheckListeningEndpointState
NOT PAGEABLE -- UlpIsUrlRouteableInListenScope
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Performs global initialization of this module.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlInitializeTdi(
    VOID
    )
{
    NTSTATUS status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( !g_TdiInitialized );

    //
    // Initialize global data.
    //

    InitializeListHead( &g_TdiEndpointListHead );
    InitializeListHead( &g_TdiDeletedEndpointListHead );
    InitializeListHead( &g_TdiConnectionListHead );
    UlInitializeSpinLock( &g_TdiSpinLock, "g_TdiSpinLock" );

    g_TdiEndpointCount = 0;
    g_TdiConnectionCount = 0;

    RtlZeroMemory(&g_UlConnectionStats, sizeof(g_UlConnectionStats));

    KeInitializeEvent(
        &g_TdiEndpointDrainEvent,
        NotificationEvent,
        FALSE
        );

    KeInitializeEvent(
        &g_TdiConnectionDrainEvent,
        NotificationEvent,
        FALSE
        );

    if (g_UlIdleConnectionsHighMark == DEFAULT_IDLE_CONNECTIONS_HIGH_MARK)
    {
        //
        // Let's start with one connection per 2 MB and enforce a 64-512 range.
        //

        g_UlIdleConnectionsHighMark = (USHORT) g_UlTotalPhysicalMemMB / 2;
        g_UlIdleConnectionsHighMark = MAX(64, g_UlIdleConnectionsHighMark);
        g_UlIdleConnectionsHighMark = MIN(512, g_UlIdleConnectionsHighMark);
    }

    if (g_UlIdleConnectionsLowMark == DEFAULT_IDLE_CONNECTIONS_LOW_MARK)
    {
        //
        // To reduce the NPP usage on inactive endpoints. Pick the low mark
        // as small as possible, however not too small to surface a connection
        // drop problem. If we pick 1/4 of high, this would give us a range
        // of (16 .. 128).
        //

        g_UlIdleConnectionsLowMark     = g_UlIdleConnectionsHighMark / 8;
    }

    UlTrace(TDI_STATS, (
        "UlInitializeTdi ...\n"
        "\tg_UlTotalPhysicalMemMB     : %d\n"
        "\tg_UlIdleConnectionsLowMark : %d\n"
        "\tg_UlIdleConnectionsHighMark: %d\n",
        g_UlTotalPhysicalMemMB,
        g_UlIdleConnectionsLowMark,
        g_UlIdleConnectionsHighMark
        ));

    if (g_UlMaxEndpoints == DEFAULT_MAX_ENDPOINTS)
    {
        //
        // Compute a default based on physical memory.  This starts at 16
        // for a 64MB machine and it is capped at 64 for a 256MB+ machine.
        //

        g_UlMaxEndpoints = (USHORT) g_UlTotalPhysicalMemMB / 4;
        g_UlMaxEndpoints = MIN(64, g_UlMaxEndpoints);
    }

    //
    // Init the idle list trim timer.
    //

    g_UlTrimTimer.Initialized = TRUE;
    g_UlTrimTimer.Started   = FALSE;

    UlInitializeSpinLock(&g_UlTrimTimer.SpinLock,"IdleListTrimTimerSpinLock");

    KeInitializeDpc(&g_UlTrimTimer.DpcObject,
                    &UlpIdleListTrimTimerDpcRoutine,
                    NULL
                    );

    KeInitializeTimer(&g_UlTrimTimer.Timer);

    UlInitializeWorkItem(&g_UlTrimTimer.WorkItem);
    g_UlTrimTimer.WorkItemScheduled = FALSE;
    InitializeListHead(&g_UlTrimTimer.ZombieConnectionListHead);

    //
    // Init list of addresses to listen on if it hasn't been done already
    //

    if ( !g_pTdiListenAddresses )
    {
        PUL_TRANSPORT_ADDRESS pTa, pTaCurrent;
        USHORT ip6addr_any[8] = { 0 };

        //
        // Allocate for two addresses, INADDR_ANY and in6addr_any.
        //
        // CODEWORK: check if IPv6 is enabled to see if we should add IPv6
        // address.

        pTa = UL_ALLOCATE_ARRAY(
                    NonPagedPool,
                    UL_TRANSPORT_ADDRESS,
                    2,
                    UL_TRANSPORT_ADDRESS_POOL_TAG
                    );

        if (pTa == NULL)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        g_TdiListenAddrCount = 2;
        g_pTdiListenAddresses = pTa;

        RtlZeroMemory( pTa, g_TdiListenAddrCount * sizeof(UL_TRANSPORT_ADDRESS) );
        pTaCurrent = &pTa[0];

        UlInitializeIpTransportAddress( &(pTa[0].TaIp), 0L, 0 );
        UlInitializeIp6TransportAddress( &(pTa[1].TaIp6), ip6addr_any, 0, 0 );
    }

    // NOTE: we always want to be dual stack (IPv4/IPv6).

    status = UlpQueryTcpFastSend(DD_TCP_DEVICE_NAME, &g_TcpFastSendIPv4);

    if (NT_SUCCESS(status))
    {
        NTSTATUS status6;

        status6 = UlpQueryTcpFastSend(DD_TCPV6_DEVICE_NAME, &g_TcpFastSendIPv6);
    }

    if (NT_SUCCESS(status))
    {
        g_TdiInitialized = TRUE;
    }

    return status;

}   // UlInitializeTdi


/***************************************************************************++

Routine Description:

    Performs global termination of this module.

--***************************************************************************/
VOID
UlTerminateTdi(
    VOID
    )
{
    KIRQL OldIrql;

    //
    // Sanity check.
    //

    if (g_TdiInitialized)
    {
        UlTrace(TDI,
                ("UlTerminateTdi: connections refused:\n"
                 "\tTotalConnections=%lu\n"
                 "\tGlobalLimit=%lu\n"
                 "\tEndpointDying=%lu\n"
                 "\tNoIdleConn=%lu\n",
                 g_UlConnectionStats.TotalConnections,
                 g_UlConnectionStats.GlobalLimit,
                 g_UlConnectionStats.EndpointDying,
                 g_UlConnectionStats.NoIdleConn
                 ));

        ASSERT( IsListEmpty( &g_TdiEndpointListHead )) ;
        ASSERT( IsListEmpty( &g_TdiDeletedEndpointListHead )) ;
        ASSERT( IsListEmpty( &g_TdiConnectionListHead )) ;
        ASSERT( g_TdiEndpointCount == 0 );
        ASSERT( g_TdiConnectionCount == 0 );

        UlAcquireSpinLock(&g_UlTrimTimer.SpinLock, &OldIrql);

        g_UlTrimTimer.Initialized = FALSE;

        KeCancelTimer(&g_UlTrimTimer.Timer);

        UlReleaseSpinLock(&g_UlTrimTimer.SpinLock, OldIrql);

        g_TdiInitialized = FALSE;
    }

}   // UlTerminateTdi

/***************************************************************************++

Routine Description:

    One minute idle timer for trimming the idle list of each endpoint.

Arguments:

    None

--***************************************************************************/

VOID
UlpSetIdleListTrimTimer(
    VOID
    )
{
    LONGLONG        BufferPeriodTime100Ns;
    LONG            BufferPeriodTimeMs;
    LARGE_INTEGER   BufferPeriodTime;

    //
    // Remaining time to next tick. Default value is in seconds.
    //

    BufferPeriodTimeMs    = g_UlIdleListTrimmerPeriod * 1000;
    BufferPeriodTime100Ns = (LONGLONG) BufferPeriodTimeMs * 10 * 1000;

    //
    // Negative time for relative value.
    //

    BufferPeriodTime.QuadPart = -BufferPeriodTime100Ns;

    KeSetTimerEx(
        &g_UlTrimTimer.Timer,
        BufferPeriodTime,           // Must be in nanosec
        BufferPeriodTimeMs,         // Must be in millisec
        &g_UlTrimTimer.DpcObject
        );
}

/***************************************************************************++

Routine Description:

    This function blocks until the endpoint list is empty. It also prevents
    new endpoints from being created.

Arguments:

    None.

--***************************************************************************/
VOID
UlWaitForEndpointDrain(
    VOID
    )
{
    KIRQL oldIrql;
    BOOLEAN WaitConnection = FALSE;
    BOOLEAN WaitEndpoint = FALSE;
    ULONG WaitCount = 0;

    if (g_TdiInitialized)
    {
        UlAcquireSpinLock( &g_TdiSpinLock, &oldIrql );

        if (!g_TdiWaitingForEndpointDrain)
        {
            g_TdiWaitingForEndpointDrain = TRUE;
        }

        if (g_TdiEndpointCount > 0)
        {
            WaitEndpoint = TRUE;
        }

        if (g_TdiConnectionCount > 0)
        {
            WaitConnection = TRUE;
        }

        UlReleaseSpinLock( &g_TdiSpinLock, oldIrql );

        if (WaitConnection || WaitEndpoint)
        {
            PVOID Events[2];

            if (WaitEndpoint && WaitConnection)
            {
                Events[0] = &g_TdiEndpointDrainEvent;
                Events[1] = &g_TdiConnectionDrainEvent;
                WaitCount = 2;
            }
            else
            {
                if (WaitEndpoint)
                {
                    Events[0] = &g_TdiEndpointDrainEvent;
                }
                else
                {
                    Events[0] = &g_TdiConnectionDrainEvent;
                }

                Events[1] = NULL;
                WaitCount = 1;
            }

            KeWaitForMultipleObjects(
                WaitCount,
                Events,
                WaitAll,
                UserRequest,
                KernelMode,
                FALSE,
                NULL,
                NULL
                );
        }
    }

} // UlWaitForEndpointDrain


/***************************************************************************++

Routine Description:

    Creates a new listening endpoint bound to the specified port on
    all available TDI addresses (see: g_TdiListenAddresses and
    g_TdiListenAddressCount).

Arguments:

    Port - TCP Port for this endpoint.

    InitialBacklog - Supplies the initial number of idle connections
        to add to the endpoint.

    pConnectionRequestHandler - Supplies a pointer to an indication
        handler to invoke when incoming connections arrive.

    pConnectionCompleteHandler - Supplies a pointer to an indication
        handler to invoke when either a) the incoming connection is
        fully accepted, or b) the incoming connection could not be
        accepted due to a fatal error.

    pConnectionDisconnectHandler - Supplies a pointer to an indication
        handler to invoke when connections are disconnected by the
        remote (client) side.

    pConnectionDestroyedHandler - Supplies a pointer to an indication
        handle to invoke after a connection has been fully destroyed.
        This is typically the TDI client's opportunity to cleanup
        any allocated resources.

    pDataReceiveHandler - Supplies a pointer to an indication handler to
        invoke when incoming data arrives.

    pListeningContext - Supplies an uninterpreted context value to
        associate with the new listening endpoint.

    ppListeningEndpoint - Receives a pointer to the new listening
        endpoint if successful.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCreateListeningEndpoint(
    IN PHTTP_PARSED_URL pParsedUrl,
    IN PUL_CONNECTION_REQUEST pConnectionRequestHandler,
    IN PUL_CONNECTION_COMPLETE pConnectionCompleteHandler,
    IN PUL_CONNECTION_DISCONNECT pConnectionDisconnectHandler,
    IN PUL_CONNECTION_DISCONNECT_COMPLETE pConnectionDisconnectCompleteHandler,
    IN PUL_CONNECTION_DESTROYED pConnectionDestroyedHandler,
    IN PUL_DATA_RECEIVE pDataReceiveHandler,
    OUT PUL_ENDPOINT *ppListeningEndpoint
    )
{
    NTSTATUS status;
    PUL_ENDPOINT pEndpoint;
    ULONG i;
    ULONG AddrIdleListSize;
    ULONG FailedAddrIdleList;
    KIRQL OldIrql;
    WCHAR IpAddressString[MAX_IP_ADDR_AND_PORT_STRING_LEN + 1];
    USHORT   BytesWritten;
    USHORT   Port;

    //
    // Sanity check.
    //

    ASSERT( pParsedUrl );

    Port = SWAP_SHORT(pParsedUrl->PortNumber);

    ASSERT( Port > 0 );

    //
    // Setup locals so we know how to cleanup on a fatal exit.
    //

    pEndpoint = NULL;

    if (!g_pTdiListenAddresses || (0 == g_TdiListenAddrCount))
    {
        // Fail.  We have failed to initialize properly.
        // REVIEW: is there a better return code in this case?
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto fatal;
    }

    //
    // Allocate enough pool for the endpoint structure and the
    // array of UL_ADDR_IDLE_LISTs.
    //

    AddrIdleListSize = g_TdiListenAddrCount * sizeof(UL_ADDR_IDLE_LIST);
    pEndpoint = UL_ALLOCATE_STRUCT_WITH_SPACE(
                    NonPagedPool,
                    UL_ENDPOINT,
                    AddrIdleListSize,
                    UL_ENDPOINT_POOL_TAG
                    );

    if (pEndpoint == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto fatal;
    }

    //
    // Initialize the easy parts.
    //

    pEndpoint->Signature = UL_ENDPOINT_SIGNATURE;
    pEndpoint->ReferenceCount = 0;
    pEndpoint->UsageCount = 1;

    WRITE_REF_TRACE_LOG(
        g_pEndpointUsageTraceLog,
        REF_ACTION_REFERENCE_ENDPOINT_USAGE,
        pEndpoint->UsageCount,
        pEndpoint,
        __FILE__,
        __LINE__
        );

    UlInitializeWorkItem(&pEndpoint->WorkItem);
    pEndpoint->WorkItemScheduled = FALSE;

    REFERENCE_ENDPOINT(pEndpoint, REF_ACTION_INIT);
    REFERENCE_ENDPOINT(pEndpoint, REF_ACTION_ENDPOINT_USAGE_REFERENCE);
    REFERENCE_ENDPOINT(pEndpoint, REF_ACTION_ENDPOINT_EVENT_REFERENCE);

    pEndpoint->pConnectionRequestHandler = pConnectionRequestHandler;
    pEndpoint->pConnectionCompleteHandler = pConnectionCompleteHandler;
    pEndpoint->pConnectionDisconnectHandler = pConnectionDisconnectHandler;
    pEndpoint->pConnectionDisconnectCompleteHandler = pConnectionDisconnectCompleteHandler;
    pEndpoint->pConnectionDestroyedHandler = pConnectionDestroyedHandler;
    pEndpoint->pDataReceiveHandler = pDataReceiveHandler;
    pEndpoint->pListeningContext = (PVOID)pEndpoint;

    pEndpoint->LocalPort = Port;
    pEndpoint->Secure = pParsedUrl->Secure;
    pEndpoint->Counted = FALSE;
    pEndpoint->Deleted = FALSE;
    pEndpoint->GlobalEndpointListEntry.Flink = NULL;

    RtlZeroMemory(
        &pEndpoint->CleanupIrpContext,
        sizeof(UL_IRP_CONTEXT)
        );

    pEndpoint->CleanupIrpContext.Signature = UL_IRP_CONTEXT_SIGNATURE;

    //
    // build array of Listening Address Objects
    //

    ASSERT( g_TdiListenAddrCount > 0 );
    pEndpoint->AddrIdleListCount = g_TdiListenAddrCount;
    // Address Idle Lists immediately follow the UL_ENDPOINT object
    pEndpoint->aAddrIdleLists = (PUL_ADDR_IDLE_LIST)(&pEndpoint[1]);

    RtlZeroMemory(
        pEndpoint->aAddrIdleLists,
        AddrIdleListSize
        );

    FailedAddrIdleList = 0;

    for ( i = 0; i < pEndpoint->AddrIdleListCount; i++ )
    {
        status = UlpInitializeAddrIdleList(
                    pEndpoint,
                    Port,
                    &g_pTdiListenAddresses[i],
                    &pEndpoint->aAddrIdleLists[i]
                    );

        if (!NT_SUCCESS(status))
        {
            //
            // NOTE: STATUS_OBJECT_NOT_FOUND is returned if the underlying 
            // transport is not present on the system (e.g. IPv6).
            // 

            if(status != STATUS_OBJECT_NAME_NOT_FOUND)
            {
                PUL_TRANSPORT_ADDRESS pTa;

                pTa = &pEndpoint->aAddrIdleLists[i].LocalAddress;

                BytesWritten =
                    HostAddressAndPortToStringW(
                             IpAddressString,
                             pTa->Ta.Address->Address,
                             pTa->Ta.Address->AddressType
                             );

                ASSERT(BytesWritten <=
                        (MAX_IP_ADDR_AND_PORT_STRING_LEN * sizeof(WCHAR)));

                UlEventLogOneStringEntry(
                    EVENT_HTTP_CREATE_ENDPOINT_FAILED,
                    IpAddressString,
                    TRUE,
                    status
                    );

                goto fatal;
            }

            FailedAddrIdleList++;
            continue; // ignore; makes cleanup easier.
        }

        //
        // Replenish the idle connection pool.
        //
        status = UlpReplenishAddrIdleList( 
                    &pEndpoint->aAddrIdleLists[i], 
                    TRUE 
                    );

        if (!NT_SUCCESS(status))
        {
            goto fatal;
        }
    }

    //
    // see if we got at least one valid AO
    //

    if ( FailedAddrIdleList == pEndpoint->AddrIdleListCount )
    {
        // No valid AO's created; fail the endpoint creation!
        status = STATUS_INVALID_ADDRESS;
        goto fatal;       
    }

    //
    // Put the endpoint onto the global list.
    //

    UlAcquireSpinLock( &g_TdiSpinLock, &OldIrql );

    //
    // Check if we have exceeded the g_UlMaxEndpoints limit.
    //

    if (g_TdiEndpointCount >= g_UlMaxEndpoints)
    {
        status = STATUS_ALLOTTED_SPACE_EXCEEDED;
        UlReleaseSpinLock( &g_TdiSpinLock, OldIrql );
        goto fatal;
    }

    InsertTailList(
        &g_TdiEndpointListHead,
        &pEndpoint->GlobalEndpointListEntry
        );

    g_TdiEndpointCount++;
    pEndpoint->Counted = TRUE;

    UlReleaseSpinLock( &g_TdiSpinLock, OldIrql );

    //
    // Now we have at least one endpoint, kick the idle timer to action.
    //

    UlAcquireSpinLock(&g_UlTrimTimer.SpinLock, &OldIrql);
    if (g_UlTrimTimer.Started == FALSE)
    {
        UlpSetIdleListTrimTimer();
        g_UlTrimTimer.Started = TRUE;
    }
    UlReleaseSpinLock(&g_UlTrimTimer.SpinLock, OldIrql);

    //
    // Success!
    //

    UlTrace(TDI, (
        "UlCreateListeningEndpoint: endpoint %p, port %d\n",
        pEndpoint,
        SWAP_SHORT(Port)
        ));

    *ppListeningEndpoint = pEndpoint;
    return STATUS_SUCCESS;

fatal:

    ASSERT( !NT_SUCCESS(status) );

    if (pEndpoint != NULL)
    {
        PUL_ADDR_IDLE_LIST pAddrIdleList = pEndpoint->aAddrIdleLists;

        //
        // Remove connect event handler so we won't get any more
        // indications that could add a reference.
        //
        // These calls could fail, but there's basically nothing
        // we can do about it if they do.
        //

        for ( i = 0; i < pEndpoint->AddrIdleListCount; i++ )
        {
            if (pAddrIdleList->AddressObject.pDeviceObject)
            {
                //
                // Close the TDI object.
                //

                UxCloseTdiObject( &pAddrIdleList->AddressObject );
            }

            pAddrIdleList++;
        }

        //
        // Release the three references on the endpoint, which
        // will cause it to destroy itself.
        //

        ASSERT( 3 == pEndpoint->ReferenceCount );
        pEndpoint->UsageCount = 0;  // to prevent assertions

        WRITE_REF_TRACE_LOG(
            g_pEndpointUsageTraceLog,
            REF_ACTION_DEREFERENCE_ENDPOINT_USAGE,
            pEndpoint->UsageCount,
            pEndpoint,
            __FILE__,
            __LINE__
            );

        DEREFERENCE_ENDPOINT_SELF(
            pEndpoint,
            REF_ACTION_ENDPOINT_EVENT_DEREFERENCE
            );
        DEREFERENCE_ENDPOINT_SELF(
            pEndpoint, REF_ACTION_ENDPOINT_USAGE_DEREFERENCE
            );
        DEREFERENCE_ENDPOINT_SELF(
            pEndpoint, REF_ACTION_FINAL_DEREF
            );
    }

    return status;

}   // UlCreateListeningEndpoint


/***************************************************************************++

Routine Description:

    Closes an existing listening endpoint.

Arguments:

    pListeningEndpoint - Supplies a pointer to a listening endpoint
        previously created with UlCreateListeningEndpoint().

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the listening endpoint is fully closed.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCloseListeningEndpoint(
    IN PUL_ENDPOINT pListeningEndpoint,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    )
{
    PUL_IRP_CONTEXT pIrpContext;
    NTSTATUS status;
    PUL_ADDR_IDLE_LIST pAddrIdleList;
    PUL_CONNECTION pConnection;
    ULONG i;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_ENDPOINT( pListeningEndpoint ) );
    ASSERT( pCompletionRoutine != NULL );

    UlTrace(TDI, (
        "UlCloseListeningEndpoint: endpoint %p, completion %p, ctx %p\n",
        pListeningEndpoint,
        pCompletionRoutine,
        pCompletionContext
        ));

    //
    // Remember completion information to be used when
    // we're done cleaning up.
    //

    pIrpContext = &pListeningEndpoint->CleanupIrpContext;

    pIrpContext->pCompletionRoutine = pCompletionRoutine;
    pIrpContext->pCompletionContext = pCompletionContext;
    pIrpContext->pOwnIrp            = NULL;
    pIrpContext->OwnIrpContext      = TRUE;

    //
    // Remove connect event handler so we won't get any more
    // indications that could add a reference.
    //
    // These calls could fail, but there's basically nothing
    // we can do about it if they do.
    //
    // Once we're done we remove the reference we held
    // on the endpoint for the handlers.
    //

    pAddrIdleList = pListeningEndpoint->aAddrIdleLists;
    for ( i = 0; i < pListeningEndpoint->AddrIdleListCount; i++ )
    {
        if ( pAddrIdleList->AddressObject.pDeviceObject )
        {
            //
            // Close the TDI Address Object to flush all outstanding
            // completions.
            //

            UxCloseTdiObject( &pAddrIdleList->AddressObject );

            //
            // Destroy as many idle connections as possible.
            //

            while ( NULL != ( pConnection = UlpDequeueIdleConnectionToDrain(
                                                pAddrIdleList
                                                ) ) )
            {
                ASSERT( IS_VALID_CONNECTION( pConnection ) );
                UlpDestroyConnection( pConnection );
            }
        }

        pAddrIdleList++;
    }

    DEREFERENCE_ENDPOINT_SELF(
        pListeningEndpoint,
        REF_ACTION_ENDPOINT_EVENT_DEREFERENCE
        );

    //
    // Let UlpDisconnectAllActiveConnections do the dirty work.
    //

    status = UlpDisconnectAllActiveConnections( pListeningEndpoint );

    return status;

}   // UlCloseListeningEndpoint


/***************************************************************************++

Routine Description:

    Closes a previously accepted connection.

Arguments:

    pConnection - Supplies a pointer to a connection as previously
        indicated to the PUL_CONNECTION_REQUEST handler.

    AbortiveDisconnect - Supplies TRUE if the connection is to be abortively
        disconnected, FALSE if it should be gracefully disconnected.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the connection is fully closed.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCloseConnection(
    IN PUL_CONNECTION pConnection,
    IN BOOLEAN AbortiveDisconnect,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    )
{
    NTSTATUS status;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    UlTrace(TDI, (
        "UlCloseConnection: connection %p, abort %lu\n",
        pConnection,
        (ULONG)AbortiveDisconnect
        ));

    WRITE_REF_TRACE_LOG2(
        g_pTdiTraceLog,
        pConnection->pTraceLog,
        (USHORT) (AbortiveDisconnect
                    ? REF_ACTION_CLOSE_UL_CONN_ABORTIVE
                    : REF_ACTION_CLOSE_UL_CONN_GRACEFUL),
        pConnection->ReferenceCount,
        pConnection,
        __FILE__,
        __LINE__
        );

    //
    // We only send graceful disconnects through the filter
    // process. There's also no point in going through the
    // filter if the connection is already being closed or
    // aborted.
    //

    if (pConnection->FilterInfo.pFilterChannel &&
        !pConnection->ConnectionFlags.CleanupBegun &&
        !pConnection->ConnectionFlags.AbortIndicated &&
        !AbortiveDisconnect)
    {
        //
        // Send graceful disconnect through the filter process.
        //
        status = UlFilterCloseHandler(
                        &pConnection->FilterInfo,
                        pCompletionRoutine,
                        pCompletionContext
                        );

    }
    else
    {
        //
        // Really close the connection.
        //

        status = UlpCloseRawConnection(
                        pConnection,
                        AbortiveDisconnect,
                        pCompletionRoutine,
                        pCompletionContext
                        );
    }

    return status;

}   // UlCloseConnection


/***************************************************************************++

Routine Description:

    Sends a block of data on the specified connection. If the connection
    is filtered, the data will be sent to the filter first.

Arguments:

    pConnection - Supplies a pointer to a connection as previously
        indicated to the PUL_CONNECTION_REQUEST handler.

    pMdlChain - Supplies a pointer to a MDL chain describing the
        data buffers to send.

    Length - Supplies the length of the data referenced by the MDL
        chain.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the data is sent.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

    InitiateDisconnect - Supplies TRUE if a graceful disconnect should
        be initiated immediately after initiating the send (i.e. before
        the send actually completes).

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlSendData(
    IN PUL_CONNECTION pConnection,
    IN PMDL pMdlChain,
    IN ULONG Length,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext,
    IN PIRP pOwnIrp,
    IN PUL_IRP_CONTEXT pOwnIrpContext,
    IN BOOLEAN InitiateDisconnect,
    IN BOOLEAN RequestComplete
    )
{
    NTSTATUS Status;
    PUL_IRP_CONTEXT pIrpContext;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    ASSERT( pMdlChain != NULL );
    ASSERT( Length > 0 );
    ASSERT( pCompletionRoutine != NULL );

    UlTrace(TDI, (
        "UlSendData: connection %p, mdl %p, length %lu\n",
        pConnection,
        pMdlChain,
        Length
        ));

    //
    // Connection should be around until we make a call to close connection.
    // Otherwise if the send completes inline, it may free
    // up the connection reference when we enter this function, causing
    // us to reference a stale connection pointer when calling disconnect.
    //

    REFERENCE_CONNECTION( pConnection );

    //
    // Allocate & initialize a context structure if necessary.
    //

    if (pOwnIrpContext == NULL)
    {
        pIrpContext = UlPplAllocateIrpContext();
    }
    else
    {
        ASSERT( pOwnIrp != NULL );
        pIrpContext = pOwnIrpContext;
    }

    if (pIrpContext == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto fatal;
    }

    ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );

    pIrpContext->pConnectionContext = (PVOID) pConnection;
    pIrpContext->pCompletionRoutine = pCompletionRoutine;
    pIrpContext->pCompletionContext = pCompletionContext;
    pIrpContext->pOwnIrp            = pOwnIrp;
    pIrpContext->OwnIrpContext      = (BOOLEAN) (pOwnIrpContext != NULL);

    //
    // Try to send the data.  This send operation may complete inline
    // fast, if the connection has already been aborted by the client
    // In that case connection may gone away. To prevent this we
    // keep additional refcount until we make a call to close connection
    // below.
    //

    if (pConnection->FilterInfo.pFilterChannel)
    {
        //
        // First go through the filter.
        //

        Status = UlFilterSendHandler(
                        &pConnection->FilterInfo,
                        pMdlChain,
                        Length,
                        pIrpContext
                        );

        UlTrace(TDI, (
            "UlSendData: sent filtered data, status = 0x%x\n",
            Status
            ));

        ASSERT( Status == STATUS_PENDING );
    }
    else
    {
        if (RequestComplete &&
            pConnection->AddressType == TDI_ADDRESS_TYPE_IP)
        {
            //
            // Just send it directly to the network.
            //

            Status = UlpSendRawData(
                            pConnection,
                            pMdlChain,
                            Length,
                            pIrpContext,
                            InitiateDisconnect
                            );

            UlTrace(TDI, (
                "UlSendData: sent raw data with disconnect, status = 0x%x\n",
                Status
                ));

            InitiateDisconnect = FALSE;
        }
        else
        {
            //
            // Just send it directly to the network.
            //

            Status = UlpSendRawData(
                            pConnection,
                            pMdlChain,
                            Length,
                            pIrpContext,
                            FALSE
                            );

            UlTrace(TDI, (
                "UlSendData: sent raw data, status = 0x%x\n",
                Status
                ));
        }
    }

    if (!NT_SUCCESS(Status))
    {
        goto fatal;
    }

    //
    // Now that the send is "in flight", initiate a disconnect if
    // so requested.
    //

    if (InitiateDisconnect)
    {
        WRITE_REF_TRACE_LOG2(
                g_pTdiTraceLog,
                pConnection->pTraceLog,
                REF_ACTION_CLOSE_UL_CONN_GRACEFUL,
                pConnection->ReferenceCount,
                pConnection,
                __FILE__,
                __LINE__
                );

        (VOID) UlCloseConnection(
                pConnection,
                FALSE,          // AbortiveDisconnect
                NULL,           // pCompletionRoutine
                NULL            // pCompletionContext
                );

        UlTrace(TDI, (
                "UlSendData: closed conn\n"
                ));
    }

    DEREFERENCE_CONNECTION( pConnection );

    return STATUS_PENDING;

fatal:

    ASSERT( !NT_SUCCESS(Status) );

    if (pIrpContext != NULL && pIrpContext != pOwnIrpContext)
    {
        UlPplFreeIrpContext( pIrpContext );
    }

    (VOID) UlpCloseRawConnection(
                pConnection,
                TRUE,           // AbortiveDisconnect
                NULL,           // pCompletionRoutine
                NULL            // pCompletionContext
                );

    UlTrace(TDI, (
        "UlSendData: error occurred; closed raw conn\n"
        ));

    Status = UlInvokeCompletionRoutine(
                    Status,
                    0,
                    pCompletionRoutine,
                    pCompletionContext
                    );

    UlTrace(TDI, (
        "UlSendData: finished completion routine: status = 0x%x\n",
        Status
        ));

    DEREFERENCE_CONNECTION( pConnection );

    return Status;

}   // UlSendData



/***************************************************************************++

Routine Description:

    Receives data from the specified connection. This function is
    typically used after a receive indication handler has failed to
    consume all of the indicated data.

    If the connection is filtered the data will be read from the
    filter channel.

Arguments:

    pConnection - Supplies a pointer to a connection as previously
        indicated to the PUL_CONNECTION_REQUEST handler.

    pBuffer - Supplies a pointer to the target buffer for the received
        data.

    BufferLength - Supplies the length of pBuffer.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the listening endpoint is fully closed.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlReceiveData(
    IN PVOID                  pConnectionContext,
    IN PVOID                  pBuffer,
    IN ULONG                  BufferLength,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID                  pCompletionContext
    )
{
    NTSTATUS status;
    PUL_CONNECTION pConnection = (PUL_CONNECTION)pConnectionContext;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_CONNECTION(pConnection));

    if (pConnection->FilterInfo.pFilterChannel)
    {
        //
        // This is a filtered connection, get the data from the filter.
        //

        status = UlFilterReadHandler(
                        &pConnection->FilterInfo,
                        (PBYTE)pBuffer,
                        BufferLength,
                        pCompletionRoutine,
     